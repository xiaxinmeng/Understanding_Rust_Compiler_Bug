{"sha": "da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhNTEwYmZiNGEzZjZjYTgwNWU4NDkzNzJmOWJiZTdiMmIwZjZhNjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-13T01:10:49Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-13T01:10:49Z"}, "message": "auto merge of #7086 : huonw/rust/5048, r=graydon\n\nFixes #5048.\r\n\r\nI'm sure this reduces memory usage, but I can't get cgroups to work properly to actually measure memory. (It doesn't appear to offer much speed improvement, but I'm fairly sure it's not slower.)\r\n\r\nThis is quite huge, so it'd be nice to get a resolution soon.", "tree": {"sha": "cb272a50c99d8001304f044fd8a1128d30654b61", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb272a50c99d8001304f044fd8a1128d30654b61"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "html_url": "https://github.com/rust-lang/rust/commit/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "84bed9769b5d15871481b657860ad6a7d0a62f42", "url": "https://api.github.com/repos/rust-lang/rust/commits/84bed9769b5d15871481b657860ad6a7d0a62f42", "html_url": "https://github.com/rust-lang/rust/commit/84bed9769b5d15871481b657860ad6a7d0a62f42"}, {"sha": "5ebffd46d5f7476c8124856c37538088da0c918e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ebffd46d5f7476c8124856c37538088da0c918e", "html_url": "https://github.com/rust-lang/rust/commit/5ebffd46d5f7476c8124856c37538088da0c918e"}], "stats": {"total": 2670, "additions": 1329, "deletions": 1341}, "files": [{"sha": "f4ddcb72c9c4b554918385f5c8e50f874182071d", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -345,13 +345,13 @@ pub fn check_variants_T<T:Copy>(crate: @ast::crate,\n                                             intr,\n                                             span_handler,\n                                             crate2,\n-                                            fname.to_str(),\n+                                            fname.to_managed(),\n                                             rdr,\n                                             a,\n                                             pprust::no_ann(),\n                                             false)\n                     };\n-                    @string\n+                    string.to_managed()\n                 };\n                 match cx.mode {\n                     tm_converge => check_roundtrip_convergence(str3, 1),\n@@ -361,9 +361,9 @@ pub fn check_variants_T<T:Copy>(crate: @ast::crate,\n                                               thing_label,\n                                               i,\n                                               j);\n-                        let safe_to_run = !(content_is_dangerous_to_run(*str3)\n+                        let safe_to_run = !(content_is_dangerous_to_run(str3)\n                                             || has_raw_pointers(crate2));\n-                        check_whole_compiler(*str3,\n+                        check_whole_compiler(str3,\n                                              &Path(file_label),\n                                              safe_to_run);\n                     }\n@@ -502,28 +502,28 @@ pub fn check_compiling(filename: &Path) -> happiness {\n }\n \n \n-pub fn parse_and_print(code: @~str) -> ~str {\n+pub fn parse_and_print(code: @str) -> @str {\n     let filename = Path(\"tmp.rs\");\n     let sess = parse::new_parse_sess(option::None);\n-    write_file(&filename, *code);\n-    let crate = parse::parse_crate_from_source_str(filename.to_str(),\n+    write_file(&filename, code);\n+    let crate = parse::parse_crate_from_source_str(filename.to_str().to_managed(),\n                                                    code,\n                                                    ~[],\n                                                    sess);\n-    do io::with_str_reader(*code) |rdr| {\n+    do io::with_str_reader(code) |rdr| {\n         let filename = filename.to_str();\n         do as_str |a| {\n             pprust::print_crate(sess.cm,\n                                 // Assuming there are no token_trees\n                                 token::mk_fake_ident_interner(),\n                                 copy sess.span_diagnostic,\n                                 crate,\n-                                filename.to_str(),\n+                                filename.to_managed(),\n                                 rdr,\n                                 a,\n                                 pprust::no_ann(),\n                                 false)\n-        }\n+        }.to_managed()\n     }\n }\n \n@@ -598,15 +598,15 @@ pub fn file_might_not_converge(filename: &Path) -> bool {\n     return false;\n }\n \n-pub fn check_roundtrip_convergence(code: @~str, maxIters: uint) {\n+pub fn check_roundtrip_convergence(code: @str, maxIters: uint) {\n     let mut i = 0u;\n     let mut newv = code;\n     let mut oldv = code;\n \n     while i < maxIters {\n         oldv = newv;\n-        if content_might_not_converge(*oldv) { return; }\n-        newv = @parse_and_print(oldv);\n+        if content_might_not_converge(oldv) { return; }\n+        newv = parse_and_print(oldv);\n         if oldv == newv { break; }\n         i += 1u;\n     }\n@@ -615,8 +615,8 @@ pub fn check_roundtrip_convergence(code: @~str, maxIters: uint) {\n         error!(\"Converged after %u iterations\", i);\n     } else {\n         error!(\"Did not converge after %u iterations!\", i);\n-        write_file(&Path(\"round-trip-a.rs\"), *oldv);\n-        write_file(&Path(\"round-trip-b.rs\"), *newv);\n+        write_file(&Path(\"round-trip-a.rs\"), oldv);\n+        write_file(&Path(\"round-trip-b.rs\"), newv);\n         run::process_status(\"diff\", [~\"-w\", ~\"-u\", ~\"round-trip-a.rs\", ~\"round-trip-b.rs\"]);\n         fail!(\"Mismatch\");\n     }\n@@ -626,8 +626,8 @@ pub fn check_convergence(files: &[Path]) {\n     error!(\"pp convergence tests: %u files\", files.len());\n     for files.each |file| {\n         if !file_might_not_converge(file) {\n-            let s = @result::get(&io::read_whole_file_str(file));\n-            if !content_might_not_converge(*s) {\n+            let s = result::get(&io::read_whole_file_str(file)).to_managed();\n+            if !content_might_not_converge(s) {\n                 error!(\"pp converge: %s\", file.to_str());\n                 // Change from 7u to 2u once\n                 // https://github.com/mozilla/rust/issues/850 is fixed\n@@ -646,26 +646,26 @@ pub fn check_variants(files: &[Path], cx: Context) {\n             loop;\n         }\n \n-        let s = @result::get(&io::read_whole_file_str(file));\n-        if contains(*s, \"#\") {\n+        let s = result::get(&io::read_whole_file_str(file)).to_managed();\n+        if s.contains_char('#') {\n             loop; // Macros are confusing\n         }\n-        if cx.mode == tm_converge && content_might_not_converge(*s) {\n+        if cx.mode == tm_converge && content_might_not_converge(s) {\n             loop;\n         }\n-        if cx.mode == tm_run && content_is_dangerous_to_compile(*s) {\n+        if cx.mode == tm_run && content_is_dangerous_to_compile(s) {\n             loop;\n         }\n \n         let file_str = file.to_str();\n \n         error!(\"check_variants: %?\", file_str);\n         let sess = parse::new_parse_sess(None);\n-        let crate = parse::parse_crate_from_source_str(file_str.to_str(),\n+        let crate = parse::parse_crate_from_source_str(file_str.to_managed(),\n                                                        s,\n                                                        ~[],\n                                                        sess);\n-        io::with_str_reader(*s, |rdr| {\n+        io::with_str_reader(s, |rdr| {\n             let file_str = file_str.to_str();\n             error!(\"%s\",\n                    as_str(|a| {\n@@ -675,7 +675,7 @@ pub fn check_variants(files: &[Path], cx: Context) {\n                         token::mk_fake_ident_interner(),\n                         copy sess.span_diagnostic,\n                         crate,\n-                        file_str.to_str(),\n+                        file_str.to_managed(),\n                         rdr,\n                         a,\n                         pprust::no_ann(),"}, {"sha": "3934e946141704da8913a43cf6f89e8e72c1c0f4", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -493,16 +493,16 @@ pub fn build_link_meta(sess: Session,\n         let linkage_metas = attr::find_linkage_metas(c.node.attrs);\n         attr::require_unique_names(sess.diagnostic(), linkage_metas);\n         for linkage_metas.each |meta| {\n-            if *attr::get_meta_item_name(*meta) == ~\"name\" {\n+            if \"name\" == attr::get_meta_item_name(*meta) {\n                 match attr::get_meta_item_value_str(*meta) {\n                   // Changing attr would avoid the need for the copy\n                   // here\n-                  Some(v) => { name = Some(v.to_managed()); }\n+                  Some(v) => { name = Some(v); }\n                   None => cmh_items.push(*meta)\n                 }\n-            } else if *attr::get_meta_item_name(*meta) == ~\"vers\" {\n+            } else if \"vers\" == attr::get_meta_item_name(*meta) {\n                 match attr::get_meta_item_value_str(*meta) {\n-                  Some(v) => { vers = Some(v.to_managed()); }\n+                  Some(v) => { vers = Some(v); }\n                   None => cmh_items.push(*meta)\n                 }\n             } else { cmh_items.push(*meta); }\n@@ -518,7 +518,7 @@ pub fn build_link_meta(sess: Session,\n     // This calculates CMH as defined above\n     fn crate_meta_extras_hash(symbol_hasher: &mut hash::State,\n                               cmh_items: ~[@ast::meta_item],\n-                              dep_hashes: ~[~str]) -> @str {\n+                              dep_hashes: ~[@str]) -> @str {\n         fn len_and_str(s: &str) -> ~str {\n             fmt!(\"%u_%s\", s.len(), s)\n         }\n@@ -532,14 +532,14 @@ pub fn build_link_meta(sess: Session,\n         fn hash(symbol_hasher: &mut hash::State, m: &@ast::meta_item) {\n             match m.node {\n               ast::meta_name_value(key, value) => {\n-                write_string(symbol_hasher, len_and_str(*key));\n+                write_string(symbol_hasher, len_and_str(key));\n                 write_string(symbol_hasher, len_and_str_lit(value));\n               }\n               ast::meta_word(name) => {\n-                write_string(symbol_hasher, len_and_str(*name));\n+                write_string(symbol_hasher, len_and_str(name));\n               }\n               ast::meta_list(name, ref mis) => {\n-                write_string(symbol_hasher, len_and_str(*name));\n+                write_string(symbol_hasher, len_and_str(name));\n                 for mis.each |m_| {\n                     hash(symbol_hasher, m_);\n                 }\n@@ -706,7 +706,7 @@ pub fn mangle(sess: Session, ss: path) -> ~str {\n \n     for ss.each |s| {\n         match *s { path_name(s) | path_mod(s) => {\n-          let sani = sanitize(*sess.str_of(s));\n+          let sani = sanitize(sess.str_of(s));\n           n += fmt!(\"%u%s\", sani.len(), sani);\n         } }\n     }\n@@ -912,7 +912,7 @@ pub fn link_args(sess: Session,\n     }\n \n     let ula = cstore::get_used_link_args(cstore);\n-    for ula.each |arg| { args.push(/*bad*/copy *arg); }\n+    for ula.each |arg| { args.push(arg.to_owned()); }\n \n     // Add all the link args for external crates.\n     do cstore::iter_crate_data(cstore) |crate_num, _| {"}, {"sha": "0447481596aef547af629af167c39064c40218a2", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -55,31 +55,31 @@ pub enum pp_mode {\n  * The name used for source code that doesn't originate in a file\n  * (e.g. source from stdin or a string)\n  */\n-pub fn anon_src() -> ~str { ~\"<anon>\" }\n+pub fn anon_src() -> @str { @\"<anon>\" }\n \n-pub fn source_name(input: &input) -> ~str {\n+pub fn source_name(input: &input) -> @str {\n     match *input {\n-      file_input(ref ifile) => ifile.to_str(),\n+      file_input(ref ifile) => ifile.to_str().to_managed(),\n       str_input(_) => anon_src()\n     }\n }\n \n-pub fn default_configuration(sess: Session, argv0: @~str, input: &input) ->\n+pub fn default_configuration(sess: Session, argv0: @str, input: &input) ->\n    ast::crate_cfg {\n     let libc = match sess.targ_cfg.os {\n-      session::os_win32 => ~\"msvcrt.dll\",\n-      session::os_macos => ~\"libc.dylib\",\n-      session::os_linux => ~\"libc.so.6\",\n-      session::os_android => ~\"libc.so\",\n-      session::os_freebsd => ~\"libc.so.7\"\n+      session::os_win32 => @\"msvcrt.dll\",\n+      session::os_macos => @\"libc.dylib\",\n+      session::os_linux => @\"libc.so.6\",\n+      session::os_android => @\"libc.so\",\n+      session::os_freebsd => @\"libc.so.7\"\n       // _ { \"libc.so\" }\n     };\n     let tos = match sess.targ_cfg.os {\n-      session::os_win32 => ~\"win32\",\n-      session::os_macos => ~\"macos\",\n-      session::os_linux => ~\"linux\",\n-      session::os_android => ~\"android\",\n-      session::os_freebsd => ~\"freebsd\"\n+      session::os_win32 => @\"win32\",\n+      session::os_macos => @\"macos\",\n+      session::os_linux => @\"linux\",\n+      session::os_android => @\"android\",\n+      session::os_freebsd => @\"freebsd\"\n       // _ { \"libc.so\" }\n     };\n \n@@ -88,47 +88,47 @@ pub fn default_configuration(sess: Session, argv0: @~str, input: &input) ->\n     // ARM is bi-endian, however using NDK seems to default\n     // to little-endian unless a flag is provided.\n     let (end,arch,wordsz) = match sess.targ_cfg.arch {\n-        abi::X86 => (~\"little\",~\"x86\",~\"32\"),\n-        abi::X86_64 => (~\"little\",~\"x86_64\",~\"64\"),\n-        abi::Arm => (~\"little\",~\"arm\",~\"32\"),\n-        abi::Mips => (~\"big\",~\"mips\",~\"32\")\n+        abi::X86 => (@\"little\",@\"x86\",@\"32\"),\n+        abi::X86_64 => (@\"little\",@\"x86_64\",@\"64\"),\n+        abi::Arm => (@\"little\",@\"arm\",@\"32\"),\n+        abi::Mips => (@\"big\",@\"mips\",@\"32\")\n     };\n \n     return ~[ // Target bindings.\n-         attr::mk_word_item(@os::FAMILY.to_owned()),\n-         mk(@~\"target_os\", @tos),\n-         mk(@~\"target_family\", @os::FAMILY.to_owned()),\n-         mk(@~\"target_arch\", @arch),\n-         mk(@~\"target_endian\", @end),\n-         mk(@~\"target_word_size\", @wordsz),\n-         mk(@~\"target_libc\", @libc),\n+         attr::mk_word_item(os::FAMILY.to_managed()),\n+         mk(@\"target_os\", tos),\n+         mk(@\"target_family\", os::FAMILY.to_managed()),\n+         mk(@\"target_arch\", arch),\n+         mk(@\"target_endian\", end),\n+         mk(@\"target_word_size\", wordsz),\n+         mk(@\"target_libc\", libc),\n          // Build bindings.\n-         mk(@~\"build_compiler\", argv0),\n-         mk(@~\"build_input\", @source_name(input))];\n+         mk(@\"build_compiler\", argv0),\n+         mk(@\"build_input\", source_name(input))];\n }\n \n-pub fn append_configuration(cfg: ast::crate_cfg, name: ~str)\n+pub fn append_configuration(cfg: ast::crate_cfg, name: @str)\n                          -> ast::crate_cfg {\n     if attr::contains_name(cfg, name) {\n         cfg\n     } else {\n-        vec::append_one(cfg, attr::mk_word_item(@name))\n+        vec::append_one(cfg, attr::mk_word_item(name))\n     }\n }\n \n-pub fn build_configuration(sess: Session, argv0: @~str, input: &input) ->\n+pub fn build_configuration(sess: Session, argv0: @str, input: &input) ->\n    ast::crate_cfg {\n     // Combine the configuration requested by the session (command line) with\n     // some default and generated configuration items\n     let default_cfg = default_configuration(sess, argv0, input);\n     let user_cfg = /*bad*/copy sess.opts.cfg;\n     // If the user wants a test runner, then add the test cfg\n-    let user_cfg = if sess.opts.test { append_configuration(user_cfg, ~\"test\") }\n+    let user_cfg = if sess.opts.test { append_configuration(user_cfg, @\"test\") }\n                    else { user_cfg };\n     // If the user requested GC, then add the GC cfg\n     let user_cfg = append_configuration(\n         user_cfg,\n-        if sess.opts.gc { ~\"gc\" } else { ~\"nogc\" });\n+        if sess.opts.gc { @\"gc\" } else { @\"nogc\" });\n     return vec::append(user_cfg, default_cfg);\n }\n \n@@ -137,15 +137,16 @@ fn parse_cfgspecs(cfgspecs: ~[~str],\n                   demitter: diagnostic::Emitter) -> ast::crate_cfg {\n     do vec::map_consume(cfgspecs) |s| {\n         let sess = parse::new_parse_sess(Some(demitter));\n-        parse::parse_meta_from_source_str(~\"cfgspec\", @s, ~[], sess)\n+        parse::parse_meta_from_source_str(@\"cfgspec\", s.to_managed(), ~[], sess)\n     }\n }\n \n pub enum input {\n     /// Load source from file\n     file_input(Path),\n     /// The string is the source\n-    str_input(~str)\n+    // FIXME (#2319): Don't really want to box the source string\n+    str_input(@str)\n }\n \n pub fn parse_input(sess: Session, cfg: ast::crate_cfg, input: &input)\n@@ -154,10 +155,9 @@ pub fn parse_input(sess: Session, cfg: ast::crate_cfg, input: &input)\n       file_input(ref file) => {\n         parse::parse_crate_from_file(&(*file), cfg, sess.parse_sess)\n       }\n-      str_input(ref src) => {\n-        // FIXME (#2319): Don't really want to box the source string\n+      str_input(src) => {\n         parse::parse_crate_from_source_str(\n-            anon_src(), @(/*bad*/copy *src), cfg, sess.parse_sess)\n+            anon_src(), src, cfg, sess.parse_sess)\n       }\n     }\n }\n@@ -455,7 +455,7 @@ pub fn pretty_print_input(sess: Session, cfg: ast::crate_cfg, input: &input,\n     };\n     let is_expanded = upto != cu_parse;\n     let src = sess.codemap.get_filemap(source_name(input)).src;\n-    do io::with_str_reader(*src) |rdr| {\n+    do io::with_str_reader(src) |rdr| {\n         pprust::print_crate(sess.codemap, token::get_ident_interner(),\n                             sess.span_diagnostic, crate.unwrap(),\n                             source_name(input),\n@@ -566,7 +566,7 @@ pub fn host_triple() -> ~str {\n         };\n }\n \n-pub fn build_session_options(binary: @~str,\n+pub fn build_session_options(binary: @str,\n                              matches: &getopts::Matches,\n                              demitter: diagnostic::Emitter)\n                           -> @session::options {\n@@ -595,7 +595,7 @@ pub fn build_session_options(binary: @~str,\n                                 getopts::opt_strs(matches, level_name));\n         for flags.each |lint_name| {\n             let lint_name = lint_name.replace(\"-\", \"_\");\n-            match lint_dict.find(&lint_name) {\n+            match lint_dict.find_equiv(&lint_name) {\n               None => {\n                 early_error(demitter, fmt!(\"unknown %s flag: %s\",\n                                            level_name, lint_name));\n@@ -895,8 +895,8 @@ pub fn build_output_filenames(input: &input,\n           };\n \n           let mut stem = match *input {\n-              file_input(ref ifile) => (*ifile).filestem().get(),\n-              str_input(_) => ~\"rust_out\"\n+              file_input(ref ifile) => (*ifile).filestem().get().to_managed(),\n+              str_input(_) => @\"rust_out\"\n           };\n \n           // If a linkage name meta is present, we use it as the link name\n@@ -906,7 +906,7 @@ pub fn build_output_filenames(input: &input,\n               let maybe_matches = attr::find_meta_items_by_name(linkage_metas, \"name\");\n               if !maybe_matches.is_empty() {\n                   match attr::get_meta_item_value_str(maybe_matches[0]) {\n-                      Some(s) => stem = copy *s,\n+                      Some(s) => stem = s,\n                       _ => ()\n                   }\n               }\n@@ -982,9 +982,9 @@ mod test {\n               Err(f) => fail!(\"test_switch_implies_cfg_test: %s\", getopts::fail_str(f))\n             };\n         let sessopts = build_session_options(\n-            @~\"rustc\", matches, diagnostic::emit);\n+            @\"rustc\", matches, diagnostic::emit);\n         let sess = build_session(sessopts, diagnostic::emit);\n-        let cfg = build_configuration(sess, @~\"whatever\", &str_input(~\"\"));\n+        let cfg = build_configuration(sess, @\"whatever\", &str_input(@\"\"));\n         assert!((attr::contains_name(cfg, \"test\")));\n     }\n \n@@ -1000,9 +1000,9 @@ mod test {\n               }\n             };\n         let sessopts = build_session_options(\n-            @~\"rustc\", matches, diagnostic::emit);\n+            @\"rustc\", matches, diagnostic::emit);\n         let sess = build_session(sessopts, diagnostic::emit);\n-        let cfg = build_configuration(sess, @~\"whatever\", &str_input(~\"\"));\n+        let cfg = build_configuration(sess, @\"whatever\", &str_input(@\"\"));\n         let test_items = attr::find_meta_items_by_name(cfg, \"test\");\n         assert_eq!(test_items.len(), 1u);\n     }"}, {"sha": "73e8cfea8ca20821ca8ee70ee8fc7cf7c97b8cd4", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -150,7 +150,7 @@ pub struct options {\n     // will be added to the crate AST node.  This should not be used for\n     // anything except building the full crate config prior to parsing.\n     cfg: ast::crate_cfg,\n-    binary: @~str,\n+    binary: @str,\n     test: bool,\n     parse_only: bool,\n     no_trans: bool,\n@@ -295,7 +295,7 @@ impl Session_ {\n     }\n \n     // pointless function, now...\n-    pub fn str_of(@self, id: ast::ident) -> @~str {\n+    pub fn str_of(@self, id: ast::ident) -> @str {\n         token::ident_to_str(&id)\n     }\n \n@@ -331,7 +331,7 @@ pub fn basic_options() -> @options {\n         target_triple: host_triple(),\n         target_feature: ~\"\",\n         cfg: ~[],\n-        binary: @~\"rustc\",\n+        binary: @\"rustc\",\n         test: false,\n         parse_only: false,\n         no_trans: false,\n@@ -361,7 +361,7 @@ pub fn building_library(req_crate_type: crate_type,\n             match syntax::attr::first_attr_value_str_by_name(\n                 crate.node.attrs,\n                 \"crate_type\") {\n-              Some(@~\"lib\") => true,\n+              Some(s) if \"lib\" == s => true,\n               _ => false\n             }\n         }\n@@ -389,22 +389,22 @@ mod test {\n     use syntax::ast;\n     use syntax::codemap;\n \n-    fn make_crate_type_attr(t: ~str) -> ast::attribute {\n+    fn make_crate_type_attr(t: @str) -> ast::attribute {\n         codemap::respan(codemap::dummy_sp(), ast::attribute_ {\n             style: ast::attr_outer,\n             value: @codemap::respan(codemap::dummy_sp(),\n                 ast::meta_name_value(\n-                    @~\"crate_type\",\n+                    @\"crate_type\",\n                     codemap::respan(codemap::dummy_sp(),\n-                                     ast::lit_str(@t)))),\n+                                     ast::lit_str(t)))),\n             is_sugared_doc: false\n         })\n     }\n \n     fn make_crate(with_bin: bool, with_lib: bool) -> @ast::crate {\n         let mut attrs = ~[];\n-        if with_bin { attrs += [make_crate_type_attr(~\"bin\")]; }\n-        if with_lib { attrs += [make_crate_type_attr(~\"lib\")]; }\n+        if with_bin { attrs += [make_crate_type_attr(@\"bin\")]; }\n+        if with_lib { attrs += [make_crate_type_attr(@\"lib\")]; }\n         @codemap::respan(codemap::dummy_sp(), ast::crate_ {\n             module: ast::_mod { view_items: ~[], items: ~[] },\n             attrs: attrs,"}, {"sha": "3e6ac283da0a55ec7fc7e47fa41eb049348af2fa", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -202,7 +202,7 @@ pub fn metas_in_cfg(cfg: ast::crate_cfg,\n     cfg_metas.any(|cfg_meta| {\n         cfg_meta.all(|cfg_mi| {\n             match cfg_mi.node {\n-                ast::meta_list(s, ref it) if *s == ~\"not\"\n+                ast::meta_list(s, ref it) if \"not\" == s\n                     => it.all(|mi| !attr::contains(cfg, *mi)),\n                 _ => attr::contains(cfg, *cfg_mi)\n             }"}, {"sha": "0caadc8572e90cf545744b9e2af78d3cdcacd173", "filename": "src/librustc/front/intrinsic_inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fintrinsic_inject.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -17,9 +17,9 @@ use syntax::ast;\n use syntax::codemap::spanned;\n \n pub fn inject_intrinsic(sess: Session, crate: @ast::crate) -> @ast::crate {\n-    let intrinsic_module = @(include_str!(\"intrinsic.rs\").to_owned());\n+    let intrinsic_module = include_str!(\"intrinsic.rs\").to_managed();\n \n-    let item = parse::parse_item_from_source_str(~\"<intrinsic>\",\n+    let item = parse::parse_item_from_source_str(@\"<intrinsic>\",\n                                                  intrinsic_module,\n                                                  /*bad*/copy sess.opts.cfg,\n                                                  ~[],"}, {"sha": "38a21af65b93f83023c6ff6b3a458592cede8554", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -49,8 +49,8 @@ fn inject_libstd_ref(sess: Session, crate: @ast::crate) -> @ast::crate {\n                     spanned(ast::attribute_ {\n                         style: ast::attr_inner,\n                         value: @spanned(ast::meta_name_value(\n-                            @~\"vers\",\n-                            spanned(ast::lit_str(@STD_VERSION.to_str()))\n+                            @\"vers\",\n+                            spanned(ast::lit_str(STD_VERSION.to_managed()))\n                         )),\n                         is_sugared_doc: false\n                     })"}, {"sha": "de6fc322c6372390b3cc887a76c53ac6bb0370b5", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -52,7 +52,7 @@ pub fn modify_for_testing(sess: session::Session,\n     // configuration, either with the '--test' or '--cfg test'\n     // command line options.\n     let should_test = attr::contains(crate.node.config,\n-                                     attr::mk_word_item(@~\"test\"));\n+                                     attr::mk_word_item(@\"test\"));\n \n     if should_test {\n         generate_test_harness(sess, crate)\n@@ -76,7 +76,7 @@ fn generate_test_harness(sess: session::Session,\n     ext_cx.bt_push(ExpandedFrom(CallInfo {\n         call_site: dummy_sp(),\n         callee: NameAndSpan {\n-            name: ~\"test\",\n+            name: @\"test\",\n             span: None\n         }\n     }));\n@@ -111,7 +111,7 @@ fn fold_mod(cx: @mut TestCtxt,\n     fn nomain(cx: @mut TestCtxt, item: @ast::item) -> @ast::item {\n         if !*cx.sess.building_library {\n             @ast::item{attrs: item.attrs.filtered(|attr| {\n-                               *attr::get_attr_name(attr) != ~\"main\"\n+                               \"main\" != attr::get_attr_name(attr)\n                            }),.. copy *item}\n         } else { item }\n     }\n@@ -272,9 +272,9 @@ mod __test {\n */\n \n fn mk_std(cx: &TestCtxt) -> @ast::view_item {\n-    let vers = ast::lit_str(@~\"0.7-pre\");\n+    let vers = ast::lit_str(@\"0.7-pre\");\n     let vers = nospan(vers);\n-    let mi = ast::meta_name_value(@~\"vers\", vers);\n+    let mi = ast::meta_name_value(@\"vers\", vers);\n     let mi = nospan(mi);\n     let id_std = cx.sess.ident_of(\"extra\");\n     let vi = if is_std(cx) {\n@@ -321,7 +321,7 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::item {\n \n     // This attribute tells resolve to let us call unexported functions\n     let resolve_unexported_attr =\n-        attr::mk_attr(attr::mk_word_item(@~\"!resolve_unexported\"));\n+        attr::mk_attr(attr::mk_word_item(@\"!resolve_unexported\"));\n \n     let item = ast::item {\n         ident: cx.sess.ident_of(\"__test\"),\n@@ -376,7 +376,7 @@ fn is_std(cx: &TestCtxt) -> bool {\n     let is_std = {\n         let items = attr::find_linkage_metas(cx.crate.node.attrs);\n         match attr::last_meta_item_value_str_by_name(items, \"name\") {\n-          Some(@~\"extra\") => true,\n+          Some(s) if \"extra\" == s => true,\n           _ => false\n         }\n     };\n@@ -413,7 +413,7 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::expr {\n     debug!(\"encoding %s\", ast_util::path_name_i(path));\n \n     let name_lit: ast::lit =\n-        nospan(ast::lit_str(@ast_util::path_name_i(path)));\n+        nospan(ast::lit_str(ast_util::path_name_i(path).to_managed()));\n \n     let name_expr = @ast::expr {\n           id: cx.sess.next_node_id(),"}, {"sha": "e95c841b9f783077ed2a27ac2fdbb99f53216052", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -60,7 +60,7 @@ pub fn read_crates(diag: @span_handler,\n struct cache_entry {\n     cnum: int,\n     span: span,\n-    hash: @~str,\n+    hash: @str,\n     metas: @~[@ast::meta_item]\n }\n \n@@ -100,12 +100,12 @@ fn warn_if_multiple_versions(e: @mut Env,\n \n         if matches.len() != 1u {\n             diag.handler().warn(\n-                fmt!(\"using multiple versions of crate `%s`\", *name));\n+                fmt!(\"using multiple versions of crate `%s`\", name));\n             for matches.each |match_| {\n                 diag.span_note(match_.span, \"used here\");\n                 let attrs = ~[\n                     attr::mk_attr(attr::mk_list_item(\n-                        @~\"link\", /*bad*/copy *match_.metas))\n+                        @\"link\", /*bad*/copy *match_.metas))\n                 ];\n                 loader::note_linkage_attrs(e.intr, diag, attrs);\n             }\n@@ -133,7 +133,7 @@ fn visit_crate(e: @mut Env, c: &ast::crate) {\n     for link_args.each |a| {\n         match attr::get_meta_item_value_str(attr::attr_meta(*a)) {\n           Some(ref linkarg) => {\n-            cstore::add_used_link_args(cstore, **linkarg);\n+            cstore::add_used_link_args(cstore, *linkarg);\n           }\n           None => {/* fallthrough */ }\n         }\n@@ -145,7 +145,7 @@ fn visit_view_item(e: @mut Env, i: @ast::view_item) {\n       ast::view_item_extern_mod(ident, ref meta_items, id) => {\n         debug!(\"resolving extern mod stmt. ident: %?, meta: %?\",\n                ident, *meta_items);\n-        let cnum = resolve_crate(e, ident, copy *meta_items, @~\"\", i.span);\n+        let cnum = resolve_crate(e, ident, copy *meta_items, @\"\", i.span);\n         cstore::add_extern_mod_stmt_cnum(e.cstore, id, cnum);\n       }\n       _ => ()\n@@ -169,7 +169,7 @@ fn visit_item(e: @mut Env, i: @ast::item) {\n                     match attr::first_attr_value_str_by_name(i.attrs,\n                                                              \"link_name\") {\n                         Some(nn) => {\n-                            if *nn == ~\"\" {\n+                            if nn.is_empty() {\n                                 e.diag.span_fatal(\n                                     i.span,\n                                     \"empty #[link_name] not allowed; use \\\n@@ -184,7 +184,7 @@ fn visit_item(e: @mut Env, i: @ast::item) {\n                         !cstore::add_used_library(cstore, foreign_name);\n                 }\n                 if !link_args.is_empty() && already_added {\n-                    e.diag.span_fatal(i.span, ~\"library '\" + *foreign_name +\n+                    e.diag.span_fatal(i.span, ~\"library '\" + foreign_name +\n                                \"' already added: can't specify link_args.\");\n                 }\n             }\n@@ -194,7 +194,7 @@ fn visit_item(e: @mut Env, i: @ast::item) {\n         for link_args.each |a| {\n             match attr::get_meta_item_value_str(attr::attr_meta(*a)) {\n                 Some(linkarg) => {\n-                    cstore::add_used_link_args(cstore, *linkarg);\n+                    cstore::add_used_link_args(cstore, linkarg);\n                 }\n                 None => { /* fallthrough */ }\n             }\n@@ -204,22 +204,22 @@ fn visit_item(e: @mut Env, i: @ast::item) {\n     }\n }\n \n-fn metas_with(ident: @~str, key: @~str, metas: ~[@ast::meta_item])\n+fn metas_with(ident: @str, key: @str, metas: ~[@ast::meta_item])\n     -> ~[@ast::meta_item] {\n-    let name_items = attr::find_meta_items_by_name(metas, *key);\n+    let name_items = attr::find_meta_items_by_name(metas, key);\n     if name_items.is_empty() {\n         vec::append_one(metas, attr::mk_name_value_item_str(key, ident))\n     } else {\n         metas\n     }\n }\n \n-fn metas_with_ident(ident: @~str, metas: ~[@ast::meta_item])\n+fn metas_with_ident(ident: @str, metas: ~[@ast::meta_item])\n     -> ~[@ast::meta_item] {\n-    metas_with(ident, @~\"name\", metas)\n+    metas_with(ident, @\"name\", metas)\n }\n \n-fn existing_match(e: @mut Env, metas: &[@ast::meta_item], hash: @~str)\n+fn existing_match(e: @mut Env, metas: &[@ast::meta_item], hash: @str)\n                -> Option<int> {\n     for e.crate_cache.each |c| {\n         if loader::metadata_matches(*c.metas, metas)\n@@ -233,7 +233,7 @@ fn existing_match(e: @mut Env, metas: &[@ast::meta_item], hash: @~str)\n fn resolve_crate(e: @mut Env,\n                  ident: ast::ident,\n                  metas: ~[@ast::meta_item],\n-                 hash: @~str,\n+                 hash: @str,\n                  span: span)\n               -> ast::crate_num {\n     let metas = metas_with_ident(token::ident_to_str(&ident), metas);\n@@ -307,9 +307,9 @@ fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n         let extrn_cnum = dep.cnum;\n         let cname = dep.name;\n         let cname_str = token::ident_to_str(&dep.name);\n-        let cmetas = metas_with(dep.vers, @~\"vers\", ~[]);\n+        let cmetas = metas_with(dep.vers, @\"vers\", ~[]);\n         debug!(\"resolving dep crate %s ver: %s hash: %s\",\n-               *cname_str, *dep.vers, *dep.hash);\n+               cname_str, dep.vers, dep.hash);\n         match existing_match(e, metas_with_ident(cname_str,\n                                                  copy cmetas),\n                              dep.hash) {"}, {"sha": "5b154f6836c281e375ee0f8fdeb7df2622878d31", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -74,7 +74,7 @@ pub fn get_item_path(tcx: ty::ctxt, def: ast::def_id) -> ast_map::path {\n     // FIXME #1920: This path is not always correct if the crate is not linked\n     // into the root namespace.\n     vec::append(~[ast_map::path_mod(tcx.sess.ident_of(\n-        *cdata.name))], path)\n+        cdata.name))], path)\n }\n \n pub enum found_ast {"}, {"sha": "71061d9154087cd37fa98934e68db93e3ff8d5d3", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -31,7 +31,7 @@ use syntax::parse::token::ident_interner;\n pub type cnum_map = @mut HashMap<ast::crate_num, ast::crate_num>;\n \n pub struct crate_metadata {\n-    name: @~str,\n+    name: @str,\n     data: @~[u8],\n     cnum_map: cnum_map,\n     cnum: ast::crate_num\n@@ -41,8 +41,8 @@ pub struct CStore {\n     priv metas: HashMap <ast::crate_num, @crate_metadata>,\n     priv extern_mod_crate_map: extern_mod_crate_map,\n     priv used_crate_files: ~[Path],\n-    priv used_libraries: ~[~str],\n-    priv used_link_args: ~[~str],\n+    priv used_libraries: ~[@str],\n+    priv used_link_args: ~[@str],\n     intr: @ident_interner\n }\n \n@@ -65,12 +65,12 @@ pub fn get_crate_data(cstore: &CStore, cnum: ast::crate_num)\n     return *cstore.metas.get(&cnum);\n }\n \n-pub fn get_crate_hash(cstore: &CStore, cnum: ast::crate_num) -> @~str {\n+pub fn get_crate_hash(cstore: &CStore, cnum: ast::crate_num) -> @str {\n     let cdata = get_crate_data(cstore, cnum);\n     decoder::get_crate_hash(cdata.data)\n }\n \n-pub fn get_crate_vers(cstore: &CStore, cnum: ast::crate_num) -> @~str {\n+pub fn get_crate_vers(cstore: &CStore, cnum: ast::crate_num) -> @str {\n     let cdata = get_crate_data(cstore, cnum);\n     decoder::get_crate_vers(cdata.data)\n }\n@@ -102,26 +102,28 @@ pub fn get_used_crate_files(cstore: &CStore) -> ~[Path] {\n     return /*bad*/copy cstore.used_crate_files;\n }\n \n-pub fn add_used_library(cstore: &mut CStore, lib: @~str) -> bool {\n-    assert!(*lib != ~\"\");\n+pub fn add_used_library(cstore: &mut CStore, lib: @str) -> bool {\n+    assert!(!lib.is_empty());\n \n-    if cstore.used_libraries.contains(&*lib) { return false; }\n-    cstore.used_libraries.push(/*bad*/ copy *lib);\n+    if cstore.used_libraries.contains(&lib) { return false; }\n+    cstore.used_libraries.push(lib);\n     true\n }\n \n-pub fn get_used_libraries(cstore: &CStore) -> ~[~str] {\n-    /*bad*/copy cstore.used_libraries\n+pub fn get_used_libraries<'a>(cstore: &'a CStore) -> &'a [@str] {\n+    let slice: &'a [@str] = cstore.used_libraries;\n+    slice\n }\n \n pub fn add_used_link_args(cstore: &mut CStore, args: &str) {\n     for args.split_iter(' ').advance |s| {\n-        cstore.used_link_args.push(s.to_owned());\n+        cstore.used_link_args.push(s.to_managed());\n     }\n }\n \n-pub fn get_used_link_args(cstore: &CStore) -> ~[~str] {\n-    /*bad*/copy cstore.used_link_args\n+pub fn get_used_link_args<'a>(cstore: &'a CStore) -> &'a [@str] {\n+    let slice: &'a [@str] = cstore.used_link_args;\n+    slice\n }\n \n pub fn add_extern_mod_stmt_cnum(cstore: &mut CStore,\n@@ -138,15 +140,15 @@ pub fn find_extern_mod_stmt_cnum(cstore: &CStore,\n \n // returns hashes of crates directly used by this crate. Hashes are sorted by\n // (crate name, crate version, crate hash) in lexicographic order (not semver)\n-pub fn get_dep_hashes(cstore: &CStore) -> ~[~str] {\n-    struct crate_hash { name: @~str, vers: @~str, hash: @~str }\n+pub fn get_dep_hashes(cstore: &CStore) -> ~[@str] {\n+    struct crate_hash { name: @str, vers: @str, hash: @str }\n     let mut result = ~[];\n \n     for cstore.extern_mod_crate_map.each_value |&cnum| {\n         let cdata = cstore::get_crate_data(cstore, cnum);\n         let hash = decoder::get_crate_hash(cdata.data);\n         let vers = decoder::get_crate_vers(cdata.data);\n-        debug!(\"Add hash[%s]: %s %s\", *cdata.name, *vers, *hash);\n+        debug!(\"Add hash[%s]: %s %s\", cdata.name, vers, hash);\n         result.push(crate_hash {\n             name: cdata.name,\n             vers: vers,\n@@ -160,8 +162,8 @@ pub fn get_dep_hashes(cstore: &CStore) -> ~[~str] {\n \n     debug!(\"sorted:\");\n     for sorted.each |x| {\n-        debug!(\"  hash[%s]: %s\", *x.name, *x.hash);\n+        debug!(\"  hash[%s]: %s\", x.name, x.hash);\n     }\n \n-    sorted.map(|ch| /*bad*/copy *ch.hash)\n+    sorted.map(|ch| ch.hash)\n }"}, {"sha": "bea0eeb1f25056866886f9b3b579328d9bee9381", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -36,7 +36,7 @@ use extra::serialize::Decodable;\n use syntax::ast_map;\n use syntax::attr;\n use syntax::diagnostic::span_handler;\n-use syntax::parse::token::{StringRef, ident_interner, special_idents};\n+use syntax::parse::token::{ident_interner, special_idents};\n use syntax::print::pprust;\n use syntax::{ast, ast_util};\n use syntax::codemap;\n@@ -311,7 +311,7 @@ fn item_path(item_doc: ebml::Doc) -> ast_map::path {\n fn item_name(intr: @ident_interner, item: ebml::Doc) -> ast::ident {\n     let name = reader::get_doc(item, tag_paths_data_name);\n     let string = name.as_str_slice();\n-    match intr.find_equiv(&StringRef(string)) {\n+    match intr.find_equiv(&string) {\n         None => token::str_to_ident(string),\n         Some(val) => ast::new_ident(val),\n     }\n@@ -985,23 +985,23 @@ fn get_meta_items(md: ebml::Doc) -> ~[@ast::meta_item] {\n     let mut items: ~[@ast::meta_item] = ~[];\n     for reader::tagged_docs(md, tag_meta_item_word) |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = nd.as_str();\n-        items.push(attr::mk_word_item(@n));\n+        let n = nd.as_str_slice().to_managed();\n+        items.push(attr::mk_word_item(n));\n     };\n     for reader::tagged_docs(md, tag_meta_item_name_value) |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let vd = reader::get_doc(meta_item_doc, tag_meta_item_value);\n-        let n = nd.as_str();\n-        let v = vd.as_str();\n+        let n = nd.as_str_slice().to_managed();\n+        let v = vd.as_str_slice().to_managed();\n         // FIXME (#623): Should be able to decode meta_name_value variants,\n         // but currently the encoder just drops them\n-        items.push(attr::mk_name_value_item_str(@n, @v));\n+        items.push(attr::mk_name_value_item_str(n, v));\n     };\n     for reader::tagged_docs(md, tag_meta_item_list) |meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = nd.as_str();\n+        let n = nd.as_str_slice().to_managed();\n         let subitems = get_meta_items(meta_item_doc);\n-        items.push(attr::mk_list_item(@n, subitems));\n+        items.push(attr::mk_list_item(n, subitems));\n     };\n     return items;\n }\n@@ -1058,23 +1058,24 @@ pub fn get_crate_attributes(data: @~[u8]) -> ~[ast::attribute] {\n pub struct crate_dep {\n     cnum: ast::crate_num,\n     name: ast::ident,\n-    vers: @~str,\n-    hash: @~str\n+    vers: @str,\n+    hash: @str\n }\n \n pub fn get_crate_deps(data: @~[u8]) -> ~[crate_dep] {\n     let mut deps: ~[crate_dep] = ~[];\n     let cratedoc = reader::Doc(data);\n     let depsdoc = reader::get_doc(cratedoc, tag_crate_deps);\n     let mut crate_num = 1;\n-    fn docstr(doc: ebml::Doc, tag_: uint) -> ~str {\n-        reader::get_doc(doc, tag_).as_str()\n+    fn docstr(doc: ebml::Doc, tag_: uint) -> @str {\n+        let d = reader::get_doc(doc, tag_);\n+        d.as_str_slice().to_managed()\n     }\n     for reader::tagged_docs(depsdoc, tag_crate_dep) |depdoc| {\n         deps.push(crate_dep {cnum: crate_num,\n                   name: token::str_to_ident(docstr(depdoc, tag_crate_dep_name)),\n-                  vers: @docstr(depdoc, tag_crate_dep_vers),\n-                  hash: @docstr(depdoc, tag_crate_dep_hash)});\n+                  vers: docstr(depdoc, tag_crate_dep_vers),\n+                  hash: docstr(depdoc, tag_crate_dep_hash)});\n         crate_num += 1;\n     };\n     return deps;\n@@ -1086,25 +1087,25 @@ fn list_crate_deps(data: @~[u8], out: @io::Writer) {\n     for get_crate_deps(data).each |dep| {\n         out.write_str(\n             fmt!(\"%d %s-%s-%s\\n\",\n-                 dep.cnum, *token::ident_to_str(&dep.name), *dep.hash, *dep.vers));\n+                 dep.cnum, token::ident_to_str(&dep.name), dep.hash, dep.vers));\n     }\n \n     out.write_str(\"\\n\");\n }\n \n-pub fn get_crate_hash(data: @~[u8]) -> @~str {\n+pub fn get_crate_hash(data: @~[u8]) -> @str {\n     let cratedoc = reader::Doc(data);\n     let hashdoc = reader::get_doc(cratedoc, tag_crate_hash);\n-    @hashdoc.as_str()\n+    hashdoc.as_str_slice().to_managed()\n }\n \n-pub fn get_crate_vers(data: @~[u8]) -> @~str {\n+pub fn get_crate_vers(data: @~[u8]) -> @str {\n     let attrs = decoder::get_crate_attributes(data);\n     let linkage_attrs = attr::find_linkage_metas(attrs);\n \n     match attr::last_meta_item_value_str_by_name(linkage_attrs, \"vers\") {\n         Some(ver) => ver,\n-        None => @~\"0.0\"\n+        None => @\"0.0\"\n     }\n }\n \n@@ -1126,7 +1127,7 @@ pub fn list_crate_metadata(intr: @ident_interner, bytes: @~[u8],\n                            out: @io::Writer) {\n     let hash = get_crate_hash(bytes);\n     let md = reader::Doc(bytes);\n-    list_crate_attributes(intr, md, *hash, out);\n+    list_crate_attributes(intr, md, hash, out);\n     list_crate_deps(bytes, out);\n }\n "}, {"sha": "45a7c457a4c5147b1cebf559d8afe7d1b028b583", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -62,7 +62,7 @@ pub struct EncodeParams {\n     reachable: reachable::map,\n     reexports2: middle::resolve::ExportMap2,\n     item_symbols: @mut HashMap<ast::node_id, ~str>,\n-    discrim_symbols: @mut HashMap<ast::node_id, @~str>,\n+    discrim_symbols: @mut HashMap<ast::node_id, @str>,\n     link_meta: LinkMeta,\n     cstore: @mut cstore::CStore,\n     encode_inlined_item: encode_inlined_item\n@@ -89,7 +89,7 @@ pub struct EncodeContext {\n     reachable: reachable::map,\n     reexports2: middle::resolve::ExportMap2,\n     item_symbols: @mut HashMap<ast::node_id, ~str>,\n-    discrim_symbols: @mut HashMap<ast::node_id, @~str>,\n+    discrim_symbols: @mut HashMap<ast::node_id, @str>,\n     link_meta: LinkMeta,\n     cstore: @mut cstore::CStore,\n     encode_inlined_item: encode_inlined_item,\n@@ -103,14 +103,14 @@ pub fn reachable(ecx: @EncodeContext, id: node_id) -> bool {\n fn encode_name(ecx: @EncodeContext,\n                ebml_w: &mut writer::Encoder,\n                name: ident) {\n-    ebml_w.wr_tagged_str(tag_paths_data_name, *ecx.tcx.sess.str_of(name));\n+    ebml_w.wr_tagged_str(tag_paths_data_name, ecx.tcx.sess.str_of(name));\n }\n \n fn encode_impl_type_basename(ecx: @EncodeContext,\n                              ebml_w: &mut writer::Encoder,\n                              name: ident) {\n     ebml_w.wr_tagged_str(tag_item_impl_type_basename,\n-                         *ecx.tcx.sess.str_of(name));\n+                         ecx.tcx.sess.str_of(name));\n }\n \n pub fn encode_def_id(ebml_w: &mut writer::Encoder, id: def_id) {\n@@ -362,7 +362,7 @@ fn encode_path(ecx: @EncodeContext,\n           ast_map::path_name(name) => (tag_path_elt_name, name)\n         };\n \n-        ebml_w.wr_tagged_str(tag, *ecx.tcx.sess.str_of(name));\n+        ebml_w.wr_tagged_str(tag, ecx.tcx.sess.str_of(name));\n     }\n \n     ebml_w.start_tag(tag_path);\n@@ -380,13 +380,13 @@ fn encode_reexported_static_method(ecx: @EncodeContext,\n                                    method_def_id: def_id,\n                                    method_ident: ident) {\n     debug!(\"(encode reexported static method) %s::%s\",\n-            *exp.name, *ecx.tcx.sess.str_of(method_ident));\n+            exp.name, ecx.tcx.sess.str_of(method_ident));\n     ebml_w.start_tag(tag_items_data_item_reexport);\n     ebml_w.start_tag(tag_items_data_item_reexport_def_id);\n     ebml_w.wr_str(def_to_str(method_def_id));\n     ebml_w.end_tag();\n     ebml_w.start_tag(tag_items_data_item_reexport_name);\n-    ebml_w.wr_str(*exp.name + \"::\" + *ecx.tcx.sess.str_of(method_ident));\n+    ebml_w.wr_str(fmt!(\"%s::%s\", exp.name, ecx.tcx.sess.str_of(method_ident)));\n     ebml_w.end_tag();\n     ebml_w.end_tag();\n }\n@@ -449,17 +449,17 @@ fn encode_reexported_static_methods(ecx: @EncodeContext,\n             // encoded metadata for static methods relative to Bar,\n             // but not yet for Foo.\n             //\n-            if mod_path != *path || *exp.name != *original_name {\n+            if mod_path != *path || exp.name != original_name {\n                 if !encode_reexported_static_base_methods(ecx, ebml_w, exp) {\n                     if encode_reexported_static_trait_methods(ecx, ebml_w, exp) {\n                         debug!(fmt!(\"(encode reexported static methods) %s \\\n                                     [trait]\",\n-                                    *original_name));\n+                                    original_name));\n                     }\n                 }\n                 else {\n                     debug!(fmt!(\"(encode reexported static methods) %s [base]\",\n-                                *original_name));\n+                                original_name));\n                 }\n             }\n         }\n@@ -486,7 +486,7 @@ fn encode_info_for_mod(ecx: @EncodeContext,\n                 let (ident, did) = (item.ident, item.id);\n                 debug!(\"(encoding info for module) ... encoding impl %s \\\n                         (%?/%?)\",\n-                        *ecx.tcx.sess.str_of(ident),\n+                        ecx.tcx.sess.str_of(ident),\n                         did,\n                         ast_map::node_id_to_str(ecx.tcx.items, did, token::get_ident_interner()));\n \n@@ -507,13 +507,13 @@ fn encode_info_for_mod(ecx: @EncodeContext,\n             debug!(\"(encoding info for module) found reexports for %d\", id);\n             for exports.each |exp| {\n                 debug!(\"(encoding info for module) reexport '%s' for %d\",\n-                       *exp.name, id);\n+                       exp.name, id);\n                 ebml_w.start_tag(tag_items_data_item_reexport);\n                 ebml_w.start_tag(tag_items_data_item_reexport_def_id);\n                 ebml_w.wr_str(def_to_str(exp.def_id));\n                 ebml_w.end_tag();\n                 ebml_w.start_tag(tag_items_data_item_reexport_name);\n-                ebml_w.wr_str(*exp.name);\n+                ebml_w.wr_str(exp.name);\n                 ebml_w.end_tag();\n                 ebml_w.end_tag();\n                 encode_reexported_static_methods(ecx, ebml_w, path, exp);\n@@ -622,7 +622,7 @@ fn encode_info_for_struct(ecx: @EncodeContext,\n         global_index.push(entry {val: id, pos: ebml_w.writer.tell()});\n         ebml_w.start_tag(tag_items_data_item);\n         debug!(\"encode_info_for_struct: doing %s %d\",\n-               *tcx.sess.str_of(nm), id);\n+               tcx.sess.str_of(nm), id);\n         encode_struct_field_family(ebml_w, vis);\n         encode_name(ecx, ebml_w, nm);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(nm));\n@@ -648,7 +648,7 @@ fn encode_info_for_ctor(ecx: @EncodeContext,\n         encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n         let its_ty = node_id_to_type(ecx.tcx, id);\n         debug!(\"fn name = %s ty = %s its node id = %d\",\n-               *ecx.tcx.sess.str_of(ident),\n+               ecx.tcx.sess.str_of(ident),\n                ty_to_str(ecx.tcx, its_ty), id);\n         encode_type(ecx, ebml_w, its_ty);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(ident));\n@@ -708,7 +708,7 @@ fn encode_info_for_method(ecx: @EncodeContext,\n                           owner_generics: &ast::Generics,\n                           method_generics: &ast::Generics) {\n     debug!(\"encode_info_for_method: %d %s %u %u\", m.id,\n-           *ecx.tcx.sess.str_of(m.ident),\n+           ecx.tcx.sess.str_of(m.ident),\n            owner_generics.ty_params.len(),\n            method_generics.ty_params.len());\n     ebml_w.start_tag(tag_items_data_item);\n@@ -1058,7 +1058,7 @@ fn encode_info_for_item(ecx: @EncodeContext,\n                         tcx.sess.span_unimpl(\n                             item.span,\n                             fmt!(\"Method %s is both provided and static\",\n-                                 *token::ident_to_str(&method_ty.ident)));\n+                                 token::ident_to_str(&method_ty.ident)));\n                     }\n                     encode_type_param_bounds(ebml_w, ecx,\n                                              &m.generics.ty_params);\n@@ -1278,11 +1278,11 @@ fn synthesize_crate_attrs(ecx: @EncodeContext,\n         assert!(!ecx.link_meta.vers.is_empty());\n \n         let name_item =\n-            attr::mk_name_value_item_str(@~\"name\",\n-                                         @ecx.link_meta.name.to_owned());\n+            attr::mk_name_value_item_str(@\"name\",\n+                                         ecx.link_meta.name);\n         let vers_item =\n-            attr::mk_name_value_item_str(@~\"vers\",\n-                                         @ecx.link_meta.vers.to_owned());\n+            attr::mk_name_value_item_str(@\"vers\",\n+                                         ecx.link_meta.vers);\n \n         let other_items =\n             {\n@@ -1291,7 +1291,7 @@ fn synthesize_crate_attrs(ecx: @EncodeContext,\n             };\n \n         let meta_items = vec::append(~[name_item, vers_item], other_items);\n-        let link_item = attr::mk_list_item(@~\"link\", meta_items);\n+        let link_item = attr::mk_list_item(@\"link\", meta_items);\n \n         return attr::mk_attr(link_item);\n     }\n@@ -1300,15 +1300,15 @@ fn synthesize_crate_attrs(ecx: @EncodeContext,\n     let mut found_link_attr = false;\n     for crate.node.attrs.each |attr| {\n         attrs.push(\n-            if *attr::get_attr_name(attr) != ~\"link\" {\n-                /*bad*/copy *attr\n+            if \"link\" != attr::get_attr_name(attr)  {\n+                copy *attr\n             } else {\n                 match attr.node.value.node {\n                   meta_list(_, ref l) => {\n                     found_link_attr = true;;\n                     synthesize_link_attr(ecx, /*bad*/copy *l)\n                   }\n-                  _ => /*bad*/copy *attr\n+                  _ => copy *attr\n                 }\n             });\n     }\n@@ -1329,7 +1329,7 @@ fn encode_crate_deps(ecx: @EncodeContext,\n         let mut deps = ~[];\n         do cstore::iter_crate_data(cstore) |key, val| {\n             let dep = decoder::crate_dep {cnum: key,\n-                       name: ecx.tcx.sess.ident_of(/*bad*/ copy *val.name),\n+                       name: ecx.tcx.sess.ident_of(val.name),\n                        vers: decoder::get_crate_vers(val.data),\n                        hash: decoder::get_crate_hash(val.data)};\n             deps.push(dep);"}, {"sha": "dab18e7420930c52cbda5de85fcb461cde86ef0f", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -48,7 +48,7 @@ pub struct Context {\n     span: span,\n     ident: ast::ident,\n     metas: ~[@ast::meta_item],\n-    hash: @~str,\n+    hash: @str,\n     os: os,\n     is_static: bool,\n     intr: @ident_interner\n@@ -60,7 +60,7 @@ pub fn load_library_crate(cx: &Context) -> (~str, @~[u8]) {\n       None => {\n         cx.diag.span_fatal(\n             cx.span, fmt!(\"can't find crate for `%s`\",\n-                          *token::ident_to_str(&cx.ident)));\n+                          token::ident_to_str(&cx.ident)));\n       }\n     }\n }\n@@ -89,7 +89,7 @@ fn find_library_crate_aux(\n     filesearch: @filesearch::FileSearch\n ) -> Option<(~str, @~[u8])> {\n     let crate_name = crate_name_from_metas(cx.metas);\n-    let prefix: ~str = prefix + *crate_name + \"-\";\n+    let prefix: ~str = prefix + crate_name + \"-\";\n     let suffix: ~str = /*bad*/copy suffix;\n \n     let mut matches = ~[];\n@@ -128,7 +128,7 @@ fn find_library_crate_aux(\n         Some(/*bad*/copy matches[0])\n     } else {\n         cx.diag.span_err(\n-            cx.span, fmt!(\"multiple matching crates for `%s`\", *crate_name));\n+            cx.span, fmt!(\"multiple matching crates for `%s`\", crate_name));\n         cx.diag.handler().note(\"candidates:\");\n         for matches.each |&(ident, data)| {\n             cx.diag.handler().note(fmt!(\"path: %s\", ident));\n@@ -140,7 +140,7 @@ fn find_library_crate_aux(\n     }\n }\n \n-pub fn crate_name_from_metas(metas: &[@ast::meta_item]) -> @~str {\n+pub fn crate_name_from_metas(metas: &[@ast::meta_item]) -> @str {\n     let name_items = attr::find_meta_items_by_name(metas, \"name\");\n     match name_items.last_opt() {\n         Some(i) => {\n@@ -166,7 +166,7 @@ pub fn note_linkage_attrs(intr: @ident_interner,\n \n fn crate_matches(crate_data: @~[u8],\n                  metas: &[@ast::meta_item],\n-                 hash: @~str) -> bool {\n+                 hash: @str) -> bool {\n     let attrs = decoder::get_crate_attributes(crate_data);\n     let linkage_metas = attr::find_linkage_metas(attrs);\n     if !hash.is_empty() {"}, {"sha": "d9377afa9a5277f043a7294bfa5c5a06f5035f3a", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -41,7 +41,7 @@ pub struct ctxt {\n pub struct ty_abbrev {\n     pos: uint,\n     len: uint,\n-    s: @~str\n+    s: @str\n }\n \n pub enum abbrev_ctxt {\n@@ -60,20 +60,20 @@ pub fn enc_ty(w: @io::Writer, cx: @ctxt, t: ty::t) {\n     match cx.abbrevs {\n       ac_no_abbrevs => {\n         let result_str = match cx.tcx.short_names_cache.find(&t) {\n-            Some(&s) => /*bad*/copy *s,\n+            Some(&s) => s,\n             None => {\n                 let s = do io::with_str_writer |wr| {\n                     enc_sty(wr, cx, /*bad*/copy ty::get(t).sty);\n-                };\n-                cx.tcx.short_names_cache.insert(t, @copy s);\n+                }.to_managed();\n+                cx.tcx.short_names_cache.insert(t, s);\n                 s\n           }\n         };\n         w.write_str(result_str);\n       }\n       ac_use_abbrevs(abbrevs) => {\n           match abbrevs.find(&t) {\n-              Some(a) => { w.write_str(*a.s); return; }\n+              Some(a) => { w.write_str(a.s); return; }\n               None => {}\n           }\n           let pos = w.tell();\n@@ -89,8 +89,8 @@ pub fn enc_ty(w: @io::Writer, cx: @ctxt, t: ty::t) {\n           let abbrev_len = 3u + estimate_sz(pos) + estimate_sz(len);\n           if abbrev_len < len {\n               // I.e. it's actually an abbreviation.\n-              let s = fmt!(\"#%x:%x#\", pos, len);\n-              let a = ty_abbrev { pos: pos, len: len, s: @s };\n+              let s = fmt!(\"#%x:%x#\", pos, len).to_managed();\n+              let a = ty_abbrev { pos: pos, len: len, s: s };\n               abbrevs.insert(t, a);\n           }\n           return;\n@@ -171,7 +171,7 @@ fn enc_bound_region(w: @io::Writer, cx: @ctxt, br: ty::bound_region) {\n       }\n       ty::br_named(s) => {\n         w.write_char('[');\n-        w.write_str(*cx.tcx.sess.str_of(s));\n+        w.write_str(cx.tcx.sess.str_of(s));\n         w.write_char(']')\n       }\n       ty::br_cap_avoid(id, br) => {"}, {"sha": "209ab4ce3d4cbdb49e5156bdf64d1913d362ba3d", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -88,7 +88,7 @@ pub fn encode_inlined_item(ecx: @e::EncodeContext,\n                            maps: Maps) {\n     debug!(\"> Encoding inlined item: %s::%s (%u)\",\n            ast_map::path_to_str(path, token::get_ident_interner()),\n-           *ecx.tcx.sess.str_of(ii.ident()),\n+           ecx.tcx.sess.str_of(ii.ident()),\n            ebml_w.writer.tell());\n \n     let id_range = ast_util::compute_id_range_for_inlined_item(&ii);\n@@ -101,7 +101,7 @@ pub fn encode_inlined_item(ecx: @e::EncodeContext,\n \n     debug!(\"< Encoded inlined fn: %s::%s (%u)\",\n            ast_map::path_to_str(path, token::get_ident_interner()),\n-           *ecx.tcx.sess.str_of(ii.ident()),\n+           ecx.tcx.sess.str_of(ii.ident()),\n            ebml_w.writer.tell());\n }\n \n@@ -131,10 +131,10 @@ pub fn decode_inlined_item(cdata: @cstore::crate_metadata,\n         };\n         let raw_ii = decode_ast(ast_doc);\n         let ii = renumber_ast(xcx, raw_ii);\n-        debug!(\"Fn named: %s\", *tcx.sess.str_of(ii.ident()));\n+        debug!(\"Fn named: %s\", tcx.sess.str_of(ii.ident()));\n         debug!(\"< Decoded inlined fn: %s::%s\",\n                ast_map::path_to_str(path, token::get_ident_interner()),\n-               *tcx.sess.str_of(ii.ident()));\n+               tcx.sess.str_of(ii.ident()));\n         ast_map::map_decoded_item(tcx.sess.diagnostic(),\n                                   dcx.tcx.items, path, &ii);\n         decode_side_tables(xcx, ast_doc);"}, {"sha": "95e26e9e42fa5941708419593d8e2aa4c48ab420", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -711,7 +711,7 @@ impl BorrowckCtxt {\n             LpVar(id) => {\n                 match self.tcx.items.find(&id) {\n                     Some(&ast_map::node_local(ref ident)) => {\n-                        out.push_str(*token::ident_to_str(ident));\n+                        out.push_str(token::ident_to_str(ident));\n                     }\n                     r => {\n                         self.tcx.sess.bug(\n@@ -726,7 +726,7 @@ impl BorrowckCtxt {\n                 match fname {\n                     mc::NamedField(ref fname) => {\n                         out.push_char('.');\n-                        out.push_str(*token::ident_to_str(fname));\n+                        out.push_str(token::ident_to_str(fname));\n                     }\n                     mc::PositionalField(idx) => {\n                         out.push_char('#'); // invent a notation here"}, {"sha": "116282b2627e5fe0bae0b8cfeb6a3dd2c889a713", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -144,8 +144,8 @@ pub fn check_exhaustive(cx: @MatchCheckCtxt, sp: span, pats: ~[@pat]) {\n             match ty::get(ty).sty {\n                 ty::ty_bool => {\n                     match (*ctor) {\n-                        val(const_bool(true)) => Some(@~\"true\"),\n-                        val(const_bool(false)) => Some(@~\"false\"),\n+                        val(const_bool(true)) => Some(@\"true\"),\n+                        val(const_bool(false)) => Some(@\"false\"),\n                         _ => None\n                     }\n                 }\n@@ -165,7 +165,7 @@ pub fn check_exhaustive(cx: @MatchCheckCtxt, sp: span, pats: ~[@pat]) {\n                 }\n                 ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n                     match *ctor {\n-                        vec(n) => Some(@fmt!(\"vectors of length %u\", n)),\n+                        vec(n) => Some(fmt!(\"vectors of length %u\", n).to_managed()),\n                         _ => None\n                     }\n                 }\n@@ -174,7 +174,7 @@ pub fn check_exhaustive(cx: @MatchCheckCtxt, sp: span, pats: ~[@pat]) {\n         }\n     };\n     let msg = ~\"non-exhaustive patterns\" + match ext {\n-        Some(ref s) => ~\": \" + **s + \" not covered\",\n+        Some(ref s) => fmt!(\": %s not covered\",  *s),\n         None => ~\"\"\n     };\n     cx.tcx.sess.span_err(sp, msg);"}, {"sha": "14fcbcc1f149c56d06fd1cb32aa1510c8085fb49", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -236,14 +236,14 @@ pub enum const_val {\n     const_float(f64),\n     const_int(i64),\n     const_uint(u64),\n-    const_str(~str),\n+    const_str(@str),\n     const_bool(bool)\n }\n \n pub fn eval_const_expr(tcx: middle::ty::ctxt, e: @expr) -> const_val {\n     match eval_const_expr_partial(tcx, e) {\n-        Ok(ref r) => (/*bad*/copy *r),\n-        Err(ref s) => tcx.sess.span_fatal(e.span, *s)\n+        Ok(r) => r,\n+        Err(s) => tcx.sess.span_fatal(e.span, s)\n     }\n }\n \n@@ -409,13 +409,13 @@ pub fn eval_const_expr_partial(tcx: middle::ty::ctxt, e: @expr)\n \n pub fn lit_to_const(lit: @lit) -> const_val {\n     match lit.node {\n-      lit_str(s) => const_str(/*bad*/copy *s),\n+      lit_str(s) => const_str(s),\n       lit_int(n, _) => const_int(n),\n       lit_uint(n, _) => const_uint(n),\n       lit_int_unsuffixed(n) => const_int(n),\n-      lit_float(n, _) => const_float(float::from_str(*n).get() as f64),\n+      lit_float(n, _) => const_float(float::from_str(n).get() as f64),\n       lit_float_unsuffixed(n) =>\n-        const_float(float::from_str(*n).get() as f64),\n+        const_float(float::from_str(n).get() as f64),\n       lit_nil => const_int(0i64),\n       lit_bool(b) => const_bool(b)\n     }"}, {"sha": "eaf05a4a85ff903f18f1d33e79c1e3a79c259a9f", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 47, "deletions": 47, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -269,50 +269,50 @@ fn LanguageItemCollector(crate: @crate,\n                       -> LanguageItemCollector {\n     let mut item_refs = HashMap::new();\n \n-    item_refs.insert(@~\"const\", ConstTraitLangItem as uint);\n-    item_refs.insert(@~\"copy\", CopyTraitLangItem as uint);\n-    item_refs.insert(@~\"owned\", OwnedTraitLangItem as uint);\n-    item_refs.insert(@~\"sized\", SizedTraitLangItem as uint);\n-\n-    item_refs.insert(@~\"drop\", DropTraitLangItem as uint);\n-\n-    item_refs.insert(@~\"add\", AddTraitLangItem as uint);\n-    item_refs.insert(@~\"sub\", SubTraitLangItem as uint);\n-    item_refs.insert(@~\"mul\", MulTraitLangItem as uint);\n-    item_refs.insert(@~\"div\", DivTraitLangItem as uint);\n-    item_refs.insert(@~\"rem\", RemTraitLangItem as uint);\n-    item_refs.insert(@~\"neg\", NegTraitLangItem as uint);\n-    item_refs.insert(@~\"not\", NotTraitLangItem as uint);\n-    item_refs.insert(@~\"bitxor\", BitXorTraitLangItem as uint);\n-    item_refs.insert(@~\"bitand\", BitAndTraitLangItem as uint);\n-    item_refs.insert(@~\"bitor\", BitOrTraitLangItem as uint);\n-    item_refs.insert(@~\"shl\", ShlTraitLangItem as uint);\n-    item_refs.insert(@~\"shr\", ShrTraitLangItem as uint);\n-    item_refs.insert(@~\"index\", IndexTraitLangItem as uint);\n-\n-    item_refs.insert(@~\"eq\", EqTraitLangItem as uint);\n-    item_refs.insert(@~\"ord\", OrdTraitLangItem as uint);\n-\n-    item_refs.insert(@~\"str_eq\", StrEqFnLangItem as uint);\n-    item_refs.insert(@~\"uniq_str_eq\", UniqStrEqFnLangItem as uint);\n-    item_refs.insert(@~\"annihilate\", AnnihilateFnLangItem as uint);\n-    item_refs.insert(@~\"log_type\", LogTypeFnLangItem as uint);\n-    item_refs.insert(@~\"fail_\", FailFnLangItem as uint);\n-    item_refs.insert(@~\"fail_bounds_check\",\n+    item_refs.insert(@\"const\", ConstTraitLangItem as uint);\n+    item_refs.insert(@\"copy\", CopyTraitLangItem as uint);\n+    item_refs.insert(@\"owned\", OwnedTraitLangItem as uint);\n+    item_refs.insert(@\"sized\", SizedTraitLangItem as uint);\n+\n+    item_refs.insert(@\"drop\", DropTraitLangItem as uint);\n+\n+    item_refs.insert(@\"add\", AddTraitLangItem as uint);\n+    item_refs.insert(@\"sub\", SubTraitLangItem as uint);\n+    item_refs.insert(@\"mul\", MulTraitLangItem as uint);\n+    item_refs.insert(@\"div\", DivTraitLangItem as uint);\n+    item_refs.insert(@\"rem\", RemTraitLangItem as uint);\n+    item_refs.insert(@\"neg\", NegTraitLangItem as uint);\n+    item_refs.insert(@\"not\", NotTraitLangItem as uint);\n+    item_refs.insert(@\"bitxor\", BitXorTraitLangItem as uint);\n+    item_refs.insert(@\"bitand\", BitAndTraitLangItem as uint);\n+    item_refs.insert(@\"bitor\", BitOrTraitLangItem as uint);\n+    item_refs.insert(@\"shl\", ShlTraitLangItem as uint);\n+    item_refs.insert(@\"shr\", ShrTraitLangItem as uint);\n+    item_refs.insert(@\"index\", IndexTraitLangItem as uint);\n+\n+    item_refs.insert(@\"eq\", EqTraitLangItem as uint);\n+    item_refs.insert(@\"ord\", OrdTraitLangItem as uint);\n+\n+    item_refs.insert(@\"str_eq\", StrEqFnLangItem as uint);\n+    item_refs.insert(@\"uniq_str_eq\", UniqStrEqFnLangItem as uint);\n+    item_refs.insert(@\"annihilate\", AnnihilateFnLangItem as uint);\n+    item_refs.insert(@\"log_type\", LogTypeFnLangItem as uint);\n+    item_refs.insert(@\"fail_\", FailFnLangItem as uint);\n+    item_refs.insert(@\"fail_bounds_check\",\n                      FailBoundsCheckFnLangItem as uint);\n-    item_refs.insert(@~\"exchange_malloc\", ExchangeMallocFnLangItem as uint);\n-    item_refs.insert(@~\"exchange_free\", ExchangeFreeFnLangItem as uint);\n-    item_refs.insert(@~\"malloc\", MallocFnLangItem as uint);\n-    item_refs.insert(@~\"free\", FreeFnLangItem as uint);\n-    item_refs.insert(@~\"borrow_as_imm\", BorrowAsImmFnLangItem as uint);\n-    item_refs.insert(@~\"borrow_as_mut\", BorrowAsMutFnLangItem as uint);\n-    item_refs.insert(@~\"return_to_mut\", ReturnToMutFnLangItem as uint);\n-    item_refs.insert(@~\"check_not_borrowed\",\n+    item_refs.insert(@\"exchange_malloc\", ExchangeMallocFnLangItem as uint);\n+    item_refs.insert(@\"exchange_free\", ExchangeFreeFnLangItem as uint);\n+    item_refs.insert(@\"malloc\", MallocFnLangItem as uint);\n+    item_refs.insert(@\"free\", FreeFnLangItem as uint);\n+    item_refs.insert(@\"borrow_as_imm\", BorrowAsImmFnLangItem as uint);\n+    item_refs.insert(@\"borrow_as_mut\", BorrowAsMutFnLangItem as uint);\n+    item_refs.insert(@\"return_to_mut\", ReturnToMutFnLangItem as uint);\n+    item_refs.insert(@\"check_not_borrowed\",\n                      CheckNotBorrowedFnLangItem as uint);\n-    item_refs.insert(@~\"strdup_uniq\", StrDupUniqFnLangItem as uint);\n-    item_refs.insert(@~\"record_borrow\", RecordBorrowFnLangItem as uint);\n-    item_refs.insert(@~\"unrecord_borrow\", UnrecordBorrowFnLangItem as uint);\n-    item_refs.insert(@~\"start\", StartFnLangItem as uint);\n+    item_refs.insert(@\"strdup_uniq\", StrDupUniqFnLangItem as uint);\n+    item_refs.insert(@\"record_borrow\", RecordBorrowFnLangItem as uint);\n+    item_refs.insert(@\"unrecord_borrow\", UnrecordBorrowFnLangItem as uint);\n+    item_refs.insert(@\"start\", StartFnLangItem as uint);\n \n     LanguageItemCollector {\n         crate: crate,\n@@ -328,7 +328,7 @@ struct LanguageItemCollector {\n     crate: @crate,\n     session: Session,\n \n-    item_refs: HashMap<@~str, uint>,\n+    item_refs: HashMap<@str, uint>,\n }\n \n impl LanguageItemCollector {\n@@ -366,9 +366,9 @@ impl LanguageItemCollector {\n \n     pub fn match_and_collect_item(&mut self,\n                                   item_def_id: def_id,\n-                                  key: @~str,\n-                                  value: @~str) {\n-        if *key != ~\"lang\" {\n+                                  key: @str,\n+                                  value: @str) {\n+        if \"lang\" != key {\n             return;    // Didn't match.\n         }\n \n@@ -419,7 +419,7 @@ impl LanguageItemCollector {\n         for self.item_refs.each |&key, &item_ref| {\n             match self.items.items[item_ref] {\n                 None => {\n-                    self.session.err(fmt!(\"no item found for `%s`\", *key));\n+                    self.session.err(fmt!(\"no item found for `%s`\", key));\n                 }\n                 Some(_) => {\n                     // OK."}, {"sha": "8f504266f97611dab8eb52d04591701238ebb52e", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -119,7 +119,7 @@ struct LintSpec {\n     default: level\n }\n \n-pub type LintDict = HashMap<~str, LintSpec>;\n+pub type LintDict = HashMap<&'static str, LintSpec>;\n \n enum AttributedNode<'self> {\n     Item(@ast::item),\n@@ -290,7 +290,7 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n pub fn get_lint_dict() -> LintDict {\n     let mut map = HashMap::new();\n     for lint_table.each|&(k, v)| {\n-        map.insert(k.to_str(), v);\n+        map.insert(k, v);\n     }\n     return map;\n }\n@@ -352,10 +352,10 @@ impl Context {\n         }\n     }\n \n-    fn lint_to_str(&self, lint: lint) -> ~str {\n+    fn lint_to_str(&self, lint: lint) -> &'static str {\n         for self.dict.each |k, v| {\n             if v.lint == lint {\n-                return copy *k;\n+                return *k;\n             }\n         }\n         fail!(\"unregistered lint %?\", lint);\n@@ -405,13 +405,13 @@ impl Context {\n         // specified closure\n         let mut pushed = 0u;\n         for each_lint(self.tcx.sess, attrs) |meta, level, lintname| {\n-            let lint = match self.dict.find(lintname) {\n+            let lint = match self.dict.find_equiv(&lintname) {\n               None => {\n                 self.span_lint(\n                     unrecognized_lint,\n                     meta.span,\n                     fmt!(\"unknown `%s` attribute: `%s`\",\n-                         level_to_str(level), *lintname));\n+                         level_to_str(level), lintname));\n                 loop\n               }\n               Some(lint) => { lint.lint }\n@@ -422,7 +422,7 @@ impl Context {\n                 self.tcx.sess.span_err(meta.span,\n                     fmt!(\"%s(%s) overruled by outer forbid(%s)\",\n                          level_to_str(level),\n-                         *lintname, *lintname));\n+                         lintname, lintname));\n                 loop;\n             }\n \n@@ -498,7 +498,7 @@ impl Context {\n \n pub fn each_lint(sess: session::Session,\n                  attrs: &[ast::attribute],\n-                 f: &fn(@ast::meta_item, level, &~str) -> bool) -> bool\n+                 f: &fn(@ast::meta_item, level, @str) -> bool) -> bool\n {\n     for [allow, warn, deny, forbid].each |&level| {\n         let level_name = level_to_str(level);"}, {"sha": "47b55d853296319d126403eb7a9bae80d555cebe", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -310,12 +310,12 @@ impl IrMaps {\n         }\n     }\n \n-    pub fn variable_name(&mut self, var: Variable) -> @~str {\n+    pub fn variable_name(&mut self, var: Variable) -> @str {\n         match self.var_kinds[*var] {\n             Local(LocalInfo { ident: nm, _ }) | Arg(_, nm) => {\n                 self.tcx.sess.str_of(nm)\n             },\n-            ImplicitRet => @~\"<implicit-ret>\"\n+            ImplicitRet => @\"<implicit-ret>\"\n         }\n     }\n \n@@ -1578,12 +1578,12 @@ impl Liveness {\n           FreeVarNode(span) => {\n             self.tcx.sess.span_err(\n                 span,\n-                fmt!(\"capture of %s: `%s`\", msg, *name));\n+                fmt!(\"capture of %s: `%s`\", msg, name));\n           }\n           ExprNode(span) => {\n             self.tcx.sess.span_err(\n                 span,\n-                fmt!(\"use of %s: `%s`\", msg, *name));\n+                fmt!(\"use of %s: `%s`\", msg, name));\n           }\n           ExitNode | VarDefNode(_) => {\n             self.tcx.sess.span_bug(\n@@ -1593,7 +1593,7 @@ impl Liveness {\n         }\n     }\n \n-    pub fn should_warn(&self, var: Variable) -> Option<@~str> {\n+    pub fn should_warn(&self, var: Variable) -> Option<@str> {\n         let name = self.ir.variable_name(var);\n         if name[0] == ('_' as u8) { None } else { Some(name) }\n     }\n@@ -1638,10 +1638,10 @@ impl Liveness {\n                 if is_assigned {\n                     self.tcx.sess.add_lint(unused_variable, id, sp,\n                         fmt!(\"variable `%s` is assigned to, \\\n-                                  but never used\", **name));\n+                                  but never used\", *name));\n                 } else {\n                     self.tcx.sess.add_lint(unused_variable, id, sp,\n-                        fmt!(\"unused variable: `%s`\", **name));\n+                        fmt!(\"unused variable: `%s`\", *name));\n                 }\n             }\n             true\n@@ -1659,7 +1659,7 @@ impl Liveness {\n             let r = self.should_warn(var);\n             for r.iter().advance |name| {\n                 self.tcx.sess.add_lint(dead_assignment, id, sp,\n-                    fmt!(\"value assigned to `%s` is never read\", **name));\n+                    fmt!(\"value assigned to `%s` is never read\", *name));\n             }\n         }\n     }"}, {"sha": "3152b66440ce904e522b9a35dd8191d1f2649c68", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -1201,7 +1201,7 @@ pub fn ptr_sigil(ptr: ptr_kind) -> ~str {\n impl Repr for InteriorKind {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n         match *self {\n-            InteriorField(NamedField(fld)) => copy *tcx.sess.str_of(fld),\n+            InteriorField(NamedField(fld)) => tcx.sess.str_of(fld).to_owned(),\n             InteriorField(PositionalField(i)) => fmt!(\"#%?\", i),\n             InteriorElement(_) => ~\"[]\",\n         }"}, {"sha": "60193f3fe5db042a7da9ac9b70e6391d0d8c623f", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -235,7 +235,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n             if field.ident != ident { loop; }\n             if field.vis == private {\n                 tcx.sess.span_err(span, fmt!(\"field `%s` is private\",\n-                                             *token::ident_to_str(&ident)));\n+                                             token::ident_to_str(&ident)));\n             }\n             break;\n         }\n@@ -255,15 +255,15 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                      !privileged_items.contains(&(container_id.node))) {\n                 tcx.sess.span_err(span,\n                                   fmt!(\"method `%s` is private\",\n-                                       *token::ident_to_str(name)));\n+                                       token::ident_to_str(name)));\n             }\n         } else {\n             let visibility =\n                 csearch::get_item_visibility(tcx.sess.cstore, method_id);\n             if visibility != public {\n                 tcx.sess.span_err(span,\n                                   fmt!(\"method `%s` is private\",\n-                                       *token::ident_to_str(name)));\n+                                       token::ident_to_str(name)));\n             }\n         }\n     };\n@@ -283,13 +283,13 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                             !privileged_items.contains(&def_id.node) {\n                         tcx.sess.span_err(span,\n                                           fmt!(\"function `%s` is private\",\n-                                               *token::ident_to_str(path.idents.last())));\n+                                               token::ident_to_str(path.idents.last())));\n                     }\n                 } else if csearch::get_item_visibility(tcx.sess.cstore,\n                                                        def_id) != public {\n                     tcx.sess.span_err(span,\n                                       fmt!(\"function `%s` is private\",\n-                                           *token::ident_to_str(path.idents.last())));\n+                                           token::ident_to_str(path.idents.last())));\n                 }\n             }\n             _ => {}\n@@ -328,7 +328,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                                              .contains(&(trait_id.node)) => {\n                                             tcx.sess.span_err(span,\n                                                               fmt!(\"method `%s` is private\",\n-                                                                   *token::ident_to_str(&method\n+                                                                   token::ident_to_str(&method\n                                                                                         .ident)));\n                                         }\n                                         provided(_) | required(_) => {"}, {"sha": "9637a32ba9f4b2357aec638f323f83119543a45d", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -84,7 +84,7 @@ pub type TraitMap = HashMap<node_id,@mut ~[def_id]>;\n pub type ExportMap2 = @mut HashMap<node_id, ~[Export2]>;\n \n pub struct Export2 {\n-    name: @~str,        // The name of the target.\n+    name: @str,        // The name of the target.\n     def_id: def_id,     // The definition of the target.\n     reexport: bool,     // Whether this is a reexport.\n }\n@@ -1035,14 +1035,14 @@ impl Resolver {\n                     self.session.span_err(sp,\n                         fmt!(\"duplicate definition of %s `%s`\",\n                              namespace_to_str(ns),\n-                             *self.session.str_of(name)));\n+                             self.session.str_of(name)));\n                     {\n                         let r = child.span_for_namespace(ns);\n                         for r.iter().advance |sp| {\n                             self.session.span_note(*sp,\n                                  fmt!(\"first definition of %s %s here:\",\n                                       namespace_to_str(ns),\n-                                      *self.session.str_of(name)));\n+                                      self.session.str_of(name)));\n                         }\n                     }\n                 }\n@@ -1239,10 +1239,10 @@ impl Resolver {\n                             if *old_sp != span {\n                                 self.session.span_err(span,\n                                                       fmt!(\"duplicate definition of method `%s`\",\n-                                                           *self.session.str_of(ident)));\n+                                                           self.session.str_of(ident)));\n                                 self.session.span_note(*old_sp,\n                                                        fmt!(\"first definition of method `%s` here\",\n-                                                            *self.session.str_of(ident)));\n+                                                            self.session.str_of(ident)));\n                             }\n                         }\n                     }\n@@ -1376,10 +1376,10 @@ impl Resolver {\n                             if *old_sp != ty_m.span {\n                                 self.session.span_err(ty_m.span,\n                                                       fmt!(\"duplicate definition of method `%s`\",\n-                                                           *self.session.str_of(ident)));\n+                                                           self.session.str_of(ident)));\n                                 self.session.span_note(*old_sp,\n                                                        fmt!(\"first definition of method `%s` here\",\n-                                                            *self.session.str_of(ident)));\n+                                                            self.session.str_of(ident)));\n                             }\n                         }\n                     }\n@@ -1695,7 +1695,7 @@ impl Resolver {\n                   debug!(\"(building reduced graph for \\\n                           external crate) ... adding \\\n                           trait method '%s'\",\n-                         *self.session.str_of(method_name));\n+                         self.session.str_of(method_name));\n \n                   // Add it to the trait info if not static.\n                   if explicit_self != sty_static {\n@@ -1824,7 +1824,7 @@ impl Resolver {\n                                              visibility,\n                                              &mut modules,\n                                              child_name_bindings,\n-                                             *self.session.str_of(\n+                                             self.session.str_of(\n                                                  final_ident),\n                                              final_ident,\n                                              new_parent);\n@@ -1843,7 +1843,7 @@ impl Resolver {\n                                     debug!(\"(building reduced graph for \\\n                                             external crate) processing \\\n                                             static methods for type name %s\",\n-                                            *self.session.str_of(\n+                                            self.session.str_of(\n                                                 final_ident));\n \n                                     let (child_name_bindings, new_parent) =\n@@ -1894,7 +1894,7 @@ impl Resolver {\n                                         debug!(\"(building reduced graph for \\\n                                                  external crate) creating \\\n                                                  static method '%s'\",\n-                                               *self.session.str_of(ident));\n+                                               self.session.str_of(ident));\n \n                                         let (method_name_bindings, _) =\n                                             self.add_child(\n@@ -1945,7 +1945,7 @@ impl Resolver {\n                         directive: privacy %? %s::%s\",\n                        privacy,\n                        self.idents_to_str(directive.module_path),\n-                       *self.session.str_of(target));\n+                       self.session.str_of(target));\n \n                 match module_.import_resolutions.find(&target) {\n                     Some(&resolution) => {\n@@ -2054,7 +2054,7 @@ impl Resolver {\n                 Failed => {\n                     // We presumably emitted an error. Continue.\n                     let msg = fmt!(\"failed to resolve import `%s`\",\n-                                   *self.import_path_to_str(\n+                                   self.import_path_to_str(\n                                        import_directive.module_path,\n                                        *import_directive.subclass));\n                     self.session.span_err(import_directive.span, msg);\n@@ -2077,30 +2077,30 @@ impl Resolver {\n         let mut result = ~\"\";\n         for idents.each |ident| {\n             if first { first = false; } else { result += \"::\" };\n-            result += *self.session.str_of(*ident);\n+            result += self.session.str_of(*ident);\n         };\n         return result;\n     }\n \n     pub fn import_directive_subclass_to_str(@mut self,\n                                             subclass: ImportDirectiveSubclass)\n-                                            -> @~str {\n+                                            -> @str {\n         match subclass {\n             SingleImport(_target, source) => self.session.str_of(source),\n-            GlobImport => @~\"*\"\n+            GlobImport => @\"*\"\n         }\n     }\n \n     pub fn import_path_to_str(@mut self,\n                               idents: &[ident],\n                               subclass: ImportDirectiveSubclass)\n-                              -> @~str {\n+                              -> @str {\n         if idents.is_empty() {\n             self.import_directive_subclass_to_str(subclass)\n         } else {\n-            @fmt!(\"%s::%s\",\n-                 self.idents_to_str(idents),\n-                 *self.import_directive_subclass_to_str(subclass))\n+            (fmt!(\"%s::%s\",\n+                  self.idents_to_str(idents),\n+                  self.import_directive_subclass_to_str(subclass))).to_managed()\n         }\n     }\n \n@@ -2221,9 +2221,9 @@ impl Resolver {\n                                  -> ResolveResult<()> {\n         debug!(\"(resolving single import) resolving `%s` = `%s::%s` from \\\n                 `%s`\",\n-               *self.session.str_of(target),\n+               self.session.str_of(target),\n                self.module_to_str(containing_module),\n-               *self.session.str_of(source),\n+               self.session.str_of(source),\n                self.module_to_str(module_));\n \n         // We need to resolve both namespaces for this to succeed.\n@@ -2427,12 +2427,12 @@ impl Resolver {\n         let span = directive.span;\n         if resolve_fail {\n             self.session.span_err(span, fmt!(\"unresolved import: there is no `%s` in `%s`\",\n-                                             *self.session.str_of(source),\n+                                             self.session.str_of(source),\n                                              self.module_to_str(containing_module)));\n             return Failed;\n         } else if priv_fail {\n             self.session.span_err(span, fmt!(\"unresolved import: found `%s` in `%s` but it is \\\n-                                             private\", *self.session.str_of(source),\n+                                             private\", self.session.str_of(source),\n                                              self.module_to_str(containing_module)));\n             return Failed;\n         }\n@@ -2535,7 +2535,7 @@ impl Resolver {\n \n             debug!(\"(resolving glob import) writing resolution `%s` in `%s` \\\n                     to `%s`, privacy=%?\",\n-                   *self.session.str_of(ident),\n+                   self.session.str_of(ident),\n                    self.module_to_str(containing_module),\n                    self.module_to_str(module_),\n                    copy dest_import_resolution.privacy);\n@@ -2604,17 +2604,17 @@ impl Resolver {\n                                               fmt!(\"unresolved import. maybe \\\n                                                     a missing `extern mod \\\n                                                     %s`?\",\n-                                                    *segment_name));\n+                                                    segment_name));\n                         return Failed;\n                     }\n                     self.session.span_err(span, fmt!(\"unresolved import: could not find `%s` in \\\n-                                                     `%s`.\", *segment_name, module_name));\n+                                                     `%s`.\", segment_name, module_name));\n                     return Failed;\n                 }\n                 Indeterminate => {\n                     debug!(\"(resolving module path for import) module \\\n                             resolution is indeterminate: %s\",\n-                            *self.session.str_of(name));\n+                            self.session.str_of(name));\n                     return Indeterminate;\n                 }\n                 Success(target) => {\n@@ -2628,7 +2628,7 @@ impl Resolver {\n                                     self.session.span_err(span,\n                                                           fmt!(\"not a \\\n                                                                 module `%s`\",\n-                                                               *self.session.\n+                                                               self.session.\n                                                                    str_of(\n                                                                     name)));\n                                     return Failed;\n@@ -2656,7 +2656,7 @@ impl Resolver {\n                             // There are no type bindings at all.\n                             self.session.span_err(span,\n                                                   fmt!(\"not a module `%s`\",\n-                                                       *self.session.str_of(\n+                                                       self.session.str_of(\n                                                             name)));\n                             return Failed;\n                         }\n@@ -2783,7 +2783,7 @@ impl Resolver {\n                                          -> ResolveResult<Target> {\n         debug!(\"(resolving item in lexical scope) resolving `%s` in \\\n                 namespace %? in `%s`\",\n-               *self.session.str_of(name),\n+               self.session.str_of(name),\n                namespace,\n                self.module_to_str(module_));\n \n@@ -2997,11 +2997,11 @@ impl Resolver {\n         // top of the crate otherwise.\n         let mut containing_module;\n         let mut i;\n-        if *token::ident_to_str(&module_path[0]) == ~\"self\" {\n+        if \"self\" == token::ident_to_str(&module_path[0]) {\n             containing_module =\n                 self.get_nearest_normal_module_parent_or_self(module_);\n             i = 1;\n-        } else if *token::ident_to_str(&module_path[0]) == ~\"super\" {\n+        } else if \"super\" == token::ident_to_str(&module_path[0]) {\n             containing_module =\n                 self.get_nearest_normal_module_parent_or_self(module_);\n             i = 0;  // We'll handle `super` below.\n@@ -3011,7 +3011,7 @@ impl Resolver {\n \n         // Now loop through all the `super`s we find.\n         while i < module_path.len() &&\n-                *token::ident_to_str(&module_path[i]) == ~\"super\" {\n+                \"super\" == token::ident_to_str(&module_path[i]) {\n             debug!(\"(resolving module prefix) resolving `super` at %s\",\n                    self.module_to_str(containing_module));\n             match self.get_nearest_normal_module_parent(containing_module) {\n@@ -3039,7 +3039,7 @@ impl Resolver {\n                                   name_search_type: NameSearchType)\n                                   -> ResolveResult<Target> {\n         debug!(\"(resolving name in module) resolving `%s` in `%s`\",\n-               *self.session.str_of(name),\n+               self.session.str_of(name),\n                self.module_to_str(module_));\n \n         // First, check the direct children of the module.\n@@ -3112,7 +3112,7 @@ impl Resolver {\n \n         // We're out of luck.\n         debug!(\"(resolving name in module) failed to resolve `%s`\",\n-               *self.session.str_of(name));\n+               self.session.str_of(name));\n         return Failed;\n     }\n \n@@ -3230,7 +3230,7 @@ impl Resolver {\n             (Some(d), Some(Public)) => {\n                 debug!(\"(computing exports) YES: %s '%s' => %?\",\n                        if reexport { ~\"reexport\" } else { ~\"export\"},\n-                       *self.session.str_of(ident),\n+                       self.session.str_of(ident),\n                        def_id_of_def(d));\n                 exports2.push(Export2 {\n                     reexport: reexport,\n@@ -3252,7 +3252,7 @@ impl Resolver {\n                                   module_: @mut Module) {\n         for module_.children.each |ident, namebindings| {\n             debug!(\"(computing exports) maybe export '%s'\",\n-                   *self.session.str_of(*ident));\n+                   self.session.str_of(*ident));\n             self.add_exports_of_namebindings(&mut *exports2,\n                                              *ident,\n                                              *namebindings,\n@@ -3268,14 +3268,14 @@ impl Resolver {\n         for module_.import_resolutions.each |ident, importresolution| {\n             if importresolution.privacy != Public {\n                 debug!(\"(computing exports) not reexporting private `%s`\",\n-                       *self.session.str_of(*ident));\n+                       self.session.str_of(*ident));\n                 loop;\n             }\n             for [ TypeNS, ValueNS ].each |ns| {\n                 match importresolution.target_for_namespace(*ns) {\n                     Some(target) => {\n                         debug!(\"(computing exports) maybe reexport '%s'\",\n-                               *self.session.str_of(*ident));\n+                               self.session.str_of(*ident));\n                         self.add_exports_of_namebindings(&mut *exports2,\n                                                          *ident,\n                                                          target.bindings,\n@@ -3318,15 +3318,15 @@ impl Resolver {\n                 match orig_module.children.find(&name) {\n                     None => {\n                         debug!(\"!!! (with scope) didn't find `%s` in `%s`\",\n-                               *self.session.str_of(name),\n+                               self.session.str_of(name),\n                                self.module_to_str(orig_module));\n                     }\n                     Some(name_bindings) => {\n                         match (*name_bindings).get_module_if_available() {\n                             None => {\n                                 debug!(\"!!! (with scope) didn't find module \\\n                                         for `%s` in `%s`\",\n-                                       *self.session.str_of(name),\n+                                       self.session.str_of(name),\n                                        self.module_to_str(orig_module));\n                             }\n                             Some(module_) => {\n@@ -3503,7 +3503,7 @@ impl Resolver {\n \n     pub fn resolve_item(@mut self, item: @item, visitor: ResolveVisitor) {\n         debug!(\"(resolving item) resolving %s\",\n-               *self.session.str_of(item.ident));\n+               self.session.str_of(item.ident));\n \n         // Items with the !resolve_unexported attribute are X-ray contexts.\n         // This is used to allow the test runner to run unexported tests.\n@@ -4044,15 +4044,15 @@ impl Resolver {\n                         p.span,\n                         fmt!(\"variable `%s` from pattern #1 is \\\n                                   not bound in pattern #%u\",\n-                             *self.session.str_of(key), i + 1));\n+                             self.session.str_of(key), i + 1));\n                   }\n                   Some(binding_i) => {\n                     if binding_0.binding_mode != binding_i.binding_mode {\n                         self.session.span_err(\n                             binding_i.span,\n                             fmt!(\"variable `%s` is bound with different \\\n                                       mode in pattern #%u than in pattern #1\",\n-                                 *self.session.str_of(key), i + 1));\n+                                 self.session.str_of(key), i + 1));\n                     }\n                   }\n                 }\n@@ -4064,7 +4064,7 @@ impl Resolver {\n                         binding.span,\n                         fmt!(\"variable `%s` from pattern #%u is \\\n                                   not bound in pattern #1\",\n-                             *self.session.str_of(key), i + 1));\n+                             self.session.str_of(key), i + 1));\n                 }\n             }\n         }\n@@ -4148,7 +4148,7 @@ impl Resolver {\n                             Some(def) => {\n                                 debug!(\"(resolving type) resolved `%s` to \\\n                                         type %?\",\n-                                       *self.session.str_of(\n+                                       self.session.str_of(\n                                             *path.idents.last()),\n                                        def);\n                                 result_def = Some(def);\n@@ -4224,7 +4224,7 @@ impl Resolver {\n                                 if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `%s` to \\\n                                     struct or enum variant\",\n-                                    *self.session.str_of(ident));\n+                                    self.session.str_of(ident));\n \n                             self.enforce_default_binding_mode(\n                                 pattern,\n@@ -4238,13 +4238,13 @@ impl Resolver {\n                                                         shadows an enum \\\n                                                         variant or unit-like \\\n                                                         struct in scope\",\n-                                                        *self.session\n+                                                        self.session\n                                                             .str_of(ident)));\n                         }\n                         FoundConst(def) if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `%s` to \\\n                                     constant\",\n-                                    *self.session.str_of(ident));\n+                                    self.session.str_of(ident));\n \n                             self.enforce_default_binding_mode(\n                                 pattern,\n@@ -4259,7 +4259,7 @@ impl Resolver {\n                         }\n                         BareIdentifierPatternUnresolved => {\n                             debug!(\"(resolving pattern) binding `%s`\",\n-                                   *self.session.str_of(ident));\n+                                   self.session.str_of(ident));\n \n                             let is_mutable = mutability == Mutable;\n \n@@ -4350,7 +4350,7 @@ impl Resolver {\n                             self.session.span_err(\n                                 path.span,\n                                 fmt!(\"`%s` is not an enum variant or constant\",\n-                                     *self.session.str_of(\n+                                     self.session.str_of(\n                                          *path.idents.last())));\n                         }\n                         None => {\n@@ -4378,7 +4378,7 @@ impl Resolver {\n                             self.session.span_err(\n                                 path.span,\n                                 fmt!(\"`%s` is not an enum variant, struct or const\",\n-                                     *self.session.str_of(\n+                                     self.session.str_of(\n                                          *path.idents.last())));\n                         }\n                         None => {\n@@ -4753,7 +4753,7 @@ impl Resolver {\n             Some(dl_def(def)) => {\n                 debug!(\"(resolving path in local ribs) resolved `%s` to \\\n                         local: %?\",\n-                       *self.session.str_of(ident),\n+                       self.session.str_of(ident),\n                        def);\n                 return Some(def);\n             }\n@@ -4811,7 +4811,7 @@ impl Resolver {\n                     Some(def) => {\n                         debug!(\"(resolving item path in lexical scope) \\\n                                 resolved `%s` to item\",\n-                               *self.session.str_of(ident));\n+                               self.session.str_of(ident));\n                         return Some(def);\n                     }\n                 }\n@@ -4828,17 +4828,17 @@ impl Resolver {\n     pub fn find_best_match_for_name(@mut self,\n                                     name: &str,\n                                     max_distance: uint)\n-                                    -> Option<~str> {\n+                                    -> Option<@str> {\n         let this = &mut *self;\n \n-        let mut maybes: ~[~str] = ~[];\n+        let mut maybes: ~[@str] = ~[];\n         let mut values: ~[uint] = ~[];\n \n         let mut j = this.value_ribs.len();\n         while j != 0 {\n             j -= 1;\n             for this.value_ribs[j].bindings.each_key |&k| {\n-                vec::push(&mut maybes, copy *this.session.str_of(k));\n+                vec::push(&mut maybes, this.session.str_of(k));\n                 vec::push(&mut values, uint::max_value);\n             }\n         }\n@@ -4857,7 +4857,7 @@ impl Resolver {\n             values[smallest] != uint::max_value &&\n             values[smallest] < name.len() + 2 &&\n             values[smallest] <= max_distance &&\n-            maybes[smallest] != name.to_owned() {\n+            name != maybes[smallest] {\n \n             Some(vec::swap_remove(&mut maybes, smallest))\n \n@@ -4882,7 +4882,7 @@ impl Resolver {\n                         match field.node.kind {\n                           unnamed_field => {},\n                           named_field(ident, _) => {\n-                              if str::eq_slice(*this.session.str_of(ident),\n+                              if str::eq_slice(this.session.str_of(ident),\n                                                name) {\n                                 return true\n                               }\n@@ -5007,7 +5007,7 @@ impl Resolver {\n                         self.session.span_err(expr.span,\n                                               fmt!(\"use of undeclared label \\\n                                                    `%s`\",\n-                                                   *self.session.str_of(\n+                                                   self.session.str_of(\n                                                        label))),\n                     Some(dl_def(def @ def_label(_))) => {\n                         self.record_def(expr.id, def)\n@@ -5122,7 +5122,7 @@ impl Resolver {\n     pub fn search_for_traits_containing_method(@mut self, name: ident)\n                                                -> ~[def_id] {\n         debug!(\"(searching for traits containing method) looking for '%s'\",\n-               *self.session.str_of(name));\n+               self.session.str_of(name));\n \n \n         let mut found_traits = ~[];\n@@ -5227,7 +5227,7 @@ impl Resolver {\n         debug!(\"(adding trait info) found trait %d:%d for method '%s'\",\n                trait_def_id.crate,\n                trait_def_id.node,\n-               *self.session.str_of(name));\n+               self.session.str_of(name));\n         found_traits.push(trait_def_id);\n     }\n \n@@ -5346,7 +5346,7 @@ impl Resolver {\n \n         debug!(\"Children:\");\n         for module_.children.each_key |&name| {\n-            debug!(\"* %s\", *self.session.str_of(name));\n+            debug!(\"* %s\", self.session.str_of(name));\n         }\n \n         debug!(\"Import resolutions:\");\n@@ -5369,7 +5369,7 @@ impl Resolver {\n                 }\n             }\n \n-            debug!(\"* %s:%s%s\", *self.session.str_of(*name),\n+            debug!(\"* %s:%s%s\", self.session.str_of(*name),\n                    value_repr, type_repr);\n         }\n     }"}, {"sha": "53d30e9c39043a287da95869f3cc5a99f8c4d053", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -1699,7 +1699,7 @@ pub fn trans_match_inner(scope_cx: block,\n             // Special case for empty types\n             let fail_cx = @mut None;\n             let f: mk_fail = || mk_fail(scope_cx, discr_expr.span,\n-                            @~\"scrutinizing value that can't exist\", fail_cx);\n+                            @\"scrutinizing value that can't exist\", fail_cx);\n             Some(f)\n         } else {\n             None\n@@ -1731,7 +1731,7 @@ pub fn trans_match_inner(scope_cx: block,\n     bcx = controlflow::join_blocks(scope_cx, arm_cxs);\n     return bcx;\n \n-    fn mk_fail(bcx: block, sp: span, msg: @~str,\n+    fn mk_fail(bcx: block, sp: span, msg: @str,\n                finished: @mut Option<BasicBlockRef>) -> BasicBlockRef {\n         match *finished { Some(bb) => return bb, _ => () }\n         let fail_cx = sub_block(bcx, \"case_fallthrough\");"}, {"sha": "d73d57efbbf7276aab767392931fed3dc133ffaa", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -33,7 +33,7 @@ pub fn trans_inline_asm(bcx: block, ia: &ast::inline_asm) -> block {\n \n     // Prepare the output operands\n     let outputs = do ia.outputs.map |&(c, out)| {\n-        constraints.push(copy *c);\n+        constraints.push(c);\n \n         aoutputs.push(unpack_result!(bcx, {\n             callee::trans_arg_expr(bcx,\n@@ -69,7 +69,7 @@ pub fn trans_inline_asm(bcx: block, ia: &ast::inline_asm) -> block {\n \n     // Now the input operands\n     let inputs = do ia.inputs.map |&(c, in)| {\n-        constraints.push(copy *c);\n+        constraints.push(c);\n \n         unpack_result!(bcx, {\n             callee::trans_arg_expr(bcx,\n@@ -90,14 +90,14 @@ pub fn trans_inline_asm(bcx: block, ia: &ast::inline_asm) -> block {\n     let mut constraints = constraints.connect(\",\");\n \n     let mut clobbers = getClobbers();\n-    if *ia.clobbers != ~\"\" && clobbers != ~\"\" {\n-        clobbers = *ia.clobbers + \",\" + clobbers;\n+    if !ia.clobbers.is_empty() && !clobbers.is_empty() {\n+        clobbers = fmt!(\"%s,%s\", ia.clobbers, clobbers);\n     } else {\n-        clobbers += *ia.clobbers;\n+        clobbers += ia.clobbers;\n     };\n \n     // Add the clobbers to our constraints list\n-    if clobbers != ~\"\" && constraints != ~\"\" {\n+    if !clobbers.is_empty() && !constraints.is_empty() {\n         constraints += \",\";\n         constraints += clobbers;\n     } else {\n@@ -122,7 +122,7 @@ pub fn trans_inline_asm(bcx: block, ia: &ast::inline_asm) -> block {\n         ast::asm_intel => lib::llvm::AD_Intel\n     };\n \n-    let r = do str::as_c_str(*ia.asm) |a| {\n+    let r = do str::as_c_str(ia.asm) |a| {\n         do str::as_c_str(constraints) |c| {\n             InlineAsmCall(bcx, a, c, inputs, output, ia.volatile, ia.alignstack, dialect)\n         }"}, {"sha": "7337b07c402ad9b136e79f2cd1289bed72007fc8", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 86, "deletions": 94, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -485,9 +485,9 @@ pub fn set_glue_inlining(f: ValueRef, t: ty::t) {\n \n // Double-check that we never ask LLVM to declare the same symbol twice. It\n // silently mangles such symbols, breaking our linkage model.\n-pub fn note_unique_llvm_symbol(ccx: @CrateContext, sym: @~str) {\n+pub fn note_unique_llvm_symbol(ccx: @CrateContext, sym: @str) {\n     if ccx.all_llvm_symbols.contains(&sym) {\n-        ccx.sess.bug(~\"duplicate LLVM symbol: \" + *sym);\n+        ccx.sess.bug(~\"duplicate LLVM symbol: \" + sym);\n     }\n     ccx.all_llvm_symbols.insert(sym);\n }\n@@ -569,7 +569,7 @@ pub fn compare_scalar_types(cx: block,\n             rslt(\n                 controlflow::trans_fail(\n                     cx, None,\n-                    @~\"attempt to compare values of type type\"),\n+                    @\"attempt to compare values of type type\"),\n                 C_nil())\n         }\n         _ => {\n@@ -791,9 +791,9 @@ pub fn cast_shift_rhs(op: ast::binop,\n pub fn fail_if_zero(cx: block, span: span, divrem: ast::binop,\n                     rhs: ValueRef, rhs_t: ty::t) -> block {\n     let text = if divrem == ast::div {\n-        @~\"attempted to divide by zero\"\n+        @\"attempted to divide by zero\"\n     } else {\n-        @~\"attempted remainder with a divisor of zero\"\n+        @\"attempted remainder with a divisor of zero\"\n     };\n     let is_zero = match ty::get(rhs_t).sty {\n       ty::ty_int(t) => {\n@@ -1056,19 +1056,19 @@ pub fn load_if_immediate(cx: block, v: ValueRef, t: ty::t) -> ValueRef {\n     return v;\n }\n \n-pub fn trans_trace(bcx: block, sp_opt: Option<span>, trace_str: @~str) {\n+pub fn trans_trace(bcx: block, sp_opt: Option<span>, trace_str: @str) {\n     if !bcx.sess().trace() { return; }\n     let _icx = bcx.insn_ctxt(\"trans_trace\");\n-    add_comment(bcx, *trace_str);\n+    add_comment(bcx, trace_str);\n     let V_trace_str = C_cstr(bcx.ccx(), trace_str);\n     let (V_filename, V_line) = match sp_opt {\n       Some(sp) => {\n         let sess = bcx.sess();\n         let loc = sess.parse_sess.cm.lookup_char_pos(sp.lo);\n-        (C_cstr(bcx.ccx(), @/*bad*/copy loc.file.name), loc.line as int)\n+        (C_cstr(bcx.ccx(), loc.file.name), loc.line as int)\n       }\n       None => {\n-        (C_cstr(bcx.ccx(), @~\"<runtime>\"), 0)\n+        (C_cstr(bcx.ccx(), @\"<runtime>\"), 0)\n       }\n     };\n     let ccx = bcx.ccx();\n@@ -1187,7 +1187,7 @@ pub fn new_block(cx: fn_ctxt, parent: Option<block>, kind: block_kind,\n         special_idents::invalid\n     };\n     unsafe {\n-        let llbb = str::as_c_str(*cx.ccx.sess.str_of(s), |buf| {\n+        let llbb = str::as_c_str(cx.ccx.sess.str_of(s), |buf| {\n             llvm::LLVMAppendBasicBlockInContext(cx.ccx.llcx, cx.llfn, buf)\n         });\n         let bcx = mk_block(llbb,\n@@ -1308,7 +1308,7 @@ pub fn cleanup_and_leave(bcx: block,\n         if bcx.sess().trace() {\n             trans_trace(\n                 bcx, None,\n-                @fmt!(\"cleanup_and_leave(%s)\", cur.to_str()));\n+                (fmt!(\"cleanup_and_leave(%s)\", cur.to_str())).to_managed());\n         }\n \n         match cur.kind {\n@@ -1427,7 +1427,7 @@ pub fn alloc_local(cx: block, local: @ast::local) -> block {\n     let val = alloc_ty(cx, t);\n     if cx.sess().opts.debuginfo {\n         for simple_name.iter().advance |name| {\n-            str::as_c_str(*cx.ccx().sess.str_of(*name), |buf| {\n+            str::as_c_str(cx.ccx().sess.str_of(*name), |buf| {\n                 unsafe {\n                     llvm::LLVMSetValueName(val, buf)\n                 }\n@@ -1453,12 +1453,8 @@ pub fn call_memcpy(cx: block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, a\n     let _icx = cx.insn_ctxt(\"call_memcpy\");\n     let ccx = cx.ccx();\n     let key = match ccx.sess.targ_cfg.arch {\n-        X86 | Arm | Mips => {\n-            ~\"llvm.memcpy.p0i8.p0i8.i32\"\n-        }\n-        X86_64 => {\n-            ~\"llvm.memcpy.p0i8.p0i8.i64\"\n-        }\n+        X86 | Arm | Mips => \"llvm.memcpy.p0i8.p0i8.i32\",\n+        X86_64 => \"llvm.memcpy.p0i8.p0i8.i64\"\n     };\n     let memcpy = *ccx.intrinsics.get(&key);\n     let src_ptr = PointerCast(cx, src, T_ptr(T_i8()));\n@@ -1499,15 +1495,10 @@ pub fn memzero(cx: block, llptr: ValueRef, llty: TypeRef) {\n     let _icx = cx.insn_ctxt(\"memzero\");\n     let ccx = cx.ccx();\n \n-    let intrinsic_key;\n-    match ccx.sess.targ_cfg.arch {\n-        X86 | Arm | Mips => {\n-            intrinsic_key = ~\"llvm.memset.p0i8.i32\";\n-        }\n-        X86_64 => {\n-            intrinsic_key = ~\"llvm.memset.p0i8.i64\";\n-        }\n-    }\n+    let intrinsic_key = match ccx.sess.targ_cfg.arch {\n+        X86 | Arm | Mips => \"llvm.memset.p0i8.i32\",\n+        X86_64 => \"llvm.memset.p0i8.i64\"\n+    };\n \n     let llintrinsicfn = *ccx.intrinsics.get(&intrinsic_key);\n     let llptr = PointerCast(cx, llptr, T_ptr(T_i8()));\n@@ -2512,7 +2503,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::node_id) -> ValueRef {\n                 ast::foreign_item_const(*) => {\n                     let typ = ty::node_id_to_type(tcx, ni.id);\n                     let ident = token::ident_to_str(&ni.ident);\n-                    let g = do str::as_c_str(*ident) |buf| {\n+                    let g = do str::as_c_str(ident) |buf| {\n                         unsafe {\n                             llvm::LLVMAddGlobal(ccx.llmod,\n                                                 type_of(ccx, typ),\n@@ -2607,10 +2598,10 @@ pub fn trans_constant(ccx: @CrateContext, it: @ast::item) {\n                 path_name(variant.node.name),\n                 path_name(special_idents::descrim)\n             ]);\n-            let s = @mangle_exported_name(ccx, p, ty::mk_int());\n+            let s = mangle_exported_name(ccx, p, ty::mk_int()).to_managed();\n             let disr_val = vi[i].disr_val;\n             note_unique_llvm_symbol(ccx, s);\n-            let discrim_gvar = str::as_c_str(*s, |buf| {\n+            let discrim_gvar = str::as_c_str(s, |buf| {\n                 unsafe {\n                     llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)\n                 }\n@@ -2649,7 +2640,7 @@ pub fn p2i(ccx: @CrateContext, v: ValueRef) -> ValueRef {\n     }\n }\n \n-pub fn declare_intrinsics(llmod: ModuleRef) -> HashMap<~str, ValueRef> {\n+pub fn declare_intrinsics(llmod: ModuleRef) -> HashMap<&'static str, ValueRef> {\n     let T_memcpy32_args: ~[TypeRef] =\n         ~[T_ptr(T_i8()), T_ptr(T_i8()), T_i32(), T_i32(), T_i1()];\n     let T_memcpy64_args: ~[TypeRef] =\n@@ -2783,80 +2774,80 @@ pub fn declare_intrinsics(llmod: ModuleRef) -> HashMap<~str, ValueRef> {\n                                 T_fn([T_i64()], T_i64()));\n \n     let mut intrinsics = HashMap::new();\n-    intrinsics.insert(~\"llvm.gcroot\", gcroot);\n-    intrinsics.insert(~\"llvm.gcread\", gcread);\n-    intrinsics.insert(~\"llvm.memcpy.p0i8.p0i8.i32\", memcpy32);\n-    intrinsics.insert(~\"llvm.memcpy.p0i8.p0i8.i64\", memcpy64);\n-    intrinsics.insert(~\"llvm.memmove.p0i8.p0i8.i32\", memmove32);\n-    intrinsics.insert(~\"llvm.memmove.p0i8.p0i8.i64\", memmove64);\n-    intrinsics.insert(~\"llvm.memset.p0i8.i32\", memset32);\n-    intrinsics.insert(~\"llvm.memset.p0i8.i64\", memset64);\n-    intrinsics.insert(~\"llvm.trap\", trap);\n-    intrinsics.insert(~\"llvm.frameaddress\", frameaddress);\n-    intrinsics.insert(~\"llvm.sqrt.f32\", sqrtf32);\n-    intrinsics.insert(~\"llvm.sqrt.f64\", sqrtf64);\n-    intrinsics.insert(~\"llvm.powi.f32\", powif32);\n-    intrinsics.insert(~\"llvm.powi.f64\", powif64);\n-    intrinsics.insert(~\"llvm.sin.f32\", sinf32);\n-    intrinsics.insert(~\"llvm.sin.f64\", sinf64);\n-    intrinsics.insert(~\"llvm.cos.f32\", cosf32);\n-    intrinsics.insert(~\"llvm.cos.f64\", cosf64);\n-    intrinsics.insert(~\"llvm.pow.f32\", powf32);\n-    intrinsics.insert(~\"llvm.pow.f64\", powf64);\n-    intrinsics.insert(~\"llvm.exp.f32\", expf32);\n-    intrinsics.insert(~\"llvm.exp.f64\", expf64);\n-    intrinsics.insert(~\"llvm.exp2.f32\", exp2f32);\n-    intrinsics.insert(~\"llvm.exp2.f64\", exp2f64);\n-    intrinsics.insert(~\"llvm.log.f32\", logf32);\n-    intrinsics.insert(~\"llvm.log.f64\", logf64);\n-    intrinsics.insert(~\"llvm.log10.f32\", log10f32);\n-    intrinsics.insert(~\"llvm.log10.f64\", log10f64);\n-    intrinsics.insert(~\"llvm.log2.f32\", log2f32);\n-    intrinsics.insert(~\"llvm.log2.f64\", log2f64);\n-    intrinsics.insert(~\"llvm.fma.f32\", fmaf32);\n-    intrinsics.insert(~\"llvm.fma.f64\", fmaf64);\n-    intrinsics.insert(~\"llvm.fabs.f32\", fabsf32);\n-    intrinsics.insert(~\"llvm.fabs.f64\", fabsf64);\n-    intrinsics.insert(~\"llvm.floor.f32\", floorf32);\n-    intrinsics.insert(~\"llvm.floor.f64\", floorf64);\n-    intrinsics.insert(~\"llvm.ceil.f32\", ceilf32);\n-    intrinsics.insert(~\"llvm.ceil.f64\", ceilf64);\n-    intrinsics.insert(~\"llvm.trunc.f32\", truncf32);\n-    intrinsics.insert(~\"llvm.trunc.f64\", truncf64);\n-    intrinsics.insert(~\"llvm.ctpop.i8\", ctpop8);\n-    intrinsics.insert(~\"llvm.ctpop.i16\", ctpop16);\n-    intrinsics.insert(~\"llvm.ctpop.i32\", ctpop32);\n-    intrinsics.insert(~\"llvm.ctpop.i64\", ctpop64);\n-    intrinsics.insert(~\"llvm.ctlz.i8\", ctlz8);\n-    intrinsics.insert(~\"llvm.ctlz.i16\", ctlz16);\n-    intrinsics.insert(~\"llvm.ctlz.i32\", ctlz32);\n-    intrinsics.insert(~\"llvm.ctlz.i64\", ctlz64);\n-    intrinsics.insert(~\"llvm.cttz.i8\", cttz8);\n-    intrinsics.insert(~\"llvm.cttz.i16\", cttz16);\n-    intrinsics.insert(~\"llvm.cttz.i32\", cttz32);\n-    intrinsics.insert(~\"llvm.cttz.i64\", cttz64);\n-    intrinsics.insert(~\"llvm.bswap.i16\", bswap16);\n-    intrinsics.insert(~\"llvm.bswap.i32\", bswap32);\n-    intrinsics.insert(~\"llvm.bswap.i64\", bswap64);\n+    intrinsics.insert(\"llvm.gcroot\", gcroot);\n+    intrinsics.insert(\"llvm.gcread\", gcread);\n+    intrinsics.insert(\"llvm.memcpy.p0i8.p0i8.i32\", memcpy32);\n+    intrinsics.insert(\"llvm.memcpy.p0i8.p0i8.i64\", memcpy64);\n+    intrinsics.insert(\"llvm.memmove.p0i8.p0i8.i32\", memmove32);\n+    intrinsics.insert(\"llvm.memmove.p0i8.p0i8.i64\", memmove64);\n+    intrinsics.insert(\"llvm.memset.p0i8.i32\", memset32);\n+    intrinsics.insert(\"llvm.memset.p0i8.i64\", memset64);\n+    intrinsics.insert(\"llvm.trap\", trap);\n+    intrinsics.insert(\"llvm.frameaddress\", frameaddress);\n+    intrinsics.insert(\"llvm.sqrt.f32\", sqrtf32);\n+    intrinsics.insert(\"llvm.sqrt.f64\", sqrtf64);\n+    intrinsics.insert(\"llvm.powi.f32\", powif32);\n+    intrinsics.insert(\"llvm.powi.f64\", powif64);\n+    intrinsics.insert(\"llvm.sin.f32\", sinf32);\n+    intrinsics.insert(\"llvm.sin.f64\", sinf64);\n+    intrinsics.insert(\"llvm.cos.f32\", cosf32);\n+    intrinsics.insert(\"llvm.cos.f64\", cosf64);\n+    intrinsics.insert(\"llvm.pow.f32\", powf32);\n+    intrinsics.insert(\"llvm.pow.f64\", powf64);\n+    intrinsics.insert(\"llvm.exp.f32\", expf32);\n+    intrinsics.insert(\"llvm.exp.f64\", expf64);\n+    intrinsics.insert(\"llvm.exp2.f32\", exp2f32);\n+    intrinsics.insert(\"llvm.exp2.f64\", exp2f64);\n+    intrinsics.insert(\"llvm.log.f32\", logf32);\n+    intrinsics.insert(\"llvm.log.f64\", logf64);\n+    intrinsics.insert(\"llvm.log10.f32\", log10f32);\n+    intrinsics.insert(\"llvm.log10.f64\", log10f64);\n+    intrinsics.insert(\"llvm.log2.f32\", log2f32);\n+    intrinsics.insert(\"llvm.log2.f64\", log2f64);\n+    intrinsics.insert(\"llvm.fma.f32\", fmaf32);\n+    intrinsics.insert(\"llvm.fma.f64\", fmaf64);\n+    intrinsics.insert(\"llvm.fabs.f32\", fabsf32);\n+    intrinsics.insert(\"llvm.fabs.f64\", fabsf64);\n+    intrinsics.insert(\"llvm.floor.f32\", floorf32);\n+    intrinsics.insert(\"llvm.floor.f64\", floorf64);\n+    intrinsics.insert(\"llvm.ceil.f32\", ceilf32);\n+    intrinsics.insert(\"llvm.ceil.f64\", ceilf64);\n+    intrinsics.insert(\"llvm.trunc.f32\", truncf32);\n+    intrinsics.insert(\"llvm.trunc.f64\", truncf64);\n+    intrinsics.insert(\"llvm.ctpop.i8\", ctpop8);\n+    intrinsics.insert(\"llvm.ctpop.i16\", ctpop16);\n+    intrinsics.insert(\"llvm.ctpop.i32\", ctpop32);\n+    intrinsics.insert(\"llvm.ctpop.i64\", ctpop64);\n+    intrinsics.insert(\"llvm.ctlz.i8\", ctlz8);\n+    intrinsics.insert(\"llvm.ctlz.i16\", ctlz16);\n+    intrinsics.insert(\"llvm.ctlz.i32\", ctlz32);\n+    intrinsics.insert(\"llvm.ctlz.i64\", ctlz64);\n+    intrinsics.insert(\"llvm.cttz.i8\", cttz8);\n+    intrinsics.insert(\"llvm.cttz.i16\", cttz16);\n+    intrinsics.insert(\"llvm.cttz.i32\", cttz32);\n+    intrinsics.insert(\"llvm.cttz.i64\", cttz64);\n+    intrinsics.insert(\"llvm.bswap.i16\", bswap16);\n+    intrinsics.insert(\"llvm.bswap.i32\", bswap32);\n+    intrinsics.insert(\"llvm.bswap.i64\", bswap64);\n \n     return intrinsics;\n }\n \n pub fn declare_dbg_intrinsics(llmod: ModuleRef,\n-                              intrinsics: &mut HashMap<~str, ValueRef>) {\n+                              intrinsics: &mut HashMap<&'static str, ValueRef>) {\n     let declare =\n         decl_cdecl_fn(llmod, \"llvm.dbg.declare\",\n                       T_fn([T_metadata(), T_metadata()], T_void()));\n     let value =\n         decl_cdecl_fn(llmod, \"llvm.dbg.value\",\n                       T_fn([T_metadata(), T_i64(), T_metadata()], T_void()));\n-    intrinsics.insert(~\"llvm.dbg.declare\", declare);\n-    intrinsics.insert(~\"llvm.dbg.value\", value);\n+    intrinsics.insert(\"llvm.dbg.declare\", declare);\n+    intrinsics.insert(\"llvm.dbg.value\", value);\n }\n \n pub fn trap(bcx: block) {\n     let v: ~[ValueRef] = ~[];\n-    match bcx.ccx().intrinsics.find(&~\"llvm.trap\") {\n+    match bcx.ccx().intrinsics.find(& &\"llvm.trap\") {\n       Some(&x) => { Call(bcx, x, v); },\n       _ => bcx.sess().bug(\"unbound llvm.trap in trap\")\n     }\n@@ -2891,7 +2882,7 @@ pub fn create_module_map(ccx: @CrateContext) -> ValueRef {\n     lib::llvm::SetLinkage(map, lib::llvm::InternalLinkage);\n     let mut elts: ~[ValueRef] = ~[];\n     for ccx.module_data.each |key, &val| {\n-        let elt = C_struct([p2i(ccx, C_cstr(ccx, @/*bad*/ copy *key)),\n+        let elt = C_struct([p2i(ccx, C_cstr(ccx, /* bad */key.to_managed())),\n                             p2i(ccx, val)]);\n         elts.push(elt);\n     }\n@@ -2934,9 +2925,10 @@ pub fn fill_crate_map(ccx: @CrateContext, map: ValueRef) {\n     let cstore = ccx.sess.cstore;\n     while cstore::have_crate_data(cstore, i) {\n         let cdata = cstore::get_crate_data(cstore, i);\n-        let nm = ~\"_rust_crate_map_\" + *cdata.name +\n-            \"_\" + *cstore::get_crate_vers(cstore, i) +\n-            \"_\" + *cstore::get_crate_hash(cstore, i);\n+        let nm = fmt!(\"_rust_crate_map_%s_%s_%s\",\n+                      cdata.name,\n+                      cstore::get_crate_vers(cstore, i),\n+                      cstore::get_crate_hash(cstore, i));\n         let cr = str::as_c_str(nm, |buf| {\n             unsafe {\n                 llvm::LLVMAddGlobal(ccx.llmod, ccx.int_type, buf)"}, {"sha": "7e47fc47bffcce30acc7791a5b2c73111c313b8a", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -165,15 +165,15 @@ pub struct CrateContext {\n      td: TargetData,\n      tn: @TypeNames,\n      externs: ExternMap,\n-     intrinsics: HashMap<~str, ValueRef>,\n+     intrinsics: HashMap<&'static str, ValueRef>,\n      item_vals: @mut HashMap<ast::node_id, ValueRef>,\n      exp_map2: resolve::ExportMap2,\n      reachable: reachable::map,\n      item_symbols: @mut HashMap<ast::node_id, ~str>,\n      link_meta: LinkMeta,\n      enum_sizes: @mut HashMap<ty::t, uint>,\n      discrims: @mut HashMap<ast::def_id, ValueRef>,\n-     discrim_symbols: @mut HashMap<ast::node_id, @~str>,\n+     discrim_symbols: @mut HashMap<ast::node_id, @str>,\n      tydescs: @mut HashMap<ty::t, @mut tydesc_info>,\n      // Set when running emit_tydescs to enforce that no more tydescs are\n      // created.\n@@ -188,7 +188,7 @@ pub struct CrateContext {\n      // Cache generated vtables\n      vtables: @mut HashMap<mono_id, ValueRef>,\n      // Cache of constant strings,\n-     const_cstr_cache: @mut HashMap<@~str, ValueRef>,\n+     const_cstr_cache: @mut HashMap<@str, ValueRef>,\n \n      // Reverse-direction for const ptrs cast from globals.\n      // Key is an int, cast from a ValueRef holding a *T,\n@@ -215,7 +215,7 @@ pub struct CrateContext {\n      symbol_hasher: @mut hash::State,\n      type_hashcodes: @mut HashMap<ty::t, @str>,\n      type_short_names: @mut HashMap<ty::t, ~str>,\n-     all_llvm_symbols: @mut HashSet<@~str>,\n+     all_llvm_symbols: @mut HashSet<@str>,\n      tcx: ty::ctxt,\n      maps: astencode::Maps,\n      stats: @mut Stats,\n@@ -1176,14 +1176,14 @@ pub fn C_u8(i: uint) -> ValueRef {\n \n // This is a 'c-like' raw string, which differs from\n // our boxed-and-length-annotated strings.\n-pub fn C_cstr(cx: @CrateContext, s: @~str) -> ValueRef {\n+pub fn C_cstr(cx: @CrateContext, s: @str) -> ValueRef {\n     unsafe {\n         match cx.const_cstr_cache.find(&s) {\n             Some(&llval) => return llval,\n             None => ()\n         }\n \n-        let sc = do str::as_c_str(*s) |buf| {\n+        let sc = do str::as_c_str(s) |buf| {\n             llvm::LLVMConstStringInContext(cx.llcx, buf, s.len() as c_uint,\n                                            False)\n         };\n@@ -1202,7 +1202,7 @@ pub fn C_cstr(cx: @CrateContext, s: @~str) -> ValueRef {\n \n // NB: Do not use `do_spill_noroot` to make this into a constant string, or\n // you will be kicked off fast isel. See issue #4352 for an example of this.\n-pub fn C_estr_slice(cx: @CrateContext, s: @~str) -> ValueRef {\n+pub fn C_estr_slice(cx: @CrateContext, s: @str) -> ValueRef {\n     unsafe {\n         let len = s.len();\n         let cs = llvm::LLVMConstPointerCast(C_cstr(cx, s), T_ptr(T_i8()));\n@@ -1441,7 +1441,7 @@ pub fn path_str(sess: session::Session, p: &[path_elt]) -> ~str {\n             ast_map::path_name(s) | ast_map::path_mod(s) => {\n                 if first { first = false; }\n                 else { r += \"::\"; }\n-                r += *sess.str_of(s);\n+                r += sess.str_of(s);\n             }\n         }\n     }\n@@ -1564,7 +1564,7 @@ pub fn dummy_substs(tps: ~[ty::t]) -> ty::substs {\n pub fn filename_and_line_num_from_span(bcx: block,\n                                        span: span) -> (ValueRef, ValueRef) {\n     let loc = bcx.sess().parse_sess.cm.lookup_char_pos(span.lo);\n-    let filename_cstr = C_cstr(bcx.ccx(), @/*bad*/copy loc.file.name);\n+    let filename_cstr = C_cstr(bcx.ccx(), loc.file.name);\n     let filename = build::PointerCast(bcx, filename_cstr, T_ptr(T_i8()));\n     let line = C_int(bcx.ccx(), loc.line as int);\n     (filename, line)"}, {"sha": "39360f0d3fc918e70c83f19cab81c3dea9035a44", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -54,12 +54,12 @@ pub fn const_lit(cx: @CrateContext, e: @ast::expr, lit: ast::lit)\n                         ty_to_str(cx.tcx, lit_int_ty)))\n         }\n       }\n-      ast::lit_float(fs, t) => C_floating(/*bad*/copy *fs, T_float_ty(cx, t)),\n+      ast::lit_float(fs, t) => C_floating(fs, T_float_ty(cx, t)),\n       ast::lit_float_unsuffixed(fs) => {\n         let lit_float_ty = ty::node_id_to_type(cx.tcx, e.id);\n         match ty::get(lit_float_ty).sty {\n           ty::ty_float(t) => {\n-            C_floating(/*bad*/copy *fs, T_float_ty(cx, t))\n+            C_floating(fs, T_float_ty(cx, t))\n           }\n           _ => {\n             cx.sess.span_bug(lit.span,"}, {"sha": "fe3e2940907b7a6c33a5a38443952b9306b6529c", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -348,13 +348,13 @@ pub fn trans_fail_expr(bcx: block,\n                     ppaux::ty_to_str(tcx, arg_datum.ty));\n             }\n         }\n-        _ => trans_fail(bcx, sp_opt, @~\"explicit failure\")\n+        _ => trans_fail(bcx, sp_opt, @\"explicit failure\")\n     }\n }\n \n pub fn trans_fail(bcx: block,\n                   sp_opt: Option<span>,\n-                  fail_str: @~str)\n+                  fail_str: @str)\n                -> block {\n     let _icx = bcx.insn_ctxt(\"trans_fail\");\n     let V_fail_str = C_cstr(bcx.ccx(), fail_str);\n@@ -371,11 +371,11 @@ fn trans_fail_value(bcx: block,\n       Some(sp) => {\n         let sess = bcx.sess();\n         let loc = sess.parse_sess.cm.lookup_char_pos(sp.lo);\n-        (C_cstr(bcx.ccx(), @/*bad*/ copy loc.file.name),\n+        (C_cstr(bcx.ccx(), loc.file.name),\n          loc.line as int)\n       }\n       None => {\n-        (C_cstr(bcx.ccx(), @~\"<runtime>\"), 0)\n+        (C_cstr(bcx.ccx(), @\"<runtime>\"), 0)\n       }\n     };\n     let V_str = PointerCast(bcx, V_fail_str, T_ptr(T_i8()));"}, {"sha": "3bb9d4abab0f7b0de404e7c0c86b72f06c5c95c5", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -316,7 +316,7 @@ fn create_block(cx: block) -> @Metadata<BlockMetadata> {\n         None => create_function(cx.fcx).node,\n         Some(bcx) => create_block(bcx).node\n     };\n-    let file_node = create_file(cx.ccx(), fname);\n+    let file_node = create_file(cx.ccx(), /* bad */ fname.to_owned());\n     let unique_id = match cache.find(&LexicalBlockTag) {\n       option::Some(v) => v.len() as int,\n       option::None => 0\n@@ -383,7 +383,7 @@ fn create_basic_type(cx: @CrateContext, t: ty::t, span: span)\n     };\n \n     let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname);\n+    let file_node = create_file(cx, fname.to_owned());\n     let cu_node = create_compile_unit(cx);\n     let (size, align) = size_and_align_of(cx, t);\n     let lldata = ~[lltag(tg),\n@@ -420,7 +420,7 @@ fn create_pointer_type(cx: @CrateContext, t: ty::t, span: span,\n     }*/\n     let (size, align) = size_and_align_of(cx, t);\n     let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname);\n+    let file_node = create_file(cx, fname.to_owned());\n     //let cu_node = create_compile_unit(cx, fname);\n     let name = ty_to_str(cx.tcx, t);\n     let llnode = create_derived_type(tg, file_node.node, name, 0, size * 8,\n@@ -438,7 +438,7 @@ fn create_pointer_type(cx: @CrateContext, t: ty::t, span: span,\n \n struct StructCtxt {\n     file: ValueRef,\n-    name: @~str,\n+    name: @str,\n     line: int,\n     members: ~[ValueRef],\n     total_size: int,\n@@ -447,7 +447,7 @@ struct StructCtxt {\n \n fn finish_structure(cx: @mut StructCtxt) -> ValueRef {\n     return create_composite_type(StructureTypeTag,\n-                                 *cx.name,\n+                                 cx.name,\n                                  cx.file,\n                                  cx.line,\n                                  cx.total_size,\n@@ -457,7 +457,7 @@ fn finish_structure(cx: @mut StructCtxt) -> ValueRef {\n                                  Some(/*bad*/copy cx.members));\n }\n \n-fn create_structure(file: @Metadata<FileMetadata>, name: @~str, line: int)\n+fn create_structure(file: @Metadata<FileMetadata>, name: @str, line: int)\n                  -> @mut StructCtxt {\n     let cx = @mut StructCtxt {\n         file: file.node,\n@@ -501,14 +501,14 @@ fn add_member(cx: @mut StructCtxt,\n fn create_struct(cx: @CrateContext, t: ty::t, fields: ~[ty::field],\n                  span: span) -> @Metadata<TyDescMetadata> {\n     let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname);\n-    let scx = create_structure(file_node, @ty_to_str(cx.tcx, t),\n+    let file_node = create_file(cx, fname.to_owned());\n+    let scx = create_structure(file_node, (ty_to_str(cx.tcx, t)).to_managed(),\n                                line_from_span(cx.sess.codemap, span) as int);\n     for fields.each |field| {\n         let field_t = field.mt.ty;\n         let ty_md = create_ty(cx, field_t, span);\n         let (size, align) = size_and_align_of(cx, field_t);\n-        add_member(scx, *cx.sess.str_of(field.ident),\n+        add_member(scx, cx.sess.str_of(field.ident),\n                    line_from_span(cx.sess.codemap, span) as int,\n                    size as int, align as int, ty_md.node);\n     }\n@@ -524,7 +524,7 @@ fn create_struct(cx: @CrateContext, t: ty::t, fields: ~[ty::field],\n fn create_tuple(cx: @CrateContext, t: ty::t, elements: &[ty::t], span: span)\n     -> @Metadata<TyDescMetadata> {\n     let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname);\n+    let file_node = create_file(cx, fname.to_owned());\n     let scx = create_structure(file_node,\n                                cx.sess.str_of(\n                                    ((/*bad*/copy cx.dbg_cx).get().names)\n@@ -566,12 +566,12 @@ fn create_boxed_type(cx: @CrateContext, contents: ty::t,\n       option::None {}\n     }*/\n     let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname);\n+    let file_node = create_file(cx, fname.to_owned());\n     //let cu_node = create_compile_unit_metadata(cx, fname);\n     let int_t = ty::mk_int();\n     let refcount_type = create_basic_type(cx, int_t, span);\n     let name = ty_to_str(cx.tcx, contents);\n-    let scx = create_structure(file_node, @fmt!(\"box<%s>\", name), 0);\n+    let scx = create_structure(file_node, (fmt!(\"box<%s>\", name)).to_managed(), 0);\n     add_member(scx, \"refcnt\", 0, sys::size_of::<uint>() as int,\n                sys::min_align_of::<uint>() as int, refcount_type.node);\n     // the tydesc and other pointers should be irrelevant to the\n@@ -628,7 +628,7 @@ fn create_fixed_vec(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t,\n                     len: int, span: span) -> @Metadata<TyDescMetadata> {\n     let t_md = create_ty(cx, elem_t, span);\n     let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname);\n+    let file_node = create_file(cx, fname.to_owned());\n     let (size, align) = size_and_align_of(cx, elem_t);\n     let subrange = llmdnode([lltag(SubrangeTag), lli64(0), lli64(len - 1)]);\n     let name = fmt!(\"[%s]\", ty_to_str(cx.tcx, elem_t));\n@@ -647,10 +647,10 @@ fn create_boxed_vec(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t,\n                     vec_ty_span: codemap::span)\n     -> @Metadata<TyDescMetadata> {\n     let fname = filename_from_span(cx, vec_ty_span);\n-    let file_node = create_file(cx, fname);\n+    let file_node = create_file(cx, fname.to_owned());\n     let elem_ty_md = create_ty(cx, elem_t, vec_ty_span);\n     let vec_scx = create_structure(file_node,\n-                               @/*bad*/ copy ty_to_str(cx.tcx, vec_t), 0);\n+                               ty_to_str(cx.tcx, vec_t).to_managed(), 0);\n     let size_t_type = create_basic_type(cx, ty::mk_uint(), vec_ty_span);\n     add_member(vec_scx, \"fill\", 0, sys::size_of::<libc::size_t>() as int,\n                sys::min_align_of::<libc::size_t>() as int, size_t_type.node);\n@@ -673,7 +673,7 @@ fn create_boxed_vec(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t,\n         }\n     };\n \n-    let box_scx = create_structure(file_node, @fmt!(\"box<%s>\", name), 0);\n+    let box_scx = create_structure(file_node, (fmt!(\"box<%s>\", name)).to_managed(), 0);\n     let int_t = ty::mk_int();\n     let refcount_type = create_basic_type(cx, int_t, vec_ty_span);\n     add_member(box_scx, \"refcnt\", 0, sys::size_of::<uint>() as int,\n@@ -698,11 +698,11 @@ fn create_boxed_vec(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t,\n fn create_vec_slice(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t, span: span)\n     -> @Metadata<TyDescMetadata> {\n     let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname);\n+    let file_node = create_file(cx, fname.to_owned());\n     let elem_ty_md = create_ty(cx, elem_t, span);\n     let uint_type = create_basic_type(cx, ty::mk_uint(), span);\n     let elem_ptr = create_pointer_type(cx, elem_t, span, elem_ty_md);\n-    let scx = create_structure(file_node, @ty_to_str(cx.tcx, vec_t), 0);\n+    let scx = create_structure(file_node, ty_to_str(cx.tcx, vec_t).to_managed(), 0);\n     let (_, ptr_size, ptr_align) = voidptr();\n     add_member(scx, \"vec\", 0, ptr_size, ptr_align, elem_ptr.node);\n     add_member(scx, \"length\", 0, sys::size_of::<uint>() as int,\n@@ -720,7 +720,7 @@ fn create_vec_slice(cx: @CrateContext, vec_t: ty::t, elem_t: ty::t, span: span)\n fn create_fn_ty(cx: @CrateContext, fn_ty: ty::t, inputs: ~[ty::t], output: ty::t,\n                 span: span) -> @Metadata<TyDescMetadata> {\n     let fname = filename_from_span(cx, span);\n-    let file_node = create_file(cx, fname);\n+    let file_node = create_file(cx, fname.to_owned());\n     let (vp, _, _) = voidptr();\n     let output_md = create_ty(cx, output, span);\n     let output_ptr_md = create_pointer_type(cx, output, span, output_md);\n@@ -817,8 +817,8 @@ fn create_ty(cx: @CrateContext, t: ty::t, span: span)\n     }\n }\n \n-fn filename_from_span(cx: @CrateContext, sp: codemap::span) -> ~str {\n-    /*bad*/copy cx.sess.codemap.lookup_char_pos(sp.lo).file.name\n+fn filename_from_span(cx: @CrateContext, sp: codemap::span) -> @str {\n+    cx.sess.codemap.lookup_char_pos(sp.lo).file.name\n }\n \n fn create_var(type_tag: int, context: ValueRef, name: &str, file: ValueRef,\n@@ -853,12 +853,12 @@ pub fn create_local_var(bcx: block, local: @ast::local)\n     let loc = cx.sess.codemap.lookup_char_pos(local.span.lo);\n     let ty = node_id_type(bcx, local.node.id);\n     let tymd = create_ty(cx, ty, local.node.ty.span);\n-    let filemd = create_file(cx, /*bad*/copy loc.file.name);\n+    let filemd = create_file(cx, /*bad*/ loc.file.name.to_owned());\n     let context = match bcx.parent {\n         None => create_function(bcx.fcx).node,\n         Some(_) => create_block(bcx).node\n     };\n-    let mdnode = create_var(tg, context, *cx.sess.str_of(name),\n+    let mdnode = create_var(tg, context, cx.sess.str_of(name),\n                             filemd.node, loc.line as int, tymd.node);\n     let mdval = @Metadata {\n         node: mdnode,\n@@ -878,7 +878,7 @@ pub fn create_local_var(bcx: block, local: @ast::local)\n         }\n     };\n     let declargs = ~[llmdnode([llptr]), mdnode];\n-    trans::build::Call(bcx, *cx.intrinsics.get(&~\"llvm.dbg.declare\"),\n+    trans::build::Call(bcx, *cx.intrinsics.get(&(\"llvm.dbg.declare\")),\n                        declargs);\n     return mdval;\n }\n@@ -896,12 +896,12 @@ pub fn create_arg(bcx: block, arg: ast::arg, sp: span)\n     }\n \n     let loc = cx.sess.codemap.lookup_char_pos(sp.lo);\n-    if loc.file.name == ~\"<intrinsic>\" {\n+    if \"<intrinsic>\" == loc.file.name {\n         return None;\n     }\n     let ty = node_id_type(bcx, arg.id);\n     let tymd = create_ty(cx, ty, arg.ty.span);\n-    let filemd = create_file(cx, /*bad*/copy loc.file.name);\n+    let filemd = create_file(cx, /* bad */ loc.file.name.to_owned());\n     let context = create_function(bcx.fcx);\n \n     match arg.pat.node {\n@@ -910,7 +910,7 @@ pub fn create_arg(bcx: block, arg: ast::arg, sp: span)\n             let mdnode = create_var(\n                 tg,\n                 context.node,\n-                *cx.sess.str_of(*path.idents.last()),\n+                cx.sess.str_of(*path.idents.last()),\n                 filemd.node,\n                 loc.line as int,\n                 tymd.node\n@@ -927,7 +927,7 @@ pub fn create_arg(bcx: block, arg: ast::arg, sp: span)\n             let llptr = fcx.llargs.get_copy(&arg.id);\n             let declargs = ~[llmdnode([llptr]), mdnode];\n             trans::build::Call(bcx,\n-                               *cx.intrinsics.get(&~\"llvm.dbg.declare\"),\n+                               *cx.intrinsics.get(&(\"llvm.dbg.declare\")),\n                                declargs);\n             return Some(mdval);\n         }\n@@ -1000,7 +1000,7 @@ pub fn create_function(fcx: fn_ctxt) -> @Metadata<SubProgramMetadata> {\n     }\n \n     let loc = cx.sess.codemap.lookup_char_pos(sp.lo);\n-    let file_node = create_file(cx, copy loc.file.name).node;\n+    let file_node = create_file(cx, loc.file.name.to_owned()).node;\n     let ty_node = if cx.sess.opts.extra_debuginfo {\n         match ret_ty.node {\n           ast::ty_nil => llnull(),\n@@ -1017,9 +1017,9 @@ pub fn create_function(fcx: fn_ctxt) -> @Metadata<SubProgramMetadata> {\n     let fn_metadata = ~[lltag(SubprogramTag),\n                        llunused(),\n                        file_node,\n-                       llstr(*cx.sess.str_of(ident)),\n+                       llstr(cx.sess.str_of(ident)),\n                         //XXX fully-qualified C++ name:\n-                       llstr(*cx.sess.str_of(ident)),\n+                       llstr(cx.sess.str_of(ident)),\n                        llstr(\"\"), //XXX MIPS name?????\n                        file_node,\n                        lli32(loc.line as int),"}, {"sha": "13fc610e94a8db08ecaa4c714cca34c5e34c91cc", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -452,7 +452,7 @@ fn trans_to_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n fn trans_rvalue_datum_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n     let _icx = bcx.insn_ctxt(\"trans_rvalue_datum_unadjusted\");\n \n-    trace_span!(bcx, expr.span, @shorten(bcx.expr_to_str(expr)));\n+    trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n \n     match expr.node {\n         ast::expr_path(_) | ast::expr_self => {\n@@ -507,7 +507,7 @@ fn trans_rvalue_stmt_unadjusted(bcx: block, expr: @ast::expr) -> block {\n         return bcx;\n     }\n \n-    trace_span!(bcx, expr.span, @shorten(bcx.expr_to_str(expr)));\n+    trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n \n     match expr.node {\n         ast::expr_break(label_opt) => {\n@@ -560,7 +560,7 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n     let _icx = bcx.insn_ctxt(\"trans_rvalue_dps_unadjusted\");\n     let tcx = bcx.tcx();\n \n-    trace_span!(bcx, expr.span, @shorten(bcx.expr_to_str(expr)));\n+    trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n \n     match expr.node {\n         ast::expr_paren(e) => {\n@@ -821,7 +821,7 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n     debug!(\"trans_lvalue(expr=%s)\", bcx.expr_to_str(expr));\n     let _indenter = indenter();\n \n-    trace_span!(bcx, expr.span, @shorten(bcx.expr_to_str(expr)));\n+    trace_span!(bcx, expr.span, shorten(bcx.expr_to_str(expr)));\n \n     return match expr.node {\n         ast::expr_paren(e) => {\n@@ -1703,6 +1703,6 @@ fn trans_assign_op(bcx: block,\n     return result_datum.copy_to_datum(bcx, DROP_EXISTING, dst_datum);\n }\n \n-fn shorten(x: ~str) -> ~str {\n-    if x.char_len() > 60 { x.slice_chars(0, 60).to_owned() } else { x }\n+fn shorten(x: &str) -> @str {\n+    (if x.char_len() > 60 {x.slice_chars(0, 60)} else {x}).to_managed()\n }"}, {"sha": "094c202b12174596f891acd7e7197a419c46c0c1", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 143, "deletions": 143, "changes": 286, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -55,7 +55,7 @@ fn abi_info(ccx: @CrateContext) -> @cabi::ABIInfo {\n     }\n }\n \n-pub fn link_name(ccx: @CrateContext, i: @ast::foreign_item) -> @~str {\n+pub fn link_name(ccx: @CrateContext, i: @ast::foreign_item) -> @str {\n      match attr::first_attr_value_str_by_name(i.attrs, \"link_name\") {\n         None => ccx.sess.str_of(i.ident),\n         Some(ln) => ln,\n@@ -345,7 +345,7 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n             }\n             ast::foreign_item_const(*) => {\n                 let ident = token::ident_to_str(&foreign_item.ident);\n-                ccx.item_symbols.insert(foreign_item.id, copy *ident);\n+                ccx.item_symbols.insert(foreign_item.id, /* bad */ident.to_owned());\n             }\n         }\n     }\n@@ -403,9 +403,9 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n         }\n \n         let lname = link_name(ccx, foreign_item);\n-        let llbasefn = base_fn(ccx, *lname, tys, cc);\n+        let llbasefn = base_fn(ccx, lname, tys, cc);\n         // Name the shim function\n-        let shim_name = *lname + \"__c_stack_shim\";\n+        let shim_name = fmt!(\"%s__c_stack_shim\", lname);\n         build_shim_fn_(ccx,\n                        shim_name,\n                        llbasefn,\n@@ -433,12 +433,12 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n                        item: @ast::foreign_item,\n                        tys: &ShimTypes,\n                        cc: lib::llvm::CallConv) {\n-        debug!(\"build_direct_fn(%s)\", *link_name(ccx, item));\n+        debug!(\"build_direct_fn(%s)\", link_name(ccx, item));\n \n         let fcx = new_fn_ctxt(ccx, ~[], decl, tys.fn_sig.output, None);\n         let bcx = top_scope_block(fcx, None);\n         let lltop = bcx.llbb;\n-        let llbasefn = base_fn(ccx, *link_name(ccx, item), tys, cc);\n+        let llbasefn = base_fn(ccx, link_name(ccx, item), tys, cc);\n         let ty = ty::lookup_item_type(ccx.tcx,\n                                       ast_util::local_def(item.id)).ty;\n         let ret_ty = ty::ty_fn_ret(ty);\n@@ -460,12 +460,12 @@ pub fn trans_foreign_mod(ccx: @CrateContext,\n                          item: @ast::foreign_item,\n                          tys: &ShimTypes,\n                          cc: lib::llvm::CallConv) {\n-        debug!(\"build_fast_ffi_fn(%s)\", *link_name(ccx, item));\n+        debug!(\"build_fast_ffi_fn(%s)\", link_name(ccx, item));\n \n         let fcx = new_fn_ctxt(ccx, ~[], decl, tys.fn_sig.output, None);\n         let bcx = top_scope_block(fcx, None);\n         let lltop = bcx.llbb;\n-        let llbasefn = base_fn(ccx, *link_name(ccx, item), tys, cc);\n+        let llbasefn = base_fn(ccx, link_name(ccx, item), tys, cc);\n         set_no_inline(fcx.llfn);\n         set_fixed_stack_segment(fcx.llfn);\n         let ty = ty::lookup_item_type(ccx.tcx,\n@@ -553,7 +553,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                        substs: @param_substs,\n                        attributes: &[ast::attribute],\n                        ref_id: Option<ast::node_id>) {\n-    debug!(\"trans_intrinsic(item.ident=%s)\", *ccx.sess.str_of(item.ident));\n+    debug!(\"trans_intrinsic(item.ident=%s)\", ccx.sess.str_of(item.ident));\n \n     let output_type = ty::ty_fn_ret(ty::node_id_to_type(ccx.tcx, item.id));\n \n@@ -574,125 +574,125 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n     let mut bcx = top_scope_block(fcx, None);\n     let lltop = bcx.llbb;\n     let first_real_arg = fcx.arg_pos(0u);\n-    match *ccx.sess.str_of(item.ident) {\n-        ~\"atomic_cxchg\" => {\n+    match ccx.sess.str_of(item.ident).as_slice() {\n+        \"atomic_cxchg\" => {\n             let old = AtomicCmpXchg(bcx,\n                                     get_param(decl, first_real_arg),\n                                     get_param(decl, first_real_arg + 1u),\n                                     get_param(decl, first_real_arg + 2u),\n                                     SequentiallyConsistent);\n             Store(bcx, old, fcx.llretptr.get());\n         }\n-        ~\"atomic_cxchg_acq\" => {\n+        \"atomic_cxchg_acq\" => {\n             let old = AtomicCmpXchg(bcx,\n                                     get_param(decl, first_real_arg),\n                                     get_param(decl, first_real_arg + 1u),\n                                     get_param(decl, first_real_arg + 2u),\n                                     Acquire);\n             Store(bcx, old, fcx.llretptr.get());\n         }\n-        ~\"atomic_cxchg_rel\" => {\n+        \"atomic_cxchg_rel\" => {\n             let old = AtomicCmpXchg(bcx,\n                                     get_param(decl, first_real_arg),\n                                     get_param(decl, first_real_arg + 1u),\n                                     get_param(decl, first_real_arg + 2u),\n                                     Release);\n             Store(bcx, old, fcx.llretptr.get());\n         }\n-        ~\"atomic_load\" => {\n+        \"atomic_load\" => {\n             let old = AtomicLoad(bcx,\n                                  get_param(decl, first_real_arg),\n                                  SequentiallyConsistent);\n             Store(bcx, old, fcx.llretptr.get());\n         }\n-        ~\"atomic_load_acq\" => {\n+        \"atomic_load_acq\" => {\n             let old = AtomicLoad(bcx,\n                                  get_param(decl, first_real_arg),\n                                  Acquire);\n             Store(bcx, old, fcx.llretptr.get());\n         }\n-        ~\"atomic_store\" => {\n+        \"atomic_store\" => {\n             AtomicStore(bcx,\n                         get_param(decl, first_real_arg + 1u),\n                         get_param(decl, first_real_arg),\n                         SequentiallyConsistent);\n         }\n-        ~\"atomic_store_rel\" => {\n+        \"atomic_store_rel\" => {\n             AtomicStore(bcx,\n                         get_param(decl, first_real_arg + 1u),\n                         get_param(decl, first_real_arg),\n                         Release);\n         }\n-        ~\"atomic_xchg\" => {\n+        \"atomic_xchg\" => {\n             let old = AtomicRMW(bcx, Xchg,\n                                 get_param(decl, first_real_arg),\n                                 get_param(decl, first_real_arg + 1u),\n                                 SequentiallyConsistent);\n             Store(bcx, old, fcx.llretptr.get());\n         }\n-        ~\"atomic_xchg_acq\" => {\n+        \"atomic_xchg_acq\" => {\n             let old = AtomicRMW(bcx, Xchg,\n                                 get_param(decl, first_real_arg),\n                                 get_param(decl, first_real_arg + 1u),\n                                 Acquire);\n             Store(bcx, old, fcx.llretptr.get());\n         }\n-        ~\"atomic_xchg_rel\" => {\n+        \"atomic_xchg_rel\" => {\n             let old = AtomicRMW(bcx, Xchg,\n                                 get_param(decl, first_real_arg),\n                                 get_param(decl, first_real_arg + 1u),\n                                 Release);\n             Store(bcx, old, fcx.llretptr.get());\n         }\n-        ~\"atomic_xadd\" => {\n+        \"atomic_xadd\" => {\n             let old = AtomicRMW(bcx, lib::llvm::Add,\n                                 get_param(decl, first_real_arg),\n                                 get_param(decl, first_real_arg + 1u),\n                                 SequentiallyConsistent);\n             Store(bcx, old, fcx.llretptr.get());\n         }\n-        ~\"atomic_xadd_acq\" => {\n+        \"atomic_xadd_acq\" => {\n             let old = AtomicRMW(bcx, lib::llvm::Add,\n                                 get_param(decl, first_real_arg),\n                                 get_param(decl, first_real_arg + 1u),\n                                 Acquire);\n             Store(bcx, old, fcx.llretptr.get());\n         }\n-        ~\"atomic_xadd_rel\" => {\n+        \"atomic_xadd_rel\" => {\n             let old = AtomicRMW(bcx, lib::llvm::Add,\n                                 get_param(decl, first_real_arg),\n                                 get_param(decl, first_real_arg + 1u),\n                                 Release);\n             Store(bcx, old, fcx.llretptr.get());\n         }\n-        ~\"atomic_xsub\" => {\n+        \"atomic_xsub\" => {\n             let old = AtomicRMW(bcx, lib::llvm::Sub,\n                                 get_param(decl, first_real_arg),\n                                 get_param(decl, first_real_arg + 1u),\n                                 SequentiallyConsistent);\n             Store(bcx, old, fcx.llretptr.get());\n         }\n-        ~\"atomic_xsub_acq\" => {\n+        \"atomic_xsub_acq\" => {\n             let old = AtomicRMW(bcx, lib::llvm::Sub,\n                                 get_param(decl, first_real_arg),\n                                 get_param(decl, first_real_arg + 1u),\n                                 Acquire);\n             Store(bcx, old, fcx.llretptr.get());\n         }\n-        ~\"atomic_xsub_rel\" => {\n+        \"atomic_xsub_rel\" => {\n             let old = AtomicRMW(bcx, lib::llvm::Sub,\n                                 get_param(decl, first_real_arg),\n                                 get_param(decl, first_real_arg + 1u),\n                                 Release);\n             Store(bcx, old, fcx.llretptr.get());\n         }\n-        ~\"size_of\" => {\n+        \"size_of\" => {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             Store(bcx, C_uint(ccx, machine::llsize_of_real(ccx, lltp_ty)),\n                   fcx.llretptr.get());\n         }\n-        ~\"move_val\" => {\n+        \"move_val\" => {\n             // Create a datum reflecting the value being moved.\n             // Use `appropriate_mode` so that the datum is by ref\n             // if the value is non-immediate. Note that, with\n@@ -705,27 +705,27 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             bcx = src.move_to(bcx, DROP_EXISTING,\n                               get_param(decl, first_real_arg));\n         }\n-        ~\"move_val_init\" => {\n+        \"move_val_init\" => {\n             // See comments for `\"move_val\"`.\n             let tp_ty = substs.tys[0];\n             let mode = appropriate_mode(tp_ty);\n             let src = Datum {val: get_param(decl, first_real_arg + 1u),\n                              ty: tp_ty, mode: mode};\n             bcx = src.move_to(bcx, INIT, get_param(decl, first_real_arg));\n         }\n-        ~\"min_align_of\" => {\n+        \"min_align_of\" => {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             Store(bcx, C_uint(ccx, machine::llalign_of_min(ccx, lltp_ty)),\n                   fcx.llretptr.get());\n         }\n-        ~\"pref_align_of\"=> {\n+        \"pref_align_of\"=> {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             Store(bcx, C_uint(ccx, machine::llalign_of_pref(ccx, lltp_ty)),\n                   fcx.llretptr.get());\n         }\n-        ~\"get_tydesc\" => {\n+        \"get_tydesc\" => {\n             let tp_ty = substs.tys[0];\n             let static_ti = get_tydesc(ccx, tp_ty);\n             glue::lazily_emit_all_tydesc_glue(ccx, static_ti);\n@@ -735,18 +735,18 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let td = PointerCast(bcx, static_ti.tydesc, T_ptr(T_nil()));\n             Store(bcx, td, fcx.llretptr.get());\n         }\n-        ~\"init\" => {\n+        \"init\" => {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             if !ty::type_is_nil(tp_ty) {\n                 Store(bcx, C_null(lltp_ty), fcx.llretptr.get());\n             }\n         }\n-        ~\"uninit\" => {\n+        \"uninit\" => {\n             // Do nothing, this is effectively a no-op\n         }\n-        ~\"forget\" => {}\n-        ~\"transmute\" => {\n+        \"forget\" => {}\n+        \"transmute\" => {\n             let (in_type, out_type) = (substs.tys[0], substs.tys[1]);\n             let llintype = type_of::type_of(ccx, in_type);\n             let llouttype = type_of::type_of(ccx, out_type);\n@@ -792,13 +792,13 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                 call_memcpy(bcx, lldestptr, llsrcptr, llsize, 1);\n             }\n         }\n-        ~\"needs_drop\" => {\n+        \"needs_drop\" => {\n             let tp_ty = substs.tys[0];\n             Store(bcx,\n                   C_bool(ty::type_needs_drop(ccx.tcx, tp_ty)),\n                   fcx.llretptr.get());\n         }\n-        ~\"visit_tydesc\" => {\n+        \"visit_tydesc\" => {\n             let td = get_param(decl, first_real_arg);\n             let visitor = get_param(decl, first_real_arg + 1u);\n             //let llvisitorptr = alloca(bcx, val_ty(visitor));\n@@ -810,8 +810,8 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                                         abi::tydesc_field_visit_glue,\n                                         None);\n         }\n-        ~\"frame_address\" => {\n-            let frameaddress = *ccx.intrinsics.get(&~\"llvm.frameaddress\");\n+        \"frame_address\" => {\n+            let frameaddress = *ccx.intrinsics.get(& &\"llvm.frameaddress\");\n             let frameaddress_val = Call(bcx, frameaddress, [C_i32(0i32)]);\n             let star_u8 = ty::mk_imm_ptr(\n                 bcx.tcx(),\n@@ -836,7 +836,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                 |bcx| Callee {bcx: bcx, data: Closure(datum)},\n                 ArgVals(arg_vals), Ignore, DontAutorefArg);\n         }\n-        ~\"morestack_addr\" => {\n+        \"morestack_addr\" => {\n             // XXX This is a hack to grab the address of this particular\n             // native function. There should be a general in-language\n             // way to do this\n@@ -847,7 +847,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n                                              T_ptr(T_nil()));\n             Store(bcx, morestack_addr, fcx.llretptr.get());\n         }\n-        ~\"memcpy32\" => {\n+        \"memcpy32\" => {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n@@ -857,10 +857,10 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), T_ptr(T_i8()));\n             let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n-            let llfn = *bcx.ccx().intrinsics.get(&~\"llvm.memcpy.p0i8.p0i8.i32\");\n+            let llfn = *bcx.ccx().intrinsics.get(& &\"llvm.memcpy.p0i8.p0i8.i32\");\n             Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n         }\n-        ~\"memcpy64\" => {\n+        \"memcpy64\" => {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n@@ -870,10 +870,10 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), T_ptr(T_i8()));\n             let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n-            let llfn = *bcx.ccx().intrinsics.get(&~\"llvm.memcpy.p0i8.p0i8.i64\");\n+            let llfn = *bcx.ccx().intrinsics.get(& &\"llvm.memcpy.p0i8.p0i8.i64\");\n             Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n         }\n-        ~\"memmove32\" => {\n+        \"memmove32\" => {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n@@ -883,10 +883,10 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), T_ptr(T_i8()));\n             let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n-            let llfn = *bcx.ccx().intrinsics.get(&~\"llvm.memmove.p0i8.p0i8.i32\");\n+            let llfn = *bcx.ccx().intrinsics.get(& &\"llvm.memmove.p0i8.p0i8.i32\");\n             Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n         }\n-        ~\"memmove64\" => {\n+        \"memmove64\" => {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n@@ -896,10 +896,10 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let src_ptr = PointerCast(bcx, get_param(decl, first_real_arg + 1), T_ptr(T_i8()));\n             let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n-            let llfn = *bcx.ccx().intrinsics.get(&~\"llvm.memmove.p0i8.p0i8.i64\");\n+            let llfn = *bcx.ccx().intrinsics.get(& &\"llvm.memmove.p0i8.p0i8.i64\");\n             Call(bcx, llfn, [dst_ptr, src_ptr, Mul(bcx, size, count), align, volatile]);\n         }\n-        ~\"memset32\" => {\n+        \"memset32\" => {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n@@ -909,10 +909,10 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let val = get_param(decl, first_real_arg + 1);\n             let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n-            let llfn = *bcx.ccx().intrinsics.get(&~\"llvm.memset.p0i8.i32\");\n+            let llfn = *bcx.ccx().intrinsics.get(& &\"llvm.memset.p0i8.i32\");\n             Call(bcx, llfn, [dst_ptr, val, Mul(bcx, size, count), align, volatile]);\n         }\n-        ~\"memset64\" => {\n+        \"memset64\" => {\n             let tp_ty = substs.tys[0];\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n             let align = C_i32(machine::llalign_of_min(ccx, lltp_ty) as i32);\n@@ -922,248 +922,248 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             let val = get_param(decl, first_real_arg + 1);\n             let count = get_param(decl, first_real_arg + 2);\n             let volatile = C_i1(false);\n-            let llfn = *bcx.ccx().intrinsics.get(&~\"llvm.memset.p0i8.i64\");\n+            let llfn = *bcx.ccx().intrinsics.get(& &\"llvm.memset.p0i8.i64\");\n             Call(bcx, llfn, [dst_ptr, val, Mul(bcx, size, count), align, volatile]);\n         }\n-        ~\"sqrtf32\" => {\n+        \"sqrtf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let sqrtf = *ccx.intrinsics.get(&~\"llvm.sqrt.f32\");\n+            let sqrtf = *ccx.intrinsics.get(& &\"llvm.sqrt.f32\");\n             Store(bcx, Call(bcx, sqrtf, [x]), fcx.llretptr.get());\n         }\n-        ~\"sqrtf64\" => {\n+        \"sqrtf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let sqrtf = *ccx.intrinsics.get(&~\"llvm.sqrt.f64\");\n+            let sqrtf = *ccx.intrinsics.get(& &\"llvm.sqrt.f64\");\n             Store(bcx, Call(bcx, sqrtf, [x]), fcx.llretptr.get());\n         }\n-        ~\"powif32\" => {\n+        \"powif32\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n-            let powif = *ccx.intrinsics.get(&~\"llvm.powi.f32\");\n+            let powif = *ccx.intrinsics.get(& &\"llvm.powi.f32\");\n             Store(bcx, Call(bcx, powif, [a, x]), fcx.llretptr.get());\n         }\n-        ~\"powif64\" => {\n+        \"powif64\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n-            let powif = *ccx.intrinsics.get(&~\"llvm.powi.f64\");\n+            let powif = *ccx.intrinsics.get(& &\"llvm.powi.f64\");\n             Store(bcx, Call(bcx, powif, [a, x]), fcx.llretptr.get());\n         }\n-        ~\"sinf32\" => {\n+        \"sinf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let sinf = *ccx.intrinsics.get(&~\"llvm.sin.f32\");\n+            let sinf = *ccx.intrinsics.get(& &\"llvm.sin.f32\");\n             Store(bcx, Call(bcx, sinf, [x]), fcx.llretptr.get());\n         }\n-        ~\"sinf64\" => {\n+        \"sinf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let sinf = *ccx.intrinsics.get(&~\"llvm.sin.f64\");\n+            let sinf = *ccx.intrinsics.get(& &\"llvm.sin.f64\");\n             Store(bcx, Call(bcx, sinf, [x]), fcx.llretptr.get());\n         }\n-        ~\"cosf32\" => {\n+        \"cosf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let cosf = *ccx.intrinsics.get(&~\"llvm.cos.f32\");\n+            let cosf = *ccx.intrinsics.get(& &\"llvm.cos.f32\");\n             Store(bcx, Call(bcx, cosf, [x]), fcx.llretptr.get());\n         }\n-        ~\"cosf64\" => {\n+        \"cosf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let cosf = *ccx.intrinsics.get(&~\"llvm.cos.f64\");\n+            let cosf = *ccx.intrinsics.get(& &\"llvm.cos.f64\");\n             Store(bcx, Call(bcx, cosf, [x]), fcx.llretptr.get());\n         }\n-        ~\"powf32\" => {\n+        \"powf32\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n-            let powf = *ccx.intrinsics.get(&~\"llvm.pow.f32\");\n+            let powf = *ccx.intrinsics.get(& &\"llvm.pow.f32\");\n             Store(bcx, Call(bcx, powf, [a, x]), fcx.llretptr.get());\n         }\n-        ~\"powf64\" => {\n+        \"powf64\" => {\n             let a = get_param(decl, first_real_arg);\n             let x = get_param(decl, first_real_arg + 1u);\n-            let powf = *ccx.intrinsics.get(&~\"llvm.pow.f64\");\n+            let powf = *ccx.intrinsics.get(& &\"llvm.pow.f64\");\n             Store(bcx, Call(bcx, powf, [a, x]), fcx.llretptr.get());\n         }\n-        ~\"expf32\" => {\n+        \"expf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let expf = *ccx.intrinsics.get(&~\"llvm.exp.f32\");\n+            let expf = *ccx.intrinsics.get(& &\"llvm.exp.f32\");\n             Store(bcx, Call(bcx, expf, [x]), fcx.llretptr.get());\n         }\n-        ~\"expf64\" => {\n+        \"expf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let expf = *ccx.intrinsics.get(&~\"llvm.exp.f64\");\n+            let expf = *ccx.intrinsics.get(& &\"llvm.exp.f64\");\n             Store(bcx, Call(bcx, expf, [x]), fcx.llretptr.get());\n         }\n-        ~\"exp2f32\" => {\n+        \"exp2f32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let exp2f = *ccx.intrinsics.get(&~\"llvm.exp2.f32\");\n+            let exp2f = *ccx.intrinsics.get(& &\"llvm.exp2.f32\");\n             Store(bcx, Call(bcx, exp2f, [x]), fcx.llretptr.get());\n         }\n-        ~\"exp2f64\" => {\n+        \"exp2f64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let exp2f = *ccx.intrinsics.get(&~\"llvm.exp2.f64\");\n+            let exp2f = *ccx.intrinsics.get(& &\"llvm.exp2.f64\");\n             Store(bcx, Call(bcx, exp2f, [x]), fcx.llretptr.get());\n         }\n-        ~\"logf32\" => {\n+        \"logf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let logf = *ccx.intrinsics.get(&~\"llvm.log.f32\");\n+            let logf = *ccx.intrinsics.get(& &\"llvm.log.f32\");\n             Store(bcx, Call(bcx, logf, [x]), fcx.llretptr.get());\n         }\n-        ~\"logf64\" => {\n+        \"logf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let logf = *ccx.intrinsics.get(&~\"llvm.log.f64\");\n+            let logf = *ccx.intrinsics.get(& &\"llvm.log.f64\");\n             Store(bcx, Call(bcx, logf, [x]), fcx.llretptr.get());\n         }\n-        ~\"log10f32\" => {\n+        \"log10f32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let log10f = *ccx.intrinsics.get(&~\"llvm.log10.f32\");\n+            let log10f = *ccx.intrinsics.get(& &\"llvm.log10.f32\");\n             Store(bcx, Call(bcx, log10f, [x]), fcx.llretptr.get());\n         }\n-        ~\"log10f64\" => {\n+        \"log10f64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let log10f = *ccx.intrinsics.get(&~\"llvm.log10.f64\");\n+            let log10f = *ccx.intrinsics.get(& &\"llvm.log10.f64\");\n             Store(bcx, Call(bcx, log10f, [x]), fcx.llretptr.get());\n         }\n-        ~\"log2f32\" => {\n+        \"log2f32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let log2f = *ccx.intrinsics.get(&~\"llvm.log2.f32\");\n+            let log2f = *ccx.intrinsics.get(& &\"llvm.log2.f32\");\n             Store(bcx, Call(bcx, log2f, [x]), fcx.llretptr.get());\n         }\n-        ~\"log2f64\" => {\n+        \"log2f64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let log2f = *ccx.intrinsics.get(&~\"llvm.log2.f64\");\n+            let log2f = *ccx.intrinsics.get(& &\"llvm.log2.f64\");\n             Store(bcx, Call(bcx, log2f, [x]), fcx.llretptr.get());\n         }\n-        ~\"fmaf32\" => {\n+        \"fmaf32\" => {\n             let a = get_param(decl, first_real_arg);\n             let b = get_param(decl, first_real_arg + 1u);\n             let c = get_param(decl, first_real_arg + 2u);\n-            let fmaf = *ccx.intrinsics.get(&~\"llvm.fma.f32\");\n+            let fmaf = *ccx.intrinsics.get(& &\"llvm.fma.f32\");\n             Store(bcx, Call(bcx, fmaf, [a, b, c]), fcx.llretptr.get());\n         }\n-        ~\"fmaf64\" => {\n+        \"fmaf64\" => {\n             let a = get_param(decl, first_real_arg);\n             let b = get_param(decl, first_real_arg + 1u);\n             let c = get_param(decl, first_real_arg + 2u);\n-            let fmaf = *ccx.intrinsics.get(&~\"llvm.fma.f64\");\n+            let fmaf = *ccx.intrinsics.get(& &\"llvm.fma.f64\");\n             Store(bcx, Call(bcx, fmaf, [a, b, c]), fcx.llretptr.get());\n         }\n-        ~\"fabsf32\" => {\n+        \"fabsf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let fabsf = *ccx.intrinsics.get(&~\"llvm.fabs.f32\");\n+            let fabsf = *ccx.intrinsics.get(& &\"llvm.fabs.f32\");\n             Store(bcx, Call(bcx, fabsf, [x]), fcx.llretptr.get());\n         }\n-        ~\"fabsf64\" => {\n+        \"fabsf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let fabsf = *ccx.intrinsics.get(&~\"llvm.fabs.f64\");\n+            let fabsf = *ccx.intrinsics.get(& &\"llvm.fabs.f64\");\n             Store(bcx, Call(bcx, fabsf, [x]), fcx.llretptr.get());\n         }\n-        ~\"floorf32\" => {\n+        \"floorf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let floorf = *ccx.intrinsics.get(&~\"llvm.floor.f32\");\n+            let floorf = *ccx.intrinsics.get(& &\"llvm.floor.f32\");\n             Store(bcx, Call(bcx, floorf, [x]), fcx.llretptr.get());\n         }\n-        ~\"floorf64\" => {\n+        \"floorf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let floorf = *ccx.intrinsics.get(&~\"llvm.floor.f64\");\n+            let floorf = *ccx.intrinsics.get(& &\"llvm.floor.f64\");\n             Store(bcx, Call(bcx, floorf, [x]), fcx.llretptr.get());\n         }\n-        ~\"ceilf32\" => {\n+        \"ceilf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let ceilf = *ccx.intrinsics.get(&~\"llvm.ceil.f32\");\n+            let ceilf = *ccx.intrinsics.get(& &\"llvm.ceil.f32\");\n             Store(bcx, Call(bcx, ceilf, [x]), fcx.llretptr.get());\n         }\n-        ~\"ceilf64\" => {\n+        \"ceilf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let ceilf = *ccx.intrinsics.get(&~\"llvm.ceil.f64\");\n+            let ceilf = *ccx.intrinsics.get(& &\"llvm.ceil.f64\");\n             Store(bcx, Call(bcx, ceilf, [x]), fcx.llretptr.get());\n         }\n-        ~\"truncf32\" => {\n+        \"truncf32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let truncf = *ccx.intrinsics.get(&~\"llvm.trunc.f32\");\n+            let truncf = *ccx.intrinsics.get(& &\"llvm.trunc.f32\");\n             Store(bcx, Call(bcx, truncf, [x]), fcx.llretptr.get());\n         }\n-        ~\"truncf64\" => {\n+        \"truncf64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let truncf = *ccx.intrinsics.get(&~\"llvm.trunc.f64\");\n+            let truncf = *ccx.intrinsics.get(& &\"llvm.trunc.f64\");\n             Store(bcx, Call(bcx, truncf, [x]), fcx.llretptr.get());\n         }\n-        ~\"ctpop8\" => {\n+        \"ctpop8\" => {\n             let x = get_param(decl, first_real_arg);\n-            let ctpop = *ccx.intrinsics.get(&~\"llvm.ctpop.i8\");\n+            let ctpop = *ccx.intrinsics.get(& &\"llvm.ctpop.i8\");\n             Store(bcx, Call(bcx, ctpop, [x]), fcx.llretptr.get())\n         }\n-        ~\"ctpop16\" => {\n+        \"ctpop16\" => {\n             let x = get_param(decl, first_real_arg);\n-            let ctpop = *ccx.intrinsics.get(&~\"llvm.ctpop.i16\");\n+            let ctpop = *ccx.intrinsics.get(& &\"llvm.ctpop.i16\");\n             Store(bcx, Call(bcx, ctpop, [x]), fcx.llretptr.get())\n         }\n-        ~\"ctpop32\" => {\n+        \"ctpop32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let ctpop = *ccx.intrinsics.get(&~\"llvm.ctpop.i32\");\n+            let ctpop = *ccx.intrinsics.get(& &\"llvm.ctpop.i32\");\n             Store(bcx, Call(bcx, ctpop, [x]), fcx.llretptr.get())\n         }\n-        ~\"ctpop64\" => {\n+        \"ctpop64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let ctpop = *ccx.intrinsics.get(&~\"llvm.ctpop.i64\");\n+            let ctpop = *ccx.intrinsics.get(& &\"llvm.ctpop.i64\");\n             Store(bcx, Call(bcx, ctpop, [x]), fcx.llretptr.get())\n         }\n-        ~\"ctlz8\" => {\n+        \"ctlz8\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n-            let ctlz = *ccx.intrinsics.get(&~\"llvm.ctlz.i8\");\n+            let ctlz = *ccx.intrinsics.get(& &\"llvm.ctlz.i8\");\n             Store(bcx, Call(bcx, ctlz, [x, y]), fcx.llretptr.get())\n         }\n-        ~\"ctlz16\" => {\n+        \"ctlz16\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n-            let ctlz = *ccx.intrinsics.get(&~\"llvm.ctlz.i16\");\n+            let ctlz = *ccx.intrinsics.get(& &\"llvm.ctlz.i16\");\n             Store(bcx, Call(bcx, ctlz, [x, y]), fcx.llretptr.get())\n         }\n-        ~\"ctlz32\" => {\n+        \"ctlz32\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n-            let ctlz = *ccx.intrinsics.get(&~\"llvm.ctlz.i32\");\n+            let ctlz = *ccx.intrinsics.get(& &\"llvm.ctlz.i32\");\n             Store(bcx, Call(bcx, ctlz, [x, y]), fcx.llretptr.get())\n         }\n-        ~\"ctlz64\" => {\n+        \"ctlz64\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n-            let ctlz = *ccx.intrinsics.get(&~\"llvm.ctlz.i64\");\n+            let ctlz = *ccx.intrinsics.get(& &\"llvm.ctlz.i64\");\n             Store(bcx, Call(bcx, ctlz, [x, y]), fcx.llretptr.get())\n         }\n-        ~\"cttz8\" => {\n+        \"cttz8\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n-            let cttz = *ccx.intrinsics.get(&~\"llvm.cttz.i8\");\n+            let cttz = *ccx.intrinsics.get(& &\"llvm.cttz.i8\");\n             Store(bcx, Call(bcx, cttz, [x, y]), fcx.llretptr.get())\n         }\n-        ~\"cttz16\" => {\n+        \"cttz16\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n-            let cttz = *ccx.intrinsics.get(&~\"llvm.cttz.i16\");\n+            let cttz = *ccx.intrinsics.get(& &\"llvm.cttz.i16\");\n             Store(bcx, Call(bcx, cttz, [x, y]), fcx.llretptr.get())\n         }\n-        ~\"cttz32\" => {\n+        \"cttz32\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n-            let cttz = *ccx.intrinsics.get(&~\"llvm.cttz.i32\");\n+            let cttz = *ccx.intrinsics.get(& &\"llvm.cttz.i32\");\n             Store(bcx, Call(bcx, cttz, [x, y]), fcx.llretptr.get())\n         }\n-        ~\"cttz64\" => {\n+        \"cttz64\" => {\n             let x = get_param(decl, first_real_arg);\n             let y = C_i1(false);\n-            let cttz = *ccx.intrinsics.get(&~\"llvm.cttz.i64\");\n+            let cttz = *ccx.intrinsics.get(& &\"llvm.cttz.i64\");\n             Store(bcx, Call(bcx, cttz, [x, y]), fcx.llretptr.get())\n         }\n-        ~\"bswap16\" => {\n+        \"bswap16\" => {\n             let x = get_param(decl, first_real_arg);\n-            let cttz = *ccx.intrinsics.get(&~\"llvm.bswap.i16\");\n+            let cttz = *ccx.intrinsics.get(& &\"llvm.bswap.i16\");\n             Store(bcx, Call(bcx, cttz, [x]), fcx.llretptr.get())\n         }\n-        ~\"bswap32\" => {\n+        \"bswap32\" => {\n             let x = get_param(decl, first_real_arg);\n-            let cttz = *ccx.intrinsics.get(&~\"llvm.bswap.i32\");\n+            let cttz = *ccx.intrinsics.get(& &\"llvm.bswap.i32\");\n             Store(bcx, Call(bcx, cttz, [x]), fcx.llretptr.get())\n         }\n-        ~\"bswap64\" => {\n+        \"bswap64\" => {\n             let x = get_param(decl, first_real_arg);\n-            let cttz = *ccx.intrinsics.get(&~\"llvm.bswap.i64\");\n+            let cttz = *ccx.intrinsics.get(& &\"llvm.bswap.i64\");\n             Store(bcx, Call(bcx, cttz, [x]), fcx.llretptr.get())\n         }\n         _ => {"}, {"sha": "c982b26fe84b03fb6f74a3a3f82c98a202b4b109", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -686,10 +686,10 @@ pub fn declare_tydesc(ccx: @CrateContext, t: ty::t) -> @mut tydesc_info {\n     let llsize = llsize_of(ccx, llty);\n     let llalign = llalign_of(ccx, llty);\n     let addrspace = declare_tydesc_addrspace(ccx, t);\n-    let name = @mangle_internal_name_by_type_and_seq(ccx, t, \"tydesc\");\n+    let name = mangle_internal_name_by_type_and_seq(ccx, t, \"tydesc\").to_managed();\n     note_unique_llvm_symbol(ccx, name);\n-    debug!(\"+++ declare_tydesc %s %s\", ppaux::ty_to_str(ccx.tcx, t), *name);\n-    let gvar = str::as_c_str(*name, |buf| {\n+    debug!(\"+++ declare_tydesc %s %s\", ppaux::ty_to_str(ccx.tcx, t), name);\n+    let gvar = str::as_c_str(name, |buf| {\n         unsafe {\n             llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type, buf)\n         }\n@@ -715,10 +715,10 @@ pub fn declare_generic_glue(ccx: @CrateContext, t: ty::t, llfnty: TypeRef,\n                             name: ~str) -> ValueRef {\n     let _icx = ccx.insn_ctxt(\"declare_generic_glue\");\n     let name = name;\n-    let fn_nm = @mangle_internal_name_by_type_and_seq(ccx, t, (~\"glue_\" + name));\n-    debug!(\"%s is for type %s\", *fn_nm, ppaux::ty_to_str(ccx.tcx, t));\n+    let fn_nm = mangle_internal_name_by_type_and_seq(ccx, t, (~\"glue_\" + name)).to_managed();\n+    debug!(\"%s is for type %s\", fn_nm, ppaux::ty_to_str(ccx.tcx, t));\n     note_unique_llvm_symbol(ccx, fn_nm);\n-    let llfn = decl_cdecl_fn(ccx.llmod, *fn_nm, llfnty);\n+    let llfn = decl_cdecl_fn(ccx.llmod, fn_nm, llfnty);\n     set_glue_inlining(llfn, t);\n     return llfn;\n }"}, {"sha": "d2a437a18729496d867c10622c0b88f5f917031e", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -139,7 +139,7 @@ pub fn static_size_of_enum(cx: @CrateContext, t: ty::t) -> uint {\n                 });\n \n                 debug!(\"static_size_of_enum: variant %s type %s\",\n-                       *cx.tcx.sess.str_of(variant.name),\n+                       cx.tcx.sess.str_of(variant.name),\n                        ty_str(cx.tn, T_struct(lltypes, false)));\n \n                 let this_size = llsize_of_real(cx, T_struct(lltypes, false));"}, {"sha": "2b9f559c0997ae40ccda76fdbe0299cab12961af", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -339,7 +339,7 @@ pub fn trans_static_method_callee(bcx: block,\n         }\n     };\n     debug!(\"trans_static_method_callee: method_id=%?, callee_id=%?, \\\n-            name=%s\", method_id, callee_id, *ccx.sess.str_of(mname));\n+            name=%s\", method_id, callee_id, ccx.sess.str_of(mname));\n \n     let vtbls = resolve_vtables_in_fn_ctxt(\n         bcx.fcx, ccx.maps.vtable_map.get_copy(&callee_id));\n@@ -791,7 +791,7 @@ pub fn make_vtable(ccx: @CrateContext,\n \n         let tbl = C_struct(components);\n         let vtable = ccx.sess.str_of((ccx.names)(\"vtable\"));\n-        let vt_gvar = do str::as_c_str(*vtable) |buf| {\n+        let vt_gvar = do str::as_c_str(vtable) |buf| {\n             llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl), buf)\n         };\n         llvm::LLVMSetInitializer(vt_gvar, tbl);\n@@ -827,16 +827,15 @@ pub fn make_impl_vtable(bcx: block,\n                                 ty::mk_bare_fn(tcx, copy im.fty));\n         if im.generics.has_type_params() || ty::type_has_self(fty) {\n             debug!(\"(making impl vtable) method has self or type params: %s\",\n-                   *tcx.sess.str_of(im.ident));\n+                   tcx.sess.str_of(im.ident));\n             C_null(T_ptr(T_nil()))\n         } else {\n             debug!(\"(making impl vtable) adding method to vtable: %s\",\n-                   *tcx.sess.str_of(im.ident));\n+                   tcx.sess.str_of(im.ident));\n             let m_id = method_with_name_or_default(ccx, impl_id, im.ident);\n \n             trans_fn_ref_with_vtables(bcx, m_id, 0,\n                                       substs, Some(vtables)).llfn\n-\n         }\n     };\n "}, {"sha": "54be98e47705a013ab56fb1c2a3b24929040681d", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -164,7 +164,7 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n     ccx.monomorphizing.insert(fn_id, depth + 1);\n \n     let pt = vec::append(/*bad*/copy *pt,\n-                         [path_name((ccx.names)(*ccx.sess.str_of(name)))]);\n+                         [path_name((ccx.names)(ccx.sess.str_of(name)))]);\n     let s = mangle_exported_name(ccx, /*bad*/copy pt, mono_ty);\n \n     let mk_lldecl = || {"}, {"sha": "5c47cdbdb365cc7b42ebe3de624528857af20428", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -50,7 +50,7 @@ impl Reflector {\n         C_int(self.bcx.ccx(), i)\n     }\n \n-    pub fn c_slice(&mut self, s: @~str) -> ValueRef {\n+    pub fn c_slice(&mut self, s: @str) -> ValueRef {\n         // We're careful to not use first class aggregates here because that\n         // will kick us off fast isel. (Issue #4352.)\n         let bcx = self.bcx;"}, {"sha": "0667b0ed7dca1e82704e891701dbddc646200a95", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -250,7 +250,7 @@ pub fn trans_slice_vstore(bcx: block,\n \n pub fn trans_lit_str(bcx: block,\n                      lit_expr: @ast::expr,\n-                     str_lit: @~str,\n+                     str_lit: @str,\n                      dest: Dest)\n                   -> block {\n     //!"}, {"sha": "d1402935e8d6309b2ec10a8c0d54f4336d72b0d7", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 37, "deletions": 37, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -118,43 +118,43 @@ pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n                                  _,\n                                  _) => {\n         if abi.is_intrinsic() {\n-            let flags = match *cx.ccx.sess.str_of(i.ident) {\n-                ~\"size_of\"  | ~\"pref_align_of\" | ~\"min_align_of\" |\n-                ~\"uninit\"   | ~\"init\" | ~\"transmute\" | ~\"move_val\" |\n-                ~\"move_val_init\" => use_repr,\n-\n-                ~\"get_tydesc\" | ~\"needs_drop\" => use_tydesc,\n-\n-                ~\"atomic_cxchg\"    | ~\"atomic_cxchg_acq\"|\n-                ~\"atomic_cxchg_rel\"| ~\"atomic_load\"     |\n-                ~\"atomic_load_acq\" | ~\"atomic_store\"    |\n-                ~\"atomic_store_rel\"| ~\"atomic_xchg\"     |\n-                ~\"atomic_xadd\"     | ~\"atomic_xsub\"     |\n-                ~\"atomic_xchg_acq\" | ~\"atomic_xadd_acq\" |\n-                ~\"atomic_xsub_acq\" | ~\"atomic_xchg_rel\" |\n-                ~\"atomic_xadd_rel\" | ~\"atomic_xsub_rel\" => 0,\n-\n-                ~\"visit_tydesc\"  | ~\"forget\" | ~\"frame_address\" |\n-                ~\"morestack_addr\" => 0,\n-\n-                ~\"memcpy32\" | ~\"memcpy64\" | ~\"memmove32\" | ~\"memmove64\" |\n-                ~\"memset32\" | ~\"memset64\" => use_repr,\n-\n-                ~\"sqrtf32\" | ~\"sqrtf64\" | ~\"powif32\" | ~\"powif64\" |\n-                ~\"sinf32\"  | ~\"sinf64\"  | ~\"cosf32\"  | ~\"cosf64\"  |\n-                ~\"powf32\"  | ~\"powf64\"  | ~\"expf32\"  | ~\"expf64\"  |\n-                ~\"exp2f32\" | ~\"exp2f64\" | ~\"logf32\"  | ~\"logf64\"  |\n-                ~\"log10f32\"| ~\"log10f64\"| ~\"log2f32\" | ~\"log2f64\" |\n-                ~\"fmaf32\"  | ~\"fmaf64\"  | ~\"fabsf32\" | ~\"fabsf64\" |\n-                ~\"floorf32\"| ~\"floorf64\"| ~\"ceilf32\" | ~\"ceilf64\" |\n-                ~\"truncf32\"| ~\"truncf64\" => 0,\n-\n-                ~\"ctpop8\" | ~\"ctpop16\" | ~\"ctpop32\" | ~\"ctpop64\" => 0,\n-\n-                ~\"ctlz8\" | ~\"ctlz16\" | ~\"ctlz32\" | ~\"ctlz64\" => 0,\n-                ~\"cttz8\" | ~\"cttz16\" | ~\"cttz32\" | ~\"cttz64\" => 0,\n-\n-                ~\"bswap16\" | ~\"bswap32\" | ~\"bswap64\" => 0,\n+            let flags = match cx.ccx.sess.str_of(i.ident).as_slice() {\n+                \"size_of\"  | \"pref_align_of\" | \"min_align_of\" |\n+                \"uninit\"   | \"init\" | \"transmute\" | \"move_val\" |\n+                \"move_val_init\" => use_repr,\n+\n+                \"get_tydesc\" | \"needs_drop\" => use_tydesc,\n+\n+                \"atomic_cxchg\"    | \"atomic_cxchg_acq\"|\n+                \"atomic_cxchg_rel\"| \"atomic_load\"     |\n+                \"atomic_load_acq\" | \"atomic_store\"    |\n+                \"atomic_store_rel\"| \"atomic_xchg\"     |\n+                \"atomic_xadd\"     | \"atomic_xsub\"     |\n+                \"atomic_xchg_acq\" | \"atomic_xadd_acq\" |\n+                \"atomic_xsub_acq\" | \"atomic_xchg_rel\" |\n+                \"atomic_xadd_rel\" | \"atomic_xsub_rel\" => 0,\n+\n+                \"visit_tydesc\"  | \"forget\" | \"frame_address\" |\n+                \"morestack_addr\" => 0,\n+\n+                \"memcpy32\" | \"memcpy64\" | \"memmove32\" | \"memmove64\" |\n+                \"memset32\" | \"memset64\" => use_repr,\n+\n+                \"sqrtf32\" | \"sqrtf64\" | \"powif32\" | \"powif64\" |\n+                \"sinf32\"  | \"sinf64\"  | \"cosf32\"  | \"cosf64\"  |\n+                \"powf32\"  | \"powf64\"  | \"expf32\"  | \"expf64\"  |\n+                \"exp2f32\" | \"exp2f64\" | \"logf32\"  | \"logf64\"  |\n+                \"log10f32\"| \"log10f64\"| \"log2f32\" | \"log2f64\" |\n+                \"fmaf32\"  | \"fmaf64\"  | \"fabsf32\" | \"fabsf64\" |\n+                \"floorf32\"| \"floorf64\"| \"ceilf32\" | \"ceilf64\" |\n+                \"truncf32\"| \"truncf64\" => 0,\n+\n+                \"ctpop8\" | \"ctpop16\" | \"ctpop32\" | \"ctpop64\" => 0,\n+\n+                \"ctlz8\" | \"ctlz16\" | \"ctlz32\" | \"ctlz64\" => 0,\n+                \"cttz8\" | \"cttz16\" | \"cttz32\" | \"cttz64\" => 0,\n+\n+                \"bswap16\" | \"bswap32\" | \"bswap64\" => 0,\n \n                 // would be cool to make these an enum instead of strings!\n                 _ => fail!(\"unknown intrinsic in type_use\")"}, {"sha": "d76d4642801bbe3ffb69c16e1ac38a193b5b1693", "filename": "src/librustc/middle/trans/write_guard.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fwrite_guard.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -117,8 +117,8 @@ fn root(datum: &Datum,\n     if bcx.sess().trace() {\n         trans_trace(\n             bcx, None,\n-            @fmt!(\"preserving until end of scope %d\",\n-                  root_info.scope));\n+            (fmt!(\"preserving until end of scope %d\",\n+                  root_info.scope)).to_managed());\n     }\n \n     // First, root the datum. Note that we must zero this value,"}, {"sha": "a9ecd12bf2d76df3f6f38d6c270db68889ed6fe3", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -281,7 +281,7 @@ struct ctxt_ {\n     tcache: type_cache,\n     rcache: creader_cache,\n     ccache: constness_cache,\n-    short_names_cache: @mut HashMap<t, @~str>,\n+    short_names_cache: @mut HashMap<t, @str>,\n     needs_unwind_cleanup_cache: @mut HashMap<t, bool>,\n     tc_cache: @mut HashMap<uint, TypeContents>,\n     ast_ty_to_ty_cache: @mut HashMap<node_id, ast_ty_to_ty_cache_entry>,\n@@ -3366,7 +3366,7 @@ pub fn field_idx_strict(tcx: ty::ctxt, id: ast::ident, fields: &[field])\n     for fields.each |f| { if f.ident == id { return i; } i += 1u; }\n     tcx.sess.bug(fmt!(\n         \"No field named `%s` found in the list of fields `%?`\",\n-        *tcx.sess.str_of(id),\n+        tcx.sess.str_of(id),\n         fields.map(|f| tcx.sess.str_of(f.ident))));\n }\n \n@@ -3514,8 +3514,8 @@ pub fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n         terr_record_fields(values) => {\n             fmt!(\"expected a record with field `%s` but found one with field \\\n                   `%s`\",\n-                 *cx.sess.str_of(values.expected),\n-                 *cx.sess.str_of(values.found))\n+                 cx.sess.str_of(values.expected),\n+                 cx.sess.str_of(values.found))\n         }\n         terr_arg_count => ~\"incorrect number of function parameters\",\n         terr_regions_does_not_outlive(*) => {\n@@ -3549,7 +3549,7 @@ pub fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n                  trait_store_to_str(cx, (*values).found))\n         }\n         terr_in_field(err, fname) => {\n-            fmt!(\"in field `%s`, %s\", *cx.sess.str_of(fname),\n+            fmt!(\"in field `%s`, %s\", cx.sess.str_of(fname),\n                  type_err_to_str(cx, err))\n         }\n         terr_sorts(values) => {"}, {"sha": "4a546ce20d2d1735eecfc4b535f6a2c81b0da41d", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -297,7 +297,7 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n                 tcx.sess.span_err(span,\n                                   fmt!(\"struct `%s` does not have a field\n                                         named `%s`\", name,\n-                                       *tcx.sess.str_of(field.ident)));\n+                                       tcx.sess.str_of(field.ident)));\n             }\n         }\n     }\n@@ -310,7 +310,7 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n             }\n             tcx.sess.span_err(span,\n                               fmt!(\"pattern does not mention field `%s`\",\n-                                   *tcx.sess.str_of(field.ident)));\n+                                   tcx.sess.str_of(field.ident)));\n         }\n     }\n }"}, {"sha": "14f251878a4d2b2009d08b2928d7260ff3e6a3d8", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 81, "deletions": 80, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -490,7 +490,7 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                   if pat_util::pat_is_binding(fcx.ccx.tcx.def_map, p) => {\n                 assign(p.id, None);\n                 debug!(\"Pattern binding %s is assigned to %s\",\n-                       *tcx.sess.str_of(path.idents[0]),\n+                       tcx.sess.str_of(path.idents[0]),\n                        fcx.infcx().ty_to_str(\n                            fcx.inh.locals.get_copy(&p.id)));\n               }\n@@ -557,7 +557,7 @@ pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n         match orig_sp {\n             Some(orig_sp) => {\n                 tcx.sess.span_err(sp, fmt!(\"Duplicate field name %s in record type declaration\",\n-                                           *tcx.sess.str_of(id)));\n+                                           tcx.sess.str_of(id)));\n                 tcx.sess.span_note(orig_sp, \"First declaration of this field occurred here\");\n                 break;\n             }\n@@ -599,7 +599,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n       ast::item_impl(_, _, _, ref ms) => {\n         let rp = ccx.tcx.region_paramd_items.find(&it.id).map_consume(|x| *x);\n         debug!(\"item_impl %s with id %d rp %?\",\n-               *ccx.tcx.sess.str_of(it.ident), it.id, rp);\n+               ccx.tcx.sess.str_of(it.ident), it.id, rp);\n         for ms.each |m| {\n             check_method(ccx, *m);\n         }\n@@ -1396,7 +1396,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                       fmt!(\"type `%s` does not implement any method in scope \\\n                             named `%s`\",\n                            actual,\n-                           *fcx.ccx.tcx.sess.str_of(method_name))\n+                           fcx.ccx.tcx.sess.str_of(method_name))\n                   },\n                   expr_t,\n                   None);\n@@ -1772,7 +1772,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                     |actual| {\n                         fmt!(\"attempted to take value of method `%s` on type `%s` \\\n                               (try writing an anonymous function)\",\n-                             *tcx.sess.str_of(field), actual)\n+                             tcx.sess.str_of(field), actual)\n                     },\n                     expr_t, None);\n             }\n@@ -1783,7 +1783,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                     |actual| {\n                         fmt!(\"attempted access of field `%s` on type `%s`, \\\n                               but no field with that name was found\",\n-                             *tcx.sess.str_of(field), actual)\n+                             tcx.sess.str_of(field), actual)\n                     },\n                     expr_t, None);\n             }\n@@ -1821,14 +1821,14 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                     tcx.sess.span_err(\n                         field.span,\n                         fmt!(\"structure has no field named `%s`\",\n-                             *tcx.sess.str_of(field.node.ident)));\n+                             tcx.sess.str_of(field.node.ident)));\n                     error_happened = true;\n                 }\n                 Some((_, true)) => {\n                     tcx.sess.span_err(\n                         field.span,\n                         fmt!(\"field `%s` specified more than once\",\n-                             *tcx.sess.str_of(field.node.ident)));\n+                             tcx.sess.str_of(field.node.ident)));\n                     error_happened = true;\n                 }\n                 Some((field_id, false)) => {\n@@ -1862,7 +1862,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                     let (_, seen) = *class_field_map.get(&name);\n                     if !seen {\n                         missing_fields.push(\n-                            ~\"`\" + *tcx.sess.str_of(name) + \"`\");\n+                            ~\"`\" + tcx.sess.str_of(name) + \"`\");\n                     }\n                 }\n \n@@ -3424,7 +3424,7 @@ pub fn check_bounds_are_used(ccx: @mut CrateCtxt,\n         if !*b {\n             ccx.tcx.sess.span_err(\n                 span, fmt!(\"type parameter `%s` is unused\",\n-                           *ccx.tcx.sess.str_of(tps.get(i).ident)));\n+                           ccx.tcx.sess.str_of(tps.get(i).ident)));\n         }\n     }\n }\n@@ -3435,24 +3435,25 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n     }\n \n     let tcx = ccx.tcx;\n-    let (n_tps, inputs, output) = match *ccx.tcx.sess.str_of(it.ident) {\n-        ~\"size_of\" |\n-        ~\"pref_align_of\" | ~\"min_align_of\" => (1u, ~[], ty::mk_uint()),\n-        ~\"init\" => (1u, ~[], param(ccx, 0u)),\n-        ~\"uninit\" => (1u, ~[], param(ccx, 0u)),\n-        ~\"forget\" => (1u, ~[ param(ccx, 0) ], ty::mk_nil()),\n-        ~\"transmute\" => (2, ~[ param(ccx, 0) ], param(ccx, 1)),\n-        ~\"move_val\" | ~\"move_val_init\" => {\n+    let str = ccx.tcx.sess.str_of(it.ident);\n+    let (n_tps, inputs, output) = match str.as_slice() {\n+        \"size_of\" |\n+        \"pref_align_of\" | \"min_align_of\" => (1u, ~[], ty::mk_uint()),\n+        \"init\" => (1u, ~[], param(ccx, 0u)),\n+        \"uninit\" => (1u, ~[], param(ccx, 0u)),\n+        \"forget\" => (1u, ~[ param(ccx, 0) ], ty::mk_nil()),\n+        \"transmute\" => (2, ~[ param(ccx, 0) ], param(ccx, 1)),\n+        \"move_val\" | \"move_val_init\" => {\n             (1u,\n              ~[\n                 ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)), param(ccx, 0)),\n                 param(ccx, 0u)\n               ],\n            ty::mk_nil())\n         }\n-        ~\"needs_drop\" => (1u, ~[], ty::mk_bool()),\n+        \"needs_drop\" => (1u, ~[], ty::mk_bool()),\n \n-        ~\"atomic_cxchg\"    | ~\"atomic_cxchg_acq\"| ~\"atomic_cxchg_rel\" => {\n+        \"atomic_cxchg\"    | \"atomic_cxchg_acq\"| \"atomic_cxchg_rel\" => {\n           (0,\n            ~[\n               ty::mk_mut_rptr(tcx,\n@@ -3463,24 +3464,24 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n            ],\n            ty::mk_int())\n         }\n-        ~\"atomic_load\"     | ~\"atomic_load_acq\" => {\n+        \"atomic_load\"     | \"atomic_load_acq\" => {\n           (0,\n            ~[\n               ty::mk_imm_rptr(tcx, ty::re_bound(ty::br_anon(0)), ty::mk_int())\n            ],\n           ty::mk_int())\n         }\n-        ~\"atomic_store\"    | ~\"atomic_store_rel\" => {\n+        \"atomic_store\"    | \"atomic_store_rel\" => {\n           (0,\n            ~[\n               ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)), ty::mk_int()),\n               ty::mk_int()\n            ],\n            ty::mk_nil())\n         }\n-        ~\"atomic_xchg\"     | ~\"atomic_xadd\"     | ~\"atomic_xsub\"     |\n-        ~\"atomic_xchg_acq\" | ~\"atomic_xadd_acq\" | ~\"atomic_xsub_acq\" |\n-        ~\"atomic_xchg_rel\" | ~\"atomic_xadd_rel\" | ~\"atomic_xsub_rel\" => {\n+        \"atomic_xchg\"     | \"atomic_xadd\"     | \"atomic_xsub\"     |\n+        \"atomic_xchg_acq\" | \"atomic_xadd_acq\" | \"atomic_xsub_acq\" |\n+        \"atomic_xchg_rel\" | \"atomic_xadd_rel\" | \"atomic_xsub_rel\" => {\n           (0,\n            ~[\n               ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)), ty::mk_int()),\n@@ -3489,11 +3490,11 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n            ty::mk_int())\n         }\n \n-        ~\"get_tydesc\" => {\n+        \"get_tydesc\" => {\n           // FIXME (#3730): return *intrinsic::tydesc, not *()\n           (1u, ~[], ty::mk_nil_ptr(ccx.tcx))\n         }\n-        ~\"visit_tydesc\" => {\n+        \"visit_tydesc\" => {\n           let tydesc_name = special_idents::tydesc;\n           assert!(tcx.intrinsic_defs.contains_key(&tydesc_name));\n           let (_, tydesc_ty) = tcx.intrinsic_defs.get_copy(&tydesc_name);\n@@ -3504,7 +3505,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n           });\n           (0, ~[ td_ptr, visitor_object_ty ], ty::mk_nil())\n         }\n-        ~\"frame_address\" => {\n+        \"frame_address\" => {\n           let fty = ty::mk_closure(ccx.tcx, ty::ClosureTy {\n               purity: ast::impure_fn,\n               sigil: ast::BorrowedSigil,\n@@ -3519,10 +3520,10 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n           });\n           (0u, ~[fty], ty::mk_nil())\n         }\n-        ~\"morestack_addr\" => {\n+        \"morestack_addr\" => {\n           (0u, ~[], ty::mk_nil_ptr(ccx.tcx))\n         }\n-        ~\"memcpy32\" => {\n+        \"memcpy32\" => {\n           (1,\n            ~[\n               ty::mk_ptr(tcx, ty::mt {\n@@ -3537,7 +3538,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n            ],\n            ty::mk_nil())\n         }\n-        ~\"memcpy64\" => {\n+        \"memcpy64\" => {\n           (1,\n            ~[\n               ty::mk_ptr(tcx, ty::mt {\n@@ -3552,7 +3553,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n            ],\n            ty::mk_nil())\n         }\n-        ~\"memmove32\" => {\n+        \"memmove32\" => {\n           (1,\n            ~[\n               ty::mk_ptr(tcx, ty::mt {\n@@ -3567,7 +3568,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n            ],\n            ty::mk_nil())\n         }\n-        ~\"memmove64\" => {\n+        \"memmove64\" => {\n           (1,\n            ~[\n               ty::mk_ptr(tcx, ty::mt {\n@@ -3582,7 +3583,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n            ],\n            ty::mk_nil())\n         }\n-        ~\"memset32\" => {\n+        \"memset32\" => {\n           (1,\n            ~[\n               ty::mk_ptr(tcx, ty::mt {\n@@ -3594,7 +3595,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n            ],\n            ty::mk_nil())\n         }\n-        ~\"memset64\" => {\n+        \"memset64\" => {\n           (1,\n            ~[\n               ty::mk_ptr(tcx, ty::mt {\n@@ -3606,75 +3607,75 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n            ],\n            ty::mk_nil())\n         }\n-        ~\"sqrtf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        ~\"sqrtf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        ~\"powif32\" => {\n+        \"sqrtf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+        \"sqrtf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+        \"powif32\" => {\n            (0,\n             ~[ ty::mk_f32(), ty::mk_i32() ],\n             ty::mk_f32())\n         }\n-        ~\"powif64\" => {\n+        \"powif64\" => {\n            (0,\n             ~[ ty::mk_f64(), ty::mk_i32() ],\n             ty::mk_f64())\n         }\n-        ~\"sinf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        ~\"sinf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        ~\"cosf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        ~\"cosf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        ~\"powf32\" => {\n+        \"sinf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+        \"sinf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+        \"cosf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+        \"cosf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+        \"powf32\" => {\n            (0,\n             ~[ ty::mk_f32(), ty::mk_f32() ],\n             ty::mk_f32())\n         }\n-        ~\"powf64\" => {\n+        \"powf64\" => {\n            (0,\n             ~[ ty::mk_f64(), ty::mk_f64() ],\n             ty::mk_f64())\n         }\n-        ~\"expf32\"   => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        ~\"expf64\"   => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        ~\"exp2f32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        ~\"exp2f64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        ~\"logf32\"   => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        ~\"logf64\"   => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        ~\"log10f32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        ~\"log10f64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        ~\"log2f32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        ~\"log2f64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        ~\"fmaf32\" => {\n+        \"expf32\"   => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+        \"expf64\"   => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+        \"exp2f32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+        \"exp2f64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+        \"logf32\"   => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+        \"logf64\"   => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+        \"log10f32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+        \"log10f64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+        \"log2f32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+        \"log2f64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+        \"fmaf32\" => {\n             (0,\n              ~[ ty::mk_f32(), ty::mk_f32(), ty::mk_f32() ],\n              ty::mk_f32())\n         }\n-        ~\"fmaf64\" => {\n+        \"fmaf64\" => {\n             (0,\n              ~[ ty::mk_f64(), ty::mk_f64(), ty::mk_f64() ],\n              ty::mk_f64())\n         }\n-        ~\"fabsf32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        ~\"fabsf64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        ~\"floorf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        ~\"floorf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        ~\"ceilf32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        ~\"ceilf64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        ~\"truncf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n-        ~\"truncf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n-        ~\"ctpop8\"   => (0, ~[ ty::mk_i8()  ], ty::mk_i8()),\n-        ~\"ctpop16\"  => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n-        ~\"ctpop32\"  => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n-        ~\"ctpop64\"  => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n-        ~\"ctlz8\"    => (0, ~[ ty::mk_i8()  ], ty::mk_i8()),\n-        ~\"ctlz16\"   => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n-        ~\"ctlz32\"   => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n-        ~\"ctlz64\"   => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n-        ~\"cttz8\"    => (0, ~[ ty::mk_i8()  ], ty::mk_i8()),\n-        ~\"cttz16\"   => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n-        ~\"cttz32\"   => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n-        ~\"cttz64\"   => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n-        ~\"bswap16\"  => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n-        ~\"bswap32\"  => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n-        ~\"bswap64\"  => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n+        \"fabsf32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+        \"fabsf64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+        \"floorf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+        \"floorf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+        \"ceilf32\"  => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+        \"ceilf64\"  => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+        \"truncf32\" => (0, ~[ ty::mk_f32() ], ty::mk_f32()),\n+        \"truncf64\" => (0, ~[ ty::mk_f64() ], ty::mk_f64()),\n+        \"ctpop8\"   => (0, ~[ ty::mk_i8()  ], ty::mk_i8()),\n+        \"ctpop16\"  => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n+        \"ctpop32\"  => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n+        \"ctpop64\"  => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n+        \"ctlz8\"    => (0, ~[ ty::mk_i8()  ], ty::mk_i8()),\n+        \"ctlz16\"   => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n+        \"ctlz32\"   => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n+        \"ctlz64\"   => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n+        \"cttz8\"    => (0, ~[ ty::mk_i8()  ], ty::mk_i8()),\n+        \"cttz16\"   => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n+        \"cttz32\"   => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n+        \"cttz64\"   => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n+        \"bswap16\"  => (0, ~[ ty::mk_i16() ], ty::mk_i16()),\n+        \"bswap32\"  => (0, ~[ ty::mk_i32() ], ty::mk_i32()),\n+        \"bswap64\"  => (0, ~[ ty::mk_i64() ], ty::mk_i64()),\n         ref other => {\n             tcx.sess.span_err(it.span,\n                               fmt!(\"unrecognized intrinsic function: `%s`\","}, {"sha": "115381a76cf602b57e42e26e1d34880e220d7034", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -251,7 +251,7 @@ impl CoherenceChecker {\n         if associated_traits.len() == 0 {\n             debug!(\"(checking implementation) no associated traits for item \\\n                     '%s'\",\n-                   *self.crate_context.tcx.sess.str_of(item.ident));\n+                   self.crate_context.tcx.sess.str_of(item.ident));\n \n             match get_base_type_def_id(self.inference_context,\n                                        item.span,\n@@ -278,7 +278,7 @@ impl CoherenceChecker {\n                     associated_trait.ref_id);\n             debug!(\"(checking implementation) adding impl for trait '%s', item '%s'\",\n                    trait_ref.repr(self.crate_context.tcx),\n-                   *self.crate_context.tcx.sess.str_of(item.ident));\n+                   self.crate_context.tcx.sess.str_of(item.ident));\n \n             self.instantiate_default_methods(item.id, trait_ref);\n \n@@ -401,15 +401,15 @@ impl CoherenceChecker {\n                     // method to that entry.\n                     debug!(\"(checking implementation) adding method `%s` \\\n                             to entry for existing trait\",\n-                            *self.crate_context.tcx.sess.str_of(\n+                            self.crate_context.tcx.sess.str_of(\n                                 provided_method_info.method_info.ident));\n                     mis.push(provided_method_info);\n                 }\n                 None => {\n                     // If the trait doesn't have an entry yet, create one.\n                     debug!(\"(checking implementation) creating new entry \\\n                             for method `%s`\",\n-                            *self.crate_context.tcx.sess.str_of(\n+                            self.crate_context.tcx.sess.str_of(\n                                 provided_method_info.method_info.ident));\n                     pmm.insert(local_def(impl_id),\n                                @mut ~[provided_method_info]);\n@@ -742,7 +742,7 @@ impl CoherenceChecker {\n \n             tcx.sess.span_err(trait_ref_span,\n                               fmt!(\"missing method `%s`\",\n-                                   *tcx.sess.str_of(method.ident)));\n+                                   tcx.sess.str_of(method.ident)));\n         }\n     }\n \n@@ -794,7 +794,7 @@ impl CoherenceChecker {\n             for all_provided_methods.each |provided_method| {\n                 debug!(\n                     \"(creating impl) adding provided method `%s` to impl\",\n-                    *sess.str_of(provided_method.method_info.ident));\n+                    sess.str_of(provided_method.method_info.ident));\n                 vec::push(all_methods, provided_method.method_info);\n             }\n         }\n@@ -909,7 +909,7 @@ impl CoherenceChecker {\n                         session.bug(fmt!(\n                             \"no base type for external impl \\\n                              with no trait: %s (type %s)!\",\n-                             *session.str_of(implementation.ident),\n+                             session.str_of(implementation.ident),\n                              ty_to_str(self.crate_context.tcx,self_type.ty)));\n                     }\n                     Some(_) => {"}, {"sha": "6ced82df1d735496fc3416d62e258f72c60bd5de", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -471,7 +471,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n                 cm.span,\n                 fmt!(\"method `%s` has a `%s` declaration in the impl, \\\n                       but not in the trait\",\n-                     *tcx.sess.str_of(trait_m.ident),\n+                     tcx.sess.str_of(trait_m.ident),\n                      explicit_self_to_str(impl_m.explicit_self, tcx.sess.intr())));\n             return;\n         }\n@@ -480,7 +480,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n                 cm.span,\n                 fmt!(\"method `%s` has a `%s` declaration in the trait, \\\n                       but not in the impl\",\n-                     *tcx.sess.str_of(trait_m.ident),\n+                     tcx.sess.str_of(trait_m.ident),\n                      explicit_self_to_str(trait_m.explicit_self, tcx.sess.intr())));\n             return;\n         }\n@@ -496,7 +496,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n             cm.span,\n             fmt!(\"method `%s` has %u type %s, but its trait \\\n                   declaration has %u type %s\",\n-                 *tcx.sess.str_of(trait_m.ident),\n+                 tcx.sess.str_of(trait_m.ident),\n                  num_impl_m_type_params,\n                  pluralize(num_impl_m_type_params, ~\"parameter\"),\n                  num_trait_m_type_params,\n@@ -509,7 +509,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n             cm.span,\n             fmt!(\"method `%s` has %u parameter%s \\\n                   but the trait has %u\",\n-                 *tcx.sess.str_of(trait_m.ident),\n+                 tcx.sess.str_of(trait_m.ident),\n                  impl_m.fty.sig.inputs.len(),\n                  if impl_m.fty.sig.inputs.len() == 1 { \"\" } else { \"s\" },\n                  trait_m.fty.sig.inputs.len()));\n@@ -533,7 +533,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n                      which is not required by \\\n                      the corresponding type parameter \\\n                      in the trait declaration\",\n-                    *tcx.sess.str_of(trait_m.ident),\n+                    tcx.sess.str_of(trait_m.ident),\n                     i,\n                     extra_bounds.user_string(tcx)));\n            return;\n@@ -551,7 +551,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n                       type parameter %u has %u trait %s, but the \\\n                       corresponding type parameter in \\\n                       the trait declaration has %u trait %s\",\n-                     *tcx.sess.str_of(trait_m.ident),\n+                     tcx.sess.str_of(trait_m.ident),\n                      i, impl_param_def.bounds.trait_bounds.len(),\n                      pluralize(impl_param_def.bounds.trait_bounds.len(),\n                                ~\"bound\"),\n@@ -652,7 +652,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n             tcx.sess.span_err(\n                 cm.span,\n                 fmt!(\"method `%s` has an incompatible type: %s\",\n-                     *tcx.sess.str_of(trait_m.ident),\n+                     tcx.sess.str_of(trait_m.ident),\n                      ty::type_err_to_str(tcx, terr)));\n             ty::note_and_explain_type_err(tcx, terr);\n         }\n@@ -700,7 +700,7 @@ pub fn check_methods_against_trait(ccx: &CrateCtxt,\n                 tcx.sess.span_err(\n                     impl_m.span,\n                     fmt!(\"method `%s` is not a member of trait `%s`\",\n-                         *tcx.sess.str_of(impl_m.mty.ident),\n+                         tcx.sess.str_of(impl_m.mty.ident),\n                          path_to_str(a_trait_ty.path, tcx.sess.intr())));\n             }\n         }\n@@ -829,7 +829,7 @@ pub fn convert(ccx: &CrateCtxt, it: @ast::item) {\n     let tcx = ccx.tcx;\n     let rp = tcx.region_paramd_items.find(&it.id).map_consume(|x| *x);\n     debug!(\"convert: item %s with id %d rp %?\",\n-           *tcx.sess.str_of(it.ident), it.id, rp);\n+           tcx.sess.str_of(it.ident), it.id, rp);\n     match it.node {\n       // These don't define types.\n       ast::item_foreign_mod(_) | ast::item_mod(_) => {}\n@@ -1084,7 +1084,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: @ast::item)\n             ty: ty::mk_bare_fn(ccx.tcx, tofd)\n         };\n         debug!(\"type of %s (id %d) is %s\",\n-               *tcx.sess.str_of(it.ident),\n+               tcx.sess.str_of(it.ident),\n                it.id,\n                ppaux::ty_to_str(tcx, tpt.ty));\n         ccx.tcx.tcache.insert(local_def(it.id), tpt);"}, {"sha": "7d86b312908c7b455657a17ee309dc6356891149", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -236,9 +236,9 @@ pub fn run_compiler(args: &~[~str], demitter: diagnostic::Emitter) {\n     ::core::logging::console_off();\n \n     let mut args = /*bad*/copy *args;\n-    let binary = @args.shift();\n+    let binary = args.shift().to_managed();\n \n-    if args.is_empty() { usage(*binary); return; }\n+    if args.is_empty() { usage(binary); return; }\n \n     let matches =\n         &match getopts::groups::getopts(args, optgroups()) {\n@@ -249,7 +249,7 @@ pub fn run_compiler(args: &~[~str], demitter: diagnostic::Emitter) {\n         };\n \n     if opt_present(matches, \"h\") || opt_present(matches, \"help\") {\n-        usage(*binary);\n+        usage(binary);\n         return;\n     }\n \n@@ -276,16 +276,16 @@ pub fn run_compiler(args: &~[~str], demitter: diagnostic::Emitter) {\n     }\n \n     if opt_present(matches, \"v\") || opt_present(matches, \"version\") {\n-        version(*binary);\n+        version(binary);\n         return;\n     }\n     let input = match matches.free.len() {\n       0u => early_error(demitter, ~\"no input filename given\"),\n       1u => {\n-        let ifile = /*bad*/copy matches.free[0];\n-        if ifile == ~\"-\" {\n+        let ifile = matches.free[0].as_slice();\n+        if \"-\" == ifile {\n             let src = str::from_bytes(io::stdin().read_whole_stream());\n-            str_input(src)\n+            str_input(src.to_managed())\n         } else {\n             file_input(Path(ifile))\n         }"}, {"sha": "4979f5acf63c6a1dce516f51b14490532d806bc8", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -159,7 +159,7 @@ pub fn bound_region_to_str_space(cx: ctxt,\n     if cx.sess.verbose() { return fmt!(\"%s%? \", prefix, br); }\n \n     match br {\n-      br_named(id)         => fmt!(\"%s'%s \", prefix, *cx.sess.str_of(id)),\n+      br_named(id)         => fmt!(\"%s'%s \", prefix, cx.sess.str_of(id)),\n       br_self              => fmt!(\"%s'self \", prefix),\n       br_anon(_)           => prefix.to_str(),\n       br_fresh(_)          => prefix.to_str(),\n@@ -323,7 +323,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         match ident {\n           Some(i) => {\n               s.push_char(' ');\n-              s.push_str(*cx.sess.str_of(i));\n+              s.push_str(cx.sess.str_of(i));\n           }\n           _ => { }\n         }\n@@ -389,7 +389,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n                        &m.fty.sig) + \";\"\n     }\n     fn field_to_str(cx: ctxt, f: field) -> ~str {\n-        return *cx.sess.str_of(f.ident) + \": \" + mt_to_str(cx, &f.mt);\n+        return fmt!(\"%s: %s\", cx.sess.str_of(f.ident), mt_to_str(cx, &f.mt));\n     }\n \n     // if there is an id, print that instead of the structural type:\n@@ -656,7 +656,7 @@ impl Repr for ty::Method {\n \n impl Repr for ast::ident {\n     fn repr(&self, _tcx: ctxt) -> ~str {\n-        copy *token::ident_to_str(self)\n+        token::ident_to_str(self).to_owned()\n     }\n }\n "}, {"sha": "9d8f750a3500638690dff0daf8902029aa8d31e5", "filename": "src/librustdoc/astsrv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fastsrv.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -41,7 +41,7 @@ pub struct Ctxt {\n \n type SrvOwner<'self,T> = &'self fn(srv: Srv) -> T;\n pub type CtxtHandler<T> = ~fn(ctxt: Ctxt) -> T;\n-type Parser = ~fn(Session, s: ~str) -> @ast::crate;\n+type Parser = ~fn(Session, s: @str) -> @ast::crate;\n \n enum Msg {\n     HandleRequest(~fn(Ctxt)),\n@@ -68,7 +68,7 @@ fn run<T>(owner: SrvOwner<T>, source: ~str, parse: Parser) -> T {\n     let source = Cell::new(source);\n     let parse = Cell::new(parse);\n     do task::spawn {\n-        act(&po, source.take(), parse.take());\n+        act(&po, source.take().to_managed(), parse.take());\n     }\n \n     let srv_ = Srv {\n@@ -80,12 +80,12 @@ fn run<T>(owner: SrvOwner<T>, source: ~str, parse: Parser) -> T {\n     res\n }\n \n-fn act(po: &Port<Msg>, source: ~str, parse: Parser) {\n+fn act(po: &Port<Msg>, source: @str, parse: Parser) {\n     let sess = build_session();\n \n     let ctxt = build_ctxt(\n         sess,\n-        parse(sess, copy source)\n+        parse(sess, source)\n     );\n \n     let mut keep_going = true;"}, {"sha": "a86a7f38a8cddbbc0f22b1539dde5f034ad9c42b", "filename": "src/librustdoc/attr_parser.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_parser.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -41,13 +41,13 @@ pub fn parse_crate(attrs: ~[ast::attribute]) -> CrateAttrs {\n     let name = attr::last_meta_item_value_str_by_name(link_metas, \"name\");\n \n     CrateAttrs {\n-        name: name.map(|s| copy **s)\n+        name: name.map(|s| s.to_owned())\n     }\n }\n \n pub fn parse_desc(attrs: ~[ast::attribute]) -> Option<~str> {\n     let doc_strs = do doc_metas(attrs).filter_mapped |meta| {\n-        attr::get_meta_item_value_str(*meta).map(|s| copy **s)\n+        attr::get_meta_item_value_str(*meta).map(|s| s.to_owned())\n     };\n     if doc_strs.is_empty() {\n         None\n@@ -75,82 +75,82 @@ mod test {\n     use syntax;\n     use super::{parse_hidden, parse_crate, parse_desc};\n \n-    fn parse_attributes(source: ~str) -> ~[ast::attribute] {\n+    fn parse_attributes(source: @str) -> ~[ast::attribute] {\n         use syntax::parse;\n         use syntax::parse::attr::parser_attr;\n \n         let parse_sess = syntax::parse::new_parse_sess(None);\n         let parser = parse::new_parser_from_source_str(\n-            parse_sess, ~[], ~\"-\", @source);\n+            parse_sess, ~[], @\"-\", source);\n \n         parser.parse_outer_attributes()\n     }\n \n \n     #[test]\n     fn should_extract_crate_name_from_link_attribute() {\n-        let source = ~\"#[link(name = \\\"snuggles\\\")]\";\n+        let source = @\"#[link(name = \\\"snuggles\\\")]\";\n         let attrs = parse_attributes(source);\n         let attrs = parse_crate(attrs);\n         assert!(attrs.name == Some(~\"snuggles\"));\n     }\n \n     #[test]\n     fn should_not_extract_crate_name_if_no_link_attribute() {\n-        let source = ~\"\";\n+        let source = @\"\";\n         let attrs = parse_attributes(source);\n         let attrs = parse_crate(attrs);\n         assert!(attrs.name == None);\n     }\n \n     #[test]\n     fn should_not_extract_crate_name_if_no_name_value_in_link_attribute() {\n-        let source = ~\"#[link(whatever)]\";\n+        let source = @\"#[link(whatever)]\";\n         let attrs = parse_attributes(source);\n         let attrs = parse_crate(attrs);\n         assert!(attrs.name == None);\n     }\n \n     #[test]\n     fn parse_desc_should_handle_undocumented_mods() {\n-        let source = ~\"\";\n+        let source = @\"\";\n         let attrs = parse_attributes(source);\n         let attrs = parse_desc(attrs);\n         assert!(attrs == None);\n     }\n \n     #[test]\n     fn parse_desc_should_parse_simple_doc_attributes() {\n-        let source = ~\"#[doc = \\\"basic\\\"]\";\n+        let source = @\"#[doc = \\\"basic\\\"]\";\n         let attrs = parse_attributes(source);\n         let attrs = parse_desc(attrs);\n         assert!(attrs == Some(~\"basic\"));\n     }\n \n     #[test]\n     fn should_parse_hidden_attribute() {\n-        let source = ~\"#[doc(hidden)]\";\n+        let source = @\"#[doc(hidden)]\";\n         let attrs = parse_attributes(source);\n         assert!(parse_hidden(attrs) == true);\n     }\n \n     #[test]\n     fn should_parse_hidden_attribute_with_other_docs() {\n-        let source = ~\"#[doc = \\\"foo\\\"] #[doc(hidden)] #[doc = \\\"foo\\\"]\";\n+        let source = @\"#[doc = \\\"foo\\\"] #[doc(hidden)] #[doc = \\\"foo\\\"]\";\n         let attrs = parse_attributes(source);\n         assert!(parse_hidden(attrs) == true);\n     }\n \n     #[test]\n     fn should_not_parse_non_hidden_attribute() {\n-        let source = ~\"#[doc = \\\"\\\"]\";\n+        let source = @\"#[doc = \\\"\\\"]\";\n         let attrs = parse_attributes(source);\n         assert!(parse_hidden(attrs) == false);\n     }\n \n     #[test]\n     fn should_concatenate_multiple_doc_comments() {\n-        let source = ~\"/// foo\\n/// bar\";\n+        let source = @\"/// foo\\n/// bar\";\n         let desc = parse_desc(parse_attributes(source));\n         assert!(desc == Some(~\"foo\\nbar\"));\n     }"}, {"sha": "f4b6ae8fb32af8cd844246f20ded550e582d1323", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -25,7 +25,7 @@ use syntax::parse::token;\n // thread-local data\n // Hack-Becomes-Feature: using thread-local-state everywhere...\n pub fn to_str(id: ast::ident) -> ~str {\n-    return copy *ident_to_str(&id);\n+    /* bad */ ident_to_str(&id).to_owned()\n }\n \n // get rid of this pointless function:\n@@ -287,49 +287,49 @@ mod test {\n \n     use core::vec;\n \n-    fn mk_doc(source: ~str) -> doc::Doc {\n+    fn mk_doc(source: @str) -> doc::Doc {\n         let ast = parse::from_str(source);\n         extract(ast, ~\"\")\n     }\n \n     #[test]\n     fn extract_empty_crate() {\n-        let doc = mk_doc(~\"\");\n+        let doc = mk_doc(@\"\");\n         assert!(doc.cratemod().mods().is_empty());\n         assert!(doc.cratemod().fns().is_empty());\n     }\n \n     #[test]\n     fn extract_mods() {\n-        let doc = mk_doc(~\"mod a { mod b { } mod c { } }\");\n+        let doc = mk_doc(@\"mod a { mod b { } mod c { } }\");\n         assert!(doc.cratemod().mods()[0].name() == ~\"a\");\n         assert!(doc.cratemod().mods()[0].mods()[0].name() == ~\"b\");\n         assert!(doc.cratemod().mods()[0].mods()[1].name() == ~\"c\");\n     }\n \n     #[test]\n     fn extract_fns_from_foreign_mods() {\n-        let doc = mk_doc(~\"extern { fn a(); }\");\n+        let doc = mk_doc(@\"extern { fn a(); }\");\n         assert!(doc.cratemod().nmods()[0].fns[0].name() == ~\"a\");\n     }\n \n     #[test]\n     fn extract_mods_deep() {\n-        let doc = mk_doc(~\"mod a { mod b { mod c { } } }\");\n+        let doc = mk_doc(@\"mod a { mod b { mod c { } } }\");\n         assert!(doc.cratemod().mods()[0].mods()[0].mods()[0].name() ==\n             ~\"c\");\n     }\n \n     #[test]\n     fn extract_should_set_mod_ast_id() {\n-        let doc = mk_doc(~\"mod a { }\");\n+        let doc = mk_doc(@\"mod a { }\");\n         assert!(doc.cratemod().mods()[0].id() != 0);\n     }\n \n     #[test]\n     fn extract_fns() {\n         let doc = mk_doc(\n-            ~\"fn a() { } \\\n+            @\"fn a() { } \\\n               mod b { fn c() {\n              } }\");\n         assert!(doc.cratemod().fns()[0].name() == ~\"a\");\n@@ -338,13 +338,13 @@ mod test {\n \n     #[test]\n     fn extract_should_set_fn_ast_id() {\n-        let doc = mk_doc(~\"fn a() { }\");\n+        let doc = mk_doc(@\"fn a() { }\");\n         assert!(doc.cratemod().fns()[0].id() != 0);\n     }\n \n     #[test]\n     fn extract_should_use_default_crate_name() {\n-        let source = ~\"\";\n+        let source = @\"\";\n         let ast = parse::from_str(source);\n         let doc = extract(ast, ~\"burp\");\n         assert!(doc.cratemod().name() == ~\"burp\");\n@@ -361,57 +361,57 @@ mod test {\n \n     #[test]\n     fn should_extract_const_name_and_id() {\n-        let doc = mk_doc(~\"static a: int = 0;\");\n+        let doc = mk_doc(@\"static a: int = 0;\");\n         assert!(doc.cratemod().consts()[0].id() != 0);\n         assert!(doc.cratemod().consts()[0].name() == ~\"a\");\n     }\n \n     #[test]\n     fn should_extract_enums() {\n-        let doc = mk_doc(~\"enum e { v }\");\n+        let doc = mk_doc(@\"enum e { v }\");\n         assert!(doc.cratemod().enums()[0].id() != 0);\n         assert!(doc.cratemod().enums()[0].name() == ~\"e\");\n     }\n \n     #[test]\n     fn should_extract_enum_variants() {\n-        let doc = mk_doc(~\"enum e { v }\");\n+        let doc = mk_doc(@\"enum e { v }\");\n         assert!(doc.cratemod().enums()[0].variants[0].name == ~\"v\");\n     }\n \n     #[test]\n     fn should_extract_traits() {\n-        let doc = mk_doc(~\"trait i { fn f(); }\");\n+        let doc = mk_doc(@\"trait i { fn f(); }\");\n         assert!(doc.cratemod().traits()[0].name() == ~\"i\");\n     }\n \n     #[test]\n     fn should_extract_trait_methods() {\n-        let doc = mk_doc(~\"trait i { fn f(); }\");\n+        let doc = mk_doc(@\"trait i { fn f(); }\");\n         assert!(doc.cratemod().traits()[0].methods[0].name == ~\"f\");\n     }\n \n     #[test]\n     fn should_extract_impl_methods() {\n-        let doc = mk_doc(~\"impl int { fn f() { } }\");\n+        let doc = mk_doc(@\"impl int { fn f() { } }\");\n         assert!(doc.cratemod().impls()[0].methods[0].name == ~\"f\");\n     }\n \n     #[test]\n     fn should_extract_tys() {\n-        let doc = mk_doc(~\"type a = int;\");\n+        let doc = mk_doc(@\"type a = int;\");\n         assert!(doc.cratemod().types()[0].name() == ~\"a\");\n     }\n \n     #[test]\n     fn should_extract_structs() {\n-        let doc = mk_doc(~\"struct Foo { field: () }\");\n+        let doc = mk_doc(@\"struct Foo { field: () }\");\n         assert!(doc.cratemod().structs()[0].name() == ~\"Foo\");\n     }\n \n     #[test]\n     fn should_extract_struct_fields() {\n-        let doc = mk_doc(~\"struct Foo { field: () }\");\n+        let doc = mk_doc(@\"struct Foo { field: () }\");\n         assert!(doc.cratemod().structs()[0].fields[0] == ~\"field\");\n     }\n }"}, {"sha": "7cf616065d381e047ce0b23a27bc54335b6fb5a1", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -368,7 +368,7 @@ pub fn default_seq_fold_struct<T>(\n \n #[test]\n fn default_fold_should_produce_same_doc() {\n-    let source = ~\"mod a { fn b() { } mod c { fn d() { } } }\";\n+    let source = @\"mod a { fn b() { } mod c { fn d() { } } }\";\n     let ast = parse::from_str(source);\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_seq_fold(());\n@@ -378,7 +378,7 @@ fn default_fold_should_produce_same_doc() {\n \n #[test]\n fn default_fold_should_produce_same_consts() {\n-    let source = ~\"static a: int = 0;\";\n+    let source = @\"static a: int = 0;\";\n     let ast = parse::from_str(source);\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_seq_fold(());\n@@ -388,7 +388,7 @@ fn default_fold_should_produce_same_consts() {\n \n #[test]\n fn default_fold_should_produce_same_enums() {\n-    let source = ~\"enum a { b }\";\n+    let source = @\"enum a { b }\";\n     let ast = parse::from_str(source);\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_seq_fold(());\n@@ -398,7 +398,7 @@ fn default_fold_should_produce_same_enums() {\n \n #[test]\n fn default_parallel_fold_should_produce_same_doc() {\n-    let source = ~\"mod a { fn b() { } mod c { fn d() { } } }\";\n+    let source = @\"mod a { fn b() { } mod c { fn d() { } } }\";\n     let ast = parse::from_str(source);\n     let doc = extract::extract(ast, ~\"\");\n     let fld = default_par_fold(());"}, {"sha": "138e4d49156de9d2215c9c1d3b5ffb31a1df2077", "filename": "src/librustdoc/parse.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustdoc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustdoc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fparse.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -23,21 +23,21 @@ pub fn from_file(file: &Path) -> @ast::crate {\n         file, ~[], parse::new_parse_sess(None))\n }\n \n-pub fn from_str(source: ~str) -> @ast::crate {\n+pub fn from_str(source: @str) -> @ast::crate {\n     parse::parse_crate_from_source_str(\n-        ~\"-\", @source, ~[], parse::new_parse_sess(None))\n+        @\"-\", source, ~[], parse::new_parse_sess(None))\n }\n \n pub fn from_file_sess(sess: session::Session, file: &Path) -> @ast::crate {\n     parse::parse_crate_from_file(\n         file, cfg(sess, file_input(copy *file)), sess.parse_sess)\n }\n \n-pub fn from_str_sess(sess: session::Session, source: ~str) -> @ast::crate {\n+pub fn from_str_sess(sess: session::Session, source: @str) -> @ast::crate {\n     parse::parse_crate_from_source_str(\n-        ~\"-\", @copy source, cfg(sess, str_input(source)), sess.parse_sess)\n+        @\"-\", source, cfg(sess, str_input(source)), sess.parse_sess)\n }\n \n fn cfg(sess: session::Session, input: driver::input) -> ast::crate_cfg {\n-    driver::build_configuration(sess, @~\"rustdoc\", &input)\n+    driver::build_configuration(sess, @\"rustdoc\", &input)\n }"}, {"sha": "8df1018a0defa56b4ce559890ce28d7747423ad1", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -117,7 +117,7 @@ fn record(mut repl: Repl, blk: &ast::blk, intr: @token::ident_interner) -> Repl\n \n /// Run an input string in a Repl, returning the new Repl.\n fn run(repl: Repl, input: ~str) -> Repl {\n-    let binary = @copy repl.binary;\n+    let binary = repl.binary.to_managed();\n     let options = @session::options {\n         crate_type: session::unknown_crate,\n         binary: binary,\n@@ -130,7 +130,7 @@ fn run(repl: Repl, input: ~str) -> Repl {\n     let head = include_str!(\"wrapper.rs\").to_owned();\n     let foot = fmt!(\"fn main() {\\n%s\\n%s\\n\\nprint({\\n%s\\n})\\n}\",\n                     repl.view_items, repl.stmts, input);\n-    let wrapped = driver::str_input(head + foot);\n+    let wrapped = driver::str_input((head + foot).to_managed());\n \n     debug!(\"inputting %s\", head + foot);\n \n@@ -186,7 +186,7 @@ fn run(repl: Repl, input: ~str) -> Repl {\n fn compile_crate(src_filename: ~str, binary: ~str) -> Option<bool> {\n     match do task::try {\n         let src_path = Path(src_filename);\n-        let binary = @copy binary;\n+        let binary = binary.to_managed();\n         let options = @session::options {\n             binary: binary,\n             addl_lib_search_paths: @mut ~[os::getcwd()],"}, {"sha": "f9dc9a6160f90afc8ff60463a047a121b6ce0cc0", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -100,7 +100,7 @@ impl<'self> PkgScript<'self> {\n     /// a PkgScript that we can then execute\n     fn parse<'a>(script: Path, workspace: &Path, id: &'a PkgId) -> PkgScript<'a> {\n         // Get the executable name that was invoked\n-        let binary = @copy os::args()[0];\n+        let binary = os::args()[0].to_managed();\n         // Build the rustc session data structures to pass\n         // to the compiler\n         let options = @session::options {\n@@ -145,7 +145,7 @@ impl<'self> PkgScript<'self> {\n                 let root = r.pop().pop().pop().pop(); // :-\\\n                 debug!(\"Root is %s, calling compile_rest\", root.to_str());\n                 let exe = self.build_dir.push(~\"pkg\" + util::exe_suffix());\n-                let binary = @copy os::args()[0];\n+                let binary = os::args()[0].to_managed();\n                 util::compile_crate_from_input(&self.input,\n                                                &self.build_dir,\n                                                sess,"}, {"sha": "1b863cd9a86430fa9e1f260d16ac77f05cc2a7ad", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -80,7 +80,7 @@ fn fold_mod(_ctx: @mut ReadyCtx,\n     fn strip_main(item: @ast::item) -> @ast::item {\n         @ast::item {\n             attrs: do item.attrs.filtered |attr| {\n-                *attr::get_attr_name(attr) != ~\"main\"\n+                \"main\" != attr::get_attr_name(attr)\n             },\n             .. copy *item\n         }\n@@ -109,7 +109,7 @@ fn fold_item(ctx: @mut ReadyCtx,\n                 ast::meta_list(_, ref mis) => {\n                     for mis.each |mi| {\n                         match mi.node {\n-                            ast::meta_word(cmd) => cmds.push(copy *cmd),\n+                            ast::meta_word(cmd) => cmds.push(cmd.to_owned()),\n                             _ => {}\n                         };\n                     }\n@@ -205,7 +205,7 @@ pub fn compile_input(ctxt: &Ctx,\n     // tjc: by default, use the package ID name as the link name\n     // not sure if we should support anything else\n \n-    let binary = @(copy os::args()[0]);\n+    let binary = os::args()[0].to_managed();\n \n     debug!(\"flags: %s\", flags.connect(\" \"));\n     debug!(\"cfgs: %s\", cfgs.connect(\" \"));\n@@ -270,11 +270,11 @@ pub fn compile_input(ctxt: &Ctx,\n         debug!(\"Injecting link name: %s\", short_name_to_use);\n         crate = @codemap::respan(crate.span, ast::crate_ {\n             attrs: ~[mk_attr(@dummy_spanned(\n-                meta_list(@~\"link\",\n-                 ~[@dummy_spanned(meta_name_value(@~\"name\",\n-                                      mk_string_lit(@short_name_to_use))),\n-                   @dummy_spanned(meta_name_value(@~\"vers\",\n-                         mk_string_lit(@pkg_id.version.to_str_nonempty())))])))],\n+                meta_list(@\"link\",\n+                 ~[@dummy_spanned(meta_name_value(@\"name\",\n+                                      mk_string_lit(short_name_to_use.to_managed()))),\n+                   @dummy_spanned(meta_name_value(@\"vers\",\n+                         mk_string_lit(pkg_id.version.to_str_nonempty().to_managed())))])))],\n             ..copy crate.node});\n     }\n \n@@ -363,24 +363,24 @@ fn find_and_install_dependencies(ctxt: &Ctx,\n                     None => ()\n                 };\n                 let lib_name = sess.str_of(lib_ident);\n-                match find_library_in_search_path(my_ctxt.sysroot_opt, *lib_name) {\n+                match find_library_in_search_path(my_ctxt.sysroot_opt, lib_name) {\n                     Some(installed_path) => {\n                         debug!(\"It exists: %s\", installed_path.to_str());\n                     }\n                     None => {\n                         // Try to install it\n-                        let pkg_id = PkgId::new(*lib_name);\n+                        let pkg_id = PkgId::new(lib_name);\n                         my_ctxt.install(&my_workspace, &pkg_id);\n                         let built_lib =\n                             built_library_in_workspace(&pkg_id,\n                                 &my_workspace).expect(fmt!(\"find_and_install_dependencies: \\\n                                 I thought I already built %s, but the library doesn't seem \\\n-                                to exist\", *lib_name));\n+                                to exist\", lib_name));\n                         // Also, add an additional search path\n                         let installed_path = target_library_in_workspace(&my_workspace,\n                                                                          &built_lib).pop();\n                         debug!(\"Great, I installed %s, and it's in %s\",\n-                               *lib_name, installed_path.to_str());\n+                               lib_name, installed_path.to_str());\n                         save(installed_path);\n                     }\n                 }\n@@ -415,7 +415,7 @@ pub fn link_exe(src: &Path, dest: &Path) -> bool {\n     }\n }\n \n-pub fn mk_string_lit(s: @~str) -> ast::lit {\n+pub fn mk_string_lit(s: @str) -> ast::lit {\n     spanned {\n         node: ast::lit_str(s),\n         span: dummy_sp()"}, {"sha": "9c4e8f083584c542adcaa501d18dbb3f1bfc7f6e", "filename": "src/libstd/path.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -22,7 +22,7 @@ use iterator::IteratorUtil;\n use libc;\n use option::{None, Option, Some};\n use str;\n-use str::{StrSlice, StrVector};\n+use str::{Str, StrSlice, StrVector};\n use to_str::ToStr;\n use ascii::{AsciiCast, AsciiStr};\n use old_iter::BaseIter;\n@@ -102,7 +102,7 @@ pub trait GenericPath {\n     fn push_rel(&self, (&Self)) -> Self;\n     /// Returns a new Path consisting of the path given by the given vector\n     /// of strings, relative to `self`.\n-    fn push_many(&self, (&[~str])) -> Self;\n+    fn push_many<S: Str>(&self, (&[S])) -> Self;\n     /// Identical to `dir_path` except in the case where `self` has only one\n     /// component. In this case, `pop` returns the empty path.\n     fn pop(&self) -> Self;\n@@ -566,10 +566,10 @@ impl GenericPath for PosixPath {\n         false\n     }\n \n-    fn push_many(&self, cs: &[~str]) -> PosixPath {\n+    fn push_many<S: Str>(&self, cs: &[S]) -> PosixPath {\n         let mut v = copy self.components;\n         for cs.each |e| {\n-            for e.split_iter(windows::is_sep).advance |s| {\n+            for e.as_slice().split_iter(windows::is_sep).advance |s| {\n                 if !s.is_empty() {\n                     v.push(s.to_owned())\n                 }\n@@ -823,10 +823,10 @@ impl GenericPath for WindowsPath {\n         }\n     }\n \n-    fn push_many(&self, cs: &[~str]) -> WindowsPath {\n+    fn push_many<S: Str>(&self, cs: &[S]) -> WindowsPath {\n         let mut v = copy self.components;\n         for cs.each |e| {\n-            for e.split_iter(windows::is_sep).advance |s| {\n+            for e.as_slice().split_iter(windows::is_sep).advance |s| {\n                 if !s.is_empty() {\n                     v.push(s.to_owned())\n                 }"}, {"sha": "4400cb5de9833522788f52237b37fd03f548b1e1", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -64,7 +64,7 @@ pub use path::PosixPath;\n pub use path::WindowsPath;\n pub use ptr::RawPtr;\n pub use ascii::{Ascii, AsciiCast, OwnedAsciiCast, AsciiStr};\n-pub use str::{StrVector, StrSlice, OwnedStr, StrUtil, NullTerminatedStr};\n+pub use str::{Str, StrVector, StrSlice, OwnedStr, StrUtil, NullTerminatedStr};\n pub use from_str::{FromStr};\n pub use to_bytes::IterBytes;\n pub use to_str::{ToStr, ToStrConsume};"}, {"sha": "c928933f4a74ca10bedee563f259a17bd53bb2f9", "filename": "src/libstd/str.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -729,10 +729,22 @@ impl Ord for @str {\n }\n \n #[cfg(not(test))]\n-impl<'self> Equiv<~str> for &'self str {\n+impl<'self, S: Str> Equiv<S> for &'self str {\n     #[inline(always)]\n-    fn equiv(&self, other: &~str) -> bool { eq_slice(*self, *other) }\n+    fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n }\n+#[cfg(not(test))]\n+impl<'self, S: Str> Equiv<S> for @str {\n+    #[inline(always)]\n+    fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n+}\n+\n+#[cfg(not(test))]\n+impl<'self, S: Str> Equiv<S> for ~str {\n+    #[inline(always)]\n+    fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n+}\n+\n \n /*\n Section: Iterating through strings"}, {"sha": "e3182916723b70808be0c1813660e453be20dee8", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -84,7 +84,7 @@ pub type Mrk = uint;\n \n impl<S:Encoder> Encodable<S> for ident {\n     fn encode(&self, s: &mut S) {\n-        s.emit_str(*interner_get(self.name));\n+        s.emit_str(interner_get(self.name));\n     }\n }\n \n@@ -228,9 +228,9 @@ pub type meta_item = spanned<meta_item_>;\n \n #[deriving(Eq, Encodable, Decodable)]\n pub enum meta_item_ {\n-    meta_word(@~str),\n-    meta_list(@~str, ~[@meta_item]),\n-    meta_name_value(@~str, lit),\n+    meta_word(@str),\n+    meta_list(@str, ~[@meta_item]),\n+    meta_name_value(@str, lit),\n }\n \n pub type blk = spanned<blk_>;\n@@ -634,12 +634,12 @@ pub type lit = spanned<lit_>;\n \n #[deriving(Eq, Encodable, Decodable)]\n pub enum lit_ {\n-    lit_str(@~str),\n+    lit_str(@str),\n     lit_int(i64, int_ty),\n     lit_uint(u64, uint_ty),\n     lit_int_unsuffixed(i64),\n-    lit_float(@~str, float_ty),\n-    lit_float_unsuffixed(@~str),\n+    lit_float(@str, float_ty),\n+    lit_float_unsuffixed(@str),\n     lit_nil,\n     lit_bool(bool),\n }\n@@ -819,10 +819,10 @@ pub enum asm_dialect {\n \n #[deriving(Eq, Encodable, Decodable)]\n pub struct inline_asm {\n-    asm: @~str,\n-    clobbers: @~str,\n-    inputs: ~[(@~str, @expr)],\n-    outputs: ~[(@~str, @expr)],\n+    asm: @str,\n+    clobbers: @str,\n+    inputs: ~[(@str, @expr)],\n+    outputs: ~[(@str, @expr)],\n     volatile: bool,\n     alignstack: bool,\n     dialect: asm_dialect"}, {"sha": "ca91d3a4f8cb91b7611a26a8d8a7fd90cb06aa6b", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -58,8 +58,8 @@ pub fn path_to_str_with_sep(p: &[path_elt], sep: &str, itr: @ident_interner)\n                          -> ~str {\n     let strs = do p.map |e| {\n         match *e {\n-          path_mod(s) => copy *itr.get(s.name),\n-          path_name(s) => copy *itr.get(s.name)\n+          path_mod(s) => itr.get(s.name),\n+          path_name(s) => itr.get(s.name)\n         }\n     };\n     strs.connect(sep)\n@@ -68,9 +68,9 @@ pub fn path_to_str_with_sep(p: &[path_elt], sep: &str, itr: @ident_interner)\n pub fn path_ident_to_str(p: &path, i: ident, itr: @ident_interner) -> ~str {\n     if p.is_empty() {\n         //FIXME /* FIXME (#2543) */ copy *i\n-        copy *itr.get(i.name)\n+        itr.get(i.name).to_owned()\n     } else {\n-        fmt!(\"%s::%s\", path_to_str(*p, itr), *itr.get(i.name))\n+        fmt!(\"%s::%s\", path_to_str(*p, itr), itr.get(i.name))\n     }\n }\n \n@@ -80,8 +80,8 @@ pub fn path_to_str(p: &[path_elt], itr: @ident_interner) -> ~str {\n \n pub fn path_elt_to_str(pe: path_elt, itr: @ident_interner) -> ~str {\n     match pe {\n-        path_mod(s) => copy *itr.get(s.name),\n-        path_name(s) => copy *itr.get(s.name)\n+        path_mod(s) => itr.get(s.name).to_owned(),\n+        path_name(s) => itr.get(s.name).to_owned()\n     }\n }\n \n@@ -359,16 +359,16 @@ pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n       }\n       Some(&node_method(m, _, path)) => {\n         fmt!(\"method %s in %s (id=%?)\",\n-             *itr.get(m.ident.name), path_to_str(*path, itr), id)\n+             itr.get(m.ident.name), path_to_str(*path, itr), id)\n       }\n       Some(&node_trait_method(ref tm, _, path)) => {\n         let m = ast_util::trait_method_to_ty_method(&**tm);\n         fmt!(\"method %s in %s (id=%?)\",\n-             *itr.get(m.ident.name), path_to_str(*path, itr), id)\n+             itr.get(m.ident.name), path_to_str(*path, itr), id)\n       }\n       Some(&node_variant(ref variant, _, path)) => {\n         fmt!(\"variant %s in %s (id=%?)\",\n-             *itr.get(variant.node.name.name), path_to_str(*path, itr), id)\n+             itr.get(variant.node.name.name), path_to_str(*path, itr), id)\n       }\n       Some(&node_expr(expr)) => {\n         fmt!(\"expr %s (id=%?)\", pprust::expr_to_str(expr, itr), id)\n@@ -384,7 +384,7 @@ pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n         fmt!(\"arg (id=%?)\", id)\n       }\n       Some(&node_local(ident)) => {\n-        fmt!(\"local (id=%?, name=%s)\", id, *itr.get(ident.name))\n+        fmt!(\"local (id=%?, name=%s)\", id, itr.get(ident.name))\n       }\n       Some(&node_block(_)) => {\n         fmt!(\"block\")"}, {"sha": "d4aa922931949baf7cfbd571bf493b01e3eecf98", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -28,7 +28,7 @@ use core::iterator::IteratorUtil;\n \n pub fn path_name_i(idents: &[ident]) -> ~str {\n     // FIXME: Bad copies (#2543 -- same for everything else that says \"bad\")\n-    idents.map(|i| copy *token::interner_get(i.name)).connect(\"::\")\n+    idents.map(|i| token::interner_get(i.name)).connect(\"::\")\n }\n \n pub fn path_to_ident(p: @Path) -> ident { copy *p.idents.last() }\n@@ -815,7 +815,7 @@ mod test {\n         assert_eq!(copy s,~[14]);\n     }\n \n-    // convert a list of uints to an @~[ident]\n+    // convert a list of uints to an @[ident]\n     // (ignores the interner completely)\n     fn uints_to_idents (uints: &~[uint]) -> @~[ident] {\n         @uints.map(|u|{ ident {name:*u, ctxt: empty_ctxt} })"}, {"sha": "1bf21c188862aa879098561226cd940f05f10aa2", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -26,23 +26,23 @@ use extra;\n \n /* Constructors */\n \n-pub fn mk_name_value_item_str(name: @~str, value: @~str)\n+pub fn mk_name_value_item_str(name: @str, value: @str)\n                            -> @ast::meta_item {\n     let value_lit = dummy_spanned(ast::lit_str(value));\n     mk_name_value_item(name, value_lit)\n }\n \n-pub fn mk_name_value_item(name: @~str, value: ast::lit)\n+pub fn mk_name_value_item(name: @str, value: ast::lit)\n         -> @ast::meta_item {\n     @dummy_spanned(ast::meta_name_value(name, value))\n }\n \n-pub fn mk_list_item(name: @~str, items: ~[@ast::meta_item]) ->\n+pub fn mk_list_item(name: @str, items: ~[@ast::meta_item]) ->\n    @ast::meta_item {\n     @dummy_spanned(ast::meta_list(name, items))\n }\n \n-pub fn mk_word_item(name: @~str) -> @ast::meta_item {\n+pub fn mk_word_item(name: @str) -> @ast::meta_item {\n     @dummy_spanned(ast::meta_word(name))\n }\n \n@@ -52,13 +52,13 @@ pub fn mk_attr(item: @ast::meta_item) -> ast::attribute {\n                                     is_sugared_doc: false })\n }\n \n-pub fn mk_sugared_doc_attr(text: ~str,\n+pub fn mk_sugared_doc_attr(text: @str,\n                            lo: BytePos, hi: BytePos) -> ast::attribute {\n     let style = doc_comment_style(text);\n-    let lit = spanned(lo, hi, ast::lit_str(@text));\n+    let lit = spanned(lo, hi, ast::lit_str(text));\n     let attr = ast::attribute_ {\n         style: style,\n-        value: @spanned(lo, hi, ast::meta_name_value(@~\"doc\", lit)),\n+        value: @spanned(lo, hi, ast::meta_name_value(@\"doc\", lit)),\n         is_sugared_doc: true\n     };\n     spanned(lo, hi, attr)\n@@ -78,8 +78,8 @@ pub fn attr_metas(attrs: &[ast::attribute]) -> ~[@ast::meta_item] {\n pub fn desugar_doc_attr(attr: &ast::attribute) -> ast::attribute {\n     if attr.node.is_sugared_doc {\n         let comment = get_meta_item_value_str(attr.node.value).get();\n-        let meta = mk_name_value_item_str(@~\"doc\",\n-                                     @strip_doc_comment_decoration(*comment));\n+        let meta = mk_name_value_item_str(@\"doc\",\n+                                     strip_doc_comment_decoration(comment).to_managed());\n         mk_attr(meta)\n     } else {\n         *attr\n@@ -88,11 +88,11 @@ pub fn desugar_doc_attr(attr: &ast::attribute) -> ast::attribute {\n \n /* Accessors */\n \n-pub fn get_attr_name(attr: &ast::attribute) -> @~str {\n+pub fn get_attr_name(attr: &ast::attribute) -> @str {\n     get_meta_item_name(attr.node.value)\n }\n \n-pub fn get_meta_item_name(meta: @ast::meta_item) -> @~str {\n+pub fn get_meta_item_name(meta: @ast::meta_item) -> @str {\n     match meta.node {\n         ast::meta_word(n) => n,\n         ast::meta_name_value(n, _) => n,\n@@ -104,7 +104,7 @@ pub fn get_meta_item_name(meta: @ast::meta_item) -> @~str {\n  * Gets the string value if the meta_item is a meta_name_value variant\n  * containing a string, otherwise none\n  */\n-pub fn get_meta_item_value_str(meta: @ast::meta_item) -> Option<@~str> {\n+pub fn get_meta_item_value_str(meta: @ast::meta_item) -> Option<@str> {\n     match meta.node {\n         ast::meta_name_value(_, v) => {\n             match v.node {\n@@ -130,7 +130,7 @@ pub fn get_meta_item_list(meta: @ast::meta_item)\n  * a tuple containing the name and string value, otherwise `none`\n  */\n pub fn get_name_value_str_pair(item: @ast::meta_item)\n-                            -> Option<(@~str, @~str)> {\n+                            -> Option<(@str, @str)> {\n     match attr::get_meta_item_value_str(item) {\n       Some(value) => {\n         let name = attr::get_meta_item_name(item);\n@@ -147,7 +147,7 @@ pub fn get_name_value_str_pair(item: @ast::meta_item)\n pub fn find_attrs_by_name(attrs: &[ast::attribute], name: &str) ->\n    ~[ast::attribute] {\n     do vec::filter_mapped(attrs) |a| {\n-        if name == *get_attr_name(a) {\n+        if name == get_attr_name(a) {\n             Some(*a)\n         } else {\n             None\n@@ -160,7 +160,7 @@ pub fn find_meta_items_by_name(metas: &[@ast::meta_item], name: &str) ->\n    ~[@ast::meta_item] {\n     let mut rs = ~[];\n     for metas.each |mi| {\n-        if name == *get_meta_item_name(*mi) {\n+        if name == get_meta_item_name(*mi) {\n             rs.push(*mi)\n         }\n     }\n@@ -214,7 +214,7 @@ pub fn attrs_contains_name(attrs: &[ast::attribute], name: &str) -> bool {\n }\n \n pub fn first_attr_value_str_by_name(attrs: &[ast::attribute], name: &str)\n-                                 -> Option<@~str> {\n+                                 -> Option<@str> {\n \n     let mattrs = find_attrs_by_name(attrs, name);\n     if mattrs.len() > 0 {\n@@ -232,7 +232,7 @@ fn last_meta_item_by_name(items: &[@ast::meta_item], name: &str)\n }\n \n pub fn last_meta_item_value_str_by_name(items: &[@ast::meta_item], name: &str)\n-                                     -> Option<@~str> {\n+                                     -> Option<@str> {\n \n     match last_meta_item_by_name(items, name) {\n         Some(item) => {\n@@ -282,7 +282,7 @@ pub fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: &str) ->\n    ~[@ast::meta_item] {\n \n     return vec::filter_mapped(items, |item| {\n-        if name != *get_meta_item_name(*item) {\n+        if name != get_meta_item_name(*item) {\n             Some(*item)\n         } else {\n             None\n@@ -316,8 +316,8 @@ pub fn find_inline_attr(attrs: &[ast::attribute]) -> inline_attr {\n     // FIXME (#2809)---validate the usage of #[inline] and #[inline(always)]\n     do attrs.iter().fold(ia_none) |ia,attr| {\n         match attr.node.value.node {\n-          ast::meta_word(@~\"inline\") => ia_hint,\n-          ast::meta_list(@~\"inline\", ref items) => {\n+          ast::meta_word(s) if \"inline\" == s => ia_hint,\n+          ast::meta_list(s, ref items) if \"inline\" == s => {\n             if !find_meta_items_by_name(*items, \"always\").is_empty() {\n                 ia_always\n             } else if !find_meta_items_by_name(*items, \"never\").is_empty() {\n@@ -341,7 +341,7 @@ pub fn require_unique_names(diagnostic: @span_handler,\n         // FIXME: How do I silence the warnings? --pcw (#2619)\n         if !set.insert(name) {\n             diagnostic.span_fatal(meta.span,\n-                                  fmt!(\"duplicate meta item `%s`\", *name));\n+                                  fmt!(\"duplicate meta item `%s`\", name));\n         }\n     }\n }"}, {"sha": "0c09a001d48ec92b143fb487143ea76db89598a0", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -184,7 +184,7 @@ pub struct Loc {\n // Actually, *none* of the clients use the filename *or* file field;\n // perhaps they should just be removed.\n pub struct LocWithOpt {\n-    filename: ~str,\n+    filename: FileName,\n     line: uint,\n     col: CharPos,\n     file: Option<@FileMap>,\n@@ -193,7 +193,7 @@ pub struct LocWithOpt {\n // used to be structural records. Better names, anyone?\n pub struct FileMapAndLine {fm: @FileMap, line: uint}\n pub struct FileMapAndBytePos {fm: @FileMap, pos: BytePos}\n-pub struct NameAndSpan {name: ~str, span: Option<span>}\n+pub struct NameAndSpan {name: @str, span: Option<span>}\n \n impl to_bytes::IterBytes for NameAndSpan {\n     fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n@@ -227,7 +227,7 @@ impl to_bytes::IterBytes for ExpnInfo {\n     }\n }\n \n-pub type FileName = ~str;\n+pub type FileName = @str;\n \n pub struct FileLines\n {\n@@ -261,7 +261,7 @@ pub struct FileMap {\n     /// Extra information used by qquote\n     substr: FileSubstr,\n     /// The complete source code\n-    src: @~str,\n+    src: @str,\n     /// The start position of this source in the CodeMap\n     start_pos: BytePos,\n     /// Locations of lines beginnings in the source code\n@@ -316,14 +316,14 @@ impl CodeMap {\n     }\n \n     /// Add a new FileMap to the CodeMap and return it\n-    pub fn new_filemap(&self, filename: FileName, src: @~str) -> @FileMap {\n+    pub fn new_filemap(&self, filename: FileName, src: @str) -> @FileMap {\n         return self.new_filemap_w_substr(filename, FssNone, src);\n     }\n \n     pub fn new_filemap_w_substr(&self,\n                                 filename: FileName,\n                                 substr: FileSubstr,\n-                                src: @~str)\n+                                src: @str)\n                                 -> @FileMap {\n         let files = &mut *self.files;\n         let start_pos = if files.len() == 0 {\n@@ -362,7 +362,7 @@ impl CodeMap {\n         match (loc.file.substr) {\n             FssNone =>\n             LocWithOpt {\n-                filename: /* FIXME (#2543) */ copy loc.file.name,\n+                filename: loc.file.name,\n                 line: loc.line,\n                 col: loc.col,\n                 file: Some(loc.file)},\n@@ -421,8 +421,8 @@ impl CodeMap {\n                           begin.pos.to_uint(), end.pos.to_uint()).to_owned();\n     }\n \n-    pub fn get_filemap(&self, filename: ~str) -> @FileMap {\n-        for self.files.each |fm| { if fm.name == filename { return *fm; } }\n+    pub fn get_filemap(&self, filename: &str) -> @FileMap {\n+        for self.files.each |fm| { if filename == fm.name { return *fm; } }\n         //XXjdm the following triggers a mismatched type bug\n         //      (or expected function, found _|_)\n         fail!(); // (\"asking for \" + filename + \" which we don't know about\");\n@@ -532,7 +532,7 @@ mod test {\n     #[test]\n     fn t1 () {\n         let cm = CodeMap::new();\n-        let fm = cm.new_filemap(~\"blork.rs\",@~\"first line.\\nsecond line\");\n+        let fm = cm.new_filemap(@\"blork.rs\",@\"first line.\\nsecond line\");\n         fm.next_line(BytePos(0));\n         assert_eq!(&fm.get_line(0),&~\"first line.\");\n         // TESTING BROKEN BEHAVIOR:\n@@ -544,7 +544,7 @@ mod test {\n     #[should_fail]\n     fn t2 () {\n         let cm = CodeMap::new();\n-        let fm = cm.new_filemap(~\"blork.rs\",@~\"first line.\\nsecond line\");\n+        let fm = cm.new_filemap(@\"blork.rs\",@\"first line.\\nsecond line\");\n         // TESTING *REALLY* BROKEN BEHAVIOR:\n         fm.next_line(BytePos(0));\n         fm.next_line(BytePos(10));"}, {"sha": "36100e3f52f990a7b9ccf850a46e9fbe78fb0ed6", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -306,8 +306,8 @@ fn highlight_lines(cm: @codemap::CodeMap,\n \n fn print_macro_backtrace(cm: @codemap::CodeMap, sp: span) {\n     for sp.expn_info.iter().advance |ei| {\n-        let ss = ei.callee.span.map_default(@~\"\", |span| @cm.span_to_str(*span));\n-        print_diagnostic(*ss, note,\n+        let ss = ei.callee.span.map_default(~\"\", |span| cm.span_to_str(*span));\n+        print_diagnostic(ss, note,\n                          fmt!(\"in expansion of %s!\", ei.callee.name));\n         let ss = cm.span_to_str(ei.call_site);\n         print_diagnostic(ss, note, \"expansion site\");"}, {"sha": "0394ccb3efb19ee265284d4cf71ebaba316d9ab8", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -45,7 +45,7 @@ pub fn expand_asm(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n                                        cx.cfg(),\n                                        tts.to_owned());\n \n-    let mut asm = ~\"\";\n+    let mut asm = @\"\";\n     let mut outputs = ~[];\n     let mut inputs = ~[];\n     let mut cons = ~\"\";\n@@ -113,7 +113,7 @@ pub fn expand_asm(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n                         p.eat(&token::COMMA);\n                     }\n \n-                    let clob = ~\"~{\" + *p.parse_str() + \"}\";\n+                    let clob = fmt!(\"~{%s}\", p.parse_str());\n                     clobs.push(clob);\n                 }\n \n@@ -122,11 +122,11 @@ pub fn expand_asm(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n             Options => {\n                 let option = p.parse_str();\n \n-                if \"volatile\" == *option {\n+                if \"volatile\" == option {\n                     volatile = true;\n-                } else if \"alignstack\" == *option {\n+                } else if \"alignstack\" == option {\n                     alignstack = true;\n-                } else if \"intel\" == *option {\n+                } else if \"intel\" == option {\n                     dialect = ast::asm_intel;\n                 }\n \n@@ -176,8 +176,8 @@ pub fn expand_asm(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     MRExpr(@ast::expr {\n         id: cx.next_id(),\n         node: ast::expr_inline_asm(ast::inline_asm {\n-            asm: @asm,\n-            clobbers: @cons,\n+            asm: asm,\n+            clobbers: cons.to_managed(),\n             inputs: inputs,\n             outputs: outputs,\n             volatile: volatile,"}, {"sha": "8e30a5880d54b9eedff9eedda525d07930228965", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -33,7 +33,7 @@ use core::hashmap::HashMap;\n // ast::mac_invoc_tt.\n \n pub struct MacroDef {\n-    name: ~str,\n+    name: @str,\n     ext: SyntaxExtension\n }\n \n@@ -308,18 +308,18 @@ impl ExtCtxt {\n     pub fn set_trace_macros(&self, x: bool) {\n         *self.trace_mac = x\n     }\n-    pub fn str_of(&self, id: ast::ident) -> ~str {\n-        copy *ident_to_str(&id)\n+    pub fn str_of(&self, id: ast::ident) -> @str {\n+        ident_to_str(&id)\n     }\n     pub fn ident_of(&self, st: &str) -> ast::ident {\n         str_to_ident(st)\n     }\n }\n \n-pub fn expr_to_str(cx: @ExtCtxt, expr: @ast::expr, err_msg: ~str) -> ~str {\n+pub fn expr_to_str(cx: @ExtCtxt, expr: @ast::expr, err_msg: ~str) -> @str {\n     match expr.node {\n       ast::expr_lit(l) => match l.node {\n-        ast::lit_str(s) => copy *s,\n+        ast::lit_str(s) => s,\n         _ => cx.span_fatal(l.span, err_msg)\n       },\n       _ => cx.span_fatal(expr.span, err_msg)\n@@ -350,7 +350,7 @@ pub fn check_zero_tts(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree],\n pub fn get_single_str_from_tts(cx: @ExtCtxt,\n                                sp: span,\n                                tts: &[ast::token_tree],\n-                               name: &str) -> ~str {\n+                               name: &str) -> @str {\n     if tts.len() != 1 {\n         cx.span_fatal(sp, fmt!(\"%s takes 1 argument.\", name));\n     }\n@@ -538,25 +538,25 @@ mod test {\n \n     #[test] fn testenv () {\n         let mut a = HashMap::new();\n-        a.insert (@~\"abc\",@15);\n+        a.insert (@\"abc\",@15);\n         let m = MapChain::new(~a);\n-        m.insert (@~\"def\",@16);\n-        // FIXME: #4492 (ICE)  assert_eq!(m.find(&@~\"abc\"),Some(@15));\n-        //  ....               assert_eq!(m.find(&@~\"def\"),Some(@16));\n-        assert_eq!(*(m.find(&@~\"abc\").get()),15);\n-        assert_eq!(*(m.find(&@~\"def\").get()),16);\n+        m.insert (@\"def\",@16);\n+        // FIXME: #4492 (ICE)  assert_eq!(m.find(&@\"abc\"),Some(@15));\n+        //  ....               assert_eq!(m.find(&@\"def\"),Some(@16));\n+        assert_eq!(*(m.find(&@\"abc\").get()),15);\n+        assert_eq!(*(m.find(&@\"def\").get()),16);\n         let n = m.push_frame();\n         // old bindings are still present:\n-        assert_eq!(*(n.find(&@~\"abc\").get()),15);\n-        assert_eq!(*(n.find(&@~\"def\").get()),16);\n-        n.insert (@~\"def\",@17);\n+        assert_eq!(*(n.find(&@\"abc\").get()),15);\n+        assert_eq!(*(n.find(&@\"def\").get()),16);\n+        n.insert (@\"def\",@17);\n         // n shows the new binding\n-        assert_eq!(*(n.find(&@~\"abc\").get()),15);\n-        assert_eq!(*(n.find(&@~\"def\").get()),17);\n+        assert_eq!(*(n.find(&@\"abc\").get()),15);\n+        assert_eq!(*(n.find(&@\"def\").get()),17);\n         // ... but m still has the old ones\n-        // FIXME: #4492: assert_eq!(m.find(&@~\"abc\"),Some(@15));\n-        // FIXME: #4492: assert_eq!(m.find(&@~\"def\"),Some(@16));\n-        assert_eq!(*(m.find(&@~\"abc\").get()),15);\n-        assert_eq!(*(m.find(&@~\"def\").get()),16);\n+        // FIXME: #4492: assert_eq!(m.find(&@\"abc\"),Some(@15));\n+        // FIXME: #4492: assert_eq!(m.find(&@\"def\"),Some(@16));\n+        assert_eq!(*(m.find(&@\"abc\").get()),15);\n+        assert_eq!(*(m.find(&@\"def\").get()),16);\n     }\n }"}, {"sha": "dc31a248065da247759b29207fe4d3b8dc19a75b", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -126,8 +126,8 @@ pub trait AstBuilder {\n     fn expr_vec(&self, sp: span, exprs: ~[@ast::expr]) -> @ast::expr;\n     fn expr_vec_uniq(&self, sp: span, exprs: ~[@ast::expr]) -> @ast::expr;\n     fn expr_vec_slice(&self, sp: span, exprs: ~[@ast::expr]) -> @ast::expr;\n-    fn expr_str(&self, sp: span, s: ~str) -> @ast::expr;\n-    fn expr_str_uniq(&self, sp: span, s: ~str) -> @ast::expr;\n+    fn expr_str(&self, sp: span, s: @str) -> @ast::expr;\n+    fn expr_str_uniq(&self, sp: span, s: @str) -> @ast::expr;\n \n     fn expr_unreachable(&self, span: span) -> @ast::expr;\n \n@@ -215,9 +215,9 @@ pub trait AstBuilder {\n \n     fn attribute(&self, sp: span, mi: @ast::meta_item) -> ast::attribute;\n \n-    fn meta_word(&self, sp: span, w: ~str) -> @ast::meta_item;\n-    fn meta_list(&self, sp: span, name: ~str, mis: ~[@ast::meta_item]) -> @ast::meta_item;\n-    fn meta_name_value(&self, sp: span, name: ~str, value: ast::lit_) -> @ast::meta_item;\n+    fn meta_word(&self, sp: span, w: @str) -> @ast::meta_item;\n+    fn meta_list(&self, sp: span, name: @str, mis: ~[@ast::meta_item]) -> @ast::meta_item;\n+    fn meta_name_value(&self, sp: span, name: @str, value: ast::lit_) -> @ast::meta_item;\n \n     fn view_use(&self, sp: span,\n                 vis: ast::visibility, vp: ~[@ast::view_path]) -> @ast::view_item;\n@@ -521,10 +521,10 @@ impl AstBuilder for @ExtCtxt {\n     fn expr_vec_slice(&self, sp: span, exprs: ~[@ast::expr]) -> @ast::expr {\n         self.expr_vstore(sp, self.expr_vec(sp, exprs), ast::expr_vstore_slice)\n     }\n-    fn expr_str(&self, sp: span, s: ~str) -> @ast::expr {\n-        self.expr_lit(sp, ast::lit_str(@s))\n+    fn expr_str(&self, sp: span, s: @str) -> @ast::expr {\n+        self.expr_lit(sp, ast::lit_str(s))\n     }\n-    fn expr_str_uniq(&self, sp: span, s: ~str) -> @ast::expr {\n+    fn expr_str_uniq(&self, sp: span, s: @str) -> @ast::expr {\n         self.expr_vstore(sp, self.expr_str(sp, s), ast::expr_vstore_uniq)\n     }\n \n@@ -540,8 +540,8 @@ impl AstBuilder for @ExtCtxt {\n                 self.ident_of(\"fail_with\"),\n             ],\n             ~[\n-                self.expr_str(span, ~\"internal error: entered unreachable code\"),\n-                self.expr_str(span, copy loc.file.name),\n+                self.expr_str(span, @\"internal error: entered unreachable code\"),\n+                self.expr_str(span, loc.file.name),\n                 self.expr_uint(span, loc.line),\n             ])\n     }\n@@ -791,14 +791,14 @@ impl AstBuilder for @ExtCtxt {\n                })\n     }\n \n-    fn meta_word(&self, sp: span, w: ~str) -> @ast::meta_item {\n-        @respan(sp, ast::meta_word(@w))\n+    fn meta_word(&self, sp: span, w: @str) -> @ast::meta_item {\n+        @respan(sp, ast::meta_word(w))\n     }\n-    fn meta_list(&self, sp: span, name: ~str, mis: ~[@ast::meta_item]) -> @ast::meta_item {\n-        @respan(sp, ast::meta_list(@name, mis))\n+    fn meta_list(&self, sp: span, name: @str, mis: ~[@ast::meta_item]) -> @ast::meta_item {\n+        @respan(sp, ast::meta_list(name, mis))\n     }\n-    fn meta_name_value(&self, sp: span, name: ~str, value: ast::lit_) -> @ast::meta_item {\n-        @respan(sp, ast::meta_name_value(@name, respan(sp, value)))\n+    fn meta_name_value(&self, sp: span, name: @str, value: ast::lit_) -> @ast::meta_item {\n+        @respan(sp, ast::meta_name_value(name, respan(sp, value)))\n     }\n \n     fn view_use(&self, sp: span,"}, {"sha": "abea7912fc8be41b7013ee0d4f6190e3cee5296a", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -72,7 +72,7 @@ fn decodable_substructure(cx: @ExtCtxt, span: span,\n             };\n             let read_struct_field = cx.ident_of(\"read_struct_field\");\n \n-            let getarg = |name: ~str, field: uint| {\n+            let getarg = |name: @str, field: uint| {\n                 cx.expr_method_call(span, blkdecoder, read_struct_field,\n                                     ~[cx.expr_str(span, name),\n                                       cx.expr_uint(span, field),\n@@ -86,7 +86,7 @@ fn decodable_substructure(cx: @ExtCtxt, span: span,\n                     } else {\n                         let mut fields = vec::with_capacity(n);\n                         for uint::range(0, n) |i| {\n-                            fields.push(getarg(fmt!(\"_field%u\", i), i));\n+                            fields.push(getarg(fmt!(\"_field%u\", i).to_managed(), i));\n                         }\n                         cx.expr_call_ident(span, substr.type_ident, fields)\n                     }"}, {"sha": "d7e64caa5c87cc75e00e7e27f3a0993a23c1eecc", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -127,7 +127,7 @@ fn encodable_substructure(cx: @ExtCtxt, span: span,\n             for fields.eachi |i, f| {\n                 let (name, val) = match *f {\n                     (Some(id), e, _) => (cx.str_of(id), e),\n-                    (None, e, _) => (fmt!(\"_field%u\", i), e)\n+                    (None, e, _) => (fmt!(\"_field%u\", i).to_managed(), e)\n                 };\n                 let enc = cx.expr_method_call(span, val, encode, ~[blkencoder]);\n                 let lambda = cx.lambda_expr_1(span, enc, blkarg);"}, {"sha": "5d07171bbb1d406ca4bdd6a826c95fb3b474487b", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -364,7 +364,7 @@ impl<'self> TraitDef<'self> {\n         let doc_attr = cx.attribute(\n             span,\n             cx.meta_name_value(span,\n-                               ~\"doc\", ast::lit_str(@~\"Automatically derived.\")));\n+                               @\"doc\", ast::lit_str(@\"Automatically derived.\")));\n         cx.item(\n             span,\n             ::parse::token::special_idents::clownshoes_extensions,"}, {"sha": "606e372a25da6f51542f6b900a63769ee7b8f98b", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -82,23 +82,23 @@ pub fn expand_meta_deriving(cx: @ExtCtxt,\n                     meta_word(tname) => {\n                         macro_rules! expand(($func:path) => ($func(cx, titem.span,\n                                                                    titem, in_items)));\n-                        match *tname {\n-                            ~\"Clone\" => expand!(clone::expand_deriving_clone),\n-                            ~\"DeepClone\" => expand!(clone::expand_deriving_deep_clone),\n+                        match tname.as_slice() {\n+                            \"Clone\" => expand!(clone::expand_deriving_clone),\n+                            \"DeepClone\" => expand!(clone::expand_deriving_deep_clone),\n \n-                            ~\"IterBytes\" => expand!(iter_bytes::expand_deriving_iter_bytes),\n+                            \"IterBytes\" => expand!(iter_bytes::expand_deriving_iter_bytes),\n \n-                            ~\"Encodable\" => expand!(encodable::expand_deriving_encodable),\n-                            ~\"Decodable\" => expand!(decodable::expand_deriving_decodable),\n+                            \"Encodable\" => expand!(encodable::expand_deriving_encodable),\n+                            \"Decodable\" => expand!(decodable::expand_deriving_decodable),\n \n-                            ~\"Eq\" => expand!(eq::expand_deriving_eq),\n-                            ~\"TotalEq\" => expand!(totaleq::expand_deriving_totaleq),\n-                            ~\"Ord\" => expand!(ord::expand_deriving_ord),\n-                            ~\"TotalOrd\" => expand!(totalord::expand_deriving_totalord),\n+                            \"Eq\" => expand!(eq::expand_deriving_eq),\n+                            \"TotalEq\" => expand!(totaleq::expand_deriving_totaleq),\n+                            \"Ord\" => expand!(ord::expand_deriving_ord),\n+                            \"TotalOrd\" => expand!(totalord::expand_deriving_totalord),\n \n-                            ~\"Rand\" => expand!(rand::expand_deriving_rand),\n+                            \"Rand\" => expand!(rand::expand_deriving_rand),\n \n-                            ~\"ToStr\" => expand!(to_str::expand_deriving_to_str),\n+                            \"ToStr\" => expand!(to_str::expand_deriving_to_str),\n \n                             ref tname => {\n                                 cx.span_err(titem.span, fmt!(\"unknown \\"}, {"sha": "34be6fc814322910b45cebfc698045d781f2170d", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -33,8 +33,8 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     // Option<str> rather than just an maybe-empty string.\n \n     let e = match os::getenv(var) {\n-      None => cx.expr_str(sp, ~\"\"),\n-      Some(ref s) => cx.expr_str(sp, copy *s)\n+      None => cx.expr_str(sp, @\"\"),\n+      Some(s) => cx.expr_str(sp, s.to_managed())\n     };\n     MRExpr(e)\n }"}, {"sha": "7ca8ab911de824865768c7e3e4460d2e851a33f9", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 47, "deletions": 48, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -57,7 +57,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                         None => {\n                             cx.span_fatal(\n                                 pth.span,\n-                                fmt!(\"macro undefined: '%s'\", *extnamestr))\n+                                fmt!(\"macro undefined: '%s'\", extnamestr))\n                         }\n                         Some(@SE(NormalTT(SyntaxExpanderTT{\n                             expander: exp,\n@@ -66,7 +66,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                             cx.bt_push(ExpandedFrom(CallInfo {\n                                 call_site: s,\n                                 callee: NameAndSpan {\n-                                    name: copy *extnamestr,\n+                                    name: extnamestr,\n                                     span: exp_sp,\n                                 },\n                             }));\n@@ -79,7 +79,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                                         pth.span,\n                                         fmt!(\n                                             \"non-expr macro in expr pos: %s\",\n-                                            *extnamestr\n+                                            extnamestr\n                                         )\n                                     )\n                                 }\n@@ -95,7 +95,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                         _ => {\n                             cx.span_fatal(\n                                 pth.span,\n-                                fmt!(\"'%s' is not a tt-style macro\", *extnamestr)\n+                                fmt!(\"'%s' is not a tt-style macro\", extnamestr)\n                             )\n                         }\n                     }\n@@ -132,12 +132,12 @@ pub fn expand_mod_items(extsbox: @mut SyntaxEnv,\n         do item.attrs.rev_iter().fold(~[*item]) |items, attr| {\n             let mname = attr::get_attr_name(attr);\n \n-            match (*extsbox).find(&intern(*mname)) {\n+            match (*extsbox).find(&intern(mname)) {\n               Some(@SE(ItemDecorator(dec_fn))) => {\n                   cx.bt_push(ExpandedFrom(CallInfo {\n                       call_site: attr.span,\n                       callee: NameAndSpan {\n-                          name: /*bad*/ copy *mname,\n+                          name: mname,\n                           span: None\n                       }\n                   }));\n@@ -201,7 +201,7 @@ pub fn expand_item(extsbox: @mut SyntaxEnv,\n \n // does this attribute list contain \"macro_escape\" ?\n pub fn contains_macro_escape (attrs: &[ast::attribute]) -> bool {\n-    attrs.any(|attr| \"macro_escape\" == *attr::get_attr_name(attr))\n+    attrs.any(|attr| \"macro_escape\" == attr::get_attr_name(attr))\n }\n \n // Support for item-position macro invocations, exactly the same\n@@ -221,19 +221,19 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n     let extnamestr = ident_to_str(extname);\n     let expanded = match (*extsbox).find(&extname.name) {\n         None => cx.span_fatal(pth.span,\n-                              fmt!(\"macro undefined: '%s!'\", *extnamestr)),\n+                              fmt!(\"macro undefined: '%s!'\", extnamestr)),\n \n         Some(@SE(NormalTT(ref expand))) => {\n             if it.ident != parse::token::special_idents::invalid {\n                 cx.span_fatal(pth.span,\n                               fmt!(\"macro %s! expects no ident argument, \\\n-                                    given '%s'\", *extnamestr,\n-                                   *ident_to_str(&it.ident)));\n+                                    given '%s'\", extnamestr,\n+                                   ident_to_str(&it.ident)));\n             }\n             cx.bt_push(ExpandedFrom(CallInfo {\n                 call_site: it.span,\n                 callee: NameAndSpan {\n-                    name: copy *extnamestr,\n+                    name: extnamestr,\n                     span: expand.span\n                 }\n             }));\n@@ -243,26 +243,25 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n             if it.ident == parse::token::special_idents::invalid {\n                 cx.span_fatal(pth.span,\n                               fmt!(\"macro %s! expects an ident argument\",\n-                                   *extnamestr));\n+                                   extnamestr));\n             }\n             cx.bt_push(ExpandedFrom(CallInfo {\n                 call_site: it.span,\n                 callee: NameAndSpan {\n-                    name: copy *extnamestr,\n+                    name: extnamestr,\n                     span: expand.span\n                 }\n             }));\n             ((*expand).expander)(cx, it.span, it.ident, tts)\n         }\n         _ => cx.span_fatal(\n-            it.span, fmt!(\"%s! is not legal in item position\", *extnamestr))\n+            it.span, fmt!(\"%s! is not legal in item position\", extnamestr))\n     };\n \n     let maybe_it = match expanded {\n         MRItem(it) => fld.fold_item(it),\n         MRExpr(_) => cx.span_fatal(pth.span,\n-                                    ~\"expr macro in item position: \"\n-                                    + *extnamestr),\n+                                   fmt!(\"expr macro in item position: %s\", extnamestr)),\n         MRAny(_, item_maker, _) => item_maker().chain(|i| {fld.fold_item(i)}),\n         MRDef(ref mdef) => {\n             insert_macro(*extsbox,intern(mdef.name), @SE((*mdef).ext));\n@@ -319,13 +318,13 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n     let extnamestr = ident_to_str(extname);\n     let (fully_expanded, sp) = match (*extsbox).find(&extname.name) {\n         None =>\n-            cx.span_fatal(pth.span, fmt!(\"macro undefined: '%s'\", *extnamestr)),\n+            cx.span_fatal(pth.span, fmt!(\"macro undefined: '%s'\", extnamestr)),\n \n         Some(@SE(NormalTT(\n             SyntaxExpanderTT{expander: exp, span: exp_sp}))) => {\n             cx.bt_push(ExpandedFrom(CallInfo {\n                 call_site: sp,\n-                callee: NameAndSpan { name: copy *extnamestr, span: exp_sp }\n+                callee: NameAndSpan { name: extnamestr, span: exp_sp }\n             }));\n             let expanded = match exp(cx, mac.span, tts) {\n                 MRExpr(e) =>\n@@ -334,7 +333,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n                 MRAny(_,_,stmt_mkr) => stmt_mkr(),\n                 _ => cx.span_fatal(\n                     pth.span,\n-                    fmt!(\"non-stmt macro in stmt pos: %s\", *extnamestr))\n+                    fmt!(\"non-stmt macro in stmt pos: %s\", extnamestr))\n             };\n \n             //keep going, outside-in\n@@ -355,7 +354,7 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n \n         _ => {\n             cx.span_fatal(pth.span,\n-                          fmt!(\"'%s' is not a tt-style macro\", *extnamestr))\n+                          fmt!(\"'%s' is not a tt-style macro\", extnamestr))\n         }\n     };\n \n@@ -414,7 +413,7 @@ fn get_block_info(exts : SyntaxEnv) -> BlockInfo {\n     match exts.find_in_topmost_frame(&intern(special_block_name)) {\n         Some(@BlockInfo(bi)) => bi,\n         _ => fail!(fmt!(\"special identifier %? was bound to a non-BlockInfo\",\n-                       @~\" block\"))\n+                       @\" block\"))\n     }\n }\n \n@@ -456,9 +455,9 @@ pub fn new_span(cx: @ExtCtxt, sp: span) -> span {\n // the default compilation environment. It would be much nicer to use\n // a mechanism like syntax_quote to ensure hygiene.\n \n-pub fn core_macros() -> ~str {\n+pub fn core_macros() -> @str {\n     return\n-~\"pub mod macros {\n+@\"pub mod macros {\n     macro_rules! ignore (($($x:tt)*) => (()))\n \n     macro_rules! error (\n@@ -679,16 +678,16 @@ pub fn expand_crate(parse_sess: @mut parse::ParseSess,\n             node: attribute_ {\n                 style: attr_outer,\n                 value: @spanned {\n-                    node: meta_word(@~\"macro_escape\"),\n+                    node: meta_word(@\"macro_escape\"),\n                     span: codemap::dummy_sp(),\n                 },\n                 is_sugared_doc: false,\n             }\n         }\n     ];\n \n-    let cm = match parse_item_from_source_str(~\"<core-macros>\",\n-                                              @core_macros(),\n+    let cm = match parse_item_from_source_str(@\"<core-macros>\",\n+                                              core_macros(),\n                                               copy cfg,\n                                               attrs,\n                                               parse_sess) {\n@@ -764,11 +763,11 @@ mod test {\n \n     // make sure that fail! is present\n     #[test] fn fail_exists_test () {\n-        let src = ~\"fn main() { fail!(\\\"something appropriately gloomy\\\");}\";\n+        let src = @\"fn main() { fail!(\\\"something appropriately gloomy\\\");}\";\n         let sess = parse::new_parse_sess(None);\n         let crate_ast = parse::parse_crate_from_source_str(\n-            ~\"<test>\",\n-            @src,\n+            @\"<test>\",\n+            src,\n             ~[],sess);\n         expand_crate(sess,~[],crate_ast);\n     }\n@@ -779,12 +778,12 @@ mod test {\n     // make sure that macros can leave scope\n     #[should_fail]\n     #[test] fn macros_cant_escape_fns_test () {\n-        let src = ~\"fn bogus() {macro_rules! z (() => (3+4))}\\\n+        let src = @\"fn bogus() {macro_rules! z (() => (3+4))}\\\n                     fn inty() -> int { z!() }\";\n         let sess = parse::new_parse_sess(None);\n         let crate_ast = parse::parse_crate_from_source_str(\n-            ~\"<test>\",\n-            @src,\n+            @\"<test>\",\n+            src,\n             ~[],sess);\n         // should fail:\n         expand_crate(sess,~[],crate_ast);\n@@ -793,32 +792,32 @@ mod test {\n     // make sure that macros can leave scope for modules\n     #[should_fail]\n     #[test] fn macros_cant_escape_mods_test () {\n-        let src = ~\"mod foo {macro_rules! z (() => (3+4))}\\\n+        let src = @\"mod foo {macro_rules! z (() => (3+4))}\\\n                     fn inty() -> int { z!() }\";\n         let sess = parse::new_parse_sess(None);\n         let crate_ast = parse::parse_crate_from_source_str(\n-            ~\"<test>\",\n-            @src,\n+            @\"<test>\",\n+            src,\n             ~[],sess);\n         // should fail:\n         expand_crate(sess,~[],crate_ast);\n     }\n \n     // macro_escape modules shouldn't cause macros to leave scope\n     #[test] fn macros_can_escape_flattened_mods_test () {\n-        let src = ~\"#[macro_escape] mod foo {macro_rules! z (() => (3+4))}\\\n+        let src = @\"#[macro_escape] mod foo {macro_rules! z (() => (3+4))}\\\n                     fn inty() -> int { z!() }\";\n         let sess = parse::new_parse_sess(None);\n         let crate_ast = parse::parse_crate_from_source_str(\n-            ~\"<test>\",\n-            @src,\n+            @\"<test>\",\n+            src,\n             ~[], sess);\n         // should fail:\n         expand_crate(sess,~[],crate_ast);\n     }\n \n     #[test] fn core_macros_must_parse () {\n-        let src = ~\"\n+        let src = @\"\n   pub mod macros {\n     macro_rules! ignore (($($x:tt)*) => (()))\n \n@@ -828,27 +827,27 @@ mod test {\n         let sess = parse::new_parse_sess(None);\n         let cfg = ~[];\n         let item_ast = parse::parse_item_from_source_str(\n-            ~\"<test>\",\n-            @src,\n-            cfg,~[make_dummy_attr (@~\"macro_escape\")],sess);\n+            @\"<test>\",\n+            src,\n+            cfg,~[make_dummy_attr (@\"macro_escape\")],sess);\n         match item_ast {\n             Some(_) => (), // success\n             None => fail!(\"expected this to parse\")\n         }\n     }\n \n     #[test] fn test_contains_flatten (){\n-        let attr1 = make_dummy_attr (@~\"foo\");\n-        let attr2 = make_dummy_attr (@~\"bar\");\n-        let escape_attr = make_dummy_attr (@~\"macro_escape\");\n+        let attr1 = make_dummy_attr (@\"foo\");\n+        let attr2 = make_dummy_attr (@\"bar\");\n+        let escape_attr = make_dummy_attr (@\"macro_escape\");\n         let attrs1 = ~[attr1, escape_attr, attr2];\n         assert_eq!(contains_macro_escape (attrs1),true);\n         let attrs2 = ~[attr1,attr2];\n         assert_eq!(contains_macro_escape (attrs2),false);\n     }\n \n     // make a \"meta_word\" outer attribute with the given name\n-    fn make_dummy_attr(s: @~str) -> ast::attribute {\n+    fn make_dummy_attr(s: @str) -> ast::attribute {\n         spanned {\n             span:codemap::dummy_sp(),\n             node: attribute_ {\n@@ -864,7 +863,7 @@ mod test {\n \n     #[test]\n     fn renaming () {\n-        let maybe_item_ast = string_to_item(@~\"fn a() -> int { let b = 13; b }\");\n+        let maybe_item_ast = string_to_item(@\"fn a() -> int { let b = 13; b }\");\n         let item_ast = match maybe_item_ast {\n             Some(x) => x,\n             None => fail!(\"test case fail\")\n@@ -887,7 +886,7 @@ mod test {\n \n     #[test]\n     fn pat_idents(){\n-        let pat = string_to_pat(@~\"(a,Foo{x:c @ (b,9),y:Bar(4,d)})\");\n+        let pat = string_to_pat(@\"(a,Foo{x:c @ (b,9),y:Bar(4,d)})\");\n         let pat_idents = new_name_finder();\n         let idents = @mut ~[];\n         ((*pat_idents).visit_pat)(pat, (idents, mk_vt(pat_idents)));"}, {"sha": "74496ac535984897c3cd5f389ecd1524ff2e75f1", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -274,12 +274,13 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n                    then there's no need for it to be mutable */\n                 if i == 0 {\n                     stms.push(cx.stmt_let(fmt_sp, npieces > 1,\n-                                          ident, cx.expr_str_uniq(fmt_sp, s)));\n+                                          ident, cx.expr_str_uniq(fmt_sp, s.to_managed())));\n                 } else {\n                     // we call the push_str function because the\n                     // bootstrap doesnt't seem to work if we call the\n                     // method.\n-                    let args = ~[cx.expr_mut_addr_of(fmt_sp, buf()), cx.expr_str(fmt_sp, s)];\n+                    let args = ~[cx.expr_mut_addr_of(fmt_sp, buf()),\n+                                 cx.expr_str(fmt_sp, s.to_managed())];\n                     let call = cx.expr_call_global(fmt_sp,\n                                                    ~[core_ident,\n                                                      str_ident,\n@@ -303,7 +304,7 @@ fn pieces_to_expr(cx: @ExtCtxt, sp: span,\n                    must be initialized as an empty string */\n                 if i == 0 {\n                     stms.push(cx.stmt_let(fmt_sp, true, ident,\n-                                          cx.expr_str_uniq(fmt_sp, ~\"\")));\n+                                          cx.expr_str_uniq(fmt_sp, @\"\")));\n                 }\n                 stms.push(cx.stmt_expr(make_new_conv(cx, fmt_sp, conv,\n                                                      args[n], buf())));"}, {"sha": "c1b9b051ec9ecaf06dde0774ab8d8c4d174c5a66", "filename": "src/libsyntax/ext/pipes/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fcheck.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -51,7 +51,7 @@ impl proto::visitor<(), (), ()> for @ExtCtxt {\n         }\n     }\n \n-    fn visit_message(&self, name: ~str, _span: span, _tys: &[@ast::Ty],\n+    fn visit_message(&self, name: @str, _span: span, _tys: &[@ast::Ty],\n                      this: state, next: Option<next_state>) {\n         match next {\n           Some(ref next_state) => {"}, {"sha": "11db1a5da297483d7bd71695ee9c63d2ef0f1d2b", "filename": "src/libsyntax/ext/pipes/parse_proto.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fparse_proto.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -20,13 +20,13 @@ use parse::token;\n use parse::token::{interner_get};\n \n pub trait proto_parser {\n-    fn parse_proto(&self, id: ~str) -> protocol;\n+    fn parse_proto(&self, id: @str) -> protocol;\n     fn parse_state(&self, proto: protocol);\n     fn parse_message(&self, state: state);\n }\n \n impl proto_parser for parser::Parser {\n-    fn parse_proto(&self, id: ~str) -> protocol {\n+    fn parse_proto(&self, id: @str) -> protocol {\n         let proto = protocol(id, *self.span);\n \n         self.parse_seq_to_before_end(\n@@ -43,17 +43,17 @@ impl proto_parser for parser::Parser {\n \n     fn parse_state(&self, proto: protocol) {\n         let id = self.parse_ident();\n-        let name = copy *interner_get(id.name);\n+        let name = interner_get(id.name);\n \n         self.expect(&token::COLON);\n         let dir = match copy *self.token {\n             token::IDENT(n, _) => interner_get(n.name),\n             _ => fail!()\n         };\n         self.bump();\n-        let dir = match dir {\n-          @~\"send\" => send,\n-          @~\"recv\" => recv,\n+        let dir = match dir.as_slice() {\n+          \"send\" => send,\n+          \"recv\" => recv,\n           _ => fail!()\n         };\n \n@@ -78,7 +78,7 @@ impl proto_parser for parser::Parser {\n     }\n \n     fn parse_message(&self, state: state) {\n-        let mname = copy *interner_get(self.parse_ident().name);\n+        let mname = interner_get(self.parse_ident().name);\n \n         let args = if *self.token == token::LPAREN {\n             self.parse_unspanned_seq(\n@@ -97,7 +97,7 @@ impl proto_parser for parser::Parser {\n \n         let next = match *self.token {\n           token::IDENT(_, _) => {\n-            let name = copy *interner_get(self.parse_ident().name);\n+            let name = interner_get(self.parse_ident().name);\n             let ntys = if *self.token == token::LT {\n                 self.parse_unspanned_seq(\n                     &token::LT,"}, {"sha": "b00f5057dac99ae4472a2305d3ccadfef724af3f", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -101,7 +101,7 @@ impl gen_send for message {\n                          name,\n                          vec::append_one(\n                              arg_names.map(|x| cx.str_of(*x)),\n-                             ~\"s\").connect(\", \"));\n+                             @\"s\").connect(\", \"));\n \n             if !try {\n                 body += fmt!(\"::std::pipes::send(pipe, message);\\n\");\n@@ -114,7 +114,7 @@ impl gen_send for message {\n                               } else { ::std::pipes::rt::make_none() } }\");\n             }\n \n-            let body = cx.parse_expr(body);\n+            let body = cx.parse_expr(body.to_managed());\n \n             let mut rty = cx.ty_path(path(~[next.data_name()],\n                                           span)\n@@ -123,7 +123,7 @@ impl gen_send for message {\n                 rty = cx.ty_option(rty);\n             }\n \n-            let name = cx.ident_of(if try { ~\"try_\" + name } else { name } );\n+            let name = if try {cx.ident_of(~\"try_\" + name)} else {cx.ident_of(name)};\n \n             cx.item_fn_poly(dummy_sp(),\n                             name,\n@@ -173,12 +173,12 @@ impl gen_send for message {\n                                   } }\");\n                 }\n \n-                let body = cx.parse_expr(body);\n+                let body = cx.parse_expr(body.to_managed());\n \n-                let name = if try { ~\"try_\" + name } else { name };\n+                let name = if try {cx.ident_of(~\"try_\" + name)} else {cx.ident_of(name)};\n \n                 cx.item_fn_poly(dummy_sp(),\n-                                cx.ident_of(name),\n+                                name,\n                                 args_ast,\n                                 if try {\n                                     cx.ty_option(cx.ty_nil())\n@@ -326,7 +326,7 @@ impl gen_init for protocol {\n                            start_state.generics.to_source(),\n                            start_state.to_ty(cx).to_source(),\n                            start_state.to_ty(cx).to_source(),\n-                           body.to_source()))\n+                           body.to_source()).to_managed())\n     }\n \n     fn gen_buffer_init(&self, ext_cx: @ExtCtxt) -> @ast::expr {\n@@ -358,10 +358,10 @@ impl gen_init for protocol {\n                 self.states.map_to_vec(\n                     |s| ext_cx.parse_stmt(\n                         fmt!(\"data.%s.set_buffer(buffer)\",\n-                             s.name))),\n+                             s.name).to_managed())),\n                 Some(ext_cx.parse_expr(fmt!(\n                     \"::std::ptr::to_mut_unsafe_ptr(&mut (data.%s))\",\n-                    self.states[0].name)))));\n+                    self.states[0].name).to_managed()))));\n \n         quote_expr!({\n             let buffer = $buffer;\n@@ -459,9 +459,9 @@ impl gen_init for protocol {\n         let allows = cx.attribute(\n             copy self.span,\n             cx.meta_list(copy self.span,\n-                         ~\"allow\",\n-                         ~[cx.meta_word(copy self.span, ~\"non_camel_case_types\"),\n-                           cx.meta_word(copy self.span, ~\"unused_mut\")]));\n+                         @\"allow\",\n+                         ~[cx.meta_word(copy self.span, @\"non_camel_case_types\"),\n+                           cx.meta_word(copy self.span, @\"unused_mut\")]));\n         cx.item_mod(copy self.span, cx.ident_of(copy self.name),\n                     ~[allows], ~[], items)\n     }"}, {"sha": "32714f37272634e0e22d5075526ea413131e798a", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -38,17 +38,17 @@ impl direction {\n }\n \n pub struct next_state {\n-    state: ~str,\n+    state: @str,\n     tys: ~[@ast::Ty],\n }\n \n // name, span, data, current state, next state\n-pub struct message(~str, span, ~[@ast::Ty], state, Option<next_state>);\n+pub struct message(@str, span, ~[@ast::Ty], state, Option<next_state>);\n \n impl message {\n-    pub fn name(&mut self) -> ~str {\n+    pub fn name(&mut self) -> @str {\n         match *self {\n-          message(ref id, _, _, _, _) => copy *id\n+          message(id, _, _, _, _) => id\n         }\n     }\n \n@@ -70,7 +70,7 @@ pub type state = @state_;\n \n pub struct state_ {\n     id: uint,\n-    name: ~str,\n+    name: @str,\n     ident: ast::ident,\n     span: span,\n     dir: direction,\n@@ -81,7 +81,7 @@ pub struct state_ {\n \n impl state_ {\n     pub fn add_message(@self,\n-                       name: ~str,\n+                       name: @str,\n                        span: span,\n                        data: ~[@ast::Ty],\n                        next: Option<next_state>) {\n@@ -122,11 +122,11 @@ impl state_ {\n \n pub type protocol = @mut protocol_;\n \n-pub fn protocol(name: ~str, span: span) -> protocol {\n+pub fn protocol(name: @str, span: span) -> protocol {\n     @mut protocol_(name, span)\n }\n \n-pub fn protocol_(name: ~str, span: span) -> protocol_ {\n+pub fn protocol_(name: @str, span: span) -> protocol_ {\n     protocol_ {\n         name: name,\n         span: span,\n@@ -136,7 +136,7 @@ pub fn protocol_(name: ~str, span: span) -> protocol_ {\n }\n \n pub struct protocol_ {\n-    name: ~str,\n+    name: @str,\n     span: span,\n     states: @mut ~[state],\n \n@@ -181,7 +181,7 @@ impl protocol_ {\n \n impl protocol_ {\n     pub fn add_state_poly(@mut self,\n-                          name: ~str,\n+                          name: @str,\n                           ident: ast::ident,\n                           dir: direction,\n                           generics: ast::Generics)\n@@ -208,7 +208,7 @@ impl protocol_ {\n pub trait visitor<Tproto, Tstate, Tmessage> {\n     fn visit_proto(&self, proto: protocol, st: &[Tstate]) -> Tproto;\n     fn visit_state(&self, state: state, m: &[Tmessage]) -> Tstate;\n-    fn visit_message(&self, name: ~str, spane: span, tys: &[@ast::Ty],\n+    fn visit_message(&self, name: @str, spane: span, tys: &[@ast::Ty],\n                      this: state, next: Option<next_state>) -> Tmessage;\n }\n "}, {"sha": "5e47862a1f04ab317118e86087b9636e113c0868", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 56, "deletions": 58, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -43,8 +43,6 @@ pub mod rt {\n     pub use parse::new_parser_from_tts;\n     pub use codemap::{BytePos, span, dummy_spanned};\n \n-    use print::pprust::{item_to_str, ty_to_str};\n-\n     pub trait ToTokens {\n         pub fn to_tokens(&self, _cx: @ExtCtxt) -> ~[token_tree];\n     }\n@@ -71,132 +69,132 @@ pub mod rt {\n \n     pub trait ToSource {\n         // Takes a thing and generates a string containing rust code for it.\n-        pub fn to_source(&self) -> ~str;\n+        pub fn to_source(&self) -> @str;\n     }\n \n     impl ToSource for ast::ident {\n-        fn to_source(&self) -> ~str {\n-            copy *ident_to_str(self)\n+        fn to_source(&self) -> @str {\n+            ident_to_str(self)\n         }\n     }\n \n     impl ToSource for @ast::item {\n-        fn to_source(&self) -> ~str {\n-            item_to_str(*self, get_ident_interner())\n+        fn to_source(&self) -> @str {\n+            pprust::item_to_str(*self, get_ident_interner()).to_managed()\n         }\n     }\n \n     impl<'self> ToSource for &'self [@ast::item] {\n-        fn to_source(&self) -> ~str {\n-            self.map(|i| i.to_source()).connect(\"\\n\\n\")\n+        fn to_source(&self) -> @str {\n+            self.map(|i| i.to_source()).connect(\"\\n\\n\").to_managed()\n         }\n     }\n \n     impl ToSource for @ast::Ty {\n-        fn to_source(&self) -> ~str {\n-            ty_to_str(*self, get_ident_interner())\n+        fn to_source(&self) -> @str {\n+            pprust::ty_to_str(*self, get_ident_interner()).to_managed()\n         }\n     }\n \n     impl<'self> ToSource for &'self [@ast::Ty] {\n-        fn to_source(&self) -> ~str {\n-            self.map(|i| i.to_source()).connect(\", \")\n+        fn to_source(&self) -> @str {\n+            self.map(|i| i.to_source()).connect(\", \").to_managed()\n         }\n     }\n \n     impl ToSource for Generics {\n-        fn to_source(&self) -> ~str {\n-            pprust::generics_to_str(self, get_ident_interner())\n+        fn to_source(&self) -> @str {\n+            pprust::generics_to_str(self, get_ident_interner()).to_managed()\n         }\n     }\n \n     impl ToSource for @ast::expr {\n-        fn to_source(&self) -> ~str {\n-            pprust::expr_to_str(*self, get_ident_interner())\n+        fn to_source(&self) -> @str {\n+            pprust::expr_to_str(*self, get_ident_interner()).to_managed()\n         }\n     }\n \n     impl ToSource for ast::blk {\n-        fn to_source(&self) -> ~str {\n-            pprust::block_to_str(self, get_ident_interner())\n+        fn to_source(&self) -> @str {\n+            pprust::block_to_str(self, get_ident_interner()).to_managed()\n         }\n     }\n \n     impl<'self> ToSource for &'self str {\n-        fn to_source(&self) -> ~str {\n-            let lit = dummy_spanned(ast::lit_str(@self.to_owned()));\n-            pprust::lit_to_str(@lit)\n+        fn to_source(&self) -> @str {\n+            let lit = dummy_spanned(ast::lit_str(self.to_managed()));\n+            pprust::lit_to_str(@lit).to_managed()\n         }\n     }\n \n     impl ToSource for int {\n-        fn to_source(&self) -> ~str {\n+        fn to_source(&self) -> @str {\n             let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i));\n-            pprust::lit_to_str(@lit)\n+            pprust::lit_to_str(@lit).to_managed()\n         }\n     }\n \n     impl ToSource for i8 {\n-        fn to_source(&self) -> ~str {\n+        fn to_source(&self) -> @str {\n             let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i8));\n-            pprust::lit_to_str(@lit)\n+            pprust::lit_to_str(@lit).to_managed()\n         }\n     }\n \n     impl ToSource for i16 {\n-        fn to_source(&self) -> ~str {\n+        fn to_source(&self) -> @str {\n             let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i16));\n-            pprust::lit_to_str(@lit)\n+            pprust::lit_to_str(@lit).to_managed()\n         }\n     }\n \n \n     impl ToSource for i32 {\n-        fn to_source(&self) -> ~str {\n+        fn to_source(&self) -> @str {\n             let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i32));\n-            pprust::lit_to_str(@lit)\n+            pprust::lit_to_str(@lit).to_managed()\n         }\n     }\n \n     impl ToSource for i64 {\n-        fn to_source(&self) -> ~str {\n+        fn to_source(&self) -> @str {\n             let lit = dummy_spanned(ast::lit_int(*self as i64, ast::ty_i64));\n-            pprust::lit_to_str(@lit)\n+            pprust::lit_to_str(@lit).to_managed()\n         }\n     }\n \n     impl ToSource for uint {\n-        fn to_source(&self) -> ~str {\n+        fn to_source(&self) -> @str {\n             let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u));\n-            pprust::lit_to_str(@lit)\n+            pprust::lit_to_str(@lit).to_managed()\n         }\n     }\n \n     impl ToSource for u8 {\n-        fn to_source(&self) -> ~str {\n+        fn to_source(&self) -> @str {\n             let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u8));\n-            pprust::lit_to_str(@lit)\n+            pprust::lit_to_str(@lit).to_managed()\n         }\n     }\n \n     impl ToSource for u16 {\n-        fn to_source(&self) -> ~str {\n+        fn to_source(&self) -> @str {\n             let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u16));\n-            pprust::lit_to_str(@lit)\n+            pprust::lit_to_str(@lit).to_managed()\n         }\n     }\n \n     impl ToSource for u32 {\n-        fn to_source(&self) -> ~str {\n+        fn to_source(&self) -> @str {\n             let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u32));\n-            pprust::lit_to_str(@lit)\n+            pprust::lit_to_str(@lit).to_managed()\n         }\n     }\n \n     impl ToSource for u64 {\n-        fn to_source(&self) -> ~str {\n+        fn to_source(&self) -> @str {\n             let lit = dummy_spanned(ast::lit_uint(*self as u64, ast::ty_u64));\n-            pprust::lit_to_str(@lit)\n+            pprust::lit_to_str(@lit).to_managed()\n         }\n     }\n \n@@ -317,18 +315,18 @@ pub mod rt {\n     }\n \n     pub trait ExtParseUtils {\n-        fn parse_item(&self, s: ~str) -> @ast::item;\n-        fn parse_expr(&self, s: ~str) -> @ast::expr;\n-        fn parse_stmt(&self, s: ~str) -> @ast::stmt;\n-        fn parse_tts(&self, s: ~str) -> ~[ast::token_tree];\n+        fn parse_item(&self, s: @str) -> @ast::item;\n+        fn parse_expr(&self, s: @str) -> @ast::expr;\n+        fn parse_stmt(&self, s: @str) -> @ast::stmt;\n+        fn parse_tts(&self, s: @str) -> ~[ast::token_tree];\n     }\n \n     impl ExtParseUtils for ExtCtxt {\n \n-        fn parse_item(&self, s: ~str) -> @ast::item {\n+        fn parse_item(&self, s: @str) -> @ast::item {\n             let res = parse::parse_item_from_source_str(\n-                ~\"<quote expansion>\",\n-                @(copy s),\n+                @\"<quote expansion>\",\n+                s,\n                 self.cfg(),\n                 ~[],\n                 self.parse_sess());\n@@ -341,27 +339,27 @@ pub mod rt {\n             }\n         }\n \n-        fn parse_stmt(&self, s: ~str) -> @ast::stmt {\n+        fn parse_stmt(&self, s: @str) -> @ast::stmt {\n             parse::parse_stmt_from_source_str(\n-                ~\"<quote expansion>\",\n-                @(copy s),\n+                @\"<quote expansion>\",\n+                s,\n                 self.cfg(),\n                 ~[],\n                 self.parse_sess())\n         }\n \n-        fn parse_expr(&self, s: ~str) -> @ast::expr {\n+        fn parse_expr(&self, s: @str) -> @ast::expr {\n             parse::parse_expr_from_source_str(\n-                ~\"<quote expansion>\",\n-                @(copy s),\n+                @\"<quote expansion>\",\n+                s,\n                 self.cfg(),\n                 self.parse_sess())\n         }\n \n-        fn parse_tts(&self, s: ~str) -> ~[ast::token_tree] {\n+        fn parse_tts(&self, s: @str) -> ~[ast::token_tree] {\n             parse::parse_tts_from_source_str(\n-                ~\"<quote expansion>\",\n-                @(copy s),\n+                @\"<quote expansion>\",\n+                s,\n                 self.cfg(),\n                 self.parse_sess())\n         }"}, {"sha": "d92f4e8458bfcc9562e1d3359b1a6ab0982c22cb", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -59,21 +59,21 @@ pub fn expand_file(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n \n     let topmost = topmost_expn_info(cx.backtrace().get());\n     let loc = cx.codemap().lookup_char_pos(topmost.call_site.lo);\n-    let filename = copy loc.file.name;\n+    let filename = loc.file.name;\n     base::MRExpr(cx.expr_str(topmost.call_site, filename))\n }\n \n pub fn expand_stringify(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let s = pprust::tts_to_str(tts, get_ident_interner());\n-    base::MRExpr(cx.expr_str(sp, s))\n+    base::MRExpr(cx.expr_str(sp, s.to_managed()))\n }\n \n pub fn expand_mod(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     base::check_zero_tts(cx, sp, tts, \"module_path!\");\n     base::MRExpr(cx.expr_str(sp,\n-                             cx.mod_path().map(|x| cx.str_of(*x)).connect(\"::\")))\n+                             cx.mod_path().map(|x| cx.str_of(*x)).connect(\"::\").to_managed()))\n }\n \n // include! : parse the given file as an expr\n@@ -94,13 +94,13 @@ pub fn expand_include_str(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     let file = get_single_str_from_tts(cx, sp, tts, \"include_str!\");\n     let res = io::read_whole_file_str(&res_rel_file(cx, sp, &Path(file)));\n     match res {\n-      result::Ok(_) => { /* Continue. */ }\n-      result::Err(ref e) => {\n-        cx.parse_sess().span_diagnostic.handler().fatal((*e));\n+      result::Ok(res) => {\n+          base::MRExpr(cx.expr_str(sp, res.to_managed()))\n+      }\n+      result::Err(e) => {\n+        cx.span_fatal(sp, e);\n       }\n     }\n-\n-    base::MRExpr(cx.expr_str(sp, result::unwrap(res)))\n }\n \n pub fn expand_include_bin(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n@@ -131,7 +131,7 @@ fn topmost_expn_info(expn_info: @codemap::ExpnInfo) -> @codemap::ExpnInfo {\n                             _\n                         }) => {\n                             // Don't recurse into file using \"include!\"\n-                            if *name == ~\"include\" {\n+                            if \"include\" == *name  {\n                                 expn_info\n                             } else {\n                                 topmost_expn_info(next_expn_info)"}, {"sha": "dd1558695263078508de352529bd3ea75bfa5bfd", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -205,7 +205,7 @@ pub fn nameize(p_s: @mut ParseSess, ms: &[matcher], res: &[@named_match])\n           } => {\n             if ret_val.contains_key(bind_name) {\n                 p_s.span_diagnostic.span_fatal(sp, ~\"Duplicated bind name: \"+\n-                                               *ident_to_str(bind_name))\n+                                               ident_to_str(bind_name))\n             }\n             ret_val.insert(*bind_name, res[idx]);\n           }\n@@ -373,8 +373,8 @@ pub fn parse(\n                 let nts = bb_eis.map(|ei| {\n                     match ei.elts[ei.idx].node {\n                       match_nonterminal(ref bind,ref name,_) => {\n-                        fmt!(\"%s ('%s')\", *ident_to_str(name),\n-                             *ident_to_str(bind))\n+                        fmt!(\"%s ('%s')\", ident_to_str(name),\n+                             ident_to_str(bind))\n                       }\n                       _ => fail!()\n                     } }).connect(\" or \");\n@@ -398,7 +398,7 @@ pub fn parse(\n                 match ei.elts[ei.idx].node {\n                   match_nonterminal(_, ref name, idx) => {\n                     ei.matches[idx].push(@matched_nonterminal(\n-                        parse_nt(&rust_parser, *ident_to_str(name))));\n+                        parse_nt(&rust_parser, ident_to_str(name))));\n                     ei.idx += 1u;\n                   }\n                   _ => fail!()"}, {"sha": "491989c77c4bc110f0bbac92ba5d64ac12a5cf3b", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -148,7 +148,7 @@ pub fn add_new_extension(cx: @ExtCtxt,\n         |cx, sp, arg| generic_extension(cx, sp, name, arg, *lhses, *rhses);\n \n     return MRDef(MacroDef{\n-        name: copy *ident_to_str(&name),\n+        name: ident_to_str(&name),\n         ext: NormalTT(base::SyntaxExpanderTT{expander: exp, span: Some(sp)})\n     });\n }"}, {"sha": "e44c3e67212625a5deb74edf99fd73fd3bcf788c", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -121,7 +121,7 @@ fn lookup_cur_matched(r: &mut TtReader, name: ident) -> @named_match {\n         Some(s) => lookup_cur_matched_by_matched(r, s),\n         None => {\n             r.sp_diag.span_fatal(r.cur_span, fmt!(\"unknown macro variable `%s`\",\n-                                                  *ident_to_str(&name)));\n+                                                  ident_to_str(&name)));\n         }\n     }\n }\n@@ -139,8 +139,8 @@ fn lockstep_iter_size(t: &token_tree, r: &mut TtReader) -> lis {\n             lis_contradiction(_) => copy rhs,\n             lis_constraint(r_len, _) if l_len == r_len => copy lhs,\n             lis_constraint(r_len, ref r_id) => {\n-                let l_n = copy *ident_to_str(l_id);\n-                let r_n = copy *ident_to_str(r_id);\n+                let l_n = ident_to_str(l_id);\n+                let r_n = ident_to_str(r_id);\n                 lis_contradiction(fmt!(\"Inconsistent lockstep iteration: \\\n                                        '%s' has %u items, but '%s' has %u\",\n                                         l_n, l_len, r_n, r_len))\n@@ -290,7 +290,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                 r.sp_diag.span_fatal(\n                     copy r.cur_span, /* blame the macro writer */\n                     fmt!(\"variable '%s' is still repeating at this depth\",\n-                         *ident_to_str(&ident)));\n+                         ident_to_str(&ident)));\n               }\n             }\n           }"}, {"sha": "035675e523e71e662e6c8acb892bfc879b78d433", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -990,7 +990,7 @@ mod test {\n     // make sure idents get transformed everywhere\n     #[test] fn ident_transformation () {\n         let zz_fold = fun_to_ident_folder(to_zz());\n-        let ast = string_to_crate(@~\"#[a] mod b {fn c (d : e, f : g) {h!(i,j,k);l;m}}\");\n+        let ast = string_to_crate(@\"#[a] mod b {fn c (d : e, f : g) {h!(i,j,k);l;m}}\");\n         assert_pred!(matches_codepattern,\n                      \"matches_codepattern\",\n                      pprust::to_str(zz_fold.fold_crate(ast),fake_print_crate,\n@@ -1001,7 +1001,7 @@ mod test {\n     // even inside macro defs....\n     #[test] fn ident_transformation_in_defs () {\n         let zz_fold = fun_to_ident_folder(to_zz());\n-        let ast = string_to_crate(@~\"macro_rules! a {(b $c:expr $(d $e:token)f+\n+        let ast = string_to_crate(@\"macro_rules! a {(b $c:expr $(d $e:token)f+\n => (g $(d $d $e)+))} \");\n         assert_pred!(matches_codepattern,\n                      \"matches_codepattern\","}, {"sha": "ddcad5c3e8f6c29bf59d2a2d003ec9bcf0af41a4", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -46,7 +46,7 @@ impl parser_attr for Parser {\n               }\n               token::DOC_COMMENT(s) => {\n                 let attr = ::attr::mk_sugared_doc_attr(\n-                    copy *self.id_to_str(s),\n+                    self.id_to_str(s),\n                     self.span.lo,\n                     self.span.hi\n                 );\n@@ -119,7 +119,7 @@ impl parser_attr for Parser {\n               }\n               token::DOC_COMMENT(s) => {\n                 let attr = ::attr::mk_sugared_doc_attr(\n-                    copy *self.id_to_str(s),\n+                    self.id_to_str(s),\n                     self.span.lo,\n                     self.span.hi\n                 );"}, {"sha": "5c56ea6c446c07bb9e87fcc4e85ba9679769ed4c", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -320,10 +320,10 @@ pub struct lit {\n // probably not a good thing.\n pub fn gather_comments_and_literals(span_diagnostic:\n                                     @diagnostic::span_handler,\n-                                    path: ~str,\n+                                    path: @str,\n                                     srdr: @io::Reader)\n                                  -> (~[cmnt], ~[lit]) {\n-    let src = @str::from_bytes(srdr.read_whole_stream());\n+    let src = str::from_bytes(srdr.read_whole_stream()).to_managed();\n     let cm = CodeMap::new();\n     let filemap = cm.new_filemap(path, src);\n     let rdr = lexer::new_low_level_string_reader(span_diagnostic, filemap);"}, {"sha": "0956fa7225f20ad74775ba03aa1d31bd8026608a", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -158,7 +158,7 @@ impl Parser {\n             self.fatal(\n                 fmt!(\n                     \"expected `%s`, found `%s`\",\n-                    *self.id_to_str(kw.to_ident()),\n+                    self.id_to_str(kw.to_ident()),\n                     self.this_token_to_str()\n                 )\n             );"}, {"sha": "d71e2763b5cdad8b89ea09b4ed8ee2303e957ca8", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -40,7 +40,7 @@ pub struct TokenAndSpan {tok: token::Token, sp: span}\n \n pub struct StringReader {\n     span_diagnostic: @span_handler,\n-    src: @~str,\n+    src: @str,\n     // The absolute offset within the codemap of the next character to read\n     pos: BytePos,\n     // The absolute offset within the codemap of the last character read(curr)\n@@ -176,7 +176,7 @@ pub fn with_str_from<T>(rdr: @mut StringReader, start: BytePos, f: &fn(s: &str)\n pub fn bump(rdr: &mut StringReader) {\n     rdr.last_pos = rdr.pos;\n     let current_byte_offset = byte_offset(rdr, rdr.pos).to_uint();\n-    if current_byte_offset < (*rdr.src).len() {\n+    if current_byte_offset < (rdr.src).len() {\n         assert!(rdr.curr != -1 as char);\n         let last_char = rdr.curr;\n         let next = rdr.src.char_range_at(current_byte_offset);\n@@ -202,7 +202,7 @@ pub fn is_eof(rdr: @mut StringReader) -> bool {\n }\n pub fn nextch(rdr: @mut StringReader) -> char {\n     let offset = byte_offset(rdr, rdr.pos).to_uint();\n-    if offset < (*rdr.src).len() {\n+    if offset < (rdr.src).len() {\n         return rdr.src.char_at(offset);\n     } else { return -1 as char; }\n }\n@@ -801,9 +801,9 @@ mod test {\n     }\n \n     // open a string reader for the given string\n-    fn setup(teststr: ~str) -> Env {\n+    fn setup(teststr: @str) -> Env {\n         let cm = CodeMap::new();\n-        let fm = cm.new_filemap(~\"zebra.rs\", @teststr);\n+        let fm = cm.new_filemap(@\"zebra.rs\", teststr);\n         let span_handler =\n             diagnostic::mk_span_handler(diagnostic::mk_handler(None),@cm);\n         Env {\n@@ -813,7 +813,7 @@ mod test {\n \n     #[test] fn t1 () {\n         let Env {string_reader} =\n-            setup(~\"/* my source file */ \\\n+            setup(@\"/* my source file */ \\\n                     fn main() { io::println(~\\\"zebra\\\"); }\\n\");\n         let id = str_to_ident(\"fn\");\n         let tok1 = string_reader.next_token();\n@@ -849,59 +849,59 @@ mod test {\n     }\n \n     #[test] fn doublecolonparsing () {\n-        let env = setup (~\"a b\");\n+        let env = setup (@\"a b\");\n         check_tokenization (env,\n                            ~[mk_ident(\"a\",false),\n                              mk_ident(\"b\",false)]);\n     }\n \n     #[test] fn dcparsing_2 () {\n-        let env = setup (~\"a::b\");\n+        let env = setup (@\"a::b\");\n         check_tokenization (env,\n                            ~[mk_ident(\"a\",true),\n                              token::MOD_SEP,\n                              mk_ident(\"b\",false)]);\n     }\n \n     #[test] fn dcparsing_3 () {\n-        let env = setup (~\"a ::b\");\n+        let env = setup (@\"a ::b\");\n         check_tokenization (env,\n                            ~[mk_ident(\"a\",false),\n                              token::MOD_SEP,\n                              mk_ident(\"b\",false)]);\n     }\n \n     #[test] fn dcparsing_4 () {\n-        let env = setup (~\"a:: b\");\n+        let env = setup (@\"a:: b\");\n         check_tokenization (env,\n                            ~[mk_ident(\"a\",true),\n                              token::MOD_SEP,\n                              mk_ident(\"b\",false)]);\n     }\n \n     #[test] fn character_a() {\n-        let env = setup(~\"'a'\");\n+        let env = setup(@\"'a'\");\n         let TokenAndSpan {tok, sp: _} =\n             env.string_reader.next_token();\n         assert_eq!(tok,token::LIT_INT('a' as i64, ast::ty_char));\n     }\n \n     #[test] fn character_space() {\n-        let env = setup(~\"' '\");\n+        let env = setup(@\"' '\");\n         let TokenAndSpan {tok, sp: _} =\n             env.string_reader.next_token();\n         assert_eq!(tok, token::LIT_INT(' ' as i64, ast::ty_char));\n     }\n \n     #[test] fn character_escaped() {\n-        let env = setup(~\"'\\n'\");\n+        let env = setup(@\"'\\n'\");\n         let TokenAndSpan {tok, sp: _} =\n             env.string_reader.next_token();\n         assert_eq!(tok, token::LIT_INT('\\n' as i64, ast::ty_char));\n     }\n \n     #[test] fn lifetime_name() {\n-        let env = setup(~\"'abc\");\n+        let env = setup(@\"'abc\");\n         let TokenAndSpan {tok, sp: _} =\n             env.string_reader.next_token();\n         let id = token::str_to_ident(\"abc\");"}, {"sha": "5edd2ec4d47901c243b1c7108dc188dc1a06b0ce", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 40, "deletions": 40, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -82,92 +82,92 @@ pub fn parse_crate_from_file(\n }\n \n pub fn parse_crate_from_source_str(\n-    name: ~str,\n-    source: @~str,\n+    name: @str,\n+    source: @str,\n     cfg: ast::crate_cfg,\n     sess: @mut ParseSess\n ) -> @ast::crate {\n     let p = new_parser_from_source_str(\n         sess,\n         /*bad*/ copy cfg,\n-        /*bad*/ copy name,\n+        name,\n         source\n     );\n     maybe_aborted(p.parse_crate_mod(),p)\n }\n \n pub fn parse_expr_from_source_str(\n-    name: ~str,\n-    source: @~str,\n+    name: @str,\n+    source: @str,\n     cfg: ast::crate_cfg,\n     sess: @mut ParseSess\n ) -> @ast::expr {\n     let p = new_parser_from_source_str(\n         sess,\n         cfg,\n-        /*bad*/ copy name,\n+        name,\n         source\n     );\n     maybe_aborted(p.parse_expr(), p)\n }\n \n pub fn parse_item_from_source_str(\n-    name: ~str,\n-    source: @~str,\n+    name: @str,\n+    source: @str,\n     cfg: ast::crate_cfg,\n     attrs: ~[ast::attribute],\n     sess: @mut ParseSess\n ) -> Option<@ast::item> {\n     let p = new_parser_from_source_str(\n         sess,\n         cfg,\n-        /*bad*/ copy name,\n+        name,\n         source\n     );\n     maybe_aborted(p.parse_item(attrs),p)\n }\n \n pub fn parse_meta_from_source_str(\n-    name: ~str,\n-    source: @~str,\n+    name: @str,\n+    source: @str,\n     cfg: ast::crate_cfg,\n     sess: @mut ParseSess\n ) -> @ast::meta_item {\n     let p = new_parser_from_source_str(\n         sess,\n         cfg,\n-        /*bad*/ copy name,\n+        name,\n         source\n     );\n     maybe_aborted(p.parse_meta_item(),p)\n }\n \n pub fn parse_stmt_from_source_str(\n-    name: ~str,\n-    source: @~str,\n+    name: @str,\n+    source: @str,\n     cfg: ast::crate_cfg,\n     attrs: ~[ast::attribute],\n     sess: @mut ParseSess\n ) -> @ast::stmt {\n     let p = new_parser_from_source_str(\n         sess,\n         cfg,\n-        /*bad*/ copy name,\n+        name,\n         source\n     );\n     maybe_aborted(p.parse_stmt(attrs),p)\n }\n \n pub fn parse_tts_from_source_str(\n-    name: ~str,\n-    source: @~str,\n+    name: @str,\n+    source: @str,\n     cfg: ast::crate_cfg,\n     sess: @mut ParseSess\n ) -> ~[ast::token_tree] {\n     let p = new_parser_from_source_str(\n         sess,\n         cfg,\n-        /*bad*/ copy name,\n+        name,\n         source\n     );\n     *p.quote_depth += 1u;\n@@ -182,8 +182,8 @@ pub fn parse_tts_from_source_str(\n // result.\n pub fn parse_from_source_str<T>(\n     f: &fn(&Parser) -> T,\n-    name: ~str, ss: codemap::FileSubstr,\n-    source: @~str,\n+    name: @str, ss: codemap::FileSubstr,\n+    source: @str,\n     cfg: ast::crate_cfg,\n     sess: @mut ParseSess\n ) -> T {\n@@ -213,8 +213,8 @@ pub fn next_node_id(sess: @mut ParseSess) -> node_id {\n // Create a new parser from a source string\n pub fn new_parser_from_source_str(sess: @mut ParseSess,\n                                   cfg: ast::crate_cfg,\n-                                  name: ~str,\n-                                  source: @~str)\n+                                  name: @str,\n+                                  source: @str)\n                                -> Parser {\n     filemap_to_parser(sess,string_to_filemap(sess,source,name),cfg)\n }\n@@ -223,9 +223,9 @@ pub fn new_parser_from_source_str(sess: @mut ParseSess,\n // is specified as a substring of another file.\n pub fn new_parser_from_source_substr(sess: @mut ParseSess,\n                                   cfg: ast::crate_cfg,\n-                                  name: ~str,\n+                                  name: @str,\n                                   ss: codemap::FileSubstr,\n-                                  source: @~str)\n+                                  source: @str)\n                                -> Parser {\n     filemap_to_parser(sess,substring_to_filemap(sess,source,name,ss),cfg)\n }\n@@ -275,7 +275,7 @@ pub fn new_parser_from_tts(sess: @mut ParseSess,\n pub fn file_to_filemap(sess: @mut ParseSess, path: &Path, spanopt: Option<span>)\n     -> @FileMap {\n     match io::read_whole_file_str(path) {\n-        Ok(src) => string_to_filemap(sess, @src, path.to_str()),\n+        Ok(src) => string_to_filemap(sess, src.to_managed(), path.to_str().to_managed()),\n         Err(e) => {\n             match spanopt {\n                 Some(span) => sess.span_diagnostic.span_fatal(span, e),\n@@ -287,14 +287,14 @@ pub fn file_to_filemap(sess: @mut ParseSess, path: &Path, spanopt: Option<span>)\n \n // given a session and a string, add the string to\n // the session's codemap and return the new filemap\n-pub fn string_to_filemap(sess: @mut ParseSess, source: @~str, path: ~str)\n+pub fn string_to_filemap(sess: @mut ParseSess, source: @str, path: @str)\n     -> @FileMap {\n     sess.cm.new_filemap(path, source)\n }\n \n // given a session and a string and a path and a FileSubStr, add\n // the string to the CodeMap and return the new FileMap\n-pub fn substring_to_filemap(sess: @mut ParseSess, source: @~str, path: ~str,\n+pub fn substring_to_filemap(sess: @mut ParseSess, source: @str, path: @str,\n                            filesubstr: FileSubstr) -> @FileMap {\n     sess.cm.new_filemap_w_substr(path,filesubstr,source)\n }\n@@ -349,7 +349,7 @@ mod test {\n     use util::parser_testing::{string_to_stmt, strs_to_idents};\n \n     // map a string to tts, return the tt without its parsesess\n-    fn string_to_tts_only(source_str : @~str) -> ~[ast::token_tree] {\n+    fn string_to_tts_only(source_str : @str) -> ~[ast::token_tree] {\n         let (tts,_ps) = string_to_tts_and_sess(source_str);\n         tts\n     }\n@@ -368,7 +368,7 @@ mod test {\n     }\n \n     #[test] fn path_exprs_1 () {\n-        assert_eq!(string_to_expr(@~\"a\"),\n+        assert_eq!(string_to_expr(@\"a\"),\n                    @ast::expr{id:1,\n                               node:ast::expr_path(@ast::Path {span:sp(0,1),\n                                                               global:false,\n@@ -379,7 +379,7 @@ mod test {\n     }\n \n     #[test] fn path_exprs_2 () {\n-        assert_eq!(string_to_expr(@~\"::a::b\"),\n+        assert_eq!(string_to_expr(@\"::a::b\"),\n                    @ast::expr{id:1,\n                                node:ast::expr_path(\n                                    @ast::Path {span:sp(0,6),\n@@ -394,11 +394,11 @@ mod test {\n     // marked as `#[should_fail]`.\n     /*#[should_fail]\n     #[test] fn bad_path_expr_1() {\n-        string_to_expr(@~\"::abc::def::return\");\n+        string_to_expr(@\"::abc::def::return\");\n     }*/\n \n     #[test] fn string_to_tts_1 () {\n-        let (tts,_ps) = string_to_tts_and_sess(@~\"fn a (b : int) { b; }\");\n+        let (tts,_ps) = string_to_tts_and_sess(@\"fn a (b : int) { b; }\");\n         assert_eq!(to_json_str(@tts),\n                    ~\"[\\\n                 [\\\"tt_tok\\\",null,[\\\"IDENT\\\",\\\"fn\\\",false]],\\\n@@ -427,7 +427,7 @@ mod test {\n     }\n \n     #[test] fn ret_expr() {\n-        assert_eq!(string_to_expr(@~\"return d\"),\n+        assert_eq!(string_to_expr(@\"return d\"),\n                    @ast::expr{id:2,\n                               node:ast::expr_ret(\n                                   Some(@ast::expr{id:1,\n@@ -443,7 +443,7 @@ mod test {\n     }\n \n     #[test] fn parse_stmt_1 () {\n-        assert_eq!(string_to_stmt(@~\"b;\"),\n+        assert_eq!(string_to_stmt(@\"b;\"),\n                    @spanned{\n                        node: ast::stmt_expr(@ast::expr{\n                            id: 1,\n@@ -465,7 +465,7 @@ mod test {\n     }\n \n     #[test] fn parse_ident_pat () {\n-        let parser = string_to_parser(@~\"b\");\n+        let parser = string_to_parser(@\"b\");\n         assert_eq!(parser.parse_pat(),\n                    @ast::pat{id:1, // fixme\n                              node: ast::pat_ident(ast::bind_infer,\n@@ -482,7 +482,7 @@ mod test {\n     }\n \n     #[test] fn parse_arg () {\n-        let parser = string_to_parser(@~\"b : int\");\n+        let parser = string_to_parser(@\"b : int\");\n         assert_eq!(parser.parse_arg_general(true),\n                    ast::arg{\n                        is_mutbl: false,\n@@ -515,7 +515,7 @@ mod test {\n     #[test] fn parse_fundecl () {\n         // this test depends on the intern order of \"fn\" and \"int\", and on the\n         // assignment order of the node_ids.\n-        assert_eq!(string_to_item(@~\"fn a (b : int) { b; }\"),\n+        assert_eq!(string_to_item(@\"fn a (b : int) { b; }\"),\n                   Some(\n                       @ast::item{ident:str_to_ident(\"a\"),\n                             attrs:~[],\n@@ -585,12 +585,12 @@ mod test {\n \n     #[test] fn parse_exprs () {\n         // just make sure that they parse....\n-        string_to_expr(@~\"3 + 4\");\n-        string_to_expr(@~\"a::z.froob(b,@(987+3))\");\n+        string_to_expr(@\"3 + 4\");\n+        string_to_expr(@\"a::z.froob(b,@(987+3))\");\n     }\n \n     #[test] fn attrs_fix_bug () {\n-        string_to_item(@~\"pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n+        string_to_item(@\"pub fn mk_file_writer(path: &Path, flags: &[FileFlag])\n                    -> Result<@Writer, ~str> {\n     #[cfg(windows)]\n     fn wb() -> c_int {"}, {"sha": "cc7b7fab07e83bfc4b422e5f0fd3f5738a23e05c", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -259,7 +259,7 @@ impl Parser {\n                                    -> bool {\n         match *token {\n             token::IDENT(sid, _) => {\n-                str::eq_slice(*self.id_to_str(sid), ident)\n+                str::eq_slice(self.id_to_str(sid), ident)\n             }\n             _ => false\n         }"}, {"sha": "47c0827eb23c4633adad1cd3b3ca16ec74ad2ba6", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -96,7 +96,6 @@ use core::iterator::IteratorUtil;\n use core::either::Either;\n use core::either;\n use core::hashmap::HashSet;\n-use core::str;\n use core::vec;\n \n #[deriving(Eq)]\n@@ -263,7 +262,7 @@ pub struct Parser {\n     /// extra detail when the same error is seen twice\n     obsolete_set: @mut HashSet<ObsoleteSyntax>,\n     /// Used to determine the path to externally loaded source files\n-    mod_path_stack: @mut ~[~str],\n+    mod_path_stack: @mut ~[@str],\n \n }\n \n@@ -333,7 +332,7 @@ impl Parser {\n     }\n     pub fn get_id(&self) -> node_id { next_node_id(self.sess) }\n \n-    pub fn id_to_str(&self, id: ident) -> @~str {\n+    pub fn id_to_str(&self, id: ident) -> @str {\n         get_ident_interner().get(id.name)\n     }\n \n@@ -2886,7 +2885,7 @@ impl Parser {\n         loop {\n             match *self.token {\n                 token::LIFETIME(lifetime) => {\n-                    if str::eq_slice(*self.id_to_str(lifetime), \"static\") {\n+                    if \"static\" == self.id_to_str(lifetime) {\n                         result.push(RegionTyParamBound);\n                     } else {\n                         self.span_err(*self.span,\n@@ -2898,11 +2897,11 @@ impl Parser {\n                     let obsolete_bound = match *self.token {\n                         token::MOD_SEP => false,\n                         token::IDENT(sid, _) => {\n-                            match *self.id_to_str(sid) {\n-                                ~\"send\" |\n-                                ~\"copy\" |\n-                                ~\"const\" |\n-                                ~\"owned\" => {\n+                            match self.id_to_str(sid).as_slice() {\n+                                \"send\" |\n+                                \"copy\" |\n+                                \"const\" |\n+                                \"owned\" => {\n                                     self.obsolete(\n                                         *self.span,\n                                         ObsoleteLowerCaseKindBounds);\n@@ -3364,7 +3363,7 @@ impl Parser {\n             }\n             if fields.len() == 0 {\n                 self.fatal(fmt!(\"Unit-like struct should be written as `struct %s;`\",\n-                                *get_ident_interner().get(class_name.name)));\n+                                get_ident_interner().get(class_name.name)));\n             }\n             self.bump();\n         } else if *self.token == token::LPAREN {\n@@ -3580,8 +3579,8 @@ impl Parser {\n         let file_path = match ::attr::first_attr_value_str_by_name(\n             attrs, \"path\") {\n \n-            Some(d) => copy *d,\n-            None => copy *default_path\n+            Some(d) => d,\n+            None => default_path\n         };\n         self.mod_path_stack.push(file_path)\n     }\n@@ -3599,13 +3598,13 @@ impl Parser {\n         let prefix = prefix.dir_path();\n         let mod_path_stack = &*self.mod_path_stack;\n         let mod_path = Path(\".\").push_many(*mod_path_stack);\n-        let default_path = *token::interner_get(id.name) + \".rs\";\n+        let default_path = token::interner_get(id.name).to_owned() + \".rs\";\n         let file_path = match ::attr::first_attr_value_str_by_name(\n             outer_attrs, \"path\") {\n             Some(d) => {\n-                let path = Path(copy *d);\n+                let path = Path(d);\n                 if !path.is_absolute {\n-                    mod_path.push(copy *d)\n+                    mod_path.push(d)\n                 } else {\n                     path\n                 }\n@@ -3637,9 +3636,9 @@ impl Parser {\n         let m0 = p0.parse_mod_items(token::EOF, first_item_outer_attrs);\n         return (ast::item_mod(m0), mod_attrs);\n \n-        fn cdir_path_opt(default: ~str, attrs: ~[ast::attribute]) -> ~str {\n+        fn cdir_path_opt(default: @str, attrs: ~[ast::attribute]) -> @str {\n             match ::attr::first_attr_value_str_by_name(attrs, \"path\") {\n-                Some(d) => copy *d,\n+                Some(d) => d,\n                 None => default\n             }\n         }\n@@ -4263,7 +4262,7 @@ impl Parser {\n \n         let first_ident = self.parse_ident();\n         let mut path = ~[first_ident];\n-        debug!(\"parsed view_path: %s\", *self.id_to_str(first_ident));\n+        debug!(\"parsed view_path: %s\", self.id_to_str(first_ident));\n         match *self.token {\n           token::EQ => {\n             // x = foo::bar\n@@ -4528,7 +4527,7 @@ impl Parser {\n                                config: copy self.cfg })\n     }\n \n-    pub fn parse_str(&self) -> @~str {\n+    pub fn parse_str(&self) -> @str {\n         match *self.token {\n             token::LIT_STR(s) => {\n                 self.bump();"}, {"sha": "e7bc67340f011fc4f2545831ba60eb18d72f7d90", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 11, "deletions": 27, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -21,10 +21,8 @@ use core::cast;\n use core::char;\n use core::cmp::Equiv;\n use core::local_data;\n-use core::str;\n use core::rand;\n use core::rand::RngUtil;\n-use core::to_bytes;\n \n #[deriving(Encodable, Decodable, Eq)]\n pub enum binop {\n@@ -180,28 +178,28 @@ pub fn to_str(in: @ident_interner, t: &Token) -> ~str {\n       }\n       LIT_INT_UNSUFFIXED(i) => { i.to_str() }\n       LIT_FLOAT(ref s, t) => {\n-        let mut body = copy *ident_to_str(s);\n+        let mut body = ident_to_str(s).to_owned();\n         if body.ends_with(\".\") {\n             body += \"0\";  // `10.f` is not a float literal\n         }\n         body + ast_util::float_ty_to_str(t)\n       }\n       LIT_FLOAT_UNSUFFIXED(ref s) => {\n-        let mut body = copy *ident_to_str(s);\n+        let mut body = ident_to_str(s).to_owned();\n         if body.ends_with(\".\") {\n             body += \"0\";  // `10.f` is not a float literal\n         }\n         body\n       }\n-      LIT_STR(ref s) => { ~\"\\\"\" + ident_to_str(s).escape_default() + \"\\\"\" }\n+      LIT_STR(ref s) => { fmt!(\"\\\"%s\\\"\", ident_to_str(s).escape_default()) }\n \n       /* Name components */\n-      IDENT(s, _) => copy *in.get(s.name),\n-      LIFETIME(s) => fmt!(\"'%s\", *in.get(s.name)),\n+      IDENT(s, _) => in.get(s.name).to_owned(),\n+      LIFETIME(s) => fmt!(\"'%s\", in.get(s.name)),\n       UNDERSCORE => ~\"_\",\n \n       /* Other */\n-      DOC_COMMENT(ref s) => copy *ident_to_str(s),\n+      DOC_COMMENT(ref s) => ident_to_str(s).to_owned(),\n       EOF => ~\"<eof>\",\n       INTERPOLATED(ref nt) => {\n         match nt {\n@@ -350,20 +348,6 @@ pub mod special_idents {\n     pub static type_self: ident = ident { name: 34, ctxt: 0};    // `Self`\n }\n \n-pub struct StringRef<'self>(&'self str);\n-\n-impl<'self> Equiv<@~str> for StringRef<'self> {\n-    #[inline(always)]\n-    fn equiv(&self, other: &@~str) -> bool { str::eq_slice(**self, **other) }\n-}\n-\n-impl<'self> to_bytes::IterBytes for StringRef<'self> {\n-    #[inline(always)]\n-    fn iter_bytes(&self, lsb0: bool, f: to_bytes::Cb) -> bool {\n-        (**self).iter_bytes(lsb0, f)\n-    }\n-}\n-\n /**\n  * Maps a token to a record specifying the corresponding binary\n  * operator\n@@ -403,14 +387,14 @@ impl ident_interner {\n     pub fn gensym(&self, val: &str) -> Name {\n         self.interner.gensym(val)\n     }\n-    pub fn get(&self, idx: Name) -> @~str {\n+    pub fn get(&self, idx: Name) -> @str {\n         self.interner.get(idx)\n     }\n     // is this really something that should be exposed?\n     pub fn len(&self) -> uint {\n         self.interner.len()\n     }\n-    pub fn find_equiv<Q:Hash + IterBytes + Equiv<@~str>>(&self, val: &Q)\n+    pub fn find_equiv<Q:Hash + IterBytes + Equiv<@str>>(&self, val: &Q)\n                                                      -> Option<Name> {\n         self.interner.find_equiv(val)\n     }\n@@ -542,12 +526,12 @@ pub fn gensym(str : &str) -> Name {\n }\n \n // map an interned representation back to a string\n-pub fn interner_get(name : Name) -> @~str {\n+pub fn interner_get(name : Name) -> @str {\n     get_ident_interner().get(name)\n }\n \n // maps an identifier to the string that it corresponds to\n-pub fn ident_to_str(id : &ast::ident) -> @~str {\n+pub fn ident_to_str(id : &ast::ident) -> @str {\n     interner_get(id.name)\n }\n \n@@ -715,6 +699,6 @@ mod test {\n     #[test] fn t1() {\n         let a = fresh_name(\"ghi\");\n         io::println(fmt!(\"interned name: %u,\\ntextual name: %s\\n\",\n-                         a,*interner_get(a)));\n+                         a,interner_get(a)));\n     }\n }"}, {"sha": "7853e7e312d41aab759f104d260994d02ab9dfbd", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -80,7 +80,7 @@ pub struct begin_t {\n }\n \n pub enum token {\n-    STRING(@~str, int),\n+    STRING(@str, int),\n     BREAK(break_t),\n     BEGIN(begin_t),\n     END,\n@@ -107,7 +107,7 @@ impl token {\n \n pub fn tok_str(t: token) -> ~str {\n     match t {\n-        STRING(s, len) => return fmt!(\"STR(%s,%d)\", *s, len),\n+        STRING(s, len) => return fmt!(\"STR(%s,%d)\", s, len),\n         BREAK(_) => return ~\"BREAK\",\n         BEGIN(_) => return ~\"BEGIN\",\n         END => return ~\"END\",\n@@ -335,11 +335,11 @@ impl Printer {\n           STRING(s, len) => {\n             if self.scan_stack_empty {\n                 debug!(\"pp STRING('%s')/print ~[%u,%u]\",\n-                       *s, self.left, self.right);\n+                       s, self.left, self.right);\n                 self.print(t, len);\n             } else {\n                 debug!(\"pp STRING('%s')/buffer ~[%u,%u]\",\n-                       *s, self.left, self.right);\n+                       s, self.left, self.right);\n                 self.advance_right();\n                 self.token[self.right] = t;\n                 self.size[self.right] = len;\n@@ -534,11 +534,11 @@ impl Printer {\n             }\n           }\n           STRING(s, len) => {\n-            debug!(\"print STRING(%s)\", *s);\n+            debug!(\"print STRING(%s)\", s);\n             assert_eq!(L, len);\n             // assert!(L <= space);\n             self.space -= len;\n-            self.print_str(*s);\n+            self.print_str(s);\n           }\n           EOF => {\n             // EOF should never get here.\n@@ -572,15 +572,15 @@ pub fn end(p: @mut Printer) { p.pretty_print(END); }\n pub fn eof(p: @mut Printer) { p.pretty_print(EOF); }\n \n pub fn word(p: @mut Printer, wrd: &str) {\n-    p.pretty_print(STRING(@/*bad*/ wrd.to_owned(), wrd.len() as int));\n+    p.pretty_print(STRING(/* bad */ wrd.to_managed(), wrd.len() as int));\n }\n \n pub fn huge_word(p: @mut Printer, wrd: &str) {\n-    p.pretty_print(STRING(@/*bad*/ wrd.to_owned(), size_infinity));\n+    p.pretty_print(STRING(/* bad */ wrd.to_managed(), size_infinity));\n }\n \n pub fn zero_word(p: @mut Printer, wrd: &str) {\n-    p.pretty_print(STRING(@/*bad*/ wrd.to_owned(), 0));\n+    p.pretty_print(STRING(/* bad */ wrd.to_managed(), 0));\n }\n \n pub fn spaces(p: @mut Printer, n: uint) { break_offset(p, n, 0); }"}, {"sha": "c2a537dd10d8ffff13949786be4196cb7f9d9634", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -111,14 +111,14 @@ pub fn print_crate(cm: @CodeMap,\n                    intr: @ident_interner,\n                    span_diagnostic: @diagnostic::span_handler,\n                    crate: @ast::crate,\n-                   filename: ~str,\n+                   filename: @str,\n                    in: @io::Reader,\n                    out: @io::Writer,\n                    ann: pp_ann,\n                    is_expanded: bool) {\n     let (cmnts, lits) = comments::gather_comments_and_literals(\n         span_diagnostic,\n-        copy filename,\n+        filename,\n         in\n     );\n     let s = @ps {\n@@ -860,7 +860,7 @@ pub fn print_attribute(s: @ps, attr: ast::attribute) {\n     if attr.node.is_sugared_doc {\n         let meta = attr::attr_meta(attr);\n         let comment = attr::get_meta_item_value_str(meta).get();\n-        word(s.s, *comment);\n+        word(s.s, comment);\n     } else {\n         word(s.s, \"#[\");\n         print_meta_item(s, attr.node.value);\n@@ -1400,25 +1400,25 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n             word(s.s, \"asm!\");\n         }\n         popen(s);\n-        print_string(s, *a.asm);\n+        print_string(s, a.asm);\n         word_space(s, \":\");\n         for a.outputs.each |&(co, o)| {\n-            print_string(s, *co);\n+            print_string(s, co);\n             popen(s);\n             print_expr(s, o);\n             pclose(s);\n             word_space(s, \",\");\n         }\n         word_space(s, \":\");\n         for a.inputs.each |&(co, o)| {\n-            print_string(s, *co);\n+            print_string(s, co);\n             popen(s);\n             print_expr(s, o);\n             pclose(s);\n             word_space(s, \",\");\n         }\n         word_space(s, \":\");\n-        print_string(s, *a.clobbers);\n+        print_string(s, a.clobbers);\n         pclose(s);\n       }\n       ast::expr_mac(ref m) => print_mac(s, m),\n@@ -1474,7 +1474,7 @@ pub fn print_decl(s: @ps, decl: @ast::decl) {\n }\n \n pub fn print_ident(s: @ps, ident: ast::ident) {\n-    word(s.s, *ident_to_str(&ident));\n+    word(s.s, ident_to_str(&ident));\n }\n \n pub fn print_for_decl(s: @ps, loc: @ast::local, coll: @ast::expr) {\n@@ -1776,14 +1776,14 @@ pub fn print_generics(s: @ps, generics: &ast::Generics) {\n pub fn print_meta_item(s: @ps, item: @ast::meta_item) {\n     ibox(s, indent_unit);\n     match item.node {\n-      ast::meta_word(name) => word(s.s, *name),\n+      ast::meta_word(name) => word(s.s, name),\n       ast::meta_name_value(name, value) => {\n-        word_space(s, *name);\n+        word_space(s, name);\n         word_space(s, \"=\");\n         print_literal(s, @value);\n       }\n       ast::meta_list(name, ref items) => {\n-        word(s.s, *name);\n+        word(s.s, name);\n         popen(s);\n         commasep(\n             s,\n@@ -1995,7 +1995,7 @@ pub fn print_literal(s: @ps, lit: @ast::lit) {\n       _ => ()\n     }\n     match lit.node {\n-      ast::lit_str(st) => print_string(s, *st),\n+      ast::lit_str(st) => print_string(s, st),\n       ast::lit_int(ch, ast::ty_char) => {\n         word(s.s, ~\"'\" + char::escape_default(ch as char) + \"'\");\n       }\n@@ -2023,9 +2023,9 @@ pub fn print_literal(s: @ps, lit: @ast::lit) {\n         }\n       }\n       ast::lit_float(f, t) => {\n-        word(s.s, *f + ast_util::float_ty_to_str(t));\n+        word(s.s, f.to_owned() + ast_util::float_ty_to_str(t));\n       }\n-      ast::lit_float_unsuffixed(f) => word(s.s, *f),\n+      ast::lit_float_unsuffixed(f) => word(s.s, f),\n       ast::lit_nil => word(s.s, \"()\"),\n       ast::lit_bool(val) => {\n         if val { word(s.s, \"true\"); } else { word(s.s, \"false\"); }\n@@ -2101,7 +2101,7 @@ pub fn print_comment(s: @ps, cmnt: &comments::cmnt) {\n         // We need to do at least one, possibly two hardbreaks.\n         let is_semi =\n             match s.s.last_token() {\n-              pp::STRING(s, _) => *s == ~\";\",\n+              pp::STRING(s, _) => \";\" == s,\n               _ => false\n             };\n         if is_semi || is_begin(s) || is_end(s) { hardbreak(s.s); }"}, {"sha": "d4f183ada7b6ee147555fd98809191e8006020bd", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -19,7 +19,6 @@ use core::prelude::*;\n \n use core::cmp::Equiv;\n use core::hashmap::HashMap;\n-use syntax::parse::token::StringRef;\n \n pub struct Interner<T> {\n     priv map: @mut HashMap<T, uint>,\n@@ -80,8 +79,8 @@ impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n // A StrInterner differs from Interner<String> in that it accepts\n // borrowed pointers rather than @ ones, resulting in less allocation.\n pub struct StrInterner {\n-    priv map: @mut HashMap<@~str, uint>,\n-    priv vect: @mut ~[@~str],\n+    priv map: @mut HashMap<@str, uint>,\n+    priv vect: @mut ~[@str],\n }\n \n // when traits can extend traits, we should extend index<uint,T> to get []\n@@ -95,37 +94,38 @@ impl StrInterner {\n \n     pub fn prefill(init: &[&str]) -> StrInterner {\n         let rv = StrInterner::new();\n-        for init.each() |v| { rv.intern(*v); }\n+        for init.each |&v| { rv.intern(v); }\n         rv\n     }\n \n     pub fn intern(&self, val: &str) -> uint {\n-        match self.map.find_equiv(&StringRef(val)) {\n+        match self.map.find_equiv(&val) {\n             Some(&idx) => return idx,\n             None => (),\n         }\n \n         let new_idx = self.len();\n-        self.map.insert(@val.to_owned(), new_idx);\n-        self.vect.push(@val.to_owned());\n+        let val = val.to_managed();\n+        self.map.insert(val, new_idx);\n+        self.vect.push(val);\n         new_idx\n     }\n \n     pub fn gensym(&self, val: &str) -> uint {\n         let new_idx = self.len();\n         // leave out of .map to avoid colliding\n-        self.vect.push(@val.to_owned());\n+        self.vect.push(val.to_managed());\n         new_idx\n     }\n \n     // this isn't \"pure\" in the traditional sense, because it can go from\n     // failing to returning a value as items are interned. But for typestate,\n     // where we first check a pred and then rely on it, ceasing to fail is ok.\n-    pub fn get(&self, idx: uint) -> @~str { self.vect[idx] }\n+    pub fn get(&self, idx: uint) -> @str { self.vect[idx] }\n \n     pub fn len(&self) -> uint { let vect = &*self.vect; vect.len() }\n \n-    pub fn find_equiv<Q:Hash + IterBytes + Equiv<@~str>>(&self, val: &Q)\n+    pub fn find_equiv<Q:Hash + IterBytes + Equiv<@str>>(&self, val: &Q)\n                                                          -> Option<uint> {\n         match self.map.find_equiv(val) {\n             Some(v) => Some(*v),\n@@ -140,41 +140,41 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn i1 () {\n-        let i : Interner<@~str> = Interner::new();\n+        let i : Interner<@str> = Interner::new();\n         i.get(13);\n     }\n \n     #[test]\n     fn i2 () {\n-        let i : Interner<@~str> = Interner::new();\n+        let i : Interner<@str> = Interner::new();\n         // first one is zero:\n-        assert_eq!(i.intern (@~\"dog\"), 0);\n+        assert_eq!(i.intern (@\"dog\"), 0);\n         // re-use gets the same entry:\n-        assert_eq!(i.intern (@~\"dog\"), 0);\n+        assert_eq!(i.intern (@\"dog\"), 0);\n         // different string gets a different #:\n-        assert_eq!(i.intern (@~\"cat\"), 1);\n-        assert_eq!(i.intern (@~\"cat\"), 1);\n+        assert_eq!(i.intern (@\"cat\"), 1);\n+        assert_eq!(i.intern (@\"cat\"), 1);\n         // dog is still at zero\n-        assert_eq!(i.intern (@~\"dog\"), 0);\n+        assert_eq!(i.intern (@\"dog\"), 0);\n         // gensym gets 3\n-        assert_eq!(i.gensym (@~\"zebra\" ), 2);\n+        assert_eq!(i.gensym (@\"zebra\" ), 2);\n         // gensym of same string gets new number :\n-        assert_eq!(i.gensym (@~\"zebra\" ), 3);\n+        assert_eq!(i.gensym (@\"zebra\" ), 3);\n         // gensym of *existing* string gets new number:\n-        assert_eq!(i.gensym (@~\"dog\"), 4);\n-        assert_eq!(i.get(0), @~\"dog\");\n-        assert_eq!(i.get(1), @~\"cat\");\n-        assert_eq!(i.get(2), @~\"zebra\");\n-        assert_eq!(i.get(3), @~\"zebra\");\n-        assert_eq!(i.get(4), @~\"dog\");\n+        assert_eq!(i.gensym (@\"dog\"), 4);\n+        assert_eq!(i.get(0), @\"dog\");\n+        assert_eq!(i.get(1), @\"cat\");\n+        assert_eq!(i.get(2), @\"zebra\");\n+        assert_eq!(i.get(3), @\"zebra\");\n+        assert_eq!(i.get(4), @\"dog\");\n     }\n \n     #[test]\n     fn i3 () {\n-        let i : Interner<@~str> = Interner::prefill([@~\"Alan\",@~\"Bob\",@~\"Carol\"]);\n-        assert_eq!(i.get(0), @~\"Alan\");\n-        assert_eq!(i.get(1), @~\"Bob\");\n-        assert_eq!(i.get(2), @~\"Carol\");\n-        assert_eq!(i.intern(@~\"Bob\"), 1);\n+        let i : Interner<@str> = Interner::prefill([@\"Alan\",@\"Bob\",@\"Carol\"]);\n+        assert_eq!(i.get(0), @\"Alan\");\n+        assert_eq!(i.get(1), @\"Bob\");\n+        assert_eq!(i.get(2), @\"Carol\");\n+        assert_eq!(i.intern(@\"Bob\"), 1);\n     }\n }"}, {"sha": "d0961ddbc70fe7ea3a8b77736576cb7bb5ec6aac", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=da510bfb4a3f6ca805e849372f9bbe7b2b0f6a61", "patch": "@@ -18,50 +18,50 @@ use parse::token;\n \n // map a string to tts, using a made-up filename: return both the token_trees\n // and the ParseSess\n-pub fn string_to_tts_and_sess (source_str : @~str) -> (~[ast::token_tree],@mut ParseSess) {\n+pub fn string_to_tts_and_sess (source_str : @str) -> (~[ast::token_tree],@mut ParseSess) {\n     let ps = new_parse_sess(None);\n-    (filemap_to_tts(ps,string_to_filemap(ps,source_str,~\"bogofile\")),ps)\n+    (filemap_to_tts(ps,string_to_filemap(ps,source_str,@\"bogofile\")),ps)\n }\n \n-pub fn string_to_parser_and_sess(source_str: @~str) -> (Parser,@mut ParseSess) {\n+pub fn string_to_parser_and_sess(source_str: @str) -> (Parser,@mut ParseSess) {\n     let ps = new_parse_sess(None);\n-    (new_parser_from_source_str(ps,~[],~\"bogofile\",source_str),ps)\n+    (new_parser_from_source_str(ps,~[],@\"bogofile\",source_str),ps)\n }\n \n // map string to parser (via tts)\n-pub fn string_to_parser(source_str: @~str) -> Parser {\n+pub fn string_to_parser(source_str: @str) -> Parser {\n     let (p,_) = string_to_parser_and_sess(source_str);\n     p\n }\n \n-pub fn string_to_crate (source_str : @~str) -> @ast::crate {\n+pub fn string_to_crate (source_str : @str) -> @ast::crate {\n     string_to_parser(source_str).parse_crate_mod()\n }\n \n // parse a string, return an expr\n-pub fn string_to_expr (source_str : @~str) -> @ast::expr {\n+pub fn string_to_expr (source_str : @str) -> @ast::expr {\n     string_to_parser(source_str).parse_expr()\n }\n \n // parse a string, return an item\n-pub fn string_to_item (source_str : @~str) -> Option<@ast::item> {\n+pub fn string_to_item (source_str : @str) -> Option<@ast::item> {\n     string_to_parser(source_str).parse_item(~[])\n }\n \n // parse a string, return an item and the ParseSess\n-pub fn string_to_item_and_sess (source_str : @~str) -> (Option<@ast::item>,@mut ParseSess) {\n+pub fn string_to_item_and_sess (source_str : @str) -> (Option<@ast::item>,@mut ParseSess) {\n     let (p,ps) = string_to_parser_and_sess(source_str);\n     (p.parse_item(~[]),ps)\n }\n \n // parse a string, return a stmt\n-pub fn string_to_stmt(source_str : @~str) -> @ast::stmt {\n+pub fn string_to_stmt(source_str : @str) -> @ast::stmt {\n     string_to_parser(source_str).parse_stmt(~[])\n }\n \n // parse a string, return a pat. Uses \"irrefutable\"... which doesn't\n // (currently) affect parsing.\n-pub fn string_to_pat(source_str : @~str) -> @ast::pat {\n+pub fn string_to_pat(source_str : @str) -> @ast::pat {\n     string_to_parser(source_str).parse_pat()\n }\n "}]}