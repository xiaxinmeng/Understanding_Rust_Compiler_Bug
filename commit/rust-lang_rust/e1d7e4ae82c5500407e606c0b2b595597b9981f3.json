{"sha": "e1d7e4ae82c5500407e606c0b2b595597b9981f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxZDdlNGFlODJjNTUwMDQwN2U2MDZjMGIyYjU5NTU5N2I5OTgxZjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-05T04:36:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-05T04:36:51Z"}, "message": "Auto merge of #63248 - petrochenkov:nomarker, r=matthewjasper\n\nMove special treatment of `derive(Copy, PartialEq, Eq)` from expansion infrastructure to elsewhere\n\nAs described in https://github.com/rust-lang/rust/pull/62086#issuecomment-515195477.\n\nReminder:\n- `derive(PartialEq, Eq)` makes the type it applied to a \"structural match\" type, so constants of this type can be used in patterns (and const generics in the future).\n- `derive(Copy)` notifies other derives that the type it applied to implements `Copy`, so `derive(Clone)` can generate optimized code and other derives can generate code working with `packed` types and types with `rustc_layout_scalar_valid_range` attributes.\n\nFirst, the special behavior is now enabled after properly resolving the derives, rather than after textually comparing them with `\"Copy\"`, `\"PartialEq\"` and `\"Eq\"` in `fn add_derived_markers`.\n\nThe markers are no longer kept as attributes in AST since derives cannot modify items and previously did it through hacks in the expansion infra.\nInstead, the markers are now kept in a \"global context\" available from all the necessary places, namely - resolver.\n\nFor `derive(PartialEq, Eq)` the markers are created by the derive macros themselves and then consumed during HIR lowering to add the `#[structural_match]` attribute in HIR.\nThis is still a hack, but now it's a hack local to two specific macros rather than affecting the whole expansion infra.\nIdeally we should find the way to put `#[structural_match]` on the impls rather than on the original item, and then consume it in `rustc_mir`, then no hacks in expansion and lowering will be required.\n(I'll make an issue about this for someone else to solve, after this PR lands.)\n\nThe marker for `derive(Copy)` cannot be emitted by the `Copy` macro itself because we need to know it *before* the `Copy` macro is expanded for expanding other macros.\nSo we have to do it in resolve and block expansion of any derives in a `derive(...)` container until we know for sure whether this container has `Copy` in it or not.\nNasty stuff.\n\nr? @eddyb or @matthewjasper", "tree": {"sha": "af36da7b4099f30dffe74257607bbce6f84d85e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af36da7b4099f30dffe74257607bbce6f84d85e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1d7e4ae82c5500407e606c0b2b595597b9981f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1d7e4ae82c5500407e606c0b2b595597b9981f3", "html_url": "https://github.com/rust-lang/rust/commit/e1d7e4ae82c5500407e606c0b2b595597b9981f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1d7e4ae82c5500407e606c0b2b595597b9981f3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11a51488f03405ea539a9fe84973ee972eaa7b96", "url": "https://api.github.com/repos/rust-lang/rust/commits/11a51488f03405ea539a9fe84973ee972eaa7b96", "html_url": "https://github.com/rust-lang/rust/commit/11a51488f03405ea539a9fe84973ee972eaa7b96"}, {"sha": "2a9b75281bfb03fc795568ac8fb6eeff7cac8034", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a9b75281bfb03fc795568ac8fb6eeff7cac8034", "html_url": "https://github.com/rust-lang/rust/commit/2a9b75281bfb03fc795568ac8fb6eeff7cac8034"}], "stats": {"total": 275, "additions": 167, "deletions": 108}, "files": [{"sha": "5031e6dbd87d2a02441361afdf9970a80c430cdc", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=e1d7e4ae82c5500407e606c0b2b595597b9981f3", "patch": "@@ -61,6 +61,7 @@ use syntax::ast;\n use syntax::ptr::P as AstP;\n use syntax::ast::*;\n use syntax::errors;\n+use syntax::ext::base::SpecialDerives;\n use syntax::ext::hygiene::ExpnId;\n use syntax::print::pprust;\n use syntax::source_map::{respan, ExpnInfo, ExpnKind, DesugaringKind, Spanned};\n@@ -176,6 +177,8 @@ pub trait Resolver {\n         components: &[Symbol],\n         is_value: bool,\n     ) -> (ast::Path, Res<NodeId>);\n+\n+    fn has_derives(&self, node_id: NodeId, derives: SpecialDerives) -> bool;\n }\n \n /// Context of `impl Trait` in code, which determines whether it is allowed in an HIR subtree,\n@@ -1329,13 +1332,17 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_attrs(&mut self, attrs: &[Attribute]) -> hir::HirVec<Attribute> {\n+    fn lower_attrs_extendable(&mut self, attrs: &[Attribute]) -> Vec<Attribute> {\n         attrs\n             .iter()\n             .map(|a| self.lower_attr(a))\n             .collect()\n     }\n \n+    fn lower_attrs(&mut self, attrs: &[Attribute]) -> hir::HirVec<Attribute> {\n+        self.lower_attrs_extendable(attrs).into()\n+    }\n+\n     fn lower_attr(&mut self, attr: &Attribute) -> Attribute {\n         // Note that we explicitly do not walk the path. Since we don't really\n         // lower attributes (we use the AST version) there is nowhere to keep\n@@ -4028,7 +4035,14 @@ impl<'a> LoweringContext<'a> {\n     pub fn lower_item(&mut self, i: &Item) -> Option<hir::Item> {\n         let mut ident = i.ident;\n         let mut vis = self.lower_visibility(&i.vis, None);\n-        let attrs = self.lower_attrs(&i.attrs);\n+        let mut attrs = self.lower_attrs_extendable(&i.attrs);\n+        if self.resolver.has_derives(i.id, SpecialDerives::PARTIAL_EQ | SpecialDerives::EQ) {\n+            // Add `#[structural_match]` if the item derived both `PartialEq` and `Eq`.\n+            let ident = Ident::new(sym::structural_match, i.span);\n+            attrs.push(attr::mk_attr_outer(attr::mk_word_item(ident)));\n+        }\n+        let attrs = attrs.into();\n+\n         if let ItemKind::MacroDef(ref def) = i.node {\n             if !def.legacy || attr::contains_name(&i.attrs, sym::macro_export) {\n                 let body = self.lower_token_stream(def.stream());"}, {"sha": "1a203e73f0a8619dc0a8bc00f0eab1eb53bd5232", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e1d7e4ae82c5500407e606c0b2b595597b9981f3", "patch": "@@ -38,8 +38,7 @@ use rustc_metadata::cstore::CStore;\n use syntax::source_map::SourceMap;\n use syntax::ext::hygiene::{ExpnId, Transparency, SyntaxContext};\n use syntax::ast::{self, Name, NodeId, Ident, FloatTy, IntTy, UintTy};\n-use syntax::ext::base::SyntaxExtension;\n-use syntax::ext::base::MacroKind;\n+use syntax::ext::base::{SyntaxExtension, MacroKind, SpecialDerives};\n use syntax::symbol::{Symbol, kw, sym};\n use syntax::util::lev_distance::find_best_match_for_name;\n \n@@ -1685,6 +1684,12 @@ pub struct Resolver<'a> {\n     local_macro_def_scopes: FxHashMap<NodeId, Module<'a>>,\n     unused_macros: NodeMap<Span>,\n     proc_macro_stubs: NodeSet,\n+    /// Some built-in derives mark items they are applied to so they are treated specially later.\n+    /// Derive macros cannot modify the item themselves and have to store the markers in the global\n+    /// context, so they attach the markers to derive container IDs using this resolver table.\n+    /// FIXME: Find a way for `PartialEq` and `Eq` to emulate `#[structural_match]`\n+    /// by marking the produced impls rather than the original items.\n+    special_derives: FxHashMap<ExpnId, SpecialDerives>,\n \n     /// Maps the `ExpnId` of an expansion to its containing module or block.\n     invocations: FxHashMap<ExpnId, &'a InvocationData<'a>>,\n@@ -1813,6 +1818,12 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n     fn definitions(&mut self) -> &mut Definitions {\n         &mut self.definitions\n     }\n+\n+    fn has_derives(&self, node_id: NodeId, derives: SpecialDerives) -> bool {\n+        let def_id = self.definitions.local_def_id(node_id);\n+        let expn_id = self.definitions.expansion_that_defined(def_id.index);\n+        self.has_derives(expn_id, derives)\n+    }\n }\n \n impl<'a> Resolver<'a> {\n@@ -2031,6 +2042,7 @@ impl<'a> Resolver<'a> {\n             struct_constructors: Default::default(),\n             unused_macros: Default::default(),\n             proc_macro_stubs: Default::default(),\n+            special_derives: Default::default(),\n             current_type_ascription: Vec::new(),\n             injected_crate: None,\n             active_features:\n@@ -2077,6 +2089,10 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n+    fn has_derives(&self, expn_id: ExpnId, markers: SpecialDerives) -> bool {\n+        self.special_derives.get(&expn_id).map_or(false, |m| m.contains(markers))\n+    }\n+\n     /// Entry point to crate resolution.\n     pub fn resolve_crate(&mut self, krate: &Crate) {\n         ImportResolver { resolver: self }.finalize_imports();"}, {"sha": "1f534bc41fe6f3554d62d85bdc6ca9eb6e36f7ad", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=e1d7e4ae82c5500407e606c0b2b595597b9981f3", "patch": "@@ -14,7 +14,7 @@ use rustc::{ty, lint, span_bug};\n use syntax::ast::{self, Ident, ItemKind};\n use syntax::attr::{self, StabilityLevel};\n use syntax::edition::Edition;\n-use syntax::ext::base::{self, Indeterminate};\n+use syntax::ext::base::{self, Indeterminate, SpecialDerives};\n use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax::ext::expand::{AstFragment, Invocation, InvocationKind};\n use syntax::ext::hygiene::{self, ExpnId, ExpnInfo, ExpnKind};\n@@ -203,8 +203,28 @@ impl<'a> base::Resolver for Resolver<'a> {\n                 (&mac.node.path, MacroKind::Bang, Vec::new(), false),\n             InvocationKind::Derive { ref path, .. } =>\n                 (path, MacroKind::Derive, Vec::new(), false),\n-            InvocationKind::DeriveContainer { .. } =>\n-                return Ok(None),\n+            InvocationKind::DeriveContainer { ref derives, .. } => {\n+                // Block expansion of derives in the container until we know whether one of them\n+                // is a built-in `Copy`. Skip the resolution if there's only one derive - either\n+                // it's not a `Copy` and we don't need to do anything, or it's a `Copy` and it\n+                // will automatically knows about itself.\n+                let mut result = Ok(None);\n+                if derives.len() > 1 {\n+                    let parent_scope = self.invoc_parent_scope(invoc_id, Vec::new());\n+                    for path in derives {\n+                        match self.resolve_macro_path(path, Some(MacroKind::Derive),\n+                                                      &parent_scope, true, force) {\n+                            Ok((Some(ref ext), _)) if ext.is_derive_copy => {\n+                                self.add_derives(invoc.expansion_data.id, SpecialDerives::COPY);\n+                                return Ok(None);\n+                            }\n+                            Err(Determinacy::Undetermined) => result = Err(Indeterminate),\n+                            _ => {}\n+                        }\n+                    }\n+                }\n+                return result;\n+            }\n         };\n \n         let parent_scope = self.invoc_parent_scope(invoc_id, derives_in_scope);\n@@ -234,6 +254,14 @@ impl<'a> base::Resolver for Resolver<'a> {\n             );\n         }\n     }\n+\n+    fn has_derives(&self, expn_id: ExpnId, derives: SpecialDerives) -> bool {\n+        self.has_derives(expn_id, derives)\n+    }\n+\n+    fn add_derives(&mut self, expn_id: ExpnId, derives: SpecialDerives) {\n+        *self.special_derives.entry(expn_id).or_default() |= derives;\n+    }\n }\n \n impl<'a> Resolver<'a> {"}, {"sha": "d69822c7c7f1af8d38f67e51f2b17d72ec283ce5", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=e1d7e4ae82c5500407e606c0b2b595597b9981f3", "patch": "@@ -595,6 +595,8 @@ pub struct SyntaxExtension {\n     /// Built-in macros have a couple of special properties (meaning of `$crate`,\n     /// availability in `#[no_implicit_prelude]` modules), so we have to keep this flag.\n     pub is_builtin: bool,\n+    /// We have to identify macros providing a `Copy` impl early for compatibility reasons.\n+    pub is_derive_copy: bool,\n }\n \n impl SyntaxExtensionKind {\n@@ -640,6 +642,7 @@ impl SyntaxExtension {\n             helper_attrs: Vec::new(),\n             edition,\n             is_builtin: false,\n+            is_derive_copy: false,\n             kind,\n         }\n     }\n@@ -683,6 +686,16 @@ pub type NamedSyntaxExtension = (Name, SyntaxExtension);\n /// Error type that denotes indeterminacy.\n pub struct Indeterminate;\n \n+bitflags::bitflags! {\n+    /// Built-in derives that need some extra tracking beyond the usual macro functionality.\n+    #[derive(Default)]\n+    pub struct SpecialDerives: u8 {\n+        const PARTIAL_EQ = 1 << 0;\n+        const EQ         = 1 << 1;\n+        const COPY       = 1 << 2;\n+    }\n+}\n+\n pub trait Resolver {\n     fn next_node_id(&mut self) -> ast::NodeId;\n \n@@ -699,6 +712,9 @@ pub trait Resolver {\n                                 -> Result<Option<Lrc<SyntaxExtension>>, Indeterminate>;\n \n     fn check_unused_macros(&self);\n+\n+    fn has_derives(&self, expn_id: ExpnId, derives: SpecialDerives) -> bool;\n+    fn add_derives(&mut self, expn_id: ExpnId, derives: SpecialDerives);\n }\n \n #[derive(Clone)]\n@@ -726,7 +742,6 @@ pub struct ExtCtxt<'a> {\n     pub resolver: &'a mut dyn Resolver,\n     pub current_expansion: ExpansionData,\n     pub expansions: FxHashMap<Span, Vec<String>>,\n-    pub allow_derive_markers: Lrc<[Symbol]>,\n }\n \n impl<'a> ExtCtxt<'a> {\n@@ -747,7 +762,6 @@ impl<'a> ExtCtxt<'a> {\n                 prior_type_ascription: None,\n             },\n             expansions: FxHashMap::default(),\n-            allow_derive_markers: [sym::rustc_attrs, sym::structural_match][..].into(),\n         }\n     }\n "}, {"sha": "d2807e4a4b5fa1714eef74575c18cbf619a45971", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=e1d7e4ae82c5500407e606c0b2b595597b9981f3", "patch": "@@ -4,7 +4,7 @@ use crate::attr::{self, HasAttrs};\n use crate::source_map::{dummy_spanned, respan};\n use crate::config::StripUnconfigured;\n use crate::ext::base::*;\n-use crate::ext::proc_macro::{add_derived_markers, collect_derives};\n+use crate::ext::proc_macro::collect_derives;\n use crate::ext::hygiene::{ExpnId, SyntaxContext, ExpnInfo, ExpnKind};\n use crate::ext::placeholders::{placeholder, PlaceholderExpander};\n use crate::feature_gate::{self, Features, GateIssue, is_builtin_attr, emit_feature_err};\n@@ -209,7 +209,6 @@ pub enum InvocationKind {\n     Derive {\n         path: Path,\n         item: Annotatable,\n-        item_with_markers: Annotatable,\n     },\n     /// \"Invocation\" that contains all derives from an item,\n     /// broken into multiple `Derive` invocations when expanded.\n@@ -360,8 +359,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n                 let mut item = self.fully_configure(item);\n                 item.visit_attrs(|attrs| attrs.retain(|a| a.path != sym::derive));\n-                let mut item_with_markers = item.clone();\n-                add_derived_markers(&mut self.cx, item.span(), &traits, &mut item_with_markers);\n                 let derives = derives.entry(invoc.expansion_data.id).or_default();\n \n                 derives.reserve(traits.len());\n@@ -370,11 +367,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     let expn_id = ExpnId::fresh(self.cx.current_expansion.id, None);\n                     derives.push(expn_id);\n                     invocations.push(Invocation {\n-                        kind: InvocationKind::Derive {\n-                            path,\n-                            item: item.clone(),\n-                            item_with_markers: item_with_markers.clone(),\n-                        },\n+                        kind: InvocationKind::Derive { path, item: item.clone() },\n                         fragment_kind: invoc.fragment_kind,\n                         expansion_data: ExpansionData {\n                             id: expn_id,\n@@ -383,7 +376,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     });\n                 }\n                 let fragment = invoc.fragment_kind\n-                    .expect_from_annotatables(::std::iter::once(item_with_markers));\n+                    .expect_from_annotatables(::std::iter::once(item));\n                 self.collect_invocations(fragment, derives)\n             } else {\n                 unreachable!()\n@@ -574,13 +567,9 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 }\n                 _ => unreachable!()\n             }\n-            InvocationKind::Derive { path, item, item_with_markers } => match ext {\n+            InvocationKind::Derive { path, item } => match ext {\n                 SyntaxExtensionKind::Derive(expander) |\n                 SyntaxExtensionKind::LegacyDerive(expander) => {\n-                    let (path, item) = match ext {\n-                        SyntaxExtensionKind::LegacyDerive(..) => (path, item_with_markers),\n-                        _ => (path, item),\n-                    };\n                     if !item.derive_allowed() {\n                         return fragment_kind.dummy(span);\n                     }"}, {"sha": "c17b6f6b4248a75858c3a19c6117f6c0a16d85b2", "filename": "src/libsyntax/ext/proc_macro.rs", "status": "modified", "additions": 2, "deletions": 33, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Flibsyntax%2Fext%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Flibsyntax%2Fext%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro.rs?ref=e1d7e4ae82c5500407e606c0b2b595597b9981f3", "patch": "@@ -1,17 +1,15 @@\n use crate::ast::{self, ItemKind, Attribute, Mac};\n-use crate::attr::{mark_used, mark_known, HasAttrs};\n+use crate::attr::{mark_used, mark_known};\n use crate::errors::{Applicability, FatalError};\n use crate::ext::base::{self, *};\n use crate::ext::proc_macro_server;\n use crate::parse::{self, token};\n use crate::parse::parser::PathStyle;\n-use crate::symbol::{sym, Symbol};\n+use crate::symbol::sym;\n use crate::tokenstream::{self, TokenStream};\n use crate::visit::Visitor;\n \n-use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::Lrc;\n-use syntax_pos::hygiene::{ExpnInfo, ExpnKind};\n use syntax_pos::{Span, DUMMY_SP};\n \n const EXEC_STRATEGY: proc_macro::bridge::server::SameThread =\n@@ -217,32 +215,3 @@ crate fn collect_derives(cx: &mut ExtCtxt<'_>, attrs: &mut Vec<ast::Attribute>)\n     });\n     result\n }\n-\n-crate fn add_derived_markers<T: HasAttrs>(\n-    cx: &mut ExtCtxt<'_>, span: Span, traits: &[ast::Path], item: &mut T\n-) {\n-    let (mut names, mut pretty_name) = (FxHashSet::default(), String::new());\n-    for (i, path) in traits.iter().enumerate() {\n-        if i > 0 {\n-            pretty_name.push_str(\", \");\n-        }\n-        pretty_name.push_str(&path.to_string());\n-        names.insert(unwrap_or!(path.segments.get(0), continue).ident.name);\n-    }\n-\n-    let span = span.fresh_expansion(cx.current_expansion.id, ExpnInfo::allow_unstable(\n-        ExpnKind::Macro(MacroKind::Derive, Symbol::intern(&pretty_name)), span,\n-        cx.parse_sess.edition, cx.allow_derive_markers.clone(),\n-    ));\n-\n-    item.visit_attrs(|attrs| {\n-        if names.contains(&sym::Eq) && names.contains(&sym::PartialEq) {\n-            let meta = cx.meta_word(span, sym::structural_match);\n-            attrs.push(cx.attribute(meta));\n-        }\n-        if names.contains(&sym::Copy) {\n-            let meta = cx.meta_word(span, sym::rustc_copy_clone_marker);\n-            attrs.push(cx.attribute(meta));\n-        }\n-    });\n-}"}, {"sha": "7401f25641236192070c518f079ca1edf5154924", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=e1d7e4ae82c5500407e606c0b2b595597b9981f3", "patch": "@@ -430,6 +430,8 @@ pub fn compile(\n         }\n     }\n \n+    let is_builtin = attr::contains_name(&def.attrs, sym::rustc_builtin_macro);\n+\n     SyntaxExtension {\n         kind: SyntaxExtensionKind::LegacyBang(expander),\n         span: def.span,\n@@ -441,7 +443,8 @@ pub fn compile(\n         deprecation: attr::find_deprecation(&sess, &def.attrs, def.span),\n         helper_attrs: Vec::new(),\n         edition,\n-        is_builtin: attr::contains_name(&def.attrs, sym::rustc_builtin_macro),\n+        is_builtin,\n+        is_derive_copy: is_builtin && def.ident.name == sym::Copy,\n     }\n }\n "}, {"sha": "08a113b53d0324d607af9be916061be189f3af4c", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=e1d7e4ae82c5500407e606c0b2b595597b9981f3", "patch": "@@ -1329,11 +1329,6 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n                                                 /*opt*/ attributes(name1, name2, ...)\"),\n                                     Ungated),\n \n-    (sym::rustc_copy_clone_marker, Whitelisted, template!(Word), Gated(Stability::Unstable,\n-                                                sym::rustc_attrs,\n-                                                \"internal implementation detail\",\n-                                                cfg_fn!(rustc_attrs))),\n-\n     (sym::rustc_allocator, Whitelisted, template!(Word), Gated(Stability::Unstable,\n                                                 sym::rustc_attrs,\n                                                 \"internal implementation detail\","}, {"sha": "3b1edf90d6bf2790417ea2e0da5e094bd9c00377", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=e1d7e4ae82c5500407e606c0b2b595597b9981f3", "patch": "@@ -3,8 +3,7 @@ use crate::deriving::generic::*;\n use crate::deriving::generic::ty::*;\n \n use syntax::ast::{self, Expr, GenericArg, Generics, ItemKind, MetaItem, VariantData};\n-use syntax::attr;\n-use syntax::ext::base::{Annotatable, ExtCtxt};\n+use syntax::ext::base::{Annotatable, ExtCtxt, SpecialDerives};\n use syntax::ptr::P;\n use syntax::symbol::{kw, sym, Symbol};\n use syntax_pos::Span;\n@@ -36,7 +35,8 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt<'_>,\n             match annitem.node {\n                 ItemKind::Struct(_, Generics { ref params, .. }) |\n                 ItemKind::Enum(_, Generics { ref params, .. }) => {\n-                    if attr::contains_name(&annitem.attrs, sym::rustc_copy_clone_marker) &&\n+                    let container_id = cx.current_expansion.id.parent();\n+                    if cx.resolver.has_derives(container_id, SpecialDerives::COPY) &&\n                         !params.iter().any(|param| match param.kind {\n                             ast::GenericParamKind::Type { .. } => true,\n                             _ => false,"}, {"sha": "1909729f4a941c1e48ad0ce717c679dd8daa1cc7", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=e1d7e4ae82c5500407e606c0b2b595597b9981f3", "patch": "@@ -3,7 +3,7 @@ use crate::deriving::generic::*;\n use crate::deriving::generic::ty::*;\n \n use syntax::ast::{self, Expr, MetaItem, GenericArg};\n-use syntax::ext::base::{Annotatable, ExtCtxt};\n+use syntax::ext::base::{Annotatable, ExtCtxt, SpecialDerives};\n use syntax::ptr::P;\n use syntax::symbol::{sym, Symbol};\n use syntax_pos::Span;\n@@ -13,6 +13,8 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt<'_>,\n                           mitem: &MetaItem,\n                           item: &Annotatable,\n                           push: &mut dyn FnMut(Annotatable)) {\n+    cx.resolver.add_derives(cx.current_expansion.id.parent(), SpecialDerives::EQ);\n+\n     let inline = cx.meta_word(span, sym::inline);\n     let hidden = cx.meta_list_item_word(span, sym::hidden);\n     let doc = cx.meta_list(span, sym::doc, vec![hidden]);"}, {"sha": "7d7c4ae22a8a619204dc1276944585c53e40831e", "filename": "src/libsyntax_ext/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=e1d7e4ae82c5500407e606c0b2b595597b9981f3", "patch": "@@ -3,7 +3,7 @@ use crate::deriving::generic::*;\n use crate::deriving::generic::ty::*;\n \n use syntax::ast::{BinOpKind, Expr, MetaItem};\n-use syntax::ext::base::{Annotatable, ExtCtxt};\n+use syntax::ext::base::{Annotatable, ExtCtxt, SpecialDerives};\n use syntax::ptr::P;\n use syntax::symbol::sym;\n use syntax_pos::Span;\n@@ -13,6 +13,8 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt<'_>,\n                                   mitem: &MetaItem,\n                                   item: &Annotatable,\n                                   push: &mut dyn FnMut(Annotatable)) {\n+    cx.resolver.add_derives(cx.current_expansion.id.parent(), SpecialDerives::PARTIAL_EQ);\n+\n     // structures are equal if all fields are equal, and non equal, if\n     // any fields are not equal or if the enum variants are different\n     fn cs_op(cx: &mut ExtCtxt<'_>,"}, {"sha": "7e6d9126c87400bca5bfc1193afff2821d8f04e1", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=e1d7e4ae82c5500407e606c0b2b595597b9981f3", "patch": "@@ -186,7 +186,7 @@ use rustc_target::spec::abi::Abi;\n use syntax::ast::{self, BinOpKind, EnumDef, Expr, Generics, Ident, PatKind};\n use syntax::ast::{VariantData, GenericParamKind, GenericArg};\n use syntax::attr;\n-use syntax::ext::base::{Annotatable, ExtCtxt};\n+use syntax::ext::base::{Annotatable, ExtCtxt, SpecialDerives};\n use syntax::source_map::{self, respan};\n use syntax::util::map_in_place::MapInPlace;\n use syntax::ptr::P;\n@@ -425,8 +425,9 @@ impl<'a> TraitDef<'a> {\n                         return;\n                     }\n                 };\n+                let container_id = cx.current_expansion.id.parent();\n                 let is_always_copy =\n-                    attr::contains_name(&item.attrs, sym::rustc_copy_clone_marker) &&\n+                    cx.resolver.has_derives(container_id, SpecialDerives::COPY) &&\n                     has_no_type_params;\n                 let use_temporaries = is_packed && is_always_copy;\n "}, {"sha": "f7e1b983e54468cb0f1c423c82a3c7ccd6fec569", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=e1d7e4ae82c5500407e606c0b2b595597b9981f3", "patch": "@@ -565,7 +565,6 @@ symbols! {\n         rustc_clean,\n         rustc_const_unstable,\n         rustc_conversion_suggestion,\n-        rustc_copy_clone_marker,\n         rustc_def_path,\n         rustc_deprecated,\n         rustc_diagnostic_macros,"}, {"sha": "da1d7549d0750a943c927e8619e6c751469a4885", "filename": "src/test/ui/proc-macro/dollar-crate.stdout", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout?ref=e1d7e4ae82c5500407e606c0b2b595597b9981f3", "patch": "@@ -124,121 +124,121 @@ PRINT-BANG INPUT (DISPLAY): struct M ($crate :: S) ;\n PRINT-BANG INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #10 bytes(LO..HI),\n+        span: #9 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"M\",\n-        span: #10 bytes(LO..HI),\n+        span: #9 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"$crate\",\n-                span: #10 bytes(LO..HI),\n+                span: #9 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Joint,\n-                span: #10 bytes(LO..HI),\n+                span: #9 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Alone,\n-                span: #10 bytes(LO..HI),\n+                span: #9 bytes(LO..HI),\n             },\n             Ident {\n                 ident: \"S\",\n-                span: #10 bytes(LO..HI),\n+                span: #9 bytes(LO..HI),\n             },\n         ],\n-        span: #10 bytes(LO..HI),\n+        span: #9 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #10 bytes(LO..HI),\n+        span: #9 bytes(LO..HI),\n     },\n ]\n PRINT-ATTR INPUT (DISPLAY): struct A(::dollar_crate_external::S);\n PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ($crate :: S) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #10 bytes(LO..HI),\n+        span: #9 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"A\",\n-        span: #10 bytes(LO..HI),\n+        span: #9 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"$crate\",\n-                span: #10 bytes(LO..HI),\n+                span: #9 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Joint,\n-                span: #10 bytes(LO..HI),\n+                span: #9 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Alone,\n-                span: #10 bytes(LO..HI),\n+                span: #9 bytes(LO..HI),\n             },\n             Ident {\n                 ident: \"S\",\n-                span: #10 bytes(LO..HI),\n+                span: #9 bytes(LO..HI),\n             },\n         ],\n-        span: #10 bytes(LO..HI),\n+        span: #9 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #10 bytes(LO..HI),\n+        span: #9 bytes(LO..HI),\n     },\n ]\n PRINT-DERIVE INPUT (DISPLAY): struct D(::dollar_crate_external::S);\n PRINT-DERIVE RE-COLLECTED (DISPLAY): struct D ($crate :: S) ;\n PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #10 bytes(LO..HI),\n+        span: #9 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"D\",\n-        span: #10 bytes(LO..HI),\n+        span: #9 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"$crate\",\n-                span: #10 bytes(LO..HI),\n+                span: #9 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Joint,\n-                span: #10 bytes(LO..HI),\n+                span: #9 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Alone,\n-                span: #10 bytes(LO..HI),\n+                span: #9 bytes(LO..HI),\n             },\n             Ident {\n                 ident: \"S\",\n-                span: #10 bytes(LO..HI),\n+                span: #9 bytes(LO..HI),\n             },\n         ],\n-        span: #10 bytes(LO..HI),\n+        span: #9 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #10 bytes(LO..HI),\n+        span: #9 bytes(LO..HI),\n     },\n ]"}, {"sha": "b2f124788286d7ddba606dcdcd54ca3ca9aed40e", "filename": "src/test/ui/proc-macro/macro-namespace-reserved-2.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-namespace-reserved-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-namespace-reserved-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fmacro-namespace-reserved-2.stderr?ref=e1d7e4ae82c5500407e606c0b2b595597b9981f3", "patch": "@@ -46,18 +46,6 @@ error: expected attribute, found derive macro `MyTrait`\n LL | #[MyTrait]\n    |   ^^^^^^^ not an attribute\n \n-error: can't use a procedural macro from the same crate that defines it\n-  --> $DIR/macro-namespace-reserved-2.rs:49:10\n-   |\n-LL | #[derive(crate::my_macro)]\n-   |          ^^^^^^^^^^^^^^^\n-\n-error: expected derive macro, found macro `crate::my_macro`\n-  --> $DIR/macro-namespace-reserved-2.rs:49:10\n-   |\n-LL | #[derive(crate::my_macro)]\n-   |          ^^^^^^^^^^^^^^^ not a derive macro\n-\n error: can't use a procedural macro from the same crate that defines it\n   --> $DIR/macro-namespace-reserved-2.rs:52:10\n    |\n@@ -88,6 +76,18 @@ error: expected attribute, found macro `crate::my_macro`\n LL | #[crate::my_macro]\n    |   ^^^^^^^^^^^^^^^ not an attribute\n \n+error: can't use a procedural macro from the same crate that defines it\n+  --> $DIR/macro-namespace-reserved-2.rs:49:10\n+   |\n+LL | #[derive(crate::my_macro)]\n+   |          ^^^^^^^^^^^^^^^\n+\n+error: expected derive macro, found macro `crate::my_macro`\n+  --> $DIR/macro-namespace-reserved-2.rs:49:10\n+   |\n+LL | #[derive(crate::my_macro)]\n+   |          ^^^^^^^^^^^^^^^ not a derive macro\n+\n error: cannot find attribute macro `my_macro` in this scope\n   --> $DIR/macro-namespace-reserved-2.rs:38:3\n    |"}, {"sha": "8f1599a5abcb0fbf98e965e8cf84dcff70d9f108", "filename": "src/test/ui/span/issue-43927-non-ADT-derive.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Ftest%2Fui%2Fspan%2Fissue-43927-non-ADT-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Ftest%2Fui%2Fspan%2Fissue-43927-non-ADT-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-43927-non-ADT-derive.rs?ref=e1d7e4ae82c5500407e606c0b2b595597b9981f3", "patch": "@@ -2,6 +2,9 @@\n \n #![derive(Debug, PartialEq, Eq)] // should be an outer attribute!\n //~^ ERROR `derive` may only be applied to structs, enums and unions\n+//~| ERROR cannot determine resolution for the derive macro `Debug`\n+//~| ERROR cannot determine resolution for the derive macro `PartialEq`\n+//~| ERROR cannot determine resolution for the derive macro `Eq`\n struct DerivedOn;\n \n fn main() {}"}, {"sha": "47ce718600cec90510b39f79ced49b3464557edf", "filename": "src/test/ui/span/issue-43927-non-ADT-derive.stderr", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Ftest%2Fui%2Fspan%2Fissue-43927-non-ADT-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1d7e4ae82c5500407e606c0b2b595597b9981f3/src%2Ftest%2Fui%2Fspan%2Fissue-43927-non-ADT-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-43927-non-ADT-derive.stderr?ref=e1d7e4ae82c5500407e606c0b2b595597b9981f3", "patch": "@@ -4,5 +4,29 @@ error: `derive` may only be applied to structs, enums and unions\n LL | #![derive(Debug, PartialEq, Eq)] // should be an outer attribute!\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try an outer attribute: `#[derive(Debug, PartialEq, Eq)]`\n \n-error: aborting due to previous error\n+error: cannot determine resolution for the derive macro `Debug`\n+  --> $DIR/issue-43927-non-ADT-derive.rs:3:11\n+   |\n+LL | #![derive(Debug, PartialEq, Eq)] // should be an outer attribute!\n+   |           ^^^^^\n+   |\n+   = note: import resolution is stuck, try simplifying macro imports\n+\n+error: cannot determine resolution for the derive macro `PartialEq`\n+  --> $DIR/issue-43927-non-ADT-derive.rs:3:18\n+   |\n+LL | #![derive(Debug, PartialEq, Eq)] // should be an outer attribute!\n+   |                  ^^^^^^^^^\n+   |\n+   = note: import resolution is stuck, try simplifying macro imports\n+\n+error: cannot determine resolution for the derive macro `Eq`\n+  --> $DIR/issue-43927-non-ADT-derive.rs:3:29\n+   |\n+LL | #![derive(Debug, PartialEq, Eq)] // should be an outer attribute!\n+   |                             ^^\n+   |\n+   = note: import resolution is stuck, try simplifying macro imports\n+\n+error: aborting due to 4 previous errors\n "}]}