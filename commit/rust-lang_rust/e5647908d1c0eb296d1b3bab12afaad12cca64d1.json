{"sha": "e5647908d1c0eb296d1b3bab12afaad12cca64d1", "node_id": "C_kwDOAAsO6NoAKGU1NjQ3OTA4ZDFjMGViMjk2ZDFiM2JhYjEyYWZhYWQxMmNjYTY0ZDE", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-12-02T15:28:40Z"}, "committer": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2023-03-27T13:09:10Z"}, "message": "Split codegen_i128::maybe_codegen into two functions", "tree": {"sha": "7643596b71ef51f6f3baf69da107ba8e6a71800b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7643596b71ef51f6f3baf69da107ba8e6a71800b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5647908d1c0eb296d1b3bab12afaad12cca64d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5647908d1c0eb296d1b3bab12afaad12cca64d1", "html_url": "https://github.com/rust-lang/rust/commit/e5647908d1c0eb296d1b3bab12afaad12cca64d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5647908d1c0eb296d1b3bab12afaad12cca64d1/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b40efa24e284a8038a28b4695c1274e55e3440d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b40efa24e284a8038a28b4695c1274e55e3440d", "html_url": "https://github.com/rust-lang/rust/commit/9b40efa24e284a8038a28b4695c1274e55e3440d"}], "stats": {"total": 149, "additions": 82, "deletions": 67}, "files": [{"sha": "983af5f648768592502a71e5b5c63ea2501a759a", "filename": "src/codegen_i128.rs", "status": "modified", "additions": 80, "deletions": 65, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/e5647908d1c0eb296d1b3bab12afaad12cca64d1/src%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5647908d1c0eb296d1b3bab12afaad12cca64d1/src%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcodegen_i128.rs?ref=e5647908d1c0eb296d1b3bab12afaad12cca64d1", "patch": "@@ -7,7 +7,6 @@ use crate::prelude::*;\n pub(crate) fn maybe_codegen<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     bin_op: BinOp,\n-    checked: bool,\n     lhs: CValue<'tcx>,\n     rhs: CValue<'tcx>,\n ) -> Option<CValue<'tcx>> {\n@@ -22,69 +21,23 @@ pub(crate) fn maybe_codegen<'tcx>(\n     let is_signed = type_sign(lhs.layout().ty);\n \n     match bin_op {\n-        BinOp::BitAnd | BinOp::BitOr | BinOp::BitXor => {\n-            assert!(!checked);\n-            None\n-        }\n-        BinOp::Add | BinOp::Sub if !checked => None,\n-        BinOp::Mul if !checked || is_signed => {\n-            if !checked {\n-                let args = [lhs.load_scalar(fx), rhs.load_scalar(fx)];\n-                let ret_val = fx.lib_call(\n-                    \"__multi3\",\n-                    vec![AbiParam::new(types::I128), AbiParam::new(types::I128)],\n-                    vec![AbiParam::new(types::I128)],\n-                    &args,\n-                )[0];\n-                Some(CValue::by_val(\n-                    ret_val,\n-                    fx.layout_of(if is_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 }),\n-                ))\n-            } else {\n-                let out_ty = fx.tcx.mk_tup(&[lhs.layout().ty, fx.tcx.types.bool]);\n-                let oflow = CPlace::new_stack_slot(fx, fx.layout_of(fx.tcx.types.i32));\n-                let lhs = lhs.load_scalar(fx);\n-                let rhs = rhs.load_scalar(fx);\n-                let oflow_ptr = oflow.to_ptr().get_addr(fx);\n-                let res = fx.lib_call_unadjusted(\n-                    \"__muloti4\",\n-                    vec![\n-                        AbiParam::new(types::I128),\n-                        AbiParam::new(types::I128),\n-                        AbiParam::new(fx.pointer_type),\n-                    ],\n-                    vec![AbiParam::new(types::I128)],\n-                    &[lhs, rhs, oflow_ptr],\n-                )[0];\n-                let oflow = oflow.to_cvalue(fx).load_scalar(fx);\n-                let oflow = fx.bcx.ins().ireduce(types::I8, oflow);\n-                Some(CValue::by_val_pair(res, oflow, fx.layout_of(out_ty)))\n-            }\n-        }\n-        BinOp::Add | BinOp::Sub | BinOp::Mul => {\n-            assert!(checked);\n-            let out_ty = fx.tcx.mk_tup(&[lhs.layout().ty, fx.tcx.types.bool]);\n-            let out_place = CPlace::new_stack_slot(fx, fx.layout_of(out_ty));\n-            let param_types = vec![\n-                AbiParam::special(fx.pointer_type, ArgumentPurpose::StructReturn),\n-                AbiParam::new(types::I128),\n-                AbiParam::new(types::I128),\n-            ];\n-            let args = [out_place.to_ptr().get_addr(fx), lhs.load_scalar(fx), rhs.load_scalar(fx)];\n-            let name = match (bin_op, is_signed) {\n-                (BinOp::Add, false) => \"__rust_u128_addo\",\n-                (BinOp::Add, true) => \"__rust_i128_addo\",\n-                (BinOp::Sub, false) => \"__rust_u128_subo\",\n-                (BinOp::Sub, true) => \"__rust_i128_subo\",\n-                (BinOp::Mul, false) => \"__rust_u128_mulo\",\n-                _ => unreachable!(),\n-            };\n-            fx.lib_call(name, param_types, vec![], &args);\n-            Some(out_place.to_cvalue(fx))\n+        BinOp::BitAnd | BinOp::BitOr | BinOp::BitXor => None,\n+        BinOp::Add | BinOp::Sub => None,\n+        BinOp::Mul => {\n+            let args = [lhs.load_scalar(fx), rhs.load_scalar(fx)];\n+            let ret_val = fx.lib_call(\n+                \"__multi3\",\n+                vec![AbiParam::new(types::I128), AbiParam::new(types::I128)],\n+                vec![AbiParam::new(types::I128)],\n+                &args,\n+            )[0];\n+            Some(CValue::by_val(\n+                ret_val,\n+                fx.layout_of(if is_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 }),\n+            ))\n         }\n         BinOp::Offset => unreachable!(\"offset should only be used on pointers, not 128bit ints\"),\n         BinOp::Div | BinOp::Rem => {\n-            assert!(!checked);\n             let name = match (bin_op, is_signed) {\n                 (BinOp::Div, false) => \"__udivti3\",\n                 (BinOp::Div, true) => \"__divti3\",\n@@ -115,10 +68,72 @@ pub(crate) fn maybe_codegen<'tcx>(\n                 Some(CValue::by_val(ret_val, lhs.layout()))\n             }\n         }\n-        BinOp::Lt | BinOp::Le | BinOp::Eq | BinOp::Ge | BinOp::Gt | BinOp::Ne => {\n-            assert!(!checked);\n-            None\n-        }\n+        BinOp::Lt | BinOp::Le | BinOp::Eq | BinOp::Ge | BinOp::Gt | BinOp::Ne => None,\n         BinOp::Shl | BinOp::Shr => None,\n     }\n }\n+\n+pub(crate) fn maybe_codegen_checked<'tcx>(\n+    fx: &mut FunctionCx<'_, '_, 'tcx>,\n+    bin_op: BinOp,\n+    lhs: CValue<'tcx>,\n+    rhs: CValue<'tcx>,\n+) -> Option<CValue<'tcx>> {\n+    if lhs.layout().ty != fx.tcx.types.u128\n+        && lhs.layout().ty != fx.tcx.types.i128\n+        && rhs.layout().ty != fx.tcx.types.u128\n+        && rhs.layout().ty != fx.tcx.types.i128\n+    {\n+        return None;\n+    }\n+\n+    let is_signed = type_sign(lhs.layout().ty);\n+\n+    match bin_op {\n+        BinOp::BitAnd | BinOp::BitOr | BinOp::BitXor => unreachable!(),\n+        BinOp::Mul if is_signed => {\n+            let out_ty = fx.tcx.mk_tup(&[lhs.layout().ty, fx.tcx.types.bool]);\n+            let oflow = CPlace::new_stack_slot(fx, fx.layout_of(fx.tcx.types.i32));\n+            let lhs = lhs.load_scalar(fx);\n+            let rhs = rhs.load_scalar(fx);\n+            let oflow_ptr = oflow.to_ptr().get_addr(fx);\n+            let res = fx.lib_call_unadjusted(\n+                \"__muloti4\",\n+                vec![\n+                    AbiParam::new(types::I128),\n+                    AbiParam::new(types::I128),\n+                    AbiParam::new(fx.pointer_type),\n+                ],\n+                vec![AbiParam::new(types::I128)],\n+                &[lhs, rhs, oflow_ptr],\n+            )[0];\n+            let oflow = oflow.to_cvalue(fx).load_scalar(fx);\n+            let oflow = fx.bcx.ins().ireduce(types::I8, oflow);\n+            Some(CValue::by_val_pair(res, oflow, fx.layout_of(out_ty)))\n+        }\n+        BinOp::Add | BinOp::Sub | BinOp::Mul => {\n+            let out_ty = fx.tcx.mk_tup(&[lhs.layout().ty, fx.tcx.types.bool]);\n+            let out_place = CPlace::new_stack_slot(fx, fx.layout_of(out_ty));\n+            let param_types = vec![\n+                AbiParam::special(fx.pointer_type, ArgumentPurpose::StructReturn),\n+                AbiParam::new(types::I128),\n+                AbiParam::new(types::I128),\n+            ];\n+            let args = [out_place.to_ptr().get_addr(fx), lhs.load_scalar(fx), rhs.load_scalar(fx)];\n+            let name = match (bin_op, is_signed) {\n+                (BinOp::Add, false) => \"__rust_u128_addo\",\n+                (BinOp::Add, true) => \"__rust_i128_addo\",\n+                (BinOp::Sub, false) => \"__rust_u128_subo\",\n+                (BinOp::Sub, true) => \"__rust_i128_subo\",\n+                (BinOp::Mul, false) => \"__rust_u128_mulo\",\n+                _ => unreachable!(),\n+            };\n+            fx.lib_call(name, param_types, vec![], &args);\n+            Some(out_place.to_cvalue(fx))\n+        }\n+        BinOp::Offset => unreachable!(\"offset should only be used on pointers, not 128bit ints\"),\n+        BinOp::Div | BinOp::Rem => unreachable!(),\n+        BinOp::Lt | BinOp::Le | BinOp::Eq | BinOp::Ge | BinOp::Gt | BinOp::Ne => unreachable!(),\n+        BinOp::Shl | BinOp::Shr => unreachable!(),\n+    }\n+}"}, {"sha": "ba53e01c7a2123919dc3d30a4c14f81d220c3486", "filename": "src/num.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e5647908d1c0eb296d1b3bab12afaad12cca64d1/src%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5647908d1c0eb296d1b3bab12afaad12cca64d1/src%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnum.rs?ref=e5647908d1c0eb296d1b3bab12afaad12cca64d1", "patch": "@@ -118,7 +118,7 @@ pub(crate) fn codegen_int_binop<'tcx>(\n         );\n     }\n \n-    if let Some(res) = crate::codegen_i128::maybe_codegen(fx, bin_op, false, in_lhs, in_rhs) {\n+    if let Some(res) = crate::codegen_i128::maybe_codegen(fx, bin_op, in_lhs, in_rhs) {\n         return res;\n     }\n \n@@ -173,7 +173,7 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n     let lhs = in_lhs.load_scalar(fx);\n     let rhs = in_rhs.load_scalar(fx);\n \n-    if let Some(res) = crate::codegen_i128::maybe_codegen(fx, bin_op, true, in_lhs, in_rhs) {\n+    if let Some(res) = crate::codegen_i128::maybe_codegen_checked(fx, bin_op, in_lhs, in_rhs) {\n         return res;\n     }\n "}]}