{"sha": "9259b022f8ec05072993fd5e3e9f2eba3afc0c95", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyNTliMDIyZjhlYzA1MDcyOTkzZmQ1ZTNlOWYyZWJhM2FmYzBjOTU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-09-07T17:00:54Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-09-14T00:39:35Z"}, "message": "syntax: fold: use move semantics for efficient folding.", "tree": {"sha": "064e9af18cd39639574f22930c38f2a156a3f8be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/064e9af18cd39639574f22930c38f2a156a3f8be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9259b022f8ec05072993fd5e3e9f2eba3afc0c95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9259b022f8ec05072993fd5e3e9f2eba3afc0c95", "html_url": "https://github.com/rust-lang/rust/commit/9259b022f8ec05072993fd5e3e9f2eba3afc0c95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9259b022f8ec05072993fd5e3e9f2eba3afc0c95/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cccb6f84a317d1f7d516e6bb2c898c946629ab1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/cccb6f84a317d1f7d516e6bb2c898c946629ab1f", "html_url": "https://github.com/rust-lang/rust/commit/cccb6f84a317d1f7d516e6bb2c898c946629ab1f"}], "stats": {"total": 1413, "additions": 691, "deletions": 722}, "files": [{"sha": "8e32191f22adb1e0433e6b3d4243a96cda8400af", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 677, "deletions": 721, "changes": 1398, "blob_url": "https://github.com/rust-lang/rust/blob/9259b022f8ec05072993fd5e3e9f2eba3afc0c95/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9259b022f8ec05072993fd5e3e9f2eba3afc0c95/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=9259b022f8ec05072993fd5e3e9f2eba3afc0c95", "patch": "@@ -23,11 +23,28 @@ use ast;\n use ast_util;\n use codemap::{respan, Span, Spanned};\n use parse::token;\n+use ptr::P;\n use owned_slice::OwnedSlice;\n use util::small_vector::SmallVector;\n \n use std::rc::Rc;\n-use std::gc::{Gc, GC};\n+\n+// This could have a better place to live.\n+pub trait MoveMap<T> {\n+    fn move_map(self, f: |T| -> T) -> Self;\n+}\n+\n+impl<T> MoveMap<T> for Vec<T> {\n+    fn move_map(self, f: |T| -> T) -> Vec<T> {\n+        self.move_iter().map(f).collect()\n+    }\n+}\n+\n+impl<T> MoveMap<T> for OwnedSlice<T> {\n+    fn move_map(self, f: |T| -> T) -> OwnedSlice<T> {\n+        OwnedSlice::from_vec(self.into_vec().move_map(f))\n+    }\n+}\n \n pub trait Folder {\n     // Any additions to this trait should happen in form\n@@ -42,91 +59,91 @@ pub trait Folder {\n         noop_fold_crate(c, self)\n     }\n \n-    fn fold_meta_items(&mut self, meta_items: &[Gc<MetaItem>]) -> Vec<Gc<MetaItem>> {\n+    fn fold_meta_items(&mut self, meta_items: Vec<P<MetaItem>>) -> Vec<P<MetaItem>> {\n         noop_fold_meta_items(meta_items, self)\n     }\n \n-    fn fold_meta_item(&mut self, meta_item: &MetaItem) -> MetaItem {\n+    fn fold_meta_item(&mut self, meta_item: P<MetaItem>) -> P<MetaItem> {\n         noop_fold_meta_item(meta_item, self)\n     }\n \n-    fn fold_view_path(&mut self, view_path: Gc<ViewPath>) -> Gc<ViewPath> {\n+    fn fold_view_path(&mut self, view_path: P<ViewPath>) -> P<ViewPath> {\n         noop_fold_view_path(view_path, self)\n     }\n \n-    fn fold_view_item(&mut self, vi: &ViewItem) -> ViewItem {\n+    fn fold_view_item(&mut self, vi: ViewItem) -> ViewItem {\n         noop_fold_view_item(vi, self)\n     }\n \n-    fn fold_foreign_item(&mut self, ni: Gc<ForeignItem>) -> Gc<ForeignItem> {\n-        noop_fold_foreign_item(&*ni, self)\n+    fn fold_foreign_item(&mut self, ni: P<ForeignItem>) -> P<ForeignItem> {\n+        noop_fold_foreign_item(ni, self)\n     }\n \n-    fn fold_item(&mut self, i: Gc<Item>) -> SmallVector<Gc<Item>> {\n-        noop_fold_item(&*i, self)\n+    fn fold_item(&mut self, i: P<Item>) -> SmallVector<P<Item>> {\n+        noop_fold_item(i, self)\n     }\n \n-    fn fold_item_simple(&mut self, i: &Item) -> Item {\n+    fn fold_item_simple(&mut self, i: Item) -> Item {\n         noop_fold_item_simple(i, self)\n     }\n \n-    fn fold_struct_field(&mut self, sf: &StructField) -> StructField {\n+    fn fold_struct_field(&mut self, sf: StructField) -> StructField {\n         noop_fold_struct_field(sf, self)\n     }\n \n-    fn fold_item_underscore(&mut self, i: &Item_) -> Item_ {\n+    fn fold_item_underscore(&mut self, i: Item_) -> Item_ {\n         noop_fold_item_underscore(i, self)\n     }\n \n-    fn fold_fn_decl(&mut self, d: &FnDecl) -> P<FnDecl> {\n+    fn fold_fn_decl(&mut self, d: P<FnDecl>) -> P<FnDecl> {\n         noop_fold_fn_decl(d, self)\n     }\n \n-    fn fold_type_method(&mut self, m: &TypeMethod) -> TypeMethod {\n+    fn fold_type_method(&mut self, m: TypeMethod) -> TypeMethod {\n         noop_fold_type_method(m, self)\n     }\n \n-    fn fold_method(&mut self, m: Gc<Method>) -> SmallVector<Gc<Method>>  {\n-        noop_fold_method(&*m, self)\n+    fn fold_method(&mut self, m: P<Method>) -> SmallVector<P<Method>> {\n+        noop_fold_method(m, self)\n     }\n \n     fn fold_block(&mut self, b: P<Block>) -> P<Block> {\n         noop_fold_block(b, self)\n     }\n \n-    fn fold_stmt(&mut self, s: &Stmt) -> SmallVector<Gc<Stmt>> {\n-        noop_fold_stmt(s, self)\n+    fn fold_stmt(&mut self, s: P<Stmt>) -> SmallVector<P<Stmt>> {\n+        s.and_then(|s| noop_fold_stmt(s, self))\n     }\n \n-    fn fold_arm(&mut self, a: &Arm) -> Arm {\n+    fn fold_arm(&mut self, a: Arm) -> Arm {\n         noop_fold_arm(a, self)\n     }\n \n-    fn fold_pat(&mut self, p: Gc<Pat>) -> Gc<Pat> {\n+    fn fold_pat(&mut self, p: P<Pat>) -> P<Pat> {\n         noop_fold_pat(p, self)\n     }\n \n-    fn fold_decl(&mut self, d: Gc<Decl>) -> SmallVector<Gc<Decl>> {\n+    fn fold_decl(&mut self, d: P<Decl>) -> SmallVector<P<Decl>> {\n         noop_fold_decl(d, self)\n     }\n \n-    fn fold_expr(&mut self, e: Gc<Expr>) -> Gc<Expr> {\n-        noop_fold_expr(e, self)\n+    fn fold_expr(&mut self, e: P<Expr>) -> P<Expr> {\n+        e.map(|e| noop_fold_expr(e, self))\n     }\n \n     fn fold_ty(&mut self, t: P<Ty>) -> P<Ty> {\n         noop_fold_ty(t, self)\n     }\n \n-    fn fold_mod(&mut self, m: &Mod) -> Mod {\n+    fn fold_mod(&mut self, m: Mod) -> Mod {\n         noop_fold_mod(m, self)\n     }\n \n-    fn fold_foreign_mod(&mut self, nm: &ForeignMod) -> ForeignMod {\n+    fn fold_foreign_mod(&mut self, nm: ForeignMod) -> ForeignMod {\n         noop_fold_foreign_mod(nm, self)\n     }\n \n-    fn fold_variant(&mut self, v: &Variant) -> P<Variant> {\n+    fn fold_variant(&mut self, v: P<Variant>) -> P<Variant> {\n         noop_fold_variant(v, self)\n     }\n \n@@ -138,15 +155,15 @@ pub trait Folder {\n         noop_fold_uint(i, self)\n     }\n \n-    fn fold_path(&mut self, p: &Path) -> Path {\n+    fn fold_path(&mut self, p: Path) -> Path {\n         noop_fold_path(p, self)\n     }\n \n-    fn fold_local(&mut self, l: Gc<Local>) -> Gc<Local> {\n+    fn fold_local(&mut self, l: P<Local>) -> P<Local> {\n         noop_fold_local(l, self)\n     }\n \n-    fn fold_mac(&mut self, _macro: &Mac) -> Mac {\n+    fn fold_mac(&mut self, _macro: Mac) -> Mac {\n         fail!(\"fold_mac disabled by default\");\n         // NB: see note about macros above.\n         // if you really want a folder that\n@@ -155,55 +172,55 @@ pub trait Folder {\n         // fold::noop_fold_mac(_macro, self)\n     }\n \n-    fn fold_explicit_self(&mut self, es: &ExplicitSelf) -> ExplicitSelf {\n+    fn fold_explicit_self(&mut self, es: ExplicitSelf) -> ExplicitSelf {\n         noop_fold_explicit_self(es, self)\n     }\n \n-    fn fold_explicit_self_underscore(&mut self, es: &ExplicitSelf_) -> ExplicitSelf_ {\n+    fn fold_explicit_self_underscore(&mut self, es: ExplicitSelf_) -> ExplicitSelf_ {\n         noop_fold_explicit_self_underscore(es, self)\n     }\n \n-    fn fold_lifetime(&mut self, l: &Lifetime) -> Lifetime {\n+    fn fold_lifetime(&mut self, l: Lifetime) -> Lifetime {\n         noop_fold_lifetime(l, self)\n     }\n \n-    fn fold_lifetime_def(&mut self, l: &LifetimeDef) -> LifetimeDef {\n+    fn fold_lifetime_def(&mut self, l: LifetimeDef) -> LifetimeDef {\n         noop_fold_lifetime_def(l, self)\n     }\n \n     fn fold_attribute(&mut self, at: Attribute) -> Attribute {\n         noop_fold_attribute(at, self)\n     }\n \n-    fn fold_arg(&mut self, a: &Arg) -> Arg {\n+    fn fold_arg(&mut self, a: Arg) -> Arg {\n         noop_fold_arg(a, self)\n     }\n \n-    fn fold_generics(&mut self, generics: &Generics) -> Generics {\n+    fn fold_generics(&mut self, generics: Generics) -> Generics {\n         noop_fold_generics(generics, self)\n     }\n \n-    fn fold_trait_ref(&mut self, p: &TraitRef) -> TraitRef {\n+    fn fold_trait_ref(&mut self, p: TraitRef) -> TraitRef {\n         noop_fold_trait_ref(p, self)\n     }\n \n-    fn fold_struct_def(&mut self, struct_def: Gc<StructDef>) -> Gc<StructDef> {\n+    fn fold_struct_def(&mut self, struct_def: P<StructDef>) -> P<StructDef> {\n         noop_fold_struct_def(struct_def, self)\n     }\n \n-    fn fold_lifetimes(&mut self, lts: &[Lifetime]) -> Vec<Lifetime> {\n+    fn fold_lifetimes(&mut self, lts: Vec<Lifetime>) -> Vec<Lifetime> {\n         noop_fold_lifetimes(lts, self)\n     }\n \n-    fn fold_lifetime_defs(&mut self, lts: &[LifetimeDef]) -> Vec<LifetimeDef> {\n+    fn fold_lifetime_defs(&mut self, lts: Vec<LifetimeDef>) -> Vec<LifetimeDef> {\n         noop_fold_lifetime_defs(lts, self)\n     }\n \n-    fn fold_ty_param(&mut self, tp: &TyParam) -> TyParam {\n+    fn fold_ty_param(&mut self, tp: TyParam) -> TyParam {\n         noop_fold_ty_param(tp, self)\n     }\n \n-    fn fold_ty_params(&mut self, tps: &[TyParam]) -> OwnedSlice<TyParam> {\n+    fn fold_ty_params(&mut self, tps: OwnedSlice<TyParam>) -> OwnedSlice<TyParam> {\n         noop_fold_ty_params(tps, self)\n     }\n \n@@ -215,61 +232,54 @@ pub trait Folder {\n         noop_fold_tts(tts, self)\n     }\n \n-    fn fold_token(&mut self, t: &token::Token) -> token::Token {\n+    fn fold_token(&mut self, t: token::Token) -> token::Token {\n         noop_fold_token(t, self)\n     }\n \n-    fn fold_interpolated(&mut self, nt : &token::Nonterminal) -> token::Nonterminal {\n+    fn fold_interpolated(&mut self, nt: token::Nonterminal) -> token::Nonterminal {\n         noop_fold_interpolated(nt, self)\n     }\n \n-    fn fold_opt_lifetime(&mut self, o_lt: &Option<Lifetime>) -> Option<Lifetime> {\n+    fn fold_opt_lifetime(&mut self, o_lt: Option<Lifetime>) -> Option<Lifetime> {\n         noop_fold_opt_lifetime(o_lt, self)\n     }\n \n-    fn fold_variant_arg(&mut self, va: &VariantArg) -> VariantArg {\n+    fn fold_variant_arg(&mut self, va: VariantArg) -> VariantArg {\n         noop_fold_variant_arg(va, self)\n     }\n \n-    fn fold_opt_bounds(&mut self, b: &Option<OwnedSlice<TyParamBound>>)\n+    fn fold_opt_bounds(&mut self, b: Option<OwnedSlice<TyParamBound>>)\n                        -> Option<OwnedSlice<TyParamBound>> {\n         noop_fold_opt_bounds(b, self)\n     }\n \n-    fn fold_bounds(&mut self, b: &OwnedSlice<TyParamBound>)\n+    fn fold_bounds(&mut self, b: OwnedSlice<TyParamBound>)\n                        -> OwnedSlice<TyParamBound> {\n         noop_fold_bounds(b, self)\n     }\n \n-    fn fold_ty_param_bound(&mut self, tpb: &TyParamBound) -> TyParamBound {\n+    fn fold_ty_param_bound(&mut self, tpb: TyParamBound) -> TyParamBound {\n         noop_fold_ty_param_bound(tpb, self)\n     }\n \n-    fn fold_mt(&mut self, mt: &MutTy) -> MutTy {\n+    fn fold_mt(&mut self, mt: MutTy) -> MutTy {\n         noop_fold_mt(mt, self)\n     }\n \n     fn fold_field(&mut self, field: Field) -> Field {\n         noop_fold_field(field, self)\n     }\n \n-    fn fold_where_clause(&mut self, where_clause: &WhereClause)\n+    fn fold_where_clause(&mut self, where_clause: WhereClause)\n                          -> WhereClause {\n         noop_fold_where_clause(where_clause, self)\n     }\n \n-    fn fold_where_predicate(&mut self, where_predicate: &WherePredicate)\n+    fn fold_where_predicate(&mut self, where_predicate: WherePredicate)\n                             -> WherePredicate {\n         noop_fold_where_predicate(where_predicate, self)\n     }\n \n-// Helper methods:\n-\n-    fn map_exprs(&self, f: |Gc<Expr>| -> Gc<Expr>,\n-                 es: &[Gc<Expr>]) -> Vec<Gc<Expr>> {\n-        es.iter().map(|x| f(*x)).collect()\n-    }\n-\n     fn new_id(&mut self, i: NodeId) -> NodeId {\n         i\n     }\n@@ -279,190 +289,161 @@ pub trait Folder {\n     }\n }\n \n-pub fn noop_fold_meta_items<T: Folder>(meta_items: &[Gc<MetaItem>], fld: &mut T)\n-                                       -> Vec<Gc<MetaItem>> {\n-    meta_items.iter().map(|x| box (GC) fld.fold_meta_item(&**x)).collect()\n+pub fn noop_fold_meta_items<T: Folder>(meta_items: Vec<P<MetaItem>>, fld: &mut T)\n+                                       -> Vec<P<MetaItem>> {\n+    meta_items.move_map(|x| fld.fold_meta_item(x))\n }\n \n-pub fn noop_fold_view_path<T: Folder>(view_path: Gc<ViewPath>, fld: &mut T) -> Gc<ViewPath> {\n-    let inner_view_path = match view_path.node {\n-        ViewPathSimple(ref ident, ref path, node_id) => {\n-            let id = fld.new_id(node_id);\n-            ViewPathSimple(ident.clone(),\n-                        fld.fold_path(path),\n-                        id)\n-        }\n-        ViewPathGlob(ref path, node_id) => {\n-            let id = fld.new_id(node_id);\n-            ViewPathGlob(fld.fold_path(path), id)\n-        }\n-        ViewPathList(ref path, ref path_list_idents, node_id) => {\n-            let id = fld.new_id(node_id);\n-            ViewPathList(fld.fold_path(path),\n-                        path_list_idents.iter().map(|path_list_ident| {\n-                            Spanned {\n-                                node: match path_list_ident.node {\n-                                    PathListIdent { id, name } =>\n-                                        PathListIdent {\n-                                            id: fld.new_id(id),\n-                                            name: name.clone()\n-                                        },\n-                                    PathListMod { id } =>\n-                                        PathListMod { id: fld.new_id(id) }\n-                                },\n-                                span: fld.new_span(path_list_ident.span)\n-                            }\n-                        }).collect(),\n-                        id)\n-        }\n-    };\n-    box(GC) Spanned {\n-        node: inner_view_path,\n-        span: fld.new_span(view_path.span),\n-    }\n+pub fn noop_fold_view_path<T: Folder>(view_path: P<ViewPath>, fld: &mut T) -> P<ViewPath> {\n+    view_path.map(|Spanned {node, span}| Spanned {\n+        node: match node {\n+            ViewPathSimple(ident, path, node_id) => {\n+                let id = fld.new_id(node_id);\n+                ViewPathSimple(ident, fld.fold_path(path), id)\n+            }\n+            ViewPathGlob(path, node_id) => {\n+                let id = fld.new_id(node_id);\n+                ViewPathGlob(fld.fold_path(path), id)\n+            }\n+            ViewPathList(path, path_list_idents, node_id) => {\n+                let id = fld.new_id(node_id);\n+                ViewPathList(fld.fold_path(path),\n+                             path_list_idents.move_map(|path_list_ident| {\n+                                Spanned {\n+                                    node: match path_list_ident.node {\n+                                        PathListIdent { id, name } =>\n+                                            PathListIdent {\n+                                                id: fld.new_id(id),\n+                                                name: name\n+                                            },\n+                                        PathListMod { id } =>\n+                                            PathListMod { id: fld.new_id(id) }\n+                                    },\n+                                    span: fld.new_span(path_list_ident.span)\n+                                }\n+                             }),\n+                             id)\n+            }\n+        },\n+        span: fld.new_span(span)\n+    })\n }\n \n-pub fn noop_fold_arm<T: Folder>(a: &Arm, fld: &mut T) -> Arm {\n+pub fn noop_fold_arm<T: Folder>(Arm {attrs, pats, guard, body}: Arm, fld: &mut T) -> Arm {\n     Arm {\n-        attrs: a.attrs.iter().map(|x| fld.fold_attribute(*x)).collect(),\n-        pats: a.pats.iter().map(|x| fld.fold_pat(*x)).collect(),\n-        guard: a.guard.map(|x| fld.fold_expr(x)),\n-        body: fld.fold_expr(a.body),\n+        attrs: attrs.move_map(|x| fld.fold_attribute(x)),\n+        pats: pats.move_map(|x| fld.fold_pat(x)),\n+        guard: guard.map(|x| fld.fold_expr(x)),\n+        body: fld.fold_expr(body),\n     }\n }\n \n-pub fn noop_fold_decl<T: Folder>(d: Gc<Decl>, fld: &mut T) -> SmallVector<Gc<Decl>> {\n-    let node = match d.node {\n-        DeclLocal(ref l) => SmallVector::one(DeclLocal(fld.fold_local(*l))),\n-        DeclItem(it) => {\n-            fld.fold_item(it).move_iter().map(|i| DeclItem(i)).collect()\n-        }\n-    };\n-\n-    node.move_iter().map(|node| {\n-        box(GC) Spanned {\n-            node: node,\n-            span: fld.new_span(d.span),\n-        }\n-    }).collect()\n+pub fn noop_fold_decl<T: Folder>(d: P<Decl>, fld: &mut T) -> SmallVector<P<Decl>> {\n+    d.and_then(|Spanned {node, span}| match node {\n+        DeclLocal(l) => SmallVector::one(P(Spanned {\n+            node: DeclLocal(fld.fold_local(l)),\n+            span: fld.new_span(span)\n+        })),\n+        DeclItem(it) => fld.fold_item(it).move_iter().map(|i| P(Spanned {\n+            node: DeclItem(i),\n+            span: fld.new_span(span)\n+        })).collect()\n+    })\n }\n \n pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n-    let id = fld.new_id(t.id);\n-    let node = match t.node {\n-        TyNil | TyBot | TyInfer => t.node.clone(),\n-        TyBox(ty) => TyBox(fld.fold_ty(ty)),\n-        TyUniq(ty) => TyUniq(fld.fold_ty(ty)),\n-        TyVec(ty) => TyVec(fld.fold_ty(ty)),\n-        TyPtr(ref mt) => TyPtr(fld.fold_mt(mt)),\n-        TyRptr(ref region, ref mt) => {\n-            TyRptr(fld.fold_opt_lifetime(region), fld.fold_mt(mt))\n-        }\n-        TyClosure(ref f) => {\n-            TyClosure(box(GC) ClosureTy {\n-                fn_style: f.fn_style,\n-                onceness: f.onceness,\n-                bounds: fld.fold_bounds(&f.bounds),\n-                decl: fld.fold_fn_decl(&*f.decl),\n-                lifetimes: fld.fold_lifetime_defs(f.lifetimes.as_slice()),\n-            })\n-        }\n-        TyProc(ref f) => {\n-            TyProc(box(GC) ClosureTy {\n-                fn_style: f.fn_style,\n-                onceness: f.onceness,\n-                bounds: fld.fold_bounds(&f.bounds),\n-                decl: fld.fold_fn_decl(&*f.decl),\n-                lifetimes: fld.fold_lifetime_defs(f.lifetimes.as_slice()),\n-            })\n-        }\n-        TyBareFn(ref f) => {\n-            TyBareFn(box(GC) BareFnTy {\n-                lifetimes: fld.fold_lifetime_defs(f.lifetimes.as_slice()),\n-                fn_style: f.fn_style,\n-                abi: f.abi,\n-                decl: fld.fold_fn_decl(&*f.decl)\n-            })\n-        }\n-        TyUnboxedFn(ref f) => {\n-            TyUnboxedFn(box(GC) UnboxedFnTy {\n-                decl: fld.fold_fn_decl(&*f.decl),\n-                kind: f.kind,\n-            })\n-        }\n-        TyTup(ref tys) => TyTup(tys.iter().map(|&ty| fld.fold_ty(ty)).collect()),\n-        TyParen(ref ty) => TyParen(fld.fold_ty(*ty)),\n-        TyPath(ref path, ref bounds, id) => {\n-            let id = fld.new_id(id);\n-            TyPath(fld.fold_path(path),\n-                    fld.fold_opt_bounds(bounds),\n-                    id)\n-        }\n-        TyFixedLengthVec(ty, e) => {\n-            TyFixedLengthVec(fld.fold_ty(ty), fld.fold_expr(e))\n-        }\n-        TyTypeof(expr) => TyTypeof(fld.fold_expr(expr)),\n-    };\n-    P(Ty {\n-        id: id,\n-        span: fld.new_span(t.span),\n-        node: node,\n+    t.map(|Ty {id, node, span}| Ty {\n+        id: fld.new_id(id),\n+        node: match node {\n+            TyNil | TyBot | TyInfer => node,\n+            TyBox(ty) => TyBox(fld.fold_ty(ty)),\n+            TyUniq(ty) => TyUniq(fld.fold_ty(ty)),\n+            TyVec(ty) => TyVec(fld.fold_ty(ty)),\n+            TyPtr(mt) => TyPtr(fld.fold_mt(mt)),\n+            TyRptr(region, mt) => {\n+                TyRptr(fld.fold_opt_lifetime(region), fld.fold_mt(mt))\n+            }\n+            TyClosure(f) => {\n+                TyClosure(f.map(|ClosureTy {fn_style, onceness, bounds, decl, lifetimes}| {\n+                    ClosureTy {\n+                        fn_style: fn_style,\n+                        onceness: onceness,\n+                        bounds: fld.fold_bounds(bounds),\n+                        decl: fld.fold_fn_decl(decl),\n+                        lifetimes: fld.fold_lifetime_defs(lifetimes)\n+                    }\n+                }))\n+            }\n+            TyProc(f) => {\n+                TyProc(f.map(|ClosureTy {fn_style, onceness, bounds, decl, lifetimes}| {\n+                    ClosureTy {\n+                        fn_style: fn_style,\n+                        onceness: onceness,\n+                        bounds: fld.fold_bounds(bounds),\n+                        decl: fld.fold_fn_decl(decl),\n+                        lifetimes: fld.fold_lifetime_defs(lifetimes)\n+                    }\n+                }))\n+            }\n+            TyBareFn(f) => {\n+                TyBareFn(f.map(|BareFnTy {lifetimes, fn_style, abi, decl}| BareFnTy {\n+                    lifetimes: fld.fold_lifetime_defs(lifetimes),\n+                    fn_style: fn_style,\n+                    abi: abi,\n+                    decl: fld.fold_fn_decl(decl)\n+                }))\n+            }\n+            TyUnboxedFn(f) => {\n+                TyUnboxedFn(f.map(|UnboxedFnTy {decl, kind}| UnboxedFnTy {\n+                    decl: fld.fold_fn_decl(decl),\n+                    kind: kind,\n+                }))\n+            }\n+            TyTup(tys) => TyTup(tys.move_map(|ty| fld.fold_ty(ty))),\n+            TyParen(ty) => TyParen(fld.fold_ty(ty)),\n+            TyPath(path, bounds, id) => {\n+                let id = fld.new_id(id);\n+                TyPath(fld.fold_path(path),\n+                        fld.fold_opt_bounds(bounds),\n+                        id)\n+            }\n+            TyFixedLengthVec(ty, e) => {\n+                TyFixedLengthVec(fld.fold_ty(ty), fld.fold_expr(e))\n+            }\n+            TyTypeof(expr) => TyTypeof(fld.fold_expr(expr))\n+        },\n+        span: fld.new_span(span)\n     })\n }\n \n-pub fn noop_fold_foreign_mod<T: Folder>(nm: &ForeignMod, fld: &mut T) -> ForeignMod {\n-    ast::ForeignMod {\n-        abi: nm.abi,\n-        view_items: nm.view_items\n-                        .iter()\n-                        .map(|x| fld.fold_view_item(x))\n-                        .collect(),\n-        items: nm.items\n-                    .iter()\n-                    .map(|x| fld.fold_foreign_item(*x))\n-                    .collect(),\n+pub fn noop_fold_foreign_mod<T: Folder>(ForeignMod {abi, view_items, items}: ForeignMod,\n+                                        fld: &mut T) -> ForeignMod {\n+    ForeignMod {\n+        abi: abi,\n+        view_items: view_items.move_map(|x| fld.fold_view_item(x)),\n+        items: items.move_map(|x| fld.fold_foreign_item(x)),\n     }\n }\n \n-pub fn noop_fold_variant<T: Folder>(v: &Variant, fld: &mut T) -> P<Variant> {\n-    let id = fld.new_id(v.node.id);\n-    let kind;\n-    match v.node.kind {\n-        TupleVariantKind(ref variant_args) => {\n-            kind = TupleVariantKind(variant_args.iter().map(|x|\n-                fld.fold_variant_arg(x)).collect())\n-        }\n-        StructVariantKind(ref struct_def) => {\n-            kind = StructVariantKind(box(GC) ast::StructDef {\n-                fields: struct_def.fields.iter()\n-                    .map(|f| fld.fold_struct_field(f)).collect(),\n-                ctor_id: struct_def.ctor_id.map(|c| fld.new_id(c)),\n-                super_struct: match struct_def.super_struct {\n-                    Some(t) => Some(fld.fold_ty(t)),\n-                    None => None\n-                },\n-                is_virtual: struct_def.is_virtual,\n-            })\n-        }\n-    }\n-\n-    let attrs = v.node.attrs.iter().map(|x| fld.fold_attribute(*x)).collect();\n-\n-    let de = match v.node.disr_expr {\n-        Some(e) => Some(fld.fold_expr(e)),\n-        None => None\n-    };\n-    let node = ast::Variant_ {\n-        name: v.node.name,\n-        attrs: attrs,\n-        kind: kind,\n-        id: id,\n-        disr_expr: de,\n-        vis: v.node.vis,\n-    };\n-    P(Spanned {\n-        node: node,\n-        span: fld.new_span(v.span),\n+pub fn noop_fold_variant<T: Folder>(v: P<Variant>, fld: &mut T) -> P<Variant> {\n+    v.map(|Spanned {node: Variant_ {id, name, attrs, kind, disr_expr, vis}, span}| Spanned {\n+        node: Variant_ {\n+            id: fld.new_id(id),\n+            name: name,\n+            attrs: attrs.move_map(|x| fld.fold_attribute(x)),\n+            kind: match kind {\n+                TupleVariantKind(variant_args) => {\n+                    TupleVariantKind(variant_args.move_map(|x|\n+                        fld.fold_variant_arg(x)))\n+                }\n+                StructVariantKind(struct_def) => {\n+                    StructVariantKind(fld.fold_struct_def(struct_def))\n+                }\n+            },\n+            disr_expr: disr_expr.map(|e| fld.fold_expr(e)),\n+            vis: vis,\n+        },\n+        span: fld.new_span(span),\n     })\n }\n \n@@ -474,109 +455,103 @@ pub fn noop_fold_uint<T: Folder>(i: uint, _: &mut T) -> uint {\n     i\n }\n \n-pub fn noop_fold_path<T: Folder>(p: &Path, fld: &mut T) -> Path {\n-    ast::Path {\n-        span: fld.new_span(p.span),\n-        global: p.global,\n-        segments: p.segments.iter().map(|segment| ast::PathSegment {\n-            identifier: fld.fold_ident(segment.identifier),\n-            lifetimes: segment.lifetimes.iter().map(|l| fld.fold_lifetime(l)).collect(),\n-            types: segment.types.iter().map(|&typ| fld.fold_ty(typ)).collect(),\n-        }).collect()\n+pub fn noop_fold_path<T: Folder>(Path {global, segments, span}: Path, fld: &mut T) -> Path {\n+    Path {\n+        global: global,\n+        segments: segments.move_map(|PathSegment {identifier, lifetimes, types}| PathSegment {\n+            identifier: fld.fold_ident(identifier),\n+            lifetimes: fld.fold_lifetimes(lifetimes),\n+            types: types.move_map(|typ| fld.fold_ty(typ)),\n+        }),\n+        span: fld.new_span(span)\n     }\n }\n \n-pub fn noop_fold_local<T: Folder>(l: Gc<Local>, fld: &mut T) -> Gc<Local> {\n-    let id = fld.new_id(l.id); // Needs to be first, for ast_map.\n-    box(GC) Local {\n-        id: id,\n-        ty: fld.fold_ty(l.ty),\n-        pat: fld.fold_pat(l.pat),\n-        init: l.init.map(|e| fld.fold_expr(e)),\n-        span: fld.new_span(l.span),\n-        source: l.source,\n-    }\n+pub fn noop_fold_local<T: Folder>(l: P<Local>, fld: &mut T) -> P<Local> {\n+    l.map(|Local {id, pat, ty, init, source, span}| Local {\n+        id: fld.new_id(id), // Needs to be first, for ast_map.\n+        ty: fld.fold_ty(ty),\n+        pat: fld.fold_pat(pat),\n+        init: init.map(|e| fld.fold_expr(e)),\n+        source: source,\n+        span: fld.new_span(span)\n+    })\n }\n \n pub fn noop_fold_attribute<T: Folder>(at: Attribute, fld: &mut T) -> Attribute {\n+    let Spanned {node: Attribute_ {id, style, value, is_sugared_doc}, span} = at;\n     Spanned {\n-        span: fld.new_span(at.span),\n-        node: ast::Attribute_ {\n-            id: at.node.id,\n-            style: at.node.style,\n-            value: box (GC) fld.fold_meta_item(&*at.node.value),\n-            is_sugared_doc: at.node.is_sugared_doc\n-        }\n+        node: Attribute_ {\n+            id: id,\n+            style: style,\n+            value: fld.fold_meta_item(value),\n+            is_sugared_doc: is_sugared_doc\n+        },\n+        span: fld.new_span(span)\n     }\n }\n \n-pub fn noop_fold_explicit_self_underscore<T: Folder>(es: &ExplicitSelf_, fld: &mut T)\n+pub fn noop_fold_explicit_self_underscore<T: Folder>(es: ExplicitSelf_, fld: &mut T)\n                                                      -> ExplicitSelf_ {\n-    match *es {\n-        SelfStatic | SelfValue(_) => *es,\n-        SelfRegion(ref lifetime, m, id) => {\n+    match es {\n+        SelfStatic | SelfValue(_) => es,\n+        SelfRegion(lifetime, m, id) => {\n             SelfRegion(fld.fold_opt_lifetime(lifetime), m, id)\n         }\n-        SelfExplicit(ref typ, id) => SelfExplicit(fld.fold_ty(*typ), id),\n+        SelfExplicit(typ, id) => SelfExplicit(fld.fold_ty(typ), id),\n     }\n }\n \n-pub fn noop_fold_explicit_self<T: Folder>(es: &ExplicitSelf, fld: &mut T) -> ExplicitSelf {\n+pub fn noop_fold_explicit_self<T: Folder>(Spanned {span, node}: ExplicitSelf, fld: &mut T)\n+                                          -> ExplicitSelf {\n     Spanned {\n-        span: fld.new_span(es.span),\n-        node: fld.fold_explicit_self_underscore(&es.node)\n+        node: fld.fold_explicit_self_underscore(node),\n+        span: fld.new_span(span)\n     }\n }\n \n \n-pub fn noop_fold_mac<T: Folder>(macro: &Mac, fld: &mut T) -> Mac {\n+pub fn noop_fold_mac<T: Folder>(Spanned {node, span}: Mac, fld: &mut T) -> Mac {\n     Spanned {\n-        node: match macro.node {\n-            MacInvocTT(ref p, ref tts, ctxt) => {\n-                MacInvocTT(fld.fold_path(p),\n-                           fld.fold_tts(tts.as_slice()),\n-                           ctxt)\n+        node: match node {\n+            MacInvocTT(p, tts, ctxt) => {\n+                MacInvocTT(fld.fold_path(p), fld.fold_tts(tts.as_slice()), ctxt)\n             }\n         },\n-        span: fld.new_span(macro.span)\n+        span: fld.new_span(span)\n     }\n }\n \n-pub fn noop_fold_meta_item<T: Folder>(mi: &MetaItem, fld: &mut T) -> MetaItem {\n-    Spanned {\n-        node:\n-            match mi.node {\n-                MetaWord(ref id) => MetaWord((*id).clone()),\n-                MetaList(ref id, ref mis) => {\n-                    MetaList((*id).clone(),\n-                             mis.iter()\n-                                .map(|e| box (GC) fld.fold_meta_item(&**e)).collect())\n-                }\n-                MetaNameValue(ref id, ref s) => {\n-                    MetaNameValue((*id).clone(), (*s).clone())\n-                }\n-            },\n-        span: fld.new_span(mi.span) }\n+pub fn noop_fold_meta_item<T: Folder>(mi: P<MetaItem>, fld: &mut T) -> P<MetaItem> {\n+    mi.map(|Spanned {node, span}| Spanned {\n+        node: match node {\n+            MetaWord(id) => MetaWord(id),\n+            MetaList(id, mis) => {\n+                MetaList(id, mis.move_map(|e| fld.fold_meta_item(e)))\n+            }\n+            MetaNameValue(id, s) => MetaNameValue(id, s)\n+        },\n+        span: fld.new_span(span)\n+    })\n }\n \n-pub fn noop_fold_arg<T: Folder>(a: &Arg, fld: &mut T) -> Arg {\n-    let id = fld.new_id(a.id); // Needs to be first, for ast_map.\n+pub fn noop_fold_arg<T: Folder>(Arg {id, pat, ty}: Arg, fld: &mut T) -> Arg {\n     Arg {\n-        id: id,\n-        ty: fld.fold_ty(a.ty),\n-        pat: fld.fold_pat(a.pat),\n+        id: fld.new_id(id), // Needs to be first, for ast_map.\n+        pat: fld.fold_pat(pat),\n+        ty: fld.fold_ty(ty)\n     }\n }\n \n pub fn noop_fold_tt<T: Folder>(tt: &TokenTree, fld: &mut T) -> TokenTree {\n     match *tt {\n         TTTok(span, ref tok) =>\n-            TTTok(span, fld.fold_token(tok)),\n+            TTTok(span, fld.fold_token(tok.clone())),\n         TTDelim(ref tts) => TTDelim(Rc::new(fld.fold_tts(tts.as_slice()))),\n         TTSeq(span, ref pattern, ref sep, is_optional) =>\n             TTSeq(span,\n                   Rc::new(fld.fold_tts(pattern.as_slice())),\n-                  sep.as_ref().map(|tok| fld.fold_token(tok)),\n+                  sep.clone().map(|tok| fld.fold_token(tok)),\n                   is_optional),\n         TTNonterminal(sp,ref ident) =>\n             TTNonterminal(sp,fld.fold_ident(*ident))\n@@ -588,14 +563,14 @@ pub fn noop_fold_tts<T: Folder>(tts: &[TokenTree], fld: &mut T) -> Vec<TokenTree\n }\n \n // apply ident folder if it's an ident, apply other folds to interpolated nodes\n-pub fn noop_fold_token<T: Folder>(t: &token::Token, fld: &mut T) -> token::Token {\n-    match *t {\n+pub fn noop_fold_token<T: Folder>(t: token::Token, fld: &mut T) -> token::Token {\n+    match t {\n         token::IDENT(id, followed_by_colons) => {\n             token::IDENT(fld.fold_ident(id), followed_by_colons)\n         }\n         token::LIFETIME(id) => token::LIFETIME(fld.fold_ident(id)),\n-        token::INTERPOLATED(ref nt) => token::INTERPOLATED(fld.fold_interpolated(nt)),\n-        _ => (*t).clone()\n+        token::INTERPOLATED(nt) => token::INTERPOLATED(fld.fold_interpolated(nt)),\n+        _ => t\n     }\n }\n \n@@ -619,9 +594,9 @@ pub fn noop_fold_token<T: Folder>(t: &token::Token, fld: &mut T) -> token::Token\n // BTW, design choice: I considered just changing the type of, e.g., NtItem to contain\n // multiple items, but decided against it when I looked at parse_item_or_view_item and\n // tried to figure out what I would do with multiple items there....\n-pub fn noop_fold_interpolated<T: Folder>(nt : &token::Nonterminal, fld: &mut T)\n+pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n                                          -> token::Nonterminal {\n-    match *nt {\n+    match nt {\n         token::NtItem(item) =>\n             token::NtItem(fld.fold_item(item)\n                           // this is probably okay, because the only folds likely\n@@ -630,411 +605,381 @@ pub fn noop_fold_interpolated<T: Folder>(nt : &token::Nonterminal, fld: &mut T)\n                           .expect_one(\"expected fold to produce exactly one item\")),\n         token::NtBlock(block) => token::NtBlock(fld.fold_block(block)),\n         token::NtStmt(stmt) =>\n-            token::NtStmt(fld.fold_stmt(&*stmt)\n+            token::NtStmt(fld.fold_stmt(stmt)\n                           // this is probably okay, because the only folds likely\n                           // to peek inside interpolated nodes will be renamings/markings,\n                           // which map single items to single items\n                           .expect_one(\"expected fold to produce exactly one statement\")),\n         token::NtPat(pat) => token::NtPat(fld.fold_pat(pat)),\n         token::NtExpr(expr) => token::NtExpr(fld.fold_expr(expr)),\n         token::NtTy(ty) => token::NtTy(fld.fold_ty(ty)),\n-        token::NtIdent(ref id, is_mod_name) =>\n-            token::NtIdent(box fld.fold_ident(**id),is_mod_name),\n-        token::NtMeta(meta_item) => token::NtMeta(box (GC) fld.fold_meta_item(&*meta_item)),\n-        token::NtPath(ref path) => token::NtPath(box fld.fold_path(&**path)),\n-        token::NtTT(tt) => token::NtTT(box (GC) fld.fold_tt(&*tt)),\n+        token::NtIdent(box id, is_mod_name) =>\n+            token::NtIdent(box fld.fold_ident(id), is_mod_name),\n+        token::NtMeta(meta_item) => token::NtMeta(fld.fold_meta_item(meta_item)),\n+        token::NtPath(box path) => token::NtPath(box fld.fold_path(path)),\n+        token::NtTT(tt) => token::NtTT(P(fld.fold_tt(&*tt))),\n         // it looks to me like we can leave out the matchers: token::NtMatchers(matchers)\n-        _ => (*nt).clone()\n+        _ => nt\n     }\n }\n \n-pub fn noop_fold_fn_decl<T: Folder>(decl: &FnDecl, fld: &mut T) -> P<FnDecl> {\n-    P(FnDecl {\n-        inputs: decl.inputs.iter().map(|x| fld.fold_arg(x)).collect(), // bad copy\n-        output: fld.fold_ty(decl.output),\n-        cf: decl.cf,\n-        variadic: decl.variadic\n+pub fn noop_fold_fn_decl<T: Folder>(decl: P<FnDecl>, fld: &mut T) -> P<FnDecl> {\n+    decl.map(|FnDecl {inputs, output, cf, variadic}| FnDecl {\n+        inputs: inputs.move_map(|x| fld.fold_arg(x)),\n+        output: fld.fold_ty(output),\n+        cf: cf,\n+        variadic: variadic\n     })\n }\n \n-pub fn noop_fold_ty_param_bound<T: Folder>(tpb: &TyParamBound, fld: &mut T)\n+pub fn noop_fold_ty_param_bound<T: Folder>(tpb: TyParamBound, fld: &mut T)\n                                            -> TyParamBound {\n-    match *tpb {\n-        TraitTyParamBound(ref ty) => TraitTyParamBound(fld.fold_trait_ref(ty)),\n-        RegionTyParamBound(ref lifetime) => RegionTyParamBound(fld.fold_lifetime(lifetime)),\n-        UnboxedFnTyParamBound(ref unboxed_function_type) => {\n+    match tpb {\n+        TraitTyParamBound(ty) => TraitTyParamBound(fld.fold_trait_ref(ty)),\n+        RegionTyParamBound(lifetime) => RegionTyParamBound(fld.fold_lifetime(lifetime)),\n+        UnboxedFnTyParamBound(UnboxedFnTy {decl, kind}) => {\n             UnboxedFnTyParamBound(UnboxedFnTy {\n-                decl: fld.fold_fn_decl(&*unboxed_function_type.decl),\n-                kind: unboxed_function_type.kind,\n+                decl: fld.fold_fn_decl(decl),\n+                kind: kind,\n             })\n         }\n     }\n }\n \n-pub fn noop_fold_ty_param<T: Folder>(tp: &TyParam, fld: &mut T) -> TyParam {\n-    let id = fld.new_id(tp.id);\n+pub fn noop_fold_ty_param<T: Folder>(tp: TyParam, fld: &mut T) -> TyParam {\n+    let TyParam {id, ident, bounds, unbound, default, span} = tp;\n     TyParam {\n-        ident: tp.ident,\n-        id: id,\n-        bounds: fld.fold_bounds(&tp.bounds),\n-        unbound: tp.unbound.as_ref().map(|x| fld.fold_ty_param_bound(x)),\n-        default: tp.default.map(|x| fld.fold_ty(x)),\n-        span: tp.span\n+        id: fld.new_id(id),\n+        ident: ident,\n+        bounds: fld.fold_bounds(bounds),\n+        unbound: unbound.map(|x| fld.fold_ty_param_bound(x)),\n+        default: default.map(|x| fld.fold_ty(x)),\n+        span: span\n     }\n }\n \n-pub fn noop_fold_ty_params<T: Folder>(tps: &[TyParam], fld: &mut T)\n+pub fn noop_fold_ty_params<T: Folder>(tps: OwnedSlice<TyParam>, fld: &mut T)\n                                       -> OwnedSlice<TyParam> {\n-    tps.iter().map(|tp| fld.fold_ty_param(tp)).collect()\n+    tps.move_map(|tp| fld.fold_ty_param(tp))\n }\n \n-pub fn noop_fold_lifetime<T: Folder>(l: &Lifetime, fld: &mut T) -> Lifetime {\n-    let id = fld.new_id(l.id);\n+pub fn noop_fold_lifetime<T: Folder>(l: Lifetime, fld: &mut T) -> Lifetime {\n     Lifetime {\n-        id: id,\n-        span: fld.new_span(l.span),\n-        name: l.name\n+        id: fld.new_id(l.id),\n+        name: l.name,\n+        span: fld.new_span(l.span)\n     }\n }\n \n-pub fn noop_fold_lifetime_def<T: Folder>(l: &LifetimeDef, fld: &mut T)\n-                                         -> LifetimeDef\n-{\n+pub fn noop_fold_lifetime_def<T: Folder>(l: LifetimeDef, fld: &mut T)\n+                                         -> LifetimeDef {\n     LifetimeDef {\n-        lifetime: fld.fold_lifetime(&l.lifetime),\n-        bounds: fld.fold_lifetimes(l.bounds.as_slice()),\n+        lifetime: fld.fold_lifetime(l.lifetime),\n+        bounds: fld.fold_lifetimes(l.bounds),\n     }\n }\n \n-pub fn noop_fold_lifetimes<T: Folder>(lts: &[Lifetime], fld: &mut T) -> Vec<Lifetime> {\n-    lts.iter().map(|l| fld.fold_lifetime(l)).collect()\n+pub fn noop_fold_lifetimes<T: Folder>(lts: Vec<Lifetime>, fld: &mut T) -> Vec<Lifetime> {\n+    lts.move_map(|l| fld.fold_lifetime(l))\n }\n \n-pub fn noop_fold_lifetime_defs<T: Folder>(lts: &[LifetimeDef], fld: &mut T) -> Vec<LifetimeDef> {\n-    lts.iter().map(|l| fld.fold_lifetime_def(l)).collect()\n+pub fn noop_fold_lifetime_defs<T: Folder>(lts: Vec<LifetimeDef>, fld: &mut T)\n+                                          -> Vec<LifetimeDef> {\n+    lts.move_map(|l| fld.fold_lifetime_def(l))\n }\n \n-pub fn noop_fold_opt_lifetime<T: Folder>(o_lt: &Option<Lifetime>, fld: &mut T)\n-                                      -> Option<Lifetime> {\n-    o_lt.as_ref().map(|lt| fld.fold_lifetime(lt))\n+pub fn noop_fold_opt_lifetime<T: Folder>(o_lt: Option<Lifetime>, fld: &mut T)\n+                                         -> Option<Lifetime> {\n+    o_lt.map(|lt| fld.fold_lifetime(lt))\n }\n \n-pub fn noop_fold_generics<T: Folder>(generics: &Generics, fld: &mut T) -> Generics {\n+pub fn noop_fold_generics<T: Folder>(Generics {ty_params, lifetimes, where_clause}: Generics,\n+                                     fld: &mut T) -> Generics {\n     Generics {\n-        ty_params: fld.fold_ty_params(generics.ty_params.as_slice()),\n-        lifetimes: fld.fold_lifetime_defs(generics.lifetimes.as_slice()),\n-        where_clause: fld.fold_where_clause(&generics.where_clause),\n+        ty_params: fld.fold_ty_params(ty_params),\n+        lifetimes: fld.fold_lifetime_defs(lifetimes),\n+        where_clause: fld.fold_where_clause(where_clause),\n     }\n }\n \n pub fn noop_fold_where_clause<T: Folder>(\n-                              where_clause: &WhereClause,\n+                              WhereClause {id, predicates}: WhereClause,\n                               fld: &mut T)\n                               -> WhereClause {\n     WhereClause {\n-        id: fld.new_id(where_clause.id),\n-        predicates: where_clause.predicates.iter().map(|predicate| {\n+        id: fld.new_id(id),\n+        predicates: predicates.move_map(|predicate| {\n             fld.fold_where_predicate(predicate)\n-        }).collect(),\n+        })\n     }\n }\n \n pub fn noop_fold_where_predicate<T: Folder>(\n-                                 predicate: &WherePredicate,\n+                                 WherePredicate {id, ident, bounds, span}: WherePredicate,\n                                  fld: &mut T)\n                                  -> WherePredicate {\n     WherePredicate {\n-        id: fld.new_id(predicate.id),\n-        span: fld.new_span(predicate.span),\n-        ident: fld.fold_ident(predicate.ident),\n-        bounds: predicate.bounds.map(|x| {\n-            fld.fold_ty_param_bound(x)\n-        }),\n+        id: fld.new_id(id),\n+        ident: fld.fold_ident(ident),\n+        bounds: bounds.move_map(|x| fld.fold_ty_param_bound(x)),\n+        span: fld.new_span(span)\n     }\n }\n \n-pub fn noop_fold_struct_def<T: Folder>(struct_def: Gc<StructDef>,\n-                              fld: &mut T) -> Gc<StructDef> {\n-    box(GC) ast::StructDef {\n-        fields: struct_def.fields.iter().map(|f| fld.fold_struct_field(f)).collect(),\n-        ctor_id: struct_def.ctor_id.map(|cid| fld.new_id(cid)),\n-        super_struct: match struct_def.super_struct {\n-            Some(t) => Some(fld.fold_ty(t)),\n-            None => None\n-        },\n-        is_virtual: struct_def.is_virtual,\n-    }\n+pub fn noop_fold_struct_def<T: Folder>(struct_def: P<StructDef>, fld: &mut T) -> P<StructDef> {\n+    struct_def.map(|StructDef {fields, ctor_id, super_struct, is_virtual}| StructDef {\n+        fields: fields.move_map(|f| fld.fold_struct_field(f)),\n+        ctor_id: ctor_id.map(|cid| fld.new_id(cid)),\n+        super_struct: super_struct.map(|t| fld.fold_ty(t)),\n+        is_virtual: is_virtual\n+    })\n }\n \n-pub fn noop_fold_trait_ref<T: Folder>(p: &TraitRef, fld: &mut T) -> TraitRef {\n-    let id = fld.new_id(p.ref_id);\n-    ast::TraitRef {\n-        path: fld.fold_path(&p.path),\n-        ref_id: id,\n+pub fn noop_fold_trait_ref<T: Folder>(TraitRef {ref_id, path}: TraitRef, fld: &mut T) -> TraitRef {\n+    TraitRef {\n+        ref_id: fld.new_id(ref_id),\n+        path: fld.fold_path(path),\n     }\n }\n \n-pub fn noop_fold_struct_field<T: Folder>(f: &StructField, fld: &mut T) -> StructField {\n-    let id = fld.new_id(f.node.id);\n+pub fn noop_fold_struct_field<T: Folder>(f: StructField, fld: &mut T) -> StructField {\n+    let StructField {node: StructField_ {id, kind, ty, attrs}, span} = f;\n     Spanned {\n-        node: ast::StructField_ {\n-            kind: f.node.kind,\n-            id: id,\n-            ty: fld.fold_ty(f.node.ty),\n-            attrs: f.node.attrs.iter().map(|a| fld.fold_attribute(*a)).collect(),\n+        node: StructField_ {\n+            id: fld.new_id(id),\n+            kind: kind,\n+            ty: fld.fold_ty(ty),\n+            attrs: attrs.move_map(|a| fld.fold_attribute(a))\n         },\n-        span: fld.new_span(f.span),\n+        span: fld.new_span(span)\n     }\n }\n \n-pub fn noop_fold_field<T: Folder>(field: Field, folder: &mut T) -> Field {\n-    ast::Field {\n-        ident: respan(field.ident.span, folder.fold_ident(field.ident.node)),\n-        expr: folder.fold_expr(field.expr),\n-        span: folder.new_span(field.span),\n+pub fn noop_fold_field<T: Folder>(Field {ident, expr, span}: Field, folder: &mut T) -> Field {\n+    Field {\n+        ident: respan(ident.span, folder.fold_ident(ident.node)),\n+        expr: folder.fold_expr(expr),\n+        span: folder.new_span(span)\n     }\n }\n \n-pub fn noop_fold_mt<T: Folder>(mt: &MutTy, folder: &mut T) -> MutTy {\n+pub fn noop_fold_mt<T: Folder>(MutTy {ty, mutbl}: MutTy, folder: &mut T) -> MutTy {\n     MutTy {\n-        ty: folder.fold_ty(mt.ty),\n-        mutbl: mt.mutbl,\n+        ty: folder.fold_ty(ty),\n+        mutbl: mutbl,\n     }\n }\n \n-pub fn noop_fold_opt_bounds<T: Folder>(b: &Option<OwnedSlice<TyParamBound>>, folder: &mut T)\n-                              -> Option<OwnedSlice<TyParamBound>> {\n-    b.as_ref().map(|bounds| folder.fold_bounds(bounds))\n+pub fn noop_fold_opt_bounds<T: Folder>(b: Option<OwnedSlice<TyParamBound>>, folder: &mut T)\n+                                       -> Option<OwnedSlice<TyParamBound>> {\n+    b.map(|bounds| folder.fold_bounds(bounds))\n }\n \n-fn noop_fold_bounds<T: Folder>(bounds: &TyParamBounds, folder: &mut T)\n+fn noop_fold_bounds<T: Folder>(bounds: TyParamBounds, folder: &mut T)\n                           -> TyParamBounds {\n-    bounds.map(|bound| folder.fold_ty_param_bound(bound))\n+    bounds.move_map(|bound| folder.fold_ty_param_bound(bound))\n }\n \n-pub fn noop_fold_variant_arg<T: Folder>(va: &VariantArg, folder: &mut T) -> VariantArg {\n-    let id = folder.new_id(va.id);\n-    ast::VariantArg {\n-        ty: folder.fold_ty(va.ty),\n-        id: id,\n+fn noop_fold_variant_arg<T: Folder>(VariantArg {id, ty}: VariantArg, folder: &mut T)\n+                                    -> VariantArg {\n+    VariantArg {\n+        id: folder.new_id(id),\n+        ty: folder.fold_ty(ty)\n     }\n }\n \n-pub fn noop_fold_view_item<T: Folder>(vi: &ViewItem, folder: &mut T)\n-                                       -> ViewItem{\n-    let inner_view_item = match vi.node {\n-        ViewItemExternCrate(ref ident, ref string, node_id) => {\n-            ViewItemExternCrate(ident.clone(),\n-                              (*string).clone(),\n-                              folder.new_id(node_id))\n-        }\n-        ViewItemUse(ref view_path) => {\n-            ViewItemUse(folder.fold_view_path(*view_path))\n-        }\n-    };\n+pub fn noop_fold_view_item<T: Folder>(ViewItem {node, attrs, vis, span}: ViewItem,\n+                                      folder: &mut T) -> ViewItem {\n     ViewItem {\n-        node: inner_view_item,\n-        attrs: vi.attrs.iter().map(|a| folder.fold_attribute(*a)).collect(),\n-        vis: vi.vis,\n-        span: folder.new_span(vi.span),\n+        node: match node {\n+            ViewItemExternCrate(ident, string, node_id) => {\n+                ViewItemExternCrate(ident, string,\n+                                    folder.new_id(node_id))\n+            }\n+            ViewItemUse(view_path) => {\n+                ViewItemUse(folder.fold_view_path(view_path))\n+            }\n+        },\n+        attrs: attrs.move_map(|a| folder.fold_attribute(a)),\n+        vis: vis,\n+        span: folder.new_span(span)\n     }\n }\n \n pub fn noop_fold_block<T: Folder>(b: P<Block>, folder: &mut T) -> P<Block> {\n-    let id = folder.new_id(b.id); // Needs to be first, for ast_map.\n-    let view_items = b.view_items.iter().map(|x| folder.fold_view_item(x)).collect();\n-    let stmts = b.stmts.iter().flat_map(|s| folder.fold_stmt(&**s).move_iter()).collect();\n-    P(Block {\n-        id: id,\n-        view_items: view_items,\n-        stmts: stmts,\n-        expr: b.expr.map(|x| folder.fold_expr(x)),\n-        rules: b.rules,\n-        span: folder.new_span(b.span),\n+    b.map(|Block {id, view_items, stmts, expr, rules, span}| Block {\n+        id: folder.new_id(id), // Needs to be first, for ast_map.\n+        view_items: view_items.move_map(|x| folder.fold_view_item(x)),\n+        stmts: stmts.move_iter().flat_map(|s| folder.fold_stmt(s).move_iter()).collect(),\n+        expr: expr.map(|x| folder.fold_expr(x)),\n+        rules: rules,\n+        span: folder.new_span(span),\n     })\n }\n \n-pub fn noop_fold_item_underscore<T: Folder>(i: &Item_, folder: &mut T) -> Item_ {\n-    match *i {\n+pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n+    match i {\n         ItemStatic(t, m, e) => {\n             ItemStatic(folder.fold_ty(t), m, folder.fold_expr(e))\n         }\n-        ItemFn(decl, fn_style, abi, ref generics, body) => {\n+        ItemFn(decl, fn_style, abi, generics, body) => {\n             ItemFn(\n-                folder.fold_fn_decl(&*decl),\n+                folder.fold_fn_decl(decl),\n                 fn_style,\n                 abi,\n                 folder.fold_generics(generics),\n                 folder.fold_block(body)\n             )\n         }\n-        ItemMod(ref m) => ItemMod(folder.fold_mod(m)),\n-        ItemForeignMod(ref nm) => ItemForeignMod(folder.fold_foreign_mod(nm)),\n-        ItemTy(t, ref generics) => {\n+        ItemMod(m) => ItemMod(folder.fold_mod(m)),\n+        ItemForeignMod(nm) => ItemForeignMod(folder.fold_foreign_mod(nm)),\n+        ItemTy(t, generics) => {\n             ItemTy(folder.fold_ty(t), folder.fold_generics(generics))\n         }\n-        ItemEnum(ref enum_definition, ref generics) => {\n+        ItemEnum(enum_definition, generics) => {\n             ItemEnum(\n                 ast::EnumDef {\n-                    variants: enum_definition.variants.iter().map(|&x| {\n-                        folder.fold_variant(&*x)\n-                    }).collect(),\n+                    variants: enum_definition.variants.move_map(|x| folder.fold_variant(x)),\n                 },\n                 folder.fold_generics(generics))\n         }\n-        ItemStruct(ref struct_def, ref generics) => {\n-            let struct_def = folder.fold_struct_def(*struct_def);\n+        ItemStruct(struct_def, generics) => {\n+            let struct_def = folder.fold_struct_def(struct_def);\n             ItemStruct(struct_def, folder.fold_generics(generics))\n         }\n-        ItemImpl(ref generics, ref ifce, ty, ref impl_items) => {\n+        ItemImpl(generics, ifce, ty, impl_items) => {\n             ItemImpl(folder.fold_generics(generics),\n-                     ifce.as_ref().map(|p| folder.fold_trait_ref(p)),\n+                     ifce.map(|p| folder.fold_trait_ref(p)),\n                      folder.fold_ty(ty),\n-                     impl_items.iter()\n-                               .flat_map(|impl_item| {\n-                                    match *impl_item {\n-                                        MethodImplItem(x) => {\n-                                            folder.fold_method(x)\n-                                                  .move_iter()\n-                                                  .map(|x| MethodImplItem(x))\n-                                        }\n-                                    }\n-                               }).collect()\n-            )\n+                     impl_items.move_iter().flat_map(|impl_item| match impl_item {\n+                        MethodImplItem(x) => {\n+                            folder.fold_method(x).move_iter().map(|x| MethodImplItem(x))\n+                        }\n+                     }).collect())\n         }\n-        ItemTrait(ref generics, ref unbound, ref bounds, ref methods) => {\n+        ItemTrait(generics, unbound, bounds, methods) => {\n             let bounds = folder.fold_bounds(bounds);\n-            let methods = methods.iter().flat_map(|method| {\n-                let r = match *method {\n-                    RequiredMethod(ref m) => {\n-                            SmallVector::one(RequiredMethod(\n-                                    folder.fold_type_method(m))).move_iter()\n-                    }\n-                    ProvidedMethod(method) => {\n-                            // the awkward collect/iter idiom here is because\n-                            // even though an iter and a map satisfy the same trait bound,\n-                            // they're not actually the same type, so the method arms\n-                            // don't unify.\n-                            let methods : SmallVector<ast::TraitItem> =\n-                                folder.fold_method(method).move_iter()\n-                                .map(|m| ProvidedMethod(m)).collect();\n-                            methods.move_iter()\n-                        }\n-                };\n-                r\n+            let methods = methods.move_iter().flat_map(|method| match method {\n+                RequiredMethod(m) => {\n+                    SmallVector::one(RequiredMethod(folder.fold_type_method(m))).move_iter()\n+                }\n+                ProvidedMethod(method) => {\n+                    // the awkward collect/iter idiom here is because\n+                    // even though an iter and a map satisfy the same trait bound,\n+                    // they're not actually the same type, so the method arms\n+                    // don't unify.\n+                    let methods: SmallVector<ast::TraitItem> =\n+                        folder.fold_method(method).move_iter()\n+                        .map(|m| ProvidedMethod(m)).collect();\n+                    methods.move_iter()\n+                }\n             }).collect();\n             ItemTrait(folder.fold_generics(generics),\n-                      unbound.clone(),\n+                      unbound,\n                       bounds,\n                       methods)\n         }\n-        ItemMac(ref m) => ItemMac(folder.fold_mac(m)),\n+        ItemMac(m) => ItemMac(folder.fold_mac(m)),\n     }\n }\n \n-pub fn noop_fold_type_method<T: Folder>(m: &TypeMethod, fld: &mut T) -> TypeMethod {\n-    let id = fld.new_id(m.id); // Needs to be first, for ast_map.\n+pub fn noop_fold_type_method<T: Folder>(m: TypeMethod, fld: &mut T) -> TypeMethod {\n+    let TypeMethod {id, ident, attrs, fn_style, abi, decl, generics, explicit_self, vis, span} = m;\n     TypeMethod {\n-        id: id,\n-        ident: fld.fold_ident(m.ident),\n-        attrs: m.attrs.iter().map(|a| fld.fold_attribute(*a)).collect(),\n-        fn_style: m.fn_style,\n-        abi: m.abi,\n-        decl: fld.fold_fn_decl(&*m.decl),\n-        generics: fld.fold_generics(&m.generics),\n-        explicit_self: fld.fold_explicit_self(&m.explicit_self),\n-        span: fld.new_span(m.span),\n-        vis: m.vis,\n+        id: fld.new_id(id), // Needs to be first, for ast_map.\n+        ident: fld.fold_ident(ident),\n+        attrs: attrs.move_map(|a| fld.fold_attribute(a)),\n+        fn_style: fn_style,\n+        abi: abi,\n+        decl: fld.fold_fn_decl(decl),\n+        generics: fld.fold_generics(generics),\n+        explicit_self: fld.fold_explicit_self(explicit_self),\n+        vis: vis,\n+        span: fld.new_span(span)\n     }\n }\n \n-pub fn noop_fold_mod<T: Folder>(m: &Mod, folder: &mut T) -> Mod {\n-    ast::Mod {\n-        inner: folder.new_span(m.inner),\n-        view_items: m.view_items\n-                     .iter()\n-                     .map(|x| folder.fold_view_item(x)).collect(),\n-        items: m.items.iter().flat_map(|x| folder.fold_item(*x).move_iter()).collect(),\n+pub fn noop_fold_mod<T: Folder>(Mod {inner, view_items, items}: Mod, folder: &mut T) -> Mod {\n+    Mod {\n+        inner: folder.new_span(inner),\n+        view_items: view_items.move_map(|x| folder.fold_view_item(x)),\n+        items: items.move_iter().flat_map(|x| folder.fold_item(x).move_iter()).collect(),\n     }\n }\n \n-pub fn noop_fold_crate<T: Folder>(c: Crate, folder: &mut T) -> Crate {\n+pub fn noop_fold_crate<T: Folder>(Crate {module, attrs, config, exported_macros, span}: Crate,\n+                                  folder: &mut T) -> Crate {\n     Crate {\n-        module: folder.fold_mod(&c.module),\n-        attrs: c.attrs.iter().map(|x| folder.fold_attribute(*x)).collect(),\n-        config: c.config.iter().map(|x| box (GC) folder.fold_meta_item(&**x)).collect(),\n-        span: folder.new_span(c.span),\n-        exported_macros: c.exported_macros\n+        module: folder.fold_mod(module),\n+        attrs: attrs.move_map(|x| folder.fold_attribute(x)),\n+        config: folder.fold_meta_items(config),\n+        exported_macros: exported_macros,\n+        span: folder.new_span(span)\n     }\n }\n \n // fold one item into possibly many items\n-pub fn noop_fold_item<T: Folder>(i: &Item,\n-                                 folder: &mut T) -> SmallVector<Gc<Item>> {\n-    SmallVector::one(box(GC) folder.fold_item_simple(i))\n+pub fn noop_fold_item<T: Folder>(i: P<Item>, folder: &mut T) -> SmallVector<P<Item>> {\n+    SmallVector::one(i.map(|i| folder.fold_item_simple(i)))\n }\n \n-\n // fold one item into exactly one item\n-pub fn noop_fold_item_simple<T: Folder>(i: &Item, folder: &mut T) -> Item {\n-    let id = folder.new_id(i.id); // Needs to be first, for ast_map.\n-    let node = folder.fold_item_underscore(&i.node);\n+pub fn noop_fold_item_simple<T: Folder>(Item {id, ident, attrs, node, vis, span}: Item,\n+                                        folder: &mut T) -> Item {\n+    let id = folder.new_id(id); // Needs to be first, for ast_map.\n+    let node = folder.fold_item_underscore(node);\n     let ident = match node {\n         // The node may have changed, recompute the \"pretty\" impl name.\n-        ItemImpl(_, ref maybe_trait, ty, _) => {\n-            ast_util::impl_pretty_name(maybe_trait, &*ty)\n+        ItemImpl(_, ref maybe_trait, ref ty, _) => {\n+            ast_util::impl_pretty_name(maybe_trait, &**ty)\n         }\n-        _ => i.ident\n+        _ => ident\n     };\n \n     Item {\n         id: id,\n         ident: folder.fold_ident(ident),\n-        attrs: i.attrs.iter().map(|e| folder.fold_attribute(*e)).collect(),\n+        attrs: attrs.move_map(|e| folder.fold_attribute(e)),\n         node: node,\n-        vis: i.vis,\n-        span: folder.new_span(i.span)\n+        vis: vis,\n+        span: folder.new_span(span)\n     }\n }\n \n-pub fn noop_fold_foreign_item<T: Folder>(ni: &ForeignItem,\n-                                         folder: &mut T) -> Gc<ForeignItem> {\n-    let id = folder.new_id(ni.id); // Needs to be first, for ast_map.\n-    box(GC) ForeignItem {\n-        id: id,\n-        ident: folder.fold_ident(ni.ident),\n-        attrs: ni.attrs.iter().map(|x| folder.fold_attribute(*x)).collect(),\n-        node: match ni.node {\n-            ForeignItemFn(ref fdec, ref generics) => {\n-                ForeignItemFn(P(FnDecl {\n-                    inputs: fdec.inputs.iter().map(|a| folder.fold_arg(a)).collect(),\n-                    output: folder.fold_ty(fdec.output),\n-                    cf: fdec.cf,\n-                    variadic: fdec.variadic\n+pub fn noop_fold_foreign_item<T: Folder>(ni: P<ForeignItem>, folder: &mut T) -> P<ForeignItem> {\n+    ni.map(|ForeignItem {id, ident, attrs, node, span, vis}| ForeignItem {\n+        id: folder.new_id(id), // Needs to be first, for ast_map.\n+        ident: folder.fold_ident(ident),\n+        attrs: attrs.move_map(|x| folder.fold_attribute(x)),\n+        node: match node {\n+            ForeignItemFn(fdec, generics) => {\n+                ForeignItemFn(fdec.map(|FnDecl {inputs, output, cf, variadic}| FnDecl {\n+                    inputs: inputs.move_map(|a| folder.fold_arg(a)),\n+                    output: folder.fold_ty(output),\n+                    cf: cf,\n+                    variadic: variadic\n                 }), folder.fold_generics(generics))\n             }\n             ForeignItemStatic(t, m) => {\n                 ForeignItemStatic(folder.fold_ty(t), m)\n             }\n         },\n-        span: folder.new_span(ni.span),\n-        vis: ni.vis,\n-    }\n+        vis: vis,\n+        span: folder.new_span(span)\n+    })\n }\n \n // Default fold over a method.\n // Invariant: produces exactly one method.\n-pub fn noop_fold_method<T: Folder>(m: &Method, folder: &mut T) -> SmallVector<Gc<Method>> {\n-    let id = folder.new_id(m.id); // Needs to be first, for ast_map.\n-    SmallVector::one(box(GC) Method {\n-        attrs: m.attrs.iter().map(|a| folder.fold_attribute(*a)).collect(),\n-        id: id,\n-        span: folder.new_span(m.span),\n-        node: match m.node {\n+pub fn noop_fold_method<T: Folder>(m: P<Method>, folder: &mut T) -> SmallVector<P<Method>> {\n+    SmallVector::one(m.map(|Method {id, attrs, node, span}| Method {\n+        id: folder.new_id(id), // Needs to be first, for ast_map.\n+        attrs: attrs.move_map(|a| folder.fold_attribute(a)),\n+        node: match node {\n             MethDecl(ident,\n-                     ref generics,\n+                     generics,\n                      abi,\n-                     ref explicit_self,\n+                     explicit_self,\n                      fn_style,\n                      decl,\n                      body,\n@@ -1044,215 +989,226 @@ pub fn noop_fold_method<T: Folder>(m: &Method, folder: &mut T) -> SmallVector<Gc\n                          abi,\n                          folder.fold_explicit_self(explicit_self),\n                          fn_style,\n-                         folder.fold_fn_decl(&*decl),\n+                         folder.fold_fn_decl(decl),\n                          folder.fold_block(body),\n                          vis)\n             },\n-            MethMac(ref mac) => MethMac(folder.fold_mac(mac)),\n-        }\n-    })\n+            MethMac(mac) => MethMac(folder.fold_mac(mac)),\n+        },\n+        span: folder.new_span(span)\n+    }))\n }\n \n-pub fn noop_fold_pat<T: Folder>(p: Gc<Pat>, folder: &mut T) -> Gc<Pat> {\n-    let id = folder.new_id(p.id);\n-    let node = match p.node {\n-        PatWild(k) => PatWild(k),\n-        PatIdent(binding_mode, ref pth1, ref sub) => {\n-            PatIdent(binding_mode,\n-                     Spanned{span: folder.new_span(pth1.span),\n-                             node: folder.fold_ident(pth1.node)},\n-                     sub.map(|x| folder.fold_pat(x)))\n-        }\n-        PatLit(e) => PatLit(folder.fold_expr(e)),\n-        PatEnum(ref pth, ref pats) => {\n-            PatEnum(folder.fold_path(pth),\n-                    pats.as_ref().map(|pats| pats.iter().map(|x| folder.fold_pat(*x)).collect()))\n-        }\n-        PatStruct(ref pth, ref fields, etc) => {\n-            let pth_ = folder.fold_path(pth);\n-            let fs = fields.iter().map(|f| {\n-                ast::FieldPat {\n-                    ident: f.ident,\n-                    pat: folder.fold_pat(f.pat)\n-                }\n-            }).collect();\n-            PatStruct(pth_, fs, etc)\n-        }\n-        PatTup(ref elts) => PatTup(elts.iter().map(|x| folder.fold_pat(*x)).collect()),\n-        PatBox(inner) => PatBox(folder.fold_pat(inner)),\n-        PatRegion(inner) => PatRegion(folder.fold_pat(inner)),\n-        PatRange(e1, e2) => {\n-            PatRange(folder.fold_expr(e1), folder.fold_expr(e2))\n+pub fn noop_fold_pat<T: Folder>(p: P<Pat>, folder: &mut T) -> P<Pat> {\n+    p.map(|Pat {id, node, span}| Pat {\n+        id: folder.new_id(id),\n+        node: match node {\n+            PatWild(k) => PatWild(k),\n+            PatIdent(binding_mode, pth1, sub) => {\n+                PatIdent(binding_mode,\n+                        Spanned{span: folder.new_span(pth1.span),\n+                                node: folder.fold_ident(pth1.node)},\n+                        sub.map(|x| folder.fold_pat(x)))\n+            }\n+            PatLit(e) => PatLit(folder.fold_expr(e)),\n+            PatEnum(pth, pats) => {\n+                PatEnum(folder.fold_path(pth),\n+                        pats.map(|pats| pats.move_map(|x| folder.fold_pat(x))))\n+            }\n+            PatStruct(pth, fields, etc) => {\n+                let pth = folder.fold_path(pth);\n+                let fs = fields.move_map(|f| {\n+                    ast::FieldPat {\n+                        ident: f.ident,\n+                        pat: folder.fold_pat(f.pat)\n+                    }\n+                });\n+                PatStruct(pth, fs, etc)\n+            }\n+            PatTup(elts) => PatTup(elts.move_map(|x| folder.fold_pat(x))),\n+            PatBox(inner) => PatBox(folder.fold_pat(inner)),\n+            PatRegion(inner) => PatRegion(folder.fold_pat(inner)),\n+            PatRange(e1, e2) => {\n+                PatRange(folder.fold_expr(e1), folder.fold_expr(e2))\n+            },\n+            PatVec(before, slice, after) => {\n+                PatVec(before.move_map(|x| folder.fold_pat(x)),\n+                       slice.map(|x| folder.fold_pat(x)),\n+                       after.move_map(|x| folder.fold_pat(x)))\n+            }\n+            PatMac(mac) => PatMac(folder.fold_mac(mac))\n         },\n-        PatVec(ref before, ref slice, ref after) => {\n-            PatVec(before.iter().map(|x| folder.fold_pat(*x)).collect(),\n-                    slice.map(|x| folder.fold_pat(x)),\n-                    after.iter().map(|x| folder.fold_pat(*x)).collect())\n-        }\n-        PatMac(ref mac) => PatMac(folder.fold_mac(mac)),\n-    };\n-\n-    box(GC) Pat {\n-        id: id,\n-        span: folder.new_span(p.span),\n-        node: node,\n-    }\n+        span: folder.new_span(span)\n+    })\n }\n \n-pub fn noop_fold_expr<T: Folder>(e: Gc<Expr>, folder: &mut T) -> Gc<Expr> {\n-    let id = folder.new_id(e.id);\n-    let node = match e.node {\n-        ExprBox(p, e) => {\n-            ExprBox(folder.fold_expr(p), folder.fold_expr(e))\n-        }\n-        ExprVec(ref exprs) => {\n-            ExprVec(exprs.iter().map(|&x| folder.fold_expr(x)).collect())\n-        }\n-        ExprRepeat(expr, count) => {\n-            ExprRepeat(folder.fold_expr(expr), folder.fold_expr(count))\n-        }\n-        ExprTup(ref elts) => ExprTup(elts.iter().map(|x| folder.fold_expr(*x)).collect()),\n-        ExprCall(f, ref args) => {\n-            ExprCall(folder.fold_expr(f),\n-                     args.iter().map(|&x| folder.fold_expr(x)).collect())\n-        }\n-        ExprMethodCall(i, ref tps, ref args) => {\n-            ExprMethodCall(\n-                respan(i.span, folder.fold_ident(i.node)),\n-                tps.iter().map(|&x| folder.fold_ty(x)).collect(),\n-                args.iter().map(|&x| folder.fold_expr(x)).collect())\n-        }\n-        ExprBinary(binop, lhs, rhs) => {\n-            ExprBinary(binop,\n-                       folder.fold_expr(lhs),\n-                       folder.fold_expr(rhs))\n-        }\n-        ExprUnary(binop, ohs) => {\n-            ExprUnary(binop, folder.fold_expr(ohs))\n-        }\n-        ExprLit(_) => e.node.clone(),\n-        ExprCast(expr, ty) => {\n-            ExprCast(folder.fold_expr(expr), folder.fold_ty(ty))\n-        }\n-        ExprAddrOf(m, ohs) => ExprAddrOf(m, folder.fold_expr(ohs)),\n-        ExprIf(cond, tr, fl) => {\n-            ExprIf(folder.fold_expr(cond),\n-                   folder.fold_block(tr),\n-                   fl.map(|x| folder.fold_expr(x)))\n-        }\n-        ExprWhile(cond, body, opt_ident) => {\n-            ExprWhile(folder.fold_expr(cond),\n-                      folder.fold_block(body),\n-                      opt_ident.map(|i| folder.fold_ident(i)))\n-        }\n-        ExprForLoop(pat, iter, body, ref opt_ident) => {\n-            ExprForLoop(folder.fold_pat(pat),\n-                        folder.fold_expr(iter),\n-                        folder.fold_block(body),\n+pub fn noop_fold_expr<T: Folder>(Expr {id, node, span}: Expr, folder: &mut T) -> Expr {\n+    Expr {\n+        id: folder.new_id(id),\n+        node: match node {\n+            ExprBox(p, e) => {\n+                ExprBox(folder.fold_expr(p), folder.fold_expr(e))\n+            }\n+            ExprVec(exprs) => {\n+                ExprVec(exprs.move_map(|x| folder.fold_expr(x)))\n+            }\n+            ExprRepeat(expr, count) => {\n+                ExprRepeat(folder.fold_expr(expr), folder.fold_expr(count))\n+            }\n+            ExprTup(elts) => ExprTup(elts.move_map(|x| folder.fold_expr(x))),\n+            ExprCall(f, args) => {\n+                ExprCall(folder.fold_expr(f),\n+                         args.move_map(|x| folder.fold_expr(x)))\n+            }\n+            ExprMethodCall(i, tps, args) => {\n+                ExprMethodCall(\n+                    respan(i.span, folder.fold_ident(i.node)),\n+                    tps.move_map(|x| folder.fold_ty(x)),\n+                    args.move_map(|x| folder.fold_expr(x)))\n+            }\n+            ExprBinary(binop, lhs, rhs) => {\n+                ExprBinary(binop,\n+                        folder.fold_expr(lhs),\n+                        folder.fold_expr(rhs))\n+            }\n+            ExprUnary(binop, ohs) => {\n+                ExprUnary(binop, folder.fold_expr(ohs))\n+            }\n+            ExprLit(l) => ExprLit(l),\n+            ExprCast(expr, ty) => {\n+                ExprCast(folder.fold_expr(expr), folder.fold_ty(ty))\n+            }\n+            ExprAddrOf(m, ohs) => ExprAddrOf(m, folder.fold_expr(ohs)),\n+            ExprIf(cond, tr, fl) => {\n+                ExprIf(folder.fold_expr(cond),\n+                       folder.fold_block(tr),\n+                       fl.map(|x| folder.fold_expr(x)))\n+            }\n+            ExprWhile(cond, body, opt_ident) => {\n+                ExprWhile(folder.fold_expr(cond),\n+                          folder.fold_block(body),\n+                          opt_ident.map(|i| folder.fold_ident(i)))\n+            }\n+            ExprForLoop(pat, iter, body, opt_ident) => {\n+                ExprForLoop(folder.fold_pat(pat),\n+                            folder.fold_expr(iter),\n+                            folder.fold_block(body),\n+                            opt_ident.map(|i| folder.fold_ident(i)))\n+            }\n+            ExprLoop(body, opt_ident) => {\n+                ExprLoop(folder.fold_block(body),\n                         opt_ident.map(|i| folder.fold_ident(i)))\n-        }\n-        ExprLoop(body, opt_ident) => {\n-            ExprLoop(folder.fold_block(body),\n-                     opt_ident.map(|i| folder.fold_ident(i)))\n-        }\n-        ExprMatch(expr, ref arms) => {\n-            ExprMatch(folder.fold_expr(expr),\n-                      arms.iter().map(|x| folder.fold_arm(x)).collect())\n-        }\n-        ExprFnBlock(capture_clause, ref decl, ref body) => {\n-            ExprFnBlock(capture_clause,\n-                        folder.fold_fn_decl(&**decl),\n-                        folder.fold_block(body.clone()))\n-        }\n-        ExprProc(ref decl, ref body) => {\n-            ExprProc(folder.fold_fn_decl(&**decl),\n-                     folder.fold_block(body.clone()))\n-        }\n-        ExprUnboxedFn(capture_clause, kind, ref decl, ref body) => {\n-            ExprUnboxedFn(capture_clause,\n-                          kind,\n-                          folder.fold_fn_decl(&**decl),\n-                          folder.fold_block(*body))\n-        }\n-        ExprBlock(ref blk) => ExprBlock(folder.fold_block(*blk)),\n-        ExprAssign(el, er) => {\n-            ExprAssign(folder.fold_expr(el), folder.fold_expr(er))\n-        }\n-        ExprAssignOp(op, el, er) => {\n-            ExprAssignOp(op,\n-                         folder.fold_expr(el),\n-                         folder.fold_expr(er))\n-        }\n-        ExprField(el, id, ref tys) => {\n-            ExprField(folder.fold_expr(el),\n-                      respan(id.span, folder.fold_ident(id.node)),\n-                      tys.iter().map(|&x| folder.fold_ty(x)).collect())\n-        }\n-        ExprTupField(el, id, ref tys) => {\n-            ExprTupField(folder.fold_expr(el),\n-                      respan(id.span, folder.fold_uint(id.node)),\n-                      tys.iter().map(|&x| folder.fold_ty(x)).collect())\n-        }\n-        ExprIndex(el, er) => {\n-            ExprIndex(folder.fold_expr(el), folder.fold_expr(er))\n-        }\n-        ExprPath(ref pth) => ExprPath(folder.fold_path(pth)),\n-        ExprBreak(opt_ident) => ExprBreak(opt_ident.map(|x| folder.fold_ident(x))),\n-        ExprAgain(opt_ident) => ExprAgain(opt_ident.map(|x| folder.fold_ident(x))),\n-        ExprRet(ref e) => {\n-            ExprRet(e.map(|x| folder.fold_expr(x)))\n-        }\n-        ExprInlineAsm(ref a) => {\n+            }\n+            ExprMatch(expr, arms) => {\n+                ExprMatch(folder.fold_expr(expr),\n+                        arms.move_map(|x| folder.fold_arm(x)))\n+            }\n+            ExprFnBlock(capture_clause, decl, body) => {\n+                ExprFnBlock(capture_clause,\n+                            folder.fold_fn_decl(decl),\n+                            folder.fold_block(body))\n+            }\n+            ExprProc(decl, body) => {\n+                ExprProc(folder.fold_fn_decl(decl),\n+                         folder.fold_block(body))\n+            }\n+            ExprUnboxedFn(capture_clause, kind, decl, body) => {\n+                ExprUnboxedFn(capture_clause,\n+                            kind,\n+                            folder.fold_fn_decl(decl),\n+                            folder.fold_block(body))\n+            }\n+            ExprBlock(blk) => ExprBlock(folder.fold_block(blk)),\n+            ExprAssign(el, er) => {\n+                ExprAssign(folder.fold_expr(el), folder.fold_expr(er))\n+            }\n+            ExprAssignOp(op, el, er) => {\n+                ExprAssignOp(op,\n+                            folder.fold_expr(el),\n+                            folder.fold_expr(er))\n+            }\n+            ExprField(el, ident, tys) => {\n+                ExprField(folder.fold_expr(el),\n+                          respan(ident.span, folder.fold_ident(ident.node)),\n+                          tys.move_map(|x| folder.fold_ty(x)))\n+            }\n+            ExprTupField(el, ident, tys) => {\n+                ExprTupField(folder.fold_expr(el),\n+                             respan(ident.span, folder.fold_uint(ident.node)),\n+                             tys.move_map(|x| folder.fold_ty(x)))\n+            }\n+            ExprIndex(el, er) => {\n+                ExprIndex(folder.fold_expr(el), folder.fold_expr(er))\n+            }\n+            ExprPath(pth) => ExprPath(folder.fold_path(pth)),\n+            ExprBreak(opt_ident) => ExprBreak(opt_ident.map(|x| folder.fold_ident(x))),\n+            ExprAgain(opt_ident) => ExprAgain(opt_ident.map(|x| folder.fold_ident(x))),\n+            ExprRet(e) => ExprRet(e.map(|x| folder.fold_expr(x))),\n             ExprInlineAsm(InlineAsm {\n-                inputs: a.inputs.iter().map(|&(ref c, input)| {\n-                    ((*c).clone(), folder.fold_expr(input))\n-                }).collect(),\n-                outputs: a.outputs.iter().map(|&(ref c, out, is_rw)| {\n-                    ((*c).clone(), folder.fold_expr(out), is_rw)\n-                }).collect(),\n-                .. (*a).clone()\n-            })\n-        }\n-        ExprMac(ref mac) => ExprMac(folder.fold_mac(mac)),\n-        ExprStruct(ref path, ref fields, maybe_expr) => {\n-            ExprStruct(folder.fold_path(path),\n-                       fields.iter().map(|x| folder.fold_field(*x)).collect(),\n-                       maybe_expr.map(|x| folder.fold_expr(x)))\n+                inputs,\n+                outputs,\n+                asm,\n+                asm_str_style,\n+                clobbers,\n+                volatile,\n+                alignstack,\n+                dialect\n+            }) => ExprInlineAsm(InlineAsm {\n+                inputs: inputs.move_map(|(c, input)| {\n+                    (c, folder.fold_expr(input))\n+                }),\n+                outputs: outputs.move_map(|(c, out, is_rw)| {\n+                    (c, folder.fold_expr(out), is_rw)\n+                }),\n+                asm: asm,\n+                asm_str_style: asm_str_style,\n+                clobbers: clobbers,\n+                volatile: volatile,\n+                alignstack: alignstack,\n+                dialect: dialect\n+            }),\n+            ExprMac(mac) => ExprMac(folder.fold_mac(mac)),\n+            ExprStruct(path, fields, maybe_expr) => {\n+                ExprStruct(folder.fold_path(path),\n+                        fields.move_map(|x| folder.fold_field(x)),\n+                        maybe_expr.map(|x| folder.fold_expr(x)))\n+            },\n+            ExprParen(ex) => ExprParen(folder.fold_expr(ex))\n         },\n-        ExprParen(ex) => ExprParen(folder.fold_expr(ex))\n-    };\n-\n-    box(GC) Expr {\n-        id: id,\n-        node: node,\n-        span: folder.new_span(e.span),\n+        span: folder.new_span(span)\n     }\n }\n \n-pub fn noop_fold_stmt<T: Folder>(s: &Stmt,\n-                                 folder: &mut T) -> SmallVector<Gc<Stmt>> {\n-    let nodes = match s.node {\n+pub fn noop_fold_stmt<T: Folder>(Spanned {node, span}: Stmt, folder: &mut T)\n+                                 -> SmallVector<P<Stmt>> {\n+    let span = folder.new_span(span);\n+    match node {\n         StmtDecl(d, id) => {\n             let id = folder.new_id(id);\n-            folder.fold_decl(d).move_iter()\n-                    .map(|d| StmtDecl(d, id))\n-                    .collect()\n+            folder.fold_decl(d).move_iter().map(|d| P(Spanned {\n+                node: StmtDecl(d, id),\n+                span: span\n+            })).collect()\n         }\n         StmtExpr(e, id) => {\n             let id = folder.new_id(id);\n-            SmallVector::one(StmtExpr(folder.fold_expr(e), id))\n+            SmallVector::one(P(Spanned {\n+                node: StmtExpr(folder.fold_expr(e), id),\n+                span: span\n+            }))\n         }\n         StmtSemi(e, id) => {\n             let id = folder.new_id(id);\n-            SmallVector::one(StmtSemi(folder.fold_expr(e), id))\n+            SmallVector::one(P(Spanned {\n+                node: StmtSemi(folder.fold_expr(e), id),\n+                span: span\n+            }))\n         }\n-        StmtMac(ref mac, semi) => SmallVector::one(StmtMac(folder.fold_mac(mac), semi))\n-    };\n-\n-    nodes.move_iter().map(|node| box(GC) Spanned {\n-        node: node,\n-        span: folder.new_span(s.span),\n-    }).collect()\n+        StmtMac(mac, semi) => SmallVector::one(P(Spanned {\n+            node: StmtMac(folder.fold_mac(mac), semi),\n+            span: span\n+        }))\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "47aef987a63d04426428acede8c63fd942a562c6", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9259b022f8ec05072993fd5e3e9f2eba3afc0c95/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9259b022f8ec05072993fd5e3e9f2eba3afc0c95/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=9259b022f8ec05072993fd5e3e9f2eba3afc0c95", "patch": "@@ -12,6 +12,8 @@ use std::mem;\n use std::slice;\n use std::vec;\n \n+use fold::MoveMap;\n+\n /// A vector type optimized for cases where the size is almost always 0 or 1\n pub struct SmallVector<T> {\n     repr: SmallVectorRepr<T>,\n@@ -20,7 +22,7 @@ pub struct SmallVector<T> {\n enum SmallVectorRepr<T> {\n     Zero,\n     One(T),\n-    Many(Vec<T> ),\n+    Many(Vec<T>),\n }\n \n impl<T> Collection for SmallVector<T> {\n@@ -160,6 +162,17 @@ impl<T> Iterator<T> for MoveItems<T> {\n     }\n }\n \n+impl<T> MoveMap<T> for SmallVector<T> {\n+    fn move_map(self, f: |T| -> T) -> SmallVector<T> {\n+        let repr = match self.repr {\n+            Zero => Zero,\n+            One(v) => One(f(v)),\n+            Many(vs) => Many(vs.move_map(f))\n+        };\n+        SmallVector { repr: repr }\n+    }\n+}\n+\n #[cfg(test)]\n mod test {\n     use super::*;"}]}