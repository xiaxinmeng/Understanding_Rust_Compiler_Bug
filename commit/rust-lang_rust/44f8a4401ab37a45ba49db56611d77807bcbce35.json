{"sha": "44f8a4401ab37a45ba49db56611d77807bcbce35", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0ZjhhNDQwMWFiMzdhNDViYTQ5ZGI1NjYxMWQ3NzgwN2JjYmNlMzU=", "commit": {"author": {"name": "Simon BD", "email": "simon@server", "date": "2012-10-04T02:41:53Z"}, "committer": {"name": "Simon BD", "email": "simon@server", "date": "2012-10-04T02:41:53Z"}, "message": "Backup changes before pull from incoming", "tree": {"sha": "7aaaa6ec9328f305bc4387eaa00a9f3509b076aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7aaaa6ec9328f305bc4387eaa00a9f3509b076aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44f8a4401ab37a45ba49db56611d77807bcbce35", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44f8a4401ab37a45ba49db56611d77807bcbce35", "html_url": "https://github.com/rust-lang/rust/commit/44f8a4401ab37a45ba49db56611d77807bcbce35", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44f8a4401ab37a45ba49db56611d77807bcbce35/comments", "author": {"login": "14427", "id": 2423611, "node_id": "MDQ6VXNlcjI0MjM2MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2423611?v=4", "gravatar_id": "", "url": "https://api.github.com/users/14427", "html_url": "https://github.com/14427", "followers_url": "https://api.github.com/users/14427/followers", "following_url": "https://api.github.com/users/14427/following{/other_user}", "gists_url": "https://api.github.com/users/14427/gists{/gist_id}", "starred_url": "https://api.github.com/users/14427/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/14427/subscriptions", "organizations_url": "https://api.github.com/users/14427/orgs", "repos_url": "https://api.github.com/users/14427/repos", "events_url": "https://api.github.com/users/14427/events{/privacy}", "received_events_url": "https://api.github.com/users/14427/received_events", "type": "User", "site_admin": false}, "committer": {"login": "14427", "id": 2423611, "node_id": "MDQ6VXNlcjI0MjM2MTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2423611?v=4", "gravatar_id": "", "url": "https://api.github.com/users/14427", "html_url": "https://github.com/14427", "followers_url": "https://api.github.com/users/14427/followers", "following_url": "https://api.github.com/users/14427/following{/other_user}", "gists_url": "https://api.github.com/users/14427/gists{/gist_id}", "starred_url": "https://api.github.com/users/14427/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/14427/subscriptions", "organizations_url": "https://api.github.com/users/14427/orgs", "repos_url": "https://api.github.com/users/14427/repos", "events_url": "https://api.github.com/users/14427/events{/privacy}", "received_events_url": "https://api.github.com/users/14427/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ec5c9af9bef2969203eaba02b168603620cc0c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ec5c9af9bef2969203eaba02b168603620cc0c6", "html_url": "https://github.com/rust-lang/rust/commit/0ec5c9af9bef2969203eaba02b168603620cc0c6"}], "stats": {"total": 142, "additions": 131, "deletions": 11}, "files": [{"sha": "ed7e3f0f6d9e403e2e3f66803fbc8777b2c4fe6e", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 131, "deletions": 11, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/44f8a4401ab37a45ba49db56611d77807bcbce35/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44f8a4401ab37a45ba49db56611d77807bcbce35/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=44f8a4401ab37a45ba49db56611d77807bcbce35", "patch": "@@ -10,7 +10,7 @@ export le;\n export merge_sort;\n export quick_sort;\n export quick_sort3;\n-export timsort;\n+export tim_sort;\n export Sort;\n \n type Le<T> = pure fn(v1: &T, v2: &T) -> bool;\n@@ -415,7 +415,7 @@ struct MergeState<T> {\n             if self.last_hi && size > 0 {\n                 self.mergePt -= self.tmpPt;\n                 move_vec(self.array, self.mergePt, self.tmp, 0, self.tmpPt);\n-            } else if !self.last_hi && size > 0 {\n+            } else if !self.last_hi && size-self.tmpPt > 0 {\n                 move_vec(self.array, self.mergePt,\n                         self.tmp, self.tmpPt, size-self.tmpPt);\n             }\n@@ -982,9 +982,9 @@ mod tests {\n     }\n }\n \n-#[cfg(test)]\n-mod test_timsort {\n-    #[legacy_exports];\n+//#[cfg(test)]\n+//mod test_tim_sort {\n+//    #[legacy_exports];\n     struct CVal {\n         val: ~float,\n     }\n@@ -1004,7 +1004,7 @@ mod test_timsort {\n \n     fn check_sort(v1: &[mut int], v2: &[mut int]) {\n         let len = vec::len::<int>(v1);\n-        timsort::<int>(v1);\n+        tim_sort::<int>(v1);\n         let mut i = 0u;\n         while i < len {\n             log(debug, v2[i]);\n@@ -1037,19 +1037,139 @@ mod test_timsort {\n             check_sort(v1, v2);\n         }\n     }\n-\n-    #[test]\n-    #[should_fail]\n+//}\n+    //#[test]\n+    //#[should_fail]\n     fn crash_test() {\n-        let arr = do vec::from_fn |_i| {\n+        let rng = rand::Rng();\n+        let mut arr = do vec::from_fn(1000) |_i| {\n             let randVal = rng.gen_float();\n             CVal { val: ~randVal }\n         };\n \n         tim_sort(arr);\n         fail ~\"Guarantee the fail\";\n     }\n-}\n+//}\n+\n+//#[cfg(test)]\n+/*mod big_tests {\n+\n+    #[test]\n+    fn sorts_test() {\n+        let low = 5;\n+        let high = 10;\n+\n+        //pure fn le(a: &~float, b: &~float) -> bool { *a <= *b }\n+\n+        //let sorts = ~[\n+            //let s1 = fn(arr: &[mut ~float]) { tim_sort(arr); };\n+            //let s2 = fn(arr: &[mut ~float]) { quick_sort(arr, le); };\n+            //let s3 = fn(arr: &[mut ~float]) { quick_sort3(arr); };\n+            //let s4 = fn(arr: &[mut ~float]) { let rs = merge_sort(arr, le);\n+             //                        for rs.eachi |i, v| {arr[i] = *v}};\n+        //];\n+\n+        tabulate_unique(low, high);\n+        //tabulate_managed(low, high, tim_sort);\n+        //tabulate_linear(low, high, tim_sort);\n+    }\n+\n+    fn multiplyVec<T: Copy>(arr: &[const T], num: uint) -> ~[mut T] {\n+        let size = arr.len();\n+        let res = do vec::from_fn(num) |i| {\n+            arr[i % size]\n+        };\n+        vec::to_mut(res)\n+    }\n+\n+    fn makeRange(n: uint) -> ~[uint] {\n+        let one = do vec::from_fn(n) |i| { i };\n+        let mut two = copy one;\n+        vec::reverse(two);\n+        vec::append(two, one)\n+    }\n+\n+    fn tabulate_unique(lo: uint, hi: uint) {\n+        fn isSorted<T: Ord>(arr: &[const T]) {\n+            for uint::range(0, arr.len()-1) |i| {\n+                if arr[i] > arr[i+1] {\n+                    fail ~\"Array not sorted\";\n+                }\n+            }\n+        }\n+\n+        let rng = rand::Rng();\n+\n+        for uint::range(lo, hi) |i| {\n+            let n = 1 << i;\n+            let arr = do vec::from_fn(n) |_i| {\n+                ~rng.gen_float()\n+            };\n+            let arr = vec::to_mut(arr);\n+\n+            tim_sort(arr); // *sort\n+            isSorted(arr);\n+\n+            vec::reverse(arr);\n+            tim_sort(arr); // \\sort\n+            isSorted(arr);\n+\n+            tim_sort(arr); // /sort\n+            isSorted(arr);\n+\n+            for 3.times {\n+                let i1 = rng.gen_uint_range(0, n);\n+                let i2 = rng.gen_uint_range(0, n);\n+                arr[i1] <-> arr[i2];\n+            }\n+            tim_sort(arr); // 3sort\n+            isSorted(arr);\n+\n+            if n >= 10 {\n+                let size = arr.len();\n+                let mut idx = 1;\n+                while idx <= 10 {\n+                    arr[size-idx] = ~rng.gen_float();\n+                    idx += 1;\n+                }\n+            }\n+            tim_sort(arr); // +sort\n+            isSorted(arr);\n+\n+            for (n/100).times {\n+                let idx = rng.gen_uint_range(0, n);\n+                arr[idx] = ~rng.gen_float();\n+            }\n+            tim_sort(arr);\n+            isSorted(arr);\n+\n+            let arr = if n > 4 {\n+                let part = vec::view(arr, 0, 4);\n+                multiplyVec(part, n)\n+            } else { arr };\n+            tim_sort(arr); // ~sort\n+            isSorted(arr);\n+\n+            let mut arr = vec::from_elem(n, ~(-0.5));\n+            tim_sort(arr); // =sort\n+            isSorted(arr);\n+\n+            let half = n / 2;\n+            let mut arr = makeRange(half).map(|i| ~(*i as float));\n+            tim_sort(arr); // !sort\n+            isSorted(arr);\n+        }\n+    }\n+\n+    fn tabulate_managed(lo: uint, hi: uint, sort: fn(x: &[mut ~float])) {\n+\n+    }\n+\n+    fn tabulate_linear(lo: uint, hi: uint, sort: fn(x: &[mut ~float])) {\n+\n+    }\n+}*/\n \n // Local Variables:\n // mode: rust;"}]}