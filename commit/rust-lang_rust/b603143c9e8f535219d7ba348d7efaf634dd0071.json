{"sha": "b603143c9e8f535219d7ba348d7efaf634dd0071", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2MDMxNDNjOWU4ZjUzNTIxOWQ3YmEzNDhkN2VmYWY2MzRkZDAwNzE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-09-20T10:08:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-20T10:08:15Z"}, "message": "Rollup merge of #76800 - jyn514:usage, r=Mark-Simulacrum\n\nDon't generate bootstrap usage unless it's needed\n\nPreviously, `x.py` would unconditionally run `x.py build` to get the\nhelp message. After https://github.com/rust-lang/rust/issues/76165,\nwhen checking the CI stage was moved into `Config`, that would cause an\nassertion failure (but only only in CI!):\n\n```\nthread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `2`', src/bootstrap/config.rs:619:49\n```\n\nThis changes bootstrap to only generate a help message when it needs\nto (when someone passes `--help`).\n\nr? @Mark-Simulacrum\nThis should fix the CI failures in https://github.com/rust-lang/rust/pull/76797 and https://github.com/rust-lang/rust/pull/75991.", "tree": {"sha": "4cafa892d1b11a32a5ffbae8040e6fcb77020826", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4cafa892d1b11a32a5ffbae8040e6fcb77020826"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b603143c9e8f535219d7ba348d7efaf634dd0071", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfZyoPCRBK7hj4Ov3rIwAAdHIIAChWbQ1CGcs81IkiA8bYC7Ju\njtymwT6TfQUdqy0Z2lUVrVKGPskFLLPZKC25EIT6k71HB/ImsvH/PDywPPFwGG+N\nzoE9sjYUqlJMU2A1qOGCQNVyp5KsJUrVHPWqnNNzF9MK7kT2eue4SQB+Bbj+Rn7E\nz7TxhE5m6o/HLEPIRk4FzaX1hKprLC6cmi610oybU4V5PL8uyFR0YTqubB8uebf+\ncohEh1UBAygDJpAMV6mq12agUEwKEGrMN9hzdIQDiPOk4xMdhF8Dv2Lz36wT4yp4\nlRZ/LsTPa0rJ6ViYHNHJzcqsd+5kBeDbPXnhJkxiq1Qcqe5D+wSeGxwhOPfJCGY=\n=kfX2\n-----END PGP SIGNATURE-----\n", "payload": "tree 4cafa892d1b11a32a5ffbae8040e6fcb77020826\nparent 2911b8cb30cf4fed41a6d6dba4fb0076b6a82e93\nparent c35ce3ff170333d11ccf89e75dc87c49f44a570a\nauthor Ralf Jung <post@ralfj.de> 1600596495 +0200\ncommitter GitHub <noreply@github.com> 1600596495 +0200\n\nRollup merge of #76800 - jyn514:usage, r=Mark-Simulacrum\n\nDon't generate bootstrap usage unless it's needed\n\nPreviously, `x.py` would unconditionally run `x.py build` to get the\nhelp message. After https://github.com/rust-lang/rust/issues/76165,\nwhen checking the CI stage was moved into `Config`, that would cause an\nassertion failure (but only only in CI!):\n\n```\nthread 'main' panicked at 'assertion failed: `(left == right)`\n  left: `1`,\n right: `2`', src/bootstrap/config.rs:619:49\n```\n\nThis changes bootstrap to only generate a help message when it needs\nto (when someone passes `--help`).\n\nr? @Mark-Simulacrum\nThis should fix the CI failures in https://github.com/rust-lang/rust/pull/76797 and https://github.com/rust-lang/rust/pull/75991.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b603143c9e8f535219d7ba348d7efaf634dd0071", "html_url": "https://github.com/rust-lang/rust/commit/b603143c9e8f535219d7ba348d7efaf634dd0071", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b603143c9e8f535219d7ba348d7efaf634dd0071/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2911b8cb30cf4fed41a6d6dba4fb0076b6a82e93", "url": "https://api.github.com/repos/rust-lang/rust/commits/2911b8cb30cf4fed41a6d6dba4fb0076b6a82e93", "html_url": "https://github.com/rust-lang/rust/commit/2911b8cb30cf4fed41a6d6dba4fb0076b6a82e93"}, {"sha": "c35ce3ff170333d11ccf89e75dc87c49f44a570a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c35ce3ff170333d11ccf89e75dc87c49f44a570a", "html_url": "https://github.com/rust-lang/rust/commit/c35ce3ff170333d11ccf89e75dc87c49f44a570a"}], "stats": {"total": 62, "additions": 32, "deletions": 30}, "files": [{"sha": "842c84a3e5cd6dcd82220e36c49133be5da00db2", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 32, "deletions": 30, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/b603143c9e8f535219d7ba348d7efaf634dd0071/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b603143c9e8f535219d7ba348d7efaf634dd0071/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=b603143c9e8f535219d7ba348d7efaf634dd0071", "patch": "@@ -98,7 +98,6 @@ impl Default for Subcommand {\n \n impl Flags {\n     pub fn parse(args: &[String]) -> Flags {\n-        let mut extra_help = String::new();\n         let mut subcommand_help = String::from(\n             \"\\\n Usage: x.py <subcommand> [options] [<paths>...]\n@@ -170,16 +169,6 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n             \"VALUE\",\n         );\n \n-        // fn usage()\n-        let usage =\n-            |exit_code: i32, opts: &Options, subcommand_help: &str, extra_help: &str| -> ! {\n-                println!(\"{}\", opts.usage(subcommand_help));\n-                if !extra_help.is_empty() {\n-                    println!(\"{}\", extra_help);\n-                }\n-                process::exit(exit_code);\n-            };\n-\n         // We can't use getopt to parse the options until we have completed specifying which\n         // options are valid, but under the current implementation, some options are conditional on\n         // the subcommand. Therefore we must manually identify the subcommand first, so that we can\n@@ -263,12 +252,38 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\",\n             _ => {}\n         };\n \n+        // fn usage()\n+        let usage = |exit_code: i32, opts: &Options, verbose: bool, subcommand_help: &str| -> ! {\n+            let mut extra_help = String::new();\n+\n+            // All subcommands except `clean` can have an optional \"Available paths\" section\n+            if verbose {\n+                let config = Config::parse(&[\"build\".to_string()]);\n+                let build = Build::new(config);\n+\n+                let maybe_rules_help = Builder::get_help(&build, subcommand.as_str());\n+                extra_help.push_str(maybe_rules_help.unwrap_or_default().as_str());\n+            } else if !(subcommand.as_str() == \"clean\" || subcommand.as_str() == \"fmt\") {\n+                extra_help.push_str(\n+                    format!(\"Run `./x.py {} -h -v` to see a list of available paths.\", subcommand)\n+                        .as_str(),\n+                );\n+            }\n+\n+            println!(\"{}\", opts.usage(subcommand_help));\n+            if !extra_help.is_empty() {\n+                println!(\"{}\", extra_help);\n+            }\n+            process::exit(exit_code);\n+        };\n+\n         // Done specifying what options are possible, so do the getopts parsing\n         let matches = opts.parse(&args[..]).unwrap_or_else(|e| {\n             // Invalid argument/option format\n             println!(\"\\n{}\\n\", e);\n-            usage(1, &opts, &subcommand_help, &extra_help);\n+            usage(1, &opts, false, &subcommand_help);\n         });\n+\n         // Extra sanity check to make sure we didn't hit this crazy corner case:\n         //\n         //     ./x.py --frobulate clean build\n@@ -436,24 +451,11 @@ Arguments:\n         let paths = matches.free[1..].iter().map(|p| p.into()).collect::<Vec<PathBuf>>();\n \n         let cfg_file = env::var_os(\"BOOTSTRAP_CONFIG\").map(PathBuf::from);\n-\n-        // All subcommands except `clean` can have an optional \"Available paths\" section\n-        if matches.opt_present(\"verbose\") {\n-            let config = Config::parse(&[\"build\".to_string()]);\n-            let build = Build::new(config);\n-\n-            let maybe_rules_help = Builder::get_help(&build, subcommand.as_str());\n-            extra_help.push_str(maybe_rules_help.unwrap_or_default().as_str());\n-        } else if !(subcommand.as_str() == \"clean\" || subcommand.as_str() == \"fmt\") {\n-            extra_help.push_str(\n-                format!(\"Run `./x.py {} -h -v` to see a list of available paths.\", subcommand)\n-                    .as_str(),\n-            );\n-        }\n+        let verbose = matches.opt_present(\"verbose\");\n \n         // User passed in -h/--help?\n         if matches.opt_present(\"help\") {\n-            usage(0, &opts, &subcommand_help, &extra_help);\n+            usage(0, &opts, verbose, &subcommand_help);\n         }\n \n         let cmd = match subcommand.as_str() {\n@@ -483,7 +485,7 @@ Arguments:\n             \"clean\" => {\n                 if !paths.is_empty() {\n                     println!(\"\\nclean does not take a path argument\\n\");\n-                    usage(1, &opts, &subcommand_help, &extra_help);\n+                    usage(1, &opts, verbose, &subcommand_help);\n                 }\n \n                 Subcommand::Clean { all: matches.opt_present(\"all\") }\n@@ -494,12 +496,12 @@ Arguments:\n             \"run\" | \"r\" => {\n                 if paths.is_empty() {\n                     println!(\"\\nrun requires at least a path!\\n\");\n-                    usage(1, &opts, &subcommand_help, &extra_help);\n+                    usage(1, &opts, verbose, &subcommand_help);\n                 }\n                 Subcommand::Run { paths }\n             }\n             _ => {\n-                usage(1, &opts, &subcommand_help, &extra_help);\n+                usage(1, &opts, verbose, &subcommand_help);\n             }\n         };\n "}]}