{"sha": "d42346fed61f706d68fe888631a41ea5f2752d7f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0MjM0NmZlZDYxZjcwNmQ2OGZlODg4NjMxYTQxZWE1ZjI3NTJkN2Y=", "commit": {"author": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-04-11T20:54:18Z"}, "committer": {"name": "Benjamin Coenen", "email": "5719034+bnjjj@users.noreply.github.com", "date": "2020-04-11T20:54:18Z"}, "message": "Improve autocompletion by looking on the type and name\n\nSigned-off-by: Benjamin Coenen <5719034+bnjjj@users.noreply.github.com>", "tree": {"sha": "b9e7eac005c4c6200d6a95f191e00cb738ad31b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9e7eac005c4c6200d6a95f191e00cb738ad31b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d42346fed61f706d68fe888631a41ea5f2752d7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d42346fed61f706d68fe888631a41ea5f2752d7f", "html_url": "https://github.com/rust-lang/rust/commit/d42346fed61f706d68fe888631a41ea5f2752d7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d42346fed61f706d68fe888631a41ea5f2752d7f/comments", "author": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bnjjj", "id": 5719034, "node_id": "MDQ6VXNlcjU3MTkwMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/5719034?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bnjjj", "html_url": "https://github.com/bnjjj", "followers_url": "https://api.github.com/users/bnjjj/followers", "following_url": "https://api.github.com/users/bnjjj/following{/other_user}", "gists_url": "https://api.github.com/users/bnjjj/gists{/gist_id}", "starred_url": "https://api.github.com/users/bnjjj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bnjjj/subscriptions", "organizations_url": "https://api.github.com/users/bnjjj/orgs", "repos_url": "https://api.github.com/users/bnjjj/repos", "events_url": "https://api.github.com/users/bnjjj/events{/privacy}", "received_events_url": "https://api.github.com/users/bnjjj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1317d692321ba5ba8f138067ebefbb9559d098d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1317d692321ba5ba8f138067ebefbb9559d098d", "html_url": "https://github.com/rust-lang/rust/commit/c1317d692321ba5ba8f138067ebefbb9559d098d"}], "stats": {"total": 224, "additions": 194, "deletions": 30}, "files": [{"sha": "358b041aa97e1302c403a1f1f4b645a0317de81d", "filename": "crates/ra_ide/src/completion/complete_dot.rs", "status": "modified", "additions": 122, "deletions": 3, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/d42346fed61f706d68fe888631a41ea5f2752d7f/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42346fed61f706d68fe888631a41ea5f2752d7f/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=d42346fed61f706d68fe888631a41ea5f2752d7f", "patch": "@@ -1,13 +1,14 @@\n //! FIXME: write short doc here\n \n-use hir::{HasVisibility, Type};\n+use hir::{HasVisibility, HirDisplay, Type};\n \n use crate::completion::completion_item::CompletionKind;\n use crate::{\n     completion::{completion_context::CompletionContext, completion_item::Completions},\n     CompletionItem,\n };\n use rustc_hash::FxHashSet;\n+use std::cmp::Ordering;\n \n /// Complete dot accesses, i.e. fields or methods (and .await syntax).\n pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n@@ -37,7 +38,31 @@ pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n \n fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: &Type) {\n     for receiver in receiver.autoderef(ctx.db) {\n-        for (field, ty) in receiver.fields(ctx.db) {\n+        let mut fields = receiver.fields(ctx.db);\n+        if let Some(call_info) = &ctx.call_info {\n+            if let Some(active_parameter_type) = call_info.active_parameter_type() {\n+                let active_parameter_name = call_info.active_parameter_name().unwrap();\n+                fields.sort_by(|a, b| {\n+                    // For the same type\n+                    if active_parameter_type == a.1.display(ctx.db).to_string() {\n+                        // If same type + same name then go top position\n+                        if active_parameter_name == a.0.name(ctx.db).to_string() {\n+                            Ordering::Less\n+                        } else {\n+                            if active_parameter_type == b.1.display(ctx.db).to_string() {\n+                                Ordering::Equal\n+                            } else {\n+                                Ordering::Less\n+                            }\n+                        }\n+                    } else {\n+                        Ordering::Greater\n+                    }\n+                });\n+            }\n+        }\n+\n+        for (field, ty) in fields {\n             if ctx.scope().module().map_or(false, |m| !field.is_visible_from(ctx.db, m)) {\n                 // Skip private field. FIXME: If the definition location of the\n                 // field is editable, we should show the completion\n@@ -47,6 +72,7 @@ fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: &Ty\n         }\n         for (i, ty) in receiver.tuple_fields(ctx.db).into_iter().enumerate() {\n             // FIXME: Handle visibility\n+            // TODO: add the same behavior with type ?\n             acc.add_tuple_field(ctx, i, &ty);\n         }\n     }\n@@ -70,13 +96,20 @@ fn complete_methods(acc: &mut Completions, ctx: &CompletionContext, receiver: &T\n \n #[cfg(test)]\n mod tests {\n-    use crate::completion::{test_utils::do_completion, CompletionItem, CompletionKind};\n+    use crate::completion::{\n+        test_utils::{do_completion, do_completion_without_sort},\n+        CompletionItem, CompletionKind,\n+    };\n     use insta::assert_debug_snapshot;\n \n     fn do_ref_completion(code: &str) -> Vec<CompletionItem> {\n         do_completion(code, CompletionKind::Reference)\n     }\n \n+    fn do_ref_completion_without_sort(code: &str) -> Vec<CompletionItem> {\n+        do_completion_without_sort(code, CompletionKind::Reference)\n+    }\n+\n     #[test]\n     fn test_struct_field_completion() {\n         assert_debug_snapshot!(\n@@ -103,6 +136,92 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn test_struct_field_completion_in_func_call() {\n+        assert_debug_snapshot!(\n+        do_ref_completion_without_sort(\n+                r\"\n+                struct A { another_field: i64, the_field: u32, my_string: String }\n+                fn test(my_param: u32) -> u32 { my_param }\n+                fn foo(a: A) {\n+                    test(a.<|>)\n+                }\n+                \",\n+        ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"the_field\",\n+                source_range: [201; 201),\n+                delete: [201; 201),\n+                insert: \"the_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+            CompletionItem {\n+                label: \"another_field\",\n+                source_range: [201; 201),\n+                delete: [201; 201),\n+                insert: \"another_field\",\n+                kind: Field,\n+                detail: \"i64\",\n+            },\n+            CompletionItem {\n+                label: \"my_string\",\n+                source_range: [201; 201),\n+                delete: [201; 201),\n+                insert: \"my_string\",\n+                kind: Field,\n+                detail: \"{unknown}\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n+    #[test]\n+    fn test_struct_field_completion_in_func_call_with_type_and_name() {\n+        assert_debug_snapshot!(\n+        do_ref_completion_without_sort(\n+                r\"\n+                struct A { another_field: i64, another_good_type: u32, the_field: u32 }\n+                fn test(the_field: u32) -> u32 { the_field }\n+                fn foo(a: A) {\n+                    test(a.<|>)\n+                }\n+                \",\n+        ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"the_field\",\n+                source_range: [208; 208),\n+                delete: [208; 208),\n+                insert: \"the_field\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+            CompletionItem {\n+                label: \"another_good_type\",\n+                source_range: [208; 208),\n+                delete: [208; 208),\n+                insert: \"another_good_type\",\n+                kind: Field,\n+                detail: \"u32\",\n+            },\n+            CompletionItem {\n+                label: \"another_field\",\n+                source_range: [208; 208),\n+                delete: [208; 208),\n+                insert: \"another_field\",\n+                kind: Field,\n+                detail: \"i64\",\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n     #[test]\n     fn test_struct_field_completion_self() {\n         assert_debug_snapshot!("}, {"sha": "fddaf21e498cc32762b5c3a6b9aa4a12f21c9c54", "filename": "crates/ra_ide/src/completion/completion_context.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d42346fed61f706d68fe888631a41ea5f2752d7f/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42346fed61f706d68fe888631a41ea5f2752d7f/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_context.rs?ref=d42346fed61f706d68fe888631a41ea5f2752d7f", "patch": "@@ -1,17 +1,19 @@\n //! FIXME: write short doc here\n \n-use hir::{Semantics, SemanticsScope};\n+use hir::{db::HirDatabase, Semantics, SemanticsScope};\n use ra_db::SourceDatabase;\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     algo::{find_covering_element, find_node_at_offset},\n-    ast, AstNode,\n+    ast,\n+    ast::ArgListOwner,\n+    AstNode,\n     SyntaxKind::*,\n     SyntaxNode, SyntaxToken, TextRange, TextUnit,\n };\n use ra_text_edit::AtomTextEdit;\n \n-use crate::{completion::CompletionConfig, FilePosition};\n+use crate::{call_info::call_info, completion::CompletionConfig, CallInfo, FilePosition};\n \n /// `CompletionContext` is created early during completion to figure out, where\n /// exactly is the cursor, syntax-wise.\n@@ -21,6 +23,7 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) db: &'a RootDatabase,\n     pub(super) config: &'a CompletionConfig,\n     pub(super) offset: TextUnit,\n+    pub(super) file_position: FilePosition,\n     /// The token before the cursor, in the original file.\n     pub(super) original_token: SyntaxToken,\n     /// The token before the cursor, in the macro-expanded file.\n@@ -32,6 +35,7 @@ pub(crate) struct CompletionContext<'a> {\n     pub(super) record_lit_syntax: Option<ast::RecordLit>,\n     pub(super) record_lit_pat: Option<ast::RecordPat>,\n     pub(super) impl_def: Option<ast::ImplDef>,\n+    pub(super) call_info: Option<CallInfo>,\n     pub(super) is_param: bool,\n     /// If a name-binding or reference to a const in a pattern.\n     /// Irrefutable patterns (like let) are excluded.\n@@ -88,9 +92,11 @@ impl<'a> CompletionContext<'a> {\n             original_token,\n             token,\n             offset: position.offset,\n+            file_position: position,\n             krate,\n             name_ref_syntax: None,\n             function_syntax: None,\n+            call_info: None,\n             use_item_syntax: None,\n             record_lit_syntax: None,\n             record_lit_pat: None,\n@@ -253,6 +259,8 @@ impl<'a> CompletionContext<'a> {\n         self.use_item_syntax =\n             self.sema.ancestors_with_macros(self.token.parent()).find_map(ast::UseItem::cast);\n \n+        self.call_info = call_info(self.db, self.file_position);\n+\n         self.function_syntax = self\n             .sema\n             .ancestors_with_macros(self.token.parent())"}, {"sha": "8be2d02d0efe28163121146183c78ea2386bd5cc", "filename": "crates/ra_ide/src/completion/presentation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d42346fed61f706d68fe888631a41ea5f2752d7f/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42346fed61f706d68fe888631a41ea5f2752d7f/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=d42346fed61f706d68fe888631a41ea5f2752d7f", "patch": "@@ -367,7 +367,7 @@ mod tests {\n         ra_fixture: &str,\n         options: CompletionConfig,\n     ) -> Vec<CompletionItem> {\n-        do_completion_with_options(ra_fixture, CompletionKind::Reference, &options)\n+        do_completion_with_options(ra_fixture, CompletionKind::Reference, &options, true)\n     }\n \n     #[test]"}, {"sha": "f54d15a90330b08a2491f8aa97a7cee267880d8c", "filename": "crates/ra_ide/src/completion/test_utils.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d42346fed61f706d68fe888631a41ea5f2752d7f/crates%2Fra_ide%2Fsrc%2Fcompletion%2Ftest_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42346fed61f706d68fe888631a41ea5f2752d7f/crates%2Fra_ide%2Fsrc%2Fcompletion%2Ftest_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Ftest_utils.rs?ref=d42346fed61f706d68fe888631a41ea5f2752d7f", "patch": "@@ -7,13 +7,18 @@ use crate::{\n };\n \n pub(crate) fn do_completion(code: &str, kind: CompletionKind) -> Vec<CompletionItem> {\n-    do_completion_with_options(code, kind, &CompletionConfig::default())\n+    do_completion_with_options(code, kind, &CompletionConfig::default(), true)\n+}\n+\n+pub(crate) fn do_completion_without_sort(code: &str, kind: CompletionKind) -> Vec<CompletionItem> {\n+    do_completion_with_options(code, kind, &CompletionConfig::default(), false)\n }\n \n pub(crate) fn do_completion_with_options(\n     code: &str,\n     kind: CompletionKind,\n     options: &CompletionConfig,\n+    sort_by_key: bool,\n ) -> Vec<CompletionItem> {\n     let (analysis, position) = if code.contains(\"//-\") {\n         analysis_and_position(code)\n@@ -24,6 +29,8 @@ pub(crate) fn do_completion_with_options(\n     let completion_items: Vec<CompletionItem> = completions.into();\n     let mut kind_completions: Vec<CompletionItem> =\n         completion_items.into_iter().filter(|c| c.completion_kind == kind).collect();\n-    kind_completions.sort_by_key(|c| c.label().to_owned());\n+    if sort_by_key {\n+        kind_completions.sort_by_key(|c| c.label().to_owned());\n+    }\n     kind_completions\n }"}, {"sha": "e58a78271737e7e0cb103d6362f1e8277c2dd194", "filename": "crates/ra_ide/src/display/function_signature.rs", "status": "modified", "additions": 36, "deletions": 21, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d42346fed61f706d68fe888631a41ea5f2752d7f/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42346fed61f706d68fe888631a41ea5f2752d7f/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs?ref=d42346fed61f706d68fe888631a41ea5f2752d7f", "patch": "@@ -36,6 +36,8 @@ pub struct FunctionSignature {\n     pub parameters: Vec<String>,\n     /// Parameter names of the function\n     pub parameter_names: Vec<String>,\n+    /// Parameter types of the function\n+    pub parameter_types: Vec<String>,\n     /// Optional return type\n     pub ret_type: Option<String>,\n     /// Where predicates\n@@ -62,14 +64,14 @@ impl FunctionSignature {\n             return None;\n         };\n \n-        let params = st\n-            .fields(db)\n-            .into_iter()\n-            .map(|field: hir::StructField| {\n-                let ty = field.signature_ty(db);\n-                format!(\"{}\", ty.display(db))\n-            })\n-            .collect();\n+        let mut params = vec![];\n+        let mut parameter_types = vec![];\n+        for field in st.fields(db).into_iter() {\n+            let ty = field.signature_ty(db);\n+            let raw_param = format!(\"{}\", ty.display(db));\n+            parameter_types.push(raw_param.split(':').nth(1).unwrap()[1..].to_string());\n+            params.push(raw_param);\n+        }\n \n         Some(\n             FunctionSignature {\n@@ -79,6 +81,7 @@ impl FunctionSignature {\n                 ret_type: node.name().map(|n| n.text().to_string()),\n                 parameters: params,\n                 parameter_names: vec![],\n+                parameter_types,\n                 generic_parameters: generic_parameters(&node),\n                 where_predicates: where_predicates(&node),\n                 doc: None,\n@@ -99,15 +102,14 @@ impl FunctionSignature {\n \n         let name = format!(\"{}::{}\", parent_name, variant.name(db));\n \n-        let params = variant\n-            .fields(db)\n-            .into_iter()\n-            .map(|field: hir::StructField| {\n-                let name = field.name(db);\n-                let ty = field.signature_ty(db);\n-                format!(\"{}: {}\", name, ty.display(db))\n-            })\n-            .collect();\n+        let mut params = vec![];\n+        let mut parameter_types = vec![];\n+        for field in variant.fields(db).into_iter() {\n+            let ty = field.signature_ty(db);\n+            let raw_param = format!(\"{}\", ty.display(db));\n+            parameter_types.push(raw_param.split(':').nth(1).unwrap()[1..].to_string());\n+            params.push(raw_param);\n+        }\n \n         Some(\n             FunctionSignature {\n@@ -117,6 +119,7 @@ impl FunctionSignature {\n                 ret_type: None,\n                 parameters: params,\n                 parameter_names: vec![],\n+                parameter_types,\n                 generic_parameters: vec![],\n                 where_predicates: vec![],\n                 doc: None,\n@@ -139,6 +142,7 @@ impl FunctionSignature {\n                 ret_type: None,\n                 parameters: params,\n                 parameter_names: vec![],\n+                parameter_types: vec![],\n                 generic_parameters: vec![],\n                 where_predicates: vec![],\n                 doc: None,\n@@ -151,18 +155,28 @@ impl FunctionSignature {\n \n impl From<&'_ ast::FnDef> for FunctionSignature {\n     fn from(node: &ast::FnDef) -> FunctionSignature {\n-        fn param_list(node: &ast::FnDef) -> (bool, Vec<String>) {\n+        fn param_list(node: &ast::FnDef) -> (bool, Vec<String>, Vec<String>) {\n             let mut res = vec![];\n+            let mut res_types = vec![];\n             let mut has_self_param = false;\n             if let Some(param_list) = node.param_list() {\n                 if let Some(self_param) = param_list.self_param() {\n                     has_self_param = true;\n-                    res.push(self_param.syntax().text().to_string())\n+                    let raw_param = self_param.syntax().text().to_string();\n+\n+                    // TODO: better solution ?\n+                    res_types.push(\n+                        raw_param.split(':').nth(1).unwrap_or_else(|| \" Self\")[1..].to_string(),\n+                    );\n+                    res.push(raw_param);\n                 }\n \n                 res.extend(param_list.params().map(|param| param.syntax().text().to_string()));\n+                res_types.extend(param_list.params().map(|param| {\n+                    param.syntax().text().to_string().split(':').nth(1).unwrap()[1..].to_string()\n+                }));\n             }\n-            (has_self_param, res)\n+            (has_self_param, res, res_types)\n         }\n \n         fn param_name_list(node: &ast::FnDef) -> Vec<String> {\n@@ -192,7 +206,7 @@ impl From<&'_ ast::FnDef> for FunctionSignature {\n             res\n         }\n \n-        let (has_self_param, parameters) = param_list(node);\n+        let (has_self_param, parameters, parameter_types) = param_list(node);\n \n         FunctionSignature {\n             kind: CallableKind::Function,\n@@ -204,6 +218,7 @@ impl From<&'_ ast::FnDef> for FunctionSignature {\n                 .map(|n| n.syntax().text().to_string()),\n             parameters,\n             parameter_names: param_name_list(node),\n+            parameter_types,\n             generic_parameters: generic_parameters(node),\n             where_predicates: where_predicates(node),\n             // docs are processed separately"}, {"sha": "357c01cdf8316fe5fd384546e22621574895fc0f", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d42346fed61f706d68fe888631a41ea5f2752d7f/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d42346fed61f706d68fe888631a41ea5f2752d7f/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=d42346fed61f706d68fe888631a41ea5f2752d7f", "patch": "@@ -127,6 +127,21 @@ pub struct CallInfo {\n     pub active_parameter: Option<usize>,\n }\n \n+impl CallInfo {\n+    pub fn active_parameter_type(&self) -> Option<String> {\n+        if let Some(id) = self.active_parameter {\n+            return self.signature.parameter_types.get(id).map(|param_ty| param_ty.clone());\n+        }\n+        None\n+    }\n+    pub fn active_parameter_name(&self) -> Option<String> {\n+        if let Some(id) = self.active_parameter {\n+            return self.signature.parameter_names.get(id).map(|param_ty| param_ty.clone());\n+        }\n+        None\n+    }\n+}\n+\n /// `AnalysisHost` stores the current state of the world.\n #[derive(Debug)]\n pub struct AnalysisHost {"}]}