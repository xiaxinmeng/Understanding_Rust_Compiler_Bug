{"sha": "e2e3a887710b281ccc0e4e841c6fd4d5f95d85fc", "node_id": "C_kwDOAAsO6NoAKGUyZTNhODg3NzEwYjI4MWNjYzBlNGU4NDFjNmZkNGQ1Zjk1ZDg1ZmM", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-07-26T22:37:00Z"}, "committer": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-07-26T22:37:00Z"}, "message": "Explain how *mut [T] helps, and how we rely on the check in split_at_mut", "tree": {"sha": "c07fb4ea0f77209eeee0d6a3b4f9a4c7a2de286f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c07fb4ea0f77209eeee0d6a3b4f9a4c7a2de286f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2e3a887710b281ccc0e4e841c6fd4d5f95d85fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2e3a887710b281ccc0e4e841c6fd4d5f95d85fc", "html_url": "https://github.com/rust-lang/rust/commit/e2e3a887710b281ccc0e4e841c6fd4d5f95d85fc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2e3a887710b281ccc0e4e841c6fd4d5f95d85fc/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7919e4208b0a7937a1407523c7f4181aca8c85b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/7919e4208b0a7937a1407523c7f4181aca8c85b7", "html_url": "https://github.com/rust-lang/rust/commit/7919e4208b0a7937a1407523c7f4181aca8c85b7"}], "stats": {"total": 75, "additions": 55, "deletions": 20}, "files": [{"sha": "fdbc9fd0b5b192362d72f7d824fb1dfcfdb1efeb", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 55, "deletions": 20, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/e2e3a887710b281ccc0e4e841c6fd4d5f95d85fc/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2e3a887710b281ccc0e4e841c6fd4d5f95d85fc/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=e2e3a887710b281ccc0e4e841c6fd4d5f95d85fc", "patch": "@@ -1629,6 +1629,11 @@ unsafe impl<'a, T> TrustedRandomAccessNoCoerce for Chunks<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub struct ChunksMut<'a, T: 'a> {\n+    // This slice pointer must point at a valid region of T with at least length v.len(). Normally,\n+    // those requirements would mean that we could instead use a &mut [T] here, but we cannot\n+    // because __iterator_get_unchecked needs to return &mut [T], which guarantees certain aliasing\n+    // properties that we cannot uphold if we hold on to the full original &mut [T]. Wrapping a raw\n+    // slice instead lets us hand out non-overlapping &mut [T] subslices of the slice we wrap.\n     v: *mut [T],\n     chunk_size: usize,\n     _marker: PhantomData<&'a mut T>,\n@@ -1651,10 +1656,10 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n             None\n         } else {\n             let sz = cmp::min(self.v.len(), self.chunk_size);\n-            // SAFETY: sz cannot exceed the slice length based on the calculation above\n+            // SAFETY: This type ensures that any split_at_mut on self.v is valid.\n             let (head, tail) = unsafe { self.v.split_at_mut(sz) };\n             self.v = tail;\n-            // SAFETY: Nothing points to or will point to the contents of this slice\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n             Some(unsafe { &mut *head })\n         }\n     }\n@@ -1687,12 +1692,12 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n                 Some(sum) => cmp::min(self.v.len(), sum),\n                 None => self.v.len(),\n             };\n-            // SAFETY: end is inbounds because we compared above against self.v.len()\n+            // SAFETY: This type ensures that any split_at_mut on self.v is valid.\n             let (head, tail) = unsafe { self.v.split_at_mut(end) };\n-            // SAFETY: start is inbounds because\n+            // SAFETY: This type ensures that any split_at_mut on self.v is valid.\n             let (_, nth) = unsafe { head.split_at_mut(start) };\n             self.v = tail;\n-            // SAFETY: Nothing points to or will point to the contents of this slice\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n             Some(unsafe { &mut *nth })\n         }\n     }\n@@ -1703,7 +1708,7 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n             None\n         } else {\n             let start = (self.v.len() - 1) / self.chunk_size * self.chunk_size;\n-            // SAFETY: Nothing points to or will point to the contents of this slice\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n             Some(unsafe { &mut *self.v.get_unchecked_mut(start..) })\n         }\n     }\n@@ -1736,7 +1741,7 @@ impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n             // SAFETY: Similar to `Chunks::next_back`\n             let (head, tail) = unsafe { self.v.split_at_mut_unchecked(len - sz) };\n             self.v = head;\n-            // SAFETY: Nothing points to or will point to the contents of this slice\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n             Some(unsafe { &mut *tail })\n         }\n     }\n@@ -1753,11 +1758,12 @@ impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n                 Some(res) => cmp::min(self.v.len(), res),\n                 None => self.v.len(),\n             };\n-            // SAFETY: end is inbounds because we compared above against self.v.len()\n+            // SAFETY: This type ensures that any split_at_mut on self.v is valid.\n             let (temp, _tail) = unsafe { self.v.split_at_mut(end) };\n+            // SAFETY: This type ensures that any split_at_mut on self.v is valid.\n             let (head, nth_back) = unsafe { temp.split_at_mut(start) };\n             self.v = head;\n-            // SAFETY: Nothing points to or will point to the contents of this slice\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n             Some(unsafe { &mut *nth_back })\n         }\n     }\n@@ -1964,6 +1970,11 @@ unsafe impl<'a, T> TrustedRandomAccessNoCoerce for ChunksExact<'a, T> {\n #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub struct ChunksExactMut<'a, T: 'a> {\n+    // This slice pointer must point at a valid region of T with at least length v.len(). Normally,\n+    // those requirements would mean that we could instead use a &mut [T] here, but we cannot\n+    // because __iterator_get_unchecked needs to return &mut [T], which guarantees certain aliasing\n+    // properties that we cannot uphold if we hold on to the full original &mut [T]. Wrapping a raw\n+    // slice instead lets us hand out non-overlapping &mut [T] subslices of the slice we wrap.\n     v: *mut [T],\n     rem: &'a mut [T], // The iterator never yields from here, so this can be unique\n     chunk_size: usize,\n@@ -2002,7 +2013,7 @@ impl<'a, T> Iterator for ChunksExactMut<'a, T> {\n             // SAFETY: self.chunk_size is inbounds because we compared above against self.v.len()\n             let (head, tail) = unsafe { self.v.split_at_mut(self.chunk_size) };\n             self.v = tail;\n-            // SAFETY: Nothing points to or will point to the contents of this slice\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n             Some(unsafe { &mut *head })\n         }\n     }\n@@ -2025,6 +2036,7 @@ impl<'a, T> Iterator for ChunksExactMut<'a, T> {\n             self.v = &mut [];\n             None\n         } else {\n+            // SAFETY: This type ensures that any split_at_mut on self.v is valid.\n             let (_, snd) = unsafe { self.v.split_at_mut(start) };\n             self.v = snd;\n             self.next()\n@@ -2053,7 +2065,7 @@ impl<'a, T> DoubleEndedIterator for ChunksExactMut<'a, T> {\n             // SAFETY: This subtraction is inbounds because of the check above\n             let (head, tail) = unsafe { self.v.split_at_mut(self.v.len() - self.chunk_size) };\n             self.v = head;\n-            // SAFETY: Nothing points to or will point to the contents of this slice\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n             Some(unsafe { &mut *tail })\n         }\n     }\n@@ -2067,10 +2079,12 @@ impl<'a, T> DoubleEndedIterator for ChunksExactMut<'a, T> {\n         } else {\n             let start = (len - 1 - n) * self.chunk_size;\n             let end = start + self.chunk_size;\n+            // SAFETY: This type ensures that any split_at_mut on self.v is valid.\n             let (temp, _tail) = unsafe { mem::replace(&mut self.v, &mut []).split_at_mut(end) };\n+            // SAFETY: This type ensures that any split_at_mut on self.v is valid.\n             let (head, nth_back) = unsafe { temp.split_at_mut(start) };\n             self.v = head;\n-            // SAFETY: Nothing points to or will point to the contents of this slice\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n             Some(unsafe { &mut *nth_back })\n         }\n     }\n@@ -2655,6 +2669,11 @@ unsafe impl<'a, T> TrustedRandomAccessNoCoerce for RChunks<'a, T> {\n #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub struct RChunksMut<'a, T: 'a> {\n+    // This slice pointer must point at a valid region of T with at least length v.len(). Normally,\n+    // those requirements would mean that we could instead use a &mut [T] here, but we cannot\n+    // because __iterator_get_unchecked needs to return &mut [T], which guarantees certain aliasing\n+    // properties that we cannot uphold if we hold on to the full original &mut [T]. Wrapping a raw\n+    // slice instead lets us hand out non-overlapping &mut [T] subslices of the slice we wrap.\n     v: *mut [T],\n     chunk_size: usize,\n     _marker: PhantomData<&'a mut T>,\n@@ -2685,7 +2704,7 @@ impl<'a, T> Iterator for RChunksMut<'a, T> {\n             // `self.v.len()` (e.g. `len`) and `self.chunk_size`.\n             let (head, tail) = unsafe { self.v.split_at_mut_unchecked(len - sz) };\n             self.v = head;\n-            // SAFETY: Nothing points to or will point to the contents of this slice\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n             Some(unsafe { &mut *tail })\n         }\n     }\n@@ -2720,10 +2739,14 @@ impl<'a, T> Iterator for RChunksMut<'a, T> {\n                 Some(sum) => sum,\n                 None => 0,\n             };\n+            // SAFETY: This type ensures that self.v is a valid pointer with a correct len.\n+            // Therefore the bounds check in split_at_mut guarantess the split point is inbounds.\n             let (head, tail) = unsafe { self.v.split_at_mut(start) };\n+            // SAFETY: This type ensures that self.v is a valid pointer with a correct len.\n+            // Therefore the bounds check in split_at_mut guarantess the split point is inbounds.\n             let (nth, _) = unsafe { tail.split_at_mut(end - start) };\n             self.v = head;\n-            // SAFETY: Nothing points to or will point to the contents of this slice\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n             Some(unsafe { &mut *nth })\n         }\n     }\n@@ -2735,7 +2758,7 @@ impl<'a, T> Iterator for RChunksMut<'a, T> {\n         } else {\n             let rem = self.v.len() % self.chunk_size;\n             let end = if rem == 0 { self.chunk_size } else { rem };\n-            // SAFETY: Nothing points to or will point to the contents of this slice\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n             Some(unsafe { &mut *self.v.get_unchecked_mut(0..end) })\n         }\n     }\n@@ -2764,7 +2787,7 @@ impl<'a, T> DoubleEndedIterator for RChunksMut<'a, T> {\n             // SAFETY: Similar to `Chunks::next_back`\n             let (head, tail) = unsafe { self.v.split_at_mut_unchecked(sz) };\n             self.v = tail;\n-            // SAFETY: Nothing points to or will point to the contents of this slice\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n             Some(unsafe { &mut *head })\n         }\n     }\n@@ -2780,10 +2803,12 @@ impl<'a, T> DoubleEndedIterator for RChunksMut<'a, T> {\n             let offset_from_end = (len - 1 - n) * self.chunk_size;\n             let end = self.v.len() - offset_from_end;\n             let start = end.saturating_sub(self.chunk_size);\n+            // SAFETY: This type ensures that any split_at_mut on self.v is valid.\n             let (tmp, tail) = unsafe { self.v.split_at_mut(end) };\n+            // SAFETY: This type ensures that any split_at_mut on self.v is valid.\n             let (_, nth_back) = unsafe { tmp.split_at_mut(start) };\n             self.v = tail;\n-            // SAFETY: Nothing points to or will point to the contents of this slice\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n             Some(unsafe { &mut *nth_back })\n         }\n     }\n@@ -2993,6 +3018,11 @@ unsafe impl<'a, T> TrustedRandomAccessNoCoerce for RChunksExact<'a, T> {\n #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub struct RChunksExactMut<'a, T: 'a> {\n+    // This slice pointer must point at a valid region of T with at least length v.len(). Normally,\n+    // those requirements would mean that we could instead use a &mut [T] here, but we cannot\n+    // because __iterator_get_unchecked needs to return &mut [T], which guarantees certain aliasing\n+    // properties that we cannot uphold if we hold on to the full original &mut [T]. Wrapping a raw\n+    // slice instead lets us hand out non-overlapping &mut [T] subslices of the slice we wrap.\n     v: *mut [T],\n     rem: &'a mut [T],\n     chunk_size: usize,\n@@ -3027,9 +3057,10 @@ impl<'a, T> Iterator for RChunksExactMut<'a, T> {\n             None\n         } else {\n             let len = self.v.len();\n+            // SAFETY: This type ensures that any split_at_mut on self.v is valid.\n             let (head, tail) = unsafe { self.v.split_at_mut(len - self.chunk_size) };\n             self.v = head;\n-            // SAFETY: Nothing points to or will point to the contents of this slice\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n             Some(unsafe { &mut *tail })\n         }\n     }\n@@ -3053,6 +3084,7 @@ impl<'a, T> Iterator for RChunksExactMut<'a, T> {\n             None\n         } else {\n             let len = self.v.len();\n+            // SAFETY: This type ensures that any split_at_mut on self.v is valid.\n             let (fst, _) = unsafe { self.v.split_at_mut(len - end) };\n             self.v = fst;\n             self.next()\n@@ -3079,9 +3111,10 @@ impl<'a, T> DoubleEndedIterator for RChunksExactMut<'a, T> {\n         if self.v.len() < self.chunk_size {\n             None\n         } else {\n+            // SAFETY: This type ensures that any split_at_mut on self.v is valid.\n             let (head, tail) = unsafe { self.v.split_at_mut(self.chunk_size) };\n             self.v = tail;\n-            // SAFETY: Nothing points to or will point to the contents of this slice\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n             Some(unsafe { &mut *head })\n         }\n     }\n@@ -3098,10 +3131,12 @@ impl<'a, T> DoubleEndedIterator for RChunksExactMut<'a, T> {\n             let offset = (len - n) * self.chunk_size;\n             let start = self.v.len() - offset;\n             let end = start + self.chunk_size;\n+            // SAFETY: This type ensures that any split_at_mut on self.v is valid.\n             let (tmp, tail) = unsafe { self.v.split_at_mut(end) };\n+            // SAFETY: This type ensures that any split_at_mut on self.v is valid.\n             let (_, nth_back) = unsafe { tmp.split_at_mut(start) };\n             self.v = tail;\n-            // SAFETY: Nothing points to or will point to the contents of this slice\n+            // SAFETY: Nothing else points to or will point to the contents of this slice.\n             Some(unsafe { &mut *nth_back })\n         }\n     }"}]}