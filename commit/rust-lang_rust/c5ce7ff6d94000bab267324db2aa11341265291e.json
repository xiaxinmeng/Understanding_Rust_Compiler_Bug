{"sha": "c5ce7ff6d94000bab267324db2aa11341265291e", "node_id": "C_kwDOAAsO6NoAKGM1Y2U3ZmY2ZDk0MDAwYmFiMjY3MzI0ZGIyYWExMTM0MTI2NTI5MWU", "commit": {"author": {"name": "ThibsG", "email": "thibsg@pm.me", "date": "2021-11-27T18:22:19Z"}, "committer": {"name": "ThibsG", "email": "thibsg@pm.me", "date": "2021-11-27T18:22:19Z"}, "message": "Add `Index` when checking projs in a call, rename some variables and remove unneeded statements", "tree": {"sha": "2f87b6331d5ece71d9b4f6de7a59a7028c19a890", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f87b6331d5ece71d9b4f6de7a59a7028c19a890"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5ce7ff6d94000bab267324db2aa11341265291e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5ce7ff6d94000bab267324db2aa11341265291e", "html_url": "https://github.com/rust-lang/rust/commit/c5ce7ff6d94000bab267324db2aa11341265291e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5ce7ff6d94000bab267324db2aa11341265291e/comments", "author": {"login": "ThibsG", "id": 12683889, "node_id": "MDQ6VXNlcjEyNjgzODg5", "avatar_url": "https://avatars.githubusercontent.com/u/12683889?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ThibsG", "html_url": "https://github.com/ThibsG", "followers_url": "https://api.github.com/users/ThibsG/followers", "following_url": "https://api.github.com/users/ThibsG/following{/other_user}", "gists_url": "https://api.github.com/users/ThibsG/gists{/gist_id}", "starred_url": "https://api.github.com/users/ThibsG/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ThibsG/subscriptions", "organizations_url": "https://api.github.com/users/ThibsG/orgs", "repos_url": "https://api.github.com/users/ThibsG/repos", "events_url": "https://api.github.com/users/ThibsG/events{/privacy}", "received_events_url": "https://api.github.com/users/ThibsG/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ThibsG", "id": 12683889, "node_id": "MDQ6VXNlcjEyNjgzODg5", "avatar_url": "https://avatars.githubusercontent.com/u/12683889?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ThibsG", "html_url": "https://github.com/ThibsG", "followers_url": "https://api.github.com/users/ThibsG/followers", "following_url": "https://api.github.com/users/ThibsG/following{/other_user}", "gists_url": "https://api.github.com/users/ThibsG/gists{/gist_id}", "starred_url": "https://api.github.com/users/ThibsG/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ThibsG/subscriptions", "organizations_url": "https://api.github.com/users/ThibsG/orgs", "repos_url": "https://api.github.com/users/ThibsG/repos", "events_url": "https://api.github.com/users/ThibsG/events{/privacy}", "received_events_url": "https://api.github.com/users/ThibsG/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "092fe209a6568ade22046dbf4e78455d5aeeb5fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/092fe209a6568ade22046dbf4e78455d5aeeb5fa", "html_url": "https://github.com/rust-lang/rust/commit/092fe209a6568ade22046dbf4e78455d5aeeb5fa"}], "stats": {"total": 32, "additions": 14, "deletions": 18}, "files": [{"sha": "5dd49c1d26b98fb76a74d1400aa9206f457d07cc", "filename": "clippy_utils/src/sugg.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c5ce7ff6d94000bab267324db2aa11341265291e/clippy_utils%2Fsrc%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5ce7ff6d94000bab267324db2aa11341265291e/clippy_utils%2Fsrc%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fsugg.rs?ref=c5ce7ff6d94000bab267324db2aa11341265291e", "patch": "@@ -737,9 +737,9 @@ pub struct DerefClosure {\n /// such as explicit deref and borrowing cases.\n /// Returns `None` if no such use cases have been triggered in closure body\n ///\n-/// note: this only works on single line immutable closures\n-pub fn deref_closure_args<'tcx>(cx: &LateContext<'_>, search_expr: &'tcx hir::Expr<'_>) -> Option<DerefClosure> {\n-    if let hir::ExprKind::Closure(_, fn_decl, body_id, ..) = search_expr.kind {\n+/// note: this only works on single line immutable closures with one exactly one input parameter.\n+pub fn deref_closure_args<'tcx>(cx: &LateContext<'_>, closure: &'tcx hir::Expr<'_>) -> Option<DerefClosure> {\n+    if let hir::ExprKind::Closure(_, fn_decl, body_id, ..) = closure.kind {\n         let closure_body = cx.tcx.hir().body(body_id);\n         // is closure arg a double reference (i.e.: `|x: &&i32| ...`)\n         let closure_arg_is_double_ref = if let TyKind::Rptr(_, MutTy { ty, .. }) = fn_decl.inputs[0].kind {\n@@ -750,14 +750,14 @@ pub fn deref_closure_args<'tcx>(cx: &LateContext<'_>, search_expr: &'tcx hir::Ex\n \n         let mut visitor = DerefDelegate {\n             cx,\n-            closure_span: search_expr.span,\n+            closure_span: closure.span,\n             closure_arg_is_double_ref,\n-            next_pos: search_expr.span.lo(),\n+            next_pos: closure.span.lo(),\n             suggestion_start: String::new(),\n             applicability: Applicability::MaybeIncorrect,\n         };\n \n-        let fn_def_id = cx.tcx.hir().local_def_id(search_expr.hir_id);\n+        let fn_def_id = cx.tcx.hir().local_def_id(closure.hir_id);\n         cx.tcx.infer_ctxt().enter(|infcx| {\n             ExprUseVisitor::new(&mut visitor, &infcx, fn_def_id, cx.param_env, cx.typeck_results())\n                 .consume_body(closure_body);\n@@ -847,7 +847,6 @@ impl<'tcx> Delegate<'tcx> for DerefDelegate<'_, 'tcx> {\n             if cmt.place.projections.is_empty() {\n                 // handle item without any projection, that needs an explicit borrowing\n                 // i.e.: suggest `&x` instead of `x`\n-                self.closure_arg_is_double_ref = false;\n                 self.suggestion_start.push_str(&format!(\"{}&{}\", start_snip, ident_str));\n             } else {\n                 // cases where a parent `Call` or `MethodCall` is using the item\n@@ -879,21 +878,20 @@ impl<'tcx> Delegate<'tcx> for DerefDelegate<'_, 'tcx> {\n                                 let takes_arg_by_double_ref =\n                                     self.func_takes_arg_by_double_ref(parent_expr, cmt.hir_id);\n \n-                                // compiler will automatically dereference field projection, so no need\n+                                // compiler will automatically dereference field or index projection, so no need\n                                 // to suggest ampersand, but full identifier that includes projection is required\n-                                let has_field_projection = cmt\n-                                    .place\n-                                    .projections\n-                                    .iter()\n-                                    .any(|proj| matches!(proj.kind, ProjectionKind::Field(..)));\n+                                let has_field_or_index_projection =\n+                                    cmt.place.projections.iter().any(|proj| {\n+                                        matches!(proj.kind, ProjectionKind::Field(..) | ProjectionKind::Index)\n+                                    });\n \n                                 // no need to bind again if the function doesn't take arg by double ref\n                                 // and if the item is already a double ref\n                                 let ident_sugg = if !call_args.is_empty()\n                                     && !takes_arg_by_double_ref\n-                                    && (self.closure_arg_is_double_ref || has_field_projection)\n+                                    && (self.closure_arg_is_double_ref || has_field_or_index_projection)\n                                 {\n-                                    let ident = if has_field_projection {\n+                                    let ident = if has_field_or_index_projection {\n                                         ident_str_with_proj\n                                     } else {\n                                         ident_str\n@@ -953,9 +951,7 @@ impl<'tcx> Delegate<'tcx> for DerefDelegate<'_, 'tcx> {\n \n                 // handle `ProjectionKind::Deref` by removing one explicit deref\n                 // if no special case was detected (i.e.: suggest `*x` instead of `**x`)\n-                if projections_handled {\n-                    self.closure_arg_is_double_ref = false;\n-                } else {\n+                if !projections_handled {\n                     let last_deref = cmt\n                         .place\n                         .projections"}]}