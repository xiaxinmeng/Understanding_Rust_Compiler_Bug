{"sha": "e39bcecf79a6951f528b12b47ea671f9b0328bb3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzOWJjZWNmNzlhNjk1MWY1MjhiMTJiNDdlYTY3MWY5YjAzMjhiYjM=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2017-07-18T18:41:21Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2017-07-18T20:33:36Z"}, "message": "Handle type ascription cases with a method call instead of a type", "tree": {"sha": "f63798cafedefb476c2e44061b81727fc520b3b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f63798cafedefb476c2e44061b81727fc520b3b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e39bcecf79a6951f528b12b47ea671f9b0328bb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e39bcecf79a6951f528b12b47ea671f9b0328bb3", "html_url": "https://github.com/rust-lang/rust/commit/e39bcecf79a6951f528b12b47ea671f9b0328bb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e39bcecf79a6951f528b12b47ea671f9b0328bb3/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "faf90351b79de04de0176b1e0de07cc5f1730eaa", "url": "https://api.github.com/repos/rust-lang/rust/commits/faf90351b79de04de0176b1e0de07cc5f1730eaa", "html_url": "https://github.com/rust-lang/rust/commit/faf90351b79de04de0176b1e0de07cc5f1730eaa"}], "stats": {"total": 108, "additions": 94, "deletions": 14}, "files": [{"sha": "d7316c75b2d270335f0969666649a4beda754ba4", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 63, "deletions": 14, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/e39bcecf79a6951f528b12b47ea671f9b0328bb3/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e39bcecf79a6951f528b12b47ea671f9b0328bb3/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=e39bcecf79a6951f528b12b47ea671f9b0328bb3", "patch": "@@ -599,19 +599,24 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n         self.resolve_local(local);\n     }\n     fn visit_ty(&mut self, ty: &'tcx Ty) {\n-        if let TyKind::Path(ref qself, ref path) = ty.node {\n-            self.smart_resolve_path(ty.id, qself.as_ref(), path, PathSource::Type);\n-        } else if let TyKind::ImplicitSelf = ty.node {\n-            let self_ty = keywords::SelfType.ident();\n-            let def = self.resolve_ident_in_lexical_scope(self_ty, TypeNS, true, ty.span)\n-                          .map_or(Def::Err, |d| d.def());\n-            self.record_def(ty.id, PathResolution::new(def));\n-        } else if let TyKind::Array(ref element, ref length) = ty.node {\n-            self.visit_ty(element);\n-            self.with_constant_rib(|this| {\n-                this.visit_expr(length);\n-            });\n-            return;\n+        match ty.node {\n+            TyKind::Path(ref qself, ref path) => {\n+                self.smart_resolve_path(ty.id, qself.as_ref(), path, PathSource::Type);\n+            }\n+            TyKind::ImplicitSelf => {\n+                let self_ty = keywords::SelfType.ident();\n+                let def = self.resolve_ident_in_lexical_scope(self_ty, TypeNS, true, ty.span)\n+                              .map_or(Def::Err, |d| d.def());\n+                self.record_def(ty.id, PathResolution::new(def));\n+            }\n+            TyKind::Array(ref element, ref length) => {\n+                self.visit_ty(element);\n+                self.with_constant_rib(|this| {\n+                    this.visit_expr(length);\n+                });\n+                return;\n+            }\n+            _ => (),\n         }\n         visit::walk_ty(self, ty);\n     }\n@@ -1221,6 +1226,9 @@ pub struct Resolver<'a> {\n     // This table maps struct IDs into struct constructor IDs,\n     // it's not used during normal resolution, only for better error reporting.\n     struct_constructors: DefIdMap<(Def, ty::Visibility)>,\n+\n+    // Only used for better errors on `fn(): fn()`\n+    current_type_ascription: Vec<Span>,\n }\n \n pub struct ResolverArenas<'a> {\n@@ -1411,6 +1419,7 @@ impl<'a> Resolver<'a> {\n             struct_constructors: DefIdMap(),\n             found_unresolved_macro: false,\n             unused_macros: FxHashSet(),\n+            current_type_ascription: Vec::new(),\n         }\n     }\n \n@@ -2495,6 +2504,7 @@ impl<'a> Resolver<'a> {\n             // Fallback label.\n             if !levenshtein_worked {\n                 err.span_label(base_span, fallback_label);\n+                this.type_ascription_suggestion(&mut err, base_span);\n             }\n             err\n         };\n@@ -2550,6 +2560,41 @@ impl<'a> Resolver<'a> {\n         resolution\n     }\n \n+    fn type_ascription_suggestion(&self,\n+                                  err: &mut DiagnosticBuilder,\n+                                  base_span: Span) {\n+        debug!(\"type_ascription_suggetion {:?}\", base_span);\n+        let cm = self.session.codemap();\n+        debug!(\"self.current_type_ascription {:?}\", self.current_type_ascription);\n+        if let Some(sp) = self.current_type_ascription.last() {\n+            let mut sp = *sp;\n+            loop {  // try to find the `:`, bail on first non-':'/non-whitespace\n+                sp = sp.next_point();\n+                if let Ok(snippet) = cm.span_to_snippet(sp.to(sp.next_point())) {\n+                    debug!(\"snippet {:?}\", snippet);\n+                    let line_sp = cm.lookup_char_pos(sp.hi).line;\n+                    let line_base_sp = cm.lookup_char_pos(base_span.lo).line;\n+                    debug!(\"{:?} {:?}\", line_sp, line_base_sp);\n+                    if snippet == \":\" {\n+                        err.span_label(base_span,\n+                                       \"expecting a type here because of type ascription\");\n+                        if line_sp != line_base_sp {\n+                            err.span_suggestion_short(sp,\n+                                                      \"did you mean to use `;` here instead?\",\n+                                                      \";\".to_string());\n+                        }\n+                        break;\n+                    } else if snippet.trim().len() != 0  {\n+                        debug!(\"tried to find type ascription `:` token, couldn't find it\");\n+                        break;\n+                    }\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n     fn self_type_is_available(&mut self, span: Span) -> bool {\n         let binding = self.resolve_ident_in_lexical_scope(keywords::SelfType.ident(),\n                                                           TypeNS, false, span);\n@@ -3166,7 +3211,11 @@ impl<'a> Resolver<'a> {\n                     self.resolve_expr(argument, None);\n                 }\n             }\n-\n+            ExprKind::Type(ref type_expr, _) => {\n+                self.current_type_ascription.push(type_expr.span);\n+                visit::walk_expr(self, expr);\n+                self.current_type_ascription.pop();\n+            }\n             _ => {\n                 visit::walk_expr(self, expr);\n             }"}, {"sha": "7c10bf98c8409b1052161f4b7d5db59629daebd0", "filename": "src/test/ui/suggestions/type-ascription-with-fn-call.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e39bcecf79a6951f528b12b47ea671f9b0328bb3/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-with-fn-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e39bcecf79a6951f528b12b47ea671f9b0328bb3/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-with-fn-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-with-fn-call.rs?ref=e39bcecf79a6951f528b12b47ea671f9b0328bb3", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(type_ascription)]\n+\n+fn main() {\n+    f()  :\n+    f();\n+}\n+\n+fn f() {}"}, {"sha": "93c65c263dd12f0dbed3cef3a4d01b2bbac1e00f", "filename": "src/test/ui/suggestions/type-ascription-with-fn-call.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e39bcecf79a6951f528b12b47ea671f9b0328bb3/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-with-fn-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e39bcecf79a6951f528b12b47ea671f9b0328bb3/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-with-fn-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftype-ascription-with-fn-call.stderr?ref=e39bcecf79a6951f528b12b47ea671f9b0328bb3", "patch": "@@ -0,0 +1,13 @@\n+error[E0573]: expected type, found function `f`\n+  --> $DIR/type-ascription-with-fn-call.rs:15:5\n+   |\n+14 |     f()  :\n+   |          - help: did you mean to use `;` here instead?\n+15 |     f();\n+   |     ^^^\n+   |     |\n+   |     not a type\n+   |     expecting a type here because of type ascription\n+\n+error: aborting due to previous error\n+"}]}