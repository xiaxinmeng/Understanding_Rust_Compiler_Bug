{"sha": "c148d887e37023af01b98da38d0c9264a8ea084c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxNDhkODg3ZTM3MDIzYWYwMWI5OGRhMzhkMGM5MjY0YThlYTA4NGM=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-10-21T17:06:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-21T17:06:19Z"}, "message": "Merge pull request #69 from oli-obk/master\n\ndon't force allocations for most casts", "tree": {"sha": "fc41283b04e9a0eed32fcf9c552e58f9e9371030", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc41283b04e9a0eed32fcf9c552e58f9e9371030"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c148d887e37023af01b98da38d0c9264a8ea084c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c148d887e37023af01b98da38d0c9264a8ea084c", "html_url": "https://github.com/rust-lang/rust/commit/c148d887e37023af01b98da38d0c9264a8ea084c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c148d887e37023af01b98da38d0c9264a8ea084c/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f3cb7fdb8e3b79cb0c2b41398e24f94c806aaaa", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f3cb7fdb8e3b79cb0c2b41398e24f94c806aaaa", "html_url": "https://github.com/rust-lang/rust/commit/7f3cb7fdb8e3b79cb0c2b41398e24f94c806aaaa"}, {"sha": "073f91654c5ac9d9a18e872ca340e9fd13d61d39", "url": "https://api.github.com/repos/rust-lang/rust/commits/073f91654c5ac9d9a18e872ca340e9fd13d61d39", "html_url": "https://github.com/rust-lang/rust/commit/073f91654c5ac9d9a18e872ca340e9fd13d61d39"}], "stats": {"total": 47, "additions": 18, "deletions": 29}, "files": [{"sha": "c7e5e12794faa52dffd80af211a8e6f807121b40", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 18, "deletions": 29, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c148d887e37023af01b98da38d0c9264a8ea084c/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c148d887e37023af01b98da38d0c9264a8ea084c/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=c148d887e37023af01b98da38d0c9264a8ea084c", "patch": "@@ -652,9 +652,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             }\n \n             Cast(kind, ref operand, cast_ty) => {\n-                // FIXME(solson)\n-                let dest = self.force_allocation(dest)?.to_ptr();\n-\n                 debug_assert_eq!(self.monomorphize(cast_ty, self.substs()), dest_ty);\n                 use rustc::mir::repr::CastKind::*;\n                 match kind {\n@@ -669,34 +666,27 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         let src_ty = self.operand_ty(operand);\n                         if self.type_is_fat_ptr(src_ty) {\n                             trace!(\"misc cast: {:?}\", src);\n-                            let ptr_size = self.memory.pointer_size();\n                             match (src, self.type_is_fat_ptr(dest_ty)) {\n-                                (Value::ByValPair(data, meta), true) => {\n-                                    self.memory.write_primval(dest, data)?;\n-                                    self.memory.write_primval(dest.offset(ptr_size as isize), meta)?;\n+                                (Value::ByRef(_), _) |\n+                                (Value::ByValPair(..), true) => {\n+                                    self.write_value(src, dest, dest_ty)?;\n                                 },\n                                 (Value::ByValPair(data, _), false) => {\n-                                    self.memory.write_primval(dest, data)?;\n-                                },\n-                                (Value::ByRef(ptr), true) => {\n-                                    self.memory.copy(ptr, dest, ptr_size * 2, ptr_size)?;\n-                                },\n-                                (Value::ByRef(ptr), false) => {\n-                                    self.memory.copy(ptr, dest, ptr_size, ptr_size)?;\n+                                    self.write_value(Value::ByVal(data), dest, dest_ty)?;\n                                 },\n                                 (Value::ByVal(_), _) => bug!(\"expected fat ptr\"),\n                             }\n                         } else {\n                             let src_val = self.value_to_primval(src, src_ty)?;\n                             let dest_val = self.cast_primval(src_val, dest_ty)?;\n-                            self.memory.write_primval(dest, dest_val)?;\n+                            self.write_value(Value::ByVal(dest_val), dest, dest_ty)?;\n                         }\n                     }\n \n                     ReifyFnPointer => match self.operand_ty(operand).sty {\n                         ty::TyFnDef(def_id, substs, fn_ty) => {\n                             let fn_ptr = self.memory.create_fn_ptr(def_id, substs, fn_ty);\n-                            self.memory.write_ptr(dest, fn_ptr)?;\n+                            self.write_value(Value::ByVal(PrimVal::from_fn_ptr(fn_ptr)), dest, dest_ty)?;\n                         },\n                         ref other => bug!(\"reify fn pointer on {:?}\", other),\n                     },\n@@ -707,7 +697,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                             let ptr = src.read_ptr(&self.memory)?;\n                             let (def_id, substs, _) = self.memory.get_fn(ptr.alloc_id)?;\n                             let fn_ptr = self.memory.create_fn_ptr(def_id, substs, unsafe_fn_ty);\n-                            self.memory.write_ptr(dest, fn_ptr)?;\n+                            self.write_value(Value::ByVal(PrimVal::from_fn_ptr(fn_ptr)), dest, dest_ty)?;\n                         },\n                         ref other => bug!(\"fn to unsafe fn cast on {:?}\", other),\n                     },\n@@ -1492,7 +1482,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         &mut self,\n         src: Value,\n         src_ty: Ty<'tcx>,\n-        dest: Pointer,\n+        dest: Lvalue<'tcx>,\n         dest_ty: Ty<'tcx>,\n     ) -> EvalResult<'tcx, ()> {\n         match (&src_ty.sty, &dest_ty.sty) {\n@@ -1506,33 +1496,32 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 match (&src_pointee_ty.sty, &dest_pointee_ty.sty) {\n                     (&ty::TyArray(_, length), &ty::TySlice(_)) => {\n                         let ptr = src.read_ptr(&self.memory)?;\n-                        self.memory.write_ptr(dest, ptr)?;\n-                        let ptr_size = self.memory.pointer_size() as isize;\n-                        let dest_extra = dest.offset(ptr_size);\n-                        self.memory.write_usize(dest_extra, length as u64)?;\n+                        let len = self.usize_primval(length as u64);\n+                        let ptr = PrimVal::from_ptr(ptr);\n+                        self.write_value(Value::ByValPair(ptr, len), dest, dest_ty)?;\n                     }\n                     (&ty::TyTrait(_), &ty::TyTrait(_)) => {\n                         // For now, upcasts are limited to changes in marker\n                         // traits, and hence never actually require an actual\n                         // change to the vtable.\n-                        self.write_value_to_ptr(src, dest, dest_ty)?;\n+                        self.write_value(src, dest, dest_ty)?;\n                     },\n                     (_, &ty::TyTrait(ref data)) => {\n                         let trait_ref = data.principal.with_self_ty(self.tcx, src_pointee_ty);\n                         let trait_ref = self.tcx.erase_regions(&trait_ref);\n                         let vtable = self.get_vtable(trait_ref)?;\n                         let ptr = src.read_ptr(&self.memory)?;\n-\n-                        self.memory.write_ptr(dest, ptr)?;\n-                        let ptr_size = self.memory.pointer_size() as isize;\n-                        let dest_extra = dest.offset(ptr_size);\n-                        self.memory.write_ptr(dest_extra, vtable)?;\n+                        let ptr = PrimVal::from_ptr(ptr);\n+                        let extra = PrimVal::from_ptr(vtable);\n+                        self.write_value(Value::ByValPair(ptr, extra), dest, dest_ty)?;\n                     },\n \n                     _ => bug!(\"invalid unsizing {:?} -> {:?}\", src_ty, dest_ty),\n                 }\n             }\n             (&ty::TyAdt(def_a, substs_a), &ty::TyAdt(def_b, substs_b)) => {\n+                // FIXME(solson)\n+                let dest = self.force_allocation(dest)?.to_ptr();\n                 // unsizing of generic struct with pointer fields\n                 // Example: `Arc<T>` -> `Arc<Trait>`\n                 // here we need to increase the size of every &T thin ptr field to a fat ptr\n@@ -1563,7 +1552,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     if src_fty == dst_fty {\n                         self.copy(src_f_ptr, dst_f_ptr, src_fty)?;\n                     } else {\n-                        self.unsize_into(Value::ByRef(src_f_ptr), src_fty, dst_f_ptr, dst_fty)?;\n+                        self.unsize_into(Value::ByRef(src_f_ptr), src_fty, Lvalue::from_ptr(dst_f_ptr), dst_fty)?;\n                     }\n                 }\n             }"}]}