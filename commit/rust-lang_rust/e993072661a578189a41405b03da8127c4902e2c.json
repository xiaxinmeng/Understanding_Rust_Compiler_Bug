{"sha": "e993072661a578189a41405b03da8127c4902e2c", "node_id": "C_kwDOAAsO6NoAKGU5OTMwNzI2NjFhNTc4MTg5YTQxNDA1YjAzZGE4MTI3YzQ5MDJlMmM", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2023-01-27T18:17:23Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2023-01-27T18:17:23Z"}, "message": "Provide signature help when typing record literal", "tree": {"sha": "48d0ecba42ef6ab8115497bd4f44dd8f1f2939da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48d0ecba42ef6ab8115497bd4f44dd8f1f2939da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e993072661a578189a41405b03da8127c4902e2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e993072661a578189a41405b03da8127c4902e2c", "html_url": "https://github.com/rust-lang/rust/commit/e993072661a578189a41405b03da8127c4902e2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e993072661a578189a41405b03da8127c4902e2c/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "261afbdd885973f3402a2e7ee7c5e000568b6cc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/261afbdd885973f3402a2e7ee7c5e000568b6cc6", "html_url": "https://github.com/rust-lang/rust/commit/261afbdd885973f3402a2e7ee7c5e000568b6cc6"}], "stats": {"total": 180, "additions": 173, "deletions": 7}, "files": [{"sha": "d249bc4728efc8940597f67d58792d5536fc7650", "filename": "crates/ide/src/signature_help.rs", "status": "modified", "additions": 173, "deletions": 7, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/e993072661a578189a41405b03da8127c4902e2c/crates%2Fide%2Fsrc%2Fsignature_help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e993072661a578189a41405b03da8127c4902e2c/crates%2Fide%2Fsrc%2Fsignature_help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsignature_help.rs?ref=e993072661a578189a41405b03da8127c4902e2c", "patch": "@@ -4,13 +4,15 @@\n use std::collections::BTreeSet;\n \n use either::Either;\n-use hir::{AssocItem, GenericParam, HasAttrs, HirDisplay, Semantics, Trait};\n-use ide_db::{active_parameter::callable_for_node, base_db::FilePosition};\n+use hir::{\n+    AssocItem, GenericParam, HasAttrs, HirDisplay, ModuleDef, PathResolution, Semantics, Trait,\n+};\n+use ide_db::{active_parameter::callable_for_node, base_db::FilePosition, FxIndexMap};\n use stdx::format_to;\n use syntax::{\n     algo,\n     ast::{self, HasArgList},\n-    match_ast, AstNode, Direction, SyntaxToken, TextRange, TextSize,\n+    match_ast, AstNode, Direction, SyntaxKind, SyntaxToken, TextRange, TextSize,\n };\n \n use crate::RootDatabase;\n@@ -37,14 +39,18 @@ impl SignatureHelp {\n     }\n \n     fn push_call_param(&mut self, param: &str) {\n-        self.push_param('(', param);\n+        self.push_param(\"(\", param);\n     }\n \n     fn push_generic_param(&mut self, param: &str) {\n-        self.push_param('<', param);\n+        self.push_param(\"<\", param);\n+    }\n+\n+    fn push_record_field(&mut self, param: &str) {\n+        self.push_param(\"{ \", param);\n     }\n \n-    fn push_param(&mut self, opening_delim: char, param: &str) {\n+    fn push_param(&mut self, opening_delim: &str, param: &str) {\n         if !self.signature.ends_with(opening_delim) {\n             self.signature.push_str(\", \");\n         }\n@@ -85,14 +91,23 @@ pub(crate) fn signature_help(db: &RootDatabase, position: FilePosition) -> Optio\n                     }\n                     return signature_help_for_generics(&sema, garg_list, token);\n                 },\n+                ast::RecordExpr(record) => {\n+                    let cursor_outside = record.record_expr_field_list().and_then(|list| list.r_curly_token()).as_ref() == Some(&token);\n+                    if cursor_outside {\n+                        continue;\n+                    }\n+                    return signature_help_for_record_lit(&sema, record, token);\n+                },\n                 _ => (),\n             }\n         }\n \n         // Stop at multi-line expressions, since the signature of the outer call is not very\n         // helpful inside them.\n         if let Some(expr) = ast::Expr::cast(node.clone()) {\n-            if expr.syntax().text().contains_char('\\n') {\n+            if expr.syntax().text().contains_char('\\n')\n+                && expr.syntax().kind() != SyntaxKind::RECORD_EXPR\n+            {\n                 return None;\n             }\n         }\n@@ -368,6 +383,81 @@ fn add_assoc_type_bindings(\n     }\n }\n \n+fn signature_help_for_record_lit(\n+    sema: &Semantics<'_, RootDatabase>,\n+    record: ast::RecordExpr,\n+    token: SyntaxToken,\n+) -> Option<SignatureHelp> {\n+    let arg_list = record\n+        .syntax()\n+        .ancestors()\n+        .filter_map(ast::RecordExpr::cast)\n+        .find(|list| list.syntax().text_range().contains(token.text_range().start()))?;\n+\n+    let active_parameter = arg_list\n+        .record_expr_field_list()?\n+        .fields()\n+        .take_while(|arg| arg.syntax().text_range().end() <= token.text_range().start())\n+        .count();\n+\n+    let mut res = SignatureHelp {\n+        doc: None,\n+        signature: String::new(),\n+        parameters: vec![],\n+        active_parameter: Some(active_parameter),\n+    };\n+\n+    let fields;\n+\n+    let db = sema.db;\n+    match sema.resolve_path(&record.path()?)? {\n+        PathResolution::Def(ModuleDef::Adt(adt)) => match adt {\n+            hir::Adt::Struct(it) => {\n+                fields = it.fields(db);\n+                res.doc = it.docs(db).map(|it| it.into());\n+                format_to!(res.signature, \"struct {} {{ \", it.name(db));\n+            }\n+            hir::Adt::Union(it) => {\n+                fields = it.fields(db);\n+                res.doc = it.docs(db).map(|it| it.into());\n+                format_to!(res.signature, \"union {} {{ \", it.name(db));\n+            }\n+            _ => return None,\n+        },\n+        PathResolution::Def(ModuleDef::Variant(variant)) => {\n+            fields = variant.fields(db);\n+            let en = variant.parent_enum(db);\n+\n+            res.doc = en.docs(db).map(|it| it.into());\n+            format_to!(res.signature, \"enum {}::{} {{ \", en.name(db), variant.name(db));\n+        }\n+        _ => return None,\n+    }\n+\n+    let mut fields =\n+        fields.into_iter().map(|field| (field.name(db), Some(field))).collect::<FxIndexMap<_, _>>();\n+    let mut buf = String::new();\n+    for field in record.record_expr_field_list()?.fields() {\n+        let Some((field, _, ty)) = sema.resolve_record_field(&field) else { continue };\n+        let name = field.name(db);\n+        format_to!(buf, \"{name}: {}\", ty.display_truncated(db, Some(20)));\n+        res.push_record_field(&buf);\n+        buf.clear();\n+\n+        if let Some(field) = fields.get_mut(&name) {\n+            *field = None;\n+        }\n+    }\n+    for (name, field) in fields {\n+        let Some(field) = field else { continue };\n+        format_to!(buf, \"{name}: {}\", field.ty(db).display_truncated(db, Some(20)));\n+        res.push_record_field(&buf);\n+        buf.clear();\n+    }\n+    res.signature.push_str(\" }\");\n+    Some(res)\n+}\n+\n #[cfg(test)]\n mod tests {\n     use std::iter;\n@@ -1405,4 +1495,80 @@ fn take<C, Error>(\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn record_literal() {\n+        check(\n+            r#\"\n+struct Strukt<T, U = ()> {\n+    t: T,\n+    u: U,\n+    unit: (),\n+}\n+fn f() {\n+    Strukt {\n+        u: 0,\n+        $0\n+    }\n+}\n+\"#,\n+            expect![[r#\"\n+                struct Strukt { u: i32, t: T, unit: () }\n+                                ------  ^^^^  --------\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn record_literal_nonexistent_field() {\n+        check(\n+            r#\"\n+struct Strukt {\n+    a: u8,\n+}\n+fn f() {\n+    Strukt {\n+        b: 8,\n+        $0\n+    }\n+}\n+\"#,\n+            expect![[r#\"\n+                struct Strukt { a: u8 }\n+                                -----\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_variant_record_literal() {\n+        check(\n+            r#\"\n+enum Opt {\n+    Some(u8),\n+}\n+fn f() {\n+    Opt::Some {$0}\n+}\n+\"#,\n+            expect![[r#\"\n+                enum Opt::Some { 0: u8 }\n+                                 ^^^^^\n+            \"#]],\n+        );\n+        check(\n+            r#\"\n+enum Opt {\n+    Some(u8),\n+}\n+fn f() {\n+    Opt::Some {0:0,$0}\n+}\n+\"#,\n+            expect![[r#\"\n+                enum Opt::Some { 0: u8 }\n+                                 -----\n+            \"#]],\n+        );\n+    }\n }"}]}