{"sha": "942b384d61590c39eb635596de0370a823001817", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0MmIzODRkNjE1OTBjMzllYjYzNTU5NmRlMDM3MGE4MjMwMDE4MTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-21T14:37:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-21T14:37:45Z"}, "message": "Auto merge of #52405 - matthewjasper:mutability-errors, r=pnkfelix\n\n[NLL] Mutability errors\n\ncc #51028\ncc #51170\ncc #46559\nCloses #46629\n\n* Better explain why the place is immutable (\"immutable item\" is gone)\n* Distinguish &T and *const T\n* Use better spans when a mutable borrow is for a closure capture\n\nr? @pnkfelix", "tree": {"sha": "c336f80f6cc2db5da6d2141794afc7158e5dd490", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c336f80f6cc2db5da6d2141794afc7158e5dd490"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/942b384d61590c39eb635596de0370a823001817", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/942b384d61590c39eb635596de0370a823001817", "html_url": "https://github.com/rust-lang/rust/commit/942b384d61590c39eb635596de0370a823001817", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/942b384d61590c39eb635596de0370a823001817/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "606713f37aadbdb314137df464f099130c2062bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/606713f37aadbdb314137df464f099130c2062bd", "html_url": "https://github.com/rust-lang/rust/commit/606713f37aadbdb314137df464f099130c2062bd"}, {"sha": "a06b2433fc2963dba4ef25deee6720c63ffcc03b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a06b2433fc2963dba4ef25deee6720c63ffcc03b", "html_url": "https://github.com/rust-lang/rust/commit/a06b2433fc2963dba4ef25deee6720c63ffcc03b"}], "stats": {"total": 2173, "additions": 1822, "deletions": 351}, "files": [{"sha": "458c2f3885f9477fb0272a5a6412528ebd2ed35e", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -531,6 +531,8 @@ pub enum BindingForm<'tcx> {\n     Var(VarBindingForm<'tcx>),\n     /// Binding for a `self`/`&self`/`&mut self` binding where the type is implicit.\n     ImplicitSelf,\n+    /// Reference used in a guard expression to ensure immutability.\n+    RefForGuard,\n }\n \n CloneTypeFoldableAndLiftImpls! { BindingForm<'tcx>, }\n@@ -555,6 +557,7 @@ mod binding_form_impl {\n             match self {\n                 Var(binding) => binding.hash_stable(hcx, hasher),\n                 ImplicitSelf => (),\n+                RefForGuard => (),\n             }\n         }\n     }"}, {"sha": "3dca7768d704e6ba0f20203e15e3c512df0660c2", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -202,7 +202,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// the local assigned at `location`.\n     /// This is done by searching in statements succeeding `location`\n     /// and originating from `maybe_closure_span`.\n-    fn find_closure_span(\n+    pub(super) fn find_closure_span(\n         &self,\n         maybe_closure_span: Span,\n         location: Location,\n@@ -742,6 +742,24 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     autoderef,\n                                     &including_downcast,\n                                 )?;\n+                            } else if let Place::Local(local) = proj.base {\n+                                if let Some(ClearCrossCrate::Set(BindingForm::RefForGuard))\n+                                    = self.mir.local_decls[local].is_user_variable {\n+                                    self.append_place_to_string(\n+                                        &proj.base,\n+                                        buf,\n+                                        autoderef,\n+                                        &including_downcast,\n+                                    )?;\n+                                } else {\n+                                    buf.push_str(&\"*\");\n+                                    self.append_place_to_string(\n+                                        &proj.base,\n+                                        buf,\n+                                        autoderef,\n+                                        &including_downcast,\n+                                    )?;\n+                                }\n                             } else {\n                                 buf.push_str(&\"*\");\n                                 self.append_place_to_string("}, {"sha": "c212c1b826bd976907c6db0e9e4e87fceb35299d", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 20, "deletions": 209, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -16,7 +16,7 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::infer::InferCtxt;\n use rustc::lint::builtin::UNUSED_MUT;\n-use rustc::mir::{self, AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n+use rustc::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n use rustc::mir::{ClearCrossCrate, Local, Location, Mir, Mutability, Operand, Place};\n use rustc::mir::{Field, Projection, ProjectionElem, Rvalue, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n@@ -43,27 +43,27 @@ use dataflow::{do_dataflow, DebugFormatted};\n use dataflow::{EverInitializedPlaces, MovingOutStatements};\n use dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n use util::borrowck_errors::{BorrowckErrors, Origin};\n-use util::collect_writes::FindAssignments;\n-use util::suggest_ref_mut;\n \n use self::borrow_set::{BorrowData, BorrowSet};\n use self::flows::Flows;\n use self::location::LocationTable;\n use self::prefixes::PrefixSet;\n use self::MutateMode::{JustWrite, WriteAndRead};\n+use self::mutability_errors::AccessKind;\n \n use self::path_utils::*;\n \n crate mod borrow_set;\n mod error_reporting;\n mod flows;\n mod location;\n+mod move_errors;\n+mod mutability_errors;\n mod path_utils;\n crate mod place_ext;\n mod places_conflict;\n mod prefixes;\n mod used_muts;\n-mod move_errors;\n \n pub(crate) mod nll;\n \n@@ -922,7 +922,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n \n         let mutability_error =\n-            self.check_access_permissions(place_span, rw, is_local_mutation_allowed, flow_state);\n+            self.check_access_permissions(\n+                place_span,\n+                rw,\n+                is_local_mutation_allowed,\n+                flow_state,\n+                context.loc,\n+            );\n         let conflict_error =\n             self.check_access_for_conflict(context, place_span, sd, rw, flow_state);\n \n@@ -1668,6 +1674,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n+\n     /// Check the permissions for the given place and read or write kind\n     ///\n     /// Returns true if an error is reported, false otherwise.\n@@ -1677,17 +1684,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         kind: ReadOrWrite,\n         is_local_mutation_allowed: LocalMutationIsAllowed,\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n+        location: Location,\n     ) -> bool {\n         debug!(\n             \"check_access_permissions({:?}, {:?}, {:?})\",\n             place, kind, is_local_mutation_allowed\n         );\n \n-        #[derive(Copy, Clone, Debug)]\n-        enum AccessKind {\n-            MutableBorrow,\n-            Mutate,\n-        }\n         let error_access;\n         let the_place_err;\n \n@@ -1756,206 +1759,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         }\n \n         // at this point, we have set up the error reporting state.\n-\n-        let mut err;\n-        let item_msg = match self.describe_place(place) {\n-            Some(name) => format!(\"immutable item `{}`\", name),\n-            None => \"immutable item\".to_owned(),\n-        };\n-\n-        // `act` and `acted_on` are strings that let us abstract over\n-        // the verbs used in some diagnostic messages.\n-        let act;\n-        let acted_on;\n-\n-        match error_access {\n-            AccessKind::Mutate => {\n-                let item_msg = match the_place_err {\n-                    Place::Projection(box Projection {\n-                        base: _,\n-                        elem: ProjectionElem::Deref,\n-                    }) => match self.describe_place(place) {\n-                        Some(description) => {\n-                            format!(\"`{}` which is behind a `&` reference\", description)\n-                        }\n-                        None => format!(\"data in a `&` reference\"),\n-                    },\n-                    _ => item_msg,\n-                };\n-                err = self.tcx.cannot_assign(span, &item_msg, Origin::Mir);\n-                act = \"assign\";\n-                acted_on = \"written\";\n-            }\n-            AccessKind::MutableBorrow => {\n-                err = self\n-                    .tcx\n-                    .cannot_borrow_path_as_mutable(span, &item_msg, Origin::Mir);\n-                act = \"borrow as mutable\";\n-                acted_on = \"borrowed as mutable\";\n-            }\n-        }\n-\n-        match the_place_err {\n-            // We want to suggest users use `let mut` for local (user\n-            // variable) mutations...\n-            Place::Local(local) if self.mir.local_decls[*local].can_be_made_mutable() => {\n-                // ... but it doesn't make sense to suggest it on\n-                // variables that are `ref x`, `ref mut x`, `&self`,\n-                // or `&mut self` (such variables are simply not\n-                // mutable)..\n-                let local_decl = &self.mir.local_decls[*local];\n-                assert_eq!(local_decl.mutability, Mutability::Not);\n-\n-                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n-                err.span_suggestion(\n-                    local_decl.source_info.span,\n-                    \"consider changing this to be mutable\",\n-                    format!(\"mut {}\", local_decl.name.unwrap()),\n-                );\n-            }\n-\n-            // complete hack to approximate old AST-borrowck\n-            // diagnostic: if the span starts with a mutable borrow of\n-            // a local variable, then just suggest the user remove it.\n-            Place::Local(_)\n-                if {\n-                    if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n-                        snippet.starts_with(\"&mut \")\n-                    } else {\n-                        false\n-                    }\n-                } =>\n-            {\n-                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n-                err.span_label(span, \"try removing `&mut` here\");\n-            }\n-\n-            // We want to point out when a `&` can be readily replaced\n-            // with an `&mut`.\n-            //\n-            // FIXME: can this case be generalized to work for an\n-            // arbitrary base for the projection?\n-            Place::Projection(box Projection {\n-                base: Place::Local(local),\n-                elem: ProjectionElem::Deref,\n-            }) if self.mir.local_decls[*local].is_user_variable.is_some() => {\n-                let local_decl = &self.mir.local_decls[*local];\n-                let suggestion = match local_decl.is_user_variable.as_ref().unwrap() {\n-                    ClearCrossCrate::Set(mir::BindingForm::ImplicitSelf) => {\n-                        Some(suggest_ampmut_self(local_decl))\n-                    },\n-\n-                    ClearCrossCrate::Set(mir::BindingForm::Var(mir::VarBindingForm {\n-                        binding_mode: ty::BindingMode::BindByValue(_),\n-                        opt_ty_info,\n-                        ..\n-                    })) => Some(suggest_ampmut(\n-                        self.tcx,\n-                        self.mir,\n-                        *local,\n-                        local_decl,\n-                        *opt_ty_info,\n-                    )),\n-\n-                    ClearCrossCrate::Set(mir::BindingForm::Var(mir::VarBindingForm {\n-                        binding_mode: ty::BindingMode::BindByReference(_),\n-                        ..\n-                    })) => suggest_ref_mut(self.tcx, local_decl.source_info.span),\n-\n-                    ClearCrossCrate::Clear => bug!(\"saw cleared local state\"),\n-                };\n-\n-                if let Some((err_help_span, suggested_code)) = suggestion {\n-                    err.span_suggestion(\n-                        err_help_span,\n-                        \"consider changing this to be a mutable reference\",\n-                        suggested_code,\n-                    );\n-                }\n-\n-                if let Some(name) = local_decl.name {\n-                    err.span_label(\n-                        span,\n-                        format!(\n-                            \"`{NAME}` is a `&` reference, \\\n-                             so the data it refers to cannot be {ACTED_ON}\",\n-                            NAME = name,\n-                            ACTED_ON = acted_on\n-                        ),\n-                    );\n-                } else {\n-                    err.span_label(\n-                        span,\n-                        format!(\"cannot {ACT} through `&`-reference\", ACT = act),\n-                    );\n-                }\n-            }\n-\n-            _ => {\n-                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n-            }\n-        }\n-\n-        err.emit();\n+        self.report_mutability_error(\n+            place,\n+            span,\n+            the_place_err,\n+            error_access,\n+            location,\n+        );\n         return true;\n-\n-        fn suggest_ampmut_self<'cx, 'gcx, 'tcx>(\n-            local_decl: &mir::LocalDecl<'tcx>,\n-        ) -> (Span, String) {\n-            (local_decl.source_info.span, \"&mut self\".to_string())\n-        }\n-\n-        // When we want to suggest a user change a local variable to be a `&mut`, there\n-        // are three potential \"obvious\" things to highlight:\n-        //\n-        // let ident [: Type] [= RightHandSideExpression];\n-        //     ^^^^^    ^^^^     ^^^^^^^^^^^^^^^^^^^^^^^\n-        //     (1.)     (2.)              (3.)\n-        //\n-        // We can always fallback on highlighting the first. But chances are good that\n-        // the user experience will be better if we highlight one of the others if possible;\n-        // for example, if the RHS is present and the Type is not, then the type is going to\n-        // be inferred *from* the RHS, which means we should highlight that (and suggest\n-        // that they borrow the RHS mutably).\n-        //\n-        // This implementation attempts to emulate AST-borrowck prioritization\n-        // by trying (3.), then (2.) and finally falling back on (1.).\n-        fn suggest_ampmut<'cx, 'gcx, 'tcx>(\n-            tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n-            mir: &Mir<'tcx>,\n-            local: Local,\n-            local_decl: &mir::LocalDecl<'tcx>,\n-            opt_ty_info: Option<Span>,\n-        ) -> (Span, String) {\n-            let locations = mir.find_assignments(local);\n-            if locations.len() > 0 {\n-                let assignment_rhs_span = mir.source_info(locations[0]).span;\n-                let snippet = tcx.sess.codemap().span_to_snippet(assignment_rhs_span);\n-                if let Ok(src) = snippet {\n-                    if src.starts_with('&') {\n-                        let borrowed_expr = src[1..].to_string();\n-                        return (\n-                            assignment_rhs_span,\n-                            format!(\"&mut {}\", borrowed_expr),\n-                        );\n-                    }\n-                }\n-            }\n-\n-            let highlight_span = match opt_ty_info {\n-                // if this is a variable binding with an explicit type,\n-                // try to highlight that for the suggestion.\n-                Some(ty_span) => ty_span,\n-\n-                // otherwise, just highlight the span associated with\n-                // the (MIR) LocalDecl.\n-                None => local_decl.source_info.span,\n-            };\n-\n-            let ty_mut = local_decl.ty.builtin_deref(true).unwrap();\n-            assert_eq!(ty_mut.mutbl, hir::MutImmutable);\n-            (highlight_span, format!(\"&mut {}\", ty_mut.ty))\n-        }\n     }\n \n     /// Adds the place into the used mutable variables set"}, {"sha": "2a074a84e63e5e953b73079976eea56d55682334", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "added", "additions": 469, "deletions": 0, "changes": 469, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -0,0 +1,469 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir;\n+use rustc::mir::{self, BindingForm, ClearCrossCrate, Local, Location, Mir};\n+use rustc::mir::{Mutability, Place, Projection, ProjectionElem, Static};\n+use rustc::ty::{self, TyCtxt};\n+use rustc_data_structures::indexed_vec::Idx;\n+use syntax_pos::Span;\n+\n+use borrow_check::MirBorrowckCtxt;\n+use util::borrowck_errors::{BorrowckErrors, Origin};\n+use util::collect_writes::FindAssignments;\n+use util::suggest_ref_mut;\n+\n+#[derive(Copy, Clone, Debug)]\n+pub(super) enum AccessKind {\n+    MutableBorrow,\n+    Mutate,\n+}\n+\n+impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n+    pub(super) fn report_mutability_error(\n+        &mut self,\n+        access_place: &Place<'tcx>,\n+        span: Span,\n+        the_place_err: &Place<'tcx>,\n+        error_access: AccessKind,\n+        location: Location,\n+    ) {\n+        let mut err;\n+        let item_msg;\n+        let reason;\n+        let access_place_desc = self.describe_place(access_place);\n+\n+        match the_place_err {\n+            Place::Local(local) => {\n+                item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n+                if let Place::Local(_) = access_place {\n+                    reason = \", as it is not declared as mutable\".to_string();\n+                } else {\n+                    let name = self.mir.local_decls[*local]\n+                        .name\n+                        .expect(\"immutable unnamed local\");\n+                    reason = format!(\", as `{}` is not declared as mutable\", name);\n+                }\n+            }\n+\n+            Place::Projection(box Projection {\n+                base,\n+                elem: ProjectionElem::Field(upvar_index, _),\n+            }) => {\n+                debug_assert!(is_closure_or_generator(\n+                    base.ty(self.mir, self.tcx).to_ty(self.tcx)\n+                ));\n+\n+                item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n+                if self.is_upvar(access_place) {\n+                    reason = \", as it is not declared as mutable\".to_string();\n+                } else {\n+                    let name = self.mir.upvar_decls[upvar_index.index()].debug_name;\n+                    reason = format!(\", as `{}` is not declared as mutable\", name);\n+                }\n+            }\n+\n+            Place::Projection(box Projection {\n+                base,\n+                elem: ProjectionElem::Deref,\n+            }) => {\n+                if *base == Place::Local(Local::new(1)) && !self.mir.upvar_decls.is_empty() {\n+                    item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n+                    debug_assert!(self.mir.local_decls[Local::new(1)].ty.is_region_ptr());\n+                    debug_assert!(is_closure_or_generator(\n+                        the_place_err.ty(self.mir, self.tcx).to_ty(self.tcx)\n+                    ));\n+\n+                    reason = if self.is_upvar(access_place) {\n+                        \", as it is a captured variable in a `Fn` closure\".to_string()\n+                    } else {\n+                        format!(\", as `Fn` closures cannot mutate their captured variables\")\n+                    }\n+                } else if {\n+                    if let Place::Local(local) = *base {\n+                        if let Some(ClearCrossCrate::Set(BindingForm::RefForGuard))\n+                            = self.mir.local_decls[local].is_user_variable {\n+                                true\n+                        } else {\n+                            false\n+                        }\n+                    } else {\n+                        false\n+                    }\n+                } {\n+                    item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n+                    reason = format!(\", as it is immutable for the pattern guard\");\n+                } else {\n+                    let pointer_type =\n+                        if base.ty(self.mir, self.tcx).to_ty(self.tcx).is_region_ptr() {\n+                            \"`&` reference\"\n+                        } else {\n+                            \"`*const` pointer\"\n+                        };\n+                    if let Some(desc) = access_place_desc {\n+                        item_msg = format!(\"`{}`\", desc);\n+                        reason = match error_access {\n+                            AccessKind::Mutate => format!(\" which is behind a {}\", pointer_type),\n+                            AccessKind::MutableBorrow => {\n+                                format!(\", as it is behind a {}\", pointer_type)\n+                            }\n+                        }\n+                    } else {\n+                        item_msg = format!(\"data in a {}\", pointer_type);\n+                        reason = \"\".to_string();\n+                    }\n+                }\n+            }\n+\n+            Place::Static(box Static { def_id, ty: _ }) => {\n+                if let Place::Static(_) = access_place {\n+                    item_msg = format!(\"immutable static item `{}`\", access_place_desc.unwrap());\n+                    reason = \"\".to_string();\n+                } else {\n+                    item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n+                    let static_name = &self.tcx.item_name(*def_id);\n+                    reason = format!(\", as `{}` is an immutable static item\", static_name);\n+                }\n+            }\n+\n+            Place::Projection(box Projection {\n+                base: _,\n+                elem: ProjectionElem::Index(_),\n+            })\n+            | Place::Projection(box Projection {\n+                base: _,\n+                elem: ProjectionElem::ConstantIndex { .. },\n+            })\n+            | Place::Projection(box Projection {\n+                base: _,\n+                elem: ProjectionElem::Subslice { .. },\n+            })\n+            | Place::Projection(box Projection {\n+                base: _,\n+                elem: ProjectionElem::Downcast(..),\n+            }) => bug!(\"Unexpected immutable place.\"),\n+        }\n+\n+        // `act` and `acted_on` are strings that let us abstract over\n+        // the verbs used in some diagnostic messages.\n+        let act;\n+        let acted_on;\n+\n+\n+        let span = match error_access {\n+            AccessKind::Mutate => {\n+                err = self.tcx\n+                    .cannot_assign(span, &(item_msg + &reason), Origin::Mir);\n+                act = \"assign\";\n+                acted_on = \"written\";\n+                span\n+            }\n+            AccessKind::MutableBorrow => {\n+                act = \"borrow as mutable\";\n+                acted_on = \"borrowed as mutable\";\n+\n+                let closure_span = self.find_closure_span(span, location);\n+                if let Some((args, var)) = closure_span {\n+                    err = self.tcx.cannot_borrow_path_as_mutable_because(\n+                        args,\n+                        &item_msg,\n+                        &reason,\n+                        Origin::Mir,\n+                    );\n+                    err.span_label(\n+                        var,\n+                        format!(\n+                            \"mutable borrow occurs due to use of `{}` in closure\",\n+                            self.describe_place(access_place).unwrap(),\n+                        ),\n+                    );\n+                    args\n+                } else {\n+                    err = self.tcx.cannot_borrow_path_as_mutable_because(\n+                        span,\n+                        &item_msg,\n+                        &reason,\n+                        Origin::Mir,\n+                    );\n+                    span\n+                }\n+            }\n+        };\n+\n+        match the_place_err {\n+            // We want to suggest users use `let mut` for local (user\n+            // variable) mutations...\n+            Place::Local(local) if self.mir.local_decls[*local].can_be_made_mutable() => {\n+                // ... but it doesn't make sense to suggest it on\n+                // variables that are `ref x`, `ref mut x`, `&self`,\n+                // or `&mut self` (such variables are simply not\n+                // mutable).\n+                let local_decl = &self.mir.local_decls[*local];\n+                assert_eq!(local_decl.mutability, Mutability::Not);\n+\n+                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n+                err.span_suggestion(\n+                    local_decl.source_info.span,\n+                    \"consider changing this to be mutable\",\n+                    format!(\"mut {}\", local_decl.name.unwrap()),\n+                );\n+            }\n+\n+            // Also suggest adding mut for upvars\n+            Place::Projection(box Projection {\n+                base,\n+                elem: ProjectionElem::Field(upvar_index, _),\n+            }) => {\n+                debug_assert!(is_closure_or_generator(\n+                    base.ty(self.mir, self.tcx).to_ty(self.tcx)\n+                ));\n+\n+                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n+\n+                let upvar_hir_id = self.mir.upvar_decls[upvar_index.index()]\n+                    .var_hir_id\n+                    .assert_crate_local();\n+                let upvar_node_id = self.tcx.hir.hir_to_node_id(upvar_hir_id);\n+                if let Some(hir::map::NodeBinding(pat)) = self.tcx.hir.find(upvar_node_id) {\n+                    if let hir::PatKind::Binding(\n+                        hir::BindingAnnotation::Unannotated,\n+                        _,\n+                        upvar_ident,\n+                        _,\n+                    ) = pat.node\n+                    {\n+                        err.span_suggestion(\n+                            upvar_ident.span,\n+                            \"consider changing this to be mutable\",\n+                            format!(\"mut {}\", upvar_ident.name),\n+                        );\n+                    }\n+                }\n+            }\n+\n+            // complete hack to approximate old AST-borrowck\n+            // diagnostic: if the span starts with a mutable borrow of\n+            // a local variable, then just suggest the user remove it.\n+            Place::Local(_)\n+                if {\n+                    if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n+                        snippet.starts_with(\"&mut \")\n+                    } else {\n+                        false\n+                    }\n+                } =>\n+            {\n+                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n+                err.span_label(span, \"try removing `&mut` here\");\n+            }\n+\n+            Place::Projection(box Projection {\n+                base: Place::Local(local),\n+                elem: ProjectionElem::Deref,\n+            }) if {\n+                if let Some(ClearCrossCrate::Set(BindingForm::RefForGuard)) =\n+                    self.mir.local_decls[*local].is_user_variable\n+                {\n+                    true\n+                } else {\n+                    false\n+                }\n+            } =>\n+            {\n+                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n+                err.note(\n+                    \"variables bound in patterns are immutable until the end of the pattern guard\",\n+                );\n+            }\n+\n+            // We want to point out when a `&` can be readily replaced\n+            // with an `&mut`.\n+            //\n+            // FIXME: can this case be generalized to work for an\n+            // arbitrary base for the projection?\n+            Place::Projection(box Projection {\n+                base: Place::Local(local),\n+                elem: ProjectionElem::Deref,\n+            }) if self.mir.local_decls[*local].is_user_variable.is_some() =>\n+            {\n+                let local_decl = &self.mir.local_decls[*local];\n+                let suggestion = match local_decl.is_user_variable.as_ref().unwrap() {\n+                    ClearCrossCrate::Set(mir::BindingForm::ImplicitSelf) => {\n+                        Some(suggest_ampmut_self(local_decl))\n+                    }\n+\n+                    ClearCrossCrate::Set(mir::BindingForm::Var(mir::VarBindingForm {\n+                        binding_mode: ty::BindingMode::BindByValue(_),\n+                        opt_ty_info,\n+                        ..\n+                    })) => Some(suggest_ampmut(\n+                        self.tcx,\n+                        self.mir,\n+                        *local,\n+                        local_decl,\n+                        *opt_ty_info,\n+                    )),\n+\n+                    ClearCrossCrate::Set(mir::BindingForm::Var(mir::VarBindingForm {\n+                        binding_mode: ty::BindingMode::BindByReference(_),\n+                        ..\n+                    })) => suggest_ref_mut(self.tcx, local_decl.source_info.span),\n+\n+                    //\n+                    ClearCrossCrate::Set(mir::BindingForm::RefForGuard) => unreachable!(),\n+\n+                    ClearCrossCrate::Clear => bug!(\"saw cleared local state\"),\n+                };\n+\n+                let (pointer_sigil, pointer_desc) = if local_decl.ty.is_region_ptr() {\n+                    (\"&\", \"reference\")\n+                } else {\n+                    (\"*const\", \"pointer\")\n+                };\n+\n+                if let Some((err_help_span, suggested_code)) = suggestion {\n+                    err.span_suggestion(\n+                        err_help_span,\n+                        &format!(\"consider changing this to be a mutable {}\", pointer_desc),\n+                        suggested_code,\n+                    );\n+                }\n+\n+                if let Some(name) = local_decl.name {\n+                    err.span_label(\n+                        span,\n+                        format!(\n+                            \"`{NAME}` is a `{SIGIL}` {DESC}, \\\n+                             so the data it refers to cannot be {ACTED_ON}\",\n+                            NAME = name,\n+                            SIGIL = pointer_sigil,\n+                            DESC = pointer_desc,\n+                            ACTED_ON = acted_on\n+                        ),\n+                    );\n+                } else {\n+                    err.span_label(\n+                        span,\n+                        format!(\n+                            \"cannot {ACT} through `{SIGIL}` {DESC}\",\n+                            ACT = act,\n+                            SIGIL = pointer_sigil,\n+                            DESC = pointer_desc\n+                        ),\n+                    );\n+                }\n+            }\n+\n+            Place::Projection(box Projection {\n+                base,\n+                elem: ProjectionElem::Deref,\n+            }) if *base == Place::Local(Local::new(1)) && !self.mir.upvar_decls.is_empty() =>\n+            {\n+                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n+                err.span_help(\n+                    self.mir.span,\n+                    \"consider changing this to accept closures that implement `FnMut`\"\n+                );\n+            }\n+\n+            _ => {\n+                err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n+            }\n+        }\n+\n+        err.emit();\n+    }\n+\n+    // Does this place refer to what the user sees as an upvar\n+    fn is_upvar(&self, place: &Place<'tcx>) -> bool {\n+        match *place {\n+            Place::Projection(box Projection {\n+                ref base,\n+                elem: ProjectionElem::Field(_, _),\n+            }) => {\n+                let base_ty = base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                is_closure_or_generator(base_ty)\n+            }\n+            Place::Projection(box Projection {\n+                base:\n+                    Place::Projection(box Projection {\n+                        ref base,\n+                        elem: ProjectionElem::Field(upvar_index, _),\n+                    }),\n+                elem: ProjectionElem::Deref,\n+            }) => {\n+                let base_ty = base.ty(self.mir, self.tcx).to_ty(self.tcx);\n+                is_closure_or_generator(base_ty) && self.mir.upvar_decls[upvar_index.index()].by_ref\n+            }\n+            _ => false,\n+        }\n+    }\n+}\n+\n+fn suggest_ampmut_self<'cx, 'gcx, 'tcx>(local_decl: &mir::LocalDecl<'tcx>) -> (Span, String) {\n+    (local_decl.source_info.span, \"&mut self\".to_string())\n+}\n+\n+// When we want to suggest a user change a local variable to be a `&mut`, there\n+// are three potential \"obvious\" things to highlight:\n+//\n+// let ident [: Type] [= RightHandSideExpression];\n+//     ^^^^^    ^^^^     ^^^^^^^^^^^^^^^^^^^^^^^\n+//     (1.)     (2.)              (3.)\n+//\n+// We can always fallback on highlighting the first. But chances are good that\n+// the user experience will be better if we highlight one of the others if possible;\n+// for example, if the RHS is present and the Type is not, then the type is going to\n+// be inferred *from* the RHS, which means we should highlight that (and suggest\n+// that they borrow the RHS mutably).\n+//\n+// This implementation attempts to emulate AST-borrowck prioritization\n+// by trying (3.), then (2.) and finally falling back on (1.).\n+fn suggest_ampmut<'cx, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    mir: &Mir<'tcx>,\n+    local: Local,\n+    local_decl: &mir::LocalDecl<'tcx>,\n+    opt_ty_info: Option<Span>,\n+) -> (Span, String) {\n+    let locations = mir.find_assignments(local);\n+    if locations.len() > 0 {\n+        let assignment_rhs_span = mir.source_info(locations[0]).span;\n+        let snippet = tcx.sess.codemap().span_to_snippet(assignment_rhs_span);\n+        if let Ok(src) = snippet {\n+            if src.starts_with('&') {\n+                let borrowed_expr = src[1..].to_string();\n+                return (assignment_rhs_span, format!(\"&mut {}\", borrowed_expr));\n+            }\n+        }\n+    }\n+\n+    let highlight_span = match opt_ty_info {\n+        // if this is a variable binding with an explicit type,\n+        // try to highlight that for the suggestion.\n+        Some(ty_span) => ty_span,\n+\n+        // otherwise, just highlight the span associated with\n+        // the (MIR) LocalDecl.\n+        None => local_decl.source_info.span,\n+    };\n+\n+    let ty_mut = local_decl.ty.builtin_deref(true).unwrap();\n+    assert_eq!(ty_mut.mutbl, hir::MutImmutable);\n+    if local_decl.ty.is_region_ptr() {\n+        (highlight_span, format!(\"&mut {}\", ty_mut.ty))\n+    } else {\n+        (highlight_span, format!(\"*mut {}\", ty_mut.ty))\n+    }\n+}\n+\n+fn is_closure_or_generator(ty: ty::Ty) -> bool {\n+    ty.is_closure() || ty.is_generator()\n+}"}, {"sha": "384eb1db04ff7642740a88bb8375cdfdbd383703", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 116, "deletions": 1, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -206,7 +206,27 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                 this.consume_by_copy_or_move(place)\n                             }\n                             _ => {\n-                                unpack!(block = this.as_operand(block, scope, upvar))\n+                                // Turn mutable borrow captures into unique\n+                                // borrow captures when capturing an immutable\n+                                // variable. This is sound because the mutation\n+                                // that caused the capture will cause an error.\n+                                match upvar.kind {\n+                                    ExprKind::Borrow {\n+                                        borrow_kind: BorrowKind::Mut {\n+                                            allow_two_phase_borrow: false\n+                                        },\n+                                        region,\n+                                        arg,\n+                                    } => unpack!(block = this.limit_capture_mutability(\n+                                        upvar.span,\n+                                        upvar.ty,\n+                                        scope,\n+                                        block,\n+                                        arg,\n+                                        region,\n+                                    )),\n+                                    _ => unpack!(block = this.as_operand(block, scope, upvar)),\n+                                }\n                             }\n                         }\n                     })\n@@ -393,6 +413,101 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn limit_capture_mutability(\n+        &mut self,\n+        upvar_span: Span,\n+        upvar_ty: Ty<'tcx>,\n+        temp_lifetime: Option<region::Scope>,\n+        mut block: BasicBlock,\n+        arg: ExprRef<'tcx>,\n+        region: &'tcx ty::RegionKind,\n+    ) -> BlockAnd<Operand<'tcx>> {\n+        let this = self;\n+\n+        let source_info = this.source_info(upvar_span);\n+        let temp = this.local_decls.push(LocalDecl::new_temp(upvar_ty, upvar_span));\n+\n+        this.cfg.push(block, Statement {\n+            source_info,\n+            kind: StatementKind::StorageLive(temp)\n+        });\n+\n+        let arg_place = unpack!(block = this.as_place(block, arg));\n+\n+        let mutability = match arg_place {\n+            Place::Local(local) => this.local_decls[local].mutability,\n+            Place::Projection(box Projection {\n+                base: Place::Local(local),\n+                elem: ProjectionElem::Deref,\n+            }) => {\n+                debug_assert!(\n+                    if let Some(ClearCrossCrate::Set(BindingForm::RefForGuard))\n+                        = this.local_decls[local].is_user_variable {\n+                        true\n+                    } else {\n+                        false\n+                    },\n+                    \"Unexpected capture place\",\n+                );\n+                this.local_decls[local].mutability\n+            }\n+            Place::Projection(box Projection {\n+                ref base,\n+                elem: ProjectionElem::Field(upvar_index, _),\n+            })\n+            | Place::Projection(box Projection {\n+                base: Place::Projection(box Projection {\n+                    ref base,\n+                    elem: ProjectionElem::Field(upvar_index, _),\n+                }),\n+                elem: ProjectionElem::Deref,\n+            }) => {\n+                // Not projected from the implicit `self` in a closure.\n+                debug_assert!(\n+                    match *base {\n+                        Place::Local(local) => local == Local::new(1),\n+                        Place::Projection(box Projection {\n+                            ref base,\n+                            elem: ProjectionElem::Deref,\n+                        }) => *base == Place::Local(Local::new(1)),\n+                        _ => false,\n+                    },\n+                    \"Unexpected capture place\"\n+                );\n+                // Not in a closure\n+                debug_assert!(\n+                    this.upvar_decls.len() > upvar_index.index(),\n+                    \"Unexpected capture place\"\n+                );\n+                this.upvar_decls[upvar_index.index()].mutability\n+            }\n+            _ => bug!(\"Unexpected capture place\"),\n+        };\n+\n+        let borrow_kind = match mutability {\n+            Mutability::Not => BorrowKind::Unique,\n+            Mutability::Mut => BorrowKind::Mut { allow_two_phase_borrow: false },\n+        };\n+\n+        this.cfg.push_assign(\n+            block,\n+            source_info,\n+            &Place::Local(temp),\n+            Rvalue::Ref(region, borrow_kind, arg_place),\n+        );\n+\n+        // In constants, temp_lifetime is None. We should not need to drop\n+        // anything because no values with a destructor can be created in\n+        // a constant at this time, even if the type may need dropping.\n+        if let Some(temp_lifetime) = temp_lifetime {\n+            this.schedule_drop_storage_and_value(\n+                upvar_span, temp_lifetime, &Place::Local(temp), upvar_ty,\n+            );\n+        }\n+\n+        block.and(Operand::Move(Place::Local(temp)))\n+    }\n+\n     // Helper to get a `-1` value of the appropriate type\n     fn neg_1_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n         let param_ty = ty::ParamEnv::empty().and(self.hir.tcx().lift_to_global(&ty).unwrap());"}, {"sha": "d75b8d506e77b44292f1d4e78ade8ac5ebcc6c27", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1198,7 +1198,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 visibility_scope,\n                 // FIXME: should these secretly injected ref_for_guard's be marked as `internal`?\n                 internal: false,\n-                is_user_variable: None,\n+                is_user_variable: Some(ClearCrossCrate::Set(BindingForm::RefForGuard)),\n             });\n             LocalsForNode::Three { val_for_guard, ref_for_guard, for_arm_body }\n         } else {"}, {"sha": "24228389fbfbb1182d4db4ac3e3c8fa8d69a3ff1", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 52, "deletions": 48, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -286,6 +286,7 @@ struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     /// (A match binding can have two locals; the 2nd is for the arm's guard.)\n     var_indices: NodeMap<LocalsForNode>,\n     local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n+    upvar_decls: Vec<UpvarDecl>,\n     unit_temp: Option<Place<'tcx>>,\n \n     /// cached block with the RESUME terminator; this is created\n@@ -472,11 +473,52 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n \n     let tcx = hir.tcx();\n     let span = tcx.hir.span(fn_id);\n+\n+    // Gather the upvars of a closure, if any.\n+    let upvar_decls: Vec<_> = tcx.with_freevars(fn_id, |freevars| {\n+        freevars.iter().map(|fv| {\n+            let var_id = fv.var_id();\n+            let var_hir_id = tcx.hir.node_to_hir_id(var_id);\n+            let closure_expr_id = tcx.hir.local_def_id(fn_id);\n+            let capture = hir.tables().upvar_capture(ty::UpvarId {\n+                var_id: var_hir_id,\n+                closure_expr_id: LocalDefId::from_def_id(closure_expr_id),\n+            });\n+            let by_ref = match capture {\n+                ty::UpvarCapture::ByValue => false,\n+                ty::UpvarCapture::ByRef(..) => true\n+            };\n+            let mut decl = UpvarDecl {\n+                debug_name: keywords::Invalid.name(),\n+                var_hir_id: ClearCrossCrate::Set(var_hir_id),\n+                by_ref,\n+                mutability: Mutability::Not,\n+            };\n+            if let Some(hir::map::NodeBinding(pat)) = tcx.hir.find(var_id) {\n+                if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n+                    decl.debug_name = ident.name;\n+\n+                    if let Some(&bm) = hir.tables.pat_binding_modes().get(pat.hir_id) {\n+                        if bm == ty::BindByValue(hir::MutMutable) {\n+                            decl.mutability = Mutability::Mut;\n+                        } else {\n+                            decl.mutability = Mutability::Not;\n+                        }\n+                    } else {\n+                        tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n+                    }\n+                }\n+            }\n+            decl\n+        }).collect()\n+    });\n+\n     let mut builder = Builder::new(hir.clone(),\n         span,\n         arguments.len(),\n         safety,\n-        return_ty);\n+        return_ty,\n+        upvar_decls);\n \n     let fn_def_id = tcx.hir.local_def_id(fn_id);\n     let call_site_scope = region::Scope::CallSite(body.value.hir_id.local_id);\n@@ -519,46 +561,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     info!(\"fn_id {:?} has attrs {:?}\", closure_expr_id,\n           tcx.get_attrs(closure_expr_id));\n \n-    // Gather the upvars of a closure, if any.\n-    let upvar_decls: Vec<_> = tcx.with_freevars(fn_id, |freevars| {\n-        freevars.iter().map(|fv| {\n-            let var_id = fv.var_id();\n-            let var_hir_id = tcx.hir.node_to_hir_id(var_id);\n-            let closure_expr_id = tcx.hir.local_def_id(fn_id);\n-            let capture = hir.tables().upvar_capture(ty::UpvarId {\n-                var_id: var_hir_id,\n-                closure_expr_id: LocalDefId::from_def_id(closure_expr_id),\n-            });\n-            let by_ref = match capture {\n-                ty::UpvarCapture::ByValue => false,\n-                ty::UpvarCapture::ByRef(..) => true\n-            };\n-            let mut decl = UpvarDecl {\n-                debug_name: keywords::Invalid.name(),\n-                var_hir_id: ClearCrossCrate::Set(var_hir_id),\n-                by_ref,\n-                mutability: Mutability::Not,\n-            };\n-            if let Some(hir::map::NodeBinding(pat)) = tcx.hir.find(var_id) {\n-                if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n-                    decl.debug_name = ident.name;\n-\n-                    if let Some(&bm) = hir.tables.pat_binding_modes().get(pat.hir_id) {\n-                        if bm == ty::BindByValue(hir::MutMutable) {\n-                            decl.mutability = Mutability::Mut;\n-                        } else {\n-                            decl.mutability = Mutability::Not;\n-                        }\n-                    } else {\n-                        tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n-                    }\n-                }\n-            }\n-            decl\n-        }).collect()\n-    });\n-\n-    let mut mir = builder.finish(upvar_decls, yield_ty);\n+    let mut mir = builder.finish(yield_ty);\n     mir.spread_arg = spread_arg;\n     mir\n }\n@@ -571,7 +574,7 @@ fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n     let ty = hir.tables().expr_ty_adjusted(ast_expr);\n     let owner_id = tcx.hir.body_owner(body_id);\n     let span = tcx.hir.span(owner_id);\n-    let mut builder = Builder::new(hir.clone(), span, 0, Safety::Safe, ty);\n+    let mut builder = Builder::new(hir.clone(), span, 0, Safety::Safe, ty, vec![]);\n \n     let mut block = START_BLOCK;\n     let expr = builder.hir.mirror(ast_expr);\n@@ -590,7 +593,7 @@ fn construct_const<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n                               TerminatorKind::Unreachable);\n     }\n \n-    builder.finish(vec![], None)\n+    builder.finish(None)\n }\n \n fn construct_error<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n@@ -599,18 +602,19 @@ fn construct_error<'a, 'gcx, 'tcx>(hir: Cx<'a, 'gcx, 'tcx>,\n     let owner_id = hir.tcx().hir.body_owner(body_id);\n     let span = hir.tcx().hir.span(owner_id);\n     let ty = hir.tcx().types.err;\n-    let mut builder = Builder::new(hir, span, 0, Safety::Safe, ty);\n+    let mut builder = Builder::new(hir, span, 0, Safety::Safe, ty, vec![]);\n     let source_info = builder.source_info(span);\n     builder.cfg.terminate(START_BLOCK, source_info, TerminatorKind::Unreachable);\n-    builder.finish(vec![], None)\n+    builder.finish(None)\n }\n \n impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn new(hir: Cx<'a, 'gcx, 'tcx>,\n            span: Span,\n            arg_count: usize,\n            safety: Safety,\n-           return_ty: Ty<'tcx>)\n+           return_ty: Ty<'tcx>,\n+           upvar_decls: Vec<UpvarDecl>)\n            -> Builder<'a, 'gcx, 'tcx> {\n         let lint_level = LintLevel::Explicit(hir.root_lint_level);\n         let mut builder = Builder {\n@@ -628,6 +632,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             breakable_scopes: vec![],\n             local_decls: IndexVec::from_elem_n(LocalDecl::new_return_place(return_ty,\n                                                                              span), 1),\n+            upvar_decls,\n             var_indices: NodeMap(),\n             unit_temp: None,\n             cached_resume_block: None,\n@@ -645,7 +650,6 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     }\n \n     fn finish(self,\n-              upvar_decls: Vec<UpvarDecl>,\n               yield_ty: Option<Ty<'tcx>>)\n               -> Mir<'tcx> {\n         for (index, block) in self.cfg.basic_blocks.iter().enumerate() {\n@@ -661,7 +665,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                  yield_ty,\n                  self.local_decls,\n                  self.arg_count,\n-                 upvar_decls,\n+                 self.upvar_decls,\n                  self.fn_span\n         )\n     }"}, {"sha": "2d6b6cea030197b9673b715124d55f1e02f3a5ac", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -519,24 +519,35 @@ pub trait BorrowckErrors<'cx>: Sized + Copy {\n         self.cancel_if_wrong_origin(err, o)\n     }\n \n-    fn cannot_borrow_path_as_mutable(\n+    fn cannot_borrow_path_as_mutable_because(\n         self,\n         span: Span,\n         path: &str,\n+        reason: &str,\n         o: Origin,\n     ) -> DiagnosticBuilder<'cx> {\n         let err = struct_span_err!(\n             self,\n             span,\n             E0596,\n-            \"cannot borrow {} as mutable{OGN}\",\n+            \"cannot borrow {} as mutable{}{OGN}\",\n             path,\n-            OGN = o\n+            reason,\n+            OGN = o,\n         );\n \n         self.cancel_if_wrong_origin(err, o)\n     }\n \n+    fn cannot_borrow_path_as_mutable(\n+        self,\n+        span: Span,\n+        path: &str,\n+        o: Origin,\n+    ) -> DiagnosticBuilder<'cx> {\n+        self.cannot_borrow_path_as_mutable_because(span, path, \"\", o)\n+    }\n+\n     fn cannot_borrow_across_generator_yield(\n         self,\n         span: Span,"}, {"sha": "e5e96451d1360dbf38279cb32dd330a9ec5dc48b", "filename": "src/test/compile-fail/E0594.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fcompile-fail%2FE0594.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fcompile-fail%2FE0594.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0594.rs?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -15,5 +15,5 @@ static NUM: i32 = 18;\n \n fn main() {\n     NUM = 20; //[ast]~ ERROR E0594\n-              //[mir]~^ ERROR cannot assign to immutable item `NUM`\n+              //[mir]~^ ERROR cannot assign to immutable static item `NUM`\n }"}, {"sha": "57002dd40fc95fd31a90ca8bab41e1caafd939d0", "filename": "src/test/compile-fail/borrowck/borrowck-assign-to-constants.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-assign-to-constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-assign-to-constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-assign-to-constants.rs?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -16,5 +16,5 @@ static foo: isize = 5;\n fn main() {\n     // assigning to various global constants\n     foo = 6; //[ast]~ ERROR cannot assign to immutable static item\n-             //[mir]~^ ERROR cannot assign to immutable item `foo`\n+             //[mir]~^ ERROR cannot assign to immutable static item `foo`\n }"}, {"sha": "6bd52f00788e6bb96385fa1f04e50e7118e2668a", "filename": "src/test/compile-fail/cannot-mutate-captured-non-mut-var.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fcompile-fail%2Fcannot-mutate-captured-non-mut-var.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fcompile-fail%2Fcannot-mutate-captured-non-mut-var.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcannot-mutate-captured-non-mut-var.rs?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -22,10 +22,10 @@ fn main() {\n     let x = 1;\n     to_fn_once(move|| { x = 2; });\n     //[ast]~^ ERROR: cannot assign to immutable captured outer variable\n-    //[mir]~^^ ERROR: cannot assign to immutable item `x`\n+    //[mir]~^^ ERROR: cannot assign to `x`, as it is not declared as mutable\n \n     let s = std::io::stdin();\n     to_fn_once(move|| { s.read_to_end(&mut Vec::new()); });\n     //[ast]~^ ERROR: cannot borrow immutable captured outer variable\n-    //[mir]~^^ ERROR: cannot borrow immutable item `s` as mutable\n+    //[mir]~^^ ERROR: cannot borrow `s` as mutable, as it is not declared as mutable\n }"}, {"sha": "7b1dd9265af0da33abfb1d7d76aeac4c695d94ea", "filename": "src/test/compile-fail/nll/constant-thread-locals-issue-47053.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fcompile-fail%2Fnll%2Fconstant-thread-locals-issue-47053.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fcompile-fail%2Fnll%2Fconstant-thread-locals-issue-47053.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnll%2Fconstant-thread-locals-issue-47053.rs?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -17,5 +17,5 @@\n static FOO: isize = 5;\n \n fn main() {\n-    FOO = 6; //~ ERROR cannot assign to immutable item `FOO` [E0594]\n+    FOO = 6; //~ ERROR cannot assign to immutable static item `FOO` [E0594]\n }"}, {"sha": "57a86227f764d104d6dfa82b593dbc80eeee2f81", "filename": "src/test/ui/augmented-assignments.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Faugmented-assignments.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Faugmented-assignments.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Faugmented-assignments.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -14,7 +14,7 @@ LL | |     x;  //~ value moved here\n    | |_____move out of `x` occurs here\n    |       borrow later used here\n \n-error[E0596]: cannot borrow immutable item `y` as mutable\n+error[E0596]: cannot borrow `y` as mutable, as it is not declared as mutable\n   --> $DIR/augmented-assignments.rs:30:5\n    |\n LL |     let y = Int(2);"}, {"sha": "5a1f1986fcf05c31151405339555760702a06eaf", "filename": "src/test/ui/borrowck/issue-45983.nll.stderr", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fborrowck%2Fissue-45983.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fborrowck%2Fissue-45983.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-45983.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -14,21 +14,14 @@ LL |     give_any(|y| x = Some(y));\n    |               |\n    |               lifetime `'1` appears in this argument\n \n-error[E0594]: cannot assign to immutable item `x`\n+error[E0594]: cannot assign to `x`, as it is not declared as mutable\n   --> $DIR/issue-45983.rs:17:18\n    |\n-LL |     give_any(|y| x = Some(y));\n-   |                  ^^^^^^^^^^^ cannot assign\n-\n-error[E0596]: cannot borrow immutable item `x` as mutable\n-  --> $DIR/issue-45983.rs:17:14\n-   |\n LL |     let x = None;\n    |         - help: consider changing this to be mutable: `mut x`\n LL |     give_any(|y| x = Some(y));\n-   |              ^^^^^^^^^^^^^^^ cannot borrow as mutable\n+   |                  ^^^^^^^^^^^ cannot assign\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 2 previous errors\n \n-Some errors occurred: E0594, E0596.\n-For more information about an error, try `rustc --explain E0594`.\n+For more information about this error, try `rustc --explain E0594`."}, {"sha": "ece3c62e6a940b5dd6ef45ae8ab8b0a765b965ff", "filename": "src/test/ui/borrowck/mut-borrow-of-mut-ref.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-of-mut-ref.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-of-mut-ref.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmut-borrow-of-mut-ref.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,4 +1,4 @@\n-error[E0596]: cannot borrow immutable item `b` as mutable\n+error[E0596]: cannot borrow `b` as mutable, as it is not declared as mutable\n   --> $DIR/mut-borrow-of-mut-ref.rs:18:7\n    |\n LL | fn f(b: &mut i32) {"}, {"sha": "14c41bb81b2c65594af40320298f4e157a95e47b", "filename": "src/test/ui/borrowck/mutability-errors.nll.stderr", "status": "added", "additions": 379, "deletions": 0, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fborrowck%2Fmutability-errors.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fborrowck%2Fmutability-errors.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmutability-errors.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -0,0 +1,379 @@\n+error[E0594]: cannot assign to `*x` which is behind a `&` reference\n+  --> $DIR/mutability-errors.rs:19:5\n+   |\n+LL | fn named_ref(x: &(i32,)) {\n+   |                 ------- help: consider changing this to be a mutable reference: `&mut (i32,)`\n+LL |     *x = (1,); //~ ERROR\n+   |     ^^^^^^^^^ `x` is a `&` reference, so the data it refers to cannot be written\n+\n+error[E0594]: cannot assign to `x.0` which is behind a `&` reference\n+  --> $DIR/mutability-errors.rs:20:5\n+   |\n+LL | fn named_ref(x: &(i32,)) {\n+   |                 ------- help: consider changing this to be a mutable reference: `&mut (i32,)`\n+LL |     *x = (1,); //~ ERROR\n+LL |     x.0 = 1; //~ ERROR\n+   |     ^^^^^^^ `x` is a `&` reference, so the data it refers to cannot be written\n+\n+error[E0596]: cannot borrow `*x` as mutable, as it is behind a `&` reference\n+  --> $DIR/mutability-errors.rs:21:5\n+   |\n+LL | fn named_ref(x: &(i32,)) {\n+   |                 ------- help: consider changing this to be a mutable reference: `&mut (i32,)`\n+...\n+LL |     &mut *x; //~ ERROR\n+   |     ^^^^^^^ `x` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n+\n+error[E0596]: cannot borrow `x.0` as mutable, as it is behind a `&` reference\n+  --> $DIR/mutability-errors.rs:22:5\n+   |\n+LL | fn named_ref(x: &(i32,)) {\n+   |                 ------- help: consider changing this to be a mutable reference: `&mut (i32,)`\n+...\n+LL |     &mut x.0; //~ ERROR\n+   |     ^^^^^^^^ `x` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n+\n+error[E0594]: cannot assign to data in a `&` reference\n+  --> $DIR/mutability-errors.rs:26:5\n+   |\n+LL |     *f() = (1,); //~ ERROR\n+   |     ^^^^^^^^^^^ cannot assign\n+\n+error[E0594]: cannot assign to data in a `&` reference\n+  --> $DIR/mutability-errors.rs:27:5\n+   |\n+LL |     f().0 = 1; //~ ERROR\n+   |     ^^^^^^^^^ cannot assign\n+\n+error[E0596]: cannot borrow data in a `&` reference as mutable\n+  --> $DIR/mutability-errors.rs:28:5\n+   |\n+LL |     &mut *f(); //~ ERROR\n+   |     ^^^^^^^^^ cannot borrow as mutable\n+\n+error[E0596]: cannot borrow data in a `&` reference as mutable\n+  --> $DIR/mutability-errors.rs:29:5\n+   |\n+LL |     &mut f().0; //~ ERROR\n+   |     ^^^^^^^^^^ cannot borrow as mutable\n+\n+error[E0594]: cannot assign to `*x` which is behind a `*const` pointer\n+  --> $DIR/mutability-errors.rs:33:5\n+   |\n+LL | unsafe fn named_ptr(x: *const (i32,)) {\n+   |                        ------------- help: consider changing this to be a mutable pointer: `*mut (i32,)`\n+LL |     *x = (1,); //~ ERROR\n+   |     ^^^^^^^^^ `x` is a `*const` pointer, so the data it refers to cannot be written\n+\n+error[E0594]: cannot assign to `x.0` which is behind a `*const` pointer\n+  --> $DIR/mutability-errors.rs:34:5\n+   |\n+LL | unsafe fn named_ptr(x: *const (i32,)) {\n+   |                        ------------- help: consider changing this to be a mutable pointer: `*mut (i32,)`\n+LL |     *x = (1,); //~ ERROR\n+LL |     (*x).0 = 1; //~ ERROR\n+   |     ^^^^^^^^^^ `x` is a `*const` pointer, so the data it refers to cannot be written\n+\n+error[E0596]: cannot borrow `*x` as mutable, as it is behind a `*const` pointer\n+  --> $DIR/mutability-errors.rs:35:5\n+   |\n+LL | unsafe fn named_ptr(x: *const (i32,)) {\n+   |                        ------------- help: consider changing this to be a mutable pointer: `*mut (i32,)`\n+...\n+LL |     &mut *x; //~ ERROR\n+   |     ^^^^^^^ `x` is a `*const` pointer, so the data it refers to cannot be borrowed as mutable\n+\n+error[E0596]: cannot borrow `x.0` as mutable, as it is behind a `*const` pointer\n+  --> $DIR/mutability-errors.rs:36:5\n+   |\n+LL | unsafe fn named_ptr(x: *const (i32,)) {\n+   |                        ------------- help: consider changing this to be a mutable pointer: `*mut (i32,)`\n+...\n+LL |     &mut (*x).0; //~ ERROR\n+   |     ^^^^^^^^^^^ `x` is a `*const` pointer, so the data it refers to cannot be borrowed as mutable\n+\n+error[E0594]: cannot assign to data in a `*const` pointer\n+  --> $DIR/mutability-errors.rs:40:5\n+   |\n+LL |     *f() = (1,); //~ ERROR\n+   |     ^^^^^^^^^^^ cannot assign\n+\n+error[E0594]: cannot assign to data in a `*const` pointer\n+  --> $DIR/mutability-errors.rs:41:5\n+   |\n+LL |     (*f()).0 = 1; //~ ERROR\n+   |     ^^^^^^^^^^^^ cannot assign\n+\n+error[E0596]: cannot borrow data in a `*const` pointer as mutable\n+  --> $DIR/mutability-errors.rs:42:5\n+   |\n+LL |     &mut *f(); //~ ERROR\n+   |     ^^^^^^^^^ cannot borrow as mutable\n+\n+error[E0596]: cannot borrow data in a `*const` pointer as mutable\n+  --> $DIR/mutability-errors.rs:43:5\n+   |\n+LL |     &mut (*f()).0; //~ ERROR\n+   |     ^^^^^^^^^^^^^ cannot borrow as mutable\n+\n+error[E0594]: cannot assign to `x`, as it is a captured variable in a `Fn` closure\n+  --> $DIR/mutability-errors.rs:50:9\n+   |\n+LL |         x = (1,); //~ ERROR\n+   |         ^^^^^^^^ cannot assign\n+   |\n+help: consider changing this to accept closures that implement `FnMut`\n+  --> $DIR/mutability-errors.rs:49:12\n+   |\n+LL |       fn_ref(|| {\n+   |  ____________^\n+LL | |         x = (1,); //~ ERROR\n+LL | |         x.0 = 1; //~ ERROR\n+LL | |         &mut x; //~ ERROR\n+LL | |         &mut x.0; //~ ERROR\n+LL | |     });\n+   | |_____^\n+\n+error[E0594]: cannot assign to `x.0`, as `Fn` closures cannot mutate their captured variables\n+  --> $DIR/mutability-errors.rs:51:9\n+   |\n+LL |         x.0 = 1; //~ ERROR\n+   |         ^^^^^^^ cannot assign\n+   |\n+help: consider changing this to accept closures that implement `FnMut`\n+  --> $DIR/mutability-errors.rs:49:12\n+   |\n+LL |       fn_ref(|| {\n+   |  ____________^\n+LL | |         x = (1,); //~ ERROR\n+LL | |         x.0 = 1; //~ ERROR\n+LL | |         &mut x; //~ ERROR\n+LL | |         &mut x.0; //~ ERROR\n+LL | |     });\n+   | |_____^\n+\n+error[E0596]: cannot borrow `x` as mutable, as it is a captured variable in a `Fn` closure\n+  --> $DIR/mutability-errors.rs:52:9\n+   |\n+LL |         &mut x; //~ ERROR\n+   |         ^^^^^^ cannot borrow as mutable\n+   |\n+help: consider changing this to accept closures that implement `FnMut`\n+  --> $DIR/mutability-errors.rs:49:12\n+   |\n+LL |       fn_ref(|| {\n+   |  ____________^\n+LL | |         x = (1,); //~ ERROR\n+LL | |         x.0 = 1; //~ ERROR\n+LL | |         &mut x; //~ ERROR\n+LL | |         &mut x.0; //~ ERROR\n+LL | |     });\n+   | |_____^\n+\n+error[E0596]: cannot borrow `x.0` as mutable, as `Fn` closures cannot mutate their captured variables\n+  --> $DIR/mutability-errors.rs:53:9\n+   |\n+LL |         &mut x.0; //~ ERROR\n+   |         ^^^^^^^^ cannot borrow as mutable\n+   |\n+help: consider changing this to accept closures that implement `FnMut`\n+  --> $DIR/mutability-errors.rs:49:12\n+   |\n+LL |       fn_ref(|| {\n+   |  ____________^\n+LL | |         x = (1,); //~ ERROR\n+LL | |         x.0 = 1; //~ ERROR\n+LL | |         &mut x; //~ ERROR\n+LL | |         &mut x.0; //~ ERROR\n+LL | |     });\n+   | |_____^\n+\n+error[E0594]: cannot assign to `x`, as it is a captured variable in a `Fn` closure\n+  --> $DIR/mutability-errors.rs:56:9\n+   |\n+LL |         x = (1,); //~ ERROR\n+   |         ^^^^^^^^ cannot assign\n+   |\n+help: consider changing this to accept closures that implement `FnMut`\n+  --> $DIR/mutability-errors.rs:55:12\n+   |\n+LL |       fn_ref(move || {\n+   |  ____________^\n+LL | |         x = (1,); //~ ERROR\n+LL | |         x.0 = 1; //~ ERROR\n+LL | |         &mut x; //~ ERROR\n+LL | |         &mut x.0; //~ ERROR\n+LL | |     });\n+   | |_____^\n+\n+error[E0594]: cannot assign to `x.0`, as `Fn` closures cannot mutate their captured variables\n+  --> $DIR/mutability-errors.rs:57:9\n+   |\n+LL |         x.0 = 1; //~ ERROR\n+   |         ^^^^^^^ cannot assign\n+   |\n+help: consider changing this to accept closures that implement `FnMut`\n+  --> $DIR/mutability-errors.rs:55:12\n+   |\n+LL |       fn_ref(move || {\n+   |  ____________^\n+LL | |         x = (1,); //~ ERROR\n+LL | |         x.0 = 1; //~ ERROR\n+LL | |         &mut x; //~ ERROR\n+LL | |         &mut x.0; //~ ERROR\n+LL | |     });\n+   | |_____^\n+\n+error[E0596]: cannot borrow `x` as mutable, as it is a captured variable in a `Fn` closure\n+  --> $DIR/mutability-errors.rs:58:9\n+   |\n+LL |         &mut x; //~ ERROR\n+   |         ^^^^^^ cannot borrow as mutable\n+   |\n+help: consider changing this to accept closures that implement `FnMut`\n+  --> $DIR/mutability-errors.rs:55:12\n+   |\n+LL |       fn_ref(move || {\n+   |  ____________^\n+LL | |         x = (1,); //~ ERROR\n+LL | |         x.0 = 1; //~ ERROR\n+LL | |         &mut x; //~ ERROR\n+LL | |         &mut x.0; //~ ERROR\n+LL | |     });\n+   | |_____^\n+\n+error[E0596]: cannot borrow `x.0` as mutable, as `Fn` closures cannot mutate their captured variables\n+  --> $DIR/mutability-errors.rs:59:9\n+   |\n+LL |         &mut x.0; //~ ERROR\n+   |         ^^^^^^^^ cannot borrow as mutable\n+   |\n+help: consider changing this to accept closures that implement `FnMut`\n+  --> $DIR/mutability-errors.rs:55:12\n+   |\n+LL |       fn_ref(move || {\n+   |  ____________^\n+LL | |         x = (1,); //~ ERROR\n+LL | |         x.0 = 1; //~ ERROR\n+LL | |         &mut x; //~ ERROR\n+LL | |         &mut x.0; //~ ERROR\n+LL | |     });\n+   | |_____^\n+\n+error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\n+  --> $DIR/mutability-errors.rs:64:5\n+   |\n+LL | fn imm_local(x: (i32,)) {\n+   |              - help: consider changing this to be mutable: `mut x`\n+LL |     &mut x; //~ ERROR\n+   |     ^^^^^^ cannot borrow as mutable\n+\n+error[E0596]: cannot borrow `x.0` as mutable, as `x` is not declared as mutable\n+  --> $DIR/mutability-errors.rs:65:5\n+   |\n+LL | fn imm_local(x: (i32,)) {\n+   |              - help: consider changing this to be mutable: `mut x`\n+LL |     &mut x; //~ ERROR\n+LL |     &mut x.0; //~ ERROR\n+   |     ^^^^^^^^ cannot borrow as mutable\n+\n+error[E0594]: cannot assign to `x`, as it is not declared as mutable\n+  --> $DIR/mutability-errors.rs:70:9\n+   |\n+LL | fn imm_capture(x: (i32,)) {\n+   |                - help: consider changing this to be mutable: `mut x`\n+LL |     || { //~ ERROR\n+LL |         x = (1,);\n+   |         ^^^^^^^^ cannot assign\n+\n+error[E0594]: cannot assign to `x.0`, as `x` is not declared as mutable\n+  --> $DIR/mutability-errors.rs:71:9\n+   |\n+LL | fn imm_capture(x: (i32,)) {\n+   |                - help: consider changing this to be mutable: `mut x`\n+...\n+LL |         x.0 = 1;\n+   |         ^^^^^^^ cannot assign\n+\n+error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\n+  --> $DIR/mutability-errors.rs:72:9\n+   |\n+LL | fn imm_capture(x: (i32,)) {\n+   |                - help: consider changing this to be mutable: `mut x`\n+...\n+LL |         &mut x;\n+   |         ^^^^^^ cannot borrow as mutable\n+\n+error[E0596]: cannot borrow `x.0` as mutable, as `x` is not declared as mutable\n+  --> $DIR/mutability-errors.rs:73:9\n+   |\n+LL | fn imm_capture(x: (i32,)) {\n+   |                - help: consider changing this to be mutable: `mut x`\n+...\n+LL |         &mut x.0;\n+   |         ^^^^^^^^ cannot borrow as mutable\n+\n+error[E0594]: cannot assign to `x`, as it is not declared as mutable\n+  --> $DIR/mutability-errors.rs:76:9\n+   |\n+LL | fn imm_capture(x: (i32,)) {\n+   |                - help: consider changing this to be mutable: `mut x`\n+...\n+LL |         x = (1,); //~ ERROR\n+   |         ^^^^^^^^ cannot assign\n+\n+error[E0594]: cannot assign to `x.0`, as `x` is not declared as mutable\n+  --> $DIR/mutability-errors.rs:77:9\n+   |\n+LL | fn imm_capture(x: (i32,)) {\n+   |                - help: consider changing this to be mutable: `mut x`\n+...\n+LL |         x.0 = 1; //~ ERROR\n+   |         ^^^^^^^ cannot assign\n+\n+error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\n+  --> $DIR/mutability-errors.rs:78:9\n+   |\n+LL | fn imm_capture(x: (i32,)) {\n+   |                - help: consider changing this to be mutable: `mut x`\n+...\n+LL |         &mut x; //~ ERROR\n+   |         ^^^^^^ cannot borrow as mutable\n+\n+error[E0596]: cannot borrow `x.0` as mutable, as `x` is not declared as mutable\n+  --> $DIR/mutability-errors.rs:79:9\n+   |\n+LL | fn imm_capture(x: (i32,)) {\n+   |                - help: consider changing this to be mutable: `mut x`\n+...\n+LL |         &mut x.0; //~ ERROR\n+   |         ^^^^^^^^ cannot borrow as mutable\n+\n+error[E0594]: cannot assign to immutable static item `X`\n+  --> $DIR/mutability-errors.rs:86:5\n+   |\n+LL |     X = (1,); //~ ERROR\n+   |     ^^^^^^^^ cannot assign\n+\n+error[E0594]: cannot assign to `X.0`, as `X` is an immutable static item\n+  --> $DIR/mutability-errors.rs:87:5\n+   |\n+LL |     X.0 = 1; //~ ERROR\n+   |     ^^^^^^^ cannot assign\n+\n+error[E0596]: cannot borrow immutable static item `X` as mutable\n+  --> $DIR/mutability-errors.rs:88:5\n+   |\n+LL |     &mut X; //~ ERROR\n+   |     ^^^^^^ cannot borrow as mutable\n+\n+error[E0596]: cannot borrow `X.0` as mutable, as `X` is an immutable static item\n+  --> $DIR/mutability-errors.rs:89:5\n+   |\n+LL |     &mut X.0; //~ ERROR\n+   |     ^^^^^^^^ cannot borrow as mutable\n+\n+error: aborting due to 38 previous errors\n+\n+Some errors occurred: E0594, E0596.\n+For more information about an error, try `rustc --explain E0594`."}, {"sha": "0b4548cbebb7df6fd3df325361402ed1ce4587eb", "filename": "src/test/ui/borrowck/mutability-errors.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fborrowck%2Fmutability-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fborrowck%2Fmutability-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmutability-errors.rs?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -0,0 +1,92 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// All the possible mutability error cases.\n+\n+#![allow(unused)]\n+\n+type MakeRef = fn() -> &'static (i32,);\n+type MakePtr = fn() -> *const (i32,);\n+\n+fn named_ref(x: &(i32,)) {\n+    *x = (1,); //~ ERROR\n+    x.0 = 1; //~ ERROR\n+    &mut *x; //~ ERROR\n+    &mut x.0; //~ ERROR\n+}\n+\n+fn unnamed_ref(f: MakeRef) {\n+    *f() = (1,); //~ ERROR\n+    f().0 = 1; //~ ERROR\n+    &mut *f(); //~ ERROR\n+    &mut f().0; //~ ERROR\n+}\n+\n+unsafe fn named_ptr(x: *const (i32,)) {\n+    *x = (1,); //~ ERROR\n+    (*x).0 = 1; //~ ERROR\n+    &mut *x; //~ ERROR\n+    &mut (*x).0; //~ ERROR\n+}\n+\n+unsafe fn unnamed_ptr(f: MakePtr) {\n+    *f() = (1,); //~ ERROR\n+    (*f()).0 = 1; //~ ERROR\n+    &mut *f(); //~ ERROR\n+    &mut (*f()).0; //~ ERROR\n+}\n+\n+fn fn_ref<F: Fn()>(f: F) -> F { f }\n+\n+fn ref_closure(mut x: (i32,)) {\n+    fn_ref(|| {\n+        x = (1,); //~ ERROR\n+        x.0 = 1; //~ ERROR\n+        &mut x; //~ ERROR\n+        &mut x.0; //~ ERROR\n+    });\n+    fn_ref(move || {\n+        x = (1,); //~ ERROR\n+        x.0 = 1; //~ ERROR\n+        &mut x; //~ ERROR\n+        &mut x.0; //~ ERROR\n+    });\n+}\n+\n+fn imm_local(x: (i32,)) {\n+    &mut x; //~ ERROR\n+    &mut x.0; //~ ERROR\n+}\n+\n+fn imm_capture(x: (i32,)) {\n+    || { //~ ERROR\n+        x = (1,);\n+        x.0 = 1;\n+        &mut x;\n+        &mut x.0;\n+    };\n+    move || {\n+        x = (1,); //~ ERROR\n+        x.0 = 1; //~ ERROR\n+        &mut x; //~ ERROR\n+        &mut x.0; //~ ERROR\n+    };\n+}\n+\n+static X: (i32,) = (0,);\n+\n+fn imm_static() {\n+    X = (1,); //~ ERROR\n+    X.0 = 1; //~ ERROR\n+    &mut X; //~ ERROR\n+    &mut X.0; //~ ERROR\n+}\n+\n+fn main() {}"}, {"sha": "d77254f31414b8251eb156c44680b3e3437b920d", "filename": "src/test/ui/borrowck/mutability-errors.stderr", "status": "added", "additions": 308, "deletions": 0, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fborrowck%2Fmutability-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fborrowck%2Fmutability-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fmutability-errors.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -0,0 +1,308 @@\n+error[E0594]: cannot assign to immutable borrowed content `*x`\n+  --> $DIR/mutability-errors.rs:19:5\n+   |\n+LL | fn named_ref(x: &(i32,)) {\n+   |                 ------- use `&mut (i32,)` here to make mutable\n+LL |     *x = (1,); //~ ERROR\n+   |     ^^^^^^^^^ cannot borrow as mutable\n+\n+error[E0594]: cannot assign to field `x.0` of immutable binding\n+  --> $DIR/mutability-errors.rs:20:5\n+   |\n+LL | fn named_ref(x: &(i32,)) {\n+   |                 ------- use `&mut (i32,)` here to make mutable\n+LL |     *x = (1,); //~ ERROR\n+LL |     x.0 = 1; //~ ERROR\n+   |     ^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0596]: cannot borrow immutable borrowed content `*x` as mutable\n+  --> $DIR/mutability-errors.rs:21:10\n+   |\n+LL | fn named_ref(x: &(i32,)) {\n+   |                 ------- use `&mut (i32,)` here to make mutable\n+...\n+LL |     &mut *x; //~ ERROR\n+   |          ^^ cannot borrow as mutable\n+\n+error[E0596]: cannot borrow field `x.0` of immutable binding as mutable\n+  --> $DIR/mutability-errors.rs:22:10\n+   |\n+LL | fn named_ref(x: &(i32,)) {\n+   |                 ------- use `&mut (i32,)` here to make mutable\n+...\n+LL |     &mut x.0; //~ ERROR\n+   |          ^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0594]: cannot assign to immutable borrowed content\n+  --> $DIR/mutability-errors.rs:26:5\n+   |\n+LL |     *f() = (1,); //~ ERROR\n+   |     ^^^^^^^^^^^ cannot borrow as mutable\n+\n+error[E0594]: cannot assign to field of immutable binding\n+  --> $DIR/mutability-errors.rs:27:5\n+   |\n+LL |     f().0 = 1; //~ ERROR\n+   |     ^^^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0596]: cannot borrow immutable borrowed content as mutable\n+  --> $DIR/mutability-errors.rs:28:10\n+   |\n+LL |     &mut *f(); //~ ERROR\n+   |          ^^^^ cannot borrow as mutable\n+\n+error[E0596]: cannot borrow field of immutable binding as mutable\n+  --> $DIR/mutability-errors.rs:29:10\n+   |\n+LL |     &mut f().0; //~ ERROR\n+   |          ^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0594]: cannot assign to immutable dereference of raw pointer `*x`\n+  --> $DIR/mutability-errors.rs:33:5\n+   |\n+LL |     *x = (1,); //~ ERROR\n+   |     ^^^^^^^^^ cannot borrow as mutable\n+\n+error[E0594]: cannot assign to field `x.0` of immutable binding\n+  --> $DIR/mutability-errors.rs:34:5\n+   |\n+LL |     (*x).0 = 1; //~ ERROR\n+   |     ^^^^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0596]: cannot borrow immutable dereference of raw pointer `*x` as mutable\n+  --> $DIR/mutability-errors.rs:35:10\n+   |\n+LL |     &mut *x; //~ ERROR\n+   |          ^^ cannot borrow as mutable\n+\n+error[E0596]: cannot borrow field `x.0` of immutable binding as mutable\n+  --> $DIR/mutability-errors.rs:36:10\n+   |\n+LL |     &mut (*x).0; //~ ERROR\n+   |          ^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0594]: cannot assign to immutable dereference of raw pointer\n+  --> $DIR/mutability-errors.rs:40:5\n+   |\n+LL |     *f() = (1,); //~ ERROR\n+   |     ^^^^^^^^^^^ cannot borrow as mutable\n+\n+error[E0594]: cannot assign to field of immutable binding\n+  --> $DIR/mutability-errors.rs:41:5\n+   |\n+LL |     (*f()).0 = 1; //~ ERROR\n+   |     ^^^^^^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0596]: cannot borrow immutable dereference of raw pointer as mutable\n+  --> $DIR/mutability-errors.rs:42:10\n+   |\n+LL |     &mut *f(); //~ ERROR\n+   |          ^^^^ cannot borrow as mutable\n+\n+error[E0596]: cannot borrow field of immutable binding as mutable\n+  --> $DIR/mutability-errors.rs:43:10\n+   |\n+LL |     &mut (*f()).0; //~ ERROR\n+   |          ^^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0387]: cannot assign to data in a captured outer variable in an `Fn` closure\n+  --> $DIR/mutability-errors.rs:50:9\n+   |\n+LL |         x = (1,); //~ ERROR\n+   |         ^^^^^^^^\n+   |\n+help: consider changing this closure to take self by mutable reference\n+  --> $DIR/mutability-errors.rs:49:12\n+   |\n+LL |       fn_ref(|| {\n+   |  ____________^\n+LL | |         x = (1,); //~ ERROR\n+LL | |         x.0 = 1; //~ ERROR\n+LL | |         &mut x; //~ ERROR\n+LL | |         &mut x.0; //~ ERROR\n+LL | |     });\n+   | |_____^\n+\n+error[E0387]: cannot assign to data in a captured outer variable in an `Fn` closure\n+  --> $DIR/mutability-errors.rs:51:9\n+   |\n+LL |         x.0 = 1; //~ ERROR\n+   |         ^^^^^^^\n+   |\n+help: consider changing this closure to take self by mutable reference\n+  --> $DIR/mutability-errors.rs:49:12\n+   |\n+LL |       fn_ref(|| {\n+   |  ____________^\n+LL | |         x = (1,); //~ ERROR\n+LL | |         x.0 = 1; //~ ERROR\n+LL | |         &mut x; //~ ERROR\n+LL | |         &mut x.0; //~ ERROR\n+LL | |     });\n+   | |_____^\n+\n+error[E0387]: cannot borrow data mutably in a captured outer variable in an `Fn` closure\n+  --> $DIR/mutability-errors.rs:52:14\n+   |\n+LL |         &mut x; //~ ERROR\n+   |              ^\n+   |\n+help: consider changing this closure to take self by mutable reference\n+  --> $DIR/mutability-errors.rs:49:12\n+   |\n+LL |       fn_ref(|| {\n+   |  ____________^\n+LL | |         x = (1,); //~ ERROR\n+LL | |         x.0 = 1; //~ ERROR\n+LL | |         &mut x; //~ ERROR\n+LL | |         &mut x.0; //~ ERROR\n+LL | |     });\n+   | |_____^\n+\n+error[E0387]: cannot borrow data mutably in a captured outer variable in an `Fn` closure\n+  --> $DIR/mutability-errors.rs:53:14\n+   |\n+LL |         &mut x.0; //~ ERROR\n+   |              ^^^\n+   |\n+help: consider changing this closure to take self by mutable reference\n+  --> $DIR/mutability-errors.rs:49:12\n+   |\n+LL |       fn_ref(|| {\n+   |  ____________^\n+LL | |         x = (1,); //~ ERROR\n+LL | |         x.0 = 1; //~ ERROR\n+LL | |         &mut x; //~ ERROR\n+LL | |         &mut x.0; //~ ERROR\n+LL | |     });\n+   | |_____^\n+\n+error[E0594]: cannot assign to captured outer variable in an `Fn` closure\n+  --> $DIR/mutability-errors.rs:56:9\n+   |\n+LL |         x = (1,); //~ ERROR\n+   |         ^^^^^^^^\n+   |\n+   = note: `Fn` closures cannot capture their enclosing environment for modifications\n+help: consider changing this closure to take self by mutable reference\n+  --> $DIR/mutability-errors.rs:55:12\n+   |\n+LL |       fn_ref(move || {\n+   |  ____________^\n+LL | |         x = (1,); //~ ERROR\n+LL | |         x.0 = 1; //~ ERROR\n+LL | |         &mut x; //~ ERROR\n+LL | |         &mut x.0; //~ ERROR\n+LL | |     });\n+   | |_____^\n+\n+error[E0594]: cannot assign to field `x.0` of immutable binding\n+  --> $DIR/mutability-errors.rs:57:9\n+   |\n+LL |         x.0 = 1; //~ ERROR\n+   |         ^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0596]: cannot borrow captured outer variable in an `Fn` closure as mutable\n+  --> $DIR/mutability-errors.rs:58:14\n+   |\n+LL |         &mut x; //~ ERROR\n+   |              ^\n+   |\n+help: consider changing this closure to take self by mutable reference\n+  --> $DIR/mutability-errors.rs:55:12\n+   |\n+LL |       fn_ref(move || {\n+   |  ____________^\n+LL | |         x = (1,); //~ ERROR\n+LL | |         x.0 = 1; //~ ERROR\n+LL | |         &mut x; //~ ERROR\n+LL | |         &mut x.0; //~ ERROR\n+LL | |     });\n+   | |_____^\n+\n+error[E0596]: cannot borrow field `x.0` of immutable binding as mutable\n+  --> $DIR/mutability-errors.rs:59:14\n+   |\n+LL |         &mut x.0; //~ ERROR\n+   |              ^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0596]: cannot borrow immutable argument `x` as mutable\n+  --> $DIR/mutability-errors.rs:64:10\n+   |\n+LL | fn imm_local(x: (i32,)) {\n+   |              - consider changing this to `mut x`\n+LL |     &mut x; //~ ERROR\n+   |          ^ cannot borrow mutably\n+\n+error[E0596]: cannot borrow field `x.0` of immutable binding as mutable\n+  --> $DIR/mutability-errors.rs:65:10\n+   |\n+LL | fn imm_local(x: (i32,)) {\n+   |              - consider changing this to `mut x`\n+LL |     &mut x; //~ ERROR\n+LL |     &mut x.0; //~ ERROR\n+   |          ^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0595]: closure cannot assign to immutable argument `x`\n+  --> $DIR/mutability-errors.rs:69:5\n+   |\n+LL | fn imm_capture(x: (i32,)) {\n+   |                - consider changing this to `mut x`\n+LL |     || { //~ ERROR\n+   |     ^^ cannot borrow mutably\n+\n+error[E0594]: cannot assign to captured outer variable in an `FnMut` closure\n+  --> $DIR/mutability-errors.rs:76:9\n+   |\n+LL | fn imm_capture(x: (i32,)) {\n+   |                - help: consider making `x` mutable: `mut x`\n+...\n+LL |         x = (1,); //~ ERROR\n+   |         ^^^^^^^^\n+\n+error[E0594]: cannot assign to field `x.0` of immutable binding\n+  --> $DIR/mutability-errors.rs:77:9\n+   |\n+LL |         x.0 = 1; //~ ERROR\n+   |         ^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0596]: cannot borrow captured outer variable in an `FnMut` closure as mutable\n+  --> $DIR/mutability-errors.rs:78:14\n+   |\n+LL |         &mut x; //~ ERROR\n+   |              ^\n+\n+error[E0596]: cannot borrow field `x.0` of immutable binding as mutable\n+  --> $DIR/mutability-errors.rs:79:14\n+   |\n+LL |         &mut x.0; //~ ERROR\n+   |              ^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0594]: cannot assign to immutable static item\n+  --> $DIR/mutability-errors.rs:86:5\n+   |\n+LL |     X = (1,); //~ ERROR\n+   |     ^^^^^^^^\n+\n+error[E0594]: cannot assign to field of immutable binding\n+  --> $DIR/mutability-errors.rs:87:5\n+   |\n+LL |     X.0 = 1; //~ ERROR\n+   |     ^^^^^^^ cannot mutably borrow field of immutable binding\n+\n+error[E0596]: cannot borrow immutable static item as mutable\n+  --> $DIR/mutability-errors.rs:88:10\n+   |\n+LL |     &mut X; //~ ERROR\n+   |          ^\n+\n+error[E0596]: cannot borrow field of immutable binding as mutable\n+  --> $DIR/mutability-errors.rs:89:10\n+   |\n+LL |     &mut X.0; //~ ERROR\n+   |          ^^^ cannot mutably borrow field of immutable binding\n+\n+error: aborting due to 35 previous errors\n+\n+Some errors occurred: E0387, E0594, E0595, E0596.\n+For more information about an error, try `rustc --explain E0387`."}, {"sha": "d91c1199b3f8235957aa555be17951cd19ef9bfb", "filename": "src/test/ui/closure-immutable-outer-variable.nll.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fclosure-immutable-outer-variable.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fclosure-immutable-outer-variable.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosure-immutable-outer-variable.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,6 +1,8 @@\n-error[E0594]: cannot assign to immutable item `y`\n+error[E0594]: cannot assign to `y`, as it is not declared as mutable\n   --> $DIR/closure-immutable-outer-variable.rs:21:26\n    |\n+LL |     let y = true;\n+   |         - help: consider changing this to be mutable: `mut y`\n LL |     foo(Box::new(move || y = false) as Box<_>); //~ ERROR cannot assign to captured outer variable\n    |                          ^^^^^^^^^ cannot assign\n "}, {"sha": "8251f04d353f767a738d4c7ffdf3a12f7389f562", "filename": "src/test/ui/codemap_tests/huge_multispan_highlight.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Fhuge_multispan_highlight.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,4 +1,4 @@\n-error[E0596]: cannot borrow immutable item `x` as mutable\n+error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\n   --> $DIR/huge_multispan_highlight.rs:100:13\n    |\n LL |     let x = \"foo\";"}, {"sha": "eae834e2b1aa8e6f35269ad115588a7537ecffe2", "filename": "src/test/ui/did_you_mean/issue-31424.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-31424.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-31424.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-31424.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,10 +1,10 @@\n-error[E0596]: cannot borrow immutable item `self` as mutable\n+error[E0596]: cannot borrow `self` as mutable, as it is not declared as mutable\n   --> $DIR/issue-31424.rs:17:9\n    |\n LL |         (&mut self).bar(); //~ ERROR cannot borrow\n    |         ^^^^^^^^^^^ cannot borrow as mutable\n \n-error[E0596]: cannot borrow immutable item `self` as mutable\n+error[E0596]: cannot borrow `self` as mutable, as it is not declared as mutable\n   --> $DIR/issue-31424.rs:23:9\n    |\n LL |     fn bar(self: &mut Self) {"}, {"sha": "004c43a7343f802e19bb0d3963cd896e8f927ab1", "filename": "src/test/ui/did_you_mean/issue-34126.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-34126.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-34126.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-34126.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,4 +1,4 @@\n-error[E0596]: cannot borrow immutable item `self` as mutable\n+error[E0596]: cannot borrow `self` as mutable, as it is not declared as mutable\n   --> $DIR/issue-34126.rs:16:18\n    |\n LL |         self.run(&mut self); //~ ERROR cannot borrow"}, {"sha": "38315a067c07f8729cfbc81bac0b3bee88ac1c15", "filename": "src/test/ui/did_you_mean/issue-34337.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-34337.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-34337.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-34337.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,4 +1,4 @@\n-error[E0596]: cannot borrow immutable item `key` as mutable\n+error[E0596]: cannot borrow `key` as mutable, as it is not declared as mutable\n   --> $DIR/issue-34337.rs:16:9\n    |\n LL |     get(&mut key); //~ ERROR cannot borrow"}, {"sha": "804e5f0531f852a5b9976b35139a5b025b27c1c1", "filename": "src/test/ui/did_you_mean/issue-35937.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-35937.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-35937.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-35937.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,4 +1,4 @@\n-error[E0596]: cannot borrow immutable item `f.v` as mutable\n+error[E0596]: cannot borrow `f.v` as mutable, as `f` is not declared as mutable\n   --> $DIR/issue-35937.rs:17:5\n    |\n LL |     let f = Foo { v: Vec::new() };"}, {"sha": "7cc7ca14638145b1ee37eabe26fffe442761de8a", "filename": "src/test/ui/did_you_mean/issue-37139.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-37139.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-37139.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-37139.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,4 +1,4 @@\n-error[E0596]: cannot borrow immutable item `x` as mutable\n+error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\n   --> $DIR/issue-37139.rs:22:18\n    |\n LL |             test(&mut x); //~ ERROR cannot borrow immutable"}, {"sha": "25613561bbaf886cb379a3ef819f242f23a60a9b", "filename": "src/test/ui/did_you_mean/issue-38147-1.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-1.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-1.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-1.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,4 +1,4 @@\n-error[E0596]: cannot borrow immutable item `*self.s` as mutable\n+error[E0596]: cannot borrow `*self.s` as mutable, as it is behind a `&` reference\n   --> $DIR/issue-38147-1.rs:27:9\n    |\n LL |     fn f(&self) {"}, {"sha": "21fc4079d5b59d29626e162a04f1d6c2aba956a9", "filename": "src/test/ui/did_you_mean/issue-38147-2.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-2.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-2.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-2.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,4 +1,4 @@\n-error[E0596]: cannot borrow immutable item `*self.s` as mutable\n+error[E0596]: cannot borrow `*self.s` as mutable, as it is behind a `&` reference\n   --> $DIR/issue-38147-2.rs:17:9\n    |\n LL |         self.s.push('x');"}, {"sha": "d426c1f37fc1c667a3a44f339ed19d44b0fdbae1", "filename": "src/test/ui/did_you_mean/issue-38147-3.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-3.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-3.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-3.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,4 +1,4 @@\n-error[E0596]: cannot borrow immutable item `*self.s` as mutable\n+error[E0596]: cannot borrow `*self.s` as mutable, as it is behind a `&` reference\n   --> $DIR/issue-38147-3.rs:17:9\n    |\n LL |         self.s.push('x');"}, {"sha": "eccbe19ac943e36c3da5cc0787653b3fb5c7ac56", "filename": "src/test/ui/did_you_mean/issue-38147-4.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-4.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-4.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-38147-4.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,4 +1,4 @@\n-error[E0596]: cannot borrow immutable item `*f.s` as mutable\n+error[E0596]: cannot borrow `*f.s` as mutable, as it is behind a `&` reference\n   --> $DIR/issue-38147-4.rs:16:5\n    |\n LL | fn f(x: usize, f: &Foo) {"}, {"sha": "00e4cc6b0c35d459ebb2f4910e85c47545c3ba95", "filename": "src/test/ui/did_you_mean/issue-39544.nll.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-39544.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,28 +1,28 @@\n-error[E0596]: cannot borrow immutable item `z.x` as mutable\n+error[E0596]: cannot borrow `z.x` as mutable, as `z` is not declared as mutable\n   --> $DIR/issue-39544.rs:21:13\n    |\n LL |     let z = Z { x: X::Y };\n    |         - help: consider changing this to be mutable: `mut z`\n LL |     let _ = &mut z.x; //~ ERROR cannot borrow\n    |             ^^^^^^^^ cannot borrow as mutable\n \n-error[E0596]: cannot borrow immutable item `self.x` as mutable\n+error[E0596]: cannot borrow `self.x` as mutable, as it is behind a `&` reference\n   --> $DIR/issue-39544.rs:26:17\n    |\n LL |     fn foo<'z>(&'z self) {\n    |                -------- help: consider changing this to be a mutable reference: `&mut self`\n LL |         let _ = &mut self.x; //~ ERROR cannot borrow\n    |                 ^^^^^^^^^^^ `self` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n-error[E0596]: cannot borrow immutable item `self.x` as mutable\n+error[E0596]: cannot borrow `self.x` as mutable, as it is behind a `&` reference\n   --> $DIR/issue-39544.rs:30:17\n    |\n LL |     fn foo1(&self, other: &Z) {\n    |             ----- help: consider changing this to be a mutable reference: `&mut self`\n LL |         let _ = &mut self.x; //~ ERROR cannot borrow\n    |                 ^^^^^^^^^^^ `self` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n-error[E0596]: cannot borrow immutable item `other.x` as mutable\n+error[E0596]: cannot borrow `other.x` as mutable, as it is behind a `&` reference\n   --> $DIR/issue-39544.rs:31:17\n    |\n LL |     fn foo1(&self, other: &Z) {\n@@ -31,15 +31,15 @@ LL |         let _ = &mut self.x; //~ ERROR cannot borrow\n LL |         let _ = &mut other.x; //~ ERROR cannot borrow\n    |                 ^^^^^^^^^^^^ `other` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n-error[E0596]: cannot borrow immutable item `self.x` as mutable\n+error[E0596]: cannot borrow `self.x` as mutable, as it is behind a `&` reference\n   --> $DIR/issue-39544.rs:35:17\n    |\n LL |     fn foo2<'a>(&'a self, other: &Z) {\n    |                 -------- help: consider changing this to be a mutable reference: `&mut self`\n LL |         let _ = &mut self.x; //~ ERROR cannot borrow\n    |                 ^^^^^^^^^^^ `self` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n-error[E0596]: cannot borrow immutable item `other.x` as mutable\n+error[E0596]: cannot borrow `other.x` as mutable, as it is behind a `&` reference\n   --> $DIR/issue-39544.rs:36:17\n    |\n LL |     fn foo2<'a>(&'a self, other: &Z) {\n@@ -48,15 +48,15 @@ LL |         let _ = &mut self.x; //~ ERROR cannot borrow\n LL |         let _ = &mut other.x; //~ ERROR cannot borrow\n    |                 ^^^^^^^^^^^^ `other` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n-error[E0596]: cannot borrow immutable item `self.x` as mutable\n+error[E0596]: cannot borrow `self.x` as mutable, as it is behind a `&` reference\n   --> $DIR/issue-39544.rs:40:17\n    |\n LL |     fn foo3<'a>(self: &'a Self, other: &Z) {\n    |                       -------- help: consider changing this to be a mutable reference: `&mut Z`\n LL |         let _ = &mut self.x; //~ ERROR cannot borrow\n    |                 ^^^^^^^^^^^ `self` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n-error[E0596]: cannot borrow immutable item `other.x` as mutable\n+error[E0596]: cannot borrow `other.x` as mutable, as it is behind a `&` reference\n   --> $DIR/issue-39544.rs:41:17\n    |\n LL |     fn foo3<'a>(self: &'a Self, other: &Z) {\n@@ -65,23 +65,23 @@ LL |         let _ = &mut self.x; //~ ERROR cannot borrow\n LL |         let _ = &mut other.x; //~ ERROR cannot borrow\n    |                 ^^^^^^^^^^^^ `other` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n-error[E0596]: cannot borrow immutable item `other.x` as mutable\n+error[E0596]: cannot borrow `other.x` as mutable, as it is behind a `&` reference\n   --> $DIR/issue-39544.rs:45:17\n    |\n LL |     fn foo4(other: &Z) {\n    |                    -- help: consider changing this to be a mutable reference: `&mut Z`\n LL |         let _ = &mut other.x; //~ ERROR cannot borrow\n    |                 ^^^^^^^^^^^^ `other` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n-error[E0596]: cannot borrow immutable item `z.x` as mutable\n+error[E0596]: cannot borrow `z.x` as mutable, as `z` is not declared as mutable\n   --> $DIR/issue-39544.rs:51:13\n    |\n LL | pub fn with_arg(z: Z, w: &Z) {\n    |                 - help: consider changing this to be mutable: `mut z`\n LL |     let _ = &mut z.x; //~ ERROR cannot borrow\n    |             ^^^^^^^^ cannot borrow as mutable\n \n-error[E0596]: cannot borrow immutable item `w.x` as mutable\n+error[E0596]: cannot borrow `w.x` as mutable, as it is behind a `&` reference\n   --> $DIR/issue-39544.rs:52:13\n    |\n LL | pub fn with_arg(z: Z, w: &Z) {"}, {"sha": "44ae058cc28034baca8f198864f974ec57ee5620", "filename": "src/test/ui/did_you_mean/issue-40823.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40823.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40823.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-40823.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,4 +1,4 @@\n-error[E0596]: cannot borrow immutable item `*buf` as mutable\n+error[E0596]: cannot borrow `*buf` as mutable, as it is behind a `&` reference\n   --> $DIR/issue-40823.rs:13:5\n    |\n LL |     let mut buf = &[1, 2, 3, 4];"}, {"sha": "08708d213d3f68e5071f60a0c99fb7c94414bd85", "filename": "src/test/ui/error-codes/E0017.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Ferror-codes%2FE0017.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Ferror-codes%2FE0017.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0017.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -10,7 +10,7 @@ error[E0017]: references in statics may only refer to immutable values\n LL | static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017\n    |                                       ^^^^^^ statics require immutable values\n \n-error[E0596]: cannot borrow immutable item `X` as mutable\n+error[E0596]: cannot borrow immutable static item `X` as mutable\n   --> $DIR/E0017.rs:15:39\n    |\n LL | static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017"}, {"sha": "a048374a4972502a8ecc027e1ad6897eaddff675", "filename": "src/test/ui/error-codes/E0388.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Ferror-codes%2FE0388.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Ferror-codes%2FE0388.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0388.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -10,7 +10,7 @@ error[E0017]: references in statics may only refer to immutable values\n LL | static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017\n    |                                       ^^^^^^ statics require immutable values\n \n-error[E0596]: cannot borrow immutable item `X` as mutable\n+error[E0596]: cannot borrow immutable static item `X` as mutable\n   --> $DIR/E0388.rs:15:39\n    |\n LL | static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0017"}, {"sha": "ff06256088fa2ec3218f8d5830c10601ae90601f", "filename": "src/test/ui/fn-closure-mutable-capture.nll.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Ffn-closure-mutable-capture.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Ffn-closure-mutable-capture.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffn-closure-mutable-capture.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,8 +1,14 @@\n-error[E0594]: cannot assign to `x` which is behind a `&` reference\n+error[E0594]: cannot assign to `x`, as it is a captured variable in a `Fn` closure\n   --> $DIR/fn-closure-mutable-capture.rs:15:17\n    |\n LL |     bar(move || x = 1);\n    |                 ^^^^^ cannot assign\n+   |\n+help: consider changing this to accept closures that implement `FnMut`\n+  --> $DIR/fn-closure-mutable-capture.rs:15:9\n+   |\n+LL |     bar(move || x = 1);\n+   |         ^^^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "5fe8dc45ccc72ce4afc988d49da9477aab06a0e0", "filename": "src/test/ui/issue-21600.nll.stderr", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fissue-21600.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fissue-21600.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-21600.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,14 +1,33 @@\n-error[E0596]: cannot borrow immutable item `x` as mutable\n+error[E0596]: cannot borrow `x` as mutable, as it is a captured variable in a `Fn` closure\n   --> $DIR/issue-21600.rs:24:20\n    |\n LL |         call_it(|| x.gen_mut()); //~ ERROR cannot borrow data mutably in a captured outer\n    |                    ^ cannot borrow as mutable\n+   |\n+help: consider changing this to accept closures that implement `FnMut`\n+  --> $DIR/issue-21600.rs:24:17\n+   |\n+LL |         call_it(|| x.gen_mut()); //~ ERROR cannot borrow data mutably in a captured outer\n+   |                 ^^^^^^^^^^^^^^\n \n-error[E0596]: cannot borrow immutable item `x` as mutable\n+error[E0596]: cannot borrow `x` as mutable, as it is a captured variable in a `Fn` closure\n   --> $DIR/issue-21600.rs:24:17\n    |\n LL |         call_it(|| x.gen_mut()); //~ ERROR cannot borrow data mutably in a captured outer\n-   |                 ^^^^^^^^^^^^^^ cannot borrow as mutable\n+   |                 ^^ - mutable borrow occurs due to use of `x` in closure\n+   |                 |\n+   |                 cannot borrow as mutable\n+   |\n+help: consider changing this to accept closures that implement `FnMut`\n+  --> $DIR/issue-21600.rs:22:13\n+   |\n+LL |       call_it(|| {\n+   |  _____________^\n+LL | |         call_it(|| x.gen());\n+LL | |         call_it(|| x.gen_mut()); //~ ERROR cannot borrow data mutably in a captured outer\n+LL | |         //~^ ERROR cannot borrow data mutably in a captured outer\n+LL | |     });\n+   | |_____^\n \n error: aborting due to 2 previous errors\n "}, {"sha": "39d54f6e7ae28f65df90fda4a4f04ea7561ce7f4", "filename": "src/test/ui/issue-27282-reborrow-ref-mut-in-guard.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fissue-27282-reborrow-ref-mut-in-guard.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fissue-27282-reborrow-ref-mut-in-guard.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-27282-reborrow-ref-mut-in-guard.rs?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -24,7 +24,7 @@ fn main() {\n     match b {\n         &mut false => {},\n         ref mut r if { (|| { let bar = &mut *r; **bar = false; })();\n-                             //~^ ERROR cannot borrow immutable item `*r` as mutable\n+        //~^ ERROR cannot borrow `r` as mutable, as it is immutable for the pattern guard\n                              false } => { &mut *r; },\n         &mut true => { println!(\"You might think we should get here\"); },\n         _ => panic!(\"surely we could never get here, since rustc warns it is unreachable.\"),"}, {"sha": "660902880ac2ff833c68449d1f096865d67d1293", "filename": "src/test/ui/issue-27282-reborrow-ref-mut-in-guard.stderr", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fissue-27282-reborrow-ref-mut-in-guard.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fissue-27282-reborrow-ref-mut-in-guard.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-27282-reborrow-ref-mut-in-guard.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,8 +1,12 @@\n-error[E0596]: cannot borrow immutable item `*r` as mutable\n-  --> $DIR/issue-27282-reborrow-ref-mut-in-guard.rs:26:24\n+error[E0596]: cannot borrow `r` as mutable, as it is immutable for the pattern guard\n+  --> $DIR/issue-27282-reborrow-ref-mut-in-guard.rs:26:25\n    |\n LL |         ref mut r if { (|| { let bar = &mut *r; **bar = false; })();\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot borrow as mutable\n+   |                         ^^                   - mutable borrow occurs due to use of `r` in closure\n+   |                         |\n+   |                         cannot borrow as mutable\n+   |\n+   = note: variables bound in patterns are immutable until the end of the pattern guard\n \n error: aborting due to previous error\n "}, {"sha": "78ad31a04c88b2112659cc39cab11259cbbf8854", "filename": "src/test/ui/issue-33819.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fissue-33819.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fissue-33819.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-33819.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,4 +1,4 @@\n-error[E0596]: cannot borrow immutable item `v` as mutable\n+error[E0596]: cannot borrow `v` as mutable, as it is not declared as mutable\n   --> $DIR/issue-33819.rs:13:34\n    |\n LL |         Some(ref v) => { let a = &mut v; },"}, {"sha": "e4347f0ece831c270a9b4686661adf501dbbb1d1", "filename": "src/test/ui/issue-36400.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fissue-36400.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fissue-36400.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-36400.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,4 +1,4 @@\n-error[E0596]: cannot borrow immutable item `*x` as mutable\n+error[E0596]: cannot borrow `*x` as mutable, as `x` is not declared as mutable\n   --> $DIR/issue-36400.rs:15:7\n    |\n LL |     let x = Box::new(3);"}, {"sha": "06ff743a0f5ed295a7e360db7bae73e4d9d72c6f", "filename": "src/test/ui/issue-41726.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fissue-41726.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fissue-41726.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-41726.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,4 +1,4 @@\n-error[E0596]: cannot borrow immutable item as mutable\n+error[E0596]: cannot borrow data in a `&` reference as mutable\n   --> $DIR/issue-41726.rs:15:9\n    |\n LL |         things[src.as_str()].sort(); //~ ERROR cannot borrow immutable"}, {"sha": "1abc448dbb090c2ae64d6563da06b47304f47f84", "filename": "src/test/ui/issue-42344.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fissue-42344.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fissue-42344.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-42344.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,4 +1,4 @@\n-error[E0596]: cannot borrow immutable item `*TAB[..]` as mutable\n+error[E0596]: cannot borrow `*TAB[..]` as mutable, as `TAB` is an immutable static item\n   --> $DIR/issue-42344.rs:14:5\n    |\n LL |     TAB[0].iter_mut(); //~ ERROR cannot borrow data mutably in a `&` reference [E0389]"}, {"sha": "bda629d48affcd3bd15be3a8fe1e87f1e9371141", "filename": "src/test/ui/issue-46023.ast.nll.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fissue-46023.ast.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fissue-46023.ast.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-46023.ast.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,6 +1,9 @@\n-error[E0594]: cannot assign to immutable item `x`\n+error[E0594]: cannot assign to `x`, as it is not declared as mutable\n   --> $DIR/issue-46023.rs:18:9\n    |\n+LL |     let x = 0;\n+   |         - help: consider changing this to be mutable: `mut x`\n+...\n LL |         x = 1;\n    |         ^^^^^ cannot assign\n "}, {"sha": "bda629d48affcd3bd15be3a8fe1e87f1e9371141", "filename": "src/test/ui/issue-46023.mir.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fissue-46023.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fissue-46023.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-46023.mir.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,6 +1,9 @@\n-error[E0594]: cannot assign to immutable item `x`\n+error[E0594]: cannot assign to `x`, as it is not declared as mutable\n   --> $DIR/issue-46023.rs:18:9\n    |\n+LL |     let x = 0;\n+   |         - help: consider changing this to be mutable: `mut x`\n+...\n LL |         x = 1;\n    |         ^^^^^ cannot assign\n "}, {"sha": "d5c8cd6d0f8fc6e3012dbe8a0e5d410eb673bfbc", "filename": "src/test/ui/issue-46023.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fissue-46023.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fissue-46023.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-46023.rs?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -16,7 +16,7 @@ fn main() {\n \n     (move || {\n         x = 1;\n-        //[mir]~^ ERROR cannot assign to immutable item `x` [E0594]\n+        //[mir]~^ ERROR cannot assign to `x`, as it is not declared as mutable [E0594]\n         //[ast]~^^ ERROR cannot assign to captured outer variable in an `FnMut` closure [E0594]\n     })()\n }"}, {"sha": "a4ee0d4e2a3a926f1faa3b9cae1076d14335a90f", "filename": "src/test/ui/issue-46604.ast.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fissue-46604.ast.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fissue-46604.ast.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-46604.ast.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -4,7 +4,7 @@ error[E0017]: references in statics may only refer to immutable values\n LL | static buf: &mut [u8] = &mut [1u8,2,3,4,5,7];   //[ast]~ ERROR E0017\n    |                         ^^^^^^^^^^^^^^^^^^^^ statics require immutable values\n \n-error[E0594]: cannot assign to immutable item `buf[..]`\n+error[E0594]: cannot assign to `buf[..]`, as `buf` is an immutable static item\n   --> $DIR/issue-46604.rs:20:5\n    |\n LL |     buf[0]=2;                                   //[ast]~ ERROR E0389"}, {"sha": "a4ee0d4e2a3a926f1faa3b9cae1076d14335a90f", "filename": "src/test/ui/issue-46604.mir.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fissue-46604.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fissue-46604.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-46604.mir.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -4,7 +4,7 @@ error[E0017]: references in statics may only refer to immutable values\n LL | static buf: &mut [u8] = &mut [1u8,2,3,4,5,7];   //[ast]~ ERROR E0017\n    |                         ^^^^^^^^^^^^^^^^^^^^ statics require immutable values\n \n-error[E0594]: cannot assign to immutable item `buf[..]`\n+error[E0594]: cannot assign to `buf[..]`, as `buf` is an immutable static item\n   --> $DIR/issue-46604.rs:20:5\n    |\n LL |     buf[0]=2;                                   //[ast]~ ERROR E0389"}, {"sha": "d5bba6649a2c714bb0cf37bccf24621bb4fa05ff", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-using-fn-items.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-fn-items.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-fn-items.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-fn-items.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -12,7 +12,7 @@ LL | fn foo(x:fn(&u8, &u8), y: Vec<&u8>, z: &u8) {\n LL |   y.push(z); //~ ERROR lifetime mismatch\n    |   ^ ...but data from `z` flows into `y` here\n \n-error[E0596]: cannot borrow immutable item `y` as mutable\n+error[E0596]: cannot borrow `y` as mutable, as it is not declared as mutable\n   --> $DIR/ex3-both-anon-regions-using-fn-items.rs:11:3\n    |\n LL | fn foo(x:fn(&u8, &u8), y: Vec<&u8>, z: &u8) {"}, {"sha": "0608b3be8b33aea599e5bc91c6ab8cebf63705b7", "filename": "src/test/ui/lifetime-errors/ex3-both-anon-regions-using-trait-objects.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-trait-objects.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-trait-objects.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex3-both-anon-regions-using-trait-objects.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -12,7 +12,7 @@ LL | fn foo(x:Box<Fn(&u8, &u8)> , y: Vec<&u8>, z: &u8) {\n LL |   y.push(z); //~ ERROR lifetime mismatch\n    |   ^ ...but data from `z` flows into `y` here\n \n-error[E0596]: cannot borrow immutable item `y` as mutable\n+error[E0596]: cannot borrow `y` as mutable, as it is not declared as mutable\n   --> $DIR/ex3-both-anon-regions-using-trait-objects.rs:11:3\n    |\n LL | fn foo(x:Box<Fn(&u8, &u8)> , y: Vec<&u8>, z: &u8) {"}, {"sha": "3947f6c0f11fca8e7351d4983284c373cf8e5e6b", "filename": "src/test/ui/macros/span-covering-argument-1.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fmacros%2Fspan-covering-argument-1.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fmacros%2Fspan-covering-argument-1.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fspan-covering-argument-1.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,4 +1,4 @@\n-error[E0596]: cannot borrow immutable item `foo` as mutable\n+error[E0596]: cannot borrow `foo` as mutable, as it is not declared as mutable\n   --> $DIR/span-covering-argument-1.rs:15:14\n    |\n LL |             let $s = 0;"}, {"sha": "03a22bb79a86ba527831c62b94c634a8dc664952", "filename": "src/test/ui/nll/closure-captures.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fnll%2Fclosure-captures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fnll%2Fclosure-captures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-captures.rs?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -0,0 +1,68 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Some cases with closures that might be problems\n+\n+#![allow(unused)]\n+#![feature(nll)]\n+\n+// Should have one error per assigment\n+\n+fn one_closure(x: i32) {\n+    ||\n+    x = 1; //~ ERROR\n+    move ||\n+    x = 1; //~ ERROR\n+}\n+\n+fn two_closures(x: i32) {\n+    || {\n+        ||\n+        x = 1; //~ ERROR\n+    };\n+    move || {\n+        ||\n+        x = 1; //~ ERROR\n+    };\n+}\n+\n+fn fn_ref<F: Fn()>(f: F) -> F { f }\n+\n+fn two_closures_ref_mut(mut x: i32) {\n+    fn_ref(|| {\n+        || //~ ERROR\n+         x = 1;}\n+    );\n+    fn_ref(move || {\n+        ||  //~ ERROR\n+    x = 1;});\n+}\n+\n+// This still gives two messages, but it requires two things to be fixed.\n+fn two_closures_ref(x: i32) {\n+    fn_ref(|| {\n+        || //~ ERROR\n+         x = 1;} //~ ERROR\n+    );\n+    fn_ref(move || {\n+        ||  //~ ERROR\n+    x = 1;}); //~ ERROR\n+}\n+\n+fn two_closures_two_refs(x: &mut i32) {\n+    fn_ref(|| {\n+        || //~ ERROR\n+        *x = 1;});\n+    fn_ref(move || {\n+        || //~ ERROR\n+        *x = 1;});\n+}\n+\n+fn main() {}"}, {"sha": "a03e104a1b1fbc20ddea5bfc9fe323179ace6ac7", "filename": "src/test/ui/nll/closure-captures.stderr", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fnll%2Fclosure-captures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fnll%2Fclosure-captures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-captures.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -0,0 +1,160 @@\n+error[E0594]: cannot assign to `x`, as it is not declared as mutable\n+  --> $DIR/closure-captures.rs:20:5\n+   |\n+LL | fn one_closure(x: i32) {\n+   |                - help: consider changing this to be mutable: `mut x`\n+LL |     ||\n+LL |     x = 1; //~ ERROR\n+   |     ^^^^^ cannot assign\n+\n+error[E0594]: cannot assign to `x`, as it is not declared as mutable\n+  --> $DIR/closure-captures.rs:22:5\n+   |\n+LL | fn one_closure(x: i32) {\n+   |                - help: consider changing this to be mutable: `mut x`\n+...\n+LL |     x = 1; //~ ERROR\n+   |     ^^^^^ cannot assign\n+\n+error[E0594]: cannot assign to `x`, as it is not declared as mutable\n+  --> $DIR/closure-captures.rs:28:9\n+   |\n+LL | fn two_closures(x: i32) {\n+   |                 - help: consider changing this to be mutable: `mut x`\n+...\n+LL |         x = 1; //~ ERROR\n+   |         ^^^^^ cannot assign\n+\n+error[E0594]: cannot assign to `x`, as it is not declared as mutable\n+  --> $DIR/closure-captures.rs:32:9\n+   |\n+LL | fn two_closures(x: i32) {\n+   |                 - help: consider changing this to be mutable: `mut x`\n+...\n+LL |         x = 1; //~ ERROR\n+   |         ^^^^^ cannot assign\n+\n+error[E0596]: cannot borrow `x` as mutable, as it is a captured variable in a `Fn` closure\n+  --> $DIR/closure-captures.rs:40:9\n+   |\n+LL |         || //~ ERROR\n+   |         ^^ cannot borrow as mutable\n+LL |          x = 1;}\n+   |          - mutable borrow occurs due to use of `x` in closure\n+   |\n+help: consider changing this to accept closures that implement `FnMut`\n+  --> $DIR/closure-captures.rs:39:12\n+   |\n+LL |       fn_ref(|| {\n+   |  ____________^\n+LL | |         || //~ ERROR\n+LL | |          x = 1;}\n+   | |________________^\n+\n+error[E0596]: cannot borrow `x` as mutable, as it is a captured variable in a `Fn` closure\n+  --> $DIR/closure-captures.rs:44:9\n+   |\n+LL |         ||  //~ ERROR\n+   |         ^^ cannot borrow as mutable\n+LL |     x = 1;});\n+   |     - mutable borrow occurs due to use of `x` in closure\n+   |\n+help: consider changing this to accept closures that implement `FnMut`\n+  --> $DIR/closure-captures.rs:43:12\n+   |\n+LL |       fn_ref(move || {\n+   |  ____________^\n+LL | |         ||  //~ ERROR\n+LL | |     x = 1;});\n+   | |___________^\n+\n+error[E0594]: cannot assign to `x`, as it is not declared as mutable\n+  --> $DIR/closure-captures.rs:52:10\n+   |\n+LL | fn two_closures_ref(x: i32) {\n+   |                     - help: consider changing this to be mutable: `mut x`\n+...\n+LL |          x = 1;} //~ ERROR\n+   |          ^^^^^ cannot assign\n+\n+error[E0596]: cannot borrow `x` as mutable, as it is a captured variable in a `Fn` closure\n+  --> $DIR/closure-captures.rs:51:9\n+   |\n+LL |         || //~ ERROR\n+   |         ^^ cannot borrow as mutable\n+LL |          x = 1;} //~ ERROR\n+   |          - mutable borrow occurs due to use of `x` in closure\n+   |\n+help: consider changing this to accept closures that implement `FnMut`\n+  --> $DIR/closure-captures.rs:50:12\n+   |\n+LL |       fn_ref(|| {\n+   |  ____________^\n+LL | |         || //~ ERROR\n+LL | |          x = 1;} //~ ERROR\n+   | |________________^\n+\n+error[E0594]: cannot assign to `x`, as it is not declared as mutable\n+  --> $DIR/closure-captures.rs:56:5\n+   |\n+LL | fn two_closures_ref(x: i32) {\n+   |                     - help: consider changing this to be mutable: `mut x`\n+...\n+LL |     x = 1;}); //~ ERROR\n+   |     ^^^^^ cannot assign\n+\n+error[E0596]: cannot borrow `x` as mutable, as it is a captured variable in a `Fn` closure\n+  --> $DIR/closure-captures.rs:55:9\n+   |\n+LL |         ||  //~ ERROR\n+   |         ^^ cannot borrow as mutable\n+LL |     x = 1;}); //~ ERROR\n+   |     - mutable borrow occurs due to use of `x` in closure\n+   |\n+help: consider changing this to accept closures that implement `FnMut`\n+  --> $DIR/closure-captures.rs:54:12\n+   |\n+LL |       fn_ref(move || {\n+   |  ____________^\n+LL | |         ||  //~ ERROR\n+LL | |     x = 1;}); //~ ERROR\n+   | |___________^\n+\n+error[E0596]: cannot borrow `x` as mutable, as it is a captured variable in a `Fn` closure\n+  --> $DIR/closure-captures.rs:61:9\n+   |\n+LL |         || //~ ERROR\n+   |         ^^ cannot borrow as mutable\n+LL |         *x = 1;});\n+   |          - mutable borrow occurs due to use of `x` in closure\n+   |\n+help: consider changing this to accept closures that implement `FnMut`\n+  --> $DIR/closure-captures.rs:60:12\n+   |\n+LL |       fn_ref(|| {\n+   |  ____________^\n+LL | |         || //~ ERROR\n+LL | |         *x = 1;});\n+   | |________________^\n+\n+error[E0596]: cannot borrow `x` as mutable, as it is a captured variable in a `Fn` closure\n+  --> $DIR/closure-captures.rs:64:9\n+   |\n+LL |         || //~ ERROR\n+   |         ^^ cannot borrow as mutable\n+LL |         *x = 1;});\n+   |          - mutable borrow occurs due to use of `x` in closure\n+   |\n+help: consider changing this to accept closures that implement `FnMut`\n+  --> $DIR/closure-captures.rs:63:12\n+   |\n+LL |       fn_ref(move || {\n+   |  ____________^\n+LL | |         || //~ ERROR\n+LL | |         *x = 1;});\n+   | |________________^\n+\n+error: aborting due to 12 previous errors\n+\n+Some errors occurred: E0594, E0596.\n+For more information about an error, try `rustc --explain E0594`."}, {"sha": "180a330a30e745a2102b426827a03a4ec5c57cd1", "filename": "src/test/ui/nll/generator-upvar-mutability.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fnll%2Fgenerator-upvar-mutability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fnll%2Fgenerator-upvar-mutability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fgenerator-upvar-mutability.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,6 +1,9 @@\n-error[E0594]: cannot assign to immutable item `x`\n+error[E0594]: cannot assign to `x`, as it is not declared as mutable\n   --> $DIR/generator-upvar-mutability.rs:18:9\n    |\n+LL |     let x = 0;\n+   |         - help: consider changing this to be mutable: `mut x`\n+LL |     move || {\n LL |         x = 1;\n    |         ^^^^^ cannot assign\n "}, {"sha": "366bfc8fa20a5a013bc9c293f1a52c855836d143", "filename": "src/test/ui/span/borrowck-borrow-overloaded-auto-deref-mut.nll.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fspan%2Fborrowck-borrow-overloaded-auto-deref-mut.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fspan%2Fborrowck-borrow-overloaded-auto-deref-mut.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-borrow-overloaded-auto-deref-mut.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,60 +1,60 @@\n-error[E0596]: cannot borrow immutable item `x` as mutable\n+error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\n   --> $DIR/borrowck-borrow-overloaded-auto-deref-mut.rs:63:24\n    |\n LL | fn deref_mut_field1(x: Own<Point>) {\n    |                     - help: consider changing this to be mutable: `mut x`\n LL |     let __isize = &mut x.y; //~ ERROR cannot borrow\n    |                        ^ cannot borrow as mutable\n \n-error[E0596]: cannot borrow immutable item `*x` as mutable\n+error[E0596]: cannot borrow `*x` as mutable, as it is behind a `&` reference\n   --> $DIR/borrowck-borrow-overloaded-auto-deref-mut.rs:75:10\n    |\n LL | fn deref_extend_mut_field1(x: &Own<Point>) -> &mut isize {\n    |                               ----------- help: consider changing this to be a mutable reference: `&mut Own<Point>`\n LL |     &mut x.y //~ ERROR cannot borrow\n    |          ^ `x` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n-error[E0596]: cannot borrow immutable item `x` as mutable\n+error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\n   --> $DIR/borrowck-borrow-overloaded-auto-deref-mut.rs:98:5\n    |\n LL | fn assign_field1<'a>(x: Own<Point>) {\n    |                      - help: consider changing this to be mutable: `mut x`\n LL |     x.y = 3; //~ ERROR cannot borrow\n    |     ^ cannot borrow as mutable\n \n-error[E0596]: cannot borrow immutable item `*x` as mutable\n+error[E0596]: cannot borrow `*x` as mutable, as it is behind a `&` reference\n   --> $DIR/borrowck-borrow-overloaded-auto-deref-mut.rs:102:5\n    |\n LL | fn assign_field2<'a>(x: &'a Own<Point>) {\n    |                         -------------- help: consider changing this to be a mutable reference: `&mut Own<Point>`\n LL |     x.y = 3; //~ ERROR cannot borrow\n    |     ^ `x` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n-error[E0596]: cannot borrow immutable item `x` as mutable\n+error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\n   --> $DIR/borrowck-borrow-overloaded-auto-deref-mut.rs:119:5\n    |\n LL | fn deref_mut_method1(x: Own<Point>) {\n    |                      - help: consider changing this to be mutable: `mut x`\n LL |     x.set(0, 0); //~ ERROR cannot borrow\n    |     ^ cannot borrow as mutable\n \n-error[E0596]: cannot borrow immutable item `*x` as mutable\n+error[E0596]: cannot borrow `*x` as mutable, as it is behind a `&` reference\n   --> $DIR/borrowck-borrow-overloaded-auto-deref-mut.rs:131:5\n    |\n LL | fn deref_extend_mut_method1(x: &Own<Point>) -> &mut isize {\n    |                                ----------- help: consider changing this to be a mutable reference: `&mut Own<Point>`\n LL |     x.y_mut() //~ ERROR cannot borrow\n    |     ^ `x` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n-error[E0596]: cannot borrow immutable item `x` as mutable\n+error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\n   --> $DIR/borrowck-borrow-overloaded-auto-deref-mut.rs:139:6\n    |\n LL | fn assign_method1<'a>(x: Own<Point>) {\n    |                       - help: consider changing this to be mutable: `mut x`\n LL |     *x.y_mut() = 3; //~ ERROR cannot borrow\n    |      ^ cannot borrow as mutable\n \n-error[E0596]: cannot borrow immutable item `*x` as mutable\n+error[E0596]: cannot borrow `*x` as mutable, as it is behind a `&` reference\n   --> $DIR/borrowck-borrow-overloaded-auto-deref-mut.rs:143:6\n    |\n LL | fn assign_method2<'a>(x: &'a Own<Point>) {"}, {"sha": "69bf246ff3fef61d645f38bb58a528901b3c9f45", "filename": "src/test/ui/span/borrowck-borrow-overloaded-deref-mut.nll.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fspan%2Fborrowck-borrow-overloaded-deref-mut.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fspan%2Fborrowck-borrow-overloaded-deref-mut.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-borrow-overloaded-deref-mut.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,28 +1,28 @@\n-error[E0596]: cannot borrow immutable item `x` as mutable\n+error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\n   --> $DIR/borrowck-borrow-overloaded-deref-mut.rs:39:25\n    |\n LL | fn deref_mut1(x: Own<isize>) {\n    |               - help: consider changing this to be mutable: `mut x`\n LL |     let __isize = &mut *x; //~ ERROR cannot borrow\n    |                         ^ cannot borrow as mutable\n \n-error[E0596]: cannot borrow immutable item `*x` as mutable\n+error[E0596]: cannot borrow `*x` as mutable, as it is behind a `&` reference\n   --> $DIR/borrowck-borrow-overloaded-deref-mut.rs:51:11\n    |\n LL | fn deref_extend_mut1<'a>(x: &'a Own<isize>) -> &'a mut isize {\n    |                             -------------- help: consider changing this to be a mutable reference: `&mut Own<isize>`\n LL |     &mut **x //~ ERROR cannot borrow\n    |           ^^ `x` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n-error[E0596]: cannot borrow immutable item `x` as mutable\n+error[E0596]: cannot borrow `x` as mutable, as it is not declared as mutable\n   --> $DIR/borrowck-borrow-overloaded-deref-mut.rs:59:6\n    |\n LL | fn assign1<'a>(x: Own<isize>) {\n    |                - help: consider changing this to be mutable: `mut x`\n LL |     *x = 3; //~ ERROR cannot borrow\n    |      ^ cannot borrow as mutable\n \n-error[E0596]: cannot borrow immutable item `*x` as mutable\n+error[E0596]: cannot borrow `*x` as mutable, as it is behind a `&` reference\n   --> $DIR/borrowck-borrow-overloaded-deref-mut.rs:63:6\n    |\n LL | fn assign2<'a>(x: &'a Own<isize>) {"}, {"sha": "f752015c650b9d825c447eabe7efffd334793404", "filename": "src/test/ui/span/borrowck-call-is-borrow-issue-12224.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-is-borrow-issue-12224.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-is-borrow-issue-12224.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-is-borrow-issue-12224.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -12,15 +12,15 @@ LL | |         f((Box::new(|| {})))\n LL | |     }));\n    | |_______- borrow later used here\n \n-error[E0596]: cannot borrow immutable item `*f` as mutable\n+error[E0596]: cannot borrow `*f` as mutable, as it is behind a `&` reference\n   --> $DIR/borrowck-call-is-borrow-issue-12224.rs:35:5\n    |\n LL | fn test2<F>(f: &F) where F: FnMut() {\n    |                -- help: consider changing this to be a mutable reference: `&mut F`\n LL |     (*f)();\n    |     ^^^^ `f` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n-error[E0596]: cannot borrow immutable item `*f.f` as mutable\n+error[E0596]: cannot borrow `*f.f` as mutable, as it is behind a `&` reference\n   --> $DIR/borrowck-call-is-borrow-issue-12224.rs:44:5\n    |\n LL | fn test4(f: &Test) {"}, {"sha": "e9c0505af68b23bced7993396b81269aa1618344", "filename": "src/test/ui/span/borrowck-call-method-from-mut-aliasable.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-method-from-mut-aliasable.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-method-from-mut-aliasable.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-call-method-from-mut-aliasable.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,4 +1,4 @@\n-error[E0596]: cannot borrow immutable item `*x` as mutable\n+error[E0596]: cannot borrow `*x` as mutable, as it is behind a `&` reference\n   --> $DIR/borrowck-call-method-from-mut-aliasable.rs:27:5\n    |\n LL | fn b(x: &Foo) {"}, {"sha": "5e47d3271d49fe436d17a225242ed85b3a4885d5", "filename": "src/test/ui/span/borrowck-fn-in-const-b.nll.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fspan%2Fborrowck-fn-in-const-b.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fspan%2Fborrowck-fn-in-const-b.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-fn-in-const-b.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,4 +1,4 @@\n-error[E0596]: cannot borrow immutable item `*x` as mutable\n+error[E0596]: cannot borrow `*x` as mutable, as it is behind a `&` reference\n   --> $DIR/borrowck-fn-in-const-b.rs:17:9\n    |\n LL |     fn broken(x: &Vec<String>) {"}, {"sha": "3f0eb97c7af293b16b97bc0c7f053e69843a718c", "filename": "src/test/ui/span/borrowck-object-mutability.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fspan%2Fborrowck-object-mutability.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fspan%2Fborrowck-object-mutability.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fborrowck-object-mutability.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,4 +1,4 @@\n-error[E0596]: cannot borrow immutable item `*x` as mutable\n+error[E0596]: cannot borrow `*x` as mutable, as it is behind a `&` reference\n   --> $DIR/borrowck-object-mutability.rs:19:5\n    |\n LL | fn borrowed_receiver(x: &Foo) {\n@@ -7,7 +7,7 @@ LL |     x.borrowed();\n LL |     x.borrowed_mut(); //~ ERROR cannot borrow\n    |     ^ `x` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n-error[E0596]: cannot borrow immutable item `*x` as mutable\n+error[E0596]: cannot borrow `*x` as mutable, as `x` is not declared as mutable\n   --> $DIR/borrowck-object-mutability.rs:29:5\n    |\n LL | fn owned_receiver(x: Box<Foo>) {"}, {"sha": "f264ea1f916769b274b99efbed7166297284daf0", "filename": "src/test/ui/span/mut-arg-hint.nll.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fspan%2Fmut-arg-hint.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Fspan%2Fmut-arg-hint.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmut-arg-hint.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,20 +1,20 @@\n-error[E0596]: cannot borrow immutable item `*a` as mutable\n+error[E0596]: cannot borrow `*a` as mutable, as it is behind a `&` reference\n   --> $DIR/mut-arg-hint.rs:13:9\n    |\n LL |     fn foo(mut a: &String) {\n    |                   ------- help: consider changing this to be a mutable reference: `&mut std::string::String`\n LL |         a.push_str(\"bar\"); //~ ERROR cannot borrow immutable borrowed content\n    |         ^ `a` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n-error[E0596]: cannot borrow immutable item `*a` as mutable\n+error[E0596]: cannot borrow `*a` as mutable, as it is behind a `&` reference\n   --> $DIR/mut-arg-hint.rs:18:5\n    |\n LL | pub fn foo<'a>(mut a: &'a String) {\n    |                       ---------- help: consider changing this to be a mutable reference: `&mut std::string::String`\n LL |     a.push_str(\"foo\"); //~ ERROR cannot borrow immutable borrowed content\n    |     ^ `a` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n-error[E0596]: cannot borrow immutable item `*a` as mutable\n+error[E0596]: cannot borrow `*a` as mutable, as it is behind a `&` reference\n   --> $DIR/mut-arg-hint.rs:25:9\n    |\n LL |     pub fn foo(mut a: &String) {"}, {"sha": "215faf6c73c369ab1e2c90f96d9867968c144335", "filename": "src/test/ui/trivial-bounds-inconsistent-copy-reborrow.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Ftrivial-bounds-inconsistent-copy-reborrow.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/942b384d61590c39eb635596de0370a823001817/src%2Ftest%2Fui%2Ftrivial-bounds-inconsistent-copy-reborrow.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftrivial-bounds-inconsistent-copy-reborrow.nll.stderr?ref=942b384d61590c39eb635596de0370a823001817", "patch": "@@ -1,12 +1,12 @@\n-error[E0596]: cannot borrow immutable item `**t` as mutable\n+error[E0596]: cannot borrow `**t` as mutable, as it is behind a `&` reference\n   --> $DIR/trivial-bounds-inconsistent-copy-reborrow.rs:16:5\n    |\n LL | fn reborrow_mut<'a>(t: &'a &'a mut i32) -> &'a mut i32 where &'a mut i32: Copy {\n    |                        --------------- help: consider changing this to be a mutable reference: `&mut &mut i32`\n LL |     *t //~ ERROR\n    |     ^^ `t` is a `&` reference, so the data it refers to cannot be borrowed as mutable\n \n-error[E0596]: cannot borrow immutable item `**t` as mutable\n+error[E0596]: cannot borrow `**t` as mutable, as it is behind a `&` reference\n   --> $DIR/trivial-bounds-inconsistent-copy-reborrow.rs:20:6\n    |\n LL | fn copy_reborrow_mut<'a>(t: &'a &'a mut i32) -> &'a mut i32 where &'a mut i32: Copy {"}]}