{"sha": "04045cc83f59e08be5d12d7ca4ac4d6364a02ff1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA0MDQ1Y2M4M2Y1OWUwOGJlNWQxMmQ3Y2E0YWM0ZDYzNjRhMDJmZjE=", "commit": {"author": {"name": "Mara", "email": "m-ou.se@m-ou.se", "date": "2021-03-05T09:57:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-05T09:57:23Z"}, "message": "Rollup merge of #82770 - m-ou-se:assert-match, r=joshtriplett\n\nAdd assert_matches macro.\n\nThis adds `assert_matches!(expression, pattern)`.\n\nUnlike the other asserts, this one ~~consumes the expression~~ may consume the expression, to be able to match the pattern. (It could add a `&` implicitly, but that's noticable in the pattern, and will make a consuming guard impossible.)\n\nSee https://github.com/rust-lang/rust/issues/62633#issuecomment-790737853\n\nThis re-uses the same `left: .. right: ..` output as the `assert_eq` and `assert_ne` macros, but with the pattern as the right part:\n\nassert_eq:\n```\nassertion failed: `(left == right)`\n  left: `Some(\"asdf\")`,\n right: `None`\n```\nassert_matches:\n```\nassertion failed: `(left matches right)`\n  left: `Ok(\"asdf\")`,\n right: `Err(_)`\n```\n\ncc ```@cuviper```", "tree": {"sha": "a344474d23628d27137c40905cb00c62d5108e4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a344474d23628d27137c40905cb00c62d5108e4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/04045cc83f59e08be5d12d7ca4ac4d6364a02ff1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgQgCDCRBK7hj4Ov3rIwAAdHIIAD8xqf/8u4KfZb4bw3bHyroQ\nk7ZihTAZFdISTz5c/TwpqXSG30e4YMtgXCTxCWANUeIYg7xJDk5JE9q3wO9TmX21\nB5R7m/d66UmtOb2KBEsvOLusePlRscIakPQvwMsgGKf+LgRIcvRRb20aXM7dJSjX\nqOp3yPMWccnwOios1Elmir6NyiGY2LSQhRWgOB9kqXAPteOuCvH1Eo+IM/zZI5CB\n7Ze2R1lj9K6WWNg8s3Q8hBedeDRxpaqg3Ep2t899PR70n76oIDdHuVl1/quPCAIA\nYXsR3vm0aa6ILJIKlUCiE59eMwq5LxK+x0KcjxnUyEcq03y1CZxjDTyEmJhtJP0=\n=Kvvw\n-----END PGP SIGNATURE-----\n", "payload": "tree a344474d23628d27137c40905cb00c62d5108e4e\nparent 232caad39581118619c5168284b15457d1c72900\nparent 80fcdef3b53c43f3d7bace1db3e3ef9ffebd757e\nauthor Mara <m-ou.se@m-ou.se> 1614938243 +0100\ncommitter GitHub <noreply@github.com> 1614938243 +0100\n\nRollup merge of #82770 - m-ou-se:assert-match, r=joshtriplett\n\nAdd assert_matches macro.\n\nThis adds `assert_matches!(expression, pattern)`.\n\nUnlike the other asserts, this one ~~consumes the expression~~ may consume the expression, to be able to match the pattern. (It could add a `&` implicitly, but that's noticable in the pattern, and will make a consuming guard impossible.)\n\nSee https://github.com/rust-lang/rust/issues/62633#issuecomment-790737853\n\nThis re-uses the same `left: .. right: ..` output as the `assert_eq` and `assert_ne` macros, but with the pattern as the right part:\n\nassert_eq:\n```\nassertion failed: `(left == right)`\n  left: `Some(\"asdf\")`,\n right: `None`\n```\nassert_matches:\n```\nassertion failed: `(left matches right)`\n  left: `Ok(\"asdf\")`,\n right: `Err(_)`\n```\n\ncc ```@cuviper```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/04045cc83f59e08be5d12d7ca4ac4d6364a02ff1", "html_url": "https://github.com/rust-lang/rust/commit/04045cc83f59e08be5d12d7ca4ac4d6364a02ff1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/04045cc83f59e08be5d12d7ca4ac4d6364a02ff1/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "232caad39581118619c5168284b15457d1c72900", "url": "https://api.github.com/repos/rust-lang/rust/commits/232caad39581118619c5168284b15457d1c72900", "html_url": "https://github.com/rust-lang/rust/commit/232caad39581118619c5168284b15457d1c72900"}, {"sha": "80fcdef3b53c43f3d7bace1db3e3ef9ffebd757e", "url": "https://api.github.com/repos/rust-lang/rust/commits/80fcdef3b53c43f3d7bace1db3e3ef9ffebd757e", "html_url": "https://github.com/rust-lang/rust/commit/80fcdef3b53c43f3d7bace1db3e3ef9ffebd757e"}], "stats": {"total": 164, "additions": 139, "deletions": 25}, "files": [{"sha": "3e70ba81d49975f884e457a677b2e9ccd75f6c19", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/04045cc83f59e08be5d12d7ca4ac4d6364a02ff1/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04045cc83f59e08be5d12d7ca4ac4d6364a02ff1/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=04045cc83f59e08be5d12d7ca4ac4d6364a02ff1", "patch": "@@ -110,6 +110,60 @@ macro_rules! assert_ne {\n     });\n }\n \n+/// Asserts that an expression matches any of the given patterns.\n+///\n+/// Like in a `match` expression, the pattern can be optionally followed by `if`\n+/// and a guard expression that has access to names bound by the pattern.\n+///\n+/// On panic, this macro will print the value of the expression with its\n+/// debug representation.\n+///\n+/// Like [`assert!`], this macro has a second form, where a custom\n+/// panic message can be provided.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(assert_matches)]\n+///\n+/// let a = 1u32.checked_add(2);\n+/// let b = 1u32.checked_sub(2);\n+/// assert_matches!(a, Some(_));\n+/// assert_matches!(b, None);\n+///\n+/// let c = Ok(\"abc\".to_string());\n+/// assert_matches!(c, Ok(x) | Err(x) if x.len() < 100);\n+/// ```\n+#[macro_export]\n+#[unstable(feature = \"assert_matches\", issue = \"82775\")]\n+#[allow_internal_unstable(core_panic)]\n+macro_rules! assert_matches {\n+    ($left:expr, $( $pattern:pat )|+ $( if $guard: expr )? $(,)?) => ({\n+        match $left {\n+            $( $pattern )|+ $( if $guard )? => {}\n+            ref left_val => {\n+                $crate::panicking::assert_matches_failed(\n+                    left_val,\n+                    $crate::stringify!($($pattern)|+ $(if $guard)?),\n+                    $crate::option::Option::None\n+                );\n+            }\n+        }\n+    });\n+    ($left:expr, $( $pattern:pat )|+ $( if $guard: expr )?, $($arg:tt)+) => ({\n+        match $left {\n+            $( $pattern )|+ $( if $guard )? => {}\n+            ref left_val => {\n+                $crate::panicking::assert_matches_failed(\n+                    left_val,\n+                    $crate::stringify!($($pattern)|+ $(if $guard)?),\n+                    $crate::option::Option::Some($crate::format_args!($($arg)+))\n+                );\n+            }\n+        }\n+    });\n+}\n+\n /// Asserts that a boolean expression is `true` at runtime.\n ///\n /// This will invoke the [`panic!`] macro if the provided expression cannot be\n@@ -208,6 +262,42 @@ macro_rules! debug_assert_ne {\n     ($($arg:tt)*) => (if $crate::cfg!(debug_assertions) { $crate::assert_ne!($($arg)*); })\n }\n \n+/// Asserts that an expression matches any of the given patterns.\n+///\n+/// Like in a `match` expression, the pattern can be optionally followed by `if`\n+/// and a guard expression that has access to names bound by the pattern.\n+///\n+/// On panic, this macro will print the value of the expression with its\n+/// debug representation.\n+///\n+/// Unlike [`assert_matches!`], `debug_assert_matches!` statements are only\n+/// enabled in non optimized builds by default. An optimized build will not\n+/// execute `debug_assert_matches!` statements unless `-C debug-assertions` is\n+/// passed to the compiler. This makes `debug_assert_matches!` useful for\n+/// checks that are too expensive to be present in a release build but may be\n+/// helpful during development. The result of expanding `debug_assert_matches!`\n+/// is always type checked.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(assert_matches)]\n+///\n+/// let a = 1u32.checked_add(2);\n+/// let b = 1u32.checked_sub(2);\n+/// debug_assert_matches!(a, Some(_));\n+/// debug_assert_matches!(b, None);\n+///\n+/// let c = Ok(\"abc\".to_string());\n+/// debug_assert_matches!(c, Ok(x) | Err(x) if x.len() < 100);\n+/// ```\n+#[macro_export]\n+#[unstable(feature = \"assert_matches\", issue = \"82775\")]\n+#[allow_internal_unstable(assert_matches)]\n+macro_rules! debug_assert_matches {\n+    ($($arg:tt)*) => (if $crate::cfg!(debug_assertions) { $crate::assert_matches!($($arg)*); })\n+}\n+\n /// Returns whether the given expression matches any of the given patterns.\n ///\n /// Like in a `match` expression, the pattern can be optionally followed by `if`"}, {"sha": "12acf5b4329dbba8d615d355013dc0ca2035a8ca", "filename": "library/core/src/panicking.rs", "status": "modified", "additions": 46, "deletions": 23, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/04045cc83f59e08be5d12d7ca4ac4d6364a02ff1/library%2Fcore%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04045cc83f59e08be5d12d7ca4ac4d6364a02ff1/library%2Fcore%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpanicking.rs?ref=04045cc83f59e08be5d12d7ca4ac4d6364a02ff1", "patch": "@@ -97,6 +97,7 @@ pub fn panic_fmt(fmt: fmt::Arguments<'_>) -> ! {\n pub enum AssertKind {\n     Eq,\n     Ne,\n+    Match,\n }\n \n /// Internal function for `assert_eq!` and `assert_ne!` macros\n@@ -113,32 +114,54 @@ where\n     T: fmt::Debug + ?Sized,\n     U: fmt::Debug + ?Sized,\n {\n-    #[track_caller]\n-    fn inner(\n-        kind: AssertKind,\n-        left: &dyn fmt::Debug,\n-        right: &dyn fmt::Debug,\n-        args: Option<fmt::Arguments<'_>>,\n-    ) -> ! {\n-        let op = match kind {\n-            AssertKind::Eq => \"==\",\n-            AssertKind::Ne => \"!=\",\n-        };\n-\n-        match args {\n-            Some(args) => panic!(\n-                r#\"assertion failed: `(left {} right)`\n+    assert_failed_inner(kind, &left, &right, args)\n+}\n+\n+/// Internal function for `assert_match!`\n+#[cold]\n+#[track_caller]\n+#[doc(hidden)]\n+pub fn assert_matches_failed<T: fmt::Debug + ?Sized>(\n+    left: &T,\n+    right: &str,\n+    args: Option<fmt::Arguments<'_>>,\n+) -> ! {\n+    // Use the Display implementation to display the pattern.\n+    struct Pattern<'a>(&'a str);\n+    impl fmt::Debug for Pattern<'_> {\n+        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+            fmt::Display::fmt(self.0, f)\n+        }\n+    }\n+    assert_failed_inner(AssertKind::Match, &left, &Pattern(right), args);\n+}\n+\n+/// Non-generic version of the above functions, to avoid code bloat.\n+#[track_caller]\n+fn assert_failed_inner(\n+    kind: AssertKind,\n+    left: &dyn fmt::Debug,\n+    right: &dyn fmt::Debug,\n+    args: Option<fmt::Arguments<'_>>,\n+) -> ! {\n+    let op = match kind {\n+        AssertKind::Eq => \"==\",\n+        AssertKind::Ne => \"!=\",\n+        AssertKind::Match => \"matches\",\n+    };\n+\n+    match args {\n+        Some(args) => panic!(\n+            r#\"assertion failed: `(left {} right)`\n   left: `{:?}`,\n  right: `{:?}: {}`\"#,\n-                op, left, right, args\n-            ),\n-            None => panic!(\n-                r#\"assertion failed: `(left {} right)`\n+            op, left, right, args\n+        ),\n+        None => panic!(\n+            r#\"assertion failed: `(left {} right)`\n   left: `{:?}`,\n  right: `{:?}`\"#,\n-                op, left, right,\n-            ),\n-        }\n+            op, left, right,\n+        ),\n     }\n-    inner(kind, &left, &right, args)\n }"}, {"sha": "72b86338d2c9783e7fef77db8a45b471dbfcb7d1", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/04045cc83f59e08be5d12d7ca4ac4d6364a02ff1/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/04045cc83f59e08be5d12d7ca4ac4d6364a02ff1/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=04045cc83f59e08be5d12d7ca4ac4d6364a02ff1", "patch": "@@ -228,6 +228,7 @@\n #![feature(arbitrary_self_types)]\n #![feature(array_error_internals)]\n #![feature(asm)]\n+#![feature(assert_matches)]\n #![feature(associated_type_bounds)]\n #![feature(atomic_mut_ptr)]\n #![feature(box_syntax)]\n@@ -552,8 +553,8 @@ pub use std_detect::detect;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow(deprecated, deprecated_in_future)]\n pub use core::{\n-    assert_eq, assert_ne, debug_assert, debug_assert_eq, debug_assert_ne, matches, r#try, todo,\n-    unimplemented, unreachable, write, writeln,\n+    assert_eq, assert_matches, assert_ne, debug_assert, debug_assert_eq, debug_assert_matches,\n+    debug_assert_ne, matches, r#try, todo, unimplemented, unreachable, write, writeln,\n };\n \n // Re-export built-in macros defined through libcore."}]}