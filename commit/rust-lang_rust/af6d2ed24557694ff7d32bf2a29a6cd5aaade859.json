{"sha": "af6d2ed24557694ff7d32bf2a29a6cd5aaade859", "node_id": "C_kwDOAAsO6NoAKGFmNmQyZWQyNDU1NzY5NGZmN2QzMmJmMmEyOWE2Y2Q1YWFhZGU4NTk", "commit": {"author": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2022-03-02T23:35:47Z"}, "committer": {"name": "The 8472", "email": "git@infinite-source.de", "date": "2022-03-02T23:43:46Z"}, "message": "hardcode /sys/fs/cgroup instead of doing a lookup via mountinfo\n\nthis avoids parsing mountinfo which can be huge on some systems and\nsomething might be emulating cgroup fs for sandboxing reasons which means\nit wouldn't show up as mountpoint\n\nadditionally the new implementation operates on a single pathbuffer, reducing allocations", "tree": {"sha": "9cf146a1f1d8ca537bb495c852bd045ee7f61943", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9cf146a1f1d8ca537bb495c852bd045ee7f61943"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af6d2ed24557694ff7d32bf2a29a6cd5aaade859", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af6d2ed24557694ff7d32bf2a29a6cd5aaade859", "html_url": "https://github.com/rust-lang/rust/commit/af6d2ed24557694ff7d32bf2a29a6cd5aaade859", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af6d2ed24557694ff7d32bf2a29a6cd5aaade859/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bac5523ea0025988361a092c1f0e7f4eb90f6ad7", "url": "https://api.github.com/repos/rust-lang/rust/commits/bac5523ea0025988361a092c1f0e7f4eb90f6ad7", "html_url": "https://github.com/rust-lang/rust/commit/bac5523ea0025988361a092c1f0e7f4eb90f6ad7"}], "stats": {"total": 120, "additions": 67, "deletions": 53}, "files": [{"sha": "ff01ce273332909b3ee2dd06621f0b0c838549ce", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 67, "deletions": 53, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/af6d2ed24557694ff7d32bf2a29a6cd5aaade859/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af6d2ed24557694ff7d32bf2a29a6cd5aaade859/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=af6d2ed24557694ff7d32bf2a29a6cd5aaade859", "patch": "@@ -279,7 +279,7 @@ pub fn available_parallelism() -> io::Result<NonZeroUsize> {\n         ))] {\n             #[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n             {\n-                let quota = cgroup2_quota().unwrap_or(usize::MAX).max(1);\n+                let quota = cgroup2_quota().max(1);\n                 let mut set: libc::cpu_set_t = unsafe { mem::zeroed() };\n                 unsafe {\n                     if libc::sched_getaffinity(0, mem::size_of::<libc::cpu_set_t>(), &mut set) == 0 {\n@@ -373,64 +373,78 @@ pub fn available_parallelism() -> io::Result<NonZeroUsize> {\n     }\n }\n \n+/// Returns cgroup CPU quota in core-equivalents, rounded down, or usize::MAX if the quota cannot\n+/// be determined or is not set.\n #[cfg(any(target_os = \"android\", target_os = \"linux\"))]\n-fn cgroup2_quota() -> Option<usize> {\n+fn cgroup2_quota() -> usize {\n     use crate::ffi::OsString;\n-    use crate::fs::{read, read_to_string, File};\n-    use crate::io::{BufRead, BufReader};\n+    use crate::fs::{try_exists, File};\n+    use crate::io::Read;\n     use crate::os::unix::ffi::OsStringExt;\n     use crate::path::PathBuf;\n \n-    // find cgroup2 fs\n-    let cgroups_mount = BufReader::new(File::open(\"/proc/self/mountinfo\").ok()?)\n-        .split(b'\\n')\n-        .map_while(Result::ok)\n-        .filter_map(|line| {\n-            let fields: Vec<_> = line.split(|&c| c == b' ').collect();\n-            let suffix_at = fields.iter().position(|f| f == b\"-\")?;\n-            let fs_type = fields[suffix_at + 1];\n-            if fs_type == b\"cgroup2\" { Some(fields[4].to_owned()) } else { None }\n-        })\n-        .next()?;\n-\n-    let cgroups_mount = PathBuf::from(OsString::from_vec(cgroups_mount));\n-\n-    // find our place in the hierarchy\n-    let cgroup_path = read(\"/proc/self/cgroup\")\n-        .ok()?\n-        .split(|&c| c == b'\\n')\n-        .filter_map(|line| {\n-            let mut fields = line.splitn(3, |&c| c == b':');\n-            // expect cgroupv2 which has an empty 2nd field\n-            if fields.nth(1) != Some(b\"\") {\n-                return None;\n-            }\n-            let path = fields.last()?;\n-            // skip leading slash\n-            Some(path[1..].to_owned())\n-        })\n-        .next()?;\n-    let cgroup_path = PathBuf::from(OsString::from_vec(cgroup_path));\n-\n-    // walk hierarchy and take the minimum quota\n-    cgroup_path\n-        .ancestors()\n-        .filter_map(|level| {\n-            let cgroup_path = cgroups_mount.join(level);\n-            let quota = match read_to_string(cgroup_path.join(\"cpu.max\")) {\n-                Ok(quota) => quota,\n-                _ => return None,\n-            };\n-            let quota = quota.lines().next()?;\n-            let mut quota = quota.split(' ');\n-            let limit = quota.next()?;\n-            let period = quota.next()?;\n-            match (limit.parse::<usize>(), period.parse::<usize>()) {\n-                (Ok(limit), Ok(period)) => Some(limit / period),\n-                _ => None,\n+    let mut quota = usize::MAX;\n+\n+    let _: Option<()> = try {\n+        let mut buf = Vec::with_capacity(128);\n+        // find our place in the cgroup hierarchy\n+        File::open(\"/proc/self/cgroup\").ok()?.read_to_end(&mut buf).ok()?;\n+        let cgroup_path = buf\n+            .split(|&c| c == b'\\n')\n+            .filter_map(|line| {\n+                let mut fields = line.splitn(3, |&c| c == b':');\n+                // expect cgroupv2 which has an empty 2nd field\n+                if fields.nth(1) != Some(b\"\") {\n+                    return None;\n+                }\n+                let path = fields.last()?;\n+                // skip leading slash\n+                Some(path[1..].to_owned())\n+            })\n+            .next()?;\n+        let cgroup_path = PathBuf::from(OsString::from_vec(cgroup_path));\n+\n+        let mut path = PathBuf::with_capacity(128);\n+        let mut read_buf = String::with_capacity(20);\n+\n+        let cgroup_mount = \"/sys/fs/cgroup\";\n+\n+        path.push(cgroup_mount);\n+        path.push(&cgroup_path);\n+\n+        path.push(\"cgroup.controllers\");\n+\n+        // skip if we're not looking at cgroup2\n+        if matches!(try_exists(&path), Err(_) | Ok(false)) {\n+            return usize::MAX;\n+        };\n+\n+        path.pop();\n+\n+        while path.starts_with(cgroup_mount) {\n+            path.push(\"cpu.max\");\n+\n+            read_buf.clear();\n+\n+            if File::open(&path).and_then(|mut f| f.read_to_string(&mut read_buf)).is_ok() {\n+                let raw_quota = read_buf.lines().next()?;\n+                let mut raw_quota = raw_quota.split(' ');\n+                let limit = raw_quota.next()?;\n+                let period = raw_quota.next()?;\n+                match (limit.parse::<usize>(), period.parse::<usize>()) {\n+                    (Ok(limit), Ok(period)) => {\n+                        quota = quota.min(limit / period);\n+                    }\n+                    _ => {}\n+                }\n             }\n-        })\n-        .min()\n+\n+            path.pop(); // pop filename\n+            path.pop(); // pop dir\n+        }\n+    };\n+\n+    quota\n }\n \n #[cfg(all("}]}