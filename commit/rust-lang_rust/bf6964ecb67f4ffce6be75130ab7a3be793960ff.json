{"sha": "bf6964ecb67f4ffce6be75130ab7a3be793960ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmNjk2NGVjYjY3ZjRmZmNlNmJlNzUxMzBhYjdhM2JlNzkzOTYwZmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-29T04:31:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-11-29T04:31:39Z"}, "message": "auto merge of #10709 : alexcrichton/rust/snapshot, r=pcwalton", "tree": {"sha": "ddf8aabea4d05b3ae0cb977cc1a466526f871b06", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ddf8aabea4d05b3ae0cb977cc1a466526f871b06"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf6964ecb67f4ffce6be75130ab7a3be793960ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf6964ecb67f4ffce6be75130ab7a3be793960ff", "html_url": "https://github.com/rust-lang/rust/commit/bf6964ecb67f4ffce6be75130ab7a3be793960ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf6964ecb67f4ffce6be75130ab7a3be793960ff/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "90d06ecf6b26e949921778f0d479ea1532077200", "url": "https://api.github.com/repos/rust-lang/rust/commits/90d06ecf6b26e949921778f0d479ea1532077200", "html_url": "https://github.com/rust-lang/rust/commit/90d06ecf6b26e949921778f0d479ea1532077200"}, {"sha": "ab387a68388974a432951e806851936898907fd0", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab387a68388974a432951e806851936898907fd0", "html_url": "https://github.com/rust-lang/rust/commit/ab387a68388974a432951e806851936898907fd0"}], "stats": {"total": 2621, "additions": 1287, "deletions": 1334}, "files": [{"sha": "a25f19371bd7b70e0148fad92a245c4d91a2dfe9", "filename": "doc/rust.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -2820,7 +2820,7 @@ expression*, which is the value to compare to the patterns. The type of the\n patterns must equal the type of the head expression.\n \n In a pattern whose head expression has an `enum` type, a placeholder (`_`) stands for a\n-*single* data field, whereas a wildcard `*` stands for *all* the fields of a particular\n+*single* data field, whereas a wildcard `..` stands for *all* the fields of a particular\n variant. For example:\n \n ~~~~\n@@ -2830,15 +2830,15 @@ let x: List<int> = Cons(10, @Cons(11, @Nil));\n \n match x {\n     Cons(_, @Nil) => fail!(\"singleton list\"),\n-    Cons(*)       => return,\n+    Cons(..)      => return,\n     Nil           => fail!(\"empty list\")\n }\n ~~~~\n \n The first pattern matches lists constructed by applying `Cons` to any head value, and a\n tail value of `@Nil`. The second pattern matches _any_ list constructed with `Cons`,\n ignoring the values of its arguments. The difference between `_` and `*` is that the pattern `C(_)` is only type-correct if\n-`C` has exactly one argument, while the pattern `C(*)` is type-correct for any enum variant `C`, regardless of how many arguments `C` has.\n+`C` has exactly one argument, while the pattern `C(..)` is type-correct for any enum variant `C`, regardless of how many arguments `C` has.\n \n To execute an `match` expression, first the head expression is evaluated, then\n its value is sequentially compared to the patterns in the arms until a match"}, {"sha": "c82f99772c9d384dd071ec8dc732009b00884558", "filename": "doc/tutorial.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -606,16 +606,16 @@ match mypoint {\n \n In general, the field names of a struct do not have to appear in the same\n order they appear in the type. When you are not interested in all\n-the fields of a struct, a struct pattern may end with `, _` (as in\n-`Name { field1, _ }`) to indicate that you're ignoring all other fields.\n+the fields of a struct, a struct pattern may end with `, ..` (as in\n+`Name { field1, .. }`) to indicate that you're ignoring all other fields.\n Additionally, struct fields have a shorthand matching form that simply\n reuses the field name as the binding name.\n \n ~~~\n # struct Point { x: f64, y: f64 }\n # let mypoint = Point { x: 0.0, y: 0.0 };\n match mypoint {\n-    Point { x, _ } => { println(x.to_str()) }\n+    Point { x, .. } => { println(x.to_str()) }\n }\n ~~~\n \n@@ -696,7 +696,7 @@ fn area(sh: Shape) -> f64 {\n ~~~~\n \n You can write a lone `_` to ignore an individual field, and can\n-ignore all fields of a variant like: `Circle(*)`. As in their\n+ignore all fields of a variant like: `Circle(..)`. As in their\n introduction form, nullary enum patterns are written without\n parentheses.\n \n@@ -725,7 +725,7 @@ enum Shape {\n }\n fn area(sh: Shape) -> f64 {\n     match sh {\n-        Circle { radius: radius, _ } => f64::consts::PI * square(radius),\n+        Circle { radius: radius, .. } => f64::consts::PI * square(radius),\n         Rectangle { top_left: top_left, bottom_right: bottom_right } => {\n             (bottom_right.x - top_left.x) * (top_left.y - bottom_right.y)\n         }\n@@ -1698,7 +1698,7 @@ a function that returns `Option<T>` instead of `T`.\n fn radius(shape: Shape) -> Option<f64> {\n     match shape {\n         Circle(_, radius) => Some(radius),\n-        Rectangle(*)      => None\n+        Rectangle(..)      => None\n     }\n }\n ~~~~"}, {"sha": "1bf6542903aad8e4cff2a0b442a56228558ebadb", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -166,7 +166,7 @@ fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n                           &ProcRes);\n         }\n \n-        let ProcRes{ stdout, _ } = ProcRes;\n+        let ProcRes{ stdout, .. } = ProcRes;\n         srcs.push(stdout);\n         round += 1;\n     }"}, {"sha": "770aa6432cfa1cced9a3052c16eb5ed9a87b6dbc", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -256,7 +256,7 @@ impl<T:Send> MutexArc<T> {\n     pub fn unwrap(self) -> T {\n         let MutexArc { x: x } = self;\n         let inner = x.unwrap();\n-        let MutexArcInner { failed: failed, data: data, _ } = inner;\n+        let MutexArcInner { failed: failed, data: data, .. } = inner;\n         if failed {\n             fail!(\"Can't unwrap poisoned MutexArc - another task failed inside!\");\n         }\n@@ -504,9 +504,9 @@ impl<T:Freeze + Send> RWArc<T> {\n      * in write mode.\n      */\n     pub fn unwrap(self) -> T {\n-        let RWArc { x: x, _ } = self;\n+        let RWArc { x: x, .. } = self;\n         let inner = x.unwrap();\n-        let RWArcInner { failed: failed, data: data, _ } = inner;\n+        let RWArcInner { failed: failed, data: data, .. } = inner;\n         if failed {\n             fail!(\"Can't unwrap poisoned RWArc - another task failed inside!\")\n         }"}, {"sha": "015dcc2e1dd206dc8fc92f0c25d4f316853897ca", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -663,7 +663,7 @@ impl BitvSet {\n             size += 1;\n             true\n         });\n-        let Bitv{rep, _} = bitv;\n+        let Bitv{rep, ..} = bitv;\n         match rep {\n             Big(b) => BitvSet{ size: size, bitv: b },\n             Small(SmallBitv{bits}) =>\n@@ -678,7 +678,7 @@ impl BitvSet {\n     /// Consumes this set to return the underlying bit vector\n     pub fn unwrap(self) -> Bitv {\n         let cap = self.capacity();\n-        let BitvSet{bitv, _} = self;\n+        let BitvSet{bitv, ..} = self;\n         return Bitv{ nbits:cap, rep: Big(bitv) };\n     }\n "}, {"sha": "040c814a04a513fa6d6ad980c276fe9006c44657", "filename": "src/libextra/btree.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibextra%2Fbtree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibextra%2Fbtree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbtree.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -111,8 +111,8 @@ impl<K: Clone + TotalOrd, V: Clone> Node<K, V>{\n     ///Differentiates between leaf and branch nodes.\n     fn is_leaf(&self) -> bool{\n         match self{\n-            &LeafNode(*) => true,\n-            &BranchNode(*) => false\n+            &LeafNode(..) => true,\n+            &BranchNode(..) => false\n         }\n     }\n \n@@ -208,7 +208,7 @@ impl<K: ToStr + TotalOrd, V: ToStr> ToStr for Node<K, V>{\n     fn to_str(&self) -> ~str{\n         match *self{\n             LeafNode(ref leaf) => leaf.to_str(),\n-            BranchNode(*) => ~\"\"\n+            BranchNode(..) => ~\"\"\n         }\n     }\n }"}, {"sha": "ccbaca295ec4ffa8248579342bc97653d0fb28a3", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -241,7 +241,7 @@ impl<T> Deque<T> for DList<T> {\n     ///\n     /// O(1)\n     fn pop_front(&mut self) -> Option<T> {\n-        self.pop_front_node().map(|~Node{value, _}| value)\n+        self.pop_front_node().map(|~Node{value, ..}| value)\n     }\n \n     /// Add an element last in the list\n@@ -255,7 +255,7 @@ impl<T> Deque<T> for DList<T> {\n     ///\n     /// O(1)\n     fn pop_back(&mut self) -> Option<T> {\n-        self.pop_back_node().map(|~Node{value, _}| value)\n+        self.pop_back_node().map(|~Node{value, ..}| value)\n     }\n }\n "}, {"sha": "ad5df00a2fe84de6a1e8d80594b34958926164a3", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -549,7 +549,7 @@ pub mod groups {\n                 long_name: long_name,\n                 hasarg: hasarg,\n                 occur: occur,\n-                _\n+                ..\n             } = (*self).clone();\n \n             match (short_name.len(), long_name.len()) {\n@@ -686,7 +686,7 @@ pub mod groups {\n                          hint: hint,\n                          desc: desc,\n                          hasarg: hasarg,\n-                         _} = (*optref).clone();\n+                         ..} = (*optref).clone();\n \n             let mut row = \" \".repeat(4);\n "}, {"sha": "e398a10ecf138a4f9f85145e85b6680bc5d5bfb4", "filename": "src/libextra/glob.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibextra%2Fglob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibextra%2Fglob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fglob.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -154,7 +154,7 @@ fn list_dir_sorted(path: &Path) -> ~[Path] {\n             sort::quick_sort(children, |p1, p2| p2.filename() <= p1.filename());\n             children\n         }\n-        Err(*) => ~[]\n+        Err(..) => ~[]\n     }\n }\n "}, {"sha": "273996513926608497e689f1da301ed7322ab943", "filename": "src/libextra/json.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -875,11 +875,11 @@ impl Decoder {\n     fn expected(&self, expected: &str, found: &Json) -> ! {\n         let found_s = match *found {\n             Null => \"null\",\n-            List(*) => \"list\",\n-            Object(*) => \"object\",\n-            Number(*) => \"number\",\n-            String(*) => \"string\",\n-            Boolean(*) => \"boolean\"\n+            List(..) => \"list\",\n+            Object(..) => \"object\",\n+            Number(..) => \"number\",\n+            String(..) => \"string\",\n+            Boolean(..) => \"boolean\"\n         };\n         self.err(format!(\"expected {expct} but found {fnd}: {val}\",\n                          expct=expected, fnd=found_s, val=found.to_str()))"}, {"sha": "a74c4993be3507e6b317bd9c019481d0f0a2b137", "filename": "src/libextra/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibextra%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibextra%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flib.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -38,8 +38,6 @@ Rust extras are part of the standard Rust distribution.\n \n #[deny(non_camel_case_types)];\n #[deny(missing_doc)];\n-#[allow(unrecognized_lint)]; // NOTE: remove after the next snapshot\n-#[allow(cstack)]; // NOTE: remove after the next snapshot.\n \n use std::str::{StrSlice, OwnedStr};\n "}, {"sha": "d305b3f3b248aca2c361bac37c949606212cc128", "filename": "src/libextra/tempfile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibextra%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibextra%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftempfile.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -39,7 +39,7 @@ impl TempDir {\n         for _ in range(0u, 1000) {\n             let p = tmpdir.join(r.gen_ascii_str(16) + suffix);\n             match io::result(|| fs::mkdir(&p, io::UserRWX)) {\n-                Err(*) => {}\n+                Err(..) => {}\n                 Ok(()) => return Some(TempDir { path: Some(p) })\n             }\n         }"}, {"sha": "c16d4aa3e16869da21a6663eae713f6b283fca14", "filename": "src/libextra/test.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -97,12 +97,12 @@ pub enum TestFn {\n impl TestFn {\n     fn padding(&self) -> NamePadding {\n         match self {\n-            &StaticTestFn(*)   => PadNone,\n-            &StaticBenchFn(*)  => PadOnRight,\n-            &StaticMetricFn(*) => PadOnRight,\n-            &DynTestFn(*)      => PadNone,\n-            &DynMetricFn(*)    => PadOnRight,\n-            &DynBenchFn(*)     => PadOnRight,\n+            &StaticTestFn(..)   => PadNone,\n+            &StaticBenchFn(..)  => PadOnRight,\n+            &StaticMetricFn(..) => PadOnRight,\n+            &DynTestFn(..)      => PadNone,\n+            &DynMetricFn(..)    => PadOnRight,\n+            &DynBenchFn(..)     => PadOnRight,\n         }\n     }\n }"}, {"sha": "3ea7bf0fa56e2260392697819219f4efb7f6f03d", "filename": "src/libextra/time.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -681,13 +681,13 @@ pub fn strptime(s: &str, format: &str) -> Result<Tm, ~str> {\n \n         let mut buf = [0];\n         let c = match rdr.read(buf) {\n-            Some(*) => buf[0] as u8 as char,\n+            Some(..) => buf[0] as u8 as char,\n             None => break\n         };\n         match c {\n             '%' => {\n                 let ch = match rdr.read(buf) {\n-                    Some(*) => buf[0] as u8 as char,\n+                    Some(..) => buf[0] as u8 as char,\n                     None => break\n                 };\n                 match parse_type(s, pos, ch, &mut tm) {\n@@ -932,7 +932,7 @@ pub fn strftime(format: &str, tm: &Tm) -> ~str {\n     loop {\n         let mut b = [0];\n         let ch = match rdr.read(b) {\n-            Some(*) => b[0],\n+            Some(..) => b[0],\n             None => break,\n         };\n         match ch as char {"}, {"sha": "a936ceacc2e921113af4b3a481d87fccc524461a", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -686,7 +686,7 @@ fn mutate_values<'r,\n                  -> bool {\n     match *node {\n       Some(~TreeNode{key: ref key, value: ref mut value, left: ref mut left,\n-                     right: ref mut right, _}) => {\n+                     right: ref mut right, ..}) => {\n         if !mutate_values(left,  |k,v| f(k,v)) { return false }\n         if !f(key, value) { return false }\n         if !mutate_values(right, |k,v| f(k,v)) { return false }\n@@ -801,13 +801,13 @@ fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n                     (remove(&mut save.left, key), true)\n                 } else {\n                     let new = save.left.take_unwrap();\n-                    let ~TreeNode{value, _} = replace(save, new);\n+                    let ~TreeNode{value, ..} = replace(save, new);\n                     *save = save.left.take_unwrap();\n                     (Some(value), true)\n                 }\n             } else if save.right.is_some() {\n                 let new = save.right.take_unwrap();\n-                let ~TreeNode{value, _} = replace(save, new);\n+                let ~TreeNode{value, ..} = replace(save, new);\n                 (Some(value), true)\n             } else {\n                 (None, false)\n@@ -843,7 +843,7 @@ fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n       }\n     }\n     return match node.take() {\n-        Some(~TreeNode{value, _}) => Some(value), None => fail!()\n+        Some(~TreeNode{value, ..}) => Some(value), None => fail!()\n     };\n }\n "}, {"sha": "cfa4680052d0bdbc1090c67c4b64253fd684ee63", "filename": "src/libextra/url.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibextra%2Furl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibextra%2Furl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Furl.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -74,7 +74,7 @@ fn encode_inner(s: &str, full_url: bool) -> ~str {\n         let mut buf = [0];\n         let ch = match rdr.read(buf) {\n             None => break,\n-            Some(*) => buf[0] as char,\n+            Some(..) => buf[0] as char,\n         };\n \n         match ch {\n@@ -138,7 +138,7 @@ fn decode_inner(s: &str, full_url: bool) -> ~str {\n         let mut buf = [0];\n         let ch = match rdr.read(buf) {\n             None => break,\n-            Some(*) => buf[0] as char\n+            Some(..) => buf[0] as char\n         };\n         match ch {\n           '%' => {\n@@ -199,7 +199,7 @@ fn encode_plus(s: &str) -> ~str {\n     loop {\n         let mut buf = [0];\n         let ch = match rdr.read(buf) {\n-            Some(*) => buf[0] as char,\n+            Some(..) => buf[0] as char,\n             None => break,\n         };\n         match ch {\n@@ -253,7 +253,7 @@ pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<~str, ~[~str]> {\n     loop {\n         let mut buf = [0];\n         let ch = match rdr.read(buf) {\n-            Some(*) => buf[0] as char,\n+            Some(..) => buf[0] as char,\n             None => break,\n         };\n         match ch {\n@@ -318,7 +318,7 @@ fn split_char_first(s: &str, c: char) -> (~str, ~str) {\n     loop {\n         let mut buf = [0];\n         let ch = match rdr.read(buf) {\n-            Some(*) => buf[0] as char,\n+            Some(..) => buf[0] as char,\n             None => break,\n         };\n         if ch == c {"}, {"sha": "9aba16422d3fd4fdb637d23f21397390d96c7937", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -973,7 +973,7 @@ fn is_writeable(p: &Path) -> bool {\n \n     !p.exists() ||\n         (match io::result(|| p.stat()) {\n-            Err(*) => false,\n+            Err(..) => false,\n             Ok(m) => m.perm & io::UserWrite == io::UserWrite\n         })\n }"}, {"sha": "82ddb9c2f973cf55e6c34c2bea869ea68d3d3d4c", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -95,7 +95,7 @@ impl Visitor<()> for Context {\n             ast::view_item_use(ref paths) => {\n                 for path in paths.iter() {\n                     match path.node {\n-                        ast::view_path_glob(*) => {\n+                        ast::view_path_glob(..) => {\n                             self.gate_feature(\"globs\", path.span,\n                                               \"glob import statements are \\\n                                                experimental and possibly buggy\");\n@@ -110,8 +110,6 @@ impl Visitor<()> for Context {\n     }\n \n     fn visit_item(&mut self, i: @ast::item, _:()) {\n-        // NOTE: uncomment after snapshot\n-        /*\n         for attr in i.attrs.iter() {\n             if \"thread_local\" == attr.name() {\n                 self.gate_feature(\"thread_local\", i.span,\n@@ -120,12 +118,11 @@ impl Visitor<()> for Context {\n                                   `#[task_local]` mapping to the task model\");\n             }\n         }\n-        */\n         match i.node {\n             ast::item_enum(ref def, _) => {\n                 for variant in def.variants.iter() {\n                     match variant.node.kind {\n-                        ast::struct_variant_kind(*) => {\n+                        ast::struct_variant_kind(..) => {\n                             self.gate_feature(\"struct_variant\", variant.span,\n                                               \"enum struct variants are \\\n                                                experimental and possibly buggy\");"}, {"sha": "c65dc5cc50e3f7a743a213d35c412236773cdefe", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -19,8 +19,6 @@\n #[crate_type = \"lib\"];\n \n #[feature(macro_rules, globs, struct_variant, managed_boxes)];\n-#[allow(unrecognized_lint)]; // NOTE: remove after the next snapshot\n-#[allow(cstack)]; // NOTE: remove after the next snapshot.\n \n extern mod extra;\n extern mod syntax;"}, {"sha": "a6a96b25ff5591e7829b9ad8f902d6214acb9d90", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -128,7 +128,6 @@ pub enum RealPredicate {\n \n // The LLVM TypeKind type - must stay in sync with the def of\n // LLVMTypeKind in llvm/include/llvm-c/Core.h\n-#[cfg(not(stage0))]\n #[deriving(Eq)]\n #[repr(C)]\n pub enum TypeKind {\n@@ -150,42 +149,6 @@ pub enum TypeKind {\n     X86_MMX   = 15,\n }\n \n-// NOTE remove these after snapshot.  (See also #10308.)\n-#[cfg(stage0)]\n-pub type TypeKind = u32;\n-#[cfg(stage0)]\n-pub static Void: TypeKind      = 0;\n-#[cfg(stage0)]\n-pub static Half: TypeKind      = 1;\n-#[cfg(stage0)]\n-pub static Float: TypeKind     = 2;\n-#[cfg(stage0)]\n-pub static Double: TypeKind    = 3;\n-#[cfg(stage0)]\n-pub static X86_FP80: TypeKind  = 4;\n-#[cfg(stage0)]\n-pub static FP128: TypeKind     = 5;\n-#[cfg(stage0)]\n-pub static PPC_FP128: TypeKind = 6;\n-#[cfg(stage0)]\n-pub static Label: TypeKind     = 7;\n-#[cfg(stage0)]\n-pub static Integer: TypeKind   = 8;\n-#[cfg(stage0)]\n-pub static Function: TypeKind  = 9;\n-#[cfg(stage0)]\n-pub static Struct: TypeKind    = 10;\n-#[cfg(stage0)]\n-pub static Array: TypeKind     = 11;\n-#[cfg(stage0)]\n-pub static Pointer: TypeKind   = 12;\n-#[cfg(stage0)]\n-pub static Vector: TypeKind    = 13;\n-#[cfg(stage0)]\n-pub static Metadata: TypeKind  = 14;\n-#[cfg(stage0)]\n-pub static X86_MMX: TypeKind   = 15;\n-\n #[repr(C)]\n pub enum AtomicBinOp {\n     Xchg = 0,"}, {"sha": "48621459228fb4fcbd98fddc576f812c34058837", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -503,7 +503,7 @@ pub enum DefLike {\n pub fn def_like_to_def(def_like: DefLike) -> ast::Def {\n     match def_like {\n         DlDef(def) => return def,\n-        DlImpl(*) => fail!(\"found impl in def_like_to_def\"),\n+        DlImpl(..) => fail!(\"found impl in def_like_to_def\"),\n         DlField => fail!(\"found field in def_like_to_def\")\n     }\n }"}, {"sha": "6da75397002df4662ecc42fb009eecc6763985e9", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -623,7 +623,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n         });\n \n         match item.node {\n-            item_impl(*) => {\n+            item_impl(..) => {\n                 let (ident, did) = (item.ident, item.id);\n                 debug!(\"(encoding info for module) ... encoding impl {} \\\n                         ({:?}/{:?})\",\n@@ -983,7 +983,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_visibility(ebml_w, vis);\n         ebml_w.end_tag();\n       }\n-      item_ty(*) => {\n+      item_ty(..) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n@@ -1242,7 +1242,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // Encode inherent implementations for this trait.\n         encode_inherent_implementations(ecx, ebml_w, def_id);\n       }\n-      item_mac(*) => fail!(\"item macros unimplemented\")\n+      item_mac(..) => fail!(\"item macros unimplemented\")\n     }\n }\n \n@@ -1256,7 +1256,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n \n     ebml_w.start_tag(tag_items_data_item);\n     match nitem.node {\n-      foreign_item_fn(*) => {\n+      foreign_item_fn(..) => {\n         encode_def_id(ebml_w, local_def(nitem.id));\n         encode_family(ebml_w, purity_fn_family(impure_fn));\n         encode_bounds_and_type(ebml_w, ecx,\n@@ -1769,7 +1769,7 @@ pub fn encode_metadata(parms: EncodeParams, crate: &Crate) -> ~[u8] {\n         link_meta,\n         reachable,\n         non_inlineable_statics,\n-        _\n+        ..\n     } = parms;\n     let type_abbrevs = @mut HashMap::new();\n     let stats = @mut stats;"}, {"sha": "456a08f6d08c0b9cb3ade9dfe319ac6645043108", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -138,7 +138,7 @@ pub fn search(filesearch: @FileSearch, pick: pick) {\n                 }\n                 rslt\n             }\n-            Err(*) => FileDoesntMatch,\n+            Err(..) => FileDoesntMatch,\n         }\n     });\n }"}, {"sha": "2eb6dcaf49be4b25ddb8c7f343f86a5a41acaebb", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -313,7 +313,7 @@ impl fold::ast_fold for NestedItemsDropper {\n                     node: ast::DeclItem(_),\n                     span: _\n                 }, _) => None,\n-                ast::StmtMac(*) => fail!(\"unexpanded macro in astencode\")\n+                ast::StmtMac(..) => fail!(\"unexpanded macro in astencode\")\n             }\n         }).collect();\n         let blk_sans_items = ast::Block {\n@@ -483,7 +483,7 @@ impl tr for ty::Region {\n                                                                      index,\n                                                                      ident),\n             ty::ReScope(id) => ty::ReScope(xcx.tr_id(id)),\n-            ty::ReEmpty | ty::ReStatic | ty::ReInfer(*) => *self,\n+            ty::ReEmpty | ty::ReStatic | ty::ReInfer(..) => *self,\n             ty::ReFree(ref fr) => {\n                 ty::ReFree(ty::FreeRegion {scope_id: xcx.tr_id(fr.scope_id),\n                                             bound_region: fr.bound_region.tr(xcx)})"}, {"sha": "6545919e8442f656d7a1d8b604d07851e07258a8", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -399,12 +399,12 @@ impl<'self> CheckLoanCtxt<'self> {\n                         cmt = b;\n                     }\n \n-                    mc::cat_rvalue(*) |\n+                    mc::cat_rvalue(..) |\n                     mc::cat_static_item |\n-                    mc::cat_copied_upvar(*) |\n-                    mc::cat_deref(_, _, mc::unsafe_ptr(*)) |\n-                    mc::cat_deref(_, _, mc::gc_ptr(*)) |\n-                    mc::cat_deref(_, _, mc::region_ptr(*)) => {\n+                    mc::cat_copied_upvar(..) |\n+                    mc::cat_deref(_, _, mc::unsafe_ptr(..)) |\n+                    mc::cat_deref(_, _, mc::gc_ptr(..)) |\n+                    mc::cat_deref(_, _, mc::region_ptr(..)) => {\n                         assert_eq!(cmt.mutbl, mc::McDeclared);\n                         return;\n                     }\n@@ -477,12 +477,12 @@ impl<'self> CheckLoanCtxt<'self> {\n                     }\n \n                     mc::cat_copied_upvar(_) |\n-                    mc::cat_rvalue(*) |\n-                    mc::cat_local(*) |\n+                    mc::cat_rvalue(..) |\n+                    mc::cat_local(..) |\n                     mc::cat_arg(_) |\n-                    mc::cat_self(*) |\n-                    mc::cat_deref(_, _, mc::unsafe_ptr(*)) |\n-                    mc::cat_static_item(*) |\n+                    mc::cat_self(..) |\n+                    mc::cat_deref(_, _, mc::unsafe_ptr(..)) |\n+                    mc::cat_static_item(..) |\n                     mc::cat_deref(_, _, mc::gc_ptr(_)) |\n                     mc::cat_deref(_, _, mc::region_ptr(MutImmutable, _)) => {\n                         // Aliasability is independent of base cmt\n@@ -654,7 +654,7 @@ impl<'self> CheckLoanCtxt<'self> {\n \n     fn check_move_out_from_expr(&self, expr: @ast::Expr) {\n         match expr.node {\n-            ast::ExprFnBlock(*) | ast::ExprProc(*) => {\n+            ast::ExprFnBlock(..) | ast::ExprProc(..) => {\n                 // moves due to capture clauses are checked\n                 // in `check_loans_in_fn`, so that we can\n                 // give a better error message\n@@ -728,14 +728,14 @@ fn check_loans_in_fn<'a>(this: &mut CheckLoanCtxt<'a>,\n                          sp: Span,\n                          id: ast::NodeId) {\n     match *fk {\n-        visit::fk_item_fn(*) |\n-        visit::fk_method(*) => {\n+        visit::fk_item_fn(..) |\n+        visit::fk_method(..) => {\n             // Don't process nested items.\n             return;\n         }\n \n-        visit::fk_anon(*) |\n-        visit::fk_fn_block(*) => {\n+        visit::fk_anon(..) |\n+        visit::fk_fn_block(..) => {\n             check_captured_variables(this, id, sp);\n         }\n     }\n@@ -800,7 +800,7 @@ fn check_loans_in_expr<'a>(this: &mut CheckLoanCtxt<'a>,\n \n     match expr.node {\n       ast::ExprSelf |\n-      ast::ExprPath(*) => {\n+      ast::ExprPath(..) => {\n           if !this.move_data.is_assignee(expr.id) {\n               let cmt = this.bccx.cat_expr_unadjusted(expr);\n               debug!(\"path cmt={}\", cmt.repr(this.tcx()));"}, {"sha": "2b8c500b637c8a452b65d1e1d0698240a1cc92ad", "filename": "src/librustc/middle/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -100,11 +100,11 @@ fn check_is_legal_to_move_from(bccx: &BorrowckCtxt,\n                                cmt0: mc::cmt,\n                                cmt: mc::cmt) -> bool {\n     match cmt.cat {\n-        mc::cat_deref(_, _, mc::region_ptr(*)) |\n-        mc::cat_deref(_, _, mc::gc_ptr(*)) |\n-        mc::cat_deref(_, _, mc::unsafe_ptr(*)) |\n-        mc::cat_stack_upvar(*) |\n-        mc::cat_copied_upvar(mc::CopiedUpvar { onceness: ast::Many, _ }) => {\n+        mc::cat_deref(_, _, mc::region_ptr(..)) |\n+        mc::cat_deref(_, _, mc::gc_ptr(..)) |\n+        mc::cat_deref(_, _, mc::unsafe_ptr(..)) |\n+        mc::cat_stack_upvar(..) |\n+        mc::cat_copied_upvar(mc::CopiedUpvar { onceness: ast::Many, .. }) => {\n             bccx.span_err(\n                 cmt0.span,\n                 format!(\"cannot move out of {}\",\n@@ -115,7 +115,7 @@ fn check_is_legal_to_move_from(bccx: &BorrowckCtxt,\n         // Can move out of captured upvars only if the destination closure\n         // type is 'once'. 1-shot stack closures emit the copied_upvar form\n         // (see mem_categorization.rs).\n-        mc::cat_copied_upvar(mc::CopiedUpvar { onceness: ast::Once, _ }) => {\n+        mc::cat_copied_upvar(mc::CopiedUpvar { onceness: ast::Once, .. }) => {\n             true\n         }\n \n@@ -132,10 +132,10 @@ fn check_is_legal_to_move_from(bccx: &BorrowckCtxt,\n             true\n         }\n \n-        mc::cat_rvalue(*) |\n-        mc::cat_local(*) |\n-        mc::cat_arg(*) |\n-        mc::cat_self(*) => {\n+        mc::cat_rvalue(..) |\n+        mc::cat_local(..) |\n+        mc::cat_arg(..) |\n+        mc::cat_self(..) => {\n             true\n         }\n "}, {"sha": "0ce36e522621d228d4433e0e3278f9b89c91bc35", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -70,13 +70,13 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n         //! Main routine. Walks down `cmt` until we find the \"guarantor\".\n \n         match cmt.cat {\n-            mc::cat_rvalue(*) |\n-            mc::cat_copied_upvar(*) |                  // L-Local\n-            mc::cat_local(*) |                         // L-Local\n-            mc::cat_arg(*) |                           // L-Local\n-            mc::cat_self(*) |                          // L-Local\n-            mc::cat_deref(_, _, mc::region_ptr(*)) |   // L-Deref-Borrowed\n-            mc::cat_deref(_, _, mc::unsafe_ptr(*)) => {\n+            mc::cat_rvalue(..) |\n+            mc::cat_copied_upvar(..) |                  // L-Local\n+            mc::cat_local(..) |                         // L-Local\n+            mc::cat_arg(..) |                           // L-Local\n+            mc::cat_self(..) |                          // L-Local\n+            mc::cat_deref(_, _, mc::region_ptr(..)) |   // L-Deref-Borrowed\n+            mc::cat_deref(_, _, mc::unsafe_ptr(..)) => {\n                 let scope = self.scope(cmt);\n                 self.check_scope(scope)\n             }\n@@ -183,7 +183,7 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n         //! lvalue.\n \n         cmt.mutbl.is_immutable() || match cmt.guarantor().cat {\n-            mc::cat_rvalue(*) => true,\n+            mc::cat_rvalue(..) => true,\n             _ => false\n         }\n     }\n@@ -305,16 +305,16 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n             mc::cat_arg(id) => {\n                 self.bccx.moved_variables_set.contains(&id)\n             }\n-            mc::cat_rvalue(*) |\n+            mc::cat_rvalue(..) |\n             mc::cat_static_item |\n-            mc::cat_copied_upvar(*) |\n-            mc::cat_deref(*) => {\n+            mc::cat_copied_upvar(..) |\n+            mc::cat_deref(..) => {\n                 false\n             }\n-            r @ mc::cat_downcast(*) |\n-            r @ mc::cat_interior(*) |\n-            r @ mc::cat_stack_upvar(*) |\n-            r @ mc::cat_discr(*) => {\n+            r @ mc::cat_downcast(..) |\n+            r @ mc::cat_interior(..) |\n+            r @ mc::cat_stack_upvar(..) |\n+            r @ mc::cat_discr(..) => {\n                 self.tcx().sess.span_bug(\n                     cmt.span,\n                     format!(\"illegal guarantor category: {:?}\", r));\n@@ -344,15 +344,15 @@ impl<'self> GuaranteeLifetimeContext<'self> {\n             mc::cat_self(local_id) => {\n                 self.bccx.tcx.region_maps.encl_region(local_id)\n             }\n-            mc::cat_deref(_, _, mc::unsafe_ptr(*)) => {\n+            mc::cat_deref(_, _, mc::unsafe_ptr(..)) => {\n                 ty::ReStatic\n             }\n             mc::cat_deref(_, _, mc::region_ptr(_, r)) => {\n                 r\n             }\n             mc::cat_downcast(cmt) |\n             mc::cat_deref(cmt, _, mc::uniq_ptr) |\n-            mc::cat_deref(cmt, _, mc::gc_ptr(*)) |\n+            mc::cat_deref(cmt, _, mc::gc_ptr(..)) |\n             mc::cat_interior(cmt, _) |\n             mc::cat_stack_upvar(cmt) |\n             mc::cat_discr(cmt, _) => {"}, {"sha": "7688d4dff73d86987d4fd9e2562e382649c5b9f3", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -135,12 +135,12 @@ fn gather_loans_in_fn(this: &mut GatherLoanCtxt,\n                       sp: Span,\n                       id: ast::NodeId) {\n     match fk {\n-        &visit::fk_item_fn(*) | &visit::fk_method(*) => {\n+        &visit::fk_item_fn(..) | &visit::fk_method(..) => {\n             fail!(\"cannot occur, due to visit_item override\");\n         }\n \n         // Visit closures as part of the containing item.\n-        &visit::fk_anon(*) | &visit::fk_fn_block(*) => {\n+        &visit::fk_anon(..) | &visit::fk_fn_block(..) => {\n             this.push_repeating_id(body.id);\n             visit::walk_fn(this, fk, decl, body, sp, id, ());\n             this.pop_repeating_id(body.id);\n@@ -305,7 +305,7 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n           this.pop_repeating_id(body.id);\n       }\n \n-      ast::ExprFnBlock(*) | ast::ExprProc(*) => {\n+      ast::ExprFnBlock(..) | ast::ExprProc(..) => {\n           gather_moves::gather_captures(this.bccx, this.move_data, ex);\n           visit::walk_expr(this, ex, ());\n       }\n@@ -353,14 +353,14 @@ impl<'self> GatherLoanCtxt<'self> {\n         let _i = indenter();\n \n         match *adjustment {\n-            ty::AutoAddEnv(*) => {\n+            ty::AutoAddEnv(..) => {\n                 debug!(\"autoaddenv -- no autoref\");\n                 return;\n             }\n \n             ty::AutoDerefRef(\n                 ty::AutoDerefRef {\n-                    autoref: None, _ }) => {\n+                    autoref: None, .. }) => {\n                 debug!(\"no autoref\");\n                 return;\n             }\n@@ -489,9 +489,9 @@ impl<'self> GatherLoanCtxt<'self> {\n                     }\n \n                     ty::ReEmpty |\n-                    ty::ReLateBound(*) |\n-                    ty::ReEarlyBound(*) |\n-                    ty::ReInfer(*) => {\n+                    ty::ReLateBound(..) |\n+                    ty::ReEarlyBound(..) |\n+                    ty::ReInfer(..) => {\n                         self.tcx().sess.span_bug(\n                             cmt.span,\n                             format!(\"Invalid borrow lifetime: {:?}\", loan_region));"}, {"sha": "57f180846e938f061c3357e3f4aeaee385180a15", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -68,7 +68,7 @@ impl<'self> RestrictionsContext<'self> {\n         }\n \n         match cmt.cat {\n-            mc::cat_rvalue(*) => {\n+            mc::cat_rvalue(..) => {\n                 // Effectively, rvalues are stored into a\n                 // non-aliasable temporary on the stack. Since they\n                 // are inherently non-aliasable, they can only be\n@@ -117,8 +117,8 @@ impl<'self> RestrictionsContext<'self> {\n                 self.extend(result, cmt.mutbl, LpDeref(pk), restrictions)\n             }\n \n-            mc::cat_copied_upvar(*) | // FIXME(#2152) allow mutation of upvars\n-            mc::cat_static_item(*) |\n+            mc::cat_copied_upvar(..) | // FIXME(#2152) allow mutation of upvars\n+            mc::cat_static_item(..) |\n             mc::cat_deref(_, _, mc::region_ptr(MutImmutable, _)) |\n             mc::cat_deref(_, _, mc::gc_ptr(MutImmutable)) => {\n                 // R-Deref-Imm-Borrowed\n@@ -200,7 +200,7 @@ impl<'self> RestrictionsContext<'self> {\n                 }\n             }\n \n-            mc::cat_deref(_, _, mc::unsafe_ptr(*)) => {\n+            mc::cat_deref(_, _, mc::unsafe_ptr(..)) => {\n                 // We are very trusting when working with unsafe pointers.\n                 Safe\n             }"}, {"sha": "c12194ac8bb9d05462ff6dc79d630c4461d8c113", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -127,13 +127,13 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n                sp: Span,\n                id: ast::NodeId) {\n     match fk {\n-        &visit::fk_anon(*) |\n-        &visit::fk_fn_block(*) => {\n+        &visit::fk_anon(..) |\n+        &visit::fk_fn_block(..) => {\n             // Closures are checked as part of their containing fn item.\n         }\n \n-        &visit::fk_item_fn(*) |\n-        &visit::fk_method(*) => {\n+        &visit::fk_item_fn(..) |\n+        &visit::fk_method(..) => {\n             debug!(\"borrowck_fn(id={:?})\", id);\n \n             // Check the body of fn items.\n@@ -305,7 +305,7 @@ pub fn opt_loan_path(cmt: mc::cmt) -> Option<@LoanPath> {\n     //! traverses the CMT.\n \n     match cmt.cat {\n-        mc::cat_rvalue(*) |\n+        mc::cat_rvalue(..) |\n         mc::cat_static_item |\n         mc::cat_copied_upvar(_) => {\n             None\n@@ -497,14 +497,14 @@ impl BorrowckCtxt {\n                                adj: @ty::AutoAdjustment)\n                                -> mc::cmt {\n         match *adj {\n-            ty::AutoAddEnv(*) => {\n+            ty::AutoAddEnv(..) => {\n                 // no autoderefs\n                 mc::cat_expr_unadjusted(self.tcx, self.method_map, expr)\n             }\n \n             ty::AutoDerefRef(\n                 ty::AutoDerefRef {\n-                    autoderefs: autoderefs, _}) => {\n+                    autoderefs: autoderefs, ..}) => {\n                 mc::cat_expr_autoderefd(self.tcx, self.method_map, expr,\n                                         autoderefs)\n             }\n@@ -657,10 +657,10 @@ impl BorrowckCtxt {\n                      self.cmt_to_str(err.cmt),\n                      self.mut_to_str(lk))\n             }\n-            err_out_of_root_scope(*) => {\n+            err_out_of_root_scope(..) => {\n                 format!(\"cannot root managed value long enough\")\n             }\n-            err_out_of_scope(*) => {\n+            err_out_of_scope(..) => {\n                 format!(\"borrowed value does not live long enough\")\n             }\n             err_freeze_aliasable_const => {\n@@ -733,7 +733,7 @@ impl BorrowckCtxt {\n     pub fn note_and_explain_bckerr(&self, err: BckError) {\n         let code = err.code;\n         match code {\n-            err_mutbl(*) | err_freeze_aliasable_const(*) => {}\n+            err_mutbl(..) | err_freeze_aliasable_const(..) => {}\n \n             err_out_of_root_scope(super_scope, sub_scope) => {\n                 note_and_explain_region("}, {"sha": "dc58423a42478107a0401b714905e04eb4c622cc", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -211,7 +211,7 @@ impl MoveData {\n         }\n \n         let index = match *lp {\n-            LpVar(*) => {\n+            LpVar(..) => {\n                 let index = MovePathIndex(self.paths.len());\n \n                 self.paths.push(MovePath {\n@@ -284,7 +284,7 @@ impl MoveData {\n             }\n             None => {\n                 match *lp {\n-                    LpVar(*) => { }\n+                    LpVar(..) => { }\n                     LpExtend(b, _, _) => {\n                         self.add_existing_base_paths(b, result);\n                     }\n@@ -394,7 +394,7 @@ impl MoveData {\n                     let path = *self.path_map.get(&path.loan_path);\n                     self.kill_moves(path, kill_id, dfcx_moves);\n                 }\n-                LpExtend(*) => {}\n+                LpExtend(..) => {}\n             }\n         }\n \n@@ -405,7 +405,7 @@ impl MoveData {\n                     let kill_id = tcx.region_maps.encl_scope(id);\n                     dfcx_assign.add_kill(kill_id, assignment_index);\n                 }\n-                LpExtend(*) => {\n+                LpExtend(..) => {\n                     tcx.sess.bug(\"Var assignment for non var path\");\n                 }\n             }"}, {"sha": "028fdd52a26512f36c246a954664ad551d46a727", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -43,7 +43,7 @@ pub fn construct(tcx: ty::ctxt,\n     };\n     let entry = cfg_builder.add_node(0, []);\n     let exit = cfg_builder.block(blk, entry);\n-    let CFGBuilder {exit_map, graph, _} = cfg_builder;\n+    let CFGBuilder {exit_map, graph, ..} = cfg_builder;\n     CFG {exit_map: exit_map,\n          graph: graph,\n          entry: entry,\n@@ -72,7 +72,7 @@ impl CFGBuilder {\n                 self.expr(expr, pred)\n             }\n \n-            ast::StmtMac(*) => {\n+            ast::StmtMac(..) => {\n                 self.tcx.sess.span_bug(stmt.span, \"unexpanded macro\");\n             }\n         }\n@@ -95,8 +95,8 @@ impl CFGBuilder {\n         match pat.node {\n             ast::PatIdent(_, _, None) |\n             ast::PatEnum(_, None) |\n-            ast::PatLit(*) |\n-            ast::PatRange(*) |\n+            ast::PatLit(..) |\n+            ast::PatRange(..) |\n             ast::PatWild | ast::PatWildMulti => {\n                 self.add_node(pat.id, [pred])\n             }\n@@ -239,7 +239,7 @@ impl CFGBuilder {\n                 expr_exit\n             }\n \n-            ast::ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n+            ast::ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n \n             ast::ExprLoop(ref body, _) => {\n                 //\n@@ -405,13 +405,13 @@ impl CFGBuilder {\n             }\n \n             ast::ExprLogLevel |\n-            ast::ExprMac(*) |\n-            ast::ExprInlineAsm(*) |\n+            ast::ExprMac(..) |\n+            ast::ExprInlineAsm(..) |\n             ast::ExprSelf |\n-            ast::ExprFnBlock(*) |\n-            ast::ExprProc(*) |\n-            ast::ExprLit(*) |\n-            ast::ExprPath(*) => {\n+            ast::ExprFnBlock(..) |\n+            ast::ExprProc(..) |\n+            ast::ExprLit(..) |\n+            ast::ExprPath(..) => {\n                 self.straightline(expr, pred, [])\n             }\n         }"}, {"sha": "39cd3356fae61a50c5033fb56e8a9a44f7d832c8", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -86,9 +86,9 @@ pub fn check_pat(v: &mut CheckCrateVisitor, p: &Pat, _is_const: bool) {\n         match e.node {\n             ExprVstore(\n                 @Expr { node: ExprLit(@codemap::Spanned {\n-                    node: lit_str(*),\n-                    _}),\n-                       _ },\n+                    node: lit_str(..),\n+                    ..}),\n+                       .. },\n                 ExprVstoreUniq\n             ) => true,\n             _ => false\n@@ -120,8 +120,8 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n                           \"cannot do allocations in constant expressions\");\n             return;\n           }\n-          ExprLit(@codemap::Spanned {node: lit_str(*), _}) => { }\n-          ExprBinary(*) | ExprUnary(*) => {\n+          ExprLit(@codemap::Spanned {node: lit_str(..), ..}) => { }\n+          ExprBinary(..) | ExprUnary(..) => {\n             if method_map.contains_key(&e.id) {\n                 sess.span_err(e.span, \"user-defined operators are not \\\n                                        allowed in constant expressions\");\n@@ -147,7 +147,7 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n                              items without type parameters\");\n             }\n             match def_map.find(&e.id) {\n-              Some(&DefStatic(*)) |\n+              Some(&DefStatic(..)) |\n               Some(&DefFn(_, _)) |\n               Some(&DefVariant(_, _, _)) |\n               Some(&DefStruct(_)) => { }\n@@ -166,8 +166,8 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n           }\n           ExprCall(callee, _, NoSugar) => {\n             match def_map.find(&callee.id) {\n-                Some(&DefStruct(*)) => {}    // OK.\n-                Some(&DefVariant(*)) => {}    // OK.\n+                Some(&DefStruct(..)) => {}    // OK.\n+                Some(&DefVariant(..)) => {}    // OK.\n                 _ => {\n                     sess.span_err(\n                         e.span,\n@@ -181,12 +181,12 @@ pub fn check_expr(v: &mut CheckCrateVisitor,\n           ExprVstore(_, ExprVstoreSlice) |\n           ExprVec(_, MutImmutable) |\n           ExprAddrOf(MutImmutable, _) |\n-          ExprField(*) |\n-          ExprIndex(*) |\n-          ExprTup(*) |\n-          ExprRepeat(*) |\n-          ExprStruct(*) => { }\n-          ExprAddrOf(*) => {\n+          ExprField(..) |\n+          ExprIndex(..) |\n+          ExprTup(..) |\n+          ExprRepeat(..) |\n+          ExprStruct(..) => { }\n+          ExprAddrOf(..) => {\n                 sess.span_err(\n                     e.span,\n                     \"borrowed pointers in constants may only refer to \\\n@@ -251,7 +251,7 @@ impl Visitor<()> for CheckItemRecursionVisitor {\n \n     fn visit_expr(&mut self, e: @Expr, _: ()) {\n         match e.node {\n-            ExprPath(*) => match self.env.def_map.find(&e.id) {\n+            ExprPath(..) => match self.env.def_map.find(&e.id) {\n                 Some(&DefStatic(def_id, _)) if ast_util::is_local(def_id) =>\n                     match self.env.ast_map.get_copy(&def_id.node) {\n                         ast_map::node_item(it, _) => {"}, {"sha": "c46f5fa892ed35f3b2f375e9643021b54fb65e04", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -192,7 +192,7 @@ fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, pats: ~[@Pat]) {\n                         }\n                     }\n                 }\n-                ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n+                ty::ty_unboxed_vec(..) | ty::ty_evec(..) => {\n                     match *ctor {\n                         vec(n) => Some(format!(\"vectors of length {}\", n).to_managed()),\n                         _ => None\n@@ -274,7 +274,7 @@ fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@Pat]) -> useful {\n               ty::ty_evec(_, ty::vstore_fixed(n)) => {\n                 is_useful_specialized(cx, m, v, vec(n), n, left_ty)\n               }\n-              ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n+              ty::ty_unboxed_vec(..) | ty::ty_evec(..) => {\n                 let max_len = m.rev_iter().fold(0, |max_len, r| {\n                   match r[0].node {\n                     PatVec(ref before, _, ref after) => {\n@@ -348,13 +348,13 @@ fn pat_ctor_id(cx: &MatchCheckCtxt, p: @Pat) -> Option<ctor> {\n       PatRange(lo, hi) => {\n         Some(range(eval_const_expr(cx.tcx, lo), eval_const_expr(cx.tcx, hi)))\n       }\n-      PatStruct(*) => {\n+      PatStruct(..) => {\n         match cx.tcx.def_map.find(&pat.id) {\n           Some(&DefVariant(_, id, _)) => Some(variant(id)),\n           _ => Some(single)\n         }\n       }\n-      PatBox(_) | PatUniq(_) | PatTup(_) | PatRegion(*) => {\n+      PatBox(_) | PatUniq(_) | PatTup(_) | PatRegion(..) => {\n         Some(single)\n       }\n       PatVec(ref before, slice, ref after) => {\n@@ -372,7 +372,7 @@ fn is_wild(cx: &MatchCheckCtxt, p: @Pat) -> bool {\n       PatWild | PatWildMulti => { true }\n       PatIdent(_, _, _) => {\n         match cx.tcx.def_map.find(&pat.id) {\n-          Some(&DefVariant(_, _, _)) | Some(&DefStatic(*)) => { false }\n+          Some(&DefVariant(_, _, _)) | Some(&DefStatic(..)) => { false }\n           _ => { true }\n         }\n       }\n@@ -385,8 +385,8 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n                     left_ty: ty::t)\n                  -> Option<ctor> {\n     match ty::get(left_ty).sty {\n-      ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(*) | ty::ty_tup(_) |\n-      ty::ty_struct(*) => {\n+      ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(..) | ty::ty_tup(_) |\n+      ty::ty_struct(..) => {\n         for r in m.iter() {\n             if !is_wild(cx, r[0]) { return None; }\n         }\n@@ -451,7 +451,7 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n           _         => None\n         }\n       }\n-      ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n+      ty::ty_unboxed_vec(..) | ty::ty_evec(..) => {\n \n         // Find the lengths and slices of all vector patterns.\n         let vec_pat_lens = m.iter().filter_map(|r| {\n@@ -508,7 +508,7 @@ fn missing_ctor(cx: &MatchCheckCtxt,\n fn ctor_arity(cx: &MatchCheckCtxt, ctor: &ctor, ty: ty::t) -> uint {\n     match ty::get(ty).sty {\n       ty::ty_tup(ref fs) => fs.len(),\n-      ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(*) => 1u,\n+      ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(..) => 1u,\n       ty::ty_enum(eid, _) => {\n           let id = match *ctor { variant(id) => id,\n           _ => fail!(\"impossible case\") };\n@@ -518,7 +518,7 @@ fn ctor_arity(cx: &MatchCheckCtxt, ctor: &ctor, ty: ty::t) -> uint {\n         }\n       }\n       ty::ty_struct(cid, _) => ty::lookup_struct_fields(cx.tcx, cid).len(),\n-      ty::ty_unboxed_vec(*) | ty::ty_evec(*) => {\n+      ty::ty_unboxed_vec(..) | ty::ty_evec(..) => {\n         match *ctor {\n           vec(n) => n,\n           _ => 0u\n@@ -656,8 +656,8 @@ fn specialize(cx: &MatchCheckCtxt,\n                     }\n                     DefVariant(_, _, _) => None,\n \n-                    DefFn(*) |\n-                    DefStruct(*) => {\n+                    DefFn(..) |\n+                    DefStruct(..) => {\n                         // FIXME #4731: Is this right? --pcw\n                         let new_args;\n                         match args {\n@@ -847,7 +847,7 @@ fn is_refutable(cx: &MatchCheckCtxt, pat: &Pat) -> bool {\n             return true;\n         }\n       }\n-      Some(&DefStatic(*)) => return true,\n+      Some(&DefStatic(..)) => return true,\n       _ => ()\n     }\n \n@@ -857,7 +857,7 @@ fn is_refutable(cx: &MatchCheckCtxt, pat: &Pat) -> bool {\n         is_refutable(cx, sub)\n       }\n       PatWild | PatWildMulti | PatIdent(_, _, None) => { false }\n-      PatLit(@Expr {node: ExprLit(@Spanned { node: lit_nil, _}), _}) => {\n+      PatLit(@Expr {node: ExprLit(@Spanned { node: lit_nil, ..}), ..}) => {\n         // \"()\"\n         false\n       }\n@@ -872,7 +872,7 @@ fn is_refutable(cx: &MatchCheckCtxt, pat: &Pat) -> bool {\n         args.iter().any(|a| is_refutable(cx, *a))\n       }\n       PatEnum(_,_) => { false }\n-      PatVec(*) => { true }\n+      PatVec(..) => { true }\n     }\n }\n \n@@ -903,7 +903,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n     let check_move: |&Pat, Option<@Pat>| = |p, sub| {\n         // check legality of moving out of the enum\n \n-        // x @ Foo(*) is legal, but x @ Foo(y) isn't.\n+        // x @ Foo(..) is legal, but x @ Foo(y) isn't.\n         if sub.map_default(false, |p| pat_contains_bindings(def_map, p)) {\n             tcx.sess.span_err(\n                 p.span,"}, {"sha": "641a685a38fe1b8e5f351105cedf323f75945d46", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -193,7 +193,7 @@ impl ConstEvalVisitor {\n         let cn = match e.node {\n             ast::ExprLit(lit) => {\n                 match lit.node {\n-                    ast::lit_str(*) | ast::lit_float(*) => general_const,\n+                    ast::lit_str(..) | ast::lit_float(..) => general_const,\n                     _ => integral_const\n                 }\n             }\n@@ -246,7 +246,7 @@ impl ConstEvalVisitor {\n             // surrounding nonlocal constants. But we don't yet.\n             ast::ExprPath(_) => self.lookup_constness(e),\n \n-            ast::ExprRepeat(*) => general_const,\n+            ast::ExprRepeat(..) => general_const,\n \n             _ => non_const\n         };"}, {"sha": "6927793ec1fa11db344f980ae59c3c4e26b0b1b9", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -399,7 +399,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 self.walk_expr(expr, in_out, loop_scopes);\n             }\n \n-            ast::StmtMac(*) => {\n+            ast::StmtMac(..) => {\n                 self.tcx().sess.span_bug(stmt.span, \"unexpanded macro\");\n             }\n         }\n@@ -568,7 +568,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 copy_bits(new_loop_scope.break_bits, in_out);\n             }\n \n-            ast::ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n+            ast::ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n \n             ast::ExprLoop(ref blk, _) => {\n                 //\n@@ -706,8 +706,8 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n             }\n \n             ast::ExprLogLevel |\n-            ast::ExprLit(*) |\n-            ast::ExprPath(*) |\n+            ast::ExprLit(..) |\n+            ast::ExprPath(..) |\n             ast::ExprSelf => {\n             }\n \n@@ -734,7 +734,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 self.walk_block(blk, in_out, loop_scopes);\n             }\n \n-            ast::ExprMac(*) => {\n+            ast::ExprMac(..) => {\n                 self.tcx().sess.span_bug(expr.span, \"unexpanded macro\");\n             }\n         }"}, {"sha": "4c7ffcf1e214486b8fd9da63530fd1df9b72f655", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -70,7 +70,7 @@ impl EffectCheckVisitor {\n         debug!(\"effect: checking index with base type {}\",\n                 ppaux::ty_to_str(self.tcx, base_type));\n         match ty::get(base_type).sty {\n-            ty::ty_estr(*) => {\n+            ty::ty_estr(..) => {\n                 self.tcx.sess.span_err(e.span,\n                     \"modification of string types is not allowed\");\n             }\n@@ -106,7 +106,7 @@ impl Visitor<()> for EffectCheckVisitor {\n     fn visit_block(&mut self, block: &ast::Block, _:()) {\n         let old_unsafe_context = self.unsafe_context;\n         let is_unsafe = match block.rules {\n-            ast::UnsafeBlock(*) => true, ast::DefaultBlock => false\n+            ast::UnsafeBlock(..) => true, ast::DefaultBlock => false\n         };\n         if is_unsafe && self.unsafe_context == SafeContext {\n             self.unsafe_context = UnsafeBlock(block.id)\n@@ -154,10 +154,10 @@ impl Visitor<()> for EffectCheckVisitor {\n             ast::ExprAddrOf(ast::MutMutable, base) => {\n                 self.check_str_index(base);\n             }\n-            ast::ExprInlineAsm(*) => {\n+            ast::ExprInlineAsm(..) => {\n                 self.require_unsafe(expr.span, \"use of inline assembly\")\n             }\n-            ast::ExprPath(*) => {\n+            ast::ExprPath(..) => {\n                 match ty::resolve_expr(self.tcx, expr) {\n                     ast::DefStatic(_, true) => {\n                         self.require_unsafe(expr.span, \"use of mutable static\")"}, {"sha": "c2d7878a081b655eccce529d7d0e831f109ca699", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -76,7 +76,7 @@ pub fn find_entry_point(session: Session, crate: &Crate, ast_map: ast_map::map)\n \n fn find_item(item: @item, ctxt: &mut EntryContext) {\n     match item.node {\n-        item_fn(*) => {\n+        item_fn(..) => {\n             if item.ident.name == special_idents::main.name {\n                 match ctxt.ast_map.find(&item.id) {\n                     Some(&ast_map::node_item(_, path)) => {"}, {"sha": "1219fd9260e5baec1454ef600f0a628dd8d5b25f", "filename": "src/librustc/middle/freevars.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffreevars.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -47,10 +47,10 @@ impl Visitor<int> for CollectFreevarsVisitor {\n     fn visit_expr(&mut self, expr:@ast::Expr, depth:int) {\n \n             match expr.node {\n-              ast::ExprFnBlock(*) | ast::ExprProc(*) => {\n+              ast::ExprFnBlock(..) | ast::ExprProc(..) => {\n                 visit::walk_expr(self, expr, depth + 1)\n               }\n-              ast::ExprPath(*) | ast::ExprSelf => {\n+              ast::ExprPath(..) | ast::ExprSelf => {\n                   let mut i = 0;\n                   match self.def_map.find(&expr.id) {\n                     None => fail!(\"path not found\"),"}, {"sha": "a4348a71d214f61a57a02c98739fcb3c10797546", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -216,21 +216,21 @@ fn with_appropriate_checker(cx: &Context,\n         ty::ty_closure(ty::ClosureTy {\n             sigil: OwnedSigil,\n             bounds: bounds,\n-            _\n+            ..\n         }) => {\n             b(|cx, fv| check_for_uniq(cx, fv, bounds))\n         }\n         ty::ty_closure(ty::ClosureTy {\n             sigil: ManagedSigil,\n-            _\n+            ..\n         }) => {\n             // can't happen\n         }\n         ty::ty_closure(ty::ClosureTy {\n             sigil: BorrowedSigil,\n             bounds: bounds,\n             region: region,\n-            _\n+            ..\n         }) => {\n             b(|cx, fv| check_for_block(cx, fv, bounds, region))\n         }\n@@ -442,9 +442,9 @@ fn check_imm_free_var(cx: &Context, def: Def, sp: Span) {\n                 sp,\n                 \"mutable variables cannot be implicitly captured\");\n         }\n-        DefLocal(*) | DefArg(*) => { /* ok */ }\n+        DefLocal(..) | DefArg(..) => { /* ok */ }\n         DefUpvar(_, def1, _, _) => { check_imm_free_var(cx, *def1, sp); }\n-        DefBinding(*) | DefSelf(*) => { /*ok*/ }\n+        DefBinding(..) | DefSelf(..) => { /*ok*/ }\n         _ => {\n             cx.tcx.sess.span_bug(\n                 sp,\n@@ -480,7 +480,7 @@ pub fn check_send(cx: &Context, ty: ty::t, sp: Span) -> bool {\n pub fn check_durable(tcx: ty::ctxt, ty: ty::t, sp: Span) -> bool {\n     if !ty::type_is_static(tcx, ty) {\n         match ty::get(ty).sty {\n-          ty::ty_param(*) => {\n+          ty::ty_param(..) => {\n             tcx.sess.span_err(sp, \"value may contain borrowed \\\n                                    pointers; add `'static` bound\");\n           }\n@@ -529,7 +529,7 @@ pub fn check_cast_for_escaping_regions(\n     // worries.\n     let target_ty = ty::expr_ty(cx.tcx, target);\n     match ty::get(target_ty).sty {\n-        ty::ty_trait(*) => {}\n+        ty::ty_trait(..) => {}\n         _ => { return; }\n     }\n \n@@ -591,7 +591,7 @@ pub fn check_cast_for_escaping_regions(\n \n     fn is_ReScope(r: ty::Region) -> bool {\n         match r {\n-            ty::ReScope(*) => true,\n+            ty::ReScope(..) => true,\n             _ => false\n         }\n     }"}, {"sha": "c8f245d5555d8081bada6cd1a7e7fe70fcd9e9a0", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -434,7 +434,7 @@ pub fn extract(attrs: &[ast::Attribute]) -> Option<@str> {\n             Some((key, value)) if \"lang\" == key => {\n                 return Some(value);\n             }\n-            Some(*) | None => {}\n+            Some(..) | None => {}\n         }\n     }\n \n@@ -446,7 +446,7 @@ pub fn collect_language_items(crate: &ast::Crate,\n                            -> LanguageItems {\n     let mut collector = LanguageItemCollector::new(session);\n     collector.collect(crate);\n-    let LanguageItemCollector { items, _ } = collector;\n+    let LanguageItemCollector { items, .. } = collector;\n     session.abort_if_errors();\n     items\n }"}, {"sha": "4c6ca53694a0e7af5cf99f3b0e2a07e5250495e9", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -542,7 +542,7 @@ fn check_while_true_expr(cx: &Context, e: &ast::Expr) {\n         ast::ExprWhile(cond, _) => {\n             match cond.node {\n                 ast::ExprLit(@codemap::Spanned {\n-                    node: ast::lit_bool(true), _}) =>\n+                    node: ast::lit_bool(true), ..}) =>\n                 {\n                     cx.span_lint(while_true, e.span,\n                                  \"denote infinite loops with loop { ... }\");\n@@ -720,7 +720,7 @@ fn check_item_ctypes(cx: &Context, it: &ast::item) {\n                             cx.span_lint(ctypes, ty.span,\n                                          \"found enum type without foreign-function-safe \\\n                                           representation annotation in foreign module\");\n-                            // NOTE this message could be more helpful\n+                            // hmm... this message could be more helpful\n                         }\n                     }\n                     _ => ()\n@@ -785,10 +785,10 @@ fn check_heap_type(cx: &Context, span: Span, ty: ty::t) {\n \n fn check_heap_item(cx: &Context, it: &ast::item) {\n     match it.node {\n-        ast::item_fn(*) |\n-        ast::item_ty(*) |\n-        ast::item_enum(*) |\n-        ast::item_struct(*) => check_heap_type(cx, it.span,\n+        ast::item_fn(..) |\n+        ast::item_ty(..) |\n+        ast::item_enum(..) |\n+        ast::item_struct(..) => check_heap_type(cx, it.span,\n                                                ty::node_id_to_type(cx.tcx,\n                                                                    it.id)),\n         _ => ()\n@@ -892,7 +892,7 @@ fn check_heap_expr(cx: &Context, e: &ast::Expr) {\n \n fn check_path_statement(cx: &Context, s: &ast::Stmt) {\n     match s.node {\n-        ast::StmtSemi(@ast::Expr { node: ast::ExprPath(_), _ }, _) => {\n+        ast::StmtSemi(@ast::Expr { node: ast::ExprPath(_), .. }, _) => {\n             cx.span_lint(path_statement, s.span,\n                          \"path statement with no effect\");\n         }\n@@ -922,10 +922,10 @@ fn check_item_non_camel_case_types(cx: &Context, it: &ast::item) {\n     }\n \n     match it.node {\n-        ast::item_ty(*) | ast::item_struct(*) => {\n+        ast::item_ty(..) | ast::item_struct(..) => {\n             check_case(cx, \"type\", it.ident, it.span)\n         }\n-        ast::item_trait(*) => {\n+        ast::item_trait(..) => {\n             check_case(cx, \"trait\", it.ident, it.span)\n         }\n         ast::item_enum(ref enum_definition, _) => {\n@@ -1001,7 +1001,7 @@ fn check_unused_mut_pat(cx: &Context, p: &ast::Pat) {\n                       ref path, _) if pat_util::pat_is_binding(cx.tcx.def_map, p)=> {\n             // `let mut _a = 1;` doesn't need a warning.\n             let initial_underscore = match path.segments {\n-                [ast::PathSegment { identifier: id, _ }] => {\n+                [ast::PathSegment { identifier: id, .. }] => {\n                     cx.tcx.sess.str_of(id).starts_with(\"_\")\n                 }\n                 _ => {\n@@ -1027,8 +1027,8 @@ fn check_unnecessary_allocation(cx: &Context, e: &ast::Expr) {\n         ast::ExprVstore(e2, ast::ExprVstoreUniq) |\n         ast::ExprVstore(e2, ast::ExprVstoreBox) => {\n             match e2.node {\n-                ast::ExprLit(@codemap::Spanned{node: ast::lit_str(*), _}) |\n-                ast::ExprVec(*) => {}\n+                ast::ExprLit(@codemap::Spanned{node: ast::lit_str(..), ..}) |\n+                ast::ExprVec(..) => {}\n                 _ => return\n             }\n         }\n@@ -1038,7 +1038,7 @@ fn check_unnecessary_allocation(cx: &Context, e: &ast::Expr) {\n \n     match cx.tcx.adjustments.find_copy(&e.id) {\n         Some(@ty::AutoDerefRef(ty::AutoDerefRef {\n-            autoref: Some(ty::AutoBorrowVec(*)), _ })) => {\n+            autoref: Some(ty::AutoBorrowVec(..)), .. })) => {\n             cx.span_lint(unnecessary_allocation, e.span,\n                          \"unnecessary allocation, the sigil can be removed\");\n         }\n@@ -1071,11 +1071,11 @@ fn check_missing_doc_attrs(cx: &Context,\n \n fn check_missing_doc_item(cx: &mut Context, it: &ast::item) { // XXX doesn't need to be mut\n     let desc = match it.node {\n-        ast::item_fn(*) => \"a function\",\n-        ast::item_mod(*) => \"a module\",\n-        ast::item_enum(*) => \"an enum\",\n-        ast::item_struct(*) => \"a struct\",\n-        ast::item_trait(*) => \"a trait\",\n+        ast::item_fn(..) => \"a function\",\n+        ast::item_mod(..) => \"a module\",\n+        ast::item_enum(..) => \"an enum\",\n+        ast::item_struct(..) => \"a struct\",\n+        ast::item_trait(..) => \"a trait\",\n         _ => return\n     };\n     check_missing_doc_attrs(cx, it.id, it.attrs, it.span, desc);\n@@ -1091,13 +1091,13 @@ fn check_missing_doc_method(cx: &Context, m: &ast::method) {\n         Some(md) => {\n             match md.container {\n                 // Always check default methods defined on traits.\n-                ty::TraitContainer(*) => {}\n+                ty::TraitContainer(..) => {}\n                 // For methods defined on impls, it depends on whether\n                 // it is an implementation for a trait or is a plain\n                 // impl.\n                 ty::ImplContainer(cid) => {\n                     match ty::impl_trait_ref(cx.tcx, cid) {\n-                        Some(*) => return, // impl for trait: don't doc\n+                        Some(..) => return, // impl for trait: don't doc\n                         None => {} // plain impl: doc according to privacy\n                     }\n                 }\n@@ -1128,9 +1128,9 @@ fn check_missing_doc_variant(cx: &Context, v: &ast::variant) {\n /// #[unstable] (or none of them) attributes.\n fn check_stability(cx: &Context, e: &ast::Expr) {\n     let def = match e.node {\n-        ast::ExprMethodCall(*) |\n-        ast::ExprPath(*) |\n-        ast::ExprStruct(*) => {\n+        ast::ExprMethodCall(..) |\n+        ast::ExprPath(..) |\n+        ast::ExprStruct(..) => {\n             match cx.tcx.def_map.find(&e.id) {\n                 Some(&def) => def,\n                 None => return\n@@ -1178,17 +1178,17 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n     let (lint, label) = match stability {\n         // no stability attributes == Unstable\n         None => (unstable, \"unmarked\"),\n-        Some(attr::Stability { level: attr::Unstable, _ }) =>\n+        Some(attr::Stability { level: attr::Unstable, .. }) =>\n                 (unstable, \"unstable\"),\n-        Some(attr::Stability { level: attr::Experimental, _ }) =>\n+        Some(attr::Stability { level: attr::Experimental, .. }) =>\n                 (experimental, \"experimental\"),\n-        Some(attr::Stability { level: attr::Deprecated, _ }) =>\n+        Some(attr::Stability { level: attr::Deprecated, .. }) =>\n                 (deprecated, \"deprecated\"),\n         _ => return\n     };\n \n     let msg = match stability {\n-        Some(attr::Stability { text: Some(ref s), _ }) => {\n+        Some(attr::Stability { text: Some(ref s), .. }) => {\n             format!(\"use of {} item: {}\", label, *s)\n         }\n         _ => format!(\"use of {} item\", label)"}, {"sha": "ec86efdad75722f40e5c405d7edf5f5a35c3d89f", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -298,7 +298,7 @@ impl IrMaps {\n         self.num_vars += 1;\n \n         match vk {\n-            Local(LocalInfo { id: node_id, _ }) | Arg(node_id, _) => {\n+            Local(LocalInfo { id: node_id, .. }) | Arg(node_id, _) => {\n                 self.variable_map.insert(node_id, v);\n             },\n             ImplicitRet => {}\n@@ -321,7 +321,7 @@ impl IrMaps {\n \n     pub fn variable_name(&mut self, var: Variable) -> @str {\n         match self.var_kinds[*var] {\n-            Local(LocalInfo { ident: nm, _ }) | Arg(_, nm) => {\n+            Local(LocalInfo { ident: nm, .. }) | Arg(_, nm) => {\n                 self.tcx.sess.str_of(nm)\n             },\n             ImplicitRet => @\"<implicit-ret>\"\n@@ -394,14 +394,14 @@ fn visit_fn(v: &mut LivenessVisitor,\n     match *fk {\n         visit::fk_method(_, _, method) => {\n             match method.explicit_self.node {\n-                sty_value(_) | sty_region(*) | sty_box(_) | sty_uniq(_) => {\n+                sty_value(_) | sty_region(..) | sty_box(_) | sty_uniq(_) => {\n                     fn_maps.add_variable(Arg(method.self_id,\n                                              special_idents::self_));\n                 }\n                 sty_static => {}\n             }\n         }\n-        visit::fk_item_fn(*) | visit::fk_anon(*) | visit::fk_fn_block(*) => {}\n+        visit::fk_item_fn(..) | visit::fk_anon(..) | visit::fk_fn_block(..) => {}\n     }\n \n     // gather up the various local variables, significant expressions,\n@@ -486,7 +486,7 @@ fn visit_expr(v: &mut LivenessVisitor, expr: @Expr, this: @mut IrMaps) {\n         }\n         visit::walk_expr(v, expr, this);\n       }\n-      ExprFnBlock(*) | ExprProc(*) => {\n+      ExprFnBlock(..) | ExprProc(..) => {\n         // Interesting control flow (for loops can contain labeled\n         // breaks or continues)\n         this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n@@ -521,25 +521,25 @@ fn visit_expr(v: &mut LivenessVisitor, expr: @Expr, this: @mut IrMaps) {\n       }\n \n       // live nodes required for interesting control flow:\n-      ExprIf(*) | ExprMatch(*) | ExprWhile(*) | ExprLoop(*) => {\n+      ExprIf(..) | ExprMatch(..) | ExprWhile(..) | ExprLoop(..) => {\n         this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         visit::walk_expr(v, expr, this);\n       }\n-      ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n+      ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n       ExprBinary(_, op, _, _) if ast_util::lazy_binop(op) => {\n         this.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         visit::walk_expr(v, expr, this);\n       }\n \n       // otherwise, live nodes are not required:\n-      ExprIndex(*) | ExprField(*) | ExprVstore(*) | ExprVec(*) |\n-      ExprCall(*) | ExprMethodCall(*) | ExprTup(*) | ExprLogLevel |\n-      ExprBinary(*) | ExprAddrOf(*) |\n-      ExprDoBody(*) | ExprCast(*) | ExprUnary(*) | ExprBreak(_) |\n-      ExprAgain(_) | ExprLit(_) | ExprRet(*) | ExprBlock(*) |\n-      ExprAssign(*) | ExprAssignOp(*) | ExprMac(*) |\n-      ExprStruct(*) | ExprRepeat(*) | ExprParen(*) |\n-      ExprInlineAsm(*) => {\n+      ExprIndex(..) | ExprField(..) | ExprVstore(..) | ExprVec(..) |\n+      ExprCall(..) | ExprMethodCall(..) | ExprTup(..) | ExprLogLevel |\n+      ExprBinary(..) | ExprAddrOf(..) |\n+      ExprDoBody(..) | ExprCast(..) | ExprUnary(..) | ExprBreak(_) |\n+      ExprAgain(_) | ExprLit(_) | ExprRet(..) | ExprBlock(..) |\n+      ExprAssign(..) | ExprAssignOp(..) | ExprMac(..) |\n+      ExprStruct(..) | ExprRepeat(..) | ExprParen(..) |\n+      ExprInlineAsm(..) => {\n           visit::walk_expr(v, expr, this);\n       }\n     }\n@@ -956,7 +956,7 @@ impl Liveness {\n             return self.propagate_through_expr(expr, succ);\n           }\n \n-          StmtMac(*) => {\n+          StmtMac(..) => {\n             self.tcx.sess.span_bug(stmt.span, \"unexpanded macro\");\n           }\n         }\n@@ -1073,7 +1073,7 @@ impl Liveness {\n             self.propagate_through_loop(expr, Some(cond), blk, succ)\n           }\n \n-          ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n+          ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n \n           // Note that labels have been resolved, so we don't need to look\n           // at the label ident\n@@ -1243,15 +1243,15 @@ impl Liveness {\n           }\n \n           ExprLogLevel |\n-          ExprLit(*) => {\n+          ExprLit(..) => {\n             succ\n           }\n \n           ExprBlock(ref blk) => {\n             self.propagate_through_block(blk, succ)\n           }\n \n-          ExprMac(*) => {\n+          ExprMac(..) => {\n             self.tcx.sess.span_bug(expr.span, \"unexpanded macro\");\n           }\n         }\n@@ -1493,18 +1493,18 @@ fn check_expr(this: &mut Liveness, expr: @Expr) {\n       }\n \n       // no correctness conditions related to liveness\n-      ExprCall(*) | ExprMethodCall(*) | ExprIf(*) | ExprMatch(*) |\n-      ExprWhile(*) | ExprLoop(*) | ExprIndex(*) | ExprField(*) |\n-      ExprVstore(*) | ExprVec(*) | ExprTup(*) | ExprLogLevel |\n-      ExprBinary(*) | ExprDoBody(*) |\n-      ExprCast(*) | ExprUnary(*) | ExprRet(*) | ExprBreak(*) |\n-      ExprAgain(*) | ExprLit(_) | ExprBlock(*) |\n-      ExprMac(*) | ExprAddrOf(*) | ExprStruct(*) | ExprRepeat(*) |\n-      ExprParen(*) | ExprFnBlock(*) | ExprProc(*) | ExprPath(*) |\n-      ExprSelf(*) => {\n+      ExprCall(..) | ExprMethodCall(..) | ExprIf(..) | ExprMatch(..) |\n+      ExprWhile(..) | ExprLoop(..) | ExprIndex(..) | ExprField(..) |\n+      ExprVstore(..) | ExprVec(..) | ExprTup(..) | ExprLogLevel |\n+      ExprBinary(..) | ExprDoBody(..) |\n+      ExprCast(..) | ExprUnary(..) | ExprRet(..) | ExprBreak(..) |\n+      ExprAgain(..) | ExprLit(_) | ExprBlock(..) |\n+      ExprMac(..) | ExprAddrOf(..) | ExprStruct(..) | ExprRepeat(..) |\n+      ExprParen(..) | ExprFnBlock(..) | ExprProc(..) | ExprPath(..) |\n+      ExprSelf(..) => {\n         visit::walk_expr(this, expr, ());\n       }\n-      ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\")\n+      ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\")\n     }\n }\n "}, {"sha": "0c44f58aeb40605defa9812ee8eb167f61dfdb69", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -68,11 +68,11 @@ pub enum categorization {\n     cat_arg(ast::NodeId),              // formal argument\n     cat_deref(cmt, uint, PointerKind), // deref of a ptr\n     cat_interior(cmt, InteriorKind),   // something interior: field, tuple, etc\n-    cat_downcast(cmt),                 // selects a particular enum variant (*)\n+    cat_downcast(cmt),                 // selects a particular enum variant (..)\n     cat_discr(cmt, ast::NodeId),       // match discriminant (see preserve())\n     cat_self(ast::NodeId),             // explicit `self`\n \n-    // (*) downcast is only required if the enum has more than one variant\n+    // (..) downcast is only required if the enum has more than one variant\n }\n \n #[deriving(Eq)]\n@@ -159,7 +159,7 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n         ty::ty_trait(_, _, ty::UniqTraitStore, _, _) |\n         ty::ty_evec(_, ty::vstore_uniq) |\n         ty::ty_estr(ty::vstore_uniq) |\n-        ty::ty_closure(ty::ClosureTy {sigil: ast::OwnedSigil, _}) => {\n+        ty::ty_closure(ty::ClosureTy {sigil: ast::OwnedSigil, ..}) => {\n             Some(deref_ptr(uniq_ptr))\n         }\n \n@@ -174,7 +174,7 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n \n         ty::ty_estr(ty::vstore_slice(r)) |\n         ty::ty_closure(ty::ClosureTy {sigil: ast::BorrowedSigil,\n-                                      region: r, _}) => {\n+                                      region: r, ..}) => {\n             Some(deref_ptr(region_ptr(ast::MutImmutable, r)))\n         }\n \n@@ -195,8 +195,8 @@ pub fn opt_deref_kind(t: ty::t) -> Option<deref_kind> {\n             Some(deref_ptr(unsafe_ptr(mt.mutbl)))\n         }\n \n-        ty::ty_enum(*) |\n-        ty::ty_struct(*) => { // newtype\n+        ty::ty_enum(..) |\n+        ty::ty_struct(..) => { // newtype\n             Some(deref_interior(InteriorField(PositionalField(0))))\n         }\n \n@@ -346,7 +346,7 @@ impl mem_categorization_ctxt {\n                 self.cat_expr_unadjusted(expr)\n             }\n \n-            Some(&@ty::AutoAddEnv(*)) => {\n+            Some(&@ty::AutoAddEnv(..)) => {\n                 // Convert a bare fn to a closure by adding NULL env.\n                 // Result is an rvalue.\n                 let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n@@ -356,7 +356,7 @@ impl mem_categorization_ctxt {\n             Some(\n                 &@ty::AutoDerefRef(\n                     ty::AutoDerefRef {\n-                        autoref: Some(_), _})) => {\n+                        autoref: Some(_), ..})) => {\n                 // Equivalent to &*expr or something similar.\n                 // Result is an rvalue.\n                 let expr_ty = ty::expr_ty_adjusted(self.tcx, expr);\n@@ -422,21 +422,21 @@ impl mem_categorization_ctxt {\n \n           ast::ExprParen(e) => self.cat_expr_unadjusted(e),\n \n-          ast::ExprAddrOf(*) | ast::ExprCall(*) |\n-          ast::ExprAssign(*) | ast::ExprAssignOp(*) |\n-          ast::ExprFnBlock(*) | ast::ExprProc(*) | ast::ExprRet(*) |\n-          ast::ExprDoBody(*) | ast::ExprUnary(*) |\n-          ast::ExprMethodCall(*) | ast::ExprCast(*) | ast::ExprVstore(*) |\n-          ast::ExprVec(*) | ast::ExprTup(*) | ast::ExprIf(*) |\n-          ast::ExprLogLevel | ast::ExprBinary(*) | ast::ExprWhile(*) |\n-          ast::ExprBlock(*) | ast::ExprLoop(*) | ast::ExprMatch(*) |\n-          ast::ExprLit(*) | ast::ExprBreak(*) | ast::ExprMac(*) |\n-          ast::ExprAgain(*) | ast::ExprStruct(*) | ast::ExprRepeat(*) |\n-          ast::ExprInlineAsm(*) => {\n+          ast::ExprAddrOf(..) | ast::ExprCall(..) |\n+          ast::ExprAssign(..) | ast::ExprAssignOp(..) |\n+          ast::ExprFnBlock(..) | ast::ExprProc(..) | ast::ExprRet(..) |\n+          ast::ExprDoBody(..) | ast::ExprUnary(..) |\n+          ast::ExprMethodCall(..) | ast::ExprCast(..) | ast::ExprVstore(..) |\n+          ast::ExprVec(..) | ast::ExprTup(..) | ast::ExprIf(..) |\n+          ast::ExprLogLevel | ast::ExprBinary(..) | ast::ExprWhile(..) |\n+          ast::ExprBlock(..) | ast::ExprLoop(..) | ast::ExprMatch(..) |\n+          ast::ExprLit(..) | ast::ExprBreak(..) | ast::ExprMac(..) |\n+          ast::ExprAgain(..) | ast::ExprStruct(..) | ast::ExprRepeat(..) |\n+          ast::ExprInlineAsm(..) => {\n             return self.cat_rvalue_node(expr, expr_ty);\n           }\n \n-          ast::ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\")\n+          ast::ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\")\n         }\n     }\n \n@@ -447,13 +447,13 @@ impl mem_categorization_ctxt {\n                    def: ast::Def)\n                    -> cmt {\n         match def {\n-          ast::DefFn(*) | ast::DefStaticMethod(*) | ast::DefMod(_) |\n+          ast::DefFn(..) | ast::DefStaticMethod(..) | ast::DefMod(_) |\n           ast::DefForeignMod(_) | ast::DefStatic(_, false) |\n-          ast::DefUse(_) | ast::DefVariant(*) |\n+          ast::DefUse(_) | ast::DefVariant(..) |\n           ast::DefTrait(_) | ast::DefTy(_) | ast::DefPrimTy(_) |\n-          ast::DefTyParam(*) | ast::DefStruct(*) |\n-          ast::DefTyParamBinder(*) | ast::DefRegion(_) |\n-          ast::DefLabel(_) | ast::DefSelfTy(*) | ast::DefMethod(*) => {\n+          ast::DefTyParam(..) | ast::DefStruct(..) |\n+          ast::DefTyParamBinder(..) | ast::DefRegion(_) |\n+          ast::DefLabel(_) | ast::DefSelfTy(..) | ast::DefMethod(..) => {\n               @cmt_ {\n                   id:id,\n                   span:span,\n@@ -835,7 +835,7 @@ impl mem_categorization_ctxt {\n         // we can be sure that the binding will remain valid for the\n         // duration of the arm.\n         //\n-        // (*) There is subtlety concerning the correspondence between\n+        // (..) There is subtlety concerning the correspondence between\n         // pattern ids and types as compared to *expression* ids and\n         // types. This is explained briefly. on the definition of the\n         // type `cmt`, so go off and read what it says there, then\n@@ -881,7 +881,7 @@ impl mem_categorization_ctxt {\n           }\n \n           ast::PatEnum(_, None) => {\n-            // variant(*)\n+            // variant(..)\n           }\n           ast::PatEnum(_, Some(ref subpats)) => {\n             match self.tcx.def_map.find(&pat.id) {\n@@ -897,7 +897,7 @@ impl mem_categorization_ctxt {\n                     };\n \n                     for (i, &subpat) in subpats.iter().enumerate() {\n-                        let subpat_ty = self.pat_ty(subpat); // see (*)\n+                        let subpat_ty = self.pat_ty(subpat); // see (..)\n \n                         let subcmt =\n                             self.cat_imm_interior(\n@@ -907,18 +907,18 @@ impl mem_categorization_ctxt {\n                         self.cat_pattern(subcmt, subpat, |x,y| op(x,y));\n                     }\n                 }\n-                Some(&ast::DefFn(*)) |\n-                Some(&ast::DefStruct(*)) => {\n+                Some(&ast::DefFn(..)) |\n+                Some(&ast::DefStruct(..)) => {\n                     for (i, &subpat) in subpats.iter().enumerate() {\n-                        let subpat_ty = self.pat_ty(subpat); // see (*)\n+                        let subpat_ty = self.pat_ty(subpat); // see (..)\n                         let cmt_field =\n                             self.cat_imm_interior(\n                                 pat, cmt, subpat_ty,\n                                 InteriorField(PositionalField(i)));\n                         self.cat_pattern(cmt_field, subpat, |x,y| op(x,y));\n                     }\n                 }\n-                Some(&ast::DefStatic(*)) => {\n+                Some(&ast::DefStatic(..)) => {\n                     for &subpat in subpats.iter() {\n                         self.cat_pattern(cmt, subpat, |x,y| op(x,y));\n                     }\n@@ -942,7 +942,7 @@ impl mem_categorization_ctxt {\n           ast::PatStruct(_, ref field_pats, _) => {\n             // {f1: p1, ..., fN: pN}\n             for fp in field_pats.iter() {\n-                let field_ty = self.pat_ty(fp.pat); // see (*)\n+                let field_ty = self.pat_ty(fp.pat); // see (..)\n                 let cmt_field = self.cat_field(pat, cmt, fp.ident, field_ty);\n                 self.cat_pattern(cmt_field, fp.pat, |x,y| op(x,y));\n             }\n@@ -951,7 +951,7 @@ impl mem_categorization_ctxt {\n           ast::PatTup(ref subpats) => {\n             // (p1, ..., pN)\n             for (i, &subpat) in subpats.iter().enumerate() {\n-                let subpat_ty = self.pat_ty(subpat); // see (*)\n+                let subpat_ty = self.pat_ty(subpat); // see (..)\n                 let subcmt =\n                     self.cat_imm_interior(\n                         pat, cmt, subpat_ty,\n@@ -1003,7 +1003,7 @@ impl mem_categorization_ctxt {\n           cat_copied_upvar(_) => {\n               ~\"captured outer variable in a heap closure\"\n           }\n-          cat_rvalue(*) => {\n+          cat_rvalue(..) => {\n               ~\"non-lvalue\"\n           }\n           cat_local(_) => {\n@@ -1012,7 +1012,7 @@ impl mem_categorization_ctxt {\n           cat_self(_) => {\n               ~\"self value\"\n           }\n-          cat_arg(*) => {\n+          cat_arg(..) => {\n               ~\"argument\"\n           }\n           cat_deref(_, _, pk) => {\n@@ -1069,7 +1069,7 @@ pub fn field_mutbl(tcx: ty::ctxt,\n             }\n         }\n       }\n-      ty::ty_enum(*) => {\n+      ty::ty_enum(..) => {\n         match tcx.def_map.get_copy(&node_id) {\n           ast::DefVariant(_, variant_id, _) => {\n             let r = ty::lookup_struct_fields(tcx, variant_id);\n@@ -1101,15 +1101,15 @@ impl cmt_ {\n         //! determines how long the value in `self` remains live.\n \n         match self.cat {\n-            cat_rvalue(*) |\n+            cat_rvalue(..) |\n             cat_static_item |\n-            cat_copied_upvar(*) |\n-            cat_local(*) |\n-            cat_self(*) |\n-            cat_arg(*) |\n-            cat_deref(_, _, unsafe_ptr(*)) |\n-            cat_deref(_, _, gc_ptr(*)) |\n-            cat_deref(_, _, region_ptr(*)) => {\n+            cat_copied_upvar(..) |\n+            cat_local(..) |\n+            cat_self(..) |\n+            cat_arg(..) |\n+            cat_deref(_, _, unsafe_ptr(..)) |\n+            cat_deref(_, _, gc_ptr(..)) |\n+            cat_deref(_, _, region_ptr(..)) => {\n                 self\n             }\n             cat_downcast(b) |\n@@ -1137,18 +1137,18 @@ impl cmt_ {\n         // aliased and eventually recused.\n \n         match self.cat {\n-            cat_copied_upvar(CopiedUpvar {onceness: ast::Once, _}) |\n-            cat_rvalue(*) |\n-            cat_local(*) |\n+            cat_copied_upvar(CopiedUpvar {onceness: ast::Once, ..}) |\n+            cat_rvalue(..) |\n+            cat_local(..) |\n             cat_arg(_) |\n-            cat_self(*) |\n-            cat_deref(_, _, unsafe_ptr(*)) | // of course it is aliasable, but...\n+            cat_self(..) |\n+            cat_deref(_, _, unsafe_ptr(..)) | // of course it is aliasable, but...\n             cat_deref(_, _, region_ptr(MutMutable, _)) => {\n                 None\n             }\n \n-            cat_copied_upvar(CopiedUpvar {onceness: ast::Many, _}) |\n-            cat_static_item(*) => {\n+            cat_copied_upvar(CopiedUpvar {onceness: ast::Many, ..}) |\n+            cat_static_item(..) => {\n                 Some(AliasableOther)\n             }\n \n@@ -1160,11 +1160,11 @@ impl cmt_ {\n                 Some(AliasableBorrowed(m))\n             }\n \n-            cat_downcast(*) |\n-            cat_stack_upvar(*) |\n+            cat_downcast(..) |\n+            cat_stack_upvar(..) |\n             cat_deref(_, _, uniq_ptr) |\n-            cat_interior(*) |\n-            cat_discr(*) => {\n+            cat_interior(..) |\n+            cat_discr(..) => {\n                 None\n             }\n         }\n@@ -1185,11 +1185,11 @@ impl Repr for categorization {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n         match *self {\n             cat_static_item |\n-            cat_rvalue(*) |\n-            cat_copied_upvar(*) |\n-            cat_local(*) |\n-            cat_self(*) |\n-            cat_arg(*) => {\n+            cat_rvalue(..) |\n+            cat_copied_upvar(..) |\n+            cat_local(..) |\n+            cat_self(..) |\n+            cat_arg(..) => {\n                 format!(\"{:?}\", *self)\n             }\n             cat_deref(cmt, derefs, ptr) => {\n@@ -1233,8 +1233,8 @@ impl Repr for InteriorKind {\n \n fn element_kind(t: ty::t) -> ElementKind {\n     match ty::get(t).sty {\n-        ty::ty_evec(*) => VecElement,\n-        ty::ty_estr(*) => StrElement,\n+        ty::ty_evec(..) => VecElement,\n+        ty::ty_estr(..) => StrElement,\n         _ => OtherElement\n     }\n }"}, {"sha": "f23ebac5e9636a774dc7d5290204dba1c88b1057", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -322,14 +322,14 @@ impl VisitContext {\n         let comp_mode = match self.tcx.adjustments.find(&expr.id) {\n             Some(&@ty::AutoDerefRef(\n                 ty::AutoDerefRef {\n-                    autoref: Some(_), _})) => Read,\n+                    autoref: Some(_), ..})) => Read,\n             _ => expr_mode\n         };\n \n         debug!(\"comp_mode = {:?}\", comp_mode);\n \n         match expr.node {\n-            ExprPath(*) | ExprSelf => {\n+            ExprPath(..) | ExprSelf => {\n                 match comp_mode {\n                     Move => {\n                         let def = self.tcx.def_map.get_copy(&expr.id);\n@@ -372,7 +372,7 @@ impl VisitContext {\n                         Many => Read,\n                         }\n                     },\n-                    ty::ty_bare_fn(*) => Read,\n+                    ty::ty_bare_fn(..) => Read,\n                     ref x =>\n                         self.tcx.sess.span_bug(callee.span,\n                             format!(\"non-function type in moves for expr_call: {:?}\", x)),\n@@ -484,10 +484,10 @@ impl VisitContext {\n             }\n \n             ExprLogLevel |\n-            ExprInlineAsm(*) |\n-            ExprBreak(*) |\n-            ExprAgain(*) |\n-            ExprLit(*) => {}\n+            ExprInlineAsm(..) |\n+            ExprBreak(..) |\n+            ExprAgain(..) |\n+            ExprLit(..) => {}\n \n             ExprLoop(ref blk, _) => {\n                 self.consume_block(blk);\n@@ -498,7 +498,7 @@ impl VisitContext {\n                 self.consume_block(blk);\n             }\n \n-            ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n+            ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n \n             ExprUnary(_, _, lhs) => {\n                 if !self.use_overloaded_operator(expr, lhs, [])\n@@ -567,7 +567,7 @@ impl VisitContext {\n                 self.use_expr(base, comp_mode);\n             }\n \n-            ExprMac(*) => {\n+            ExprMac(..) => {\n                 self.tcx.sess.span_bug(\n                     expr.span,\n                     \"macro expression remains after expansion\");"}, {"sha": "9ef7a5f147db5a40535ee7ab4bd11c8700391bc8", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -30,9 +30,9 @@ pub fn pat_id_map(dm: resolve::DefMap, pat: &Pat) -> PatIdMap {\n \n pub fn pat_is_variant_or_struct(dm: resolve::DefMap, pat: &Pat) -> bool {\n     match pat.node {\n-        PatEnum(_, _) | PatIdent(_, _, None) | PatStruct(*) => {\n+        PatEnum(_, _) | PatIdent(_, _, None) | PatStruct(..) => {\n             match dm.find(&pat.id) {\n-                Some(&DefVariant(*)) | Some(&DefStruct(*)) => true,\n+                Some(&DefVariant(..)) | Some(&DefStruct(..)) => true,\n                 _ => false\n             }\n         }\n@@ -42,7 +42,7 @@ pub fn pat_is_variant_or_struct(dm: resolve::DefMap, pat: &Pat) -> bool {\n \n pub fn pat_is_const(dm: resolve::DefMap, pat: &Pat) -> bool {\n     match pat.node {\n-        PatIdent(_, _, None) | PatEnum(*) => {\n+        PatIdent(_, _, None) | PatEnum(..) => {\n             match dm.find(&pat.id) {\n                 Some(&DefStatic(_, false)) => true,\n                 _ => false\n@@ -54,7 +54,7 @@ pub fn pat_is_const(dm: resolve::DefMap, pat: &Pat) -> bool {\n \n pub fn pat_is_binding(dm: resolve::DefMap, pat: &Pat) -> bool {\n     match pat.node {\n-        PatIdent(*) => {\n+        PatIdent(..) => {\n             !pat_is_variant_or_struct(dm, pat) &&\n             !pat_is_const(dm, pat)\n         }\n@@ -64,7 +64,7 @@ pub fn pat_is_binding(dm: resolve::DefMap, pat: &Pat) -> bool {\n \n pub fn pat_is_binding_or_wild(dm: resolve::DefMap, pat: &Pat) -> bool {\n     match pat.node {\n-        PatIdent(*) => pat_is_binding(dm, pat),\n+        PatIdent(..) => pat_is_binding(dm, pat),\n         PatWild | PatWildMulti => true,\n         _ => false\n     }\n@@ -93,7 +93,7 @@ pub fn pat_binding_ids(dm: resolve::DefMap, pat: &Pat) -> ~[NodeId] {\n }\n \n /// Checks if the pattern contains any patterns that bind something to\n-/// an ident, e.g. `foo`, or `Foo(foo)` or `foo @ Bar(*)`.\n+/// an ident, e.g. `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n pub fn pat_contains_bindings(dm: resolve::DefMap, pat: &Pat) -> bool {\n     let mut contains_bindings = false;\n     walk_pat(pat, |p| {"}, {"sha": "100d9329f186b831323c97cf57170de0e7ff08c5", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -50,7 +50,7 @@ impl Visitor<()> for ParentVisitor {\n \n         let prev = self.curparent;\n         match item.node {\n-            ast::item_mod(*) => { self.curparent = item.id; }\n+            ast::item_mod(..) => { self.curparent = item.id; }\n             // Enum variants are parented to the enum definition itself beacuse\n             // they inherit privacy\n             ast::item_enum(ref def, _) => {\n@@ -173,7 +173,7 @@ impl<'self> Visitor<()> for EmbargoVisitor<'self> {\n         match item.node {\n             // impls/extern blocks do not break the \"public chain\" because they\n             // cannot have visibility qualifiers on them anyway\n-            ast::item_impl(*) | ast::item_foreign_mod(*) => {}\n+            ast::item_impl(..) | ast::item_foreign_mod(..) => {}\n \n             // Private by default, hence we only retain the \"public chain\" if\n             // `pub` is explicitly listed.\n@@ -221,7 +221,7 @@ impl<'self> Visitor<()> for EmbargoVisitor<'self> {\n                 let public_ty = match ty.node {\n                     ast::ty_path(_, _, id) => {\n                         match self.tcx.def_map.get_copy(&id) {\n-                            ast::DefPrimTy(*) => true,\n+                            ast::DefPrimTy(..) => true,\n                             def => {\n                                 let did = def_id_of_def(def);\n                                 !is_local(did) ||\n@@ -404,12 +404,12 @@ impl<'self> PrivacyVisitor<'self> {\n                 //               where the method was defined?\n                 Some(&ast_map::node_method(ref m, imp, _)) => {\n                     match ty::impl_trait_ref(self.tcx, imp) {\n-                        Some(*) => return Allowable,\n+                        Some(..) => return Allowable,\n                         _ if m.vis == ast::public => return Allowable,\n                         _ => m.vis\n                     }\n                 }\n-                Some(&ast_map::node_trait_method(*)) => {\n+                Some(&ast_map::node_trait_method(..)) => {\n                     return Allowable;\n                 }\n \n@@ -494,15 +494,15 @@ impl<'self> PrivacyVisitor<'self> {\n                 match self.tcx.items.find(&id) {\n                     Some(&ast_map::node_item(item, _)) => {\n                         let desc = match item.node {\n-                            ast::item_mod(*) => \"module\",\n-                            ast::item_trait(*) => \"trait\",\n+                            ast::item_mod(..) => \"module\",\n+                            ast::item_trait(..) => \"trait\",\n                             _ => return false,\n                         };\n                         let msg = format!(\"{} `{}` is private\", desc,\n                                           token::ident_to_str(&item.ident));\n                         self.tcx.sess.span_note(span, msg);\n                     }\n-                    Some(*) | None => {}\n+                    Some(..) | None => {}\n                 }\n             }\n             Allowable => return true\n@@ -516,7 +516,7 @@ impl<'self> PrivacyVisitor<'self> {\n \n         match self.def_privacy(variant_info.id) {\n             Allowable => {}\n-            ExternallyDenied | DisallowedBy(*) => {\n+            ExternallyDenied | DisallowedBy(..) => {\n                 self.tcx.sess.span_err(span, \"can only dereference enums \\\n                                               with a single, public variant\");\n             }\n@@ -569,16 +569,16 @@ impl<'self> PrivacyVisitor<'self> {\n             }\n         };\n         match self.tcx.def_map.get_copy(&path_id) {\n-            ast::DefStaticMethod(*) => ck(\"static method\"),\n-            ast::DefFn(*) => ck(\"function\"),\n-            ast::DefStatic(*) => ck(\"static\"),\n-            ast::DefVariant(*) => ck(\"variant\"),\n-            ast::DefTy(*) => ck(\"type\"),\n-            ast::DefTrait(*) => ck(\"trait\"),\n-            ast::DefStruct(*) => ck(\"struct\"),\n-            ast::DefMethod(_, Some(*)) => ck(\"trait method\"),\n-            ast::DefMethod(*) => ck(\"method\"),\n-            ast::DefMod(*) => ck(\"module\"),\n+            ast::DefStaticMethod(..) => ck(\"static method\"),\n+            ast::DefFn(..) => ck(\"function\"),\n+            ast::DefStatic(..) => ck(\"static\"),\n+            ast::DefVariant(..) => ck(\"variant\"),\n+            ast::DefTy(..) => ck(\"type\"),\n+            ast::DefTrait(..) => ck(\"trait\"),\n+            ast::DefStruct(..) => ck(\"struct\"),\n+            ast::DefMethod(_, Some(..)) => ck(\"trait method\"),\n+            ast::DefMethod(..) => ck(\"method\"),\n+            ast::DefMod(..) => ck(\"module\"),\n             _ => {}\n         }\n     }\n@@ -592,8 +592,8 @@ impl<'self> PrivacyVisitor<'self> {\n             }\n             // Trait methods are always all public. The only controlling factor\n             // is whether the trait itself is accessible or not.\n-            method_param(method_param { trait_id: trait_id, _ }) |\n-            method_object(method_object { trait_id: trait_id, _ }) => {\n+            method_param(method_param { trait_id: trait_id, .. }) |\n+            method_object(method_object { trait_id: trait_id, .. }) => {\n                 self.ensure_public(span, trait_id, None, \"source trait\");\n             }\n         }\n@@ -707,7 +707,7 @@ impl<'self> Visitor<()> for PrivacyVisitor<'self> {\n \n     fn visit_view_item(&mut self, a: &ast::view_item, _: ()) {\n         match a.node {\n-            ast::view_item_extern_mod(*) => {}\n+            ast::view_item_extern_mod(..) => {}\n             ast::view_item_use(ref uses) => {\n                 for vpath in uses.iter() {\n                     match vpath.node {\n@@ -793,7 +793,7 @@ impl Visitor<()> for SanePrivacyVisitor {\n         }\n \n         let orig_in_fn = util::replace(&mut self.in_fn, match item.node {\n-            ast::item_mod(*) => false, // modules turn privacy back on\n+            ast::item_mod(..) => false, // modules turn privacy back on\n             _ => self.in_fn,           // otherwise we inherit\n         });\n         visit::walk_item(self, item, ());\n@@ -842,14 +842,14 @@ impl SanePrivacyVisitor {\n                     ast::named_field(_, ast::private) => {\n                         // Fields should really be private by default...\n                     }\n-                    ast::named_field(*) | ast::unnamed_field => {}\n+                    ast::named_field(..) | ast::unnamed_field => {}\n                 }\n             }\n         };\n         match item.node {\n             // implementations of traits don't need visibility qualifiers because\n             // that's controlled by having the trait in scope.\n-            ast::item_impl(_, Some(*), _, ref methods) => {\n+            ast::item_impl(_, Some(..), _, ref methods) => {\n                 check_inherited(item.span, item.vis,\n                                 \"visibility qualifiers have no effect on trait \\\n                                  impls\");\n@@ -896,7 +896,7 @@ impl SanePrivacyVisitor {\n \n                     match v.node.kind {\n                         ast::struct_variant_kind(ref s) => check_struct(s),\n-                        ast::tuple_variant_kind(*) => {}\n+                        ast::tuple_variant_kind(..) => {}\n                     }\n                 }\n             }\n@@ -910,14 +910,14 @@ impl SanePrivacyVisitor {\n                             check_inherited(m.span, m.vis,\n                                             \"unnecessary visibility\");\n                         }\n-                        ast::required(*) => {}\n+                        ast::required(..) => {}\n                     }\n                 }\n             }\n \n-            ast::item_static(*) |\n-            ast::item_fn(*) | ast::item_mod(*) | ast::item_ty(*) |\n-            ast::item_mac(*) => {\n+            ast::item_static(..) |\n+            ast::item_fn(..) | ast::item_mod(..) | ast::item_ty(..) |\n+            ast::item_mac(..) => {\n                 check_not_priv(item.span, item.vis, \"items are private by \\\n                                                      default\");\n             }\n@@ -959,7 +959,7 @@ impl SanePrivacyVisitor {\n \n                     match v.node.kind {\n                         ast::struct_variant_kind(ref s) => check_struct(s),\n-                        ast::tuple_variant_kind(*) => {}\n+                        ast::tuple_variant_kind(..) => {}\n                     }\n                 }\n             }\n@@ -969,15 +969,15 @@ impl SanePrivacyVisitor {\n             ast::item_trait(_, _, ref methods) => {\n                 for m in methods.iter() {\n                     match *m {\n-                        ast::required(*) => {}\n+                        ast::required(..) => {}\n                         ast::provided(ref m) => check_inherited(m.span, m.vis),\n                     }\n                 }\n             }\n \n-            ast::item_static(*) |\n-            ast::item_fn(*) | ast::item_mod(*) | ast::item_ty(*) |\n-            ast::item_mac(*) => {}\n+            ast::item_static(..) |\n+            ast::item_fn(..) | ast::item_mod(..) | ast::item_ty(..) |\n+            ast::item_mac(..) => {}\n         }\n     }\n }"}, {"sha": "bc62e6afeee72b2a85cfb5fa5484abd9bb83b43c", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -73,7 +73,7 @@ fn method_might_be_inlined(tcx: ty::ctxt, method: &ast::method,\n     if is_local(impl_src) {\n         match tcx.items.find(&impl_src.node) {\n             Some(&ast_map::node_item(item, _)) => item_might_be_inlined(item),\n-            Some(*) | None => {\n+            Some(..) | None => {\n                 tcx.sess.span_bug(method.span, \"impl did is not an item\")\n             }\n         }\n@@ -134,11 +134,11 @@ impl Visitor<()> for MarkSymbolVisitor {\n                     }\n                 self.reachable_symbols.insert(def_id.node);\n             }\n-            ast::ExprMethodCall(*) => {\n+            ast::ExprMethodCall(..) => {\n                 match self.method_map.find(&expr.id) {\n                     Some(&typeck::method_map_entry {\n                         origin: typeck::method_static(def_id),\n-                        _\n+                        ..\n                     }) => {\n                         if ReachableContext::\n                             def_id_represents_local_inlined_item(\n@@ -191,7 +191,7 @@ impl ReachableContext {\n         match tcx.items.find(&node_id) {\n             Some(&ast_map::node_item(item, _)) => {\n                 match item.node {\n-                    ast::item_fn(*) => item_might_be_inlined(item),\n+                    ast::item_fn(..) => item_might_be_inlined(item),\n                     _ => false,\n                 }\n             }\n@@ -313,10 +313,10 @@ impl ReachableContext {\n                     // These are normal, nothing reachable about these\n                     // inherently and their children are already in the\n                     // worklist, as determined by the privacy pass\n-                    ast::item_static(*) | ast::item_ty(*) |\n-                    ast::item_mod(*) | ast::item_foreign_mod(*) |\n-                    ast::item_impl(*) | ast::item_trait(*) |\n-                    ast::item_struct(*) | ast::item_enum(*) => {}\n+                    ast::item_static(..) | ast::item_ty(..) |\n+                    ast::item_mod(..) | ast::item_foreign_mod(..) |\n+                    ast::item_impl(..) | ast::item_trait(..) |\n+                    ast::item_struct(..) | ast::item_enum(..) => {}\n \n                     _ => {\n                         self.tcx.sess.span_bug(item.span,\n@@ -327,7 +327,7 @@ impl ReachableContext {\n             }\n             ast_map::node_trait_method(trait_method, _, _) => {\n                 match *trait_method {\n-                    ast::required(*) => {\n+                    ast::required(..) => {\n                         // Keep going, nothing to get exported\n                     }\n                     ast::provided(ref method) => {\n@@ -341,9 +341,9 @@ impl ReachableContext {\n                 }\n             }\n             // Nothing to recurse on for these\n-            ast_map::node_foreign_item(*) |\n-            ast_map::node_variant(*) |\n-            ast_map::node_struct_ctor(*) => {}\n+            ast_map::node_foreign_item(..) |\n+            ast_map::node_variant(..) |\n+            ast_map::node_struct_ctor(..) => {}\n             _ => {\n                 let ident_interner = token::get_ident_interner();\n                 let desc = ast_map::node_id_to_str(self.tcx.items,"}, {"sha": "fc7dfdf5624207cf78340f61bbf32dbe52ebc675", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -351,7 +351,7 @@ fn resolve_stmt(visitor: &mut RegionResolutionVisitor,\n                 stmt: @ast::Stmt,\n                 cx: Context) {\n     match stmt.node {\n-        ast::StmtDecl(*) => {\n+        ast::StmtDecl(..) => {\n             visit::walk_stmt(visitor, stmt, cx);\n         }\n         ast::StmtExpr(_, stmt_id) |\n@@ -360,7 +360,7 @@ fn resolve_stmt(visitor: &mut RegionResolutionVisitor,\n             let expr_cx = Context {parent: Some(stmt_id), ..cx};\n             visit::walk_stmt(visitor, stmt, expr_cx);\n         }\n-        ast::StmtMac(*) => visitor.sess.bug(\"unexpanded macro\")\n+        ast::StmtMac(..) => visitor.sess.bug(\"unexpanded macro\")\n     }\n }\n \n@@ -372,8 +372,8 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor,\n     let mut new_cx = cx;\n     new_cx.parent = Some(expr.id);\n     match expr.node {\n-        ast::ExprAssignOp(*) | ast::ExprIndex(*) | ast::ExprBinary(*) |\n-        ast::ExprUnary(*) | ast::ExprCall(*) | ast::ExprMethodCall(*) => {\n+        ast::ExprAssignOp(..) | ast::ExprIndex(..) | ast::ExprBinary(..) |\n+        ast::ExprUnary(..) | ast::ExprCall(..) | ast::ExprMethodCall(..) => {\n             // FIXME(#6268) Nested method calls\n             //\n             // The lifetimes for a call or method call look as follows:\n@@ -394,7 +394,7 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor,\n             // parent_to_expr(new_cx, expr.callee_id);\n         }\n \n-        ast::ExprMatch(*) => {\n+        ast::ExprMatch(..) => {\n             new_cx.var_parent = Some(expr.id);\n         }\n \n@@ -452,12 +452,12 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n     // The body of the fn itself is either a root scope (top-level fn)\n     // or it continues with the inherited scope (closures).\n     let body_cx = match *fk {\n-        visit::fk_item_fn(*) |\n-        visit::fk_method(*) => {\n+        visit::fk_item_fn(..) |\n+        visit::fk_method(..) => {\n             Context {parent: None, var_parent: None, ..cx}\n         }\n-        visit::fk_anon(*) |\n-        visit::fk_fn_block(*) => {\n+        visit::fk_anon(..) |\n+        visit::fk_fn_block(..) => {\n             cx\n         }\n     };"}, {"sha": "0d4c23d3dfb0d667ba15f0249876f406c5f23046", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -1149,7 +1149,7 @@ impl Resolver {\n         let is_public = item.vis == ast::public;\n \n         match item.node {\n-            item_mod(*) => {\n+            item_mod(..) => {\n                 let (name_bindings, new_parent) =\n                     self.add_child(ident, parent, ForbidDuplicateModules, sp);\n \n@@ -1165,7 +1165,7 @@ impl Resolver {\n                 ModuleReducedGraphParent(name_bindings.get_module())\n             }\n \n-            item_foreign_mod(*) => parent,\n+            item_foreign_mod(..) => parent,\n \n             // These items live in the value namespace.\n             item_static(_, m, _) => {\n@@ -1187,7 +1187,7 @@ impl Resolver {\n             }\n \n             // These items live in the type namespace.\n-            item_ty(*) => {\n+            item_ty(..) => {\n                 let (name_bindings, _) =\n                     self.add_child(ident, parent, ForbidDuplicateTypes, sp);\n \n@@ -1253,7 +1253,7 @@ impl Resolver {\n                 match ty {\n                     &Ty {\n                         node: ty_path(ref path, _, _),\n-                        _\n+                        ..\n                     } if path.segments.len() == 1 => {\n                         let name = path_to_ident(path);\n \n@@ -1395,7 +1395,7 @@ impl Resolver {\n                 new_parent\n             }\n \n-            item_mac(*) => {\n+            item_mac(..) => {\n                 fail!(\"item macros unimplemented\")\n             }\n         }\n@@ -1622,7 +1622,7 @@ impl Resolver {\n           DefMod(def_id) | DefForeignMod(def_id) | DefStruct(def_id) |\n           DefTy(def_id) => {\n             match child_name_bindings.type_def {\n-              Some(TypeNsDef { module_def: Some(module_def), _ }) => {\n+              Some(TypeNsDef { module_def: Some(module_def), .. }) => {\n                 debug!(\"(building reduced graph for external crate) \\\n                         already created module\");\n                 module_def.def_id = Some(def_id);\n@@ -1662,7 +1662,7 @@ impl Resolver {\n                 child_name_bindings.define_value(def, dummy_sp(), is_public);\n             }\n           }\n-          DefFn(*) | DefStaticMethod(*) | DefStatic(*) => {\n+          DefFn(..) | DefStaticMethod(..) | DefStatic(..) => {\n             debug!(\"(building reduced graph for external \\\n                     crate) building value (fn/static) {}\", final_ident);\n             child_name_bindings.define_value(def, dummy_sp(), is_public);\n@@ -1732,15 +1732,15 @@ impl Resolver {\n             }\n             self.structs.insert(def_id);\n           }\n-          DefMethod(*) => {\n+          DefMethod(..) => {\n               debug!(\"(building reduced graph for external crate) \\\n                       ignoring {:?}\", def);\n               // Ignored; handled elsewhere.\n           }\n-          DefSelf(*) | DefArg(*) | DefLocal(*) |\n-          DefPrimTy(*) | DefTyParam(*) | DefBinding(*) |\n-          DefUse(*) | DefUpvar(*) | DefRegion(*) |\n-          DefTyParamBinder(*) | DefLabel(*) | DefSelfTy(*) => {\n+          DefSelf(..) | DefArg(..) | DefLocal(..) |\n+          DefPrimTy(..) | DefTyParam(..) | DefBinding(..) |\n+          DefUse(..) | DefUpvar(..) | DefRegion(..) |\n+          DefTyParamBinder(..) | DefLabel(..) | DefSelfTy(..) => {\n             fail!(\"didn't expect `{:?}`\", def);\n           }\n         }\n@@ -1817,7 +1817,7 @@ impl Resolver {\n                                 match child_name_bindings.type_def {\n                                     Some(TypeNsDef {\n                                         module_def: Some(module_def),\n-                                        _\n+                                        ..\n                                     }) => {\n                                         // We already have a module. This\n                                         // is OK.\n@@ -2211,7 +2211,7 @@ impl Resolver {\n                     assert!(module_.glob_count >= 1);\n                     module_.glob_count -= 1;\n                 }\n-                SingleImport(*) => {\n+                SingleImport(..) => {\n                     // Ignore.\n                 }\n             }\n@@ -2278,7 +2278,7 @@ impl Resolver {\n         // search imports as well.\n         let mut used_reexport = false;\n         match (value_result, type_result) {\n-            (BoundResult(*), BoundResult(*)) => {} // Continue.\n+            (BoundResult(..), BoundResult(..)) => {} // Continue.\n             _ => {\n                 // If there is an unresolved glob at this point in the\n                 // containing module, bail out. We don't know enough to be\n@@ -2365,7 +2365,7 @@ impl Resolver {\n         // external modules.\n         let mut used_public = false;\n         match type_result {\n-            BoundResult(*) => {}\n+            BoundResult(..) => {}\n             _ => {\n                 match containing_module.external_module_children\n                                        .find(&source.name) {\n@@ -3386,16 +3386,16 @@ impl Resolver {\n         let is_ty_param;\n \n         match def_like {\n-            DlDef(d @ DefLocal(*)) | DlDef(d @ DefUpvar(*)) |\n-            DlDef(d @ DefArg(*)) | DlDef(d @ DefBinding(*)) => {\n+            DlDef(d @ DefLocal(..)) | DlDef(d @ DefUpvar(..)) |\n+            DlDef(d @ DefArg(..)) | DlDef(d @ DefBinding(..)) => {\n                 def = d;\n                 is_ty_param = false;\n             }\n-            DlDef(d @ DefTyParam(*)) => {\n+            DlDef(d @ DefTyParam(..)) => {\n                 def = d;\n                 is_ty_param = true;\n             }\n-            DlDef(d @ DefSelf(*))\n+            DlDef(d @ DefSelf(..))\n                     if allow_capturing_self == DontAllowCapturingSelf => {\n                 def = d;\n                 is_ty_param = false;\n@@ -3666,7 +3666,7 @@ impl Resolver {\n                                                                 *foreign_item,\n                                                                 ()));\n                             }\n-                            foreign_item_static(*) => {\n+                            foreign_item_static(..) => {\n                                 visit::walk_foreign_item(this,\n                                                          *foreign_item,\n                                                          ());\n@@ -3688,13 +3688,13 @@ impl Resolver {\n                                       NoSelfBinding);\n             }\n \n-            item_static(*) => {\n+            item_static(..) => {\n                 self.with_constant_rib(|this| {\n                     visit::walk_item(this, item, ());\n                 });\n             }\n \n-          item_mac(*) => {\n+          item_mac(..) => {\n             fail!(\"item macros unimplemented\")\n           }\n         }\n@@ -3734,7 +3734,7 @@ impl Resolver {\n         f(self);\n \n         match type_parameters {\n-            HasTypeParameters(*) => {\n+            HasTypeParameters(..) => {\n                 self.type_ribs.pop();\n             }\n \n@@ -4282,7 +4282,7 @@ impl Resolver {\n                                 \"an enum variant\");\n                             self.record_def(pattern.id, (def, lp));\n                         }\n-                        FoundStructOrEnumVariant(*) => {\n+                        FoundStructOrEnumVariant(..) => {\n                             self.resolve_error(pattern.span,\n                                                   format!(\"declaration of `{}` \\\n                                                         shadows an enum \\\n@@ -4301,7 +4301,7 @@ impl Resolver {\n                                 \"a constant\");\n                             self.record_def(pattern.id, (def, lp));\n                         }\n-                        FoundConst(*) => {\n+                        FoundConst(..) => {\n                             self.resolve_error(pattern.span,\n                                                   \"only irrefutable patterns \\\n                                                    allowed here\");\n@@ -4384,11 +4384,11 @@ impl Resolver {\n                 PatIdent(binding_mode, ref path, _) => {\n                     // This must be an enum variant, struct, or constant.\n                     match self.resolve_path(pat_id, path, ValueNS, false) {\n-                        Some(def @ (DefVariant(*), _)) |\n-                        Some(def @ (DefStruct(*), _)) => {\n+                        Some(def @ (DefVariant(..), _)) |\n+                        Some(def @ (DefStruct(..), _)) => {\n                             self.record_def(pattern.id, def);\n                         }\n-                        Some(def @ (DefStatic(*), _)) => {\n+                        Some(def @ (DefStatic(..), _)) => {\n                             self.enforce_default_binding_mode(\n                                 pattern,\n                                 binding_mode,\n@@ -4419,10 +4419,10 @@ impl Resolver {\n                 PatEnum(ref path, _) => {\n                     // This must be an enum variant, struct or const.\n                     match self.resolve_path(pat_id, path, ValueNS, false) {\n-                        Some(def @ (DefFn(*), _))      |\n-                        Some(def @ (DefVariant(*), _)) |\n-                        Some(def @ (DefStruct(*), _))  |\n-                        Some(def @ (DefStatic(*), _)) => {\n+                        Some(def @ (DefFn(..), _))      |\n+                        Some(def @ (DefVariant(..), _)) |\n+                        Some(def @ (DefStruct(..), _))  |\n+                        Some(def @ (DefStatic(..), _)) => {\n                             self.record_def(pattern.id, def);\n                         }\n                         Some(_) => {\n@@ -4516,7 +4516,7 @@ impl Resolver {\n                         // considered as not having a private component because\n                         // the lookup happened only within the current module.\n                         match def.def {\n-                            def @ DefVariant(*) | def @ DefStruct(*) => {\n+                            def @ DefVariant(..) | def @ DefStruct(..) => {\n                                 return FoundStructOrEnumVariant(def, AllPublic);\n                             }\n                             def @ DefStatic(_, false) => {\n@@ -4655,7 +4655,7 @@ impl Resolver {\n                     None => {}\n                 }\n             }\n-            Some(*) | None => {} // Continue.\n+            Some(..) | None => {} // Continue.\n         }\n \n         // Finally, search through external children.\n@@ -4975,7 +4975,7 @@ impl Resolver {\n                         // First-class methods are not supported yet; error\n                         // out here.\n                         match def {\n-                            (DefMethod(*), _) => {\n+                            (DefMethod(..), _) => {\n                                 self.resolve_error(expr.span,\n                                                       \"first-class methods \\\n                                                        are not supported\");\n@@ -5078,7 +5078,7 @@ impl Resolver {\n                 })\n             }\n \n-            ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n+            ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n \n             ExprBreak(Some(label)) | ExprAgain(Some(label)) => {\n                 match self.search_ribs(self.label_ribs, label, expr.span,\n@@ -5192,7 +5192,7 @@ impl Resolver {\n                 let i = self.lang_items.not_trait();\n                 self.add_fixed_trait_for_expr(expr.id, i);\n             }\n-            ExprIndex(*) => {\n+            ExprIndex(..) => {\n                 let i = self.lang_items.index_trait();\n                 self.add_fixed_trait_for_expr(expr.id, i);\n             }\n@@ -5345,7 +5345,7 @@ impl Resolver {\n                                         descr: &str) {\n         match pat_binding_mode {\n             BindByValue(_) => {}\n-            BindByRef(*) => {\n+            BindByRef(..) => {\n                 self.resolve_error(\n                     pat.span,\n                     format!(\"cannot use `ref` binding mode with {}\",\n@@ -5375,7 +5375,7 @@ impl Resolver {\n         if vi.span == dummy_sp() { return }\n \n         match vi.node {\n-            view_item_extern_mod(*) => {} // ignore\n+            view_item_extern_mod(..) => {} // ignore\n             view_item_use(ref path) => {\n                 for p in path.iter() {\n                     match p.node {\n@@ -5486,7 +5486,7 @@ pub fn resolve_crate(session: Session,\n     let mut resolver = Resolver(session, lang_items, crate.span);\n     resolver.resolve(crate);\n     let Resolver { def_map, export_map2, trait_map, last_private,\n-                   external_exports, _ } = resolver;\n+                   external_exports, .. } = resolver;\n     CrateMap {\n         def_map: def_map,\n         exp_map2: export_map2,"}, {"sha": "fe1e2036b92e72911333f85bcb4755aac85cd351", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -60,11 +60,11 @@ impl<'self> Visitor<&'self ScopeChain<'self>> for LifetimeContext {\n                   item: @ast::item,\n                   _: &'self ScopeChain<'self>) {\n         let scope = match item.node {\n-            ast::item_fn(*) | // fn lifetimes get added in visit_fn below\n-            ast::item_mod(*) |\n-            ast::item_mac(*) |\n-            ast::item_foreign_mod(*) |\n-            ast::item_static(*) => {\n+            ast::item_fn(..) | // fn lifetimes get added in visit_fn below\n+            ast::item_mod(..) |\n+            ast::item_mac(..) |\n+            ast::item_foreign_mod(..) |\n+            ast::item_static(..) => {\n                 RootScope\n             }\n             ast::item_ty(_, ref generics) |\n@@ -97,7 +97,7 @@ impl<'self> Visitor<&'self ScopeChain<'self>> for LifetimeContext {\n                 visit::walk_fn(self, fk, fd, b, s, n, &scope1);\n                 debug!(\"popping fn scope id={} due to item/method\", n);\n             }\n-            visit::fk_anon(*) | visit::fk_fn_block(*) => {\n+            visit::fk_anon(..) | visit::fk_fn_block(..) => {\n                 visit::walk_fn(self, fk, fd, b, s, n, scope);\n             }\n         }\n@@ -107,8 +107,8 @@ impl<'self> Visitor<&'self ScopeChain<'self>> for LifetimeContext {\n                 ty: &ast::Ty,\n                 scope: &'self ScopeChain<'self>) {\n         match ty.node {\n-            ast::ty_closure(@ast::TyClosure { lifetimes: ref lifetimes, _ }) |\n-            ast::ty_bare_fn(@ast::TyBareFn { lifetimes: ref lifetimes, _ }) => {\n+            ast::ty_closure(@ast::TyClosure { lifetimes: ref lifetimes, .. }) |\n+            ast::ty_bare_fn(@ast::TyBareFn { lifetimes: ref lifetimes, .. }) => {\n                 let scope1 = FnScope(ty.id, lifetimes, scope);\n                 self.check_lifetime_names(lifetimes);\n                 debug!(\"pushing fn scope id={} due to type\", ty.id);"}, {"sha": "bd87ab436504e3ce497665f86112f5226d7b3943", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -358,7 +358,7 @@ fn variant_opt(bcx: @mut Block, pat_id: ast::NodeId)\n             }\n             unreachable!();\n         }\n-        ast::DefFn(*) |\n+        ast::DefFn(..) |\n         ast::DefStruct(_) => {\n             return lit(UnitLikeStructLit(pat_id));\n         }\n@@ -618,7 +618,7 @@ fn enter_opt<'r>(bcx: @mut Block,\n     let mut i = 0;\n     enter_match(bcx, tcx.def_map, m, col, val, |p| {\n         let answer = match p.node {\n-            ast::PatEnum(*) |\n+            ast::PatEnum(..) |\n             ast::PatIdent(_, _, None) if pat_is_const(tcx.def_map, p) => {\n                 let const_def = tcx.def_map.get_copy(&p.id);\n                 let const_def_id = ast_util::def_id_of_def(const_def);\n@@ -724,7 +724,7 @@ fn enter_opt<'r>(bcx: @mut Block,\n                 // submatch. Thus, including a default match would\n                 // cause the default match to fire spuriously.\n                 match *opt {\n-                    vec_len(*) => None,\n+                    vec_len(..) => None,\n                     _ => Some(vec::from_elem(variant_size, dummy))\n                 }\n             }\n@@ -935,15 +935,15 @@ fn get_options(bcx: @mut Block, m: &[Match], col: uint) -> ~[Opt] {\n             ast::PatLit(l) => {\n                 add_to_set(ccx.tcx, &mut found, lit(ExprLit(l)));\n             }\n-            ast::PatIdent(*) => {\n+            ast::PatIdent(..) => {\n                 // This is one of: an enum variant, a unit-like struct, or a\n                 // variable binding.\n                 match ccx.tcx.def_map.find(&cur.id) {\n-                    Some(&ast::DefVariant(*)) => {\n+                    Some(&ast::DefVariant(..)) => {\n                         add_to_set(ccx.tcx, &mut found,\n                                    variant_opt(bcx, cur.id));\n                     }\n-                    Some(&ast::DefStruct(*)) => {\n+                    Some(&ast::DefStruct(..)) => {\n                         add_to_set(ccx.tcx, &mut found,\n                                    lit(UnitLikeStructLit(cur.id)));\n                     }\n@@ -954,12 +954,12 @@ fn get_options(bcx: @mut Block, m: &[Match], col: uint) -> ~[Opt] {\n                     _ => {}\n                 }\n             }\n-            ast::PatEnum(*) | ast::PatStruct(*) => {\n+            ast::PatEnum(..) | ast::PatStruct(..) => {\n                 // This could be one of: a tuple-like enum variant, a\n                 // struct-like enum variant, or a struct.\n                 match ccx.tcx.def_map.find(&cur.id) {\n-                    Some(&ast::DefFn(*)) |\n-                    Some(&ast::DefVariant(*)) => {\n+                    Some(&ast::DefFn(..)) |\n+                    Some(&ast::DefVariant(..)) => {\n                         add_to_set(ccx.tcx, &mut found,\n                                    variant_opt(bcx, cur.id));\n                     }\n@@ -1078,7 +1078,7 @@ fn collect_record_or_struct_fields(bcx: @mut Block,\n         match br.pats[col].node {\n           ast::PatStruct(_, ref fs, _) => {\n             match ty::get(node_id_type(bcx, br.pats[col].id)).sty {\n-              ty::ty_struct(*) => {\n+              ty::ty_struct(..) => {\n                    extend(&mut fields, *fs);\n                    found = true;\n               }\n@@ -1168,8 +1168,8 @@ fn any_tuple_struct_pat(bcx: @mut Block, m: &[Match], col: uint) -> bool {\n         match pat.node {\n             ast::PatEnum(_, Some(_)) => {\n                 match bcx.tcx().def_map.find(&pat.id) {\n-                    Some(&ast::DefFn(*)) |\n-                    Some(&ast::DefStruct(*)) => true,\n+                    Some(&ast::DefFn(..)) |\n+                    Some(&ast::DefStruct(..)) => true,\n                     _ => false\n                 }\n             }\n@@ -1599,7 +1599,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n         let pat_ty = node_id_type(bcx, pat_id);\n         let llbox = Load(bcx, val);\n         let unboxed = match ty::get(pat_ty).sty {\n-            ty::ty_uniq(*) if !ty::type_contents(bcx.tcx(), pat_ty).owns_managed() => llbox,\n+            ty::ty_uniq(..) if !ty::type_contents(bcx.tcx(), pat_ty).owns_managed() => llbox,\n             _ => GEPi(bcx, llbox, [0u, abi::box_field_body])\n         };\n         compile_submatch(bcx, enter_uniq(bcx, dm, m, col, val),\n@@ -1636,7 +1636,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n                 test_val = Load(bcx, val);\n                 kind = compare;\n             },\n-            vec_len(*) => {\n+            vec_len(..) => {\n                 let vt = tvec::vec_types(bcx, node_id_type(bcx, pat_id));\n                 let unboxed = load_if_immediate(bcx, val, vt.vec_ty);\n                 let (_, len) = tvec::get_base_and_len(bcx, unboxed, vt.vec_ty);\n@@ -1708,7 +1708,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n                                           t, ast::BiGe)\n                               }\n                               range_result(\n-                                  Result {val: vbegin, _},\n+                                  Result {val: vbegin, ..},\n                                   Result {bcx, val: vend}) => {\n                                   let Result {bcx, val: llge} =\n                                       compare_scalar_types(\n@@ -1748,7 +1748,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n                                   rslt(bcx, value)\n                               }\n                               range_result(\n-                                  Result {val: vbegin, _},\n+                                  Result {val: vbegin, ..},\n                                   Result {bcx, val: vend}) => {\n                                   let llge =\n                                       compare_scalar_values(\n@@ -2172,8 +2172,8 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n                         }\n                     }\n                 }\n-                Some(&ast::DefFn(*)) |\n-                Some(&ast::DefStruct(*)) => {\n+                Some(&ast::DefFn(..)) |\n+                Some(&ast::DefStruct(..)) => {\n                     match *sub_pats {\n                         None => {\n                             // This is a unit-like struct. Nothing to do here.\n@@ -2221,7 +2221,7 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n             let pat_ty = node_id_type(bcx, pat.id);\n             let llbox = Load(bcx, val);\n             let unboxed = match ty::get(pat_ty).sty {\n-                ty::ty_uniq(*) if !ty::type_contents(bcx.tcx(), pat_ty).owns_managed() => llbox,\n+                ty::ty_uniq(..) if !ty::type_contents(bcx.tcx(), pat_ty).owns_managed() => llbox,\n                     _ => GEPi(bcx, llbox, [0u, abi::box_field_body])\n             };\n             bcx = bind_irrefutable_pat(bcx, inner, unboxed, binding_mode);\n@@ -2230,7 +2230,7 @@ fn bind_irrefutable_pat(bcx: @mut Block,\n             let loaded_val = Load(bcx, val);\n             bcx = bind_irrefutable_pat(bcx, inner, loaded_val, binding_mode);\n         }\n-        ast::PatVec(*) => {\n+        ast::PatVec(..) => {\n             bcx.tcx().sess.span_bug(\n                 pat.span,\n                 format!(\"vector patterns are never irrefutable!\"));"}, {"sha": "7893a63fa5d5374566e8b2dfe96d1826914985c8", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -247,7 +247,7 @@ pub fn is_ffi_safe(tcx: ty::ctxt, def_id: ast::DefId) -> bool {\n     }\n }\n \n-// NOTE this should probably all be in ty\n+// this should probably all be in ty\n struct Case { discr: Disr, tys: ~[ty::t] }\n impl Case {\n     fn is_zerolen(&self, cx: &mut CrateContext) -> bool {\n@@ -386,16 +386,16 @@ pub fn incomplete_type_of(cx: &mut CrateContext, r: &Repr, name: &str) -> Type {\n }\n pub fn finish_type_of(cx: &mut CrateContext, r: &Repr, llty: &mut Type) {\n     match *r {\n-        CEnum(*) | General(*) => { }\n-        Univariant(ref st, _) | NullablePointer{ nonnull: ref st, _ } =>\n+        CEnum(..) | General(..) => { }\n+        Univariant(ref st, _) | NullablePointer{ nonnull: ref st, .. } =>\n             llty.set_struct_body(struct_llfields(cx, st, false), st.packed)\n     }\n }\n \n fn generic_type_of(cx: &mut CrateContext, r: &Repr, name: Option<&str>, sizing: bool) -> Type {\n     match *r {\n         CEnum(ity, _, _) => ll_inttype(cx, ity),\n-        Univariant(ref st, _) | NullablePointer{ nonnull: ref st, _ } => {\n+        Univariant(ref st, _) | NullablePointer{ nonnull: ref st, .. } => {\n             match name {\n                 None => Type::struct_(struct_llfields(cx, st, sizing), st.packed),\n                 Some(name) => { assert_eq!(sizing, false); Type::named_struct(name) }\n@@ -461,13 +461,13 @@ fn struct_llfields(cx: &mut CrateContext, st: &Struct, sizing: bool) -> ~[Type]\n pub fn trans_switch(bcx: @mut Block, r: &Repr, scrutinee: ValueRef)\n     -> (_match::branch_kind, Option<ValueRef>) {\n     match *r {\n-        CEnum(*) | General(*) => {\n+        CEnum(..) | General(..) => {\n             (_match::switch, Some(trans_get_discr(bcx, r, scrutinee, None)))\n         }\n-        NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n+        NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, .. } => {\n             (_match::switch, Some(nullable_bitdiscr(bcx, nonnull, nndiscr, ptrfield, scrutinee)))\n         }\n-        Univariant(*) => {\n+        Univariant(..) => {\n             (_match::single, None)\n         }\n     }\n@@ -490,11 +490,11 @@ pub fn trans_get_discr(bcx: @mut Block, r: &Repr, scrutinee: ValueRef, cast_to:\n             val = load_discr(bcx, ity, ptr, 0, (cases.len() - 1) as Disr);\n             signed = ity.is_signed();\n         }\n-        Univariant(*) => {\n+        Univariant(..) => {\n             val = C_u8(0);\n             signed = false;\n         }\n-        NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n+        NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, .. } => {\n             val = nullable_bitdiscr(bcx, nonnull, nndiscr, ptrfield, scrutinee);\n             signed = false;\n         }\n@@ -552,10 +552,10 @@ pub fn trans_case(bcx: @mut Block, r: &Repr, discr: Disr) -> _match::opt_result\n             _match::single_result(rslt(bcx, C_integral(ll_inttype(bcx.ccx(), ity),\n                                                        discr as u64, true)))\n         }\n-        Univariant(*) => {\n+        Univariant(..) => {\n             bcx.ccx().sess.bug(\"no cases for univariants or structs\")\n         }\n-        NullablePointer{ _ } => {\n+        NullablePointer{ .. } => {\n             assert!(discr == 0 || discr == 1);\n             _match::single_result(rslt(bcx, C_i1(discr != 0)))\n         }\n@@ -583,10 +583,10 @@ pub fn trans_start_init(bcx: @mut Block, r: &Repr, val: ValueRef, discr: Disr) {\n             Store(bcx, C_bool(true),\n                   GEPi(bcx, val, [0, st.fields.len() - 1]))\n         }\n-        Univariant(*) => {\n+        Univariant(..) => {\n             assert_eq!(discr, 0);\n         }\n-        NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n+        NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, .. } => {\n             if discr != nndiscr {\n                 let llptrptr = GEPi(bcx, val, [0, ptrfield]);\n                 let llptrty = type_of::type_of(bcx.ccx(), nonnull.fields[ptrfield]);\n@@ -609,13 +609,14 @@ fn assert_discr_in_range(ity: IntType, min: Disr, max: Disr, discr: Disr) {\n  */\n pub fn num_args(r: &Repr, discr: Disr) -> uint {\n     match *r {\n-        CEnum(*) => 0,\n+        CEnum(..) => 0,\n         Univariant(ref st, dtor) => {\n             assert_eq!(discr, 0);\n             st.fields.len() - (if dtor { 1 } else { 0 })\n         }\n         General(_, ref cases) => cases[discr].fields.len() - 1,\n-        NullablePointer{ nonnull: ref nonnull, nndiscr, nullfields: ref nullfields, _ } => {\n+        NullablePointer{ nonnull: ref nonnull, nndiscr,\n+                         nullfields: ref nullfields, .. } => {\n             if discr == nndiscr { nonnull.fields.len() } else { nullfields.len() }\n         }\n     }\n@@ -628,7 +629,7 @@ pub fn trans_field_ptr(bcx: @mut Block, r: &Repr, val: ValueRef, discr: Disr,\n     // decide to do some kind of cdr-coding-like non-unique repr\n     // someday), it will need to return a possibly-new bcx as well.\n     match *r {\n-        CEnum(*) => {\n+        CEnum(..) => {\n             bcx.ccx().sess.bug(\"element access in C-like enum\")\n         }\n         Univariant(ref st, _dtor) => {\n@@ -638,7 +639,8 @@ pub fn trans_field_ptr(bcx: @mut Block, r: &Repr, val: ValueRef, discr: Disr,\n         General(_, ref cases) => {\n             struct_field_ptr(bcx, &cases[discr], val, ix + 1, true)\n         }\n-        NullablePointer{ nonnull: ref nonnull, nullfields: ref nullfields, nndiscr, _ } => {\n+        NullablePointer{ nonnull: ref nonnull, nullfields: ref nullfields,\n+                         nndiscr, .. } => {\n             if (discr == nndiscr) {\n                 struct_field_ptr(bcx, nonnull, val, ix, false)\n             } else {\n@@ -718,7 +720,7 @@ pub fn trans_const(ccx: &mut CrateContext, r: &Repr, discr: Disr,\n             let contents = build_const_struct(ccx, st, vals);\n             C_struct(contents, st.packed)\n         }\n-        NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, _ } => {\n+        NullablePointer{ nonnull: ref nonnull, nndiscr, ptrfield, .. } => {\n             if discr == nndiscr {\n                 C_struct(build_const_struct(ccx, nonnull, vals), false)\n             } else {\n@@ -789,18 +791,18 @@ pub fn const_get_discrim(ccx: &mut CrateContext, r: &Repr, val: ValueRef)\n     match *r {\n         CEnum(ity, _, _) => {\n             match ity {\n-                attr::SignedInt(*) => const_to_int(val) as Disr,\n-                attr::UnsignedInt(*) => const_to_uint(val) as Disr\n+                attr::SignedInt(..) => const_to_int(val) as Disr,\n+                attr::UnsignedInt(..) => const_to_uint(val) as Disr\n             }\n         }\n         General(ity, _) => {\n             match ity {\n-                attr::SignedInt(*) => const_to_int(const_get_elt(ccx, val, [0])) as Disr,\n-                attr::UnsignedInt(*) => const_to_uint(const_get_elt(ccx, val, [0])) as Disr\n+                attr::SignedInt(..) => const_to_int(const_get_elt(ccx, val, [0])) as Disr,\n+                attr::UnsignedInt(..) => const_to_uint(const_get_elt(ccx, val, [0])) as Disr\n             }\n         }\n-        Univariant(*) => 0,\n-        NullablePointer{ nndiscr, ptrfield, _ } => {\n+        Univariant(..) => 0,\n+        NullablePointer{ nndiscr, ptrfield, .. } => {\n             if is_null(const_struct_field(ccx, val, ptrfield)) {\n                 /* subtraction as uint is ok because nndiscr is either 0 or 1 */\n                 (1 - nndiscr) as Disr\n@@ -821,10 +823,10 @@ pub fn const_get_discrim(ccx: &mut CrateContext, r: &Repr, val: ValueRef)\n pub fn const_get_field(ccx: &mut CrateContext, r: &Repr, val: ValueRef,\n                        _discr: Disr, ix: uint) -> ValueRef {\n     match *r {\n-        CEnum(*) => ccx.sess.bug(\"element access in C-like enum const\"),\n-        Univariant(*) => const_struct_field(ccx, val, ix),\n-        General(*) => const_struct_field(ccx, val, ix + 1),\n-        NullablePointer{ _ } => const_struct_field(ccx, val, ix)\n+        CEnum(..) => ccx.sess.bug(\"element access in C-like enum const\"),\n+        Univariant(..) => const_struct_field(ccx, val, ix),\n+        General(..) => const_struct_field(ccx, val, ix + 1),\n+        NullablePointer{ .. } => const_struct_field(ccx, val, ix)\n     }\n }\n "}, {"sha": "ac7b82401768226118cec65b9819e9d259f338e8", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -230,7 +230,7 @@ fn decl_rust_fn(ccx: &mut CrateContext, inputs: &[ty::t], output: ty::t, name: &\n             }\n         }\n         // `~` pointer return values never alias because ownership is transferred\n-        ty::ty_uniq(*) |\n+        ty::ty_uniq(..) |\n         ty::ty_evec(_, ty::vstore_uniq) => {\n             unsafe {\n                 llvm::LLVMAddReturnAttribute(llfn, lib::llvm::NoAliasAttribute as c_uint);\n@@ -246,9 +246,9 @@ fn decl_rust_fn(ccx: &mut CrateContext, inputs: &[ty::t], output: ty::t, name: &\n         let llarg = unsafe { llvm::LLVMGetParam(llfn, (offset + i) as c_uint) };\n         match ty::get(arg_ty).sty {\n             // `~` pointer parameters never alias because ownership is transferred\n-            ty::ty_uniq(*) |\n+            ty::ty_uniq(..) |\n             ty::ty_evec(_, ty::vstore_uniq) |\n-            ty::ty_closure(ty::ClosureTy {sigil: ast::OwnedSigil, _}) => {\n+            ty::ty_closure(ty::ClosureTy {sigil: ast::OwnedSigil, ..}) => {\n                 unsafe {\n                     llvm::LLVMAddAttribute(llarg, lib::llvm::NoAliasAttribute as c_uint);\n                 }\n@@ -702,7 +702,7 @@ pub fn iter_structural_ty(cx: @mut Block, av: ValueRef, t: ty::t,\n \n     let mut cx = cx;\n     match ty::get(t).sty {\n-      ty::ty_struct(*) => {\n+      ty::ty_struct(..) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n           expr::with_field_tys(cx.tcx(), t, None, |discr, field_tys| {\n               for (i, field_ty) in field_tys.iter().enumerate() {\n@@ -854,7 +854,7 @@ pub fn trans_external_path(ccx: &mut CrateContext, did: ast::DefId, t: ty::t) ->\n                 Some(Rust) | Some(RustIntrinsic) => {\n                     get_extern_rust_fn(ccx, fn_ty.sig.inputs, fn_ty.sig.output, name, did)\n                 }\n-                Some(*) | None => {\n+                Some(..) | None => {\n                     let c = foreign::llvm_calling_convention(ccx, fn_ty.abis);\n                     let cconv = c.unwrap_or(lib::llvm::CCallConv);\n                     let llty = type_of_fn_from_ty(ccx, t);\n@@ -1046,11 +1046,11 @@ pub fn find_bcx_for_scope(bcx: @mut Block, scope_id: ast::NodeId) -> @mut Block\n         cur_scope = match cur_scope {\n             Some(inf) => {\n                 match inf.node_info {\n-                    Some(NodeInfo { id, _ }) if id == scope_id => {\n+                    Some(NodeInfo { id, .. }) if id == scope_id => {\n                         return bcx_sid\n                     }\n                     // FIXME(#6268, #6248) hacky cleanup for nested method calls\n-                    Some(NodeInfo { callee_id: Some(id), _ }) if id == scope_id => {\n+                    Some(NodeInfo { callee_id: Some(id), .. }) if id == scope_id => {\n                         return bcx_sid\n                     }\n                     _ => inf.parent\n@@ -1171,7 +1171,7 @@ pub fn trans_stmt(cx: @mut Block, s: &ast::Stmt) -> @mut Block {\n                 ast::DeclItem(i) => trans_item(cx.fcx.ccx, i)\n             }\n         }\n-        ast::StmtMac(*) => cx.tcx().sess.bug(\"unexpanded macro\")\n+        ast::StmtMac(..) => cx.tcx().sess.bug(\"unexpanded macro\")\n     }\n \n     return bcx;\n@@ -2261,7 +2261,7 @@ pub fn trans_item(ccx: @mut CrateContext, item: &ast::item) {\n             trans_struct_def(ccx, struct_def);\n         }\n       }\n-      ast::item_trait(*) => {\n+      ast::item_trait(..) => {\n         // Inside of this trait definition, we won't be actually translating any\n         // functions, but the trait still needs to be walked. Otherwise default\n         // methods with items will not get translated and will cause ICE's when\n@@ -2607,11 +2607,11 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::NodeId) -> ValueRef {\n                     foreign = true;\n \n                     match ni.node {\n-                        ast::foreign_item_fn(*) => {\n+                        ast::foreign_item_fn(..) => {\n                             let path = vec::append((*pth).clone(), [path_name(ni.ident)]);\n                             foreign::register_foreign_item_fn(ccx, abis, &path, ni)\n                         }\n-                        ast::foreign_item_static(*) => {\n+                        ast::foreign_item_static(..) => {\n                             // Treat the crate map static specially in order to\n                             // a weak-linkage-like functionality where it's\n                             // dynamically resolved at runtime. If we're\n@@ -3157,7 +3157,7 @@ pub fn trans_crate(sess: session::Session,\n     decl_gc_metadata(ccx, llmod_id);\n     fill_crate_map(ccx, ccx.crate_map);\n \n-    // NOTE win32: wart with exporting crate_map symbol\n+    // win32: wart with exporting crate_map symbol\n     // We set the crate map (_rust_crate_map_toplevel) to use dll_export\n     // linkage but that ends up causing the linker to look for a\n     // __rust_crate_map_toplevel symbol (extra underscore) which it will"}, {"sha": "b1aa8a1f26a37fec031483c5938344ddca6dc0e2", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -95,11 +95,11 @@ pub fn trans(bcx: @mut Block, expr: &ast::Expr) -> Callee {\n     fn datum_callee(bcx: @mut Block, expr: &ast::Expr) -> Callee {\n         let DatumBlock {bcx, datum} = expr::trans_to_datum(bcx, expr);\n         match ty::get(datum.ty).sty {\n-            ty::ty_bare_fn(*) => {\n+            ty::ty_bare_fn(..) => {\n                 let llval = datum.to_appropriate_llval(bcx);\n                 return Callee {bcx: bcx, data: Fn(FnData {llfn: llval})};\n             }\n-            ty::ty_closure(*) => {\n+            ty::ty_closure(..) => {\n                 return Callee {bcx: bcx, data: Closure(datum)};\n             }\n             _ => {\n@@ -138,19 +138,19 @@ pub fn trans(bcx: @mut Block, expr: &ast::Expr) -> Callee {\n             ast::DefStruct(def_id) => {\n                 fn_callee(bcx, trans_fn_ref(bcx, def_id, ref_expr.id))\n             }\n-            ast::DefStatic(*) |\n-            ast::DefArg(*) |\n-            ast::DefLocal(*) |\n-            ast::DefBinding(*) |\n-            ast::DefUpvar(*) |\n-            ast::DefSelf(*) => {\n+            ast::DefStatic(..) |\n+            ast::DefArg(..) |\n+            ast::DefLocal(..) |\n+            ast::DefBinding(..) |\n+            ast::DefUpvar(..) |\n+            ast::DefSelf(..) => {\n                 datum_callee(bcx, ref_expr)\n             }\n-            ast::DefMod(*) | ast::DefForeignMod(*) | ast::DefTrait(*) |\n-            ast::DefTy(*) | ast::DefPrimTy(*) |\n-            ast::DefUse(*) | ast::DefTyParamBinder(*) |\n-            ast::DefRegion(*) | ast::DefLabel(*) | ast::DefTyParam(*) |\n-            ast::DefSelfTy(*) | ast::DefMethod(*) => {\n+            ast::DefMod(..) | ast::DefForeignMod(..) | ast::DefTrait(..) |\n+            ast::DefTy(..) | ast::DefPrimTy(..) |\n+            ast::DefUse(..) | ast::DefTyParamBinder(..) |\n+            ast::DefRegion(..) | ast::DefLabel(..) | ast::DefTyParam(..) |\n+            ast::DefSelfTy(..) | ast::DefMethod(..) => {\n                 bcx.tcx().sess.span_bug(\n                     ref_expr.span,\n                     format!(\"Cannot translate def {:?} \\\n@@ -718,7 +718,7 @@ pub fn trans_call_inner(in_cx: @mut Block,\n             // The `noalias` attribute on the return value is useful to a function ptr caller.\n             match ty::get(ret_ty).sty {\n                 // `~` pointer return values never alias because ownership is transferred\n-                ty::ty_uniq(*) |\n+                ty::ty_uniq(..) |\n                 ty::ty_evec(_, ty::vstore_uniq) => {\n                     attrs.push((0, NoAliasAttribute));\n                 }"}, {"sha": "5395944ce4605b39152a28f01e8dbb88e394d11f", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -71,7 +71,7 @@ pub fn type_is_immediate(ccx: &mut CrateContext, ty: ty::t) -> bool {\n     }\n     match ty::get(ty).sty {\n         ty::ty_bot => true,\n-        ty::ty_struct(*) | ty::ty_enum(*) | ty::ty_tup(*) => {\n+        ty::ty_struct(..) | ty::ty_enum(..) | ty::ty_tup(..) => {\n             let llty = sizing_type_of(ccx, ty);\n             llsize_of_alloc(ccx, llty) <= llsize_of_alloc(ccx, ccx.int_type)\n         }\n@@ -778,7 +778,7 @@ pub fn in_scope_cx(cx: @mut Block,\n         cur_scope = match cur_scope {\n             Some(inf) => match scope_id {\n                 Some(wanted) => match inf.node_info {\n-                    Some(NodeInfo { id: actual, _ }) if wanted == actual => {\n+                    Some(NodeInfo { id: actual, .. }) if wanted == actual => {\n                         debug!(\"in_scope_cx: selected cur={} (cx={})\",\n                                cur.to_str(), cx.to_str());\n                         f(inf);\n@@ -1054,11 +1054,11 @@ pub enum MonoDataClass {\n pub fn mono_data_classify(t: ty::t) -> MonoDataClass {\n     match ty::get(t).sty {\n         ty::ty_float(_) => MonoFloat,\n-        ty::ty_rptr(*) | ty::ty_uniq(*) |\n-        ty::ty_box(*) | ty::ty_opaque_box(*) |\n+        ty::ty_rptr(..) | ty::ty_uniq(..) |\n+        ty::ty_box(..) | ty::ty_opaque_box(..) |\n         ty::ty_estr(ty::vstore_uniq) | ty::ty_evec(_, ty::vstore_uniq) |\n         ty::ty_estr(ty::vstore_box) | ty::ty_evec(_, ty::vstore_box) |\n-        ty::ty_bare_fn(*) => MonoNonNull,\n+        ty::ty_bare_fn(..) => MonoNonNull,\n         // Is that everything?  Would closures or slices qualify?\n         _ => MonoBits\n     }"}, {"sha": "9a9f343744c95f0c05fb79f95e2dc71dbd882914", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -133,10 +133,10 @@ fn const_deref(cx: &mut CrateContext, v: ValueRef, t: ty::t, explicit: bool)\n         Some(ref mt) => {\n             assert!(mt.mutbl != ast::MutMutable);\n             let dv = match ty::get(t).sty {\n-                ty::ty_ptr(*) | ty::ty_rptr(*) => {\n+                ty::ty_ptr(..) | ty::ty_rptr(..) => {\n                      const_deref_ptr(cx, v)\n                 }\n-                ty::ty_enum(*) | ty::ty_struct(*) => {\n+                ty::ty_enum(..) | ty::ty_struct(..) => {\n                     const_deref_newtype(cx, v, t)\n                 }\n                 _ => {\n@@ -162,7 +162,7 @@ pub fn get_const_val(cx: @mut CrateContext,\n         }\n         match cx.tcx.items.get_copy(&def_id.node) {\n             ast_map::node_item(@ast::item {\n-                node: ast::item_static(_, ast::MutImmutable, _), _\n+                node: ast::item_static(_, ast::MutImmutable, _), ..\n             }, _) => {\n                 trans_const(cx, ast::MutImmutable, def_id.node);\n             }\n@@ -419,7 +419,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext,\n \n               let len = llvm::LLVMConstIntGetZExtValue(len) as u64;\n               let len = match ty::get(bt).sty {\n-                  ty::ty_estr(*) => {assert!(len > 0); len - 1},\n+                  ty::ty_estr(..) => {assert!(len > 0); len - 1},\n                   _ => len\n               };\n               if iv >= len {\n@@ -533,7 +533,7 @@ fn const_expr_unadjusted(cx: @mut CrateContext,\n             match sub.node {\n               ast::ExprLit(ref lit) => {\n                 match lit.node {\n-                  ast::lit_str(*) => { const_expr(cx, sub) }\n+                  ast::lit_str(..) => { const_expr(cx, sub) }\n                   _ => { cx.sess.span_bug(e.span, \"bad const-slice lit\") }\n                 }\n               }"}, {"sha": "952854e7d047f63600f7b4fa680da523a029d39e", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -238,7 +238,7 @@ pub fn trans_break_cont(bcx: @mut Block,\n                 loop_break: Some(brk),\n                 loop_label: l,\n                 parent,\n-                _\n+                ..\n             }) => {\n                 // If we're looking for a labeled loop, check the label...\n                 target = if to_end {"}, {"sha": "ad242a9bfe6469e9b9502083fef941c879d5f05b", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -300,7 +300,7 @@ pub fn create_captured_var_metadata(bcx: @mut Block,\n             cx.sess.span_bug(span, \"debuginfo::create_captured_var_metadata() - NodeId not found\");\n         }\n         Some(ast_map::node_local(ident)) => ident,\n-        Some(ast_map::node_arg(@ast::Pat { node: ast::PatIdent(_, ref path, _), _ })) => {\n+        Some(ast_map::node_arg(@ast::Pat { node: ast::PatIdent(_, ref path, _), .. })) => {\n             ast_util::path_to_ident(path)\n         }\n         _ => {\n@@ -388,14 +388,14 @@ pub fn create_self_argument_metadata(bcx: @mut Block,\n     // Extract the span of the self argument from the method's AST\n     let fnitem = bcx.ccx().tcx.items.get_copy(&bcx.fcx.id);\n     let span = match fnitem {\n-        ast_map::node_method(@ast::method { explicit_self: explicit_self, _ }, _, _) => {\n+        ast_map::node_method(@ast::method { explicit_self: explicit_self, .. }, _, _) => {\n             explicit_self.span\n         }\n         ast_map::node_trait_method(\n             @ast::provided(\n                 @ast::method {\n                     explicit_self: explicit_self,\n-                    _\n+                    ..\n                 }),\n             _,\n             _) => {\n@@ -570,7 +570,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n                 generics: ref generics,\n                 body: ref top_level_block,\n                 span: span,\n-                _\n+                ..\n             },\n             _,\n             _) => {\n@@ -603,15 +603,15 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n                     generics: ref generics,\n                     body: ref top_level_block,\n                     span: span,\n-                    _\n+                    ..\n                 }),\n             _,\n             _) => {\n             (ident, fn_decl, generics, top_level_block, span, true)\n         }\n-        ast_map::node_foreign_item(@ast::foreign_item { _ }, _, _, _) |\n-        ast_map::node_variant(*) |\n-        ast_map::node_struct_ctor(*) => {\n+        ast_map::node_foreign_item(@ast::foreign_item { .. }, _, _, _) |\n+        ast_map::node_variant(..) |\n+        ast_map::node_struct_ctor(..) => {\n             return FunctionWithoutDebugInfo;\n         }\n         _ => cx.sess.bug(format!(\"create_function_debug_context: \\\n@@ -744,7 +744,7 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n                                name_to_append_suffix_to: &mut ~str)\n                             -> DIArray {\n         let self_type = match param_substs {\n-            Some(@param_substs{ self_ty: self_type, _ }) => self_type,\n+            Some(@param_substs{ self_ty: self_type, .. }) => self_type,\n             _ => None\n         };\n \n@@ -798,13 +798,13 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n \n         // Handle other generic parameters\n         let actual_types = match param_substs {\n-            Some(@param_substs { tys: ref types, _ }) => types,\n+            Some(@param_substs { tys: ref types, .. }) => types,\n             None => {\n                 return create_DIArray(DIB(cx), template_params);\n             }\n         };\n \n-        for (index, &ast::TyParam{ ident: ident, _ }) in generics.ty_params.iter().enumerate() {\n+        for (index, &ast::TyParam{ ident: ident, .. }) in generics.ty_params.iter().enumerate() {\n             let actual_type = actual_types[index];\n             // Add actual type name to <...> clause of function name\n             let actual_type_name = ppaux::ty_to_str(cx.tcx, actual_type);\n@@ -843,10 +843,10 @@ pub fn create_function_debug_context(cx: &mut CrateContext,\n                       default: uint)\n                    -> uint {\n         match *top_level_block {\n-            ast::Block { stmts: ref statements, _ } if statements.len() > 0 => {\n+            ast::Block { stmts: ref statements, .. } if statements.len() > 0 => {\n                 span_start(cx, statements[0].span).line\n             }\n-            ast::Block { expr: Some(@ref expr), _ } => {\n+            ast::Block { expr: Some(@ref expr), .. } => {\n                 span_start(cx, expr.span).line\n             }\n             _ => default\n@@ -1171,7 +1171,7 @@ impl RecursiveTypeDescription {\n \n     fn metadata(&self) -> DICompositeType {\n         match *self {\n-            UnfinishedMetadata { metadata_stub, _ } => metadata_stub,\n+            UnfinishedMetadata { metadata_stub, .. } => metadata_stub,\n             FinalMetadata(metadata) => metadata\n         }\n     }\n@@ -1517,7 +1517,7 @@ fn prepare_enum_metadata(cx: &mut CrateContext,\n                 } as @MemberDescriptionFactory,\n             }\n         }\n-        adt::NullablePointer { nonnull: ref struct_def, nndiscr, _ } => {\n+        adt::NullablePointer { nonnull: ref struct_def, nndiscr, .. } => {\n             let (metadata_stub,\n                  variant_llvm_type,\n                  member_description_factory) = describe_variant(cx,\n@@ -2227,7 +2227,7 @@ fn get_namespace_and_span_for_item(cx: &mut CrateContext,\n     let containing_scope = namespace_for_item(cx, def_id, warning_span).scope;\n     let definition_span = if def_id.crate == ast::LOCAL_CRATE {\n         let definition_span = match cx.tcx.items.find(&def_id.node) {\n-            Some(&ast_map::node_item(@ast::item { span, _ }, _)) => span,\n+            Some(&ast_map::node_item(@ast::item { span, .. }, _)) => span,\n             ref node => {\n                 cx.sess.span_warn(warning_span,\n                     format!(\"debuginfo::get_namespace_and_span_for_item() \\\n@@ -2328,7 +2328,7 @@ fn populate_scope_map(cx: &mut CrateContext,\n                 ast::StmtDecl(@ref decl, _) => walk_decl(cx, decl, scope_stack, scope_map),\n                 ast::StmtExpr(@ref exp, _) |\n                 ast::StmtSemi(@ref exp, _) => walk_expr(cx, exp, scope_stack, scope_map),\n-                ast::StmtMac(*) => () // ignore macros (which should be expanded anyway)\n+                ast::StmtMac(..) => () // ignore macros (which should be expanded anyway)\n             }\n         }\n \n@@ -2342,7 +2342,7 @@ fn populate_scope_map(cx: &mut CrateContext,\n                  scope_stack: &mut ~[ScopeStackEntry],\n                  scope_map: &mut HashMap<ast::NodeId, DIScope>) {\n         match *decl {\n-            codemap::Spanned { node: ast::DeclLocal(@ref local), _ } => {\n+            codemap::Spanned { node: ast::DeclLocal(@ref local), .. } => {\n                 scope_map.insert(local.id, scope_stack.last().scope_metadata);\n \n                 walk_pattern(cx, local.pat, scope_stack, scope_map);\n@@ -2453,7 +2453,7 @@ fn populate_scope_map(cx: &mut CrateContext,\n             ast::PatStruct(_, ref field_pats, _) => {\n                 scope_map.insert(pat.id, scope_stack.last().scope_metadata);\n \n-                for &ast::FieldPat { pat: sub_pat, _ } in field_pats.iter() {\n+                for &ast::FieldPat { pat: sub_pat, .. } in field_pats.iter() {\n                     walk_pattern(cx, sub_pat, scope_stack, scope_map);\n                 }\n             }\n@@ -2604,14 +2604,14 @@ fn populate_scope_map(cx: &mut CrateContext,\n                 })\n             }\n \n-            ast::ExprFnBlock(ast::fn_decl { inputs: ref inputs, _ }, ref block) |\n-            ast::ExprProc(ast::fn_decl { inputs: ref inputs, _ }, ref block) => {\n+            ast::ExprFnBlock(ast::fn_decl { inputs: ref inputs, .. }, ref block) |\n+            ast::ExprProc(ast::fn_decl { inputs: ref inputs, .. }, ref block) => {\n                 with_new_scope(cx,\n                                block.span,\n                                scope_stack,\n                                scope_map,\n                                |cx, scope_stack, scope_map| {\n-                    for &ast::arg { pat: pattern, _ } in inputs.iter() {\n+                    for &ast::arg { pat: pattern, .. } in inputs.iter() {\n                         walk_pattern(cx, pattern, scope_stack, scope_map);\n                     }\n \n@@ -2622,7 +2622,7 @@ fn populate_scope_map(cx: &mut CrateContext,\n             // ast::expr_loop_body(@ref inner_exp) |\n             ast::ExprDoBody(@ref inner_exp)   => {\n                 let inner_expr_is_expr_fn_block = match *inner_exp {\n-                    ast::Expr { node: ast::ExprFnBlock(*), _ } => true,\n+                    ast::Expr { node: ast::ExprFnBlock(..), .. } => true,\n                     _ => false\n                 };\n \n@@ -2680,7 +2680,7 @@ fn populate_scope_map(cx: &mut CrateContext,\n             }\n \n             ast::ExprStruct(_, ref fields, ref base_exp) => {\n-                for &ast::Field { expr: @ref exp, _ } in fields.iter() {\n+                for &ast::Field { expr: @ref exp, .. } in fields.iter() {\n                     walk_expr(cx, exp, scope_stack, scope_map);\n                 }\n \n@@ -2691,8 +2691,8 @@ fn populate_scope_map(cx: &mut CrateContext,\n             }\n \n             ast::ExprInlineAsm(ast::inline_asm { inputs: ref inputs,\n-                                                   outputs: ref outputs,\n-                                                   _ }) => {\n+                                                 outputs: ref outputs,\n+                                                 .. }) => {\n                 // inputs, outputs: ~[(@str, @expr)]\n                 for &(_, @ref exp) in inputs.iter() {\n                     walk_expr(cx, exp, scope_stack, scope_map);"}, {"sha": "47bd57e88f5c3db452de5095352ff812f3e15b5e", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -193,7 +193,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n     };\n     debug!(\"unadjusted datum: {}\", datum.to_str(bcx.ccx()));\n     match *adjustment {\n-        AutoAddEnv(*) => {\n+        AutoAddEnv(..) => {\n             datum = unpack_datum!(bcx, add_env(bcx, expr, datum));\n         }\n         AutoDerefRef(ref adj) => {\n@@ -209,24 +209,24 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n                 None => {\n                     datum\n                 }\n-                Some(AutoUnsafe(*)) | // region + unsafe ptrs have same repr\n-                Some(AutoPtr(*)) => {\n+                Some(AutoUnsafe(..)) | // region + unsafe ptrs have same repr\n+                Some(AutoPtr(..)) => {\n                     unpack_datum!(bcx, auto_ref(bcx, datum))\n                 }\n-                Some(AutoBorrowVec(*)) => {\n+                Some(AutoBorrowVec(..)) => {\n                     unpack_datum!(bcx, auto_slice(bcx, adj.autoderefs,\n                                                   expr, datum))\n                 }\n-                Some(AutoBorrowVecRef(*)) => {\n+                Some(AutoBorrowVecRef(..)) => {\n                     unpack_datum!(bcx, auto_slice_and_ref(bcx, adj.autoderefs,\n                                                           expr, datum))\n                 }\n-                Some(AutoBorrowFn(*)) => {\n+                Some(AutoBorrowFn(..)) => {\n                     let adjusted_ty = ty::adjust_ty(bcx.tcx(), expr.span,\n                                                     datum.ty, Some(adjustment));\n                     unpack_datum!(bcx, auto_borrow_fn(bcx, adjusted_ty, datum))\n                 }\n-                Some(AutoBorrowObj(*)) => {\n+                Some(AutoBorrowObj(..)) => {\n                     unpack_datum!(bcx, auto_borrow_obj(\n                         bcx, adj.autoderefs, expr, datum))\n                 }\n@@ -364,7 +364,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n         let source_data_ptr = GEPi(bcx, source_llval, [0u, abi::trt_field_box]);\n         let source_data = Load(bcx, source_data_ptr); // always a ptr\n         let target_data = match source_store {\n-            ty::BoxTraitStore(*) => {\n+            ty::BoxTraitStore(..) => {\n                 // For deref of @T or @mut T, create a dummy datum and\n                 // use the datum's deref method. This is more work\n                 // than just calling GEPi ourselves, but it ensures\n@@ -388,7 +388,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n                                                      autoderefs));\n                 derefd_datum.to_rptr(bcx).to_value_llval(bcx)\n             }\n-            ty::UniqTraitStore(*) => {\n+            ty::UniqTraitStore(..) => {\n                 // For a ~T box, there may or may not be a header,\n                 // depending on whether the type T references managed\n                 // boxes. However, since we do not *know* the type T\n@@ -410,7 +410,7 @@ pub fn trans_to_datum(bcx: @mut Block, expr: &ast::Expr) -> DatumBlock {\n                     Load(bcx, borrow_offset_ptr);\n                 InBoundsGEP(bcx, llopaque, [borrow_offset])\n             }\n-            ty::RegionTraitStore(*) => {\n+            ty::RegionTraitStore(..) => {\n                 source_data\n             }\n         };\n@@ -709,14 +709,14 @@ fn trans_rvalue_dps_unadjusted(bcx: @mut Block, expr: &ast::Expr,\n                 args.iter().enumerate().map(|(i, arg)| (i, *arg)).collect();\n             return trans_adt(bcx, repr, 0, numbered_fields, None, dest);\n         }\n-        ast::ExprLit(@codemap::Spanned {node: ast::lit_str(s, _), _}) => {\n+        ast::ExprLit(@codemap::Spanned {node: ast::lit_str(s, _), ..}) => {\n             return tvec::trans_lit_str(bcx, expr, s, dest);\n         }\n         ast::ExprVstore(contents, ast::ExprVstoreSlice) |\n         ast::ExprVstore(contents, ast::ExprVstoreMutSlice) => {\n             return tvec::trans_slice_vstore(bcx, expr, contents, dest);\n         }\n-        ast::ExprVec(*) | ast::ExprRepeat(*) => {\n+        ast::ExprVec(..) | ast::ExprRepeat(..) => {\n             return tvec::trans_fixed_vstore(bcx, expr, expr, dest);\n         }\n         ast::ExprFnBlock(ref decl, ref body) |\n@@ -832,7 +832,7 @@ fn trans_def_dps_unadjusted(bcx: @mut Block, ref_expr: &ast::Expr,\n                     let repr = adt::represent_type(ccx, ty);\n                     adt::trans_start_init(bcx, repr, lldest, 0);\n                 }\n-                ty::ty_bare_fn(*) => {\n+                ty::ty_bare_fn(..) => {\n                     let fn_data = callee::trans_fn_ref(bcx, def_id, ref_expr.id);\n                     Store(bcx, fn_data.llfn, lldest);\n                 }\n@@ -1672,14 +1672,14 @@ pub enum cast_kind {\n pub fn cast_type_kind(t: ty::t) -> cast_kind {\n     match ty::get(t).sty {\n         ty::ty_char       => cast_integral,\n-        ty::ty_float(*)   => cast_float,\n-        ty::ty_ptr(*)     => cast_pointer,\n-        ty::ty_rptr(*)    => cast_pointer,\n-        ty::ty_bare_fn(*) => cast_pointer,\n-        ty::ty_int(*)     => cast_integral,\n-        ty::ty_uint(*)    => cast_integral,\n+        ty::ty_float(..)   => cast_float,\n+        ty::ty_ptr(..)     => cast_pointer,\n+        ty::ty_rptr(..)    => cast_pointer,\n+        ty::ty_bare_fn(..) => cast_pointer,\n+        ty::ty_int(..)     => cast_integral,\n+        ty::ty_uint(..)    => cast_integral,\n         ty::ty_bool       => cast_integral,\n-        ty::ty_enum(*)    => cast_enum,\n+        ty::ty_enum(..)    => cast_enum,\n         _                 => cast_other\n     }\n }"}, {"sha": "ac65719f02e861cc69ba757cd15f345c5fe73639", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -98,7 +98,7 @@ pub fn llvm_calling_convention(ccx: &mut CrateContext,\n             C => lib::llvm::CCallConv,\n             Win64 => lib::llvm::X86_64_Win64,\n \n-            // NOTE These API constants ought to be more specific\n+            // These API constants ought to be more specific...\n             Cdecl => lib::llvm::CCallConv,\n             Aapcs => lib::llvm::CCallConv,\n         }\n@@ -347,7 +347,7 @@ pub fn trans_foreign_mod(ccx: @mut CrateContext,\n     let _icx = push_ctxt(\"foreign::trans_foreign_mod\");\n     for &foreign_item in foreign_mod.items.iter() {\n         match foreign_item.node {\n-            ast::foreign_item_fn(*) => {\n+            ast::foreign_item_fn(..) => {\n                 let (abis, mut path) = match ccx.tcx.items.get_copy(&foreign_item.id) {\n                     ast_map::node_foreign_item(_, abis, _, path) => (abis, (*path).clone()),\n                     _ => fail!(\"Unable to find foreign item in tcx.items table.\")"}, {"sha": "4e796fd21b3f745d0ba34e770283af335a978006", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -127,8 +127,8 @@ pub fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n \n     if field == abi::tydesc_field_take_glue {\n         match ty::get(t).sty {\n-          ty::ty_unboxed_vec(*) |\n-              ty::ty_uniq(*) |\n+          ty::ty_unboxed_vec(..) |\n+              ty::ty_uniq(..) |\n               ty::ty_estr(ty::vstore_uniq) |\n               ty::ty_evec(_, ty::vstore_uniq) => { return ty::mk_u32(); }\n           _ => ()\n@@ -142,14 +142,14 @@ pub fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n \n     if field == abi::tydesc_field_free_glue {\n         match ty::get(t).sty {\n-          ty::ty_bare_fn(*) |\n-          ty::ty_closure(*) |\n-          ty::ty_box(*) |\n+          ty::ty_bare_fn(..) |\n+          ty::ty_closure(..) |\n+          ty::ty_box(..) |\n           ty::ty_opaque_box |\n-          ty::ty_uniq(*) |\n+          ty::ty_uniq(..) |\n           ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) |\n           ty::ty_evec(_, ty::vstore_box) | ty::ty_estr(ty::vstore_box) |\n-          ty::ty_opaque_closure_ptr(*) => (),\n+          ty::ty_opaque_closure_ptr(..) => (),\n           _ => { return ty::mk_u32(); }\n         }\n     }\n@@ -373,7 +373,7 @@ pub fn make_free_glue(bcx: @mut Block, v: ValueRef, t: ty::t) -> @mut Block {\n                               None);\n         trans_free(bcx, v)\n       }\n-      ty::ty_uniq(*) => {\n+      ty::ty_uniq(..) => {\n         uniq::make_free_glue(bcx, v, t)\n       }\n       ty::ty_evec(_, ty::vstore_uniq) | ty::ty_estr(ty::vstore_uniq) |\n@@ -602,8 +602,8 @@ pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n     }\n \n     let has_header = match ty::get(t).sty {\n-        ty::ty_box(*) => true,\n-        ty::ty_uniq(*) => ty::type_contents(ccx.tcx, t).owns_managed(),\n+        ty::ty_box(..) => true,\n+        ty::ty_uniq(..) => ty::type_contents(ccx.tcx, t).owns_managed(),\n         _ => false\n     };\n "}, {"sha": "bbabba3381da58ebe8554361c32054000990e6cd", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -67,7 +67,7 @@ pub fn maybe_instantiate_inline(ccx: @mut CrateContext, fn_id: ast::DefId)\n             // however, so we use the available_externally linkage which llvm\n             // provides\n             match item.node {\n-                ast::item_static(*) => {\n+                ast::item_static(..) => {\n                     let g = get_item_val(ccx, item.id);\n                     // see the comment in get_item_val() as to why this check is\n                     // performed here."}, {"sha": "3c4aeb9e762c07ed1d97646bb1d52e6a051877b7", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -113,7 +113,7 @@ pub fn trans_method(ccx: @mut CrateContext,\n         let self_ty = ty::node_id_to_type(ccx.tcx, method.self_id);\n         let self_ty = match param_substs {\n             None => self_ty,\n-            Some(@param_substs {tys: ref tys, self_ty: ref self_sub, _}) => {\n+            Some(@param_substs {tys: ref tys, self_ty: ref self_sub, ..}) => {\n                 ty::subst_tps(ccx.tcx, *tys, *self_sub, self_ty)\n             }\n         };\n@@ -361,7 +361,7 @@ pub fn trans_monomorphized_callee(bcx: @mut Block,\n               })\n           }\n       }\n-      typeck::vtable_param(*) => {\n+      typeck::vtable_param(..) => {\n           fail!(\"vtable_param left in monomorphized function's vtable substs\");\n       }\n     };\n@@ -437,7 +437,7 @@ pub fn trans_trait_callee(bcx: @mut Block,\n     // make a local copy for trait if needed\n     let self_ty = expr_ty_adjusted(bcx, self_expr);\n     let self_scratch = match ty::get(self_ty).sty {\n-        ty::ty_trait(_, _, ty::RegionTraitStore(*), _, _) => {\n+        ty::ty_trait(_, _, ty::RegionTraitStore(..), _, _) => {\n             unpack_datum!(bcx, expr::trans_to_datum(bcx, self_expr))\n         }\n         _ => {"}, {"sha": "9f26b5c4caff9956127f6c0741434ba0ec25da16", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -105,7 +105,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n       ast_map::node_method(m, _, pt) => (pt, m.ident, m.span),\n       ast_map::node_foreign_item(i, abis, _, pt) if abis.is_intrinsic()\n       => (pt, i.ident, i.span),\n-      ast_map::node_foreign_item(*) => {\n+      ast_map::node_foreign_item(..) => {\n         // Foreign externs don't have to be monomorphized.\n         return (get_item_val(ccx, fn_id.node), true);\n       }\n@@ -121,20 +121,20 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n       ast_map::node_trait_method(@ast::required(_), _, _) => {\n         ccx.tcx.sess.bug(\"Can't monomorphize a required trait method\")\n       }\n-      ast_map::node_expr(*) => {\n+      ast_map::node_expr(..) => {\n         ccx.tcx.sess.bug(\"Can't monomorphize an expr\")\n       }\n-      ast_map::node_stmt(*) => {\n+      ast_map::node_stmt(..) => {\n         ccx.tcx.sess.bug(\"Can't monomorphize a stmt\")\n       }\n-      ast_map::node_arg(*) => ccx.tcx.sess.bug(\"Can't monomorphize an arg\"),\n-      ast_map::node_block(*) => {\n+      ast_map::node_arg(..) => ccx.tcx.sess.bug(\"Can't monomorphize an arg\"),\n+      ast_map::node_block(..) => {\n           ccx.tcx.sess.bug(\"Can't monomorphize a block\")\n       }\n-      ast_map::node_local(*) => {\n+      ast_map::node_local(..) => {\n           ccx.tcx.sess.bug(\"Can't monomorphize a local\")\n       }\n-      ast_map::node_callee_scope(*) => {\n+      ast_map::node_callee_scope(..) => {\n           ccx.tcx.sess.bug(\"Can't monomorphize a callee-scope\")\n       }\n       ast_map::node_struct_ctor(_, i, pt) => (pt, i.ident, i.span)\n@@ -208,7 +208,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n     let lldecl = match map_node {\n       ast_map::node_item(i@@ast::item {\n                 node: ast::item_fn(ref decl, _, _, _, ref body),\n-                _\n+                ..\n             }, _) => {\n         let d = mk_lldecl();\n         set_llvm_fn_attrs(i.attrs, d);\n@@ -223,7 +223,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n                  []);\n         d\n       }\n-      ast_map::node_item(*) => {\n+      ast_map::node_item(..) => {\n           ccx.tcx.sess.bug(\"Can't monomorphize this kind of item\")\n       }\n       ast_map::node_foreign_item(i, _, _, _) => {\n@@ -278,13 +278,13 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n       }\n \n       // Ugh -- but this ensures any new variants won't be forgotten\n-      ast_map::node_expr(*) |\n-      ast_map::node_stmt(*) |\n-      ast_map::node_trait_method(*) |\n-      ast_map::node_arg(*) |\n-      ast_map::node_block(*) |\n-      ast_map::node_callee_scope(*) |\n-      ast_map::node_local(*) => {\n+      ast_map::node_expr(..) |\n+      ast_map::node_stmt(..) |\n+      ast_map::node_trait_method(..) |\n+      ast_map::node_arg(..) |\n+      ast_map::node_block(..) |\n+      ast_map::node_callee_scope(..) |\n+      ast_map::node_local(..) => {\n         ccx.tcx.sess.bug(format!(\"Can't monomorphize a {:?}\", map_node))\n       }\n     };"}, {"sha": "5278ff1549543518eb63f6e8c7586f37057ca3e2", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -355,7 +355,7 @@ impl Reflector {\n               let extra = ~[self.c_uint(p.idx)];\n               self.visit(\"param\", extra)\n           }\n-          ty::ty_self(*) => self.leaf(\"self\"),\n+          ty::ty_self(..) => self.leaf(\"self\"),\n           ty::ty_type => self.leaf(\"type\"),\n           ty::ty_opaque_box => self.leaf(\"opaque_box\"),\n           ty::ty_opaque_closure_ptr(ck) => {"}, {"sha": "d641ed42c30dccdc82d36257c7047dd105bb8924", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -359,7 +359,7 @@ pub fn write_content(bcx: @mut Block,\n     let _indenter = indenter();\n \n     match content_expr.node {\n-        ast::ExprLit(@codemap::Spanned { node: ast::lit_str(s, _), _ }) => {\n+        ast::ExprLit(@codemap::Spanned { node: ast::lit_str(s, _), .. }) => {\n             match dest {\n                 Ignore => {\n                     return bcx;\n@@ -456,7 +456,7 @@ pub fn elements_required(bcx: @mut Block, content_expr: &ast::Expr) -> uint {\n     //! Figure out the number of elements we need to store this content\n \n     match content_expr.node {\n-        ast::ExprLit(@codemap::Spanned { node: ast::lit_str(s, _), _ }) => {\n+        ast::ExprLit(@codemap::Spanned { node: ast::lit_str(s, _), .. }) => {\n             s.len()\n         },\n         ast::ExprVec(ref es, _) => es.len(),"}, {"sha": "3e0761e214ce8aada7e7e8138e7913235d1a805d", "filename": "src/librustc/middle/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -283,7 +283,7 @@ impl Type {\n         let box_ty = match store {\n             ty::BoxTraitStore => Type::opaque_box(ctx),\n             ty::UniqTraitStore => Type::unique(ctx, &Type::i8()),\n-            ty::RegionTraitStore(*) => Type::i8()\n+            ty::RegionTraitStore(..) => Type::i8()\n         };\n         Type::struct_([tydesc_ptr, box_ty.ptr_to()], false)\n     }"}, {"sha": "2a8db2ca2a7fb5f0fad58b769c98d5357943052b", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -118,21 +118,21 @@ pub fn sizing_type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n         ty::ty_estr(ty::vstore_box) |\n         ty::ty_evec(_, ty::vstore_uniq) |\n         ty::ty_evec(_, ty::vstore_box) |\n-        ty::ty_box(*) |\n+        ty::ty_box(..) |\n         ty::ty_opaque_box |\n-        ty::ty_uniq(*) |\n-        ty::ty_ptr(*) |\n-        ty::ty_rptr(*) |\n+        ty::ty_uniq(..) |\n+        ty::ty_ptr(..) |\n+        ty::ty_rptr(..) |\n         ty::ty_type |\n-        ty::ty_opaque_closure_ptr(*) => Type::i8p(),\n+        ty::ty_opaque_closure_ptr(..) => Type::i8p(),\n \n-        ty::ty_estr(ty::vstore_slice(*)) |\n-        ty::ty_evec(_, ty::vstore_slice(*)) => {\n+        ty::ty_estr(ty::vstore_slice(..)) |\n+        ty::ty_evec(_, ty::vstore_slice(..)) => {\n             Type::struct_([Type::i8p(), Type::i8p()], false)\n         }\n \n-        ty::ty_bare_fn(*) => Type::i8p(),\n-        ty::ty_closure(*) => Type::struct_([Type::i8p(), Type::i8p()], false),\n+        ty::ty_bare_fn(..) => Type::i8p(),\n+        ty::ty_closure(..) => Type::struct_([Type::i8p(), Type::i8p()], false),\n         ty::ty_trait(_, _, store, _, _) => Type::opaque_trait(cx, store),\n \n         ty::ty_estr(ty::vstore_fixed(size)) => Type::array(&Type::i8(), size as u64),\n@@ -145,12 +145,12 @@ pub fn sizing_type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n             Type::vec(cx.sess.targ_cfg.arch, &sz_ty)\n         }\n \n-        ty::ty_tup(*) | ty::ty_enum(*) => {\n+        ty::ty_tup(..) | ty::ty_enum(..) => {\n             let repr = adt::represent_type(cx, t);\n             adt::sizing_type_of(cx, repr)\n         }\n \n-        ty::ty_struct(*) => {\n+        ty::ty_struct(..) => {\n             if ty::type_is_simd(cx.tcx, t) {\n                 let et = ty::simd_type(cx.tcx, t);\n                 let n = ty::simd_size(cx.tcx, t);\n@@ -161,7 +161,7 @@ pub fn sizing_type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n             }\n         }\n \n-        ty::ty_self(_) | ty::ty_infer(*) | ty::ty_param(*) | ty::ty_err(*) => {\n+        ty::ty_self(_) | ty::ty_infer(..) | ty::ty_param(..) | ty::ty_err(..) => {\n             cx.tcx.sess.bug(format!(\"fictitious type {:?} in sizing_type_of()\", ty::get(t).sty))\n         }\n     };\n@@ -285,7 +285,7 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n       }\n       ty::ty_trait(_, _, store, _, _) => Type::opaque_trait(cx, store),\n       ty::ty_type => cx.tydesc_type.ptr_to(),\n-      ty::ty_tup(*) => {\n+      ty::ty_tup(..) => {\n           let repr = adt::represent_type(cx, t);\n           adt::type_of(cx, repr)\n       }\n@@ -304,10 +304,10 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n               adt::incomplete_type_of(cx, repr, name)\n           }\n       }\n-      ty::ty_self(*) => cx.tcx.sess.unimpl(\"type_of: ty_self\"),\n-      ty::ty_infer(*) => cx.tcx.sess.bug(\"type_of with ty_infer\"),\n-      ty::ty_param(*) => cx.tcx.sess.bug(\"type_of with ty_param\"),\n-      ty::ty_err(*) => cx.tcx.sess.bug(\"type_of with ty_err\")\n+      ty::ty_self(..) => cx.tcx.sess.unimpl(\"type_of: ty_self\"),\n+      ty::ty_infer(..) => cx.tcx.sess.bug(\"type_of with ty_infer\"),\n+      ty::ty_param(..) => cx.tcx.sess.bug(\"type_of with ty_param\"),\n+      ty::ty_err(..) => cx.tcx.sess.bug(\"type_of with ty_err\")\n     };\n \n     debug!(\"--> mapped t={} {:?} to llty={}\",\n@@ -318,7 +318,7 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n \n     // If this was an enum or struct, fill in the type now.\n     match ty::get(t).sty {\n-        ty::ty_enum(*) | ty::ty_struct(*) if !ty::type_is_simd(cx.tcx, t) => {\n+        ty::ty_enum(..) | ty::ty_struct(..) if !ty::type_is_simd(cx.tcx, t) => {\n             let repr = adt::represent_type(cx, t);\n             adt::finish_type_of(cx, repr, &mut llty);\n         }"}, {"sha": "cabe65b097bb6b7c4dbdf90d296e91dae1122127", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 68, "deletions": 68, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -512,8 +512,8 @@ pub enum Region {\n impl Region {\n     pub fn is_bound(&self) -> bool {\n         match self {\n-            &ty::ReEarlyBound(*) => true,\n-            &ty::ReLateBound(*) => true,\n+            &ty::ReEarlyBound(..) => true,\n+            &ty::ReLateBound(..) => true,\n             _ => false\n         }\n     }\n@@ -1506,14 +1506,14 @@ pub fn type_is_bool(ty: t) -> bool { get(ty).sty == ty_bool }\n \n pub fn type_is_self(ty: t) -> bool {\n     match get(ty).sty {\n-        ty_self(*) => true,\n+        ty_self(..) => true,\n         _ => false\n     }\n }\n \n pub fn type_is_structural(ty: t) -> bool {\n     match get(ty).sty {\n-      ty_struct(*) | ty_tup(_) | ty_enum(*) | ty_closure(_) | ty_trait(*) |\n+      ty_struct(..) | ty_tup(_) | ty_enum(..) | ty_closure(_) | ty_trait(..) |\n       ty_evec(_, vstore_fixed(_)) | ty_estr(vstore_fixed(_)) |\n       ty_evec(_, vstore_slice(_)) | ty_estr(vstore_slice(_))\n       => true,\n@@ -1647,7 +1647,7 @@ pub fn type_is_scalar(ty: t) -> bool {\n     match get(ty).sty {\n       ty_nil | ty_bool | ty_char | ty_int(_) | ty_float(_) | ty_uint(_) |\n       ty_infer(IntVar(_)) | ty_infer(FloatVar(_)) | ty_type |\n-      ty_bare_fn(*) | ty_ptr(_) => true,\n+      ty_bare_fn(..) | ty_ptr(_) => true,\n       _ => false\n     }\n }\n@@ -2296,7 +2296,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n                 type_requires(cx, seen, r_ty, mt.ty)\n             }\n \n-            ty_ptr(*) => {\n+            ty_ptr(..) => {\n                 false           // unsafe ptrs can always be NULL\n             }\n \n@@ -2401,7 +2401,7 @@ pub fn type_structurally_contains_uniques(cx: ctxt, ty: t) -> bool {\n \n pub fn type_is_trait(ty: t) -> bool {\n     match get(ty).sty {\n-        ty_trait(*) => true,\n+        ty_trait(..) => true,\n         _ => false\n     }\n }\n@@ -2422,7 +2422,7 @@ pub fn type_is_char(ty: t) -> bool {\n \n pub fn type_is_bare_fn(ty: t) -> bool {\n     match get(ty).sty {\n-        ty_bare_fn(*) => true,\n+        ty_bare_fn(..) => true,\n         _ => false\n     }\n }\n@@ -2448,7 +2448,7 @@ pub fn type_is_signed(ty: t) -> bool {\n pub fn type_is_machine(ty: t) -> bool {\n     match get(ty).sty {\n         ty_int(ast::ty_i) | ty_uint(ast::ty_u) => false,\n-        ty_int(*) | ty_uint(*) | ty_float(*) => true,\n+        ty_int(..) | ty_uint(..) | ty_float(..) => true,\n         _ => false\n     }\n }\n@@ -2497,11 +2497,11 @@ pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n         });\n       }\n \n-      ty_estr(vstore_slice(*)) | ty_evec(_, vstore_slice(*)) => {\n+      ty_estr(vstore_slice(..)) | ty_evec(_, vstore_slice(..)) => {\n         result = false;\n       }\n \n-      ty_infer(*) | ty_self(*) | ty_err => {\n+      ty_infer(..) | ty_self(..) | ty_err => {\n         cx.sess.bug(\"non concrete type in type_is_pod\");\n       }\n     }\n@@ -3010,10 +3010,10 @@ pub fn method_call_type_param_defs(tcx: ctxt,\n           }\n           typeck::method_param(typeck::method_param {\n               trait_id: trt_id,\n-              method_num: n_mth, _}) |\n+              method_num: n_mth, ..}) |\n           typeck::method_object(typeck::method_object {\n               trait_id: trt_id,\n-              method_num: n_mth, _}) => {\n+              method_num: n_mth, ..}) => {\n             // ...trait methods bounds, in contrast, include only the\n             // method bounds, so we must preprend the tps from the\n             // trait itself.  This ought to be harmonized.\n@@ -3068,28 +3068,28 @@ pub fn expr_kind(tcx: ctxt,\n         // generated via DPS.  However, assign_op (e.g., `x += y`) is an\n         // exception, as its result is always unit.\n         return match expr.node {\n-            ast::ExprAssignOp(*) => RvalueStmtExpr,\n+            ast::ExprAssignOp(..) => RvalueStmtExpr,\n             _ => RvalueDpsExpr\n         };\n     }\n \n     match expr.node {\n-        ast::ExprPath(*) | ast::ExprSelf => {\n+        ast::ExprPath(..) | ast::ExprSelf => {\n             match resolve_expr(tcx, expr) {\n-                ast::DefVariant(*) | ast::DefStruct(*) => RvalueDpsExpr,\n+                ast::DefVariant(..) | ast::DefStruct(..) => RvalueDpsExpr,\n \n                 // Fn pointers are just scalar values.\n-                ast::DefFn(*) | ast::DefStaticMethod(*) => RvalueDatumExpr,\n+                ast::DefFn(..) | ast::DefStaticMethod(..) => RvalueDatumExpr,\n \n                 // Note: there is actually a good case to be made that\n                 // def_args, particularly those of immediate type, ought to\n                 // considered rvalues.\n-                ast::DefStatic(*) |\n-                ast::DefBinding(*) |\n-                ast::DefUpvar(*) |\n-                ast::DefArg(*) |\n-                ast::DefLocal(*) |\n-                ast::DefSelf(*) => LvalueExpr,\n+                ast::DefStatic(..) |\n+                ast::DefBinding(..) |\n+                ast::DefUpvar(..) |\n+                ast::DefArg(..) |\n+                ast::DefLocal(..) |\n+                ast::DefSelf(..) => LvalueExpr,\n \n                 def => {\n                     tcx.sess.span_bug(expr.span, format!(\n@@ -3100,30 +3100,30 @@ pub fn expr_kind(tcx: ctxt,\n         }\n \n         ast::ExprUnary(_, ast::UnDeref, _) |\n-        ast::ExprField(*) |\n-        ast::ExprIndex(*) => {\n+        ast::ExprField(..) |\n+        ast::ExprIndex(..) => {\n             LvalueExpr\n         }\n \n-        ast::ExprCall(*) |\n-        ast::ExprMethodCall(*) |\n-        ast::ExprStruct(*) |\n-        ast::ExprTup(*) |\n-        ast::ExprIf(*) |\n-        ast::ExprMatch(*) |\n-        ast::ExprFnBlock(*) |\n-        ast::ExprProc(*) |\n-        ast::ExprDoBody(*) |\n-        ast::ExprBlock(*) |\n-        ast::ExprRepeat(*) |\n-        ast::ExprLit(@codemap::Spanned {node: lit_str(*), _}) |\n+        ast::ExprCall(..) |\n+        ast::ExprMethodCall(..) |\n+        ast::ExprStruct(..) |\n+        ast::ExprTup(..) |\n+        ast::ExprIf(..) |\n+        ast::ExprMatch(..) |\n+        ast::ExprFnBlock(..) |\n+        ast::ExprProc(..) |\n+        ast::ExprDoBody(..) |\n+        ast::ExprBlock(..) |\n+        ast::ExprRepeat(..) |\n+        ast::ExprLit(@codemap::Spanned {node: lit_str(..), ..}) |\n         ast::ExprVstore(_, ast::ExprVstoreSlice) |\n         ast::ExprVstore(_, ast::ExprVstoreMutSlice) |\n-        ast::ExprVec(*) => {\n+        ast::ExprVec(..) => {\n             RvalueDpsExpr\n         }\n \n-        ast::ExprCast(*) => {\n+        ast::ExprCast(..) => {\n             match tcx.node_types.find(&(expr.id as uint)) {\n                 Some(&t) => {\n                     if type_is_trait(t) {\n@@ -3149,24 +3149,24 @@ pub fn expr_kind(tcx: ctxt,\n             }\n         }\n \n-        ast::ExprBreak(*) |\n-        ast::ExprAgain(*) |\n-        ast::ExprRet(*) |\n-        ast::ExprWhile(*) |\n-        ast::ExprLoop(*) |\n-        ast::ExprAssign(*) |\n-        ast::ExprInlineAsm(*) |\n-        ast::ExprAssignOp(*) => {\n+        ast::ExprBreak(..) |\n+        ast::ExprAgain(..) |\n+        ast::ExprRet(..) |\n+        ast::ExprWhile(..) |\n+        ast::ExprLoop(..) |\n+        ast::ExprAssign(..) |\n+        ast::ExprInlineAsm(..) |\n+        ast::ExprAssignOp(..) => {\n             RvalueStmtExpr\n         }\n \n-        ast::ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n+        ast::ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n \n         ast::ExprLogLevel |\n         ast::ExprLit(_) | // Note: lit_str is carved out above\n-        ast::ExprUnary(*) |\n-        ast::ExprAddrOf(*) |\n-        ast::ExprBinary(*) |\n+        ast::ExprUnary(..) |\n+        ast::ExprAddrOf(..) |\n+        ast::ExprBinary(..) |\n         ast::ExprVstore(_, ast::ExprVstoreBox) |\n         ast::ExprVstore(_, ast::ExprVstoreMutBox) |\n         ast::ExprVstore(_, ast::ExprVstoreUniq) => {\n@@ -3175,7 +3175,7 @@ pub fn expr_kind(tcx: ctxt,\n \n         ast::ExprParen(e) => expr_kind(tcx, method_map, e),\n \n-        ast::ExprMac(*) => {\n+        ast::ExprMac(..) => {\n             tcx.sess.span_bug(\n                 expr.span,\n                 \"macro expression remains after expansion\");\n@@ -3188,7 +3188,7 @@ pub fn stmt_node_id(s: &ast::Stmt) -> ast::NodeId {\n       ast::StmtDecl(_, id) | StmtExpr(_, id) | StmtSemi(_, id) => {\n         return id;\n       }\n-      ast::StmtMac(*) => fail!(\"unexpanded macro in trans\")\n+      ast::StmtMac(..) => fail!(\"unexpanded macro in trans\")\n     }\n }\n \n@@ -3356,13 +3356,13 @@ pub fn type_err_to_str(cx: ctxt, err: &type_err) -> ~str {\n                  cx.sess.str_of(values.found))\n         }\n         terr_arg_count => ~\"incorrect number of function parameters\",\n-        terr_regions_does_not_outlive(*) => {\n+        terr_regions_does_not_outlive(..) => {\n             format!(\"lifetime mismatch\")\n         }\n-        terr_regions_not_same(*) => {\n+        terr_regions_not_same(..) => {\n             format!(\"lifetimes are not the same\")\n         }\n-        terr_regions_no_overlap(*) => {\n+        terr_regions_no_overlap(..) => {\n             format!(\"lifetimes do not intersect\")\n         }\n         terr_regions_insufficiently_polymorphic(br, _) => {\n@@ -3482,7 +3482,7 @@ pub fn provided_trait_methods(cx: ctxt, id: ast::DefId) -> ~[@Method] {\n         match cx.items.find(&id.node) {\n             Some(&ast_map::node_item(@ast::item {\n                         node: item_trait(_, _, ref ms),\n-                        _\n+                        ..\n                     }, _)) =>\n                 match ast_util::split_trait_methods(*ms) {\n                    (_, p) => p.map(|m| method(cx, ast_util::local_def(m.id)))\n@@ -3589,7 +3589,7 @@ pub fn impl_trait_ref(cx: ctxt, id: ast::DefId) -> Option<@TraitRef> {\n         match cx.items.find(&id.node) {\n             Some(&ast_map::node_item(@ast::item {\n                                      node: ast::item_impl(_, ref opt_trait, _, _),\n-                                     _},\n+                                     ..},\n                                      _)) => {\n                 match opt_trait {\n                     &Some(ref t) => Some(ty::node_id_to_trait_ref(cx, t.ref_id)),\n@@ -3865,7 +3865,7 @@ pub fn enum_variants(cx: ctxt, id: ast::DefId) -> @~[@VariantInfo] {\n         match cx.items.get_copy(&id.node) {\n           ast_map::node_item(@ast::item {\n                     node: ast::item_enum(ref enum_definition, _),\n-                    _\n+                    ..\n                 }, _) => {\n             let mut last_discriminant: Option<Disr> = None;\n             @enum_definition.variants.iter().map(|variant| {\n@@ -3960,7 +3960,7 @@ pub fn lookup_trait_def(cx: ctxt, did: ast::DefId) -> @ty::TraitDef {\n pub fn each_attr(tcx: ctxt, did: DefId, f: |@MetaItem| -> bool) -> bool {\n     if is_local(did) {\n         match tcx.items.find(&did.node) {\n-            Some(&ast_map::node_item(@ast::item {attrs: ref attrs, _}, _)) =>\n+            Some(&ast_map::node_item(@ast::item {attrs: ref attrs, ..}, _)) =>\n                 attrs.iter().advance(|attr| f(attr.node.value)),\n             _ => tcx.sess.bug(format!(\"has_attr: {:?} is not an item\",\n                                       did))\n@@ -4022,7 +4022,7 @@ pub fn lookup_field_type(tcx: ctxt,\n     }\n     else {\n         match tcx.tcache.find(&id) {\n-           Some(&ty_param_bounds_and_ty {ty, _}) => ty,\n+           Some(&ty_param_bounds_and_ty {ty, ..}) => ty,\n            None => {\n                let tpt = csearch::get_field_type(tcx, struct_id, id);\n                tcx.tcache.insert(id, tpt);\n@@ -4224,7 +4224,7 @@ pub fn normalize_ty(cx: ctxt, t: t) -> t {\n \n         fn fold_vstore(&mut self, vstore: vstore) -> vstore {\n             match vstore {\n-                vstore_fixed(*) | vstore_uniq | vstore_box => vstore,\n+                vstore_fixed(..) | vstore_uniq | vstore_box => vstore,\n                 vstore_slice(_) => vstore_slice(ReStatic)\n             }\n         }\n@@ -4307,7 +4307,7 @@ pub fn eval_repeat_count<T: ExprTyProvider>(tcx: &T, count_expr: &ast::Expr) ->\n             return 0;\n         }\n       },\n-      Err(*) => {\n+      Err(..) => {\n         tcx.ty_ctxt().sess.span_err(count_expr.span,\n                                     \"expected constant integer for repeat count \\\n                                      but found variable\");\n@@ -4574,11 +4574,11 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: @str) -> u64 {\n             ReStatic => {}\n \n             ReEmpty |\n-            ReEarlyBound(*) |\n-            ReLateBound(*) |\n-            ReFree(*) |\n-            ReScope(*) |\n-            ReInfer(*) => {\n+            ReEarlyBound(..) |\n+            ReLateBound(..) |\n+            ReFree(..) |\n+            ReScope(..) |\n+            ReInfer(..) => {\n                 tcx.sess.bug(\"non-static region found when hashing a type\")\n             }\n         }"}, {"sha": "d196956163bf510ab5353c4509050bbb25b1412b", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -192,7 +192,7 @@ pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n         ty::ty_float(_) | ty::ty_type |\n         ty::ty_opaque_closure_ptr(_) |\n         ty::ty_err | ty::ty_opaque_box | ty::ty_infer(_) |\n-        ty::ty_param(*) | ty::ty_self(_) => {\n+        ty::ty_param(..) | ty::ty_self(_) => {\n             (*sty).clone()\n         }\n     }"}, {"sha": "74a51f1dbce23df0659d759d0f4e3c37c4718dc6", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -329,7 +329,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n                             ty::vstore_slice(r) => {\n                                 ty::RegionTraitStore(r)\n                             }\n-                            ty::vstore_fixed(*) => {\n+                            ty::vstore_fixed(..) => {\n                                 tcx.sess.span_err(\n                                     path.span,\n                                     \"@trait, ~trait or &trait are the only supported \\\n@@ -459,7 +459,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n         // Kind bounds on path types are only supported for traits.\n         match a_def {\n             // But don't emit the error if the user meant to do a trait anyway.\n-            ast::DefTrait(*) => { },\n+            ast::DefTrait(..) => { },\n             _ if bounds.is_some() =>\n                 tcx.sess.span_err(ast_ty.span,\n                     \"kind bounds can only be used on trait types\"),\n@@ -810,6 +810,6 @@ fn conv_builtin_bounds(tcx: ty::ctxt, ast_bounds: &Option<OptVec<ast::TyParamBou\n             let mut set = ty::EmptyBuiltinBounds(); set.add(ty::BoundStatic); set\n         }\n         // &'r Trait is sugar for &'r Trait:<no-bounds>.\n-        (&None, ty::RegionTraitStore(*)) => ty::EmptyBuiltinBounds(),\n+        (&None, ty::RegionTraitStore(..)) => ty::EmptyBuiltinBounds(),\n     }\n }"}, {"sha": "809f465fb28cc7722507e93224968bc76d135c8c", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -355,7 +355,7 @@ pub fn check_struct_pat(pcx: &pat_ctxt, pat_id: ast::NodeId, span: Span,\n                 if supplied_def_id == struct_id => {\n             // OK.\n         }\n-        Some(&ast::DefStruct(*)) | Some(&ast::DefVariant(*)) => {\n+        Some(&ast::DefStruct(..)) | Some(&ast::DefVariant(..)) => {\n             let name = pprust::path_to_str(path, tcx.sess.intr());\n             tcx.sess.span_err(span,\n                               format!(\"mismatched types: expected `{}` but found `{}`\",\n@@ -393,7 +393,7 @@ pub fn check_struct_like_enum_variant_pat(pcx: &pat_ctxt,\n             check_struct_pat_fields(pcx, span, path, fields, class_fields,\n                                     variant_id, substitutions, etc);\n         }\n-        Some(&ast::DefStruct(*)) | Some(&ast::DefVariant(*)) => {\n+        Some(&ast::DefStruct(..)) | Some(&ast::DefVariant(..)) => {\n             let name = pprust::path_to_str(path, tcx.sess.intr());\n             tcx.sess.span_err(span,\n                               format!(\"mismatched types: expected `{}` but \\\n@@ -452,8 +452,8 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::Pat, expected: ty::t) {\n         }\n         fcx.write_ty(pat.id, b_ty);\n       }\n-      ast::PatEnum(*) |\n-      ast::PatIdent(*) if pat_is_const(tcx.def_map, pat) => {\n+      ast::PatEnum(..) |\n+      ast::PatIdent(..) if pat_is_const(tcx.def_map, pat) => {\n         let const_did = ast_util::def_id_of_def(tcx.def_map.get_copy(&pat.id));\n         let const_tpt = ty::lookup_item_type(tcx, const_did);\n         demand::suptype(fcx, pat.span, expected, const_tpt.ty);"}, {"sha": "6467be93a8e140d57eaeb5d774c264e02726ec42", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -324,7 +324,7 @@ impl<'self> LookupContext<'self> {\n                 ty_param(p) => {\n                     self.push_inherent_candidates_from_param(self_ty, p);\n                 }\n-                ty_self(*) => {\n+                ty_self(..) => {\n                     // Call is of the form \"self.foo()\" and appears in one\n                     // of a trait's default method implementations.\n                     self.push_inherent_candidates_from_self(self_ty);\n@@ -740,7 +740,7 @@ impl<'self> LookupContext<'self> {\n                     })\n             }\n \n-            ty_closure(*) => {\n+            ty_closure(..) => {\n                 // This case should probably be handled similarly to\n                 // Trait instances.\n                 None\n@@ -760,13 +760,13 @@ impl<'self> LookupContext<'self> {\n \n         let tcx = self.tcx();\n         match ty::get(self_ty).sty {\n-            ty_bare_fn(*) | ty_box(*) | ty_uniq(*) | ty_rptr(*) |\n+            ty_bare_fn(..) | ty_box(..) | ty_uniq(..) | ty_rptr(..) |\n             ty_infer(IntVar(_)) |\n             ty_infer(FloatVar(_)) |\n-            ty_self(_) | ty_param(*) | ty_nil | ty_bot | ty_bool |\n-            ty_char | ty_int(*) | ty_uint(*) |\n-            ty_float(*) | ty_enum(*) | ty_ptr(*) | ty_struct(*) | ty_tup(*) |\n-            ty_estr(*) | ty_evec(*) | ty_trait(*) | ty_closure(*) => {\n+            ty_self(_) | ty_param(..) | ty_nil | ty_bot | ty_bool |\n+            ty_char | ty_int(..) | ty_uint(..) |\n+            ty_float(..) | ty_enum(..) | ty_ptr(..) | ty_struct(..) | ty_tup(..) |\n+            ty_estr(..) | ty_evec(..) | ty_trait(..) | ty_closure(..) => {\n                 self.search_for_some_kind_of_autorefd_method(\n                     AutoPtr, autoderefs, [MutImmutable, MutMutable],\n                     |m,r| ty::mk_rptr(tcx, r, ty::mt {ty:self_ty, mutbl:m}))\n@@ -929,7 +929,7 @@ impl<'self> LookupContext<'self> {\n         assert!(candidate.method_ty.explicit_self != sty_static);\n \n         let transformed_self_ty = match candidate.origin {\n-            method_object(*) => {\n+            method_object(..) => {\n                 // For annoying reasons, we've already handled the\n                 // substitution for object calls.\n                 candidate.method_ty.transformed_self_ty.unwrap()\n@@ -1066,7 +1066,7 @@ impl<'self> LookupContext<'self> {\n             ast::sty_value(_) => {\n                 ty::mk_err() // error reported in `enforce_object_limitations()`\n             }\n-            ast::sty_region(*) | ast::sty_box(*) | ast::sty_uniq(*) => {\n+            ast::sty_region(..) | ast::sty_box(..) | ast::sty_uniq(..) => {\n                 let transformed_self_ty =\n                     method_ty.transformed_self_ty.clone().unwrap();\n                 match ty::get(transformed_self_ty).sty {\n@@ -1108,10 +1108,10 @@ impl<'self> LookupContext<'self> {\n          */\n \n         match candidate.origin {\n-            method_static(*) | method_param(*) => {\n+            method_static(..) | method_param(..) => {\n                 return; // not a call to a trait instance\n             }\n-            method_object(*) => {}\n+            method_object(..) => {}\n         }\n \n         match candidate.method_ty.explicit_self {\n@@ -1129,7 +1129,7 @@ impl<'self> LookupContext<'self> {\n                      through an object\");\n             }\n \n-            ast::sty_region(*) | ast::sty_box(*) | ast::sty_uniq(*) => {}\n+            ast::sty_region(..) | ast::sty_box(..) | ast::sty_uniq(..) => {}\n         }\n \n         if ty::type_has_self(method_fty) { // reason (a) above\n@@ -1155,8 +1155,8 @@ impl<'self> LookupContext<'self> {\n             }\n             // XXX: does this properly enforce this on everything now\n             // that self has been merged in? -sully\n-            method_param(method_param { trait_id: trait_id, _ }) |\n-            method_object(method_object { trait_id: trait_id, _ }) => {\n+            method_param(method_param { trait_id: trait_id, .. }) |\n+            method_object(method_object { trait_id: trait_id, .. }) => {\n                 bad = self.tcx().destructor_for_type.contains_key(&trait_id);\n             }\n         }"}, {"sha": "8caf873a8896ab7a7cd0a0c8fd009400a7216884", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -198,7 +198,7 @@ impl PurityState {\n \n             purity => {\n                 let (purity, def) = match blk.rules {\n-                    ast::UnsafeBlock(*) => (ast::unsafe_fn, blk.id),\n+                    ast::UnsafeBlock(..) => (ast::unsafe_fn, blk.id),\n                     ast::DefaultBlock => (purity, self.def),\n                 };\n                 PurityState{ def: def,\n@@ -622,7 +622,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n         let trait_def = ty::lookup_trait_def(ccx.tcx, local_def(it.id));\n         for trait_method in (*trait_methods).iter() {\n             match *trait_method {\n-              required(*) => {\n+              required(..) => {\n                 // Nothing to do, since required methods don't have\n                 // bodies to check.\n               }\n@@ -633,7 +633,7 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n             }\n         }\n       }\n-      ast::item_struct(*) => {\n+      ast::item_struct(..) => {\n         check_struct(ccx, it.id, it.span);\n       }\n       ast::item_ty(ref t, ref generics) => {\n@@ -1354,8 +1354,8 @@ pub fn check_lit(fcx: @mut FnCtxt, lit: @ast::lit) -> ty::t {\n     let tcx = fcx.ccx.tcx;\n \n     match lit.node {\n-      ast::lit_str(*) => ty::mk_estr(tcx, ty::vstore_slice(ty::ReStatic)),\n-      ast::lit_binary(*) => {\n+      ast::lit_str(..) => ty::mk_estr(tcx, ty::vstore_slice(ty::ReStatic)),\n+      ast::lit_binary(..) => {\n           ty::mk_evec(tcx, ty::mt{ ty: ty::mk_u8(), mutbl: ast::MutImmutable },\n                       ty::vstore_slice(ty::ReStatic))\n       }\n@@ -1743,9 +1743,9 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             };\n             for (i, arg) in args.iter().take(t).enumerate() {\n                 let is_block = match arg.node {\n-                    ast::ExprFnBlock(*) |\n-                    ast::ExprProc(*) |\n-                    ast::ExprDoBody(*) => true,\n+                    ast::ExprFnBlock(..) |\n+                    ast::ExprProc(..) |\n+                    ast::ExprDoBody(..) => true,\n                     _ => false\n                 };\n \n@@ -1874,8 +1874,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         };\n \n         let fn_sig = match *fn_sty {\n-            ty::ty_bare_fn(ty::BareFnTy {sig: ref sig, _}) |\n-            ty::ty_closure(ty::ClosureTy {sig: ref sig, _}) => sig,\n+            ty::ty_bare_fn(ty::BareFnTy {sig: ref sig, ..}) |\n+            ty::ty_closure(ty::ClosureTy {sig: ref sig, ..}) => sig,\n             _ => {\n                 fcx.type_error_message(call_expr.span, |actual| {\n                     format!(\"expected function but \\\n@@ -2573,7 +2573,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n     match expr.node {\n       ast::ExprVstore(ev, vst) => {\n         let typ = match ev.node {\n-          ast::ExprLit(@codemap::Spanned { node: ast::lit_str(*), _ }) => {\n+          ast::ExprLit(@codemap::Spanned { node: ast::lit_str(..), .. }) => {\n             let tt = ast_expr_vstore_to_vstore(fcx, ev, vst);\n             ty::mk_estr(tcx, tt)\n           }\n@@ -2723,13 +2723,13 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                         }\n                         None => {\n                             match *sty {\n-                                ty::ty_enum(*) => {\n+                                ty::ty_enum(..) => {\n                                     tcx.sess.span_err(\n                                         expr.span,\n                                         \"can only dereference enums with a single variant which \\\n                                          has a single argument\");\n                                 }\n-                                ty::ty_struct(*) => {\n+                                ty::ty_struct(..) => {\n                                     tcx.sess.span_err(\n                                         expr.span,\n                                         \"can only dereference structs with one anonymous field\");\n@@ -2890,7 +2890,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             fcx.write_nil(id);\n         }\n       }\n-      ast::ExprForLoop(*) =>\n+      ast::ExprForLoop(..) =>\n           fail!(\"non-desugared expr_for_loop\"),\n       ast::ExprLoop(ref body, _) => {\n         check_block_no_value(fcx, (body));\n@@ -3012,7 +3012,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         else {\n             match ty::get(t_1).sty {\n                 // This will be looked up later on\n-                ty::ty_trait(*) => (),\n+                ty::ty_trait(..) => (),\n \n                 _ => {\n                     if ty::type_is_nil(t_e) {\n@@ -3322,7 +3322,7 @@ pub fn check_stmt(fcx: @mut FnCtxt, stmt: @ast::Stmt)  {\n         saw_bot |= ty::type_is_bot(expr_ty);\n         saw_err |= ty::type_is_error(expr_ty);\n       }\n-      ast::StmtMac(*) => fcx.ccx.tcx.sess.bug(\"unexpanded macro\")\n+      ast::StmtMac(..) => fcx.ccx.tcx.sess.bug(\"unexpanded macro\")\n     }\n     if saw_bot {\n         fcx.write_bot(node_id);\n@@ -3371,7 +3371,7 @@ pub fn check_block_with_expected(fcx: @mut FnCtxt,\n             let s_ty = fcx.node_ty(s_id);\n             if last_was_bot && !warned && match s.node {\n                   ast::StmtDecl(@codemap::Spanned { node: ast::DeclLocal(_),\n-                                                 _}, _) |\n+                                                 ..}, _) |\n                   ast::StmtExpr(_, _) | ast::StmtSemi(_, _) => {\n                     true\n                   }\n@@ -3656,28 +3656,28 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n       ast::DefTrait(_) |\n       ast::DefTy(_) |\n       ast::DefPrimTy(_) |\n-      ast::DefTyParam(*)=> {\n+      ast::DefTyParam(..)=> {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found type\");\n       }\n-      ast::DefMod(*) | ast::DefForeignMod(*) => {\n+      ast::DefMod(..) | ast::DefForeignMod(..) => {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found module\");\n       }\n-      ast::DefUse(*) => {\n+      ast::DefUse(..) => {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found use\");\n       }\n-      ast::DefRegion(*) => {\n+      ast::DefRegion(..) => {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found region\");\n       }\n-      ast::DefTyParamBinder(*) => {\n+      ast::DefTyParamBinder(..) => {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found type parameter\");\n       }\n-      ast::DefLabel(*) => {\n+      ast::DefLabel(..) => {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found label\");\n       }\n-      ast::DefSelfTy(*) => {\n+      ast::DefSelfTy(..) => {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found self ty\");\n       }\n-      ast::DefMethod(*) => {\n+      ast::DefMethod(..) => {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found method\");\n       }\n     }\n@@ -3905,7 +3905,7 @@ pub fn check_bounds_are_used(ccx: @mut CrateCtxt,\n \n     ty::walk_ty(ty, |t| {\n             match ty::get(t).sty {\n-                ty::ty_param(param_ty {idx, _}) => {\n+                ty::ty_param(param_ty {idx, ..}) => {\n                     debug!(\"Found use of ty param \\\\#{}\", idx);\n                     tps_used[idx] = true;\n                 }"}, {"sha": "57781fbe6cc52295aea569da6e4a04adb9968971", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 45, "deletions": 45, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -164,7 +164,7 @@ pub fn regionck_fn(fcx: @mut FnCtxt, blk: &ast::Block) {\n }\n \n impl Visitor<()> for Rcx {\n-    // (*) FIXME(#3238) should use visit_pat, not visit_arm/visit_local,\n+    // (..) FIXME(#3238) should use visit_pat, not visit_arm/visit_local,\n     // However, right now we run into an issue whereby some free\n     // regions are not properly related if they appear within the\n     // types of arguments that must be inferred. This could be\n@@ -176,7 +176,7 @@ impl Visitor<()> for Rcx {\n \n     fn visit_expr(&mut self, ex:@ast::Expr, _:()) { visit_expr(self, ex); }\n \n-        //visit_pat: visit_pat, // (*) see above\n+        //visit_pat: visit_pat, // (..) see above\n \n     fn visit_arm(&mut self, a:&ast::Arm, _:()) { visit_arm(self, a); }\n \n@@ -264,20 +264,20 @@ fn visit_expr(rcx: &mut Rcx, expr: @ast::Expr) {\n         // operators is a hopeless mess and I can't figure out how to\n         // represent it. - ndm\n         //\n-        // ast::expr_assign_op(*) |\n+        // ast::expr_assign_op(..) |\n \n-        ast::ExprIndex(*) |\n-        ast::ExprBinary(*) |\n-        ast::ExprUnary(*) if has_method_map => {\n+        ast::ExprIndex(..) |\n+        ast::ExprBinary(..) |\n+        ast::ExprUnary(..) if has_method_map => {\n             tcx.region_maps.record_cleanup_scope(expr.id);\n         }\n         ast::ExprBinary(_, ast::BiAnd, lhs, rhs) |\n         ast::ExprBinary(_, ast::BiOr, lhs, rhs) => {\n             tcx.region_maps.record_cleanup_scope(lhs.id);\n             tcx.region_maps.record_cleanup_scope(rhs.id);\n         }\n-        ast::ExprCall(*) |\n-        ast::ExprMethodCall(*) => {\n+        ast::ExprCall(..) |\n+        ast::ExprMethodCall(..) => {\n             tcx.region_maps.record_cleanup_scope(expr.id);\n         }\n         ast::ExprMatch(_, ref arms) => {\n@@ -427,7 +427,7 @@ fn visit_expr(rcx: &mut Rcx, expr: @ast::Expr) {\n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprFnBlock(*) | ast::ExprProc(*) => {\n+        ast::ExprFnBlock(..) | ast::ExprProc(..) => {\n             check_expr_fn_block(rcx, expr);\n         }\n \n@@ -462,7 +462,7 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n             match ty::get(function_type).sty {\n                 ty::ty_closure(\n                     ty::ClosureTy {\n-                        sigil: ast::BorrowedSigil, region: region, _}) => {\n+                        sigil: ast::BorrowedSigil, region: region, ..}) => {\n                     if get_freevars(tcx, expr.id).is_empty() {\n                         // No free variables means that the environment\n                         // will be NULL at runtime and hence the closure\n@@ -504,7 +504,7 @@ fn constrain_callee(rcx: &mut Rcx,\n \n     let callee_ty = rcx.resolve_node_type(callee_id);\n     match ty::get(callee_ty).sty {\n-        ty::ty_bare_fn(*) => { }\n+        ty::ty_bare_fn(..) => { }\n         ty::ty_closure(ref closure_ty) => {\n             rcx.fcx.mk_subr(true, infer::InvokeClosure(callee_expr.span),\n                             call_region, closure_ty.region);\n@@ -1004,7 +1004,7 @@ pub mod guarantor {\n                 guarantor(rcx, e)\n             }\n \n-            ast::ExprPath(*) | ast::ExprSelf => {\n+            ast::ExprPath(..) | ast::ExprSelf => {\n                 // Either a variable or constant and hence resides\n                 // in constant memory or on the stack frame.  Either way,\n                 // not guaranteed by a region pointer.\n@@ -1013,39 +1013,39 @@ pub mod guarantor {\n \n             // All of these expressions are rvalues and hence their\n             // value is not guaranteed by a region pointer.\n-            ast::ExprInlineAsm(*) |\n-            ast::ExprMac(*) |\n+            ast::ExprInlineAsm(..) |\n+            ast::ExprMac(..) |\n             ast::ExprLit(_) |\n-            ast::ExprUnary(*) |\n-            ast::ExprAddrOf(*) |\n-            ast::ExprBinary(*) |\n-            ast::ExprVstore(*) |\n-            ast::ExprBreak(*) |\n-            ast::ExprAgain(*) |\n-            ast::ExprRet(*) |\n+            ast::ExprUnary(..) |\n+            ast::ExprAddrOf(..) |\n+            ast::ExprBinary(..) |\n+            ast::ExprVstore(..) |\n+            ast::ExprBreak(..) |\n+            ast::ExprAgain(..) |\n+            ast::ExprRet(..) |\n             ast::ExprLogLevel |\n-            ast::ExprWhile(*) |\n-            ast::ExprLoop(*) |\n-            ast::ExprAssign(*) |\n-            ast::ExprAssignOp(*) |\n-            ast::ExprCast(*) |\n-            ast::ExprCall(*) |\n-            ast::ExprMethodCall(*) |\n-            ast::ExprStruct(*) |\n-            ast::ExprTup(*) |\n-            ast::ExprIf(*) |\n-            ast::ExprMatch(*) |\n-            ast::ExprFnBlock(*) |\n-            ast::ExprProc(*) |\n-            ast::ExprDoBody(*) |\n-            ast::ExprBlock(*) |\n-            ast::ExprRepeat(*) |\n-            ast::ExprVec(*) => {\n+            ast::ExprWhile(..) |\n+            ast::ExprLoop(..) |\n+            ast::ExprAssign(..) |\n+            ast::ExprAssignOp(..) |\n+            ast::ExprCast(..) |\n+            ast::ExprCall(..) |\n+            ast::ExprMethodCall(..) |\n+            ast::ExprStruct(..) |\n+            ast::ExprTup(..) |\n+            ast::ExprIf(..) |\n+            ast::ExprMatch(..) |\n+            ast::ExprFnBlock(..) |\n+            ast::ExprProc(..) |\n+            ast::ExprDoBody(..) |\n+            ast::ExprBlock(..) |\n+            ast::ExprRepeat(..) |\n+            ast::ExprVec(..) => {\n                 assert!(!ty::expr_is_lval(\n                     rcx.fcx.tcx(), rcx.fcx.inh.method_map, expr));\n                 None\n             }\n-            ast::ExprForLoop(*) => fail!(\"non-desugared expr_for_loop\"),\n+            ast::ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n         }\n     }\n \n@@ -1056,7 +1056,7 @@ pub mod guarantor {\n         debug!(\"before adjustments, cat={:?}\", expr_ct.cat);\n \n         match rcx.fcx.inh.adjustments.find(&expr.id) {\n-            Some(&@ty::AutoAddEnv(*)) => {\n+            Some(&@ty::AutoAddEnv(..)) => {\n                 // This is basically an rvalue, not a pointer, no regions\n                 // involved.\n                 expr_ct.cat = ExprCategorization {\n@@ -1166,14 +1166,14 @@ pub mod guarantor {\n             ty::ty_estr(ty::vstore_slice(r)) => {\n                 BorrowedPointer(r)\n             }\n-            ty::ty_uniq(*) |\n+            ty::ty_uniq(..) |\n             ty::ty_estr(ty::vstore_uniq) |\n             ty::ty_trait(_, _, ty::UniqTraitStore, _, _) |\n             ty::ty_evec(_, ty::vstore_uniq) => {\n                 OwnedPointer\n             }\n-            ty::ty_box(*) |\n-            ty::ty_ptr(*) |\n+            ty::ty_box(..) |\n+            ty::ty_ptr(..) |\n             ty::ty_evec(_, ty::vstore_box) |\n             ty::ty_trait(_, _, ty::BoxTraitStore, _, _) |\n             ty::ty_estr(ty::vstore_box) => {\n@@ -1255,8 +1255,8 @@ pub mod guarantor {\n                 let r = ty::ty_region(rcx.fcx.tcx(), pat.span, rptr_ty);\n                 link_ref_bindings_in_pat(rcx, p, Some(r));\n             }\n-            ast::PatLit(*) => {}\n-            ast::PatRange(*) => {}\n+            ast::PatLit(..) => {}\n+            ast::PatRange(..) => {}\n             ast::PatVec(ref before, ref slice, ref after) => {\n                 let vec_ty = rcx.resolve_node_type(pat.id);\n                 let vstore = ty::ty_vstore(vec_ty);"}, {"sha": "abdab02dedd7ac2973be13aba6c2712faa033cf0", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -248,7 +248,7 @@ fn lookup_vtable(vcx: &VtableContext,\n     // If the type is self or a param, we look at the trait/supertrait\n     // bounds to see if they include the trait we are looking for.\n     let vtable_opt = match ty::get(ty).sty {\n-        ty::ty_param(param_ty {idx: n, _}) => {\n+        ty::ty_param(param_ty {idx: n, ..}) => {\n             let type_param_bounds: &[@ty::TraitRef] =\n                 vcx.param_env.type_param_bounds[n].trait_bounds;\n             lookup_vtable_from_bounds(vcx,\n@@ -559,7 +559,7 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n \n     let cx = fcx.ccx;\n     match ex.node {\n-      ast::ExprPath(*) => {\n+      ast::ExprPath(..) => {\n         fcx.opt_node_ty_substs(ex.id, |substs| {\n             debug!(\"vtable resolution on parameter bounds for expr {}\",\n                    ex.repr(fcx.tcx()));\n@@ -631,15 +631,15 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n                   match (&ty::get(ty).sty, store) {\n                       (&ty::ty_box(mt), ty::BoxTraitStore) |\n                       (&ty::ty_uniq(mt), ty::UniqTraitStore) |\n-                      (&ty::ty_rptr(_, mt), ty::RegionTraitStore(*))\n+                      (&ty::ty_rptr(_, mt), ty::RegionTraitStore(..))\n                         if !mutability_allowed(mt.mutbl, target_mutbl) => {\n                           fcx.tcx().sess.span_err(ex.span,\n                                                   format!(\"types differ in mutability\"));\n                       }\n \n                       (&ty::ty_box(mt), ty::BoxTraitStore) |\n                       (&ty::ty_uniq(mt), ty::UniqTraitStore) |\n-                      (&ty::ty_rptr(_, mt), ty::RegionTraitStore(*)) => {\n+                      (&ty::ty_rptr(_, mt), ty::RegionTraitStore(..)) => {\n                           let location_info =\n                               &location_info_for_expr(ex);\n                           let vcx = fcx.vtable_context();"}, {"sha": "f7a1662ca12640805b7a0b30052f6828c7907800", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -75,15 +75,15 @@ pub fn get_base_type(inference_context: @mut InferCtxt,\n     }\n \n     match get(resolved_type).sty {\n-        ty_enum(*) | ty_trait(*) | ty_struct(*) => {\n+        ty_enum(..) | ty_trait(..) | ty_struct(..) => {\n             debug!(\"(getting base type) found base type\");\n             Some(resolved_type)\n         }\n \n-        ty_nil | ty_bot | ty_bool | ty_char | ty_int(*) | ty_uint(*) | ty_float(*) |\n-        ty_estr(*) | ty_evec(*) | ty_bare_fn(*) | ty_closure(*) | ty_tup(*) |\n-        ty_infer(*) | ty_param(*) | ty_self(*) | ty_type | ty_opaque_box |\n-        ty_opaque_closure_ptr(*) | ty_unboxed_vec(*) | ty_err | ty_box(_) |\n+        ty_nil | ty_bot | ty_bool | ty_char | ty_int(..) | ty_uint(..) | ty_float(..) |\n+        ty_estr(..) | ty_evec(..) | ty_bare_fn(..) | ty_closure(..) | ty_tup(..) |\n+        ty_infer(..) | ty_param(..) | ty_self(..) | ty_type | ty_opaque_box |\n+        ty_opaque_closure_ptr(..) | ty_unboxed_vec(..) | ty_err | ty_box(_) |\n         ty_uniq(_) | ty_ptr(_) | ty_rptr(_, _) => {\n             debug!(\"(getting base type) no base type; found {:?}\",\n                    get(original_type).sty);\n@@ -562,7 +562,7 @@ impl CoherenceChecker {\n                             }\n                             Some(&node_item(item, _)) => {\n                                 match item.node {\n-                                    item_struct(*) | item_enum(*) => true,\n+                                    item_struct(..) | item_enum(..) => true,\n                                     _ => false,\n                                 }\n                             }"}, {"sha": "11cbcd4cbdda2d93f3ed3496fe505b9d34553e28", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -74,7 +74,7 @@ impl visit::Visitor<()> for CollectItemTypesVisitor {\n pub fn collect_item_types(ccx: @mut CrateCtxt, crate: &ast::Crate) {\n     fn collect_intrinsic_type(ccx: &CrateCtxt,\n                               lang_item: ast::DefId) {\n-        let ty::ty_param_bounds_and_ty { ty: ty, _ } =\n+        let ty::ty_param_bounds_and_ty { ty: ty, .. } =\n             ccx.get_item_ty(lang_item);\n         ccx.tcx.intrinsic_defs.insert(lang_item, ty);\n     }\n@@ -184,7 +184,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n     match tcx.items.get_copy(&trait_id) {\n         ast_map::node_item(@ast::item {\n             node: ast::item_trait(ref generics, _, ref ms),\n-            _\n+            ..\n         }, _) => {\n             let trait_ty_generics =\n                 ty_generics(ccx, generics, 0);\n@@ -811,7 +811,7 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n             tcx.tcache.insert(local_def(it.id), tpt);\n             return tpt;\n         }\n-        ast::item_trait(*) => {\n+        ast::item_trait(..) => {\n             tcx.sess.span_bug(\n                 it.span,\n                 format!(\"Invoked ty_of_item on trait\"));\n@@ -827,9 +827,9 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n             tcx.tcache.insert(local_def(it.id), tpt);\n             return tpt;\n         }\n-        ast::item_impl(*) | ast::item_mod(_) |\n+        ast::item_impl(..) | ast::item_mod(_) |\n         ast::item_foreign_mod(_) => fail!(),\n-        ast::item_mac(*) => fail!(\"item macros unimplemented\")\n+        ast::item_mac(..) => fail!(\"item macros unimplemented\")\n     }\n }\n "}, {"sha": "f4c3c33dbb35db8477a18728c95273e54a965e84", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -115,13 +115,13 @@ impl Coerce {\n                 });\n             }\n \n-            ty::ty_closure(ty::ClosureTy {sigil: ast::BorrowedSigil, _}) => {\n+            ty::ty_closure(ty::ClosureTy {sigil: ast::BorrowedSigil, ..}) => {\n                 return self.unpack_actual_value(a, |sty_a| {\n                     self.coerce_borrowed_fn(a, sty_a, b)\n                 });\n             }\n \n-            ty::ty_trait(_, _, ty::RegionTraitStore(*), m, _) => {\n+            ty::ty_trait(_, _, ty::RegionTraitStore(..), m, _) => {\n                 return self.unpack_actual_value(a, |sty_a| {\n                     self.coerce_borrowed_object(a, sty_a, b, m)\n                 });"}, {"sha": "04ba1bcb31fd6f72848a17d0ae2c4b431b321930", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -472,7 +472,7 @@ impl ErrorReportingHelpers for InferCtxt {\n             infer::BoundRegionInTypeOrImpl(_) => {\n                 format!(\" for region in type/impl\")\n             }\n-            infer::BoundRegionInCoherence(*) => {\n+            infer::BoundRegionInCoherence(..) => {\n                 format!(\" for coherence check\")\n             }\n         };"}, {"sha": "f63779cd8b8ce718b9864dbaf01c459a7bd02c96", "filename": "src/librustc/middle/typeck/infer/region_inference/doc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -192,10 +192,10 @@ going on:\n     fn weird() {\n         let mut x: ~Foo = ~Foo { ... };\n         'a: add(&mut (*x).f,\n-                'b: inc(&mut (*x).f)) // (*)\n+                'b: inc(&mut (*x).f)) // (..)\n     }\n \n-The important part is the line marked `(*)` which contains a call to\n+The important part is the line marked `(..)` which contains a call to\n `add()`. The first argument is a mutable borrow of the field `f`.  The\n second argument also borrows the field `f`. Now, in the current borrow\n checker, the first borrow is given the lifetime of the call to\n@@ -248,7 +248,7 @@ this similar but unsound example:\n     }\n     fn weird() {\n         let mut x: ~Foo = ~Foo { ... };\n-        'a: add(&mut (*x).f, consume(x)) // (*)\n+        'a: add(&mut (*x).f, consume(x)) // (..)\n     }\n \n In this case, the second argument to `add` actually consumes `x`, thus"}, {"sha": "1a36d2c54d8533506d1c423aeee355c0ca538c6a", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -244,10 +244,10 @@ impl RegionVarBindings {\n \n         debug!(\"RegionVarBindings: make_subregion({:?}, {:?})\", sub, sup);\n         match (sub, sup) {\n-          (ReEarlyBound(*), _) |\n-          (ReLateBound(*), _) |\n-          (_, ReEarlyBound(*)) |\n-          (_, ReLateBound(*)) => {\n+          (ReEarlyBound(..), _) |\n+          (ReLateBound(..), _) |\n+          (_, ReEarlyBound(..)) |\n+          (_, ReLateBound(..)) => {\n             self.tcx.sess.span_bug(\n                 origin.span(),\n                 format!(\"Cannot relate bound region: {} <= {}\",\n@@ -493,10 +493,10 @@ impl RegionVarBindings {\n \n     fn lub_concrete_regions(&self, a: Region, b: Region) -> Region {\n         match (a, b) {\n-          (ReLateBound(*), _) |\n-          (_, ReLateBound(*)) |\n-          (ReEarlyBound(*), _) |\n-          (_, ReEarlyBound(*)) => {\n+          (ReLateBound(..), _) |\n+          (_, ReLateBound(..)) |\n+          (ReEarlyBound(..), _) |\n+          (_, ReEarlyBound(..)) => {\n             self.tcx.sess.bug(\n                 format!(\"Cannot relate bound region: LUB({}, {})\",\n                         a.repr(self.tcx),\n@@ -553,8 +553,8 @@ impl RegionVarBindings {\n \n           // For these types, we cannot define any additional\n           // relationship:\n-          (ReInfer(ReSkolemized(*)), _) |\n-          (_, ReInfer(ReSkolemized(*))) => {\n+          (ReInfer(ReSkolemized(..)), _) |\n+          (_, ReInfer(ReSkolemized(..))) => {\n             if a == b {a} else {ReStatic}\n           }\n         }\n@@ -597,10 +597,10 @@ impl RegionVarBindings {\n                          -> cres<Region> {\n         debug!(\"glb_concrete_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n-            (ReLateBound(*), _) |\n-            (_, ReLateBound(*)) |\n-            (ReEarlyBound(*), _) |\n-            (_, ReEarlyBound(*)) => {\n+            (ReLateBound(..), _) |\n+            (_, ReLateBound(..)) |\n+            (ReEarlyBound(..), _) |\n+            (_, ReEarlyBound(..)) => {\n               self.tcx.sess.bug(\n                   format!(\"Cannot relate bound region: GLB({}, {})\",\n                           a.repr(self.tcx),\n@@ -649,8 +649,8 @@ impl RegionVarBindings {\n \n             // For these types, we cannot define any additional\n             // relationship:\n-            (ReInfer(ReSkolemized(*)), _) |\n-            (_, ReInfer(ReSkolemized(*))) => {\n+            (ReInfer(ReSkolemized(..)), _) |\n+            (_, ReInfer(ReSkolemized(..))) => {\n                 if a == b {\n                     Ok(a)\n                 } else {\n@@ -779,11 +779,11 @@ impl RegionVarBindings {\n                   }\n                 }\n               }\n-              ConstrainVarSubReg(*) => {\n+              ConstrainVarSubReg(..) => {\n                 // This is a contraction constraint.  Ignore it.\n                 false\n               }\n-              ConstrainRegSubReg(*) => {\n+              ConstrainRegSubReg(..) => {\n                 // No region variables involved. Ignore.\n                 false\n               }\n@@ -831,7 +831,7 @@ impl RegionVarBindings {\n                    var_data: &mut [VarData]) {\n         self.iterate_until_fixed_point(\"Contraction\", |constraint| {\n             match *constraint {\n-              ConstrainRegSubVar(*) => {\n+              ConstrainRegSubVar(..) => {\n                 // This is an expansion constraint.  Ignore.\n                 false\n               }\n@@ -848,7 +848,7 @@ impl RegionVarBindings {\n                 let a_data = &mut var_data[a_vid.to_uint()];\n                 self.contract_node(a_vid, a_data, b_region)\n               }\n-              ConstrainRegSubReg(*) => {\n+              ConstrainRegSubReg(..) => {\n                 // No region variables involved. Ignore.\n                 false\n               }\n@@ -934,9 +934,9 @@ impl RegionVarBindings {\n     {\n         for (constraint, _) in self.constraints.iter() {\n             let (sub, sup) = match *constraint {\n-                ConstrainVarSubVar(*) |\n-                ConstrainRegSubVar(*) |\n-                ConstrainVarSubReg(*) => {\n+                ConstrainVarSubVar(..) |\n+                ConstrainRegSubVar(..) |\n+                ConstrainVarSubReg(..) => {\n                     continue;\n                 }\n                 ConstrainRegSubReg(sub, sup) => {\n@@ -1065,7 +1065,7 @@ impl RegionVarBindings {\n                                    dummy_idx,\n                                    *constraint);\n                 }\n-                ConstrainRegSubReg(*) => {\n+                ConstrainRegSubReg(..) => {\n                     // Relations between two concrete regions do not\n                     // require an edge in the graph.\n                 }\n@@ -1214,7 +1214,7 @@ impl RegionVarBindings {\n             process_edges(self, &mut state, graph, node_idx, dir);\n         }\n \n-        let WalkState {result, dup_found, _} = state;\n+        let WalkState {result, dup_found, ..} = state;\n         return (result, dup_found);\n \n         fn process_edges(this: &RegionVarBindings,\n@@ -1243,7 +1243,7 @@ impl RegionVarBindings {\n                         });\n                     }\n \n-                    ConstrainRegSubReg(*) => {}\n+                    ConstrainRegSubReg(..) => {}\n                 }\n                 true\n             });"}, {"sha": "a48e7b5d0f0e70feb9107e5856b35f10827c0794", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -126,14 +126,14 @@ impl Env {\n             }\n \n             return match it.node {\n-                ast::item_const(*) | ast::item_fn(*) |\n-                ast::item_foreign_mod(*) | ast::item_ty(*) => {\n+                ast::item_const(..) | ast::item_fn(..) |\n+                ast::item_foreign_mod(..) | ast::item_ty(..) => {\n                     None\n                 }\n \n-                ast::item_enum(*) | ast::item_struct(*) |\n-                ast::item_trait(*) | ast::item_impl(*) |\n-                ast::item_mac(*) => {\n+                ast::item_enum(..) | ast::item_struct(..) |\n+                ast::item_trait(..) | ast::item_impl(..) |\n+                ast::item_mac(..) => {\n                     None\n                 }\n "}, {"sha": "ac7e6940b60707e40e7c9a264be6b950edcbad9c", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -344,7 +344,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n     let tcx = ccx.tcx;\n     let main_t = ty::node_id_to_type(tcx, main_id);\n     match ty::get(main_t).sty {\n-        ty::ty_bare_fn(*) => {\n+        ty::ty_bare_fn(..) => {\n             match tcx.items.find(&main_id) {\n                 Some(&ast_map::node_item(it,_)) => {\n                     match it.node {"}, {"sha": "95fe4ec34c6fad576231ab9784696bafab1c99bc", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -338,7 +338,7 @@ impl<'self> Visitor<()> for TermsContext<'self> {\n         // tcx, we rely on the fact that all inferreds for a particular\n         // item are assigned continuous indices.\n         match item.node {\n-            ast::item_trait(*) => {\n+            ast::item_trait(..) => {\n                 self.add_inferred(item.id, SelfParam, 0, item.id);\n             }\n             _ => { }\n@@ -372,13 +372,13 @@ impl<'self> Visitor<()> for TermsContext<'self> {\n                 visit::walk_item(self, item, ());\n             }\n \n-            ast::item_impl(*) |\n-            ast::item_static(*) |\n-            ast::item_fn(*) |\n-            ast::item_mod(*) |\n-            ast::item_foreign_mod(*) |\n-            ast::item_ty(*) |\n-            ast::item_mac(*) => {\n+            ast::item_impl(..) |\n+            ast::item_static(..) |\n+            ast::item_fn(..) |\n+            ast::item_mod(..) |\n+            ast::item_foreign_mod(..) |\n+            ast::item_ty(..) |\n+            ast::item_mac(..) => {\n                 visit::walk_item(self, item, ());\n             }\n         }\n@@ -460,7 +460,7 @@ impl<'self> Visitor<()> for ConstraintContext<'self> {\n                 }\n             }\n \n-            ast::item_struct(*) => {\n+            ast::item_struct(..) => {\n                 let struct_fields = ty::lookup_struct_fields(tcx, did);\n                 for field_info in struct_fields.iter() {\n                     assert_eq!(field_info.id.crate, ast::LOCAL_CRATE);\n@@ -469,7 +469,7 @@ impl<'self> Visitor<()> for ConstraintContext<'self> {\n                 }\n             }\n \n-            ast::item_trait(*) => {\n+            ast::item_trait(..) => {\n                 let methods = ty::trait_methods(tcx, did);\n                 for method in methods.iter() {\n                     match method.transformed_self_ty {\n@@ -493,13 +493,13 @@ impl<'self> Visitor<()> for ConstraintContext<'self> {\n                 }\n             }\n \n-            ast::item_static(*) |\n-            ast::item_fn(*) |\n-            ast::item_mod(*) |\n-            ast::item_foreign_mod(*) |\n-            ast::item_ty(*) |\n-            ast::item_impl(*) |\n-            ast::item_mac(*) => {\n+            ast::item_static(..) |\n+            ast::item_fn(..) |\n+            ast::item_mod(..) |\n+            ast::item_foreign_mod(..) |\n+            ast::item_ty(..) |\n+            ast::item_impl(..) |\n+            ast::item_mac(..) => {\n                 visit::walk_item(self, item, ());\n             }\n         }\n@@ -659,7 +659,7 @@ impl<'self> ConstraintContext<'self> {\n                                                  substs, variance);\n             }\n \n-            ty::ty_param(ty::param_ty { def_id: ref def_id, _ }) => {\n+            ty::ty_param(ty::param_ty { def_id: ref def_id, .. }) => {\n                 assert_eq!(def_id.crate, ast::LOCAL_CRATE);\n                 match self.terms_cx.inferred_map.find(&def_id.node) {\n                     Some(&index) => {\n@@ -679,19 +679,19 @@ impl<'self> ConstraintContext<'self> {\n                 self.add_constraint(index, variance);\n             }\n \n-            ty::ty_bare_fn(ty::BareFnTy { sig: ref sig, _ }) => {\n+            ty::ty_bare_fn(ty::BareFnTy { sig: ref sig, .. }) => {\n                 self.add_constraints_from_sig(sig, variance);\n             }\n \n-            ty::ty_closure(ty::ClosureTy { sig: ref sig, region, _ }) => {\n+            ty::ty_closure(ty::ClosureTy { sig: ref sig, region, .. }) => {\n                 let contra = self.contravariant(variance);\n                 self.add_constraints_from_region(region, contra);\n                 self.add_constraints_from_sig(sig, variance);\n             }\n \n-            ty::ty_infer(*) | ty::ty_err | ty::ty_type |\n-            ty::ty_opaque_box | ty::ty_opaque_closure_ptr(*) |\n-            ty::ty_unboxed_vec(*) => {\n+            ty::ty_infer(..) | ty::ty_err | ty::ty_type |\n+            ty::ty_opaque_box | ty::ty_opaque_closure_ptr(..) |\n+            ty::ty_unboxed_vec(..) => {\n                 self.tcx().sess.bug(\n                     format!(\"Unexpected type encountered in \\\n                             variance inference: {}\",\n@@ -770,12 +770,12 @@ impl<'self> ConstraintContext<'self> {\n \n             ty::ReStatic => { }\n \n-            ty::ReLateBound(*) => {\n+            ty::ReLateBound(..) => {\n                 // We do not infer variance for region parameters on\n                 // methods or in fn types.\n             }\n \n-            ty::ReFree(*) | ty::ReScope(*) | ty::ReInfer(*) |\n+            ty::ReFree(..) | ty::ReScope(..) | ty::ReInfer(..) |\n             ty::ReEmpty => {\n                 // We don't expect to see anything but 'static or bound\n                 // regions when visiting member types or method types.\n@@ -822,7 +822,7 @@ struct SolveContext<'self> {\n }\n \n fn solve_constraints(constraints_cx: ConstraintContext) {\n-    let ConstraintContext { terms_cx, constraints, _ } = constraints_cx;\n+    let ConstraintContext { terms_cx, constraints, .. } = constraints_cx;\n     let solutions = vec::from_elem(terms_cx.num_inferred(), ty::Bivariant);\n     let mut solutions_cx = SolveContext {\n         terms_cx: terms_cx,"}, {"sha": "a0823a584c343b0835ef672f8092965065b72bce", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -71,7 +71,7 @@ impl<'self> Visitor<()> for LoopQueryVisitor<'self> {\n         match e.node {\n           // Skip inner loops, since a break in the inner loop isn't a\n           // break inside the outer loop\n-          ast::ExprLoop(*) | ast::ExprWhile(*) => {}\n+          ast::ExprLoop(..) | ast::ExprWhile(..) => {}\n           _ => visit::walk_expr(self, e, ())\n         }\n     }"}, {"sha": "1a7640e5b9a68484eb8914da5948741f93b060b6", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -81,19 +81,19 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n           }\n           Some(&ast_map::node_expr(expr)) => {\n             match expr.node {\n-              ast::ExprCall(*) => explain_span(cx, \"call\", expr.span),\n-              ast::ExprMethodCall(*) => {\n+              ast::ExprCall(..) => explain_span(cx, \"call\", expr.span),\n+              ast::ExprMethodCall(..) => {\n                 explain_span(cx, \"method call\", expr.span)\n               },\n-              ast::ExprMatch(*) => explain_span(cx, \"match\", expr.span),\n+              ast::ExprMatch(..) => explain_span(cx, \"match\", expr.span),\n               _ => explain_span(cx, \"expression\", expr.span)\n             }\n           }\n           Some(&ast_map::node_stmt(stmt)) => {\n               explain_span(cx, \"statement\", stmt.span)\n           }\n           Some(&ast_map::node_item(it, _)) if (match it.node {\n-                ast::item_fn(*) => true, _ => false}) => {\n+                ast::item_fn(..) => true, _ => false}) => {\n               explain_span(cx, \"function body\", it.span)\n           }\n           Some(_) | None => {\n@@ -119,7 +119,7 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n             (format!(\"{} {}\", prefix, msg), opt_span)\n           }\n           Some(&ast_map::node_item(it, _)) if match it.node {\n-                ast::item_impl(*) => true, _ => false} => {\n+                ast::item_impl(..) => true, _ => false} => {\n             let (msg, opt_span) = explain_span(cx, \"impl\", it.span);\n             (format!(\"{} {}\", prefix, msg), opt_span)\n           }\n@@ -136,7 +136,7 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n \n       // I believe these cases should not occur (except when debugging,\n       // perhaps)\n-      ty::ReInfer(_) | ty::ReEarlyBound(*) | ty::ReLateBound(*) => {\n+      ty::ReInfer(_) | ty::ReEarlyBound(..) | ty::ReLateBound(..) => {\n         (format!(\"lifetime {:?}\", region), None)\n       }\n     };\n@@ -179,18 +179,18 @@ pub fn ReScope_id_to_str(cx: ctxt, node_id: ast::NodeId) -> ~str {\n       }\n       Some(&ast_map::node_expr(expr)) => {\n         match expr.node {\n-          ast::ExprCall(*) => {\n+          ast::ExprCall(..) => {\n             format!(\"<call at {}>\",\n                  cx.sess.codemap.span_to_str(expr.span))\n           }\n-          ast::ExprMatch(*) => {\n+          ast::ExprMatch(..) => {\n             format!(\"<match at {}>\",\n                  cx.sess.codemap.span_to_str(expr.span))\n           }\n-          ast::ExprAssignOp(*) |\n-          ast::ExprUnary(*) |\n-          ast::ExprBinary(*) |\n-          ast::ExprIndex(*) => {\n+          ast::ExprAssignOp(..) |\n+          ast::ExprUnary(..) |\n+          ast::ExprBinary(..) |\n+          ast::ExprIndex(..) => {\n             format!(\"<method at {}>\",\n                  cx.sess.codemap.span_to_str(expr.span))\n           }\n@@ -494,7 +494,7 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n           };\n           if !cx.sess.verbose() { ident } else { format!(\"{}:{:?}\", ident, did) }\n       }\n-      ty_self(*) => ~\"Self\",\n+      ty_self(..) => ~\"Self\",\n       ty_enum(did, ref substs) | ty_struct(did, ref substs) => {\n         let path = ty::item_path(cx, did);\n         let base = ast_map::path_to_str(path, cx.sess.intr());\n@@ -751,12 +751,12 @@ impl Repr for ast::DefId {\n         // and otherwise fallback to just printing the crate/node pair\n         if self.crate == ast::LOCAL_CRATE {\n             match tcx.items.find(&self.node) {\n-                Some(&ast_map::node_item(*)) |\n-                Some(&ast_map::node_foreign_item(*)) |\n-                Some(&ast_map::node_method(*)) |\n-                Some(&ast_map::node_trait_method(*)) |\n-                Some(&ast_map::node_variant(*)) |\n-                Some(&ast_map::node_struct_ctor(*)) => {\n+                Some(&ast_map::node_item(..)) |\n+                Some(&ast_map::node_foreign_item(..)) |\n+                Some(&ast_map::node_method(..)) |\n+                Some(&ast_map::node_trait_method(..)) |\n+                Some(&ast_map::node_variant(..)) |\n+                Some(&ast_map::node_struct_ctor(..)) => {\n                     return format!(\"{:?}:{}\", *self, ty::item_path_str(tcx, *self));\n                 }\n                 _ => {}"}, {"sha": "87d2b5dac1e82ed1773bbbf99bfd29c28216bfcb", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -151,19 +151,19 @@ impl Item {\n     }\n \n     pub fn is_mod(&self) -> bool {\n-        match self.inner { ModuleItem(*) => true, _ => false }\n+        match self.inner { ModuleItem(..) => true, _ => false }\n     }\n     pub fn is_trait(&self) -> bool {\n-        match self.inner { TraitItem(*) => true, _ => false }\n+        match self.inner { TraitItem(..) => true, _ => false }\n     }\n     pub fn is_struct(&self) -> bool {\n-        match self.inner { StructItem(*) => true, _ => false }\n+        match self.inner { StructItem(..) => true, _ => false }\n     }\n     pub fn is_enum(&self) -> bool {\n-        match self.inner { EnumItem(*) => true, _ => false }\n+        match self.inner { EnumItem(..) => true, _ => false }\n     }\n     pub fn is_fn(&self) -> bool {\n-        match self.inner { FunctionItem(*) => true, _ => false }\n+        match self.inner { FunctionItem(..) => true, _ => false }\n     }\n }\n \n@@ -538,13 +538,13 @@ pub enum TraitMethod {\n impl TraitMethod {\n     pub fn is_req(&self) -> bool {\n         match self {\n-            &Required(*) => true,\n+            &Required(..) => true,\n             _ => false,\n         }\n     }\n     pub fn is_def(&self) -> bool {\n         match self {\n-            &Provided(*) => true,\n+            &Provided(..) => true,\n             _ => false,\n         }\n     }\n@@ -1140,17 +1140,17 @@ fn name_from_pat(p: &ast::Pat) -> ~str {\n         PatWildMulti => ~\"..\",\n         PatIdent(_, ref p, _) => path_to_str(p),\n         PatEnum(ref p, _) => path_to_str(p),\n-        PatStruct(*) => fail!(\"tried to get argument name from pat_struct, \\\n+        PatStruct(..) => fail!(\"tried to get argument name from pat_struct, \\\n                                 which is not allowed in function arguments\"),\n-        PatTup(*) => ~\"(tuple arg NYI)\",\n+        PatTup(..) => ~\"(tuple arg NYI)\",\n         PatBox(p) => name_from_pat(p),\n         PatUniq(p) => name_from_pat(p),\n         PatRegion(p) => name_from_pat(p),\n-        PatLit(*) => fail!(\"tried to get argument name from pat_lit, \\\n+        PatLit(..) => fail!(\"tried to get argument name from pat_lit, \\\n                             which is not allowed in function arguments\"),\n-        PatRange(*) => fail!(\"tried to get argument name from pat_range, \\\n+        PatRange(..) => fail!(\"tried to get argument name from pat_range, \\\n                               which is not allowed in function arguments\"),\n-        PatVec(*) => fail!(\"tried to get argument name from pat_vec, \\\n+        PatVec(..) => fail!(\"tried to get argument name from pat_vec, \\\n                              which is not allowed in function arguments\")\n     }\n }"}, {"sha": "dc8e9072499db4652c3ba132a1202b08317c4d8d", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -73,7 +73,7 @@ fn get_ast_and_resolve(cpath: &Path,\n     let mut crate = phase_1_parse_input(sess, cfg.clone(), &input);\n     crate = phase_2_configure_and_expand(sess, cfg, crate);\n     let driver::driver::CrateAnalysis {\n-        exported_items, ty_cx, _\n+        exported_items, ty_cx, ..\n     } = phase_3_run_analysis_passes(sess, &crate);\n \n     debug!(\"crate: {:?}\", crate);"}, {"sha": "b80f92016a816581e3422ba78b73e97c71e1f96f", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -277,7 +277,7 @@ impl fmt::Default for clean::Type {\n                 external_path(f.buf, path, false, fqn.as_slice(), kind, crate);\n                 typarams(f.buf, tp);\n             }\n-            clean::Self(*) => f.buf.write(\"Self\".as_bytes()),\n+            clean::Self(..) => f.buf.write(\"Self\".as_bytes()),\n             clean::Primitive(prim) => {\n                 let s = match prim {\n                     ast::ty_int(ast::ty_i) => \"int\","}, {"sha": "0df4820d822c3936b0045bea88e1b1c0ae40de0b", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 81, "deletions": 81, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -423,7 +423,7 @@ impl<'self> SourceCollector<'self> {\n             let mut r = match io::result(|| File::open(&p)) {\n                 Ok(r) => r,\n                 // eew macro hacks\n-                Err(*) => return filename == \"<std-macros>\"\n+                Err(..) => return filename == \"<std-macros>\"\n             };\n \n             // read everything\n@@ -491,12 +491,12 @@ impl DocFolder for Cache {\n         match item.inner {\n             clean::ImplItem(ref i) => {\n                 match i.trait_ {\n-                    Some(clean::ResolvedPath{ id, _ }) => {\n+                    Some(clean::ResolvedPath{ id, .. }) => {\n                         let v = self.implementors.find_or_insert_with(id, |_|{\n                             ~[]\n                         });\n                         match i.for_ {\n-                            clean::ResolvedPath{_} => {\n+                            clean::ResolvedPath{..} => {\n                                 v.unshift(PathType(i.for_.clone()));\n                             }\n                             _ => {\n@@ -506,7 +506,7 @@ impl DocFolder for Cache {\n                             }\n                         }\n                     }\n-                    Some(*) | None => {}\n+                    Some(..) | None => {}\n                 }\n             }\n             _ => {}\n@@ -516,21 +516,21 @@ impl DocFolder for Cache {\n         match item.name {\n             Some(ref s) => {\n                 let parent = match item.inner {\n-                    clean::TyMethodItem(*) |\n-                    clean::StructFieldItem(*) |\n-                    clean::VariantItem(*) => {\n+                    clean::TyMethodItem(..) |\n+                    clean::StructFieldItem(..) |\n+                    clean::VariantItem(..) => {\n                         Some((Some(*self.parent_stack.last()),\n                               self.stack.slice_to(self.stack.len() - 1)))\n \n                     }\n-                    clean::MethodItem(*) => {\n+                    clean::MethodItem(..) => {\n                         if self.parent_stack.len() == 0 {\n                             None\n                         } else {\n                             let last = self.parent_stack.last();\n                             let amt = match self.paths.find(last) {\n                                 Some(&(_, \"trait\")) => self.stack.len() - 1,\n-                                Some(*) | None => self.stack.len(),\n+                                Some(..) | None => self.stack.len(),\n                             };\n                             Some((Some(*last), self.stack.slice_to(amt)))\n                         }\n@@ -562,23 +562,23 @@ impl DocFolder for Cache {\n             } else { false }\n         } else { false };\n         match item.inner {\n-            clean::StructItem(*) | clean::EnumItem(*) |\n-            clean::TypedefItem(*) | clean::TraitItem(*) |\n-            clean::FunctionItem(*) | clean::ModuleItem(*) |\n-            clean::ForeignFunctionItem(*) | clean::VariantItem(*) => {\n+            clean::StructItem(..) | clean::EnumItem(..) |\n+            clean::TypedefItem(..) | clean::TraitItem(..) |\n+            clean::FunctionItem(..) | clean::ModuleItem(..) |\n+            clean::ForeignFunctionItem(..) | clean::VariantItem(..) => {\n                 self.paths.insert(item.id, (self.stack.clone(), shortty(&item)));\n             }\n             _ => {}\n         }\n \n         // Maintain the parent stack\n         let parent_pushed = match item.inner {\n-            clean::TraitItem(*) | clean::EnumItem(*) | clean::StructItem(*) => {\n+            clean::TraitItem(..) | clean::EnumItem(..) | clean::StructItem(..) => {\n                 self.parent_stack.push(item.id); true\n             }\n             clean::ImplItem(ref i) => {\n                 match i.for_ {\n-                    clean::ResolvedPath{ id, _ } => {\n+                    clean::ResolvedPath{ id, .. } => {\n                         self.parent_stack.push(id); true\n                     }\n                     _ => false\n@@ -592,9 +592,9 @@ impl DocFolder for Cache {\n         let ret = match self.fold_item_recur(item) {\n             Some(item) => {\n                 match item {\n-                    clean::Item{ attrs, inner: clean::ImplItem(i), _ } => {\n+                    clean::Item{ attrs, inner: clean::ImplItem(i), .. } => {\n                         match i.for_ {\n-                            clean::ResolvedPath { id, _ } => {\n+                            clean::ResolvedPath { id, .. } => {\n                                 let v = self.impls.find_or_insert_with(id, |_| {\n                                     ~[]\n                                 });\n@@ -608,7 +608,7 @@ impl DocFolder for Cache {\n                                     Some(clean::NameValue(_, dox)) => {\n                                         v.push((i, Some(dox)));\n                                     }\n-                                    Some(*) | None => {\n+                                    Some(..) | None => {\n                                         v.push((i, None));\n                                     }\n                                 }\n@@ -620,7 +620,7 @@ impl DocFolder for Cache {\n                     // Private modules may survive the strip-private pass if\n                     // they contain impls for public types, but those will get\n                     // stripped here\n-                    clean::Item { inner: clean::ModuleItem(ref m), _ }\n+                    clean::Item { inner: clean::ModuleItem(ref m), .. }\n                             if m.items.len() == 0 => None,\n                     i => Some(i),\n                 }\n@@ -800,7 +800,7 @@ impl Context {\n         match item.inner {\n             // modules are special because they add a namespace. We also need to\n             // recurse into the items of the module as well.\n-            clean::ModuleItem(*) => {\n+            clean::ModuleItem(..) => {\n                 let name = item.name.get_ref().to_owned();\n                 let item = Cell::new(item);\n                 self.recurse(name, |this| {\n@@ -833,28 +833,28 @@ impl Context {\n \n fn shortty(item: &clean::Item) -> &'static str {\n     match item.inner {\n-        clean::ModuleItem(*)          => \"mod\",\n-        clean::StructItem(*)          => \"struct\",\n-        clean::EnumItem(*)            => \"enum\",\n-        clean::FunctionItem(*)        => \"fn\",\n-        clean::TypedefItem(*)         => \"typedef\",\n-        clean::StaticItem(*)          => \"static\",\n-        clean::TraitItem(*)           => \"trait\",\n-        clean::ImplItem(*)            => \"impl\",\n-        clean::ViewItemItem(*)        => \"viewitem\",\n-        clean::TyMethodItem(*)        => \"tymethod\",\n-        clean::MethodItem(*)          => \"method\",\n-        clean::StructFieldItem(*)     => \"structfield\",\n-        clean::VariantItem(*)         => \"variant\",\n-        clean::ForeignFunctionItem(*) => \"ffi\",\n-        clean::ForeignStaticItem(*)   => \"ffs\",\n+        clean::ModuleItem(..)          => \"mod\",\n+        clean::StructItem(..)          => \"struct\",\n+        clean::EnumItem(..)            => \"enum\",\n+        clean::FunctionItem(..)        => \"fn\",\n+        clean::TypedefItem(..)         => \"typedef\",\n+        clean::StaticItem(..)          => \"static\",\n+        clean::TraitItem(..)           => \"trait\",\n+        clean::ImplItem(..)            => \"impl\",\n+        clean::ViewItemItem(..)        => \"viewitem\",\n+        clean::TyMethodItem(..)        => \"tymethod\",\n+        clean::MethodItem(..)          => \"method\",\n+        clean::StructFieldItem(..)     => \"structfield\",\n+        clean::VariantItem(..)         => \"variant\",\n+        clean::ForeignFunctionItem(..) => \"ffi\",\n+        clean::ForeignStaticItem(..)   => \"ffs\",\n     }\n }\n \n impl<'self> Item<'self> {\n     fn ismodule(&self) -> bool {\n         match self.item.inner {\n-            clean::ModuleItem(*) => true, _ => false\n+            clean::ModuleItem(..) => true, _ => false\n         }\n     }\n }\n@@ -895,11 +895,11 @@ impl<'self> fmt::Default for Item<'self> {\n         // Write the breadcrumb trail header for the top\n         write!(fmt.buf, \"<h1 class='fqn'>\");\n         match it.item.inner {\n-            clean::ModuleItem(*) => write!(fmt.buf, \"Module \"),\n-            clean::FunctionItem(*) => write!(fmt.buf, \"Function \"),\n-            clean::TraitItem(*) => write!(fmt.buf, \"Trait \"),\n-            clean::StructItem(*) => write!(fmt.buf, \"Struct \"),\n-            clean::EnumItem(*) => write!(fmt.buf, \"Enum \"),\n+            clean::ModuleItem(..) => write!(fmt.buf, \"Module \"),\n+            clean::FunctionItem(..) => write!(fmt.buf, \"Function \"),\n+            clean::TraitItem(..) => write!(fmt.buf, \"Trait \"),\n+            clean::StructItem(..) => write!(fmt.buf, \"Struct \"),\n+            clean::EnumItem(..) => write!(fmt.buf, \"Enum \"),\n             _ => {}\n         }\n         let cur = it.cx.current.as_slice();\n@@ -931,7 +931,7 @@ impl<'self> fmt::Default for Item<'self> {\n \n fn item_path(item: &clean::Item) -> ~str {\n     match item.inner {\n-        clean::ModuleItem(*) => *item.name.get_ref() + \"/index.html\",\n+        clean::ModuleItem(..) => *item.name.get_ref() + \"/index.html\",\n         _ => shortty(item) + \".\" + *item.name.get_ref() + \".html\"\n     }\n }\n@@ -982,31 +982,31 @@ fn item_module(w: &mut Writer, cx: &Context,\n         match (&i1.inner, &i2.inner) {\n             (&clean::ViewItemItem(ref a), &clean::ViewItemItem(ref b)) => {\n                 match (&a.inner, &b.inner) {\n-                    (&clean::ExternMod(*), _) => true,\n-                    (_, &clean::ExternMod(*)) => false,\n+                    (&clean::ExternMod(..), _) => true,\n+                    (_, &clean::ExternMod(..)) => false,\n                     _ => idx1 < idx2,\n                 }\n             }\n-            (&clean::ViewItemItem(*), _) => true,\n-            (_, &clean::ViewItemItem(*)) => false,\n-            (&clean::ModuleItem(*), _) => true,\n-            (_, &clean::ModuleItem(*)) => false,\n-            (&clean::StructItem(*), _) => true,\n-            (_, &clean::StructItem(*)) => false,\n-            (&clean::EnumItem(*), _) => true,\n-            (_, &clean::EnumItem(*)) => false,\n-            (&clean::StaticItem(*), _) => true,\n-            (_, &clean::StaticItem(*)) => false,\n-            (&clean::ForeignFunctionItem(*), _) => true,\n-            (_, &clean::ForeignFunctionItem(*)) => false,\n-            (&clean::ForeignStaticItem(*), _) => true,\n-            (_, &clean::ForeignStaticItem(*)) => false,\n-            (&clean::TraitItem(*), _) => true,\n-            (_, &clean::TraitItem(*)) => false,\n-            (&clean::FunctionItem(*), _) => true,\n-            (_, &clean::FunctionItem(*)) => false,\n-            (&clean::TypedefItem(*), _) => true,\n-            (_, &clean::TypedefItem(*)) => false,\n+            (&clean::ViewItemItem(..), _) => true,\n+            (_, &clean::ViewItemItem(..)) => false,\n+            (&clean::ModuleItem(..), _) => true,\n+            (_, &clean::ModuleItem(..)) => false,\n+            (&clean::StructItem(..), _) => true,\n+            (_, &clean::StructItem(..)) => false,\n+            (&clean::EnumItem(..), _) => true,\n+            (_, &clean::EnumItem(..)) => false,\n+            (&clean::StaticItem(..), _) => true,\n+            (_, &clean::StaticItem(..)) => false,\n+            (&clean::ForeignFunctionItem(..), _) => true,\n+            (_, &clean::ForeignFunctionItem(..)) => false,\n+            (&clean::ForeignStaticItem(..), _) => true,\n+            (_, &clean::ForeignStaticItem(..)) => false,\n+            (&clean::TraitItem(..), _) => true,\n+            (_, &clean::TraitItem(..)) => false,\n+            (&clean::FunctionItem(..), _) => true,\n+            (_, &clean::FunctionItem(..)) => false,\n+            (&clean::TypedefItem(..), _) => true,\n+            (_, &clean::TypedefItem(..)) => false,\n             _ => idx1 < idx2,\n         }\n     }\n@@ -1026,21 +1026,21 @@ fn item_module(w: &mut Writer, cx: &Context,\n             }\n             curty = myty;\n             write!(w, \"<h2>{}</h2>\\n<table>\", match myitem.inner {\n-                clean::ModuleItem(*)          => \"Modules\",\n-                clean::StructItem(*)          => \"Structs\",\n-                clean::EnumItem(*)            => \"Enums\",\n-                clean::FunctionItem(*)        => \"Functions\",\n-                clean::TypedefItem(*)         => \"Type Definitions\",\n-                clean::StaticItem(*)          => \"Statics\",\n-                clean::TraitItem(*)           => \"Traits\",\n-                clean::ImplItem(*)            => \"Implementations\",\n-                clean::ViewItemItem(*)        => \"Reexports\",\n-                clean::TyMethodItem(*)        => \"Type Methods\",\n-                clean::MethodItem(*)          => \"Methods\",\n-                clean::StructFieldItem(*)     => \"Struct Fields\",\n-                clean::VariantItem(*)         => \"Variants\",\n-                clean::ForeignFunctionItem(*) => \"Foreign Functions\",\n-                clean::ForeignStaticItem(*)   => \"Foreign Statics\",\n+                clean::ModuleItem(..)          => \"Modules\",\n+                clean::StructItem(..)          => \"Structs\",\n+                clean::EnumItem(..)            => \"Enums\",\n+                clean::FunctionItem(..)        => \"Functions\",\n+                clean::TypedefItem(..)         => \"Type Definitions\",\n+                clean::StaticItem(..)          => \"Statics\",\n+                clean::TraitItem(..)           => \"Traits\",\n+                clean::ImplItem(..)            => \"Implementations\",\n+                clean::ViewItemItem(..)        => \"Reexports\",\n+                clean::TyMethodItem(..)        => \"Type Methods\",\n+                clean::MethodItem(..)          => \"Methods\",\n+                clean::StructFieldItem(..)     => \"Struct Fields\",\n+                clean::VariantItem(..)         => \"Variants\",\n+                clean::ForeignFunctionItem(..) => \"Foreign Functions\",\n+                clean::ForeignStaticItem(..)   => \"Foreign Statics\",\n             });\n         }\n \n@@ -1450,7 +1450,7 @@ fn render_impl(w: &mut Writer, i: &clean::Impl, dox: &Option<~str>) {\n         Some(ref ty) => {\n             write!(w, \"{} for \", *ty);\n             match *ty {\n-                clean::ResolvedPath { id, _ } => Some(id),\n+                clean::ResolvedPath { id, .. } => Some(id),\n                 _ => None,\n             }\n         }\n@@ -1527,7 +1527,7 @@ fn render_impl(w: &mut Writer, i: &clean::Impl, dox: &Option<~str>) {\n                             for method in t.methods.iter() {\n                                 let n = method.item().name.clone();\n                                 match i.methods.iter().find(|m| m.name == n) {\n-                                    Some(*) => continue,\n+                                    Some(..) => continue,\n                                     None => {}\n                                 }\n "}, {"sha": "c5b2125c163c453c9d16d4b2067fcc83c5ac6d76", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -278,7 +278,7 @@ fn json_input(input: &str) -> Result<Output, ~str> {\n                                             version {}\", SCHEMA_VERSION))\n                     }\n                 }\n-                Some(*) => return Err(~\"malformed json\"),\n+                Some(..) => return Err(~\"malformed json\"),\n                 None => return Err(~\"expected a schema version\"),\n             }\n             let crate = match obj.pop(&~\"crate\") {\n@@ -293,7 +293,7 @@ fn json_input(input: &str) -> Result<Output, ~str> {\n             let plugin_output = ~[];\n             Ok((crate, plugin_output))\n         }\n-        Ok(*) => Err(~\"malformed json input: expected an object at the top\"),\n+        Ok(..) => Err(~\"malformed json input: expected an object at the top\"),\n     }\n }\n "}, {"sha": "6f469ba6fff98310738a563a8323193d3bb00114", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -88,39 +88,39 @@ impl<'self> fold::DocFolder for Stripper<'self> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         match i.inner {\n             // These items can all get re-exported\n-            clean::TypedefItem(*) | clean::StaticItem(*) |\n-            clean::StructItem(*) | clean::EnumItem(*) |\n-            clean::TraitItem(*) | clean::FunctionItem(*) |\n-            clean::VariantItem(*) | clean::MethodItem(*) |\n-            clean::ForeignFunctionItem(*) | clean::ForeignStaticItem(*) => {\n+            clean::TypedefItem(..) | clean::StaticItem(..) |\n+            clean::StructItem(..) | clean::EnumItem(..) |\n+            clean::TraitItem(..) | clean::FunctionItem(..) |\n+            clean::VariantItem(..) | clean::MethodItem(..) |\n+            clean::ForeignFunctionItem(..) | clean::ForeignStaticItem(..) => {\n                 if !self.exported_items.contains(&i.id) {\n                     return None;\n                 }\n             }\n \n-            clean::ViewItemItem(*) => {\n+            clean::ViewItemItem(..) => {\n                 if i.visibility != Some(ast::public) {\n                     return None\n                 }\n             }\n \n-            clean::StructFieldItem(*) => {\n+            clean::StructFieldItem(..) => {\n                 if i.visibility == Some(ast::private) {\n                     return None;\n                 }\n             }\n \n             // handled below\n-            clean::ModuleItem(*) => {}\n+            clean::ModuleItem(..) => {}\n \n             // impls/tymethods have no control over privacy\n-            clean::ImplItem(*) | clean::TyMethodItem(*) => {}\n+            clean::ImplItem(..) | clean::TyMethodItem(..) => {}\n         }\n \n         let fastreturn = match i.inner {\n             // nothing left to do for traits (don't want to filter their\n             // methods out, visibility controlled by the trait)\n-            clean::TraitItem(*) => true,\n+            clean::TraitItem(..) => true,\n \n             // implementations of traits are always public.\n             clean::ImplItem(ref imp) if imp.trait_.is_some() => true,\n@@ -159,12 +159,12 @@ impl<'self> fold::DocFolder for ImplStripper<'self> {\n         match i.inner {\n             clean::ImplItem(ref imp) => {\n                 match imp.trait_ {\n-                    Some(clean::ResolvedPath{ id, _ }) => {\n+                    Some(clean::ResolvedPath{ id, .. }) => {\n                         if !self.contains(&id) {\n                             return None;\n                         }\n                     }\n-                    Some(*) | None => {}\n+                    Some(..) | None => {}\n                 }\n             }\n             _ => {}"}, {"sha": "ffc5f2c947d035457b5a67797bbcaf820b482013", "filename": "src/librustpkg/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustpkg%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustpkg%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Flib.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -233,7 +233,7 @@ impl CtxMethods for BuildContext {\n                     self.build(&mut pkg_src, what);\n                     match pkg_src {\n                         PkgSrc { destination_workspace: ws,\n-                                 id: id, _ } => {\n+                                 id: id, .. } => {\n                             Some((id, ws))\n                         }\n                     }\n@@ -244,7 +244,7 @@ impl CtxMethods for BuildContext {\n                     self.build(&mut pkg_src, what);\n                     match pkg_src {\n                         PkgSrc { destination_workspace: ws,\n-                                 id: id, _ } => {\n+                                 id: id, .. } => {\n                             Some((id, ws))\n                         }\n                     }"}, {"sha": "b89d4f55258432a0141a34c37051efb8936409ad", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -146,7 +146,7 @@ impl PkgSrc {\n                                 source_workspace: source,\n                                 destination_workspace: destination,\n                                 start_dir: start,\n-                                id: id, _ } => {\n+                                id: id, .. } => {\n                                 let result = PkgSrc {\n                                     source_workspace: source.clone(),\n                                     build_in_destination: build_in_destination,"}, {"sha": "5401a30a86c998bf491698003b4906a782044dbf", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -1091,7 +1091,7 @@ fn no_rebuilding() {\n     command_line_test([~\"build\", ~\"foo\"], workspace);\n \n     match command_line_test_partial([~\"build\", ~\"foo\"], workspace) {\n-        Success(*) => (), // ok\n+        Success(..) => (), // ok\n         Fail(ref status) if status.status.matches_exit_status(65) =>\n             fail!(\"no_rebuilding failed: it tried to rebuild bar\"),\n         Fail(_) => fail!(\"no_rebuilding failed for some other reason\")\n@@ -1110,7 +1110,7 @@ fn no_recopying() {\n     assert!(chmod_read_only(&foo_lib.unwrap()));\n \n     match command_line_test_partial([~\"install\", ~\"foo\"], workspace) {\n-        Success(*) => (), // ok\n+        Success(..) => (), // ok\n         Fail(ref status) if status.status.matches_exit_status(65) =>\n             fail!(\"no_recopying failed: it tried to re-copy foo\"),\n         Fail(_) => fail!(\"no_copying failed for some other reason\")\n@@ -1129,7 +1129,7 @@ fn no_rebuilding_dep() {\n     // Now make `bar` read-only so that subsequent rebuilds of it will fail\n     assert!(chmod_read_only(&bar_lib));\n     match command_line_test_partial([~\"build\", ~\"foo\"], workspace) {\n-        Success(*) => (), // ok\n+        Success(..) => (), // ok\n         Fail(ref r) if r.status.matches_exit_status(65) =>\n             fail!(\"no_rebuilding_dep failed: it tried to rebuild bar\"),\n         Fail(_) => fail!(\"no_rebuilding_dep failed for some other reason\")\n@@ -1150,7 +1150,7 @@ fn do_rebuild_dep_dates_change() {\n     assert!(chmod_read_only(&bar_lib_name));\n \n     match command_line_test_partial([~\"build\", ~\"foo\"], workspace) {\n-        Success(*) => fail!(\"do_rebuild_dep_dates_change failed: it didn't rebuild bar\"),\n+        Success(..) => fail!(\"do_rebuild_dep_dates_change failed: it didn't rebuild bar\"),\n         Fail(ref r) if r.status.matches_exit_status(65) => (), // ok\n         Fail(_) => fail!(\"do_rebuild_dep_dates_change failed for some other reason\")\n     }\n@@ -1171,7 +1171,7 @@ fn do_rebuild_dep_only_contents_change() {\n \n     // should adjust the datestamp\n     match command_line_test_partial([~\"build\", ~\"foo\"], workspace) {\n-        Success(*) => fail!(\"do_rebuild_dep_only_contents_change failed: it didn't rebuild bar\"),\n+        Success(..) => fail!(\"do_rebuild_dep_only_contents_change failed: it didn't rebuild bar\"),\n         Fail(ref r) if r.status.matches_exit_status(65) => (), // ok\n         Fail(_) => fail!(\"do_rebuild_dep_only_contents_change failed for some other reason\")\n     }\n@@ -1729,7 +1729,7 @@ fn test_cfg_fail() {\n                        ~\"build\",\n                        ~\"foo\"],\n                       workspace) {\n-        Success(*) => fail!(\"test_cfg_fail failed\"),\n+        Success(..) => fail!(\"test_cfg_fail failed\"),\n         _          => ()\n     }\n }\n@@ -2116,7 +2116,7 @@ fn test_rustpkg_test_failure_exit_status() {\n     let res = command_line_test_partial([~\"test\", ~\"foo\"], foo_workspace);\n     match res {\n         Fail(_) => {},\n-        Success(*) => fail!(\"Expected test failure but got success\")\n+        Success(..) => fail!(\"Expected test failure but got success\")\n     }\n }\n \n@@ -2147,7 +2147,7 @@ fn test_rebuild_when_needed() {\n     frob_source_file(foo_workspace, &foo_id, \"test.rs\");\n     chmod_read_only(&test_executable);\n     match command_line_test_partial([~\"test\", ~\"foo\"], foo_workspace) {\n-        Success(*) => fail!(\"test_rebuild_when_needed didn't rebuild\"),\n+        Success(..) => fail!(\"test_rebuild_when_needed didn't rebuild\"),\n         Fail(ref r) if r.status.matches_exit_status(65) => (), // ok\n         Fail(_) => fail!(\"test_rebuild_when_needed failed for some other reason\")\n     }\n@@ -2167,7 +2167,7 @@ fn test_no_rebuilding() {\n                             foo_workspace).expect(\"test_no_rebuilding failed\");\n     chmod_read_only(&test_executable);\n     match command_line_test_partial([~\"test\", ~\"foo\"], foo_workspace) {\n-        Success(*) => (), // ok\n+        Success(..) => (), // ok\n         Fail(ref r) if r.status.matches_exit_status(65) =>\n             fail!(\"test_no_rebuilding failed: it rebuilt the tests\"),\n         Fail(_) => fail!(\"test_no_rebuilding failed for some other reason\")\n@@ -2295,7 +2295,7 @@ fn test_compile_error() {\n     writeFile(&main_crate, \"pub fn main() { if 42 != ~\\\"the answer\\\" { fail!(); } }\");\n     let result = command_line_test_partial([~\"build\", ~\"foo\"], foo_workspace);\n     match result {\n-        Success(*) => fail!(\"Failed by succeeding!\"), // should be a compile error\n+        Success(..) => fail!(\"Failed by succeeding!\"), // should be a compile error\n         Fail(ref status) => {\n             debug!(\"Failed with status {:?}... that's good, right?\", status);\n         }\n@@ -2363,7 +2363,7 @@ fn test_c_dependency_no_rebuilding() {\n     assert!(chmod_read_only(&c_library_path));\n \n     match command_line_test_partial([~\"build\", ~\"cdep\"], dir) {\n-        Success(*) => (), // ok\n+        Success(..) => (), // ok\n         Fail(ref r) if r.status.matches_exit_status(65) =>\n             fail!(\"test_c_dependency_no_rebuilding failed: \\\n                     it tried to rebuild foo.c\"),\n@@ -2401,7 +2401,7 @@ fn test_c_dependency_yes_rebuilding() {\n     }\n \n     match command_line_test_partial([~\"build\", ~\"cdep\"], dir) {\n-        Success(*) => fail!(\"test_c_dependency_yes_rebuilding failed: \\\n+        Success(..) => fail!(\"test_c_dependency_yes_rebuilding failed: \\\n                             it didn't rebuild and should have\"),\n         Fail(ref r) if r.status.matches_exit_status(65) => (),\n         Fail(_) => fail!(\"test_c_dependency_yes_rebuilding failed for some other reason\")\n@@ -2421,7 +2421,7 @@ fn correct_error_dependency() {\n                fn main() {}\");\n \n     match command_line_test_partial([~\"build\", ~\"badpkg\"], dir) {\n-        Fail(ProcessOutput{ error: error, output: output, _ }) => {\n+        Fail(ProcessOutput{ error: error, output: output, .. }) => {\n             assert!(str::is_utf8(error));\n             assert!(str::is_utf8(output));\n             let error_str = str::from_utf8(error);\n@@ -2436,7 +2436,7 @@ fn correct_error_dependency() {\n                 fail!(\"Wrong error\");\n             }\n         }\n-        Success(*)       => fail!(\"Test passed when it should have failed\")\n+        Success(..)       => fail!(\"Test passed when it should have failed\")\n     }\n }\n "}, {"sha": "41b8fd5f37384c894a985a7bee2709f763ea5468", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -649,7 +649,7 @@ pub fn datestamp(p: &Path) -> Option<libc::time_t> {\n             debug!(\"Date = {:?}\", out);\n             Some(out as libc::time_t)\n         }\n-        Err(*) => None,\n+        Err(..) => None,\n     }\n }\n "}, {"sha": "76882e885a8c924c15a230afa59f21433d6c916d", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -44,8 +44,6 @@ via `close` and `delete` methods.\n #[crate_type = \"lib\"];\n \n #[feature(macro_rules, globs)];\n-#[allow(unrecognized_lint)]; // NOTE: remove after the next snapshot\n-#[allow(cstack)]; // NOTE: remove after the next snapshot.\n \n use std::cast::transmute;\n use std::cast;"}, {"sha": "3a485bf2ea9dad3b2f2ae97ac961fed4b71b6fd3", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -36,8 +36,8 @@ use uvll::sockaddr;\n \n fn socket_addr_as_sockaddr<T>(addr: SocketAddr, f: |*sockaddr| -> T) -> T {\n     let malloc = match addr.ip {\n-        Ipv4Addr(*) => uvll::rust_malloc_ip4_addr,\n-        Ipv6Addr(*) => uvll::rust_malloc_ip6_addr,\n+        Ipv4Addr(..) => uvll::rust_malloc_ip4_addr,\n+        Ipv6Addr(..) => uvll::rust_malloc_ip6_addr,\n     };\n \n     let ip = addr.ip.to_str();\n@@ -667,32 +667,32 @@ mod test {\n     #[test]\n     fn connect_close_ip4() {\n         match TcpWatcher::connect(local_loop(), next_test_ip4()) {\n-            Ok(*) => fail!(),\n+            Ok(..) => fail!(),\n             Err(e) => assert_eq!(e.name(), ~\"ECONNREFUSED\"),\n         }\n     }\n \n     #[test]\n     fn connect_close_ip6() {\n         match TcpWatcher::connect(local_loop(), next_test_ip6()) {\n-            Ok(*) => fail!(),\n+            Ok(..) => fail!(),\n             Err(e) => assert_eq!(e.name(), ~\"ECONNREFUSED\"),\n         }\n     }\n \n     #[test]\n     fn udp_bind_close_ip4() {\n         match UdpWatcher::bind(local_loop(), next_test_ip4()) {\n-            Ok(*) => {}\n-            Err(*) => fail!()\n+            Ok(..) => {}\n+            Err(..) => fail!()\n         }\n     }\n \n     #[test]\n     fn udp_bind_close_ip6() {\n         match UdpWatcher::bind(local_loop(), next_test_ip6()) {\n-            Ok(*) => {}\n-            Err(*) => fail!()\n+            Ok(..) => {}\n+            Err(..) => fail!()\n         }\n     }\n "}, {"sha": "829ddf9fe16cdcb0555353030750d7b1e518517d", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -246,15 +246,15 @@ mod tests {\n     #[test]\n     fn connect_err() {\n         match PipeWatcher::connect(local_loop(), &\"path/to/nowhere\".to_c_str()) {\n-            Ok(*) => fail!(),\n-            Err(*) => {}\n+            Ok(..) => fail!(),\n+            Err(..) => {}\n         }\n     }\n \n     #[test]\n     fn bind_err() {\n         match PipeListener::bind(local_loop(), &\"path/to/nowhere\".to_c_str()) {\n-            Ok(*) => fail!(),\n+            Ok(..) => fail!(),\n             Err(e) => assert_eq!(e.name(), ~\"EACCES\"),\n         }\n     }\n@@ -263,8 +263,8 @@ mod tests {\n     fn bind() {\n         let p = next_test_unix().to_c_str();\n         match PipeListener::bind(local_loop(), &p) {\n-            Ok(*) => {}\n-            Err(*) => fail!(),\n+            Ok(..) => {}\n+            Err(..) => fail!(),\n         }\n     }\n "}, {"sha": "8098ea653bc7921dd8f20f1cce510b12ae537671", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -212,7 +212,7 @@ impl RtioProcess for Process {\n         // Make sure (on the home scheduler) that we have an exit status listed\n         let _m = self.fire_homing_missile();\n         match self.exit_status {\n-            Some(*) => {}\n+            Some(..) => {}\n             None => {\n                 // If there's no exit code previously listed, then the\n                 // process's exit callback has yet to be invoked. We just"}, {"sha": "9fa2c7ab1f3b4f36a3916ac9c0875917dbffebed", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -768,7 +768,7 @@ impl<'self> Formatter<'self> {\n                         Left(parse::Few) => value < 8,\n                         Left(parse::Many) => value >= 8,\n \n-                        Right(*) => false\n+                        Right(..) => false\n                     };\n                     if run {\n                         return self.runplural(value, s.result);"}, {"sha": "6489ff79205b4886393775cffdd42266ab7c33c4", "filename": "src/libstd/fmt/parse.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Ffmt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Ffmt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fparse.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -217,7 +217,7 @@ impl<'self> Parser<'self> {\n                 self.cur.next();\n                 true\n             }\n-            Some(*) | None => false,\n+            Some(..) | None => false,\n         }\n     }\n \n@@ -251,7 +251,7 @@ impl<'self> Parser<'self> {\n         loop {\n             match self.cur.clone().next() {\n                 Some((_, c)) if char::is_whitespace(c) => { self.cur.next(); }\n-                Some(*) | None => { return }\n+                Some(..) | None => { return }\n             }\n         }\n     }\n@@ -284,7 +284,7 @@ impl<'self> Parser<'self> {\n                 Some((pos, '}')) | Some((pos, '{')) => {\n                     return self.input.slice(start, pos);\n                 }\n-                Some(*) => { self.cur.next(); }\n+                Some(..) => { self.cur.next(); }\n                 None => {\n                     self.cur.next();\n                     return self.input.slice(start, self.input.len());\n@@ -340,7 +340,7 @@ impl<'self> Parser<'self> {\n                         spec.fill = Some(c);\n                         self.cur.next();\n                     }\n-                    Some(*) | None => {}\n+                    Some(..) | None => {}\n                 }\n             }\n             None => {}\n@@ -449,7 +449,7 @@ impl<'self> Parser<'self> {\n             self.ws();\n             match self.cur.clone().next() {\n                 Some((_, '}')) => { break }\n-                Some(*) | None => {}\n+                Some(..) | None => {}\n             }\n         }\n         // The \"other\" selector must be present\n@@ -493,10 +493,10 @@ impl<'self> Parser<'self> {\n                             }\n                         }\n                     }\n-                    Some(*) | None => {}\n+                    Some(..) | None => {}\n                 }\n             }\n-            Some(*) | None => {}\n+            Some(..) | None => {}\n         }\n \n         // Next, generate all the arms\n@@ -547,7 +547,7 @@ impl<'self> Parser<'self> {\n             self.ws();\n             match self.cur.clone().next() {\n                 Some((_, '}')) => { break }\n-                Some(*) | None => {}\n+                Some(..) | None => {}\n             }\n         }\n \n@@ -597,7 +597,7 @@ impl<'self> Parser<'self> {\n                 self.cur.next();\n                 pos\n             }\n-            Some(*) | None => { return self.input.slice(0, 0); }\n+            Some(..) | None => { return self.input.slice(0, 0); }\n         };\n         let mut end;\n         loop {"}, {"sha": "e7eb8e60704655ca7d6f9e44fe28539006e2ffd9", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -577,7 +577,7 @@ impl<K, V> Iterator<(K, V)> for HashMapMoveIterator<K, V> {\n     fn next(&mut self) -> Option<(K, V)> {\n         for elt in self.iter {\n             match elt {\n-                Some(Bucket {key, value, _}) => return Some((key, value)),\n+                Some(Bucket {key, value, ..}) => return Some((key, value)),\n                 None => {},\n             }\n         }"}, {"sha": "a4be74d1d7f814e32e090beec62bc0a01c69930b", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -678,7 +678,7 @@ impl path::Path {\n     pub fn is_file(&self) -> bool {\n         match io::result(|| self.stat()) {\n             Ok(s) => s.kind == io::TypeFile,\n-            Err(*) => false\n+            Err(..) => false\n         }\n     }\n \n@@ -693,7 +693,7 @@ impl path::Path {\n     pub fn is_dir(&self) -> bool {\n         match io::result(|| self.stat()) {\n             Ok(s) => s.kind == io::TypeDirectory,\n-            Err(*) => false\n+            Err(..) => false\n         }\n     }\n }\n@@ -1027,8 +1027,8 @@ mod test {\n         let from = Path::new(\"test/nonexistent-bogus-path\");\n         let to = Path::new(\"test/other-bogus-path\");\n         match io::result(|| copy(&from, &to)) {\n-            Ok(*) => fail!(),\n-            Err(*) => {\n+            Ok(..) => fail!(),\n+            Err(..) => {\n                 assert!(!from.exists());\n                 assert!(!to.exists());\n             }\n@@ -1054,7 +1054,7 @@ mod test {\n \n         File::create(&out);\n         match io::result(|| copy(&out, &*tmpdir)) {\n-            Ok(*) => fail!(), Err(*) => {}\n+            Ok(..) => fail!(), Err(..) => {}\n         }\n     })\n \n@@ -1076,7 +1076,7 @@ mod test {\n         let out = tmpdir.join(\"out\");\n \n         match io::result(|| copy(&*tmpdir, &out)) {\n-            Ok(*) => fail!(), Err(*) => {}\n+            Ok(..) => fail!(), Err(..) => {}\n         }\n         assert!(!out.exists());\n     })\n@@ -1121,8 +1121,8 @@ mod test {\n     test!(fn readlink_not_symlink() {\n         let tmpdir = tmpdir();\n         match io::result(|| readlink(&*tmpdir)) {\n-            Ok(*) => fail!(\"wanted a failure\"),\n-            Err(*) => {}\n+            Ok(..) => fail!(\"wanted a failure\"),\n+            Err(..) => {}\n         }\n     })\n \n@@ -1142,13 +1142,13 @@ mod test {\n \n         // can't link to yourself\n         match io::result(|| link(&input, &input)) {\n-            Ok(*) => fail!(\"wanted a failure\"),\n-            Err(*) => {}\n+            Ok(..) => fail!(\"wanted a failure\"),\n+            Err(..) => {}\n         }\n         // can't link to something that doesn't exist\n         match io::result(|| link(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\"))) {\n-            Ok(*) => fail!(\"wanted a failure\"),\n-            Err(*) => {}\n+            Ok(..) => fail!(\"wanted a failure\"),\n+            Err(..) => {}\n         }\n     })\n \n@@ -1162,8 +1162,8 @@ mod test {\n         assert!(stat(&file).perm & io::UserWrite == 0);\n \n         match io::result(|| chmod(&tmpdir.join(\"foo\"), io::UserRWX)) {\n-            Ok(*) => fail!(\"wanted a failure\"),\n-            Err(*) => {}\n+            Ok(..) => fail!(\"wanted a failure\"),\n+            Err(..) => {}\n         }\n \n         chmod(&file, io::UserFile);\n@@ -1218,7 +1218,7 @@ mod test {\n \n         match io::result(|| File::open_mode(&tmpdir.join(\"a\"), io::Open,\n                                             io::Read)) {\n-            Ok(*) => fail!(), Err(*) => {}\n+            Ok(..) => fail!(), Err(..) => {}\n         }\n         File::open_mode(&tmpdir.join(\"b\"), io::Open, io::Write).unwrap();\n         File::open_mode(&tmpdir.join(\"c\"), io::Open, io::ReadWrite).unwrap();\n@@ -1233,7 +1233,7 @@ mod test {\n             let mut f = File::open_mode(&tmpdir.join(\"h\"), io::Open,\n                                         io::Read).unwrap();\n             match io::result(|| f.write(\"wut\".as_bytes())) {\n-                Ok(*) => fail!(), Err(*) => {}\n+                Ok(..) => fail!(), Err(..) => {}\n             }\n         }\n         assert_eq!(stat(&tmpdir.join(\"h\")).size, 3);\n@@ -1267,8 +1267,8 @@ mod test {\n         let tmpdir = tmpdir();\n \n         match io::result(|| change_file_times(&tmpdir.join(\"a\"), 100, 200)) {\n-            Ok(*) => fail!(),\n-            Err(*) => {}\n+            Ok(..) => fail!(),\n+            Err(..) => {}\n         }\n     }\n }"}, {"sha": "8b680020fd9178cb5ddf00608a2b0db27f570373", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -1047,7 +1047,7 @@ pub trait Buffer: Reader {\n         let mut buf = [0, ..4];\n         match self.read(buf.mut_slice_to(width)) {\n             Some(n) if n == width => {}\n-            Some(*) | None => return None // read error\n+            Some(..) | None => return None // read error\n         }\n         match str::from_utf8_slice_opt(buf.slice_to(width)) {\n             Some(s) => Some(s.char_at(0)),"}, {"sha": "218040b72d6b9dacd884551f4f2d51f6ce5ac5df", "filename": "src/libstd/io/native/file.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Fio%2Fnative%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Fio%2Fnative%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnative%2Ffile.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -114,7 +114,7 @@ impl FileDesc {\n \n impl io::Reader for FileDesc {\n     fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n-        match self.inner_read(buf) { Ok(n) => Some(n), Err(*) => None }\n+        match self.inner_read(buf) { Ok(n) => Some(n), Err(..) => None }\n     }\n     fn eof(&mut self) -> bool { false }\n }"}, {"sha": "1b61485273754385bed2aee4a16bd5932ccaae9d", "filename": "src/libstd/io/native/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Fio%2Fnative%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Fio%2Fnative%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnative%2Fprocess.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -129,7 +129,7 @@ impl rtio::RtioProcess for Process {\n         // and we kill it, then on unix we might ending up killing a\n         // newer process that happens to have the same (re-used) id\n         match self.exit_code {\n-            Some(*) => return Err(io::IoError {\n+            Some(..) => return Err(io::IoError {\n                 kind: io::OtherIoError,\n                 desc: \"can't kill an exited process\",\n                 detail: None,"}, {"sha": "6a97a21673d29b38540d0a0063c704240565f15e", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -56,8 +56,8 @@ pub struct SocketAddr {\n impl ToStr for SocketAddr {\n     fn to_str(&self) -> ~str {\n         match self.ip {\n-            Ipv4Addr(*) => format!(\"{}:{}\", self.ip.to_str(), self.port),\n-            Ipv6Addr(*) => format!(\"[{}]:{}\", self.ip.to_str(), self.port),\n+            Ipv4Addr(..) => format!(\"{}:{}\", self.ip.to_str(), self.port),\n+            Ipv6Addr(..) => format!(\"[{}]:{}\", self.ip.to_str(), self.port),\n         }\n     }\n }"}, {"sha": "fe0385c9a957198c476282d8a58cbe5574e008c7", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -247,7 +247,7 @@ impl StdWriter {\n                     }\n                 }\n             }\n-            File(*) => {\n+            File(..) => {\n                 io_error::cond.raise(IoError {\n                     kind: OtherIoError,\n                     desc: \"stream is not a tty\",\n@@ -273,7 +273,7 @@ impl StdWriter {\n                     Err(e) => io_error::cond.raise(e),\n                 }\n             }\n-            File(*) => {\n+            File(..) => {\n                 io_error::cond.raise(IoError {\n                     kind: OtherIoError,\n                     desc: \"stream is not a tty\",\n@@ -286,8 +286,8 @@ impl StdWriter {\n     /// Returns whether this stream is attached to a TTY instance or not.\n     pub fn isatty(&self) -> bool {\n         match self.inner {\n-            TTY(*) => true,\n-            File(*) => false,\n+            TTY(..) => true,\n+            File(..) => false,\n         }\n     }\n }"}, {"sha": "a72bc6b832863e0700e35d599f0804b9d57596bb", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -57,15 +57,13 @@\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://static.rust-lang.org/doc/master\")];\n \n-#[feature(macro_rules, globs, asm, managed_boxes)];\n+#[feature(macro_rules, globs, asm, managed_boxes, thread_local)];\n \n // Don't link to std. We are std.\n #[no_std];\n \n #[deny(non_camel_case_types)];\n #[deny(missing_doc)];\n-#[allow(unrecognized_lint)]; // NOTE: remove after the next snapshot\n-#[allow(cstack)]; // NOTE: remove after the next snapshot.\n \n // When testing libstd, bring in libuv as the I/O backend so tests can print\n // things and all of the std::io tests have an I/O interface to run on top"}, {"sha": "3433176961463ba7b31843facd71fef1cca23a85", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -386,7 +386,7 @@ pub fn self_exe_path() -> Option<Path> {\n \n         match io::result(|| io::fs::readlink(&Path::new(\"/proc/self/exe\"))) {\n             Ok(Some(path)) => Some(path.as_vec().to_owned()),\n-            Ok(None) | Err(*) => None\n+            Ok(None) | Err(..) => None\n         }\n     }\n "}, {"sha": "081673e86cb5099ad81bc86bffa4b3586041a332", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -550,7 +550,7 @@ impl<'self> TyVisitor for ReprVisitor<'self> {\n                         _align: uint)\n                         -> bool {\n         match self.var_stk.pop() {\n-            SearchingFor(*) => fail!(\"enum value matched no variant\"),\n+            SearchingFor(..) => fail!(\"enum value matched no variant\"),\n             _ => true\n         }\n     }"}, {"sha": "afcf092b4f6cb251f9726a5eff1907fb79cdb08c", "filename": "src/libstd/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -178,15 +178,15 @@ impl<T, E: ToStr> Result<T, E> {\n     pub fn iter<'r>(&'r self) -> OptionIterator<&'r T> {\n         match *self {\n             Ok(ref t) => Some(t),\n-            Err(*) => None,\n+            Err(..) => None,\n         }.move_iter()\n     }\n \n     /// Returns an `Iterator` over one or zero references to the value of an `Err`\n     #[inline]\n     pub fn iter_err<'r>(&'r self) -> OptionIterator<&'r E> {\n         match *self {\n-            Ok(*) => None,\n+            Ok(..) => None,\n             Err(ref t) => Some(t),\n         }.move_iter()\n     }"}, {"sha": "418557f659b0092c3dd2ad1063d9599b115162f9", "filename": "src/libstd/rt/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Frt%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Frt%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcontext.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -97,10 +97,10 @@ impl Context {\n     pub fn swap(out_context: &mut Context, in_context: &Context) {\n         rtdebug!(\"swapping contexts\");\n         let out_regs: &mut Registers = match out_context {\n-            &Context { regs: ~ref mut r, _ } => r\n+            &Context { regs: ~ref mut r, .. } => r\n         };\n         let in_regs: &Registers = match in_context {\n-            &Context { regs: ~ref r, _ } => r\n+            &Context { regs: ~ref r, .. } => r\n         };\n \n         rtdebug!(\"noting the stack limit and doing raw swap\");"}, {"sha": "803938589afcf3a26f7ca07a48218589248b80eb", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -21,10 +21,9 @@ use unstable::finally::Finally;\n \n #[cfg(windows)]               // mingw-w32 doesn't like thread_local things\n #[cfg(target_os = \"android\")] // see #10686\n-#[cfg(stage0)] // only remove this attribute after the next snapshot\n pub use self::native::*;\n \n-#[cfg(not(stage0), not(windows), not(target_os = \"android\"))]\n+#[cfg(not(windows), not(target_os = \"android\"))]\n pub use self::compiled::*;\n \n /// Borrow the thread-local value from thread-local storage."}, {"sha": "78ec32ead3ccba1816dd809138e71daa2ed3fbfd", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -96,7 +96,7 @@ pub mod shouldnt_be_public {\n     pub use super::select::SelectInner;\n     pub use super::select::{SelectInner, SelectPortInner};\n     pub use super::local_ptr::native::maybe_tls_key;\n-    #[cfg(not(stage0), not(windows), not(target_os = \"android\"))]\n+    #[cfg(not(windows), not(target_os = \"android\"))]\n     pub use super::local_ptr::compiled::RT_TLS_PTR;\n }\n "}, {"sha": "d66bd1e4135650b6a03b1e2112bbba896e4a1ec6", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -588,7 +588,7 @@ impl Scheduler {\n                 transmute_mut_region(*next_task.sched.get_mut_ref());\n \n             let current_task: &mut Task = match sched.cleanup_job {\n-                Some(CleanupJob { task: ref task, _ }) => {\n+                Some(CleanupJob { task: ref task, .. }) => {\n                     let task_ptr: *~Task = task;\n                     transmute_mut_region(*transmute_mut_unsafe(task_ptr))\n                 }"}, {"sha": "e5f7c08912ae3cd711e645f527a5356ff6d82b41", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -335,7 +335,7 @@ impl Task {\n     pub fn is_home_no_tls(&self, sched: &~Scheduler) -> bool {\n         match self.task_type {\n             GreenTask(Some(AnySched)) => { false }\n-            GreenTask(Some(Sched(SchedHandle { sched_id: ref id, _}))) => {\n+            GreenTask(Some(Sched(SchedHandle { sched_id: ref id, .. }))) => {\n                 *id == sched.sched_id()\n             }\n             GreenTask(None) => {\n@@ -351,7 +351,7 @@ impl Task {\n     pub fn homed(&self) -> bool {\n         match self.task_type {\n             GreenTask(Some(AnySched)) => { false }\n-            GreenTask(Some(Sched(SchedHandle { _ }))) => { true }\n+            GreenTask(Some(Sched(SchedHandle { .. }))) => { true }\n             GreenTask(None) => {\n                 rtabort!(\"task without home\");\n             }\n@@ -372,7 +372,7 @@ impl Task {\n                     rtdebug!(\"anysched task in sched check ****\");\n                     sched_run_anything\n                 }\n-                GreenTask(Some(Sched(SchedHandle { sched_id: ref id, _ }))) => {\n+                GreenTask(Some(Sched(SchedHandle { sched_id: ref id, ..}))) => {\n                     rtdebug!(\"homed task in sched check ****\");\n                     *id == sched_id\n                 }\n@@ -470,7 +470,7 @@ impl Coroutine {\n     /// Destroy coroutine and try to reuse stack segment.\n     pub fn recycle(self, stack_pool: &mut StackPool) {\n         match self {\n-            Coroutine { current_stack_segment, _ } => {\n+            Coroutine { current_stack_segment, .. } => {\n                 stack_pool.give_segment(current_stack_segment);\n             }\n         }"}, {"sha": "97209e99bd67027e46258440df22773e43608fac", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -374,7 +374,7 @@ fn chunk(n: uint, idx: uint) -> uint {\n fn find_mut<'r, T>(child: &'r mut Child<T>, key: uint, idx: uint) -> Option<&'r mut T> {\n     match *child {\n         External(stored, ref mut value) if stored == key => Some(value),\n-        External(*) => None,\n+        External(..) => None,\n         Internal(ref mut x) => find_mut(&mut x.children[chunk(key, idx)], key, idx + 1),\n         Nothing => None\n     }\n@@ -426,7 +426,7 @@ fn remove<T>(count: &mut uint, child: &mut Child<T>, key: uint,\n             _ => fail!()\n         }\n       }\n-      External(*) => (None, false),\n+      External(..) => (None, false),\n       Internal(ref mut x) => {\n           let ret = remove(&mut x.count, &mut x.children[chunk(key, idx)],\n                            key, idx + 1);"}, {"sha": "89a51a5ddddd3e4956e72f96638d08ab064626c7", "filename": "src/libstd/unstable/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Funstable%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Funstable%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fintrinsics.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -177,7 +177,6 @@ extern \"rust-intrinsic\" {\n     pub fn abort() -> !;\n \n     /// Execute a breakpoint trap, for inspection by a debugger.\n-    #[cfg(not(stage0))]\n     pub fn breakpoint();\n \n     /// Atomic compare and exchange, sequentially consistent."}, {"sha": "02b35992f8c40cbeea89e68fbd35a68ec744f1fe", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -455,7 +455,7 @@ impl<T:Send> Exclusive<T> {\n         let Exclusive { x: x } = self;\n         // Someday we might need to unkillably unwrap an Exclusive, but not today.\n         let inner = x.unwrap();\n-        let ExData { data: user_data, _ } = inner; // will destroy the LittleLock\n+        let ExData { data: user_data, .. } = inner; // will destroy the LittleLock\n         user_data\n     }\n }"}, {"sha": "d75c60c0bf2c29d90aefa1a03629a14e35fff6c7", "filename": "src/libstd/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibstd%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Futil.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -209,7 +209,7 @@ mod bench {\n         let x = [1,2,3,4,5,6];\n         bh.iter(|| {\n             let _q = match x {\n-                [1,2,3,.._] => 10,\n+                [1,2,3,..] => 10,\n                 _ => 11\n             };\n         });"}, {"sha": "7bde8083b50f3c3a732f1fe9a8742c481c2133aa", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -618,7 +618,7 @@ pub enum token_tree {\n \n     // a kleene-style repetition sequence with a span, a tt_forest,\n     // an optional separator, and a boolean where true indicates\n-    // zero or more (*), and false indicates one or more (+).\n+    // zero or more (..), and false indicates one or more (+).\n     tt_seq(Span, @~[token_tree], Option<::parse::token::Token>, bool),\n \n     // a syntactic variable that will be filled in by macro expansion."}, {"sha": "aed6af3d7ed0da3ec39d25b9d774ff42190a056a", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -226,7 +226,7 @@ impl Ctx {\n         }\n         visit::walk_fn(self, fk, decl, body, sp, id, ());\n         match *fk {\n-            visit::fk_method(*) => { self.path.pop(); }\n+            visit::fk_method(..) => { self.path.pop(); }\n             _ => {}\n         }\n     }\n@@ -338,7 +338,7 @@ impl Visitor<()> for Ctx {\n             item_mod(_) | item_foreign_mod(_) => {\n                 self.path.push(path_mod(i.ident));\n             }\n-            item_impl(*) => {} // this was guessed above.\n+            item_impl(..) => {} // this was guessed above.\n             _ => self.path.push(path_name(i.ident))\n         }\n         visit::walk_item(self, i, ());\n@@ -407,7 +407,7 @@ pub fn map_decoded_item(diag: @mut span_handler,\n     // don't decode and instantiate the impl, but just the method, we have to\n     // add it to the table now. Likewise with foreign items.\n     match *ii {\n-        ii_item(*) => {} // fallthrough\n+        ii_item(..) => {} // fallthrough\n         ii_foreign(i) => {\n             cx.map.insert(i.id, node_foreign_item(i,\n                                                   AbiSet::Intrinsic(),\n@@ -431,16 +431,16 @@ pub fn node_id_to_str(map: map, id: NodeId, itr: @ident_interner) -> ~str {\n       Some(&node_item(item, path)) => {\n         let path_str = path_ident_to_str(path, item.ident, itr);\n         let item_str = match item.node {\n-          item_static(*) => ~\"static\",\n-          item_fn(*) => ~\"fn\",\n-          item_mod(*) => ~\"mod\",\n-          item_foreign_mod(*) => ~\"foreign mod\",\n-          item_ty(*) => ~\"ty\",\n-          item_enum(*) => ~\"enum\",\n-          item_struct(*) => ~\"struct\",\n-          item_trait(*) => ~\"trait\",\n-          item_impl(*) => ~\"impl\",\n-          item_mac(*) => ~\"macro\"\n+          item_static(..) => ~\"static\",\n+          item_fn(..) => ~\"fn\",\n+          item_mod(..) => ~\"mod\",\n+          item_foreign_mod(..) => ~\"foreign mod\",\n+          item_ty(..) => ~\"ty\",\n+          item_enum(..) => ~\"enum\",\n+          item_struct(..) => ~\"struct\",\n+          item_trait(..) => ~\"trait\",\n+          item_impl(..) => ~\"impl\",\n+          item_mac(..) => ~\"macro\"\n         };\n         format!(\"{} {} (id={})\", item_str, path_str, id)\n       }"}, {"sha": "dcb15ad85df539856f9f5f7365db08b4204287a4", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -45,7 +45,7 @@ pub fn stmt_id(s: &Stmt) -> NodeId {\n       StmtDecl(_, id) => id,\n       StmtExpr(_, id) => id,\n       StmtSemi(_, id) => id,\n-      StmtMac(*) => fail!(\"attempted to analyze unexpanded stmt\")\n+      StmtMac(..) => fail!(\"attempted to analyze unexpanded stmt\")\n     }\n }\n \n@@ -194,7 +194,7 @@ pub fn float_ty_to_str(t: float_ty) -> ~str {\n }\n \n pub fn is_call_expr(e: @Expr) -> bool {\n-    match e.node { ExprCall(*) => true, _ => false }\n+    match e.node { ExprCall(..) => true, _ => false }\n }\n \n pub fn block_from_expr(e: @Expr) -> Block {\n@@ -338,7 +338,7 @@ impl inlined_item_utils for inlined_item {\n  referring to a def_self */\n pub fn is_self(d: ast::Def) -> bool {\n   match d {\n-    DefSelf(*)           => true,\n+    DefSelf(..)           => true,\n     DefUpvar(_, d, _, _) => is_self(*d),\n     _                     => false\n   }\n@@ -537,8 +537,8 @@ impl<'self, O: IdVisitingOperation> Visitor<()> for IdVisitor<'self, O> {\n                 env: ()) {\n         if !self.pass_through_items {\n             match *function_kind {\n-                visit::fk_method(*) if self.visited_outermost => return,\n-                visit::fk_method(*) => self.visited_outermost = true,\n+                visit::fk_method(..) if self.visited_outermost => return,\n+                visit::fk_method(..) => self.visited_outermost = true,\n                 _ => {}\n             }\n         }\n@@ -570,7 +570,7 @@ impl<'self, O: IdVisitingOperation> Visitor<()> for IdVisitor<'self, O> {\n \n         if !self.pass_through_items {\n             match *function_kind {\n-                visit::fk_method(*) => self.visited_outermost = false,\n+                visit::fk_method(..) => self.visited_outermost = false,\n                 _ => {}\n             }\n         }\n@@ -631,7 +631,7 @@ pub fn compute_id_range_for_inlined_item(item: &inlined_item) -> id_range {\n \n pub fn is_item_impl(item: @ast::item) -> bool {\n     match item.node {\n-       item_impl(*) => true,\n+       item_impl(..) => true,\n        _            => false\n     }\n }\n@@ -706,7 +706,7 @@ pub fn struct_def_is_tuple_like(struct_def: &ast::struct_def) -> bool {\n /// and false otherwise.\n pub fn pat_is_ident(pat: @ast::Pat) -> bool {\n     match pat.node {\n-        ast::PatIdent(*) => true,\n+        ast::PatIdent(..) => true,\n         _ => false,\n     }\n }"}, {"sha": "05a65de16b8a16dadc0d4d17d4e1fe89b81d1c4e", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -459,8 +459,8 @@ impl IntType {\n     #[inline]\n     pub fn is_signed(self) -> bool {\n         match self {\n-            SignedInt(*) => true,\n-            UnsignedInt(*) => false\n+            SignedInt(..) => true,\n+            UnsignedInt(..) => false\n         }\n     }\n     fn is_ffi_safe(self) -> bool {"}, {"sha": "a773fe8497c25cce13216cf61d95d9b6b7937a4d", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -340,7 +340,7 @@ impl ExtCtxt {\n     pub fn expand_expr(@self, mut e: @ast::Expr) -> @ast::Expr {\n         loop {\n             match e.node {\n-                ast::ExprMac(*) => {\n+                ast::ExprMac(..) => {\n                     let extsbox = @mut syntax_expander_table();\n                     let expander = expand::MacroExpander {\n                         extsbox: extsbox,\n@@ -358,7 +358,7 @@ impl ExtCtxt {\n     pub fn cfg(&self) -> ast::CrateConfig { self.cfg.clone() }\n     pub fn call_site(&self) -> Span {\n         match *self.backtrace {\n-            Some(@ExpnInfo {call_site: cs, _}) => cs,\n+            Some(@ExpnInfo {call_site: cs, ..}) => cs,\n             None => self.bug(\"missing top span\")\n         }\n     }\n@@ -381,7 +381,7 @@ impl ExtCtxt {\n     pub fn bt_pop(&self) {\n         match *self.backtrace {\n             Some(@ExpnInfo {\n-                call_site: Span {expn_info: prev, _}, _}) => {\n+                call_site: Span {expn_info: prev, ..}, ..}) => {\n                 *self.backtrace = prev\n             }\n             _ => self.bug(\"tried to pop without a push\")"}, {"sha": "11e316e3e6bd65fd4df630b67180eaa572d6073e", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -44,7 +44,7 @@ pub fn expand_syntax_ext(cx: @base::ExtCtxt,\n                     ast::lit_bool(b) => {\n                         accumulator.push_str(format!(\"{}\", b));\n                     }\n-                    ast::lit_binary(*) => {\n+                    ast::lit_binary(..) => {\n                         cx.span_err(e.span, \"cannot concatenate a binary literal\");\n                     }\n                 }"}, {"sha": "0f83f725223477f14e65067e92330af626326430", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -87,16 +87,16 @@ fn cs_clone(\n             ctor_ident = variant.node.name;\n             all_fields = af;\n         },\n-        EnumNonMatching(*) => cx.span_bug(span,\n+        EnumNonMatching(..) => cx.span_bug(span,\n                                           format!(\"Non-matching enum variants in `deriving({})`\",\n                                                name)),\n-        StaticEnum(*) | StaticStruct(*) => cx.span_bug(span,\n+        StaticEnum(..) | StaticStruct(..) => cx.span_bug(span,\n                                                        format!(\"Static method in `deriving({})`\",\n                                                             name))\n     }\n \n     match *all_fields {\n-        [FieldInfo { name: None, _ }, .. _] => {\n+        [FieldInfo { name: None, .. }, ..] => {\n             // enum-like\n             let subcalls = all_fields.map(|field| subcall(field.self_));\n             cx.expr_call_ident(span, ctor_ident, subcalls)"}, {"sha": "3ecdd5e60fe97134b509f5d71ec5a397cdeb878d", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -67,7 +67,7 @@ fn default_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Exp\n                 }\n             }\n         }\n-        StaticEnum(*) => {\n+        StaticEnum(..) => {\n             cx.span_fatal(span, \"`Default` cannot be derived for enums, \\\n                                  only structs\")\n         }"}, {"sha": "e882650f046b14f9fee137dead23910708148972", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -1087,7 +1087,7 @@ pub fn cs_fold(use_foldl: bool,\n         EnumNonMatching(ref all_enums) => enum_nonmatch_f(cx, trait_span,\n                                                           *all_enums,\n                                                           substructure.nonself_args),\n-        StaticEnum(*) | StaticStruct(*) => {\n+        StaticEnum(..) | StaticStruct(..) => {\n             cx.span_bug(trait_span, \"Static function in `deriving`\")\n         }\n     }\n@@ -1125,7 +1125,7 @@ pub fn cs_same_method(f: |@ExtCtxt, Span, ~[@Expr]| -> @Expr,\n         EnumNonMatching(ref all_enums) => enum_nonmatch_f(cx, trait_span,\n                                                           *all_enums,\n                                                           substructure.nonself_args),\n-        StaticEnum(*) | StaticStruct(*) => {\n+        StaticEnum(..) | StaticStruct(..) => {\n             cx.span_bug(trait_span, \"Static function in `deriving`\")\n         }\n     }"}, {"sha": "f291d2b751db24ad35b6bc1f964a4988448e80ee", "filename": "src/libsyntax/ext/deriving/iter_bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fiter_bytes.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -82,7 +82,7 @@ fn iter_bytes_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @\n         _ => cx.span_bug(span, \"Impossible substructure in `deriving(IterBytes)`\")\n     }\n \n-    for &FieldInfo { self_, _ } in fields.iter() {\n+    for &FieldInfo { self_, .. } in fields.iter() {\n         exprs.push(call_iterbytes(self_));\n     }\n "}, {"sha": "b26a3a09f045b55504bf5d6ad57417eebc14253a", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -69,7 +69,7 @@ fn cs_from(name: &str, cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr\n     };\n \n     match *substr.fields {\n-        StaticStruct(*) => {\n+        StaticStruct(..) => {\n             cx.span_err(span, \"`FromPrimitive` cannot be derived for structs\");\n             return cx.expr_fail(span, @\"\");\n         }"}, {"sha": "193dc4965fc631221a262ed8c31d99f855373f18", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -66,7 +66,7 @@ fn to_str_substructure(cx: @ExtCtxt, span: Span,\n                 stmts.push(cx.stmt_expr(call));\n             };\n \n-            for (i, &FieldInfo {name, span, self_, _}) in fields.iter().enumerate() {\n+            for (i, &FieldInfo {name, span, self_, .. }) in fields.iter().enumerate() {\n                 if i > 0 {\n                     push(cx.expr_str(span, @\", \"));\n                 }\n@@ -96,9 +96,9 @@ fn to_str_substructure(cx: @ExtCtxt, span: Span,\n \n         EnumMatching(_, variant, ref fields) => {\n             match variant.node.kind {\n-                ast::tuple_variant_kind(*) =>\n+                ast::tuple_variant_kind(..) =>\n                     doit(\"(\", @\")\", variant.node.name, *fields),\n-                ast::struct_variant_kind(*) =>\n+                ast::struct_variant_kind(..) =>\n                     doit(\"{\", @\"}\", variant.node.name, *fields),\n             }\n         }"}, {"sha": "af6379d476e682308707e7d71d160d5ae40fa889", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -182,8 +182,8 @@ impl<'self> Ty<'self> {\n             Literal(ref p) => {\n                 p.to_path(cx, span, self_ty, self_generics)\n             }\n-            Ptr(*) => { cx.span_bug(span, \"Pointer in a path in generic `deriving`\") }\n-            Tuple(*) => { cx.span_bug(span, \"Tuple in a path in generic `deriving`\") }\n+            Ptr(..) => { cx.span_bug(span, \"Pointer in a path in generic `deriving`\") }\n+            Tuple(..) => { cx.span_bug(span, \"Tuple in a path in generic `deriving`\") }\n         }\n     }\n }"}, {"sha": "1fdb41316891c51371c6cff2fb3b3fc4c5ce53bc", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -83,7 +83,7 @@ fn zero_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n                 }\n             }\n         }\n-        StaticEnum(*) => {\n+        StaticEnum(..) => {\n             cx.span_fatal(span, \"`Zero` cannot be derived for enums, \\\n                                  only structs\")\n         }"}, {"sha": "85839691b48fb9bf3444ec15c44cdeb7f456959a", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -313,7 +313,7 @@ pub fn expand_item(extsbox: @mut SyntaxEnv,\n                    fld: &MacroExpander)\n                    -> SmallVector<@ast::item> {\n     match it.node {\n-        ast::item_mac(*) => expand_item_mac(extsbox, cx, it, fld),\n+        ast::item_mac(..) => expand_item_mac(extsbox, cx, it, fld),\n         ast::item_mod(_) | ast::item_foreign_mod(_) => {\n             cx.mod_push(it.ident);\n             let macro_escape = contains_macro_escape(it.attrs);\n@@ -342,7 +342,7 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n     let (pth, tts, ctxt) = match it.node {\n         item_mac(codemap::Spanned {\n             node: mac_invoc_tt(ref pth, ref tts, ctxt),\n-            _\n+            ..\n         }) => {\n             (pth, (*tts).clone(), ctxt)\n         }\n@@ -430,8 +430,8 @@ fn insert_macro(exts: SyntaxEnv, name: ast::Name, transformer: @Transformer) {\n     let is_non_escaping_block =\n         |t : &@Transformer| -> bool{\n         match t {\n-            &@BlockInfo(BlockInfo {macros_escape:false,_}) => true,\n-            &@BlockInfo(BlockInfo {_}) => false,\n+            &@BlockInfo(BlockInfo {macros_escape:false,..}) => true,\n+            &@BlockInfo(BlockInfo {..}) => false,\n             _ => fail!(\"special identifier {:?} was bound to a non-BlockInfo\",\n                         special_block_name)\n         }\n@@ -1400,7 +1400,7 @@ mod test {\n         visit::walk_crate(&mut path_finder, &renamed_ast, ());\n \n         match path_finder.path_accumulator {\n-            [ast::Path{segments:[ref seg],_}] =>\n+            [ast::Path{segments:[ref seg],..}] =>\n                 assert_eq!(mtwt_resolve(seg.identifier),a2_name),\n             _ => assert_eq!(0,1)\n         }\n@@ -1415,7 +1415,7 @@ mod test {\n         let mut path_finder = new_path_finder(~[]);\n         visit::walk_crate(&mut path_finder, &double_renamed, ());\n         match path_finder.path_accumulator {\n-            [ast::Path{segments:[ref seg],_}] =>\n+            [ast::Path{segments:[ref seg],..}] =>\n                 assert_eq!(mtwt_resolve(seg.identifier),a3_name),\n             _ => assert_eq!(0,1)\n         }"}, {"sha": "c7354b0601c1fade7a25aece2564dbbdf7794b75", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -125,7 +125,7 @@ impl Context {\n     /// format strings.\n     fn verify_piece(&mut self, p: &parse::Piece) {\n         match *p {\n-            parse::String(*) => {}\n+            parse::String(..) => {}\n             parse::CurrentArgument => {\n                 if self.nest_level == 0 {\n                     self.ecx.span_err(self.fmtsp,\n@@ -173,7 +173,7 @@ impl Context {\n \n     fn verify_count(&mut self, c: parse::Count) {\n         match c {\n-            parse::CountImplied | parse::CountIs(*) => {}\n+            parse::CountImplied | parse::CountIs(..) => {}\n             parse::CountIsParam(i) => {\n                 self.verify_arg_type(Left(i), Unsigned);\n             }"}, {"sha": "fe7699f36bb2304a54b5178b9407f6566e07c4a1", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -553,7 +553,7 @@ fn mk_tt(cx: @ExtCtxt, sp: Span, tt: &ast::token_tree)\n         }\n \n         ast::tt_delim(ref tts) => mk_tts(cx, sp, **tts),\n-        ast::tt_seq(*) => fail!(\"tt_seq in quote!\"),\n+        ast::tt_seq(..) => fail!(\"tt_seq in quote!\"),\n \n         ast::tt_nonterminal(sp, ident) => {\n "}, {"sha": "c0c5c6c6c079c83bca7a706637259008753bdf52", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -128,13 +128,13 @@ pub fn expand_include_bin(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n // recur along an ExpnInfo chain to find the original expression\n fn topmost_expn_info(expn_info: @codemap::ExpnInfo) -> @codemap::ExpnInfo {\n     match *expn_info {\n-        ExpnInfo { call_site: ref call_site, _ } => {\n+        ExpnInfo { call_site: ref call_site, .. } => {\n             match call_site.expn_info {\n                 Some(next_expn_info) => {\n                     match *next_expn_info {\n                         ExpnInfo {\n-                            callee: NameAndSpan { name: ref name, _ },\n-                            _\n+                            callee: NameAndSpan { name: ref name, .. },\n+                            ..\n                         } => {\n                             // Don't recurse into file using \"include!\"\n                             if \"include\" == *name  {"}, {"sha": "3da2eac1a3d07effd816c3478182dc8887d523d6", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -193,8 +193,8 @@ pub fn nameize(p_s: @mut ParseSess, ms: &[matcher], res: &[@named_match])\n     fn n_rec(p_s: @mut ParseSess, m: &matcher, res: &[@named_match],\n              ret_val: &mut HashMap<Ident, @named_match>) {\n         match *m {\n-          codemap::Spanned {node: match_tok(_), _} => (),\n-          codemap::Spanned {node: match_seq(ref more_ms, _, _, _, _), _} => {\n+          codemap::Spanned {node: match_tok(_), .. } => (),\n+          codemap::Spanned {node: match_seq(ref more_ms, _, _, _, _), .. } => {\n             for next_m in more_ms.iter() {\n                 n_rec(p_s, next_m, res, ret_val)\n             };"}, {"sha": "58a114a2de0cfd73f434c2cf16965cd3b88d8f6d", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -156,7 +156,7 @@ fn lockstep_iter_size(t: &token_tree, r: &mut TtReader) -> lis {\n             lis_merge(lis, lis2)\n         })\n       }\n-      tt_tok(*) => lis_unconstrained,\n+      tt_tok(..) => lis_unconstrained,\n       tt_nonterminal(_, name) => match *lookup_cur_matched(r, name) {\n         matched_nonterminal(_) => lis_unconstrained,\n         matched_seq(ref ads, _) => lis_constraint(ads.len(), name)\n@@ -290,7 +290,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                 r.stack.idx += 1u;\n                 return ret_val;\n               }\n-              matched_seq(*) => {\n+              matched_seq(..) => {\n                 r.sp_diag.span_fatal(\n                     r.cur_span, /* blame the macro writer */\n                     format!(\"variable '{}' is still repeating at this depth\","}, {"sha": "351eab35a77fbfdb5aa6e352fa53a0c926a55244", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -22,8 +22,6 @@\n #[crate_type = \"lib\"];\n \n #[feature(macro_rules, globs, managed_boxes)];\n-#[allow(unrecognized_lint)]; // NOTE: remove after the next snapshot\n-#[allow(cstack)]; // NOTE: remove after the next snapshot.\n \n extern mod extra;\n "}, {"sha": "18e45a20fed83f9faeb4c3ef2f6c5a20ee5c0a57", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -35,7 +35,7 @@ impl parser_attr for Parser {\n             debug!(\"parse_outer_attributes: self.token={:?}\",\n                    self.token);\n             match *self.token {\n-              token::INTERPOLATED(token::nt_attr(*)) => {\n+              token::INTERPOLATED(token::nt_attr(..)) => {\n                 attrs.push(self.parse_attribute(false));\n               }\n               token::POUND => {\n@@ -121,7 +121,7 @@ impl parser_attr for Parser {\n         let mut next_outer_attrs: ~[ast::Attribute] = ~[];\n         loop {\n             let attr = match *self.token {\n-                token::INTERPOLATED(token::nt_attr(*)) => {\n+                token::INTERPOLATED(token::nt_attr(..)) => {\n                     self.parse_attribute(true)\n                 }\n                 token::POUND => {\n@@ -164,7 +164,7 @@ impl parser_attr for Parser {\n                 // FIXME #623 Non-string meta items are not serialized correctly;\n                 // just forbid them for now\n                 match lit.node {\n-                    ast::lit_str(*) => (),\n+                    ast::lit_str(..) => (),\n                     _ => {\n                         self.span_err(\n                             lit.span,"}, {"sha": "81b98e537f49635b5a148c331e9e74f08a73a0f7", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -23,12 +23,12 @@ use ast;\n // isn't parsed as (if true {...} else {...} | x) | 5\n pub fn expr_requires_semi_to_be_stmt(e: @ast::Expr) -> bool {\n     match e.node {\n-      ast::ExprIf(*)\n-      | ast::ExprMatch(*)\n+      ast::ExprIf(..)\n+      | ast::ExprMatch(..)\n       | ast::ExprBlock(_)\n-      | ast::ExprWhile(*)\n-      | ast::ExprLoop(*)\n-      | ast::ExprForLoop(*)\n+      | ast::ExprWhile(..)\n+      | ast::ExprLoop(..)\n+      | ast::ExprForLoop(..)\n       | ast::ExprCall(_, _, ast::DoSugar)\n       | ast::ExprCall(_, _, ast::ForSugar)\n       | ast::ExprMethodCall(_, _, _, _, _, ast::DoSugar)\n@@ -40,7 +40,7 @@ pub fn expr_requires_semi_to_be_stmt(e: @ast::Expr) -> bool {\n pub fn expr_is_simple_block(e: @ast::Expr) -> bool {\n     match e.node {\n         ast::ExprBlock(\n-            ast::Block { rules: ast::DefaultBlock, _ }\n+            ast::Block { rules: ast::DefaultBlock, .. }\n         ) => true,\n       _ => false\n     }\n@@ -58,7 +58,7 @@ pub fn stmt_ends_with_semi(stmt: &ast::Stmt) -> bool {\n             }\n         }\n         ast::StmtExpr(e, _) => { expr_requires_semi_to_be_stmt(e) }\n-        ast::StmtSemi(*) => { false }\n-        ast::StmtMac(*) => { false }\n+        ast::StmtSemi(..) => { false }\n+        ast::StmtMac(..) => { false }\n     }\n }"}, {"sha": "3e4a421cfbaec1239fe76f3ff75b400235fd19ee", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 39, "deletions": 42, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -447,7 +447,7 @@ impl Parser {\n     pub fn commit_expr(&self, e: @Expr, edible: &[token::Token], inedible: &[token::Token]) {\n         debug!(\"commit_expr {:?}\", e);\n         match e.node {\n-            ExprPath(*) => {\n+            ExprPath(..) => {\n                 // might be unit-struct construction; check for recoverableinput error.\n                 let expected = vec::append(edible.to_owned(), inedible);\n                 self.check_for_erroneous_unit_struct_expecting(expected);\n@@ -486,7 +486,7 @@ impl Parser {\n                 self.bump();\n                 i\n             }\n-            token::INTERPOLATED(token::nt_ident(*)) => {\n+            token::INTERPOLATED(token::nt_ident(..)) => {\n                 self.bug(\"ident interpolation not converted to real token\");\n             }\n             _ => {\n@@ -835,7 +835,7 @@ impl Parser {\n \n     pub fn token_is_lifetime(&self, tok: &token::Token) -> bool {\n         match *tok {\n-            token::LIFETIME(*) => true,\n+            token::LIFETIME(..) => true,\n             _ => false,\n         }\n     }\n@@ -1280,13 +1280,13 @@ impl Parser {\n                                      -> ty_ {\n         // ~'foo fn() or ~fn() are parsed directly as obsolete fn types:\n         match *self.token {\n-            token::LIFETIME(*) => {\n+            token::LIFETIME(..) => {\n                 let lifetime = self.parse_lifetime();\n                 self.obsolete(*self.last_span, ObsoleteBoxedClosure);\n                 return self.parse_ty_closure(Some(sigil), Some(lifetime));\n             }\n \n-            token::IDENT(*) => {\n+            token::IDENT(..) => {\n                 if self.token_is_old_style_closure_keyword() {\n                     self.obsolete(*self.last_span, ObsoleteBoxedClosure);\n                     return self.parse_ty_closure(Some(sigil), None);\n@@ -1574,7 +1574,7 @@ impl Parser {\n     /// parses 0 or 1 lifetime\n     pub fn parse_opt_lifetime(&self) -> Option<ast::Lifetime> {\n         match *self.token {\n-            token::LIFETIME(*) => {\n+            token::LIFETIME(..) => {\n                 Some(self.parse_lifetime())\n             }\n             _ => {\n@@ -2108,7 +2108,7 @@ impl Parser {\n                     );\n                     let (s, z) = p.parse_sep_and_zerok();\n                     let seq = match seq {\n-                        Spanned { node, _ } => node,\n+                        Spanned { node, .. } => node,\n                     };\n                     tt_seq(\n                         mk_sp(sp.lo, p.span.hi),\n@@ -2274,13 +2274,13 @@ impl Parser {\n                 hi = e.span.hi;\n                 // HACK: turn &[...] into a &-evec\n                 ex = match e.node {\n-                  ExprVec(*) | ExprLit(@codemap::Spanned {\n-                    node: lit_str(*), span: _\n+                  ExprVec(..) | ExprLit(@codemap::Spanned {\n+                    node: lit_str(..), span: _\n                   })\n                   if m == MutImmutable => {\n                     ExprVstore(e, ExprVstoreSlice)\n                   }\n-                  ExprVec(*) if m == MutMutable => {\n+                  ExprVec(..) if m == MutMutable => {\n                     ExprVstore(e, ExprVstoreMutSlice)\n                   }\n                   _ => ExprAddrOf(m, e)\n@@ -2296,11 +2296,11 @@ impl Parser {\n             hi = e.span.hi;\n             // HACK: turn @[...] into a @-evec\n             ex = match e.node {\n-              ExprVec(*) | ExprRepeat(*) if m == MutMutable =>\n+              ExprVec(..) | ExprRepeat(..) if m == MutMutable =>\n                 ExprVstore(e, ExprVstoreMutBox),\n-              ExprVec(*) |\n-              ExprLit(@codemap::Spanned { node: lit_str(*), span: _}) |\n-              ExprRepeat(*) if m == MutImmutable => ExprVstore(e, ExprVstoreBox),\n+              ExprVec(..) |\n+              ExprLit(@codemap::Spanned { node: lit_str(..), span: _}) |\n+              ExprRepeat(..) if m == MutImmutable => ExprVstore(e, ExprVstoreBox),\n               _ => self.mk_unary(UnBox(m), e)\n             };\n           }\n@@ -2311,9 +2311,9 @@ impl Parser {\n             hi = e.span.hi;\n             // HACK: turn ~[...] into a ~-evec\n             ex = match e.node {\n-              ExprVec(*) |\n-              ExprLit(@codemap::Spanned { node: lit_str(*), span: _}) |\n-              ExprRepeat(*) => ExprVstore(e, ExprVstoreUniq),\n+              ExprVec(..) |\n+              ExprLit(@codemap::Spanned { node: lit_str(..), span: _}) |\n+              ExprRepeat(..) => ExprVstore(e, ExprVstoreUniq),\n               _ => self.mk_unary(UnUniq, e)\n             };\n           }\n@@ -2564,8 +2564,8 @@ impl Parser {\n                                                  ~[last_arg],\n                                                  sugar))\n             }\n-            ExprPath(*) | ExprCall(*) | ExprMethodCall(*) |\n-                ExprParen(*) => {\n+            ExprPath(..) | ExprCall(..) | ExprMethodCall(..) |\n+                ExprParen(..) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n@@ -2742,18 +2742,17 @@ impl Parser {\n                     let subpat = self.parse_pat();\n                     match subpat {\n                         @ast::Pat { id, node: PatWild, span } => {\n-                            // NOTE #5830 activate after snapshot\n-                            // self.obsolete(*self.span, ObsoleteVecDotDotWildcard);\n+                            self.obsolete(*self.span, ObsoleteVecDotDotWildcard);\n                             slice = Some(@ast::Pat {\n                                 id: id,\n                                 node: PatWildMulti,\n                                 span: span\n                             })\n                         },\n-                        @ast::Pat { node: PatIdent(_, _, _), _ } => {\n+                        @ast::Pat { node: PatIdent(_, _, _), .. } => {\n                             slice = Some(subpat);\n                         }\n-                        @ast::Pat { span, _ } => self.span_fatal(\n+                        @ast::Pat { span, .. } => self.span_fatal(\n                             span, \"expected an identifier or nothing\"\n                         )\n                     }\n@@ -2782,8 +2781,7 @@ impl Parser {\n \n             etc = *self.token == token::UNDERSCORE || *self.token == token::DOTDOT;\n             if *self.token == token::UNDERSCORE {\n-                // NOTE #5830 activate after snapshot\n-                // self.obsolete(*self.span, ObsoleteStructWildcard);\n+                self.obsolete(*self.span, ObsoleteStructWildcard);\n             }\n             if etc {\n                 self.bump();\n@@ -2848,8 +2846,8 @@ impl Parser {\n             pat = match sub.node {\n               PatLit(e@@Expr {\n                 node: ExprLit(@codemap::Spanned {\n-                    node: lit_str(*),\n-                    span: _}), _\n+                    node: lit_str(..),\n+                    span: _}), ..\n               }) => {\n                 let vst = @Expr {\n                     id: ast::DUMMY_NODE_ID,\n@@ -2876,8 +2874,8 @@ impl Parser {\n             pat = match sub.node {\n               PatLit(e@@Expr {\n                 node: ExprLit(@codemap::Spanned {\n-                    node: lit_str(*),\n-                    span: _}), _\n+                    node: lit_str(..),\n+                    span: _}), ..\n               }) => {\n                 let vst = @Expr {\n                     id: ast::DUMMY_NODE_ID,\n@@ -2904,8 +2902,8 @@ impl Parser {\n               // HACK: parse &\"...\" as a literal of a borrowed str\n               pat = match sub.node {\n                   PatLit(e@@Expr {\n-                      node: ExprLit(@codemap::Spanned {\n-                            node: lit_str(*), span: _}), _\n+                      node: ExprLit(@codemap::Spanned{ node: lit_str(..), .. }),\n+                      ..\n                   }) => {\n                       let vst = @Expr {\n                           id: ast::DUMMY_NODE_ID,\n@@ -3056,8 +3054,7 @@ impl Parser {\n                                 // This is a \"top constructor only\" pat\n                                 self.bump();\n                                 if is_star {\n-                                    // NOTE #5830 activate after snapshot\n-                                    // self.obsolete(*self.span, ObsoleteEnumWildcard);\n+                                    self.obsolete(*self.span, ObsoleteEnumWildcard);\n                                 }\n                                 self.bump();\n                                 self.expect(&token::RPAREN);\n@@ -3330,7 +3327,7 @@ impl Parser {\n             attrs_remaining: attrs_remaining,\n             view_items: view_items,\n             items: items,\n-            _\n+            ..\n         } = self.parse_items_and_view_items(first_item_attrs,\n                                             false, false);\n \n@@ -3478,7 +3475,7 @@ impl Parser {\n                     }\n                     self.bump();\n                 }\n-                token::MOD_SEP | token::IDENT(*) => {\n+                token::MOD_SEP | token::IDENT(..) => {\n                     let tref = self.parse_trait_ref();\n                     result.push(TraitTyParamBound(tref));\n                 }\n@@ -3702,7 +3699,7 @@ impl Parser {\n                 sty_uniq(MutImmutable)\n             }, self)\n           }\n-          token::IDENT(*) if self.is_self_ident() => {\n+          token::IDENT(..) if self.is_self_ident() => {\n             self.bump();\n             sty_value(MutImmutable)\n           }\n@@ -3952,7 +3949,7 @@ impl Parser {\n                         ref_id: node_id\n                     })\n                 }\n-                ty_path(*) => {\n+                ty_path(..) => {\n                     self.span_err(ty.span,\n                                   \"bounded traits are only valid in type position\");\n                     None\n@@ -4129,7 +4126,7 @@ impl Parser {\n             attrs_remaining: attrs_remaining,\n             view_items: view_items,\n             items: starting_items,\n-            _\n+            ..\n         } = self.parse_items_and_view_items(first_item_attrs, true, true);\n         let mut items: ~[@item] = starting_items;\n         let attrs_remaining_len = attrs_remaining.len();\n@@ -4386,7 +4383,7 @@ impl Parser {\n         }\n \n         let (named, maybe_path, ident) = match *self.token {\n-            token::IDENT(*) => {\n+            token::IDENT(..) => {\n                 let the_ident = self.parse_ident();\n                 let path = if *self.token == token::EQ {\n                     self.bump();\n@@ -5046,16 +5043,16 @@ impl Parser {\n                 }\n                 iovi_view_item(view_item) => {\n                     match view_item.node {\n-                        view_item_use(*) => {\n+                        view_item_use(..) => {\n                             // `extern mod` must precede `use`.\n                             extern_mod_allowed = false;\n                         }\n-                        view_item_extern_mod(*)\n+                        view_item_extern_mod(..)\n                         if !extern_mod_allowed => {\n                             self.span_err(view_item.span,\n                                           \"\\\"extern mod\\\" declarations are not allowed here\");\n                         }\n-                        view_item_extern_mod(*) => {}\n+                        view_item_extern_mod(..) => {}\n                     }\n                     view_items.push(view_item);\n                 }"}, {"sha": "8f8b956315ff870ac592fc159b2c427641753bdd", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -217,17 +217,17 @@ pub fn to_str(input: @ident_interner, t: &Token) -> ~str {\n             _ => {\n                 ~\"an interpolated \" +\n                     match (*nt) {\n-                      nt_item(*) => ~\"item\",\n-                      nt_block(*) => ~\"block\",\n-                      nt_stmt(*) => ~\"statement\",\n-                      nt_pat(*) => ~\"pattern\",\n-                      nt_attr(*) => fail!(\"should have been handled\"),\n-                      nt_expr(*) => fail!(\"should have been handled above\"),\n-                      nt_ty(*) => ~\"type\",\n-                      nt_ident(*) => ~\"identifier\",\n-                      nt_path(*) => ~\"path\",\n-                      nt_tt(*) => ~\"tt\",\n-                      nt_matchers(*) => ~\"matcher sequence\"\n+                      nt_item(..) => ~\"item\",\n+                      nt_block(..) => ~\"block\",\n+                      nt_stmt(..) => ~\"statement\",\n+                      nt_pat(..) => ~\"pattern\",\n+                      nt_attr(..) => fail!(\"should have been handled\"),\n+                      nt_expr(..) => fail!(\"should have been handled above\"),\n+                      nt_ty(..) => ~\"type\",\n+                      nt_ident(..) => ~\"identifier\",\n+                      nt_path(..) => ~\"path\",\n+                      nt_tt(..) => ~\"tt\",\n+                      nt_matchers(..) => ~\"matcher sequence\"\n                     }\n             }\n         }\n@@ -260,10 +260,10 @@ pub fn can_begin_expr(t: &Token) -> bool {\n       BINOP(OR) => true, // in lambda syntax\n       OROR => true, // in lambda syntax\n       MOD_SEP => true,\n-      INTERPOLATED(nt_expr(*))\n-      | INTERPOLATED(nt_ident(*))\n-      | INTERPOLATED(nt_block(*))\n-      | INTERPOLATED(nt_path(*)) => true,\n+      INTERPOLATED(nt_expr(..))\n+      | INTERPOLATED(nt_ident(..))\n+      | INTERPOLATED(nt_block(..))\n+      | INTERPOLATED(nt_path(..)) => true,\n       _ => false\n     }\n }\n@@ -303,7 +303,7 @@ pub fn is_ident(t: &Token) -> bool {\n \n pub fn is_ident_or_path(t: &Token) -> bool {\n     match *t {\n-      IDENT(_, _) | INTERPOLATED(nt_path(*)) => true,\n+      IDENT(_, _) | INTERPOLATED(nt_path(..)) => true,\n       _ => false\n     }\n }"}, {"sha": "9c1023c6cb84a2e32a717c15513189678b6de950", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -625,7 +625,7 @@ pub fn print_item(s: @ps, item: &ast::item) {\n       }\n       // I think it's reasonable to hide the context here:\n       ast::item_mac(codemap::Spanned { node: ast::mac_invoc_tt(ref pth, ref tts, _),\n-                                   _}) => {\n+                                   ..}) => {\n         print_visibility(s, item.vis);\n         print_path(s, pth, false);\n         word(s.s, \"! \");\n@@ -706,7 +706,7 @@ pub fn print_struct(s: @ps,\n             popen(s);\n             commasep(s, inconsistent, struct_def.fields, |s, field| {\n                 match field.node.kind {\n-                    ast::named_field(*) => fail!(\"unexpected named field\"),\n+                    ast::named_field(..) => fail!(\"unexpected named field\"),\n                     ast::unnamed_field => {\n                         maybe_print_comment(s, field.span.lo);\n                         print_type(s, &field.node.ty);\n@@ -955,7 +955,7 @@ pub fn print_possibly_embedded_block_(s: @ps,\n                                       attrs: &[ast::Attribute],\n                                       close_box: bool) {\n     match blk.rules {\n-      ast::UnsafeBlock(*) => word_space(s, \"unsafe\"),\n+      ast::UnsafeBlock(..) => word_space(s, \"unsafe\"),\n       ast::DefaultBlock => ()\n     }\n     maybe_print_comment(s, blk.span.lo);\n@@ -1215,7 +1215,7 @@ pub fn print_expr(s: @ps, expr: &ast::Expr) {\n         print_mutability(s, m);\n         // Avoid `& &e` => `&&e`.\n         match (m, &expr.node) {\n-            (ast::MutImmutable, &ast::ExprAddrOf(*)) => space(s.s),\n+            (ast::MutImmutable, &ast::ExprAddrOf(..)) => space(s.s),\n             _ => { }\n         }\n         print_expr(s, expr);\n@@ -1639,7 +1639,7 @@ pub fn print_pat(s: @ps, pat: &ast::Pat) {\n       ast::PatEnum(ref path, ref args_) => {\n         print_path(s, path, true);\n         match *args_ {\n-          None => word(s.s, \"(*)\"),\n+          None => word(s.s, \"(..)\"),\n           Some(ref args) => {\n             if !args.is_empty() {\n               popen(s);\n@@ -1666,7 +1666,7 @@ pub fn print_pat(s: @ps, pat: &ast::Pat) {\n                       get_span);\n         if etc {\n             if fields.len() != 0u { word_space(s, \",\"); }\n-            word(s.s, \"_\");\n+            word(s.s, \"..\");\n         }\n         word(s.s, \"}\");\n       }\n@@ -1703,7 +1703,7 @@ pub fn print_pat(s: @ps, pat: &ast::Pat) {\n         for &p in slice.iter() {\n             if !before.is_empty() { word_space(s, \",\"); }\n             match p {\n-                @ast::Pat { node: ast::PatWildMulti, _ } => {\n+                @ast::Pat { node: ast::PatWildMulti, .. } => {\n                     // this case is handled by print_pat\n                 }\n                 _ => word(s.s, \"..\"),"}, {"sha": "0e07ee23b6761dcbdb7b1377177418a1698acdb4", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -21,7 +21,7 @@ impl<T> Container for SmallVector<T> {\n     fn len(&self) -> uint {\n         match *self {\n             Zero => 0,\n-            One(*) => 1,\n+            One(..) => 1,\n             Many(ref vals) => vals.len()\n         }\n     }\n@@ -53,7 +53,7 @@ impl<T> SmallVector<T> {\n     pub fn push(&mut self, v: T) {\n         match *self {\n             Zero => *self = One(v),\n-            One(*) => {\n+            One(..) => {\n                 let one = util::replace(self, Zero);\n                 match one {\n                     One(v1) => util::replace(self, Many(~[v1, v])),\n@@ -99,7 +99,7 @@ impl<T> Iterator<T> for SmallVectorMoveIterator<T> {\n     fn next(&mut self) -> Option<T> {\n         match *self {\n             ZeroIterator => None,\n-            OneIterator(*) => {\n+            OneIterator(..) => {\n                 let mut replacement = ZeroIterator;\n                 util::swap(self, &mut replacement);\n                 match replacement {\n@@ -114,7 +114,7 @@ impl<T> Iterator<T> for SmallVectorMoveIterator<T> {\n     fn size_hint(&self) -> (uint, Option<uint>) {\n         match *self {\n             ZeroIterator => (0, Some(0)),\n-            OneIterator(*) => (1, Some(1)),\n+            OneIterator(..) => (1, Some(1)),\n             ManyIterator(ref inner) => inner.size_hint()\n         }\n     }"}, {"sha": "4100104dd61e147ae64b33feb3a315d2ede47a31", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -47,7 +47,7 @@ pub fn name_of_fn(fk: &fn_kind) -> Ident {\n       fk_item_fn(name, _, _, _) | fk_method(name, _, _) => {\n           name\n       }\n-      fk_anon(*) | fk_fn_block(*) => parse::token::special_idents::anon,\n+      fk_anon(..) | fk_fn_block(..) => parse::token::special_idents::anon,\n     }\n }\n \n@@ -57,7 +57,7 @@ pub fn generics_of_fn(fk: &fn_kind) -> Generics {\n         fk_method(_, generics, _) => {\n             (*generics).clone()\n         }\n-        fk_anon(*) | fk_fn_block(*) => {\n+        fk_anon(..) | fk_fn_block(..) => {\n             Generics {\n                 lifetimes: opt_vec::Empty,\n                 ty_params: opt_vec::Empty,\n@@ -501,7 +501,7 @@ pub fn walk_fn<E:Clone, V:Visitor<E>>(visitor: &mut V,\n \n             visitor.visit_explicit_self(&method.explicit_self, env.clone());\n         }\n-        fk_anon(*) | fk_fn_block(*) => {\n+        fk_anon(..) | fk_fn_block(..) => {\n         }\n     }\n "}, {"sha": "f9d1d1f6cf26c06262045ab8e32c0e51a9de244b", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -1,3 +1,11 @@\n+S 2013-11-28 859c3ba\n+  freebsd-x86_64 4110bb67408e382623b6c55e997e2c34342dc98d\n+  linux-i386 072e638a6a11f7d00cf2c7b487162d0d2e3b5036\n+  linux-x86_64 bf6d926e5da26e41f3697aa2e997c270c02a7965\n+  macos-i386 470635a2cc9b71d05833ca483e0a9ecca1c9f97d\n+  macos-x86_64 f4c78234f13df7e4505b31d01f3b2cc6aa01f384\n+  winnt-i386 4929d471d01175641e2b797c61450637abcc585f\n+\n S 2013-11-10 b5e602a\n   freebsd-x86_64 bdcfcfa63216559765b83fe4056abb953da25da0\n   linux-i386 0fb5cdff8a46e9a02bcdba100803bb5504b6f332"}, {"sha": "5eca6546ea92c68f86fbf1abadbc3147258b6c96", "filename": "src/test/compile-fail/match-vec-mismatch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-vec-mismatch.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n     match ~\"foo\" {\n-        ['f', 'o', .._] => { } //~ ERROR mismatched types: expected `~str` but found a vector pattern\n+        ['f', 'o', ..] => { } //~ ERROR mismatched types: expected `~str` but found a vector pattern\n         _ => { }\n     }\n }"}, {"sha": "54e25aea09b1bbf5b08fcfb8f33970345226631c", "filename": "src/test/compile-fail/match-vec-unreachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-vec-unreachable.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -7,7 +7,7 @@ fn main() {\n     }\n \n     match ~[~\"foo\", ~\"bar\", ~\"baz\"] {\n-        [a, _, _, .._] => { println(a); }\n+        [a, _, _, ..] => { println(a); }\n         [~\"foo\", ~\"bar\", ~\"baz\", ~\"foo\", ~\"bar\"] => { } //~ ERROR unreachable pattern\n         _ => { }\n     }"}, {"sha": "e728b9c2fd76e2b67bbe915f046f862241113373", "filename": "src/test/compile-fail/non-exhaustive-match.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-exhaustive-match.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -36,8 +36,8 @@ fn main() {\n       (b, b) => {}\n     }\n     match ~[Some(42), None, Some(21)] { //~ ERROR non-exhaustive patterns: vectors of length 0 not covered\n-        [Some(*), None, ..tail] => {}\n-        [Some(*), Some(*), ..tail] => {}\n+        [Some(..), None, ..tail] => {}\n+        [Some(..), Some(..), ..tail] => {}\n         [None] => {}\n     }\n     match ~[1] {\n@@ -51,10 +51,10 @@ fn main() {\n         [] => ()\n     }\n     match ~[Some(42), None, Some(21)] {\n-        [Some(*), None, ..tail] => {}\n-        [Some(*), Some(*), ..tail] => {}\n+        [Some(..), None, ..tail] => {}\n+        [Some(..), Some(..), ..tail] => {}\n         [None, None, ..tail] => {}\n-        [None, Some(*), ..tail] => {}\n+        [None, Some(..), ..tail] => {}\n         [Some(_)] => {}\n         [None] => {}\n         [] => {}"}, {"sha": "47d0a226a56ac5c1a11a731e5a21a031e168c7f8", "filename": "src/test/compile-fail/pattern-error-continue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Fcompile-fail%2Fpattern-error-continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Fcompile-fail%2Fpattern-error-continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-error-continue.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -29,7 +29,7 @@ fn main() {\n         _ => ()\n     }\n     match 'c' {\n-        S { _ } => (),   //~ ERROR mismatched types: expected `char` but found a structure pattern\n+        S { .. } => (),   //~ ERROR mismatched types: expected `char` but found a structure pattern\n \n         _ => ()\n     }"}, {"sha": "8af57468b190a2ed3457f4e624d5dd57bb0b03ff", "filename": "src/test/debug-info/destructured-fn-argument.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Fdebug-info%2Fdestructured-fn-argument.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Fdebug-info%2Fdestructured-fn-argument.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fdestructured-fn-argument.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -221,7 +221,7 @@ fn ignored_tuple_element((m, _, n): (int, u16, i32)) {\n     zzz();\n }\n \n-fn ignored_struct_field(Struct { b: o, _ }: Struct) {\n+fn ignored_struct_field(Struct { b: o, .. }: Struct) {\n     zzz();\n }\n \n@@ -262,7 +262,7 @@ fn ref_binding_in_tuple((ref ff, gg): (int, (int, int))) {\n     zzz();\n }\n \n-fn ref_binding_in_struct(Struct { b: ref hh, _ }: Struct) {\n+fn ref_binding_in_struct(Struct { b: ref hh, .. }: Struct) {\n     zzz();\n }\n "}, {"sha": "cd17906623ef1e3949d4e174368ffe9b7c2bdfa9", "filename": "src/test/debug-info/destructured-local.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Fdebug-info%2Fdestructured-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Fdebug-info%2Fdestructured-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fdestructured-local.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -157,7 +157,7 @@ fn main() {\n     let (m, _, n) = (14, 15, 16);\n \n     // ignored struct field\n-    let Struct { b: o, _ } = Struct { a: 17, b: 18 };\n+    let Struct { b: o, .. } = Struct { a: 17, b: 18 };\n \n     // one struct destructured, one not\n     let (Struct { a: p, b: q }, r) = (Struct { a: 19, b: 20 }, Struct { a: 21, b: 22 });\n@@ -188,7 +188,7 @@ fn main() {\n     let (ref ff, gg) = (46, (47, 48));\n \n     // ref binding in struct\n-    let Struct { b: ref hh, _ } = Struct { a: 49, b: 50 };\n+    let Struct { b: ref hh, .. } = Struct { a: 49, b: 50 };\n \n     // univariant enum\n     let Unit(ii) = Unit(51);"}, {"sha": "7cb68e9890d29a242b9fdf2a28d3b1bcfb07444b", "filename": "src/test/debug-info/lexical-scope-in-match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Fdebug-info%2Flexical-scope-in-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Fdebug-info%2Flexical-scope-in-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Flexical-scope-in-match.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -116,7 +116,7 @@ fn main() {\n \n     match Struct { x: 239, y: 240 } {\n         // ignored field\n-        Struct { x: shadowed, _ } => {\n+        Struct { x: shadowed, .. } => {\n \n             zzz();\n             sentinel();"}, {"sha": "eaca18be93a1368f469a087af9b5d5f040a9c07b", "filename": "src/test/run-pass/const-enum-byref-self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fconst-enum-byref-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fconst-enum-byref-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-byref-self.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -15,7 +15,7 @@ impl E {\n     pub fn method(&self) {\n         match *self {\n             V => {}\n-            VV(*) => fail!()\n+            VV(..) => fail!()\n         }\n     }\n }"}, {"sha": "ee7e3c7c66300ec85b7963e2506c650670a5f0bf", "filename": "src/test/run-pass/const-enum-byref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fconst-enum-byref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fconst-enum-byref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-byref.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -14,7 +14,7 @@ static C: E = V;\n fn f(a: &E) {\n     match *a {\n         V => {}\n-        VV(*) => fail!()\n+        VV(..) => fail!()\n     }\n }\n "}, {"sha": "8b5e98f6ebadef82864e67b99e3598b49afc942f", "filename": "src/test/run-pass/const-enum-structlike.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fconst-enum-structlike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fconst-enum-structlike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-enum-structlike.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -19,7 +19,7 @@ static C: E = S1 { u: 23 };\n \n pub fn main() {\n     match C {\n-        S0 { _ } => fail!(),\n+        S0 { .. } => fail!(),\n         S1 { u } => assert!(u == 23)\n     }\n }"}, {"sha": "37dc48ebda406e38a227d488b7a3e2153255257c", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -58,13 +58,13 @@ fn test_destroy_actually_kills(force: bool) {\n \n     #[cfg(unix,not(target_os=\"android\"))]\n     fn process_exists(pid: libc::pid_t) -> bool {\n-        let run::ProcessOutput {output, _} = run::process_output(\"ps\", [~\"-p\", pid.to_str()]);\n+        let run::ProcessOutput {output, ..} = run::process_output(\"ps\", [~\"-p\", pid.to_str()]);\n         str::from_utf8(output).contains(pid.to_str())\n     }\n \n     #[cfg(unix,target_os=\"android\")]\n     fn process_exists(pid: libc::pid_t) -> bool {\n-        let run::ProcessOutput {output, _} = run::process_output(\"/system/bin/ps\", [pid.to_str()]);\n+        let run::ProcessOutput {output, ..} = run::process_output(\"/system/bin/ps\", [pid.to_str()]);\n         str::from_utf8(output).contains(~\"root\")\n     }\n "}, {"sha": "cba12e9199b2966925db31d2d692f14f8d0664cd", "filename": "src/test/run-pass/func-arg-incomplete-pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Ffunc-arg-incomplete-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Ffunc-arg-incomplete-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffunc-arg-incomplete-pattern.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -6,7 +6,7 @@ struct Foo {\n     y: ~uint,\n }\n \n-fn foo(Foo {x, _}: Foo) -> *uint {\n+fn foo(Foo {x, ..}: Foo) -> *uint {\n     let addr: *uint = &*x;\n     addr\n }"}, {"sha": "b176254a878bf77c6f321e126ec4e835aceb681f", "filename": "src/test/run-pass/ignore-all-the-things.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fignore-all-the-things.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fignore-all-the-things.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fignore-all-the-things.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -13,16 +13,14 @@ struct Bar{a: int, b: int, c: int, d: int}\n \n pub fn main() {\n     let Foo(..) = Foo(5, 5, 5, 5);\n-    let Foo(*) = Foo(5, 5, 5, 5);\n+    let Foo(..) = Foo(5, 5, 5, 5);\n     let Bar{..} = Bar{a: 5, b: 5, c: 5, d: 5};\n-    let Bar{_} = Bar{a: 5, b: 5, c: 5, d: 5};\n     //let (..) = (5, 5, 5, 5);\n     //let Foo(a, b, ..) = Foo(5, 5, 5, 5);\n     //let Foo(.., d) = Foo(5, 5, 5, 5);\n     //let (a, b, ..) = (5, 5, 5, 5);\n     //let (.., c, d) = (5, 5, 5, 5);\n     let Bar{b: b, ..} = Bar{a: 5, b: 5, c: 5, d: 5};\n-    let Bar{b: b, _} = Bar{a: 5, b: 5, c: 5, d: 5};\n     match [5, 5, 5, 5] {\n         [..] => { }\n     }\n@@ -36,15 +34,15 @@ pub fn main() {\n         [a, .., b] => { }\n     }\n     match [5, 5, 5] {\n-        [.._] => { }\n+        [..] => { }\n     }\n     match [5, 5, 5] {\n-        [a, .._] => { }\n+        [a, ..] => { }\n     }\n     match [5, 5, 5] {\n-        [.._, a] => { }\n+        [.., a] => { }\n     }\n     match [5, 5, 5] {\n-        [a, .._, b] => { }\n+        [a, .., b] => { }\n     }\n }"}, {"sha": "d8e4d04dded544ddce224e609da2155cb83c90bb", "filename": "src/test/run-pass/issue-1701.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fissue-1701.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fissue-1701.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1701.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -16,10 +16,10 @@ enum animal { cat(pattern), dog(breed), rabbit(name, ear_kind), tiger }\n \n fn noise(a: animal) -> Option<~str> {\n     match a {\n-      cat(*)    => { Some(~\"meow\") }\n-      dog(*)    => { Some(~\"woof\") }\n-      rabbit(*) => { None }\n-      tiger(*)  => { Some(~\"roar\") }\n+      cat(..)    => { Some(~\"meow\") }\n+      dog(..)    => { Some(~\"woof\") }\n+      rabbit(..) => { None }\n+      tiger(..)  => { Some(~\"roar\") }\n     }\n }\n "}, {"sha": "9c1e782ffce19cdf24e0d162854a56bcbc7567aa", "filename": "src/test/run-pass/issue-4875.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fissue-4875.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fissue-4875.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4875.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -14,7 +14,7 @@ pub struct Foo<T> {\n     data: T,\n }\n \n-fn foo<T>(Foo{_}: Foo<T>) {\n+fn foo<T>(Foo{..}: Foo<T>) {\n }\n \n pub fn main() {"}, {"sha": "e82a8a7313eee4fa951bf7a8715fbcead76aec46", "filename": "src/test/run-pass/issue-8351-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fissue-8351-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fissue-8351-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8351-1.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -19,7 +19,7 @@ pub fn main() {\n     let e = Foo{f: 0};\n     match e {\n         Foo{f: 1} => fail!(),\n-        Foo{_} => (),\n+        Foo{..} => (),\n         _ => fail!(),\n     }\n }"}, {"sha": "a4d8296c8725828791a455a73ab281e555564e1d", "filename": "src/test/run-pass/match-enum-struct-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fmatch-enum-struct-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fmatch-enum-struct-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-enum-struct-1.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -18,7 +18,7 @@ enum E {\n pub fn main() {\n     let e = Foo{f: 1};\n     match e {\n-        Foo{_} => (),\n+        Foo{..} => (),\n         _ => fail!(),\n     }\n     match e {"}, {"sha": "769a5ab5460a7150c65b5b7607461373ca87ef20", "filename": "src/test/run-pass/match-struct-0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fmatch-struct-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fmatch-struct-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-struct-0.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -16,7 +16,7 @@ pub fn main() {\n     let f = Foo{f: 1};\n     match f {\n         Foo{f: 0} => fail!(),\n-        Foo{_} => (),\n+        Foo{..} => (),\n     }\n     match f {\n         Foo{f: 0} => fail!(),"}, {"sha": "fa4bec0271f0d96998fe2fdc16a96c9ff68415d5", "filename": "src/test/run-pass/nested-exhaustive-match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fnested-exhaustive-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fnested-exhaustive-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-exhaustive-match.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -12,9 +12,9 @@ struct Foo { foo: bool, bar: Option<int>, baz: int }\n \n pub fn main() {\n     match @Foo{foo: true, bar: Some(10), baz: 20} {\n-      @Foo{foo: true, bar: Some(_), _} => {}\n-      @Foo{foo: false, bar: None, _} => {}\n-      @Foo{foo: true, bar: None, _} => {}\n-      @Foo{foo: false, bar: Some(_), _} => {}\n+      @Foo{foo: true, bar: Some(_), ..} => {}\n+      @Foo{foo: false, bar: None, ..} => {}\n+      @Foo{foo: true, bar: None, ..} => {}\n+      @Foo{foo: false, bar: Some(_), ..} => {}\n     }\n }"}, {"sha": "ccb6ec59ed1baddb5e38a08c294b3cd55c2ffa42", "filename": "src/test/run-pass/nested-patterns.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fnested-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fnested-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-patterns.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -18,12 +18,12 @@ struct C { c: int }\n pub fn main() {\n     match A {a: 10, b: @20} {\n         x@A {a, b: @20} => { assert!(x.a == 10); assert!(a == 10); }\n-        A {b: _b, _} => { fail!(); }\n+        A {b: _b, ..} => { fail!(); }\n     }\n-    let mut x@B {b, _} = B {a: 10, b: C {c: 20}};\n+    let mut x@B {b, ..} = B {a: 10, b: C {c: 20}};\n     x.b.c = 30;\n     assert_eq!(b.c, 20);\n-    let mut y@D {d, _} = D {a: 10, d: C {c: 20}};\n+    let mut y@D {d, ..} = D {a: 10, d: C {c: 20}};\n     y.d.c = 30;\n     assert_eq!(d.c, 20);\n }"}, {"sha": "acb7fe12360e1607ca6c676de9a8291ac4f1f555", "filename": "src/test/run-pass/nullable-pointer-iotareduction.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -26,13 +26,13 @@ enum E<T> { Thing(int, T), Nothing((), ((), ()), [i8, ..0]) }\n impl<T> E<T> {\n     fn is_none(&self) -> bool {\n         match *self {\n-            Thing(*) => false,\n-            Nothing(*) => true\n+            Thing(..) => false,\n+            Nothing(..) => true\n         }\n     }\n     fn get_ref<'r>(&'r self) -> (int, &'r T) {\n         match *self {\n-            Nothing(*) => fail!(\"E::get_ref(Nothing::<%s>)\",  stringify!($T)),\n+            Nothing(..) => fail!(\"E::get_ref(Nothing::<%s>)\",  stringify!($T)),\n             Thing(x, ref y) => (x, y)\n         }\n     }"}, {"sha": "ff87cceba1913238e6074c610b12cf0f84878101", "filename": "src/test/run-pass/record-pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Frecord-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Frecord-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frecord-pat.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -14,7 +14,7 @@ enum t3 { c(T2, uint), }\n \n fn m(input: t3) -> int {\n     match input {\n-      c(T2 {x: a(m), _}, _) => { return m; }\n+      c(T2 {x: a(m), ..}, _) => { return m; }\n       c(T2 {x: b(m), y: y}, z) => { return ((m + z) as int) + y; }\n     }\n }"}, {"sha": "de619685ca4267f745cc37771704dbec162fe77d", "filename": "src/test/run-pass/regions-dependent-addr-of.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fregions-dependent-addr-of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fregions-dependent-addr-of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-dependent-addr-of.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -63,21 +63,21 @@ fn get_v6_a<'v>(a: &'v A, _i: uint) -> &'v int {\n \n fn get_v6_b<'v>(a: &'v A, _i: uint) -> &'v int {\n     match *a {\n-        A { value: B { v6: Some(ref v), _ } } => &v.f,\n+        A { value: B { v6: Some(ref v), .. } } => &v.f,\n         _ => fail!()\n     }\n }\n \n fn get_v6_c<'v>(a: &'v A, _i: uint) -> &'v int {\n     match a {\n-        &A { value: B { v6: Some(ref v), _ } } => &v.f,\n+        &A { value: B { v6: Some(ref v), .. } } => &v.f,\n         _ => fail!()\n     }\n }\n \n fn get_v5_ref<'v>(a: &'v A, _i: uint) -> &'v int {\n     match &a.value {\n-        &B {v5: ~C {f: ref v}, _} => v\n+        &B {v5: ~C {f: ref v}, ..} => v\n     }\n }\n "}, {"sha": "69dc27f216ddd98d147f709eea35ca8b27748f28", "filename": "src/test/run-pass/rtio-processes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Frtio-processes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Frtio-processes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frtio-processes.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -59,8 +59,8 @@ fn smoke_failure() {\n         io: io,\n     };\n     match io::result(|| Process::new(args)) {\n-        Ok(*) => fail!(),\n-        Err(*) => {}\n+        Ok(..) => fail!(),\n+        Err(..) => {}\n     }\n }\n "}, {"sha": "989f911134bb38056c4a29d96d920526219b5d59", "filename": "src/test/run-pass/tag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Ftag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Ftag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -22,7 +22,7 @@ impl Eq for colour {\n             }\n             green => {\n                 match (*other) {\n-                    red(*) => false,\n+                    red(..) => false,\n                     green => true\n                 }\n             }"}, {"sha": "acd1d63a6edff9a2047387a545cda72db01b7222", "filename": "src/test/run-pass/vec-matching-autoslice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fvec-matching-autoslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fvec-matching-autoslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching-autoslice.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -1,7 +1,7 @@\n pub fn main() {\n     let x = @[1, 2, 3];\n     match x {\n-        [2, .._] => fail!(),\n+        [2, ..] => fail!(),\n         [1, ..tail] => {\n             assert_eq!(tail, [2, 3]);\n         }"}, {"sha": "ed88dc3008a170b2e6e5390633a561df168feadf", "filename": "src/test/run-pass/vec-matching-fixed.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fvec-matching-fixed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fvec-matching-fixed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching-fixed.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -2,17 +2,17 @@ fn a() {\n     let x = [1, 2, 3];\n     match x {\n         [1, 2, 4] => unreachable!(),\n-        [0, 2, 3, .._] => unreachable!(),\n-        [0, .._, 3] => unreachable!(),\n-        [0, .._] => unreachable!(),\n+        [0, 2, 3, ..] => unreachable!(),\n+        [0, .., 3] => unreachable!(),\n+        [0, ..] => unreachable!(),\n         [1, 2, 3] => (),\n         [_, _, _] => unreachable!(),\n     }\n     match x {\n-        [.._] => (),\n+        [..] => (),\n     }\n     match x {\n-        [_, _, _, .._] => (),\n+        [_, _, _, ..] => (),\n     }\n     match x {\n         [a, b, c] => {"}, {"sha": "16c68afa47bab2548561d95be6e097af27f3c47e", "filename": "src/test/run-pass/vec-matching.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fvec-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fvec-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -1,9 +1,9 @@\n fn a() {\n     let x = ~[1];\n     match x {\n-        [_, _, _, _, _, .._] => fail!(),\n-        [.._, _, _, _, _] => fail!(),\n-        [_, .._, _, _] => fail!(),\n+        [_, _, _, _, _, ..] => fail!(),\n+        [.., _, _, _, _] => fail!(),\n+        [_, .., _, _] => fail!(),\n         [_, _] => fail!(),\n         [a] => {\n             assert_eq!(a, 1);\n@@ -51,17 +51,17 @@ fn b() {\n fn c() {\n     let x = [1];\n     match x {\n-        [2, .. _] => fail!(),\n-        [.. _] => ()\n+        [2, ..] => fail!(),\n+        [..] => ()\n     }\n }\n \n fn d() {\n     let x = [1, 2, 3];\n     let branch = match x {\n-        [1, 1, .. _] => 0,\n-        [1, 2, 3, .. _] => 1,\n-        [1, 2, .. _] => 2,\n+        [1, 1, ..] => 0,\n+        [1, 2, 3, ..] => 1,\n+        [1, 2, ..] => 2,\n         _ => 3\n     };\n     assert_eq!(branch, 1);"}, {"sha": "1ab9e17523d0ad1faf38ac6625a9f3e455bfae4e", "filename": "src/test/run-pass/vec-tail-matching.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf6964ecb67f4ffce6be75130ab7a3be793960ff/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-tail-matching.rs?ref=bf6964ecb67f4ffce6be75130ab7a3be793960ff", "patch": "@@ -16,7 +16,7 @@ pub fn main() {\n             assert!(tail[1].string == ~\"baz\");\n \n             match tail {\n-                [Foo { _ }, _, Foo { _ }, .. _tail] => {\n+                [Foo { .. }, _, Foo { .. }, .. _tail] => {\n                     unreachable!();\n                 }\n                 [Foo { string: ref a }, Foo { string: ref b }] => {"}]}