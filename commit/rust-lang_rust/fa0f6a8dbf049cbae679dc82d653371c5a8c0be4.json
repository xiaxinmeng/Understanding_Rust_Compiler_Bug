{"sha": "fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhMGY2YThkYmYwNDljYmFlNjc5ZGM4MmQ2NTMzNzFjNWE4YzBiZTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-23T00:27:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-06-23T00:27:02Z"}, "message": "Auto merge of #5711 - flip1995:rustup, r=flip1995\n\nRustup\n\nchangelog: none", "tree": {"sha": "35ebb9e0055ca5d7b579adbec485723f826c88b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35ebb9e0055ca5d7b579adbec485723f826c88b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "html_url": "https://github.com/rust-lang/rust/commit/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "742706511c9f33c6a0d4380392e513e5249057e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/742706511c9f33c6a0d4380392e513e5249057e3", "html_url": "https://github.com/rust-lang/rust/commit/742706511c9f33c6a0d4380392e513e5249057e3"}, {"sha": "51592f8587bd5dac9cb3f34fbd5896218a814677", "url": "https://api.github.com/repos/rust-lang/rust/commits/51592f8587bd5dac9cb3f34fbd5896218a814677", "html_url": "https://github.com/rust-lang/rust/commit/51592f8587bd5dac9cb3f34fbd5896218a814677"}], "stats": {"total": 414, "additions": 192, "deletions": 222}, "files": [{"sha": "fca9aaaff9dcea4d9d2cabb54df37e8df501c8bd", "filename": "clippy_lints/src/atomic_ordering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fatomic_ordering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fatomic_ordering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fatomic_ordering.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -70,7 +70,7 @@ fn match_ordering_def_path(cx: &LateContext<'_, '_>, did: DefId, orderings: &[&s\n \n fn check_atomic_load_store(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n     if_chain! {\n-        if let ExprKind::MethodCall(ref method_path, _, args) = &expr.kind;\n+        if let ExprKind::MethodCall(ref method_path, _, args, _) = &expr.kind;\n         let method = method_path.ident.name.as_str();\n         if type_is_atomic(cx, &args[0]);\n         if method == \"load\" || method == \"store\";"}, {"sha": "f92c564543b89bd46aba72bc7646a09bc190a7e9", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -247,7 +247,7 @@ fn simplify_not(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Option<String> {\n                 ))\n             })\n         },\n-        ExprKind::MethodCall(path, _, args) if args.len() == 1 => {\n+        ExprKind::MethodCall(path, _, args, _) if args.len() == 1 => {\n             let type_of_receiver = cx.tables.expr_ty(&args[0]);\n             if !is_type_diagnostic_item(cx, type_of_receiver, sym!(option_type))\n                 && !is_type_diagnostic_item(cx, type_of_receiver, sym!(result_type))"}, {"sha": "531531a654d0efb1e13f56ad7a6abec5f871b0a1", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -38,10 +38,10 @@ declare_lint_pass!(ByteCount => [NAIVE_BYTECOUNT]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n     fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::MethodCall(ref count, _, ref count_args) = expr.kind;\n+            if let ExprKind::MethodCall(ref count, _, ref count_args, _) = expr.kind;\n             if count.ident.name == sym!(count);\n             if count_args.len() == 1;\n-            if let ExprKind::MethodCall(ref filter, _, ref filter_args) = count_args[0].kind;\n+            if let ExprKind::MethodCall(ref filter, _, ref filter_args, _) = count_args[0].kind;\n             if filter.ident.name == sym!(filter);\n             if filter_args.len() == 2;\n             if let ExprKind::Closure(_, _, body_id, _, _) = filter_args[1].kind;\n@@ -66,7 +66,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n                         if ty::Uint(UintTy::U8) != walk_ptrs_ty(cx.tables.expr_ty(needle)).kind {\n                             return;\n                         }\n-                        let haystack = if let ExprKind::MethodCall(ref path, _, ref args) =\n+                        let haystack = if let ExprKind::MethodCall(ref path, _, ref args, _) =\n                                 filter_args[0].kind {\n                             let p = path.ident.name;\n                             if (p == sym!(iter) || p == sym!(iter_mut)) && args.len() == 1 {"}, {"sha": "88145015ba8bd529490705891d4fce901e481aaf", "filename": "clippy_lints/src/checked_conversions.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fchecked_conversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fchecked_conversions.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -88,7 +88,7 @@ fn double_check<'a>(cx: &LateContext<'_, '_>, left: &'a Expr<'_>, right: &'a Exp\n         let upper = check_upper_bound(l);\n         let lower = check_lower_bound(r);\n \n-        transpose(upper, lower).and_then(|(l, r)| l.combine(r, cx))\n+        upper.zip(lower).and_then(|(l, r)| l.combine(r, cx))\n     };\n \n     upper_lower(left, right).or_else(|| upper_lower(right, left))\n@@ -131,7 +131,10 @@ impl<'a> Conversion<'a> {\n \n     /// Checks if the to-type is the same (if there is a type constraint)\n     fn has_compatible_to_type(&self, other: &Self) -> bool {\n-        transpose(self.to_type.as_ref(), other.to_type.as_ref()).map_or(true, |(l, r)| l == r)\n+        match (self.to_type, other.to_type) {\n+            (Some(l), Some(r)) => l == r,\n+            _ => true,\n+        }\n     }\n \n     /// Try to construct a new conversion if the conversion type is valid\n@@ -322,14 +325,6 @@ fn int_ty_to_sym<'tcx>(path: &QPath<'_>) -> Option<&'tcx str> {\n     }\n }\n \n-/// (Option<T>, Option<U>) -> Option<(T, U)>\n-fn transpose<T, U>(lhs: Option<T>, rhs: Option<U>) -> Option<(T, U)> {\n-    match (lhs, rhs) {\n-        (Some(l), Some(r)) => Some((l, r)),\n-        _ => None,\n-    }\n-}\n-\n /// Will return the expressions as if they were expr1 <= expr2\n fn normalize_le_ge<'a>(op: &BinOp, left: &'a Expr<'a>, right: &'a Expr<'a>) -> Option<(&'a Expr<'a>, &'a Expr<'a>)> {\n     match op.node {"}, {"sha": "22c5acca064e9242b4f7c1f962ccd25044ba9d08", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -254,11 +254,11 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n                     if let [\"core\", \"num\", int_impl, \"max_value\"] = *def_path;\n                     then {\n                        let value = match int_impl {\n-                           \"<impl i8>\" => i8::max_value() as u128,\n-                           \"<impl i16>\" => i16::max_value() as u128,\n-                           \"<impl i32>\" => i32::max_value() as u128,\n-                           \"<impl i64>\" => i64::max_value() as u128,\n-                           \"<impl i128>\" => i128::max_value() as u128,\n+                           \"<impl i8>\" => i8::MAX as u128,\n+                           \"<impl i16>\" => i16::MAX as u128,\n+                           \"<impl i32>\" => i32::MAX as u128,\n+                           \"<impl i64>\" => i64::MAX as u128,\n+                           \"<impl i128>\" => i128::MAX as u128,\n                            _ => return None,\n                        };\n                        Some(Constant::Int(value))"}, {"sha": "1cd30ae2c6381f844c92af3f1ea4f86fbf2d1bda", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -42,7 +42,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Dereferencing {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if !expr.span.from_expansion();\n-            if let ExprKind::MethodCall(ref method_name, _, ref args) = &expr.kind;\n+            if let ExprKind::MethodCall(ref method_name, _, ref args, _) = &expr.kind;\n             if args.len() == 1;\n \n             then {"}, {"sha": "1eb380a22cc6ba765ba1988e33308020bffbe691", "filename": "clippy_lints/src/double_parens.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fdouble_parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fdouble_parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdouble_parens.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -70,7 +70,7 @@ impl EarlyLintPass for DoubleParens {\n                     }\n                 }\n             },\n-            ExprKind::MethodCall(_, ref params) => {\n+            ExprKind::MethodCall(_, ref params, _) => {\n                 if params.len() == 2 {\n                     let param = &params[1];\n                     if let ExprKind::Paren(_) = param.kind {"}, {"sha": "7171dcef968c14150ebc548734c534c97ed2b4fc", "filename": "clippy_lints/src/duration_subsec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fduration_subsec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fduration_subsec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fduration_subsec.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -42,7 +42,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DurationSubsec {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Binary(Spanned { node: BinOpKind::Div, .. }, ref left, ref right) = expr.kind;\n-            if let ExprKind::MethodCall(ref method_path, _ , ref args) = left.kind;\n+            if let ExprKind::MethodCall(ref method_path, _ , ref args, _) = left.kind;\n             if match_type(cx, walk_ptrs_ty(cx.tables.expr_ty(&args[0])), &paths::DURATION);\n             if let Some((Constant::Int(divisor), _)) = constant(cx, cx.tables, right);\n             then {"}, {"sha": "f625058b6703cec269e01a9f2c0da9b8e4f2e9fe", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -103,7 +103,7 @@ fn check_cond<'a, 'tcx, 'b>(\n     check: &'b Expr<'b>,\n ) -> Option<(&'static str, &'b Expr<'b>, &'b Expr<'b>)> {\n     if_chain! {\n-        if let ExprKind::MethodCall(ref path, _, ref params) = check.kind;\n+        if let ExprKind::MethodCall(ref path, _, ref params, _) = check.kind;\n         if params.len() >= 2;\n         if path.ident.name == sym!(contains_key);\n         if let ExprKind::AddrOf(BorrowKind::Ref, _, ref key) = params[1].kind;\n@@ -140,7 +140,7 @@ impl<'a, 'tcx, 'b> Visitor<'tcx> for InsertVisitor<'a, 'tcx, 'b> {\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::MethodCall(ref path, _, ref params) = expr.kind;\n+            if let ExprKind::MethodCall(ref path, _, ref params, _) = expr.kind;\n             if params.len() == 3;\n             if path.ident.name == sym!(insert);\n             if get_item_name(self.cx, self.map) == get_item_name(self.cx, &params[0]);"}, {"sha": "12b62f5cf97899792eada3b8f46295924ce9a24f", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -65,7 +65,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnportableVariant {\n                                     continue;\n                                 }\n                             },\n-                            ty::Uint(UintTy::Usize) if val > u128::from(u32::max_value()) => {},\n+                            ty::Uint(UintTy::Usize) if val > u128::from(u32::MAX) => {},\n                             _ => continue,\n                         }\n                         span_lint("}, {"sha": "77e90eeac49589ecfcdfcb1c9488f61dc54fe832", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -6,7 +6,7 @@ use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n use rustc_target::abi::LayoutOf;\n-use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, Place, PlaceBase};\n+use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n \n use crate::utils::span_lint;\n \n@@ -112,9 +112,9 @@ fn is_argument(map: rustc_middle::hir::map::Map<'_>, id: HirId) -> bool {\n }\n \n impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n-    fn consume(&mut self, cmt: &Place<'tcx>, mode: ConsumeMode) {\n-        if cmt.projections.is_empty() {\n-            if let PlaceBase::Local(lid) = cmt.base {\n+    fn consume(&mut self, cmt: &PlaceWithHirId<'tcx>, mode: ConsumeMode) {\n+        if cmt.place.projections.is_empty() {\n+            if let PlaceBase::Local(lid) = cmt.place.base {\n                 if let ConsumeMode::Move = mode {\n                     // moved out or in. clearly can't be localized\n                     self.set.remove(&lid);\n@@ -132,16 +132,16 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n         }\n     }\n \n-    fn borrow(&mut self, cmt: &Place<'tcx>, _: ty::BorrowKind) {\n-        if cmt.projections.is_empty() {\n-            if let PlaceBase::Local(lid) = cmt.base {\n+    fn borrow(&mut self, cmt: &PlaceWithHirId<'tcx>, _: ty::BorrowKind) {\n+        if cmt.place.projections.is_empty() {\n+            if let PlaceBase::Local(lid) = cmt.place.base {\n                 self.set.remove(&lid);\n             }\n         }\n     }\n \n-    fn mutate(&mut self, cmt: &Place<'tcx>) {\n-        if cmt.projections.is_empty() {\n+    fn mutate(&mut self, cmt: &PlaceWithHirId<'tcx>) {\n+        if cmt.place.projections.is_empty() {\n             let map = &self.cx.tcx.hir();\n             if is_argument(*map, cmt.hir_id) {\n                 // Skip closure arguments\n@@ -150,7 +150,7 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n                     return;\n                 }\n \n-                if is_non_trait_box(cmt.ty) && !self.is_large_box(cmt.ty) {\n+                if is_non_trait_box(cmt.place.ty) && !self.is_large_box(cmt.place.ty) {\n                     self.set.insert(cmt.hir_id);\n                 }\n                 return;"}, {"sha": "a889856de274215b324197e4a20ba2cb80489dbb", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -71,7 +71,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EtaReduction {\n         }\n \n         match expr.kind {\n-            ExprKind::Call(_, args) | ExprKind::MethodCall(_, _, args) => {\n+            ExprKind::Call(_, args) | ExprKind::MethodCall(_, _, args, _) => {\n                 for arg in args {\n                     check_closure(cx, arg)\n                 }\n@@ -120,7 +120,7 @@ fn check_closure(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n         );\n \n         if_chain!(\n-            if let ExprKind::MethodCall(ref path, _, ref args) = ex.kind;\n+            if let ExprKind::MethodCall(ref path, _, ref args, _) = ex.kind;\n \n             // Not the same number of arguments, there is no way the closure is the same as the function return;\n             if args.len() == decl.inputs.len();"}, {"sha": "7269e2b52c2ce953a6e74400bbf821134cb05684", "filename": "clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexplicit_write.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -32,11 +32,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ExplicitWrite {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             // match call to unwrap\n-            if let ExprKind::MethodCall(ref unwrap_fun, _, ref unwrap_args) = expr.kind;\n+            if let ExprKind::MethodCall(ref unwrap_fun, _, ref unwrap_args, _) = expr.kind;\n             if unwrap_fun.ident.name == sym!(unwrap);\n             // match call to write_fmt\n             if !unwrap_args.is_empty();\n-            if let ExprKind::MethodCall(ref write_fun, _, write_args) =\n+            if let ExprKind::MethodCall(ref write_fun, _, write_args, _) =\n                 unwrap_args[0].kind;\n             if write_fun.ident.name == sym!(write_fmt);\n             // match calls to std::io::stdout() / std::io::stderr ()"}, {"sha": "ad4f66c52c2c85c18bbb21c1d19a965057e9aa51", "filename": "clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -301,7 +301,7 @@ fn check_expm1(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n         if cx.tables.expr_ty(lhs).is_floating_point();\n         if let Some((value, _)) = constant(cx, cx.tables, rhs);\n         if F32(1.0) == value || F64(1.0) == value;\n-        if let ExprKind::MethodCall(ref path, _, ref method_args) = lhs.kind;\n+        if let ExprKind::MethodCall(ref path, _, ref method_args, _) = lhs.kind;\n         if cx.tables.expr_ty(&method_args[0]).is_floating_point();\n         if path.ident.name.as_str() == \"exp\";\n         then {\n@@ -481,7 +481,7 @@ fn check_custom_abs(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FloatingPointArithmetic {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::MethodCall(ref path, _, args) = &expr.kind {\n+        if let ExprKind::MethodCall(ref path, _, args, _) = &expr.kind {\n             let recv_ty = cx.tables.expr_ty(&args[0]);\n \n             if recv_ty.is_floating_point() {"}, {"sha": "4cae5ca2c4326b6d52310d3b36ea786bde4e8f8f", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -104,7 +104,7 @@ fn on_argumentv1_new<'a, 'tcx>(\n                 }\n             } else {\n                 let snip = snippet(cx, format_args.span, \"<arg>\");\n-                if let ExprKind::MethodCall(ref path, _, _) = format_args.kind {\n+                if let ExprKind::MethodCall(ref path, _, _, _) = format_args.kind {\n                     if path.ident.name == sym!(to_string) {\n                         return Some(format!(\"{}\", snip));\n                     }"}, {"sha": "991d129e8f0d612a7d7187abe0d007c5592502b3", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -556,7 +556,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n                     }\n                 }\n             },\n-            hir::ExprKind::MethodCall(_, _, args) => {\n+            hir::ExprKind::MethodCall(_, _, args, _) => {\n                 let def_id = self.tables.type_dependent_def_id(expr.hir_id).unwrap();\n                 let base_type = self.cx.tcx.type_of(def_id);\n \n@@ -610,7 +610,7 @@ impl<'a, 'tcx> intravisit::Visitor<'tcx> for StaticMutVisitor<'a, 'tcx> {\n             return;\n         }\n         match expr.kind {\n-            Call(_, args) | MethodCall(_, _, args) => {\n+            Call(_, args) | MethodCall(_, _, args, _) => {\n                 let mut tys = FxHashSet::default();\n                 for arg in args {\n                     let def_id = arg.hir_id.owner.to_def_id();"}, {"sha": "3629ba623ce43a64dc6176ccac1e21722fe3cbd0", "filename": "clippy_lints/src/get_last_with_len.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fget_last_with_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fget_last_with_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fget_last_with_len.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -47,7 +47,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for GetLastWithLen {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             // Is a method call\n-            if let ExprKind::MethodCall(ref path, _, ref args) = expr.kind;\n+            if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;\n \n             // Method name is \"get\"\n             if path.ident.name == sym!(get);\n@@ -69,7 +69,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for GetLastWithLen {\n             ) = &get_index_arg.kind;\n \n             // LHS of subtraction is \"x.len()\"\n-            if let ExprKind::MethodCall(arg_lhs_path, _, lhs_args) = &lhs.kind;\n+            if let ExprKind::MethodCall(arg_lhs_path, _, lhs_args, _) = &lhs.kind;\n             if arg_lhs_path.ident.name == sym!(len);\n             if let Some(arg_lhs_struct) = lhs_args.get(0);\n "}, {"sha": "04d17c91d63c1515dd73532581ab68984c15796d", "filename": "clippy_lints/src/if_let_mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -147,7 +147,7 @@ impl<'tcx, 'l> ArmVisitor<'tcx, 'l> {\n \n fn is_mutex_lock_call<'a>(cx: &LateContext<'a, '_>, expr: &'a Expr<'_>) -> Option<&'a Expr<'a>> {\n     if_chain! {\n-        if let ExprKind::MethodCall(path, _span, args) = &expr.kind;\n+        if let ExprKind::MethodCall(path, _span, args, _) = &expr.kind;\n         if path.ident.to_string() == \"lock\";\n         let ty = cx.tables.expr_ty(&args[0]);\n         if is_type_diagnostic_item(cx, ty, sym!(mutex_type));"}, {"sha": "6a1fcdd1ce445edc5a30021a2f2b70233ce9ee19", "filename": "clippy_lints/src/if_let_some_result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fif_let_some_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fif_let_some_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_some_result.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -42,7 +42,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OkIfLet {\n         if_chain! { //begin checking variables\n             if let ExprKind::Match(ref op, ref body, source) = expr.kind; //test if expr is a match\n             if let MatchSource::IfLetDesugar { .. } = source; //test if it is an If Let\n-            if let ExprKind::MethodCall(_, ok_span, ref result_types) = op.kind; //check is expr.ok() has type Result<T,E>.ok()\n+            if let ExprKind::MethodCall(_, ok_span, ref result_types, _) = op.kind; //check is expr.ok() has type Result<T,E>.ok(, _)\n             if let PatKind::TupleStruct(QPath::Resolved(_, ref x), ref y, _)  = body[0].pat.kind; //get operation\n             if method_chain_args(op, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n             if is_type_diagnostic_item(cx, cx.tables.expr_ty(&result_types[0]), sym!(result_type));"}, {"sha": "a860a9def24224725444f7535b6b10b2431cecbf", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -142,7 +142,7 @@ const HEURISTICS: [(&str, usize, Heuristic, Finiteness); 19] = [\n \n fn is_infinite(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Finiteness {\n     match expr.kind {\n-        ExprKind::MethodCall(ref method, _, ref args) => {\n+        ExprKind::MethodCall(ref method, _, ref args, _) => {\n             for &(name, len, heuristic, cap) in &HEURISTICS {\n                 if method.ident.name.as_str() == name && args.len() == len {\n                     return (match heuristic {\n@@ -218,7 +218,7 @@ const INFINITE_COLLECTORS: [&[&str]; 8] = [\n \n fn complete_infinite_iter(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Finiteness {\n     match expr.kind {\n-        ExprKind::MethodCall(ref method, _, ref args) => {\n+        ExprKind::MethodCall(ref method, _, ref args, _) => {\n             for &(name, len) in &COMPLETING_METHODS {\n                 if method.ident.name.as_str() == name && args.len() == len {\n                     return is_infinite(cx, &args[0]);"}, {"sha": "7838e8e8ab774c8d6e456fabb552e42e6faa0cf7", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -211,7 +211,8 @@ fn check_impl_items(cx: &LateContext<'_, '_>, item: &Item<'_>, impl_items: &[Imp\n }\n \n fn check_cmp(cx: &LateContext<'_, '_>, span: Span, method: &Expr<'_>, lit: &Expr<'_>, op: &str, compare_to: u32) {\n-    if let (&ExprKind::MethodCall(ref method_path, _, ref args), &ExprKind::Lit(ref lit)) = (&method.kind, &lit.kind) {\n+    if let (&ExprKind::MethodCall(ref method_path, _, ref args, _), &ExprKind::Lit(ref lit)) = (&method.kind, &lit.kind)\n+    {\n         // check if we are in an is_empty() method\n         if let Some(name) = get_item_name(cx, method) {\n             if name.as_str() == \"is_empty\" {"}, {"sha": "318d0b69d57b7924ae7dd9adb8f138689bf838b2", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -379,7 +379,7 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n             TyKind::Path(ref path) => {\n                 self.collect_anonymous_lifetimes(path, ty);\n             },\n-            TyKind::Def(item, _) => {\n+            TyKind::OpaqueDef(item, _) => {\n                 let map = self.cx.tcx.hir();\n                 if let ItemKind::OpaqueTy(ref exist_ty) = map.expect_item(item.id).kind {\n                     for bound in exist_ty.bounds {"}, {"sha": "ae1aa66be5cdab1ecff29e6f598ec3851e086ced", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -28,7 +28,7 @@ use rustc_middle::ty::{self, Ty, TyS};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::Symbol;\n-use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, Place, PlaceBase};\n+use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n use std::iter::{once, Iterator};\n use std::mem;\n \n@@ -526,7 +526,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Loops {\n             let pat = &arms[0].pat.kind;\n             if let (\n                 &PatKind::TupleStruct(ref qpath, ref pat_args, _),\n-                &ExprKind::MethodCall(ref method_path, _, ref method_args),\n+                &ExprKind::MethodCall(ref method_path, _, ref method_args, _),\n             ) = (pat, &match_expr.kind)\n             {\n                 let iter_expr = &method_args[0];\n@@ -654,7 +654,7 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n         | ExprKind::Struct(_, _, Some(ref e))\n         | ExprKind::Repeat(ref e, _)\n         | ExprKind::DropTemps(ref e) => never_loop_expr(e, main_loop_id),\n-        ExprKind::Array(ref es) | ExprKind::MethodCall(_, _, ref es) | ExprKind::Tup(ref es) => {\n+        ExprKind::Array(ref es) | ExprKind::MethodCall(_, _, ref es, _) | ExprKind::Tup(ref es) => {\n             never_loop_expr_all(&mut es.iter(), main_loop_id)\n         },\n         ExprKind::Call(ref e, ref es) => never_loop_expr_all(&mut once(&**e).chain(es.iter()), main_loop_id),\n@@ -806,7 +806,7 @@ fn is_slice_like<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: Ty<'_>) -> bool {\n \n fn fetch_cloned_expr<'tcx>(expr: &'tcx Expr<'tcx>) -> &'tcx Expr<'tcx> {\n     if_chain! {\n-        if let ExprKind::MethodCall(method, _, args) = expr.kind;\n+        if let ExprKind::MethodCall(method, _, args, _) = expr.kind;\n         if method.ident.name == sym!(clone);\n         if args.len() == 1;\n         if let Some(arg) = args.get(0);\n@@ -915,7 +915,7 @@ fn build_manual_memcpy_suggestion<'a, 'tcx>(\n \n     let print_limit = |end: &Expr<'_>, offset: Offset, var: &Expr<'_>| {\n         if_chain! {\n-            if let ExprKind::MethodCall(method, _, len_args) = end.kind;\n+            if let ExprKind::MethodCall(method, _, len_args, _) = end.kind;\n             if method.ident.name == sym!(len);\n             if len_args.len() == 1;\n             if let Some(arg) = len_args.get(0);\n@@ -1190,7 +1190,7 @@ fn check_for_loop_range<'a, 'tcx>(\n \n fn is_len_call(expr: &Expr<'_>, var: Name) -> bool {\n     if_chain! {\n-        if let ExprKind::MethodCall(ref method, _, ref len_args) = expr.kind;\n+        if let ExprKind::MethodCall(ref method, _, ref len_args, _) = expr.kind;\n         if len_args.len() == 1;\n         if method.ident.name == sym!(len);\n         if let ExprKind::Path(QPath::Resolved(_, ref path)) = len_args[0].kind;\n@@ -1244,7 +1244,7 @@ fn lint_iter_method(cx: &LateContext<'_, '_>, args: &[Expr<'_>], arg: &Expr<'_>,\n \n fn check_for_loop_arg(cx: &LateContext<'_, '_>, pat: &Pat<'_>, arg: &Expr<'_>, expr: &Expr<'_>) {\n     let mut next_loop_linted = false; // whether or not ITER_NEXT_LOOP lint was used\n-    if let ExprKind::MethodCall(ref method, _, ref args) = arg.kind {\n+    if let ExprKind::MethodCall(ref method, _, ref args, _) = arg.kind {\n         // just the receiver, no arguments\n         if args.len() == 1 {\n             let method_name = &*method.ident.as_str();\n@@ -1489,42 +1489,43 @@ fn check_for_loop_over_map_kv<'a, 'tcx>(\n     }\n }\n \n-struct MutatePairDelegate {\n+struct MutatePairDelegate<'a, 'tcx> {\n+    cx: &'a LateContext<'a, 'tcx>,\n     hir_id_low: Option<HirId>,\n     hir_id_high: Option<HirId>,\n     span_low: Option<Span>,\n     span_high: Option<Span>,\n }\n \n-impl<'tcx> Delegate<'tcx> for MutatePairDelegate {\n-    fn consume(&mut self, _: &Place<'tcx>, _: ConsumeMode) {}\n+impl<'a, 'tcx> Delegate<'tcx> for MutatePairDelegate<'a, 'tcx> {\n+    fn consume(&mut self, _: &PlaceWithHirId<'tcx>, _: ConsumeMode) {}\n \n-    fn borrow(&mut self, cmt: &Place<'tcx>, bk: ty::BorrowKind) {\n+    fn borrow(&mut self, cmt: &PlaceWithHirId<'tcx>, bk: ty::BorrowKind) {\n         if let ty::BorrowKind::MutBorrow = bk {\n-            if let PlaceBase::Local(id) = cmt.base {\n+            if let PlaceBase::Local(id) = cmt.place.base {\n                 if Some(id) == self.hir_id_low {\n-                    self.span_low = Some(cmt.span)\n+                    self.span_low = Some(self.cx.tcx.hir().span(cmt.hir_id))\n                 }\n                 if Some(id) == self.hir_id_high {\n-                    self.span_high = Some(cmt.span)\n+                    self.span_high = Some(self.cx.tcx.hir().span(cmt.hir_id))\n                 }\n             }\n         }\n     }\n \n-    fn mutate(&mut self, cmt: &Place<'tcx>) {\n-        if let PlaceBase::Local(id) = cmt.base {\n+    fn mutate(&mut self, cmt: &PlaceWithHirId<'tcx>) {\n+        if let PlaceBase::Local(id) = cmt.place.base {\n             if Some(id) == self.hir_id_low {\n-                self.span_low = Some(cmt.span)\n+                self.span_low = Some(self.cx.tcx.hir().span(cmt.hir_id))\n             }\n             if Some(id) == self.hir_id_high {\n-                self.span_high = Some(cmt.span)\n+                self.span_high = Some(self.cx.tcx.hir().span(cmt.hir_id))\n             }\n         }\n     }\n }\n \n-impl<'tcx> MutatePairDelegate {\n+impl<'a, 'tcx> MutatePairDelegate<'a, 'tcx> {\n     fn mutation_span(&self) -> (Option<Span>, Option<Span>) {\n         (self.span_low, self.span_high)\n     }\n@@ -1579,12 +1580,13 @@ fn check_for_mutability(cx: &LateContext<'_, '_>, bound: &Expr<'_>) -> Option<Hi\n     None\n }\n \n-fn check_for_mutation(\n-    cx: &LateContext<'_, '_>,\n+fn check_for_mutation<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n     body: &Expr<'_>,\n     bound_ids: &[Option<HirId>],\n ) -> (Option<Span>, Option<Span>) {\n     let mut delegate = MutatePairDelegate {\n+        cx,\n         hir_id_low: bound_ids[0],\n         hir_id_high: bound_ids[1],\n         span_low: None,\n@@ -1718,7 +1720,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             // a range index op\n-            if let ExprKind::MethodCall(ref meth, _, ref args) = expr.kind;\n+            if let ExprKind::MethodCall(ref meth, _, ref args, _) = expr.kind;\n             if (meth.ident.name == sym!(index) && match_trait_method(self.cx, expr, &paths::INDEX))\n                 || (meth.ident.name == sym!(index_mut) && match_trait_method(self.cx, expr, &paths::INDEX_MUT));\n             if !self.check(&args[1], &args[0], expr);\n@@ -1776,7 +1778,7 @@ impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n                     self.visit_expr(expr);\n                 }\n             },\n-            ExprKind::MethodCall(_, _, args) => {\n+            ExprKind::MethodCall(_, _, args, _) => {\n                 let def_id = self.cx.tables.type_dependent_def_id(expr.hir_id).unwrap();\n                 for (ty, expr) in self.cx.tcx.fn_sig(def_id).inputs().skip_binder().iter().zip(args) {\n                     self.prefer_mutable = false;\n@@ -2369,8 +2371,8 @@ const NEEDLESS_COLLECT_MSG: &str = \"avoid using `collect()` when not needed\";\n \n fn check_needless_collect<'a, 'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'a, 'tcx>) {\n     if_chain! {\n-        if let ExprKind::MethodCall(ref method, _, ref args) = expr.kind;\n-        if let ExprKind::MethodCall(ref chain_method, _, _) = args[0].kind;\n+        if let ExprKind::MethodCall(ref method, _, ref args, _) = expr.kind;\n+        if let ExprKind::MethodCall(ref chain_method, _, _, _) = args[0].kind;\n         if chain_method.ident.name == sym!(collect) && match_trait_method(cx, &args[0], &paths::ITERATOR);\n         if let Some(ref generic_args) = chain_method.args;\n         if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n@@ -2437,7 +2439,7 @@ fn check_needless_collect<'a, 'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'a, '\n \n fn shorten_span(expr: &Expr<'_>, target_fn_name: Symbol) -> Span {\n     let mut current_expr = expr;\n-    while let ExprKind::MethodCall(ref path, ref span, ref args) = current_expr.kind {\n+    while let ExprKind::MethodCall(ref path, ref span, ref args, _) = current_expr.kind {\n         if path.ident.name == target_fn_name {\n             return expr.span.with_lo(span.lo());\n         }"}, {"sha": "03ab274d9ca9c9cc741445741b58b07f8da75436", "filename": "clippy_lints/src/manual_async_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fmanual_async_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fmanual_async_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_async_fn.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -99,7 +99,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ManualAsyncFn {\n \n fn future_trait_ref<'tcx>(cx: &LateContext<'_, 'tcx>, ty: &'tcx Ty<'tcx>) -> Option<&'tcx TraitRef<'tcx>> {\n     if_chain! {\n-        if let TyKind::Def(item_id, _) = ty.kind;\n+        if let TyKind::OpaqueDef(item_id, _) = ty.kind;\n         let item = cx.tcx.hir().item(item_id.id);\n         if let ItemKind::OpaqueTy(opaque) = &item.kind;\n         if opaque.bounds.len() == 1;"}, {"sha": "8f4fdc685ef38c4d15d0a5af3f53da578445c6dd", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -49,7 +49,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MapClone {\n         }\n \n         if_chain! {\n-            if let hir::ExprKind::MethodCall(ref method, _, ref args) = e.kind;\n+            if let hir::ExprKind::MethodCall(ref method, _, ref args, _) = e.kind;\n             if args.len() == 2;\n             if method.ident.as_str() == \"map\";\n             let ty = cx.tables.expr_ty(&args[0]);\n@@ -75,7 +75,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MapClone {\n                                     }\n                                 }\n                             },\n-                            hir::ExprKind::MethodCall(ref method, _, ref obj) => {\n+                            hir::ExprKind::MethodCall(ref method, _, ref obj, _) => {\n                                 if ident_eq(name, &obj[0]) && method.ident.as_str() == \"clone\"\n                                     && match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) {\n "}, {"sha": "8f4b674c04f49ecde8af39f95c813239beb144a4", "filename": "clippy_lints/src/map_unit_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fmap_unit_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_unit_fn.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -125,7 +125,7 @@ fn reduce_unit_expression<'a>(cx: &LateContext<'_, '_>, expr: &'a hir::Expr<'_>)\n     }\n \n     match expr.kind {\n-        hir::ExprKind::Call(_, _) | hir::ExprKind::MethodCall(_, _, _) => {\n+        hir::ExprKind::Call(_, _) | hir::ExprKind::MethodCall(_, _, _, _) => {\n             // Calls can't be reduced any more\n             Some(expr.span)\n         },"}, {"sha": "f25a9782813bbbd36c0bdf906b6f408a24294c0f", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -1429,7 +1429,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Methods {\n         }\n \n         match expr.kind {\n-            hir::ExprKind::MethodCall(ref method_call, ref method_span, ref args) => {\n+            hir::ExprKind::MethodCall(ref method_call, ref method_span, ref args, _) => {\n                 lint_or_fun_call(cx, expr, *method_span, &method_call.ident.as_str(), args);\n                 lint_expect_fun_call(cx, expr, *method_span, &method_call.ident.as_str(), args);\n \n@@ -1677,7 +1677,7 @@ fn lint_or_fun_call<'a, 'tcx>(\n         or_has_args: bool,\n         span: Span,\n     ) {\n-        if let hir::ExprKind::MethodCall(ref path, _, ref args) = &arg.kind {\n+        if let hir::ExprKind::MethodCall(ref path, _, ref args, _) = &arg.kind {\n             if path.ident.as_str() == \"len\" {\n                 let ty = walk_ptrs_ty(cx.tables.expr_ty(&args[0]));\n \n@@ -1751,7 +1751,7 @@ fn lint_or_fun_call<'a, 'tcx>(\n                     );\n                 }\n             },\n-            hir::ExprKind::MethodCall(_, span, ref or_args) => check_general_case(\n+            hir::ExprKind::MethodCall(_, span, ref or_args, _) => check_general_case(\n                 cx,\n                 name,\n                 method_span,\n@@ -1782,7 +1782,7 @@ fn lint_expect_fun_call(\n         loop {\n             arg_root = match &arg_root.kind {\n                 hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, expr) => expr,\n-                hir::ExprKind::MethodCall(method_name, _, call_args) => {\n+                hir::ExprKind::MethodCall(method_name, _, call_args, _) => {\n                     if call_args.len() == 1\n                         && (method_name.ident.name == sym!(as_str) || method_name.ident.name == sym!(as_ref))\n                         && {\n@@ -2002,7 +2002,7 @@ fn lint_clone_on_copy(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, arg: &hir:\n                     // &*x is a nop, &x.clone() is not\n                     hir::ExprKind::AddrOf(..) => return,\n                     // (*x).func() is useless, x.clone().func() can work in case func borrows mutably\n-                    hir::ExprKind::MethodCall(_, _, parent_args) if expr.hir_id == parent_args[0].hir_id => return,\n+                    hir::ExprKind::MethodCall(_, _, parent_args, _) if expr.hir_id == parent_args[0].hir_id => return,\n \n                     _ => {},\n                 },\n@@ -2478,7 +2478,7 @@ fn derefs_to_slice<'a, 'tcx>(\n         }\n     }\n \n-    if let hir::ExprKind::MethodCall(ref path, _, ref args) = expr.kind {\n+    if let hir::ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind {\n         if path.ident.name == sym!(iter) && may_slice(cx, cx.tables.expr_ty(&args[0])) {\n             Some(&args[0])\n         } else {\n@@ -3182,7 +3182,7 @@ fn lint_asref(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, call_name: &str, a\n             // allow the `as_ref` or `as_mut` if it is followed by another method call\n             if_chain! {\n                 if let Some(parent) = get_parent_expr(cx, expr);\n-                if let hir::ExprKind::MethodCall(_, ref span, _) = parent.kind;\n+                if let hir::ExprKind::MethodCall(_, ref span, _, _) = parent.kind;\n                 if span != &expr.span;\n                 then {\n                     return;\n@@ -3310,7 +3310,7 @@ fn lint_option_as_ref_deref<'a, 'tcx>(\n             let closure_expr = remove_blocks(&closure_body.value);\n \n             match &closure_expr.kind {\n-                hir::ExprKind::MethodCall(_, _, args) => {\n+                hir::ExprKind::MethodCall(_, _, args, _) => {\n                     if_chain! {\n                         if args.len() == 1;\n                         if let hir::ExprKind::Path(qpath) = &args[0].kind;"}, {"sha": "a0947608e60776dc0db4ab3a43addc0871f72f10", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -545,7 +545,7 @@ fn is_signum(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n     }\n \n     if_chain! {\n-        if let ExprKind::MethodCall(ref method_name, _, ref expressions) = expr.kind;\n+        if let ExprKind::MethodCall(ref method_name, _, ref expressions, _) = expr.kind;\n         if sym!(signum) == method_name.ident.name;\n         // Check that the receiver of the signum() is a float (expressions[0] is the receiver of\n         // the method call)\n@@ -572,7 +572,7 @@ fn is_array(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool {\n \n fn check_to_owned(cx: &LateContext<'_, '_>, expr: &Expr<'_>, other: &Expr<'_>) {\n     let (arg_ty, snip) = match expr.kind {\n-        ExprKind::MethodCall(.., ref args) if args.len() == 1 => {\n+        ExprKind::MethodCall(.., ref args, _) if args.len() == 1 => {\n             if match_trait_method(cx, expr, &paths::TO_STRING) || match_trait_method(cx, expr, &paths::TO_OWNED) {\n                 (cx.tables.expr_ty_adjusted(&args[0]), snippet(cx, args[0].span, \"..\"))\n             } else {"}, {"sha": "0fd1e87f9e415c7b343b378310881a48fecc5728", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -187,7 +187,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             hir::ImplItemKind::Const(..) => \"an associated constant\",\n             hir::ImplItemKind::Fn(..) => \"a method\",\n             hir::ImplItemKind::TyAlias(_) => \"an associated type\",\n-            hir::ImplItemKind::OpaqueTy(_) => \"an existential type\",\n         };\n         self.check_missing_docs_attrs(cx, &impl_item.attrs, impl_item.span, desc);\n     }"}, {"sha": "1802470b1841e72c63f0b58da84a6d86ba82b896", "filename": "clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_inline.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -142,7 +142,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n \n         let desc = match impl_item.kind {\n             hir::ImplItemKind::Fn(..) => \"a method\",\n-            hir::ImplItemKind::Const(..) | hir::ImplItemKind::TyAlias(_) | hir::ImplItemKind::OpaqueTy(_) => return,\n+            hir::ImplItemKind::Const(..) | hir::ImplItemKind::TyAlias(_) => return,\n         };\n \n         let def_id = cx.tcx.hir().local_def_id(impl_item.hir_id);"}, {"sha": "7fcf15f8acbe828d1b385b405068d44fc6c5e57c", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -42,7 +42,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnecessaryMutPassed {\n                     );\n                 }\n             },\n-            ExprKind::MethodCall(ref path, _, ref arguments) => {\n+            ExprKind::MethodCall(ref path, _, ref arguments, _) => {\n                 let def_id = cx.tables.type_dependent_def_id(e.hir_id).unwrap();\n                 let substs = cx.tables.node_substs(e.hir_id);\n                 let method_type = cx.tcx.type_of(def_id).subst(cx.tcx, substs);"}, {"sha": "56658cb5abab410098780d686df23c940aef7488", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -319,21 +319,21 @@ struct MovedVariablesCtxt {\n }\n \n impl MovedVariablesCtxt {\n-    fn move_common(&mut self, cmt: &euv::Place<'_>) {\n-        if let euv::PlaceBase::Local(vid) = cmt.base {\n+    fn move_common(&mut self, cmt: &euv::PlaceWithHirId<'_>) {\n+        if let euv::PlaceBase::Local(vid) = cmt.place.base {\n             self.moved_vars.insert(vid);\n         }\n     }\n }\n \n impl<'tcx> euv::Delegate<'tcx> for MovedVariablesCtxt {\n-    fn consume(&mut self, cmt: &euv::Place<'tcx>, mode: euv::ConsumeMode) {\n+    fn consume(&mut self, cmt: &euv::PlaceWithHirId<'tcx>, mode: euv::ConsumeMode) {\n         if let euv::ConsumeMode::Move = mode {\n             self.move_common(cmt);\n         }\n     }\n \n-    fn borrow(&mut self, _: &euv::Place<'tcx>, _: ty::BorrowKind) {}\n+    fn borrow(&mut self, _: &euv::PlaceWithHirId<'tcx>, _: ty::BorrowKind) {}\n \n-    fn mutate(&mut self, _: &euv::Place<'tcx>) {}\n+    fn mutate(&mut self, _: &euv::PlaceWithHirId<'tcx>) {}\n }"}, {"sha": "2d4629b683f057b12fb44e7500e445314dd7cf2e", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -29,7 +29,7 @@ declare_lint_pass!(OpenOptions => [NONSENSICAL_OPEN_OPTIONS]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OpenOptions {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr<'_>) {\n-        if let ExprKind::MethodCall(ref path, _, ref arguments) = e.kind {\n+        if let ExprKind::MethodCall(ref path, _, ref arguments, _) = e.kind {\n             let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&arguments[0]));\n             if path.ident.name == sym!(open) && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {\n                 let mut options = Vec::new();\n@@ -57,7 +57,7 @@ enum OpenOption {\n }\n \n fn get_open_options(cx: &LateContext<'_, '_>, argument: &Expr<'_>, options: &mut Vec<(OpenOption, Argument)>) {\n-    if let ExprKind::MethodCall(ref path, _, ref arguments) = argument.kind {\n+    if let ExprKind::MethodCall(ref path, _, ref arguments, _) = argument.kind {\n         let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(&arguments[0]));\n \n         // Only proceed if this is a call on some object of type std::fs::OpenOptions"}, {"sha": "fd653044a1bcb9fb6442041c6e2b4e1f39d90c21", "filename": "clippy_lints/src/option_env_unwrap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Foption_env_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Foption_env_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_env_unwrap.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -35,7 +35,7 @@ declare_lint_pass!(OptionEnvUnwrap => [OPTION_ENV_UNWRAP]);\n impl EarlyLintPass for OptionEnvUnwrap {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &Expr) {\n         if_chain! {\n-            if let ExprKind::MethodCall(path_segment, args) = &expr.kind;\n+            if let ExprKind::MethodCall(path_segment, args, _) = &expr.kind;\n             let method_name = path_segment.ident.as_str();\n             if method_name == \"expect\" || method_name == \"unwrap\";\n             if let ExprKind::Call(caller, _) = &args[0].kind;"}, {"sha": "88ad1e0914f25f1a5763eaf02c13cfb2dc565368", "filename": "clippy_lints/src/path_buf_push_overwrite.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpath_buf_push_overwrite.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -43,7 +43,7 @@ declare_lint_pass!(PathBufPushOverwrite => [PATH_BUF_PUSH_OVERWRITE]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PathBufPushOverwrite {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::MethodCall(ref path, _, ref args) = expr.kind;\n+            if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;\n             if path.ident.name == sym!(push);\n             if args.len() == 2;\n             if match_type(cx, walk_ptrs_ty(cx.tables.expr_ty(&args[0])), &paths::PATH_BUF);"}, {"sha": "7dce23dd223061f5684ecdbe6a7179ec89a5f88e", "filename": "clippy_lints/src/precedence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprecedence.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -103,7 +103,7 @@ impl EarlyLintPass for Precedence {\n         }\n \n         if let ExprKind::Unary(UnOp::Neg, ref rhs) = expr.kind {\n-            if let ExprKind::MethodCall(ref path_segment, ref args) = rhs.kind {\n+            if let ExprKind::MethodCall(ref path_segment, ref args, _) = rhs.kind {\n                 let path_segment_str = path_segment.ident.name.as_str();\n                 if let Some(slf) = args.first() {\n                     if let ExprKind::Lit(ref lit) = slf.kind {"}, {"sha": "d23d7e59b73fc054369ab6b57a1eced54450d033", "filename": "clippy_lints/src/ptr_offset_with_cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr_offset_with_cast.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -90,7 +90,7 @@ fn expr_as_ptr_offset_call<'a, 'tcx>(\n     cx: &LateContext<'a, 'tcx>,\n     expr: &'tcx Expr<'_>,\n ) -> Option<(&'tcx Expr<'tcx>, &'tcx Expr<'tcx>, Method)> {\n-    if let ExprKind::MethodCall(ref path_segment, _, ref args) = expr.kind {\n+    if let ExprKind::MethodCall(ref path_segment, _, ref args, _) = expr.kind {\n         if is_expr_ty_raw_ptr(cx, &args[0]) {\n             if path_segment.ident.name == sym!(offset) {\n                 return Some((&args[0], &args[1], Method::Offset));"}, {"sha": "3591972fe082f7d0db4a12878a993059556509b8", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -50,7 +50,7 @@ impl QuestionMark {\n     fn check_is_none_and_early_return_none(cx: &LateContext<'_, '_>, expr: &Expr<'_>) {\n         if_chain! {\n             if let Some((if_expr, body, else_)) = higher::if_block(&expr);\n-            if let ExprKind::MethodCall(segment, _, args) = &if_expr.kind;\n+            if let ExprKind::MethodCall(segment, _, args, _) = &if_expr.kind;\n             if segment.ident.name == sym!(is_none);\n             if Self::expression_returns_none(cx, body);\n             if let Some(subject) = args.get(0);"}, {"sha": "fcd02a196e7bf593398effda1a57d285707db808", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -129,20 +129,20 @@ declare_lint_pass!(Ranges => [\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Ranges {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::MethodCall(ref path, _, ref args) = expr.kind {\n+        if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind {\n             let name = path.ident.as_str();\n             if name == \"zip\" && args.len() == 2 {\n                 let iter = &args[0].kind;\n                 let zip_arg = &args[1];\n                 if_chain! {\n                     // `.iter()` call\n-                    if let ExprKind::MethodCall(ref iter_path, _, ref iter_args ) = *iter;\n+                    if let ExprKind::MethodCall(ref iter_path, _, ref iter_args , _) = *iter;\n                     if iter_path.ident.name == sym!(iter);\n                     // range expression in `.zip()` call: `0..x.len()`\n                     if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(cx, zip_arg);\n                     if is_integer_const(cx, start, 0);\n                     // `.len()` call\n-                    if let ExprKind::MethodCall(ref len_path, _, ref len_args) = end.kind;\n+                    if let ExprKind::MethodCall(ref len_path, _, ref len_args, _) = end.kind;\n                     if len_path.ident.name == sym!(len) && len_args.len() == 1;\n                     // `.iter()` and `.len()` called on same `Path`\n                     if let ExprKind::Path(QPath::Resolved(_, ref iter_path)) = iter_args[0].kind;"}, {"sha": "f16b916441ae81a51142998a4590b099845cba29", "filename": "clippy_lints/src/redundant_pattern_matching.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_pattern_matching.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -89,7 +89,7 @@ fn find_sugg_for_if_let<'a, 'tcx>(\n     // check that `while_let_on_iterator` lint does not trigger\n     if_chain! {\n         if keyword == \"while\";\n-        if let ExprKind::MethodCall(method_path, _, _) = op.kind;\n+        if let ExprKind::MethodCall(method_path, _, _, _) = op.kind;\n         if method_path.ident.name == sym!(next);\n         if match_trait_method(cx, op, &paths::ITERATOR);\n         then {"}, {"sha": "44c9cc19cfb4e740f96b13fe3b12376db448d8e1", "filename": "clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -207,7 +207,7 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     fn search_slow_extend_filling(&mut self, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if self.initialization_found;\n-            if let ExprKind::MethodCall(ref path, _, ref args) = expr.kind;\n+            if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;\n             if let ExprKind::Path(ref qpath_subj) = args[0].kind;\n             if match_qpath(&qpath_subj, &[&*self.vec_alloc.variable_name.as_str()]);\n             if path.ident.name == sym!(extend);\n@@ -224,7 +224,7 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     fn search_slow_resize_filling(&mut self, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if self.initialization_found;\n-            if let ExprKind::MethodCall(ref path, _, ref args) = expr.kind;\n+            if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;\n             if let ExprKind::Path(ref qpath_subj) = args[0].kind;\n             if match_qpath(&qpath_subj, &[&*self.vec_alloc.variable_name.as_str()]);\n             if path.ident.name == sym!(resize);\n@@ -246,7 +246,7 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     /// Returns `true` if give expression is `repeat(0).take(...)`\n     fn is_repeat_take(&self, expr: &Expr<'_>) -> bool {\n         if_chain! {\n-            if let ExprKind::MethodCall(ref take_path, _, ref take_args) = expr.kind;\n+            if let ExprKind::MethodCall(ref take_path, _, ref take_args, _) = expr.kind;\n             if take_path.ident.name == sym!(take);\n \n             // Check that take is applied to `repeat(0)`"}, {"sha": "d8e4bff3d702aa2c0577d8cf87899340d7fd88cc", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -164,7 +164,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringLitAsBytes {\n         use rustc_ast::ast::LitKind;\n \n         if_chain! {\n-            if let ExprKind::MethodCall(path, _, args) = &e.kind;\n+            if let ExprKind::MethodCall(path, _, args, _) = &e.kind;\n             if path.ident.name == sym!(as_bytes);\n             if let ExprKind::Lit(lit) = &args[0].kind;\n             if let LitKind::Str(lit_content, _) = &lit.node;"}, {"sha": "4f132c6db76fa2aa318241385085f1d0c2bb0016", "filename": "clippy_lints/src/to_digit_is_some.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fto_digit_is_some.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fto_digit_is_some.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fto_digit_is_some.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -34,12 +34,12 @@ declare_lint_pass!(ToDigitIsSome => [TO_DIGIT_IS_SOME]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ToDigitIsSome {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr<'_>) {\n         if_chain! {\n-            if let hir::ExprKind::MethodCall(is_some_path, _, is_some_args) = &expr.kind;\n+            if let hir::ExprKind::MethodCall(is_some_path, _, is_some_args, _) = &expr.kind;\n             if is_some_path.ident.name.as_str() == \"is_some\";\n             if let [to_digit_expr] = &**is_some_args;\n             then {\n                 let match_result = match &to_digit_expr.kind {\n-                    hir::ExprKind::MethodCall(to_digits_path, _, to_digit_args) => {\n+                    hir::ExprKind::MethodCall(to_digits_path, _, to_digit_args, _) => {\n                         if_chain! {\n                             if let [char_arg, radix_arg] = &**to_digit_args;\n                             if to_digits_path.ident.name.as_str() == \"to_digit\";"}, {"sha": "98de08f79f3d7872a61a3b18c878a7f8b222c40b", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 19, "deletions": 53, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -778,7 +778,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitArg {\n         }\n \n         match expr.kind {\n-            ExprKind::Call(_, args) | ExprKind::MethodCall(_, _, args) => {\n+            ExprKind::Call(_, args) | ExprKind::MethodCall(_, _, args, _) => {\n                 let args_to_recover = args\n                     .iter()\n                     .filter(|arg| {\n@@ -1262,14 +1262,14 @@ fn check_loss_of_sign(cx: &LateContext<'_, '_>, expr: &Expr<'_>, op: &Expr<'_>,\n     }\n \n     // don't lint for the result of methods that always return non-negative values\n-    if let ExprKind::MethodCall(ref path, _, _) = op.kind {\n+    if let ExprKind::MethodCall(ref path, _, _, _) = op.kind {\n         let mut method_name = path.ident.name.as_str();\n         let whitelisted_methods = [\"abs\", \"checked_abs\", \"rem_euclid\", \"checked_rem_euclid\"];\n \n         if_chain! {\n             if method_name == \"unwrap\";\n             if let Some(arglist) = method_chain_args(op, &[\"unwrap\"]);\n-            if let ExprKind::MethodCall(ref inner_path, _, _) = &arglist[0][0].kind;\n+            if let ExprKind::MethodCall(ref inner_path, _, _, _) = &arglist[0][0].kind;\n             then {\n                 method_name = inner_path.ident.name.as_str();\n             }\n@@ -1945,19 +1945,15 @@ fn detect_extreme_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_\n \n     let which = match (&ty.kind, cv) {\n         (&ty::Bool, Constant::Bool(false)) | (&ty::Uint(_), Constant::Int(0)) => Minimum,\n-        (&ty::Int(ity), Constant::Int(i))\n-            if i == unsext(cx.tcx, i128::min_value() >> (128 - int_bits(cx.tcx, ity)), ity) =>\n-        {\n+        (&ty::Int(ity), Constant::Int(i)) if i == unsext(cx.tcx, i128::MIN >> (128 - int_bits(cx.tcx, ity)), ity) => {\n             Minimum\n         },\n \n         (&ty::Bool, Constant::Bool(true)) => Maximum,\n-        (&ty::Int(ity), Constant::Int(i))\n-            if i == unsext(cx.tcx, i128::max_value() >> (128 - int_bits(cx.tcx, ity)), ity) =>\n-        {\n+        (&ty::Int(ity), Constant::Int(i)) if i == unsext(cx.tcx, i128::MAX >> (128 - int_bits(cx.tcx, ity)), ity) => {\n             Maximum\n         },\n-        (&ty::Uint(uty), Constant::Int(i)) if clip(cx.tcx, u128::max_value(), uty) == i => Maximum,\n+        (&ty::Uint(uty), Constant::Int(i)) if clip(cx.tcx, u128::MAX, uty) == i => Maximum,\n \n         _ => return None,\n     };\n@@ -2039,7 +2035,7 @@ impl FullInt {\n     fn cmp_s_u(s: i128, u: u128) -> Ordering {\n         if s < 0 {\n             Ordering::Less\n-        } else if u > (i128::max_value() as u128) {\n+        } else if u > (i128::MAX as u128) {\n             Ordering::Greater\n         } else {\n             (s as u128).cmp(&u)\n@@ -2083,50 +2079,20 @@ fn numeric_cast_precast_bounds<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr<'_>)\n         }\n         match pre_cast_ty.kind {\n             ty::Int(int_ty) => Some(match int_ty {\n-                IntTy::I8 => (\n-                    FullInt::S(i128::from(i8::min_value())),\n-                    FullInt::S(i128::from(i8::max_value())),\n-                ),\n-                IntTy::I16 => (\n-                    FullInt::S(i128::from(i16::min_value())),\n-                    FullInt::S(i128::from(i16::max_value())),\n-                ),\n-                IntTy::I32 => (\n-                    FullInt::S(i128::from(i32::min_value())),\n-                    FullInt::S(i128::from(i32::max_value())),\n-                ),\n-                IntTy::I64 => (\n-                    FullInt::S(i128::from(i64::min_value())),\n-                    FullInt::S(i128::from(i64::max_value())),\n-                ),\n-                IntTy::I128 => (FullInt::S(i128::min_value()), FullInt::S(i128::max_value())),\n-                IntTy::Isize => (\n-                    FullInt::S(isize::min_value() as i128),\n-                    FullInt::S(isize::max_value() as i128),\n-                ),\n+                IntTy::I8 => (FullInt::S(i128::from(i8::MIN)), FullInt::S(i128::from(i8::MAX))),\n+                IntTy::I16 => (FullInt::S(i128::from(i16::MIN)), FullInt::S(i128::from(i16::MAX))),\n+                IntTy::I32 => (FullInt::S(i128::from(i32::MIN)), FullInt::S(i128::from(i32::MAX))),\n+                IntTy::I64 => (FullInt::S(i128::from(i64::MIN)), FullInt::S(i128::from(i64::MAX))),\n+                IntTy::I128 => (FullInt::S(i128::MIN), FullInt::S(i128::MAX)),\n+                IntTy::Isize => (FullInt::S(isize::MIN as i128), FullInt::S(isize::MAX as i128)),\n             }),\n             ty::Uint(uint_ty) => Some(match uint_ty {\n-                UintTy::U8 => (\n-                    FullInt::U(u128::from(u8::min_value())),\n-                    FullInt::U(u128::from(u8::max_value())),\n-                ),\n-                UintTy::U16 => (\n-                    FullInt::U(u128::from(u16::min_value())),\n-                    FullInt::U(u128::from(u16::max_value())),\n-                ),\n-                UintTy::U32 => (\n-                    FullInt::U(u128::from(u32::min_value())),\n-                    FullInt::U(u128::from(u32::max_value())),\n-                ),\n-                UintTy::U64 => (\n-                    FullInt::U(u128::from(u64::min_value())),\n-                    FullInt::U(u128::from(u64::max_value())),\n-                ),\n-                UintTy::U128 => (FullInt::U(u128::min_value()), FullInt::U(u128::max_value())),\n-                UintTy::Usize => (\n-                    FullInt::U(usize::min_value() as u128),\n-                    FullInt::U(usize::max_value() as u128),\n-                ),\n+                UintTy::U8 => (FullInt::U(u128::from(u8::MIN)), FullInt::U(u128::from(u8::MAX))),\n+                UintTy::U16 => (FullInt::U(u128::from(u16::MIN)), FullInt::U(u128::from(u16::MAX))),\n+                UintTy::U32 => (FullInt::U(u128::from(u32::MIN)), FullInt::U(u128::from(u32::MAX))),\n+                UintTy::U64 => (FullInt::U(u128::from(u64::MIN)), FullInt::U(u128::from(u64::MAX))),\n+                UintTy::U128 => (FullInt::U(u128::MIN), FullInt::U(u128::MAX)),\n+                UintTy::Usize => (FullInt::U(usize::MIN as u128), FullInt::U(usize::MAX as u128)),\n             }),\n             _ => None,\n         }"}, {"sha": "6ac6a12529c868c13e0c903bcb8b8c6b68660e83", "filename": "clippy_lints/src/unnecessary_sort_by.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_sort_by.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -95,7 +95,10 @@ fn mirrored_exprs(\n         // The two exprs are method calls.\n         // Check to see that the function is the same and the arguments are mirrored\n         // This is enough because the receiver of the method is listed in the arguments\n-        (ExprKind::MethodCall(left_segment, _, left_args), ExprKind::MethodCall(right_segment, _, right_args)) => {\n+        (\n+            ExprKind::MethodCall(left_segment, _, left_args, _),\n+            ExprKind::MethodCall(right_segment, _, right_args, _),\n+        ) => {\n             left_segment.ident == right_segment.ident\n                 && left_args\n                     .iter()\n@@ -170,7 +173,7 @@ fn mirrored_exprs(\n \n fn detect_lint(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n     if_chain! {\n-        if let ExprKind::MethodCall(name_ident, _, args) = &expr.kind;\n+        if let ExprKind::MethodCall(name_ident, _, args, _) = &expr.kind;\n         if let name = name_ident.ident.name.to_ident_string();\n         if name == \"sort_by\" || name == \"sort_unstable_by\";\n         if let [vec, Expr { kind: ExprKind::Closure(_, _, closure_body_id, _, _), .. }] = args;\n@@ -180,7 +183,7 @@ fn detect_lint(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> Option<LintTrigger>\n             Param { pat: Pat { kind: PatKind::Binding(_, _, left_ident, _), .. }, ..},\n             Param { pat: Pat { kind: PatKind::Binding(_, _, right_ident, _), .. }, .. }\n         ] = &closure_body.params;\n-        if let ExprKind::MethodCall(method_path, _, [ref left_expr, ref right_expr]) = &closure_body.value.kind;\n+        if let ExprKind::MethodCall(method_path, _, [ref left_expr, ref right_expr], _) = &closure_body.value.kind;\n         if method_path.ident.name.to_ident_string() == \"cmp\";\n         then {\n             let (closure_body, closure_arg, reverse) = if mirrored_exprs("}, {"sha": "5f4b5fd9dd91cb2c3942e8923435188065c655a7", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -52,7 +52,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n                 }\n             },\n \n-            hir::ExprKind::MethodCall(ref path, _, ref args) => match &*path.ident.as_str() {\n+            hir::ExprKind::MethodCall(ref path, _, ref args, _) => match &*path.ident.as_str() {\n                 \"expect\" | \"unwrap\" | \"unwrap_or\" | \"unwrap_or_else\" => {\n                     check_method_call(cx, &args[0], expr);\n                 },\n@@ -65,7 +65,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedIoAmount {\n }\n \n fn check_method_call(cx: &LateContext<'_, '_>, call: &hir::Expr<'_>, expr: &hir::Expr<'_>) {\n-    if let hir::ExprKind::MethodCall(ref path, _, _) = call.kind {\n+    if let hir::ExprKind::MethodCall(ref path, _, _, _) = call.kind {\n         let symbol = &*path.ident.as_str();\n         let read_trait = match_trait_method(cx, call, &paths::IO_READ);\n         let write_trait = match_trait_method(cx, call, &paths::IO_WRITE);"}, {"sha": "a6c7b5d405cda0aacbcf56040b13554f443e7ec5", "filename": "clippy_lints/src/unwrap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -112,7 +112,7 @@ fn collect_unwrap_info<'a, 'tcx>(\n         return collect_unwrap_info(cx, expr, branch, !invert);\n     } else {\n         if_chain! {\n-            if let ExprKind::MethodCall(method_name, _, args) = &expr.kind;\n+            if let ExprKind::MethodCall(method_name, _, args, _) = &expr.kind;\n             if let ExprKind::Path(QPath::Resolved(None, path)) = &args[0].kind;\n             let ty = cx.tables.expr_ty(&args[0]);\n             let name = method_name.ident.as_str();\n@@ -166,7 +166,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n         } else {\n             // find `unwrap[_err]()` calls:\n             if_chain! {\n-                if let ExprKind::MethodCall(ref method_name, _, ref args) = expr.kind;\n+                if let ExprKind::MethodCall(ref method_name, _, ref args, _) = expr.kind;\n                 if let ExprKind::Path(QPath::Resolved(None, ref path)) = args[0].kind;\n                 if [sym!(unwrap), sym!(unwrap_err)].contains(&method_name.ident.name);\n                 let call_to_unwrap = method_name.ident.name == sym!(unwrap);"}, {"sha": "78d249482d53d2f0e30212c440b7d27a5e40ca27", "filename": "clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -61,7 +61,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessConversion {\n                 }\n             },\n \n-            ExprKind::MethodCall(ref name, .., ref args) => {\n+            ExprKind::MethodCall(ref name, .., ref args, _) => {\n                 if match_trait_method(cx, e, &paths::INTO) && &*name.ident.as_str() == \"into\" {\n                     let a = cx.tables.expr_ty(e);\n                     let b = cx.tables.expr_ty(&args[0]);"}, {"sha": "e60e2a81e070bdeb97296492bfe433117e50cc3c", "filename": "clippy_lints/src/utils/ast_utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fast_utils.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -120,7 +120,7 @@ pub fn eq_expr(l: &Expr, r: &Expr) -> bool {\n         (Array(l), Array(r)) | (Tup(l), Tup(r)) => over(l, r, |l, r| eq_expr(l, r)),\n         (Repeat(le, ls), Repeat(re, rs)) => eq_expr(le, re) && eq_expr(&ls.value, &rs.value),\n         (Call(lc, la), Call(rc, ra)) => eq_expr(lc, rc) && over(la, ra, |l, r| eq_expr(l, r)),\n-        (MethodCall(lc, la), MethodCall(rc, ra)) => eq_path_seg(lc, rc) && over(la, ra, |l, r| eq_expr(l, r)),\n+        (MethodCall(lc, la, _), MethodCall(rc, ra, _)) => eq_path_seg(lc, rc) && over(la, ra, |l, r| eq_expr(l, r)),\n         (Binary(lo, ll, lr), Binary(ro, rl, rr)) => lo.node == ro.node && eq_expr(ll, rl) && eq_expr(lr, rr),\n         (Unary(lo, l), Unary(ro, r)) => mem::discriminant(lo) == mem::discriminant(ro) && eq_expr(l, r),\n         (Lit(l), Lit(r)) => l.kind == r.kind,"}, {"sha": "910b665ccb75ea2fcc1a4682df2e021fd0be9a55", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -250,8 +250,11 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     self.visit_expr(arg);\n                 }\n             },\n-            ExprKind::MethodCall(ref _method_name, ref _generics, ref _args) => {\n-                println!(\"MethodCall(ref method_name, ref generics, ref args) = {};\", current);\n+            ExprKind::MethodCall(ref _method_name, ref _generics, ref _args, ref _fn_span) => {\n+                println!(\n+                    \"MethodCall(ref method_name, ref generics, ref args, ref fn_span) = {};\",\n+                    current\n+                );\n                 println!(\"    // unimplemented: `ExprKind::MethodCall` is not further destructured at the moment\");\n             },\n             ExprKind::Tup(ref elements) => {"}, {"sha": "9a9aa3f94eb4b64ad6bfe491d82aee84442ddd02", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -132,7 +132,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n                             && self.eq_pat(&l.pat, &r.pat)\n                     })\n             },\n-            (&ExprKind::MethodCall(l_path, _, l_args), &ExprKind::MethodCall(r_path, _, r_args)) => {\n+            (&ExprKind::MethodCall(l_path, _, l_args, _), &ExprKind::MethodCall(r_path, _, r_args, _)) => {\n                 !self.ignore_fn && self.eq_path_segment(l_path, r_path) && self.eq_exprs(l_args, r_args)\n             },\n             (&ExprKind::Repeat(ref le, ref ll_id), &ExprKind::Repeat(ref re, ref rl_id)) => {\n@@ -539,7 +539,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n \n                 s.hash(&mut self.s);\n             },\n-            ExprKind::MethodCall(ref path, ref _tys, args) => {\n+            ExprKind::MethodCall(ref path, ref _tys, args, ref _fn_span) => {\n                 self.hash_name(path.ident.name);\n                 self.hash_exprs(args);\n             },\n@@ -707,7 +707,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                     segment.ident.name.hash(&mut self.s);\n                 },\n             },\n-            TyKind::Def(_, arg_list) => {\n+            TyKind::OpaqueDef(_, arg_list) => {\n                 for arg in *arg_list {\n                     match arg {\n                         GenericArg::Lifetime(ref l) => self.hash_lifetime(l),"}, {"sha": "afde971f9df4ef67cf9e403147d815d702eafbf1", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -63,7 +63,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for DeepCodeInspector {\n             },\n             hir::ImplItemKind::Fn(..) => println!(\"method\"),\n             hir::ImplItemKind::TyAlias(_) => println!(\"associated type\"),\n-            hir::ImplItemKind::OpaqueTy(_) => println!(\"existential type\"),\n         }\n     }\n     // fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx\n@@ -167,7 +166,7 @@ fn print_expr(cx: &LateContext<'_, '_>, expr: &hir::Expr<'_>, indent: usize) {\n                 print_expr(cx, arg, indent + 1);\n             }\n         },\n-        hir::ExprKind::MethodCall(ref path, _, args) => {\n+        hir::ExprKind::MethodCall(ref path, _, args, _) => {\n             println!(\"{}MethodCall\", ind);\n             println!(\"{}method name: {}\", ind, path.ident.name);\n             for arg in args {"}, {"sha": "89e2bcdd7935d3e88bc76f2b96ac6eb7588fdf25", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -402,7 +402,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CompilerLintFunctions {\n         }\n \n         if_chain! {\n-            if let ExprKind::MethodCall(ref path, _, ref args) = expr.kind;\n+            if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;\n             let fn_name = path.ident;\n             if let Some(sugg) = self.map.get(&*fn_name.as_str());\n             let ty = walk_ptrs_ty(cx.tables.expr_ty(&args[0]));\n@@ -491,7 +491,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CollapsibleCalls {\n             let stmts = &block.stmts;\n             if stmts.len() == 1 && block.expr.is_none();\n             if let StmtKind::Semi(only_expr) = &stmts[0].kind;\n-            if let ExprKind::MethodCall(ref ps, _, ref span_call_args) = &only_expr.kind;\n+            if let ExprKind::MethodCall(ref ps, _, ref span_call_args, _) = &only_expr.kind;\n             let and_then_snippets = get_and_then_snippets(cx, and_then_args);\n             let mut sle = SpanlessEq::new(cx).ignore_fn();\n             then {"}, {"sha": "60ab19e71f5e4e15b8f9b45ae6cac3fc01f146a5", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -379,7 +379,7 @@ pub fn method_calls<'tcx>(\n \n     let mut current = expr;\n     for _ in 0..max_depth {\n-        if let ExprKind::MethodCall(path, span, args) = &current.kind {\n+        if let ExprKind::MethodCall(path, span, args, _) = &current.kind {\n             if args.iter().any(|e| e.span.from_expansion()) {\n                 break;\n             }\n@@ -406,7 +406,7 @@ pub fn method_chain_args<'a>(expr: &'a Expr<'_>, methods: &[&str]) -> Option<Vec\n     let mut matched = Vec::with_capacity(methods.len());\n     for method_name in methods.iter().rev() {\n         // method chains are stored last -> first\n-        if let ExprKind::MethodCall(ref path, _, ref args) = current.kind {\n+        if let ExprKind::MethodCall(ref path, _, ref args, _) = current.kind {\n             if path.ident.name.as_str() == *method_name {\n                 if args.iter().any(|e| e.span.from_expansion()) {\n                     return None;\n@@ -1324,7 +1324,7 @@ pub fn is_must_use_func_call(cx: &LateContext<'_, '_>, expr: &Expr<'_>) -> bool\n                 None\n             }\n         },\n-        ExprKind::MethodCall(_, _, _) => cx.tables.type_dependent_def_id(expr.hir_id),\n+        ExprKind::MethodCall(_, _, _, _) => cx.tables.type_dependent_def_id(expr.hir_id),\n         _ => None,\n     };\n "}, {"sha": "ee336ecc58d958722ba965d8b2cfded874a891ab", "filename": "clippy_lints/src/utils/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Futils%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Futils%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fptr.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -58,7 +58,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PtrCloneVisitor<'a, 'tcx> {\n         if self.abort {\n             return;\n         }\n-        if let ExprKind::MethodCall(ref seg, _, ref args) = expr.kind {\n+        if let ExprKind::MethodCall(ref seg, _, ref args, _) = expr.kind {\n             if args.len() == 1 && match_var(&args[0], self.name) {\n                 if seg.ident.name.as_str() == \"capacity\" {\n                     self.abort = true;"}, {"sha": "0492878fc272f19a8028fa6ac04a168fd76c6a8b", "filename": "clippy_lints/src/utils/usage.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -8,7 +8,7 @@ use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty;\n use rustc_span::symbol::{Ident, Symbol};\n-use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, Place, PlaceBase};\n+use rustc_typeck::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor, PlaceBase, PlaceWithHirId};\n \n /// Returns a set of mutated local variable IDs, or `None` if mutations could not be determined.\n pub fn mutated_variables<'a, 'tcx>(expr: &'tcx Expr<'_>, cx: &'a LateContext<'a, 'tcx>) -> Option<FxHashSet<HirId>> {\n@@ -46,8 +46,8 @@ struct MutVarsDelegate {\n \n impl<'tcx> MutVarsDelegate {\n     #[allow(clippy::similar_names)]\n-    fn update(&mut self, cat: &Place<'tcx>) {\n-        match cat.base {\n+    fn update(&mut self, cat: &PlaceWithHirId<'tcx>) {\n+        match cat.place.base {\n             PlaceBase::Local(id) => {\n                 self.used_mutably.insert(id);\n             },\n@@ -63,15 +63,15 @@ impl<'tcx> MutVarsDelegate {\n }\n \n impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n-    fn consume(&mut self, _: &Place<'tcx>, _: ConsumeMode) {}\n+    fn consume(&mut self, _: &PlaceWithHirId<'tcx>, _: ConsumeMode) {}\n \n-    fn borrow(&mut self, cmt: &Place<'tcx>, bk: ty::BorrowKind) {\n+    fn borrow(&mut self, cmt: &PlaceWithHirId<'tcx>, bk: ty::BorrowKind) {\n         if let ty::BorrowKind::MutBorrow = bk {\n             self.update(&cmt)\n         }\n     }\n \n-    fn mutate(&mut self, cmt: &Place<'tcx>) {\n+    fn mutate(&mut self, cmt: &PlaceWithHirId<'tcx>) {\n         self.update(&cmt)\n     }\n }"}, {"sha": "55758efa32e67f7e0d390f90d5e7b517a89695fe", "filename": "clippy_lints/src/vec_resize_to_zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fvec_resize_to_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fvec_resize_to_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec_resize_to_zero.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -31,7 +31,7 @@ declare_lint_pass!(VecResizeToZero => [VEC_RESIZE_TO_ZERO]);\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VecResizeToZero {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n-            if let hir::ExprKind::MethodCall(path_segment, _, ref args) = expr.kind;\n+            if let hir::ExprKind::MethodCall(path_segment, _, ref args, _) = expr.kind;\n             if let Some(method_def_id) = cx.tables.type_dependent_def_id(expr.hir_id);\n             if match_def_path(cx, method_def_id, &paths::VEC_RESIZE) && args.len() == 3;\n             if let ExprKind::Lit(Spanned { node: LitKind::Int(0, _), .. }) = args[1].kind;"}, {"sha": "6d420d491c50f1aac1c7d9c3f9b9069e764e161a", "filename": "clippy_lints/src/verbose_file_reads.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fverbose_file_reads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/clippy_lints%2Fsrc%2Fverbose_file_reads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fverbose_file_reads.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -59,7 +59,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VerboseFileReads {\n \n fn is_file_read_to_end<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n     if_chain! {\n-        if let ExprKind::MethodCall(method_name, _, exprs) = expr.kind;\n+        if let ExprKind::MethodCall(method_name, _, exprs, _) = expr.kind;\n         if method_name.ident.as_str() == \"read_to_end\";\n         if let ExprKind::Path(QPath::Resolved(None, _)) = &exprs[0].kind;\n         let ty = cx.tables.expr_ty(&exprs[0]);\n@@ -73,7 +73,7 @@ fn is_file_read_to_end<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'t\n \n fn is_file_read_to_string<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr<'tcx>) -> bool {\n     if_chain! {\n-        if let ExprKind::MethodCall(method_name, _, exprs) = expr.kind;\n+        if let ExprKind::MethodCall(method_name, _, exprs, _) = expr.kind;\n         if method_name.ident.as_str() == \"read_to_string\";\n         if let ExprKind::Path(QPath::Resolved(None, _)) = &exprs[0].kind;\n         let ty = cx.tables.expr_ty(&exprs[0]);"}, {"sha": "99505fc6b29b252f09404680d0e9dd5649e76ae4", "filename": "tests/compile-test.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/tests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/tests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-test.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -49,7 +49,9 @@ fn third_party_crates() -> String {\n         if let Some(name) = path.file_name().and_then(OsStr::to_str) {\n             for dep in CRATES {\n                 if name.starts_with(&format!(\"lib{}-\", dep)) && name.ends_with(\".rlib\") {\n-                    crates.entry(dep).or_insert(path);\n+                    if let Some(old) = crates.insert(dep, path.clone()) {\n+                        panic!(\"Found multiple rlibs for crate `{}`: `{:?}` and `{:?}\", dep, old, path);\n+                    }\n                     break;\n                 }\n             }"}, {"sha": "8ee0969b0f0761b16371eb485570ac83ad3abe5d", "filename": "tests/ui/cast.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/tests%2Fui%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/tests%2Fui%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -37,11 +37,11 @@ fn main() {\n     1isize as usize;\n     -1isize as usize;\n     0i8 as u8;\n-    i8::max_value() as u8;\n-    i16::max_value() as u16;\n-    i32::max_value() as u32;\n-    i64::max_value() as u64;\n-    i128::max_value() as u128;\n+    i8::MAX as u8;\n+    i16::MAX as u16;\n+    i32::MAX as u32;\n+    i64::MAX as u64;\n+    i128::MAX as u128;\n \n     (-1i8).abs() as u8;\n     (-1i16).abs() as u16;"}, {"sha": "2f32a7b1578219a2a5c951b9099994a22681bed5", "filename": "tests/ui/implicit_saturating_sub.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/tests%2Fui%2Fimplicit_saturating_sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/tests%2Fui%2Fimplicit_saturating_sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_saturating_sub.rs?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -110,7 +110,7 @@ fn main() {\n     }\n \n     // Lint\n-    if i_8 > i8::min_value() {\n+    if i_8 > i8::MIN {\n         i_8 -= 1;\n     }\n \n@@ -120,7 +120,7 @@ fn main() {\n     }\n \n     // Lint\n-    if i_8 != i8::min_value() {\n+    if i_8 != i8::MIN {\n         i_8 -= 1;\n     }\n \n@@ -135,7 +135,7 @@ fn main() {\n     }\n \n     // Lint\n-    if i_16 > i16::min_value() {\n+    if i_16 > i16::MIN {\n         i_16 -= 1;\n     }\n \n@@ -145,7 +145,7 @@ fn main() {\n     }\n \n     // Lint\n-    if i_16 != i16::min_value() {\n+    if i_16 != i16::MIN {\n         i_16 -= 1;\n     }\n \n@@ -160,7 +160,7 @@ fn main() {\n     }\n \n     // Lint\n-    if i_32 > i32::min_value() {\n+    if i_32 > i32::MIN {\n         i_32 -= 1;\n     }\n \n@@ -170,7 +170,7 @@ fn main() {\n     }\n \n     // Lint\n-    if i_32 != i32::min_value() {\n+    if i_32 != i32::MIN {\n         i_32 -= 1;\n     }\n \n@@ -180,7 +180,7 @@ fn main() {\n     let mut i_64: i64 = endi_64 - starti_64;\n \n     // Lint\n-    if i64::min_value() < i_64 {\n+    if i64::MIN < i_64 {\n         i_64 -= 1;\n     }\n "}, {"sha": "2eb2023b3b9ef44bbdfa0c0c7f23169f6b0de117", "filename": "tests/ui/implicit_saturating_sub.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/tests%2Fui%2Fimplicit_saturating_sub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fa0f6a8dbf049cbae679dc82d653371c5a8c0be4/tests%2Fui%2Fimplicit_saturating_sub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_saturating_sub.stderr?ref=fa0f6a8dbf049cbae679dc82d653371c5a8c0be4", "patch": "@@ -75,7 +75,7 @@ LL | |     }\n error: Implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:113:5\n    |\n-LL | /     if i_8 > i8::min_value() {\n+LL | /     if i_8 > i8::MIN {\n LL | |         i_8 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_8 = i_8.saturating_sub(1);`\n@@ -91,7 +91,7 @@ LL | |     }\n error: Implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:123:5\n    |\n-LL | /     if i_8 != i8::min_value() {\n+LL | /     if i_8 != i8::MIN {\n LL | |         i_8 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_8 = i_8.saturating_sub(1);`\n@@ -107,7 +107,7 @@ LL | |     }\n error: Implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:138:5\n    |\n-LL | /     if i_16 > i16::min_value() {\n+LL | /     if i_16 > i16::MIN {\n LL | |         i_16 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_16 = i_16.saturating_sub(1);`\n@@ -123,7 +123,7 @@ LL | |     }\n error: Implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:148:5\n    |\n-LL | /     if i_16 != i16::min_value() {\n+LL | /     if i_16 != i16::MIN {\n LL | |         i_16 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_16 = i_16.saturating_sub(1);`\n@@ -139,7 +139,7 @@ LL | |     }\n error: Implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:163:5\n    |\n-LL | /     if i_32 > i32::min_value() {\n+LL | /     if i_32 > i32::MIN {\n LL | |         i_32 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_32 = i_32.saturating_sub(1);`\n@@ -155,15 +155,15 @@ LL | |     }\n error: Implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:173:5\n    |\n-LL | /     if i_32 != i32::min_value() {\n+LL | /     if i_32 != i32::MIN {\n LL | |         i_32 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_32 = i_32.saturating_sub(1);`\n \n error: Implicitly performing saturating subtraction\n   --> $DIR/implicit_saturating_sub.rs:183:5\n    |\n-LL | /     if i64::min_value() < i_64 {\n+LL | /     if i64::MIN < i_64 {\n LL | |         i_64 -= 1;\n LL | |     }\n    | |_____^ help: try: `i_64 = i_64.saturating_sub(1);`"}]}