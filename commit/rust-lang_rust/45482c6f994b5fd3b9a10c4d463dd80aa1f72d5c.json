{"sha": "45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1NDgyYzZmOTk0YjVmZDNiOWExMGM0ZDQ2M2RkODBhYTFmNzJkNWM=", "commit": {"author": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2018-05-19T17:50:58Z"}, "committer": {"name": "Wesley Wiser", "email": "wwiser@gmail.com", "date": "2018-08-02T22:57:24Z"}, "message": "Basic profiling", "tree": {"sha": "97c40eb4861231746461ae8ea47ed5c261f0e92a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/97c40eb4861231746461ae8ea47ed5c261f0e92a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c", "html_url": "https://github.com/rust-lang/rust/commit/45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c/comments", "author": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "committer": {"login": "wesleywiser", "id": 831192, "node_id": "MDQ6VXNlcjgzMTE5Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/831192?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wesleywiser", "html_url": "https://github.com/wesleywiser", "followers_url": "https://api.github.com/users/wesleywiser/followers", "following_url": "https://api.github.com/users/wesleywiser/following{/other_user}", "gists_url": "https://api.github.com/users/wesleywiser/gists{/gist_id}", "starred_url": "https://api.github.com/users/wesleywiser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wesleywiser/subscriptions", "organizations_url": "https://api.github.com/users/wesleywiser/orgs", "repos_url": "https://api.github.com/users/wesleywiser/repos", "events_url": "https://api.github.com/users/wesleywiser/events{/privacy}", "received_events_url": "https://api.github.com/users/wesleywiser/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40cb4478a3f550bf12d81cdcf08cc9ef3985ed41", "url": "https://api.github.com/repos/rust-lang/rust/commits/40cb4478a3f550bf12d81cdcf08cc9ef3985ed41", "html_url": "https://github.com/rust-lang/rust/commit/40cb4478a3f550bf12d81cdcf08cc9ef3985ed41"}], "stats": {"total": 260, "additions": 259, "deletions": 1}, "files": [{"sha": "bac511aac1fe10108f01adb76258d4df01fdcbdf", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c", "patch": "@@ -165,6 +165,7 @@ pub mod util {\n     pub mod nodemap;\n     pub mod fs;\n     pub mod time_graph;\n+    pub mod profiling;\n }\n \n // A private module so that macro-expanded idents like"}, {"sha": "cc29bad9cb532be52abb5d1fe339ebd3d5964750", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c", "patch": "@@ -65,7 +65,7 @@ pub enum Sanitizer {\n     Thread,\n }\n \n-#[derive(Clone, Copy, PartialEq, Hash)]\n+#[derive(Clone, Copy, Debug, PartialEq, Hash)]\n pub enum OptLevel {\n     No,         // -O0\n     Less,       // -O1\n@@ -1367,6 +1367,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"disables the 'leak check' for subtyping; unsound, but useful for tests\"),\n     crate_attr: Vec<String> = (Vec::new(), parse_string_push, [TRACKED],\n         \"inject the given attribute in the crate\"),\n+    self_profile: bool = (false, parse_bool, [UNTRACKED],\n+          \"run the self profiler\"),\n }\n \n pub fn default_lib_output() -> CrateType {"}, {"sha": "a321728f74989332053d28607a04758166dd5dbe", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c", "patch": "@@ -40,6 +40,7 @@ use syntax::parse::ParseSess;\n use syntax::{ast, codemap};\n use syntax::feature_gate::AttributeType;\n use syntax_pos::{MultiSpan, Span};\n+use util::profiling::SelfProfiler;\n \n use rustc_target::spec::{LinkerFlavor, PanicStrategy};\n use rustc_target::spec::{Target, TargetTriple};\n@@ -133,6 +134,9 @@ pub struct Session {\n     /// Used by -Z profile-queries in util::common\n     pub profile_channel: Lock<Option<mpsc::Sender<ProfileQueriesMsg>>>,\n \n+    /// Used by -Z self-profile\n+    pub self_profiling: Lock<SelfProfiler>,\n+\n     /// Some measurements that are being gathered during compilation.\n     pub perf_stats: PerfStats,\n \n@@ -825,6 +829,16 @@ impl Session {\n         }\n     }\n \n+    pub fn profiler<F: FnOnce(&mut SelfProfiler) -> ()>(&self, f: F) {\n+        let mut profiler = self.self_profiling.borrow_mut();\n+        f(&mut profiler);\n+    }\n+\n+    pub fn print_profiler_results(&self) {\n+        let mut profiler = self.self_profiling.borrow_mut();\n+        profiler.print_results(&self.opts);\n+    }\n+\n     pub fn print_perf_stats(&self) {\n         println!(\n             \"Total time spent computing symbol hashes:      {}\",\n@@ -1125,6 +1139,7 @@ pub fn build_session_(\n         imported_macro_spans: OneThread::new(RefCell::new(HashMap::new())),\n         incr_comp_session: OneThread::new(RefCell::new(IncrCompSession::NotInitialized)),\n         ignored_attr_names: ich::compute_ignored_attr_names(),\n+        self_profiling: Lock::new(SelfProfiler::new()),\n         profile_channel: Lock::new(None),\n         perf_stats: PerfStats {\n             symbol_hash_time: Lock::new(Duration::from_secs(0)),"}, {"sha": "d2648cad55ee9fa11dd03372af55cc510952b906", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c", "patch": "@@ -21,6 +21,7 @@ use ty::subst::Substs;\n use ty::query::queries;\n use ty::query::Query;\n use ty::query::QueryCache;\n+use util::profiling::ProfileCategory;\n \n use std::hash::Hash;\n use std::fmt::Debug;\n@@ -33,6 +34,7 @@ use ich::StableHashingContext;\n \n pub trait QueryConfig<'tcx> {\n     const NAME: &'static str;\n+    const CATEGORY: ProfileCategory;\n \n     type Key: Eq + Hash + Clone + Debug;\n     type Value: Clone + for<'a> HashStable<StableHashingContext<'a>>;"}, {"sha": "ab9bdd82e01ebf6cb97aa00f404f6810c93d571e", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c", "patch": "@@ -46,6 +46,7 @@ use ty::steal::Steal;\n use ty::subst::Substs;\n use util::nodemap::{DefIdSet, DefIdMap, ItemLocalSet};\n use util::common::{ErrorReported};\n+use util::profiling::ProfileCategory::*;\n \n use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_target::spec::PanicStrategy;"}, {"sha": "62e69ffee673f15c80c91e781dd16ce49bb18941", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c", "patch": "@@ -379,13 +379,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         if dep_node.kind.is_anon() {\n             profq_msg!(self, ProfileQueriesMsg::ProviderBegin);\n+            self.sess.profiler(|p| p.start_activity(Q::CATEGORY));\n \n             let res = job.start(self, |tcx| {\n                 tcx.dep_graph.with_anon_task(dep_node.kind, || {\n                     Q::compute(tcx.global_tcx(), key)\n                 })\n             });\n \n+            self.sess.profiler(|p| p.end_activity(Q::CATEGORY));\n             profq_msg!(self, ProfileQueriesMsg::ProviderEnd);\n             let ((result, dep_node_index), diagnostics) = res;\n \n@@ -523,6 +525,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 key, dep_node);\n \n         profq_msg!(self, ProfileQueriesMsg::ProviderBegin);\n+        self.sess.profiler(|p| p.start_activity(Q::CATEGORY));\n+\n         let res = job.start(self, |tcx| {\n             if dep_node.kind.is_eval_always() {\n                 tcx.dep_graph.with_eval_always_task(dep_node,\n@@ -536,6 +540,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                         Q::compute)\n             }\n         });\n+\n+        self.sess.profiler(|p| p.end_activity(Q::CATEGORY));\n         profq_msg!(self, ProfileQueriesMsg::ProviderEnd);\n \n         let ((result, dep_node_index), diagnostics) = res;\n@@ -655,6 +661,7 @@ macro_rules! define_queries_inner {\n             rustc_data_structures::stable_hasher::StableHasher,\n             ich::StableHashingContext\n         };\n+        use util::profiling::ProfileCategory;\n \n         define_queries_struct! {\n             tcx: $tcx,\n@@ -768,6 +775,7 @@ macro_rules! define_queries_inner {\n             type Value = $V;\n \n             const NAME: &'static str = stringify!($name);\n+            const CATEGORY: ProfileCategory = $category;\n         }\n \n         impl<$tcx> QueryAccessors<$tcx> for queries::$name<$tcx> {"}, {"sha": "eb20a85ca69f0fd366bbaa9dc0fb2286e623a189", "filename": "src/librustc/util/profiling.rs", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c/src%2Flibrustc%2Futil%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c/src%2Flibrustc%2Futil%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fprofiling.rs?ref=45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c", "patch": "@@ -0,0 +1,207 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use session::config::Options;\n+\n+use std::io::{self, StdoutLock, Write};\n+use std::time::Instant;\n+\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+pub enum ProfileCategory {\n+    Parsing,\n+    Expansion,\n+    TypeChecking,\n+    BorrowChecking,\n+    Codegen,\n+    Linking,\n+    Other,\n+}\n+\n+struct Categories<T> {\n+    parsing: T,\n+    expansion: T,\n+    type_checking: T,\n+    borrow_checking: T,\n+    codegen: T,\n+    linking: T,\n+    other: T,\n+}\n+\n+impl<T: Default> Categories<T> {\n+    fn new() -> Categories<T> {\n+        Categories {\n+            parsing: T::default(),\n+            expansion: T::default(),\n+            type_checking: T::default(),\n+            borrow_checking: T::default(),\n+            codegen: T::default(),\n+            linking: T::default(),\n+            other: T::default(),\n+        }\n+    }\n+}\n+\n+impl<T> Categories<T> {\n+    fn get(&self, category: ProfileCategory) -> &T {\n+        match category {\n+            ProfileCategory::Parsing => &self.parsing,\n+            ProfileCategory::Expansion => &self.expansion,\n+            ProfileCategory::TypeChecking => &self.type_checking,\n+            ProfileCategory::BorrowChecking => &self.borrow_checking,\n+            ProfileCategory::Codegen => &self.codegen,\n+            ProfileCategory::Linking => &self.linking,\n+            ProfileCategory::Other => &self.other,\n+        }\n+    }\n+\n+    fn set(&mut self, category: ProfileCategory, value: T) {\n+        match category {\n+            ProfileCategory::Parsing => self.parsing = value,\n+            ProfileCategory::Expansion => self.expansion = value,\n+            ProfileCategory::TypeChecking => self.type_checking = value,\n+            ProfileCategory::BorrowChecking => self.borrow_checking = value,\n+            ProfileCategory::Codegen => self.codegen = value,\n+            ProfileCategory::Linking => self.linking = value,\n+            ProfileCategory::Other => self.other = value,\n+        }\n+    }\n+}\n+\n+struct CategoryData {\n+    times: Categories<u64>,\n+}\n+\n+impl CategoryData {\n+    fn new() -> CategoryData {\n+        CategoryData {\n+            times: Categories::new(),\n+        }\n+    }\n+\n+    fn print(&self, lock: &mut StdoutLock) {\n+        writeln!(lock, \"{0: <15} \\t\\t {1: <15}\", \"Parsing\", self.times.parsing / 1_000_000).unwrap();\n+        writeln!(lock, \"{0: <15} \\t\\t {1: <15}\", \"Expansion\", self.times.expansion / 1_000_000).unwrap();\n+        writeln!(lock, \"{0: <15} \\t\\t {1: <15}\", \"TypeChecking\", self.times.type_checking / 1_000_000).unwrap();\n+        writeln!(lock, \"{0: <15} \\t\\t {1: <15}\", \"BorrowChecking\", self.times.borrow_checking / 1_000_000).unwrap();\n+        writeln!(lock, \"{0: <15} \\t\\t {1: <15}\", \"Codegen\", self.times.codegen / 1_000_000).unwrap();\n+        writeln!(lock, \"{0: <15} \\t\\t {1: <15}\", \"Linking\", self.times.linking / 1_000_000).unwrap();\n+        writeln!(lock, \"{0: <15} \\t\\t {1: <15}\", \"Other\", self.times.other / 1_000_000).unwrap();\n+    }\n+}\n+\n+pub struct SelfProfiler {\n+    timer_stack: Vec<ProfileCategory>,\n+    data: CategoryData,\n+    current_timer: Instant,\n+}\n+\n+pub struct ProfilerActivity<'a>(ProfileCategory, &'a mut SelfProfiler);\n+\n+impl<'a> Drop for ProfilerActivity<'a> {\n+    fn drop(&mut self) {\n+        let ProfilerActivity (category, profiler) = self;\n+\n+        profiler.end_activity(*category);\n+    }\n+}\n+\n+impl SelfProfiler {\n+    pub fn new() -> SelfProfiler {\n+        let mut profiler = SelfProfiler {\n+            timer_stack: Vec::new(),\n+            data: CategoryData::new(),\n+            current_timer: Instant::now(),\n+        };\n+\n+        profiler.start_activity(ProfileCategory::Other);\n+\n+        profiler\n+    }\n+\n+    pub fn start_activity(&mut self, category: ProfileCategory) {\n+        match self.timer_stack.last().cloned() {\n+            None => {\n+                self.current_timer = Instant::now();\n+            },\n+            Some(current_category) if current_category == category => {\n+                //since the current category is the same as the new activity's category,\n+                //we don't need to do anything with the timer, we just need to push it on the stack\n+            }\n+            Some(current_category) => {\n+                let elapsed = self.stop_timer();\n+\n+                //record the current category's time\n+                let new_time = self.data.times.get(current_category) + elapsed;\n+                self.data.times.set(current_category, new_time);\n+            }\n+        }\n+\n+        //push the new category\n+        self.timer_stack.push(category);\n+    }\n+\n+    pub fn end_activity(&mut self, category: ProfileCategory) {\n+        match self.timer_stack.pop() {\n+            None => bug!(\"end_activity() was called but there was no running activity\"),\n+            Some(c) => \n+                assert!(\n+                    c == category, \n+                    \"end_activity() was called but a different activity was running\"),\n+        }\n+\n+        //check if the new running timer is in the same category as this one\n+        //if it is, we don't need to do anything\n+        if let Some(c) = self.timer_stack.last() {\n+            if *c == category {\n+                return;\n+            }\n+        }\n+\n+        //the new timer is different than the previous, so record the elapsed time and start a new timer\n+        let elapsed = self.stop_timer();\n+        let new_time = self.data.times.get(category) + elapsed;\n+        self.data.times.set(category, new_time);\n+    }\n+\n+    fn stop_timer(&mut self) -> u64 {\n+        let elapsed = self.current_timer.elapsed();\n+\n+        self.current_timer = Instant::now();\n+\n+        (elapsed.as_secs() * 1_000_000_000) + (elapsed.subsec_nanos() as u64)\n+    }\n+\n+    pub fn print_results(&mut self, opts: &Options) {\n+        self.end_activity(ProfileCategory::Other);\n+\n+        assert!(self.timer_stack.is_empty(), \"there were timers running when print_results() was called\");\n+\n+        let out = io::stdout();\n+        let mut lock = out.lock();\n+\n+        let crate_name = opts.crate_name.as_ref().map(|n| format!(\" for {}\", n)).unwrap_or_default();\n+\n+        writeln!(lock, \"Self profiling results{}:\", crate_name).unwrap();\n+\n+        self.data.print(&mut lock);\n+\n+        writeln!(lock).unwrap();\n+        writeln!(lock, \"Optimization level: {:?}\", opts.optimize).unwrap();\n+\n+        let incremental = if opts.incremental.is_some() { \"on\" } else { \"off\" };\n+        writeln!(lock, \"Incremental: {}\", incremental).unwrap();\n+    }\n+\n+    pub fn record_activity<'a>(&'a mut self, category: ProfileCategory) -> ProfilerActivity<'a> {\n+        self.start_activity(category);\n+\n+        ProfilerActivity(category, self)\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "34cd3998f83cc689b0b278bcfa35d367daf48614", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c", "patch": "@@ -45,6 +45,7 @@ use rustc::dep_graph::{DepNode, DepConstructor};\n use rustc::middle::cstore::{self, LinkMeta, LinkagePreference};\n use rustc::middle::exported_symbols;\n use rustc::util::common::{time, print_time_passes_entry};\n+use rustc::util::profiling::ProfileCategory;\n use rustc::session::config::{self, NoDebugInfo};\n use rustc::session::Session;\n use rustc_incremental;\n@@ -741,11 +742,13 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let link_meta = link::build_link_meta(crate_hash);\n \n     // Codegen the metadata.\n+    tcx.sess.profiler(|p| p.start_activity(ProfileCategory::Codegen));\n     let llmod_id = \"metadata\";\n     let metadata_llvm_module = ModuleLlvm::new(tcx.sess, llmod_id);\n     let metadata = time(tcx.sess, \"write metadata\", || {\n         write_metadata(tcx, &metadata_llvm_module, &link_meta)\n     });\n+    tcx.sess.profiler(|p| p.end_activity(ProfileCategory::Codegen));\n \n     let metadata_module = ModuleCodegen {\n         name: link::METADATA_MODULE_NAME.to_string(),"}, {"sha": "c01ef37d1b8cca664653b8e90d249c09f51d2680", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c", "patch": "@@ -84,6 +84,7 @@ use rustc::session::config::{OutputFilenames, OutputType, PrintRequest};\n use rustc::ty::{self, TyCtxt};\n use rustc::util::time_graph;\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n+use rustc::util::profiling::ProfileCategory;\n use rustc_mir::monomorphize;\n use rustc_codegen_utils::codegen_backend::CodegenBackend;\n \n@@ -240,10 +241,12 @@ impl CodegenBackend for LlvmCodegenBackend {\n \n         // Run the linker on any artifacts that resulted from the LLVM run.\n         // This should produce either a finished executable or library.\n+        sess.profiler(|p| p.start_activity(ProfileCategory::Linking));\n         time(sess, \"linking\", || {\n             back::link::link_binary(sess, &ongoing_codegen,\n                                     outputs, &ongoing_codegen.crate_name.as_str());\n         });\n+        sess.profiler(|p| p.end_activity(ProfileCategory::Linking));\n \n         // Now that we won't touch anything in the incremental compilation directory\n         // any more, we can finalize it (which involves renaming it)"}, {"sha": "d862741cda54f992ad2a99c63f527ffe1d2830a7", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c", "patch": "@@ -25,6 +25,7 @@ use rustc::middle::privacy::AccessLevels;\n use rustc::ty::{self, AllArenas, Resolutions, TyCtxt};\n use rustc::traits;\n use rustc::util::common::{install_panic_hook, time, ErrorReported};\n+use rustc::util::profiling::ProfileCategory;\n use rustc_allocator as allocator;\n use rustc_borrowck as borrowck;\n use rustc_incremental;\n@@ -352,6 +353,10 @@ pub fn compile_input(\n         sess.print_perf_stats();\n     }\n \n+    if sess.opts.debugging_opts.self_profile {\n+        sess.print_profiler_results();\n+    }\n+\n     controller_entry_point!(\n         compilation_done,\n         sess,\n@@ -667,13 +672,15 @@ pub fn phase_1_parse_input<'a>(\n         profile::begin(sess);\n     }\n \n+    sess.profiler(|p| p.start_activity(ProfileCategory::Parsing));\n     let krate = time(sess, \"parsing\", || match *input {\n         Input::File(ref file) => parse::parse_crate_from_file(file, &sess.parse_sess),\n         Input::Str {\n             ref input,\n             ref name,\n         } => parse::parse_crate_from_source_str(name.clone(), input.clone(), &sess.parse_sess),\n     })?;\n+    sess.profiler(|p| p.end_activity(ProfileCategory::Parsing));\n \n     sess.diagnostic().set_continue_after_error(true);\n \n@@ -944,6 +951,7 @@ where\n     syntax_ext::register_builtins(&mut resolver, syntax_exts, sess.features_untracked().quote);\n \n     // Expand all macros\n+    sess.profiler(|p| p.start_activity(ProfileCategory::Expansion));\n     krate = time(sess, \"expansion\", || {\n         // Windows dlls do not have rpaths, so they don't know how to find their\n         // dependencies. It's up to us to tell the system where to find all the\n@@ -1021,6 +1029,7 @@ where\n         }\n         krate\n     });\n+    sess.profiler(|p| p.end_activity(ProfileCategory::Expansion));\n \n     krate = time(sess, \"maybe building test harness\", || {\n         syntax::test::modify_for_testing(\n@@ -1350,7 +1359,9 @@ pub fn phase_4_codegen<'a, 'tcx>(\n         ::rustc::middle::dependency_format::calculate(tcx)\n     });\n \n+    tcx.sess.profiler(|p| p.start_activity(ProfileCategory::Codegen));\n     let codegen = time(tcx.sess, \"codegen\", move || codegen_backend.codegen_crate(tcx, rx));\n+    tcx.sess.profiler(|p| p.end_activity(ProfileCategory::Codegen));\n     if tcx.sess.profile_queries() {\n         profile::dump(&tcx.sess, \"profile_queries\".to_string())\n     }"}, {"sha": "4f1609455178b0cbbafc53d4c26a57fa988691c6", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=45482c6f994b5fd3b9a10c4d463dd80aa1f72d5c", "patch": "@@ -109,6 +109,7 @@ use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::query::Providers;\n use rustc::traits::{ObligationCause, ObligationCauseCode, TraitEngine, TraitEngineExt};\n+use rustc::util::profiling::ProfileCategory;\n use session::{CompileIncomplete, config};\n use util::common::time;\n \n@@ -334,6 +335,8 @@ pub fn provide(providers: &mut Providers) {\n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                              -> Result<(), CompileIncomplete>\n {\n+    tcx.sess.profiler(|p| p.start_activity(ProfileCategory::TypeChecking));\n+\n     // this ensures that later parts of type checking can assume that items\n     // have valid types and not error\n     tcx.sess.track_errors(|| {\n@@ -371,6 +374,8 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n     check_unused::check_crate(tcx);\n     check_for_entry_fn(tcx);\n \n+    tcx.sess.profiler(|p| p.end_activity(ProfileCategory::TypeChecking));\n+\n     tcx.sess.compile_status()\n }\n "}]}