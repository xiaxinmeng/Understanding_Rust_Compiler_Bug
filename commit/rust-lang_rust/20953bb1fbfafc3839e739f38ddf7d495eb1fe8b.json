{"sha": "20953bb1fbfafc3839e739f38ddf7d495eb1fe8b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwOTUzYmIxZmJmYWZjMzgzOWU3MzlmMzhkZGY3ZDQ5NWViMWZlOGI=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-08-10T20:04:16Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-08-10T20:04:16Z"}, "message": "Merge branch 'match' of https://github.com/msullivan/rust into rollup", "tree": {"sha": "f7492e25ff06c4eeb3d1e480f641344b306c4247", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7492e25ff06c4eeb3d1e480f641344b306c4247"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20953bb1fbfafc3839e739f38ddf7d495eb1fe8b", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20953bb1fbfafc3839e739f38ddf7d495eb1fe8b", "html_url": "https://github.com/rust-lang/rust/commit/20953bb1fbfafc3839e739f38ddf7d495eb1fe8b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20953bb1fbfafc3839e739f38ddf7d495eb1fe8b/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f007a46d37d4f2aafd1008e4c0dcc6e694936d96", "url": "https://api.github.com/repos/rust-lang/rust/commits/f007a46d37d4f2aafd1008e4c0dcc6e694936d96", "html_url": "https://github.com/rust-lang/rust/commit/f007a46d37d4f2aafd1008e4c0dcc6e694936d96"}, {"sha": "437a4c28a338767bab9d003a80bcea38c658791b", "url": "https://api.github.com/repos/rust-lang/rust/commits/437a4c28a338767bab9d003a80bcea38c658791b", "html_url": "https://github.com/rust-lang/rust/commit/437a4c28a338767bab9d003a80bcea38c658791b"}], "stats": {"total": 257, "additions": 196, "deletions": 61}, "files": [{"sha": "c98d859337c3e4a2bf116a3c951b137030595cda", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 165, "deletions": 50, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/20953bb1fbfafc3839e739f38ddf7d495eb1fe8b/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20953bb1fbfafc3839e739f38ddf7d495eb1fe8b/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=20953bb1fbfafc3839e739f38ddf7d495eb1fe8b", "patch": "@@ -145,6 +145,51 @@\n  * - `store_non_ref_bindings()`\n  * - `insert_lllocals()`\n  *\n+ *\n+ * ## Notes on vector pattern matching.\n+ *\n+ * Vector pattern matching is surprisingly tricky. The problem is that\n+ * the structure of the vector isn't fully known, and slice matches\n+ * can be done on subparts of it.\n+ *\n+ * The way that vector pattern matches are dealt with, then, is as\n+ * follows. First, we make the actual condition associated with a\n+ * vector pattern simply a vector length comparison. So the pattern\n+ * [1, .. x] gets the condition \"vec len >= 1\", and the pattern\n+ * [.. x] gets the condition \"vec len >= 0\". The problem here is that\n+ * having the condition \"vec len >= 1\" hold clearly does not mean that\n+ * only a pattern that has exactly that condition will match. This\n+ * means that it may well be the case that a condition holds, but none\n+ * of the patterns matching that condition match; to deal with this,\n+ * when doing vector length matches, we have match failures proceed to\n+ * the next condition to check.\n+ *\n+ * There are a couple more subtleties to deal with. While the \"actual\"\n+ * condition associated with vector length tests is simply a test on\n+ * the vector length, the actual vec_len Opt entry contains more\n+ * information used to restrict which matches are associated with it.\n+ * So that all matches in a submatch are matching against the same\n+ * values from inside the vector, they are split up by how many\n+ * elements they match at the front and at the back of the vector. In\n+ * order to make sure that arms are properly checked in order, even\n+ * with the overmatching conditions, each vec_len Opt entry is\n+ * associated with a range of matches.\n+ * Consider the following:\n+ *\n+ *   match &[1, 2, 3] {\n+ *       [1, 1, .. _] => 0,\n+ *       [1, 2, 2, .. _] => 1,\n+ *       [1, 2, 3, .. _] => 2,\n+ *       [1, 2, .. _] => 3,\n+ *       _ => 4\n+ *   }\n+ * The proper arm to match is arm 2, but arms 0 and 3 both have the\n+ * condition \"len >= 2\". If arm 3 was lumped in with arm 0, then the\n+ * wrong branch would be taken. Instead, vec_len Opts are associated\n+ * with a contiguous range of matches that have the same \"shape\".\n+ * This is sort of ugly and requires a bunch of special handling of\n+ * vec_len options.\n+ *\n  */\n \n \n@@ -189,14 +234,19 @@ enum Lit {\n     ConstLit(ast::def_id),              // the def ID of the constant\n }\n \n+#[deriving(Eq)]\n+pub enum VecLenOpt {\n+    vec_len_eq,\n+    vec_len_ge(/* length of prefix */uint)\n+}\n+\n // An option identifying a branch (either a literal, a enum variant or a\n // range)\n enum Opt {\n     lit(Lit),\n     var(/* disr val */ uint, @adt::Repr),\n     range(@ast::expr, @ast::expr),\n-    vec_len_eq(uint),\n-    vec_len_ge(uint, /* slice */uint)\n+    vec_len(/* length */ uint, VecLenOpt, /*range of matches*/(uint, uint))\n }\n \n fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n@@ -247,9 +297,9 @@ fn opt_eq(tcx: ty::ctxt, a: &Opt, b: &Opt) -> bool {\n             }\n         }\n         (&var(a, _), &var(b, _)) => a == b,\n-            (&vec_len_eq(a), &vec_len_eq(b)) => a == b,\n-            (&vec_len_ge(a, _), &vec_len_ge(b, _)) => a == b,\n-            _ => false\n+        (&vec_len(a1, a2, _), &vec_len(b1, b2, _)) =>\n+            a1 == b1 && a2 == b2,\n+        _ => false\n     }\n }\n \n@@ -283,10 +333,10 @@ fn trans_opt(bcx: @mut Block, o: &Opt) -> opt_result {\n             return range_result(rslt(bcx, consts::const_expr(ccx, l1)),\n                                 rslt(bcx, consts::const_expr(ccx, l2)));\n         }\n-        vec_len_eq(n) => {\n+        vec_len(n, vec_len_eq, _) => {\n             return single_result(rslt(bcx, C_int(ccx, n as int)));\n         }\n-        vec_len_ge(n, _) => {\n+        vec_len(n, vec_len_ge(_), _) => {\n             return lower_bound(rslt(bcx, C_int(ccx, n as int)));\n         }\n     }\n@@ -471,10 +521,11 @@ fn enter_match<'r>(bcx: @mut Block,\n }\n \n fn enter_default<'r>(bcx: @mut Block,\n-                         dm: DefMap,\n-                         m: &[Match<'r>],\n-                         col: uint,\n-                         val: ValueRef)\n+                     dm: DefMap,\n+                     m: &[Match<'r>],\n+                     col: uint,\n+                     val: ValueRef,\n+                     chk: Option<mk_fail>)\n                       -> ~[Match<'r>] {\n     debug!(\"enter_default(bcx=%s, m=%s, col=%u, val=%s)\",\n            bcx.to_str(),\n@@ -483,13 +534,36 @@ fn enter_default<'r>(bcx: @mut Block,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n-    do enter_match(bcx, dm, m, col, val) |p| {\n+    // Collect all of the matches that can match against anything.\n+    let matches = do enter_match(bcx, dm, m, col, val) |p| {\n         match p.node {\n           ast::pat_wild | ast::pat_tup(_) => Some(~[]),\n           ast::pat_ident(_, _, None) if pat_is_binding(dm, p) => Some(~[]),\n           _ => None\n         }\n-    }\n+    };\n+\n+    // Ok, now, this is pretty subtle. A \"default\" match is a match\n+    // that needs to be considered if none of the actual checks on the\n+    // value being considered succeed. The subtlety lies in that sometimes\n+    // identifier/wildcard matches are *not* default matches. Consider:\n+    // \"match x { _ if something => foo, true => bar, false => baz }\".\n+    // There is a wildcard match, but it is *not* a default case. The boolean\n+    // case on the value being considered is exhaustive. If the case is\n+    // exhaustive, then there are no defaults.\n+    //\n+    // We detect whether the case is exhaustive in the following\n+    // somewhat kludgy way: if the last wildcard/binding match has a\n+    // guard, then by non-redundancy, we know that there aren't any\n+    // non guarded matches, and thus by exhaustiveness, we know that\n+    // we don't need any default cases. If the check *isn't* nonexhaustive\n+    // (because chk is Some), then we need the defaults anyways.\n+    let is_exhaustive = match matches.last_opt() {\n+        Some(m) if m.data.arm.guard.is_some() && chk.is_none() => true,\n+        _ => false\n+    };\n+\n+    if is_exhaustive { ~[] } else { matches }\n }\n \n // <pcwalton> nmatsakis: what does enter_opt do?\n@@ -523,17 +597,19 @@ fn enter_opt<'r>(bcx: @mut Block,\n                      variant_size: uint,\n                      val: ValueRef)\n                   -> ~[Match<'r>] {\n-    debug!(\"enter_opt(bcx=%s, m=%s, col=%u, val=%s)\",\n+    debug!(\"enter_opt(bcx=%s, m=%s, opt=%?, col=%u, val=%s)\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n+           *opt,\n            col,\n            bcx.val_to_str(val));\n     let _indenter = indenter();\n \n     let tcx = bcx.tcx();\n     let dummy = @ast::pat {id: 0, node: ast::pat_wild, span: dummy_sp()};\n+    let mut i = 0;\n     do enter_match(bcx, tcx.def_map, m, col, val) |p| {\n-        match p.node {\n+        let answer = match p.node {\n             ast::pat_enum(*) |\n             ast::pat_ident(_, _, None) if pat_is_const(tcx.def_map, p) => {\n                 let const_def = tcx.def_map.get_copy(&p.id);\n@@ -599,32 +675,53 @@ fn enter_opt<'r>(bcx: @mut Block,\n                 }\n             }\n             ast::pat_vec(ref before, slice, ref after) => {\n+                let (lo, hi) = match *opt {\n+                    vec_len(_, _, (lo, hi)) => (lo, hi),\n+                    _ => tcx.sess.span_bug(p.span,\n+                                           \"vec pattern but not vec opt\")\n+                };\n+\n                 match slice {\n-                    Some(slice) => {\n+                    Some(slice) if i >= lo && i <= hi => {\n                         let n = before.len() + after.len();\n-                        let i = before.len();\n-                        if opt_eq(tcx, &vec_len_ge(n, i), opt) {\n+                        let this_opt = vec_len(n, vec_len_ge(before.len()),\n+                                               (lo, hi));\n+                        if opt_eq(tcx, &this_opt, opt) {\n                             Some(vec::append_one((*before).clone(), slice) +\n                                     *after)\n                         } else {\n                             None\n                         }\n                     }\n-                    None => {\n+                    None if i >= lo && i <= hi => {\n                         let n = before.len();\n-                        if opt_eq(tcx, &vec_len_eq(n), opt) {\n+                        if opt_eq(tcx, &vec_len(n, vec_len_eq, (lo,hi)), opt) {\n                             Some((*before).clone())\n                         } else {\n                             None\n                         }\n                     }\n+                    _ => None\n                 }\n             }\n             _ => {\n                 assert_is_binding_or_wild(bcx, p);\n-                Some(vec::from_elem(variant_size, dummy))\n+                // In most cases, a binding/wildcard match be\n+                // considered to match against any Opt. However, when\n+                // doing vector pattern matching, submatches are\n+                // considered even if the eventual match might be from\n+                // a different submatch. Thus, when a submatch fails\n+                // when doing a vector match, we proceed to the next\n+                // submatch. Thus, including a default match would\n+                // cause the default match to fire spuriously.\n+                match *opt {\n+                    vec_len(*) => None,\n+                    _ => Some(vec::from_elem(variant_size, dummy))\n+                }\n             }\n-        }\n+        };\n+        i += 1;\n+        answer\n     }\n }\n \n@@ -805,9 +902,25 @@ fn get_options(bcx: @mut Block, m: &[Match], col: uint) -> ~[Opt] {\n         if set.iter().any(|l| opt_eq(tcx, l, &val)) {return;}\n         set.push(val);\n     }\n+    // Vector comparisions are special in that since the actual\n+    // conditions over-match, we need to be careful about them. This\n+    // means that in order to properly handle things in order, we need\n+    // to not always merge conditions.\n+    fn add_veclen_to_set(set: &mut ~[Opt], i: uint,\n+                         len: uint, vlo: VecLenOpt) {\n+        match set.last_opt() {\n+            // If the last condition in the list matches the one we want\n+            // to add, then extend its range. Otherwise, make a new\n+            // vec_len with a range just covering the new entry.\n+            Some(&vec_len(len2, vlo2, (start, end)))\n+                 if len == len2 && vlo == vlo2 =>\n+                 set[set.len() - 1] = vec_len(len, vlo, (start, end+1)),\n+            _ => set.push(vec_len(len, vlo, (i, i)))\n+        }\n+    }\n \n     let mut found = ~[];\n-    for br in m.iter() {\n+    for (i, br) in m.iter().enumerate() {\n         let cur = br.pats[col];\n         match cur.node {\n             ast::pat_lit(l) => {\n@@ -852,12 +965,12 @@ fn get_options(bcx: @mut Block, m: &[Match], col: uint) -> ~[Opt] {\n                 add_to_set(ccx.tcx, &mut found, range(l1, l2));\n             }\n             ast::pat_vec(ref before, slice, ref after) => {\n-                let opt = match slice {\n-                    None => vec_len_eq(before.len()),\n-                    Some(_) => vec_len_ge(before.len() + after.len(),\n-                                          before.len())\n+                let (len, vec_opt) = match slice {\n+                    None => (before.len(), vec_len_eq),\n+                    Some(_) => (before.len() + after.len(),\n+                                vec_len_ge(before.len()))\n                 };\n-                add_to_set(ccx.tcx, &mut found, opt);\n+                add_veclen_to_set(&mut found, i, len, vec_opt);\n             }\n             _ => {}\n         }\n@@ -1075,13 +1188,13 @@ fn pick_col(m: &[Match]) -> uint {\n     }\n     let mut scores = vec::from_elem(m[0].pats.len(), 0u);\n     for br in m.iter() {\n-        let mut i = 0u;\n-        for p in br.pats.iter() { scores[i] += score(*p); i += 1u; }\n+        for (i, p) in br.pats.iter().enumerate() {\n+            scores[i] += score(*p);\n+        }\n     }\n     let mut max_score = 0u;\n     let mut best_col = 0u;\n-    let mut i = 0u;\n-    for score in scores.iter() {\n+    for (i, score) in scores.iter().enumerate() {\n         let score = *score;\n \n         // Irrefutable columns always go first, they'd only be duplicated in\n@@ -1090,7 +1203,6 @@ fn pick_col(m: &[Match]) -> uint {\n         // If no irrefutable ones are found, we pick the one with the biggest\n         // branching factor.\n         if score > max_score { max_score = score; best_col = i; }\n-        i += 1u;\n     }\n     return best_col;\n }\n@@ -1460,7 +1572,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n                 test_val = Load(bcx, val);\n                 kind = compare;\n             },\n-            vec_len_eq(*) | vec_len_ge(*) => {\n+            vec_len(*) => {\n                 let vt = tvec::vec_types(bcx, node_id_type(bcx, pat_id));\n                 let unboxed = load_if_immediate(bcx, val, vt.vec_ty);\n                 let (_, len) = tvec::get_base_and_len(\n@@ -1487,16 +1599,19 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n         C_int(ccx, 0) // Placeholder for when not using a switch\n     };\n \n-    let defaults = enter_default(else_cx, dm, m, col, val);\n+    let defaults = enter_default(else_cx, dm, m, col, val, chk);\n     let exhaustive = chk.is_none() && defaults.len() == 0u;\n     let len = opts.len();\n-    let mut i = 0u;\n \n     // Compile subtrees for each option\n-    for opt in opts.iter() {\n-        i += 1u;\n+    for (i, opt) in opts.iter().enumerate() {\n+        // In some cases in vector pattern matching, we need to override\n+        // the failure case so that instead of failing, it proceeds to\n+        // try more matching. branch_chk, then, is the proper failure case\n+        // for the current conditional branch.\n+        let mut branch_chk = chk;\n         let mut opt_cx = else_cx;\n-        if !exhaustive || i < len {\n+        if !exhaustive || i+1 < len {\n             opt_cx = sub_block(bcx, \"match_case\");\n             match kind {\n               single => Br(bcx, opt_cx.llbb),\n@@ -1586,6 +1701,10 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n                       }\n                   };\n                   bcx = sub_block(after_cx, \"compare_vec_len_next\");\n+\n+                  // If none of these subcases match, move on to the\n+                  // next condition.\n+                  branch_chk = Some::<mk_fail>(|| bcx.llbb);\n                   CondBr(after_cx, matches, opt_cx.llbb, bcx.llbb);\n               }\n               _ => ()\n@@ -1604,17 +1723,13 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n                 unpacked = argvals;\n                 opt_cx = new_bcx;\n             }\n-            vec_len_eq(n) | vec_len_ge(n, _) => {\n-                let n = match *opt {\n-                    vec_len_ge(*) => n + 1u,\n-                    _ => n\n-                };\n-                let slice = match *opt {\n-                    vec_len_ge(_, i) => Some(i),\n-                    _ => None\n+            vec_len(n, vt, _) => {\n+                let (n, slice) = match vt {\n+                    vec_len_ge(i) => (n + 1u, Some(i)),\n+                    vec_len_eq => (n, None)\n                 };\n-                let args = extract_vec_elems(opt_cx, pat_span, pat_id, n, slice,\n-                                             val, test_val);\n+                let args = extract_vec_elems(opt_cx, pat_span, pat_id, n,\n+                                             slice, val, test_val);\n                 size = args.vals.len();\n                 unpacked = args.vals.clone();\n                 opt_cx = args.bcx;\n@@ -1623,7 +1738,7 @@ fn compile_submatch_continue(mut bcx: @mut Block,\n         }\n         let opt_ms = enter_opt(opt_cx, m, opt, col, size, val);\n         let opt_vals = vec::append(unpacked, vals_left);\n-        compile_submatch(opt_cx, opt_ms, opt_vals, chk);\n+        compile_submatch(opt_cx, opt_ms, opt_vals, branch_chk);\n     }\n \n     // Compile the fall-through case, if any"}, {"sha": "206dc383cb3d50cd488db1203b6645d33f99771e", "filename": "src/test/run-pass/issue-3121.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/20953bb1fbfafc3839e739f38ddf7d495eb1fe8b/src%2Ftest%2Frun-pass%2Fissue-3121.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20953bb1fbfafc3839e739f38ddf7d495eb1fe8b/src%2Ftest%2Frun-pass%2Fissue-3121.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3121.rs?ref=20953bb1fbfafc3839e739f38ddf7d495eb1fe8b", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// xfail-test\n enum side { mayo, catsup, vinegar }\n enum order { hamburger, fries(side), shake }\n enum meal { to_go(order), for_here(order) }"}, {"sha": "13a8e324d43062adf5efff02efbba031ff772b86", "filename": "src/test/run-pass/vec-matching-autoslice.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/20953bb1fbfafc3839e739f38ddf7d495eb1fe8b/src%2Ftest%2Frun-pass%2Fvec-matching-autoslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20953bb1fbfafc3839e739f38ddf7d495eb1fe8b/src%2Ftest%2Frun-pass%2Fvec-matching-autoslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching-autoslice.rs?ref=20953bb1fbfafc3839e739f38ddf7d495eb1fe8b", "patch": "@@ -1,22 +1,22 @@\n pub fn main() {\n     let x = @[1, 2, 3];\n     match x {\n-        [2, .._] => ::std::util::unreachable(),\n+        [2, .._] => fail!(),\n         [1, ..tail] => {\n             assert_eq!(tail, [2, 3]);\n         }\n-        [_] => ::std::util::unreachable(),\n-        [] => ::std::util::unreachable()\n+        [_] => fail!(),\n+        [] => fail!()\n     }\n \n     let y = (~[(1, true), (2, false)], 0.5);\n     match y {\n-        ([_, _, _], 0.5) => ::std::util::unreachable(),\n+        ([_, _, _], 0.5) => fail!(),\n         ([(1, a), (b, false), ..tail], _) => {\n             assert_eq!(a, true);\n             assert_eq!(b, 2);\n             assert!(tail.is_empty());\n         }\n-        ([..tail], _) => ::std::util::unreachable()\n+        ([..tail], _) => fail!()\n     }\n }"}, {"sha": "c09fb8d6bc7ef896ab44ad695bbc52f1dac7182a", "filename": "src/test/run-pass/vec-matching.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/20953bb1fbfafc3839e739f38ddf7d495eb1fe8b/src%2Ftest%2Frun-pass%2Fvec-matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20953bb1fbfafc3839e739f38ddf7d495eb1fe8b/src%2Ftest%2Frun-pass%2Fvec-matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-matching.rs?ref=20953bb1fbfafc3839e739f38ddf7d495eb1fe8b", "patch": "@@ -1,14 +1,14 @@\n fn a() {\n     let x = ~[1];\n     match x {\n-        [_, _, _, _, _, .._] => ::std::util::unreachable(),\n-        [.._, _, _, _, _] => ::std::util::unreachable(),\n-        [_, .._, _, _] => ::std::util::unreachable(),\n-        [_, _] => ::std::util::unreachable(),\n+        [_, _, _, _, _, .._] => fail!(),\n+        [.._, _, _, _, _] => fail!(),\n+        [_, .._, _, _] => fail!(),\n+        [_, _] => fail!(),\n         [a] => {\n             assert_eq!(a, 1);\n         }\n-        [] => ::std::util::unreachable()\n+        [] => fail!()\n     }\n }\n \n@@ -48,7 +48,28 @@ fn b() {\n     }\n }\n \n+fn c() {\n+    let x = [1];\n+    match x {\n+        [2, .. _] => fail!(),\n+        [.. _] => ()\n+    }\n+}\n+\n+fn d() {\n+    let x = [1, 2, 3];\n+    let branch = match x {\n+        [1, 1, .. _] => 0,\n+        [1, 2, 3, .. _] => 1,\n+        [1, 2, .. _] => 2,\n+        _ => 3\n+    };\n+    assert_eq!(branch, 1);\n+}\n+\n pub fn main() {\n     a();\n     b();\n+    c();\n+    d();\n }"}]}