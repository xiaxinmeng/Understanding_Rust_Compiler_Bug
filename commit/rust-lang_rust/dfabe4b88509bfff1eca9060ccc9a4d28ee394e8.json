{"sha": "dfabe4b88509bfff1eca9060ccc9a4d28ee394e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRmYWJlNGI4ODUwOWJmZmYxZWNhOTA2MGNjYzlhNGQyOGVlMzk0ZTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-14T09:47:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-14T09:47:21Z"}, "message": "Auto merge of #54032 - oli-obk:layout_scalar_ranges, r=eddyb\n\nAdd forever unstable attribute to allow specifying arbitrary scalar ranges\n\nr? @eddyb for the first commit and @nikomatsakis for the second one", "tree": {"sha": "7f637c2857e19dfbcc17254c011e644de2306e65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f637c2857e19dfbcc17254c011e644de2306e65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8", "html_url": "https://github.com/rust-lang/rust/commit/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fccde0018a618eb6f45d2a3c97f629809994dff6", "url": "https://api.github.com/repos/rust-lang/rust/commits/fccde0018a618eb6f45d2a3c97f629809994dff6", "html_url": "https://github.com/rust-lang/rust/commit/fccde0018a618eb6f45d2a3c97f629809994dff6"}, {"sha": "a94c16614c3a43d609a437afa92ef5ae7d3965ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/a94c16614c3a43d609a437afa92ef5ae7d3965ea", "html_url": "https://github.com/rust-lang/rust/commit/a94c16614c3a43d609a437afa92ef5ae7d3965ea"}], "stats": {"total": 440, "additions": 279, "deletions": 161}, "files": [{"sha": "30067d7e163d21bf43e1f9ab466109c48a553efb", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=dfabe4b88509bfff1eca9060ccc9a4d28ee394e8", "patch": "@@ -14,7 +14,8 @@ use ops::CoerceUnsized;\n \n /// A wrapper type for raw pointers and integers that will never be\n /// NULL or 0 that might allow certain optimizations.\n-#[lang = \"non_zero\"]\n+#[cfg_attr(stage0, lang = \"non_zero\")]\n+#[cfg_attr(not(stage0), rustc_layout_scalar_valid_range_start(1))]\n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Hash)]\n #[repr(transparent)]\n pub(crate) struct NonZero<T>(pub(crate) T);"}, {"sha": "cd91b85689b30efede4c8b2efd738877960098d3", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 70, "deletions": 15, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=dfabe4b88509bfff1eca9060ccc9a4d28ee394e8", "patch": "@@ -16,25 +16,53 @@ use std::fmt;\n use std::u32;\n \n newtype_index! {\n-    pub struct CrateNum {\n+    pub struct CrateId {\n         ENCODABLE = custom\n-        DEBUG_FORMAT = \"crate{}\",\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum CrateNum {\n+    /// Virtual crate for builtin macros\n+    // FIXME(jseyfried): this is also used for custom derives until proc-macro crates get\n+    // `CrateNum`s.\n+    BuiltinMacros,\n+    /// A CrateNum value that indicates that something is wrong.\n+    Invalid,\n+    /// A special CrateNum that we use for the tcx.rcache when decoding from\n+    /// the incr. comp. cache.\n+    ReservedForIncrCompCache,\n+    Index(CrateId),\n+}\n+\n+impl ::std::fmt::Debug for CrateNum {\n+    fn fmt(&self, fmt: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n+        match self {\n+            CrateNum::Index(id) => write!(fmt, \"crate{}\", id.private),\n+            CrateNum::Invalid => write!(fmt, \"invalid crate\"),\n+            CrateNum::BuiltinMacros => write!(fmt, \"bultin macros crate\"),\n+            CrateNum::ReservedForIncrCompCache => write!(fmt, \"crate for decoding incr comp cache\"),\n+        }\n+    }\n+}\n \n-        /// Item definitions in the currently-compiled crate would have the CrateNum\n-        /// LOCAL_CRATE in their DefId.\n-        const LOCAL_CRATE = 0,\n+/// Item definitions in the currently-compiled crate would have the CrateNum\n+/// LOCAL_CRATE in their DefId.\n+pub const LOCAL_CRATE: CrateNum = CrateNum::Index(CrateId::from_u32_const(0));\n \n-        /// Virtual crate for builtin macros\n-        // FIXME(jseyfried): this is also used for custom derives until proc-macro crates get\n-        // `CrateNum`s.\n-        const BUILTIN_MACROS_CRATE = CrateNum::MAX_AS_U32,\n \n-        /// A CrateNum value that indicates that something is wrong.\n-        const INVALID_CRATE = CrateNum::MAX_AS_U32 - 1,\n+impl Idx for CrateNum {\n+    #[inline]\n+    fn new(value: usize) -> Self {\n+        CrateNum::Index(Idx::new(value))\n+    }\n \n-        /// A special CrateNum that we use for the tcx.rcache when decoding from\n-        /// the incr. comp. cache.\n-        const RESERVED_FOR_INCR_COMP_CACHE = CrateNum::MAX_AS_U32 - 2,\n+    #[inline]\n+    fn index(self) -> usize {\n+        match self {\n+            CrateNum::Index(idx) => Idx::index(idx),\n+            _ => bug!(\"Tried to get crate index of {:?}\", self),\n+        }\n     }\n }\n \n@@ -43,12 +71,39 @@ impl CrateNum {\n         CrateNum::from_usize(x)\n     }\n \n+    pub fn from_usize(x: usize) -> CrateNum {\n+        CrateNum::Index(CrateId::from_usize(x))\n+    }\n+\n+    pub fn from_u32(x: u32) -> CrateNum {\n+        CrateNum::Index(CrateId::from_u32(x))\n+    }\n+\n+    pub fn as_usize(self) -> usize {\n+        match self {\n+            CrateNum::Index(id) => id.as_usize(),\n+            _ => bug!(\"tried to get index of nonstandard crate {:?}\", self),\n+        }\n+    }\n+\n+    pub fn as_u32(self) -> u32 {\n+        match self {\n+            CrateNum::Index(id) => id.as_u32(),\n+            _ => bug!(\"tried to get index of nonstandard crate {:?}\", self),\n+        }\n+    }\n+\n     pub fn as_def_id(&self) -> DefId { DefId { krate: *self, index: CRATE_DEF_INDEX } }\n }\n \n impl fmt::Display for CrateNum {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Display::fmt(&self.as_u32(), f)\n+        match self {\n+            CrateNum::Index(id) => fmt::Display::fmt(&id.private, f),\n+            CrateNum::Invalid => write!(f, \"invalid crate\"),\n+            CrateNum::BuiltinMacros => write!(f, \"bultin macros crate\"),\n+            CrateNum::ReservedForIncrCompCache => write!(f, \"crate for decoding incr comp cache\"),\n+        }\n     }\n }\n "}, {"sha": "2bf1c79c8a43606dc5e0c120d359da8252e8f13c", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=dfabe4b88509bfff1eca9060ccc9a4d28ee394e8", "patch": "@@ -772,7 +772,15 @@ impl_stable_hash_for!(enum ty::cast::CastKind {\n     FnPtrAddrCast\n });\n \n-impl_stable_hash_for!(struct ::middle::region::Scope { id, code });\n+impl_stable_hash_for!(struct ::middle::region::Scope { id, data });\n+\n+impl_stable_hash_for!(enum ::middle::region::ScopeData {\n+    Node,\n+    CallSite,\n+    Arguments,\n+    Destruction,\n+    Remainder(first_statement_index)\n+});\n \n impl<'a> ToStableHashKey<StableHashingContext<'a>> for region::Scope {\n     type KeyType = region::Scope;\n@@ -783,11 +791,6 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for region::Scope {\n     }\n }\n \n-impl_stable_hash_for!(struct ::middle::region::BlockRemainder {\n-    block,\n-    first_statement_index\n-});\n-\n impl_stable_hash_for!(struct ty::adjustment::CoerceUnsizedInfo {\n     custom_kind\n });"}, {"sha": "a0c96554c91f1d4046d0ac1206eaaca6f6852ad8", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=dfabe4b88509bfff1eca9060ccc9a4d28ee394e8", "patch": "@@ -119,17 +119,17 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 };\n                 let scope_decorated_tag = match scope.data() {\n-                    region::ScopeData::Node(_) => tag,\n-                    region::ScopeData::CallSite(_) => \"scope of call-site for function\",\n-                    region::ScopeData::Arguments(_) => \"scope of function body\",\n-                    region::ScopeData::Destruction(_) => {\n+                    region::ScopeData::Node => tag,\n+                    region::ScopeData::CallSite => \"scope of call-site for function\",\n+                    region::ScopeData::Arguments => \"scope of function body\",\n+                    region::ScopeData::Destruction => {\n                         new_string = format!(\"destruction scope surrounding {}\", tag);\n                         &new_string[..]\n                     }\n-                    region::ScopeData::Remainder(r) => {\n+                    region::ScopeData::Remainder(first_statement_index) => {\n                         new_string = format!(\n                             \"block suffix following statement {}\",\n-                            r.first_statement_index.index()\n+                            first_statement_index.index()\n                         );\n                         &new_string[..]\n                     }"}, {"sha": "c017c90b8955043ad0ab52fc285e09c98a57b0b7", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=dfabe4b88509bfff1eca9060ccc9a4d28ee394e8", "patch": "@@ -58,6 +58,8 @@\n #![feature(optin_builtin_traits)]\n #![feature(refcell_replace_swap)]\n #![feature(rustc_diagnostic_macros)]\n+#![feature(rustc_attrs)]\n+#![cfg_attr(stage0, feature(attr_literals))]\n #![feature(slice_patterns)]\n #![feature(slice_sort_by_cached_key)]\n #![feature(specialization)]"}, {"sha": "bfde4e4a3aed8abb8d94d85aa8381f15908f1633", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=dfabe4b88509bfff1eca9060ccc9a4d28ee394e8", "patch": "@@ -326,8 +326,6 @@ language_item_table! {\n \n     PhantomDataItem,                 \"phantom_data\",            phantom_data;\n \n-    NonZeroItem,                     \"non_zero\",                non_zero;\n-\n     ManuallyDropItem,                \"manually_drop\",           manually_drop;\n \n     DebugTraitLangItem,              \"debug_trait\",             debug_trait;"}, {"sha": "2f99743cfbdca0346b1334d749a30cf319a23a27", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 55, "deletions": 73, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=dfabe4b88509bfff1eca9060ccc9a4d28ee394e8", "patch": "@@ -20,8 +20,8 @@ use ich::{StableHashingContext, NodeIdHashingMode};\n use util::nodemap::{FxHashMap, FxHashSet};\n use ty;\n \n-use std::fmt;\n use std::mem;\n+use std::fmt;\n use rustc_data_structures::sync::Lrc;\n use syntax::source_map;\n use syntax::ast;\n@@ -51,7 +51,7 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n /// `DestructionScope`, but those that are `terminating_scopes` do;\n /// see discussion with `ScopeTree`.\n ///\n-/// `Remainder(BlockRemainder { block, statement_index })` represents\n+/// `Remainder { block, statement_index }` represents\n /// the scope of user code running immediately after the initializer\n /// expression for the indexed statement, until the end of the block.\n ///\n@@ -100,39 +100,46 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n /// placate the same deriving in `ty::FreeRegion`, but we may want to\n /// actually attach a more meaningful ordering to scopes than the one\n /// generated via deriving here.\n-///\n-/// Scope is a bit-packed to save space - if `code` is SCOPE_DATA_REMAINDER_MAX\n-/// or less, it is a `ScopeData::Remainder`, otherwise it is a type specified\n-/// by the bitpacking.\n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Copy, RustcEncodable, RustcDecodable)]\n pub struct Scope {\n     pub(crate) id: hir::ItemLocalId,\n-    pub(crate) code: u32\n+    pub(crate) data: ScopeData,\n }\n \n-const SCOPE_DATA_NODE: u32 = !0;\n-const SCOPE_DATA_CALLSITE: u32 = !1;\n-const SCOPE_DATA_ARGUMENTS: u32 = !2;\n-const SCOPE_DATA_DESTRUCTION: u32 = !3;\n-const SCOPE_DATA_REMAINDER_MAX: u32 = !4;\n+impl fmt::Debug for Scope {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        match self.data {\n+            ScopeData::Node => write!(fmt, \"Node({:?})\", self.id),\n+            ScopeData::CallSite => write!(fmt, \"CallSite({:?})\", self.id),\n+            ScopeData::Arguments => write!(fmt, \"Arguments({:?})\", self.id),\n+            ScopeData::Destruction => write!(fmt, \"Destruction({:?})\", self.id),\n+            ScopeData::Remainder(fsi) => write!(\n+                fmt,\n+                \"Remainder {{ block: {:?}, first_statement_index: {}}}\",\n+                self.id,\n+                fsi.as_u32(),\n+            ),\n+        }\n+    }\n+}\n \n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, Debug, Copy, RustcEncodable, RustcDecodable)]\n pub enum ScopeData {\n-    Node(hir::ItemLocalId),\n+    Node,\n \n     // Scope of the call-site for a function or closure\n     // (outlives the arguments as well as the body).\n-    CallSite(hir::ItemLocalId),\n+    CallSite,\n \n     // Scope of arguments passed to a function or closure\n     // (they outlive its body).\n-    Arguments(hir::ItemLocalId),\n+    Arguments,\n \n     // Scope of destructors for temporaries of node-id.\n-    Destruction(hir::ItemLocalId),\n+    Destruction,\n \n     // Scope following a `let id = expr;` binding in a block.\n-    Remainder(BlockRemainder)\n+    Remainder(FirstStatementIndex)\n }\n \n /// Represents a subscope of `block` for a binding that is introduced\n@@ -152,83 +159,61 @@ pub enum ScopeData {\n ///\n /// * the subscope with `first_statement_index == 1` is scope of `c`,\n ///   and thus does not include EXPR_2, but covers the `...`.\n-#[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n-         RustcDecodable, Debug, Copy)]\n-pub struct BlockRemainder {\n-    pub block: hir::ItemLocalId,\n-    pub first_statement_index: FirstStatementIndex,\n-}\n \n newtype_index! {\n-    pub struct FirstStatementIndex {\n-        MAX = SCOPE_DATA_REMAINDER_MAX\n-    }\n+    pub struct FirstStatementIndex { .. }\n }\n \n impl_stable_hash_for!(struct ::middle::region::FirstStatementIndex { private });\n \n-impl From<ScopeData> for Scope {\n-    #[inline]\n-    fn from(scope_data: ScopeData) -> Self {\n-        let (id, code) = match scope_data {\n-            ScopeData::Node(id) => (id, SCOPE_DATA_NODE),\n-            ScopeData::CallSite(id) => (id, SCOPE_DATA_CALLSITE),\n-            ScopeData::Arguments(id) => (id, SCOPE_DATA_ARGUMENTS),\n-            ScopeData::Destruction(id) => (id, SCOPE_DATA_DESTRUCTION),\n-            ScopeData::Remainder(r) => (r.block, r.first_statement_index.index() as u32)\n-        };\n-        Self { id, code }\n-    }\n-}\n-\n-impl fmt::Debug for Scope {\n-    fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Debug::fmt(&self.data(), formatter)\n-    }\n-}\n+// compilation error if size of `ScopeData` is not the same as a `u32`\n+#[allow(dead_code)]\n+// only works on stage 1 when the rustc_layout_scalar_valid_range attribute actually exists\n+#[cfg(not(stage0))]\n+static ASSERT: () = [()][!(mem::size_of::<ScopeData>() == 4) as usize];\n \n #[allow(non_snake_case)]\n impl Scope {\n     #[inline]\n     pub fn data(self) -> ScopeData {\n-        match self.code {\n-            SCOPE_DATA_NODE => ScopeData::Node(self.id),\n-            SCOPE_DATA_CALLSITE => ScopeData::CallSite(self.id),\n-            SCOPE_DATA_ARGUMENTS => ScopeData::Arguments(self.id),\n-            SCOPE_DATA_DESTRUCTION => ScopeData::Destruction(self.id),\n-            idx => ScopeData::Remainder(BlockRemainder {\n-                block: self.id,\n-                first_statement_index: FirstStatementIndex::new(idx as usize)\n-            })\n-        }\n+        self.data\n+    }\n+\n+    #[inline]\n+    pub fn new(id: hir::ItemLocalId, data: ScopeData) -> Self {\n+        Scope { id, data }\n     }\n \n     #[inline]\n     pub fn Node(id: hir::ItemLocalId) -> Self {\n-        Self::from(ScopeData::Node(id))\n+        Self::new(id, ScopeData::Node)\n     }\n \n     #[inline]\n     pub fn CallSite(id: hir::ItemLocalId) -> Self {\n-        Self::from(ScopeData::CallSite(id))\n+        Self::new(id, ScopeData::CallSite)\n     }\n \n     #[inline]\n     pub fn Arguments(id: hir::ItemLocalId) -> Self {\n-        Self::from(ScopeData::Arguments(id))\n+        Self::new(id, ScopeData::Arguments)\n     }\n \n     #[inline]\n     pub fn Destruction(id: hir::ItemLocalId) -> Self {\n-        Self::from(ScopeData::Destruction(id))\n+        Self::new(id, ScopeData::Destruction)\n     }\n \n     #[inline]\n-    pub fn Remainder(r: BlockRemainder) -> Self {\n-        Self::from(ScopeData::Remainder(r))\n+    pub fn Remainder(\n+        id: hir::ItemLocalId,\n+        first: FirstStatementIndex,\n+    ) -> Self {\n+        Self::new(id, ScopeData::Remainder(first))\n     }\n }\n \n+\n impl Scope {\n     /// Returns a item-local id associated with this scope.\n     ///\n@@ -259,7 +244,7 @@ impl Scope {\n             return DUMMY_SP;\n         }\n         let span = tcx.hir.span(node_id);\n-        if let ScopeData::Remainder(r) = self.data() {\n+        if let ScopeData::Remainder(first_statement_index) = self.data() {\n             if let Node::Block(ref blk) = tcx.hir.get(node_id) {\n                 // Want span for scope starting after the\n                 // indexed statement and ending at end of\n@@ -269,7 +254,7 @@ impl Scope {\n                 // (This is the special case aluded to in the\n                 // doc-comment for this method)\n \n-                let stmt_span = blk.stmts[r.first_statement_index.index()].span;\n+                let stmt_span = blk.stmts[first_statement_index.index()].span;\n \n                 // To avoid issues with macro-generated spans, the span\n                 // of the statement must be nested in that of the block.\n@@ -513,8 +498,8 @@ impl<'tcx> ScopeTree {\n         }\n \n         // record the destruction scopes for later so we can query them\n-        if let ScopeData::Destruction(n) = child.data() {\n-            self.destruction_scopes.insert(n, child);\n+        if let ScopeData::Destruction = child.data() {\n+            self.destruction_scopes.insert(child.item_local_id(), child);\n         }\n     }\n \n@@ -597,7 +582,7 @@ impl<'tcx> ScopeTree {\n \n         while let Some(&(p, _)) = self.parent_map.get(&id) {\n             match p.data() {\n-                ScopeData::Destruction(..) => {\n+                ScopeData::Destruction => {\n                     debug!(\"temporary_scope({:?}) = {:?} [enclosing]\",\n                            expr_id, id);\n                     return Some(id);\n@@ -652,8 +637,8 @@ impl<'tcx> ScopeTree {\n     /// Returns the id of the innermost containing body\n     pub fn containing_body(&self, mut scope: Scope)-> Option<hir::ItemLocalId> {\n         loop {\n-            if let ScopeData::CallSite(id) = scope.data() {\n-                return Some(id);\n+            if let ScopeData::CallSite = scope.data() {\n+                return Some(scope.item_local_id());\n             }\n \n             match self.opt_encl_scope(scope) {\n@@ -869,10 +854,7 @@ fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, blk:\n                 // except for the first such subscope, which has the\n                 // block itself as a parent.\n                 visitor.enter_scope(\n-                    Scope::Remainder(BlockRemainder {\n-                        block: blk.hir_id.local_id,\n-                        first_statement_index: FirstStatementIndex::new(i)\n-                    })\n+                    Scope::Remainder(blk.hir_id.local_id, FirstStatementIndex::new(i))\n                 );\n                 visitor.cx.var_parent = visitor.cx.parent;\n             }\n@@ -1035,7 +1017,7 @@ fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>, expr:\n             match visitor.scope_tree.parent_map.get(&scope) {\n                 // Don't cross from closure bodies to their parent.\n                 Some(&(superscope, _)) => match superscope.data() {\n-                    ScopeData::CallSite(_) => break,\n+                    ScopeData::CallSite => break,\n                     _ => scope = superscope\n                 },\n                 None => break"}, {"sha": "d1f37250379723e85d380e6e420c268d64962a95", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=dfabe4b88509bfff1eca9060ccc9a4d28ee394e8", "patch": "@@ -66,7 +66,7 @@ use std::collections::hash_map::{self, Entry};\n use std::hash::{Hash, Hasher};\n use std::fmt;\n use std::mem;\n-use std::ops::Deref;\n+use std::ops::{Deref, Bound};\n use std::iter;\n use std::sync::mpsc;\n use std::sync::Arc;\n@@ -829,10 +829,12 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n impl<'tcx> CommonTypes<'tcx> {\n     fn new(interners: &CtxtInterners<'tcx>) -> CommonTypes<'tcx> {\n         // Ensure our type representation does not grow\n-        #[cfg(target_pointer_width = \"64\")]\n-        assert!(mem::size_of::<ty::TyKind>() <= 24);\n-        #[cfg(target_pointer_width = \"64\")]\n-        assert!(mem::size_of::<ty::TyS>() <= 32);\n+        #[cfg(all(not(stage0), target_pointer_width = \"64\"))]\n+        #[allow(dead_code)]\n+        static ASSERT_TY_KIND: () = [()][!(::std::mem::size_of::<ty::TyKind>() <= 24) as usize];\n+        #[cfg(all(not(stage0), target_pointer_width = \"64\"))]\n+        #[allow(dead_code)]\n+        static ASSERT_TYS: () = [()][!(::std::mem::size_of::<ty::TyS>() <= 32) as usize];\n \n         let mk = |sty| CtxtInterners::intern_ty(interners, interners, sty);\n         let mk_region = |r| {\n@@ -1083,6 +1085,26 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         interned\n     }\n \n+    /// Returns a range of the start/end indices specified with the\n+    /// `rustc_layout_scalar_valid_range` attribute.\n+    pub fn layout_scalar_valid_range(self, def_id: DefId) -> (Bound<u128>, Bound<u128>) {\n+        let attrs = self.get_attrs(def_id);\n+        let get = |name| {\n+            let attr = match attrs.iter().find(|a| a.check_name(name)) {\n+                Some(attr) => attr,\n+                None => return Bound::Unbounded,\n+            };\n+            for meta in attr.meta_item_list().expect(\"rustc_layout_scalar_valid_range takes args\") {\n+                match meta.literal().expect(\"attribute takes lit\").node {\n+                    ast::LitKind::Int(a, _) => return Bound::Included(a),\n+                    _ => span_bug!(attr.span, \"rustc_layout_scalar_valid_range expects int arg\"),\n+                }\n+            }\n+            span_bug!(attr.span, \"no arguments to `rustc_layout_scalar_valid_range` attribute\");\n+        };\n+        (get(\"rustc_layout_scalar_valid_range_start\"), get(\"rustc_layout_scalar_valid_range_end\"))\n+    }\n+\n     pub fn lift<T: ?Sized + Lift<'tcx>>(self, value: &T) -> Option<T::Lifted> {\n         value.lift_to_tcx(self)\n     }"}, {"sha": "4e37a34a0c8a7f9af70d13a8f8d1cd8a790a3003", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=dfabe4b88509bfff1eca9060ccc9a4d28ee394e8", "patch": "@@ -20,6 +20,7 @@ use std::fmt;\n use std::i128;\n use std::iter;\n use std::mem;\n+use std::ops::Bound;\n \n use ich::StableHashingContext;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n@@ -761,17 +762,29 @@ impl<'a, 'tcx> LayoutCx<'tcx, TyCtxt<'a, 'tcx, 'tcx>> {\n \n                     let mut st = univariant_uninterned(&variants[v], &def.repr, kind)?;\n                     st.variants = Variants::Single { index: v };\n-                    // Exclude 0 from the range of a newtype ABI NonZero<T>.\n-                    if Some(def.did) == self.tcx.lang_items().non_zero() {\n-                        match st.abi {\n-                            Abi::Scalar(ref mut scalar) |\n-                            Abi::ScalarPair(ref mut scalar, _) => {\n-                                if *scalar.valid_range.start() == 0 {\n-                                    scalar.valid_range = 1..=*scalar.valid_range.end();\n-                                }\n+                    let (start, end) = self.tcx.layout_scalar_valid_range(def.did);\n+                    match st.abi {\n+                        Abi::Scalar(ref mut scalar) |\n+                        Abi::ScalarPair(ref mut scalar, _) => {\n+                            // the asserts ensure that we are not using the\n+                            // `#[rustc_layout_scalar_valid_range(n)]`\n+                            // attribute to widen the range of anything as that would probably\n+                            // result in UB somewhere\n+                            if let Bound::Included(start) = start {\n+                                assert!(*scalar.valid_range.start() <= start);\n+                                scalar.valid_range = start..=*scalar.valid_range.end();\n+                            }\n+                            if let Bound::Included(end) = end {\n+                                assert!(*scalar.valid_range.end() >= end);\n+                                scalar.valid_range = *scalar.valid_range.start()..=end;\n                             }\n-                            _ => {}\n                         }\n+                        _ => assert!(\n+                            start == Bound::Unbounded && end == Bound::Unbounded,\n+                            \"nonscalar layout for layout_scalar_valid_range type {:?}: {:#?}\",\n+                            def,\n+                            st,\n+                        ),\n                     }\n                     return Ok(tcx.intern_layout(st));\n                 }\n@@ -1350,8 +1363,12 @@ impl<'a, 'tcx> SizeSkeleton<'tcx> {\n                 if def.variants.len() == 1 {\n                     if let Some(SizeSkeleton::Pointer { non_zero, tail }) = v0 {\n                         return Ok(SizeSkeleton::Pointer {\n-                            non_zero: non_zero ||\n-                                Some(def.did) == tcx.lang_items().non_zero(),\n+                            non_zero: non_zero || match tcx.layout_scalar_valid_range(def.did) {\n+                                (Bound::Included(start), Bound::Unbounded) => start > 0,\n+                                (Bound::Included(start), Bound::Included(end)) =>\n+                                    0 < start && start < end,\n+                                _ => false,\n+                            },\n                             tail,\n                         });\n                     } else {"}, {"sha": "0e4d2f1f64730c940c91846871eef34fc9b642bb", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=dfabe4b88509bfff1eca9060ccc9a4d28ee394e8", "patch": "@@ -11,8 +11,7 @@\n use dep_graph::{DepNodeIndex, SerializedDepNodeIndex};\n use errors::Diagnostic;\n use hir;\n-use hir::def_id::{CrateNum, DefIndex, DefId, LocalDefId,\n-                  RESERVED_FOR_INCR_COMP_CACHE, LOCAL_CRATE};\n+use hir::def_id::{CrateNum, DefIndex, DefId, LocalDefId, LOCAL_CRATE};\n use hir::map::definitions::DefPathHash;\n use ich::{CachingSourceMapView, Fingerprint};\n use mir::{self, interpret};\n@@ -566,7 +565,7 @@ impl<'a, 'tcx: 'a, 'x> ty_codec::TyDecoder<'a, 'tcx> for CacheDecoder<'a, 'tcx,\n         let tcx = self.tcx();\n \n         let cache_key = ty::CReaderCacheKey {\n-            cnum: RESERVED_FOR_INCR_COMP_CACHE,\n+            cnum: CrateNum::ReservedForIncrCompCache,\n             pos: shorthand,\n         };\n "}, {"sha": "5ffb77dda688a923c03a22e85a5e084089bf9a5a", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=dfabe4b88509bfff1eca9060ccc9a4d28ee394e8", "patch": "@@ -11,7 +11,7 @@\n use hir::def_id::DefId;\n use hir::map::definitions::DefPathData;\n use mir::interpret::ConstValue;\n-use middle::region::{self, BlockRemainder};\n+use middle::region;\n use ty::subst::{self, Subst};\n use ty::{BrAnon, BrEnv, BrFresh, BrNamed};\n use ty::{Bool, Char, Adt};\n@@ -770,17 +770,20 @@ define_print! {\n                 }\n                 ty::ReScope(scope) if cx.identify_regions => {\n                     match scope.data() {\n-                        region::ScopeData::Node(id) =>\n-                            write!(f, \"'{}s\", id.as_usize()),\n-                        region::ScopeData::CallSite(id) =>\n-                            write!(f, \"'{}cs\", id.as_usize()),\n-                        region::ScopeData::Arguments(id) =>\n-                            write!(f, \"'{}as\", id.as_usize()),\n-                        region::ScopeData::Destruction(id) =>\n-                            write!(f, \"'{}ds\", id.as_usize()),\n-                        region::ScopeData::Remainder(BlockRemainder\n-                                                     { block, first_statement_index }) =>\n-                            write!(f, \"'{}_{}rs\", block.as_usize(), first_statement_index.index()),\n+                        region::ScopeData::Node =>\n+                            write!(f, \"'{}s\", scope.item_local_id().as_usize()),\n+                        region::ScopeData::CallSite =>\n+                            write!(f, \"'{}cs\", scope.item_local_id().as_usize()),\n+                        region::ScopeData::Arguments =>\n+                            write!(f, \"'{}as\", scope.item_local_id().as_usize()),\n+                        region::ScopeData::Destruction =>\n+                            write!(f, \"'{}ds\", scope.item_local_id().as_usize()),\n+                        region::ScopeData::Remainder(first_statement_index) => write!(\n+                            f,\n+                            \"'{}_{}rs\",\n+                            scope.item_local_id().as_usize(),\n+                            first_statement_index.index()\n+                        ),\n                     }\n                 }\n                 ty::ReVar(region_vid) if cx.identify_regions => {"}, {"sha": "2f11fea46d69a6c6db09c10ea0a5c0d32e4a6546", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=dfabe4b88509bfff1eca9060ccc9a4d28ee394e8", "patch": "@@ -72,7 +72,8 @@ macro_rules! newtype_index {\n         newtype_index!(\n             // Leave out derives marker so we can use its absence to ensure it comes first\n             @type         [$name]\n-            @max          [::std::u32::MAX - 1]\n+            // shave off 256 indices at the end to allow space for packing these indices into enums\n+            @max          [0xFFFF_FF00]\n             @vis          [$v]\n             @debug_format [\"{}\"]);\n     );\n@@ -82,7 +83,8 @@ macro_rules! newtype_index {\n         newtype_index!(\n             // Leave out derives marker so we can use its absence to ensure it comes first\n             @type         [$name]\n-            @max          [::std::u32::MAX - 1]\n+            // shave off 256 indices at the end to allow space for packing these indices into enums\n+            @max          [0xFFFF_FF00]\n             @vis          [$v]\n             @debug_format [\"{}\"]\n                           $($tokens)+);\n@@ -97,6 +99,7 @@ macro_rules! newtype_index {\n      @vis          [$v:vis]\n      @debug_format [$debug_format:tt]) => (\n         #[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, $($derives),*)]\n+        #[rustc_layout_scalar_valid_range_end($max)]\n         $v struct $type {\n             private: u32\n         }"}, {"sha": "d46b0813ca703e840c6fb4331fbd470a78e5bc79", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=dfabe4b88509bfff1eca9060ccc9a4d28ee394e8", "patch": "@@ -51,7 +51,7 @@ impl<'tcx> CFG<'tcx> {\n                                              source_info: SourceInfo,\n                                              region_scope: region::Scope) {\n         if tcx.emit_end_regions() {\n-            if let region::ScopeData::CallSite(_) = region_scope.data() {\n+            if let region::ScopeData::CallSite = region_scope.data() {\n                 // The CallSite scope (aka the root scope) is sort of weird, in that it is\n                 // supposed to \"separate\" the \"interior\" and \"exterior\" of a closure. Being\n                 // that, it is not really a part of the region hierarchy, but for some"}, {"sha": "1406183955bd430ce962fc556893714165d9d557", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=dfabe4b88509bfff1eca9060ccc9a4d28ee394e8", "patch": "@@ -566,7 +566,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         // We want `scopes[1]`, which is the `ParameterScope`.\n         assert!(self.scopes.len() >= 2);\n         assert!(match self.scopes[1].region_scope.data() {\n-            region::ScopeData::Arguments(_) => true,\n+            region::ScopeData::Arguments => true,\n             _ => false,\n         });\n         self.scopes[1].region_scope"}, {"sha": "b0a60fedfbbc2f64b8bc6fcabeb2a2c873ff04e5", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=dfabe4b88509bfff1eca9060ccc9a4d28ee394e8", "patch": "@@ -11,7 +11,7 @@\n use hair::*;\n use hair::cx::Cx;\n use hair::cx::to_ref::ToRef;\n-use rustc::middle::region::{self, BlockRemainder};\n+use rustc::middle::region;\n use rustc::hir;\n \n use rustc_data_structures::indexed_vec::Idx;\n@@ -71,10 +71,10 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         // ignore for purposes of the MIR\n                     }\n                     hir::DeclKind::Local(ref local) => {\n-                        let remainder_scope = region::Scope::Remainder(BlockRemainder {\n-                            block: block_id,\n-                            first_statement_index: region::FirstStatementIndex::new(index),\n-                        });\n+                        let remainder_scope = region::Scope::Remainder(\n+                            block_id,\n+                            region::FirstStatementIndex::new(index),\n+                        );\n \n                         let mut pattern = cx.pattern_from_hir(&local.pat);\n "}, {"sha": "8bb93d09a2aa2babbb20a14809a839d9f4d29177", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=dfabe4b88509bfff1eca9060ccc9a4d28ee394e8", "patch": "@@ -340,7 +340,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n         let field = field.try_into().unwrap();\n         let field_layout = op.layout.field(self, field)?;\n-        if field_layout.size.bytes() == 0 {\n+        if field_layout.is_zst() {\n             let val = Value::Scalar(Scalar::zst().into());\n             return Ok(OpTy { op: Operand::Immediate(val), layout: field_layout });\n         }\n@@ -397,9 +397,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             Field(field, _) => self.operand_field(base, field.index() as u64)?,\n             Downcast(_, variant) => self.operand_downcast(base, variant)?,\n             Deref => self.deref_operand(base)?.into(),\n-            // The rest should only occur as mplace, we do not use Immediates for types\n-            // allowing such operations.  This matches place_projection forcing an allocation.\n-            Subslice { .. } | ConstantIndex { .. } | Index(_) => {\n+            Subslice { .. } | ConstantIndex { .. } | Index(_) => if base.layout.is_zst() {\n+                OpTy {\n+                    op: Operand::Immediate(Value::Scalar(Scalar::zst().into())),\n+                    // the actual index doesn't matter, so we just pick a convenient one like 0\n+                    layout: base.layout.field(self, 0)?,\n+                }\n+            } else {\n+                // The rest should only occur as mplace, we do not use Immediates for types\n+                // allowing such operations.  This matches place_projection forcing an allocation.\n                 let mplace = base.to_mem_place();\n                 self.mplace_projection(mplace, proj_elem)?.into()\n             }"}, {"sha": "1594755b4ab87191b6bc13362f2f335ccca75ad6", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=dfabe4b88509bfff1eca9060ccc9a4d28ee394e8", "patch": "@@ -29,6 +29,8 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(exhaustive_patterns)]\n #![feature(range_contains)]\n #![feature(rustc_diagnostic_macros)]\n+#![feature(rustc_attrs)]\n+#![cfg_attr(stage0, feature(attr_literals))]\n #![feature(never_type)]\n #![feature(specialization)]\n #![feature(try_trait)]"}, {"sha": "25a7ff9cd3f566ed9a0c50cc188216f99da9eadb", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=dfabe4b88509bfff1eca9060ccc9a4d28ee394e8", "patch": "@@ -22,7 +22,7 @@ use Namespace::{self, TypeNS, ValueNS, MacroNS};\n use {resolve_error, resolve_struct_error, ResolutionError};\n \n use rustc::hir::def::*;\n-use rustc::hir::def_id::{BUILTIN_MACROS_CRATE, CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n+use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n use rustc::ty;\n use rustc::middle::cstore::CrateStore;\n use rustc_metadata::cstore::LoadedMacro;\n@@ -769,7 +769,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         let def_id = self.macro_defs[&expansion];\n         if let Some(id) = self.definitions.as_local_node_id(def_id) {\n             self.local_macro_def_scopes[&id]\n-        } else if def_id.krate == BUILTIN_MACROS_CRATE {\n+        } else if def_id.krate == CrateNum::BuiltinMacros {\n             self.injected_crate.unwrap_or(self.graph_root)\n         } else {\n             let module_def_id = ty::DefIdTree::parent(&*self, def_id).unwrap();"}, {"sha": "f8b5f891579ea793800d3c9cae2e834e36e4ec1f", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=dfabe4b88509bfff1eca9060ccc9a4d28ee394e8", "patch": "@@ -14,8 +14,8 @@ use ModuleOrUniformRoot;\n use Namespace::{self, TypeNS, MacroNS};\n use build_reduced_graph::{BuildReducedGraphVisitor, IsMacroExport};\n use resolve_imports::ImportResolver;\n-use rustc::hir::def_id::{DefId, BUILTIN_MACROS_CRATE, CRATE_DEF_INDEX, DefIndex,\n-                         DefIndexAddressSpace};\n+use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX, DefIndex,\n+                         CrateNum, DefIndexAddressSpace};\n use rustc::hir::def::{Def, NonMacroAttrKind};\n use rustc::hir::map::{self, DefCollector};\n use rustc::{ty, lint};\n@@ -218,7 +218,7 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n \n     fn add_builtin(&mut self, ident: ast::Ident, ext: Lrc<SyntaxExtension>) {\n         let def_id = DefId {\n-            krate: BUILTIN_MACROS_CRATE,\n+            krate: CrateNum::BuiltinMacros,\n             index: DefIndex::from_array_index(self.macro_map.len(),\n                                               DefIndexAddressSpace::Low),\n         };\n@@ -352,7 +352,7 @@ impl<'a, 'crateloader: 'a> base::Resolver for Resolver<'a, 'crateloader> {\n             self.definitions.add_parent_module_of_macro_def(invoc.expansion_data.mark,\n                                                             normal_module_def_id);\n             invoc.expansion_data.mark.set_default_transparency(ext.default_transparency());\n-            invoc.expansion_data.mark.set_is_builtin(def_id.krate == BUILTIN_MACROS_CRATE);\n+            invoc.expansion_data.mark.set_is_builtin(def_id.krate == CrateNum::BuiltinMacros);\n         }\n \n         Ok(Some(ext))\n@@ -1135,7 +1135,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         };\n \n         // Plugin-based syntax extensions are exempt from this check\n-        if krate == BUILTIN_MACROS_CRATE { return; }\n+        if krate == CrateNum::BuiltinMacros { return; }\n \n         let ext = binding.get_macro(self);\n "}, {"sha": "882579c571086ab8e48566a942abece6c3dcbdc4", "filename": "src/test/mir-opt/validate_1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_1.rs?ref=dfabe4b88509bfff1eca9060ccc9a4d28ee394e8", "patch": "@@ -64,11 +64,11 @@ fn main() {\n //     bb0: {\n //         Validate(Acquire, [_1: &ReFree(DefId(0/1:11 ~ validate_1[317d]::main[0]::{{closure}}[0]), BrEnv) [closure@NodeId(50)], _2: &ReFree(DefId(0/1:11 ~ validate_1[317d]::main[0]::{{closure}}[0]), BrAnon(0)) mut i32]);\n //         StorageLive(_3);\n-//         Validate(Suspend(ReScope(Remainder(BlockRemainder { block: ItemLocalId(25), first_statement_index: 0 }))), [(*_2): i32]);\n+//         Validate(Suspend(ReScope(Remainder { block: ItemLocalId(25), first_statement_index: 0 })), [(*_2): i32]);\n //         _3 = &ReErased (*_2);\n-//         Validate(Acquire, [(*_3): i32/ReScope(Remainder(BlockRemainder { block: ItemLocalId(25), first_statement_index: 0 })) (imm)]);\n+//         Validate(Acquire, [(*_3): i32/ReScope(Remainder { block: ItemLocalId(25), first_statement_index: 0 }) (imm)]);\n //         _0 = (*_3);\n-//         EndRegion(ReScope(Remainder(BlockRemainder { block: ItemLocalId(25), first_statement_index: 0 })));\n+//         EndRegion(ReScope(Remainder { block: ItemLocalId(25), first_statement_index: 0 }));\n //         StorageDead(_3);\n //         return;\n //     }"}, {"sha": "07f5b2aa84b7dda57e8dbb2958867272ac44981d", "filename": "src/test/mir-opt/validate_3.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fvalidate_3.rs?ref=dfabe4b88509bfff1eca9060ccc9a4d28ee394e8", "patch": "@@ -48,12 +48,12 @@ fn main() {\n //         StorageLive(_1);\n //         _1 = Test { x: const 0i32 };\n //         StorageLive(_2);\n-//         Validate(Suspend(ReScope(Remainder(BlockRemainder { block: ItemLocalId(20), first_statement_index: 3 }))), [_1: Test]);\n+//         Validate(Suspend(ReScope(Remainder { block: ItemLocalId(20), first_statement_index: 3 })), [_1: Test]);\n //         _2 = &ReErased _1;\n-//         Validate(Acquire, [(*_2): Test/ReScope(Remainder(BlockRemainder { block: ItemLocalId(20), first_statement_index: 3 })) (imm)]);\n+//         Validate(Acquire, [(*_2): Test/ReScope(Remainder { block: ItemLocalId(20), first_statement_index: 3 }) (imm)]);\n //         StorageLive(_4);\n //         StorageLive(_5);\n-//         Validate(Suspend(ReScope(Node(ItemLocalId(18)))), [((*_2).0: i32): i32/ReScope(Remainder(BlockRemainder { block: ItemLocalId(20), first_statement_index: 3 })) (imm)]);\n+//         Validate(Suspend(ReScope(Node(ItemLocalId(18)))), [((*_2).0: i32): i32/ReScope(Remainder { block: ItemLocalId(20), first_statement_index: 3 }) (imm)]);\n //         _5 = &ReErased ((*_2).0: i32);\n //         Validate(Acquire, [(*_5): i32/ReScope(Node(ItemLocalId(18))) (imm)]);\n //         Validate(Suspend(ReScope(Node(ItemLocalId(18)))), [(*_5): i32/ReScope(Node(ItemLocalId(18))) (imm)]);\n@@ -68,7 +68,7 @@ fn main() {\n //         StorageDead(_4);\n //         StorageDead(_5);\n //         _0 = ();\n-//         EndRegion(ReScope(Remainder(BlockRemainder { block: ItemLocalId(20), first_statement_index: 3 })));\n+//         EndRegion(ReScope(Remainder { block: ItemLocalId(20), first_statement_index: 3 }));\n //         StorageDead(_2);\n //         StorageDead(_1);\n //         return;"}, {"sha": "08e2c35e0722c77cc4915822db6b50424a997ccb", "filename": "src/test/run-pass-fulldeps/newtype_index.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Ftest%2Frun-pass-fulldeps%2Fnewtype_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Ftest%2Frun-pass-fulldeps%2Fnewtype_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fnewtype_index.rs?ref=dfabe4b88509bfff1eca9060ccc9a4d28ee394e8", "patch": "@@ -0,0 +1,20 @@\n+#![feature(min_const_fn, rustc_attrs, rustc_private, step_trait)]\n+\n+#[macro_use] extern crate rustc_data_structures;\n+extern crate rustc_serialize;\n+\n+use rustc_data_structures::indexed_vec::Idx;\n+\n+newtype_index!(struct MyIdx { MAX = 0xFFFF_FFFA });\n+\n+use std::mem::size_of;\n+\n+fn main() {\n+    assert_eq!(size_of::<MyIdx>(), 4);\n+    assert_eq!(size_of::<Option<MyIdx>>(), 4);\n+    assert_eq!(size_of::<Option<Option<MyIdx>>>(), 4);\n+    assert_eq!(size_of::<Option<Option<Option<MyIdx>>>>(), 4);\n+    assert_eq!(size_of::<Option<Option<Option<Option<MyIdx>>>>>(), 4);\n+    assert_eq!(size_of::<Option<Option<Option<Option<Option<MyIdx>>>>>>(), 4);\n+    assert_eq!(size_of::<Option<Option<Option<Option<Option<Option<MyIdx>>>>>>>(), 8);\n+}"}, {"sha": "d837da1066daa79d37c98a88dae7cefa80d536ae", "filename": "src/test/ui/consts/const-eval/zst_operand_eval.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fzst_operand_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dfabe4b88509bfff1eca9060ccc9a4d28ee394e8/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fzst_operand_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fzst_operand_eval.rs?ref=dfabe4b88509bfff1eca9060ccc9a4d28ee394e8", "patch": "@@ -0,0 +1,5 @@\n+// compile-pass\n+\n+static ASSERT: () = [()][!(std::mem::size_of::<u32>() == 4) as usize];\n+\n+fn main() {}"}]}