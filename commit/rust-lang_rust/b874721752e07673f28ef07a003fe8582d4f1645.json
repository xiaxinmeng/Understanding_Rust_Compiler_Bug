{"sha": "b874721752e07673f28ef07a003fe8582d4f1645", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4NzQ3MjE3NTJlMDc2NzNmMjhlZjA3YTAwM2ZlODU4MmQ0ZjE2NDU=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-09-12T21:54:49Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2020-09-12T21:54:49Z"}, "message": "Fix merge imports failing if the `self` module import is in the wrong tree", "tree": {"sha": "42b4c9db2325eaac38c2a73bb24c506755db650d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42b4c9db2325eaac38c2a73bb24c506755db650d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b874721752e07673f28ef07a003fe8582d4f1645", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b874721752e07673f28ef07a003fe8582d4f1645", "html_url": "https://github.com/rust-lang/rust/commit/b874721752e07673f28ef07a003fe8582d4f1645", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b874721752e07673f28ef07a003fe8582d4f1645/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cd6cd91bf345d47cbf22e00fc4cddced4ae67ae6", "url": "https://api.github.com/repos/rust-lang/rust/commits/cd6cd91bf345d47cbf22e00fc4cddced4ae67ae6", "html_url": "https://github.com/rust-lang/rust/commit/cd6cd91bf345d47cbf22e00fc4cddced4ae67ae6"}], "stats": {"total": 56, "additions": 34, "deletions": 22}, "files": [{"sha": "4972085d693adda04d65333d1bec7928570c23a9", "filename": "crates/assists/src/utils/insert_use.rs", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b874721752e07673f28ef07a003fe8582d4f1645/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b874721752e07673f28ef07a003fe8582d4f1645/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils%2Finsert_use.rs?ref=b874721752e07673f28ef07a003fe8582d4f1645", "patch": "@@ -149,31 +149,31 @@ fn eq_visibility(vis0: Option<ast::Visibility>, vis1: Option<ast::Visibility>) -\n }\n \n pub(crate) fn try_merge_imports(\n-    old: &ast::Use,\n-    new: &ast::Use,\n+    lhs: &ast::Use,\n+    rhs: &ast::Use,\n     merge_behaviour: MergeBehaviour,\n ) -> Option<ast::Use> {\n     // don't merge imports with different visibilities\n-    if !eq_visibility(old.visibility(), new.visibility()) {\n+    if !eq_visibility(lhs.visibility(), rhs.visibility()) {\n         return None;\n     }\n-    let old_tree = old.use_tree()?;\n-    let new_tree = new.use_tree()?;\n-    let merged = try_merge_trees(&old_tree, &new_tree, merge_behaviour)?;\n-    Some(old.with_use_tree(merged))\n+    let lhs_tree = lhs.use_tree()?;\n+    let rhs_tree = rhs.use_tree()?;\n+    let merged = try_merge_trees(&lhs_tree, &rhs_tree, merge_behaviour)?;\n+    Some(lhs.with_use_tree(merged))\n }\n \n pub(crate) fn try_merge_trees(\n-    old: &ast::UseTree,\n-    new: &ast::UseTree,\n+    lhs: &ast::UseTree,\n+    rhs: &ast::UseTree,\n     merge: MergeBehaviour,\n ) -> Option<ast::UseTree> {\n-    let lhs_path = old.path()?;\n-    let rhs_path = new.path()?;\n+    let lhs_path = lhs.path()?;\n+    let rhs_path = rhs.path()?;\n \n     let (lhs_prefix, rhs_prefix) = common_prefix(&lhs_path, &rhs_path)?;\n-    let lhs = old.split_prefix(&lhs_prefix);\n-    let rhs = new.split_prefix(&rhs_prefix);\n+    let lhs = lhs.split_prefix(&lhs_prefix);\n+    let rhs = rhs.split_prefix(&rhs_prefix);\n     recursive_merge(&lhs, &rhs, merge).map(|(merged, _)| merged)\n }\n \n@@ -209,13 +209,18 @@ fn recursive_merge(\n                     };\n                     // check if only one of the two trees has a tree list, and whether that then contains `self` or not.\n                     // If this is the case we can skip this iteration since the path without the list is already included in the other one via `self`\n-                    if lhs_t\n-                        .use_tree_list()\n-                        .xor(rhs_t.use_tree_list())\n-                        .map(|tree_list| tree_list.use_trees().any(tree_is_self))\n-                        .unwrap_or(false)\n-                    {\n-                        continue;\n+                    let tree_contains_self = |tree: &ast::UseTree| {\n+                        tree.use_tree_list()\n+                            .map(|tree_list| tree_list.use_trees().any(tree_is_self))\n+                            .unwrap_or(false)\n+                    };\n+                    match (tree_contains_self(&lhs_t), tree_contains_self(&rhs_t)) {\n+                        (true, false) => continue,\n+                        (false, true) => {\n+                            *lhs_t = rhs_t;\n+                            continue;\n+                        }\n+                        _ => (),\n                     }\n \n                     // glob imports arent part of the use-tree lists so we need to special handle them here as well\n@@ -255,6 +260,13 @@ fn recursive_merge(\n                     None => use_trees.insert(idx, rhs_t),\n                 }\n             }\n+            Err(_)\n+                if merge == MergeBehaviour::Last\n+                    && use_trees.len() > 0\n+                    && rhs_t.use_tree_list().is_some() =>\n+            {\n+                return None\n+            }\n             Err(idx) => {\n                 use_trees.insert(idx, rhs_t);\n             }\n@@ -819,8 +831,8 @@ use std::io;\",\n     fn merge_glob_nested() {\n         check_full(\n             \"foo::bar::quux::Fez\",\n-            r\"use foo::bar::{Baz, quux::*;\",\n-            r\"use foo::bar::{Baz, quux::{self::*, Fez}}\",\n+            r\"use foo::bar::{Baz, quux::*};\",\n+            r\"use foo::bar::{Baz, quux::{self::*, Fez}};\",\n         )\n     }\n "}]}