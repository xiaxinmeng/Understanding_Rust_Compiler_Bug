{"sha": "cb23a794a65c07c99c822a87b0855e3634d8a993", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiMjNhNzk0YTY1YzA3Yzk5YzgyMmE4N2IwODU1ZTM2MzRkOGE5OTM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "eddyb@lyken.rs", "date": "2021-05-15T06:17:46Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "eddyb@lyken.rs", "date": "2021-05-15T06:17:46Z"}, "message": "rustc_codegen_ssa: generate MSVC cleanup pads on demand, like GNU landing pads.", "tree": {"sha": "0e6e148e91f252721550e4a62ade10e062069336", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e6e148e91f252721550e4a62ade10e062069336"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb23a794a65c07c99c822a87b0855e3634d8a993", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb23a794a65c07c99c822a87b0855e3634d8a993", "html_url": "https://github.com/rust-lang/rust/commit/cb23a794a65c07c99c822a87b0855e3634d8a993", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb23a794a65c07c99c822a87b0855e3634d8a993/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1025db84a68b948139b5adcd55da31bce32da8f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/1025db84a68b948139b5adcd55da31bce32da8f3", "html_url": "https://github.com/rust-lang/rust/commit/1025db84a68b948139b5adcd55da31bce32da8f3"}], "stats": {"total": 221, "additions": 109, "deletions": 112}, "files": [{"sha": "8f92d3e6b804f47d6ed7e2f6c37319d89e817310", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 102, "deletions": 31, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/cb23a794a65c07c99c822a87b0855e3634d8a993/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb23a794a65c07c99c822a87b0855e3634d8a993/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=cb23a794a65c07c99c822a87b0855e3634d8a993", "patch": "@@ -20,7 +20,7 @@ use rustc_middle::ty::{self, Instance, Ty, TypeFoldable};\n use rustc_span::source_map::Span;\n use rustc_span::{sym, Symbol};\n use rustc_target::abi::call::{ArgAbi, FnAbi, PassMode};\n-use rustc_target::abi::{self, LayoutOf};\n+use rustc_target::abi::{self, HasDataLayout, LayoutOf};\n use rustc_target::spec::abi::Abi;\n \n /// Used by `FunctionCx::codegen_terminator` for emitting common patterns\n@@ -32,13 +32,34 @@ struct TerminatorCodegenHelper<'tcx> {\n }\n \n impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n-    /// Returns the associated funclet from `FunctionCx::funclets` for the\n-    /// `funclet_bb` member if it is not `None`.\n+    /// Returns the appropriate `Funclet` for the current funclet, if on MSVC,\n+    /// either already previously cached, or newly created, by `landing_pad_for`.\n     fn funclet<'b, Bx: BuilderMethods<'a, 'tcx>>(\n         &self,\n-        fx: &'b FunctionCx<'a, 'tcx, Bx>,\n+        fx: &'b mut FunctionCx<'a, 'tcx, Bx>,\n     ) -> Option<&'b Bx::Funclet> {\n-        self.funclet_bb.and_then(|funcl| fx.funclets[funcl].as_ref())\n+        let funclet_bb = self.funclet_bb?;\n+        if base::wants_msvc_seh(fx.cx.tcx().sess) {\n+            // If `landing_pad_for` hasn't been called yet to create the `Funclet`,\n+            // it has to be now. This may not seem necessary, as RPO should lead\n+            // to all the unwind edges being visited (and so to `landing_pad_for`\n+            // getting called for them), before building any of the blocks inside\n+            // the funclet itself - however, if MIR contains edges that end up not\n+            // being needed in the LLVM IR after monomorphization, the funclet may\n+            // be unreachable, and we don't have yet a way to skip building it in\n+            // such an eventuality (which may be a better solution than this).\n+            if fx.funclets[funclet_bb].is_none() {\n+                fx.landing_pad_for(funclet_bb);\n+            }\n+\n+            Some(\n+                fx.funclets[funclet_bb]\n+                    .as_ref()\n+                    .expect(\"landing_pad_for didn't also create funclets entry\"),\n+            )\n+        } else {\n+            None\n+        }\n     }\n \n     fn lltarget<Bx: BuilderMethods<'a, 'tcx>>(\n@@ -54,10 +75,10 @@ impl<'a, 'tcx> TerminatorCodegenHelper<'tcx> {\n             (Some(f), Some(t_f)) if f == t_f || !base::wants_msvc_seh(fx.cx.tcx().sess) => {\n                 (lltarget, false)\n             }\n-            // jump *into* cleanup - need a landing pad if GNU\n-            (None, Some(_)) => (fx.landing_pad_to(target), false),\n+            // jump *into* cleanup - need a landing pad if GNU, cleanup pad if MSVC\n+            (None, Some(_)) => (fx.landing_pad_for(target), false),\n             (Some(_), None) => span_bug!(span, \"{:?} - jump out of cleanup?\", self.terminator),\n-            (Some(_), Some(_)) => (fx.landing_pad_to(target), true),\n+            (Some(_), Some(_)) => (fx.landing_pad_for(target), true),\n         }\n     }\n \n@@ -1170,38 +1191,88 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         }\n     }\n \n-    /// Returns the landing-pad wrapper around the given basic block.\n-    ///\n-    /// No-op in MSVC SEH scheme.\n-    fn landing_pad_to(&mut self, target_bb: mir::BasicBlock) -> Bx::BasicBlock {\n-        if let Some(block) = self.landing_pads[target_bb] {\n-            return block;\n+    /// Returns the landing/cleanup pad wrapper around the given basic block.\n+    // FIXME(eddyb) rename this to `eh_pad_for`.\n+    fn landing_pad_for(&mut self, bb: mir::BasicBlock) -> Bx::BasicBlock {\n+        if let Some(landing_pad) = self.landing_pads[bb] {\n+            return landing_pad;\n         }\n \n-        let block = self.blocks[target_bb];\n-        let landing_pad = self.landing_pad_uncached(block);\n-        self.landing_pads[target_bb] = Some(landing_pad);\n+        let landing_pad = self.landing_pad_for_uncached(bb);\n+        self.landing_pads[bb] = Some(landing_pad);\n         landing_pad\n     }\n \n-    fn landing_pad_uncached(&mut self, target_bb: Bx::BasicBlock) -> Bx::BasicBlock {\n+    // FIXME(eddyb) rename this to `eh_pad_for_uncached`.\n+    fn landing_pad_for_uncached(&mut self, bb: mir::BasicBlock) -> Bx::BasicBlock {\n+        let llbb = self.blocks[bb];\n         if base::wants_msvc_seh(self.cx.sess()) {\n-            span_bug!(self.mir.span, \"landing pad was not inserted?\")\n-        }\n-\n-        let mut bx = self.new_block(\"cleanup\");\n+            let funclet;\n+            let ret_llbb;\n+            match self.mir[bb].terminator.as_ref().map(|t| &t.kind) {\n+                // This is a basic block that we're aborting the program for,\n+                // notably in an `extern` function. These basic blocks are inserted\n+                // so that we assert that `extern` functions do indeed not panic,\n+                // and if they do we abort the process.\n+                //\n+                // On MSVC these are tricky though (where we're doing funclets). If\n+                // we were to do a cleanuppad (like below) the normal functions like\n+                // `longjmp` would trigger the abort logic, terminating the\n+                // program. Instead we insert the equivalent of `catch(...)` for C++\n+                // which magically doesn't trigger when `longjmp` files over this\n+                // frame.\n+                //\n+                // Lots more discussion can be found on #48251 but this codegen is\n+                // modeled after clang's for:\n+                //\n+                //      try {\n+                //          foo();\n+                //      } catch (...) {\n+                //          bar();\n+                //      }\n+                Some(&mir::TerminatorKind::Abort) => {\n+                    let mut cs_bx = self.new_block(&format!(\"cs_funclet{:?}\", bb));\n+                    let mut cp_bx = self.new_block(&format!(\"cp_funclet{:?}\", bb));\n+                    ret_llbb = cs_bx.llbb();\n+\n+                    let cs = cs_bx.catch_switch(None, None, 1);\n+                    cs_bx.add_handler(cs, cp_bx.llbb());\n+\n+                    // The \"null\" here is actually a RTTI type descriptor for the\n+                    // C++ personality function, but `catch (...)` has no type so\n+                    // it's null. The 64 here is actually a bitfield which\n+                    // represents that this is a catch-all block.\n+                    let null = cp_bx.const_null(\n+                        cp_bx.type_i8p_ext(cp_bx.cx().data_layout().instruction_address_space),\n+                    );\n+                    let sixty_four = cp_bx.const_i32(64);\n+                    funclet = cp_bx.catch_pad(cs, &[null, sixty_four, null]);\n+                    cp_bx.br(llbb);\n+                }\n+                _ => {\n+                    let mut cleanup_bx = self.new_block(&format!(\"funclet_{:?}\", bb));\n+                    ret_llbb = cleanup_bx.llbb();\n+                    funclet = cleanup_bx.cleanup_pad(None, &[]);\n+                    cleanup_bx.br(llbb);\n+                }\n+            }\n+            self.funclets[bb] = Some(funclet);\n+            ret_llbb\n+        } else {\n+            let mut bx = self.new_block(\"cleanup\");\n \n-        let llpersonality = self.cx.eh_personality();\n-        let llretty = self.landing_pad_type();\n-        let lp = bx.landing_pad(llretty, llpersonality, 1);\n-        bx.set_cleanup(lp);\n+            let llpersonality = self.cx.eh_personality();\n+            let llretty = self.landing_pad_type();\n+            let lp = bx.landing_pad(llretty, llpersonality, 1);\n+            bx.set_cleanup(lp);\n \n-        let slot = self.get_personality_slot(&mut bx);\n-        slot.storage_live(&mut bx);\n-        Pair(bx.extract_value(lp, 0), bx.extract_value(lp, 1)).store(&mut bx, slot);\n+            let slot = self.get_personality_slot(&mut bx);\n+            slot.storage_live(&mut bx);\n+            Pair(bx.extract_value(lp, 0), bx.extract_value(lp, 1)).store(&mut bx, slot);\n \n-        bx.br(target_bb);\n-        bx.llbb()\n+            bx.br(llbb);\n+            bx.llbb()\n+        }\n     }\n \n     fn landing_pad_type(&self) -> Bx::Type {"}, {"sha": "a14ae16517db052902d56f961319e0713df9572f", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 7, "deletions": 81, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/cb23a794a65c07c99c822a87b0855e3634d8a993/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb23a794a65c07c99c822a87b0855e3634d8a993/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=cb23a794a65c07c99c822a87b0855e3634d8a993", "patch": "@@ -1,19 +1,16 @@\n-use crate::base;\n use crate::traits::*;\n use rustc_errors::ErrorReported;\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::ErrorHandled;\n use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt, TyAndLayout};\n use rustc_middle::ty::{self, Instance, Ty, TypeFoldable};\n use rustc_target::abi::call::{FnAbi, PassMode};\n-use rustc_target::abi::HasDataLayout;\n \n use std::iter;\n \n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n \n-use self::analyze::CleanupKind;\n use self::debuginfo::{FunctionDebugContext, PerLocalVarDebugInfo};\n use self::place::PlaceRef;\n use rustc_middle::mir::traversal;\n@@ -49,12 +46,13 @@ pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     /// The funclet status of each basic block\n     cleanup_kinds: IndexVec<mir::BasicBlock, analyze::CleanupKind>,\n \n-    /// When targeting MSVC, this stores the cleanup info for each funclet\n-    /// BB. This is initialized as we compute the funclets' head block in RPO.\n+    /// When targeting MSVC, this stores the cleanup info for each funclet BB.\n+    /// This is initialized at the same time as the `landing_pads` entry for the\n+    /// funclets' head block, i.e. when needed by an unwind / `cleanup_ret` edge.\n     funclets: IndexVec<mir::BasicBlock, Option<Bx::Funclet>>,\n \n-    /// This stores the landing-pad block for a given BB, computed lazily on GNU\n-    /// and eagerly on MSVC.\n+    /// This stores the cached landing/cleanup pad block for a given BB.\n+    // FIXME(eddyb) rename this to `eh_pads`.\n     landing_pads: IndexVec<mir::BasicBlock, Option<Bx::BasicBlock>>,\n \n     /// Cached unreachable block\n@@ -165,7 +163,6 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         })\n         .collect();\n \n-    let (landing_pads, funclets) = create_funclets(&mir, &mut bx, &cleanup_kinds, &block_bxs);\n     let mut fx = FunctionCx {\n         instance,\n         mir,\n@@ -176,8 +173,8 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         blocks: block_bxs,\n         unreachable_block: None,\n         cleanup_kinds,\n-        landing_pads,\n-        funclets,\n+        landing_pads: IndexVec::from_elem(None, mir.basic_blocks()),\n+        funclets: IndexVec::from_fn_n(|_| None, mir.basic_blocks().len()),\n         locals: IndexVec::new(),\n         debug_context,\n         per_local_var_debug_info: None,\n@@ -273,77 +270,6 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     }\n }\n \n-fn create_funclets<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n-    mir: &'tcx mir::Body<'tcx>,\n-    bx: &mut Bx,\n-    cleanup_kinds: &IndexVec<mir::BasicBlock, CleanupKind>,\n-    block_bxs: &IndexVec<mir::BasicBlock, Bx::BasicBlock>,\n-) -> (\n-    IndexVec<mir::BasicBlock, Option<Bx::BasicBlock>>,\n-    IndexVec<mir::BasicBlock, Option<Bx::Funclet>>,\n-) {\n-    iter::zip(block_bxs.iter_enumerated(), cleanup_kinds)\n-        .map(|((bb, &llbb), cleanup_kind)| {\n-            match *cleanup_kind {\n-                CleanupKind::Funclet if base::wants_msvc_seh(bx.sess()) => {}\n-                _ => return (None, None),\n-            }\n-\n-            let funclet;\n-            let ret_llbb;\n-            match mir[bb].terminator.as_ref().map(|t| &t.kind) {\n-                // This is a basic block that we're aborting the program for,\n-                // notably in an `extern` function. These basic blocks are inserted\n-                // so that we assert that `extern` functions do indeed not panic,\n-                // and if they do we abort the process.\n-                //\n-                // On MSVC these are tricky though (where we're doing funclets). If\n-                // we were to do a cleanuppad (like below) the normal functions like\n-                // `longjmp` would trigger the abort logic, terminating the\n-                // program. Instead we insert the equivalent of `catch(...)` for C++\n-                // which magically doesn't trigger when `longjmp` files over this\n-                // frame.\n-                //\n-                // Lots more discussion can be found on #48251 but this codegen is\n-                // modeled after clang's for:\n-                //\n-                //      try {\n-                //          foo();\n-                //      } catch (...) {\n-                //          bar();\n-                //      }\n-                Some(&mir::TerminatorKind::Abort) => {\n-                    let mut cs_bx = bx.build_sibling_block(&format!(\"cs_funclet{:?}\", bb));\n-                    let mut cp_bx = bx.build_sibling_block(&format!(\"cp_funclet{:?}\", bb));\n-                    ret_llbb = cs_bx.llbb();\n-\n-                    let cs = cs_bx.catch_switch(None, None, 1);\n-                    cs_bx.add_handler(cs, cp_bx.llbb());\n-\n-                    // The \"null\" here is actually a RTTI type descriptor for the\n-                    // C++ personality function, but `catch (...)` has no type so\n-                    // it's null. The 64 here is actually a bitfield which\n-                    // represents that this is a catch-all block.\n-                    let null = bx.const_null(\n-                        bx.type_i8p_ext(bx.cx().data_layout().instruction_address_space),\n-                    );\n-                    let sixty_four = bx.const_i32(64);\n-                    funclet = cp_bx.catch_pad(cs, &[null, sixty_four, null]);\n-                    cp_bx.br(llbb);\n-                }\n-                _ => {\n-                    let mut cleanup_bx = bx.build_sibling_block(&format!(\"funclet_{:?}\", bb));\n-                    ret_llbb = cleanup_bx.llbb();\n-                    funclet = cleanup_bx.cleanup_pad(None, &[]);\n-                    cleanup_bx.br(llbb);\n-                }\n-            };\n-\n-            (Some(ret_llbb), Some(funclet))\n-        })\n-        .unzip()\n-}\n-\n /// Produces, for each argument, a `Value` pointing at the\n /// argument's value. As arguments are places, these are always\n /// indirect."}]}