{"sha": "59f4ba95045e91a63e921e0d736242d7e1ffabec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5ZjRiYTk1MDQ1ZTkxYTYzZTkyMWUwZDczNjI0MmQ3ZTFmZmFiZWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-16T13:22:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-16T13:22:56Z"}, "message": "Auto merge of #70040 - Dylan-DPC:rollup-id1k6lz, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #67335 (Refactor the `Qualif` trait)\n - #69122 (Backtrace Debug tweaks)\n - #69520 (Make error message clearer about creating new module)\n - #69738 (More Method -> AssocFn renaming)\n - #69867 (Add long error explanation for E0628 )\n - #69989 (resolve/hygiene: `macro_rules` are not \"legacy\")\n - #70036 (Make article_and_description primarily use def_kind)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "c094dea10880b240fb45bf36cb8f4905edfdb2fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c094dea10880b240fb45bf36cb8f4905edfdb2fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59f4ba95045e91a63e921e0d736242d7e1ffabec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59f4ba95045e91a63e921e0d736242d7e1ffabec", "html_url": "https://github.com/rust-lang/rust/commit/59f4ba95045e91a63e921e0d736242d7e1ffabec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59f4ba95045e91a63e921e0d736242d7e1ffabec/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e6de3244cd62cbde367c206bc9972daded5281d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e6de3244cd62cbde367c206bc9972daded5281d", "html_url": "https://github.com/rust-lang/rust/commit/8e6de3244cd62cbde367c206bc9972daded5281d"}, {"sha": "d8dbb3c0413afe1cad58515295273c89d82176e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/d8dbb3c0413afe1cad58515295273c89d82176e5", "html_url": "https://github.com/rust-lang/rust/commit/d8dbb3c0413afe1cad58515295273c89d82176e5"}], "stats": {"total": 1273, "additions": 694, "deletions": 579}, "files": [{"sha": "7024e86f95d06a169dabcd2675c3cad5d6b7cb03", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -51,7 +51,7 @@ impl MaybeFnLike for hir::Item<'_> {\n impl MaybeFnLike for hir::ImplItem<'_> {\n     fn is_fn_like(&self) -> bool {\n         match self.kind {\n-            hir::ImplItemKind::Method(..) => true,\n+            hir::ImplItemKind::Fn(..) => true,\n             _ => false,\n         }\n     }\n@@ -60,7 +60,7 @@ impl MaybeFnLike for hir::ImplItem<'_> {\n impl MaybeFnLike for hir::TraitItem<'_> {\n     fn is_fn_like(&self) -> bool {\n         match self.kind {\n-            hir::TraitItemKind::Fn(_, hir::TraitMethod::Provided(_)) => true,\n+            hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(_)) => true,\n             _ => false,\n         }\n     }\n@@ -239,13 +239,13 @@ impl<'a> FnLikeNode<'a> {\n                 _ => bug!(\"item FnLikeNode that is not fn-like\"),\n             },\n             Node::TraitItem(ti) => match ti.kind {\n-                hir::TraitItemKind::Fn(ref sig, hir::TraitMethod::Provided(body)) => {\n+                hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n                     method(ti.hir_id, ti.ident, sig, None, body, ti.span, &ti.attrs)\n                 }\n                 _ => bug!(\"trait method FnLikeNode that is not fn-like\"),\n             },\n             Node::ImplItem(ii) => match ii.kind {\n-                hir::ImplItemKind::Method(ref sig, body) => {\n+                hir::ImplItemKind::Fn(ref sig, body) => {\n                     method(ii.hir_id, ii.ident, sig, Some(&ii.vis), body, ii.span, &ii.attrs)\n                 }\n                 _ => bug!(\"impl method FnLikeNode that is not fn-like\"),"}, {"sha": "55ed07a97d168e232ed08ebca9ee70792ed2e7bd", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -56,7 +56,7 @@ fn fn_decl<'hir>(node: Node<'hir>) -> Option<&'hir FnDecl<'hir>> {\n         },\n \n         Node::ImplItem(ref item) => match item.kind {\n-            ImplItemKind::Method(ref sig, _) => Some(&sig.decl),\n+            ImplItemKind::Fn(ref sig, _) => Some(&sig.decl),\n             _ => None,\n         },\n \n@@ -82,7 +82,7 @@ fn fn_sig<'hir>(node: Node<'hir>) -> Option<&'hir FnSig<'hir>> {\n         },\n \n         Node::ImplItem(item) => match &item.kind {\n-            ImplItemKind::Method(sig, _) => Some(sig),\n+            ImplItemKind::Fn(sig, _) => Some(sig),\n             _ => None,\n         },\n \n@@ -100,13 +100,14 @@ fn associated_body<'hir>(node: Node<'hir>) -> Option<BodyId> {\n         },\n \n         Node::TraitItem(item) => match item.kind {\n-            TraitItemKind::Const(_, Some(body))\n-            | TraitItemKind::Fn(_, TraitMethod::Provided(body)) => Some(body),\n+            TraitItemKind::Const(_, Some(body)) | TraitItemKind::Fn(_, TraitFn::Provided(body)) => {\n+                Some(body)\n+            }\n             _ => None,\n         },\n \n         Node::ImplItem(item) => match item.kind {\n-            ImplItemKind::Const(_, body) | ImplItemKind::Method(_, body) => Some(body),\n+            ImplItemKind::Const(_, body) | ImplItemKind::Fn(_, body) => Some(body),\n             _ => None,\n         },\n \n@@ -299,7 +300,7 @@ impl<'hir> Map<'hir> {\n             },\n             Node::ImplItem(item) => match item.kind {\n                 ImplItemKind::Const(..) => DefKind::AssocConst,\n-                ImplItemKind::Method(..) => DefKind::AssocFn,\n+                ImplItemKind::Fn(..) => DefKind::AssocFn,\n                 ImplItemKind::TyAlias(..) => DefKind::AssocTy,\n                 ImplItemKind::OpaqueTy(..) => DefKind::AssocOpaqueTy,\n             },\n@@ -443,7 +444,7 @@ impl<'hir> Map<'hir> {\n             Node::Ctor(..)\n             | Node::Item(&Item { kind: ItemKind::Fn(..), .. })\n             | Node::TraitItem(&TraitItem { kind: TraitItemKind::Fn(..), .. })\n-            | Node::ImplItem(&ImplItem { kind: ImplItemKind::Method(..), .. }) => BodyOwnerKind::Fn,\n+            | Node::ImplItem(&ImplItem { kind: ImplItemKind::Fn(..), .. }) => BodyOwnerKind::Fn,\n             Node::Item(&Item { kind: ItemKind::Static(_, m, _), .. }) => BodyOwnerKind::Static(m),\n             Node::Expr(&Expr { kind: ExprKind::Closure(..), .. }) => BodyOwnerKind::Closure,\n             node => bug!(\"{:#?} is not a body node\", node),\n@@ -749,7 +750,7 @@ impl<'hir> Map<'hir> {\n                     _ => false,\n                 },\n                 Node::ImplItem(ii) => match ii.kind {\n-                    ImplItemKind::Method(..) => true,\n+                    ImplItemKind::Fn(..) => true,\n                     _ => false,\n                 },\n                 Node::Block(_) => true,\n@@ -1110,7 +1111,7 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n             ImplItemKind::Const(..) => {\n                 format!(\"assoc const {} in {}{}\", ii.ident, path_str(), id_str)\n             }\n-            ImplItemKind::Method(..) => format!(\"method {} in {}{}\", ii.ident, path_str(), id_str),\n+            ImplItemKind::Fn(..) => format!(\"method {} in {}{}\", ii.ident, path_str(), id_str),\n             ImplItemKind::TyAlias(_) => {\n                 format!(\"assoc type {} in {}{}\", ii.ident, path_str(), id_str)\n             }"}, {"sha": "d6f6788697cd84322d26a333498f61dd92777eab", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -1520,20 +1520,21 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Returns a displayable description and article for the given `def_id` (e.g. `(\"a\", \"struct\")`).\n     pub fn article_and_description(&self, def_id: DefId) -> (&'static str, &'static str) {\n-        match self.def_key(def_id).disambiguated_data.data {\n-            DefPathData::TypeNs(..) | DefPathData::ValueNs(..) | DefPathData::MacroNs(..) => {\n-                let kind = self.def_kind(def_id).unwrap();\n-                (kind.article(), kind.descr(def_id))\n-            }\n-            DefPathData::ClosureExpr => match self.generator_kind(def_id) {\n-                None => (\"a\", \"closure\"),\n-                Some(rustc_hir::GeneratorKind::Async(..)) => (\"an\", \"async closure\"),\n-                Some(rustc_hir::GeneratorKind::Gen) => (\"a\", \"generator\"),\n-            },\n-            DefPathData::LifetimeNs(..) => (\"a\", \"lifetime\"),\n-            DefPathData::Impl => (\"an\", \"implementation\"),\n-            _ => bug!(\"article_and_description called on def_id {:?}\", def_id),\n-        }\n+        self.def_kind(def_id)\n+            .map(|def_kind| (def_kind.article(), def_kind.descr(def_id)))\n+            .unwrap_or_else(|| match self.def_key(def_id).disambiguated_data.data {\n+                DefPathData::ClosureExpr => match self.generator_kind(def_id) {\n+                    None => (\"a\", \"closure\"),\n+                    Some(rustc_hir::GeneratorKind::Async(..)) => (\"an\", \"async closure\"),\n+                    Some(rustc_hir::GeneratorKind::Gen) => (\"a\", \"generator\"),\n+                },\n+                DefPathData::LifetimeNs(..) => (\"a\", \"lifetime\"),\n+                DefPathData::Impl => (\"an\", \"implementation\"),\n+                DefPathData::TypeNs(..) | DefPathData::ValueNs(..) | DefPathData::MacroNs(..) => {\n+                    unreachable!()\n+                }\n+                _ => bug!(\"article_and_description called on def_id {:?}\", def_id),\n+            })\n     }\n }\n "}, {"sha": "338ff45a4ac7aacce623f7b04eb6185da0ce886d", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -3083,7 +3083,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn hygienic_eq(self, use_name: Ident, def_name: Ident, def_parent_def_id: DefId) -> bool {\n         // We could use `Ident::eq` here, but we deliberately don't. The name\n         // comparison fails frequently, and we want to avoid the expensive\n-        // `modern()` calls required for the span comparison whenever possible.\n+        // `normalize_to_macros_2_0()` calls required for the span comparison whenever possible.\n         use_name.name == def_name.name\n             && use_name\n                 .span\n@@ -3099,7 +3099,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     pub fn adjust_ident(self, mut ident: Ident, scope: DefId) -> Ident {\n-        ident.span.modernize_and_adjust(self.expansion_that_defined(scope));\n+        ident.span.normalize_to_macros_2_0_and_adjust(self.expansion_that_defined(scope));\n         ident\n     }\n \n@@ -3109,12 +3109,14 @@ impl<'tcx> TyCtxt<'tcx> {\n         scope: DefId,\n         block: hir::HirId,\n     ) -> (Ident, DefId) {\n-        let scope = match ident.span.modernize_and_adjust(self.expansion_that_defined(scope)) {\n-            Some(actual_expansion) => {\n-                self.hir().definitions().parent_module_of_macro_def(actual_expansion)\n-            }\n-            None => self.parent_module(block),\n-        };\n+        let scope =\n+            match ident.span.normalize_to_macros_2_0_and_adjust(self.expansion_that_defined(scope))\n+            {\n+                Some(actual_expansion) => {\n+                    self.hir().definitions().parent_module_of_macro_def(actual_expansion)\n+                }\n+                None => self.parent_module(block),\n+            };\n         (ident, scope)\n     }\n "}, {"sha": "68960ba9fe920c3e9a977b3d610c6d59a5f4f431", "filename": "src/librustc_ast/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_ast%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_ast%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fast.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -1450,7 +1450,7 @@ impl MacDelimiter {\n pub struct MacroDef {\n     pub body: P<MacArgs>,\n     /// `true` if macro was defined with `macro_rules`.\n-    pub legacy: bool,\n+    pub macro_rules: bool,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, Copy, Hash, Eq, PartialEq)]"}, {"sha": "aa2968b3cbe44dc3826869a720b0c25bd7872ffa", "filename": "src/librustc_ast/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_ast%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_ast%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast%2Fmut_visit.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -591,7 +591,7 @@ pub fn noop_visit_mac<T: MutVisitor>(mac: &mut MacCall, vis: &mut T) {\n }\n \n pub fn noop_visit_macro_def<T: MutVisitor>(macro_def: &mut MacroDef, vis: &mut T) {\n-    let MacroDef { body, legacy: _ } = macro_def;\n+    let MacroDef { body, macro_rules: _ } = macro_def;\n     visit_mac_args(body, vis);\n }\n "}, {"sha": "aab6aa7c35b0eb96a29f90fe61ef1337435475e3", "filename": "src/librustc_ast_lowering/item.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_ast_lowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_ast_lowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Fitem.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -115,7 +115,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             _ => &[],\n         };\n         let lt_def_names = parent_generics.iter().filter_map(|param| match param.kind {\n-            hir::GenericParamKind::Lifetime { .. } => Some(param.name.modern()),\n+            hir::GenericParamKind::Lifetime { .. } => Some(param.name.normalize_to_macros_2_0()),\n             _ => None,\n         });\n         self.in_scope_lifetimes.extend(lt_def_names);\n@@ -220,8 +220,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let mut vis = self.lower_visibility(&i.vis, None);\n         let attrs = self.lower_attrs(&i.attrs);\n \n-        if let ItemKind::MacroDef(MacroDef { ref body, legacy }) = i.kind {\n-            if !legacy || attr::contains_name(&i.attrs, sym::macro_export) {\n+        if let ItemKind::MacroDef(MacroDef { ref body, macro_rules }) = i.kind {\n+            if !macro_rules || attr::contains_name(&i.attrs, sym::macro_export) {\n                 let hir_id = self.lower_node_id(i.id);\n                 let body = P(self.lower_mac_args(body));\n                 self.exported_macros.push(hir::MacroDef {\n@@ -230,7 +230,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     attrs,\n                     hir_id,\n                     span: i.span,\n-                    ast: MacroDef { body, legacy },\n+                    ast: MacroDef { body, macro_rules },\n                 });\n             } else {\n                 self.non_exported_macro_attrs.extend(attrs.iter().cloned());\n@@ -761,13 +761,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let names = self.lower_fn_params_to_names(&sig.decl);\n                 let (generics, sig) =\n                     self.lower_method_sig(generics, sig, trait_item_def_id, false, None);\n-                (generics, hir::TraitItemKind::Fn(sig, hir::TraitMethod::Required(names)))\n+                (generics, hir::TraitItemKind::Fn(sig, hir::TraitFn::Required(names)))\n             }\n             AssocItemKind::Fn(_, ref sig, ref generics, Some(ref body)) => {\n                 let body_id = self.lower_fn_body_block(i.span, &sig.decl, Some(body));\n                 let (generics, sig) =\n                     self.lower_method_sig(generics, sig, trait_item_def_id, false, None);\n-                (generics, hir::TraitItemKind::Fn(sig, hir::TraitMethod::Provided(body_id)))\n+                (generics, hir::TraitItemKind::Fn(sig, hir::TraitFn::Provided(body_id)))\n             }\n             AssocItemKind::TyAlias(_, ref generics, ref bounds, ref default) => {\n                 let ty = default.as_ref().map(|x| self.lower_ty(x, ImplTraitContext::disallowed()));\n@@ -838,7 +838,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     asyncness.opt_return_id(),\n                 );\n \n-                (generics, hir::ImplItemKind::Method(sig, body_id))\n+                (generics, hir::ImplItemKind::Fn(sig, body_id))\n             }\n             AssocItemKind::TyAlias(_, generics, _, ty) => {\n                 let generics = self.lower_generics(generics, ImplTraitContext::disallowed());"}, {"sha": "32b0f0db3589d40e1e575c2ac3dbf5b22a9bdd03", "filename": "src/librustc_ast_lowering/lib.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_ast_lowering%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_ast_lowering%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_lowering%2Flib.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -153,7 +153,7 @@ struct LoweringContext<'a, 'hir: 'a> {\n     /// against this list to see if it is already in-scope, or if a definition\n     /// needs to be created for it.\n     ///\n-    /// We always store a `modern()` version of the param-name in this\n+    /// We always store a `normalize_to_macros_2_0()` version of the param-name in this\n     /// vector.\n     in_scope_lifetimes: Vec<ParamName>,\n \n@@ -803,14 +803,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             return;\n         }\n \n-        if self.in_scope_lifetimes.contains(&ParamName::Plain(ident.modern())) {\n+        if self.in_scope_lifetimes.contains(&ParamName::Plain(ident.normalize_to_macros_2_0())) {\n             return;\n         }\n \n         let hir_name = ParamName::Plain(ident);\n \n-        if self.lifetimes_to_define.iter().any(|(_, lt_name)| lt_name.modern() == hir_name.modern())\n-        {\n+        if self.lifetimes_to_define.iter().any(|(_, lt_name)| {\n+            lt_name.normalize_to_macros_2_0() == hir_name.normalize_to_macros_2_0()\n+        }) {\n             return;\n         }\n \n@@ -838,7 +839,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     ) -> T {\n         let old_len = self.in_scope_lifetimes.len();\n         let lt_def_names = params.iter().filter_map(|param| match param.kind {\n-            GenericParamKind::Lifetime { .. } => Some(ParamName::Plain(param.ident.modern())),\n+            GenericParamKind::Lifetime { .. } => {\n+                Some(ParamName::Plain(param.ident.normalize_to_macros_2_0()))\n+            }\n             _ => None,\n         });\n         self.in_scope_lifetimes.extend(lt_def_names);"}, {"sha": "2a9847c900e94173add4b5aad763e2cea937412d", "filename": "src/librustc_ast_passes/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_ast_passes%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Ffeature_gate.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -366,7 +366,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 gate_feature_post!(&self, trait_alias, i.span, \"trait aliases are experimental\");\n             }\n \n-            ast::ItemKind::MacroDef(ast::MacroDef { legacy: false, .. }) => {\n+            ast::ItemKind::MacroDef(ast::MacroDef { macro_rules: false, .. }) => {\n                 let msg = \"`macro` is experimental\";\n                 gate_feature_post!(&self, decl_macro, i.span, msg);\n             }"}, {"sha": "b2e6ab7c5e7772a4af5863a4caad505c228ec25b", "filename": "src/librustc_ast_pretty/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_ast_pretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_ast_pretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_pretty%2Fpprust.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -1238,7 +1238,7 @@ impl<'a> State<'a> {\n                 }\n             }\n             ast::ItemKind::MacroDef(ref macro_def) => {\n-                let (kw, has_bang) = if macro_def.legacy {\n+                let (kw, has_bang) = if macro_def.macro_rules {\n                     (\"macro_rules\", true)\n                 } else {\n                     self.print_visibility(&item.vis);"}, {"sha": "99083cca6cb3443a6424aff1eec92335172bc74e", "filename": "src/librustc_attr/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_attr%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_attr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_attr%2Fbuiltin.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -1024,7 +1024,7 @@ pub enum TransparencyError {\n \n pub fn find_transparency(\n     attrs: &[Attribute],\n-    is_legacy: bool,\n+    macro_rules: bool,\n ) -> (Transparency, Option<TransparencyError>) {\n     let mut transparency = None;\n     let mut error = None;\n@@ -1049,7 +1049,7 @@ pub fn find_transparency(\n             }\n         }\n     }\n-    let fallback = if is_legacy { Transparency::SemiTransparent } else { Transparency::Opaque };\n+    let fallback = if macro_rules { Transparency::SemiTransparent } else { Transparency::Opaque };\n     (transparency.map_or(fallback, |t| t.0), error)\n }\n "}, {"sha": "178a74c791b4c3e51981ffe26469b95237454a13", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -88,7 +88,7 @@ fn reachable_non_generics_provider(\n                 // Only consider nodes that actually have exported symbols.\n                 Node::Item(&hir::Item { kind: hir::ItemKind::Static(..), .. })\n                 | Node::Item(&hir::Item { kind: hir::ItemKind::Fn(..), .. })\n-                | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Method(..), .. }) => {\n+                | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }) => {\n                     let def_id = tcx.hir().local_def_id(hir_id);\n                     let generics = tcx.generics_of(def_id);\n                     if !generics.requires_monomorphization(tcx) &&"}, {"sha": "85339ab9aa15badd581582ba388c3e2e0200601a", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -349,6 +349,7 @@ E0623: include_str!(\"./error_codes/E0623.md\"),\n E0624: include_str!(\"./error_codes/E0624.md\"),\n E0626: include_str!(\"./error_codes/E0626.md\"),\n E0627: include_str!(\"./error_codes/E0627.md\"),\n+E0628: include_str!(\"./error_codes/E0628.md\"),\n E0631: include_str!(\"./error_codes/E0631.md\"),\n E0633: include_str!(\"./error_codes/E0633.md\"),\n E0634: include_str!(\"./error_codes/E0634.md\"),\n@@ -583,7 +584,6 @@ E0748: include_str!(\"./error_codes/E0748.md\"),\n //  E0612, // merged into E0609\n //  E0613, // Removed (merged with E0609)\n     E0625, // thread-local statics cannot be accessed at compile-time\n-    E0628, // generators cannot have explicit parameters\n     E0629, // missing 'feature' (rustc_const_unstable)\n     // rustc_const_unstable attribute must be paired with stable/unstable\n     // attribute"}, {"sha": "40040c9a56aacb30d9e6208148e0e8462bbbce72", "filename": "src/librustc_error_codes/error_codes/E0628.md", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_error_codes%2Ferror_codes%2FE0628.md", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_error_codes%2Ferror_codes%2FE0628.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0628.md?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -0,0 +1,30 @@\n+More than one parameter was used for a generator.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0628\n+#![feature(generators, generator_trait)]\n+\n+fn main() {\n+    let generator = |a: i32, b: i32| {\n+        // error: too many parameters for a generator\n+        // Allowed only 0 or 1 parameter\n+        yield a;\n+    };\n+}\n+```\n+\n+At present, it is not permitted to pass more than one explicit\n+parameter for a generator.This can be fixed by using\n+at most 1 parameter for the generator. For example, we might resolve\n+the previous example by passing only one parameter.\n+\n+```\n+#![feature(generators, generator_trait)]\n+\n+fn main() {\n+    let generator = |a: i32| {\n+        yield a;\n+    };\n+}\n+```"}, {"sha": "8c6bfbec902775e8756ac8397c38577a387114d7", "filename": "src/librustc_expand/mbe/macro_check.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_expand%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_expand%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_check.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -419,10 +419,10 @@ fn check_nested_occurrences(\n             | (NestedMacroState::MacroName, &TokenTree::Delimited(_, ref del))\n                 if del.delim == DelimToken::Brace =>\n             {\n-                let legacy = state == NestedMacroState::MacroRulesNotName;\n+                let macro_rules = state == NestedMacroState::MacroRulesNotName;\n                 state = NestedMacroState::Empty;\n                 let rest =\n-                    check_nested_macro(sess, node_id, legacy, &del.tts, &nested_macros, valid);\n+                    check_nested_macro(sess, node_id, macro_rules, &del.tts, &nested_macros, valid);\n                 // If we did not check the whole macro definition, then check the rest as if outside\n                 // the macro definition.\n                 check_nested_occurrences(\n@@ -493,21 +493,21 @@ fn check_nested_occurrences(\n /// Arguments:\n /// - `sess` is used to emit diagnostics and lints\n /// - `node_id` is used to emit lints\n-/// - `legacy` specifies whether the macro is legacy\n+/// - `macro_rules` specifies whether the macro is `macro_rules`\n /// - `tts` is checked as a list of (LHS) => {RHS}\n /// - `macros` is the stack of outer macros\n /// - `valid` is set in case of errors\n fn check_nested_macro(\n     sess: &ParseSess,\n     node_id: NodeId,\n-    legacy: bool,\n+    macro_rules: bool,\n     tts: &[TokenTree],\n     macros: &Stack<'_, MacroState<'_>>,\n     valid: &mut bool,\n ) -> usize {\n     let n = tts.len();\n     let mut i = 0;\n-    let separator = if legacy { TokenKind::Semi } else { TokenKind::Comma };\n+    let separator = if macro_rules { TokenKind::Semi } else { TokenKind::Comma };\n     loop {\n         // We expect 3 token trees: `(LHS) => {RHS}`. The separator is checked after.\n         if i + 2 >= n\n@@ -522,7 +522,7 @@ fn check_nested_macro(\n         let mut binders = Binders::default();\n         check_binders(sess, node_id, lhs, macros, &mut binders, &Stack::Empty, valid);\n         check_occurrences(sess, node_id, rhs, macros, &binders, &Stack::Empty, valid);\n-        // Since the last semicolon is optional for legacy macros and decl_macro are not terminated,\n+        // Since the last semicolon is optional for `macro_rules` macros and decl_macro are not terminated,\n         // we increment our checked position by how many token trees we already checked (the 3\n         // above) before checking for the separator.\n         i += 3;"}, {"sha": "3cad3ff55d91018517d7fd5562922b94870fa12e", "filename": "src/librustc_expand/mbe/macro_rules.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmbe%2Fmacro_rules.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -350,8 +350,8 @@ pub fn compile_declarative_macro(\n     let tt_spec = ast::Ident::new(sym::tt, def.span);\n \n     // Parse the macro_rules! invocation\n-    let (is_legacy, body) = match &def.kind {\n-        ast::ItemKind::MacroDef(macro_def) => (macro_def.legacy, macro_def.body.inner_tokens()),\n+    let (macro_rules, body) = match &def.kind {\n+        ast::ItemKind::MacroDef(def) => (def.macro_rules, def.body.inner_tokens()),\n         _ => unreachable!(),\n     };\n \n@@ -370,7 +370,7 @@ pub fn compile_declarative_macro(\n                     mbe::TokenTree::MetaVarDecl(def.span, rhs_nm, tt_spec),\n                 ],\n                 separator: Some(Token::new(\n-                    if is_legacy { token::Semi } else { token::Comma },\n+                    if macro_rules { token::Semi } else { token::Comma },\n                     def.span,\n                 )),\n                 kleene: mbe::KleeneToken::new(mbe::KleeneOp::OneOrMore, def.span),\n@@ -382,7 +382,7 @@ pub fn compile_declarative_macro(\n             DelimSpan::dummy(),\n             Lrc::new(mbe::SequenceRepetition {\n                 tts: vec![mbe::TokenTree::token(\n-                    if is_legacy { token::Semi } else { token::Comma },\n+                    if macro_rules { token::Semi } else { token::Comma },\n                     def.span,\n                 )],\n                 separator: None,\n@@ -456,7 +456,7 @@ pub fn compile_declarative_macro(\n     // that is not lint-checked and trigger the \"failed to process buffered lint here\" bug.\n     valid &= macro_check::check_meta_variables(sess, ast::CRATE_NODE_ID, def.span, &lhses, &rhses);\n \n-    let (transparency, transparency_error) = attr::find_transparency(&def.attrs, is_legacy);\n+    let (transparency, transparency_error) = attr::find_transparency(&def.attrs, macro_rules);\n     match transparency_error {\n         Some(TransparencyError::UnknownTransparency(value, span)) => {\n             diag.span_err(span, &format!(\"unknown macro transparency: `{}`\", value))"}, {"sha": "0ef35b184e17f3f3cde776a46be9e3fb6c1a59e2", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -79,9 +79,9 @@ impl ParamName {\n         }\n     }\n \n-    pub fn modern(&self) -> ParamName {\n+    pub fn normalize_to_macros_2_0(&self) -> ParamName {\n         match *self {\n-            ParamName::Plain(ident) => ParamName::Plain(ident.modern()),\n+            ParamName::Plain(ident) => ParamName::Plain(ident.normalize_to_macros_2_0()),\n             param_name => param_name,\n         }\n     }\n@@ -151,9 +151,11 @@ impl LifetimeName {\n         self == &LifetimeName::Static\n     }\n \n-    pub fn modern(&self) -> LifetimeName {\n+    pub fn normalize_to_macros_2_0(&self) -> LifetimeName {\n         match *self {\n-            LifetimeName::Param(param_name) => LifetimeName::Param(param_name.modern()),\n+            LifetimeName::Param(param_name) => {\n+                LifetimeName::Param(param_name.normalize_to_macros_2_0())\n+            }\n             lifetime_name => lifetime_name,\n         }\n     }\n@@ -1854,7 +1856,7 @@ pub struct TraitItem<'hir> {\n \n /// Represents a trait method's body (or just argument names).\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n-pub enum TraitMethod<'hir> {\n+pub enum TraitFn<'hir> {\n     /// No default body in the trait, just a signature.\n     Required(&'hir [Ident]),\n \n@@ -1868,7 +1870,7 @@ pub enum TraitItemKind<'hir> {\n     /// An associated constant with an optional value (otherwise `impl`s must contain a value).\n     Const(&'hir Ty<'hir>, Option<BodyId>),\n     /// An associated function with an optional body.\n-    Fn(FnSig<'hir>, TraitMethod<'hir>),\n+    Fn(FnSig<'hir>, TraitFn<'hir>),\n     /// An associated type with (possibly empty) bounds and optional concrete\n     /// type.\n     Type(GenericBounds<'hir>, Option<&'hir Ty<'hir>>),\n@@ -1901,8 +1903,8 @@ pub enum ImplItemKind<'hir> {\n     /// An associated constant of the given type, set to the constant result\n     /// of the expression.\n     Const(&'hir Ty<'hir>, BodyId),\n-    /// A method implementation with the given signature and body.\n-    Method(FnSig<'hir>, BodyId),\n+    /// An associated function implementation with the given signature and body.\n+    Fn(FnSig<'hir>, BodyId),\n     /// An associated type.\n     TyAlias(&'hir Ty<'hir>),\n     /// An associated `type = impl Trait`.\n@@ -1913,7 +1915,7 @@ impl ImplItemKind<'_> {\n     pub fn namespace(&self) -> Namespace {\n         match self {\n             ImplItemKind::OpaqueTy(..) | ImplItemKind::TyAlias(..) => Namespace::TypeNS,\n-            ImplItemKind::Const(..) | ImplItemKind::Method(..) => Namespace::ValueNS,\n+            ImplItemKind::Const(..) | ImplItemKind::Fn(..) => Namespace::ValueNS,\n         }\n     }\n }\n@@ -2704,7 +2706,7 @@ impl Node<'_> {\n     pub fn fn_decl(&self) -> Option<&FnDecl<'_>> {\n         match self {\n             Node::TraitItem(TraitItem { kind: TraitItemKind::Fn(fn_sig, _), .. })\n-            | Node::ImplItem(ImplItem { kind: ImplItemKind::Method(fn_sig, _), .. })\n+            | Node::ImplItem(ImplItem { kind: ImplItemKind::Fn(fn_sig, _), .. })\n             | Node::Item(Item { kind: ItemKind::Fn(fn_sig, _, _), .. }) => Some(fn_sig.decl),\n             Node::ForeignItem(ForeignItem { kind: ForeignItemKind::Fn(fn_decl, _, _), .. }) => {\n                 Some(fn_decl)"}, {"sha": "b13f1a91b03179a99f20244e8acd681ae427d4db", "filename": "src/librustc_hir/intravisit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_hir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_hir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fintravisit.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -911,14 +911,14 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n             visitor.visit_ty(ty);\n             walk_list!(visitor, visit_nested_body, default);\n         }\n-        TraitItemKind::Fn(ref sig, TraitMethod::Required(param_names)) => {\n+        TraitItemKind::Fn(ref sig, TraitFn::Required(param_names)) => {\n             visitor.visit_id(trait_item.hir_id);\n             visitor.visit_fn_decl(&sig.decl);\n             for &param_name in param_names {\n                 visitor.visit_ident(param_name);\n             }\n         }\n-        TraitItemKind::Fn(ref sig, TraitMethod::Provided(body_id)) => {\n+        TraitItemKind::Fn(ref sig, TraitFn::Provided(body_id)) => {\n             visitor.visit_fn(\n                 FnKind::Method(trait_item.ident, sig, None, &trait_item.attrs),\n                 &sig.decl,\n@@ -968,7 +968,7 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n             visitor.visit_ty(ty);\n             visitor.visit_nested_body(body);\n         }\n-        ImplItemKind::Method(ref sig, body_id) => {\n+        ImplItemKind::Fn(ref sig, body_id) => {\n             visitor.visit_fn(\n                 FnKind::Method(impl_item.ident, sig, Some(&impl_item.vis), &impl_item.attrs),\n                 &sig.decl,"}, {"sha": "4e9618b7676e8dcdb03a1cdacf97c62ee999af02", "filename": "src/librustc_hir/print.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_hir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_hir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fprint.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -886,13 +886,13 @@ impl<'a> State<'a> {\n                     Spanned { span: rustc_span::DUMMY_SP, node: hir::VisibilityKind::Inherited };\n                 self.print_associated_const(ti.ident, &ty, default, &vis);\n             }\n-            hir::TraitItemKind::Fn(ref sig, hir::TraitMethod::Required(ref arg_names)) => {\n+            hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Required(ref arg_names)) => {\n                 let vis =\n                     Spanned { span: rustc_span::DUMMY_SP, node: hir::VisibilityKind::Inherited };\n                 self.print_method_sig(ti.ident, sig, &ti.generics, &vis, arg_names, None);\n                 self.s.word(\";\");\n             }\n-            hir::TraitItemKind::Fn(ref sig, hir::TraitMethod::Provided(body)) => {\n+            hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n                 let vis =\n                     Spanned { span: rustc_span::DUMMY_SP, node: hir::VisibilityKind::Inherited };\n                 self.head(\"\");\n@@ -925,7 +925,7 @@ impl<'a> State<'a> {\n             hir::ImplItemKind::Const(ref ty, expr) => {\n                 self.print_associated_const(ii.ident, &ty, Some(expr), &ii.vis);\n             }\n-            hir::ImplItemKind::Method(ref sig, body) => {\n+            hir::ImplItemKind::Fn(ref sig, body) => {\n                 self.head(\"\");\n                 self.print_method_sig(ii.ident, sig, &ii.generics, &ii.vis, &[], Some(body));\n                 self.nbsp();"}, {"sha": "3a4485a1b17fd38ed43b7f431b9d1da7d72377a6", "filename": "src/librustc_hir/target.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_hir%2Ftarget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_hir%2Ftarget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Ftarget.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -105,10 +105,10 @@ impl Target {\n     pub fn from_trait_item(trait_item: &TraitItem<'_>) -> Target {\n         match trait_item.kind {\n             TraitItemKind::Const(..) => Target::AssocConst,\n-            TraitItemKind::Fn(_, hir::TraitMethod::Required(_)) => {\n+            TraitItemKind::Fn(_, hir::TraitFn::Required(_)) => {\n                 Target::Method(MethodKind::Trait { body: false })\n             }\n-            TraitItemKind::Fn(_, hir::TraitMethod::Provided(_)) => {\n+            TraitItemKind::Fn(_, hir::TraitFn::Provided(_)) => {\n                 Target::Method(MethodKind::Trait { body: true })\n             }\n             TraitItemKind::Type(..) => Target::AssocTy,"}, {"sha": "df5fd110db9b691a83ca3d4b0cc8e047bbc8159a", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -333,7 +333,7 @@ impl DirtyCleanVisitor<'tcx> {\n                 TraitItemKind::Type(..) => (\"NodeTraitType\", LABELS_CONST_IN_TRAIT),\n             },\n             HirNode::ImplItem(item) => match item.kind {\n-                ImplItemKind::Method(..) => (\"Node::ImplItem\", LABELS_FN_IN_IMPL),\n+                ImplItemKind::Fn(..) => (\"Node::ImplItem\", LABELS_FN_IN_IMPL),\n                 ImplItemKind::Const(..) => (\"NodeImplConst\", LABELS_CONST_IN_IMPL),\n                 ImplItemKind::TyAlias(..) => (\"NodeImplType\", LABELS_CONST_IN_IMPL),\n                 ImplItemKind::OpaqueTy(..) => (\"NodeImplType\", LABELS_CONST_IN_IMPL),"}, {"sha": "a544381f33da1a74b5941ac82b720fd7737c644d", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -275,7 +275,7 @@ fn trait_item_scope_tag(item: &hir::TraitItem<'_>) -> &'static str {\n \n fn impl_item_scope_tag(item: &hir::ImplItem<'_>) -> &'static str {\n     match item.kind {\n-        hir::ImplItemKind::Method(..) => \"method body\",\n+        hir::ImplItemKind::Fn(..) => \"method body\",\n         hir::ImplItemKind::Const(..)\n         | hir::ImplItemKind::OpaqueTy(..)\n         | hir::ImplItemKind::TyAlias(..) => \"associated item\","}, {"sha": "15acf632b2c9829efab5382a4c753f74d6877966", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -37,7 +37,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                         ..\n                     })\n                     | Node::ImplItem(&hir::ImplItem {\n-                        kind: hir::ImplItemKind::Method(ref m, ..),\n+                        kind: hir::ImplItemKind::Fn(ref m, ..),\n                         ..\n                     }) => &m.decl,\n                     _ => return None,"}, {"sha": "54b8fad3930799de579abba9a1374ab771cc9441", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -486,7 +486,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n \n         let desc = match impl_item.kind {\n             hir::ImplItemKind::Const(..) => \"an associated constant\",\n-            hir::ImplItemKind::Method(..) => \"a method\",\n+            hir::ImplItemKind::Fn(..) => \"a method\",\n             hir::ImplItemKind::TyAlias(_) => \"an associated type\",\n             hir::ImplItemKind::OpaqueTy(_) => \"an associated `impl Trait` type\",\n         };"}, {"sha": "afab55358d93889c33c7dd2639a95b63ea860a1d", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -343,7 +343,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::TraitItem<'_>) {\n-        if let hir::TraitItemKind::Fn(_, hir::TraitMethod::Required(pnames)) = item.kind {\n+        if let hir::TraitItemKind::Fn(_, hir::TraitFn::Required(pnames)) = item.kind {\n             self.check_snake_case(cx, \"trait method\", &item.ident);\n             for param_name in pnames {\n                 self.check_snake_case(cx, \"variable\", param_name);"}, {"sha": "b37e339bab3fc10d999db0bc83267711b12a4043", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -505,7 +505,7 @@ impl EntryKind {\n             EntryKind::Struct(_, _) => DefKind::Struct,\n             EntryKind::Union(_, _) => DefKind::Union,\n             EntryKind::Fn(_) | EntryKind::ForeignFn(_) => DefKind::Fn,\n-            EntryKind::Method(_) => DefKind::AssocFn,\n+            EntryKind::AssocFn(_) => DefKind::AssocFn,\n             EntryKind::Type => DefKind::TyAlias,\n             EntryKind::TypeParam => DefKind::TyParam,\n             EntryKind::ConstParam => DefKind::ConstParam,\n@@ -1067,7 +1067,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n         let (kind, container, has_self) = match self.kind(id) {\n             EntryKind::AssocConst(container, _, _) => (ty::AssocKind::Const, container, false),\n-            EntryKind::Method(data) => {\n+            EntryKind::AssocFn(data) => {\n                 let data = data.decode(self);\n                 (ty::AssocKind::Method, data.container, data.has_self)\n             }\n@@ -1249,7 +1249,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     fn get_fn_param_names(&self, id: DefIndex) -> Vec<ast::Name> {\n         let param_names = match self.kind(id) {\n             EntryKind::Fn(data) | EntryKind::ForeignFn(data) => data.decode(self).param_names,\n-            EntryKind::Method(data) => data.decode(self).fn_data.param_names,\n+            EntryKind::AssocFn(data) => data.decode(self).fn_data.param_names,\n             _ => Lazy::empty(),\n         };\n         param_names.decode(self).collect()\n@@ -1286,7 +1286,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     // don't serialize constness for tuple variant and tuple struct constructors.\n     fn is_const_fn_raw(&self, id: DefIndex) -> bool {\n         let constness = match self.kind(id) {\n-            EntryKind::Method(data) => data.decode(self).fn_data.constness,\n+            EntryKind::AssocFn(data) => data.decode(self).fn_data.constness,\n             EntryKind::Fn(data) => data.decode(self).constness,\n             // Some intrinsics can be const fn. While we could recompute this (at least until we\n             // stop having hardcoded whitelists and move to stability attributes), it seems cleaner\n@@ -1301,7 +1301,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     fn asyncness(&self, id: DefIndex) -> hir::IsAsync {\n         match self.kind(id) {\n             EntryKind::Fn(data) => data.decode(self).asyncness,\n-            EntryKind::Method(data) => data.decode(self).fn_data.asyncness,\n+            EntryKind::AssocFn(data) => data.decode(self).fn_data.asyncness,\n             EntryKind::ForeignFn(data) => data.decode(self).asyncness,\n             _ => bug!(\"asyncness: expected function kind\"),\n         }"}, {"sha": "005bebbe1e2462eda8f5359cec4a3098fa6883bb", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -807,10 +807,10 @@ impl EncodeContext<'tcx> {\n             ty::AssocKind::Method => {\n                 let fn_data = if let hir::TraitItemKind::Fn(m_sig, m) = &ast_item.kind {\n                     let param_names = match *m {\n-                        hir::TraitMethod::Required(ref names) => {\n+                        hir::TraitFn::Required(ref names) => {\n                             self.encode_fn_param_names(names)\n                         }\n-                        hir::TraitMethod::Provided(body) => {\n+                        hir::TraitFn::Provided(body) => {\n                             self.encode_fn_param_names_for_body(body)\n                         }\n                     };\n@@ -822,7 +822,7 @@ impl EncodeContext<'tcx> {\n                 } else {\n                     bug!()\n                 };\n-                EntryKind::Method(self.lazy(MethodData {\n+                EntryKind::AssocFn(self.lazy(AssocFnData {\n                     fn_data,\n                     container,\n                     has_self: trait_item.method_has_self_argument,\n@@ -894,7 +894,7 @@ impl EncodeContext<'tcx> {\n                 }\n             }\n             ty::AssocKind::Method => {\n-                let fn_data = if let hir::ImplItemKind::Method(ref sig, body) = ast_item.kind {\n+                let fn_data = if let hir::ImplItemKind::Fn(ref sig, body) = ast_item.kind {\n                     FnData {\n                         asyncness: sig.header.asyncness,\n                         constness: sig.header.constness,\n@@ -903,7 +903,7 @@ impl EncodeContext<'tcx> {\n                 } else {\n                     bug!()\n                 };\n-                EntryKind::Method(self.lazy(MethodData {\n+                EntryKind::AssocFn(self.lazy(AssocFnData {\n                     fn_data,\n                     container,\n                     has_self: impl_item.method_has_self_argument,\n@@ -928,7 +928,7 @@ impl EncodeContext<'tcx> {\n         self.encode_inferred_outlives(def_id);\n         let mir = match ast_item.kind {\n             hir::ImplItemKind::Const(..) => true,\n-            hir::ImplItemKind::Method(ref sig, _) => {\n+            hir::ImplItemKind::Fn(ref sig, _) => {\n                 let generics = self.tcx.generics_of(def_id);\n                 let needs_inline = (generics.requires_monomorphization(self.tcx)\n                     || tcx.codegen_fn_attrs(def_id).requests_inline())"}, {"sha": "43a1515da32cee0f75b67d4d51acd459604a2967", "filename": "src/librustc_metadata/rmeta/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fmod.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -305,7 +305,7 @@ enum EntryKind {\n     Generator(hir::GeneratorKind),\n     Trait(Lazy<TraitData>),\n     Impl(Lazy<ImplData>),\n-    Method(Lazy<MethodData>),\n+    AssocFn(Lazy<AssocFnData>),\n     AssocType(AssocContainer),\n     AssocOpaqueTy(AssocContainer),\n     AssocConst(AssocContainer, mir::ConstQualifs, Lazy<RenderedConst>),\n@@ -392,7 +392,7 @@ impl AssocContainer {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-struct MethodData {\n+struct AssocFnData {\n     fn_data: FnData,\n     container: AssocContainer,\n     has_self: bool,"}, {"sha": "c462f93414874150d7adc17b628d9759afcbeaf6", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -485,7 +485,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                         }))\n                         | Some(hir::Node::ImplItem(hir::ImplItem {\n                             ident,\n-                            kind: hir::ImplItemKind::Method(sig, _),\n+                            kind: hir::ImplItemKind::Fn(sig, _),\n                             ..\n                         })) => Some(\n                             arg_pos\n@@ -527,7 +527,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 })\n                 | hir::Node::ImplItem(hir::ImplItem {\n                     ident,\n-                    kind: hir::ImplItemKind::Method(sig, _),\n+                    kind: hir::ImplItemKind::Fn(sig, _),\n                     ..\n                 }) => {\n                     err.span_label(ident.span, \"\");"}, {"sha": "7103fc596c92269c4bda1121550c1a41f8e87353", "filename": "src/librustc_mir/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -651,7 +651,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                 if gen_move.is_some() { \" of generator\" } else { \" of closure\" },\n             ),\n             hir::Node::ImplItem(hir::ImplItem {\n-                kind: hir::ImplItemKind::Method(method_sig, _),\n+                kind: hir::ImplItemKind::Fn(method_sig, _),\n                 ..\n             }) => (method_sig.decl.output.span(), \"\"),\n             _ => (self.body.span, \"\"),"}, {"sha": "f56bef031a748b74acc4c228a19fa9b0026bc187", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -983,7 +983,7 @@ impl ItemLikeVisitor<'v> for RootCollector<'_, 'v> {\n \n     fn visit_impl_item(&mut self, ii: &'v hir::ImplItem<'v>) {\n         match ii.kind {\n-            hir::ImplItemKind::Method(hir::FnSig { .. }, _) => {\n+            hir::ImplItemKind::Fn(hir::FnSig { .. }, _) => {\n                 let def_id = self.tcx.hir().local_def_id(ii.hir_id);\n                 self.push_if_root(def_id);\n             }\n@@ -1088,9 +1088,9 @@ fn create_mono_items_for_default_impls<'tcx>(\n                 let param_env = ty::ParamEnv::reveal_all();\n                 let trait_ref = tcx.normalize_erasing_regions(param_env, trait_ref);\n                 let overridden_methods: FxHashSet<_> =\n-                    items.iter().map(|iiref| iiref.ident.modern()).collect();\n+                    items.iter().map(|iiref| iiref.ident.normalize_to_macros_2_0()).collect();\n                 for method in tcx.provided_trait_methods(trait_ref.def_id) {\n-                    if overridden_methods.contains(&method.ident.modern()) {\n+                    if overridden_methods.contains(&method.ident.normalize_to_macros_2_0()) {\n                         continue;\n                     }\n "}, {"sha": "9359ec16533a580f54e26220187a981aa45e154f", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 152, "deletions": 183, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -1,7 +1,9 @@\n-//! A copy of the `Qualif` trait in `qualify_consts.rs` that is suitable for the new validator.\n+//! Structural const qualification.\n+//!\n+//! See the `Qualif` trait for more info.\n \n use rustc::mir::*;\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, AdtDef, Ty};\n use rustc_span::DUMMY_SP;\n \n use super::Item as ConstCx;\n@@ -14,169 +16,44 @@ pub fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> ConstQualifs\n }\n \n /// A \"qualif\"(-ication) is a way to look for something \"bad\" in the MIR that would disqualify some\n-/// code for promotion or prevent it from evaluating at compile time. So `return true` means\n-/// \"I found something bad, no reason to go on searching\". `false` is only returned if we\n-/// definitely cannot find anything bad anywhere.\n+/// code for promotion or prevent it from evaluating at compile time.\n ///\n-/// The default implementations proceed structurally.\n+/// Normally, we would determine what qualifications apply to each type and error when an illegal\n+/// operation is performed on such a type. However, this was found to be too imprecise, especially\n+/// in the presence of `enum`s. If only a single variant of an enum has a certain qualification, we\n+/// needn't reject code unless it actually constructs and operates on the qualifed variant.\n+///\n+/// To accomplish this, const-checking and promotion use a value-based analysis (as opposed to a\n+/// type-based one). Qualifications propagate structurally across variables: If a local (or a\n+/// projection of a local) is assigned a qualifed value, that local itself becomes qualifed.\n pub trait Qualif {\n     /// The name of the file used to debug the dataflow analysis that computes this qualif.\n     const ANALYSIS_NAME: &'static str;\n \n     /// Whether this `Qualif` is cleared when a local is moved from.\n     const IS_CLEARED_ON_MOVE: bool = false;\n \n+    /// Extracts the field of `ConstQualifs` that corresponds to this `Qualif`.\n     fn in_qualifs(qualifs: &ConstQualifs) -> bool;\n \n-    /// Return the qualification that is (conservatively) correct for any value\n-    /// of the type.\n-    fn in_any_value_of_ty(_cx: &ConstCx<'_, 'tcx>, _ty: Ty<'tcx>) -> bool;\n-\n-    fn in_projection_structurally(\n-        cx: &ConstCx<'_, 'tcx>,\n-        per_local: &mut impl FnMut(Local) -> bool,\n-        place: PlaceRef<'tcx>,\n-    ) -> bool {\n-        if let [proj_base @ .., elem] = place.projection {\n-            let base_qualif = Self::in_place(\n-                cx,\n-                per_local,\n-                PlaceRef { local: place.local, projection: proj_base },\n-            );\n-            let qualif = base_qualif\n-                && Self::in_any_value_of_ty(\n-                    cx,\n-                    Place::ty_from(place.local, proj_base, *cx.body, cx.tcx)\n-                        .projection_ty(cx.tcx, elem)\n-                        .ty,\n-                );\n-            match elem {\n-                ProjectionElem::Deref\n-                | ProjectionElem::Subslice { .. }\n-                | ProjectionElem::Field(..)\n-                | ProjectionElem::ConstantIndex { .. }\n-                | ProjectionElem::Downcast(..) => qualif,\n-\n-                ProjectionElem::Index(local) => qualif || per_local(*local),\n-            }\n-        } else {\n-            bug!(\"This should be called if projection is not empty\");\n-        }\n-    }\n-\n-    fn in_projection(\n-        cx: &ConstCx<'_, 'tcx>,\n-        per_local: &mut impl FnMut(Local) -> bool,\n-        place: PlaceRef<'tcx>,\n-    ) -> bool {\n-        Self::in_projection_structurally(cx, per_local, place)\n-    }\n-\n-    fn in_place(\n-        cx: &ConstCx<'_, 'tcx>,\n-        per_local: &mut impl FnMut(Local) -> bool,\n-        place: PlaceRef<'tcx>,\n-    ) -> bool {\n-        match place {\n-            PlaceRef { local, projection: [] } => per_local(local),\n-            PlaceRef { local: _, projection: [.., _] } => Self::in_projection(cx, per_local, place),\n-        }\n-    }\n-\n-    fn in_operand(\n-        cx: &ConstCx<'_, 'tcx>,\n-        per_local: &mut impl FnMut(Local) -> bool,\n-        operand: &Operand<'tcx>,\n-    ) -> bool {\n-        match *operand {\n-            Operand::Copy(ref place) | Operand::Move(ref place) => {\n-                Self::in_place(cx, per_local, place.as_ref())\n-            }\n-\n-            Operand::Constant(ref constant) => {\n-                // Check the qualifs of the value of `const` items.\n-                if let ty::ConstKind::Unevaluated(def_id, _, promoted) = constant.literal.val {\n-                    assert!(promoted.is_none());\n-                    // Don't peek inside trait associated constants.\n-                    if cx.tcx.trait_of_item(def_id).is_none() {\n-                        let qualifs = cx.tcx.at(constant.span).mir_const_qualif(def_id);\n-                        if !Self::in_qualifs(&qualifs) {\n-                            return false;\n-                        }\n-\n-                        // Just in case the type is more specific than\n-                        // the definition, e.g., impl associated const\n-                        // with type parameters, take it into account.\n-                    }\n-                }\n-                // Otherwise use the qualifs of the type.\n-                Self::in_any_value_of_ty(cx, constant.literal.ty)\n-            }\n-        }\n-    }\n-\n-    fn in_rvalue_structurally(\n-        cx: &ConstCx<'_, 'tcx>,\n-        per_local: &mut impl FnMut(Local) -> bool,\n-        rvalue: &Rvalue<'tcx>,\n-    ) -> bool {\n-        match *rvalue {\n-            Rvalue::NullaryOp(..) => false,\n-\n-            Rvalue::Discriminant(ref place) | Rvalue::Len(ref place) => {\n-                Self::in_place(cx, per_local, place.as_ref())\n-            }\n-\n-            Rvalue::Use(ref operand)\n-            | Rvalue::Repeat(ref operand, _)\n-            | Rvalue::UnaryOp(_, ref operand)\n-            | Rvalue::Cast(_, ref operand, _) => Self::in_operand(cx, per_local, operand),\n-\n-            Rvalue::BinaryOp(_, ref lhs, ref rhs)\n-            | Rvalue::CheckedBinaryOp(_, ref lhs, ref rhs) => {\n-                Self::in_operand(cx, per_local, lhs) || Self::in_operand(cx, per_local, rhs)\n-            }\n-\n-            Rvalue::Ref(_, _, ref place) | Rvalue::AddressOf(_, ref place) => {\n-                // Special-case reborrows to be more like a copy of the reference.\n-                if let [proj_base @ .., ProjectionElem::Deref] = place.projection.as_ref() {\n-                    let base_ty = Place::ty_from(place.local, proj_base, *cx.body, cx.tcx).ty;\n-                    if let ty::Ref(..) = base_ty.kind {\n-                        return Self::in_place(\n-                            cx,\n-                            per_local,\n-                            PlaceRef { local: place.local, projection: proj_base },\n-                        );\n-                    }\n-                }\n-\n-                Self::in_place(cx, per_local, place.as_ref())\n-            }\n-\n-            Rvalue::Aggregate(_, ref operands) => {\n-                operands.iter().any(|o| Self::in_operand(cx, per_local, o))\n-            }\n-        }\n-    }\n-\n-    fn in_rvalue(\n-        cx: &ConstCx<'_, 'tcx>,\n-        per_local: &mut impl FnMut(Local) -> bool,\n-        rvalue: &Rvalue<'tcx>,\n-    ) -> bool {\n-        Self::in_rvalue_structurally(cx, per_local, rvalue)\n-    }\n-\n-    fn in_call(\n-        cx: &ConstCx<'_, 'tcx>,\n-        _per_local: &mut impl FnMut(Local) -> bool,\n-        _callee: &Operand<'tcx>,\n-        _args: &[Operand<'tcx>],\n-        return_ty: Ty<'tcx>,\n-    ) -> bool {\n-        // Be conservative about the returned value of a const fn.\n-        Self::in_any_value_of_ty(cx, return_ty)\n-    }\n+    /// Returns `true` if *any* value of the given type could possibly have this `Qualif`.\n+    ///\n+    /// This function determines `Qualif`s when we cannot do a value-based analysis. Since qualif\n+    /// propagation is context-insenstive, this includes function arguments and values returned\n+    /// from a call to another function.\n+    ///\n+    /// It also determines the `Qualif`s for primitive types.\n+    fn in_any_value_of_ty(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> bool;\n+\n+    /// Returns `true` if this `Qualif` is inherent to the given struct or enum.\n+    ///\n+    /// By default, `Qualif`s propagate into ADTs in a structural way: An ADT only becomes\n+    /// qualified if part of it is assigned a value with that `Qualif`. However, some ADTs *always*\n+    /// have a certain `Qualif`, regardless of whether their fields have it. For example, a type\n+    /// with a custom `Drop` impl is inherently `NeedsDrop`.\n+    ///\n+    /// Returning `true` for `in_adt_inherently` but `false` for `in_any_value_of_ty` is unsound.\n+    fn in_adt_inherently(cx: &ConstCx<'_, 'tcx>, adt: &AdtDef) -> bool;\n }\n \n /// Constant containing interior mutability (`UnsafeCell<T>`).\n@@ -197,26 +74,10 @@ impl Qualif for HasMutInterior {\n         !ty.is_freeze(cx.tcx, cx.param_env, DUMMY_SP)\n     }\n \n-    fn in_rvalue(\n-        cx: &ConstCx<'_, 'tcx>,\n-        per_local: &mut impl FnMut(Local) -> bool,\n-        rvalue: &Rvalue<'tcx>,\n-    ) -> bool {\n-        match *rvalue {\n-            Rvalue::Aggregate(ref kind, _) => {\n-                if let AggregateKind::Adt(def, ..) = **kind {\n-                    if Some(def.did) == cx.tcx.lang_items().unsafe_cell_type() {\n-                        let ty = rvalue.ty(*cx.body, cx.tcx);\n-                        assert_eq!(Self::in_any_value_of_ty(cx, ty), true);\n-                        return true;\n-                    }\n-                }\n-            }\n-\n-            _ => {}\n-        }\n-\n-        Self::in_rvalue_structurally(cx, per_local, rvalue)\n+    fn in_adt_inherently(cx: &ConstCx<'_, 'tcx>, adt: &AdtDef) -> bool {\n+        // Exactly one type, `UnsafeCell`, has the `HasMutInterior` qualif inherently.\n+        // It arises structurally for all other types.\n+        Some(adt.did) == cx.tcx.lang_items().unsafe_cell_type()\n     }\n }\n \n@@ -238,19 +99,127 @@ impl Qualif for NeedsDrop {\n         ty.needs_drop(cx.tcx, cx.param_env)\n     }\n \n-    fn in_rvalue(\n-        cx: &ConstCx<'_, 'tcx>,\n-        per_local: &mut impl FnMut(Local) -> bool,\n-        rvalue: &Rvalue<'tcx>,\n-    ) -> bool {\n-        if let Rvalue::Aggregate(ref kind, _) = *rvalue {\n+    fn in_adt_inherently(cx: &ConstCx<'_, 'tcx>, adt: &AdtDef) -> bool {\n+        adt.has_dtor(cx.tcx)\n+    }\n+}\n+\n+// FIXME: Use `mir::visit::Visitor` for the `in_*` functions if/when it supports early return.\n+\n+/// Returns `true` if this `Rvalue` contains qualif `Q`.\n+pub fn in_rvalue<Q, F>(cx: &ConstCx<'_, 'tcx>, in_local: &mut F, rvalue: &Rvalue<'tcx>) -> bool\n+where\n+    Q: Qualif,\n+    F: FnMut(Local) -> bool,\n+{\n+    match rvalue {\n+        Rvalue::NullaryOp(..) => Q::in_any_value_of_ty(cx, rvalue.ty(*cx.body, cx.tcx)),\n+\n+        Rvalue::Discriminant(place) | Rvalue::Len(place) => {\n+            in_place::<Q, _>(cx, in_local, place.as_ref())\n+        }\n+\n+        Rvalue::Use(operand)\n+        | Rvalue::Repeat(operand, _)\n+        | Rvalue::UnaryOp(_, operand)\n+        | Rvalue::Cast(_, operand, _) => in_operand::<Q, _>(cx, in_local, operand),\n+\n+        Rvalue::BinaryOp(_, lhs, rhs) | Rvalue::CheckedBinaryOp(_, lhs, rhs) => {\n+            in_operand::<Q, _>(cx, in_local, lhs) || in_operand::<Q, _>(cx, in_local, rhs)\n+        }\n+\n+        Rvalue::Ref(_, _, place) | Rvalue::AddressOf(_, place) => {\n+            // Special-case reborrows to be more like a copy of the reference.\n+            if let &[ref proj_base @ .., ProjectionElem::Deref] = place.projection.as_ref() {\n+                let base_ty = Place::ty_from(place.local, proj_base, *cx.body, cx.tcx).ty;\n+                if let ty::Ref(..) = base_ty.kind {\n+                    return in_place::<Q, _>(\n+                        cx,\n+                        in_local,\n+                        PlaceRef { local: place.local, projection: proj_base },\n+                    );\n+                }\n+            }\n+\n+            in_place::<Q, _>(cx, in_local, place.as_ref())\n+        }\n+\n+        Rvalue::Aggregate(kind, operands) => {\n+            // Return early if we know that the struct or enum being constructed is always\n+            // qualified.\n             if let AggregateKind::Adt(def, ..) = **kind {\n-                if def.has_dtor(cx.tcx) {\n+                if Q::in_adt_inherently(cx, def) {\n                     return true;\n                 }\n             }\n+\n+            // Otherwise, proceed structurally...\n+            operands.iter().any(|o| in_operand::<Q, _>(cx, in_local, o))\n         }\n+    }\n+}\n \n-        Self::in_rvalue_structurally(cx, per_local, rvalue)\n+/// Returns `true` if this `Place` contains qualif `Q`.\n+pub fn in_place<Q, F>(cx: &ConstCx<'_, 'tcx>, in_local: &mut F, place: PlaceRef<'tcx>) -> bool\n+where\n+    Q: Qualif,\n+    F: FnMut(Local) -> bool,\n+{\n+    let mut projection = place.projection;\n+    while let [ref proj_base @ .., proj_elem] = projection {\n+        match *proj_elem {\n+            ProjectionElem::Index(index) if in_local(index) => return true,\n+\n+            ProjectionElem::Deref\n+            | ProjectionElem::Field(_, _)\n+            | ProjectionElem::ConstantIndex { .. }\n+            | ProjectionElem::Subslice { .. }\n+            | ProjectionElem::Downcast(_, _)\n+            | ProjectionElem::Index(_) => {}\n+        }\n+\n+        let base_ty = Place::ty_from(place.local, proj_base, *cx.body, cx.tcx);\n+        let proj_ty = base_ty.projection_ty(cx.tcx, proj_elem).ty;\n+        if !Q::in_any_value_of_ty(cx, proj_ty) {\n+            return false;\n+        }\n+\n+        projection = proj_base;\n+    }\n+\n+    assert!(projection.is_empty());\n+    in_local(place.local)\n+}\n+\n+/// Returns `true` if this `Operand` contains qualif `Q`.\n+pub fn in_operand<Q, F>(cx: &ConstCx<'_, 'tcx>, in_local: &mut F, operand: &Operand<'tcx>) -> bool\n+where\n+    Q: Qualif,\n+    F: FnMut(Local) -> bool,\n+{\n+    let constant = match operand {\n+        Operand::Copy(place) | Operand::Move(place) => {\n+            return in_place::<Q, _>(cx, in_local, place.as_ref());\n+        }\n+\n+        Operand::Constant(c) => c,\n+    };\n+\n+    // Check the qualifs of the value of `const` items.\n+    if let ty::ConstKind::Unevaluated(def_id, _, promoted) = constant.literal.val {\n+        assert!(promoted.is_none());\n+        // Don't peek inside trait associated constants.\n+        if cx.tcx.trait_of_item(def_id).is_none() {\n+            let qualifs = cx.tcx.at(constant.span).mir_const_qualif(def_id);\n+            if !Q::in_qualifs(&qualifs) {\n+                return false;\n+            }\n+\n+            // Just in case the type is more specific than\n+            // the definition, e.g., impl associated const\n+            // with type parameters, take it into account.\n+        }\n     }\n+    // Otherwise use the qualifs of the type.\n+    Q::in_any_value_of_ty(cx, constant.literal.ty)\n }"}, {"sha": "e42f64b5c7384adaeba81508f28224324cff8486", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -8,7 +8,7 @@ use rustc_index::bit_set::BitSet;\n \n use std::marker::PhantomData;\n \n-use super::{Item, Qualif};\n+use super::{qualifs, Item, Qualif};\n use crate::dataflow::{self as old_dataflow, generic as dataflow};\n \n /// A `Visitor` that propagates qualifs between locals. This defines the transfer function of\n@@ -66,18 +66,15 @@ where\n     fn apply_call_return_effect(\n         &mut self,\n         _block: BasicBlock,\n-        func: &mir::Operand<'tcx>,\n-        args: &[mir::Operand<'tcx>],\n+        _func: &mir::Operand<'tcx>,\n+        _args: &[mir::Operand<'tcx>],\n         return_place: &mir::Place<'tcx>,\n     ) {\n+        // We cannot reason about another function's internals, so use conservative type-based\n+        // qualification for the result of a function call.\n         let return_ty = return_place.ty(*self.item.body, self.item.tcx).ty;\n-        let qualif = Q::in_call(\n-            self.item,\n-            &mut |l| self.qualifs_per_local.contains(l),\n-            func,\n-            args,\n-            return_ty,\n-        );\n+        let qualif = Q::in_any_value_of_ty(self.item, return_ty);\n+\n         if !return_place.is_indirect() {\n             self.assign_qualif_direct(return_place, qualif);\n         }\n@@ -110,7 +107,11 @@ where\n         rvalue: &mir::Rvalue<'tcx>,\n         location: Location,\n     ) {\n-        let qualif = Q::in_rvalue(self.item, &mut |l| self.qualifs_per_local.contains(l), rvalue);\n+        let qualif = qualifs::in_rvalue::<Q, _>(\n+            self.item,\n+            &mut |l| self.qualifs_per_local.contains(l),\n+            rvalue,\n+        );\n         if !place.is_indirect() {\n             self.assign_qualif_direct(place, qualif);\n         }\n@@ -125,8 +126,12 @@ where\n         // here; that occurs in `apply_call_return_effect`.\n \n         if let mir::TerminatorKind::DropAndReplace { value, location: dest, .. } = kind {\n-            let qualif =\n-                Q::in_operand(self.item, &mut |l| self.qualifs_per_local.contains(l), value);\n+            let qualif = qualifs::in_operand::<Q, _>(\n+                self.item,\n+                &mut |l| self.qualifs_per_local.contains(l),\n+                value,\n+            );\n+\n             if !dest.is_indirect() {\n                 self.assign_qualif_direct(dest, qualif);\n             }"}, {"sha": "be461c0e03d8635767f5d007db2f39f5458bf6fa", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -344,7 +344,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n             Rvalue::Ref(_, BorrowKind::Shared, ref place)\n             | Rvalue::Ref(_, BorrowKind::Shallow, ref place)\n             | Rvalue::AddressOf(Mutability::Not, ref place) => {\n-                let borrowed_place_has_mut_interior = HasMutInterior::in_place(\n+                let borrowed_place_has_mut_interior = qualifs::in_place::<HasMutInterior, _>(\n                     &self.item,\n                     &mut |local| self.qualifs.has_mut_interior(local, location),\n                     place.as_ref(),"}, {"sha": "1336206e18626734d8e72090e8cabd217ad5c033", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -407,15 +407,17 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n     // FIXME(eddyb) maybe cache this?\n     fn qualif_local<Q: qualifs::Qualif>(&self, local: Local) -> bool {\n-        let per_local = &mut |l| self.qualif_local::<Q>(l);\n-\n         if let TempState::Defined { location: loc, .. } = self.temps[local] {\n             let num_stmts = self.body[loc.block].statements.len();\n \n             if loc.statement_index < num_stmts {\n                 let statement = &self.body[loc.block].statements[loc.statement_index];\n                 match &statement.kind {\n-                    StatementKind::Assign(box (_, rhs)) => Q::in_rvalue(&self.item, per_local, rhs),\n+                    StatementKind::Assign(box (_, rhs)) => qualifs::in_rvalue::<Q, _>(\n+                        &self.item,\n+                        &mut |l| self.qualif_local::<Q>(l),\n+                        rhs,\n+                    ),\n                     _ => {\n                         span_bug!(\n                             statement.source_info.span,\n@@ -427,9 +429,9 @@ impl<'tcx> Validator<'_, 'tcx> {\n             } else {\n                 let terminator = self.body[loc.block].terminator();\n                 match &terminator.kind {\n-                    TerminatorKind::Call { func, args, .. } => {\n+                    TerminatorKind::Call { .. } => {\n                         let return_ty = self.body.local_decls[local].ty;\n-                        Q::in_call(&self.item, per_local, func, args, return_ty)\n+                        Q::in_any_value_of_ty(&self.item, return_ty)\n                     }\n                     kind => {\n                         span_bug!(terminator.source_info.span, \"{:?} not promotable\", kind);"}, {"sha": "821c4d68c7e8aaa93fa7acfdd5dbf5fbb5970214", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -39,12 +39,12 @@ fn mir_build(tcx: TyCtxt<'_>, def_id: DefId) -> BodyAndCache<'_> {\n             ..\n         })\n         | Node::ImplItem(hir::ImplItem {\n-            kind: hir::ImplItemKind::Method(hir::FnSig { decl, .. }, body_id),\n+            kind: hir::ImplItemKind::Fn(hir::FnSig { decl, .. }, body_id),\n             ..\n         })\n         | Node::TraitItem(hir::TraitItem {\n             kind:\n-                hir::TraitItemKind::Fn(hir::FnSig { decl, .. }, hir::TraitMethod::Provided(body_id)),\n+                hir::TraitItemKind::Fn(hir::FnSig { decl, .. }, hir::TraitFn::Provided(body_id)),\n             ..\n         }) => (*body_id, decl.output.span()),\n         Node::Item(hir::Item { kind: hir::ItemKind::Static(ty, _, body_id), .. })"}, {"sha": "8e52bb16147576046eb8d11b70252243ffa7e57e", "filename": "src/librustc_parse/parser/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 19, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fdiagnostics.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -18,6 +18,7 @@ use rustc_span::{MultiSpan, Span, SpanSnippetError, DUMMY_SP};\n \n use log::{debug, trace};\n use std::mem;\n+use std::path::PathBuf;\n \n const TURBOFISH: &str = \"use `::<...>` instead of `<...>` to specify type arguments\";\n \n@@ -40,29 +41,15 @@ pub(super) fn dummy_arg(ident: Ident) -> Param {\n }\n \n pub enum Error {\n-    FileNotFoundForModule {\n-        mod_name: String,\n-        default_path: String,\n-        secondary_path: String,\n-        dir_path: String,\n-    },\n-    DuplicatePaths {\n-        mod_name: String,\n-        default_path: String,\n-        secondary_path: String,\n-    },\n+    FileNotFoundForModule { mod_name: String, default_path: PathBuf },\n+    DuplicatePaths { mod_name: String, default_path: String, secondary_path: String },\n     UselessDocComment,\n }\n \n impl Error {\n     fn span_err(self, sp: impl Into<MultiSpan>, handler: &Handler) -> DiagnosticBuilder<'_> {\n         match self {\n-            Error::FileNotFoundForModule {\n-                ref mod_name,\n-                ref default_path,\n-                ref secondary_path,\n-                ref dir_path,\n-            } => {\n+            Error::FileNotFoundForModule { ref mod_name, ref default_path } => {\n                 let mut err = struct_span_err!(\n                     handler,\n                     sp,\n@@ -71,8 +58,9 @@ impl Error {\n                     mod_name,\n                 );\n                 err.help(&format!(\n-                    \"name the file either {} or {} inside the directory \\\"{}\\\"\",\n-                    default_path, secondary_path, dir_path,\n+                    \"to create the module `{}`, create file \\\"{}\\\"\",\n+                    mod_name,\n+                    default_path.display(),\n                 ));\n                 err\n             }"}, {"sha": "e927bcd07e2cd2ed1a4465ff2207664cd910e32e", "filename": "src/librustc_parse/parser/item.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_parse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fitem.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -1260,7 +1260,7 @@ impl<'a> Parser<'a> {\n         };\n \n         self.sess.gated_spans.gate(sym::decl_macro, lo.to(self.prev_token.span));\n-        Ok((ident, ItemKind::MacroDef(ast::MacroDef { body, legacy: false })))\n+        Ok((ident, ItemKind::MacroDef(ast::MacroDef { body, macro_rules: false })))\n     }\n \n     /// Is this unambiguously the start of a `macro_rules! foo` item defnition?\n@@ -1270,7 +1270,7 @@ impl<'a> Parser<'a> {\n             && self.look_ahead(2, |t| t.is_ident())\n     }\n \n-    /// Parses a legacy `macro_rules! foo { ... }` declarative macro.\n+    /// Parses a `macro_rules! foo { ... }` declarative macro.\n     fn parse_item_macro_rules(&mut self, vis: &Visibility) -> PResult<'a, ItemInfo> {\n         self.expect_keyword(kw::MacroRules)?; // `macro_rules`\n         self.expect(&token::Not)?; // `!`\n@@ -1280,7 +1280,7 @@ impl<'a> Parser<'a> {\n         self.eat_semi_for_macro_if_needed(&body);\n         self.complain_if_pub_macro(vis, true);\n \n-        Ok((ident, ItemKind::MacroDef(ast::MacroDef { body, legacy: true })))\n+        Ok((ident, ItemKind::MacroDef(ast::MacroDef { body, macro_rules: true })))\n     }\n \n     /// Item macro invocations or `macro_rules!` definitions need inherited visibility."}, {"sha": "7b46601cc7d8026cc492f04fa432d40be511a182", "filename": "src/librustc_parse/parser/module.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_parse%2Fparser%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmodule.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -234,12 +234,9 @@ impl<'a> Parser<'a> {\n                 path: secondary_path,\n                 directory_ownership: DirectoryOwnership::Owned { relative: None },\n             }),\n-            (false, false) => Err(Error::FileNotFoundForModule {\n-                mod_name: mod_name.clone(),\n-                default_path: default_path_str,\n-                secondary_path: secondary_path_str,\n-                dir_path: dir_path.display().to_string(),\n-            }),\n+            (false, false) => {\n+                Err(Error::FileNotFoundForModule { mod_name: mod_name.clone(), default_path })\n+            }\n             (true, true) => Err(Error::DuplicatePaths {\n                 mod_name: mod_name.clone(),\n                 default_path: default_path_str,"}, {"sha": "373b7c56d3802e119d650083e52ad9bda576d1b0", "filename": "src/librustc_passes/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_passes%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_passes%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fcheck_attr.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -25,7 +25,7 @@ use rustc_span::Span;\n fn target_from_impl_item<'tcx>(tcx: TyCtxt<'tcx>, impl_item: &hir::ImplItem<'_>) -> Target {\n     match impl_item.kind {\n         hir::ImplItemKind::Const(..) => Target::AssocConst,\n-        hir::ImplItemKind::Method(..) => {\n+        hir::ImplItemKind::Fn(..) => {\n             let parent_hir_id = tcx.hir().get_parent_item(impl_item.hir_id);\n             let containing_item = tcx.hir().expect_item(parent_hir_id);\n             let containing_impl_is_for_trait = match &containing_item.kind {"}, {"sha": "587b57eb3225cb02385bb686e70b017d40f8603c", "filename": "src/librustc_passes/dead.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_passes%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_passes%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdead.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -391,7 +391,7 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n                     let trait_item = self.krate.trait_item(trait_item_ref.id);\n                     match trait_item.kind {\n                         hir::TraitItemKind::Const(_, Some(_))\n-                        | hir::TraitItemKind::Fn(_, hir::TraitMethod::Provided(_)) => {\n+                        | hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(_)) => {\n                             if has_allow_dead_code_or_lang_attr(\n                                 self.tcx,\n                                 trait_item.hir_id,\n@@ -661,7 +661,7 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n                 }\n                 self.visit_nested_body(body_id)\n             }\n-            hir::ImplItemKind::Method(_, body_id) => {\n+            hir::ImplItemKind::Fn(_, body_id) => {\n                 if !self.symbol_is_live(impl_item.hir_id) {\n                     let span = self.tcx.sess.source_map().def_span(impl_item.span);\n                     self.warn_dead_code(\n@@ -682,11 +682,11 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n         match trait_item.kind {\n             hir::TraitItemKind::Const(_, Some(body_id))\n-            | hir::TraitItemKind::Fn(_, hir::TraitMethod::Provided(body_id)) => {\n+            | hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(body_id)) => {\n                 self.visit_nested_body(body_id)\n             }\n             hir::TraitItemKind::Const(_, None)\n-            | hir::TraitItemKind::Fn(_, hir::TraitMethod::Required(_))\n+            | hir::TraitItemKind::Fn(_, hir::TraitFn::Required(_))\n             | hir::TraitItemKind::Type(..) => {}\n         }\n     }"}, {"sha": "4643add5ac3fdfc638a9fa0d946ea07a4449654b", "filename": "src/librustc_passes/reachable.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_passes%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_passes%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Freachable.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -53,7 +53,7 @@ fn method_might_be_inlined(\n     if codegen_fn_attrs.requests_inline() || generics.requires_monomorphization(tcx) {\n         return true;\n     }\n-    if let hir::ImplItemKind::Method(method_sig, _) = &impl_item.kind {\n+    if let hir::ImplItemKind::Fn(method_sig, _) = &impl_item.kind {\n         if method_sig.header.is_const() {\n             return true;\n         }\n@@ -162,14 +162,14 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             },\n             Some(Node::TraitItem(trait_method)) => match trait_method.kind {\n                 hir::TraitItemKind::Const(_, ref default) => default.is_some(),\n-                hir::TraitItemKind::Fn(_, hir::TraitMethod::Provided(_)) => true,\n-                hir::TraitItemKind::Fn(_, hir::TraitMethod::Required(_))\n+                hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(_)) => true,\n+                hir::TraitItemKind::Fn(_, hir::TraitFn::Required(_))\n                 | hir::TraitItemKind::Type(..) => false,\n             },\n             Some(Node::ImplItem(impl_item)) => {\n                 match impl_item.kind {\n                     hir::ImplItemKind::Const(..) => true,\n-                    hir::ImplItemKind::Method(..) => {\n+                    hir::ImplItemKind::Fn(..) => {\n                         let attrs = self.tcx.codegen_fn_attrs(def_id);\n                         let generics = self.tcx.generics_of(def_id);\n                         if generics.requires_monomorphization(self.tcx) || attrs.requests_inline() {\n@@ -278,11 +278,11 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             Node::TraitItem(trait_method) => {\n                 match trait_method.kind {\n                     hir::TraitItemKind::Const(_, None)\n-                    | hir::TraitItemKind::Fn(_, hir::TraitMethod::Required(_)) => {\n+                    | hir::TraitItemKind::Fn(_, hir::TraitFn::Required(_)) => {\n                         // Keep going, nothing to get exported\n                     }\n                     hir::TraitItemKind::Const(_, Some(body_id))\n-                    | hir::TraitItemKind::Fn(_, hir::TraitMethod::Provided(body_id)) => {\n+                    | hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(body_id)) => {\n                         self.visit_nested_body(body_id);\n                     }\n                     hir::TraitItemKind::Type(..) => {}\n@@ -292,7 +292,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 hir::ImplItemKind::Const(_, body) => {\n                     self.visit_nested_body(body);\n                 }\n-                hir::ImplItemKind::Method(_, body) => {\n+                hir::ImplItemKind::Fn(_, body) => {\n                     let did = self.tcx.hir().get_parent_did(search_item);\n                     if method_might_be_inlined(self.tcx, impl_item, did) {\n                         self.visit_nested_body(body)"}, {"sha": "108a8006409e1b367beab318703fb5ada141232e", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -920,7 +920,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n     }\n \n     fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef<'tcx>) {\n-        if attr::find_transparency(&md.attrs, md.ast.legacy).0 != Transparency::Opaque {\n+        if attr::find_transparency(&md.attrs, md.ast.macro_rules).0 != Transparency::Opaque {\n             self.update(md.hir_id, Some(AccessLevel::Public));\n             return;\n         }\n@@ -1556,7 +1556,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                     || items.iter().any(|impl_item_ref| {\n                         let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                         match impl_item.kind {\n-                            hir::ImplItemKind::Const(..) | hir::ImplItemKind::Method(..) => {\n+                            hir::ImplItemKind::Const(..) | hir::ImplItemKind::Fn(..) => {\n                                 self.access_levels.is_reachable(impl_item_ref.id.hir_id)\n                             }\n                             hir::ImplItemKind::OpaqueTy(..) | hir::ImplItemKind::TyAlias(_) => {\n@@ -1578,8 +1578,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                                 // types in private items.\n                                 let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                                 match impl_item.kind {\n-                                    hir::ImplItemKind::Const(..)\n-                                    | hir::ImplItemKind::Method(..)\n+                                    hir::ImplItemKind::Const(..) | hir::ImplItemKind::Fn(..)\n                                         if self\n                                             .item_is_public(&impl_item.hir_id, &impl_item.vis) =>\n                                     {"}, {"sha": "ce3b1233a74737d94df369fd6caa8ab9c5bad79a", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 34, "deletions": 31, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -7,7 +7,7 @@\n \n use crate::def_collector::collect_definitions;\n use crate::imports::{Import, ImportKind};\n-use crate::macros::{LegacyBinding, LegacyScope};\n+use crate::macros::{MacroRulesBinding, MacroRulesScope};\n use crate::Namespace::{self, MacroNS, TypeNS, ValueNS};\n use crate::{CrateLint, Determinacy, PathResult, ResolutionError, VisResolutionError};\n use crate::{\n@@ -165,11 +165,11 @@ impl<'a> Resolver<'a> {\n         &mut self,\n         fragment: &AstFragment,\n         parent_scope: ParentScope<'a>,\n-    ) -> LegacyScope<'a> {\n+    ) -> MacroRulesScope<'a> {\n         collect_definitions(&mut self.definitions, fragment, parent_scope.expansion);\n         let mut visitor = BuildReducedGraphVisitor { r: self, parent_scope };\n         fragment.visit_with(&mut visitor);\n-        visitor.parent_scope.legacy\n+        visitor.parent_scope.macro_rules\n     }\n \n     crate fn build_reduced_graph_external(&mut self, module: Module<'a>) {\n@@ -624,7 +624,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     self.r.get_module(DefId { krate: crate_id, index: CRATE_DEF_INDEX })\n                 };\n \n-                let used = self.process_legacy_macro_imports(item, module);\n+                let used = self.process_macro_use_imports(item, module);\n                 let binding =\n                     (module, ty::Visibility::Public, sp, expansion).to_name_binding(self.r.arenas);\n                 let import = self.r.arenas.alloc_import(Import {\n@@ -645,7 +645,8 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 self.r.potentially_unused_imports.push(import);\n                 let imported_binding = self.r.import(binding, import);\n                 if ptr::eq(parent, self.r.graph_root) {\n-                    if let Some(entry) = self.r.extern_prelude.get(&ident.modern()) {\n+                    if let Some(entry) = self.r.extern_prelude.get(&ident.normalize_to_macros_2_0())\n+                    {\n                         if expansion != ExpnId::root()\n                             && orig_name.is_some()\n                             && entry.extern_crate_item.is_none()\n@@ -656,10 +657,12 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                         }\n                     }\n                     let entry =\n-                        self.r.extern_prelude.entry(ident.modern()).or_insert(ExternPreludeEntry {\n-                            extern_crate_item: None,\n-                            introduced_by_item: true,\n-                        });\n+                        self.r.extern_prelude.entry(ident.normalize_to_macros_2_0()).or_insert(\n+                            ExternPreludeEntry {\n+                                extern_crate_item: None,\n+                                introduced_by_item: true,\n+                            },\n+                        );\n                     entry.extern_crate_item = Some(imported_binding);\n                     if orig_name.is_some() {\n                         entry.introduced_by_item = true;\n@@ -913,7 +916,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         }\n     }\n \n-    fn legacy_import_macro(\n+    fn add_macro_use_binding(\n         &mut self,\n         name: ast::Name,\n         binding: &'a NameBinding<'a>,\n@@ -929,7 +932,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n     }\n \n     /// Returns `true` if we should consider the underlying `extern crate` to be used.\n-    fn process_legacy_macro_imports(&mut self, item: &Item, module: Module<'a>) -> bool {\n+    fn process_macro_use_imports(&mut self, item: &Item, module: Module<'a>) -> bool {\n         let mut import_all = None;\n         let mut single_imports = Vec::new();\n         for attr in &item.attrs {\n@@ -1004,7 +1007,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n             module.for_each_child(self, |this, ident, ns, binding| {\n                 if ns == MacroNS {\n                     let imported_binding = this.r.import(binding, import);\n-                    this.legacy_import_macro(ident.name, imported_binding, span, allow_shadowing);\n+                    this.add_macro_use_binding(ident.name, imported_binding, span, allow_shadowing);\n                 }\n             });\n         } else {\n@@ -1021,7 +1024,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     let import = macro_use_import(self, ident.span);\n                     self.r.potentially_unused_imports.push(import);\n                     let imported_binding = self.r.import(binding, import);\n-                    self.legacy_import_macro(\n+                    self.add_macro_use_binding(\n                         ident.name,\n                         imported_binding,\n                         ident.span,\n@@ -1060,15 +1063,15 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         false\n     }\n \n-    fn visit_invoc(&mut self, id: NodeId) -> LegacyScope<'a> {\n+    fn visit_invoc(&mut self, id: NodeId) -> MacroRulesScope<'a> {\n         let invoc_id = id.placeholder_to_expn_id();\n \n         self.parent_scope.module.unexpanded_invocations.borrow_mut().insert(invoc_id);\n \n         let old_parent_scope = self.r.invocation_parent_scopes.insert(invoc_id, self.parent_scope);\n         assert!(old_parent_scope.is_none(), \"invocation data is reset for an invocation\");\n \n-        LegacyScope::Invocation(invoc_id)\n+        MacroRulesScope::Invocation(invoc_id)\n     }\n \n     fn proc_macro_stub(item: &ast::Item) -> Option<(MacroKind, Ident, Span)> {\n@@ -1095,20 +1098,20 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         }\n     }\n \n-    fn define_macro(&mut self, item: &ast::Item) -> LegacyScope<'a> {\n+    fn define_macro(&mut self, item: &ast::Item) -> MacroRulesScope<'a> {\n         let parent_scope = self.parent_scope;\n         let expansion = parent_scope.expansion;\n-        let (ext, ident, span, is_legacy) = match &item.kind {\n+        let (ext, ident, span, macro_rules) = match &item.kind {\n             ItemKind::MacroDef(def) => {\n                 let ext = Lrc::new(self.r.compile_macro(item, self.r.session.edition()));\n-                (ext, item.ident, item.span, def.legacy)\n+                (ext, item.ident, item.span, def.macro_rules)\n             }\n             ItemKind::Fn(..) => match Self::proc_macro_stub(item) {\n                 Some((macro_kind, ident, span)) => {\n                     self.r.proc_macro_stubs.insert(item.id);\n                     (self.r.dummy_ext(macro_kind), ident, span, false)\n                 }\n-                None => return parent_scope.legacy,\n+                None => return parent_scope.macro_rules,\n             },\n             _ => unreachable!(),\n         };\n@@ -1118,8 +1121,8 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         self.r.macro_map.insert(def_id, ext);\n         self.r.local_macro_def_scopes.insert(item.id, parent_scope.module);\n \n-        if is_legacy {\n-            let ident = ident.modern();\n+        if macro_rules {\n+            let ident = ident.normalize_to_macros_2_0();\n             self.r.macro_names.insert(ident);\n             let is_macro_export = attr::contains_name(&item.attrs, sym::macro_export);\n             let vis = if is_macro_export {\n@@ -1137,8 +1140,8 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 self.r.check_reserved_macro_name(ident, res);\n                 self.insert_unused_macro(ident, item.id, span);\n             }\n-            LegacyScope::Binding(self.r.arenas.alloc_legacy_binding(LegacyBinding {\n-                parent_legacy_scope: parent_scope.legacy,\n+            MacroRulesScope::Binding(self.r.arenas.alloc_macro_rules_binding(MacroRulesBinding {\n+                parent_macro_rules_scope: parent_scope.macro_rules,\n                 binding,\n                 ident,\n             }))\n@@ -1149,7 +1152,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                 self.insert_unused_macro(ident, item.id, span);\n             }\n             self.r.define(module, ident, MacroNS, (res, vis, span, expansion));\n-            self.parent_scope.legacy\n+            self.parent_scope.macro_rules\n         }\n     }\n }\n@@ -1174,29 +1177,29 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n     fn visit_item(&mut self, item: &'b Item) {\n         let macro_use = match item.kind {\n             ItemKind::MacroDef(..) => {\n-                self.parent_scope.legacy = self.define_macro(item);\n+                self.parent_scope.macro_rules = self.define_macro(item);\n                 return;\n             }\n             ItemKind::MacCall(..) => {\n-                self.parent_scope.legacy = self.visit_invoc(item.id);\n+                self.parent_scope.macro_rules = self.visit_invoc(item.id);\n                 return;\n             }\n             ItemKind::Mod(..) => self.contains_macro_use(&item.attrs),\n             _ => false,\n         };\n         let orig_current_module = self.parent_scope.module;\n-        let orig_current_legacy_scope = self.parent_scope.legacy;\n+        let orig_current_macro_rules_scope = self.parent_scope.macro_rules;\n         self.build_reduced_graph_for_item(item);\n         visit::walk_item(self, item);\n         self.parent_scope.module = orig_current_module;\n         if !macro_use {\n-            self.parent_scope.legacy = orig_current_legacy_scope;\n+            self.parent_scope.macro_rules = orig_current_macro_rules_scope;\n         }\n     }\n \n     fn visit_stmt(&mut self, stmt: &'b ast::Stmt) {\n         if let ast::StmtKind::MacCall(..) = stmt.kind {\n-            self.parent_scope.legacy = self.visit_invoc(stmt.id);\n+            self.parent_scope.macro_rules = self.visit_invoc(stmt.id);\n         } else {\n             visit::walk_stmt(self, stmt);\n         }\n@@ -1214,11 +1217,11 @@ impl<'a, 'b> Visitor<'b> for BuildReducedGraphVisitor<'a, 'b> {\n \n     fn visit_block(&mut self, block: &'b Block) {\n         let orig_current_module = self.parent_scope.module;\n-        let orig_current_legacy_scope = self.parent_scope.legacy;\n+        let orig_current_macro_rules_scope = self.parent_scope.macro_rules;\n         self.build_reduced_graph_for_block(block);\n         visit::walk_block(self, block);\n         self.parent_scope.module = orig_current_module;\n-        self.parent_scope.legacy = orig_current_legacy_scope;\n+        self.parent_scope.macro_rules = orig_current_macro_rules_scope;\n     }\n \n     fn visit_assoc_item(&mut self, item: &'b AssocItem, ctxt: AssocCtxt) {"}, {"sha": "63fbc800ff7067fb280615202ddb4c92f4c2a2c1", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -21,7 +21,9 @@ use rustc_span::{BytePos, MultiSpan, Span};\n use crate::imports::{Import, ImportKind, ImportResolver};\n use crate::path_names_to_string;\n use crate::{AmbiguityError, AmbiguityErrorMisc, AmbiguityKind};\n-use crate::{BindingError, CrateLint, HasGenericParams, LegacyScope, Module, ModuleOrUniformRoot};\n+use crate::{\n+    BindingError, CrateLint, HasGenericParams, MacroRulesScope, Module, ModuleOrUniformRoot,\n+};\n use crate::{NameBinding, NameBindingKind, PrivacyError, VisResolutionError};\n use crate::{ParentScope, PathResult, ResolutionError, Resolver, Scope, ScopeSet, Segment};\n \n@@ -498,12 +500,12 @@ impl<'a> Resolver<'a> {\n                         }\n                     }\n                 }\n-                Scope::MacroRules(legacy_scope) => {\n-                    if let LegacyScope::Binding(legacy_binding) = legacy_scope {\n-                        let res = legacy_binding.binding.res();\n+                Scope::MacroRules(macro_rules_scope) => {\n+                    if let MacroRulesScope::Binding(macro_rules_binding) = macro_rules_scope {\n+                        let res = macro_rules_binding.binding.res();\n                         if filter_fn(res) {\n                             suggestions\n-                                .push(TypoSuggestion::from_res(legacy_binding.ident.name, res))\n+                                .push(TypoSuggestion::from_res(macro_rules_binding.ident.name, res))\n                         }\n                     }\n                 }\n@@ -756,7 +758,7 @@ impl<'a> Resolver<'a> {\n             let msg = format!(\"unsafe traits like `{}` should be implemented explicitly\", ident);\n             err.span_note(ident.span, &msg);\n         }\n-        if self.macro_names.contains(&ident.modern()) {\n+        if self.macro_names.contains(&ident.normalize_to_macros_2_0()) {\n             err.help(\"have you added the `#[macro_use]` on the module/import?\");\n         }\n     }"}, {"sha": "681c039211892e3ee01f214572aa259ab73ac445", "filename": "src/librustc_resolve/imports.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_resolve%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_resolve%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fimports.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -416,7 +416,8 @@ impl<'a> Resolver<'a> {\n                 None => return Err((Undetermined, Weak::Yes)),\n             };\n             let tmp_parent_scope;\n-            let (mut adjusted_parent_scope, mut ident) = (parent_scope, ident.modern());\n+            let (mut adjusted_parent_scope, mut ident) =\n+                (parent_scope, ident.normalize_to_macros_2_0());\n             match ident.span.glob_adjust(module.expansion, glob_import.span) {\n                 Some(Some(def)) => {\n                     tmp_parent_scope ="}, {"sha": "867aa8c63216839d8714821b412589d0e1bb3eaa", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -935,7 +935,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 _ => unreachable!(),\n             };\n \n-            let ident = param.ident.modern();\n+            let ident = param.ident.normalize_to_macros_2_0();\n             debug!(\"with_generic_param_rib: {}\", param.id);\n \n             if seen_bindings.contains_key(&ident) {\n@@ -1464,7 +1464,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         // Add the binding to the local ribs, if it doesn't already exist in the bindings map.\n         // (We must not add it if it's in the bindings map because that breaks the assumptions\n         // later passes make about or-patterns.)\n-        let ident = ident.modern_and_legacy();\n+        let ident = ident.normalize_to_macro_rules();\n \n         let mut bound_iter = bindings.iter().filter(|(_, set)| set.contains(&ident));\n         // Already bound in a product pattern? e.g. `(a, a)` which is not allowed.\n@@ -1873,7 +1873,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 self.diagnostic_metadata.unused_labels.insert(id, label.ident.span);\n             }\n             self.with_label_rib(NormalRibKind, |this| {\n-                let ident = label.ident.modern_and_legacy();\n+                let ident = label.ident.normalize_to_macro_rules();\n                 this.label_ribs.last_mut().unwrap().bindings.insert(ident, id);\n                 f(this);\n             });\n@@ -1949,7 +1949,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n             ExprKind::Break(Some(label), _) | ExprKind::Continue(Some(label)) => {\n                 let node_id = self.search_label(label.ident, |rib, ident| {\n-                    rib.bindings.get(&ident.modern_and_legacy()).cloned()\n+                    rib.bindings.get(&ident.normalize_to_macro_rules()).cloned()\n                 });\n                 match node_id {\n                     None => {\n@@ -2115,7 +2115,7 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             }\n         }\n \n-        ident.span = ident.span.modern();\n+        ident.span = ident.span.normalize_to_macros_2_0();\n         let mut search_module = self.parent_scope.module;\n         loop {\n             self.get_traits_in_module_containing_item(ident, ns, search_module, &mut found_traits);"}, {"sha": "c015841cdc52b3154cc4401fc564efa845abec70", "filename": "src/librustc_resolve/late/lifetimes.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -62,7 +62,7 @@ impl RegionExt for Region {\n         let def_id = hir_map.local_def_id(param.hir_id);\n         let origin = LifetimeDefOrigin::from_param(param);\n         debug!(\"Region::early: index={} def_id={:?}\", i, def_id);\n-        (param.name.modern(), Region::EarlyBound(i, def_id, origin))\n+        (param.name.normalize_to_macros_2_0(), Region::EarlyBound(i, def_id, origin))\n     }\n \n     fn late(hir_map: &Map<'_>, param: &GenericParam<'_>) -> (ParamName, Region) {\n@@ -73,7 +73,7 @@ impl RegionExt for Region {\n             \"Region::late: param={:?} depth={:?} def_id={:?} origin={:?}\",\n             param, depth, def_id, origin,\n         );\n-        (param.name.modern(), Region::LateBound(depth, def_id, origin))\n+        (param.name.normalize_to_macros_2_0(), Region::LateBound(depth, def_id, origin))\n     }\n \n     fn late_anon(index: &Cell<u32>) -> Region {\n@@ -771,7 +771,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         use self::hir::ImplItemKind::*;\n         self.missing_named_lifetime_spots.push((&impl_item.generics).into());\n         match impl_item.kind {\n-            Method(ref sig, _) => {\n+            Fn(ref sig, _) => {\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n                     Some(tcx.hir().get_parent_item(impl_item.hir_id)),\n@@ -1174,7 +1174,9 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body<'_>) {\n \n                 Scope::Binder { ref lifetimes, s, .. } => {\n                     // FIXME (#24278): non-hygienic comparison\n-                    if let Some(def) = lifetimes.get(&hir::ParamName::Plain(label.modern())) {\n+                    if let Some(def) =\n+                        lifetimes.get(&hir::ParamName::Plain(label.normalize_to_macros_2_0()))\n+                    {\n                         let hir_id = tcx.hir().as_local_hir_id(def.id().unwrap()).unwrap();\n \n                         signal_shadowing_problem(\n@@ -1253,7 +1255,7 @@ fn object_lifetime_defaults_for_item(\n     fn add_bounds(set: &mut Set1<hir::LifetimeName>, bounds: &[hir::GenericBound<'_>]) {\n         for bound in bounds {\n             if let hir::GenericBound::Outlives(ref lifetime) = *bound {\n-                set.insert(lifetime.name.modern());\n+                set.insert(lifetime.name.normalize_to_macros_2_0());\n             }\n         }\n     }\n@@ -1466,7 +1468,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         }\n                     }\n                     Node::ImplItem(impl_item) => {\n-                        if let hir::ImplItemKind::Method(sig, _) = &impl_item.kind {\n+                        if let hir::ImplItemKind::Fn(sig, _) = &impl_item.kind {\n                             find_arg_use_span(sig.decl.inputs);\n                         }\n                     }\n@@ -1791,7 +1793,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 Scope::Binder { ref lifetimes, s, .. } => {\n                     match lifetime_ref.name {\n                         LifetimeName::Param(param_name) => {\n-                            if let Some(&def) = lifetimes.get(&param_name.modern()) {\n+                            if let Some(&def) = lifetimes.get(&param_name.normalize_to_macros_2_0())\n+                            {\n                                 break Some(def.shifted(late_depth));\n                             }\n                         }\n@@ -1818,9 +1821,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     | Node::TraitItem(&hir::TraitItem {\n                         kind: hir::TraitItemKind::Fn(..), ..\n                     })\n-                    | Node::ImplItem(&hir::ImplItem {\n-                        kind: hir::ImplItemKind::Method(..), ..\n-                    }) => {\n+                    | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }) => {\n                         let scope = self.tcx.hir().local_def_id(fn_id);\n                         def = Region::Free(scope, def.id().unwrap());\n                     }\n@@ -2100,12 +2101,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         trait_items.iter().find(|ti| ti.id.hir_id == parent).map(|ti| ti.kind);\n                 }\n                 match *m {\n-                    hir::TraitMethod::Required(_) => None,\n-                    hir::TraitMethod::Provided(body) => Some(body),\n+                    hir::TraitFn::Required(_) => None,\n+                    hir::TraitFn::Provided(body) => Some(body),\n                 }\n             }\n \n-            Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Method(_, body), .. }) => {\n+            Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(_, body), .. }) => {\n                 if let hir::ItemKind::Impl { ref self_ty, ref items, .. } =\n                     self.tcx.hir().expect_item(self.tcx.hir().get_parent_item(parent)).kind\n                 {\n@@ -2544,7 +2545,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let lifetimes: Vec<_> = params\n             .iter()\n             .filter_map(|param| match param.kind {\n-                GenericParamKind::Lifetime { .. } => Some((param, param.name.modern())),\n+                GenericParamKind::Lifetime { .. } => {\n+                    Some((param, param.name.normalize_to_macros_2_0()))\n+                }\n                 _ => None,\n             })\n             .collect();\n@@ -2661,7 +2664,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n \n                 Scope::Binder { ref lifetimes, s, .. } => {\n-                    if let Some(&def) = lifetimes.get(&param.name.modern()) {\n+                    if let Some(&def) = lifetimes.get(&param.name.normalize_to_macros_2_0()) {\n                         let hir_id = self.tcx.hir().as_local_hir_id(def.id().unwrap()).unwrap();\n \n                         signal_shadowing_problem(\n@@ -2799,7 +2802,7 @@ fn insert_late_bound_lifetimes(\n                 // `'a: 'b` means both `'a` and `'b` are referenced\n                 appears_in_where_clause\n                     .regions\n-                    .insert(hir::LifetimeName::Param(param.name.modern()));\n+                    .insert(hir::LifetimeName::Param(param.name.normalize_to_macros_2_0()));\n             }\n         }\n     }\n@@ -2821,7 +2824,7 @@ fn insert_late_bound_lifetimes(\n             hir::GenericParamKind::Type { .. } | hir::GenericParamKind::Const { .. } => continue,\n         }\n \n-        let lt_name = hir::LifetimeName::Param(param.name.modern());\n+        let lt_name = hir::LifetimeName::Param(param.name.normalize_to_macros_2_0());\n         // appears in the where clauses? early-bound.\n         if appears_in_where_clause.regions.contains(&lt_name) {\n             continue;\n@@ -2885,7 +2888,7 @@ fn insert_late_bound_lifetimes(\n         }\n \n         fn visit_lifetime(&mut self, lifetime_ref: &'v hir::Lifetime) {\n-            self.regions.insert(lifetime_ref.name.modern());\n+            self.regions.insert(lifetime_ref.name.normalize_to_macros_2_0());\n         }\n     }\n \n@@ -2902,7 +2905,7 @@ fn insert_late_bound_lifetimes(\n         }\n \n         fn visit_lifetime(&mut self, lifetime_ref: &'v hir::Lifetime) {\n-            self.regions.insert(lifetime_ref.name.modern());\n+            self.regions.insert(lifetime_ref.name.normalize_to_macros_2_0());\n         }\n     }\n }"}, {"sha": "05d0f2064503364118d708552a2373385b85fc37", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 64, "deletions": 52, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -58,7 +58,7 @@ use diagnostics::{extend_span_to_previous_binding, find_span_of_binding_until_ne\n use diagnostics::{ImportSuggestion, Suggestion};\n use imports::{Import, ImportKind, ImportResolver, NameResolution};\n use late::{HasGenericParams, PathSource, Rib, RibKind::*};\n-use macros::{LegacyBinding, LegacyScope};\n+use macros::{MacroRulesBinding, MacroRulesScope};\n \n type Res = def::Res<NodeId>;\n \n@@ -94,7 +94,7 @@ impl Determinacy {\n enum Scope<'a> {\n     DeriveHelpers(ExpnId),\n     DeriveHelpersCompat,\n-    MacroRules(LegacyScope<'a>),\n+    MacroRules(MacroRulesScope<'a>),\n     CrateRoot,\n     Module(Module<'a>),\n     RegisteredAttrs,\n@@ -127,15 +127,20 @@ enum ScopeSet {\n pub struct ParentScope<'a> {\n     module: Module<'a>,\n     expansion: ExpnId,\n-    legacy: LegacyScope<'a>,\n+    macro_rules: MacroRulesScope<'a>,\n     derives: &'a [ast::Path],\n }\n \n impl<'a> ParentScope<'a> {\n     /// Creates a parent scope with the passed argument used as the module scope component,\n     /// and other scope components set to default empty values.\n     pub fn module(module: Module<'a>) -> ParentScope<'a> {\n-        ParentScope { module, expansion: ExpnId::root(), legacy: LegacyScope::Empty, derives: &[] }\n+        ParentScope {\n+            module,\n+            expansion: ExpnId::root(),\n+            macro_rules: MacroRulesScope::Empty,\n+            derives: &[],\n+        }\n     }\n }\n \n@@ -419,7 +424,7 @@ impl ModuleKind {\n /// program) if all but one of them come from glob imports.\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n struct BindingKey {\n-    /// The identifier for the binding, aways the `modern` version of the\n+    /// The identifier for the binding, aways the `normalize_to_macros_2_0` version of the\n     /// identifier.\n     ident: Ident,\n     ns: Namespace,\n@@ -613,7 +618,7 @@ enum AmbiguityKind {\n     Import,\n     BuiltinAttr,\n     DeriveHelper,\n-    LegacyVsModern,\n+    MacroRulesVsModularized,\n     GlobVsOuter,\n     GlobVsGlob,\n     GlobVsExpanded,\n@@ -626,7 +631,9 @@ impl AmbiguityKind {\n             AmbiguityKind::Import => \"name vs any other name during import resolution\",\n             AmbiguityKind::BuiltinAttr => \"built-in attribute vs any other name\",\n             AmbiguityKind::DeriveHelper => \"derive helper attribute vs any other name\",\n-            AmbiguityKind::LegacyVsModern => \"`macro_rules` vs non-`macro_rules` from other module\",\n+            AmbiguityKind::MacroRulesVsModularized => {\n+                \"`macro_rules` vs non-`macro_rules` from other module\"\n+            }\n             AmbiguityKind::GlobVsOuter => {\n                 \"glob import vs any other name from outer scope during import/macro resolution\"\n             }\n@@ -930,9 +937,9 @@ pub struct Resolver<'a> {\n     /// Parent scopes in which the macros were invoked.\n     /// FIXME: `derives` are missing in these parent scopes and need to be taken from elsewhere.\n     invocation_parent_scopes: FxHashMap<ExpnId, ParentScope<'a>>,\n-    /// Legacy scopes *produced* by expanding the macro invocations,\n+    /// `macro_rules` scopes *produced* by expanding the macro invocations,\n     /// include all the `macro_rules` items and other invocations generated by them.\n-    output_legacy_scopes: FxHashMap<ExpnId, LegacyScope<'a>>,\n+    output_macro_rules_scopes: FxHashMap<ExpnId, MacroRulesScope<'a>>,\n     /// Helper attributes that are in scope for the given expansion.\n     helper_attrs: FxHashMap<ExpnId, Vec<Ident>>,\n \n@@ -965,7 +972,7 @@ pub struct ResolverArenas<'a> {\n     name_bindings: arena::TypedArena<NameBinding<'a>>,\n     imports: arena::TypedArena<Import<'a>>,\n     name_resolutions: arena::TypedArena<RefCell<NameResolution<'a>>>,\n-    legacy_bindings: arena::TypedArena<LegacyBinding<'a>>,\n+    macro_rules_bindings: arena::TypedArena<MacroRulesBinding<'a>>,\n     ast_paths: arena::TypedArena<ast::Path>,\n }\n \n@@ -989,8 +996,11 @@ impl<'a> ResolverArenas<'a> {\n     fn alloc_name_resolution(&'a self) -> &'a RefCell<NameResolution<'a>> {\n         self.name_resolutions.alloc(Default::default())\n     }\n-    fn alloc_legacy_binding(&'a self, binding: LegacyBinding<'a>) -> &'a LegacyBinding<'a> {\n-        self.legacy_bindings.alloc(binding)\n+    fn alloc_macro_rules_binding(\n+        &'a self,\n+        binding: MacroRulesBinding<'a>,\n+    ) -> &'a MacroRulesBinding<'a> {\n+        self.macro_rules_bindings.alloc(binding)\n     }\n     fn alloc_ast_paths(&'a self, paths: &[ast::Path]) -> &'a [ast::Path] {\n         self.ast_paths.alloc_from_iter(paths.iter().cloned())\n@@ -1210,7 +1220,7 @@ impl<'a> Resolver<'a> {\n             dummy_ext_derive: Lrc::new(SyntaxExtension::dummy_derive(session.edition())),\n             non_macro_attrs: [non_macro_attr(false), non_macro_attr(true)],\n             invocation_parent_scopes,\n-            output_legacy_scopes: Default::default(),\n+            output_macro_rules_scopes: Default::default(),\n             helper_attrs: Default::default(),\n             macro_defs,\n             local_macro_def_scopes: FxHashMap::default(),\n@@ -1352,7 +1362,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn new_key(&mut self, ident: Ident, ns: Namespace) -> BindingKey {\n-        let ident = ident.modern();\n+        let ident = ident.normalize_to_macros_2_0();\n         let disambiguator = if ident.name == kw::Underscore {\n             self.underscore_disambiguator += 1;\n             self.underscore_disambiguator\n@@ -1403,7 +1413,7 @@ impl<'a> Resolver<'a> {\n             // Avoid marking `extern crate` items that refer to a name from extern prelude,\n             // but not introduce it, as used if they are accessed from lexical scope.\n             if is_lexical_scope {\n-                if let Some(entry) = self.extern_prelude.get(&ident.modern()) {\n+                if let Some(entry) = self.extern_prelude.get(&ident.normalize_to_macros_2_0()) {\n                     if let Some(crate_item) = entry.extern_crate_item {\n                         if ptr::eq(used_binding, crate_item) && !entry.introduced_by_item {\n                             return;\n@@ -1465,7 +1475,7 @@ impl<'a> Resolver<'a> {\n         //    derives (you need to resolve the derive first to add helpers into scope), but they\n         //    should be available before the derive is expanded for compatibility.\n         //    It's mess in general, so we are being conservative for now.\n-        // 1-3. `macro_rules` (open, not controlled), loop through legacy scopes. Have higher\n+        // 1-3. `macro_rules` (open, not controlled), loop through `macro_rules` scopes. Have higher\n         //    priority than prelude macros, but create ambiguities with macros in modules.\n         // 1-3. Names in modules (both normal `mod`ules and blocks), loop through hygienic parents\n         //    (open, not controlled). Have higher priority than prelude macros, but create\n@@ -1490,7 +1500,7 @@ impl<'a> Resolver<'a> {\n             TypeNS | ValueNS => Scope::Module(module),\n             MacroNS => Scope::DeriveHelpers(parent_scope.expansion),\n         };\n-        let mut ident = ident.modern();\n+        let mut ident = ident.normalize_to_macros_2_0();\n         let mut use_prelude = !module.no_implicit_prelude;\n \n         loop {\n@@ -1530,16 +1540,18 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n                 Scope::DeriveHelpers(..) => Scope::DeriveHelpersCompat,\n-                Scope::DeriveHelpersCompat => Scope::MacroRules(parent_scope.legacy),\n-                Scope::MacroRules(legacy_scope) => match legacy_scope {\n-                    LegacyScope::Binding(binding) => Scope::MacroRules(binding.parent_legacy_scope),\n-                    LegacyScope::Invocation(invoc_id) => Scope::MacroRules(\n-                        self.output_legacy_scopes\n+                Scope::DeriveHelpersCompat => Scope::MacroRules(parent_scope.macro_rules),\n+                Scope::MacroRules(macro_rules_scope) => match macro_rules_scope {\n+                    MacroRulesScope::Binding(binding) => {\n+                        Scope::MacroRules(binding.parent_macro_rules_scope)\n+                    }\n+                    MacroRulesScope::Invocation(invoc_id) => Scope::MacroRules(\n+                        self.output_macro_rules_scopes\n                             .get(&invoc_id)\n                             .cloned()\n-                            .unwrap_or(self.invocation_parent_scopes[&invoc_id].legacy),\n+                            .unwrap_or(self.invocation_parent_scopes[&invoc_id].macro_rules),\n                     ),\n-                    LegacyScope::Empty => Scope::Module(module),\n+                    MacroRulesScope::Empty => Scope::Module(module),\n                 },\n                 Scope::CrateRoot => match ns {\n                     TypeNS => {\n@@ -1610,27 +1622,27 @@ impl<'a> Resolver<'a> {\n         if ident.name == kw::Invalid {\n             return Some(LexicalScopeBinding::Res(Res::Err));\n         }\n-        let (general_span, modern_span) = if ident.name == kw::SelfUpper {\n+        let (general_span, normalized_span) = if ident.name == kw::SelfUpper {\n             // FIXME(jseyfried) improve `Self` hygiene\n             let empty_span = ident.span.with_ctxt(SyntaxContext::root());\n             (empty_span, empty_span)\n         } else if ns == TypeNS {\n-            let modern_span = ident.span.modern();\n-            (modern_span, modern_span)\n+            let normalized_span = ident.span.normalize_to_macros_2_0();\n+            (normalized_span, normalized_span)\n         } else {\n-            (ident.span.modern_and_legacy(), ident.span.modern())\n+            (ident.span.normalize_to_macro_rules(), ident.span.normalize_to_macros_2_0())\n         };\n         ident.span = general_span;\n-        let modern_ident = Ident { span: modern_span, ..ident };\n+        let normalized_ident = Ident { span: normalized_span, ..ident };\n \n         // Walk backwards up the ribs in scope.\n         let record_used = record_used_id.is_some();\n         let mut module = self.graph_root;\n         for i in (0..ribs.len()).rev() {\n             debug!(\"walk rib\\n{:?}\", ribs[i].bindings);\n             // Use the rib kind to determine whether we are resolving parameters\n-            // (modern hygiene) or local variables (legacy hygiene).\n-            let rib_ident = if ribs[i].kind.contains_params() { modern_ident } else { ident };\n+            // (macro 2.0 hygiene) or local variables (`macro_rules` hygiene).\n+            let rib_ident = if ribs[i].kind.contains_params() { normalized_ident } else { ident };\n             if let Some(res) = ribs[i].bindings.get(&rib_ident).cloned() {\n                 // The ident resolves to a type parameter or local variable.\n                 return Some(LexicalScopeBinding::Res(self.validate_res_from_ribs(\n@@ -1673,7 +1685,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        ident = modern_ident;\n+        ident = normalized_ident;\n         let mut poisoned = None;\n         loop {\n             let opt_module = if let Some(node_id) = record_used_id {\n@@ -1842,14 +1854,14 @@ impl<'a> Resolver<'a> {\n         let mut adjusted_parent_scope = parent_scope;\n         match module {\n             ModuleOrUniformRoot::Module(m) => {\n-                if let Some(def) = ident.span.modernize_and_adjust(m.expansion) {\n+                if let Some(def) = ident.span.normalize_to_macros_2_0_and_adjust(m.expansion) {\n                     tmp_parent_scope =\n                         ParentScope { module: self.macro_def_scope(def), ..*parent_scope };\n                     adjusted_parent_scope = &tmp_parent_scope;\n                 }\n             }\n             ModuleOrUniformRoot::ExternPrelude => {\n-                ident.span.modernize_and_adjust(ExpnId::root());\n+                ident.span.normalize_to_macros_2_0_and_adjust(ExpnId::root());\n             }\n             ModuleOrUniformRoot::CrateRootAndExternPrelude | ModuleOrUniformRoot::CurrentScope => {\n                 // No adjustments\n@@ -1872,14 +1884,14 @@ impl<'a> Resolver<'a> {\n         let mark = if ident.name == kw::DollarCrate {\n             // When resolving `$crate` from a `macro_rules!` invoked in a `macro`,\n             // we don't want to pretend that the `macro_rules!` definition is in the `macro`\n-            // as described in `SyntaxContext::apply_mark`, so we ignore prepended modern marks.\n+            // as described in `SyntaxContext::apply_mark`, so we ignore prepended opaque marks.\n             // FIXME: This is only a guess and it doesn't work correctly for `macro_rules!`\n             // definitions actually produced by `macro` and `macro` definitions produced by\n             // `macro_rules!`, but at least such configurations are not stable yet.\n-            ctxt = ctxt.modern_and_legacy();\n+            ctxt = ctxt.normalize_to_macro_rules();\n             let mut iter = ctxt.marks().into_iter().rev().peekable();\n             let mut result = None;\n-            // Find the last modern mark from the end if it exists.\n+            // Find the last opaque mark from the end if it exists.\n             while let Some(&(mark, transparency)) = iter.peek() {\n                 if transparency == Transparency::Opaque {\n                     result = Some(mark);\n@@ -1888,7 +1900,7 @@ impl<'a> Resolver<'a> {\n                     break;\n                 }\n             }\n-            // Then find the last legacy mark from the end if it exists.\n+            // Then find the last semi-transparent mark from the end if it exists.\n             for (mark, transparency) in iter {\n                 if transparency == Transparency::SemiTransparent {\n                     result = Some(mark);\n@@ -1898,7 +1910,7 @@ impl<'a> Resolver<'a> {\n             }\n             result\n         } else {\n-            ctxt = ctxt.modern();\n+            ctxt = ctxt.normalize_to_macros_2_0();\n             ctxt.adjust(ExpnId::root())\n         };\n         let module = match mark {\n@@ -1910,7 +1922,7 @@ impl<'a> Resolver<'a> {\n \n     fn resolve_self(&mut self, ctxt: &mut SyntaxContext, module: Module<'a>) -> Module<'a> {\n         let mut module = self.get_module(module.normal_ancestor_id);\n-        while module.span.ctxt().modern() != *ctxt {\n+        while module.span.ctxt().normalize_to_macros_2_0() != *ctxt {\n             let parent = module.parent.unwrap_or_else(|| self.macro_def_scope(ctxt.remove_mark()));\n             module = self.get_module(parent.normal_ancestor_id);\n         }\n@@ -1978,7 +1990,7 @@ impl<'a> Resolver<'a> {\n \n             if ns == TypeNS {\n                 if allow_super && name == kw::Super {\n-                    let mut ctxt = ident.span.ctxt().modern();\n+                    let mut ctxt = ident.span.ctxt().normalize_to_macros_2_0();\n                     let self_module = match i {\n                         0 => Some(self.resolve_self(&mut ctxt, parent_scope.module)),\n                         _ => match module {\n@@ -2004,7 +2016,7 @@ impl<'a> Resolver<'a> {\n                 }\n                 if i == 0 {\n                     if name == kw::SelfLower {\n-                        let mut ctxt = ident.span.ctxt().modern();\n+                        let mut ctxt = ident.span.ctxt().normalize_to_macros_2_0();\n                         module = Some(ModuleOrUniformRoot::Module(\n                             self.resolve_self(&mut ctxt, parent_scope.module),\n                         ));\n@@ -2413,21 +2425,21 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n-    fn disambiguate_legacy_vs_modern(\n+    fn disambiguate_macro_rules_vs_modularized(\n         &self,\n-        legacy: &'a NameBinding<'a>,\n-        modern: &'a NameBinding<'a>,\n+        macro_rules: &'a NameBinding<'a>,\n+        modularized: &'a NameBinding<'a>,\n     ) -> bool {\n-        // Some non-controversial subset of ambiguities \"modern macro name\" vs \"macro_rules\"\n+        // Some non-controversial subset of ambiguities \"modularized macro name\" vs \"macro_rules\"\n         // is disambiguated to mitigate regressions from macro modularization.\n         // Scoping for `macro_rules` behaves like scoping for `let` at module level, in general.\n         match (\n-            self.binding_parent_modules.get(&PtrKey(legacy)),\n-            self.binding_parent_modules.get(&PtrKey(modern)),\n+            self.binding_parent_modules.get(&PtrKey(macro_rules)),\n+            self.binding_parent_modules.get(&PtrKey(modularized)),\n         ) {\n-            (Some(legacy), Some(modern)) => {\n-                legacy.normal_ancestor_id == modern.normal_ancestor_id\n-                    && modern.is_ancestor_of(legacy)\n+            (Some(macro_rules), Some(modularized)) => {\n+                macro_rules.normal_ancestor_id == modularized.normal_ancestor_id\n+                    && modularized.is_ancestor_of(macro_rules)\n             }\n             _ => false,\n         }\n@@ -2757,7 +2769,7 @@ impl<'a> Resolver<'a> {\n             // Make sure `self`, `super` etc produce an error when passed to here.\n             return None;\n         }\n-        self.extern_prelude.get(&ident.modern()).cloned().and_then(|entry| {\n+        self.extern_prelude.get(&ident.normalize_to_macros_2_0()).cloned().and_then(|entry| {\n             if let Some(binding) = entry.extern_crate_item {\n                 if !speculative && entry.introduced_by_item {\n                     self.record_use(ident, TypeNS, binding, false);"}, {"sha": "058ead95f50bd7494f790cbb85aac3c7f8893909", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -33,26 +33,26 @@ use std::{mem, ptr};\n type Res = def::Res<NodeId>;\n \n /// Binding produced by a `macro_rules` item.\n-/// Not modularized, can shadow previous legacy bindings, etc.\n+/// Not modularized, can shadow previous `macro_rules` bindings, etc.\n #[derive(Debug)]\n-pub struct LegacyBinding<'a> {\n+pub struct MacroRulesBinding<'a> {\n     crate binding: &'a NameBinding<'a>,\n-    /// Legacy scope into which the `macro_rules` item was planted.\n-    crate parent_legacy_scope: LegacyScope<'a>,\n+    /// `macro_rules` scope into which the `macro_rules` item was planted.\n+    crate parent_macro_rules_scope: MacroRulesScope<'a>,\n     crate ident: Ident,\n }\n \n /// The scope introduced by a `macro_rules!` macro.\n /// This starts at the macro's definition and ends at the end of the macro's parent\n /// module (named or unnamed), or even further if it escapes with `#[macro_use]`.\n-/// Some macro invocations need to introduce legacy scopes too because they\n+/// Some macro invocations need to introduce `macro_rules` scopes too because they\n /// can potentially expand into macro definitions.\n #[derive(Copy, Clone, Debug)]\n-pub enum LegacyScope<'a> {\n+pub enum MacroRulesScope<'a> {\n     /// Empty \"root\" scope at the crate start containing no names.\n     Empty,\n     /// The scope introduced by a `macro_rules!` macro definition.\n-    Binding(&'a LegacyBinding<'a>),\n+    Binding(&'a MacroRulesBinding<'a>),\n     /// The scope introduced by a macro invocation that can potentially\n     /// create a `macro_rules!` macro definition.\n     Invocation(ExpnId),\n@@ -159,8 +159,8 @@ impl<'a> base::Resolver for Resolver<'a> {\n         // Integrate the new AST fragment into all the definition and module structures.\n         // We are inside the `expansion` now, but other parent scope components are still the same.\n         let parent_scope = ParentScope { expansion, ..self.invocation_parent_scopes[&expansion] };\n-        let output_legacy_scope = self.build_reduced_graph(fragment, parent_scope);\n-        self.output_legacy_scopes.insert(expansion, output_legacy_scope);\n+        let output_macro_rules_scope = self.build_reduced_graph(fragment, parent_scope);\n+        self.output_macro_rules_scopes.insert(expansion, output_macro_rules_scope);\n \n         parent_scope.module.unexpanded_invocations.borrow_mut().remove(&expansion);\n     }\n@@ -258,7 +258,13 @@ impl<'a> base::Resolver for Resolver<'a> {\n                             force,\n                         ) {\n                             Ok((Some(ext), _)) => {\n-                                let span = path.segments.last().unwrap().ident.span.modern();\n+                                let span = path\n+                                    .segments\n+                                    .last()\n+                                    .unwrap()\n+                                    .ident\n+                                    .span\n+                                    .normalize_to_macros_2_0();\n                                 helper_attrs.extend(\n                                     ext.helper_attrs.iter().map(|name| Ident::new(*name, span)),\n                                 );\n@@ -608,12 +614,14 @@ impl<'a> Resolver<'a> {\n                         }\n                         result\n                     }\n-                    Scope::MacroRules(legacy_scope) => match legacy_scope {\n-                        LegacyScope::Binding(legacy_binding) if ident == legacy_binding.ident => {\n-                            Ok((legacy_binding.binding, Flags::MACRO_RULES))\n+                    Scope::MacroRules(macro_rules_scope) => match macro_rules_scope {\n+                        MacroRulesScope::Binding(macro_rules_binding)\n+                            if ident == macro_rules_binding.ident =>\n+                        {\n+                            Ok((macro_rules_binding.binding, Flags::MACRO_RULES))\n                         }\n-                        LegacyScope::Invocation(invoc_id)\n-                            if !this.output_legacy_scopes.contains_key(&invoc_id) =>\n+                        MacroRulesScope::Invocation(invoc_id)\n+                            if !this.output_macro_rules_scopes.contains_key(&invoc_id) =>\n                         {\n                             Err(Determinacy::Undetermined)\n                         }\n@@ -759,16 +767,18 @@ impl<'a> Resolver<'a> {\n                                     Some(AmbiguityKind::DeriveHelper)\n                                 } else if innermost_flags.contains(Flags::MACRO_RULES)\n                                     && flags.contains(Flags::MODULE)\n-                                    && !this\n-                                        .disambiguate_legacy_vs_modern(innermost_binding, binding)\n+                                    && !this.disambiguate_macro_rules_vs_modularized(\n+                                        innermost_binding,\n+                                        binding,\n+                                    )\n                                     || flags.contains(Flags::MACRO_RULES)\n                                         && innermost_flags.contains(Flags::MODULE)\n-                                        && !this.disambiguate_legacy_vs_modern(\n+                                        && !this.disambiguate_macro_rules_vs_modularized(\n                                             binding,\n                                             innermost_binding,\n                                         )\n                                 {\n-                                    Some(AmbiguityKind::LegacyVsModern)\n+                                    Some(AmbiguityKind::MacroRulesVsModularized)\n                                 } else if innermost_binding.is_glob_import() {\n                                     Some(AmbiguityKind::GlobVsOuter)\n                                 } else if innermost_binding"}, {"sha": "e073d735a1225a3db7194125b30ebca7ac2533c6", "filename": "src/librustc_span/hygiene.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_span%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_span%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fhygiene.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -201,11 +201,11 @@ impl HygieneData {\n         true\n     }\n \n-    fn modern(&self, ctxt: SyntaxContext) -> SyntaxContext {\n+    fn normalize_to_macros_2_0(&self, ctxt: SyntaxContext) -> SyntaxContext {\n         self.syntax_context_data[ctxt.0 as usize].opaque\n     }\n \n-    fn modern_and_legacy(&self, ctxt: SyntaxContext) -> SyntaxContext {\n+    fn normalize_to_macro_rules(&self, ctxt: SyntaxContext) -> SyntaxContext {\n         self.syntax_context_data[ctxt.0 as usize].opaque_and_semitransparent\n     }\n \n@@ -266,9 +266,9 @@ impl HygieneData {\n \n         let call_site_ctxt = self.expn_data(expn_id).call_site.ctxt();\n         let mut call_site_ctxt = if transparency == Transparency::SemiTransparent {\n-            self.modern(call_site_ctxt)\n+            self.normalize_to_macros_2_0(call_site_ctxt)\n         } else {\n-            self.modern_and_legacy(call_site_ctxt)\n+            self.normalize_to_macro_rules(call_site_ctxt)\n         };\n \n         if call_site_ctxt == SyntaxContext::root() {\n@@ -491,10 +491,10 @@ impl SyntaxContext {\n         HygieneData::with(|data| data.adjust(self, expn_id))\n     }\n \n-    /// Like `SyntaxContext::adjust`, but also modernizes `self`.\n-    pub fn modernize_and_adjust(&mut self, expn_id: ExpnId) -> Option<ExpnId> {\n+    /// Like `SyntaxContext::adjust`, but also normalizes `self` to macros 2.0.\n+    pub fn normalize_to_macros_2_0_and_adjust(&mut self, expn_id: ExpnId) -> Option<ExpnId> {\n         HygieneData::with(|data| {\n-            *self = data.modern(*self);\n+            *self = data.normalize_to_macros_2_0(*self);\n             data.adjust(self, expn_id)\n         })\n     }\n@@ -527,7 +527,7 @@ impl SyntaxContext {\n     pub fn glob_adjust(&mut self, expn_id: ExpnId, glob_span: Span) -> Option<Option<ExpnId>> {\n         HygieneData::with(|data| {\n             let mut scope = None;\n-            let mut glob_ctxt = data.modern(glob_span.ctxt());\n+            let mut glob_ctxt = data.normalize_to_macros_2_0(glob_span.ctxt());\n             while !data.is_descendant_of(expn_id, data.outer_expn(glob_ctxt)) {\n                 scope = Some(data.remove_mark(&mut glob_ctxt).0);\n                 if data.remove_mark(self).0 != scope.unwrap() {\n@@ -558,7 +558,7 @@ impl SyntaxContext {\n                 return None;\n             }\n \n-            let mut glob_ctxt = data.modern(glob_span.ctxt());\n+            let mut glob_ctxt = data.normalize_to_macros_2_0(glob_span.ctxt());\n             let mut marks = Vec::new();\n             while !data.is_descendant_of(expn_id, data.outer_expn(glob_ctxt)) {\n                 marks.push(data.remove_mark(&mut glob_ctxt));\n@@ -574,20 +574,20 @@ impl SyntaxContext {\n \n     pub fn hygienic_eq(self, other: SyntaxContext, expn_id: ExpnId) -> bool {\n         HygieneData::with(|data| {\n-            let mut self_modern = data.modern(self);\n-            data.adjust(&mut self_modern, expn_id);\n-            self_modern == data.modern(other)\n+            let mut self_normalized = data.normalize_to_macros_2_0(self);\n+            data.adjust(&mut self_normalized, expn_id);\n+            self_normalized == data.normalize_to_macros_2_0(other)\n         })\n     }\n \n     #[inline]\n-    pub fn modern(self) -> SyntaxContext {\n-        HygieneData::with(|data| data.modern(self))\n+    pub fn normalize_to_macros_2_0(self) -> SyntaxContext {\n+        HygieneData::with(|data| data.normalize_to_macros_2_0(self))\n     }\n \n     #[inline]\n-    pub fn modern_and_legacy(self) -> SyntaxContext {\n-        HygieneData::with(|data| data.modern_and_legacy(self))\n+    pub fn normalize_to_macro_rules(self) -> SyntaxContext {\n+        HygieneData::with(|data| data.normalize_to_macro_rules(self))\n     }\n \n     #[inline]"}, {"sha": "caa50e9a41c0c0998c3c31e4518fbd295d313e38", "filename": "src/librustc_span/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_span%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_span%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Flib.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -548,9 +548,9 @@ impl Span {\n     }\n \n     #[inline]\n-    pub fn modernize_and_adjust(&mut self, expn_id: ExpnId) -> Option<ExpnId> {\n+    pub fn normalize_to_macros_2_0_and_adjust(&mut self, expn_id: ExpnId) -> Option<ExpnId> {\n         let mut span = self.data();\n-        let mark = span.ctxt.modernize_and_adjust(expn_id);\n+        let mark = span.ctxt.normalize_to_macros_2_0_and_adjust(expn_id);\n         *self = Span::new(span.lo, span.hi, span.ctxt);\n         mark\n     }\n@@ -576,15 +576,15 @@ impl Span {\n     }\n \n     #[inline]\n-    pub fn modern(self) -> Span {\n+    pub fn normalize_to_macros_2_0(self) -> Span {\n         let span = self.data();\n-        span.with_ctxt(span.ctxt.modern())\n+        span.with_ctxt(span.ctxt.normalize_to_macros_2_0())\n     }\n \n     #[inline]\n-    pub fn modern_and_legacy(self) -> Span {\n+    pub fn normalize_to_macro_rules(self) -> Span {\n         let span = self.data();\n-        span.with_ctxt(span.ctxt.modern_and_legacy())\n+        span.with_ctxt(span.ctxt.normalize_to_macro_rules())\n     }\n }\n "}, {"sha": "5760e1d004e038734d200bc76f8e32716d1663dd", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -853,21 +853,21 @@ impl Ident {\n     }\n \n     /// \"Normalize\" ident for use in comparisons using \"item hygiene\".\n-    /// Identifiers with same string value become same if they came from the same \"modern\" macro\n+    /// Identifiers with same string value become same if they came from the same macro 2.0 macro\n     /// (e.g., `macro` item, but not `macro_rules` item) and stay different if they came from\n-    /// different \"modern\" macros.\n+    /// different macro 2.0 macros.\n     /// Technically, this operation strips all non-opaque marks from ident's syntactic context.\n-    pub fn modern(self) -> Ident {\n-        Ident::new(self.name, self.span.modern())\n+    pub fn normalize_to_macros_2_0(self) -> Ident {\n+        Ident::new(self.name, self.span.normalize_to_macros_2_0())\n     }\n \n     /// \"Normalize\" ident for use in comparisons using \"local variable hygiene\".\n     /// Identifiers with same string value become same if they came from the same non-transparent\n     /// macro (e.g., `macro` or `macro_rules!` items) and stay different if they came from different\n     /// non-transparent macros.\n     /// Technically, this operation strips all transparent marks from ident's syntactic context.\n-    pub fn modern_and_legacy(self) -> Ident {\n-        Ident::new(self.name, self.span.modern_and_legacy())\n+    pub fn normalize_to_macro_rules(self) -> Ident {\n+        Ident::new(self.name, self.span.normalize_to_macro_rules())\n     }\n \n     /// Convert the name to a `SymbolStr`. This is a slowish operation because"}, {"sha": "46654a4e8b4aee3dad073e5b46fac4e220676f70", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -715,7 +715,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             Node::Item(&hir::Item { span, kind: hir::ItemKind::Fn(ref sig, ..), .. })\n             | Node::ImplItem(&hir::ImplItem {\n                 span,\n-                kind: hir::ImplItemKind::Method(ref sig, _),\n+                kind: hir::ImplItemKind::Fn(ref sig, _),\n                 ..\n             })\n             | Node::TraitItem(&hir::TraitItem {"}, {"sha": "3d0dd73f03c184be9bc7bbabf05fecd2449cd85a", "filename": "src/librustc_trait_selection/traits/error_reporting/on_unimplemented.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fon_unimplemented.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -90,11 +90,11 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 })\n             }\n             hir::Node::TraitItem(hir::TraitItem {\n-                kind: hir::TraitItemKind::Fn(_, hir::TraitMethod::Provided(body_id)),\n+                kind: hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(body_id)),\n                 ..\n             }) => self.describe_generator(*body_id).or_else(|| Some(\"a trait method\")),\n             hir::Node::ImplItem(hir::ImplItem {\n-                kind: hir::ImplItemKind::Method(sig, body_id),\n+                kind: hir::ImplItemKind::Fn(sig, body_id),\n                 ..\n             }) => self.describe_generator(*body_id).or_else(|| {\n                 Some(if let hir::FnHeader { asyncness: hir::IsAsync::Async, .. } = sig.header {"}, {"sha": "6fe6d7aab2832bdb492f8a48d2876cfbedf15929", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -203,7 +203,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 })\n                 | hir::Node::ImplItem(hir::ImplItem {\n                     generics,\n-                    kind: hir::ImplItemKind::Method(..),\n+                    kind: hir::ImplItemKind::Fn(..),\n                     ..\n                 })\n                 | hir::Node::Item(hir::Item {"}, {"sha": "69d0bd09296877743026aa2868f3b6051cf3410d", "filename": "src/librustc_traits/lowering/environment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering%2Fenvironment.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -190,7 +190,7 @@ crate fn environment(tcx: TyCtxt<'_>, def_id: DefId) -> Environment<'_> {\n         },\n \n         Node::ImplItem(item) => match item.kind {\n-            ImplItemKind::Method(..) => NodeKind::Fn,\n+            ImplItemKind::Fn(..) => NodeKind::Fn,\n             _ => NodeKind::Other,\n         },\n "}, {"sha": "b273efa78276d562903069caed48745f304c7919", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -1441,12 +1441,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let (assoc_ident, def_scope) =\n             tcx.adjust_ident_and_get_scope(binding.item_name, candidate.def_id(), hir_ref_id);\n \n-        // We have already adjusted the item name above, so compare with `ident.modern()` instead\n+        // We have already adjusted the item name above, so compare with `ident.normalize_to_macros_2_0()` instead\n         // of calling `filter_by_name_and_kind`.\n         let assoc_ty = tcx\n             .associated_items(candidate.def_id())\n             .filter_by_name_unhygienic(assoc_ident.name)\n-            .find(|i| i.kind == ty::AssocKind::Type && i.ident.modern() == assoc_ident)\n+            .find(|i| {\n+                i.kind == ty::AssocKind::Type && i.ident.normalize_to_macros_2_0() == assoc_ident\n+            })\n             .expect(\"missing associated type\");\n \n         if !assoc_ty.vis.is_accessible_from(def_scope, tcx) {\n@@ -2298,12 +2300,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let (assoc_ident, def_scope) =\n             tcx.adjust_ident_and_get_scope(assoc_ident, trait_did, hir_ref_id);\n \n-        // We have already adjusted the item name above, so compare with `ident.modern()` instead\n+        // We have already adjusted the item name above, so compare with `ident.normalize_to_macros_2_0()` instead\n         // of calling `filter_by_name_and_kind`.\n         let item = tcx\n             .associated_items(trait_did)\n             .in_definition_order()\n-            .find(|i| i.kind.namespace() == Namespace::TypeNS && i.ident.modern() == assoc_ident)\n+            .find(|i| {\n+                i.kind.namespace() == Namespace::TypeNS\n+                    && i.ident.normalize_to_macros_2_0() == assoc_ident\n+            })\n             .expect(\"missing associated type\");\n \n         let ty = self.projected_ty_from_poly_trait_ref(span, item.def_id, assoc_segment, bound);"}, {"sha": "779b87f6623750191db3c980927169598f442d1d", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -403,7 +403,7 @@ fn extract_spans_for_error_reporting<'a, 'tcx>(\n     let tcx = infcx.tcx;\n     let impl_m_hir_id = tcx.hir().as_local_hir_id(impl_m.def_id).unwrap();\n     let (impl_m_output, impl_m_iter) = match tcx.hir().expect_impl_item(impl_m_hir_id).kind {\n-        ImplItemKind::Method(ref impl_m_sig, _) => {\n+        ImplItemKind::Fn(ref impl_m_sig, _) => {\n             (&impl_m_sig.decl.output, impl_m_sig.decl.inputs.iter())\n         }\n         _ => bug!(\"{:?} is not a method\", impl_m),\n@@ -732,7 +732,7 @@ fn compare_number_of_method_arguments<'tcx>(\n         };\n         let impl_m_hir_id = tcx.hir().as_local_hir_id(impl_m.def_id).unwrap();\n         let impl_span = match tcx.hir().expect_impl_item(impl_m_hir_id).kind {\n-            ImplItemKind::Method(ref impl_m_sig, _) => {\n+            ImplItemKind::Fn(ref impl_m_sig, _) => {\n                 let pos = if impl_number_args > 0 { impl_number_args - 1 } else { 0 };\n                 if let Some(arg) = impl_m_sig.decl.inputs.get(pos) {\n                     if pos == 0 {\n@@ -873,7 +873,7 @@ fn compare_synthetic_generics<'tcx>(\n                         let impl_m = tcx.hir().as_local_hir_id(impl_m.def_id)?;\n                         let impl_m = tcx.hir().impl_item(hir::ImplItemId { hir_id: impl_m });\n                         let input_tys = match impl_m.kind {\n-                            hir::ImplItemKind::Method(ref sig, _) => sig.decl.inputs,\n+                            hir::ImplItemKind::Fn(ref sig, _) => sig.decl.inputs,\n                             _ => unreachable!(),\n                         };\n                         struct Visitor(Option<Span>, hir::def_id::DefId);"}, {"sha": "4531d93c01d27404331ae9000b96f91b55cb45c5", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -1203,7 +1203,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .fields\n             .iter()\n             .enumerate()\n-            .map(|(i, field)| (field.ident.modern(), (i, field)))\n+            .map(|(i, field)| (field.ident.normalize_to_macros_2_0(), (i, field)))\n             .collect::<FxHashMap<_, _>>();\n \n         let mut seen_fields = FxHashMap::default();\n@@ -1469,7 +1469,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let (ident, def_scope) =\n                         self.tcx.adjust_ident_and_get_scope(field, base_def.did, self.body_id);\n                     let fields = &base_def.non_enum_variant().fields;\n-                    if let Some(index) = fields.iter().position(|f| f.ident.modern() == ident) {\n+                    if let Some(index) =\n+                        fields.iter().position(|f| f.ident.normalize_to_macros_2_0() == ident)\n+                    {\n                         let field = &fields[index];\n                         let field_ty = self.field_ty(expr.span, field, substs);\n                         // Save the index of all fields regardless of their visibility in case"}, {"sha": "3eb3624a296658f8386cb4cbb74d6865164d1ac1", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -939,10 +939,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 })) = id.map(|id| self.tcx.hir().get(id))\n                                 {\n                                     let self_first_arg = match method {\n-                                        hir::TraitMethod::Required([ident, ..]) => {\n+                                        hir::TraitFn::Required([ident, ..]) => {\n                                             ident.name == kw::SelfLower\n                                         }\n-                                        hir::TraitMethod::Provided(body_id) => {\n+                                        hir::TraitFn::Provided(body_id) => {\n                                             match &self.tcx.hir().body(*body_id).params[..] {\n                                                 [hir::Param {\n                                                     pat:"}, {"sha": "55e395afad911a526b8787d3626b1f57cea0b245", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -816,14 +816,14 @@ fn primary_body_of(\n         },\n         Node::TraitItem(item) => match item.kind {\n             hir::TraitItemKind::Const(ref ty, Some(body)) => Some((body, Some(ty), None, None)),\n-            hir::TraitItemKind::Fn(ref sig, hir::TraitMethod::Provided(body)) => {\n+            hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n                 Some((body, None, Some(&sig.header), Some(&sig.decl)))\n             }\n             _ => None,\n         },\n         Node::ImplItem(item) => match item.kind {\n             hir::ImplItemKind::Const(ref ty, body) => Some((body, Some(ty), None, None)),\n-            hir::ImplItemKind::Method(ref sig, body) => {\n+            hir::ImplItemKind::Fn(ref sig, body) => {\n                 Some((body, None, Some(&sig.header), Some(&sig.decl)))\n             }\n             _ => None,\n@@ -1896,7 +1896,7 @@ fn check_specialization_validity<'tcx>(\n ) {\n     let kind = match impl_item.kind {\n         hir::ImplItemKind::Const(..) => ty::AssocKind::Const,\n-        hir::ImplItemKind::Method(..) => ty::AssocKind::Method,\n+        hir::ImplItemKind::Fn(..) => ty::AssocKind::Method,\n         hir::ImplItemKind::OpaqueTy(..) => ty::AssocKind::OpaqueTy,\n         hir::ImplItemKind::TyAlias(_) => ty::AssocKind::Type,\n     };\n@@ -2019,7 +2019,7 @@ fn check_impl_items_against_trait<'tcx>(\n                         err.emit()\n                     }\n                 }\n-                hir::ImplItemKind::Method(..) => {\n+                hir::ImplItemKind::Fn(..) => {\n                     let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n                     if ty_trait_item.kind == ty::AssocKind::Method {\n                         compare_impl_method(\n@@ -4738,9 +4738,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let node = self.tcx.hir().get(self.tcx.hir().get_parent_item(id));\n         match node {\n             Node::Item(&hir::Item { kind: hir::ItemKind::Fn(_, _, body_id), .. })\n-            | Node::ImplItem(&hir::ImplItem {\n-                kind: hir::ImplItemKind::Method(_, body_id), ..\n-            }) => {\n+            | Node::ImplItem(&hir::ImplItem { kind: hir::ImplItemKind::Fn(_, body_id), .. }) => {\n                 let body = self.tcx.hir().body(body_id);\n                 if let ExprKind::Block(block, _) = &body.value.kind {\n                     return Some(block.span);\n@@ -4779,7 +4777,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }) => Some((&sig.decl, ident, true)),\n             Node::ImplItem(&hir::ImplItem {\n                 ident,\n-                kind: hir::ImplItemKind::Method(ref sig, ..),\n+                kind: hir::ImplItemKind::Fn(ref sig, ..),\n                 ..\n             }) => Some((&sig.decl, ident, false)),\n             _ => None,\n@@ -4864,11 +4862,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             match hir.get_if_local(def_id) {\n                 Some(Node::Item(hir::Item { kind: ItemKind::Fn(.., body_id), .. }))\n                 | Some(Node::ImplItem(hir::ImplItem {\n-                    kind: hir::ImplItemKind::Method(_, body_id),\n+                    kind: hir::ImplItemKind::Fn(_, body_id),\n                     ..\n                 }))\n                 | Some(Node::TraitItem(hir::TraitItem {\n-                    kind: hir::TraitItemKind::Fn(.., hir::TraitMethod::Provided(body_id)),\n+                    kind: hir::TraitItemKind::Fn(.., hir::TraitFn::Provided(body_id)),\n                     ..\n                 })) => {\n                     let body = hir.body(*body_id);\n@@ -4939,7 +4937,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         .join(\", \")\n                 }\n                 Some(Node::TraitItem(hir::TraitItem {\n-                    kind: hir::TraitItemKind::Fn(.., hir::TraitMethod::Required(idents)),\n+                    kind: hir::TraitItemKind::Fn(.., hir::TraitFn::Required(idents)),\n                     ..\n                 })) => {\n                     sugg_call = idents"}, {"sha": "0f3884de84e1282048189a45a90147d4487439bd", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -1023,7 +1023,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .fields\n             .iter()\n             .enumerate()\n-            .map(|(i, field)| (field.ident.modern(), (i, field)))\n+            .map(|(i, field)| (field.ident.normalize_to_macros_2_0(), (i, field)))\n             .collect::<FxHashMap<_, _>>();\n \n         // Keep track of which fields have already appeared in the pattern.\n@@ -1064,7 +1064,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let mut unmentioned_fields = variant\n             .fields\n             .iter()\n-            .map(|field| field.ident.modern())\n+            .map(|field| field.ident.normalize_to_macros_2_0())\n             .filter(|ident| !used_fields.contains_key(&ident))\n             .collect::<Vec<_>>();\n "}, {"sha": "23826c845091ff6a24f5f43ebab59d4f28cd783a", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -248,7 +248,7 @@ pub fn check_impl_item(tcx: TyCtxt<'_>, def_id: DefId) {\n     let impl_item = tcx.hir().expect_impl_item(hir_id);\n \n     let method_sig = match impl_item.kind {\n-        hir::ImplItemKind::Method(ref sig, _) => Some(sig),\n+        hir::ImplItemKind::Fn(ref sig, _) => Some(sig),\n         _ => None,\n     };\n "}, {"sha": "7513759c76b015ffe8675b757592cb26655b93a8", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -26,7 +26,8 @@ impl InherentOverlapChecker<'tcx> {\n             let collision = impl_items2.filter_by_name_unhygienic(item1.ident.name).any(|item2| {\n                 // Symbols and namespace match, compare hygienically.\n                 item1.kind.namespace() == item2.kind.namespace()\n-                    && item1.ident.modern() == item2.ident.modern()\n+                    && item1.ident.normalize_to_macros_2_0()\n+                        == item2.ident.normalize_to_macros_2_0()\n             });\n \n             if collision {\n@@ -50,11 +51,12 @@ impl InherentOverlapChecker<'tcx> {\n             let collision = impl_items2.filter_by_name_unhygienic(item1.ident.name).find(|item2| {\n                 // Symbols and namespace match, compare hygienically.\n                 item1.kind.namespace() == item2.kind.namespace()\n-                    && item1.ident.modern() == item2.ident.modern()\n+                    && item1.ident.normalize_to_macros_2_0()\n+                        == item2.ident.normalize_to_macros_2_0()\n             });\n \n             if let Some(item2) = collision {\n-                let name = item1.ident.modern();\n+                let name = item1.ident.normalize_to_macros_2_0();\n                 let mut err = struct_span_err!(\n                     self.tcx.sess,\n                     self.tcx.span_of_impl(item1.def_id).unwrap(),"}, {"sha": "1ee344db1dd680ccb9df4a5595e9ee155ba13164", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -745,7 +745,7 @@ fn convert_impl_item(tcx: TyCtxt<'_>, impl_item_id: hir::HirId) {\n     tcx.predicates_of(def_id);\n     let impl_item = tcx.hir().expect_impl_item(impl_item_id);\n     match impl_item.kind {\n-        hir::ImplItemKind::Method(..) => {\n+        hir::ImplItemKind::Fn(..) => {\n             tcx.fn_sig(def_id);\n         }\n         hir::ImplItemKind::TyAlias(_) | hir::ImplItemKind::OpaqueTy(_) => {\n@@ -828,7 +828,7 @@ fn convert_variant(\n         .iter()\n         .map(|f| {\n             let fid = tcx.hir().local_def_id(f.hir_id);\n-            let dup_span = seen_fields.get(&f.ident.modern()).cloned();\n+            let dup_span = seen_fields.get(&f.ident.normalize_to_macros_2_0()).cloned();\n             if let Some(prev_span) = dup_span {\n                 struct_span_err!(\n                     tcx.sess,\n@@ -841,7 +841,7 @@ fn convert_variant(\n                 .span_label(prev_span, format!(\"`{}` first declared here\", f.ident))\n                 .emit();\n             } else {\n-                seen_fields.insert(f.ident.modern(), f.span);\n+                seen_fields.insert(f.ident.normalize_to_macros_2_0(), f.span);\n             }\n \n             ty::FieldDef {\n@@ -1127,7 +1127,7 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n             _ => None,\n         },\n         Node::ImplItem(item) => match item.kind {\n-            hir::ImplItemKind::Method(ref sig, _) => {\n+            hir::ImplItemKind::Fn(ref sig, _) => {\n                 has_late_bound_regions(tcx, &item.generics, &sig.decl)\n             }\n             _ => None,\n@@ -1437,12 +1437,12 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n \n     match tcx.hir().get(hir_id) {\n         TraitItem(hir::TraitItem {\n-            kind: TraitItemKind::Fn(sig, TraitMethod::Provided(_)),\n+            kind: TraitItemKind::Fn(sig, TraitFn::Provided(_)),\n             ident,\n             generics,\n             ..\n         })\n-        | ImplItem(hir::ImplItem { kind: ImplItemKind::Method(sig, _), ident, generics, .. })\n+        | ImplItem(hir::ImplItem { kind: ImplItemKind::Fn(sig, _), ident, generics, .. })\n         | Item(hir::Item { kind: ItemKind::Fn(sig, generics, _), ident, .. }) => {\n             match get_infer_ret_ty(&sig.decl.output) {\n                 Some(ty) => {"}, {"sha": "c5d3d276721ffff5f8a4588cb01d2c901408b2e1", "filename": "src/librustc_typeck/collect/type_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -47,7 +47,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n         },\n \n         Node::ImplItem(item) => match item.kind {\n-            ImplItemKind::Method(..) => {\n+            ImplItemKind::Fn(..) => {\n                 let substs = InternalSubsts::identity_for_item(tcx, def_id);\n                 tcx.mk_fn_def(def_id, substs)\n             }"}, {"sha": "5fb510d6e33df6d46318da38f69905b785472597", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -227,7 +227,7 @@ fn enforce_impl_items_are_distinct(tcx: TyCtxt<'_>, impl_item_refs: &[hir::ImplI\n             hir::ImplItemKind::TyAlias(_) => &mut seen_type_items,\n             _ => &mut seen_value_items,\n         };\n-        match seen_items.entry(impl_item.ident.modern()) {\n+        match seen_items.entry(impl_item.ident.normalize_to_macros_2_0()) {\n             Occupied(entry) => {\n                 let mut err = struct_span_err!(\n                     tcx.sess,"}, {"sha": "54f84272ae8e03830e5b496f7403ea5c24339611", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -111,7 +111,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &hir::ImplItem<'_>) {\n-        if let hir::ImplItemKind::Method(..) = impl_item.kind {\n+        if let hir::ImplItemKind::Fn(..) = impl_item.kind {\n             self.visit_node_helper(impl_item.hir_id);\n         }\n     }"}, {"sha": "3cbb42bb5f30984a2904d05a9f061b62c4434ef5", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -60,7 +60,7 @@ fn variances_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[ty::Variance] {\n         },\n \n         Node::ImplItem(item) => match item.kind {\n-            hir::ImplItemKind::Method(..) => {}\n+            hir::ImplItemKind::Fn(..) => {}\n \n             _ => unsupported(),\n         },"}, {"sha": "7e6ec96b379d8924249bac47ab6c36f05ed7ebb4", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -170,7 +170,7 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &hir::ImplItem<'_>) {\n-        if let hir::ImplItemKind::Method(..) = impl_item.kind {\n+        if let hir::ImplItemKind::Fn(..) = impl_item.kind {\n             self.add_inferreds_for_item(impl_item.hir_id);\n         }\n     }"}, {"sha": "c4ad4554a00488cd174a5c7b44bccb7721a9a493", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -1084,10 +1084,10 @@ impl Clean<Item> for hir::TraitItem<'_> {\n             hir::TraitItemKind::Const(ref ty, default) => {\n                 AssocConstItem(ty.clean(cx), default.map(|e| print_const_expr(cx, e)))\n             }\n-            hir::TraitItemKind::Fn(ref sig, hir::TraitMethod::Provided(body)) => {\n+            hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(body)) => {\n                 MethodItem((sig, &self.generics, body, None).clean(cx))\n             }\n-            hir::TraitItemKind::Fn(ref sig, hir::TraitMethod::Required(ref names)) => {\n+            hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Required(ref names)) => {\n                 let (generics, decl) = enter_impl_trait(cx, || {\n                     (self.generics.clean(cx), (&*sig.decl, &names[..]).clean(cx))\n                 });\n@@ -1118,7 +1118,7 @@ impl Clean<Item> for hir::ImplItem<'_> {\n             hir::ImplItemKind::Const(ref ty, expr) => {\n                 AssocConstItem(ty.clean(cx), Some(print_const_expr(cx, expr)))\n             }\n-            hir::ImplItemKind::Method(ref sig, body) => {\n+            hir::ImplItemKind::Fn(ref sig, body) => {\n                 MethodItem((sig, &self.generics, body, Some(self.defaultness)).clean(cx))\n             }\n             hir::ImplItemKind::TyAlias(ref ty) => {"}, {"sha": "34317c7a2ee3d9ab2cb10f0d06409749604dfea5", "filename": "src/libstd/backtrace.rs", "status": "modified", "additions": 84, "deletions": 7, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibstd%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Flibstd%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbacktrace.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -92,6 +92,7 @@\n // a backtrace or actually symbolizing it.\n \n use crate::env;\n+use crate::ffi::c_void;\n use crate::fmt;\n use crate::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n use crate::sync::Mutex;\n@@ -144,10 +145,16 @@ fn _assert_send_sync() {\n }\n \n struct BacktraceFrame {\n-    frame: backtrace::Frame,\n+    frame: RawFrame,\n     symbols: Vec<BacktraceSymbol>,\n }\n \n+enum RawFrame {\n+    Actual(backtrace::Frame),\n+    #[cfg(test)]\n+    Fake,\n+}\n+\n struct BacktraceSymbol {\n     name: Option<Vec<u8>>,\n     filename: Option<BytesOrWide>,\n@@ -162,8 +169,8 @@ enum BytesOrWide {\n impl fmt::Debug for Backtrace {\n     fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let mut capture = match &self.inner {\n-            Inner::Unsupported => return fmt.write_str(\"unsupported backtrace\"),\n-            Inner::Disabled => return fmt.write_str(\"disabled backtrace\"),\n+            Inner::Unsupported => return fmt.write_str(\"<unsupported>\"),\n+            Inner::Disabled => return fmt.write_str(\"<disabled>\"),\n             Inner::Captured(c) => c.lock().unwrap(),\n         };\n         capture.resolve();\n@@ -193,11 +200,11 @@ impl fmt::Debug for BacktraceSymbol {\n         if let Some(fn_name) = self.name.as_ref().map(|b| backtrace::SymbolName::new(b)) {\n             write!(fmt, \"fn: \\\"{:#}\\\"\", fn_name)?;\n         } else {\n-            write!(fmt, \"fn: \\\"<unknown>\\\"\")?;\n+            write!(fmt, \"fn: <unknown>\")?;\n         }\n \n         if let Some(fname) = self.filename.as_ref() {\n-            write!(fmt, \", file: {:?}\", fname)?;\n+            write!(fmt, \", file: \\\"{:?}\\\"\", fname)?;\n         }\n \n         if let Some(line) = self.lineno.as_ref() {\n@@ -293,7 +300,10 @@ impl Backtrace {\n         let mut actual_start = None;\n         unsafe {\n             backtrace::trace_unsynchronized(|frame| {\n-                frames.push(BacktraceFrame { frame: frame.clone(), symbols: Vec::new() });\n+                frames.push(BacktraceFrame {\n+                    frame: RawFrame::Actual(frame.clone()),\n+                    symbols: Vec::new(),\n+                });\n                 if frame.symbol_address() as usize == ip && actual_start.is_none() {\n                     actual_start = Some(frames.len());\n                 }\n@@ -393,8 +403,13 @@ impl Capture {\n         let _lock = lock();\n         for frame in self.frames.iter_mut() {\n             let symbols = &mut frame.symbols;\n+            let frame = match &frame.frame {\n+                RawFrame::Actual(frame) => frame,\n+                #[cfg(test)]\n+                RawFrame::Fake => unimplemented!(),\n+            };\n             unsafe {\n-                backtrace::resolve_frame_unsynchronized(&frame.frame, |symbol| {\n+                backtrace::resolve_frame_unsynchronized(frame, |symbol| {\n                     symbols.push(BacktraceSymbol {\n                         name: symbol.name().map(|m| m.as_bytes().to_vec()),\n                         filename: symbol.filename_raw().map(|b| match b {\n@@ -408,3 +423,65 @@ impl Capture {\n         }\n     }\n }\n+\n+impl RawFrame {\n+    fn ip(&self) -> *mut c_void {\n+        match self {\n+            RawFrame::Actual(frame) => frame.ip(),\n+            #[cfg(test)]\n+            RawFrame::Fake => 1 as *mut c_void,\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_debug() {\n+    let backtrace = Backtrace {\n+        inner: Inner::Captured(Mutex::new(Capture {\n+            actual_start: 1,\n+            resolved: true,\n+            frames: vec![\n+                BacktraceFrame {\n+                    frame: RawFrame::Fake,\n+                    symbols: vec![BacktraceSymbol {\n+                        name: Some(b\"std::backtrace::Backtrace::create\".to_vec()),\n+                        filename: Some(BytesOrWide::Bytes(b\"rust/backtrace.rs\".to_vec())),\n+                        lineno: Some(100),\n+                    }],\n+                },\n+                BacktraceFrame {\n+                    frame: RawFrame::Fake,\n+                    symbols: vec![BacktraceSymbol {\n+                        name: Some(b\"__rust_maybe_catch_panic\".to_vec()),\n+                        filename: None,\n+                        lineno: None,\n+                    }],\n+                },\n+                BacktraceFrame {\n+                    frame: RawFrame::Fake,\n+                    symbols: vec![\n+                        BacktraceSymbol {\n+                            name: Some(b\"std::rt::lang_start_internal\".to_vec()),\n+                            filename: Some(BytesOrWide::Bytes(b\"rust/rt.rs\".to_vec())),\n+                            lineno: Some(300),\n+                        },\n+                        BacktraceSymbol {\n+                            name: Some(b\"std::rt::lang_start\".to_vec()),\n+                            filename: Some(BytesOrWide::Bytes(b\"rust/rt.rs\".to_vec())),\n+                            lineno: Some(400),\n+                        },\n+                    ],\n+                },\n+            ],\n+        })),\n+    };\n+\n+    #[rustfmt::skip]\n+    let expected = \"Backtrace [\\\n+    \\n    { fn: \\\"__rust_maybe_catch_panic\\\" },\\\n+    \\n    { fn: \\\"std::rt::lang_start_internal\\\", file: \\\"rust/rt.rs\\\", line: 300 },\\\n+    \\n    { fn: \\\"std::rt::lang_start\\\", file: \\\"rust/rt.rs\\\", line: 400 },\\\n+    \\n]\";\n+\n+    assert_eq!(format!(\"{:#?}\", backtrace), expected);\n+}"}, {"sha": "5d47b633e78db919ba5a777790db09ea3f819f99", "filename": "src/test/ui/error-codes/E0583.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Ftest%2Fui%2Ferror-codes%2FE0583.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Ftest%2Fui%2Ferror-codes%2FE0583.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0583.stderr?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -4,7 +4,7 @@ error[E0583]: file not found for module `module_that_doesnt_exist`\n LL | mod module_that_doesnt_exist;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: name the file either module_that_doesnt_exist.rs or module_that_doesnt_exist/mod.rs inside the directory \"$DIR\"\n+   = help: to create the module `module_that_doesnt_exist`, create file \"$DIR/module_that_doesnt_exist.rs\"\n \n error: aborting due to previous error\n "}, {"sha": "22d40db3f2678e248ae13d11b9351d0a6a900cad", "filename": "src/test/ui/generator/too-many-parameters.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Ftest%2Fui%2Fgenerator%2Ftoo-many-parameters.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Ftest%2Fui%2Fgenerator%2Ftoo-many-parameters.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Ftoo-many-parameters.stderr?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -6,3 +6,4 @@ LL |     |(), ()| {\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0628`."}, {"sha": "5d2cdaef1a7611f5719583003862de9d1d72d2f9", "filename": "src/test/ui/invalid-module-declaration/invalid-module-declaration.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Ftest%2Fui%2Finvalid-module-declaration%2Finvalid-module-declaration.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Ftest%2Fui%2Finvalid-module-declaration%2Finvalid-module-declaration.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finvalid-module-declaration%2Finvalid-module-declaration.stderr?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -4,7 +4,7 @@ error[E0583]: file not found for module `baz`\n LL | pub mod baz;\n    |         ^^^\n    |\n-   = help: name the file either bar/baz.rs or bar/baz/mod.rs inside the directory \"$DIR/auxiliary/foo\"\n+   = help: to create the module `baz`, create file \"$DIR/auxiliary/foo/bar/baz.rs\"\n \n error: aborting due to previous error\n "}, {"sha": "e8d997e6de0913c81fc8d24166d903253fa5b861", "filename": "src/test/ui/missing_non_modrs_mod/missing_non_modrs_mod.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Ftest%2Fui%2Fmissing_non_modrs_mod%2Fmissing_non_modrs_mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Ftest%2Fui%2Fmissing_non_modrs_mod%2Fmissing_non_modrs_mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmissing_non_modrs_mod%2Fmissing_non_modrs_mod.stderr?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -4,7 +4,7 @@ error[E0583]: file not found for module `missing`\n LL | mod missing;\n    |     ^^^^^^^\n    |\n-   = help: name the file either foo/missing.rs or foo/missing/mod.rs inside the directory \"$DIR\"\n+   = help: to create the module `missing`, create file \"$DIR/foo/missing.rs\"\n \n error: aborting due to previous error\n "}, {"sha": "b2b0f8b466a04b2c9b34b95b39d00094397669f1", "filename": "src/test/ui/missing_non_modrs_mod/missing_non_modrs_mod_inline.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Ftest%2Fui%2Fmissing_non_modrs_mod%2Fmissing_non_modrs_mod_inline.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Ftest%2Fui%2Fmissing_non_modrs_mod%2Fmissing_non_modrs_mod_inline.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmissing_non_modrs_mod%2Fmissing_non_modrs_mod_inline.stderr?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -4,7 +4,7 @@ error[E0583]: file not found for module `missing`\n LL |     mod missing;\n    |         ^^^^^^^\n    |\n-   = help: name the file either missing.rs or missing/mod.rs inside the directory \"$DIR/foo_inline/inline\"\n+   = help: to create the module `missing`, create file \"$DIR/foo_inline/inline/missing.rs\"\n \n error: aborting due to previous error\n "}, {"sha": "71fbc7aea45eb6a675b0950a5b3d8503dcd92e1c", "filename": "src/test/ui/parser/mod_file_not_exist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Ftest%2Fui%2Fparser%2Fmod_file_not_exist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Ftest%2Fui%2Fparser%2Fmod_file_not_exist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmod_file_not_exist.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -1,7 +1,7 @@\n // ignore-windows\n \n mod not_a_real_file; //~ ERROR file not found for module `not_a_real_file`\n-//~^ HELP name the file either not_a_real_file.rs or not_a_real_file/mod.rs inside the directory\n+//~^ HELP to create the module `not_a_real_file`, create file \"\n \n fn main() {\n     assert_eq!(mod_file_aux::bar(), 10);"}, {"sha": "db3ea04ac7655029dcb565c74fe264f30238b354", "filename": "src/test/ui/parser/mod_file_not_exist.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Ftest%2Fui%2Fparser%2Fmod_file_not_exist.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Ftest%2Fui%2Fparser%2Fmod_file_not_exist.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmod_file_not_exist.stderr?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -4,7 +4,7 @@ error[E0583]: file not found for module `not_a_real_file`\n LL | mod not_a_real_file;\n    |     ^^^^^^^^^^^^^^^\n    |\n-   = help: name the file either not_a_real_file.rs or not_a_real_file/mod.rs inside the directory \"$DIR\"\n+   = help: to create the module `not_a_real_file`, create file \"$DIR/not_a_real_file.rs\"\n \n error: aborting due to previous error\n "}, {"sha": "97cadab675f5192fe9cad9b363c05eb8bce515ba", "filename": "src/test/ui/parser/mod_file_not_exist_windows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Ftest%2Fui%2Fparser%2Fmod_file_not_exist_windows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Ftest%2Fui%2Fparser%2Fmod_file_not_exist_windows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmod_file_not_exist_windows.rs?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -1,7 +1,7 @@\n // only-windows\n \n mod not_a_real_file; //~ ERROR file not found for module `not_a_real_file`\n-//~^ HELP name the file either not_a_real_file.rs or not_a_real_file\\mod.rs inside the directory\n+//~^ HELP to create the module `not_a_real_file`, create file\n \n fn main() {\n     assert_eq!(mod_file_aux::bar(), 10);"}, {"sha": "a58db80f73d7d964404cfde2afd7d94ba939b683", "filename": "src/test/ui/parser/mod_file_not_exist_windows.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Ftest%2Fui%2Fparser%2Fmod_file_not_exist_windows.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/59f4ba95045e91a63e921e0d736242d7e1ffabec/src%2Ftest%2Fui%2Fparser%2Fmod_file_not_exist_windows.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fmod_file_not_exist_windows.stderr?ref=59f4ba95045e91a63e921e0d736242d7e1ffabec", "patch": "@@ -4,7 +4,7 @@ error[E0583]: file not found for module `not_a_real_file`\n LL | mod not_a_real_file;\n    |     ^^^^^^^^^^^^^^^\n    |\n-   = help: name the file either not_a_real_file.rs or not_a_real_file/mod.rs inside the directory \"$DIR\"\n+   = help: to create the module `not_a_real_file`, create file \"$DIR/not_a_real_file.rs\"\n \n error: aborting due to previous error\n "}]}