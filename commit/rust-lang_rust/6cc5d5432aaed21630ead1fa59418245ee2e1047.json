{"sha": "6cc5d5432aaed21630ead1fa59418245ee2e1047", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjYzVkNTQzMmFhZWQyMTYzMGVhZDFmYTU5NDE4MjQ1ZWUyZTEwNDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-13T09:36:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-13T09:36:12Z"}, "message": "Auto merge of #86185 - klensy:ast-val, r=petrochenkov\n\nsimplify validate_generic_param_order", "tree": {"sha": "69933bc5e9a2578da49fc4c6260b81defe3144f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69933bc5e9a2578da49fc4c6260b81defe3144f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6cc5d5432aaed21630ead1fa59418245ee2e1047", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6cc5d5432aaed21630ead1fa59418245ee2e1047", "html_url": "https://github.com/rust-lang/rust/commit/6cc5d5432aaed21630ead1fa59418245ee2e1047", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6cc5d5432aaed21630ead1fa59418245ee2e1047/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a75e74df89230bc429a550e29d5c566de5f95deb", "url": "https://api.github.com/repos/rust-lang/rust/commits/a75e74df89230bc429a550e29d5c566de5f95deb", "html_url": "https://github.com/rust-lang/rust/commit/a75e74df89230bc429a550e29d5c566de5f95deb"}, {"sha": "6a198674170be49e4cc01bccc660f320b35a5670", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a198674170be49e4cc01bccc660f320b35a5670", "html_url": "https://github.com/rust-lang/rust/commit/6a198674170be49e4cc01bccc660f320b35a5670"}], "stats": {"total": 75, "additions": 36, "deletions": 39}, "files": [{"sha": "357a2e65cf7165bb41e1080a240ebe44b6db22cb", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 36, "deletions": 39, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/6cc5d5432aaed21630ead1fa59418245ee2e1047/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cc5d5432aaed21630ead1fa59418245ee2e1047/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=6cc5d5432aaed21630ead1fa59418245ee2e1047", "patch": "@@ -889,48 +889,45 @@ fn validate_generic_param_order(\n ) {\n     let mut max_param: Option<ParamKindOrd> = None;\n     let mut out_of_order = FxHashMap::default();\n-    let mut param_idents = vec![];\n+    let mut param_idents = Vec::with_capacity(generics.len());\n \n-    for param in generics {\n-        let ident = Some(param.ident.to_string());\n-        let (kind, bounds, span) = (&param.kind, Some(&*param.bounds), param.ident.span);\n+    for (idx, param) in generics.iter().enumerate() {\n+        let ident = param.ident;\n+        let (kind, bounds, span) = (&param.kind, &param.bounds, ident.span);\n         let (ord_kind, ident) = match &param.kind {\n-            GenericParamKind::Lifetime => (ParamKindOrd::Lifetime, ident),\n-            GenericParamKind::Type { default: _ } => (ParamKindOrd::Type, ident),\n+            GenericParamKind::Lifetime => (ParamKindOrd::Lifetime, ident.to_string()),\n+            GenericParamKind::Type { default: _ } => (ParamKindOrd::Type, ident.to_string()),\n             GenericParamKind::Const { ref ty, kw_span: _, default: _ } => {\n                 let ty = pprust::ty_to_string(ty);\n                 let unordered = sess.features_untracked().unordered_const_ty_params();\n-                (ParamKindOrd::Const { unordered }, Some(format!(\"const {}: {}\", param.ident, ty)))\n+                (ParamKindOrd::Const { unordered }, format!(\"const {}: {}\", ident, ty))\n             }\n         };\n-        if let Some(ident) = ident {\n-            param_idents.push((kind, ord_kind, bounds, param_idents.len(), ident));\n-        }\n-        let max_param = &mut max_param;\n+        param_idents.push((kind, ord_kind, bounds, idx, ident));\n         match max_param {\n-            Some(max_param) if *max_param > ord_kind => {\n-                let entry = out_of_order.entry(ord_kind).or_insert((*max_param, vec![]));\n+            Some(max_param) if max_param > ord_kind => {\n+                let entry = out_of_order.entry(ord_kind).or_insert((max_param, vec![]));\n                 entry.1.push(span);\n             }\n-            Some(_) | None => *max_param = Some(ord_kind),\n+            Some(_) | None => max_param = Some(ord_kind),\n         };\n     }\n \n-    let mut ordered_params = \"<\".to_string();\n     if !out_of_order.is_empty() {\n+        let mut ordered_params = \"<\".to_string();\n         param_idents.sort_by_key(|&(_, po, _, i, _)| (po, i));\n         let mut first = true;\n         for (kind, _, bounds, _, ident) in param_idents {\n             if !first {\n                 ordered_params += \", \";\n             }\n             ordered_params += &ident;\n-            if let Some(bounds) = bounds {\n-                if !bounds.is_empty() {\n-                    ordered_params += \": \";\n-                    ordered_params += &pprust::bounds_to_string(&bounds);\n-                }\n+\n+            if !bounds.is_empty() {\n+                ordered_params += \": \";\n+                ordered_params += &pprust::bounds_to_string(&bounds);\n             }\n+\n             match kind {\n                 GenericParamKind::Type { default: Some(default) } => {\n                     ordered_params += \" = \";\n@@ -946,32 +943,32 @@ fn validate_generic_param_order(\n             }\n             first = false;\n         }\n-    }\n-    ordered_params += \">\";\n \n-    for (param_ord, (max_param, spans)) in &out_of_order {\n-        let mut err =\n-            handler.struct_span_err(\n+        ordered_params += \">\";\n+\n+        for (param_ord, (max_param, spans)) in &out_of_order {\n+            let mut err = handler.struct_span_err(\n                 spans.clone(),\n                 &format!(\n                     \"{} parameters must be declared prior to {} parameters\",\n                     param_ord, max_param,\n                 ),\n             );\n-        err.span_suggestion(\n-            span,\n-            &format!(\n-                \"reorder the parameters: lifetimes, {}\",\n-                if sess.features_untracked().unordered_const_ty_params() {\n-                    \"then consts and types\"\n-                } else {\n-                    \"then types, then consts\"\n-                }\n-            ),\n-            ordered_params.clone(),\n-            Applicability::MachineApplicable,\n-        );\n-        err.emit();\n+            err.span_suggestion(\n+                span,\n+                &format!(\n+                    \"reorder the parameters: lifetimes, {}\",\n+                    if sess.features_untracked().unordered_const_ty_params() {\n+                        \"then consts and types\"\n+                    } else {\n+                        \"then types, then consts\"\n+                    }\n+                ),\n+                ordered_params.clone(),\n+                Applicability::MachineApplicable,\n+            );\n+            err.emit();\n+        }\n     }\n }\n "}]}