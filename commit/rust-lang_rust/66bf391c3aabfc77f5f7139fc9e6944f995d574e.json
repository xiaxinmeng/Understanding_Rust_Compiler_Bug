{"sha": "66bf391c3aabfc77f5f7139fc9e6944f995d574e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2YmYzOTFjM2FhYmZjNzdmNWY3MTM5ZmM5ZTY5NDRmOTk1ZDU3NGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-23T06:38:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-23T06:38:23Z"}, "message": "Auto merge of #64272 - Mark-Simulacrum:parallel-handler, r=estebank\n\nRefactor librustc_errors::Handler API\n\nThis should be reviewed by-commit.\n\nThe last commit moves all fields into an inner struct behind a single lock; this is done to prevent possible deadlocks in a multi-threaded compiler, as well as inconsistent state observation.", "tree": {"sha": "196ef2334e2f7787737af02f2e78ed53c10fb5a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/196ef2334e2f7787737af02f2e78ed53c10fb5a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66bf391c3aabfc77f5f7139fc9e6944f995d574e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66bf391c3aabfc77f5f7139fc9e6944f995d574e", "html_url": "https://github.com/rust-lang/rust/commit/66bf391c3aabfc77f5f7139fc9e6944f995d574e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66bf391c3aabfc77f5f7139fc9e6944f995d574e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64", "html_url": "https://github.com/rust-lang/rust/commit/b6716a1cdd7ad8eab93c9e25e7832a3c0f744d64"}, {"sha": "4cc5aaada2f8ffd444a7fbb10394b83ba3156525", "url": "https://api.github.com/repos/rust-lang/rust/commits/4cc5aaada2f8ffd444a7fbb10394b83ba3156525", "html_url": "https://github.com/rust-lang/rust/commit/4cc5aaada2f8ffd444a7fbb10394b83ba3156525"}], "stats": {"total": 584, "additions": 322, "deletions": 262}, "files": [{"sha": "e76a70350b33eb4b4c80c590e07a6d866f6dc202", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=66bf391c3aabfc77f5f7139fc9e6944f995d574e", "patch": "@@ -1,4 +1,4 @@\n-use errors::{Diagnostic, DiagnosticBuilder};\n+use errors::Diagnostic;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n@@ -819,7 +819,7 @@ impl DepGraph {\n             let handle = tcx.sess.diagnostic();\n \n             for diagnostic in diagnostics {\n-                DiagnosticBuilder::new_diagnostic(handle, diagnostic).emit();\n+                handle.emit_diagnostic(&diagnostic);\n             }\n \n             // Mark the node as green now that diagnostics are emitted"}, {"sha": "0b6740d7bbbc88ee3234d0e756c3b278f0f9a968", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=66bf391c3aabfc77f5f7139fc9e6944f995d574e", "patch": "@@ -1119,7 +1119,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     Some((expected, found)) => Some((expected, found)),\n                     None => {\n                         // Derived error. Cancel the emitter.\n-                        self.tcx.sess.diagnostic().cancel(diag);\n+                        diag.cancel();\n                         return;\n                     }\n                 };"}, {"sha": "5eda3df378126dd3215e6a51baedce568382c27c", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=66bf391c3aabfc77f5f7139fc9e6944f995d574e", "patch": "@@ -1855,7 +1855,7 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n struct NullEmitter;\n \n impl errors::emitter::Emitter for NullEmitter {\n-    fn emit_diagnostic(&mut self, _: &errors::DiagnosticBuilder<'_>) {}\n+    fn emit_diagnostic(&mut self, _: &errors::Diagnostic) {}\n }\n \n // Converts strings provided as `--cfg [cfgspec]` into a `crate_cfg`."}, {"sha": "9eb68056bfd97f0c09afc8bf7f33df30ef9627ec", "filename": "src/librustc/session/config/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustc%2Fsession%2Fconfig%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustc%2Fsession%2Fconfig%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig%2Ftests.rs?ref=66bf391c3aabfc77f5f7139fc9e6944f995d574e", "patch": "@@ -87,7 +87,7 @@ fn test_can_print_warnings() {\n         let registry = errors::registry::Registry::new(&[]);\n         let (sessopts, _) = build_session_options_and_crate_config(&matches);\n         let sess = build_session(sessopts, None, registry);\n-        assert!(!sess.diagnostic().flags.can_emit_warnings);\n+        assert!(!sess.diagnostic().can_emit_warnings());\n     });\n \n     syntax::with_default_globals(|| {\n@@ -97,15 +97,15 @@ fn test_can_print_warnings() {\n         let registry = errors::registry::Registry::new(&[]);\n         let (sessopts, _) = build_session_options_and_crate_config(&matches);\n         let sess = build_session(sessopts, None, registry);\n-        assert!(sess.diagnostic().flags.can_emit_warnings);\n+        assert!(sess.diagnostic().can_emit_warnings());\n     });\n \n     syntax::with_default_globals(|| {\n         let matches = optgroups().parse(&[\"-Adead_code\".to_string()]).unwrap();\n         let registry = errors::registry::Registry::new(&[]);\n         let (sessopts, _) = build_session_options_and_crate_config(&matches);\n         let sess = build_session(sessopts, None, registry);\n-        assert!(sess.diagnostic().flags.can_emit_warnings);\n+        assert!(sess.diagnostic().can_emit_warnings());\n     });\n }\n "}, {"sha": "a24fed8f21c5a1edcb2d25eb911d02f54be20ac2", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=66bf391c3aabfc77f5f7139fc9e6944f995d574e", "patch": "@@ -365,12 +365,6 @@ impl Session {\n     pub fn span_note_without_error<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.diagnostic().span_note_without_error(sp, msg)\n     }\n-    pub fn span_unimpl<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n-        self.diagnostic().span_unimpl(sp, msg)\n-    }\n-    pub fn unimpl(&self, msg: &str) -> ! {\n-        self.diagnostic().unimpl(msg)\n-    }\n \n     pub fn buffer_lint<S: Into<MultiSpan>>(\n         &self,\n@@ -1040,6 +1034,7 @@ fn default_emitter(\n     source_map: &Lrc<source_map::SourceMap>,\n     emitter_dest: Option<Box<dyn Write + Send>>,\n ) -> Box<dyn Emitter + sync::Send> {\n+    let external_macro_backtrace = sopts.debugging_opts.external_macro_backtrace;\n     match (sopts.error_format, emitter_dest) {\n         (config::ErrorOutputType::HumanReadable(kind), dst) => {\n             let (short, color_config) = kind.unzip();\n@@ -1048,6 +1043,7 @@ fn default_emitter(\n                 let emitter = AnnotateSnippetEmitterWriter::new(\n                     Some(source_map.clone()),\n                     short,\n+                    external_macro_backtrace,\n                 );\n                 Box::new(emitter.ui_testing(sopts.debugging_opts.ui_testing))\n             } else {\n@@ -1058,6 +1054,7 @@ fn default_emitter(\n                         short,\n                         sopts.debugging_opts.teach,\n                         sopts.debugging_opts.terminal_width,\n+                        external_macro_backtrace,\n                     ),\n                     Some(dst) => EmitterWriter::new(\n                         dst,\n@@ -1066,6 +1063,7 @@ fn default_emitter(\n                         false, // no teach messages when writing to a buffer\n                         false, // no colors when writing to a buffer\n                         None,  // no terminal width\n+                        external_macro_backtrace,\n                     ),\n                 };\n                 Box::new(emitter.ui_testing(sopts.debugging_opts.ui_testing))\n@@ -1077,6 +1075,7 @@ fn default_emitter(\n                 source_map.clone(),\n                 pretty,\n                 json_rendered,\n+                external_macro_backtrace,\n             ).ui_testing(sopts.debugging_opts.ui_testing),\n         ),\n         (config::ErrorOutputType::Json { pretty, json_rendered }, Some(dst)) => Box::new(\n@@ -1086,6 +1085,7 @@ fn default_emitter(\n                 source_map.clone(),\n                 pretty,\n                 json_rendered,\n+                external_macro_backtrace,\n             ).ui_testing(sopts.debugging_opts.ui_testing),\n         ),\n     }\n@@ -1382,27 +1382,27 @@ pub fn early_error(output: config::ErrorOutputType, msg: &str) -> ! {\n     let emitter: Box<dyn Emitter + sync::Send> = match output {\n         config::ErrorOutputType::HumanReadable(kind) => {\n             let (short, color_config) = kind.unzip();\n-            Box::new(EmitterWriter::stderr(color_config, None, short, false, None))\n+            Box::new(EmitterWriter::stderr(color_config, None, short, false, None, false))\n         }\n         config::ErrorOutputType::Json { pretty, json_rendered } =>\n-            Box::new(JsonEmitter::basic(pretty, json_rendered)),\n+            Box::new(JsonEmitter::basic(pretty, json_rendered, false)),\n     };\n     let handler = errors::Handler::with_emitter(true, None, emitter);\n-    handler.emit(&MultiSpan::new(), msg, errors::Level::Fatal);\n+    handler.struct_fatal(msg).emit();\n     errors::FatalError.raise();\n }\n \n pub fn early_warn(output: config::ErrorOutputType, msg: &str) {\n     let emitter: Box<dyn Emitter + sync::Send> = match output {\n         config::ErrorOutputType::HumanReadable(kind) => {\n             let (short, color_config) = kind.unzip();\n-            Box::new(EmitterWriter::stderr(color_config, None, short, false, None))\n+            Box::new(EmitterWriter::stderr(color_config, None, short, false, None, false))\n         }\n         config::ErrorOutputType::Json { pretty, json_rendered } =>\n-            Box::new(JsonEmitter::basic(pretty, json_rendered)),\n+            Box::new(JsonEmitter::basic(pretty, json_rendered, false)),\n     };\n     let handler = errors::Handler::with_emitter(true, None, emitter);\n-    handler.emit(&MultiSpan::new(), msg, errors::Level::Warning);\n+    handler.struct_warn(msg).emit();\n }\n \n pub type CompileResult = Result<(), ErrorReported>;"}, {"sha": "a1828bb5ab7a7cacbf6fb1692deb2e2da7bd8d21", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=66bf391c3aabfc77f5f7139fc9e6944f995d574e", "patch": "@@ -330,14 +330,13 @@ impl<'tcx> TyCtxt<'tcx> {\n                 let mut i = 0;\n \n                 while let Some(query) = current_query {\n-                    let mut db = DiagnosticBuilder::new(icx.tcx.sess.diagnostic(),\n-                        Level::FailureNote,\n+                    let mut diag = Diagnostic::new(Level::FailureNote,\n                         &format!(\"#{} [{}] {}\",\n                                  i,\n                                  query.info.query.name(),\n                                  query.info.query.describe(icx.tcx)));\n-                    db.set_span(icx.tcx.sess.source_map().def_span(query.info.span));\n-                    icx.tcx.sess.diagnostic().force_print_db(db);\n+                    diag.span = icx.tcx.sess.source_map().def_span(query.info.span).into();\n+                    icx.tcx.sess.diagnostic().force_print_diagnostic(diag);\n \n                     current_query = query.parent.clone();\n                     i += 1;"}, {"sha": "1bba479c1fd5db7f0dc37aaf3fff25308c605e22", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=66bf391c3aabfc77f5f7139fc9e6944f995d574e", "patch": "@@ -22,12 +22,11 @@ use rustc::util::common::{time_depth, set_time_depth, print_time_passes_entry};\n use rustc::util::profiling::SelfProfiler;\n use rustc_fs_util::link_or_copy;\n use rustc_data_structures::svh::Svh;\n-use rustc_errors::{Handler, Level, DiagnosticBuilder, FatalError, DiagnosticId};\n+use rustc_errors::{Handler, Level, FatalError, DiagnosticId};\n use rustc_errors::emitter::{Emitter};\n use rustc_target::spec::MergeFunctions;\n use syntax::attr;\n use syntax::ext::hygiene::ExpnId;\n-use syntax_pos::MultiSpan;\n use syntax_pos::symbol::{Symbol, sym};\n use jobserver::{Client, Acquired};\n \n@@ -1725,7 +1724,7 @@ impl SharedEmitter {\n }\n \n impl Emitter for SharedEmitter {\n-    fn emit_diagnostic(&mut self, db: &DiagnosticBuilder<'_>) {\n+    fn emit_diagnostic(&mut self, db: &rustc_errors::Diagnostic) {\n         drop(self.sender.send(SharedEmitterMessage::Diagnostic(Diagnostic {\n             msg: db.message(),\n             code: db.code.clone(),\n@@ -1760,19 +1759,12 @@ impl SharedEmitterMain {\n             match message {\n                 Ok(SharedEmitterMessage::Diagnostic(diag)) => {\n                     let handler = sess.diagnostic();\n-                    match diag.code {\n-                        Some(ref code) => {\n-                            handler.emit_with_code(&MultiSpan::new(),\n-                                                   &diag.msg,\n-                                                   code.clone(),\n-                                                   diag.lvl);\n-                        }\n-                        None => {\n-                            handler.emit(&MultiSpan::new(),\n-                                         &diag.msg,\n-                                         diag.lvl);\n-                        }\n+                    let mut d = rustc_errors::Diagnostic::new(diag.lvl, &diag.msg);\n+                    if let Some(code) = diag.code {\n+                        d.code(code);\n                     }\n+                    handler.emit_diagnostic(&d);\n+                    handler.abort_if_errors_and_should_abort();\n                 }\n                 Ok(SharedEmitterMessage::InlineAsmError(cookie, msg)) => {\n                     sess.span_err(ExpnId::from_u32(cookie).expn_data().call_site, &msg)"}, {"sha": "f99e65b4494a7f136c7eb91c7994573cb1d8d66d", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=66bf391c3aabfc77f5f7139fc9e6944f995d574e", "patch": "@@ -66,7 +66,7 @@ use syntax::source_map::FileLoader;\n use syntax::feature_gate::{GatedCfg, UnstableFeatures};\n use syntax::parse::{self, PResult};\n use syntax::symbol::sym;\n-use syntax_pos::{DUMMY_SP, MultiSpan, FileName};\n+use syntax_pos::{DUMMY_SP, FileName};\n \n pub mod pretty;\n mod args;\n@@ -1196,15 +1196,16 @@ pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n         false,\n         false,\n         None,\n+        false,\n     ));\n     let handler = errors::Handler::with_emitter(true, None, emitter);\n \n     // a .span_bug or .bug call has already printed what\n     // it wants to print.\n     if !info.payload().is::<errors::ExplicitBug>() {\n-        handler.emit(&MultiSpan::new(),\n-                     \"unexpected panic\",\n-                     errors::Level::Bug);\n+        let d = errors::Diagnostic::new(errors::Level::Bug, \"unexpected panic\");\n+        handler.emit_diagnostic(&d);\n+        handler.abort_if_errors_and_should_abort();\n     }\n \n     let mut xs: Vec<Cow<'static, str>> = vec![\n@@ -1224,9 +1225,7 @@ pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n     }\n \n     for note in &xs {\n-        handler.emit(&MultiSpan::new(),\n-                     note,\n-                     errors::Level::Note);\n+        handler.note_without_error(&note);\n     }\n \n     // If backtraces are enabled, also print the query stack"}, {"sha": "0281d10fd930ee1ac290f77a5848176e0201b52c", "filename": "src/librustc_errors/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs?ref=66bf391c3aabfc77f5f7139fc9e6944f995d574e", "patch": "@@ -7,7 +7,7 @@\n \n use syntax_pos::{SourceFile, MultiSpan, Loc};\n use crate::{\n-    Level, CodeSuggestion, DiagnosticBuilder, Emitter,\n+    Level, CodeSuggestion, Diagnostic, Emitter,\n     SourceMapperDyn, SubDiagnostic, DiagnosticId\n };\n use crate::emitter::FileWithAnnotatedLines;\n@@ -25,19 +25,21 @@ pub struct AnnotateSnippetEmitterWriter {\n     short_message: bool,\n     /// If true, will normalize line numbers with `LL` to prevent noise in UI test diffs.\n     ui_testing: bool,\n+\n+    external_macro_backtrace: bool,\n }\n \n impl Emitter for AnnotateSnippetEmitterWriter {\n     /// The entry point for the diagnostics generation\n-    fn emit_diagnostic(&mut self, db: &DiagnosticBuilder<'_>) {\n+    fn emit_diagnostic(&mut self, db: &Diagnostic) {\n         let mut children = db.children.clone();\n         let (mut primary_span, suggestions) = self.primary_span_formatted(&db);\n \n         self.fix_multispans_in_std_macros(&self.source_map,\n                                           &mut primary_span,\n                                           &mut children,\n                                           &db.level,\n-                                          db.handler().flags.external_macro_backtrace);\n+                                          self.external_macro_backtrace);\n \n         self.emit_messages_default(&db.level,\n                                    db.message(),\n@@ -163,12 +165,14 @@ impl<'a>  DiagnosticConverter<'a> {\n impl AnnotateSnippetEmitterWriter {\n     pub fn new(\n         source_map: Option<Lrc<SourceMapperDyn>>,\n-        short_message: bool\n+        short_message: bool,\n+        external_macro_backtrace: bool,\n     ) -> Self {\n         Self {\n             source_map,\n             short_message,\n             ui_testing: false,\n+            external_macro_backtrace,\n         }\n     }\n "}, {"sha": "e85388bfea29c51aa60ecc282f756093fc7e6af7", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=66bf391c3aabfc77f5f7139fc9e6944f995d574e", "patch": "@@ -99,17 +99,9 @@ impl<'a> DerefMut for DiagnosticBuilder<'a> {\n }\n \n impl<'a> DiagnosticBuilder<'a> {\n-    pub fn handler(&self) -> &'a Handler{\n-        self.0.handler\n-    }\n-\n     /// Emit the diagnostic.\n     pub fn emit(&mut self) {\n-        if self.cancelled() {\n-            return;\n-        }\n-\n-        self.0.handler.emit_db(&self);\n+        self.0.handler.emit_diagnostic(&self);\n         self.cancel();\n     }\n \n@@ -354,7 +346,7 @@ impl<'a> DiagnosticBuilder<'a> {\n \n     /// Convenience function for internal use, clients should use one of the\n     /// struct_* methods on Handler.\n-    pub fn new(handler: &'a Handler, level: Level, message: &str) -> DiagnosticBuilder<'a> {\n+    crate fn new(handler: &'a Handler, level: Level, message: &str) -> DiagnosticBuilder<'a> {\n         DiagnosticBuilder::new_with_code(handler, level, None, message)\n     }\n \n@@ -371,7 +363,8 @@ impl<'a> DiagnosticBuilder<'a> {\n \n     /// Creates a new `DiagnosticBuilder` with an already constructed\n     /// diagnostic.\n-    pub fn new_diagnostic(handler: &'a Handler, diagnostic: Diagnostic) -> DiagnosticBuilder<'a> {\n+    crate fn new_diagnostic(handler: &'a Handler, diagnostic: Diagnostic)\n+                         -> DiagnosticBuilder<'a> {\n         DiagnosticBuilder(Box::new(DiagnosticBuilderInner {\n             handler,\n             diagnostic,"}, {"sha": "fc441320e003919df9eef990995a6b4f3d0e4da6", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=66bf391c3aabfc77f5f7139fc9e6944f995d574e", "patch": "@@ -12,7 +12,7 @@ use Destination::*;\n use syntax_pos::{SourceFile, Span, MultiSpan};\n \n use crate::{\n-    Level, CodeSuggestion, DiagnosticBuilder, SubDiagnostic,\n+    Level, CodeSuggestion, Diagnostic, SubDiagnostic,\n     SuggestionStyle, SourceMapperDyn, DiagnosticId,\n };\n use crate::Level::Error;\n@@ -52,10 +52,12 @@ impl HumanReadableErrorType {\n         source_map: Option<Lrc<SourceMapperDyn>>,\n         teach: bool,\n         terminal_width: Option<usize>,\n+        external_macro_backtrace: bool,\n     ) -> EmitterWriter {\n         let (short, color_config) = self.unzip();\n         let color = color_config.suggests_using_colors();\n-        EmitterWriter::new(dst, source_map, short, teach, color, terminal_width)\n+        EmitterWriter::new(dst, source_map, short, teach, color, terminal_width,\n+            external_macro_backtrace)\n     }\n }\n \n@@ -180,7 +182,7 @@ const ANONYMIZED_LINE_NUM: &str = \"LL\";\n /// Emitter trait for emitting errors.\n pub trait Emitter {\n     /// Emit a structured diagnostic.\n-    fn emit_diagnostic(&mut self, db: &DiagnosticBuilder<'_>);\n+    fn emit_diagnostic(&mut self, db: &Diagnostic);\n \n     /// Emit a notification that an artifact has been output.\n     /// This is currently only supported for the JSON format,\n@@ -204,7 +206,7 @@ pub trait Emitter {\n     ///   we return the original `primary_span` and the original suggestions.\n     fn primary_span_formatted<'a>(\n         &mut self,\n-        db: &'a DiagnosticBuilder<'_>\n+        db: &'a Diagnostic\n     ) -> (MultiSpan, &'a [CodeSuggestion]) {\n         let mut primary_span = db.span.clone();\n         if let Some((sugg, rest)) = db.suggestions.split_first() {\n@@ -377,15 +379,15 @@ pub trait Emitter {\n }\n \n impl Emitter for EmitterWriter {\n-    fn emit_diagnostic(&mut self, db: &DiagnosticBuilder<'_>) {\n+    fn emit_diagnostic(&mut self, db: &Diagnostic) {\n         let mut children = db.children.clone();\n         let (mut primary_span, suggestions) = self.primary_span_formatted(&db);\n \n         self.fix_multispans_in_std_macros(&self.sm,\n                                           &mut primary_span,\n                                           &mut children,\n                                           &db.level,\n-                                          db.handler().flags.external_macro_backtrace);\n+                                          self.external_macro_backtrace);\n \n         self.emit_messages_default(&db.level,\n                                    &db.styled_message(),\n@@ -449,6 +451,8 @@ pub struct EmitterWriter {\n     teach: bool,\n     ui_testing: bool,\n     terminal_width: Option<usize>,\n+\n+    external_macro_backtrace: bool,\n }\n \n #[derive(Debug)]\n@@ -465,6 +469,7 @@ impl EmitterWriter {\n         short_message: bool,\n         teach: bool,\n         terminal_width: Option<usize>,\n+        external_macro_backtrace: bool,\n     ) -> EmitterWriter {\n         let dst = Destination::from_stderr(color_config);\n         EmitterWriter {\n@@ -474,6 +479,7 @@ impl EmitterWriter {\n             teach,\n             ui_testing: false,\n             terminal_width,\n+            external_macro_backtrace,\n         }\n     }\n \n@@ -484,6 +490,7 @@ impl EmitterWriter {\n         teach: bool,\n         colored: bool,\n         terminal_width: Option<usize>,\n+        external_macro_backtrace: bool,\n     ) -> EmitterWriter {\n         EmitterWriter {\n             dst: Raw(dst, colored),\n@@ -492,6 +499,7 @@ impl EmitterWriter {\n             teach,\n             ui_testing: false,\n             terminal_width,\n+            external_macro_backtrace,\n         }\n     }\n "}, {"sha": "1fe5b71d7b1cf51691f636ca7f2d1cdd59c662cd", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 225, "deletions": 164, "changes": 389, "blob_url": "https://github.com/rust-lang/rust/blob/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=66bf391c3aabfc77f5f7139fc9e6944f995d574e", "patch": "@@ -16,7 +16,7 @@ use Level::*;\n use emitter::{Emitter, EmitterWriter};\n use registry::Registry;\n \n-use rustc_data_structures::sync::{self, Lrc, Lock, AtomicUsize, AtomicBool, SeqCst};\n+use rustc_data_structures::sync::{self, Lrc, Lock};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::stable_hasher::StableHasher;\n \n@@ -298,38 +298,42 @@ pub use diagnostic_builder::DiagnosticBuilder;\n /// Certain errors (fatal, bug, unimpl) may cause immediate exit,\n /// others log errors for later reporting.\n pub struct Handler {\n-    pub flags: HandlerFlags,\n+    flags: HandlerFlags,\n+    inner: Lock<HandlerInner>,\n+}\n \n+struct HandlerInner {\n+    flags: HandlerFlags,\n     /// The number of errors that have been emitted, including duplicates.\n     ///\n     /// This is not necessarily the count that's reported to the user once\n     /// compilation ends.\n-    err_count: AtomicUsize,\n-    deduplicated_err_count: AtomicUsize,\n-    emitter: Lock<Box<dyn Emitter + sync::Send>>,\n-    continue_after_error: AtomicBool,\n-    delayed_span_bugs: Lock<Vec<Diagnostic>>,\n+    err_count: usize,\n+    deduplicated_err_count: usize,\n+    emitter: Box<dyn Emitter + sync::Send>,\n+    continue_after_error: bool,\n+    delayed_span_bugs: Vec<Diagnostic>,\n \n     /// This set contains the `DiagnosticId` of all emitted diagnostics to avoid\n     /// emitting the same diagnostic with extended help (`--teach`) twice, which\n     /// would be uneccessary repetition.\n-    taught_diagnostics: Lock<FxHashSet<DiagnosticId>>,\n+    taught_diagnostics: FxHashSet<DiagnosticId>,\n \n     /// Used to suggest rustc --explain <error code>\n-    emitted_diagnostic_codes: Lock<FxHashSet<DiagnosticId>>,\n+    emitted_diagnostic_codes: FxHashSet<DiagnosticId>,\n \n     /// This set contains a hash of every diagnostic that has been emitted by\n     /// this handler. These hashes is used to avoid emitting the same error\n     /// twice.\n-    emitted_diagnostics: Lock<FxHashSet<u128>>,\n+    emitted_diagnostics: FxHashSet<u128>,\n }\n \n fn default_track_diagnostic(_: &Diagnostic) {}\n \n thread_local!(pub static TRACK_DIAGNOSTICS: Cell<fn(&Diagnostic)> =\n                 Cell::new(default_track_diagnostic));\n \n-#[derive(Default)]\n+#[derive(Copy, Clone, Default)]\n pub struct HandlerFlags {\n     /// If false, warning-level lints are suppressed.\n     /// (rustc: see `--allow warnings` and `--cap-lints`)\n@@ -348,13 +352,13 @@ pub struct HandlerFlags {\n     pub external_macro_backtrace: bool,\n }\n \n-impl Drop for Handler {\n+impl Drop for HandlerInner {\n     fn drop(&mut self) {\n-        if !self.has_errors() {\n-            let mut bugs = self.delayed_span_bugs.borrow_mut();\n+        if self.err_count == 0 {\n+            let bugs = std::mem::replace(&mut self.delayed_span_bugs, Vec::new());\n             let has_bugs = !bugs.is_empty();\n-            for bug in bugs.drain(..) {\n-                DiagnosticBuilder::new_diagnostic(self, bug).emit();\n+            for bug in bugs {\n+                self.emit_diagnostic(&bug);\n             }\n             if has_bugs {\n                 panic!(\"no errors encountered even though `delay_span_bug` issued\");\n@@ -383,7 +387,8 @@ impl Handler {\n                                       cm: Option<Lrc<SourceMapperDyn>>,\n                                       flags: HandlerFlags)\n                                       -> Handler {\n-        let emitter = Box::new(EmitterWriter::stderr(color_config, cm, false, false, None));\n+        let emitter = Box::new(EmitterWriter::stderr(\n+            color_config, cm, false, false, None, flags.external_macro_backtrace));\n         Handler::with_emitter_and_flags(emitter, flags)\n     }\n \n@@ -404,31 +409,42 @@ impl Handler {\n     {\n         Handler {\n             flags,\n-            err_count: AtomicUsize::new(0),\n-            deduplicated_err_count: AtomicUsize::new(0),\n-            emitter: Lock::new(e),\n-            continue_after_error: AtomicBool::new(true),\n-            delayed_span_bugs: Lock::new(Vec::new()),\n-            taught_diagnostics: Default::default(),\n-            emitted_diagnostic_codes: Default::default(),\n-            emitted_diagnostics: Default::default(),\n+            inner: Lock::new(HandlerInner {\n+                flags,\n+                err_count: 0,\n+                deduplicated_err_count: 0,\n+                emitter: e,\n+                continue_after_error: true,\n+                delayed_span_bugs: Vec::new(),\n+                taught_diagnostics: Default::default(),\n+                emitted_diagnostic_codes: Default::default(),\n+                emitted_diagnostics: Default::default(),\n+            }),\n         }\n     }\n \n     pub fn set_continue_after_error(&self, continue_after_error: bool) {\n-        self.continue_after_error.store(continue_after_error, SeqCst);\n+        self.inner.borrow_mut().continue_after_error = continue_after_error;\n+    }\n+\n+    // This is here to not allow mutation of flags;\n+    // as of this writing it's only used in tests in librustc.\n+    pub fn can_emit_warnings(&self) -> bool {\n+        self.flags.can_emit_warnings\n     }\n \n     /// Resets the diagnostic error count as well as the cached emitted diagnostics.\n     ///\n     /// NOTE: *do not* call this function from rustc. It is only meant to be called from external\n     /// tools that want to reuse a `Parser` cleaning the previously emitted diagnostics as well as\n     /// the overall count of emitted error diagnostics.\n+    // FIXME: this does not clear inner entirely\n     pub fn reset_err_count(&self) {\n+        let mut inner = self.inner.borrow_mut();\n         // actually frees the underlying memory (which `clear` would not do)\n-        *self.emitted_diagnostics.borrow_mut() = Default::default();\n-        self.deduplicated_err_count.store(0, SeqCst);\n-        self.err_count.store(0, SeqCst);\n+        inner.emitted_diagnostics = Default::default();\n+        inner.deduplicated_err_count = 0;\n+        inner.err_count = 0;\n     }\n \n     pub fn struct_dummy(&self) -> DiagnosticBuilder<'_> {\n@@ -519,42 +535,23 @@ impl Handler {\n         DiagnosticBuilder::new(self, Level::Fatal, msg)\n     }\n \n-    pub fn cancel(&self, err: &mut DiagnosticBuilder<'_>) {\n-        err.cancel();\n-    }\n-\n-    fn panic_if_treat_err_as_bug(&self) {\n-        if self.treat_err_as_bug() {\n-            let s = match (self.err_count(), self.flags.treat_err_as_bug.unwrap_or(0)) {\n-                (0, _) => return,\n-                (1, 1) => \"aborting due to `-Z treat-err-as-bug=1`\".to_string(),\n-                (1, _) => return,\n-                (count, as_bug) => {\n-                    format!(\n-                        \"aborting after {} errors due to `-Z treat-err-as-bug={}`\",\n-                        count,\n-                        as_bug,\n-                    )\n-                }\n-            };\n-            panic!(s);\n-        }\n-    }\n-\n     pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> FatalError {\n-        self.emit(&sp.into(), msg, Fatal);\n+        self.emit_diagnostic(Diagnostic::new(Fatal, msg).set_span(sp));\n+        self.abort_if_errors_and_should_abort();\n         FatalError\n     }\n     pub fn span_fatal_with_code<S: Into<MultiSpan>>(&self,\n                                                     sp: S,\n                                                     msg: &str,\n                                                     code: DiagnosticId)\n                                                     -> FatalError {\n-        self.emit_with_code(&sp.into(), msg, code, Fatal);\n+        self.emit_diagnostic(Diagnostic::new_with_code(Fatal, Some(code), msg).set_span(sp));\n+        self.abort_if_errors_and_should_abort();\n         FatalError\n     }\n     pub fn span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.emit(&sp.into(), msg, Error);\n+        self.emit_diagnostic(Diagnostic::new(Error, msg).set_span(sp));\n+        self.abort_if_errors_and_should_abort();\n     }\n     pub fn mut_span_err<S: Into<MultiSpan>>(&self,\n                                             sp: S,\n@@ -565,38 +562,30 @@ impl Handler {\n         result\n     }\n     pub fn span_err_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: DiagnosticId) {\n-        self.emit_with_code(&sp.into(), msg, code, Error);\n+        self.emit_diagnostic(Diagnostic::new_with_code(Error, Some(code), msg).set_span(sp));\n+        self.abort_if_errors_and_should_abort();\n     }\n     pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.emit(&sp.into(), msg, Warning);\n+        self.emit_diagnostic(Diagnostic::new(Warning, msg).set_span(sp));\n+        self.abort_if_errors_and_should_abort();\n     }\n     pub fn span_warn_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: DiagnosticId) {\n-        self.emit_with_code(&sp.into(), msg, code, Warning);\n+        self.emit_diagnostic(Diagnostic::new_with_code(Warning, Some(code), msg).set_span(sp));\n+        self.abort_if_errors_and_should_abort();\n     }\n     pub fn span_bug<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n-        self.emit(&sp.into(), msg, Bug);\n-        panic!(ExplicitBug);\n+        self.inner.borrow_mut().span_bug(sp, msg)\n     }\n     pub fn delay_span_bug<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        if self.treat_err_as_bug() {\n-            // FIXME: don't abort here if report_delayed_bugs is off\n-            self.span_bug(sp, msg);\n-        }\n-        let mut diagnostic = Diagnostic::new(Level::Bug, msg);\n-        diagnostic.set_span(sp.into());\n-        self.delay_as_bug(diagnostic);\n-    }\n-    fn delay_as_bug(&self, diagnostic: Diagnostic) {\n-        if self.flags.report_delayed_bugs {\n-            DiagnosticBuilder::new_diagnostic(self, diagnostic.clone()).emit();\n-        }\n-        self.delayed_span_bugs.borrow_mut().push(diagnostic);\n+        self.inner.borrow_mut().delay_span_bug(sp, msg)\n     }\n     pub fn span_bug_no_panic<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.emit(&sp.into(), msg, Bug);\n+        self.emit_diagnostic(Diagnostic::new(Bug, msg).set_span(sp));\n+        self.abort_if_errors_and_should_abort();\n     }\n     pub fn span_note_without_error<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        self.emit(&sp.into(), msg, Note);\n+        self.emit_diagnostic(Diagnostic::new(Note, msg).set_span(sp));\n+        self.abort_if_errors_and_should_abort();\n     }\n     pub fn span_note_diag(&self,\n                           sp: Span,\n@@ -606,61 +595,129 @@ impl Handler {\n         db.set_span(sp);\n         db\n     }\n-    pub fn span_unimpl<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n-        self.span_bug(sp, &format!(\"unimplemented {}\", msg));\n-    }\n     pub fn failure(&self, msg: &str) {\n-        DiagnosticBuilder::new(self, FailureNote, msg).emit()\n+        self.inner.borrow_mut().failure(msg);\n     }\n     pub fn fatal(&self, msg: &str) -> FatalError {\n-        if self.treat_err_as_bug() {\n-            self.bug(msg);\n-        }\n-        DiagnosticBuilder::new(self, Fatal, msg).emit();\n-        FatalError\n+        self.inner.borrow_mut().fatal(msg)\n     }\n     pub fn err(&self, msg: &str) {\n-        if self.treat_err_as_bug() {\n-            self.bug(msg);\n-        }\n-        let mut db = DiagnosticBuilder::new(self, Error, msg);\n-        db.emit();\n+        self.inner.borrow_mut().err(msg);\n     }\n     pub fn warn(&self, msg: &str) {\n         let mut db = DiagnosticBuilder::new(self, Warning, msg);\n         db.emit();\n     }\n-    fn treat_err_as_bug(&self) -> bool {\n-        self.flags.treat_err_as_bug.map(|c| self.err_count() >= c).unwrap_or(false)\n-    }\n     pub fn note_without_error(&self, msg: &str) {\n         let mut db = DiagnosticBuilder::new(self, Note, msg);\n         db.emit();\n     }\n     pub fn bug(&self, msg: &str) -> ! {\n-        let mut db = DiagnosticBuilder::new(self, Bug, msg);\n-        db.emit();\n-        panic!(ExplicitBug);\n-    }\n-    pub fn unimpl(&self, msg: &str) -> ! {\n-        self.bug(&format!(\"unimplemented {}\", msg));\n-    }\n-\n-    fn bump_err_count(&self) {\n-        self.err_count.fetch_add(1, SeqCst);\n-        self.panic_if_treat_err_as_bug();\n+        self.inner.borrow_mut().bug(msg)\n     }\n \n     pub fn err_count(&self) -> usize {\n-        self.err_count.load(SeqCst)\n+        self.inner.borrow().err_count\n     }\n \n     pub fn has_errors(&self) -> bool {\n         self.err_count() > 0\n     }\n \n     pub fn print_error_count(&self, registry: &Registry) {\n-        let s = match self.deduplicated_err_count.load(SeqCst) {\n+        self.inner.borrow_mut().print_error_count(registry)\n+    }\n+\n+    pub fn abort_if_errors(&self) {\n+        self.inner.borrow().abort_if_errors()\n+    }\n+\n+    pub fn abort_if_errors_and_should_abort(&self) {\n+        self.inner.borrow().abort_if_errors_and_should_abort()\n+    }\n+\n+    pub fn must_teach(&self, code: &DiagnosticId) -> bool {\n+        self.inner.borrow_mut().must_teach(code)\n+    }\n+\n+    pub fn force_print_diagnostic(&self, db: Diagnostic) {\n+        self.inner.borrow_mut().force_print_diagnostic(db)\n+    }\n+\n+    pub fn emit_diagnostic(&self, diagnostic: &Diagnostic) {\n+        self.inner.borrow_mut().emit_diagnostic(diagnostic)\n+    }\n+\n+    pub fn emit_artifact_notification(&self, path: &Path, artifact_type: &str) {\n+        self.inner.borrow_mut().emit_artifact_notification(path, artifact_type)\n+    }\n+\n+    pub fn delay_as_bug(&self, diagnostic: Diagnostic) {\n+        self.inner.borrow_mut().delay_as_bug(diagnostic)\n+    }\n+}\n+\n+impl HandlerInner {\n+    /// `true` if we haven't taught a diagnostic with this code already.\n+    /// The caller must then teach the user about such a diagnostic.\n+    ///\n+    /// Used to suppress emitting the same error multiple times with extended explanation when\n+    /// calling `-Zteach`.\n+    fn must_teach(&mut self, code: &DiagnosticId) -> bool {\n+        self.taught_diagnostics.insert(code.clone())\n+    }\n+\n+    fn force_print_diagnostic(&mut self, db: Diagnostic) {\n+        self.emitter.emit_diagnostic(&db);\n+    }\n+\n+    fn emit_diagnostic(&mut self, diagnostic: &Diagnostic) {\n+        if diagnostic.cancelled() {\n+            return;\n+        }\n+\n+        if diagnostic.level == Warning && !self.flags.can_emit_warnings {\n+            return;\n+        }\n+\n+        TRACK_DIAGNOSTICS.with(|track_diagnostics| {\n+            track_diagnostics.get()(diagnostic);\n+        });\n+\n+        if let Some(ref code) = diagnostic.code {\n+            self.emitted_diagnostic_codes.insert(code.clone());\n+        }\n+\n+        let diagnostic_hash = {\n+            use std::hash::Hash;\n+            let mut hasher = StableHasher::new();\n+            diagnostic.hash(&mut hasher);\n+            hasher.finish()\n+        };\n+\n+        // Only emit the diagnostic if we haven't already emitted an equivalent\n+        // one:\n+        if self.emitted_diagnostics.insert(diagnostic_hash) {\n+            self.emitter.emit_diagnostic(diagnostic);\n+            if diagnostic.is_error() {\n+                self.deduplicated_err_count += 1;\n+            }\n+        }\n+        if diagnostic.is_error() {\n+            self.bump_err_count();\n+        }\n+    }\n+\n+    fn emit_artifact_notification(&mut self, path: &Path, artifact_type: &str) {\n+        self.emitter.emit_artifact_notification(path, artifact_type);\n+    }\n+\n+    fn treat_err_as_bug(&self) -> bool {\n+        self.flags.treat_err_as_bug.map(|c| self.err_count >= c).unwrap_or(false)\n+    }\n+\n+    fn print_error_count(&mut self, registry: &Registry) {\n+        let s = match self.deduplicated_err_count {\n             0 => return,\n             1 => \"aborting due to previous error\".to_string(),\n             count => format!(\"aborting due to {} previous errors\", count)\n@@ -671,12 +728,11 @@ impl Handler {\n \n         let _ = self.fatal(&s);\n \n-        let can_show_explain = self.emitter.borrow().should_show_explain();\n-        let are_there_diagnostics = !self.emitted_diagnostic_codes.borrow().is_empty();\n+        let can_show_explain = self.emitter.should_show_explain();\n+        let are_there_diagnostics = !self.emitted_diagnostic_codes.is_empty();\n         if can_show_explain && are_there_diagnostics {\n             let mut error_codes = self\n                 .emitted_diagnostic_codes\n-                .borrow()\n                 .iter()\n                 .filter_map(|x| match &x {\n                     DiagnosticId::Error(s) if registry.find_description(s).is_some() => {\n@@ -704,81 +760,86 @@ impl Handler {\n         }\n     }\n \n-    pub fn abort_if_errors(&self) {\n-        if self.has_errors() {\n+    fn abort_if_errors_and_should_abort(&self) {\n+        if self.err_count > 0 && !self.continue_after_error {\n             FatalError.raise();\n         }\n     }\n-    pub fn emit(&self, msp: &MultiSpan, msg: &str, lvl: Level) {\n-        if lvl == Warning && !self.flags.can_emit_warnings {\n-            return;\n-        }\n-        let mut db = DiagnosticBuilder::new(self, lvl, msg);\n-        db.set_span(msp.clone());\n-        db.emit();\n-        if !self.continue_after_error.load(SeqCst) {\n-            self.abort_if_errors();\n-        }\n-    }\n-    pub fn emit_with_code(&self, msp: &MultiSpan, msg: &str, code: DiagnosticId, lvl: Level) {\n-        if lvl == Warning && !self.flags.can_emit_warnings {\n-            return;\n-        }\n-        let mut db = DiagnosticBuilder::new_with_code(self, lvl, Some(code), msg);\n-        db.set_span(msp.clone());\n-        db.emit();\n-        if !self.continue_after_error.load(SeqCst) {\n-            self.abort_if_errors();\n+\n+    fn abort_if_errors(&self) {\n+        if self.err_count > 0 {\n+            FatalError.raise();\n         }\n     }\n \n-    /// `true` if we haven't taught a diagnostic with this code already.\n-    /// The caller must then teach the user about such a diagnostic.\n-    ///\n-    /// Used to suppress emitting the same error multiple times with extended explanation when\n-    /// calling `-Zteach`.\n-    pub fn must_teach(&self, code: &DiagnosticId) -> bool {\n-        self.taught_diagnostics.borrow_mut().insert(code.clone())\n+    fn span_bug<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> ! {\n+        self.emit_diagnostic(Diagnostic::new(Bug, msg).set_span(sp));\n+        self.abort_if_errors_and_should_abort();\n+        panic!(ExplicitBug);\n     }\n \n-    pub fn force_print_db(&self, mut db: DiagnosticBuilder<'_>) {\n-        self.emitter.borrow_mut().emit_diagnostic(&db);\n-        db.cancel();\n+    fn delay_span_bug<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) {\n+        if self.treat_err_as_bug() {\n+            // FIXME: don't abort here if report_delayed_bugs is off\n+            self.span_bug(sp, msg);\n+        }\n+        let mut diagnostic = Diagnostic::new(Level::Bug, msg);\n+        diagnostic.set_span(sp.into());\n+        self.delay_as_bug(diagnostic)\n     }\n \n-    fn emit_db(&self, db: &DiagnosticBuilder<'_>) {\n-        let diagnostic = &**db;\n+    fn failure(&mut self, msg: &str) {\n+        self.emit_diagnostic(&Diagnostic::new(FailureNote, msg));\n+    }\n \n-        TRACK_DIAGNOSTICS.with(|track_diagnostics| {\n-            track_diagnostics.get()(diagnostic);\n-        });\n+    fn fatal(&mut self, msg: &str) -> FatalError {\n+        if self.treat_err_as_bug() {\n+            self.bug(msg);\n+        }\n+        self.emit_diagnostic(&Diagnostic::new(Fatal, msg));\n+        FatalError\n+    }\n \n-        if let Some(ref code) = diagnostic.code {\n-            self.emitted_diagnostic_codes.borrow_mut().insert(code.clone());\n+    fn err(&mut self, msg: &str) {\n+        if self.treat_err_as_bug() {\n+            self.bug(msg);\n         }\n+        self.emit_diagnostic(&Diagnostic::new(Error, msg));\n+    }\n \n-        let diagnostic_hash = {\n-            use std::hash::Hash;\n-            let mut hasher = StableHasher::new();\n-            diagnostic.hash(&mut hasher);\n-            hasher.finish()\n-        };\n+    fn bug(&mut self, msg: &str) -> ! {\n+        self.emit_diagnostic(&Diagnostic::new(Bug, msg));\n+        panic!(ExplicitBug);\n+    }\n \n-        // Only emit the diagnostic if we haven't already emitted an equivalent\n-        // one:\n-        if self.emitted_diagnostics.borrow_mut().insert(diagnostic_hash) {\n-            self.emitter.borrow_mut().emit_diagnostic(db);\n-            if db.is_error() {\n-                self.deduplicated_err_count.fetch_add(1, SeqCst);\n-            }\n-        }\n-        if db.is_error() {\n-            self.bump_err_count();\n+    fn delay_as_bug(&mut self, diagnostic: Diagnostic) {\n+        if self.flags.report_delayed_bugs {\n+            self.emit_diagnostic(&diagnostic);\n         }\n+        self.delayed_span_bugs.push(diagnostic);\n     }\n \n-    pub fn emit_artifact_notification(&self, path: &Path, artifact_type: &str) {\n-        self.emitter.borrow_mut().emit_artifact_notification(path, artifact_type);\n+    fn bump_err_count(&mut self) {\n+        self.err_count += 1;\n+        self.panic_if_treat_err_as_bug();\n+    }\n+\n+    fn panic_if_treat_err_as_bug(&self) {\n+        if self.treat_err_as_bug() {\n+            let s = match (self.err_count, self.flags.treat_err_as_bug.unwrap_or(0)) {\n+                (0, _) => return,\n+                (1, 1) => \"aborting due to `-Z treat-err-as-bug=1`\".to_string(),\n+                (1, _) => return,\n+                (count, as_bug) => {\n+                    format!(\n+                        \"aborting after {} errors due to `-Z treat-err-as-bug={}`\",\n+                        count,\n+                        as_bug,\n+                    )\n+                }\n+            };\n+            panic!(s);\n+        }\n     }\n }\n "}, {"sha": "32c6dd67a4b5af42a6c6b58828b0d6d7e7da26a6", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=66bf391c3aabfc77f5f7139fc9e6944f995d574e", "patch": "@@ -402,7 +402,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         }\n \n         for diag in mbcx.errors_buffer.drain(..) {\n-            DiagnosticBuilder::new_diagnostic(mbcx.infcx.tcx.sess.diagnostic(), diag).emit();\n+            mbcx.infcx.tcx.sess.diagnostic().emit_diagnostic(&diag);\n         }\n     }\n "}, {"sha": "1cc71ea5649de23e056dc3a559a7643702e79149", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=66bf391c3aabfc77f5f7139fc9e6944f995d574e", "patch": "@@ -3,7 +3,6 @@\n // substitutions.\n \n use crate::check::FnCtxt;\n-use errors::DiagnosticBuilder;\n use rustc::hir;\n use rustc::hir::def_id::{DefId, DefIndex};\n use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n@@ -407,7 +406,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         if !errors_buffer.is_empty() {\n             errors_buffer.sort_by_key(|diag| diag.span.primary_span());\n             for diag in errors_buffer.drain(..) {\n-                DiagnosticBuilder::new_diagnostic(self.tcx().sess.diagnostic(), diag).emit();\n+                self.tcx().sess.diagnostic().emit_diagnostic(&diag);\n             }\n         }\n     }"}, {"sha": "010e4cf6cd0d53c8bee7bc78224a6dedb63d7799", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=66bf391c3aabfc77f5f7139fc9e6944f995d574e", "patch": "@@ -193,6 +193,7 @@ pub fn new_handler(error_format: ErrorOutputType,\n                     short,\n                     sessopts.debugging_opts.teach,\n                     sessopts.debugging_opts.terminal_width,\n+                    false,\n                 ).ui_testing(ui_testing)\n             )\n         },\n@@ -205,6 +206,7 @@ pub fn new_handler(error_format: ErrorOutputType,\n                     source_map,\n                     pretty,\n                     json_rendered,\n+                    false,\n                 ).ui_testing(ui_testing)\n             )\n         },"}, {"sha": "424239c9982373b25a4981f800dd8a07b8ff1992", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=66bf391c3aabfc77f5f7139fc9e6944f995d574e", "patch": "@@ -401,7 +401,7 @@ pub fn make_test(s: &str,\n         // Any errors in parsing should also appear when the doctest is compiled for real, so just\n         // send all the errors that libsyntax emits directly into a `Sink` instead of stderr.\n         let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-        let emitter = EmitterWriter::new(box io::sink(), None, false, false, false, None);\n+        let emitter = EmitterWriter::new(box io::sink(), None, false, false, false, None, false);\n         // FIXME(misdreavus): pass `-Z treat-err-as-bug` to the doctest parser\n         let handler = Handler::with_emitter(false, None, box emitter);\n         let sess = ParseSess::with_span_handler(handler, cm);"}, {"sha": "a6be5b101788e36b2e343213083478793e0b71e2", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=66bf391c3aabfc77f5f7139fc9e6944f995d574e", "patch": "@@ -1048,9 +1048,6 @@ impl<'a> ExtCtxt<'a> {\n     pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.parse_sess.span_diagnostic.span_warn(sp, msg);\n     }\n-    pub fn span_unimpl<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n-        self.parse_sess.span_diagnostic.span_unimpl(sp, msg);\n-    }\n     pub fn span_bug<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n         self.parse_sess.span_diagnostic.span_bug(sp, msg);\n     }"}, {"sha": "dfec9ee28809a098d38d9a2459c077758e856052", "filename": "src/libsyntax/ext/proc_macro_server.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fproc_macro_server.rs?ref=66bf391c3aabfc77f5f7139fc9e6944f995d574e", "patch": "@@ -4,7 +4,7 @@ use crate::parse::{self, token, ParseSess};\n use crate::parse::lexer::comments;\n use crate::tokenstream::{self, DelimSpan, IsJoint::*, TokenStream, TreeAndJoint};\n \n-use errors::{Diagnostic, DiagnosticBuilder};\n+use errors::Diagnostic;\n use rustc_data_structures::sync::Lrc;\n use syntax_pos::{BytePos, FileName, MultiSpan, Pos, SourceFile, Span};\n use syntax_pos::symbol::{kw, sym, Symbol};\n@@ -650,7 +650,7 @@ impl server::Diagnostic for Rustc<'_> {\n         diag.sub(level.to_internal(), msg, MultiSpan::from_spans(spans), None);\n     }\n     fn emit(&mut self, diag: Self::Diagnostic) {\n-        DiagnosticBuilder::new_diagnostic(&self.sess.span_diagnostic, diag).emit()\n+        self.sess.span_diagnostic.emit_diagnostic(&diag);\n     }\n }\n "}, {"sha": "5cdea3aabbe11f7552ae0d5e17f40347272ac3b9", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=66bf391c3aabfc77f5f7139fc9e6944f995d574e", "patch": "@@ -12,7 +12,7 @@\n use crate::source_map::{SourceMap, FilePathMapping};\n \n use errors::registry::Registry;\n-use errors::{DiagnosticBuilder, SubDiagnostic, CodeSuggestion, SourceMapper};\n+use errors::{SubDiagnostic, CodeSuggestion, SourceMapper};\n use errors::{DiagnosticId, Applicability};\n use errors::emitter::{Emitter, HumanReadableErrorType};\n \n@@ -32,6 +32,7 @@ pub struct JsonEmitter {\n     pretty: bool,\n     ui_testing: bool,\n     json_rendered: HumanReadableErrorType,\n+    external_macro_backtrace: bool,\n }\n \n impl JsonEmitter {\n@@ -40,6 +41,7 @@ impl JsonEmitter {\n         source_map: Lrc<SourceMap>,\n         pretty: bool,\n         json_rendered: HumanReadableErrorType,\n+        external_macro_backtrace: bool,\n     ) -> JsonEmitter {\n         JsonEmitter {\n             dst: Box::new(io::stderr()),\n@@ -48,13 +50,18 @@ impl JsonEmitter {\n             pretty,\n             ui_testing: false,\n             json_rendered,\n+            external_macro_backtrace,\n         }\n     }\n \n-    pub fn basic(pretty: bool, json_rendered: HumanReadableErrorType) -> JsonEmitter {\n+    pub fn basic(\n+        pretty: bool,\n+        json_rendered: HumanReadableErrorType,\n+        external_macro_backtrace: bool,\n+    ) -> JsonEmitter {\n         let file_path_mapping = FilePathMapping::empty();\n         JsonEmitter::stderr(None, Lrc::new(SourceMap::new(file_path_mapping)),\n-                            pretty, json_rendered)\n+                            pretty, json_rendered, external_macro_backtrace)\n     }\n \n     pub fn new(\n@@ -63,6 +70,7 @@ impl JsonEmitter {\n         source_map: Lrc<SourceMap>,\n         pretty: bool,\n         json_rendered: HumanReadableErrorType,\n+        external_macro_backtrace: bool,\n     ) -> JsonEmitter {\n         JsonEmitter {\n             dst,\n@@ -71,6 +79,7 @@ impl JsonEmitter {\n             pretty,\n             ui_testing: false,\n             json_rendered,\n+            external_macro_backtrace,\n         }\n     }\n \n@@ -80,8 +89,8 @@ impl JsonEmitter {\n }\n \n impl Emitter for JsonEmitter {\n-    fn emit_diagnostic(&mut self, db: &DiagnosticBuilder<'_>) {\n-        let data = Diagnostic::from_diagnostic_builder(db, self);\n+    fn emit_diagnostic(&mut self, db: &errors::Diagnostic) {\n+        let data = Diagnostic::from_errors_diagnostic(db, self);\n         let result = if self.pretty {\n             writeln!(&mut self.dst, \"{}\", as_pretty_json(&data))\n         } else {\n@@ -189,7 +198,7 @@ struct ArtifactNotification<'a> {\n }\n \n impl Diagnostic {\n-    fn from_diagnostic_builder(db: &DiagnosticBuilder<'_>,\n+    fn from_errors_diagnostic(db: &errors::Diagnostic,\n                                je: &JsonEmitter)\n                                -> Diagnostic {\n         let sugg = db.suggestions.iter().map(|sugg| {\n@@ -219,8 +228,9 @@ impl Diagnostic {\n         }\n         let buf = BufWriter::default();\n         let output = buf.clone();\n-        je.json_rendered.new_emitter(Box::new(buf), Some(je.sm.clone()), false, None)\n-            .ui_testing(je.ui_testing).emit_diagnostic(db);\n+        je.json_rendered.new_emitter(\n+            Box::new(buf), Some(je.sm.clone()), false, None, je.external_macro_backtrace\n+        ).ui_testing(je.ui_testing).emit_diagnostic(db);\n         let output = Arc::try_unwrap(output.0).unwrap().into_inner().unwrap();\n         let output = String::from_utf8(output).unwrap();\n "}, {"sha": "b4ae1e87bca28fb65e63b525742a2c132bb198a8", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=66bf391c3aabfc77f5f7139fc9e6944f995d574e", "patch": "@@ -60,12 +60,12 @@ macro_rules! panictry {\n macro_rules! panictry_buffer {\n     ($handler:expr, $e:expr) => ({\n         use std::result::Result::{Ok, Err};\n-        use errors::{FatalError, DiagnosticBuilder};\n+        use errors::FatalError;\n         match $e {\n             Ok(e) => e,\n             Err(errs) => {\n                 for e in errs {\n-                    DiagnosticBuilder::new_diagnostic($handler, e).emit();\n+                    $handler.emit_diagnostic(&e);\n                 }\n                 FatalError.raise()\n             }"}, {"sha": "cf6151d17b1bd3810a620c7d03f0917055045734", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=66bf391c3aabfc77f5f7139fc9e6944f995d574e", "patch": "@@ -302,14 +302,14 @@ impl<'a> Parser<'a> {\n             Ok(lit) => {\n                 return Ok(ast::NestedMetaItem::Literal(lit))\n             }\n-            Err(ref mut err) => self.diagnostic().cancel(err)\n+            Err(ref mut err) => err.cancel(),\n         }\n \n         match self.parse_meta_item() {\n             Ok(mi) => {\n                 return Ok(ast::NestedMetaItem::MetaItem(mi))\n             }\n-            Err(ref mut err) => self.diagnostic().cancel(err)\n+            Err(ref mut err) => err.cancel(),\n         }\n \n         let found = self.this_token_to_string();"}, {"sha": "59de5f1412358fce2e10e8b31746b02b230f09cd", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=66bf391c3aabfc77f5f7139fc9e6944f995d574e", "patch": "@@ -197,10 +197,6 @@ impl<'a> Parser<'a> {\n         self.sess.span_diagnostic.span_bug(sp, m)\n     }\n \n-    crate fn cancel(&self, err: &mut DiagnosticBuilder<'_>) {\n-        self.sess.span_diagnostic.cancel(err)\n-    }\n-\n     crate fn diagnostic(&self) -> &'a errors::Handler {\n         &self.sess.span_diagnostic\n     }\n@@ -426,15 +422,13 @@ impl<'a> Parser<'a> {\n     /// Eats and discards tokens until one of `kets` is encountered. Respects token trees,\n     /// passes through any errors encountered. Used for error recovery.\n     crate fn eat_to_tokens(&mut self, kets: &[&TokenKind]) {\n-        let handler = self.diagnostic();\n-\n         if let Err(ref mut err) = self.parse_seq_to_before_tokens(\n             kets,\n             SeqSep::none(),\n             TokenExpectType::Expect,\n             |p| Ok(p.parse_token_tree()),\n         ) {\n-            handler.cancel(err);\n+            err.cancel();\n         }\n     }\n "}, {"sha": "de301b1fc499d9aa43048174657fc88cbdacc67d", "filename": "src/libsyntax/parse/lexer/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibsyntax%2Fparse%2Flexer%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibsyntax%2Fparse%2Flexer%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Ftests.rs?ref=66bf391c3aabfc77f5f7139fc9e6944f995d574e", "patch": "@@ -18,6 +18,7 @@ fn mk_sess(sm: Lrc<SourceMap>) -> ParseSess {\n         false,\n         false,\n         None,\n+        false,\n     );\n     ParseSess::with_span_handler(Handler::with_emitter(true, None, Box::new(emitter)), sm)\n }"}, {"sha": "fa4c10431228ade0ce645b5c270031a585f64592", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=66bf391c3aabfc77f5f7139fc9e6944f995d574e", "patch": "@@ -304,7 +304,7 @@ fn file_to_source_file(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n     match try_file_to_source_file(sess, path, spanopt) {\n         Ok(source_file) => source_file,\n         Err(d) => {\n-            DiagnosticBuilder::new_diagnostic(&sess.span_diagnostic, d).emit();\n+            sess.span_diagnostic.emit_diagnostic(&d);\n             FatalError.raise();\n         }\n     }"}, {"sha": "d0c865a7b8e83b5d13e6b8ca3608d6c9b96b3be7", "filename": "src/libsyntax/parse/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs?ref=66bf391c3aabfc77f5f7139fc9e6944f995d574e", "patch": "@@ -777,7 +777,7 @@ impl<'a> Parser<'a> {\n                         ex = ExprKind::Lit(literal);\n                     }\n                     Err(mut err) => {\n-                        self.cancel(&mut err);\n+                        err.cancel();\n                         return Err(self.expected_expression_found());\n                     }\n                 }"}, {"sha": "3c624959eadb100eff7e5891d7a8a2bcc8af30e8", "filename": "src/libsyntax/parse/parser/pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs?ref=66bf391c3aabfc77f5f7139fc9e6944f995d574e", "patch": "@@ -537,7 +537,7 @@ impl<'a> Parser<'a> {\n         mut err: DiagnosticBuilder<'a>,\n         expected: Expected,\n     ) -> PResult<'a, P<Pat>> {\n-        self.cancel(&mut err);\n+        err.cancel();\n \n         let expected = expected.unwrap_or(\"pattern\");\n         let msg = format!(\"expected {}, found {}\", expected, self.this_token_descr());"}, {"sha": "02da56f6e35a7b36b0b9689ed7e4a655dddd7de1", "filename": "src/libsyntax/parse/parser/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs?ref=66bf391c3aabfc77f5f7139fc9e6944f995d574e", "patch": "@@ -361,7 +361,7 @@ impl<'a> Parser<'a> {\n                 }\n                 Err(mut e) => {\n                     self.recover_stmt_(SemiColonMode::Break, BlockMode::Ignore);\n-                    self.cancel(&mut e);\n+                    e.cancel();\n                 }\n                 _ => ()\n             }"}, {"sha": "f510ac9273d097ab45ff6f6220b61ce899c781fb", "filename": "src/libsyntax/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibsyntax%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66bf391c3aabfc77f5f7139fc9e6944f995d574e/src%2Flibsyntax%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftests.rs?ref=66bf391c3aabfc77f5f7139fc9e6944f995d574e", "patch": "@@ -147,6 +147,7 @@ fn test_harness(file_text: &str, span_labels: Vec<SpanLabel>, expected_output: &\n             false,\n             false,\n             None,\n+            false,\n         );\n         let handler = Handler::with_emitter(true, None, Box::new(emitter));\n         handler.span_err(msp, \"foo\");"}]}