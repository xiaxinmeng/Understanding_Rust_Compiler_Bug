{"sha": "38bdbb7cf9bebcc4b6331644f52f9d6e52754782", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4YmRiYjdjZjliZWJjYzRiNjMzMTY0NGY1MmY5ZDZlNTI3NTQ3ODI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-11T13:04:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-08-11T13:04:59Z"}, "message": "Auto merge of #43748 - RalfJung:mir-validate2, r=arielb1\n\nAddValidation: handle Call terminators into blocks that have multiple incoming edges\n\nThe old code was just wrong: It would add validation on paths that don't even come from the call, and it would add multiple validations if multiple calls end return to the same block.", "tree": {"sha": "21964556486450a098635063acbba3f18ed43be7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21964556486450a098635063acbba3f18ed43be7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38bdbb7cf9bebcc4b6331644f52f9d6e52754782", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38bdbb7cf9bebcc4b6331644f52f9d6e52754782", "html_url": "https://github.com/rust-lang/rust/commit/38bdbb7cf9bebcc4b6331644f52f9d6e52754782", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38bdbb7cf9bebcc4b6331644f52f9d6e52754782/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "59675d29eb47eb743026dcc0737884f548f2197a", "url": "https://api.github.com/repos/rust-lang/rust/commits/59675d29eb47eb743026dcc0737884f548f2197a", "html_url": "https://github.com/rust-lang/rust/commit/59675d29eb47eb743026dcc0737884f548f2197a"}, {"sha": "718a8d1c3836170eaee78d337a40e14d5a0adee6", "url": "https://api.github.com/repos/rust-lang/rust/commits/718a8d1c3836170eaee78d337a40e14d5a0adee6", "html_url": "https://github.com/rust-lang/rust/commit/718a8d1c3836170eaee78d337a40e14d5a0adee6"}], "stats": {"total": 90, "additions": 50, "deletions": 40}, "files": [{"sha": "cf36aef1c3083fd41aa2a1d5ceefb75361264f2c", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/38bdbb7cf9bebcc4b6331644f52f9d6e52754782/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bdbb7cf9bebcc4b6331644f52f9d6e52754782/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=38bdbb7cf9bebcc4b6331644f52f9d6e52754782", "patch": "@@ -949,15 +949,16 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     // These next passes must be executed together\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::no_landing_pads::NoLandingPads);\n-    passes.push_pass(MIR_OPTIMIZED, mir::transform::add_call_guards::AddCallGuards);\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::add_call_guards::CriticalCallEdges);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::elaborate_drops::ElaborateDrops);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::no_landing_pads::NoLandingPads);\n+    // AddValidation needs to run after ElaborateDrops and before EraseRegions, and it needs\n+    // an AllCallEdges pass right before it.\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::add_call_guards::AllCallEdges);\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::add_validation::AddValidation);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::simplify::SimplifyCfg::new(\"elaborate-drops\"));\n     // No lifetime analysis based on borrowing can be done from here on out.\n \n-    // AddValidation needs to run after ElaborateDrops and before EraseRegions.\n-    passes.push_pass(MIR_OPTIMIZED, mir::transform::add_validation::AddValidation);\n-\n     // From here on out, regions are gone.\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::erase_regions::EraseRegions);\n \n@@ -967,7 +968,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::deaggregator::Deaggregator);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::copy_prop::CopyPropagation);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::simplify::SimplifyLocals);\n-    passes.push_pass(MIR_OPTIMIZED, mir::transform::add_call_guards::AddCallGuards);\n+    passes.push_pass(MIR_OPTIMIZED, mir::transform::add_call_guards::CriticalCallEdges);\n     passes.push_pass(MIR_OPTIMIZED, mir::transform::dump_mir::Marker(\"PreTrans\"));\n \n     TyCtxt::create_and_enter(sess,"}, {"sha": "62e762be93a71938a7a3f93ccfdc40d1186a43f7", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/38bdbb7cf9bebcc4b6331644f52f9d6e52754782/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bdbb7cf9bebcc4b6331644f52f9d6e52754782/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=38bdbb7cf9bebcc4b6331644f52f9d6e52754782", "patch": "@@ -105,7 +105,7 @@ fn make_shim<'a, 'tcx>(tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n         debug!(\"make_shim({:?}) = untransformed {:?}\", instance, result);\n         no_landing_pads::no_landing_pads(tcx, &mut result);\n         simplify::simplify_cfg(&mut result);\n-        add_call_guards::add_call_guards(&mut result);\n+        add_call_guards::CriticalCallEdges.add_call_guards(&mut result);\n     debug!(\"make_shim({:?}) = {:?}\", instance, result);\n \n     tcx.alloc_mir(result)"}, {"sha": "23a9c4c57ca6a39b107b2fef139c8540e3145457", "filename": "src/librustc_mir/transform/add_call_guards.rs", "status": "modified", "additions": 43, "deletions": 34, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/38bdbb7cf9bebcc4b6331644f52f9d6e52754782/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38bdbb7cf9bebcc4b6331644f52f9d6e52754782/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_call_guards.rs?ref=38bdbb7cf9bebcc4b6331644f52f9d6e52754782", "patch": "@@ -13,7 +13,12 @@ use rustc::mir::*;\n use rustc::mir::transform::{MirPass, MirSource};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n \n-pub struct AddCallGuards;\n+#[derive(PartialEq)]\n+pub enum AddCallGuards {\n+    AllCallEdges,\n+    CriticalCallEdges,\n+}\n+pub use self::AddCallGuards::*;\n \n /**\n  * Breaks outgoing critical edges for call terminators in the MIR.\n@@ -40,48 +45,52 @@ impl MirPass for AddCallGuards {\n                           _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           _src: MirSource,\n                           mir: &mut Mir<'tcx>) {\n-        add_call_guards(mir);\n+        self.add_call_guards(mir);\n     }\n }\n \n-pub fn add_call_guards(mir: &mut Mir) {\n-    let pred_count: IndexVec<_, _> =\n-        mir.predecessors().iter().map(|ps| ps.len()).collect();\n+impl AddCallGuards {\n+    pub fn add_call_guards(&self, mir: &mut Mir) {\n+        let pred_count: IndexVec<_, _> =\n+            mir.predecessors().iter().map(|ps| ps.len()).collect();\n \n-    // We need a place to store the new blocks generated\n-    let mut new_blocks = Vec::new();\n+        // We need a place to store the new blocks generated\n+        let mut new_blocks = Vec::new();\n \n-    let cur_len = mir.basic_blocks().len();\n+        let cur_len = mir.basic_blocks().len();\n \n-    for block in mir.basic_blocks_mut() {\n-        match block.terminator {\n-            Some(Terminator {\n-                kind: TerminatorKind::Call {\n-                    destination: Some((_, ref mut destination)),\n-                    cleanup: Some(_),\n-                    ..\n-                }, source_info\n-            }) if pred_count[*destination] > 1 => {\n-                // It's a critical edge, break it\n-                let call_guard = BasicBlockData {\n-                    statements: vec![],\n-                    is_cleanup: block.is_cleanup,\n-                    terminator: Some(Terminator {\n-                        source_info: source_info,\n-                        kind: TerminatorKind::Goto { target: *destination }\n-                    })\n-                };\n+        for block in mir.basic_blocks_mut() {\n+            match block.terminator {\n+                Some(Terminator {\n+                    kind: TerminatorKind::Call {\n+                        destination: Some((_, ref mut destination)),\n+                        cleanup,\n+                        ..\n+                    }, source_info\n+                }) if pred_count[*destination] > 1 &&\n+                      (cleanup.is_some() || self == &AllCallEdges) =>\n+                {\n+                    // It's a critical edge, break it\n+                    let call_guard = BasicBlockData {\n+                        statements: vec![],\n+                        is_cleanup: block.is_cleanup,\n+                        terminator: Some(Terminator {\n+                            source_info: source_info,\n+                            kind: TerminatorKind::Goto { target: *destination }\n+                        })\n+                    };\n \n-                // Get the index it will be when inserted into the MIR\n-                let idx = cur_len + new_blocks.len();\n-                new_blocks.push(call_guard);\n-                *destination = BasicBlock::new(idx);\n+                    // Get the index it will be when inserted into the MIR\n+                    let idx = cur_len + new_blocks.len();\n+                    new_blocks.push(call_guard);\n+                    *destination = BasicBlock::new(idx);\n+                }\n+                _ => {}\n             }\n-            _ => {}\n         }\n-    }\n \n-    debug!(\"Broke {} N edges\", new_blocks.len());\n+        debug!(\"Broke {} N edges\", new_blocks.len());\n \n-    mir.basic_blocks_mut().extend(new_blocks);\n+        mir.basic_blocks_mut().extend(new_blocks);\n+    }\n }"}]}