{"sha": "25017f8bcece0f57cc1acd3b64394f30cbda11f4", "node_id": "C_kwDOAAsO6NoAKDI1MDE3ZjhiY2VjZTBmNTdjYzFhY2QzYjY0Mzk0ZjMwY2JkYTExZjQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-09-30T08:22:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-09-30T08:22:36Z"}, "message": "Rollup merge of #101075 - ellishg:rustc_codegen_gcc_diagnostics, r=davidtwco\n\nMigrate rustc_codegen_gcc to SessionDiagnostics\n\nAs part of #100717 this pr migrates diagnostics to `SessionDiagnostics` for the `rustc_codegen_gcc` crate.\n\n``@rustbot`` label +A-translation", "tree": {"sha": "b1b15ccfd08bead80e5d89d0a79b3ede9e9445ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1b15ccfd08bead80e5d89d0a79b3ede9e9445ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25017f8bcece0f57cc1acd3b64394f30cbda11f4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjNqdMCRBK7hj4Ov3rIwAAEikIAIDFzeeWzWVlGs5OmDWH+h62\na8iBy7YpkVQIMrIpBKTblor1miLYYTZTYU7Gl47DXp7jeZ1i6ff8aBEFEI1sjB6P\ne5IfuNBonVLqM2PpSqGKCOBSy9TCfi/FTyQ0mfantCjqMSOngP+TQbEDXbfIxpzf\njd3QJpnvS5C/O27X3l31tmcKOMlQ1/L65vznzcHXHyQogV+A5zl2lzZPQm+fyCQi\nqdu3BAl9ht/9L4QWqSwgf3VIJ5MYKZvpG6Decd8TV8SCYwNFrq44O8J1cZyDrgWJ\nBNBZGN4djQVb1n0PeIGoWoR4N7AkMblqYso1x5Lt3LkjbbzDrPbLepnka5QGkOk=\n=ntUC\n-----END PGP SIGNATURE-----\n", "payload": "tree b1b15ccfd08bead80e5d89d0a79b3ede9e9445ce\nparent b3aa4997d4817c5ea2b33ba20f6fe7c695e4f64c\nparent 01439c93b8ce1faadb207cd0d5bb3ce6a3cbf1be\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1664526156 +0200\ncommitter GitHub <noreply@github.com> 1664526156 +0200\n\nRollup merge of #101075 - ellishg:rustc_codegen_gcc_diagnostics, r=davidtwco\n\nMigrate rustc_codegen_gcc to SessionDiagnostics\n\nAs part of #100717 this pr migrates diagnostics to `SessionDiagnostics` for the `rustc_codegen_gcc` crate.\n\n``@rustbot`` label +A-translation\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25017f8bcece0f57cc1acd3b64394f30cbda11f4", "html_url": "https://github.com/rust-lang/rust/commit/25017f8bcece0f57cc1acd3b64394f30cbda11f4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25017f8bcece0f57cc1acd3b64394f30cbda11f4/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3aa4997d4817c5ea2b33ba20f6fe7c695e4f64c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3aa4997d4817c5ea2b33ba20f6fe7c695e4f64c", "html_url": "https://github.com/rust-lang/rust/commit/b3aa4997d4817c5ea2b33ba20f6fe7c695e4f64c"}, {"sha": "01439c93b8ce1faadb207cd0d5bb3ce6a3cbf1be", "url": "https://api.github.com/repos/rust-lang/rust/commits/01439c93b8ce1faadb207cd0d5bb3ce6a3cbf1be", "html_url": "https://github.com/rust-lang/rust/commit/01439c93b8ce1faadb207cd0d5bb3ce6a3cbf1be"}], "stats": {"total": 580, "additions": 417, "deletions": 163}, "files": [{"sha": "ac0342f6b80a02c8632780c6a6844d2f4ffff104", "filename": "compiler/rustc_codegen_gcc/src/archive.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/25017f8bcece0f57cc1acd3b64394f30cbda11f4/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25017f8bcece0f57cc1acd3b64394f30cbda11f4/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Farchive.rs?ref=25017f8bcece0f57cc1acd3b64394f30cbda11f4", "patch": "@@ -1,6 +1,8 @@\n use std::fs::File;\n use std::path::{Path, PathBuf};\n \n+use crate::errors::RanlibFailure;\n+\n use rustc_codegen_ssa::back::archive::{ArchiveBuilder, ArchiveBuilderBuilder};\n use rustc_session::Session;\n \n@@ -181,7 +183,7 @@ impl<'a> ArchiveBuilder<'a> for ArArchiveBuilder<'a> {\n             std::process::Command::new(\"ranlib\").arg(output).status().expect(\"Couldn't run ranlib\");\n \n         if !status.success() {\n-            self.config.sess.fatal(&format!(\"Ranlib exited with code {:?}\", status.code()));\n+            self.config.sess.emit_fatal(RanlibFailure::new(status.code()));\n         }\n \n         any_members"}, {"sha": "007b001f213f8cff99b7bed26e607d367db234e2", "filename": "compiler/rustc_codegen_gcc/src/asm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/25017f8bcece0f57cc1acd3b64394f30cbda11f4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25017f8bcece0f57cc1acd3b64394f30cbda11f4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs?ref=25017f8bcece0f57cc1acd3b64394f30cbda11f4", "patch": "@@ -12,6 +12,7 @@ use std::borrow::Cow;\n \n use crate::builder::Builder;\n use crate::context::CodegenCx;\n+use crate::errors::UnwindingInlineAsm;\n use crate::type_of::LayoutGccExt;\n use crate::callee::get_fn;\n \n@@ -109,7 +110,7 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n     fn codegen_inline_asm(&mut self, template: &[InlineAsmTemplatePiece], rust_operands: &[InlineAsmOperandRef<'tcx, Self>], options: InlineAsmOptions, span: &[Span], _instance: Instance<'_>, _dest_catch_funclet: Option<(Self::BasicBlock, Self::BasicBlock, Option<&Self::Funclet>)>) {\n         if options.contains(InlineAsmOptions::MAY_UNWIND) {\n             self.sess()\n-                .struct_span_err(span[0], \"GCC backend does not support unwinding from inline asm\")\n+                .create_err(UnwindingInlineAsm { span: span[0] })\n                 .emit();\n             return;\n         }"}, {"sha": "81f533288677a3ae1b1767185c30414672256452", "filename": "compiler/rustc_codegen_gcc/src/consts.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/25017f8bcece0f57cc1acd3b64394f30cbda11f4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25017f8bcece0f57cc1acd3b64394f30cbda11f4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs?ref=25017f8bcece0f57cc1acd3b64394f30cbda11f4", "patch": "@@ -14,6 +14,7 @@ use rustc_target::abi::{self, Align, HasDataLayout, Primitive, Size, WrappingRan\n \n use crate::base;\n use crate::context::CodegenCx;\n+use crate::errors::LinkageConstOrMutType;\n use crate::type_of::LayoutGccExt;\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n@@ -368,10 +369,7 @@ fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &Codeg\n                 cx.layout_of(mt.ty).gcc_type(cx, true)\n             }\n             else {\n-                cx.sess().span_fatal(\n-                    span,\n-                    \"must have type `*const T` or `*mut T` due to `#[linkage]` attribute\",\n-                )\n+                cx.sess().emit_fatal(LinkageConstOrMutType { span: span })\n             };\n         // Declare a symbol `foo` with the desired linkage.\n         let global1 = cx.declare_global_with_linkage(&sym, llty2, base::global_linkage_to_gcc(linkage));"}, {"sha": "46ade33eb01cbb5af767762be2c5edbcb64908b3", "filename": "compiler/rustc_codegen_gcc/src/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/25017f8bcece0f57cc1acd3b64394f30cbda11f4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25017f8bcece0f57cc1acd3b64394f30cbda11f4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs?ref=25017f8bcece0f57cc1acd3b64394f30cbda11f4", "patch": "@@ -13,7 +13,7 @@ use rustc_middle::mir::mono::CodegenUnit;\n use rustc_middle::ty::{self, Instance, ParamEnv, PolyExistentialTraitRef, Ty, TyCtxt};\n use rustc_middle::ty::layout::{FnAbiError, FnAbiOfHelpers, FnAbiRequest, HasParamEnv, HasTyCtxt, LayoutError, TyAndLayout, LayoutOfHelpers};\n use rustc_session::Session;\n-use rustc_span::Span;\n+use rustc_span::{Span, source_map::respan};\n use rustc_target::abi::{call::FnAbi, HasDataLayout, PointeeInfo, Size, TargetDataLayout, VariantIdx};\n use rustc_target::spec::{HasTargetSpec, Target, TlsModel};\n \n@@ -293,7 +293,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         self.is_native_int_type(typ) || self.is_non_native_int_type(typ) || typ.is_compatible_with(self.bool_type)\n     }\n \n-    pub fn sess(&self) -> &Session {\n+    pub fn sess(&self) -> &'tcx Session {\n         &self.tcx.sess\n     }\n \n@@ -477,7 +477,7 @@ impl<'gcc, 'tcx> LayoutOfHelpers<'tcx> for CodegenCx<'gcc, 'tcx> {\n     #[inline]\n     fn handle_layout_err(&self, err: LayoutError<'tcx>, span: Span, ty: Ty<'tcx>) -> ! {\n         if let LayoutError::SizeOverflow(_) = err {\n-            self.sess().span_fatal(span, &err.to_string())\n+            self.sess().emit_fatal(respan(span, err))\n         } else {\n             span_bug!(span, \"failed to get layout for `{}`: {}\", ty, err)\n         }\n@@ -495,7 +495,7 @@ impl<'gcc, 'tcx> FnAbiOfHelpers<'tcx> for CodegenCx<'gcc, 'tcx> {\n         fn_abi_request: FnAbiRequest<'tcx>,\n     ) -> ! {\n         if let FnAbiError::Layout(LayoutError::SizeOverflow(_)) = err {\n-            self.sess().span_fatal(span, &err.to_string())\n+            self.sess().emit_fatal(respan(span, err))\n         } else {\n             match fn_abi_request {\n                 FnAbiRequest::OfFnPtr { sig, extra_args } => {"}, {"sha": "d7816e395c8ebd7e5c225505782fa374621261f0", "filename": "compiler/rustc_codegen_gcc/src/errors.rs", "status": "added", "additions": 242, "deletions": 0, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/25017f8bcece0f57cc1acd3b64394f30cbda11f4/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25017f8bcece0f57cc1acd3b64394f30cbda11f4/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ferrors.rs?ref=25017f8bcece0f57cc1acd3b64394f30cbda11f4", "patch": "@@ -0,0 +1,242 @@\n+use rustc_errors::{DiagnosticArgValue, IntoDiagnosticArg};\n+use rustc_macros::Diagnostic;\n+use rustc_middle::ty::Ty;\n+use rustc_span::{Span, Symbol};\n+use std::borrow::Cow;\n+\n+struct ExitCode(Option<i32>);\n+\n+impl IntoDiagnosticArg for ExitCode {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        let ExitCode(exit_code) = self;\n+        match exit_code {\n+            Some(t) => t.into_diagnostic_arg(),\n+            None => DiagnosticArgValue::Str(Cow::Borrowed(\"<signal>\")),\n+        }\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::ranlib_failure)]\n+pub(crate) struct RanlibFailure {\n+    exit_code: ExitCode,\n+}\n+\n+impl RanlibFailure {\n+    pub fn new(exit_code: Option<i32>) -> Self {\n+        RanlibFailure { exit_code: ExitCode(exit_code) }\n+    }\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_basic_integer, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationBasicInteger<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_invalid_float_vector, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationInvalidFloatVector<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub elem_ty: &'a str,\n+    pub vec_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_not_float, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationNotFloat<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_unrecognized, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationUnrecognized {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_expected_signed_unsigned, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationExpectedSignedUnsigned<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub elem_ty: Ty<'a>,\n+    pub vec_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_unsupported_element, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationUnsupportedElement<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_ty: Ty<'a>,\n+    pub elem_ty: Ty<'a>,\n+    pub ret_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_invalid_bitmask, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationInvalidBitmask<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ty: Ty<'a>,\n+    pub expected_int_bits: u64,\n+    pub expected_bytes: u64,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_simd_shuffle, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationSimdShuffle<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_expected_simd, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationExpectedSimd<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub position: &'a str,\n+    pub found_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_mask_type, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationMaskType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_return_length, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationReturnLength<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_len: u64,\n+    pub ret_ty: Ty<'a>,\n+    pub out_len: u64,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_return_length_input_type, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationReturnLengthInputType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_len: u64,\n+    pub in_ty: Ty<'a>,\n+    pub ret_ty: Ty<'a>,\n+    pub out_len: u64,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_return_element, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationReturnElement<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_elem: Ty<'a>,\n+    pub in_ty: Ty<'a>,\n+    pub ret_ty: Ty<'a>,\n+    pub out_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_return_type, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationReturnType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_elem: Ty<'a>,\n+    pub in_ty: Ty<'a>,\n+    pub ret_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_inserted_type, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationInsertedType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_elem: Ty<'a>,\n+    pub in_ty: Ty<'a>,\n+    pub out_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_return_integer_type, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationReturnIntegerType<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub ret_ty: Ty<'a>,\n+    pub out_ty: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_mismatched_lengths, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationMismatchedLengths {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub m_len: u64,\n+    pub v_len: u64,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_unsupported_cast, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationUnsupportedCast<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_ty: Ty<'a>,\n+    pub in_elem: Ty<'a>,\n+    pub ret_ty: Ty<'a>,\n+    pub out_elem: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::invalid_monomorphization_unsupported_operation, code = \"E0511\")]\n+pub(crate) struct InvalidMonomorphizationUnsupportedOperation<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+    pub in_ty: Ty<'a>,\n+    pub in_elem: Ty<'a>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::linkage_const_or_mut_type)]\n+pub(crate) struct LinkageConstOrMutType {\n+    #[primary_span]\n+    pub span: Span\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::lto_not_supported)]\n+pub(crate) struct LTONotSupported;\n+\n+#[derive(Diagnostic)]\n+#[diag(codegen_gcc::unwinding_inline_asm)]\n+pub(crate) struct UnwindingInlineAsm {\n+    #[primary_span]\n+    pub span: Span\n+}"}, {"sha": "cc9c90c2427096174b97b4b2c56d7d8b689763ed", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/mod.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/25017f8bcece0f57cc1acd3b64394f30cbda11f4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25017f8bcece0f57cc1acd3b64394f30cbda11f4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs?ref=25017f8bcece0f57cc1acd3b64394f30cbda11f4", "patch": "@@ -4,7 +4,7 @@ mod simd;\n use gccjit::{ComparisonOp, Function, RValue, ToRValue, Type, UnaryOp, FunctionType};\n use rustc_codegen_ssa::MemFlags;\n use rustc_codegen_ssa::base::wants_msvc_seh;\n-use rustc_codegen_ssa::common::{IntPredicate, span_invalid_monomorphization_error};\n+use rustc_codegen_ssa::common::IntPredicate;\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{ArgAbiMethods, BaseTypeMethods, BuilderMethods, ConstMethods, IntrinsicCallMethods};\n@@ -20,6 +20,7 @@ use crate::abi::GccType;\n use crate::builder::Builder;\n use crate::common::{SignType, TypeReflection};\n use crate::context::CodegenCx;\n+use crate::errors::InvalidMonomorphizationBasicInteger;\n use crate::type_of::LayoutGccExt;\n use crate::intrinsic::simd::generic_simd_intrinsic;\n \n@@ -242,15 +243,7 @@ impl<'a, 'gcc, 'tcx> IntrinsicCallMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                                 _ => bug!(),\n                             },\n                             None => {\n-                                span_invalid_monomorphization_error(\n-                                    tcx.sess,\n-                                    span,\n-                                    &format!(\n-                                        \"invalid monomorphization of `{}` intrinsic: \\\n-                                      expected basic integer type, found `{}`\",\n-                                      name, ty\n-                                    ),\n-                                );\n+                                tcx.sess.emit_err(InvalidMonomorphizationBasicInteger { span, name, ty });\n                                 return;\n                             }\n                         }"}, {"sha": "ffc85b773a2769bbde7cfe1718f0c41c16efe051", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/simd.rs", "status": "modified", "additions": 60, "deletions": 142, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/25017f8bcece0f57cc1acd3b64394f30cbda11f4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25017f8bcece0f57cc1acd3b64394f30cbda11f4/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fsimd.rs?ref=25017f8bcece0f57cc1acd3b64394f30cbda11f4", "patch": "@@ -2,7 +2,7 @@ use std::cmp::Ordering;\n \n use gccjit::{BinaryOp, RValue, Type, ToRValue};\n use rustc_codegen_ssa::base::compare_simd_types;\n-use rustc_codegen_ssa::common::{TypeKind, span_invalid_monomorphization_error};\n+use rustc_codegen_ssa::common::TypeKind;\n use rustc_codegen_ssa::mir::operand::OperandRef;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{BaseTypeMethods, BuilderMethods};\n@@ -14,43 +14,48 @@ use rustc_span::{Span, Symbol, sym};\n use rustc_target::abi::Align;\n \n use crate::builder::Builder;\n+use crate::errors::{\n+    InvalidMonomorphizationInvalidFloatVector,\n+    InvalidMonomorphizationNotFloat,\n+    InvalidMonomorphizationUnrecognized,\n+    InvalidMonomorphizationExpectedSignedUnsigned,\n+    InvalidMonomorphizationUnsupportedElement,\n+    InvalidMonomorphizationInvalidBitmask,\n+    InvalidMonomorphizationSimdShuffle,\n+    InvalidMonomorphizationExpectedSimd,\n+    InvalidMonomorphizationMaskType,\n+    InvalidMonomorphizationReturnLength,\n+    InvalidMonomorphizationReturnLengthInputType,\n+    InvalidMonomorphizationReturnElement,\n+    InvalidMonomorphizationReturnType,\n+    InvalidMonomorphizationInsertedType,\n+    InvalidMonomorphizationReturnIntegerType,\n+    InvalidMonomorphizationMismatchedLengths,\n+    InvalidMonomorphizationUnsupportedCast,\n+    InvalidMonomorphizationUnsupportedOperation\n+};\n use crate::intrinsic;\n \n pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>, name: Symbol, callee_ty: Ty<'tcx>, args: &[OperandRef<'tcx, RValue<'gcc>>], ret_ty: Ty<'tcx>, llret_ty: Type<'gcc>, span: Span) -> Result<RValue<'gcc>, ()> {\n     // macros for error handling:\n-    #[allow(unused_macro_rules)]\n-    macro_rules! emit_error {\n-        ($msg: tt) => {\n-            emit_error!($msg, )\n-        };\n-        ($msg: tt, $($fmt: tt)*) => {\n-            span_invalid_monomorphization_error(\n-                bx.sess(), span,\n-                &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \", $msg),\n-                         name, $($fmt)*));\n-        }\n-    }\n-\n     macro_rules! return_error {\n-        ($($fmt: tt)*) => {\n+        ($err:expr) => {\n             {\n-                emit_error!($($fmt)*);\n+                bx.sess().emit_err($err);\n                 return Err(());\n             }\n         }\n     }\n-\n     macro_rules! require {\n-        ($cond: expr, $($fmt: tt)*) => {\n+        ($cond:expr, $err:expr) => {\n             if !$cond {\n-                return_error!($($fmt)*);\n+                return_error!($err);\n             }\n-        };\n+        }\n     }\n-\n     macro_rules! require_simd {\n         ($ty: expr, $position: expr) => {\n-            require!($ty.is_simd(), \"expected SIMD {} type, found non-SIMD `{}`\", $position, $ty)\n+            require!($ty.is_simd(), InvalidMonomorphizationExpectedSimd { span, name, position: $position, found_ty: $ty })\n         };\n     }\n \n@@ -82,10 +87,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                 bx.load(int_ty, ptr, Align::ONE)\n             }\n             _ => return_error!(\n-                \"invalid bitmask `{}`, expected `u{}` or `[u8; {}]`\",\n-                mask_ty,\n-                expected_int_bits,\n-                expected_bytes\n+                InvalidMonomorphizationInvalidBitmask { span, name, ty: mask_ty, expected_int_bits, expected_bytes }\n             ),\n         };\n \n@@ -127,18 +129,11 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let (out_len, out_ty) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-             found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphizationReturnLengthInputType { span, name, in_len, in_ty, ret_ty, out_len }\n         );\n         require!(\n             bx.type_kind(bx.element_type(llret_ty)) == TypeKind::Integer,\n-            \"expected return type with integer elements, found `{}` with non-integer `{}`\",\n-            ret_ty,\n-            out_ty\n+            InvalidMonomorphizationReturnIntegerType {span, name, ret_ty, out_ty}\n         );\n \n         return Ok(compare_simd_types(\n@@ -163,8 +158,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                         })\n                     }\n                     _ => return_error!(\n-                        \"simd_shuffle index must be an array of `u32`, got `{}`\",\n-                        args[2].layout.ty\n+                        InvalidMonomorphizationSimdShuffle { span, name, ty: args[2].layout.ty }\n                     ),\n                 }\n             }\n@@ -179,19 +173,11 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let (out_len, out_ty) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             out_len == n,\n-            \"expected return type of length {}, found `{}` with length {}\",\n-            n,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphizationReturnLength { span, name, in_len: n, ret_ty, out_len }\n         );\n         require!(\n             in_elem == out_ty,\n-            \"expected return element type `{}` (element of input `{}`), \\\n-             found `{}` with element type `{}`\",\n-            in_elem,\n-            in_ty,\n-            ret_ty,\n-            out_ty\n+            InvalidMonomorphizationReturnElement { span, name, in_elem, in_ty, ret_ty, out_ty }\n         );\n \n         let vector = args[2].immediate();\n@@ -207,10 +193,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n     if name == sym::simd_insert {\n         require!(\n             in_elem == arg_tys[2],\n-            \"expected inserted type `{}` (element of input `{}`), found `{}`\",\n-            in_elem,\n-            in_ty,\n-            arg_tys[2]\n+            InvalidMonomorphizationInsertedType { span, name, in_elem, in_ty, out_ty: arg_tys[2] }\n         );\n         let vector = args[0].immediate();\n         let index = args[1].immediate();\n@@ -263,10 +246,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n     if name == sym::simd_extract {\n         require!(\n             ret_ty == in_elem,\n-            \"expected return type `{}` (element of input `{}`), found `{}`\",\n-            in_elem,\n-            in_ty,\n-            ret_ty\n+            InvalidMonomorphizationReturnType { span, name, in_elem, in_ty, ret_ty }\n         );\n         let vector = args[0].immediate();\n         return Ok(bx.context.new_vector_access(None, vector, args[1].immediate()).to_rvalue());\n@@ -279,13 +259,11 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let (v_len, _) = arg_tys[1].simd_size_and_type(bx.tcx());\n         require!(\n             m_len == v_len,\n-            \"mismatched lengths: mask length `{}` != other vector length `{}`\",\n-            m_len,\n-            v_len\n+            InvalidMonomorphizationMismatchedLengths { span, name, m_len, v_len }\n         );\n         match m_elem_ty.kind() {\n             ty::Int(_) => {}\n-            _ => return_error!(\"mask element type is `{}`, expected `i_`\", m_elem_ty),\n+            _ => return_error!(InvalidMonomorphizationMaskType { span, name, ty: m_elem_ty }),\n         }\n         return Ok(bx.vector_select(args[0].immediate(), args[1].immediate(), args[2].immediate()));\n     }\n@@ -295,12 +273,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         let (out_len, out_elem) = ret_ty.simd_size_and_type(bx.tcx());\n         require!(\n             in_len == out_len,\n-            \"expected return type with length {} (same as input type `{}`), \\\n-                  found `{}` with length {}\",\n-            in_len,\n-            in_ty,\n-            ret_ty,\n-            out_len\n+            InvalidMonomorphizationReturnLengthInputType { span, name, in_len, in_ty, ret_ty, out_len }\n         );\n         // casting cares about nominal type, not just structural type\n         if in_elem == out_elem {\n@@ -412,13 +385,8 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             }\n             _ => { /* Unsupported. Fallthrough. */ }\n         }\n-        require!(\n-            false,\n-            \"unsupported cast from `{}` with element `{}` to `{}` with element `{}`\",\n-            in_ty,\n-            in_elem,\n-            ret_ty,\n-            out_elem\n+        return_error!(\n+            InvalidMonomorphizationUnsupportedCast { span, name, in_ty, in_elem, ret_ty, out_elem }\n         );\n     }\n \n@@ -431,10 +399,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                     })*\n                     _ => {},\n                 }\n-                require!(false,\n-                         \"unsupported operation on `{}` with element `{}`\",\n-                         in_ty,\n-                         in_elem)\n+                return_error!(InvalidMonomorphizationUnsupportedOperation { span, name, in_ty, in_elem })\n             })*\n         }\n     }\n@@ -448,40 +413,27 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n         span: Span,\n         args: &[OperandRef<'tcx, RValue<'gcc>>],\n     ) -> Result<RValue<'gcc>, ()> {\n-        macro_rules! emit_error {\n-            ($msg: tt, $($fmt: tt)*) => {\n-                span_invalid_monomorphization_error(\n-                    bx.sess(), span,\n-                    &format!(concat!(\"invalid monomorphization of `{}` intrinsic: \", $msg),\n-                             name, $($fmt)*));\n-            }\n-        }\n         macro_rules! return_error {\n-            ($($fmt: tt)*) => {\n+            ($err:expr) => {\n                 {\n-                    emit_error!($($fmt)*);\n+                    bx.sess().emit_err($err);\n                     return Err(());\n                 }\n             }\n         }\n-\n         let (elem_ty_str, elem_ty) =\n             if let ty::Float(f) = in_elem.kind() {\n                 let elem_ty = bx.cx.type_float_from_ty(*f);\n                 match f.bit_width() {\n                     32 => (\"f32\", elem_ty),\n                     64 => (\"f64\", elem_ty),\n                     _ => {\n-                        return_error!(\n-                            \"unsupported element type `{}` of floating-point vector `{}`\",\n-                            f.name_str(),\n-                            in_ty\n-                        );\n+                        return_error!(InvalidMonomorphizationInvalidFloatVector { span, name, elem_ty: f.name_str(), vec_ty: in_ty });\n                     }\n                 }\n             }\n             else {\n-                return_error!(\"`{}` is not a floating-point type\", in_ty);\n+                return_error!(InvalidMonomorphizationNotFloat { span, name, ty: in_ty });\n             };\n \n         let vec_ty = bx.cx.type_vector(elem_ty, in_len);\n@@ -504,7 +456,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                 sym::simd_fsqrt => (\"sqrt\", bx.type_func(&[vec_ty], vec_ty)),\n                 sym::simd_round => (\"round\", bx.type_func(&[vec_ty], vec_ty)),\n                 sym::simd_trunc => (\"trunc\", bx.type_func(&[vec_ty], vec_ty)),\n-                _ => return_error!(\"unrecognized intrinsic `{}`\", name),\n+                _ => return_error!(InvalidMonomorphizationUnrecognized { span, name })\n             };\n         let llvm_name = &format!(\"llvm.{0}.v{1}{2}\", intr_name, in_len, elem_ty_str);\n         let function = intrinsic::llvm::intrinsic(llvm_name, &bx.cx);\n@@ -557,10 +509,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                     })*\n                     _ => {},\n                 }\n-                require!(false,\n-                         \"unsupported operation on `{}` with element `{}`\",\n-                         in_ty,\n-                         in_elem)\n+                return_error!(InvalidMonomorphizationUnsupportedOperation { span, name, in_ty, in_elem })\n             })*\n         }\n     }\n@@ -579,12 +528,12 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             ty::Int(i) => (true, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_int_from_ty(i)),\n             ty::Uint(i) => (false, i.bit_width().unwrap_or(ptr_bits), bx.cx.type_uint_from_ty(i)),\n             _ => {\n-                return_error!(\n-                    \"expected element type `{}` of vector type `{}` \\\n-                     to be a signed or unsigned integer type\",\n-                    arg_tys[0].simd_size_and_type(bx.tcx()).1,\n-                    arg_tys[0]\n-                );\n+                return_error!(InvalidMonomorphizationExpectedSignedUnsigned {\n+                    span,\n+                    name,\n+                    elem_ty: arg_tys[0].simd_size_and_type(bx.tcx()).1,\n+                    vec_ty: arg_tys[0],\n+                });\n             }\n         };\n         let builtin_name =\n@@ -617,10 +566,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             if name == sym::$name {\n                 require!(\n                     ret_ty == in_elem,\n-                    \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                    in_elem,\n-                    in_ty,\n-                    ret_ty\n+                    InvalidMonomorphizationReturnType { span, name, in_elem, in_ty, ret_ty }\n                 );\n                 return match in_elem.kind() {\n                     ty::Int(_) | ty::Uint(_) => {\n@@ -644,13 +590,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                             Ok(bx.vector_reduce_op(args[0].immediate(), $vec_op))\n                         }\n                     }\n-                    _ => return_error!(\n-                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        sym::$name,\n-                        in_ty,\n-                        in_elem,\n-                        ret_ty\n-                    ),\n+                    _ => return_error!(InvalidMonomorphizationUnsupportedElement { span, name, in_ty, elem_ty: in_elem, ret_ty }),\n                 };\n             }\n         };\n@@ -676,20 +616,11 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n             if name == sym::$name {\n                 require!(\n                     ret_ty == in_elem,\n-                    \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                    in_elem,\n-                    in_ty,\n-                    ret_ty\n+                    InvalidMonomorphizationReturnType { span, name, in_elem, in_ty, ret_ty }\n                 );\n                 return match in_elem.kind() {\n                     ty::Int(_) | ty::Uint(_) | ty::Float(_) => Ok(bx.$reduction(args[0].immediate())),\n-                    _ => return_error!(\n-                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        sym::$name,\n-                        in_ty,\n-                        in_elem,\n-                        ret_ty\n-                    ),\n+                    _ => return_error!(InvalidMonomorphizationUnsupportedElement { span, name, in_ty, elem_ty: in_elem, ret_ty }),\n                 };\n             }\n         };\n@@ -704,22 +635,13 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                 let input = if !$boolean {\n                     require!(\n                         ret_ty == in_elem,\n-                        \"expected return type `{}` (element of input `{}`), found `{}`\",\n-                        in_elem,\n-                        in_ty,\n-                        ret_ty\n+                        InvalidMonomorphizationReturnType { span, name, in_elem, in_ty, ret_ty }\n                     );\n                     args[0].immediate()\n                 } else {\n                     match in_elem.kind() {\n                         ty::Int(_) | ty::Uint(_) => {}\n-                        _ => return_error!(\n-                            \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                            sym::$name,\n-                            in_ty,\n-                            in_elem,\n-                            ret_ty\n-                        ),\n+                        _ => return_error!(InvalidMonomorphizationUnsupportedElement { span, name, in_ty, elem_ty: in_elem, ret_ty }),\n                     }\n \n                     // boolean reductions operate on vectors of i1s:\n@@ -733,11 +655,7 @@ pub fn generic_simd_intrinsic<'a, 'gcc, 'tcx>(bx: &mut Builder<'a, 'gcc, 'tcx>,\n                         Ok(if !$boolean { r } else { bx.zext(r, bx.type_bool()) })\n                     }\n                     _ => return_error!(\n-                        \"unsupported {} from `{}` with element `{}` to `{}`\",\n-                        sym::$name,\n-                        in_ty,\n-                        in_elem,\n-                        ret_ty\n+                        InvalidMonomorphizationUnsupportedElement { span, name, in_ty, elem_ty: in_elem, ret_ty }\n                     ),\n                 };\n             }"}, {"sha": "007d61ed51de88474394a19a1c9217eb64dcd5fa", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/25017f8bcece0f57cc1acd3b64394f30cbda11f4/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25017f8bcece0f57cc1acd3b64394f30cbda11f4/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=25017f8bcece0f57cc1acd3b64394f30cbda11f4", "patch": "@@ -18,13 +18,16 @@\n #![recursion_limit=\"256\"]\n #![warn(rust_2018_idioms)]\n #![warn(unused_lifetimes)]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n extern crate rustc_apfloat;\n extern crate rustc_ast;\n extern crate rustc_codegen_ssa;\n extern crate rustc_data_structures;\n extern crate rustc_errors;\n extern crate rustc_hir;\n+extern crate rustc_macros;\n extern crate rustc_metadata;\n extern crate rustc_middle;\n extern crate rustc_session;\n@@ -50,6 +53,7 @@ mod context;\n mod coverageinfo;\n mod debuginfo;\n mod declare;\n+mod errors;\n mod int;\n mod intrinsic;\n mod mono_item;\n@@ -59,6 +63,7 @@ mod type_of;\n use std::any::Any;\n use std::sync::{Arc, Mutex};\n \n+use crate::errors::LTONotSupported;\n use gccjit::{Context, OptimizationLevel, CType};\n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_codegen_ssa::{CodegenResults, CompiledModule, ModuleCodegen};\n@@ -97,7 +102,7 @@ pub struct GccCodegenBackend {\n impl CodegenBackend for GccCodegenBackend {\n     fn init(&self, sess: &Session) {\n         if sess.lto() != Lto::No {\n-            sess.warn(\"LTO is not supported. You may get a linker error.\");\n+            sess.emit_warning(LTONotSupported {});\n         }\n \n         let temp_dir = TempDir::new().expect(\"cannot create temporary directory\");"}, {"sha": "178e1a67ccecff46fb28b1bfc715ec1cd0287fbf", "filename": "compiler/rustc_error_messages/locales/en-US/codegen_gcc.ftl", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/25017f8bcece0f57cc1acd3b64394f30cbda11f4/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_gcc.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/25017f8bcece0f57cc1acd3b64394f30cbda11f4/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_gcc.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcodegen_gcc.ftl?ref=25017f8bcece0f57cc1acd3b64394f30cbda11f4", "patch": "@@ -0,0 +1,68 @@\n+codegen_gcc_ranlib_failure =\n+    Ranlib exited with code {$exit_code}\n+\n+codegen_gcc_linkage_const_or_mut_type =\n+    must have type `*const T` or `*mut T` due to `#[linkage]` attribute\n+\n+codegen_gcc_unwinding_inline_asm =\n+    GCC backend does not support unwinding from inline asm\n+\n+codegen_gcc_lto_not_supported =\n+    LTO is not supported. You may get a linker error.\n+\n+codegen_gcc_invalid_monomorphization_basic_integer =\n+    invalid monomorphization of `{$name}` intrinsic: expected basic integer type, found `{$ty}`\n+\n+codegen_gcc_invalid_monomorphization_invalid_float_vector =\n+    invalid monomorphization of `{$name}` intrinsic: unsupported element type `{$elem_ty}` of floating-point vector `{$vec_ty}`\n+\n+codegen_gcc_invalid_monomorphization_not_float =\n+    invalid monomorphization of `{$name}` intrinsic: `{$ty}` is not a floating-point type\n+\n+codegen_gcc_invalid_monomorphization_unrecognized =\n+    invalid monomorphization of `{$name}` intrinsic: unrecognized intrinsic `{$name}`\n+\n+codegen_gcc_invalid_monomorphization_expected_signed_unsigned =\n+    invalid monomorphization of `{$name}` intrinsic: expected element type `{$elem_ty}` of vector type `{$vec_ty}` to be a signed or unsigned integer type\n+\n+codegen_gcc_invalid_monomorphization_unsupported_element =\n+    invalid monomorphization of `{$name}` intrinsic: unsupported {$name} from `{$in_ty}` with element `{$elem_ty}` to `{$ret_ty}`\n+\n+codegen_gcc_invalid_monomorphization_invalid_bitmask =\n+    invalid monomorphization of `{$name}` intrinsic: invalid bitmask `{ty}`, expected `u{$expected_int_bits}` or `[u8; {$expected_bytes}]`\n+\n+codegen_gcc_invalid_monomorphization_simd_shuffle =\n+    invalid monomorphization of `{$name}` intrinsic: simd_shuffle index must be an array of `u32`, got `{$ty}`\n+\n+codegen_gcc_invalid_monomorphization_expected_simd =\n+    invalid monomorphization of `{$name}` intrinsic: expected SIMD {$expected_ty} type, found non-SIMD `{$found_ty}`\n+\n+codegen_gcc_invalid_monomorphization_mask_type =\n+    invalid monomorphization of `{$name}` intrinsic: mask element type is `{$ty}`, expected `i_`\n+\n+codegen_gcc_invalid_monomorphization_return_length =\n+    invalid monomorphization of `{$name}` intrinsic: expected return type of length {$in_len}, found `{$ret_ty}` with length {$out_len}\n+\n+codegen_gcc_invalid_monomorphization_return_length_input_type =\n+    invalid monomorphization of `{$name}` intrinsic: expected return type with length {$in_len} (same as input type `{$in_ty}`), found `{$ret_ty}` with length {$out_len}\n+\n+codegen_gcc_invalid_monomorphization_return_element =\n+    invalid monomorphization of `{$name}` intrinsic: expected return element type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}` with element type `{$out_ty}`\n+\n+codegen_gcc_invalid_monomorphization_return_type =\n+    invalid monomorphization of `{$name}` intrinsic: expected return type `{$in_elem}` (element of input `{$in_ty}`), found `{$ret_ty}`\n+\n+codegen_gcc_invalid_monomorphization_inserted_type =\n+    invalid monomorphization of `{$name}` intrinsic: expected inserted type `{$in_elem}` (element of input `{$in_ty}`), found `{$out_ty}`\n+\n+codegen_gcc_invalid_monomorphization_return_integer_type =\n+    invalid monomorphization of `{$name}` intrinsic: expected return type with integer elements, found `{$ret_ty}` with non-integer `{$out_ty}`\n+\n+codegen_gcc_invalid_monomorphization_mismatched_lengths =\n+    invalid monomorphization of `{$name}` intrinsic: mismatched lengths: mask length `{$m_len}` != other vector length `{$v_len}`\n+\n+codegen_gcc_invalid_monomorphization_unsupported_cast =\n+    invalid monomorphization of `{$name}` intrinsic: unsupported cast from `{$in_ty}` with element `{$in_elem}` to `{$ret_ty}` with element `{$out_elem}`\n+\n+codegen_gcc_invalid_monomorphization_unsupported_operation =\n+    invalid monomorphization of `{$name}` intrinsic: unsupported operation on `{$in_ty}` with element `{$in_elem}`"}, {"sha": "abf98a9621e78eb3db746b081ec04864ad328bb0", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25017f8bcece0f57cc1acd3b64394f30cbda11f4/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25017f8bcece0f57cc1acd3b64394f30cbda11f4/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=25017f8bcece0f57cc1acd3b64394f30cbda11f4", "patch": "@@ -41,6 +41,7 @@ fluent_messages! {\n     borrowck => \"../locales/en-US/borrowck.ftl\",\n     builtin_macros => \"../locales/en-US/builtin_macros.ftl\",\n     const_eval => \"../locales/en-US/const_eval.ftl\",\n+    codegen_gcc => \"../locales/en-US/codegen_gcc.ftl\",\n     driver => \"../locales/en-US/driver.ftl\",\n     expand => \"../locales/en-US/expand.ftl\",\n     session => \"../locales/en-US/session.ftl\","}, {"sha": "092a77f944c093933d1bf32118e36dab577f8dc4", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/25017f8bcece0f57cc1acd3b64394f30cbda11f4/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25017f8bcece0f57cc1acd3b64394f30cbda11f4/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=25017f8bcece0f57cc1acd3b64394f30cbda11f4", "patch": "@@ -5,6 +5,7 @@ use crate::{\n };\n use crate::{Handler, Level, MultiSpan, StashKey};\n use rustc_lint_defs::Applicability;\n+use rustc_span::source_map::Spanned;\n \n use rustc_span::Span;\n use std::borrow::Cow;\n@@ -23,6 +24,18 @@ pub trait IntoDiagnostic<'a, T: EmissionGuarantee = ErrorGuaranteed> {\n     fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, T>;\n }\n \n+impl<'a, T, E> IntoDiagnostic<'a, E> for Spanned<T>\n+where\n+    T: IntoDiagnostic<'a, E>,\n+    E: EmissionGuarantee,\n+{\n+    fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, E> {\n+        let mut diag = self.node.into_diagnostic(handler);\n+        diag.set_span(self.span);\n+        diag\n+    }\n+}\n+\n /// Used for emitting structured error messages and other diagnostic information.\n ///\n /// If there is some state in a downstream crate you would like to"}, {"sha": "3c523659df74e15dbada8487c1405d1b9b1c0a79", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/25017f8bcece0f57cc1acd3b64394f30cbda11f4/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25017f8bcece0f57cc1acd3b64394f30cbda11f4/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=25017f8bcece0f57cc1acd3b64394f30cbda11f4", "patch": "@@ -7,6 +7,7 @@ use crate::ty::{\n };\n use rustc_ast as ast;\n use rustc_attr as attr;\n+use rustc_errors::{DiagnosticBuilder, Handler, IntoDiagnostic};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n@@ -206,6 +207,12 @@ pub enum LayoutError<'tcx> {\n     NormalizationFailure(Ty<'tcx>, NormalizationError<'tcx>),\n }\n \n+impl<'a> IntoDiagnostic<'a, !> for LayoutError<'a> {\n+    fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, !> {\n+        handler.struct_fatal(self.to_string())\n+    }\n+}\n+\n impl<'tcx> fmt::Display for LayoutError<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n@@ -3065,6 +3072,12 @@ impl<'tcx> fmt::Display for FnAbiError<'tcx> {\n     }\n }\n \n+impl<'tcx> IntoDiagnostic<'tcx, !> for FnAbiError<'tcx> {\n+    fn into_diagnostic(self, handler: &'tcx Handler) -> DiagnosticBuilder<'tcx, !> {\n+        handler.struct_fatal(self.to_string())\n+    }\n+}\n+\n // FIXME(eddyb) maybe use something like this for an unified `fn_abi_of`, not\n // just for error handling.\n #[derive(Debug)]"}]}