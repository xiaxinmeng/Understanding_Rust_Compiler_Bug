{"sha": "7ce2d9c3fa3d36ae79b9790e3646e5e746e64cf4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjZTJkOWMzZmEzZDM2YWU3OWI5NzkwZTM2NDZlNWU3NDZlNjRjZjQ=", "commit": {"author": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-11-21T20:00:05Z"}, "committer": {"name": "Aaron Turon", "email": "aturon@mozilla.com", "date": "2014-11-21T22:10:13Z"}, "message": "libs: stabilize ascii module\n\nThis is an initial API stabilization pass for `std::ascii`. Aside from\nsome renaming to match conversion conventions, and deprecations in favor\nof using iterators directly, almost nothing is changed here. However,\nthe static case conversion tables that were previously public are now private.\n\nThe stabilization of the (rather large!) set of extension traits is left\nto a follow-up pass, because we hope to land some more general machinery\nthat will provide the same functionality without custom traits.\n\n[breaking-change]", "tree": {"sha": "d7e3a61c32c4ca28d4d34ef4141703ab33100db0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7e3a61c32c4ca28d4d34ef4141703ab33100db0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ce2d9c3fa3d36ae79b9790e3646e5e746e64cf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ce2d9c3fa3d36ae79b9790e3646e5e746e64cf4", "html_url": "https://github.com/rust-lang/rust/commit/7ce2d9c3fa3d36ae79b9790e3646e5e746e64cf4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ce2d9c3fa3d36ae79b9790e3646e5e746e64cf4/comments", "author": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aturon", "id": 709807, "node_id": "MDQ6VXNlcjcwOTgwNw==", "avatar_url": "https://avatars.githubusercontent.com/u/709807?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aturon", "html_url": "https://github.com/aturon", "followers_url": "https://api.github.com/users/aturon/followers", "following_url": "https://api.github.com/users/aturon/following{/other_user}", "gists_url": "https://api.github.com/users/aturon/gists{/gist_id}", "starred_url": "https://api.github.com/users/aturon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aturon/subscriptions", "organizations_url": "https://api.github.com/users/aturon/orgs", "repos_url": "https://api.github.com/users/aturon/repos", "events_url": "https://api.github.com/users/aturon/events{/privacy}", "received_events_url": "https://api.github.com/users/aturon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9f6d696420107f82304b992cf623b806995fe18", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9f6d696420107f82304b992cf623b806995fe18", "html_url": "https://github.com/rust-lang/rust/commit/c9f6d696420107f82304b992cf623b806995fe18"}], "stats": {"total": 73, "additions": 57, "deletions": 16}, "files": [{"sha": "c795e69a44deabe93ea19e6217008fae18723f11", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7ce2d9c3fa3d36ae79b9790e3646e5e746e64cf4/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ce2d9c3fa3d36ae79b9790e3646e5e746e64cf4/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=7ce2d9c3fa3d36ae79b9790e3646e5e746e64cf4", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::ascii::AsciiExt;\n use std::io::{BufferedReader, File};\n use regex::Regex;\n \n@@ -31,7 +32,7 @@ pub fn load_errors(re: &Regex, testfile: &Path) -> Vec<ExpectedError> {\n fn parse_expected(line_num: uint, line: &str, re: &Regex) -> Option<ExpectedError> {\n     re.captures(line).and_then(|caps| {\n         let adjusts = caps.name(\"adjusts\").len();\n-        let kind = caps.name(\"kind\").to_ascii().to_lowercase().into_string();\n+        let kind = caps.name(\"kind\").to_ascii_lower();\n         let msg = caps.name(\"msg\").trim().to_string();\n \n         debug!(\"line={} kind={} msg={}\", line_num, kind, msg);"}, {"sha": "ae4f9fbc86d31a377026b1adb96031380b22cead", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7ce2d9c3fa3d36ae79b9790e3646e5e746e64cf4/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ce2d9c3fa3d36ae79b9790e3646e5e746e64cf4/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=7ce2d9c3fa3d36ae79b9790e3646e5e746e64cf4", "patch": "@@ -28,6 +28,7 @@\n #![allow(non_camel_case_types)]\n \n use libc;\n+use std::ascii::AsciiExt;\n use std::cell::{RefCell, Cell};\n use std::fmt;\n use std::slice;\n@@ -226,12 +227,8 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n         };\n \n         // Transform the contents of the header into a hyphenated string\n-        let id = s.as_slice().words().map(|s| {\n-            match s.to_ascii_opt() {\n-                Some(s) => s.to_lowercase().into_string(),\n-                None => s.to_string()\n-            }\n-        }).collect::<Vec<String>>().connect(\"-\");\n+        let id = s.as_slice().words().map(|s| s.to_ascii_lower())\n+            .collect::<Vec<String>>().connect(\"-\");\n \n         // This is a terrible hack working around how hoedown gives us rendered\n         // html for text rather than the raw text."}, {"sha": "afac5db148fc0d70c446f51678875287d9c187ed", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 52, "deletions": 9, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7ce2d9c3fa3d36ae79b9790e3646e5e746e64cf4/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ce2d9c3fa3d36ae79b9790e3646e5e746e64cf4/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=7ce2d9c3fa3d36ae79b9790e3646e5e746e64cf4", "patch": "@@ -12,7 +12,7 @@\n \n //! Operations on ASCII strings and characters\n \n-#![experimental]\n+#![unstable = \"unsure about placement and naming\"]\n \n use core::kinds::Sized;\n use fmt;\n@@ -31,30 +31,40 @@ pub struct Ascii { chr: u8 }\n impl Ascii {\n     /// Converts an ascii character into a `u8`.\n     #[inline]\n-    pub fn to_byte(self) -> u8 {\n+    #[unstable = \"recently renamed\"]\n+    pub fn as_byte(&self) -> u8 {\n         self.chr\n     }\n \n+    #[deprecated = \"use as_byte\"]\n+    pub fn to_byte(self) -> u8 {\n+        self.as_byte()\n+    }\n+\n     /// Converts an ascii character into a `char`.\n     #[inline]\n-    pub fn to_char(self) -> char {\n+    #[unstable = \"recently renamed\"]\n+    pub fn as_char(&self) -> char {\n         self.chr as char\n     }\n \n     /// Convert to lowercase.\n     #[inline]\n-    pub fn to_lowercase(self) -> Ascii {\n+    #[stable]\n+    pub fn to_lowercase(&self) -> Ascii {\n         Ascii{chr: ASCII_LOWER_MAP[self.chr as uint]}\n     }\n \n     /// Convert to uppercase.\n     #[inline]\n-    pub fn to_uppercase(self) -> Ascii {\n+    #[stable]\n+    pub fn to_uppercase(&self) -> Ascii {\n         Ascii{chr: ASCII_UPPER_MAP[self.chr as uint]}\n     }\n \n     /// Compares two ascii characters of equality, ignoring case.\n     #[inline]\n+    #[deprecated = \"normalize with to_lowercase\"]\n     pub fn eq_ignore_case(self, other: Ascii) -> bool {\n         ASCII_LOWER_MAP[self.chr as uint] == ASCII_LOWER_MAP[other.chr as uint]\n     }\n@@ -63,66 +73,77 @@ impl Ascii {\n \n     /// Check if the character is a letter (a-z, A-Z)\n     #[inline]\n+    #[stable]\n     pub fn is_alphabetic(&self) -> bool {\n         (self.chr >= 0x41 && self.chr <= 0x5A) || (self.chr >= 0x61 && self.chr <= 0x7A)\n     }\n \n     /// Check if the character is a number (0-9)\n     #[inline]\n+    #[unstable = \"may be renamed\"]\n     pub fn is_digit(&self) -> bool {\n         self.chr >= 0x30 && self.chr <= 0x39\n     }\n \n     /// Check if the character is a letter or number\n     #[inline]\n+    #[stable]\n     pub fn is_alphanumeric(&self) -> bool {\n         self.is_alphabetic() || self.is_digit()\n     }\n \n     /// Check if the character is a space or horizontal tab\n     #[inline]\n+    #[experimental = \"likely to be removed\"]\n     pub fn is_blank(&self) -> bool {\n         self.chr == b' ' || self.chr == b'\\t'\n     }\n \n     /// Check if the character is a control character\n     #[inline]\n+    #[stable]\n     pub fn is_control(&self) -> bool {\n         self.chr < 0x20 || self.chr == 0x7F\n     }\n \n     /// Checks if the character is printable (except space)\n     #[inline]\n+    #[experimental = \"unsure about naming, or whether this is needed\"]\n     pub fn is_graph(&self) -> bool {\n         (self.chr - 0x21) < 0x5E\n     }\n \n     /// Checks if the character is printable (including space)\n     #[inline]\n+    #[unstable = \"unsure about naming\"]\n     pub fn is_print(&self) -> bool {\n         (self.chr - 0x20) < 0x5F\n     }\n \n-    /// Checks if the character is lowercase\n+    /// Checks if the character is alphabetic and lowercase\n     #[inline]\n+    #[stable]\n     pub fn is_lowercase(&self) -> bool {\n         (self.chr - b'a') < 26\n     }\n \n-    /// Checks if the character is uppercase\n+    /// Checks if the character is alphabetic and uppercase\n     #[inline]\n+    #[stable]\n     pub fn is_uppercase(&self) -> bool {\n         (self.chr - b'A') < 26\n     }\n \n     /// Checks if the character is punctuation\n     #[inline]\n+    #[stable]\n     pub fn is_punctuation(&self) -> bool {\n         self.is_graph() && !self.is_alphanumeric()\n     }\n \n     /// Checks if the character is a valid hex digit\n     #[inline]\n+    #[stable]\n     pub fn is_hex(&self) -> bool {\n         self.is_digit() || ((self.chr | 32u8) - b'a') < 6\n     }\n@@ -135,6 +156,7 @@ impl<'a> fmt::Show for Ascii {\n }\n \n /// Trait for converting into an ascii type.\n+#[experimental = \"may be replaced by generic conversion traits\"]\n pub trait AsciiCast<T> {\n     /// Convert to an ascii type, panic on non-ASCII input.\n     #[inline]\n@@ -160,6 +182,7 @@ pub trait AsciiCast<T> {\n     fn is_ascii(&self) -> bool;\n }\n \n+#[experimental = \"may be replaced by generic conversion traits\"]\n impl<'a> AsciiCast<&'a[Ascii]> for &'a [u8] {\n     #[inline]\n     unsafe fn to_ascii_nocheck(&self) -> &'a[Ascii] {\n@@ -175,6 +198,7 @@ impl<'a> AsciiCast<&'a[Ascii]> for &'a [u8] {\n     }\n }\n \n+#[experimental = \"may be replaced by generic conversion traits\"]\n impl<'a> AsciiCast<&'a [Ascii]> for &'a str {\n     #[inline]\n     unsafe fn to_ascii_nocheck(&self) -> &'a [Ascii] {\n@@ -187,6 +211,7 @@ impl<'a> AsciiCast<&'a [Ascii]> for &'a str {\n     }\n }\n \n+#[experimental = \"may be replaced by generic conversion traits\"]\n impl AsciiCast<Ascii> for u8 {\n     #[inline]\n     unsafe fn to_ascii_nocheck(&self) -> Ascii {\n@@ -199,6 +224,7 @@ impl AsciiCast<Ascii> for u8 {\n     }\n }\n \n+#[experimental = \"may be replaced by generic conversion traits\"]\n impl AsciiCast<Ascii> for char {\n     #[inline]\n     unsafe fn to_ascii_nocheck(&self) -> Ascii {\n@@ -212,6 +238,7 @@ impl AsciiCast<Ascii> for char {\n }\n \n /// Trait for copyless casting to an ascii vector.\n+#[experimental = \"may be replaced by generic conversion traits\"]\n pub trait OwnedAsciiCast {\n     /// Check if convertible to ascii\n     fn is_ascii(&self) -> bool;\n@@ -241,6 +268,7 @@ pub trait OwnedAsciiCast {\n     unsafe fn into_ascii_nocheck(self) -> Vec<Ascii>;\n }\n \n+#[experimental = \"may be replaced by generic conversion traits\"]\n impl OwnedAsciiCast for String {\n     #[inline]\n     fn is_ascii(&self) -> bool {\n@@ -253,6 +281,7 @@ impl OwnedAsciiCast for String {\n     }\n }\n \n+#[experimental = \"may be replaced by generic conversion traits\"]\n impl OwnedAsciiCast for Vec<u8> {\n     #[inline]\n     fn is_ascii(&self) -> bool {\n@@ -274,6 +303,7 @@ impl OwnedAsciiCast for Vec<u8> {\n \n /// Trait for converting an ascii type to a string. Needed to convert\n /// `&[Ascii]` to `&str`.\n+#[experimental = \"may be replaced by generic conversion traits\"]\n pub trait AsciiStr for Sized? {\n     /// Convert to a string.\n     fn as_str_ascii<'a>(&'a self) -> &'a str;\n@@ -283,19 +313,23 @@ pub trait AsciiStr for Sized? {\n     fn to_lower(&self) -> Vec<Ascii>;\n \n     /// Convert to vector representing a lower cased ascii string.\n+    #[deprecated = \"use iterators instead\"]\n     fn to_lowercase(&self) -> Vec<Ascii>;\n \n     /// Deprecated: use `to_uppercase`\n     #[deprecated=\"renamed `to_uppercase`\"]\n     fn to_upper(&self) -> Vec<Ascii>;\n \n     /// Convert to vector representing a upper cased ascii string.\n+    #[deprecated = \"use iterators instead\"]\n     fn to_uppercase(&self) -> Vec<Ascii>;\n \n     /// Compares two Ascii strings ignoring case.\n+    #[deprecated = \"use iterators instead\"]\n     fn eq_ignore_case(&self, other: &[Ascii]) -> bool;\n }\n \n+#[experimental = \"may be replaced by generic conversion traits\"]\n impl AsciiStr for [Ascii] {\n     #[inline]\n     fn as_str_ascii<'a>(&'a self) -> &'a str {\n@@ -338,11 +372,13 @@ impl IntoString for Vec<Ascii> {\n }\n \n /// Trait to convert to an owned byte vector by consuming self\n+#[experimental = \"may be replaced by generic conversion traits\"]\n pub trait IntoBytes {\n     /// Converts to an owned byte vector by consuming self\n     fn into_bytes(self) -> Vec<u8>;\n }\n \n+#[experimental = \"may be replaced by generic conversion traits\"]\n impl IntoBytes for Vec<Ascii> {\n     fn into_bytes(self) -> Vec<u8> {\n         unsafe {\n@@ -360,6 +396,7 @@ impl IntoBytes for Vec<Ascii> {\n \n \n /// Extension methods for ASCII-subset only operations on owned strings\n+#[experimental = \"would prefer to do this in a more general way\"]\n pub trait OwnedAsciiExt {\n     /// Convert the string to ASCII upper case:\n     /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n@@ -373,6 +410,7 @@ pub trait OwnedAsciiExt {\n }\n \n /// Extension methods for ASCII-subset only operations on string slices\n+#[experimental = \"would prefer to do this in a more general way\"]\n pub trait AsciiExt<T> for Sized? {\n     /// Makes a copy of the string in ASCII upper case:\n     /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n@@ -390,6 +428,7 @@ pub trait AsciiExt<T> for Sized? {\n     fn eq_ignore_ascii_case(&self, other: &Self) -> bool;\n }\n \n+#[experimental = \"would prefer to do this in a more general way\"]\n impl AsciiExt<String> for str {\n     #[inline]\n     fn to_ascii_upper(&self) -> String {\n@@ -409,6 +448,7 @@ impl AsciiExt<String> for str {\n     }\n }\n \n+#[experimental = \"would prefer to do this in a more general way\"]\n impl OwnedAsciiExt for String {\n     #[inline]\n     fn into_ascii_upper(self) -> String {\n@@ -423,6 +463,7 @@ impl OwnedAsciiExt for String {\n     }\n }\n \n+#[experimental = \"would prefer to do this in a more general way\"]\n impl AsciiExt<Vec<u8>> for [u8] {\n     #[inline]\n     fn to_ascii_upper(&self) -> Vec<u8> {\n@@ -445,6 +486,7 @@ impl AsciiExt<Vec<u8>> for [u8] {\n     }\n }\n \n+#[experimental = \"would prefer to do this in a more general way\"]\n impl OwnedAsciiExt for Vec<u8> {\n     #[inline]\n     fn into_ascii_upper(mut self) -> Vec<u8> {\n@@ -474,6 +516,7 @@ impl OwnedAsciiExt for Vec<u8> {\n /// - Any other chars in the range [0x20,0x7e] are not escaped.\n /// - Any other chars are given hex escapes.\n /// - Unicode escapes are never generated by this function.\n+#[unstable = \"needs to be updated to use an iterator\"]\n pub fn escape_default(c: u8, f: |u8|) {\n     match c {\n         b'\\t' => { f(b'\\\\'); f(b't'); }\n@@ -496,7 +539,7 @@ pub fn escape_default(c: u8, f: |u8|) {\n     }\n }\n \n-pub static ASCII_LOWER_MAP: [u8, ..256] = [\n+static ASCII_LOWER_MAP: [u8, ..256] = [\n     0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n     0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n     0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n@@ -535,7 +578,7 @@ pub static ASCII_LOWER_MAP: [u8, ..256] = [\n     0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n ];\n \n-pub static ASCII_UPPER_MAP: [u8, ..256] = [\n+static ASCII_UPPER_MAP: [u8, ..256] = [\n     0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n     0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n     0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,"}]}