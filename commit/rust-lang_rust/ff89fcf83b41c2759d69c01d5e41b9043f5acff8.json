{"sha": "ff89fcf83b41c2759d69c01d5e41b9043f5acff8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmODlmY2Y4M2I0MWMyNzU5ZDY5YzAxZDVlNDFiOTA0M2Y1YWNmZjg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-06-09T21:02:18Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-06-15T21:31:26Z"}, "message": "Add a (somewhat hacky) cache to the tcx that tracks \"global\" trait refs\nthat are known to have been satisfied *somewhere*. This means that if\none fn finds that `SomeType: Foo`, then every other fn can just consider\nthat to hold.\n\nUnfortunately, there are some complications:\n\n1. If `SomeType: Foo` includes dependent conditions, those conditions\n   may trigger an error. This error will be repored in the first fn\n   where `SomeType: Foo` is evaluated, but not in the other fns, which\n   can lead to uneven error reporting (which is sometimes confusing).\n\n2. This kind of caching can be unsound in the presence of\n   unsatisfiable where clauses. For example, suppose that the first fn\n   has a where-clause like `i32: Bar<u32>`, which in fact does not\n   hold. This will \"fool\" trait resolution into thinking that `i32:\n   Bar<u32>` holds. This is ok currently, because it means that the\n   first fn can never be calle (since its where clauses cannot be\n   satisfied), but if the first fn's successful resolution is cached, it\n   can allow other fns to compile that should not. This problem is fixed\n   in the next commit.", "tree": {"sha": "8a5bce8dfc3f0afebc34f552bc2a8e138be0897d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a5bce8dfc3f0afebc34f552bc2a8e138be0897d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff89fcf83b41c2759d69c01d5e41b9043f5acff8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff89fcf83b41c2759d69c01d5e41b9043f5acff8", "html_url": "https://github.com/rust-lang/rust/commit/ff89fcf83b41c2759d69c01d5e41b9043f5acff8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff89fcf83b41c2759d69c01d5e41b9043f5acff8/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d82fb55dbb9b28798ea7c2004fa91fe3ae23b86", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d82fb55dbb9b28798ea7c2004fa91fe3ae23b86", "html_url": "https://github.com/rust-lang/rust/commit/0d82fb55dbb9b28798ea7c2004fa91fe3ae23b86"}], "stats": {"total": 159, "additions": 142, "deletions": 17}, "files": [{"sha": "d80eedf354a0e31218967480f6694421ec7bc999", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff89fcf83b41c2759d69c01d5e41b9043f5acff8/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff89fcf83b41c2759d69c01d5e41b9043f5acff8/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=ff89fcf83b41c2759d69c01d5e41b9043f5acff8", "patch": "@@ -285,7 +285,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     fn check_static_type(&self, e: &ast::Expr) {\n         let ty = ty::node_id_to_type(self.tcx, e.id);\n         let infcx = infer::new_infer_ctxt(self.tcx);\n-        let mut fulfill_cx = traits::FulfillmentContext::new();\n+        let mut fulfill_cx = traits::FulfillmentContext::new(false);\n         let cause = traits::ObligationCause::new(e.span, e.id, traits::SharedStatic);\n         fulfill_cx.register_builtin_bound(&infcx, ty, ty::BoundSync, cause);\n         let env = ty::empty_parameter_environment(self.tcx);"}, {"sha": "b9117745db2e20aea3cc1f12289a6984a58a3739", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 68, "deletions": 4, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/ff89fcf83b41c2759d69c01d5e41b9043f5acff8/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff89fcf83b41c2759d69c01d5e41b9043f5acff8/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=ff89fcf83b41c2759d69c01d5e41b9043f5acff8", "patch": "@@ -28,6 +28,10 @@ use super::select::SelectionContext;\n use super::Unimplemented;\n use super::util::predicate_for_builtin_bound;\n \n+pub struct FulfilledPredicates<'tcx> {\n+    set: HashSet<ty::Predicate<'tcx>>\n+}\n+\n /// The fulfillment context is used to drive trait resolution.  It\n /// consists of a list of obligations that must be (eventually)\n /// satisfied. The job is to track which are satisfied, which yielded\n@@ -44,7 +48,7 @@ pub struct FulfillmentContext<'tcx> {\n     // than the `SelectionCache`: it avoids duplicate errors and\n     // permits recursive obligations, which are often generated from\n     // traits like `Send` et al.\n-    duplicate_set: HashSet<ty::Predicate<'tcx>>,\n+    duplicate_set: FulfilledPredicates<'tcx>,\n \n     // A list of all obligations that have been registered with this\n     // fulfillment context.\n@@ -80,6 +84,8 @@ pub struct FulfillmentContext<'tcx> {\n     // obligations (otherwise, it's easy to fail to walk to a\n     // particular node-id).\n     region_obligations: NodeMap<Vec<RegionObligation<'tcx>>>,\n+\n+    errors_will_be_reported: bool,\n }\n \n #[derive(Clone)]\n@@ -90,12 +96,30 @@ pub struct RegionObligation<'tcx> {\n }\n \n impl<'tcx> FulfillmentContext<'tcx> {\n-    pub fn new() -> FulfillmentContext<'tcx> {\n+    /// Creates a new fulfillment context.\n+    ///\n+    /// `errors_will_be_reported` indicates whether ALL errors that\n+    /// are generated by this fulfillment context will be reported to\n+    /// the end user. This is used to inform caching, because it\n+    /// allows us to conclude that traits that resolve successfully\n+    /// will in fact always resolve successfully (in particular, it\n+    /// guarantees that if some dependent obligation encounters a\n+    /// problem, compilation will be aborted).  If you're not sure of\n+    /// the right value here, pass `false`, as that is the more\n+    /// conservative option.\n+    ///\n+    /// FIXME -- a better option would be to hold back on modifying\n+    /// the global cache until we know that all dependent obligations\n+    /// are also satisfied. In that case, we could actually remove\n+    /// this boolean flag, and we'd also avoid the problem of squelching\n+    /// duplicate errors that occur across fns.\n+    pub fn new(errors_will_be_reported: bool) -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n-            duplicate_set: HashSet::new(),\n+            duplicate_set: FulfilledPredicates::new(),\n             predicates: Vec::new(),\n             attempted_mark: 0,\n             region_obligations: NodeMap(),\n+            errors_will_be_reported: errors_will_be_reported,\n         }\n     }\n \n@@ -165,7 +189,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n         assert!(!obligation.has_escaping_regions());\n \n-        if !self.duplicate_set.insert(obligation.predicate.clone()) {\n+        if self.is_duplicate_or_add(infcx.tcx, &obligation.predicate) {\n             debug!(\"register_predicate({}) -- already seen, skip\", obligation.repr(infcx.tcx));\n             return;\n         }\n@@ -231,6 +255,28 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         &self.predicates\n     }\n \n+    fn is_duplicate_or_add(&mut self, tcx: &ty::ctxt<'tcx>,\n+                           predicate: &ty::Predicate<'tcx>)\n+                           -> bool {\n+        // This is a kind of dirty hack to allow us to avoid \"rederiving\"\n+        // things that we have already proven in other methods.\n+        //\n+        // The idea is that any predicate that doesn't involve type\n+        // parameters and which only involves the 'static region (and\n+        // no other regions) is universally solvable, since impls are global.\n+        //\n+        // This is particularly important since even if we have a\n+        // cache hit in the selection context, we still wind up\n+        // evaluating the 'nested obligations'.  This cache lets us\n+        // skip those.\n+\n+        if self.errors_will_be_reported && predicate.is_global() {\n+            tcx.fulfilled_predicates.borrow_mut().is_duplicate_or_add(predicate)\n+        } else {\n+            self.duplicate_set.is_duplicate_or_add(predicate)\n+        }\n+    }\n+\n     /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it\n     /// only attempts to select obligations that haven't been seen before.\n     fn select<'a>(&mut self,\n@@ -442,3 +488,21 @@ fn register_region_obligation<'tcx>(tcx: &ty::ctxt<'tcx>,\n         .push(region_obligation);\n \n }\n+\n+impl<'tcx> FulfilledPredicates<'tcx> {\n+    pub fn new() -> FulfilledPredicates<'tcx> {\n+        FulfilledPredicates {\n+            set: HashSet::new()\n+        }\n+    }\n+\n+    pub fn is_duplicate(&self, p: &ty::Predicate<'tcx>) -> bool {\n+        self.set.contains(p)\n+    }\n+\n+    fn is_duplicate_or_add(&mut self, p: &ty::Predicate<'tcx>) -> bool {\n+        !self.set.insert(p.clone())\n+    }\n+}\n+\n+"}, {"sha": "138231b599586fd482ab10f4d033083c38782406", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ff89fcf83b41c2759d69c01d5e41b9043f5acff8/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff89fcf83b41c2759d69c01d5e41b9043f5acff8/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=ff89fcf83b41c2759d69c01d5e41b9043f5acff8", "patch": "@@ -32,7 +32,7 @@ pub use self::error_reporting::suggest_new_overflow_limit;\n pub use self::coherence::orphan_check;\n pub use self::coherence::overlapping_impls;\n pub use self::coherence::OrphanCheckErr;\n-pub use self::fulfill::{FulfillmentContext, RegionObligation};\n+pub use self::fulfill::{FulfillmentContext, FulfilledPredicates, RegionObligation};\n pub use self::project::MismatchedProjectionTypes;\n pub use self::project::normalize;\n pub use self::project::Normalized;\n@@ -315,7 +315,7 @@ pub fn evaluate_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n            ty.repr(infcx.tcx),\n            bound);\n \n-    let mut fulfill_cx = FulfillmentContext::new();\n+    let mut fulfill_cx = FulfillmentContext::new(false);\n \n     // We can use a dummy node-id here because we won't pay any mind\n     // to region obligations that arise (there shouldn't really be any\n@@ -460,7 +460,7 @@ pub fn fully_normalize<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n     debug!(\"normalize_param_env(value={})\", value.repr(tcx));\n \n     let mut selcx = &mut SelectionContext::new(infcx, closure_typer);\n-    let mut fulfill_cx = FulfillmentContext::new();\n+    let mut fulfill_cx = FulfillmentContext::new(false);\n     let Normalized { value: normalized_value, obligations } =\n         project::normalize(selcx, cause, value);\n     debug!(\"normalize_param_env: normalized_value={} obligations={}\","}, {"sha": "307242d18dfefe1ced0b14f2a8ea22995a579496", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ff89fcf83b41c2759d69c01d5e41b9043f5acff8/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff89fcf83b41c2759d69c01d5e41b9043f5acff8/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=ff89fcf83b41c2759d69c01d5e41b9043f5acff8", "patch": "@@ -435,6 +435,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"evaluate_predicate_recursively({})\",\n                obligation.repr(self.tcx()));\n \n+        // Check the cache from the tcx of predicates that we know\n+        // have been proven elsewhere. This cache only contains\n+        // predicates that are global in scope and hence unaffected by\n+        // the current environment.\n+        if self.tcx().fulfilled_predicates.borrow().is_duplicate(&obligation.predicate) {\n+            return EvaluatedToOk;\n+        }\n+\n         match obligation.predicate {\n             ty::Predicate::Trait(ref t) => {\n                 assert!(!t.has_escaping_regions());"}, {"sha": "edd8f5ea6eaa9f0deb21598942d13146e5312b7f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 55, "deletions": 2, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/ff89fcf83b41c2759d69c01d5e41b9043f5acff8/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff89fcf83b41c2759d69c01d5e41b9043f5acff8/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=ff89fcf83b41c2759d69c01d5e41b9043f5acff8", "patch": "@@ -753,6 +753,11 @@ pub struct ctxt<'tcx> {\n     /// for things that do not have to do with the parameters in scope.\n     pub selection_cache: traits::SelectionCache<'tcx>,\n \n+    /// A set of predicates that have been fulfilled *somewhere*.\n+    /// This is used to avoid duplicate work. Predicates are only\n+    /// added to this set when they\n+    pub fulfilled_predicates: RefCell<traits::FulfilledPredicates<'tcx>>,\n+\n     /// Caches the representation hints for struct definitions.\n     pub repr_hint_cache: RefCell<DefIdMap<Rc<Vec<attr::ReprAttr>>>>,\n \n@@ -815,6 +820,11 @@ bitflags! {\n         const HAS_TY_ERR         = 1 << 6,\n         const HAS_PROJECTION     = 1 << 7,\n         const HAS_TY_CLOSURE     = 1 << 8,\n+\n+        // true if there are \"names\" of types and regions and so forth\n+        // that are local to a particular fn\n+        const HAS_LOCAL_NAMES   = 1 << 8,\n+\n         const NEEDS_SUBST        = TypeFlags::HAS_PARAMS.bits |\n                                    TypeFlags::HAS_SELF.bits |\n                                    TypeFlags::HAS_RE_EARLY_BOUND.bits,\n@@ -830,7 +840,8 @@ bitflags! {\n                                   TypeFlags::HAS_FREE_REGIONS.bits |\n                                   TypeFlags::HAS_TY_ERR.bits |\n                                   TypeFlags::HAS_PROJECTION.bits |\n-                                  TypeFlags::HAS_TY_CLOSURE.bits,\n+                                  TypeFlags::HAS_TY_CLOSURE.bits |\n+                                  TypeFlags::HAS_LOCAL_NAMES.bits,\n \n         // Caches for type_is_sized, type_moves_by_default\n         const SIZEDNESS_CACHED  = 1 << 16,\n@@ -986,6 +997,9 @@ pub fn type_has_ty_infer(ty: Ty) -> bool {\n pub fn type_needs_infer(ty: Ty) -> bool {\n     ty.flags.get().intersects(TypeFlags::HAS_TY_INFER | TypeFlags::HAS_RE_INFER)\n }\n+pub fn type_is_global(ty: Ty) -> bool {\n+    !ty.flags.get().intersects(TypeFlags::HAS_LOCAL_NAMES)\n+}\n pub fn type_has_projection(ty: Ty) -> bool {\n     ty.flags.get().intersects(TypeFlags::HAS_PROJECTION)\n }\n@@ -1288,6 +1302,15 @@ pub struct UpvarBorrow {\n pub type UpvarCaptureMap = FnvHashMap<UpvarId, UpvarCapture>;\n \n impl Region {\n+    pub fn is_global(&self) -> bool {\n+        // does this represent a region that can be named in a global\n+        // way? used in fulfillment caching.\n+        match *self {\n+            ty::ReStatic | ty::ReEmpty => true,\n+            _ => false,\n+        }\n+    }\n+\n     pub fn is_bound(&self) -> bool {\n         match *self {\n             ty::ReEarlyBound(..) => true,\n@@ -2022,6 +2045,29 @@ impl<'tcx> Predicate<'tcx> {\n                 Predicate::Projection(ty::Binder(data.subst(tcx, substs))),\n         }\n     }\n+\n+    // Indicates whether this predicate references only 'global'\n+    // types/lifetimes that are the same regardless of what fn we are\n+    // in. This is used for caching. Errs on the side of returning\n+    // false.\n+    pub fn is_global(&self) -> bool {\n+        match *self {\n+            ty::Predicate::Trait(ref data) => {\n+                let substs = data.skip_binder().trait_ref.substs;\n+\n+                substs.types.iter().all(|t| ty::type_is_global(t)) && {\n+                    match substs.regions {\n+                        subst::ErasedRegions => true,\n+                        subst::NonerasedRegions(ref r) => r.iter().all(|r| r.is_global()),\n+                    }\n+                }\n+            }\n+\n+            _ => {\n+                false\n+            }\n+        }\n+    }\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n@@ -2798,6 +2844,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         trait_defs: RefCell::new(DefIdMap()),\n         predicates: RefCell::new(DefIdMap()),\n         super_predicates: RefCell::new(DefIdMap()),\n+        fulfilled_predicates: RefCell::new(traits::FulfilledPredicates::new()),\n         map: map,\n         freevars: freevars,\n         tcache: RefCell::new(DefIdMap()),\n@@ -3010,6 +3057,7 @@ impl FlagComputation {\n             }\n \n             &TyParam(ref p) => {\n+                self.add_flags(TypeFlags::HAS_LOCAL_NAMES);\n                 if p.space == subst::SelfSpace {\n                     self.add_flags(TypeFlags::HAS_SELF);\n                 } else {\n@@ -3018,11 +3066,12 @@ impl FlagComputation {\n             }\n \n             &TyClosure(_, substs) => {\n-                self.add_flags(TypeFlags::HAS_TY_CLOSURE);\n+                self.add_flags(TypeFlags::HAS_LOCAL_NAMES);\n                 self.add_substs(substs);\n             }\n \n             &TyInfer(_) => {\n+                self.add_flags(TypeFlags::HAS_LOCAL_NAMES); // it might, right?\n                 self.add_flags(TypeFlags::HAS_TY_INFER)\n             }\n \n@@ -3102,6 +3151,10 @@ impl FlagComputation {\n             ty::ReStatic => {}\n             _ => { self.add_flags(TypeFlags::HAS_FREE_REGIONS); }\n         }\n+\n+        if !r.is_global() {\n+            self.add_flags(TypeFlags::HAS_LOCAL_NAMES);\n+        }\n     }\n \n     fn add_projection_predicate(&mut self, projection_predicate: &ProjectionPredicate) {"}, {"sha": "1cabeb268562daf2770f736090feacd1747e42af", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff89fcf83b41c2759d69c01d5e41b9043f5acff8/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff89fcf83b41c2759d69c01d5e41b9043f5acff8/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=ff89fcf83b41c2759d69c01d5e41b9043f5acff8", "patch": "@@ -1041,7 +1041,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // Currently, we use a fulfillment context to completely resolve\n     // all nested obligations. This is because they can inform the\n     // inference of the impl's type parameters.\n-    let mut fulfill_cx = traits::FulfillmentContext::new();\n+    let mut fulfill_cx = traits::FulfillmentContext::new(true);\n     let vtable = selection.map(|predicate| {\n         fulfill_cx.register_predicate_obligation(&infcx, predicate);\n     });\n@@ -1069,7 +1069,7 @@ pub fn normalize_and_test_predicates<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let infcx = infer::new_infer_ctxt(tcx);\n     let typer = NormalizingClosureTyper::new(tcx);\n     let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n-    let mut fulfill_cx = traits::FulfillmentContext::new();\n+    let mut fulfill_cx = traits::FulfillmentContext::new(false);\n     let cause = traits::ObligationCause::dummy();\n     let traits::Normalized { value: predicates, obligations } =\n         traits::normalize(&mut selcx, cause.clone(), &predicates);"}, {"sha": "e28dd77d5e58e008ddf2c52dd8ccafe8667e0789", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff89fcf83b41c2759d69c01d5e41b9043f5acff8/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff89fcf83b41c2759d69c01d5e41b9043f5acff8/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=ff89fcf83b41c2759d69c01d5e41b9043f5acff8", "patch": "@@ -337,7 +337,7 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n            result.repr(tcx),\n            obligations.repr(tcx));\n \n-    let mut fulfill_cx = traits::FulfillmentContext::new();\n+    let mut fulfill_cx = traits::FulfillmentContext::new(true);\n     for obligation in obligations {\n         fulfill_cx.register_predicate_obligation(&infcx, obligation);\n     }"}, {"sha": "c5861be2716b2e5c2313b8d3ed5f64c50f705fae", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ff89fcf83b41c2759d69c01d5e41b9043f5acff8/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff89fcf83b41c2759d69c01d5e41b9043f5acff8/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=ff89fcf83b41c2759d69c01d5e41b9043f5acff8", "patch": "@@ -45,7 +45,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n            impl_trait_ref.repr(tcx));\n \n     let infcx = infer::new_infer_ctxt(tcx);\n-    let mut fulfillment_cx = traits::FulfillmentContext::new();\n+    let mut fulfillment_cx = traits::FulfillmentContext::new(true);\n \n     let trait_to_impl_substs = &impl_trait_ref.substs;\n \n@@ -422,7 +422,7 @@ pub fn compare_const_impl<'tcx>(tcx: &ty::ctxt<'tcx>,\n            impl_trait_ref.repr(tcx));\n \n     let infcx = infer::new_infer_ctxt(tcx);\n-    let mut fulfillment_cx = traits::FulfillmentContext::new();\n+    let mut fulfillment_cx = traits::FulfillmentContext::new(true);\n \n     // The below is for the most part highly similar to the procedure\n     // for methods above. It is simpler in many respects, especially"}, {"sha": "9df0d4aa56b8a99fec5eda6e081dfe9e7f0da49f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff89fcf83b41c2759d69c01d5e41b9043f5acff8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff89fcf83b41c2759d69c01d5e41b9043f5acff8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ff89fcf83b41c2759d69c01d5e41b9043f5acff8", "patch": "@@ -386,7 +386,7 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n             closure_tys: RefCell::new(DefIdMap()),\n             closure_kinds: RefCell::new(DefIdMap()),\n             fn_sig_map: RefCell::new(NodeMap()),\n-            fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n+            fulfillment_cx: RefCell::new(traits::FulfillmentContext::new(true)),\n             deferred_call_resolutions: RefCell::new(DefIdMap()),\n             deferred_cast_checks: RefCell::new(Vec::new()),\n         }"}, {"sha": "cd7be46f9e01210ede09af8d4dddc9285bf73927", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ff89fcf83b41c2759d69c01d5e41b9043f5acff8/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff89fcf83b41c2759d69c01d5e41b9043f5acff8/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=ff89fcf83b41c2759d69c01d5e41b9043f5acff8", "patch": "@@ -539,7 +539,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                 }\n             };\n \n-            let mut fulfill_cx = traits::FulfillmentContext::new();\n+            let mut fulfill_cx = traits::FulfillmentContext::new(true);\n \n             // Register an obligation for `A: Trait<B>`.\n             let cause = traits::ObligationCause::misc(span, impl_did.node);"}]}