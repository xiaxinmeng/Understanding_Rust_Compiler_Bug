{"sha": "c8a52850cffd1e13e1f695451127f981345c72ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4YTUyODUwY2ZmZDFlMTNlMWY2OTU0NTExMjdmOTgxMzQ1YzcyZWM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-03-23T08:19:34Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-04-23T17:28:14Z"}, "message": "create a `QueryRegionConstraint` type\n\nChalk wants to be able to pass these constraints around. Also, the\nform we were using in our existing queries was not as general as we\nare going to need.", "tree": {"sha": "0dd1142d1404557720f6c6da8887d4ad770054f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0dd1142d1404557720f6c6da8887d4ad770054f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8a52850cffd1e13e1f695451127f981345c72ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8a52850cffd1e13e1f695451127f981345c72ec", "html_url": "https://github.com/rust-lang/rust/commit/c8a52850cffd1e13e1f695451127f981345c72ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8a52850cffd1e13e1f695451127f981345c72ec/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3aa1085cfc3b39d4c2b03642c79f1557a2424d87", "url": "https://api.github.com/repos/rust-lang/rust/commits/3aa1085cfc3b39d4c2b03642c79f1557a2424d87", "html_url": "https://github.com/rust-lang/rust/commit/3aa1085cfc3b39d4c2b03642c79f1557a2424d87"}], "stats": {"total": 115, "additions": 45, "deletions": 70}, "files": [{"sha": "acb1d2272ef52dbd0c704bcb0f9ee459bc85e912", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c8a52850cffd1e13e1f695451127f981345c72ec/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8a52850cffd1e13e1f695451127f981345c72ec/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=c8a52850cffd1e13e1f695451127f981345c72ec", "patch": "@@ -1352,10 +1352,6 @@ impl_stable_hash_for!(\n     }\n );\n \n-impl_stable_hash_for!(struct infer::canonical::QueryRegionConstraints<'tcx> {\n-    region_outlives, ty_outlives\n-});\n-\n impl_stable_hash_for!(enum infer::canonical::Certainty {\n     Proven, Ambiguous\n });"}, {"sha": "25f8b5d8c9cc0422f1c7fd288e3fd359bcf116c0", "filename": "src/librustc/infer/canonical.rs", "status": "modified", "additions": 23, "deletions": 48, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/c8a52850cffd1e13e1f695451127f981345c72ec/src%2Flibrustc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8a52850cffd1e13e1f695451127f981345c72ec/src%2Flibrustc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical.rs?ref=c8a52850cffd1e13e1f695451127f981345c72ec", "patch": "@@ -42,7 +42,6 @@ use traits::{Obligation, ObligationCause, PredicateObligation};\n use ty::{self, CanonicalVar, Lift, Region, Slice, Ty, TyCtxt, TypeFlags};\n use ty::subst::{Kind, UnpackedKind};\n use ty::fold::{TypeFoldable, TypeFolder};\n-use util::captures::Captures;\n \n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_data_structures::fx::FxHashMap;\n@@ -121,7 +120,7 @@ pub enum CanonicalTyVarKind {\n #[derive(Clone, Debug)]\n pub struct QueryResult<'tcx, R> {\n     pub var_values: CanonicalVarValues<'tcx>,\n-    pub region_constraints: QueryRegionConstraints<'tcx>,\n+    pub region_constraints: Vec<QueryRegionConstraint<'tcx>>,\n     pub certainty: Certainty,\n     pub value: R,\n }\n@@ -181,12 +180,7 @@ impl<'tcx, R> Canonical<'tcx, QueryResult<'tcx, R>> {\n     }\n }\n \n-/// Subset of `RegionConstraintData` produced by trait query.\n-#[derive(Clone, Debug, Default)]\n-pub struct QueryRegionConstraints<'tcx> {\n-    pub region_outlives: Vec<(Region<'tcx>, Region<'tcx>)>,\n-    pub ty_outlives: Vec<(Ty<'tcx>, Region<'tcx>)>,\n-}\n+pub type QueryRegionConstraint<'tcx> = ty::Binder<ty::OutlivesPredicate<Kind<'tcx>, Region<'tcx>>>;\n \n /// Trait implemented by values that can be canonicalized. It mainly\n /// serves to identify the interning table we will use.\n@@ -382,35 +376,29 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n         &'a self,\n         cause: &'a ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-        unsubstituted_region_constraints: &'a QueryRegionConstraints<'tcx>,\n+        unsubstituted_region_constraints: &'a [QueryRegionConstraint<'tcx>],\n         result_subst: &'a CanonicalVarValues<'tcx>,\n-    ) -> impl Iterator<Item = PredicateObligation<'tcx>> + Captures<'gcx> + 'a {\n-        let QueryRegionConstraints {\n-            region_outlives,\n-            ty_outlives,\n-        } = unsubstituted_region_constraints;\n-\n-        let region_obligations = region_outlives.iter().map(move |(r1, r2)| {\n-            let r1 = substitute_value(self.tcx, result_subst, r1);\n-            let r2 = substitute_value(self.tcx, result_subst, r2);\n-            Obligation::new(\n-                cause.clone(),\n-                param_env,\n-                ty::Predicate::RegionOutlives(ty::Binder(ty::OutlivesPredicate(r1, r2))),\n-            )\n-        });\n-\n-        let ty_obligations = ty_outlives.iter().map(move |(t1, r2)| {\n-            let t1 = substitute_value(self.tcx, result_subst, t1);\n+    ) -> impl Iterator<Item = PredicateObligation<'tcx>> + 'a {\n+        Box::new(unsubstituted_region_constraints.iter().map(move |constraint| {\n+            let ty::OutlivesPredicate(k1, r2) = constraint.skip_binder(); // restored below\n+            let k1 = substitute_value(self.tcx, result_subst, k1);\n             let r2 = substitute_value(self.tcx, result_subst, r2);\n-            Obligation::new(\n-                cause.clone(),\n-                param_env,\n-                ty::Predicate::TypeOutlives(ty::Binder(ty::OutlivesPredicate(t1, r2))),\n-            )\n-        });\n-\n-        region_obligations.chain(ty_obligations)\n+            match k1.unpack() {\n+                UnpackedKind::Lifetime(r1) =>\n+                    Obligation::new(\n+                        cause.clone(),\n+                        param_env,\n+                        ty::Predicate::RegionOutlives(ty::Binder(ty::OutlivesPredicate(r1, r2))),\n+                    ),\n+\n+                UnpackedKind::Type(t1) =>\n+                    Obligation::new(\n+                        cause.clone(),\n+                        param_env,\n+                        ty::Predicate::TypeOutlives(ty::Binder(ty::OutlivesPredicate(t1, r2))),\n+                    ),\n+            }\n+        })) as Box<dyn Iterator<Item = _>>\n     }\n \n     /// Given two sets of values for the same set of canonical variables, unify them.\n@@ -913,19 +901,6 @@ BraceStructTypeFoldableImpl! {\n     }\n }\n \n-BraceStructTypeFoldableImpl! {\n-    impl<'tcx> TypeFoldable<'tcx> for QueryRegionConstraints<'tcx> {\n-        region_outlives, ty_outlives\n-    }\n-}\n-\n-BraceStructLiftImpl! {\n-    impl<'a, 'tcx> Lift<'tcx> for QueryRegionConstraints<'a> {\n-        type Lifted = QueryRegionConstraints<'tcx>;\n-        region_outlives, ty_outlives\n-    }\n-}\n-\n BraceStructTypeFoldableImpl! {\n     impl<'tcx, R> TypeFoldable<'tcx> for QueryResult<'tcx, R> {\n         var_values, region_constraints, certainty, value"}, {"sha": "f25906a7bcad1593e3fff4e003bf671e4c7241d7", "filename": "src/librustc_traits/util.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c8a52850cffd1e13e1f695451127f981345c72ec/src%2Flibrustc_traits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8a52850cffd1e13e1f695451127f981345c72ec/src%2Flibrustc_traits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Futil.rs?ref=c8a52850cffd1e13e1f695451127f981345c72ec", "patch": "@@ -9,8 +9,7 @@\n // except according to those terms.\n \n use rustc::infer::InferCtxt;\n-use rustc::infer::canonical::{CanonicalVarValues, Canonicalize, Certainty, QueryRegionConstraints,\n-                              QueryResult};\n+use rustc::infer::canonical::{CanonicalVarValues, Canonicalize, Certainty, QueryResult};\n use rustc::infer::region_constraints::{Constraint, RegionConstraintData};\n use rustc::traits::{FulfillmentContext, TraitEngine};\n use rustc::traits::query::NoSolution;\n@@ -62,7 +61,7 @@ where\n \n     let region_obligations = infcx.take_registered_region_obligations();\n \n-    let (region_outlives, ty_outlives) = infcx.with_region_constraints(|region_constraints| {\n+    let region_constraints = infcx.with_region_constraints(|region_constraints| {\n         let RegionConstraintData {\n             constraints,\n             verifys,\n@@ -72,24 +71,32 @@ where\n         assert!(verifys.is_empty());\n         assert!(givens.is_empty());\n \n-        let region_outlives: Vec<_> = constraints\n+        let mut outlives: Vec<_> = constraints\n             .into_iter()\n             .map(|(k, _)| match *k {\n-                Constraint::VarSubVar(v1, v2) => {\n-                    (tcx.mk_region(ty::ReVar(v1)), tcx.mk_region(ty::ReVar(v2)))\n+                Constraint::VarSubVar(v1, v2) => ty::OutlivesPredicate(\n+                    tcx.mk_region(ty::ReVar(v1)).into(),\n+                    tcx.mk_region(ty::ReVar(v2)),\n+                ),\n+                Constraint::VarSubReg(v1, r2) => {\n+                    ty::OutlivesPredicate(tcx.mk_region(ty::ReVar(v1)).into(), r2)\n                 }\n-                Constraint::VarSubReg(v1, r2) => (tcx.mk_region(ty::ReVar(v1)), r2),\n-                Constraint::RegSubVar(r1, v2) => (r1, tcx.mk_region(ty::ReVar(v2))),\n-                Constraint::RegSubReg(r1, r2) => (r1, r2),\n+                Constraint::RegSubVar(r1, v2) => {\n+                    ty::OutlivesPredicate(r1.into(), tcx.mk_region(ty::ReVar(v2)))\n+                }\n+                Constraint::RegSubReg(r1, r2) => ty::OutlivesPredicate(r1.into(), r2),\n             })\n+            .map(ty::Binder) // no bound regions in the code above\n             .collect();\n \n-        let ty_outlives: Vec<_> = region_obligations\n-            .into_iter()\n-            .map(|(_, r_o)| (r_o.sup_type, r_o.sub_region))\n-            .collect();\n+        outlives.extend(\n+            region_obligations\n+                .into_iter()\n+                .map(|(_, r_o)| ty::OutlivesPredicate(r_o.sup_type.into(), r_o.sub_region))\n+                .map(ty::Binder) // no bound regions in the code above\n+        );\n \n-        (region_outlives, ty_outlives)\n+        outlives\n     });\n \n     let certainty = if ambig_errors.is_empty() {\n@@ -100,10 +107,7 @@ where\n \n     let (canonical_result, _) = infcx.canonicalize_response(&QueryResult {\n         var_values: inference_vars,\n-        region_constraints: QueryRegionConstraints {\n-            region_outlives,\n-            ty_outlives,\n-        },\n+        region_constraints,\n         certainty,\n         value: answer,\n     });"}]}