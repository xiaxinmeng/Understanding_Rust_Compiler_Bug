{"sha": "2b5ddf36fdc784106b3a064d93dd054c32b1f10f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiNWRkZjM2ZmRjNzg0MTA2YjNhMDY0ZDkzZGQwNTRjMzJiMWYxMGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-16T05:29:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-16T05:29:22Z"}, "message": "Auto merge of #86809 - DevinR528:reachable-pat, r=Nadrieril\n\nAdd non_exhaustive_omitted_patterns lint related to rfc-2008-non_exhaustive\n\nFixes: #84332\n\nThis PR adds `non_exhaustive_omitted_patterns`, an allow by default lint that is triggered when a `non_exhaustive` type is missing explicit patterns. The warning or deny attribute can be put above the wildcard `_` pattern on enums or on the expression for enums or structs. The lint is capable of warning about multiple types within the same pattern. This lint will not be triggered for `if let ..` patterns.\n\n```rust\n// crate A\n#[non_exhaustive]\npub struct Foo {\n    a: u8,\n    b: usize,\n}\n#[non_exhaustive]\npub enum Bar {\n    A(Foo),\n    B,\n}\n\n// crate B\n#[deny(non_exhaustive_omitted_patterns)] // here\nmatch Bar::B {\n    Bar::B => {}\n    #[deny(non_exhaustive_omitted_patterns)] // or here\n    _ => {}\n}\n\n#[warn(non_exhaustive_omitted_patterns)] // only here\nlet Foo { a, .. } = Foo::default();\n\n#[deny(non_exhaustive_omitted_patterns)]\nmatch Bar::B {\n    // triggers for Bar::B, and Foo.b\n    Bar::A(Foo { a, .. }) => {}\n    // if the attribute was here only Bar::B would cause a warning\n    _ => {}\n}\n```", "tree": {"sha": "b7909aba82b177109b1fc074f0907f2788f27084", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b7909aba82b177109b1fc074f0907f2788f27084"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b5ddf36fdc784106b3a064d93dd054c32b1f10f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b5ddf36fdc784106b3a064d93dd054c32b1f10f", "html_url": "https://github.com/rust-lang/rust/commit/2b5ddf36fdc784106b3a064d93dd054c32b1f10f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b5ddf36fdc784106b3a064d93dd054c32b1f10f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34327f6eee06835f81a26765a70ad51d44343ba3", "url": "https://api.github.com/repos/rust-lang/rust/commits/34327f6eee06835f81a26765a70ad51d44343ba3", "html_url": "https://github.com/rust-lang/rust/commit/34327f6eee06835f81a26765a70ad51d44343ba3"}, {"sha": "33a06b73d90bde1d2fc4902672f4cbeb233b83e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/33a06b73d90bde1d2fc4902672f4cbeb233b83e2", "html_url": "https://github.com/rust-lang/rust/commit/33a06b73d90bde1d2fc4902672f4cbeb233b83e2"}], "stats": {"total": 694, "additions": 626, "deletions": 68}, "files": [{"sha": "a00561e5213570ab7fa39eb60290a04c1b92b0a8", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/2b5ddf36fdc784106b3a064d93dd054c32b1f10f/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b5ddf36fdc784106b3a064d93dd054c32b1f10f/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=2b5ddf36fdc784106b3a064d93dd054c32b1f10f", "patch": "@@ -3010,6 +3010,7 @@ declare_lint_pass! {\n         UNSUPPORTED_CALLING_CONVENTIONS,\n         BREAK_WITH_LABEL_AND_LOOP,\n         UNUSED_ATTRIBUTES,\n+        NON_EXHAUSTIVE_OMITTED_PATTERNS,\n     ]\n }\n \n@@ -3416,3 +3417,56 @@ declare_lint! {\n     Warn,\n     \"`break` expression with label and unlabeled loop as value expression\"\n }\n+\n+declare_lint! {\n+    /// The `non_exhaustive_omitted_patterns` lint detects when a wildcard (`_` or `..`) in a\n+    /// pattern for a `#[non_exhaustive]` struct or enum is reachable.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,ignore (needs separate crate)\n+    /// // crate A\n+    /// #[non_exhaustive]\n+    /// pub enum Bar {\n+    ///     A,\n+    ///     B, // added variant in non breaking change\n+    /// }\n+    ///\n+    /// // in crate B\n+    /// match Bar::A {\n+    ///     Bar::A => {},\n+    ///     #[warn(non_exhaustive_omitted_patterns)]\n+    ///     _ => {},\n+    /// }\n+    /// ```\n+    ///\n+    /// This will produce:\n+    ///\n+    /// ```text\n+    /// warning: reachable patterns not covered of non exhaustive enum\n+    ///    --> $DIR/reachable-patterns.rs:70:9\n+    ///    |\n+    /// LL |         _ => {}\n+    ///    |         ^ pattern `B` not covered\n+    ///    |\n+    ///  note: the lint level is defined here\n+    ///   --> $DIR/reachable-patterns.rs:69:16\n+    ///    |\n+    /// LL |         #[warn(non_exhaustive_omitted_patterns)]\n+    ///    |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+    ///    = help: ensure that all possible cases are being handled by adding the suggested match arms\n+    ///    = note: the matched value is of type `Bar` and the `non_exhaustive_omitted_patterns` attribute was found\n+    /// ```\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Structs and enums tagged with `#[non_exhaustive]` force the user to add a\n+    /// (potentially redundant) wildcard when pattern-matching, to allow for future\n+    /// addition of fields or variants. The `non_exhaustive_omitted_patterns` lint\n+    /// detects when such a wildcard happens to actually catch some fields/variants.\n+    /// In other words, when the match without the wildcard would not be exhaustive.\n+    /// This lets the user be informed if new fields/variants were added.\n+    pub NON_EXHAUSTIVE_OMITTED_PATTERNS,\n+    Allow,\n+    \"detect when patterns of types marked `non_exhaustive` are missed\",\n+}"}, {"sha": "4c51b9207bb750b03536b53de29c4183ec1aa2f7", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2b5ddf36fdc784106b3a064d93dd054c32b1f10f/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b5ddf36fdc784106b3a064d93dd054c32b1f10f/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=2b5ddf36fdc784106b3a064d93dd054c32b1f10f", "patch": "@@ -14,8 +14,9 @@ use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::{HirId, Pat};\n use rustc_middle::thir::PatKind;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_session::lint::builtin::BINDINGS_WITH_VARIANT_NAME;\n-use rustc_session::lint::builtin::{IRREFUTABLE_LET_PATTERNS, UNREACHABLE_PATTERNS};\n+use rustc_session::lint::builtin::{\n+    BINDINGS_WITH_VARIANT_NAME, IRREFUTABLE_LET_PATTERNS, UNREACHABLE_PATTERNS,\n+};\n use rustc_session::Session;\n use rustc_span::{DesugaringKind, ExpnKind, Span};\n use std::slice;\n@@ -559,7 +560,7 @@ fn non_exhaustive_match<'p, 'tcx>(\n     err.emit();\n }\n \n-fn joined_uncovered_patterns(witnesses: &[super::Pat<'_>]) -> String {\n+crate fn joined_uncovered_patterns(witnesses: &[super::Pat<'_>]) -> String {\n     const LIMIT: usize = 3;\n     match witnesses {\n         [] => bug!(),\n@@ -576,7 +577,7 @@ fn joined_uncovered_patterns(witnesses: &[super::Pat<'_>]) -> String {\n     }\n }\n \n-fn pattern_not_covered_label(witnesses: &[super::Pat<'_>], joined_patterns: &str) -> String {\n+crate fn pattern_not_covered_label(witnesses: &[super::Pat<'_>], joined_patterns: &str) -> String {\n     format!(\"pattern{} {} not covered\", rustc_errors::pluralize!(witnesses.len()), joined_patterns)\n }\n "}, {"sha": "cee2a4db0a8b3b6649bf487801d361f8ff97ca6f", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 44, "deletions": 14, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/2b5ddf36fdc784106b3a064d93dd054c32b1f10f/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b5ddf36fdc784106b3a064d93dd054c32b1f10f/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=2b5ddf36fdc784106b3a064d93dd054c32b1f10f", "patch": "@@ -606,8 +606,9 @@ pub(super) enum Constructor<'tcx> {\n     /// for those types for which we cannot list constructors explicitly, like `f64` and `str`.\n     NonExhaustive,\n     /// Stands for constructors that are not seen in the matrix, as explained in the documentation\n-    /// for [`SplitWildcard`].\n-    Missing,\n+    /// for [`SplitWildcard`]. The carried `bool` is used for the `non_exhaustive_omitted_patterns`\n+    /// lint.\n+    Missing { nonexhaustive_enum_missing_real_variants: bool },\n     /// Wildcard pattern.\n     Wildcard,\n }\n@@ -617,6 +618,10 @@ impl<'tcx> Constructor<'tcx> {\n         matches!(self, Wildcard)\n     }\n \n+    pub(super) fn is_non_exhaustive(&self) -> bool {\n+        matches!(self, NonExhaustive)\n+    }\n+\n     fn as_int_range(&self) -> Option<&IntRange> {\n         match self {\n             IntRange(range) => Some(range),\n@@ -756,7 +761,7 @@ impl<'tcx> Constructor<'tcx> {\n             // Wildcards cover anything\n             (_, Wildcard) => true,\n             // The missing ctors are not covered by anything in the matrix except wildcards.\n-            (Missing | Wildcard, _) => false,\n+            (Missing { .. } | Wildcard, _) => false,\n \n             (Single, Single) => true,\n             (Variant(self_id), Variant(other_id)) => self_id == other_id,\n@@ -829,7 +834,7 @@ impl<'tcx> Constructor<'tcx> {\n                 .any(|other| slice.is_covered_by(other)),\n             // This constructor is never covered by anything else\n             NonExhaustive => false,\n-            Str(..) | FloatRange(..) | Opaque | Missing | Wildcard => {\n+            Str(..) | FloatRange(..) | Opaque | Missing { .. } | Wildcard => {\n                 span_bug!(pcx.span, \"found unexpected ctor in all_ctors: {:?}\", self)\n             }\n         }\n@@ -919,8 +924,14 @@ impl<'tcx> SplitWildcard<'tcx> {\n                     && !cx.tcx.features().exhaustive_patterns\n                     && !pcx.is_top_level;\n \n-                if is_secretly_empty || is_declared_nonexhaustive {\n+                if is_secretly_empty {\n                     smallvec![NonExhaustive]\n+                } else if is_declared_nonexhaustive {\n+                    def.variants\n+                        .indices()\n+                        .map(|idx| Variant(idx))\n+                        .chain(Some(NonExhaustive))\n+                        .collect()\n                 } else if cx.tcx.features().exhaustive_patterns {\n                     // If `exhaustive_patterns` is enabled, we exclude variants known to be\n                     // uninhabited.\n@@ -975,6 +986,7 @@ impl<'tcx> SplitWildcard<'tcx> {\n             // This type is one for which we cannot list constructors, like `str` or `f64`.\n             _ => smallvec![NonExhaustive],\n         };\n+\n         SplitWildcard { matrix_ctors: Vec::new(), all_ctors }\n     }\n \n@@ -1039,7 +1051,17 @@ impl<'tcx> SplitWildcard<'tcx> {\n             // sometimes prefer reporting the list of constructors instead of just `_`.\n             let report_when_all_missing = pcx.is_top_level && !IntRange::is_integral(pcx.ty);\n             let ctor = if !self.matrix_ctors.is_empty() || report_when_all_missing {\n-                Missing\n+                if pcx.is_non_exhaustive {\n+                    Missing {\n+                        nonexhaustive_enum_missing_real_variants: self\n+                            .iter_missing(pcx)\n+                            .filter(|c| !c.is_non_exhaustive())\n+                            .next()\n+                            .is_some(),\n+                    }\n+                } else {\n+                    Missing { nonexhaustive_enum_missing_real_variants: false }\n+                }\n             } else {\n                 Wildcard\n             };\n@@ -1176,7 +1198,12 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n                 }\n                 _ => bug!(\"bad slice pattern {:?} {:?}\", constructor, ty),\n             },\n-            Str(..) | FloatRange(..) | IntRange(..) | NonExhaustive | Opaque | Missing\n+            Str(..)\n+            | FloatRange(..)\n+            | IntRange(..)\n+            | NonExhaustive\n+            | Opaque\n+            | Missing { .. }\n             | Wildcard => Fields::Slice(&[]),\n         };\n         debug!(\"Fields::wildcards({:?}, {:?}) = {:#?}\", constructor, ty, ret);\n@@ -1189,15 +1216,18 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n     /// This is roughly the inverse of `specialize_constructor`.\n     ///\n     /// Examples:\n-    /// `ctor`: `Constructor::Single`\n-    /// `ty`: `Foo(u32, u32, u32)`\n-    /// `self`: `[10, 20, _]`\n+    ///\n+    /// ```text\n+    /// ctor: `Constructor::Single`\n+    /// ty: `Foo(u32, u32, u32)`\n+    /// self: `[10, 20, _]`\n     /// returns `Foo(10, 20, _)`\n     ///\n-    /// `ctor`: `Constructor::Variant(Option::Some)`\n-    /// `ty`: `Option<bool>`\n-    /// `self`: `[false]`\n+    /// ctor: `Constructor::Variant(Option::Some)`\n+    /// ty: `Option<bool>`\n+    /// self: `[false]`\n     /// returns `Some(false)`\n+    /// ```\n     pub(super) fn apply(self, pcx: PatCtxt<'_, 'p, 'tcx>, ctor: &Constructor<'tcx>) -> Pat<'tcx> {\n         let subpatterns_and_indices = self.patterns_and_indices();\n         let mut subpatterns = subpatterns_and_indices.iter().map(|&(_, p)| p).cloned();\n@@ -1265,7 +1295,7 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n             NonExhaustive => PatKind::Wild,\n             Wildcard => return Pat::wildcard_from_ty(pcx.ty),\n             Opaque => bug!(\"we should not try to apply an opaque constructor\"),\n-            Missing => bug!(\n+            Missing { .. } => bug!(\n                 \"trying to apply the `Missing` constructor; this should have been done in `apply_constructors`\"\n             ),\n         };"}, {"sha": "f4255713e2a378bebca4e2c010c5c7b9447565c6", "filename": "compiler/rustc_mir_build/src/thir/pattern/usefulness.rs", "status": "modified", "additions": 121, "deletions": 33, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/2b5ddf36fdc784106b3a064d93dd054c32b1f10f/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b5ddf36fdc784106b3a064d93dd054c32b1f10f/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fusefulness.rs?ref=2b5ddf36fdc784106b3a064d93dd054c32b1f10f", "patch": "@@ -280,20 +280,23 @@\n //! The details are not necessary to understand this file, so we explain them in\n //! [`super::deconstruct_pat`]. Splitting is done by the [`Constructor::split`] function.\n \n+use self::ArmType::*;\n use self::Usefulness::*;\n-use self::WitnessPreference::*;\n \n+use super::check_match::{joined_uncovered_patterns, pattern_not_covered_label};\n use super::deconstruct_pat::{Constructor, Fields, SplitWildcard};\n use super::{PatternFoldable, PatternFolder};\n \n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashMap;\n \n+use hir::def_id::DefId;\n+use hir::HirId;\n use rustc_arena::TypedArena;\n-use rustc_hir::def_id::DefId;\n-use rustc_hir::HirId;\n+use rustc_hir as hir;\n use rustc_middle::thir::{Pat, PatKind};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_session::lint::builtin::NON_EXHAUSTIVE_OMITTED_PATTERNS;\n use rustc_span::Span;\n \n use smallvec::{smallvec, SmallVec};\n@@ -343,6 +346,8 @@ pub(super) struct PatCtxt<'a, 'p, 'tcx> {\n     /// Whether the current pattern is the whole pattern as found in a match arm, or if it's a\n     /// subpattern.\n     pub(super) is_top_level: bool,\n+    /// Wether the current pattern is from a `non_exhaustive` enum.\n+    pub(super) is_non_exhaustive: bool,\n }\n \n impl<'a, 'p, 'tcx> fmt::Debug for PatCtxt<'a, 'p, 'tcx> {\n@@ -862,7 +867,7 @@ impl<'p, 'tcx> SubPatSet<'p, 'tcx> {\n /// of potential unreachable sub-patterns (in the presence of or-patterns). When checking\n /// exhaustiveness of a whole match, we use the `WithWitnesses` variant, which carries a list of\n /// witnesses of non-exhaustiveness when there are any.\n-/// Which variant to use is dictated by `WitnessPreference`.\n+/// Which variant to use is dictated by `ArmType`.\n #[derive(Clone, Debug)]\n enum Usefulness<'p, 'tcx> {\n     /// Carries a set of subpatterns that have been found to be reachable. If empty, this indicates\n@@ -877,16 +882,24 @@ enum Usefulness<'p, 'tcx> {\n }\n \n impl<'p, 'tcx> Usefulness<'p, 'tcx> {\n-    fn new_useful(preference: WitnessPreference) -> Self {\n+    fn new_useful(preference: ArmType) -> Self {\n         match preference {\n-            ConstructWitness => WithWitnesses(vec![Witness(vec![])]),\n-            LeaveOutWitness => NoWitnesses(SubPatSet::full()),\n+            FakeExtraWildcard => WithWitnesses(vec![Witness(vec![])]),\n+            RealArm => NoWitnesses(SubPatSet::full()),\n         }\n     }\n-    fn new_not_useful(preference: WitnessPreference) -> Self {\n+\n+    fn new_not_useful(preference: ArmType) -> Self {\n         match preference {\n-            ConstructWitness => WithWitnesses(vec![]),\n-            LeaveOutWitness => NoWitnesses(SubPatSet::empty()),\n+            FakeExtraWildcard => WithWitnesses(vec![]),\n+            RealArm => NoWitnesses(SubPatSet::empty()),\n+        }\n+    }\n+\n+    fn is_useful(&self) -> bool {\n+        match self {\n+            Usefulness::NoWitnesses(set) => !set.is_empty(),\n+            Usefulness::WithWitnesses(witnesses) => !witnesses.is_empty(),\n         }\n     }\n \n@@ -903,7 +916,7 @@ impl<'p, 'tcx> Usefulness<'p, 'tcx> {\n \n     /// When trying several branches and each returns a `Usefulness`, we need to combine the\n     /// results together.\n-    fn merge(pref: WitnessPreference, usefulnesses: impl Iterator<Item = Self>) -> Self {\n+    fn merge(pref: ArmType, usefulnesses: impl Iterator<Item = Self>) -> Self {\n         let mut ret = Self::new_not_useful(pref);\n         for u in usefulnesses {\n             ret.extend(u);\n@@ -926,7 +939,7 @@ impl<'p, 'tcx> Usefulness<'p, 'tcx> {\n         }\n     }\n \n-    /// After calculating usefulness after a specialization, call this to recontruct a usefulness\n+    /// After calculating usefulness after a specialization, call this to reconstruct a usefulness\n     /// that makes sense for the matrix pre-specialization. This new usefulness can then be merged\n     /// with the results of specializing with the other constructors.\n     fn apply_constructor(\n@@ -939,19 +952,31 @@ impl<'p, 'tcx> Usefulness<'p, 'tcx> {\n         match self {\n             WithWitnesses(witnesses) if witnesses.is_empty() => WithWitnesses(witnesses),\n             WithWitnesses(witnesses) => {\n-                let new_witnesses = if matches!(ctor, Constructor::Missing) {\n-                    let mut split_wildcard = SplitWildcard::new(pcx);\n-                    split_wildcard.split(pcx, matrix.head_ctors(pcx.cx));\n-                    // Construct for each missing constructor a \"wild\" version of this\n-                    // constructor, that matches everything that can be built with\n-                    // it. For example, if `ctor` is a `Constructor::Variant` for\n-                    // `Option::Some`, we get the pattern `Some(_)`.\n-                    let new_patterns: Vec<_> = split_wildcard\n-                        .iter_missing(pcx)\n-                        .map(|missing_ctor| {\n-                            Fields::wildcards(pcx, missing_ctor).apply(pcx, missing_ctor)\n-                        })\n-                        .collect();\n+                let new_witnesses = if let Constructor::Missing { .. } = ctor {\n+                    // We got the special `Missing` constructor, so each of the missing constructors\n+                    // gives a new pattern that is not caught by the match. We list those patterns.\n+                    let new_patterns = if pcx.is_non_exhaustive {\n+                        // Here we don't want the user to try to list all variants, we want them to add\n+                        // a wildcard, so we only suggest that.\n+                        vec![\n+                            Fields::wildcards(pcx, &Constructor::NonExhaustive)\n+                                .apply(pcx, &Constructor::NonExhaustive),\n+                        ]\n+                    } else {\n+                        let mut split_wildcard = SplitWildcard::new(pcx);\n+                        split_wildcard.split(pcx, matrix.head_ctors(pcx.cx));\n+                        // Construct for each missing constructor a \"wild\" version of this\n+                        // constructor, that matches everything that can be built with\n+                        // it. For example, if `ctor` is a `Constructor::Variant` for\n+                        // `Option::Some`, we get the pattern `Some(_)`.\n+                        split_wildcard\n+                            .iter_missing(pcx)\n+                            .map(|missing_ctor| {\n+                                Fields::wildcards(pcx, missing_ctor).apply(pcx, missing_ctor)\n+                            })\n+                            .collect()\n+                    };\n+\n                     witnesses\n                         .into_iter()\n                         .flat_map(|witness| {\n@@ -976,9 +1001,9 @@ impl<'p, 'tcx> Usefulness<'p, 'tcx> {\n }\n \n #[derive(Copy, Clone, Debug)]\n-enum WitnessPreference {\n-    ConstructWitness,\n-    LeaveOutWitness,\n+enum ArmType {\n+    FakeExtraWildcard,\n+    RealArm,\n }\n \n /// A witness of non-exhaustiveness for error reporting, represented\n@@ -1056,6 +1081,32 @@ impl<'tcx> Witness<'tcx> {\n     }\n }\n \n+/// Report that a match of a `non_exhaustive` enum marked with `non_exhaustive_omitted_patterns`\n+/// is not exhaustive enough.\n+///\n+/// NB: The partner lint for structs lives in `compiler/rustc_typeck/src/check/pat.rs`.\n+fn lint_non_exhaustive_omitted_patterns<'p, 'tcx>(\n+    cx: &MatchCheckCtxt<'p, 'tcx>,\n+    scrut_ty: Ty<'tcx>,\n+    sp: Span,\n+    hir_id: HirId,\n+    witnesses: Vec<Pat<'tcx>>,\n+) {\n+    let joined_patterns = joined_uncovered_patterns(&witnesses);\n+    cx.tcx.struct_span_lint_hir(NON_EXHAUSTIVE_OMITTED_PATTERNS, hir_id, sp, |build| {\n+        let mut lint = build.build(\"some variants are not matched explicitly\");\n+        lint.span_label(sp, pattern_not_covered_label(&witnesses, &joined_patterns));\n+        lint.help(\n+            \"ensure that all variants are matched explicitly by adding the suggested match arms\",\n+        );\n+        lint.note(&format!(\n+            \"the matched value is of type `{}` and the `non_exhaustive_omitted_patterns` attribute was found\",\n+            scrut_ty,\n+        ));\n+        lint.emit();\n+    });\n+}\n+\n /// Algorithm from <http://moscova.inria.fr/~maranget/papers/warn/index.html>.\n /// The algorithm from the paper has been modified to correctly handle empty\n /// types. The changes are:\n@@ -1086,7 +1137,7 @@ fn is_useful<'p, 'tcx>(\n     cx: &MatchCheckCtxt<'p, 'tcx>,\n     matrix: &Matrix<'p, 'tcx>,\n     v: &PatStack<'p, 'tcx>,\n-    witness_preference: WitnessPreference,\n+    witness_preference: ArmType,\n     hir_id: HirId,\n     is_under_guard: bool,\n     is_top_level: bool,\n@@ -1113,7 +1164,8 @@ fn is_useful<'p, 'tcx>(\n \n     // FIXME(Nadrieril): Hack to work around type normalization issues (see #72476).\n     let ty = matrix.heads().next().map_or(v.head().ty, |r| r.ty);\n-    let pcx = PatCtxt { cx, ty, span: v.head().span, is_top_level };\n+    let is_non_exhaustive = cx.is_foreign_non_exhaustive_enum(ty);\n+    let pcx = PatCtxt { cx, ty, span: v.head().span, is_top_level, is_non_exhaustive };\n \n     // If the first pattern is an or-pattern, expand it.\n     let ret = if is_or_pat(v.head()) {\n@@ -1148,6 +1200,7 @@ fn is_useful<'p, 'tcx>(\n         }\n         // We split the head constructor of `v`.\n         let split_ctors = v_ctor.split(pcx, matrix.head_ctors(cx));\n+        let is_non_exhaustive_and_wild = is_non_exhaustive && v_ctor.is_wildcard();\n         // For each constructor, we compute whether there's a value that starts with it that would\n         // witness the usefulness of `v`.\n         let start_matrix = &matrix;\n@@ -1160,10 +1213,46 @@ fn is_useful<'p, 'tcx>(\n             let v = v.pop_head_constructor(&ctor_wild_subpatterns);\n             let usefulness =\n                 is_useful(cx, &spec_matrix, &v, witness_preference, hir_id, is_under_guard, false);\n+\n+            // When all the conditions are met we have a match with a `non_exhaustive` enum\n+            // that has the potential to trigger the `non_exhaustive_omitted_patterns` lint.\n+            // To understand the workings checkout `Constructor::split` and `SplitWildcard::new/into_ctors`\n+            if is_non_exhaustive_and_wild\n+                // We check that the match has a wildcard pattern and that that wildcard is useful,\n+                // meaning there are variants that are covered by the wildcard. Without the check\n+                // for `witness_preference` the lint would trigger on `if let NonExhaustiveEnum::A = foo {}`\n+                && usefulness.is_useful() && matches!(witness_preference, RealArm)\n+                && matches!(\n+                    &ctor,\n+                    Constructor::Missing { nonexhaustive_enum_missing_real_variants: true }\n+                )\n+            {\n+                let patterns = {\n+                    let mut split_wildcard = SplitWildcard::new(pcx);\n+                    split_wildcard.split(pcx, matrix.head_ctors(pcx.cx));\n+                    // Construct for each missing constructor a \"wild\" version of this\n+                    // constructor, that matches everything that can be built with\n+                    // it. For example, if `ctor` is a `Constructor::Variant` for\n+                    // `Option::Some`, we get the pattern `Some(_)`.\n+                    split_wildcard\n+                        .iter_missing(pcx)\n+                        // Filter out the `Constructor::NonExhaustive` variant it's meaningless\n+                        // to our lint\n+                        .filter(|c| !c.is_non_exhaustive())\n+                        .map(|missing_ctor| {\n+                            Fields::wildcards(pcx, missing_ctor).apply(pcx, missing_ctor)\n+                        })\n+                        .collect::<Vec<_>>()\n+                };\n+\n+                lint_non_exhaustive_omitted_patterns(pcx.cx, pcx.ty, pcx.span, hir_id, patterns);\n+            }\n+\n             usefulness.apply_constructor(pcx, start_matrix, &ctor, &ctor_wild_subpatterns)\n         });\n         Usefulness::merge(witness_preference, usefulnesses)\n     };\n+\n     debug!(?ret);\n     ret\n }\n@@ -1214,8 +1303,7 @@ crate fn compute_match_usefulness<'p, 'tcx>(\n         .copied()\n         .map(|arm| {\n             let v = PatStack::from_pattern(arm.pat);\n-            let usefulness =\n-                is_useful(cx, &matrix, &v, LeaveOutWitness, arm.hir_id, arm.has_guard, true);\n+            let usefulness = is_useful(cx, &matrix, &v, RealArm, arm.hir_id, arm.has_guard, true);\n             if !arm.has_guard {\n                 matrix.push(v);\n             }\n@@ -1232,7 +1320,7 @@ crate fn compute_match_usefulness<'p, 'tcx>(\n \n     let wild_pattern = cx.pattern_arena.alloc(Pat::wildcard_from_ty(scrut_ty));\n     let v = PatStack::from_pattern(wild_pattern);\n-    let usefulness = is_useful(cx, &matrix, &v, ConstructWitness, scrut_hir_id, false, true);\n+    let usefulness = is_useful(cx, &matrix, &v, FakeExtraWildcard, scrut_hir_id, false, true);\n     let non_exhaustiveness_witnesses = match usefulness {\n         WithWitnesses(pats) => pats.into_iter().map(|w| w.single_pattern()).collect(),\n         NoWitnesses(_) => bug!(),"}, {"sha": "a056ab6aef2aec0398476a4b793e0cea99b40c19", "filename": "compiler/rustc_typeck/src/check/pat.rs", "status": "modified", "additions": 62, "deletions": 12, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/2b5ddf36fdc784106b3a064d93dd054c32b1f10f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b5ddf36fdc784106b3a064d93dd054c32b1f10f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fpat.rs?ref=2b5ddf36fdc784106b3a064d93dd054c32b1f10f", "patch": "@@ -11,6 +11,7 @@ use rustc_infer::infer;\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_middle::ty::subst::GenericArg;\n use rustc_middle::ty::{self, Adt, BindingMode, Ty, TypeFoldable};\n+use rustc_session::lint::builtin::NON_EXHAUSTIVE_OMITTED_PATTERNS;\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::source_map::{Span, Spanned};\n@@ -1261,7 +1262,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         // Require `..` if struct has non_exhaustive attribute.\n-        if variant.is_field_list_non_exhaustive() && !adt.did.is_local() && !etc {\n+        let non_exhaustive = variant.is_field_list_non_exhaustive() && !adt.did.is_local();\n+        if non_exhaustive && !etc {\n             self.error_foreign_non_exhaustive_spat(pat, adt.variant_descr(), fields.is_empty());\n         }\n \n@@ -1276,24 +1278,27 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if etc {\n                 tcx.sess.struct_span_err(pat.span, \"`..` cannot be used in union patterns\").emit();\n             }\n-        } else if !etc && !unmentioned_fields.is_empty() {\n+        } else if !unmentioned_fields.is_empty() {\n             let accessible_unmentioned_fields: Vec<_> = unmentioned_fields\n                 .iter()\n                 .copied()\n                 .filter(|(field, _)| {\n                     field.vis.is_accessible_from(tcx.parent_module(pat.hir_id).to_def_id(), tcx)\n                 })\n                 .collect();\n-\n-            if accessible_unmentioned_fields.is_empty() {\n-                unmentioned_err = Some(self.error_no_accessible_fields(pat, &fields));\n-            } else {\n-                unmentioned_err = Some(self.error_unmentioned_fields(\n-                    pat,\n-                    &accessible_unmentioned_fields,\n-                    accessible_unmentioned_fields.len() != unmentioned_fields.len(),\n-                    &fields,\n-                ));\n+            if non_exhaustive {\n+                self.non_exhaustive_reachable_pattern(pat, &accessible_unmentioned_fields, adt_ty)\n+            } else if !etc {\n+                if accessible_unmentioned_fields.is_empty() {\n+                    unmentioned_err = Some(self.error_no_accessible_fields(pat, &fields));\n+                } else {\n+                    unmentioned_err = Some(self.error_unmentioned_fields(\n+                        pat,\n+                        &accessible_unmentioned_fields,\n+                        accessible_unmentioned_fields.len() != unmentioned_fields.len(),\n+                        &fields,\n+                    ));\n+                }\n             }\n         }\n         match (inexistent_fields_err, unmentioned_err) {\n@@ -1604,6 +1609,51 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err\n     }\n \n+    /// Report that a pattern for a `#[non_exhaustive]` struct marked with `non_exhaustive_omitted_patterns`\n+    /// is not exhaustive enough.\n+    ///\n+    /// Nb: the partner lint for enums lives in `compiler/rustc_mir_build/src/thir/pattern/usefulness.rs`.\n+    fn non_exhaustive_reachable_pattern(\n+        &self,\n+        pat: &Pat<'_>,\n+        unmentioned_fields: &[(&ty::FieldDef, Ident)],\n+        ty: Ty<'tcx>,\n+    ) {\n+        fn joined_uncovered_patterns(witnesses: &[&Ident]) -> String {\n+            const LIMIT: usize = 3;\n+            match witnesses {\n+                [] => bug!(),\n+                [witness] => format!(\"`{}`\", witness),\n+                [head @ .., tail] if head.len() < LIMIT => {\n+                    let head: Vec<_> = head.iter().map(<_>::to_string).collect();\n+                    format!(\"`{}` and `{}`\", head.join(\"`, `\"), tail)\n+                }\n+                _ => {\n+                    let (head, tail) = witnesses.split_at(LIMIT);\n+                    let head: Vec<_> = head.iter().map(<_>::to_string).collect();\n+                    format!(\"`{}` and {} more\", head.join(\"`, `\"), tail.len())\n+                }\n+            }\n+        }\n+        let joined_patterns = joined_uncovered_patterns(\n+            &unmentioned_fields.iter().map(|(_, i)| i).collect::<Vec<_>>(),\n+        );\n+\n+        self.tcx.struct_span_lint_hir(NON_EXHAUSTIVE_OMITTED_PATTERNS, pat.hir_id, pat.span, |build| {\n+        let mut lint = build.build(\"some fields are not explicitly listed\");\n+        lint.span_label(pat.span, format!(\"field{} {} not listed\", rustc_errors::pluralize!(unmentioned_fields.len()), joined_patterns));\n+\n+        lint.help(\n+            \"ensure that all fields are mentioned explicitly by adding the suggested fields\",\n+        );\n+        lint.note(&format!(\n+            \"the pattern is of type `{}` and the `non_exhaustive_omitted_patterns` attribute was found\",\n+            ty,\n+        ));\n+        lint.emit();\n+    });\n+    }\n+\n     /// Returns a diagnostic reporting a struct pattern which does not mention some fields.\n     ///\n     /// ```text"}, {"sha": "0098f087d10f8dcf469d7d45683beb8683c871dd", "filename": "src/test/ui/rfc-2008-non-exhaustive/auxiliary/enums.rs", "status": "modified", "additions": 22, "deletions": 1, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2b5ddf36fdc784106b3a064d93dd054c32b1f10f/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fauxiliary%2Fenums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b5ddf36fdc784106b3a064d93dd054c32b1f10f/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fauxiliary%2Fenums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fauxiliary%2Fenums.rs?ref=2b5ddf36fdc784106b3a064d93dd054c32b1f10f", "patch": "@@ -4,8 +4,29 @@\n pub enum NonExhaustiveEnum {\n     Unit,\n     Tuple(u32),\n-    Struct { field: u32 }\n+    Struct { field: u32 },\n+}\n+\n+#[non_exhaustive]\n+pub enum NestedNonExhaustive {\n+    A(NonExhaustiveEnum),\n+    B,\n+    C,\n }\n \n #[non_exhaustive]\n pub enum EmptyNonExhaustiveEnum {}\n+\n+pub enum VariantNonExhaustive {\n+    #[non_exhaustive]\n+    Bar {\n+        x: u32,\n+        y: u64,\n+    },\n+    Baz(u32, u16),\n+}\n+\n+#[non_exhaustive]\n+pub enum NonExhaustiveSingleVariant {\n+    A(bool),\n+}"}, {"sha": "5b2181d2d833b120688d2390e3cc3452b634b94b", "filename": "src/test/ui/rfc-2008-non-exhaustive/auxiliary/structs.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2b5ddf36fdc784106b3a064d93dd054c32b1f10f/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fauxiliary%2Fstructs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b5ddf36fdc784106b3a064d93dd054c32b1f10f/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fauxiliary%2Fstructs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fauxiliary%2Fstructs.rs?ref=2b5ddf36fdc784106b3a064d93dd054c32b1f10f", "patch": "@@ -1,3 +1,4 @@\n+#[derive(Default)]\n #[non_exhaustive]\n pub struct NormalStruct {\n     pub first_field: u16,\n@@ -15,11 +16,18 @@ pub struct TupleStruct(pub u16, pub u16);\n pub struct FunctionalRecord {\n     pub first_field: u16,\n     pub second_field: u16,\n-    pub third_field: bool\n+    pub third_field: bool,\n }\n \n impl Default for FunctionalRecord {\n     fn default() -> FunctionalRecord {\n         FunctionalRecord { first_field: 640, second_field: 480, third_field: false }\n     }\n }\n+\n+#[derive(Default)]\n+#[non_exhaustive]\n+pub struct NestedStruct {\n+    pub foo: u16,\n+    pub bar: NormalStruct,\n+}"}, {"sha": "115fd300fa526cd31e469896b16f5473786f3627", "filename": "src/test/ui/rfc-2008-non-exhaustive/reachable-patterns.rs", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/2b5ddf36fdc784106b3a064d93dd054c32b1f10f/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Freachable-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b5ddf36fdc784106b3a064d93dd054c32b1f10f/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Freachable-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Freachable-patterns.rs?ref=2b5ddf36fdc784106b3a064d93dd054c32b1f10f", "patch": "@@ -0,0 +1,160 @@\n+// Test that the `non_exhaustive_omitted_patterns` lint is triggered correctly.\n+\n+// aux-build:enums.rs\n+extern crate enums;\n+\n+// aux-build:structs.rs\n+extern crate structs;\n+\n+use enums::{\n+    EmptyNonExhaustiveEnum, NestedNonExhaustive, NonExhaustiveEnum, NonExhaustiveSingleVariant,\n+    VariantNonExhaustive,\n+};\n+use structs::{FunctionalRecord, NestedStruct, NormalStruct};\n+\n+#[non_exhaustive]\n+#[derive(Default)]\n+pub struct Foo {\n+    a: u8,\n+    b: usize,\n+    c: String,\n+}\n+\n+#[non_exhaustive]\n+pub enum Bar {\n+    A,\n+    B,\n+    C,\n+}\n+\n+fn main() {\n+    let enumeration = Bar::A;\n+\n+    // Ok: this is a crate local non_exhaustive enum\n+    match enumeration {\n+        Bar::A => {}\n+        Bar::B => {}\n+        #[deny(non_exhaustive_omitted_patterns)]\n+        _ => {}\n+    }\n+\n+    let non_enum = NonExhaustiveEnum::Unit;\n+\n+    // Ok: without the attribute\n+    match non_enum {\n+        NonExhaustiveEnum::Unit => {}\n+        NonExhaustiveEnum::Tuple(_) => {}\n+        _ => {}\n+    }\n+\n+    match non_enum {\n+        NonExhaustiveEnum::Unit => {}\n+        NonExhaustiveEnum::Tuple(_) => {}\n+        #[deny(non_exhaustive_omitted_patterns)]\n+        _ => {}\n+    }\n+    //~^^ some variants are not matched explicitly\n+\n+    match non_enum {\n+        NonExhaustiveEnum::Unit | NonExhaustiveEnum::Struct { .. } => {}\n+        #[deny(non_exhaustive_omitted_patterns)]\n+        _ => {}\n+    }\n+    //~^^ some variants are not matched explicitly\n+\n+    let x = 5;\n+    match non_enum {\n+        NonExhaustiveEnum::Unit if x > 10 => {}\n+        NonExhaustiveEnum::Tuple(_) => {}\n+        NonExhaustiveEnum::Struct { .. } => {}\n+        #[deny(non_exhaustive_omitted_patterns)]\n+        _ => {}\n+    }\n+    //~^^ some variants are not matched explicitly\n+\n+    // Ok: all covered and not `unreachable-patterns`\n+    #[deny(unreachable_patterns)]\n+    match non_enum {\n+        NonExhaustiveEnum::Unit => {}\n+        NonExhaustiveEnum::Tuple(_) => {}\n+        NonExhaustiveEnum::Struct { .. } => {}\n+        #[deny(non_exhaustive_omitted_patterns)]\n+        _ => {}\n+    }\n+\n+    #[deny(non_exhaustive_omitted_patterns)]\n+    match NestedNonExhaustive::B {\n+        NestedNonExhaustive::A(NonExhaustiveEnum::Unit) => {}\n+        NestedNonExhaustive::A(_) => {}\n+        NestedNonExhaustive::B => {}\n+        _ => {}\n+    }\n+    //~^^ some variants are not matched explicitly\n+    //~^^^^^ some variants are not matched explicitly\n+\n+    // The io::ErrorKind has many `unstable` fields how do they interact with this\n+    // lint\n+    #[deny(non_exhaustive_omitted_patterns)]\n+    match std::io::ErrorKind::Other {\n+        std::io::ErrorKind::NotFound => {}\n+        std::io::ErrorKind::PermissionDenied => {}\n+        std::io::ErrorKind::ConnectionRefused => {}\n+        std::io::ErrorKind::ConnectionReset => {}\n+        std::io::ErrorKind::ConnectionAborted => {}\n+        std::io::ErrorKind::NotConnected => {}\n+        std::io::ErrorKind::AddrInUse => {}\n+        std::io::ErrorKind::AddrNotAvailable => {}\n+        std::io::ErrorKind::BrokenPipe => {}\n+        std::io::ErrorKind::AlreadyExists => {}\n+        std::io::ErrorKind::WouldBlock => {}\n+        std::io::ErrorKind::InvalidInput => {}\n+        std::io::ErrorKind::InvalidData => {}\n+        std::io::ErrorKind::TimedOut => {}\n+        std::io::ErrorKind::WriteZero => {}\n+        std::io::ErrorKind::Interrupted => {}\n+        std::io::ErrorKind::Other => {}\n+        std::io::ErrorKind::UnexpectedEof => {}\n+        std::io::ErrorKind::Unsupported => {}\n+        std::io::ErrorKind::OutOfMemory => {}\n+        // All stable variants are above and unstable in `_`\n+        _ => {}\n+    }\n+    //~^^ some variants are not matched explicitly\n+\n+    #[warn(non_exhaustive_omitted_patterns)]\n+    match VariantNonExhaustive::Baz(1, 2) {\n+        VariantNonExhaustive::Baz(_, _) => {}\n+        VariantNonExhaustive::Bar { x, .. } => {}\n+    }\n+    //~^^ some fields are not explicitly listed\n+\n+    #[warn(non_exhaustive_omitted_patterns)]\n+    let FunctionalRecord { first_field, second_field, .. } = FunctionalRecord::default();\n+    //~^ some fields are not explicitly listed\n+\n+    // Ok: this is local\n+    #[warn(non_exhaustive_omitted_patterns)]\n+    let Foo { a, b, .. } = Foo::default();\n+\n+    #[warn(non_exhaustive_omitted_patterns)]\n+    let NestedStruct { bar: NormalStruct { first_field, .. }, .. } = NestedStruct::default();\n+    //~^ some fields are not explicitly listed\n+    //~^^ some fields are not explicitly listed\n+\n+    // Ok: because this only has 1 variant\n+    #[deny(non_exhaustive_omitted_patterns)]\n+    match NonExhaustiveSingleVariant::A(true) {\n+        NonExhaustiveSingleVariant::A(true) => {}\n+        _ => {}\n+    }\n+\n+    #[deny(non_exhaustive_omitted_patterns)]\n+    match NonExhaustiveSingleVariant::A(true) {\n+        _ => {}\n+    }\n+    //~^^ some variants are not matched explicitly\n+\n+    // Ok: we don't lint on `if let` expressions\n+    #[deny(non_exhaustive_omitted_patterns)]\n+    if let NonExhaustiveEnum::Tuple(_) = non_enum {}\n+}"}, {"sha": "aebe2acb6ad8907c7201914dba0dd86b8a56ea02", "filename": "src/test/ui/rfc-2008-non-exhaustive/reachable-patterns.stderr", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/2b5ddf36fdc784106b3a064d93dd054c32b1f10f/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Freachable-patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b5ddf36fdc784106b3a064d93dd054c32b1f10f/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Freachable-patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Freachable-patterns.stderr?ref=2b5ddf36fdc784106b3a064d93dd054c32b1f10f", "patch": "@@ -0,0 +1,146 @@\n+warning: some fields are not explicitly listed\n+  --> $DIR/reachable-patterns.rs:127:9\n+   |\n+LL |         VariantNonExhaustive::Bar { x, .. } => {}\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ field `y` not listed\n+   |\n+note: the lint level is defined here\n+  --> $DIR/reachable-patterns.rs:124:12\n+   |\n+LL |     #[warn(non_exhaustive_omitted_patterns)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: ensure that all fields are mentioned explicitly by adding the suggested fields\n+   = note: the pattern is of type `VariantNonExhaustive` and the `non_exhaustive_omitted_patterns` attribute was found\n+\n+warning: some fields are not explicitly listed\n+  --> $DIR/reachable-patterns.rs:132:9\n+   |\n+LL |     let FunctionalRecord { first_field, second_field, .. } = FunctionalRecord::default();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ field `third_field` not listed\n+   |\n+note: the lint level is defined here\n+  --> $DIR/reachable-patterns.rs:131:12\n+   |\n+LL |     #[warn(non_exhaustive_omitted_patterns)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: ensure that all fields are mentioned explicitly by adding the suggested fields\n+   = note: the pattern is of type `FunctionalRecord` and the `non_exhaustive_omitted_patterns` attribute was found\n+\n+warning: some fields are not explicitly listed\n+  --> $DIR/reachable-patterns.rs:140:29\n+   |\n+LL |     let NestedStruct { bar: NormalStruct { first_field, .. }, .. } = NestedStruct::default();\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ field `second_field` not listed\n+   |\n+note: the lint level is defined here\n+  --> $DIR/reachable-patterns.rs:139:12\n+   |\n+LL |     #[warn(non_exhaustive_omitted_patterns)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: ensure that all fields are mentioned explicitly by adding the suggested fields\n+   = note: the pattern is of type `NormalStruct` and the `non_exhaustive_omitted_patterns` attribute was found\n+\n+warning: some fields are not explicitly listed\n+  --> $DIR/reachable-patterns.rs:140:9\n+   |\n+LL |     let NestedStruct { bar: NormalStruct { first_field, .. }, .. } = NestedStruct::default();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ field `foo` not listed\n+   |\n+   = help: ensure that all fields are mentioned explicitly by adding the suggested fields\n+   = note: the pattern is of type `NestedStruct` and the `non_exhaustive_omitted_patterns` attribute was found\n+\n+error: some variants are not matched explicitly\n+  --> $DIR/reachable-patterns.rs:54:9\n+   |\n+LL |         _ => {}\n+   |         ^ pattern `Struct { .. }` not covered\n+   |\n+note: the lint level is defined here\n+  --> $DIR/reachable-patterns.rs:53:16\n+   |\n+LL |         #[deny(non_exhaustive_omitted_patterns)]\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: ensure that all variants are matched explicitly by adding the suggested match arms\n+   = note: the matched value is of type `NonExhaustiveEnum` and the `non_exhaustive_omitted_patterns` attribute was found\n+\n+error: some variants are not matched explicitly\n+  --> $DIR/reachable-patterns.rs:61:9\n+   |\n+LL |         _ => {}\n+   |         ^ pattern `Tuple(_)` not covered\n+   |\n+note: the lint level is defined here\n+  --> $DIR/reachable-patterns.rs:60:16\n+   |\n+LL |         #[deny(non_exhaustive_omitted_patterns)]\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: ensure that all variants are matched explicitly by adding the suggested match arms\n+   = note: the matched value is of type `NonExhaustiveEnum` and the `non_exhaustive_omitted_patterns` attribute was found\n+\n+error: some variants are not matched explicitly\n+  --> $DIR/reachable-patterns.rs:71:9\n+   |\n+LL |         _ => {}\n+   |         ^ pattern `Unit` not covered\n+   |\n+note: the lint level is defined here\n+  --> $DIR/reachable-patterns.rs:70:16\n+   |\n+LL |         #[deny(non_exhaustive_omitted_patterns)]\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: ensure that all variants are matched explicitly by adding the suggested match arms\n+   = note: the matched value is of type `NonExhaustiveEnum` and the `non_exhaustive_omitted_patterns` attribute was found\n+\n+error: some variants are not matched explicitly\n+  --> $DIR/reachable-patterns.rs:88:32\n+   |\n+LL |         NestedNonExhaustive::A(_) => {}\n+   |                                ^ patterns `Tuple(_)` and `Struct { .. }` not covered\n+   |\n+note: the lint level is defined here\n+  --> $DIR/reachable-patterns.rs:85:12\n+   |\n+LL |     #[deny(non_exhaustive_omitted_patterns)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: ensure that all variants are matched explicitly by adding the suggested match arms\n+   = note: the matched value is of type `NonExhaustiveEnum` and the `non_exhaustive_omitted_patterns` attribute was found\n+\n+error: some variants are not matched explicitly\n+  --> $DIR/reachable-patterns.rs:90:9\n+   |\n+LL |         _ => {}\n+   |         ^ pattern `C` not covered\n+   |\n+   = help: ensure that all variants are matched explicitly by adding the suggested match arms\n+   = note: the matched value is of type `NestedNonExhaustive` and the `non_exhaustive_omitted_patterns` attribute was found\n+\n+error: some variants are not matched explicitly\n+  --> $DIR/reachable-patterns.rs:120:9\n+   |\n+LL |         _ => {}\n+   |         ^ patterns `HostUnreachable`, `NetworkUnreachable`, `NetworkDown` and 18 more not covered\n+   |\n+note: the lint level is defined here\n+  --> $DIR/reachable-patterns.rs:97:12\n+   |\n+LL |     #[deny(non_exhaustive_omitted_patterns)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: ensure that all variants are matched explicitly by adding the suggested match arms\n+   = note: the matched value is of type `ErrorKind` and the `non_exhaustive_omitted_patterns` attribute was found\n+\n+error: some variants are not matched explicitly\n+  --> $DIR/reachable-patterns.rs:153:9\n+   |\n+LL |         _ => {}\n+   |         ^ pattern `A(_)` not covered\n+   |\n+note: the lint level is defined here\n+  --> $DIR/reachable-patterns.rs:151:12\n+   |\n+LL |     #[deny(non_exhaustive_omitted_patterns)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = help: ensure that all variants are matched explicitly by adding the suggested match arms\n+   = note: the matched value is of type `NonExhaustiveSingleVariant` and the `non_exhaustive_omitted_patterns` attribute was found\n+\n+error: aborting due to 7 previous errors; 4 warnings emitted\n+"}, {"sha": "272b2ef6ee1d1c33e4ca036e16264c4805f795a5", "filename": "src/test/ui/rfc-2008-non-exhaustive/struct.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b5ddf36fdc784106b3a064d93dd054c32b1f10f/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2b5ddf36fdc784106b3a064d93dd054c32b1f10f/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2008-non-exhaustive%2Fstruct.stderr?ref=2b5ddf36fdc784106b3a064d93dd054c32b1f10f", "patch": "@@ -16,13 +16,13 @@ error[E0603]: tuple struct constructor `TupleStruct` is private\n LL |     let ts_explicit = structs::TupleStruct(640, 480);\n    |                                ^^^^^^^^^^^ private tuple struct constructor\n    |\n-  ::: $DIR/auxiliary/structs.rs:11:24\n+  ::: $DIR/auxiliary/structs.rs:12:24\n    |\n LL | pub struct TupleStruct(pub u16, pub u16);\n    |                        ---------------- a constructor is private if any of the fields is private\n    |\n note: the tuple struct constructor `TupleStruct` is defined here\n-  --> $DIR/auxiliary/structs.rs:11:1\n+  --> $DIR/auxiliary/structs.rs:12:1\n    |\n LL | pub struct TupleStruct(pub u16, pub u16);\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -34,7 +34,7 @@ LL |     let us_explicit = structs::UnitStruct;\n    |                                ^^^^^^^^^^ private unit struct\n    |\n note: the unit struct `UnitStruct` is defined here\n-  --> $DIR/auxiliary/structs.rs:8:1\n+  --> $DIR/auxiliary/structs.rs:9:1\n    |\n LL | pub struct UnitStruct;\n    | ^^^^^^^^^^^^^^^^^^^^^^"}]}