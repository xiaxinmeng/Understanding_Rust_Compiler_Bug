{"sha": "3dac31fe80b9d7279e87b94615b0d55805e83412", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkYWMzMWZlODBiOWQ3Mjc5ZTg3Yjk0NjE1YjBkNTU4MDVlODM0MTI=", "commit": {"author": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-07-24T10:53:48Z"}, "committer": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-07-24T11:34:00Z"}, "message": "SSR: Allow function calls to match method calls\n\nThis differs from how this used to work before I removed it in that:\na) It's only one direction. Function calls in the pattern can match\nmethod calls in the code, but not the other way around.\nb) We now check that the function call in the pattern resolves to the\nsame function as the method call in the code.\n\nThe lack of (b) was the reason I felt the need to remove the feature\nbefore.", "tree": {"sha": "d172c092d9ca93c182b2d88c30c3086a9ea797b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d172c092d9ca93c182b2d88c30c3086a9ea797b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3dac31fe80b9d7279e87b94615b0d55805e83412", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3dac31fe80b9d7279e87b94615b0d55805e83412", "html_url": "https://github.com/rust-lang/rust/commit/3dac31fe80b9d7279e87b94615b0d55805e83412", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3dac31fe80b9d7279e87b94615b0d55805e83412/comments", "author": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d09ab86edfc01405fd0045bef82e0642efd5f01", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d09ab86edfc01405fd0045bef82e0642efd5f01", "html_url": "https://github.com/rust-lang/rust/commit/8d09ab86edfc01405fd0045bef82e0642efd5f01"}], "stats": {"total": 194, "additions": 169, "deletions": 25}, "files": [{"sha": "95d8f79b870bef4dfed6f23c2b6baf81ce42e627", "filename": "crates/ra_ide/src/ssr.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3dac31fe80b9d7279e87b94615b0d55805e83412/crates%2Fra_ide%2Fsrc%2Fssr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dac31fe80b9d7279e87b94615b0d55805e83412/crates%2Fra_ide%2Fsrc%2Fssr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fssr.rs?ref=3dac31fe80b9d7279e87b94615b0d55805e83412", "patch": "@@ -21,6 +21,9 @@ use ra_ssr::{MatchFinder, SsrError, SsrRule};\n // replacement occurs. For example if our replacement template is `foo::Bar` and we match some\n // code in the `foo` module, we'll insert just `Bar`.\n //\n+// Method calls should generally be written in UFCS form. e.g. `foo::Bar::baz($s, $a)` will match\n+// `$s.baz($a)`, provided the method call `baz` resolves to the method `foo::Bar::baz`.\n+//\n // Placeholders may be given constraints by writing them as `${<name>:<constraint1>:<constraint2>...}`.\n //\n // Supported constraints:"}, {"sha": "2fb326b45f439a33cd0ec529b172fc424a809c32", "filename": "crates/ra_ssr/src/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3dac31fe80b9d7279e87b94615b0d55805e83412/crates%2Fra_ssr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dac31fe80b9d7279e87b94615b0d55805e83412/crates%2Fra_ssr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Flib.rs?ref=3dac31fe80b9d7279e87b94615b0d55805e83412", "patch": "@@ -202,8 +202,12 @@ impl<'db> MatchFinder<'db> {\n                     // For now we ignore rules that have a different kind than our node, otherwise\n                     // we get lots of noise. If at some point we add support for restricting rules\n                     // to a particular kind of thing (e.g. only match type references), then we can\n-                    // relax this.\n-                    if rule.pattern.node.kind() != node.kind() {\n+                    // relax this. We special-case expressions, since function calls can match\n+                    // method calls.\n+                    if rule.pattern.node.kind() != node.kind()\n+                        && !(ast::Expr::can_cast(rule.pattern.node.kind())\n+                            && ast::Expr::can_cast(node.kind()))\n+                    {\n                         continue;\n                     }\n                     out.push(MatchDebugInfo {"}, {"sha": "4862622bdec2256901bb4a2b50baf3d3ec4e1409", "filename": "crates/ra_ssr/src/matching.rs", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/3dac31fe80b9d7279e87b94615b0d55805e83412/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dac31fe80b9d7279e87b94615b0d55805e83412/crates%2Fra_ssr%2Fsrc%2Fmatching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fmatching.rs?ref=3dac31fe80b9d7279e87b94615b0d55805e83412", "patch": "@@ -189,10 +189,17 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n             }\n             return Ok(());\n         }\n-        // Non-placeholders.\n+        // We allow a UFCS call to match a method call, provided they resolve to the same function.\n+        if let Some(pattern_function) = self.rule.pattern.ufcs_function_calls.get(pattern) {\n+            if let (Some(pattern), Some(code)) =\n+                (ast::CallExpr::cast(pattern.clone()), ast::MethodCallExpr::cast(code.clone()))\n+            {\n+                return self.attempt_match_ufcs(phase, &pattern, &code, *pattern_function);\n+            }\n+        }\n         if pattern.kind() != code.kind() {\n             fail_match!(\n-                \"Pattern had a `{}` ({:?}), code had `{}` ({:?})\",\n+                \"Pattern had `{}` ({:?}), code had `{}` ({:?})\",\n                 pattern.text(),\n                 pattern.kind(),\n                 code.text(),\n@@ -514,6 +521,37 @@ impl<'db, 'sema> Matcher<'db, 'sema> {\n         Ok(())\n     }\n \n+    fn attempt_match_ufcs(\n+        &self,\n+        phase: &mut Phase,\n+        pattern: &ast::CallExpr,\n+        code: &ast::MethodCallExpr,\n+        pattern_function: hir::Function,\n+    ) -> Result<(), MatchFailed> {\n+        use ast::ArgListOwner;\n+        let code_resolved_function = self\n+            .sema\n+            .resolve_method_call(code)\n+            .ok_or_else(|| match_error!(\"Failed to resolve method call\"))?;\n+        if pattern_function != code_resolved_function {\n+            fail_match!(\"Method call resolved to a different function\");\n+        }\n+        // Check arguments.\n+        let mut pattern_args = pattern\n+            .arg_list()\n+            .ok_or_else(|| match_error!(\"Pattern function call has no args\"))?\n+            .args();\n+        self.attempt_match_opt(phase, pattern_args.next(), code.expr())?;\n+        let mut code_args =\n+            code.arg_list().ok_or_else(|| match_error!(\"Code method call has no args\"))?.args();\n+        loop {\n+            match (pattern_args.next(), code_args.next()) {\n+                (None, None) => return Ok(()),\n+                (p, c) => self.attempt_match_opt(phase, p, c)?,\n+            }\n+        }\n+    }\n+\n     fn get_placeholder(&self, element: &SyntaxElement) -> Option<&Placeholder> {\n         only_ident(element.clone()).and_then(|ident| self.rule.get_placeholder(&ident))\n     }"}, {"sha": "75f5567856f2d7473671e6544a2cff5de1205a9f", "filename": "crates/ra_ssr/src/resolving.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3dac31fe80b9d7279e87b94615b0d55805e83412/crates%2Fra_ssr%2Fsrc%2Fresolving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dac31fe80b9d7279e87b94615b0d55805e83412/crates%2Fra_ssr%2Fsrc%2Fresolving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fresolving.rs?ref=3dac31fe80b9d7279e87b94615b0d55805e83412", "patch": "@@ -18,10 +18,12 @@ pub(crate) struct ResolvedPattern {\n     pub(crate) node: SyntaxNode,\n     // Paths in `node` that we've resolved.\n     pub(crate) resolved_paths: FxHashMap<SyntaxNode, ResolvedPath>,\n+    pub(crate) ufcs_function_calls: FxHashMap<SyntaxNode, hir::Function>,\n }\n \n pub(crate) struct ResolvedPath {\n     pub(crate) resolution: hir::PathResolution,\n+    /// The depth of the ast::Path that was resolved within the pattern.\n     pub(crate) depth: u32,\n }\n \n@@ -64,10 +66,26 @@ impl Resolver<'_, '_> {\n     fn resolve_pattern_tree(&self, pattern: SyntaxNode) -> Result<ResolvedPattern, SsrError> {\n         let mut resolved_paths = FxHashMap::default();\n         self.resolve(pattern.clone(), 0, &mut resolved_paths)?;\n+        let ufcs_function_calls = resolved_paths\n+            .iter()\n+            .filter_map(|(path_node, resolved)| {\n+                if let Some(grandparent) = path_node.parent().and_then(|parent| parent.parent()) {\n+                    if grandparent.kind() == SyntaxKind::CALL_EXPR {\n+                        if let hir::PathResolution::AssocItem(hir::AssocItem::Function(function)) =\n+                            &resolved.resolution\n+                        {\n+                            return Some((grandparent, *function));\n+                        }\n+                    }\n+                }\n+                None\n+            })\n+            .collect();\n         Ok(ResolvedPattern {\n             node: pattern,\n             resolved_paths,\n             placeholders_by_stand_in: self.placeholders_by_stand_in.clone(),\n+            ufcs_function_calls,\n         })\n     }\n "}, {"sha": "bcf0f046895dc68e3de2122b4cc5e69a9a3312e0", "filename": "crates/ra_ssr/src/search.rs", "status": "modified", "additions": 44, "deletions": 21, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/3dac31fe80b9d7279e87b94615b0d55805e83412/crates%2Fra_ssr%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dac31fe80b9d7279e87b94615b0d55805e83412/crates%2Fra_ssr%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fsearch.rs?ref=3dac31fe80b9d7279e87b94615b0d55805e83412", "patch": "@@ -46,35 +46,58 @@ impl<'db> MatchFinder<'db> {\n         usage_cache: &mut UsageCache,\n         matches_out: &mut Vec<Match>,\n     ) {\n-        if let Some(first_path) = pick_path_for_usages(pattern) {\n-            let definition: Definition = first_path.resolution.clone().into();\n+        if let Some(resolved_path) = pick_path_for_usages(pattern) {\n+            let definition: Definition = resolved_path.resolution.clone().into();\n             for reference in self.find_usages(usage_cache, definition) {\n-                let file = self.sema.parse(reference.file_range.file_id);\n-                if let Some(path) = self.sema.find_node_at_offset_with_descend::<ast::Path>(\n-                    file.syntax(),\n-                    reference.file_range.range.start(),\n-                ) {\n-                    if let Some(node_to_match) = self\n-                        .sema\n-                        .ancestors_with_macros(path.syntax().clone())\n-                        .skip(first_path.depth as usize)\n-                        .next()\n+                if let Some(node_to_match) = self.find_node_to_match(resolved_path, reference) {\n+                    if !is_search_permitted_ancestors(&node_to_match) {\n+                        mark::hit!(use_declaration_with_braces);\n+                        continue;\n+                    }\n+                    if let Ok(m) =\n+                        matching::get_match(false, rule, &node_to_match, &None, &self.sema)\n                     {\n-                        if !is_search_permitted_ancestors(&node_to_match) {\n-                            mark::hit!(use_declaration_with_braces);\n-                            continue;\n-                        }\n-                        if let Ok(m) =\n-                            matching::get_match(false, rule, &node_to_match, &None, &self.sema)\n-                        {\n-                            matches_out.push(m);\n-                        }\n+                        matches_out.push(m);\n                     }\n                 }\n             }\n         }\n     }\n \n+    fn find_node_to_match(\n+        &self,\n+        resolved_path: &ResolvedPath,\n+        reference: &Reference,\n+    ) -> Option<SyntaxNode> {\n+        let file = self.sema.parse(reference.file_range.file_id);\n+        let depth = resolved_path.depth as usize;\n+        let offset = reference.file_range.range.start();\n+        if let Some(path) =\n+            self.sema.find_node_at_offset_with_descend::<ast::Path>(file.syntax(), offset)\n+        {\n+            self.sema.ancestors_with_macros(path.syntax().clone()).skip(depth).next()\n+        } else if let Some(path) =\n+            self.sema.find_node_at_offset_with_descend::<ast::MethodCallExpr>(file.syntax(), offset)\n+        {\n+            // If the pattern contained a path and we found a reference to that path that wasn't\n+            // itself a path, but was a method call, then we need to adjust how far up to try\n+            // matching by how deep the path was within a CallExpr. The structure would have been\n+            // CallExpr, PathExpr, Path - i.e. a depth offset of 2. We don't need to check if the\n+            // path was part of a CallExpr because if it wasn't then all that will happen is we'll\n+            // fail to match, which is the desired behavior.\n+            const PATH_DEPTH_IN_CALL_EXPR: usize = 2;\n+            if depth < PATH_DEPTH_IN_CALL_EXPR {\n+                return None;\n+            }\n+            self.sema\n+                .ancestors_with_macros(path.syntax().clone())\n+                .skip(depth - PATH_DEPTH_IN_CALL_EXPR)\n+                .next()\n+        } else {\n+            None\n+        }\n+    }\n+\n     fn find_usages<'a>(\n         &self,\n         usage_cache: &'a mut UsageCache,"}, {"sha": "b38807c0f9c20303eb1be38085c6c19ed15a2885", "filename": "crates/ra_ssr/src/tests.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/3dac31fe80b9d7279e87b94615b0d55805e83412/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dac31fe80b9d7279e87b94615b0d55805e83412/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Ftests.rs?ref=3dac31fe80b9d7279e87b94615b0d55805e83412", "patch": "@@ -827,3 +827,61 @@ fn use_declaration_with_braces() {\n         \"]],\n     )\n }\n+\n+#[test]\n+fn ufcs_matches_method_call() {\n+    let code = r#\"\n+    struct Foo {}\n+    impl Foo {\n+        fn new(_: i32) -> Foo { Foo {} }\n+        fn do_stuff(&self, _: i32) {}\n+    }\n+    struct Bar {}\n+    impl Bar {\n+        fn new(_: i32) -> Bar { Bar {} }\n+        fn do_stuff(&self, v: i32) {}\n+    }\n+    fn main() {\n+        let b = Bar {};\n+        let f = Foo {};\n+        b.do_stuff(1);\n+        f.do_stuff(2);\n+        Foo::new(4).do_stuff(3);\n+        // Too many / too few args - should never match\n+        f.do_stuff(2, 10);\n+        f.do_stuff();\n+    }\n+    \"#;\n+    assert_matches(\"Foo::do_stuff($a, $b)\", code, &[\"f.do_stuff(2)\", \"Foo::new(4).do_stuff(3)\"]);\n+    // The arguments needs special handling in the case of a function call matching a method call\n+    // and the first argument is different.\n+    assert_matches(\"Foo::do_stuff($a, 2)\", code, &[\"f.do_stuff(2)\"]);\n+    assert_matches(\"Foo::do_stuff(Foo::new(4), $b)\", code, &[\"Foo::new(4).do_stuff(3)\"]);\n+\n+    assert_ssr_transform(\n+        \"Foo::do_stuff(Foo::new($a), $b) ==>> Bar::new($b).do_stuff($a)\",\n+        code,\n+        expect![[r#\"\n+            struct Foo {}\n+            impl Foo {\n+                fn new(_: i32) -> Foo { Foo {} }\n+                fn do_stuff(&self, _: i32) {}\n+            }\n+            struct Bar {}\n+            impl Bar {\n+                fn new(_: i32) -> Bar { Bar {} }\n+                fn do_stuff(&self, v: i32) {}\n+            }\n+            fn main() {\n+                let b = Bar {};\n+                let f = Foo {};\n+                b.do_stuff(1);\n+                f.do_stuff(2);\n+                Bar::new(3).do_stuff(4);\n+                // Too many / too few args - should never match\n+                f.do_stuff(2, 10);\n+                f.do_stuff();\n+            }\n+        \"#]],\n+    );\n+}"}]}