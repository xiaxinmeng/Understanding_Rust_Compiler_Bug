{"sha": "0859cec65255e34221b3b443f4bdd751549fd4c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4NTljZWM2NTI1NWUzNDIyMWIzYjQ0M2Y0YmRkNzUxNTQ5ZmQ0YzM=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2021-03-23T21:25:52Z"}, "committer": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2021-03-24T00:02:10Z"}, "message": "Changes from review comments", "tree": {"sha": "0b6285ff269bb9e9b1f5315a208c5da42d737cfe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b6285ff269bb9e9b1f5315a208c5da42d737cfe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0859cec65255e34221b3b443f4bdd751549fd4c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0859cec65255e34221b3b443f4bdd751549fd4c3", "html_url": "https://github.com/rust-lang/rust/commit/0859cec65255e34221b3b443f4bdd751549fd4c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0859cec65255e34221b3b443f4bdd751549fd4c3/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "94a3454b0318e506e167f67aa52df1d054c6500b", "url": "https://api.github.com/repos/rust-lang/rust/commits/94a3454b0318e506e167f67aa52df1d054c6500b", "html_url": "https://github.com/rust-lang/rust/commit/94a3454b0318e506e167f67aa52df1d054c6500b"}], "stats": {"total": 59, "additions": 33, "deletions": 26}, "files": [{"sha": "32f4fc76b3d1f8c3efb643222cba48e421793710", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mod.rs", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0859cec65255e34221b3b443f4bdd751549fd4c3/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0859cec65255e34221b3b443f4bdd751549fd4c3/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs?ref=0859cec65255e34221b3b443f4bdd751549fd4c3", "patch": "@@ -73,10 +73,26 @@ impl CoverageInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n+    /// Functions with MIR-based coverage are normally codegenned _only_ if\n+    /// called. LLVM coverage tools typically expect every function to be\n+    /// defined (even if unused), with at least one call to LLVM intrinsic\n+    /// `instrprof.increment`.\n+    ///\n+    /// Codegen a small function that will never be called, with one counter\n+    /// that will never be incremented.\n+    ///\n+    /// For used/called functions, the coverageinfo was already added to the\n+    /// `function_coverage_map` (keyed by function `Instance`) during codegen.\n+    /// But in this case, since the unused function was _not_ previously\n+    /// codegenned, collect the coverage `CodeRegion`s from the MIR and add\n+    /// them. The first `CodeRegion` is used to add a single counter, with the\n+    /// same counter ID used in the injected `instrprof.increment` intrinsic\n+    /// call. Since the function is never called, all other `CodeRegion`s can be\n+    /// added as `unreachable_region`s.\n     fn define_unused_fn(&self, def_id: DefId) {\n         let instance = declare_unused_fn(self, &def_id);\n         codegen_unused_fn_and_counter(self, instance);\n-        add_function_coverage(self, instance, def_id);\n+        add_unused_function_coverage(self, instance, def_id);\n     }\n }\n \n@@ -200,7 +216,7 @@ fn declare_unused_fn(cx: &CodegenCx<'ll, 'tcx>, def_id: &DefId) -> Instance<'tcx\n     llvm::set_linkage(llfn, llvm::Linkage::WeakAnyLinkage);\n     llvm::set_visibility(llfn, llvm::Visibility::Hidden);\n \n-    cx.instances.borrow_mut().insert(instance, llfn);\n+    assert!(cx.instances.borrow_mut().insert(instance, llfn).is_none());\n \n     instance\n }\n@@ -221,7 +237,11 @@ fn codegen_unused_fn_and_counter(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'\n     bx.ret_void();\n }\n \n-fn add_function_coverage(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>, def_id: DefId) {\n+fn add_unused_function_coverage(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    instance: Instance<'tcx>,\n+    def_id: DefId,\n+) {\n     let tcx = cx.tcx;\n \n     let mut function_coverage = FunctionCoverage::unused(tcx, instance);"}, {"sha": "cbf570dba4c3ead260821e083c6881a431e7b0fc", "filename": "compiler/rustc_codegen_ssa/src/traits/coverageinfo.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0859cec65255e34221b3b443f4bdd751549fd4c3/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0859cec65255e34221b3b443f4bdd751549fd4c3/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fcoverageinfo.rs?ref=0859cec65255e34221b3b443f4bdd751549fd4c3", "patch": "@@ -6,22 +6,11 @@ use rustc_middle::ty::Instance;\n pub trait CoverageInfoMethods<'tcx>: BackendTypes {\n     fn coverageinfo_finalize(&self);\n \n-    /// Functions with MIR-based coverage are normally codegenned _only_ if\n-    /// called. LLVM coverage tools typically expect every function to be\n-    /// defined (even if unused), with at least one call to LLVM intrinsic\n-    /// `instrprof.increment`.\n-    ///\n     /// Codegen a small function that will never be called, with one counter\n-    /// that will never be incremented.\n-    ///\n-    /// For used/called functions, the coverageinfo was already added to the\n-    /// `function_coverage_map` (keyed by function `Instance`) during codegen.\n-    /// But in this case, since the unused function was _not_ previously\n-    /// codegenned, collect the coverage `CodeRegion`s from the MIR and add\n-    /// them. The first `CodeRegion` is used to add a single counter, with the\n-    /// same counter ID used in the injected `instrprof.increment` intrinsic\n-    /// call. Since the function is never called, all other `CodeRegion`s can be\n-    /// added as `unreachable_region`s.\n+    /// that will never be incremented, that gives LLVM coverage tools a\n+    /// function definition it needs in order to resolve coverage map references\n+    /// to unused functions. This is necessary so unused functions will appear\n+    /// as uncovered (coverage execution count `0`) in LLVM coverage reports.\n     fn define_unused_fn(&self, def_id: DefId);\n \n     /// For LLVM codegen, returns a function-specific `Value` for a global"}, {"sha": "fbcc6720780c2d50d5cbe8b5440f53b46f58039c", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0859cec65255e34221b3b443f4bdd751549fd4c3/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0859cec65255e34221b3b443f4bdd751549fd4c3/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=0859cec65255e34221b3b443f4bdd751549fd4c3", "patch": "@@ -2876,14 +2876,12 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n                     InlineAttr::None\n                 } else if list_contains_name(&items[..], sym::always) {\n                     if tcx.sess.instrument_coverage() {\n-                        // Forced inlining will discard functions marked with `#[inline(always)]`.\n-                        // If `-Z instrument-coverage` is enabled, the generated coverage map may\n-                        // hold references to functions that no longer exist, causing errors in\n-                        // coverage reports. (Note, this fixes #82875. I added some tests that\n-                        // also include `#[inline(always)]` functions, used and unused, and within\n-                        // and across crates, but could not reproduce the reported error in the\n-                        // `rustc` test suite. I am able to reproduce the error, following the steps\n-                        // described in #82875, and this change does fix that issue.)\n+                        // Fixes Issue #82875. Forced inlining allows LLVM to discard functions\n+                        // marked with `#[inline(always)]`, which can break coverage reporting if\n+                        // that function was referenced from a coverage map.\n+                        //\n+                        // FIXME(#83429): Is there a better place, e.g., in codegen, to check and\n+                        // convert `Always` to `Hint`?\n                         InlineAttr::Hint\n                     } else {\n                         InlineAttr::Always"}]}