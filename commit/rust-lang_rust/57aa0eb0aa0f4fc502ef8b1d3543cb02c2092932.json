{"sha": "57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3YWEwZWIwYWEwZjRmYzUwMmVmOGIxZDM1NDNjYjAyYzIwOTI5MzI=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-04-21T23:21:52Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-04-22T16:20:12Z"}, "message": "rustc: de-@ middle::ty.", "tree": {"sha": "a1eff06ec72c235670d58e1008ec878375752cfe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1eff06ec72c235670d58e1008ec878375752cfe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "html_url": "https://github.com/rust-lang/rust/commit/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5", "html_url": "https://github.com/rust-lang/rust/commit/1e5a112922fbac2a6f2d0aa9e6eb90bc3a4422a5"}], "stats": {"total": 875, "additions": 440, "deletions": 435}, "files": [{"sha": "4ebf4a52e41847fc4cb3bfbd2800a6fb40c02673", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -107,10 +107,10 @@ pub fn maybe_get_item_ast(tcx: &ty::ctxt, def: ast::DefId,\n }\n \n pub fn get_enum_variants(tcx: &ty::ctxt, def: ast::DefId)\n-                      -> Vec<@ty::VariantInfo> {\n+                      -> Vec<Rc<ty::VariantInfo>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n-    return decoder::get_enum_variants(cstore.intr.clone(), &*cdata, def.node, tcx)\n+    decoder::get_enum_variants(cstore.intr.clone(), &*cdata, def.node, tcx)\n }\n \n /// Returns information about the given implementation.\n@@ -147,13 +147,13 @@ pub fn get_item_variances(cstore: &cstore::CStore,\n \n pub fn get_provided_trait_methods(tcx: &ty::ctxt,\n                                   def: ast::DefId)\n-                               -> Vec<@ty::Method> {\n+                               -> Vec<Rc<ty::Method>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_provided_trait_methods(cstore.intr.clone(), &*cdata, def.node, tcx)\n }\n \n-pub fn get_supertraits(tcx: &ty::ctxt, def: ast::DefId) -> Vec<@ty::TraitRef> {\n+pub fn get_supertraits(tcx: &ty::ctxt, def: ast::DefId) -> Vec<Rc<ty::TraitRef>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_supertraits(&*cdata, def.node, tcx)\n@@ -224,7 +224,7 @@ pub fn get_field_type(tcx: &ty::ctxt, class_id: ast::DefId,\n // Given a def_id for an impl, return the trait it implements,\n // if there is one.\n pub fn get_impl_trait(tcx: &ty::ctxt,\n-                      def: ast::DefId) -> Option<@ty::TraitRef> {\n+                      def: ast::DefId) -> Option<Rc<ty::TraitRef>> {\n     let cstore = &tcx.sess.cstore;\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_impl_trait(&*cdata, def.node, tcx)"}, {"sha": "37d9d3417c9f5ef397a3d9044b685332252122ff", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -386,7 +386,7 @@ pub fn get_trait_def(cdata: Cmd,\n         generics: ty::Generics {type_param_defs: tp_defs,\n                                 region_param_defs: rp_defs},\n         bounds: bounds,\n-        trait_ref: @item_trait_ref(item_doc, tcx, cdata)\n+        trait_ref: Rc::new(item_trait_ref(item_doc, tcx, cdata))\n     }\n }\n \n@@ -410,11 +410,11 @@ pub fn get_type(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n \n pub fn get_impl_trait(cdata: Cmd,\n                       id: ast::NodeId,\n-                      tcx: &ty::ctxt) -> Option<@ty::TraitRef>\n+                      tcx: &ty::ctxt) -> Option<Rc<ty::TraitRef>>\n {\n     let item_doc = lookup_item(id, cdata.data());\n     reader::maybe_get_doc(item_doc, tag_item_trait_ref).map(|tp| {\n-        @doc_trait_ref(tp, tcx, cdata)\n+        Rc::new(doc_trait_ref(tp, tcx, cdata))\n     })\n }\n \n@@ -675,39 +675,38 @@ pub fn maybe_get_item_ast(cdata: Cmd, tcx: &ty::ctxt, id: ast::NodeId,\n }\n \n pub fn get_enum_variants(intr: Rc<IdentInterner>, cdata: Cmd, id: ast::NodeId,\n-                     tcx: &ty::ctxt) -> Vec<@ty::VariantInfo> {\n+                     tcx: &ty::ctxt) -> Vec<Rc<ty::VariantInfo>> {\n     let data = cdata.data();\n     let items = reader::get_doc(reader::Doc(data), tag_items);\n     let item = find_item(id, items);\n-    let mut infos: Vec<@ty::VariantInfo> = Vec::new();\n-    let variant_ids = enum_variant_ids(item, cdata);\n     let mut disr_val = 0;\n-    for did in variant_ids.iter() {\n+    enum_variant_ids(item, cdata).iter().map(|did| {\n         let item = find_item(did.node, items);\n         let ctor_ty = item_type(ast::DefId { krate: cdata.cnum, node: id},\n                                 item, tcx, cdata);\n         let name = item_name(&*intr, item);\n         let arg_tys = match ty::get(ctor_ty).sty {\n-          ty::ty_bare_fn(ref f) => f.sig.inputs.clone(),\n-          _ => Vec::new(), // Nullary enum variant.\n+            ty::ty_bare_fn(ref f) => f.sig.inputs.clone(),\n+            _ => Vec::new(), // Nullary enum variant.\n         };\n         match variant_disr_val(item) {\n-          Some(val) => { disr_val = val; }\n-          _         => { /* empty */ }\n+            Some(val) => { disr_val = val; }\n+            _         => { /* empty */ }\n         }\n-        infos.push(@ty::VariantInfo{\n+        let old_disr_val = disr_val;\n+        disr_val += 1;\n+        Rc::new(ty::VariantInfo {\n             args: arg_tys,\n             arg_names: None,\n             ctor_ty: ctor_ty,\n             name: name,\n             // I'm not even sure if we encode visibility\n             // for variants -- TEST -- tjc\n             id: *did,\n-            disr_val: disr_val,\n-            vis: ast::Inherited});\n-        disr_val += 1;\n-    }\n-    return infos;\n+            disr_val: old_disr_val,\n+            vis: ast::Inherited\n+        })\n+    }).collect()\n }\n \n fn get_explicit_self(item: ebml::Doc) -> ast::ExplicitSelf_ {\n@@ -816,8 +815,8 @@ pub fn get_item_variances(cdata: Cmd, id: ast::NodeId) -> ty::ItemVariances {\n }\n \n pub fn get_provided_trait_methods(intr: Rc<IdentInterner>, cdata: Cmd,\n-                                  id: ast::NodeId, tcx: &ty::ctxt) ->\n-        Vec<@ty::Method> {\n+                                  id: ast::NodeId, tcx: &ty::ctxt)\n+                                  -> Vec<Rc<ty::Method>> {\n     let data = cdata.data();\n     let item = lookup_item(id, data);\n     let mut result = Vec::new();\n@@ -827,7 +826,7 @@ pub fn get_provided_trait_methods(intr: Rc<IdentInterner>, cdata: Cmd,\n         let mth = lookup_item(did.node, data);\n \n         if item_method_sort(mth) == 'p' {\n-            result.push(@get_method(intr.clone(), cdata, did.node, tcx));\n+            result.push(Rc::new(get_method(intr.clone(), cdata, did.node, tcx)));\n         }\n         true\n     });\n@@ -837,7 +836,7 @@ pub fn get_provided_trait_methods(intr: Rc<IdentInterner>, cdata: Cmd,\n \n /// Returns the supertraits of the given trait.\n pub fn get_supertraits(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n-                    -> Vec<@ty::TraitRef> {\n+                    -> Vec<Rc<ty::TraitRef>> {\n     let mut results = Vec::new();\n     let item_doc = lookup_item(id, cdata.data());\n     reader::tagged_docs(item_doc, tag_item_super_trait_ref, |trait_doc| {\n@@ -846,7 +845,7 @@ pub fn get_supertraits(cdata: Cmd, id: ast::NodeId, tcx: &ty::ctxt)\n         // FIXME(#8559): The builtin bounds shouldn't be encoded in the first place.\n         let trait_ref = doc_trait_ref(trait_doc, tcx, cdata);\n         if tcx.lang_items.to_builtin_kind(trait_ref.def_id).is_none() {\n-            results.push(@trait_ref);\n+            results.push(Rc::new(trait_ref));\n         }\n         true\n     });"}, {"sha": "ab03e6476112790f229d9f80ac4c8209dbdeaf49", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -422,7 +422,7 @@ fn encode_reexported_static_trait_methods(ecx: &EncodeContext,\n                                           -> bool {\n     match ecx.tcx.trait_methods_cache.borrow().find(&exp.def_id) {\n         Some(methods) => {\n-            for &m in methods.iter() {\n+            for m in methods.iter() {\n                 if m.explicit_self == ast::SelfStatic {\n                     encode_reexported_static_method(ebml_w, exp, m.def_id, m.ident);\n                 }\n@@ -1057,7 +1057,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         for ast_trait_ref in opt_trait.iter() {\n             let trait_ref = ty::node_id_to_trait_ref(\n                 tcx, ast_trait_ref.ref_id);\n-            encode_trait_ref(ebml_w, ecx, trait_ref, tag_item_trait_ref);\n+            encode_trait_ref(ebml_w, ecx, &*trait_ref, tag_item_trait_ref);\n             let impl_vtables = ty::lookup_impl_vtables(tcx, def_id);\n             encode_impl_vtables(ebml_w, ecx, &impl_vtables);\n         }\n@@ -1078,10 +1078,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 val: method_def_id.node as i64,\n                 pos: ebml_w.writer.tell().unwrap(),\n             });\n-            let m = ty::method(tcx, method_def_id);\n             encode_info_for_method(ecx,\n                                    ebml_w,\n-                                   m,\n+                                   &*ty::method(tcx, method_def_id),\n                                    path.clone(),\n                                    false,\n                                    item.id,\n@@ -1099,7 +1098,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                                   trait_def.generics.type_param_defs(),\n                                   tag_items_data_item_ty_param_bounds);\n         encode_region_param_defs(ebml_w, trait_def.generics.region_param_defs());\n-        encode_trait_ref(ebml_w, ecx, trait_def.trait_ref, tag_item_trait_ref);\n+        encode_trait_ref(ebml_w, ecx, &*trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(ebml_w, item.ident.name);\n         encode_attributes(ebml_w, item.attrs.as_slice());\n         encode_visibility(ebml_w, vis);\n@@ -1118,7 +1117,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // the builtin-kinds-as-supertraits. See corresponding fixme in decoder.\n         for ast_trait_ref in super_traits.iter() {\n             let trait_ref = ty::node_id_to_trait_ref(ecx.tcx, ast_trait_ref.ref_id);\n-            encode_trait_ref(ebml_w, ecx, trait_ref, tag_item_super_trait_ref);\n+            encode_trait_ref(ebml_w, ecx, &*trait_ref, tag_item_super_trait_ref);\n         }\n \n         // Encode the implementations of this trait.\n@@ -1140,7 +1139,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n             ebml_w.start_tag(tag_items_data_item);\n \n-            encode_method_ty_fields(ecx, ebml_w, method_ty);\n+            encode_method_ty_fields(ecx, ebml_w, &*method_ty);\n \n             encode_parent_item(ebml_w, def_id);\n "}, {"sha": "3ba8dd3b30f00f7e3518e2fe1395f80fa3bd52d2", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -592,7 +592,7 @@ fn parse_bounds(st: &mut PState, conv: conv_did) -> ty::ParamBounds {\n                 param_bounds.builtin_bounds.add(ty::BoundShare);\n             }\n             'I' => {\n-                param_bounds.trait_bounds.push(@parse_trait_ref(st, |x,y| conv(x,y)));\n+                param_bounds.trait_bounds.push(Rc::new(parse_trait_ref(st, |x,y| conv(x,y))));\n             }\n             '.' => {\n                 return param_bounds;"}, {"sha": "13d24e7a1d057f7877738d6838e8f34b0b563f38", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -366,9 +366,9 @@ fn enc_bounds(w: &mut MemWriter, cx: &ctxt, bs: &ty::ParamBounds) {\n         }\n     }\n \n-    for &tp in bs.trait_bounds.iter() {\n+    for tp in bs.trait_bounds.iter() {\n         mywrite!(w, \"I\");\n-        enc_trait_ref(w, cx, tp);\n+        enc_trait_ref(w, cx, &**tp);\n     }\n \n     mywrite!(w, \".\");"}, {"sha": "e6c885e56f176e47fc084fffb223df16309912af", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -112,9 +112,9 @@ fn check_impl_of_trait(cx: &mut Context, it: &Item, trait_ref: &TraitRef, self_t\n                               .find(&trait_ref.ref_id)\n                               .expect(\"trait ref not in def map!\");\n     let trait_def_id = ast_util::def_id_of_def(ast_trait_def);\n-    let trait_def = *cx.tcx.trait_defs.borrow()\n-                           .find(&trait_def_id)\n-                           .expect(\"trait def not in trait-defs map!\");\n+    let trait_def = cx.tcx.trait_defs.borrow()\n+                          .find_copy(&trait_def_id)\n+                          .expect(\"trait def not in trait-defs map!\");\n \n     // If this trait has builtin-kind supertraits, meet them.\n     let self_ty: ty::t = ty::node_id_to_type(cx.tcx, it.id);"}, {"sha": "d1cc7d7bc401b60d1519f879f73f9d4ef7aa1812", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -53,6 +53,7 @@ use std::i16;\n use std::i32;\n use std::i64;\n use std::i8;\n+use std::rc::Rc;\n use std::to_str::ToStr;\n use std::u16;\n use std::u32;\n@@ -678,7 +679,7 @@ impl<'a> AstConv for Context<'a>{\n         ty::lookup_item_type(self.tcx, id)\n     }\n \n-    fn get_trait_def(&self, id: ast::DefId) -> @ty::TraitDef {\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n         ty::lookup_trait_def(self.tcx, id)\n     }\n \n@@ -1465,7 +1466,7 @@ fn check_missing_doc_method(cx: &Context, m: &ast::Method) {\n         node: m.id\n     };\n \n-    match cx.tcx.methods.borrow().find(&did).map(|method| *method) {\n+    match cx.tcx.methods.borrow().find_copy(&did) {\n         None => cx.tcx.sess.span_bug(m.span, \"missing method descriptor?!\"),\n         Some(md) => {\n             match md.container {"}, {"sha": "427a7f406b01558862ad62e3f3312f144759349f", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -254,7 +254,7 @@ impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n                     _ => true,\n                 };\n                 let tr = ty::impl_trait_ref(self.tcx, local_def(item.id));\n-                let public_trait = tr.map_or(false, |tr| {\n+                let public_trait = tr.clone().map_or(false, |tr| {\n                     !is_local(tr.def_id) ||\n                      self.exported_items.contains(&tr.def_id.node)\n                 });"}, {"sha": "aba03e7c79d157f7c8662b8e0bfbcc738d6ca6a7", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -75,6 +75,7 @@ use libc::c_uint;\n use std::c_str::ToCStr;\n use std::cell::{Cell, RefCell};\n use std::local_data;\n+use std::rc::Rc;\n use syntax::abi::{X86, X86_64, Arm, Mips, Rust, RustIntrinsic};\n use syntax::ast_util::{local_def, is_local};\n use syntax::attr::AttrMetaMethods;\n@@ -637,7 +638,7 @@ pub fn iter_structural_ty<'r,\n                     cx: &'b Block<'b>,\n                     repr: &adt::Repr,\n                     av: ValueRef,\n-                    variant: @ty::VariantInfo,\n+                    variant: &ty::VariantInfo,\n                     tps: &[ty::t],\n                     f: val_and_ty_fn<'r,'b>)\n                     -> &'b Block<'b> {\n@@ -694,7 +695,7 @@ pub fn iter_structural_ty<'r,\n \n           match adt::trans_switch(cx, repr, av) {\n               (_match::single, None) => {\n-                  cx = iter_variant(cx, repr, av, *variants.get(0),\n+                  cx = iter_variant(cx, repr, av, &**variants.get(0),\n                                     substs.tps.as_slice(), f);\n               }\n               (_match::switch, Some(lldiscrim_a)) => {\n@@ -720,7 +721,7 @@ pub fn iter_structural_ty<'r,\n                           iter_variant(variant_cx,\n                                        repr,\n                                        av,\n-                                       *variant,\n+                                       &**variant,\n                                        substs.tps.as_slice(),\n                                        |x,y,z| f(x,y,z));\n                       Br(variant_cx, next_cx.llbb);\n@@ -1525,11 +1526,11 @@ fn trans_enum_variant_or_tuple_like_struct(ccx: &CrateContext,\n     finish_fn(&fcx, bcx);\n }\n \n-pub fn trans_enum_def(ccx: &CrateContext, enum_definition: &ast::EnumDef,\n-                      id: ast::NodeId, vi: @Vec<@ty::VariantInfo>,\n-                      i: &mut uint) {\n+fn trans_enum_def(ccx: &CrateContext, enum_definition: &ast::EnumDef,\n+                  id: ast::NodeId, vi: &[Rc<ty::VariantInfo>],\n+                  i: &mut uint) {\n     for &variant in enum_definition.variants.iter() {\n-        let disr_val = vi.get(*i).disr_val;\n+        let disr_val = vi[*i].disr_val;\n         *i += 1;\n \n         match variant.node.kind {\n@@ -1592,7 +1593,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n         if !generics.is_type_parameterized() {\n             let vi = ty::enum_variants(ccx.tcx(), local_def(item.id));\n             let mut i = 0;\n-            trans_enum_def(ccx, enum_definition, item.id, vi, &mut i);\n+            trans_enum_def(ccx, enum_definition, item.id, vi.as_slice(), &mut i);\n         }\n       }\n       ast::ItemStatic(_, m, expr) => {"}, {"sha": "642ae86a97989f718d5e3e6e7ccf1e6d6dbb6993", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -318,7 +318,7 @@ pub fn trans_fn_ref_with_vtables(\n \n             // Compute the first substitution\n             let first_subst = make_substs_for_receiver_types(\n-                tcx, impl_id, trait_ref, method);\n+                tcx, impl_id, &*trait_ref, &*method);\n \n             // And compose them\n             let new_substs = first_subst.subst(tcx, &substs);\n@@ -333,7 +333,7 @@ pub fn trans_fn_ref_with_vtables(\n \n             let (param_vtables, self_vtables) =\n                 resolve_default_method_vtables(bcx, impl_id,\n-                                               method, &substs, vtables);\n+                                               &*method, &substs, vtables);\n \n             debug!(\"trans_fn_with_vtables - default method: \\\n                     self_vtable = {}, param_vtables = {}\","}, {"sha": "d01157e53a8d08f5909b1ea9cc7cf32e7e5802d0", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -144,6 +144,7 @@ use util::ppaux;\n \n use std::c_str::{CString, ToCStr};\n use std::cell::{Cell, RefCell};\n+use std::rc::Rc;\n use collections::HashMap;\n use collections::HashSet;\n use libc::{c_uint, c_ulonglong, c_longlong};\n@@ -1389,7 +1390,7 @@ fn prepare_tuple_metadata(cx: &CrateContext,\n \n struct GeneralMemberDescriptionFactory {\n     type_rep: @adt::Repr,\n-    variants: @Vec<@ty::VariantInfo> ,\n+    variants: Rc<Vec<Rc<ty::VariantInfo>>>,\n     discriminant_type_metadata: ValueRef,\n     containing_scope: DIScope,\n     file_metadata: DIFile,\n@@ -1412,7 +1413,7 @@ impl GeneralMemberDescriptionFactory {\n                 let (variant_type_metadata, variant_llvm_type, member_desc_factory) =\n                     describe_enum_variant(cx,\n                                           struct_def,\n-                                          *self.variants.get(i),\n+                                          &**self.variants.get(i),\n                                           Some(self.discriminant_type_metadata),\n                                           self.containing_scope,\n                                           self.file_metadata,\n@@ -1617,7 +1618,7 @@ fn prepare_enum_metadata(cx: &CrateContext,\n                  member_description_factory) =\n                     describe_enum_variant(cx,\n                                           struct_def,\n-                                          *variants.get(0),\n+                                          &**variants.get(0),\n                                           None,\n                                           containing_scope,\n                                           file_metadata,\n@@ -1676,7 +1677,7 @@ fn prepare_enum_metadata(cx: &CrateContext,\n                  member_description_factory) =\n                     describe_enum_variant(cx,\n                                           struct_def,\n-                                          *variants.get(nndiscr as uint),\n+                                          &**variants.get(nndiscr as uint),\n                                           None,\n                                           containing_scope,\n                                           file_metadata,"}, {"sha": "aa6e2dafd835ee9373d29c51b11f6baea8d797fb", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -243,7 +243,7 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n         ast_map::NodeVariant(v) => {\n             let parent = ccx.tcx.map.get_parent(fn_id.node);\n             let tvs = ty::enum_variants(ccx.tcx(), local_def(parent));\n-            let this_tv = *tvs.iter().find(|tv| { tv.id.node == fn_id.node}).unwrap();\n+            let this_tv = tvs.iter().find(|tv| { tv.id.node == fn_id.node}).unwrap();\n             let d = mk_lldecl();\n             set_inline_hint(d);\n             match v.node.kind {"}, {"sha": "d6bd84d18f097d8b9b05724465fd9276379f83e6", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -25,6 +25,7 @@ use middle::trans::type_of::*;\n use middle::ty;\n use util::ppaux::ty_to_str;\n \n+use std::rc::Rc;\n use arena::TypedArena;\n use libc::c_uint;\n use syntax::ast::DefId;\n@@ -33,15 +34,15 @@ use syntax::ast_map;\n use syntax::parse::token::{InternedString, special_idents};\n use syntax::parse::token;\n \n-pub struct Reflector<'a> {\n+pub struct Reflector<'a, 'b> {\n     visitor_val: ValueRef,\n-    visitor_methods: @Vec<@ty::Method> ,\n-    final_bcx: &'a Block<'a>,\n+    visitor_methods: &'a [Rc<ty::Method>],\n+    final_bcx: &'b Block<'b>,\n     tydesc_ty: Type,\n-    bcx: &'a Block<'a>\n+    bcx: &'b Block<'b>\n }\n \n-impl<'a> Reflector<'a> {\n+impl<'a, 'b> Reflector<'a, 'b> {\n     pub fn c_uint(&mut self, u: uint) -> ValueRef {\n         C_uint(self.bcx.ccx(), u)\n     }\n@@ -92,7 +93,7 @@ impl<'a> Reflector<'a> {\n                 format!(\"couldn't find visit method for {}\", ty_name));\n         let mth_ty =\n             ty::mk_bare_fn(tcx,\n-                           self.visitor_methods.get(mth_idx).fty.clone());\n+                           self.visitor_methods[mth_idx].fty.clone());\n         let v = self.visitor_val;\n         debug!(\"passing {} args:\", args.len());\n         let mut bcx = self.bcx;\n@@ -401,9 +402,10 @@ pub fn emit_calls_to_trait_visit_ty<'a>(\n     let final = fcx.new_temp_block(\"final\");\n     let tydesc_ty = ty::get_tydesc_ty(bcx.tcx()).unwrap();\n     let tydesc_ty = type_of(bcx.ccx(), tydesc_ty);\n+    let visitor_methods = ty::trait_methods(bcx.tcx(), visitor_trait_id);\n     let mut r = Reflector {\n         visitor_val: visitor_val,\n-        visitor_methods: ty::trait_methods(bcx.tcx(), visitor_trait_id),\n+        visitor_methods: visitor_methods.as_slice(),\n         final_bcx: final,\n         tydesc_ty: tydesc_ty,\n         bcx: bcx"}, {"sha": "59563013911c235cf02d274524f5b5ac614daf16", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 133, "deletions": 158, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -38,9 +38,11 @@ use std::cmp;\n use std::fmt::Show;\n use std::fmt;\n use std::hash::{Hash, sip};\n+use std::iter::AdditiveIterator;\n use std::ops;\n use std::rc::Rc;\n use collections::{HashMap, HashSet};\n+use syntax::abi;\n use syntax::ast::*;\n use syntax::ast_util::{is_local, lit_is_str};\n use syntax::ast_util;\n@@ -51,7 +53,7 @@ use syntax::parse::token;\n use syntax::parse::token::InternedString;\n use syntax::{ast, ast_map};\n use syntax::owned_slice::OwnedSlice;\n-use syntax::abi;\n+use syntax::util::small_vector::SmallVector;\n use collections::enum_set::{EnumSet, CLike};\n \n pub type Disr = u64;\n@@ -267,18 +269,18 @@ pub struct ctxt {\n     pub node_type_substs: RefCell<NodeMap<Vec<t>>>,\n \n     // Maps from a method to the method \"descriptor\"\n-    pub methods: RefCell<DefIdMap<@Method>>,\n+    pub methods: RefCell<DefIdMap<Rc<Method>>>,\n \n     // Maps from a trait def-id to a list of the def-ids of its methods\n-    pub trait_method_def_ids: RefCell<DefIdMap<@Vec<DefId> >>,\n+    pub trait_method_def_ids: RefCell<DefIdMap<Rc<Vec<DefId>>>>,\n \n     // A cache for the trait_methods() routine\n-    pub trait_methods_cache: RefCell<DefIdMap<@Vec<@Method> >>,\n+    pub trait_methods_cache: RefCell<DefIdMap<Rc<Vec<Rc<Method>>>>>,\n \n-    pub impl_trait_cache: RefCell<DefIdMap<Option<@ty::TraitRef>>>,\n+    pub impl_trait_cache: RefCell<DefIdMap<Option<Rc<ty::TraitRef>>>>,\n \n-    pub trait_refs: RefCell<NodeMap<@TraitRef>>,\n-    pub trait_defs: RefCell<DefIdMap<@TraitDef>>,\n+    pub trait_refs: RefCell<NodeMap<Rc<TraitRef>>>,\n+    pub trait_defs: RefCell<DefIdMap<Rc<TraitDef>>>,\n \n     pub map: ast_map::Map,\n     pub intrinsic_defs: RefCell<DefIdMap<t>>,\n@@ -289,20 +291,20 @@ pub struct ctxt {\n     pub needs_unwind_cleanup_cache: RefCell<HashMap<t, bool>>,\n     pub tc_cache: RefCell<HashMap<uint, TypeContents>>,\n     pub ast_ty_to_ty_cache: RefCell<NodeMap<ast_ty_to_ty_cache_entry>>,\n-    pub enum_var_cache: RefCell<DefIdMap<@Vec<@VariantInfo> >>,\n+    pub enum_var_cache: RefCell<DefIdMap<Rc<Vec<Rc<VariantInfo>>>>>,\n     pub ty_param_defs: RefCell<NodeMap<TypeParameterDef>>,\n     pub adjustments: RefCell<NodeMap<AutoAdjustment>>,\n     pub normalized_cache: RefCell<HashMap<t, t>>,\n     pub lang_items: middle::lang_items::LanguageItems,\n     // A mapping of fake provided method def_ids to the default implementation\n     pub provided_method_sources: RefCell<DefIdMap<ast::DefId>>,\n-    pub supertraits: RefCell<DefIdMap<@Vec<@TraitRef> >>,\n+    pub supertraits: RefCell<DefIdMap<Rc<Vec<Rc<TraitRef>>>>>,\n     pub superstructs: RefCell<DefIdMap<Option<ast::DefId>>>,\n-    pub struct_fields: RefCell<DefIdMap<@Vec<field_ty>>>,\n+    pub struct_fields: RefCell<DefIdMap<Rc<Vec<field_ty>>>>,\n \n     // Maps from def-id of a type or region parameter to its\n     // (inferred) variance.\n-    pub item_variance_map: RefCell<DefIdMap<@ItemVariances>>,\n+    pub item_variance_map: RefCell<DefIdMap<Rc<ItemVariances>>>,\n \n     // A mapping from the def ID of an enum or struct type to the def ID\n     // of the method that implements its destructor. If the type is not\n@@ -314,12 +316,12 @@ pub struct ctxt {\n     pub destructors: RefCell<DefIdSet>,\n \n     // Maps a trait onto a list of impls of that trait.\n-    pub trait_impls: RefCell<DefIdMap<@RefCell<Vec<ast::DefId>>>>,\n+    pub trait_impls: RefCell<DefIdMap<Rc<RefCell<Vec<ast::DefId>>>>>,\n \n     // Maps a DefId of a type to a list of its inherent impls.\n     // Contains implementations of methods that are inherent to a type.\n     // Methods in these implementations don't need to be exported.\n-    pub inherent_impls: RefCell<DefIdMap<@RefCell<Vec<ast::DefId>>>>,\n+    pub inherent_impls: RefCell<DefIdMap<Rc<RefCell<Vec<ast::DefId>>>>>,\n \n     // Maps a DefId of an impl to a list of its methods.\n     // Note that this contains all of the impls that we know about,\n@@ -826,7 +828,7 @@ pub enum type_err {\n #[deriving(Eq, TotalEq, Hash)]\n pub struct ParamBounds {\n     pub builtin_bounds: BuiltinBounds,\n-    pub trait_bounds: Vec<@TraitRef>\n+    pub trait_bounds: Vec<Rc<TraitRef>>\n }\n \n pub type BuiltinBounds = EnumSet<BuiltinBound>;\n@@ -1036,7 +1038,7 @@ pub struct ParameterEnvironment {\n     pub free_substs: ty::substs,\n \n     /// Bound on the Self parameter\n-    pub self_param_bound: Option<@TraitRef>,\n+    pub self_param_bound: Option<Rc<TraitRef>>,\n \n     /// Bounds on each numbered type parameter\n     pub type_param_bounds: Vec<ParamBounds> ,\n@@ -1062,7 +1064,7 @@ pub struct ty_param_bounds_and_ty {\n pub struct TraitDef {\n     pub generics: Generics,\n     pub bounds: BuiltinBounds,\n-    pub trait_ref: @ty::TraitRef,\n+    pub trait_ref: Rc<ty::TraitRef>,\n }\n \n pub struct ty_param_substs_and_ty {\n@@ -2174,7 +2176,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n                 // Self may be bounded if the associated trait has builtin kinds\n                 // for supertraits. If so we can use those bounds.\n                 let trait_def = lookup_trait_def(cx, def_id);\n-                let traits = [trait_def.trait_ref];\n+                let traits = [trait_def.trait_ref.clone()];\n                 kind_bounds_to_contents(cx, trait_def.bounds, traits)\n             }\n \n@@ -2269,7 +2271,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n \n     fn kind_bounds_to_contents(cx: &ctxt,\n                                bounds: BuiltinBounds,\n-                               traits: &[@TraitRef])\n+                               traits: &[Rc<TraitRef>])\n                                -> TypeContents {\n         let _i = indenter();\n         let mut tc = TC::All;\n@@ -2288,7 +2290,7 @@ pub fn type_contents(cx: &ctxt, ty: t) -> TypeContents {\n         // those inherited from traits with builtin-kind-supertraits.\n         fn each_inherited_builtin_bound(cx: &ctxt,\n                                         bounds: BuiltinBounds,\n-                                        traits: &[@TraitRef],\n+                                        traits: &[Rc<TraitRef>],\n                                         f: |BuiltinBound|) {\n             for bound in bounds.iter() {\n                 f(bound);\n@@ -2654,12 +2656,12 @@ pub fn index(t: t) -> Option<mt> {\n     }\n }\n \n-pub fn node_id_to_trait_ref(cx: &ctxt, id: ast::NodeId) -> @ty::TraitRef {\n+pub fn node_id_to_trait_ref(cx: &ctxt, id: ast::NodeId) -> Rc<ty::TraitRef> {\n     match cx.trait_refs.borrow().find(&id) {\n-       Some(&t) => t,\n-       None => cx.sess.bug(\n-           format!(\"node_id_to_trait_ref: no trait ref for node `{}`\",\n-               cx.map.node_to_str(id)))\n+        Some(t) => t.clone(),\n+        None => cx.sess.bug(\n+            format!(\"node_id_to_trait_ref: no trait ref for node `{}`\",\n+                cx.map.node_to_str(id)))\n     }\n }\n \n@@ -3045,8 +3047,8 @@ pub fn method_call_type_param_defs(tcx: &ctxt, origin: typeck::MethodOrigin)\n             // method bounds, so we must preprend the tps from the\n             // trait itself.  This ought to be harmonized.\n             let trait_type_param_defs =\n-                lookup_trait_def(tcx, trt_id).generics.type_param_defs();\n-            Rc::new(Vec::from_slice(trait_type_param_defs).append(\n+                Vec::from_slice(lookup_trait_def(tcx, trt_id).generics.type_param_defs());\n+            Rc::new(trait_type_param_defs.append(\n                         ty::trait_method(tcx, trt_id, n_mth).generics.type_param_defs()))\n         }\n     }\n@@ -3255,7 +3257,7 @@ pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n         fields.iter().map(|f| token::get_ident(f.ident).get().to_str()).collect::<Vec<~str>>()));\n }\n \n-pub fn method_idx(id: ast::Ident, meths: &[@Method]) -> Option<uint> {\n+pub fn method_idx(id: ast::Ident, meths: &[Rc<Method>]) -> Option<uint> {\n     meths.iter().position(|m| m.ident == id)\n }\n \n@@ -3479,42 +3481,29 @@ pub fn provided_source(cx: &ctxt, id: ast::DefId) -> Option<ast::DefId> {\n     cx.provided_method_sources.borrow().find(&id).map(|x| *x)\n }\n \n-pub fn provided_trait_methods(cx: &ctxt, id: ast::DefId) -> Vec<@Method> {\n+pub fn provided_trait_methods(cx: &ctxt, id: ast::DefId) -> Vec<Rc<Method>> {\n     if is_local(id) {\n-        {\n-            match cx.map.find(id.node) {\n-                Some(ast_map::NodeItem(item)) => {\n-                    match item.node {\n-                        ItemTrait(_, _, ref ms) => {\n-                            let (_, p) =\n-                                ast_util::split_trait_methods(ms.as_slice());\n-                            p.iter()\n-                             .map(|m| method(cx, ast_util::local_def(m.id)))\n-                             .collect()\n-                        }\n-                        _ => {\n-                            cx.sess.bug(format!(\"provided_trait_methods: \\\n-                                                 `{:?}` is not a trait\",\n-                                                id))\n-                        }\n+        match cx.map.find(id.node) {\n+            Some(ast_map::NodeItem(item)) => {\n+                match item.node {\n+                    ItemTrait(_, _, ref ms) => {\n+                        let (_, p) = ast_util::split_trait_methods(ms.as_slice());\n+                        p.iter().map(|m| method(cx, ast_util::local_def(m.id))).collect()\n                     }\n-                }\n-                _ => {\n-                    cx.sess.bug(format!(\"provided_trait_methods: `{:?}` is not \\\n-                                         a trait\",\n-                                        id))\n+                    _ => cx.sess.bug(format!(\"provided_trait_methods: `{}` is not a trait\", id))\n                 }\n             }\n+            _ => cx.sess.bug(format!(\"provided_trait_methods: `{}` is not a trait\", id))\n         }\n     } else {\n         csearch::get_provided_trait_methods(cx, id)\n     }\n }\n \n-pub fn trait_supertraits(cx: &ctxt, id: ast::DefId) -> @Vec<@TraitRef> {\n+pub fn trait_supertraits(cx: &ctxt, id: ast::DefId) -> Rc<Vec<Rc<TraitRef>>> {\n     // Check the cache.\n     match cx.supertraits.borrow().find(&id) {\n-        Some(&trait_refs) => { return trait_refs; }\n+        Some(trait_refs) => { return trait_refs.clone(); }\n         None => {}  // Continue.\n     }\n \n@@ -3524,12 +3513,12 @@ pub fn trait_supertraits(cx: &ctxt, id: ast::DefId) -> @Vec<@TraitRef> {\n \n     // Get the supertraits out of the metadata and create the\n     // TraitRef for each.\n-    let result = @csearch::get_supertraits(cx, id);\n-    cx.supertraits.borrow_mut().insert(id, result);\n-    return result;\n+    let result = Rc::new(csearch::get_supertraits(cx, id));\n+    cx.supertraits.borrow_mut().insert(id, result.clone());\n+    result\n }\n \n-pub fn trait_ref_supertraits(cx: &ctxt, trait_ref: &ty::TraitRef) -> Vec<@TraitRef> {\n+pub fn trait_ref_supertraits(cx: &ctxt, trait_ref: &ty::TraitRef) -> Vec<Rc<TraitRef>> {\n     let supertrait_refs = trait_supertraits(cx, trait_ref.def_id);\n     supertrait_refs.iter().map(\n         |supertrait_ref| supertrait_ref.subst(cx, &trait_ref.substs)).collect()\n@@ -3563,44 +3552,46 @@ fn lookup_locally_or_in_crate_store<V:Clone>(\n     v\n }\n \n-pub fn trait_method(cx: &ctxt, trait_did: ast::DefId, idx: uint) -> @Method {\n+pub fn trait_method(cx: &ctxt, trait_did: ast::DefId, idx: uint) -> Rc<Method> {\n     let method_def_id = *ty::trait_method_def_ids(cx, trait_did).get(idx);\n     ty::method(cx, method_def_id)\n }\n \n \n-pub fn trait_methods(cx: &ctxt, trait_did: ast::DefId) -> @Vec<@Method> {\n+pub fn trait_methods(cx: &ctxt, trait_did: ast::DefId) -> Rc<Vec<Rc<Method>>> {\n     let mut trait_methods = cx.trait_methods_cache.borrow_mut();\n-    match trait_methods.find(&trait_did) {\n-        Some(&methods) => methods,\n+    match trait_methods.find_copy(&trait_did) {\n+        Some(methods) => methods,\n         None => {\n             let def_ids = ty::trait_method_def_ids(cx, trait_did);\n-            let methods = @def_ids.iter().map(|d| ty::method(cx, *d)).collect();\n-            trait_methods.insert(trait_did, methods);\n+            let methods: Rc<Vec<Rc<Method>>> = Rc::new(def_ids.iter().map(|d| {\n+                ty::method(cx, *d)\n+            }).collect());\n+            trait_methods.insert(trait_did, methods.clone());\n             methods\n         }\n     }\n }\n \n-pub fn method(cx: &ctxt, id: ast::DefId) -> @Method {\n+pub fn method(cx: &ctxt, id: ast::DefId) -> Rc<Method> {\n     lookup_locally_or_in_crate_store(\"methods\", id,\n                                      &mut *cx.methods.borrow_mut(), || {\n-        @csearch::get_method(cx, id)\n+        Rc::new(csearch::get_method(cx, id))\n     })\n }\n \n-pub fn trait_method_def_ids(cx: &ctxt, id: ast::DefId) -> @Vec<DefId> {\n+pub fn trait_method_def_ids(cx: &ctxt, id: ast::DefId) -> Rc<Vec<DefId>> {\n     lookup_locally_or_in_crate_store(\"trait_method_def_ids\",\n                                      id,\n                                      &mut *cx.trait_method_def_ids.borrow_mut(),\n                                      || {\n-        @csearch::get_trait_method_def_ids(&cx.sess.cstore, id)\n+        Rc::new(csearch::get_trait_method_def_ids(&cx.sess.cstore, id))\n     })\n }\n \n-pub fn impl_trait_ref(cx: &ctxt, id: ast::DefId) -> Option<@TraitRef> {\n+pub fn impl_trait_ref(cx: &ctxt, id: ast::DefId) -> Option<Rc<TraitRef>> {\n     match cx.impl_trait_cache.borrow().find(&id) {\n-        Some(&ret) => { return ret; }\n+        Some(ret) => { return ret.clone(); }\n         None => {}\n     }\n \n@@ -3626,8 +3617,8 @@ pub fn impl_trait_ref(cx: &ctxt, id: ast::DefId) -> Option<@TraitRef> {\n         csearch::get_impl_trait(cx, id)\n     };\n \n-    cx.impl_trait_cache.borrow_mut().insert(id, ret);\n-    return ret;\n+    cx.impl_trait_cache.borrow_mut().insert(id, ret.clone());\n+    ret\n }\n \n pub fn trait_ref_to_def_id(tcx: &ctxt, tr: &ast::TraitRef) -> ast::DefId {\n@@ -3730,18 +3721,18 @@ impl VariantInfo {\n pub fn substd_enum_variants(cx: &ctxt,\n                             id: ast::DefId,\n                             substs: &substs)\n-                         -> Vec<@VariantInfo> {\n+                         -> Vec<Rc<VariantInfo>> {\n     enum_variants(cx, id).iter().map(|variant_info| {\n         let substd_args = variant_info.args.iter()\n             .map(|aty| subst(cx, substs, *aty)).collect();\n \n         let substd_ctor_ty = subst(cx, substs, variant_info.ctor_ty);\n \n-        @VariantInfo {\n+        Rc::new(VariantInfo {\n             args: substd_args,\n             ctor_ty: substd_ctor_ty,\n             ..(**variant_info).clone()\n-        }\n+        })\n     }).collect()\n }\n \n@@ -3810,27 +3801,26 @@ pub fn type_is_empty(cx: &ctxt, t: t) -> bool {\n      }\n }\n \n-pub fn enum_variants(cx: &ctxt, id: ast::DefId) -> @Vec<@VariantInfo> {\n+pub fn enum_variants(cx: &ctxt, id: ast::DefId) -> Rc<Vec<Rc<VariantInfo>>> {\n     match cx.enum_var_cache.borrow().find(&id) {\n-        Some(&variants) => return variants,\n+        Some(variants) => return variants.clone(),\n         _ => { /* fallthrough */ }\n     }\n \n     let result = if ast::LOCAL_CRATE != id.krate {\n-        @csearch::get_enum_variants(cx, id)\n+        Rc::new(csearch::get_enum_variants(cx, id))\n     } else {\n         /*\n           Although both this code and check_enum_variants in typeck/check\n           call eval_const_expr, it should never get called twice for the same\n           expr, since check_enum_variants also updates the enum_var_cache\n          */\n-        {\n-            match cx.map.get(id.node) {\n-              ast_map::NodeItem(item) => {\n-                  match item.node {\n+        match cx.map.get(id.node) {\n+            ast_map::NodeItem(item) => {\n+                match item.node {\n                     ast::ItemEnum(ref enum_definition, _) => {\n                         let mut last_discriminant: Option<Disr> = None;\n-                        @enum_definition.variants.iter().map(|&variant| {\n+                        Rc::new(enum_definition.variants.iter().map(|&variant| {\n \n                             let mut discriminant = match last_discriminant {\n                                 Some(val) => val + 1,\n@@ -3848,40 +3838,33 @@ pub fn enum_variants(cx: &ctxt, id: ast::DefId) -> @Vec<@VariantInfo> {\n                                     Ok(_) => {\n                                         cx.sess\n                                           .span_err(e.span,\n-                                                    \"expected signed integer \\\n-                                                     constant\");\n+                                                    \"expected signed integer constant\");\n                                     }\n                                     Err(ref err) => {\n                                         cx.sess\n                                           .span_err(e.span,\n-                                                    format!(\"expected \\\n-                                                             constant: {}\",\n+                                                    format!(\"expected constant: {}\",\n                                                             *err));\n                                     }\n                                 },\n                                 None => {}\n                             };\n \n-                            let variant_info =\n-                                @VariantInfo::from_ast_variant(cx,\n-                                                               variant,\n-                                                               discriminant);\n                             last_discriminant = Some(discriminant);\n-                            variant_info\n-\n-                        }).collect()\n+                            Rc::new(VariantInfo::from_ast_variant(cx, variant,\n+                                                                  discriminant))\n+                        }).collect())\n                     }\n                     _ => {\n                         cx.sess.bug(\"enum_variants: id not bound to an enum\")\n                     }\n-                  }\n-              }\n-              _ => cx.sess.bug(\"enum_variants: id not bound to an enum\")\n+                }\n             }\n+            _ => cx.sess.bug(\"enum_variants: id not bound to an enum\")\n         }\n     };\n \n-    cx.enum_var_cache.borrow_mut().insert(id, result);\n+    cx.enum_var_cache.borrow_mut().insert(id, result.clone());\n     result\n }\n \n@@ -3890,17 +3873,11 @@ pub fn enum_variants(cx: &ctxt, id: ast::DefId) -> @Vec<@VariantInfo> {\n pub fn enum_variant_with_id(cx: &ctxt,\n                             enum_id: ast::DefId,\n                             variant_id: ast::DefId)\n-                         -> @VariantInfo {\n-    let variants = enum_variants(cx, enum_id);\n-    let mut i = 0;\n-    while i < variants.len() {\n-        let variant = *variants.get(i);\n-        if variant.id == variant_id {\n-            return variant\n-        }\n-        i += 1;\n-    }\n-    cx.sess.bug(\"enum_variant_with_id(): no variant exists with that ID\");\n+                         -> Rc<VariantInfo> {\n+    enum_variants(cx, enum_id).iter()\n+                              .find(|variant| variant.id == variant_id)\n+                              .expect(\"enum_variant_with_id(): no variant exists with that ID\")\n+                              .clone()\n }\n \n \n@@ -3923,27 +3900,27 @@ pub fn lookup_impl_vtables(cx: &ctxt,\n }\n \n /// Given the did of a trait, returns its canonical trait ref.\n-pub fn lookup_trait_def(cx: &ctxt, did: ast::DefId) -> @ty::TraitDef {\n+pub fn lookup_trait_def(cx: &ctxt, did: ast::DefId) -> Rc<ty::TraitDef> {\n     let mut trait_defs = cx.trait_defs.borrow_mut();\n-    match trait_defs.find(&did) {\n-        Some(&trait_def) => {\n+    match trait_defs.find_copy(&did) {\n+        Some(trait_def) => {\n             // The item is in this crate. The caller should have added it to the\n             // type cache already\n-            return trait_def;\n+            trait_def\n         }\n         None => {\n             assert!(did.krate != ast::LOCAL_CRATE);\n-            let trait_def = @csearch::get_trait_def(cx, did);\n-            trait_defs.insert(did, trait_def);\n-            return trait_def;\n+            let trait_def = Rc::new(csearch::get_trait_def(cx, did));\n+            trait_defs.insert(did, trait_def.clone());\n+            trait_def\n         }\n     }\n }\n \n /// Iterate over meta_items of a definition.\n // (This should really be an iterator, but that would require csearch and\n // decoder to use iterators instead of higher-order functions.)\n-pub fn each_attr(tcx: &ctxt, did: DefId, f: |@MetaItem| -> bool) -> bool {\n+pub fn each_attr(tcx: &ctxt, did: DefId, f: |@ast::MetaItem| -> bool) -> bool {\n     if is_local(did) {\n         let item = tcx.map.expect_item(did.node);\n         item.attrs.iter().advance(|attr| f(attr.node.value))\n@@ -4017,20 +3994,21 @@ pub fn lookup_field_type(tcx: &ctxt,\n \n // Lookup all ancestor structs of a struct indicated by did. That is the reflexive,\n // transitive closure of doing a single lookup in cx.superstructs.\n-fn lookup_super_structs(cx: &ctxt,\n-                            did: ast::DefId) -> Vec<DefId> {\n-    let mut this_result: Vec<DefId> = vec!(did);\n-    match cx.superstructs.borrow().find(&did) {\n-        Some(&Some(def_id)) => {\n-            let ss: Vec<DefId> = lookup_super_structs(cx, def_id);\n-            this_result.extend(ss.move_iter());\n-            this_result\n-        },\n-        Some(&None) => this_result,\n-        None => {\n-            cx.sess.bug(\n-                format!(\"ID not mapped to super-struct: {}\",\n-                    cx.map.node_to_str(did.node)));\n+fn each_super_struct(cx: &ctxt, mut did: ast::DefId, f: |ast::DefId|) {\n+    let superstructs = cx.superstructs.borrow();\n+\n+    loop {\n+        f(did);\n+        match superstructs.find(&did) {\n+            Some(&Some(def_id)) => {\n+                did = def_id;\n+            },\n+            Some(&None) => break,\n+            None => {\n+                cx.sess.bug(\n+                    format!(\"ID not mapped to super-struct: {}\",\n+                        cx.map.node_to_str(did.node)));\n+            }\n         }\n     }\n }\n@@ -4043,26 +4021,22 @@ pub fn lookup_struct_fields(cx: &ctxt, did: ast::DefId) -> Vec<field_ty> {\n         // we have to walk the inheritance chain of the struct to get all the\n         // structs (explicit and inherited) for a struct. If this is expensive\n         // we could cache the whole list of fields here.\n-        let structs = lookup_super_structs(cx, did);\n         let struct_fields = cx.struct_fields.borrow();\n-        let results: Vec<&@Vec<field_ty>> = structs.iter().map(|s| {\n-            match struct_fields.find(s) {\n-                Some(fields) => fields,\n+        let mut results: SmallVector<&[field_ty]> = SmallVector::zero();\n+        each_super_struct(cx, did, |s| {\n+            match struct_fields.find(&s) {\n+                Some(fields) => results.push(fields.as_slice()),\n                 _ => {\n                     cx.sess.bug(\n                         format!(\"ID not mapped to struct fields: {}\",\n                             cx.map.node_to_str(did.node)));\n                 }\n             }\n-        }).collect();\n+        });\n \n-        let len = results.iter().map(|x| x.len()).fold(0, |a, b| a + b);\n+        let len = results.as_slice().iter().map(|x| x.len()).sum();\n         let mut result: Vec<field_ty> = Vec::with_capacity(len);\n-        for rs in results.iter() {\n-            for r in rs.iter() {\n-                result.push(*r);\n-            }\n-        }\n+        result.extend(results.as_slice().iter().flat_map(|rs| rs.iter().map(|&f| f)));\n         assert!(result.len() == len);\n         result\n     } else {\n@@ -4293,39 +4267,39 @@ pub fn eval_repeat_count<T: ExprTyProvider>(tcx: &T, count_expr: &ast::Expr) ->\n // relation on the supertraits from each bounded trait's constraint\n // list.\n pub fn each_bound_trait_and_supertraits(tcx: &ctxt,\n-                                        bounds: &[@TraitRef],\n-                                        f: |@TraitRef| -> bool)\n+                                        bounds: &[Rc<TraitRef>],\n+                                        f: |Rc<TraitRef>| -> bool)\n                                         -> bool {\n-    for &bound_trait_ref in bounds.iter() {\n+    for bound_trait_ref in bounds.iter() {\n         let mut supertrait_set = HashMap::new();\n         let mut trait_refs = Vec::new();\n         let mut i = 0;\n \n         // Seed the worklist with the trait from the bound\n         supertrait_set.insert(bound_trait_ref.def_id, ());\n-        trait_refs.push(bound_trait_ref);\n+        trait_refs.push(bound_trait_ref.clone());\n \n         // Add the given trait ty to the hash map\n         while i < trait_refs.len() {\n             debug!(\"each_bound_trait_and_supertraits(i={:?}, trait_ref={})\",\n                    i, trait_refs.get(i).repr(tcx));\n \n-            if !f(*trait_refs.get(i)) {\n+            if !f(trait_refs.get(i).clone()) {\n                 return false;\n             }\n \n             // Add supertraits to supertrait_set\n             let supertrait_refs = trait_ref_supertraits(tcx,\n-                                                        *trait_refs.get(i));\n-            for &supertrait_ref in supertrait_refs.iter() {\n+                                                        &**trait_refs.get(i));\n+            for supertrait_ref in supertrait_refs.iter() {\n                 debug!(\"each_bound_trait_and_supertraits(supertrait_ref={})\",\n                        supertrait_ref.repr(tcx));\n \n                 let d_id = supertrait_ref.def_id;\n                 if !supertrait_set.contains_key(&d_id) {\n                     // FIXME(#5527) Could have same trait multiple times\n                     supertrait_set.insert(d_id, ());\n-                    trait_refs.push(supertrait_ref);\n+                    trait_refs.push(supertrait_ref.clone());\n                 }\n             }\n \n@@ -4350,7 +4324,7 @@ pub fn get_opaque_ty(tcx: &ctxt) -> Result<t, ~str> {\n }\n \n pub fn visitor_object_ty(tcx: &ctxt,\n-                         region: ty::Region) -> Result<(@TraitRef, t), ~str> {\n+                         region: ty::Region) -> Result<(Rc<TraitRef>, t), ~str> {\n     let trait_lang_item = match tcx.lang_items.require(TyVisitorTraitLangItem) {\n         Ok(id) => id,\n         Err(s) => { return Err(s); }\n@@ -4360,19 +4334,19 @@ pub fn visitor_object_ty(tcx: &ctxt,\n         self_ty: None,\n         tps: Vec::new()\n     };\n-    let trait_ref = @TraitRef { def_id: trait_lang_item, substs: substs };\n-    Ok((trait_ref,\n+    let trait_ref = Rc::new(TraitRef { def_id: trait_lang_item, substs: substs });\n+    Ok((trait_ref.clone(),\n         mk_trait(tcx,\n                  trait_ref.def_id,\n                  trait_ref.substs.clone(),\n                  RegionTraitStore(region, ast::MutMutable),\n                  EmptyBuiltinBounds())))\n }\n \n-pub fn item_variances(tcx: &ctxt, item_id: ast::DefId) -> @ItemVariances {\n+pub fn item_variances(tcx: &ctxt, item_id: ast::DefId) -> Rc<ItemVariances> {\n     lookup_locally_or_in_crate_store(\n         \"item_variance_map\", item_id, &mut *tcx.item_variance_map.borrow_mut(),\n-        || @csearch::get_item_variances(&tcx.sess.cstore, item_id))\n+        || Rc::new(csearch::get_item_variances(&tcx.sess.cstore, item_id)))\n }\n \n /// Records a trait-to-implementation mapping.\n@@ -4386,7 +4360,7 @@ pub fn record_trait_implementation(tcx: &ctxt,\n         }\n         None => {}\n     }\n-    tcx.trait_impls.borrow_mut().insert(trait_def_id, @RefCell::new(vec!(impl_def_id)));\n+    tcx.trait_impls.borrow_mut().insert(trait_def_id, Rc::new(RefCell::new(vec!(impl_def_id))));\n }\n \n /// Populates the type context with all the implementations for the given type\n@@ -4430,7 +4404,8 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n                 }\n                 None => {}\n             }\n-            tcx.inherent_impls.borrow_mut().insert(type_id, @RefCell::new(vec!(impl_def_id)));\n+            tcx.inherent_impls.borrow_mut().insert(type_id,\n+                                                   Rc::new(RefCell::new(vec!(impl_def_id))));\n         }\n     });\n \n@@ -4500,7 +4475,7 @@ pub fn trait_of_method(tcx: &ctxt, def_id: ast::DefId)\n     if def_id.krate != LOCAL_CRATE {\n         return csearch::get_trait_of_method(&tcx.sess.cstore, def_id, tcx);\n     }\n-    match tcx.methods.borrow().find(&def_id).map(|m| *m) {\n+    match tcx.methods.borrow().find_copy(&def_id) {\n         Some(method) => {\n             match method.container {\n                 TraitContainer(def_id) => Some(def_id),\n@@ -4520,7 +4495,7 @@ pub fn trait_of_method(tcx: &ctxt, def_id: ast::DefId)\n pub fn trait_method_of_method(tcx: &ctxt,\n                               def_id: ast::DefId) -> Option<ast::DefId> {\n     let method = match tcx.methods.borrow().find(&def_id) {\n-        Some(&m) => m,\n+        Some(m) => m.clone(),\n         None => return None,\n     };\n     let name = method.ident.name;\n@@ -4689,7 +4664,7 @@ impl Variance {\n \n pub fn construct_parameter_environment(\n     tcx: &ctxt,\n-    self_bound: Option<@TraitRef>,\n+    self_bound: Option<Rc<TraitRef>>,\n     item_type_params: &[TypeParameterDef],\n     method_type_params: &[TypeParameterDef],\n     item_region_params: &[RegionParameterDef],\n@@ -4704,7 +4679,7 @@ pub fn construct_parameter_environment(\n     //\n \n     // map Self => Self\n-    let self_ty = self_bound.map(|t| ty::mk_self(tcx, t.def_id));\n+    let self_ty = self_bound.as_ref().map(|t| ty::mk_self(tcx, t.def_id));\n \n     // map A => A\n     let num_item_type_params = item_type_params.len();"}, {"sha": "6ae68bdbad1281399841349823a5513eb71ad884", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 12, "deletions": 20, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -60,6 +60,7 @@ use middle::typeck::rscope::{RegionScope};\n use middle::typeck::lookup_def_tcx;\n use util::ppaux::Repr;\n \n+use std::rc::Rc;\n use syntax::abi;\n use syntax::{ast, ast_util};\n use syntax::codemap::Span;\n@@ -69,7 +70,7 @@ use syntax::print::pprust::{lifetime_to_str, path_to_str};\n pub trait AstConv {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt;\n     fn get_item_ty(&self, id: ast::DefId) -> ty::ty_param_bounds_and_ty;\n-    fn get_trait_def(&self, id: ast::DefId) -> @ty::TraitDef;\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef>;\n \n     // what type should we use when a type is omitted?\n     fn ty_infer(&self, span: Span) -> ty::t;\n@@ -261,25 +262,16 @@ pub fn ast_path_to_substs_and_ty<AC:AstConv,\n }\n \n pub fn ast_path_to_trait_ref<AC:AstConv,RS:RegionScope>(\n-    this: &AC,\n-    rscope: &RS,\n-    trait_def_id: ast::DefId,\n-    self_ty: Option<ty::t>,\n-    path: &ast::Path) -> @ty::TraitRef\n-{\n-    let trait_def =\n-        this.get_trait_def(trait_def_id);\n-    let substs =\n-        ast_path_substs(\n-            this,\n-            rscope,\n-            &trait_def.generics,\n-            self_ty,\n-            path);\n-    let trait_ref =\n-        @ty::TraitRef {def_id: trait_def_id,\n-                       substs: substs};\n-    return trait_ref;\n+        this: &AC,\n+        rscope: &RS,\n+        trait_def_id: ast::DefId,\n+        self_ty: Option<ty::t>,\n+        path: &ast::Path) -> Rc<ty::TraitRef> {\n+    let trait_def = this.get_trait_def(trait_def_id);\n+    Rc::new(ty::TraitRef {\n+        def_id: trait_def_id,\n+        substs: ast_path_substs(this, rscope, &trait_def.generics, self_ty, path)\n+    })\n }\n \n pub fn ast_path_to_ty<AC:AstConv,RS:RegionScope>("}, {"sha": "3b33a17d5825f9e2ea657cf82aa3d00079ce0fa1", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 23, "deletions": 20, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -30,7 +30,7 @@ itself (note that inherent impls can only be defined in the same\n module as the type itself).\n \n Inherent candidates are not always derived from impls.  If you have a\n-trait instance, such as a value of type `@ToStr`, then the trait\n+trait instance, such as a value of type `~ToStr`, then the trait\n methods (`to_str()`, in this case) are inherently associated with it.\n Another case is type parameters, in which case the methods of their\n bounds are inherent.\n@@ -97,7 +97,7 @@ use util::ppaux;\n use util::ppaux::Repr;\n \n use collections::HashSet;\n-use std::result;\n+use std::rc::Rc;\n use syntax::ast::{DefId, SelfValue, SelfRegion};\n use syntax::ast::{SelfUniq, SelfStatic};\n use syntax::ast::{MutMutable, MutImmutable};\n@@ -203,7 +203,7 @@ pub fn lookup_in_trait<'a>(\n // to a trait and its supertraits.\n fn get_method_index(tcx: &ty::ctxt,\n                     trait_ref: &TraitRef,\n-                    subtrait: @TraitRef,\n+                    subtrait: Rc<TraitRef>,\n                     n_method: uint) -> uint {\n     // We need to figure the \"real index\" of the method in a\n     // listing of all the methods of an object. We do this by\n@@ -311,7 +311,7 @@ struct LookupContext<'a> {\n struct Candidate {\n     rcvr_match_condition: RcvrMatchCondition,\n     rcvr_substs: ty::substs,\n-    method_ty: @ty::Method,\n+    method_ty: Rc<ty::Method>,\n     origin: MethodOrigin,\n }\n \n@@ -412,7 +412,7 @@ impl<'a> LookupContext<'a> {\n          * `self.inherent_candidates`.  See comment at the start of\n          * the file.  To find the inherent candidates, we repeatedly\n          * deref the self-ty to find the \"base-type\".  So, for\n-         * example, if the receiver is @@C where `C` is a struct type,\n+         * example, if the receiver is ~~C where `C` is a struct type,\n          * we'll want to find the inherent impls for `C`.\n          */\n \n@@ -511,12 +511,15 @@ impl<'a> LookupContext<'a> {\n             self_ty: Some(ty::mk_err()),\n             ..(*substs).clone()\n         };\n-        let trait_ref = @TraitRef { def_id: did, substs: rcvr_substs.clone() };\n+        let trait_ref = Rc::new(TraitRef {\n+            def_id: did,\n+            substs: rcvr_substs.clone()\n+        });\n \n-        self.push_inherent_candidates_from_bounds_inner(&[trait_ref],\n+        self.push_inherent_candidates_from_bounds_inner(&[trait_ref.clone()],\n             |new_trait_ref, m, method_num, _bound_num| {\n-            let vtable_index = get_method_index(tcx, new_trait_ref,\n-                                                trait_ref, method_num);\n+            let vtable_index = get_method_index(tcx, &*new_trait_ref,\n+                                                trait_ref.clone(), method_num);\n             let mut m = (*m).clone();\n             // We need to fix up the transformed self type.\n             *m.fty.sig.inputs.get_mut(0) =\n@@ -526,7 +529,7 @@ impl<'a> LookupContext<'a> {\n             Some(Candidate {\n                 rcvr_match_condition: RcvrMatchesIfObject(did),\n                 rcvr_substs: new_trait_ref.substs.clone(),\n-                method_ty: @m,\n+                method_ty: Rc::new(m),\n                 origin: MethodObject(MethodObject {\n                         trait_id: new_trait_ref.def_id,\n                         object_trait_id: did,\n@@ -563,14 +566,14 @@ impl<'a> LookupContext<'a> {\n         debug!(\"push_inherent_candidates_from_self()\");\n         self.push_inherent_candidates_from_bounds(\n             rcvr_ty,\n-            [self.fcx.inh.param_env.self_param_bound.unwrap()],\n+            [self.fcx.inh.param_env.self_param_bound.clone().unwrap()],\n             restrict_to,\n             param_self)\n     }\n \n     fn push_inherent_candidates_from_bounds(&mut self,\n                                             self_ty: ty::t,\n-                                            bounds: &[@TraitRef],\n+                                            bounds: &[Rc<TraitRef>],\n                                             restrict_to: Option<DefId>,\n                                             param: param_index) {\n         self.push_inherent_candidates_from_bounds_inner(bounds,\n@@ -600,9 +603,9 @@ impl<'a> LookupContext<'a> {\n     // Do a search through a list of bounds, using a callback to actually\n     // create the candidates.\n     fn push_inherent_candidates_from_bounds_inner(&mut self,\n-                                                  bounds: &[@TraitRef],\n-                                                  mk_cand: |tr: @TraitRef,\n-                                                            m: @ty::Method,\n+                                                  bounds: &[Rc<TraitRef>],\n+                                                  mk_cand: |tr: Rc<TraitRef>,\n+                                                            m: Rc<ty::Method>,\n                                                             method_num: uint,\n                                                             bound_num: uint|\n                                                             -> Option<Candidate>) {\n@@ -618,7 +621,7 @@ impl<'a> LookupContext<'a> {\n                 m.explicit_self != ast::SelfStatic &&\n                 m.ident.name == self.m_name }) {\n                 Some(pos) => {\n-                    let method = *trait_methods.get(pos);\n+                    let method = trait_methods.get(pos).clone();\n \n                     match mk_cand(bound_trait_ref, method, pos, this_bound_idx) {\n                         Some(cand) => {\n@@ -692,8 +695,8 @@ impl<'a> LookupContext<'a> {\n         candidates.push(Candidate {\n             rcvr_match_condition: RcvrMatchesIfSubtype(impl_ty),\n             rcvr_substs: impl_substs,\n+            origin: MethodStatic(method.def_id),\n             method_ty: method,\n-            origin: MethodStatic(method.def_id)\n         });\n     }\n \n@@ -874,7 +877,7 @@ impl<'a> LookupContext<'a> {\n             }\n \n             ty_trait(~ty::TyTrait { def_id: trt_did, substs: trt_substs, bounds: b, .. }) => {\n-                // Coerce ~/@/&Trait instances to &Trait.\n+                // Coerce ~/&Trait instances to &Trait.\n \n                 self.search_for_some_kind_of_autorefd_method(\n                     AutoBorrowObj, autoderefs, [MutImmutable, MutMutable],\n@@ -1184,8 +1187,8 @@ impl<'a> LookupContext<'a> {\n         let span = self.self_expr.map_or(self.span, |e| e.span);\n         match self.fcx.mk_subty(false, infer::Misc(span),\n                                 rcvr_ty, transformed_self_ty) {\n-            result::Ok(_) => {}\n-            result::Err(_) => {\n+            Ok(_) => {}\n+            Err(_) => {\n                 self.bug(format!(\"{} was a subtype of {} but now is not?\",\n                               self.ty_to_str(rcvr_ty),\n                               self.ty_to_str(transformed_self_ty)));"}, {"sha": "42061d681447f1460f548cf45cd5dd7016c08002", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -117,7 +117,7 @@ use util::nodemap::{FnvHashMap, NodeMap};\n use std::cell::{Cell, RefCell};\n use collections::HashMap;\n use std::mem::replace;\n-use std::result;\n+use std::rc::Rc;\n use std::vec::Vec;\n use syntax::abi;\n use syntax::ast::{Provided, Required};\n@@ -622,9 +622,9 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n                                              it.span,\n                                              &impl_tpt.generics,\n                                              ast_trait_ref,\n-                                             impl_trait_ref,\n+                                             &*impl_trait_ref,\n                                              ms.as_slice());\n-                vtable::resolve_impl(ccx.tcx, it, &impl_tpt.generics, impl_trait_ref);\n+                vtable::resolve_impl(ccx.tcx, it, &impl_tpt.generics, &*impl_trait_ref);\n             }\n             None => { }\n         }\n@@ -640,7 +640,7 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n                 }\n                 Provided(m) => {\n                     check_method_body(ccx, &trait_def.generics,\n-                                      Some(trait_def.trait_ref), m);\n+                                      Some(trait_def.trait_ref.clone()), m);\n                 }\n             }\n         }\n@@ -682,7 +682,7 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n \n fn check_method_body(ccx: &CrateCtxt,\n                      item_generics: &ty::Generics,\n-                     self_bound: Option<@ty::TraitRef>,\n+                     self_bound: Option<Rc<ty::TraitRef>>,\n                      method: &ast::Method) {\n     /*!\n      * Type checks a method body.\n@@ -744,10 +744,10 @@ fn check_impl_methods_against_trait(ccx: &CrateCtxt,\n             Some(trait_method_ty) => {\n                 compare_impl_method(ccx.tcx,\n                                     impl_generics,\n-                                    impl_method_ty,\n+                                    &*impl_method_ty,\n                                     impl_method.span,\n                                     impl_method.body.id,\n-                                    *trait_method_ty,\n+                                    &**trait_method_ty,\n                                     &impl_trait_ref.substs);\n             }\n             None => {\n@@ -800,7 +800,7 @@ fn check_impl_methods_against_trait(ccx: &CrateCtxt,\n  */\n fn compare_impl_method(tcx: &ty::ctxt,\n                        impl_generics: &ty::Generics,\n-                       impl_m: @ty::Method,\n+                       impl_m: &ty::Method,\n                        impl_m_span: Span,\n                        impl_m_body_id: ast::NodeId,\n                        trait_m: &ty::Method,\n@@ -973,8 +973,8 @@ fn compare_impl_method(tcx: &ty::ctxt,\n \n     match infer::mk_subty(&infcx, false, infer::MethodCompatCheck(impl_m_span),\n                           impl_fty, trait_fty) {\n-        result::Ok(()) => {}\n-        result::Err(ref terr) => {\n+        Ok(()) => {}\n+        Err(ref terr) => {\n             tcx.sess.span_err(\n                 impl_m_span,\n                 format!(\"method `{}` has an incompatible type for trait: {}\",\n@@ -992,7 +992,7 @@ impl<'a> AstConv for FnCtxt<'a> {\n         ty::lookup_item_type(self.tcx(), id)\n     }\n \n-    fn get_trait_def(&self, id: ast::DefId) -> @ty::TraitDef {\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n         ty::lookup_trait_def(self.tcx(), id)\n     }\n \n@@ -1175,8 +1175,8 @@ impl<'a> FnCtxt<'a> {\n                                  infer::ExprAssignable(expr.span),\n                                  sub,\n                                  sup) {\n-            Ok(None) => result::Ok(()),\n-            Err(ref e) => result::Err((*e)),\n+            Ok(None) => Ok(()),\n+            Err(ref e) => Err((*e)),\n             Ok(Some(adjustment)) => {\n                 self.write_adjustment(expr.id, adjustment);\n                 Ok(())\n@@ -2844,8 +2844,8 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n         match expr_opt {\n           None => match fcx.mk_eqty(false, infer::Misc(expr.span),\n                                     ret_ty, ty::mk_nil()) {\n-            result::Ok(_) => { /* fall through */ }\n-            result::Err(_) => {\n+            Ok(_) => { /* fall through */ }\n+            Err(_) => {\n                 tcx.sess.span_err(\n                     expr.span,\n                     \"`return;` in function returning non-nil\");\n@@ -3541,10 +3541,10 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n                 vs: &[ast::P<ast::Variant>],\n                 id: ast::NodeId,\n                 hint: attr::ReprAttr)\n-                -> Vec<@ty::VariantInfo> {\n+                -> Vec<Rc<ty::VariantInfo>> {\n \n         let rty = ty::node_id_to_type(ccx.tcx, id);\n-        let mut variants: Vec<@ty::VariantInfo> = Vec::new();\n+        let mut variants: Vec<Rc<ty::VariantInfo>> = Vec::new();\n         let mut disr_vals: Vec<ty::Disr> = Vec::new();\n         let mut prev_disr_val: Option<ty::Disr> = None;\n \n@@ -3600,7 +3600,8 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n             }\n             disr_vals.push(current_disr_val);\n \n-            let variant_info = @VariantInfo::from_ast_variant(ccx.tcx, v, current_disr_val);\n+            let variant_info = Rc::new(VariantInfo::from_ast_variant(ccx.tcx, v,\n+                                                                     current_disr_val));\n             prev_disr_val = Some(current_disr_val);\n \n             variants.push(variant_info);\n@@ -3622,7 +3623,7 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n     let variants = do_check(ccx, vs, id, hint);\n \n     // cache so that ty::enum_variants won't repeat this work\n-    ccx.tcx.enum_var_cache.borrow_mut().insert(local_def(id), @variants);\n+    ccx.tcx.enum_var_cache.borrow_mut().insert(local_def(id), Rc::new(variants));\n \n     // Check that it is possible to represent this enum.\n     check_representable(ccx.tcx, sp, id, \"enum\");"}, {"sha": "94cbd3a3a750748000085fb95bcc18a1d0310b21", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -1008,7 +1008,7 @@ fn constrain_regions_in_type(\n             // for regions that are as-yet-unknown.\n         } else if r_sub == minimum_lifetime {\n             rcx.fcx.mk_subr(\n-                true, origin,\n+                true, origin.clone(),\n                 r_sub, r_sup);\n         } else {\n             rcx.fcx.mk_subr("}, {"sha": "bb57fa2646bf654ef2efbfe3f59987d62871e62e", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -27,6 +27,7 @@ use util::common::indenter;\n use util::ppaux;\n use util::ppaux::Repr;\n \n+use std::rc::Rc;\n use collections::HashSet;\n use syntax::ast;\n use syntax::ast_util;\n@@ -137,21 +138,21 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n \n         // Substitute the values of the type parameters that may\n         // appear in the bound.\n-        let trait_ref = substs.as_ref().map_or(trait_ref, |substs| {\n+        let trait_ref = substs.as_ref().map_or(trait_ref.clone(), |substs| {\n             debug!(\"about to subst: {}, {}\",\n                    trait_ref.repr(tcx), substs.repr(tcx));\n             trait_ref.subst(tcx, *substs)\n         });\n \n         debug!(\"after subst: {}\", trait_ref.repr(tcx));\n \n-        match lookup_vtable(vcx, span, ty, trait_ref, is_early) {\n+        match lookup_vtable(vcx, span, ty, trait_ref.clone(), is_early) {\n             Some(vtable) => param_result.push(vtable),\n             None => {\n                 vcx.tcx().sess.span_fatal(span,\n                     format!(\"failed to find an implementation of \\\n                           trait {} for {}\",\n-                         vcx.infcx.trait_ref_to_str(trait_ref),\n+                         vcx.infcx.trait_ref_to_str(&*trait_ref),\n                          vcx.infcx.ty_to_str(ty)));\n             }\n         }\n@@ -173,8 +174,8 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n \n fn relate_trait_refs(vcx: &VtableContext,\n                      span: Span,\n-                     act_trait_ref: @ty::TraitRef,\n-                     exp_trait_ref: @ty::TraitRef) {\n+                     act_trait_ref: Rc<ty::TraitRef>,\n+                     exp_trait_ref: Rc<ty::TraitRef>) {\n     /*!\n      *\n      * Checks that an implementation of `act_trait_ref` is suitable\n@@ -185,17 +186,17 @@ fn relate_trait_refs(vcx: &VtableContext,\n     match infer::mk_sub_trait_refs(vcx.infcx,\n                                    false,\n                                    infer::RelateTraitRefs(span),\n-                                   act_trait_ref,\n-                                   exp_trait_ref) {\n+                                   act_trait_ref.clone(),\n+                                   exp_trait_ref.clone()) {\n         Ok(()) => {} // Ok.\n         Err(ref err) => {\n             // There is an error, but we need to do some work to make\n             // the message good.\n             // Resolve any type vars in the trait refs\n             let r_act_trait_ref =\n-                vcx.infcx.resolve_type_vars_in_trait_ref_if_possible(act_trait_ref);\n+                vcx.infcx.resolve_type_vars_in_trait_ref_if_possible(&*act_trait_ref);\n             let r_exp_trait_ref =\n-                vcx.infcx.resolve_type_vars_in_trait_ref_if_possible(exp_trait_ref);\n+                vcx.infcx.resolve_type_vars_in_trait_ref_if_possible(&*exp_trait_ref);\n             // Only print the message if there aren't any previous type errors\n             // inside the types.\n             if !ty::trait_ref_contains_error(&r_act_trait_ref) &&\n@@ -216,12 +217,12 @@ fn relate_trait_refs(vcx: &VtableContext,\n fn lookup_vtable(vcx: &VtableContext,\n                  span: Span,\n                  ty: ty::t,\n-                 trait_ref: @ty::TraitRef,\n+                 trait_ref: Rc<ty::TraitRef>,\n                  is_early: bool)\n                  -> Option<vtable_origin> {\n     debug!(\"lookup_vtable(ty={}, trait_ref={})\",\n            vcx.infcx.ty_to_str(ty),\n-           vcx.infcx.trait_ref_to_str(trait_ref));\n+           vcx.infcx.trait_ref_to_str(&*trait_ref));\n     let _i = indenter();\n \n     let ty = match fixup_ty(vcx, span, ty, is_early) {\n@@ -242,23 +243,23 @@ fn lookup_vtable(vcx: &VtableContext,\n         ty::ty_param(param_ty {idx: n, ..}) => {\n             let env_bounds = &vcx.param_env.type_param_bounds;\n             if env_bounds.len() > n {\n-                let type_param_bounds: &[@ty::TraitRef] =\n+                let type_param_bounds: &[Rc<ty::TraitRef>] =\n                     env_bounds.get(n).trait_bounds.as_slice();\n                 lookup_vtable_from_bounds(vcx, span,\n                                           type_param_bounds,\n                                           param_numbered(n),\n-                                          trait_ref)\n+                                          trait_ref.clone())\n             } else {\n                 None\n             }\n         }\n \n         ty::ty_self(_) => {\n-            let self_param_bound = vcx.param_env.self_param_bound.unwrap();\n+            let self_param_bound = vcx.param_env.self_param_bound.clone().unwrap();\n             lookup_vtable_from_bounds(vcx, span,\n                                       [self_param_bound],\n                                       param_self,\n-                                      trait_ref)\n+                                      trait_ref.clone())\n         }\n \n         // Default case just falls through\n@@ -276,9 +277,9 @@ fn lookup_vtable(vcx: &VtableContext,\n // of them are the vtable we are looking for.\n fn lookup_vtable_from_bounds(vcx: &VtableContext,\n                              span: Span,\n-                             bounds: &[@ty::TraitRef],\n+                             bounds: &[Rc<ty::TraitRef>],\n                              param: param_index,\n-                             trait_ref: @ty::TraitRef)\n+                             trait_ref: Rc<ty::TraitRef>)\n                              -> Option<vtable_origin> {\n     let tcx = vcx.tcx();\n \n@@ -289,7 +290,7 @@ fn lookup_vtable_from_bounds(vcx: &VtableContext,\n                bound_trait_ref.repr(vcx.tcx()));\n \n         if bound_trait_ref.def_id == trait_ref.def_id {\n-            relate_trait_refs(vcx, span, bound_trait_ref, trait_ref);\n+            relate_trait_refs(vcx, span, bound_trait_ref, trait_ref.clone());\n             let vtable = vtable_param(param, n_bound);\n             debug!(\"found param vtable: {:?}\",\n                    vtable);\n@@ -306,7 +307,7 @@ fn lookup_vtable_from_bounds(vcx: &VtableContext,\n fn search_for_vtable(vcx: &VtableContext,\n                      span: Span,\n                      ty: ty::t,\n-                     trait_ref: @ty::TraitRef,\n+                     trait_ref: Rc<ty::TraitRef>,\n                      is_early: bool)\n                      -> Option<vtable_origin> {\n     let tcx = vcx.tcx();\n@@ -388,13 +389,13 @@ fn search_for_vtable(vcx: &VtableContext,\n         // some value of U) with some_trait<T>. This would fail if T\n         // and U weren't compatible.\n \n-        debug!(\"(checking vtable) @2 relating trait \\\n+        debug!(\"(checking vtable) \\\\#2 relating trait \\\n                 ty {} to of_trait_ref {}\",\n-               vcx.infcx.trait_ref_to_str(trait_ref),\n-               vcx.infcx.trait_ref_to_str(of_trait_ref));\n+               vcx.infcx.trait_ref_to_str(&*trait_ref),\n+               vcx.infcx.trait_ref_to_str(&*of_trait_ref));\n \n         let of_trait_ref = of_trait_ref.subst(tcx, &substs);\n-        relate_trait_refs(vcx, span, of_trait_ref, trait_ref);\n+        relate_trait_refs(vcx, span, of_trait_ref, trait_ref.clone());\n \n \n         // Recall that trait_ref -- the trait type we're casting to --\n@@ -429,7 +430,7 @@ fn search_for_vtable(vcx: &VtableContext,\n                 they will be unified with the bounds for \\\n                 the target ty, {}\",\n                vcx.infcx.tys_to_str(substs_f.tps.as_slice()),\n-               vcx.infcx.trait_ref_to_str(trait_ref));\n+               vcx.infcx.trait_ref_to_str(&*trait_ref));\n \n         // Next, we unify the fixed-up substitutions for the impl self\n         // ty with the substitutions from the trait type that we're\n@@ -438,7 +439,7 @@ fn search_for_vtable(vcx: &VtableContext,\n         // I am a little confused about this, since it seems to be\n         // very similar to the relate_trait_refs we already do,\n         // but problems crop up if it is removed, so... -sully\n-        connect_trait_tps(vcx, span, &substs_f, trait_ref, impl_did);\n+        connect_trait_tps(vcx, span, &substs_f, trait_ref.clone(), impl_did);\n \n         // Finally, we register that we found a matching impl, and\n         // record the def ID of the impl as well as the resolved list\n@@ -502,7 +503,7 @@ fn fixup_ty(vcx: &VtableContext,\n fn connect_trait_tps(vcx: &VtableContext,\n                      span: Span,\n                      impl_substs: &ty::substs,\n-                     trait_ref: @ty::TraitRef,\n+                     trait_ref: Rc<ty::TraitRef>,\n                      impl_did: ast::DefId) {\n     let tcx = vcx.tcx();\n \n@@ -561,14 +562,14 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                     };\n \n                       let vcx = fcx.vtable_context();\n-                      let target_trait_ref = @ty::TraitRef {\n+                      let target_trait_ref = Rc::new(ty::TraitRef {\n                           def_id: target_def_id,\n                           substs: ty::substs {\n                               tps: target_substs.tps.clone(),\n                               regions: target_substs.regions.clone(),\n                               self_ty: Some(typ)\n                           }\n-                      };\n+                      });\n \n                       let param_bounds = ty::ParamBounds {\n                           builtin_bounds: ty::EmptyBuiltinBounds(),\n@@ -761,7 +762,7 @@ pub fn resolve_impl(tcx: &ty::ctxt,\n     // but that falls out of doing this.\n     let param_bounds = ty::ParamBounds {\n         builtin_bounds: ty::EmptyBuiltinBounds(),\n-        trait_bounds: vec!(@impl_trait_ref)\n+        trait_bounds: vec!(Rc::new(impl_trait_ref))\n     };\n     let t = ty::node_id_to_type(tcx, impl_item.id);\n     let t = t.subst(tcx, &param_env.free_substs);"}, {"sha": "3a50b0681e8b89abd5bc2921f7d61de3dae23057", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -330,13 +330,13 @@ impl<'a> CoherenceChecker<'a> {\n \n             // Create substitutions for the various trait parameters.\n             let new_method_ty =\n-                @subst_receiver_types_in_method_ty(\n+                Rc::new(subst_receiver_types_in_method_ty(\n                     tcx,\n                     impl_id,\n                     trait_ref,\n                     new_did,\n-                    *trait_method,\n-                    Some(trait_method.def_id));\n+                    &**trait_method,\n+                    Some(trait_method.def_id)));\n \n             debug!(\"new_method_ty={}\", new_method_ty.repr(tcx));\n             all_methods.push(new_did);\n@@ -376,7 +376,8 @@ impl<'a> CoherenceChecker<'a> {\n             None => {}\n         }\n \n-        tcx.inherent_impls.borrow_mut().insert(base_def_id, @RefCell::new(vec!(impl_def_id)));\n+        tcx.inherent_impls.borrow_mut().insert(base_def_id,\n+                                               Rc::new(RefCell::new(vec!(impl_def_id))));\n     }\n \n     fn add_trait_impl(&self, base_def_id: DefId, impl_def_id: DefId) {\n@@ -575,7 +576,7 @@ impl<'a> CoherenceChecker<'a> {\n                         trait_ref.ref_id);\n \n                     self.instantiate_default_methods(local_def(item.id),\n-                                                     ty_trait_ref,\n+                                                     &*ty_trait_ref,\n                                                      &mut methods);\n                 }\n "}, {"sha": "0102001aa3cd997a830d5540de5f9c2576889ac9", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -126,7 +126,7 @@ impl<'a> AstConv for CrateCtxt<'a> {\n         }\n     }\n \n-    fn get_trait_def(&self, id: ast::DefId) -> @ty::TraitDef {\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n         get_trait_def(self, id)\n     }\n \n@@ -195,7 +195,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n                     // For each method, construct a suitable ty::Method and\n                     // store it into the `tcx.methods` table:\n                     for m in ms.iter() {\n-                        let ty_method = @match m {\n+                        let ty_method = Rc::new(match m {\n                             &ast::Required(ref m) => {\n                                 ty_method_of_trait_method(\n                                     ccx, trait_id, &trait_ty_generics,\n@@ -209,10 +209,10 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n                                     &m.id, &m.ident, &m.explicit_self,\n                                     &m.generics, &m.fn_style, m.decl)\n                             }\n-                        };\n+                        });\n \n                         if ty_method.explicit_self == ast::SelfStatic {\n-                            make_static_method_ty(ccx, trait_id, ty_method,\n+                            make_static_method_ty(ccx, trait_id, &*ty_method,\n                                                   &trait_ty_generics);\n                         }\n \n@@ -221,7 +221,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n                     }\n \n                     // Add an entry mapping\n-                    let method_def_ids = @ms.iter().map(|m| {\n+                    let method_def_ids = Rc::new(ms.iter().map(|m| {\n                         match m {\n                             &ast::Required(ref ty_method) => {\n                                 local_def(ty_method.id)\n@@ -230,7 +230,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt, trait_id: ast::NodeId) {\n                                 local_def(method.id)\n                             }\n                         }\n-                    }).collect();\n+                    }).collect());\n \n                     let trait_def_id = local_def(trait_id);\n                     tcx.trait_method_def_ids.borrow_mut()\n@@ -412,7 +412,7 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n     assert!(!tcx.supertraits.borrow().contains_key(&local_def(id)));\n \n     let self_ty = ty::mk_self(ccx.tcx, local_def(id));\n-    let mut ty_trait_refs: Vec<@ty::TraitRef> = Vec::new();\n+    let mut ty_trait_refs: Vec<Rc<ty::TraitRef>> = Vec::new();\n     let mut bounds = ty::EmptyBuiltinBounds();\n     for ast_trait_ref in ast_trait_refs.iter() {\n         let trait_def_id = ty::trait_ref_to_def_id(ccx.tcx, ast_trait_ref);\n@@ -434,7 +434,7 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n         }\n     }\n \n-    tcx.supertraits.borrow_mut().insert(local_def(id), @ty_trait_refs);\n+    tcx.supertraits.borrow_mut().insert(local_def(id), Rc::new(ty_trait_refs));\n     bounds\n }\n \n@@ -489,12 +489,12 @@ fn convert_methods(ccx: &CrateCtxt,\n         let num_rcvr_ty_params = rcvr_ty_generics.type_param_defs().len();\n         let m_ty_generics = ty_generics_for_fn_or_method(ccx, &m.generics,\n                                                          num_rcvr_ty_params);\n-        let mty = @ty_of_method(ccx,\n-                                container,\n-                                *m,\n-                                untransformed_rcvr_ty,\n-                                rcvr_ast_generics,\n-                                rcvr_visibility);\n+        let mty = Rc::new(ty_of_method(ccx,\n+                                       container,\n+                                       *m,\n+                                       untransformed_rcvr_ty,\n+                                       rcvr_ast_generics,\n+                                       rcvr_visibility));\n         let fty = ty::mk_bare_fn(tcx, mty.fty.clone());\n         debug!(\"method {} (id {}) has type {}\",\n                 m.ident.repr(ccx.tcx),\n@@ -726,7 +726,7 @@ pub fn convert_struct(ccx: &CrateCtxt,\n         result\n     }).collect();\n \n-    tcx.struct_fields.borrow_mut().insert(local_def(id), @field_tys);\n+    tcx.struct_fields.borrow_mut().insert(local_def(id), Rc::new(field_tys));\n \n     let super_struct = match struct_def.super_struct {\n         Some(t) => match t.node {\n@@ -813,8 +813,7 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: &ast::ForeignItem) {\n \n pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n                              ast_trait_ref: &ast::TraitRef,\n-                             self_ty: ty::t) -> @ty::TraitRef\n-{\n+                             self_ty: ty::t) -> Rc<ty::TraitRef> {\n     /*!\n      * Instantiates the path for the given trait reference, assuming that\n      * it's bound to a valid trait type. Returns the def_id for the defining\n@@ -831,8 +830,8 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n                     ccx, &rscope, trait_did, Some(self_ty), &ast_trait_ref.path);\n \n             ccx.tcx.trait_refs.borrow_mut().insert(ast_trait_ref.ref_id,\n-                                                   trait_ref);\n-            return trait_ref;\n+                                                   trait_ref.clone());\n+            trait_ref\n         }\n         _ => {\n             ccx.tcx.sess.span_fatal(\n@@ -843,7 +842,7 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n     }\n }\n \n-fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::DefId) -> @ty::TraitDef {\n+fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::DefId) -> Rc<ty::TraitDef> {\n     if trait_id.krate != ast::LOCAL_CRATE {\n         return ty::lookup_trait_def(ccx.tcx, trait_id)\n     }\n@@ -855,11 +854,11 @@ fn get_trait_def(ccx: &CrateCtxt, trait_id: ast::DefId) -> @ty::TraitDef {\n     }\n }\n \n-pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> @ty::TraitDef {\n+pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> Rc<ty::TraitDef> {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n     match tcx.trait_defs.borrow().find(&def_id) {\n-        Some(&def) => return def,\n+        Some(def) => return def.clone(),\n         _ => {}\n     }\n \n@@ -872,13 +871,16 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> @ty::TraitDef {\n                                             it.id,\n                                             it.span,\n                                             supertraits.as_slice());\n-            let trait_ref = @ty::TraitRef {def_id: def_id,\n-                                           substs: substs};\n-            let trait_def = @ty::TraitDef {generics: ty_generics,\n-                                           bounds: bounds,\n-                                           trait_ref: trait_ref};\n-            tcx.trait_defs.borrow_mut().insert(def_id, trait_def);\n-            return trait_def;\n+            let trait_def = Rc::new(ty::TraitDef {\n+                generics: ty_generics,\n+                bounds: bounds,\n+                trait_ref: Rc::new(ty::TraitRef {\n+                    def_id: def_id,\n+                    substs: substs\n+                })\n+            });\n+            tcx.trait_defs.borrow_mut().insert(def_id, trait_def.clone());\n+            trait_def\n         }\n         ref s => {\n             tcx.sess.span_bug("}, {"sha": "e921674ad83fd7ce4fb756be588a86136d1527ac", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -195,7 +195,7 @@ impl<'f> Coerce<'f> {\n     }\n \n     pub fn subtype(&self, a: ty::t, b: ty::t) -> CoerceResult {\n-        match Sub(*self.get_ref()).tys(a, b) {\n+        match Sub(self.get_ref().clone()).tys(a, b) {\n             Ok(_) => Ok(None),         // No coercion required.\n             Err(ref e) => Err(*e)\n         }\n@@ -232,8 +232,9 @@ impl<'f> Coerce<'f> {\n         // to type check, we will construct the type that `&M*expr` would\n         // yield.\n \n-        let sub = Sub(*self.get_ref());\n-        let r_borrow = self.get_ref().infcx.next_region_var(Coercion(self.get_ref().trace));\n+        let sub = Sub(self.get_ref().clone());\n+        let coercion = Coercion(self.get_ref().trace.clone());\n+        let r_borrow = self.get_ref().infcx.next_region_var(coercion);\n \n         let inner_ty = match *sty_a {\n             ty::ty_box(typ) | ty::ty_uniq(typ) => typ,\n@@ -269,7 +270,8 @@ impl<'f> Coerce<'f> {\n             }\n         };\n \n-        let r_a = self.get_ref().infcx.next_region_var(Coercion(self.get_ref().trace));\n+        let coercion = Coercion(self.get_ref().trace.clone());\n+        let r_a = self.get_ref().infcx.next_region_var(coercion);\n         let a_borrowed = ty::mk_str(self.get_ref().infcx.tcx, VstoreSlice(r_a));\n         if_ok!(self.subtype(a_borrowed, b));\n         Ok(Some(AutoDerefRef(AutoDerefRef {\n@@ -288,8 +290,9 @@ impl<'f> Coerce<'f> {\n                a.inf_str(self.get_ref().infcx), sty_a,\n                b.inf_str(self.get_ref().infcx));\n \n-        let sub = Sub(*self.get_ref());\n-        let r_borrow = self.get_ref().infcx.next_region_var(Coercion(self.get_ref().trace));\n+        let sub = Sub(self.get_ref().clone());\n+        let coercion = Coercion(self.get_ref().trace.clone());\n+        let r_borrow = self.get_ref().infcx.next_region_var(coercion);\n         let ty_inner = match *sty_a {\n             ty::ty_uniq(t) | ty::ty_ptr(ty::mt{ty: t, ..}) |\n             ty::ty_rptr(_, ty::mt{ty: t, ..}) => match ty::get(t).sty {\n@@ -324,7 +327,8 @@ impl<'f> Coerce<'f> {\n                b.inf_str(self.get_ref().infcx));\n \n         let tcx = self.get_ref().infcx.tcx;\n-        let r_a = self.get_ref().infcx.next_region_var(Coercion(self.get_ref().trace));\n+        let coercion = Coercion(self.get_ref().trace.clone());\n+        let r_a = self.get_ref().infcx.next_region_var(coercion);\n \n         let a_borrowed = match *sty_a {\n             ty::ty_trait(~ty::TyTrait { def_id, ref substs, bounds, .. }) => {"}, {"sha": "54cf6524664c507fd324210d6bf359af5005fb70", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -324,6 +324,7 @@ pub trait Combine {\n     }\n }\n \n+#[deriving(Clone)]\n pub struct CombineFields<'a> {\n     pub infcx: &'a InferCtxt<'a>,\n     pub a_is_expected: bool,"}, {"sha": "a5d41b15d5d312607966be95500506c1adcb4feb", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -76,6 +76,7 @@ use middle::typeck::infer::region_inference::ProcessedErrors;\n use middle::typeck::infer::region_inference::SameRegions;\n use std::cell::{Cell, RefCell};\n use std::char::from_u32;\n+use std::rc::Rc;\n use std::strbuf::StrBuf;\n use syntax::ast;\n use syntax::ast_map;\n@@ -158,7 +159,7 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n         let p_errors = self.process_errors(errors);\n         let errors = if p_errors.is_empty() { errors } else { &p_errors };\n         for error in errors.iter() {\n-            match *error {\n+            match error.clone() {\n                 ConcreteFailure(origin, sub, sup) => {\n                     self.report_concrete_failure(origin, sub, sup);\n                 }\n@@ -206,7 +207,7 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n         let mut same_regions = Vec::new();\n         let mut processed_errors = Vec::new();\n         for error in errors.iter() {\n-            match *error {\n+            match error.clone() {\n                 ConcreteFailure(origin, sub, sup) => {\n                     debug!(\"processing ConcreteFailure\")\n                     let trace = match origin {\n@@ -661,10 +662,10 @@ impl<'a> ErrorReporting for InferCtxt<'a> {\n                                same_regions: &[SameRegions]) {\n         self.give_suggestion(same_regions);\n         for vo in var_origins.iter() {\n-            self.report_inference_failure(*vo);\n+            self.report_inference_failure(vo.clone());\n         }\n-        for &(trace, terr) in trace_origins.iter() {\n-            self.report_type_error(trace, &terr);\n+        for &(ref trace, terr) in trace_origins.iter() {\n+            self.report_type_error(trace.clone(), &terr);\n         }\n     }\n \n@@ -1391,12 +1392,12 @@ impl Resolvable for ty::t {\n     }\n }\n \n-impl Resolvable for @ty::TraitRef {\n-    fn resolve(&self, infcx: &InferCtxt) -> @ty::TraitRef {\n-        @infcx.resolve_type_vars_in_trait_ref_if_possible(*self)\n+impl Resolvable for Rc<ty::TraitRef> {\n+    fn resolve(&self, infcx: &InferCtxt) -> Rc<ty::TraitRef> {\n+        Rc::new(infcx.resolve_type_vars_in_trait_ref_if_possible(&**self))\n     }\n     fn contains_error(&self) -> bool {\n-        ty::trait_ref_contains_error(*self)\n+        ty::trait_ref_contains_error(&**self)\n     }\n }\n "}, {"sha": "32bc7eedf2fcf3141a55b22e5739ef2680b29486", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -38,11 +38,11 @@ impl<'f> Combine for Glb<'f> {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.get_ref().infcx }\n     fn tag(&self) -> ~str { \"glb\".to_owned() }\n     fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n-    fn trace(&self) -> TypeTrace { self.get_ref().trace }\n+    fn trace(&self) -> TypeTrace { self.get_ref().trace.clone() }\n \n-    fn sub<'a>(&'a self) -> Sub<'a> { Sub(*self.get_ref()) }\n-    fn lub<'a>(&'a self) -> Lub<'a> { Lub(*self.get_ref()) }\n-    fn glb<'a>(&'a self) -> Glb<'a> { Glb(*self.get_ref()) }\n+    fn sub<'a>(&'a self) -> Sub<'a> { Sub(self.get_ref().clone()) }\n+    fn lub<'a>(&'a self) -> Lub<'a> { Lub(self.get_ref().clone()) }\n+    fn glb<'a>(&'a self) -> Glb<'a> { Glb(self.get_ref().clone()) }\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n         let tcx = self.get_ref().infcx.tcx;\n@@ -78,7 +78,7 @@ impl<'f> Combine for Glb<'f> {\n     }\n \n     fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n-        Lub(*self.get_ref()).tys(a, b)\n+        self.lub().tys(a, b)\n     }\n \n     fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<FnStyle> {\n@@ -108,12 +108,12 @@ impl<'f> Combine for Glb<'f> {\n                a.inf_str(self.get_ref().infcx),\n                b.inf_str(self.get_ref().infcx));\n \n-        Ok(self.get_ref().infcx.region_vars.glb_regions(Subtype(self.get_ref().trace), a, b))\n+        Ok(self.get_ref().infcx.region_vars.glb_regions(Subtype(self.trace()), a, b))\n     }\n \n     fn contraregions(&self, a: ty::Region, b: ty::Region)\n                     -> cres<ty::Region> {\n-        Lub(*self.get_ref()).regions(a, b)\n+        self.lub().regions(a, b)\n     }\n \n     fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n@@ -137,11 +137,11 @@ impl<'f> Combine for Glb<'f> {\n         // Instantiate each bound region with a fresh region variable.\n         let (a_with_fresh, a_map) =\n             self.get_ref().infcx.replace_late_bound_regions_with_fresh_regions(\n-                self.get_ref().trace, a);\n+                self.trace(), a);\n         let a_vars = var_ids(self, &a_map);\n         let (b_with_fresh, b_map) =\n             self.get_ref().infcx.replace_late_bound_regions_with_fresh_regions(\n-                self.get_ref().trace, b);\n+                self.trace(), b);\n         let b_vars = var_ids(self, &b_map);\n \n         // Collect constraints."}, {"sha": "ebfb17a887633a646d11ee65cb3584fe71f5f0e4", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -47,26 +47,26 @@ use util::common::indenter;\n \n use collections::HashMap;\n \n-pub trait LatticeValue {\n-    fn sub(cf: &CombineFields, a: &Self, b: &Self) -> ures;\n-    fn lub(cf: &CombineFields, a: &Self, b: &Self) -> cres<Self>;\n-    fn glb(cf: &CombineFields, a: &Self, b: &Self) -> cres<Self>;\n+trait LatticeValue {\n+    fn sub(cf: CombineFields, a: &Self, b: &Self) -> ures;\n+    fn lub(cf: CombineFields, a: &Self, b: &Self) -> cres<Self>;\n+    fn glb(cf: CombineFields, a: &Self, b: &Self) -> cres<Self>;\n }\n \n pub type LatticeOp<'a, T> =\n-    |cf: &CombineFields, a: &T, b: &T|: 'a -> cres<T>;\n+    |cf: CombineFields, a: &T, b: &T|: 'a -> cres<T>;\n \n impl LatticeValue for ty::t {\n-    fn sub(cf: &CombineFields, a: &ty::t, b: &ty::t) -> ures {\n-        Sub(*cf).tys(*a, *b).to_ures()\n+    fn sub(cf: CombineFields, a: &ty::t, b: &ty::t) -> ures {\n+        Sub(cf).tys(*a, *b).to_ures()\n     }\n \n-    fn lub(cf: &CombineFields, a: &ty::t, b: &ty::t) -> cres<ty::t> {\n-        Lub(*cf).tys(*a, *b)\n+    fn lub(cf: CombineFields, a: &ty::t, b: &ty::t) -> cres<ty::t> {\n+        Lub(cf).tys(*a, *b)\n     }\n \n-    fn glb(cf: &CombineFields, a: &ty::t, b: &ty::t) -> cres<ty::t> {\n-        Glb(*cf).tys(*a, *b)\n+    fn glb(cf: CombineFields, a: &ty::t, b: &ty::t) -> cres<ty::t> {\n+        Glb(cf).tys(*a, *b)\n     }\n }\n \n@@ -142,7 +142,7 @@ impl<'f> CombineFieldsLatticeMethods for CombineFields<'f> {\n         match (&a_bounds.ub, &b_bounds.lb) {\n             (&Some(ref a_ub), &Some(ref b_lb)) => {\n                 let r = self.infcx.try(\n-                    || LatticeValue::sub(self, a_ub, b_lb));\n+                    || LatticeValue::sub(self.clone(), a_ub, b_lb));\n                 match r {\n                     Ok(()) => {\n                         return Ok(());\n@@ -232,7 +232,7 @@ impl<'f> CombineFieldsLatticeMethods for CombineFields<'f> {\n             (&Some(_),       &None) => Ok((*a).clone()),\n             (&None,          &Some(_)) => Ok((*b).clone()),\n             (&Some(ref v_a), &Some(ref v_b)) => {\n-                lattice_op(self, v_a, v_b).and_then(|v| Ok(Some(v)))\n+                lattice_op(self.clone(), v_a, v_b).and_then(|v| Ok(Some(v)))\n             }\n         }\n     }\n@@ -314,7 +314,7 @@ impl<'f> CombineFieldsLatticeMethods for CombineFields<'f> {\n                 uok()\n             }\n             (&Some(ref t_a), &Some(ref t_b)) => {\n-                LatticeValue::sub(self, t_a, t_b)\n+                LatticeValue::sub(self.clone(), t_a, t_b)\n             }\n         }\n     }\n@@ -337,7 +337,7 @@ pub trait TyLatticeDir {\n }\n \n impl<'f> LatticeDir for Lub<'f> {\n-    fn combine_fields<'a>(&'a self) -> CombineFields<'a> { *self.get_ref() }\n+    fn combine_fields<'a>(&'a self) -> CombineFields<'a> { self.get_ref().clone() }\n     fn bnd<T:Clone>(&self, b: &Bounds<T>) -> Option<T> { b.ub.clone() }\n     fn with_bnd<T:Clone>(&self, b: &Bounds<T>, t: T) -> Bounds<T> {\n         Bounds { ub: Some(t), ..(*b).clone() }\n@@ -351,7 +351,7 @@ impl<'f> TyLatticeDir for Lub<'f> {\n }\n \n impl<'f> LatticeDir for Glb<'f> {\n-    fn combine_fields<'a>(&'a self) -> CombineFields<'a> { *self.get_ref() }\n+    fn combine_fields<'a>(&'a self) -> CombineFields<'a> { self.get_ref().clone() }\n     fn bnd<T:Clone>(&self, b: &Bounds<T>) -> Option<T> { b.lb.clone() }\n     fn with_bnd<T:Clone>(&self, b: &Bounds<T>, t: T) -> Bounds<T> {\n         Bounds { lb: Some(t), ..(*b).clone() }"}, {"sha": "d09bbc4253ba93a81ed340ca55492d4145e22a67", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -37,11 +37,11 @@ impl<'f> Combine for Lub<'f> {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.get_ref().infcx }\n     fn tag(&self) -> ~str { \"lub\".to_owned() }\n     fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n-    fn trace(&self) -> TypeTrace { self.get_ref().trace }\n+    fn trace(&self) -> TypeTrace { self.get_ref().trace.clone() }\n \n-    fn sub<'a>(&'a self) -> Sub<'a> { Sub(*self.get_ref()) }\n-    fn lub<'a>(&'a self) -> Lub<'a> { Lub(*self.get_ref()) }\n-    fn glb<'a>(&'a self) -> Glb<'a> { Glb(*self.get_ref()) }\n+    fn sub<'a>(&'a self) -> Sub<'a> { Sub(self.get_ref().clone()) }\n+    fn lub<'a>(&'a self) -> Lub<'a> { Lub(self.get_ref().clone()) }\n+    fn glb<'a>(&'a self) -> Glb<'a> { Glb(self.get_ref().clone()) }\n \n     fn mts(&self, a: &ty::mt, b: &ty::mt) -> cres<ty::mt> {\n         let tcx = self.get_ref().infcx.tcx;\n@@ -72,7 +72,7 @@ impl<'f> Combine for Lub<'f> {\n     }\n \n     fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n-        Glb(*self.get_ref()).tys(a, b)\n+        self.glb().tys(a, b)\n     }\n \n     fn fn_styles(&self, a: FnStyle, b: FnStyle) -> cres<FnStyle> {\n@@ -98,7 +98,7 @@ impl<'f> Combine for Lub<'f> {\n \n     fn contraregions(&self, a: ty::Region, b: ty::Region)\n                     -> cres<ty::Region> {\n-        return Glb(*self.get_ref()).regions(a, b);\n+        self.glb().regions(a, b)\n     }\n \n     fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n@@ -107,7 +107,7 @@ impl<'f> Combine for Lub<'f> {\n                a.inf_str(self.get_ref().infcx),\n                b.inf_str(self.get_ref().infcx));\n \n-        Ok(self.get_ref().infcx.region_vars.lub_regions(Subtype(self.get_ref().trace), a, b))\n+        Ok(self.get_ref().infcx.region_vars.lub_regions(Subtype(self.trace()), a, b))\n     }\n \n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n@@ -123,10 +123,10 @@ impl<'f> Combine for Lub<'f> {\n         // Instantiate each bound region with a fresh region variable.\n         let (a_with_fresh, a_map) =\n             self.get_ref().infcx.replace_late_bound_regions_with_fresh_regions(\n-                self.get_ref().trace, a);\n+                self.trace(), a);\n         let (b_with_fresh, _) =\n             self.get_ref().infcx.replace_late_bound_regions_with_fresh_regions(\n-                self.get_ref().trace, b);\n+                self.trace(), b);\n \n         // Collect constraints.\n         let sig0 = if_ok!(super_fn_sigs(self, &a_with_fresh, &b_with_fresh));"}, {"sha": "258f286d8f02542f237e21d6faa03514379cc064", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -38,7 +38,7 @@ use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::unify::{ValsAndBindings, Root};\n use middle::typeck::infer::error_reporting::ErrorReporting;\n use std::cell::{Cell, RefCell};\n-use std::result;\n+use std::rc::Rc;\n use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n use syntax::codemap;\n@@ -129,7 +129,7 @@ pub enum TypeOrigin {\n #[deriving(Clone)]\n pub enum ValuePairs {\n     Types(ty::expected_found<ty::t>),\n-    TraitRefs(ty::expected_found<@ty::TraitRef>),\n+    TraitRefs(ty::expected_found<Rc<ty::TraitRef>>),\n }\n \n /// The trace designates the path through inference that we took to\n@@ -301,7 +301,7 @@ pub fn common_supertype(cx: &InferCtxt,\n         values: Types(expected_found(a_is_expected, a, b))\n     };\n \n-    let result = cx.commit(|| cx.lub(a_is_expected, trace).tys(a, b));\n+    let result = cx.commit(|| cx.lub(a_is_expected, trace.clone()).tys(a, b));\n     match result {\n         Ok(t) => t,\n         Err(ref err) => {\n@@ -375,8 +375,8 @@ pub fn mk_eqty(cx: &InferCtxt,\n pub fn mk_sub_trait_refs(cx: &InferCtxt,\n                          a_is_expected: bool,\n                          origin: TypeOrigin,\n-                         a: @ty::TraitRef,\n-                         b: @ty::TraitRef)\n+                         a: Rc<ty::TraitRef>,\n+                         b: Rc<ty::TraitRef>)\n     -> ures\n {\n     debug!(\"mk_sub_trait_refs({} <: {})\",\n@@ -385,10 +385,10 @@ pub fn mk_sub_trait_refs(cx: &InferCtxt,\n         cx.commit(|| {\n             let trace = TypeTrace {\n                 origin: origin,\n-                values: TraitRefs(expected_found(a_is_expected, a, b))\n+                values: TraitRefs(expected_found(a_is_expected, a.clone(), b.clone()))\n             };\n             let suber = cx.sub(a_is_expected, trace);\n-            suber.trait_refs(a, b)\n+            suber.trait_refs(&*a, &*b)\n         })\n     }).to_ures()\n }\n@@ -666,8 +666,8 @@ impl<'a> InferCtxt<'a> {\n \n     pub fn resolve_type_vars_if_possible(&self, typ: ty::t) -> ty::t {\n         match resolve_type(self, typ, resolve_nested_tvar | resolve_ivar) {\n-          result::Ok(new_type) => new_type,\n-          result::Err(_) => typ\n+            Ok(new_type) => new_type,\n+            Err(_) => typ\n         }\n     }\n \n@@ -854,7 +854,7 @@ impl Repr for TypeOrigin {\n impl SubregionOrigin {\n     pub fn span(&self) -> Span {\n         match *self {\n-            Subtype(a) => a.span(),\n+            Subtype(ref a) => a.span(),\n             InfStackClosure(a) => a,\n             InvokeClosure(a) => a,\n             DerefPointer(a) => a,\n@@ -877,7 +877,7 @@ impl SubregionOrigin {\n impl Repr for SubregionOrigin {\n     fn repr(&self, tcx: &ty::ctxt) -> ~str {\n         match *self {\n-            Subtype(a) => format!(\"Subtype({})\", a.repr(tcx)),\n+            Subtype(ref a) => format!(\"Subtype({})\", a.repr(tcx)),\n             InfStackClosure(a) => format!(\"InfStackClosure({})\", a.repr(tcx)),\n             InvokeClosure(a) => format!(\"InvokeClosure({})\", a.repr(tcx)),\n             DerefPointer(a) => format!(\"DerefPointer({})\", a.repr(tcx)),\n@@ -907,7 +907,7 @@ impl RegionVariableOrigin {\n             AddrOfRegion(a) => a,\n             AddrOfSlice(a) => a,\n             Autoref(a) => a,\n-            Coercion(a) => a.span(),\n+            Coercion(ref a) => a.span(),\n             EarlyBoundRegion(a, _) => a,\n             LateBoundRegion(a, _) => a,\n             BoundRegionInFnType(a, _) => a,\n@@ -925,7 +925,7 @@ impl Repr for RegionVariableOrigin {\n             AddrOfRegion(a) => format!(\"AddrOfRegion({})\", a.repr(tcx)),\n             AddrOfSlice(a) => format!(\"AddrOfSlice({})\", a.repr(tcx)),\n             Autoref(a) => format!(\"Autoref({})\", a.repr(tcx)),\n-            Coercion(a) => format!(\"Coercion({})\", a.repr(tcx)),\n+            Coercion(ref a) => format!(\"Coercion({})\", a.repr(tcx)),\n             EarlyBoundRegion(a, b) => format!(\"EarlyBoundRegion({},{})\",\n                                               a.repr(tcx), b.repr(tcx)),\n             LateBoundRegion(a, b) => format!(\"LateBoundRegion({},{})\","}, {"sha": "bb6d479870b91293c41cbae41980d2728560f177", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -212,7 +212,7 @@ impl<'a> RegionVarBindings<'a> {\n \n     pub fn new_region_var(&self, origin: RegionVariableOrigin) -> RegionVid {\n         let id = self.num_vars();\n-        self.var_origins.borrow_mut().push(origin);\n+        self.var_origins.borrow_mut().push(origin.clone());\n         let vid = RegionVid { id: id };\n         if self.in_snapshot() {\n             self.undo_log.borrow_mut().push(AddVar(vid));\n@@ -330,9 +330,9 @@ impl<'a> RegionVarBindings<'a> {\n \n             _ => {\n                 self.combine_vars(\n-                    Lub, a, b, origin,\n+                    Lub, a, b, origin.clone(),\n                     |this, old_r, new_r|\n-                    this.make_subregion(origin, old_r, new_r))\n+                    this.make_subregion(origin.clone(), old_r, new_r))\n             }\n         }\n     }\n@@ -354,9 +354,9 @@ impl<'a> RegionVarBindings<'a> {\n \n             _ => {\n                 self.combine_vars(\n-                    Glb, a, b, origin,\n+                    Glb, a, b, origin.clone(),\n                     |this, old_r, new_r|\n-                    this.make_subregion(origin, new_r, old_r))\n+                    this.make_subregion(origin.clone(), new_r, old_r))\n             }\n         }\n     }\n@@ -1150,10 +1150,10 @@ impl<'a> RegionVarBindings<'a> {\n                 if !self.is_subregion_of(lower_bound.region,\n                                          upper_bound.region) {\n                     errors.push(SubSupConflict(\n-                        *self.var_origins.borrow().get(node_idx.to_uint()),\n-                        lower_bound.origin,\n+                        self.var_origins.borrow().get(node_idx.to_uint()).clone(),\n+                        lower_bound.origin.clone(),\n                         lower_bound.region,\n-                        upper_bound.origin,\n+                        upper_bound.origin.clone(),\n                         upper_bound.region));\n                     return;\n                 }\n@@ -1200,10 +1200,10 @@ impl<'a> RegionVarBindings<'a> {\n                   Ok(_) => {}\n                   Err(_) => {\n                     errors.push(SupSupConflict(\n-                        *self.var_origins.borrow().get(node_idx.to_uint()),\n-                        upper_bound_1.origin,\n+                        self.var_origins.borrow().get(node_idx.to_uint()).clone(),\n+                        upper_bound_1.origin.clone(),\n                         upper_bound_1.region,\n-                        upper_bound_2.origin,\n+                        upper_bound_2.origin.clone(),\n                         upper_bound_2.region));\n                     return;\n                   }"}, {"sha": "2c8acd0573b74f5945f675705e1859fb1c5929fc", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -37,23 +37,25 @@ impl<'f> Combine for Sub<'f> {\n     fn infcx<'a>(&'a self) -> &'a InferCtxt<'a> { self.get_ref().infcx }\n     fn tag(&self) -> ~str { \"sub\".to_owned() }\n     fn a_is_expected(&self) -> bool { self.get_ref().a_is_expected }\n-    fn trace(&self) -> TypeTrace { self.get_ref().trace }\n+    fn trace(&self) -> TypeTrace { self.get_ref().trace.clone() }\n \n-    fn sub<'a>(&'a self) -> Sub<'a> { Sub(*self.get_ref()) }\n-    fn lub<'a>(&'a self) -> Lub<'a> { Lub(*self.get_ref()) }\n-    fn glb<'a>(&'a self) -> Glb<'a> { Glb(*self.get_ref()) }\n+    fn sub<'a>(&'a self) -> Sub<'a> { Sub(self.get_ref().clone()) }\n+    fn lub<'a>(&'a self) -> Lub<'a> { Lub(self.get_ref().clone()) }\n+    fn glb<'a>(&'a self) -> Glb<'a> { Glb(self.get_ref().clone()) }\n \n     fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n         let opp = CombineFields {\n-            a_is_expected: !self.get_ref().a_is_expected,.. *self.get_ref()\n+            a_is_expected: !self.get_ref().a_is_expected,\n+            ..self.get_ref().clone()\n         };\n         Sub(opp).tys(b, a)\n     }\n \n     fn contraregions(&self, a: ty::Region, b: ty::Region)\n                     -> cres<ty::Region> {\n         let opp = CombineFields {\n-            a_is_expected: !self.get_ref().a_is_expected,.. *self.get_ref()\n+            a_is_expected: !self.get_ref().a_is_expected,\n+            ..self.get_ref().clone()\n         };\n         Sub(opp).regions(b, a)\n     }\n@@ -63,7 +65,7 @@ impl<'f> Combine for Sub<'f> {\n                self.tag(),\n                a.inf_str(self.get_ref().infcx),\n                b.inf_str(self.get_ref().infcx));\n-        self.get_ref().infcx.region_vars.make_subregion(Subtype(self.get_ref().trace), a, b);\n+        self.get_ref().infcx.region_vars.make_subregion(Subtype(self.trace()), a, b);\n         Ok(a)\n     }\n \n@@ -167,7 +169,7 @@ impl<'f> Combine for Sub<'f> {\n         // region variable.\n         let (a_sig, _) =\n             self.get_ref().infcx.replace_late_bound_regions_with_fresh_regions(\n-                self.get_ref().trace, a);\n+                self.trace(), a);\n \n         // Second, we instantiate each bound region in the supertype with a\n         // fresh concrete region."}, {"sha": "9e7c221d3c55f7b3be4357de677a73d6cd9a0ab9", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -197,6 +197,7 @@ use arena;\n use arena::Arena;\n use middle::ty;\n use std::fmt;\n+use std::rc::Rc;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util;\n@@ -254,7 +255,7 @@ struct TermsContext<'a> {\n     tcx: &'a ty::ctxt,\n     arena: &'a Arena,\n \n-    empty_variances: @ty::ItemVariances,\n+    empty_variances: Rc<ty::ItemVariances>,\n \n     // Maps from the node id of a type/generic parameter to the\n     // corresponding inferred index.\n@@ -286,9 +287,11 @@ fn determine_parameters_to_be_inferred<'a>(tcx: &'a ty::ctxt,\n \n         // cache and share the variance struct used for items with\n         // no type/region parameters\n-        empty_variances: @ty::ItemVariances { self_param: None,\n-                                              type_params: OwnedSlice::empty(),\n-                                              region_params: OwnedSlice::empty() }\n+        empty_variances: Rc::new(ty::ItemVariances {\n+            self_param: None,\n+            type_params: OwnedSlice::empty(),\n+            region_params: OwnedSlice::empty()\n+        })\n     };\n \n     visit::walk_crate(&mut terms_cx, krate, ());\n@@ -362,7 +365,7 @@ impl<'a> Visitor<()> for TermsContext<'a> {\n                 if self.num_inferred() == inferreds_on_entry {\n                     let newly_added = self.tcx.item_variance_map.borrow_mut().insert(\n                         ast_util::local_def(item.id),\n-                        self.empty_variances);\n+                        self.empty_variances.clone());\n                     assert!(newly_added);\n                 }\n \n@@ -1016,7 +1019,7 @@ impl<'a> SolveContext<'a> {\n             }\n \n             let newly_added = tcx.item_variance_map.borrow_mut()\n-                                 .insert(item_def_id, @item_variances);\n+                                 .insert(item_def_id, Rc::new(item_variances));\n             assert!(newly_added);\n         }\n     }"}, {"sha": "316b5c6a45a6f15c86929cae5828890edb4ab4a5", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -22,6 +22,7 @@ use middle::ty::{ty_uniq, ty_trait, ty_int, ty_uint, ty_infer};\n use middle::ty;\n use middle::typeck;\n \n+use std::rc::Rc;\n use std::strbuf::StrBuf;\n use syntax::abi;\n use syntax::ast_map;\n@@ -497,6 +498,12 @@ impl Repr for () {\n     }\n }\n \n+impl<T:Repr> Repr for Rc<T> {\n+    fn repr(&self, tcx: &ctxt) -> ~str {\n+        (&**self).repr(tcx)\n+    }\n+}\n+\n impl<T:Repr> Repr for @T {\n     fn repr(&self, tcx: &ctxt) -> ~str {\n         (&**self).repr(tcx)\n@@ -887,7 +894,7 @@ impl Repr for Span {\n     }\n }\n \n-impl<A:UserString> UserString for @A {\n+impl<A:UserString> UserString for Rc<A> {\n     fn user_string(&self, tcx: &ctxt) -> ~str {\n         let this: &A = &**self;\n         this.user_string(tcx)"}, {"sha": "693407b854fb923e9a3038333071d435cbaabd4c", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=57aa0eb0aa0f4fc502ef8b1d3543cb02c2092932", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::mem;\n+use std::slice;\n use std::vec;\n \n /// A vector type optimized for cases where the size is almost always 0 or 1\n@@ -61,6 +62,14 @@ impl<T> SmallVector<T> {\n         SmallVector { repr: Many(vs) }\n     }\n \n+    pub fn as_slice<'a>(&'a self) -> &'a [T] {\n+        match self.repr {\n+            Zero => &[],\n+            One(ref v) => slice::ref_slice(v),\n+            Many(ref vs) => vs.as_slice()\n+        }\n+    }\n+\n     pub fn push(&mut self, v: T) {\n         match self.repr {\n             Zero => self.repr = One(v),"}]}