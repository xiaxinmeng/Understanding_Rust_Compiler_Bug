{"sha": "fc4b35612550d833cefcd586cb13ebc0dc5a51e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjNGIzNTYxMjU1MGQ4MzNjZWZjZDU4NmNiMTNlYmMwZGM1YTUxZTE=", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2016-05-26T05:32:15Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2016-06-02T13:34:00Z"}, "message": "Fix rwlock successfully acquiring a write lock after a read lock", "tree": {"sha": "85e4c23d9928c4c6512d726acd1c719535701ef5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85e4c23d9928c4c6512d726acd1c719535701ef5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc4b35612550d833cefcd586cb13ebc0dc5a51e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc4b35612550d833cefcd586cb13ebc0dc5a51e1", "html_url": "https://github.com/rust-lang/rust/commit/fc4b35612550d833cefcd586cb13ebc0dc5a51e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc4b35612550d833cefcd586cb13ebc0dc5a51e1/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3c68a0fdf119a3b285c33c38f9f7eebd053c853", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3c68a0fdf119a3b285c33c38f9f7eebd053c853", "html_url": "https://github.com/rust-lang/rust/commit/f3c68a0fdf119a3b285c33c38f9f7eebd053c853"}], "stats": {"total": 39, "additions": 27, "deletions": 12}, "files": [{"sha": "fbd4e1d120817ebc21a0b5e4e08d2f8593ff02d2", "filename": "src/libstd/sys/unix/rwlock.rs", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fc4b35612550d833cefcd586cb13ebc0dc5a51e1/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc4b35612550d833cefcd586cb13ebc0dc5a51e1/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs?ref=fc4b35612550d833cefcd586cb13ebc0dc5a51e1", "patch": "@@ -10,10 +10,12 @@\n \n use libc;\n use cell::UnsafeCell;\n+use sync::atomic::{AtomicUsize, Ordering};\n \n pub struct RWLock {\n     inner: UnsafeCell<libc::pthread_rwlock_t>,\n     write_locked: UnsafeCell<bool>,\n+    num_readers: AtomicUsize,\n }\n \n unsafe impl Send for RWLock {}\n@@ -24,6 +26,7 @@ impl RWLock {\n         RWLock {\n             inner: UnsafeCell::new(libc::PTHREAD_RWLOCK_INITIALIZER),\n             write_locked: UnsafeCell::new(false),\n+            num_readers: AtomicUsize::new(0),\n         }\n     }\n     #[inline]\n@@ -54,23 +57,31 @@ impl RWLock {\n             panic!(\"rwlock read lock would result in deadlock\");\n         } else {\n             debug_assert_eq!(r, 0);\n+            self.num_readers.fetch_add(1, Ordering::Relaxed);\n         }\n     }\n     #[inline]\n     pub unsafe fn try_read(&self) -> bool {\n         let r = libc::pthread_rwlock_tryrdlock(self.inner.get());\n-        if r == 0 && *self.write_locked.get() {\n-            self.raw_unlock();\n-            false\n+        if r == 0 {\n+            if *self.write_locked.get() {\n+                self.raw_unlock();\n+                false\n+            } else {\n+                self.num_readers.fetch_add(1, Ordering::Relaxed);\n+                true\n+            }\n         } else {\n-            r == 0\n+            false\n         }\n     }\n     #[inline]\n     pub unsafe fn write(&self) {\n         let r = libc::pthread_rwlock_wrlock(self.inner.get());\n-        // see comments above for why we check for EDEADLK and write_locked\n-        if r == libc::EDEADLK || *self.write_locked.get() {\n+        // See comments above for why we check for EDEADLK and write_locked. We\n+        // also need to check that num_readers is 0.\n+        if r == libc::EDEADLK || *self.write_locked.get() ||\n+           self.num_readers.load(Ordering::Relaxed) != 0 {\n             if r == 0 {\n                 self.raw_unlock();\n             }\n@@ -83,12 +94,14 @@ impl RWLock {\n     #[inline]\n     pub unsafe fn try_write(&self) -> bool {\n         let r = libc::pthread_rwlock_trywrlock(self.inner.get());\n-        if r == 0 && *self.write_locked.get() {\n-            self.raw_unlock();\n-            false\n-        } else if r == 0 {\n-            *self.write_locked.get() = true;\n-            true\n+        if r == 0 {\n+            if *self.write_locked.get() || self.num_readers.load(Ordering::Relaxed) != 0 {\n+                self.raw_unlock();\n+                false\n+            } else {\n+                *self.write_locked.get() = true;\n+                true\n+            }\n         } else {\n             false\n         }\n@@ -101,10 +114,12 @@ impl RWLock {\n     #[inline]\n     pub unsafe fn read_unlock(&self) {\n         debug_assert!(!*self.write_locked.get());\n+        self.num_readers.fetch_sub(1, Ordering::Relaxed);\n         self.raw_unlock();\n     }\n     #[inline]\n     pub unsafe fn write_unlock(&self) {\n+        debug_assert_eq!(self.num_readers.load(Ordering::Relaxed), 0);\n         debug_assert!(*self.write_locked.get());\n         *self.write_locked.get() = false;\n         self.raw_unlock();"}]}