{"sha": "0046ed9462309896d6cef7208b2646c7437c8b21", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwNDZlZDk0NjIzMDk4OTZkNmNlZjcyMDhiMjY0NmM3NDM3YzhiMjE=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-12-10T21:47:54Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-12-11T02:45:01Z"}, "message": "Remove un-needed code for obsolete classes\n\nand rename \"class\" to \"struct\" everywhere possible (except local\nvars, I was too lazy for that) -- that is why this commit is so\nbig.\n\nNo review, just dead code removal and renaming.\n\nCloses #3515", "tree": {"sha": "e7e8da99bc671146ed000e331c4a7fded0a7423b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7e8da99bc671146ed000e331c4a7fded0a7423b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0046ed9462309896d6cef7208b2646c7437c8b21", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0046ed9462309896d6cef7208b2646c7437c8b21", "html_url": "https://github.com/rust-lang/rust/commit/0046ed9462309896d6cef7208b2646c7437c8b21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0046ed9462309896d6cef7208b2646c7437c8b21/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3fcdb7d6a758ac4ed1f27fcda77c372edaab4c09", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fcdb7d6a758ac4ed1f27fcda77c372edaab4c09", "html_url": "https://github.com/rust-lang/rust/commit/3fcdb7d6a758ac4ed1f27fcda77c372edaab4c09"}], "stats": {"total": 1060, "additions": 392, "deletions": 668}, "files": [{"sha": "69dcdc389d62a7c37f398436674fef8c2df0f51f", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -84,7 +84,7 @@ const tag_path_len: uint = 0x41u;\n const tag_path_elt_mod: uint = 0x42u;\n const tag_path_elt_name: uint = 0x43u;\n const tag_item_field: uint = 0x44u;\n-const tag_class_mut: uint = 0x45u;\n+const tag_struct_mut: uint = 0x45u;\n \n const tag_region_param: uint = 0x46u;\n const tag_mod_impl_trait: uint = 0x47u;"}, {"sha": "9dc4a01b7316d78478ae421ebf49e83db906d039", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -24,10 +24,9 @@ use common::*;\n use std::map::HashMap;\n use dvec::DVec;\n \n-export class_dtor;\n+export struct_dtor;\n export get_symbol;\n-export get_class_fields;\n-export get_class_method;\n+export get_struct_fields;\n export get_field_type;\n export get_type_param_count;\n export get_region_param;\n@@ -170,10 +169,10 @@ fn get_item_attrs(cstore: cstore::CStore,\n     decoder::get_item_attrs(cdata, def_id.node, f)\n }\n \n-fn get_class_fields(tcx: ty::ctxt, def: ast::def_id) -> ~[ty::field_ty] {\n+fn get_struct_fields(tcx: ty::ctxt, def: ast::def_id) -> ~[ty::field_ty] {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n-    decoder::get_class_fields(cstore.intr, cdata, def.node)\n+    decoder::get_struct_fields(cstore.intr, cdata, def.node)\n }\n \n fn get_type(tcx: ty::ctxt, def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n@@ -226,22 +225,11 @@ fn get_impl_method(cstore: cstore::CStore,\n     decoder::get_impl_method(cstore.intr, cdata, def.node, mname)\n }\n \n-/* Because classes use the trait format rather than the impl format\n-   for their methods (so that get_trait_methods can be reused to get\n-   class methods), classes require a slightly different version of\n-   get_impl_method. Sigh. */\n-fn get_class_method(cstore: cstore::CStore,\n-                    def: ast::def_id, mname: ast::ident)\n-    -> ast::def_id {\n-    let cdata = cstore::get_crate_data(cstore, def.crate);\n-    decoder::get_class_method(cstore.intr, cdata, def.node, mname)\n-}\n-\n /* If def names a class with a dtor, return it. Otherwise, return none. */\n-fn class_dtor(cstore: cstore::CStore, def: ast::def_id)\n+fn struct_dtor(cstore: cstore::CStore, def: ast::def_id)\n     -> Option<ast::def_id> {\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n-    decoder::class_dtor(cdata, def.node)\n+    decoder::struct_dtor(cdata, def.node)\n }\n // Local Variables:\n // mode: rust"}, {"sha": "110b151a651efc64d26f9d1cb19e8c281fa9b0cb", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 22, "deletions": 52, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -32,15 +32,14 @@ use syntax::parse::token::ident_interner;\n use hash::{Hash, HashUtil};\n use csearch::{ProvidedTraitMethodInfo, StaticMethodInfo};\n \n-export class_dtor;\n-export get_class_fields;\n+export struct_dtor;\n+export get_struct_fields;\n export get_symbol;\n export get_enum_variants;\n export get_type;\n export get_region_param;\n export get_type_param_count;\n export get_impl_traits;\n-export get_class_method;\n export get_impl_method;\n export get_static_methods_if_impl;\n export lookup_def;\n@@ -228,15 +227,15 @@ fn each_reexport(d: ebml::Doc, f: fn(ebml::Doc) -> bool) {\n     }\n }\n \n-fn field_mutability(d: ebml::Doc) -> ast::class_mutability {\n+fn field_mutability(d: ebml::Doc) -> ast::struct_mutability {\n     // Use maybe_get_doc in case it's a method\n     option::map_default(\n-        &reader::maybe_get_doc(d, tag_class_mut),\n-        ast::class_immutable,\n+        &reader::maybe_get_doc(d, tag_struct_mut),\n+        ast::struct_immutable,\n         |d| {\n             match reader::doc_as_u8(*d) as char {\n-              'm' => ast::class_mutable,\n-              _   => ast::class_immutable\n+              'm' => ast::struct_mutable,\n+              _   => ast::struct_immutable\n             }\n         })\n }\n@@ -338,7 +337,7 @@ fn item_to_def_like(item: ebml::Doc, did: ast::def_id, cnum: ast::crate_num)\n     let fam = item_family(item);\n     match fam {\n         Const     => dl_def(ast::def_const(did)),\n-        Struct    => dl_def(ast::def_class(did)),\n+        Struct    => dl_def(ast::def_struct(did)),\n         UnsafeFn  => dl_def(ast::def_fn(did, ast::unsafe_fn)),\n         Fn        => dl_def(ast::def_fn(did, ast::impure_fn)),\n         PureFn    => dl_def(ast::def_fn(did, ast::pure_fn)),\n@@ -419,34 +418,12 @@ fn get_impl_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n     found.get()\n }\n \n-fn get_class_method(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n-                    name: ast::ident) -> ast::def_id {\n-    let items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n-    let mut found = None;\n-    let cls_items = match maybe_find_item(id, items) {\n-      Some(it) => it,\n-      None => fail (fmt!(\"get_class_method: class id not found \\\n-                              when looking up method %s\", *intr.get(name)))\n-    };\n-    for reader::tagged_docs(cls_items, tag_item_trait_method) |mid| {\n-        let m_did = item_def_id(mid, cdata);\n-        if item_name(intr, mid) == name {\n-            found = Some(m_did);\n-        }\n-    }\n-    match found {\n-      Some(found) => found,\n-      None => fail (fmt!(\"get_class_method: no method named %s\",\n-                         *intr.get(name)))\n-    }\n-}\n-\n-fn class_dtor(cdata: cmd, id: ast::node_id) -> Option<ast::def_id> {\n+fn struct_dtor(cdata: cmd, id: ast::node_id) -> Option<ast::def_id> {\n     let items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n     let mut found = None;\n     let cls_items = match maybe_find_item(id, items) {\n             Some(it) => it,\n-            None     => fail (fmt!(\"class_dtor: class id not found \\\n+            None     => fail (fmt!(\"struct_dtor: class id not found \\\n               when looking up dtor for %d\", id))\n     };\n     for reader::tagged_docs(cls_items, tag_item_dtor) |doc| {\n@@ -905,15 +882,23 @@ fn get_item_attrs(cdata: cmd,\n     }\n }\n \n-// Helper function that gets either fields or methods\n-fn get_class_members(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n-                     p: fn(Family) -> bool) -> ~[ty::field_ty] {\n+pure fn family_to_visibility(family: Family) -> ast::visibility {\n+    match family {\n+      PublicField => ast::public,\n+      PrivateField => ast::private,\n+      InheritedField => ast::inherited,\n+      _ => fail\n+    }\n+}\n+\n+fn get_struct_fields(intr: @ident_interner, cdata: cmd, id: ast::node_id)\n+    -> ~[ty::field_ty] {\n     let data = cdata.data;\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n     for reader::tagged_docs(item, tag_item_field) |an_item| {\n        let f = item_family(an_item);\n-       if p(f) {\n+       if f == PublicField || f == PrivateField || f == InheritedField {\n           let name = item_name(intr, an_item);\n           let did = item_def_id(an_item, cdata);\n           let mt = field_mutability(an_item);\n@@ -924,21 +909,6 @@ fn get_class_members(intr: @ident_interner, cdata: cmd, id: ast::node_id,\n     result\n }\n \n-pure fn family_to_visibility(family: Family) -> ast::visibility {\n-    match family {\n-      PublicField => ast::public,\n-      PrivateField => ast::private,\n-      InheritedField => ast::inherited,\n-      _ => fail\n-    }\n-}\n-\n-fn get_class_fields(intr: @ident_interner, cdata: cmd, id: ast::node_id)\n-    -> ~[ty::field_ty] {\n-    get_class_members(intr, cdata, id, |f| f == PublicField\n-                      || f == PrivateField || f == InheritedField)\n-}\n-\n fn family_has_type_params(fam: Family) -> bool {\n     match fam {\n       Const | ForeignType | Mod | ForeignMod | PublicField | PrivateField"}, {"sha": "e2a4b8880c91ae6d24d8f1b147554ce5ee9c2aba", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 13, "deletions": 60, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -120,11 +120,11 @@ fn encode_region_param(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n     }\n }\n \n-fn encode_mutability(ebml_w: writer::Serializer, mt: class_mutability) {\n-    do ebml_w.wr_tag(tag_class_mut) {\n+fn encode_mutability(ebml_w: writer::Serializer, mt: struct_mutability) {\n+    do ebml_w.wr_tag(tag_struct_mut) {\n         let val = match mt {\n-          class_immutable => 'a',\n-          class_mutable => 'm'\n+          struct_immutable => 'a',\n+          struct_mutable => 'm'\n         };\n         ebml_w.writer.write(&[val as u8]);\n     }\n@@ -318,7 +318,7 @@ fn encode_info_for_mod(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n     // Encode info about all the module children.\n     for md.items.each |item| {\n         match item.node {\n-            item_impl(*) | item_class(*) => {\n+            item_impl(*) | item_struct(*) => {\n                 let (ident, did) = (item.ident, item.id);\n                 debug!(\"(encoding info for module) ... encoding impl %s \\\n                         (%?/%?), exported? %?\",\n@@ -412,11 +412,9 @@ fn encode_method_sort(ebml_w: writer::Serializer, sort: char) {\n }\n \n /* Returns an index of items in this class */\n-fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n-                         id: node_id, path: ast_map::path,\n-                         class_tps: ~[ty_param],\n+fn encode_info_for_struct(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n+                         path: ast_map::path,\n                          fields: ~[@struct_field],\n-                         methods: ~[@method],\n                          global_index: @mut~[entry<int>]) -> ~[entry<int>] {\n     /* Each class has its own index, since different classes\n        may have fields with the same name */\n@@ -432,7 +430,7 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n                 global_index.push({val: id,\n                                     pos: ebml_w.writer.tell()});\n                 ebml_w.start_tag(tag_items_data_item);\n-                debug!(\"encode_info_for_class: doing %s %d\",\n+                debug!(\"encode_info_for_struct: doing %s %d\",\n                        tcx.sess.str_of(nm), id);\n                 encode_visibility(ebml_w, vis);\n                 encode_name(ecx, ebml_w, nm);\n@@ -445,25 +443,6 @@ fn encode_info_for_class(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n             unnamed_field => {}\n         }\n     }\n-\n-    for methods.each |m| {\n-        match m.vis {\n-            public | inherited => {\n-                index.push({val: m.id, pos: ebml_w.writer.tell()});\n-                global_index.push(\n-                    {val: m.id, pos: ebml_w.writer.tell()});\n-                let impl_path = vec::append_one(path,\n-                                                ast_map::path_name(m.ident));\n-                debug!(\"encode_info_for_class: doing %s %d\",\n-                       ecx.tcx.sess.str_of(m.ident), m.id);\n-                encode_info_for_method(ecx, ebml_w, impl_path,\n-                                       should_inline(m.attrs), id, *m,\n-                                       vec::append(class_tps, m.tps));\n-            }\n-            _ => { /* don't encode private methods */ }\n-        }\n-    }\n-\n     *index\n }\n \n@@ -556,7 +535,7 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n     let must_write =\n         match item.node {\n           item_enum(_, _) | item_impl(*)\n-          | item_trait(*) | item_class(*) => true,\n+          | item_trait(*) | item_struct(*) => true,\n           _ => false\n         };\n     if !must_write && !reachable(ecx, item.id) { return; }\n@@ -645,14 +624,13 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n                                  index,\n                                  tps);\n       }\n-      item_class(struct_def, tps) => {\n-        /* First, encode the fields and methods\n+      item_struct(struct_def, tps) => {\n+        /* First, encode the fields\n            These come first because we need to write them to make\n            the index, and the index needs to be in the item for the\n            class itself */\n-        let idx = encode_info_for_class(ecx, ebml_w, item.id, path, tps,\n-                                        struct_def.fields, struct_def.methods,\n-                                        index);\n+        let idx = encode_info_for_struct(ecx, ebml_w, path,\n+                                        struct_def.fields, index);\n         /* Encode the dtor */\n         do struct_def.dtor.iter |dtor| {\n             index.push({val: dtor.node.id, pos: ebml_w.writer.tell()});\n@@ -677,9 +655,6 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n         encode_name(ecx, ebml_w, item.ident);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         encode_region_param(ecx, ebml_w, item);\n-        for struct_def.traits.each |t| {\n-           encode_trait_ref(ebml_w, ecx, *t);\n-        }\n         /* Encode the dtor */\n         /* Encode id for dtor */\n         do struct_def.dtor.iter |dtor| {\n@@ -704,28 +679,6 @@ fn encode_info_for_item(ecx: @encode_ctxt, ebml_w: writer::Serializer,\n             }\n         }\n \n-        for struct_def.methods.each |m| {\n-           match m.vis {\n-              private => { /* do nothing */ }\n-              public | inherited => {\n-                /* Write the info that's needed when viewing this class\n-                   as a trait */\n-                ebml_w.start_tag(tag_item_trait_method);\n-                encode_family(ebml_w, purity_fn_family(m.purity));\n-                encode_name(ecx, ebml_w, m.ident);\n-                encode_type_param_bounds(ebml_w, ecx, m.tps);\n-                encode_type(ecx, ebml_w, node_id_to_type(tcx, m.id));\n-                encode_def_id(ebml_w, local_def(m.id));\n-                encode_self_type(ebml_w, m.self_ty.node);\n-                ebml_w.end_tag();\n-                /* Write the info that's needed when viewing this class\n-                   as an impl (just the method def_id and self type) */\n-                ebml_w.start_tag(tag_item_impl_method);\n-                ebml_w.writer.write(to_bytes(def_to_str(local_def(m.id))));\n-                ebml_w.end_tag();\n-              }\n-           }\n-        }\n         /* Each class has its own index -- encode it */\n         let bkts = create_index(idx);\n         encode_index(ebml_w, bkts, write_int);"}, {"sha": "1708027eaf9b8c68bb2d46c4b46d0e2f919aa760", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -337,7 +337,7 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n           debug!(\"parsed a def_id %?\", did);\n           let substs = parse_substs(st, conv);\n           assert (next(st) == ']');\n-          return ty::mk_class(st.tcx, did, substs);\n+          return ty::mk_struct(st.tcx, did, substs);\n       }\n       c => { error!(\"unexpected char in type string: %c\", c); fail;}\n     }"}, {"sha": "d4abf099e6ec6a4ce264e5b080c06251921eccc9", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -316,7 +316,7 @@ fn enc_sty(w: io::Writer, cx: @ctxt, st: ty::sty) {\n           enc_proto(w, p);\n       }\n       ty::ty_opaque_box => w.write_char('B'),\n-      ty::ty_class(def, ref substs) => {\n+      ty::ty_struct(def, ref substs) => {\n           debug!(\"~~~~ %s\", ~\"a[\");\n           w.write_str(&\"a[\");\n           let s = (cx.ds)(def);"}, {"sha": "ea018bd528e20a4da38f9190631f3ea289e05974", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -372,8 +372,8 @@ impl ast::def: tr {\n                            xcx.tr_id(nid2),\n                            xcx.tr_id(nid3))\n           }\n-          ast::def_class(did) => {\n-            ast::def_class(did.tr(xcx))\n+          ast::def_struct(did) => {\n+            ast::def_struct(did.tr(xcx))\n           }\n           ast::def_region(nid) => ast::def_region(xcx.tr_id(nid)),\n           ast::def_typaram_binder(nid) => {"}, {"sha": "ff4fed8b37eed9107086a5af8e842b5d292d4a65", "filename": "src/librustc/middle/check_alt.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_alt.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -305,7 +305,7 @@ fn missing_ctor(cx: @AltCheckCtxt,\n              -> Option<ctor> {\n     match ty::get(left_ty).sty {\n       ty::ty_box(_) | ty::ty_uniq(_) | ty::ty_rptr(*) | ty::ty_tup(_) |\n-      ty::ty_rec(_) | ty::ty_class(*) => {\n+      ty::ty_rec(_) | ty::ty_struct(*) => {\n         for m.each |r| {\n             if !is_wild(cx, r[0]) { return None; }\n         }\n@@ -362,7 +362,7 @@ fn ctor_arity(cx: @AltCheckCtxt, ctor: ctor, ty: ty::t) -> uint {\n             None => fail ~\"impossible case\"\n         }\n       }\n-      ty::ty_class(cid, _) => ty::lookup_class_fields(cx.tcx, cid).len(),\n+      ty::ty_struct(cid, _) => ty::lookup_struct_fields(cx.tcx, cid).len(),\n       _ => 0u\n     }\n }\n@@ -410,7 +410,7 @@ fn specialize(cx: @AltCheckCtxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n             Some(vec::append(args, vec::tail(r)))\n           }\n           def_variant(_, _) => None,\n-          def_class(*) => {\n+          def_struct(*) => {\n             // XXX: Is this right? --pcw\n             let new_args;\n             match args {\n@@ -456,9 +456,9 @@ fn specialize(cx: @AltCheckCtxt, r: ~[@pat], ctor_id: ctor, arity: uint,\n                 // Grab the class data that we care about.\n                 let class_fields, class_id;\n                 match ty::get(left_ty).sty {\n-                    ty::ty_class(cid, _) => {\n+                    ty::ty_struct(cid, _) => {\n                         class_id = cid;\n-                        class_fields = ty::lookup_class_fields(cx.tcx,\n+                        class_fields = ty::lookup_struct_fields(cx.tcx,\n                                                                class_id);\n                     }\n                     _ => {"}, {"sha": "06dd18b3bf3f40d9fc6c80edc52e1b48a4109104", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -106,7 +106,7 @@ fn check_expr(sess: Session, def_map: resolve::DefMap,\n               Some(def_const(def_id)) |\n                 Some(def_fn(def_id, _)) |\n                 Some(def_variant(_, def_id)) |\n-                Some(def_class(def_id)) => {\n+                Some(def_struct(def_id)) => {\n                 if !ast_util::is_local(def_id) {\n                     sess.span_err(\n                         e.span, ~\"paths in constants may only refer to \\\n@@ -128,7 +128,7 @@ fn check_expr(sess: Session, def_map: resolve::DefMap,\n           }\n           expr_call(callee, _, false) => {\n             match def_map.find(callee.id) {\n-                Some(def_class(*)) => {}    // OK.\n+                Some(def_struct(*)) => {}    // OK.\n                 _ => {\n                     sess.span_err(\n                         e.span,"}, {"sha": "f5edad9acc4325784effb823526f757a77718518", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -319,8 +319,8 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n             let t = ty::expr_ty(cx.tcx, ex);\n             let ty_fields = match ty::get(t).sty {\n               ty::ty_rec(f) => f,\n-              ty::ty_class(did, ref substs) =>\n-                  ty::class_items_as_fields(cx.tcx, did, &(*substs)),\n+              ty::ty_struct(did, ref substs) =>\n+                  ty::struct_fields(cx.tcx, did, &(*substs)),\n               _ => cx.tcx.sess.span_bug(ex.span,\n                                         ~\"bad base expr type in record\")\n             };"}, {"sha": "91caacf73a0d4e2a044f6a6dce87b14b1355edbf", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -676,7 +676,7 @@ fn check_item_heap(cx: ty::ctxt, it: @ast::item) {\n       ast::item_fn(*) |\n       ast::item_ty(*) |\n       ast::item_enum(*) |\n-      ast::item_class(*) |\n+      ast::item_struct(*) |\n       ast::item_trait(*) => check_type(cx, it.id, it.id, it.span,\n                                        ty::node_id_to_type(cx, it.id)),\n       _ => ()\n@@ -752,7 +752,7 @@ fn check_item_non_camel_case_types(cx: ty::ctxt, it: @ast::item) {\n     }\n \n     match it.node {\n-      ast::item_ty(*) | ast::item_class(*) |\n+      ast::item_ty(*) | ast::item_struct(*) |\n       ast::item_trait(*) => {\n         check_case(cx, it.ident, it.id, it.id, it.span)\n       }"}, {"sha": "3751c7f47691b17edb8391241e6016df65115222", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -564,7 +564,7 @@ impl &mem_categorization_ctxt {\n           ast::def_foreign_mod(_) | ast::def_const(_) |\n           ast::def_use(_) | ast::def_variant(*) |\n           ast::def_ty(_) | ast::def_prim_ty(_) |\n-          ast::def_ty_param(*) | ast::def_class(*) |\n+          ast::def_ty_param(*) | ast::def_struct(*) |\n           ast::def_typaram_binder(*) | ast::def_region(_) |\n           ast::def_label(_) => {\n             @{id:id, span:span,\n@@ -913,7 +913,7 @@ impl &mem_categorization_ctxt {\n                         self.cat_pattern(subcmt, *subpat, op);\n                     }\n                 }\n-                Some(ast::def_class(*)) => {\n+                Some(ast::def_struct(*)) => {\n                     for subpats.each |subpat| {\n                         let cmt_field = self.cat_anon_struct_field(*subpat,\n                                                                    cmt);\n@@ -1104,12 +1104,12 @@ fn field_mutbl(tcx: ty::ctxt,\n             }\n         }\n       }\n-      ty::ty_class(did, _) => {\n-        for ty::lookup_class_fields(tcx, did).each |fld| {\n+      ty::ty_struct(did, _) => {\n+        for ty::lookup_struct_fields(tcx, did).each |fld| {\n             if fld.ident == f_name {\n                 let m = match fld.mutability {\n-                  ast::class_mutable => ast::m_mutbl,\n-                  ast::class_immutable => ast::m_imm\n+                  ast::struct_mutable => ast::m_mutbl,\n+                  ast::struct_immutable => ast::m_imm\n                 };\n                 return Some(m);\n             }\n@@ -1118,11 +1118,11 @@ fn field_mutbl(tcx: ty::ctxt,\n       ty::ty_enum(*) => {\n         match tcx.def_map.get(node_id) {\n           ast::def_variant(_, variant_id) => {\n-            for ty::lookup_class_fields(tcx, variant_id).each |fld| {\n+            for ty::lookup_struct_fields(tcx, variant_id).each |fld| {\n                 if fld.ident == f_name {\n                     let m = match fld.mutability {\n-                      ast::class_mutable => ast::m_mutbl,\n-                      ast::class_immutable => ast::m_imm\n+                      ast::struct_mutable => ast::m_mutbl,\n+                      ast::struct_immutable => ast::m_imm\n                     };\n                     return Some(m);\n                 }"}, {"sha": "b1bd42758f19ad84ab61ecfa782a939ba2282608", "filename": "src/librustc/middle/pat_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fpat_util.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -39,7 +39,7 @@ fn pat_is_variant_or_struct(dm: resolve::DefMap, pat: @pat) -> bool {\n     match pat.node {\n         pat_enum(_, _) | pat_ident(_, _, None) | pat_struct(*) => {\n             match dm.find(pat.id) {\n-                Some(def_variant(*)) | Some(def_class(*)) => true,\n+                Some(def_variant(*)) | Some(def_struct(*)) => true,\n                 _ => false\n             }\n         }"}, {"sha": "1bde3f82f72622ed7faf0c7fa813ac83242fcabf", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -15,13 +15,13 @@ use /*mod*/ syntax::ast;\n use /*mod*/ syntax::visit;\n use syntax::ast_map;\n use syntax::ast::{def_variant, expr_field, expr_method_call, expr_struct};\n-use syntax::ast::{expr_unary, ident, item_class, item_enum, item_impl};\n+use syntax::ast::{expr_unary, ident, item_struct, item_enum, item_impl};\n use syntax::ast::{item_trait, local_crate, node_id, pat_struct, private};\n use syntax::ast::{provided, required};\n use syntax::ast_map::{node_item, node_method};\n use syntax::ast_util::{Private, Public, has_legacy_export_attr, is_local};\n use syntax::ast_util::{visibility_to_privacy};\n-use ty::{ty_class, ty_enum};\n+use ty::{ty_struct, ty_enum};\n use typeck::{method_map, method_origin, method_param, method_self};\n use typeck::{method_static, method_trait};\n \n@@ -37,7 +37,7 @@ fn check_crate(tcx: ty::ctxt, method_map: &method_map, crate: @ast::crate) {\n         let mut count = 0;\n         for items.each |item| {\n             match item.node {\n-                item_class(*) | item_trait(*) | item_impl(*)\n+                item_struct(*) | item_trait(*) | item_impl(*)\n                 | item_enum(*) => {\n                     privileged_items.push(item.id);\n                     count += 1;\n@@ -78,7 +78,7 @@ fn check_crate(tcx: ty::ctxt, method_map: &method_map, crate: @ast::crate) {\n \n     // Checks that a private field is in scope.\n     let check_field = |span, id, ident| {\n-        let fields = ty::lookup_class_fields(tcx, id);\n+        let fields = ty::lookup_struct_fields(tcx, id);\n         for fields.each |field| {\n             if field.ident != ident { loop; }\n             if field.vis == private {\n@@ -200,7 +200,7 @@ fn check_crate(tcx: ty::ctxt, method_map: &method_map, crate: @ast::crate) {\n             match expr.node {\n                 expr_field(base, ident, _) => {\n                     match ty::get(ty::expr_ty(tcx, base)).sty {\n-                        ty_class(id, _)\n+                        ty_struct(id, _)\n                         if id.crate != local_crate ||\n                            !privileged_items.contains(&(id.node)) => {\n                             match method_map.find(expr.id) {\n@@ -221,7 +221,7 @@ fn check_crate(tcx: ty::ctxt, method_map: &method_map, crate: @ast::crate) {\n                 }\n                 expr_method_call(base, _, _, _, _) => {\n                     match ty::get(ty::expr_ty(tcx, base)).sty {\n-                        ty_class(id, _)\n+                        ty_struct(id, _)\n                         if id.crate != local_crate ||\n                            !privileged_items.contains(&(id.node)) => {\n                             match method_map.find(expr.id) {\n@@ -242,7 +242,7 @@ fn check_crate(tcx: ty::ctxt, method_map: &method_map, crate: @ast::crate) {\n                 }\n                 expr_struct(_, ref fields, _) => {\n                     match ty::get(ty::expr_ty(tcx, expr)).sty {\n-                        ty_class(id, _) => {\n+                        ty_struct(id, _) => {\n                             if id.crate != local_crate ||\n                                     !privileged_items.contains(&(id.node)) {\n                                 for (*fields).each |field| {\n@@ -308,7 +308,7 @@ fn check_crate(tcx: ty::ctxt, method_map: &method_map, crate: @ast::crate) {\n             match pattern.node {\n                 pat_struct(_, fields, _) => {\n                     match ty::get(ty::pat_ty(tcx, pattern)).sty {\n-                        ty_class(id, _) => {\n+                        ty_struct(id, _) => {\n                             if id.crate != local_crate ||\n                                     !privileged_items.contains(&(id.node)) {\n                                 for fields.each |field| {"}, {"sha": "4d5e29678a184fb6cf5e49630daaa080084b1b9a", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -666,7 +666,7 @@ fn determine_rp_in_ty(ty: @ast::Ty,\n     match ty.node {\n       ast::ty_path(path, id) => {\n         match cx.def_map.find(id) {\n-          Some(ast::def_ty(did)) | Some(ast::def_class(did)) => {\n+          Some(ast::def_ty(did)) | Some(ast::def_struct(did)) => {\n             if did.crate == ast::local_crate {\n                 if cx.opt_region_is_relevant(path.rp) {\n                     cx.add_dep(did.node);\n@@ -749,12 +749,12 @@ fn determine_rp_in_struct_field(cm: @ast::struct_field,\n                                 &&cx: determine_rp_ctxt,\n                                 visitor: visit::vt<determine_rp_ctxt>) {\n     match cm.node.kind {\n-      ast::named_field(_, ast::class_mutable, _) => {\n+      ast::named_field(_, ast::struct_mutable, _) => {\n         do cx.with_ambient_variance(rv_invariant) {\n             visit::visit_struct_field(cm, cx, visitor);\n         }\n       }\n-      ast::named_field(_, ast::class_immutable, _) |\n+      ast::named_field(_, ast::struct_immutable, _) |\n       ast::unnamed_field => {\n         visit::visit_struct_field(cm, cx, visitor);\n       }"}, {"sha": "bc987db48cd66ac40c284b534cf93c71c007d1f2", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 21, "deletions": 65, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -18,9 +18,9 @@ use middle::lint::{deny, allow, forbid, level, unused_imports, warn};\n use middle::pat_util::{pat_bindings};\n use syntax::ast::{_mod, add, arm};\n use syntax::ast::{bitand, bitor, bitxor};\n-use syntax::ast::{binding_mode, blk, capture_clause, class_ctor, class_dtor};\n+use syntax::ast::{binding_mode, blk, capture_clause, struct_dtor};\n use syntax::ast::{crate, crate_num, decl_item};\n-use syntax::ast::{def, def_arg, def_binding, def_class, def_const, def_fn};\n+use syntax::ast::{def, def_arg, def_binding, def_struct, def_const, def_fn};\n use syntax::ast::{def_foreign_mod, def_id, def_label, def_local, def_mod};\n use syntax::ast::{def_prim_ty, def_region, def_self, def_ty, def_ty_param};\n use syntax::ast::{def_typaram_binder, def_static_method};\n@@ -33,7 +33,7 @@ use syntax::ast::{enum_variant_kind, expr, expr_again, expr_assign_op};\n use syntax::ast::{expr_fn_block, expr_index, expr_loop};\n use syntax::ast::{expr_path, expr_struct, expr_unary, fn_decl};\n use syntax::ast::{foreign_item, foreign_item_const, foreign_item_fn, ge};\n-use syntax::ast::{gt, ident, impure_fn, inherited, item, item_class};\n+use syntax::ast::{gt, ident, impure_fn, inherited, item, item_struct};\n use syntax::ast::{item_const, item_enum, item_fn, item_foreign_mod};\n use syntax::ast::{item_impl, item_mac, item_mod, item_trait, item_ty, le};\n use syntax::ast::{local, local_crate, lt, method, mode, module_ns, mul, ne};\n@@ -281,8 +281,8 @@ enum RibKind {\n     // upvars as appropriate.\n     FunctionRibKind(node_id /* func id */, node_id /* body id */),\n \n-    // We passed through a class, impl, or trait and are now in one of its\n-    // methods. Allow references to ty params that that class, impl or trait\n+    // We passed through an impl or trait and are now in one of its\n+    // methods. Allow references to ty params that that impl or trait\n     // binds. Disallow any other upvars (including other ty params that are\n     // upvars).\n               // parent;   method itself\n@@ -1183,7 +1183,7 @@ impl Resolver {\n             }\n \n             // These items live in both the type and value namespaces.\n-            item_class(struct_def, _) => {\n+            item_struct(struct_def, _) => {\n                 let (name_bindings, new_parent) =\n                     self.add_child(ident, parent, ForbidDuplicateTypes, sp);\n \n@@ -1197,7 +1197,7 @@ impl Resolver {\n                     Some(ctor_id) => {\n                         name_bindings.define_value(\n                             privacy,\n-                            def_class(local_def(ctor_id)),\n+                            def_struct(local_def(ctor_id)),\n                             sp);\n                     }\n                 }\n@@ -1733,7 +1733,7 @@ impl Resolver {\n \n             child_name_bindings.define_type(Public, def, dummy_sp());\n           }\n-          def_class(def_id) => {\n+          def_struct(def_id) => {\n             debug!(\"(building reduced graph for external \\\n                     crate) building type %s\",\n                    final_ident);\n@@ -3662,12 +3662,10 @@ impl Resolver {\n                 (*self.type_ribs).pop();\n             }\n \n-            item_class(struct_def, ty_params) => {\n-                self.resolve_class(item.id,\n+            item_struct(struct_def, ty_params) => {\n+                self.resolve_struct(item.id,\n                                    @copy ty_params,\n-                                   struct_def.traits,\n                                    struct_def.fields,\n-                                   struct_def.methods,\n                                    struct_def.dtor,\n                                    visitor);\n             }\n@@ -3905,15 +3903,12 @@ impl Resolver {\n         }\n     }\n \n-    fn resolve_class(id: node_id,\n+    fn resolve_struct(id: node_id,\n                      type_parameters: @~[ty_param],\n-                     traits: ~[@trait_ref],\n                      fields: ~[@struct_field],\n-                     methods: ~[@method],\n-                     optional_destructor: Option<class_dtor>,\n+                     optional_destructor: Option<struct_dtor>,\n                      visitor: ResolveVisitor) {\n         // If applicable, create a rib for the type parameters.\n-        let outer_type_parameter_count = (*type_parameters).len();\n         let borrowed_type_parameters: &~[ty_param] = &*type_parameters;\n         do self.with_type_parameter_rib(HasTypeParameters\n                                         (borrowed_type_parameters, id, 0,\n@@ -3922,39 +3917,6 @@ impl Resolver {\n             // Resolve the type parameters.\n             self.resolve_type_parameters(*type_parameters, visitor);\n \n-            // Resolve implemented traits.\n-            for traits.each |trt| {\n-                match self.resolve_path(trt.path, TypeNS, true, visitor) {\n-                    None => {\n-                        self.session.span_err(trt.path.span,\n-                                              ~\"attempt to implement a \\\n-                                               nonexistent trait\");\n-                    }\n-                    Some(def) => {\n-                        // Write a mapping from the trait ID to the\n-                        // definition of the trait into the definition\n-                        // map.\n-\n-                        debug!(\"(resolving class) found trait def: %?\", def);\n-\n-                        self.record_def(trt.ref_id, def);\n-\n-                        // XXX: This is wrong but is needed for tests to\n-                        // pass.\n-\n-                        self.record_def(id, def);\n-                    }\n-                }\n-            }\n-\n-            // Resolve methods.\n-            for methods.each |method| {\n-                self.resolve_method(MethodRibKind(id, Provided(method.id)),\n-                                    *method,\n-                                    outer_type_parameter_count,\n-                                    visitor);\n-            }\n-\n             // Resolve fields.\n             for fields.each |field| {\n                 self.resolve_type(field.node.ty, visitor);\n@@ -4416,7 +4378,7 @@ impl Resolver {\n                     // These two must be enum variants or structs.\n                     match self.resolve_path(path, ValueNS, false, visitor) {\n                         Some(def @ def_variant(*)) |\n-                                Some(def @ def_class(*)) => {\n+                                Some(def @ def_struct(*)) => {\n                             self.record_def(pattern.id, def);\n                         }\n                         Some(_) => {\n@@ -4451,10 +4413,10 @@ impl Resolver {\n                     match self.resolve_path(path, TypeNS, false, visitor) {\n                         Some(def_ty(class_id))\n                                 if self.structs.contains_key(class_id) => {\n-                            let class_def = def_class(class_id);\n+                            let class_def = def_struct(class_id);\n                             self.record_def(pattern.id, class_def);\n                         }\n-                        Some(definition @ def_class(class_id))\n+                        Some(definition @ def_struct(class_id))\n                                 if self.structs.contains_key(class_id) => {\n                             self.record_def(pattern.id, definition);\n                         }\n@@ -4495,7 +4457,7 @@ impl Resolver {\n                     }\n                     Some(def) => {\n                         match def.def {\n-                            def @ def_variant(*) | def @ def_class(*) => {\n+                            def @ def_variant(*) | def @ def_struct(*) => {\n                                 return FoundStructOrEnumVariant(def);\n                             }\n                             def @ def_const(*) => {\n@@ -4811,7 +4773,7 @@ impl Resolver {\n         }\n     }\n \n-    fn name_exists_in_scope_class(name: &str) -> bool {\n+    fn name_exists_in_scope_struct(name: &str) -> bool {\n         let mut i = self.type_ribs.len();\n         while i != 0 {\n           i -= 1;\n@@ -4821,7 +4783,7 @@ impl Resolver {\n               for vec::each(self.crate.node.module.items) |item| {\n                 if item.id == node_id {\n                   match item.node {\n-                    item_class(class_def, _) => {\n+                    item_struct(class_def, _) => {\n                       for vec::each(class_def.fields) |field| {\n                         match field.node.kind {\n                           syntax::ast::unnamed_field\n@@ -4835,12 +4797,6 @@ impl Resolver {\n                             }\n                         }\n                       }\n-                      for vec::each(class_def.methods) |method| {\n-                        if str::eq_slice(self.session.str_of(method.ident),\n-                                         name) {\n-                          return true\n-                        }\n-                      }\n                     }\n                     _ => {}\n                   }\n@@ -4879,7 +4835,7 @@ impl Resolver {\n                         let wrong_name =\n                             connect(path.idents.map(\n                                 |x| self.session.str_of(*x)), ~\"::\") ;\n-                        if self.name_exists_in_scope_class(wrong_name) {\n+                        if self.name_exists_in_scope_struct(wrong_name) {\n                             self.session.span_err(expr.span,\n                                         fmt!(\"unresolved name: `%s`. \\\n                                             Did you mean: `self.%s`?\",\n@@ -4925,9 +4881,9 @@ impl Resolver {\n                 //    let bar = Bar { ... } // no type parameters\n \n                 match self.resolve_path(path, TypeNS, false, visitor) {\n-                    Some(def_ty(class_id)) | Some(def_class(class_id))\n+                    Some(def_ty(class_id)) | Some(def_struct(class_id))\n                             if self.structs.contains_key(class_id) => {\n-                        let class_def = def_class(class_id);\n+                        let class_def = def_struct(class_id);\n                         self.record_def(expr.id, class_def);\n                     }\n                     Some(definition @ def_variant(_, class_id))"}, {"sha": "bfb31afa64cfd66c8383305f389ac6ca0557f96a", "filename": "src/librustc/middle/trans/alt.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftrans%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftrans%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Falt.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -269,7 +269,7 @@ fn variant_opt(tcx: ty::ctxt, pat_id: ast::node_id) -> Opt {\n             }\n             core::util::unreachable();\n         }\n-        ast::def_class(_) => {\n+        ast::def_struct(_) => {\n             return lit(UnitLikeStructLit(pat_id));\n         }\n         _ => {\n@@ -531,11 +531,13 @@ fn enter_opt(bcx: block, m: &[@Match/&r], opt: &Opt, col: uint,\n                     // specified in the struct definition. Also fill in\n                     // unspecified fields with dummy.\n                     let reordered_patterns = dvec::DVec();\n-                    for ty::lookup_class_fields(tcx, struct_id).each |field| {\n-                        match field_pats.find(|p| p.ident == field.ident) {\n-                            None => reordered_patterns.push(dummy),\n-                            Some(fp) => reordered_patterns.push(fp.pat)\n-                        }\n+                    for ty::lookup_struct_fields(tcx, struct_id).each\n+                        |field| {\n+                            match field_pats.find(|p|\n+                                                  p.ident == field.ident) {\n+                                None => reordered_patterns.push(dummy),\n+                                Some(fp) => reordered_patterns.push(fp.pat)\n+                            }\n                     }\n                     Some(dvec::unwrap(move reordered_patterns))\n                 } else {\n@@ -727,7 +729,7 @@ fn get_options(ccx: @crate_ctxt, m: &[@Match], col: uint) -> ~[Opt] {\n                         add_to_set(ccx.tcx, &found,\n                                    variant_opt(ccx.tcx, cur.id));\n                     }\n-                    Some(ast::def_class(*)) => {\n+                    Some(ast::def_struct(*)) => {\n                         add_to_set(ccx.tcx, &found,\n                                    lit(UnitLikeStructLit(cur.id)));\n                     }\n@@ -796,7 +798,7 @@ fn collect_record_or_struct_fields(bcx: block, m: &[@Match], col: uint) ->\n           ast::pat_rec(fs, _) => extend(&mut fields, fs),\n           ast::pat_struct(_, fs, _) => {\n             match ty::get(node_id_type(bcx, br.pats[col].id)).sty {\n-              ty::ty_class(*) => extend(&mut fields, fs),\n+              ty::ty_struct(*) => extend(&mut fields, fs),\n               _ => ()\n             }\n           }\n@@ -874,7 +876,7 @@ fn any_tuple_struct_pat(bcx: block, m: &[@Match], col: uint) -> bool {\n         match pat.node {\n             ast::pat_enum(_, Some(_)) => {\n                 match bcx.tcx().def_map.find(pat.id) {\n-                    Some(ast::def_class(*)) => true,\n+                    Some(ast::def_struct(*)) => true,\n                     _ => false\n                 }\n             }\n@@ -1182,9 +1184,9 @@ fn compile_submatch(bcx: block,\n         let struct_ty = node_id_type(bcx, pat_id);\n         let struct_element_count;\n         match ty::get(struct_ty).sty {\n-            ty::ty_class(struct_id, _) => {\n+            ty::ty_struct(struct_id, _) => {\n                 struct_element_count =\n-                    ty::lookup_class_fields(tcx, struct_id).len();\n+                    ty::lookup_struct_fields(tcx, struct_id).len();\n             }\n             _ => {\n                 ccx.sess.bug(~\"non-struct type in tuple struct pattern\");\n@@ -1562,7 +1564,7 @@ fn bind_irrefutable_pat(bcx: block,\n                         }\n                     }\n                 }\n-                Some(ast::def_class(*)) => {\n+                Some(ast::def_struct(*)) => {\n                     match sub_pats {\n                         None => {\n                             // This is a unit-like struct. Nothing to do here."}, {"sha": "3922ba55b9d407895600ff0e192d596d73c2c677", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -557,7 +557,7 @@ fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n     */\n     let mut cx = cx;\n     match ty::get(t).sty {\n-      ty::ty_rec(*) | ty::ty_class(*) => {\n+      ty::ty_rec(*) | ty::ty_struct(*) => {\n           do expr::with_field_tys(cx.tcx(), t, None) |_has_dtor, field_tys| {\n               for vec::eachi(field_tys) |i, field_ty| {\n                   let llfld_a = GEPi(cx, av, struct_field(i));\n@@ -1776,7 +1776,7 @@ fn trans_tuple_struct(ccx: @crate_ctxt,\n     finish_fn(fcx, lltop);\n }\n \n-fn trans_class_dtor(ccx: @crate_ctxt, path: path,\n+fn trans_struct_dtor(ccx: @crate_ctxt, path: path,\n     body: ast::blk, dtor_id: ast::node_id,\n     psubsts: Option<param_substs>,\n     hash_id: Option<mono_id>, parent_id: ast::def_id)\n@@ -1829,7 +1829,7 @@ fn trans_enum_def(ccx: @crate_ctxt, enum_definition: ast::enum_def,\n             }\n             ast::struct_variant_kind(struct_def) => {\n                 trans_struct_def(ccx, struct_def, tps, path,\n-                                 variant.node.name, variant.node.id);\n+                                 variant.node.id);\n             }\n             ast::enum_variant_kind(ref enum_definition) => {\n                 trans_enum_def(ccx,\n@@ -1905,22 +1905,22 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n         };\n         foreign::trans_foreign_mod(ccx, foreign_mod, abi);\n       }\n-      ast::item_class(struct_def, tps) => {\n-        trans_struct_def(ccx, struct_def, tps, path, item.ident, item.id);\n+      ast::item_struct(struct_def, tps) => {\n+        trans_struct_def(ccx, struct_def, tps, path, item.id);\n       }\n       _ => {/* fall through */ }\n     }\n }\n \n fn trans_struct_def(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n                     tps: ~[ast::ty_param], path: @ast_map::path,\n-                    ident: ast::ident, id: ast::node_id) {\n+                    id: ast::node_id) {\n     // If there are type parameters, the destructor and constructor will be\n     // monomorphized, so we don't translate them here.\n     if tps.len() == 0u {\n         // Translate the destructor.\n         do option::iter(&struct_def.dtor) |dtor| {\n-            trans_class_dtor(ccx, *path, dtor.node.body,\n+            trans_struct_dtor(ccx, *path, dtor.node.body,\n                              dtor.node.id, None, None, local_def(id));\n         };\n \n@@ -1936,9 +1936,6 @@ fn trans_struct_def(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n             Some(_) | None => {}\n         }\n     }\n-\n-    // Translate methods.\n-    meth::trans_impl(ccx, *path, ident, struct_def.methods, tps, None, id);\n }\n \n // Translate a module. Doing this amounts to translating the items in the"}, {"sha": "c1cf6771786ca3d9f47680ed2abf635ddae5737b", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -100,7 +100,7 @@ fn trans(bcx: block, expr: @ast::expr) -> Callee {\n                                                 vid).args.len() > 0u;\n                 fn_callee(bcx, trans_fn_ref(bcx, vid, ref_expr.id))\n             }\n-            ast::def_class(def_id) => {\n+            ast::def_struct(def_id) => {\n                 fn_callee(bcx, trans_fn_ref(bcx, def_id, ref_expr.id))\n             }\n             ast::def_arg(*) |"}, {"sha": "d1b5ece9b0ce60ce371d14662a2d1723a0e21635", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -420,7 +420,7 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n \n                 C_named_struct(llty, ~[ lldiscrim, C_null(llstructtys[1]) ])\n             }\n-            Some(ast::def_class(_)) => {\n+            Some(ast::def_struct(_)) => {\n                 let ety = ty::expr_ty(cx.tcx, e);\n                 let llty = type_of::type_of(cx, ety);\n                 C_null(llty)\n@@ -433,7 +433,7 @@ fn const_expr(cx: @crate_ctxt, e: @ast::expr) -> ValueRef {\n       }\n       ast::expr_call(callee, args, _) => {\n         match cx.tcx.def_map.find(callee.id) {\n-            Some(ast::def_class(def_id)) => {\n+            Some(ast::def_struct(def_id)) => {\n                 let ety = ty::expr_ty(cx.tcx, e);\n                 let llty = type_of::type_of(cx, ety);\n                 let llstructbody = C_struct(args.map(|a| const_expr(cx, *a)));"}, {"sha": "5fc6a9ed0ba6fe50c219344bad055032f6586308", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -665,9 +665,9 @@ impl Datum {\n                     }\n                 };\n             }\n-            ty::ty_class(did, ref substs) => {\n+            ty::ty_struct(did, ref substs) => {\n                 // Check whether this struct is a newtype struct.\n-                let fields = ty::class_items_as_fields(ccx.tcx, did, substs);\n+                let fields = ty::struct_fields(ccx.tcx, did, substs);\n                 if fields.len() != 1 || fields[0].ident !=\n                     syntax::parse::token::special_idents::unnamed_field {\n                     return None;"}, {"sha": "1259ab6ccf7412a2813eb004dfdba41f5d15726b", "filename": "src/librustc/middle/trans/deriving.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftrans%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftrans%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fderiving.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -102,7 +102,7 @@ pub fn trans_deriving_impl(ccx: @crate_ctxt,\n                         derived_method_info.method_info.self_type);\n \n                 match ty::get(self_ty.ty).sty {\n-                    ty::ty_class(*) => {\n+                    ty::ty_struct(*) => {\n                         trans_deriving_struct_method(ccx,\n                                                      llfn,\n                                                      impl_def_id,\n@@ -175,8 +175,8 @@ fn trans_deriving_struct_method(ccx: @crate_ctxt,\n \n     let struct_field_tys;\n     match ty::get(self_ty).sty {\n-        ty::ty_class(struct_id, ref struct_substs) => {\n-            struct_field_tys = ty::class_items_as_fields(\n+        ty::ty_struct(struct_id, ref struct_substs) => {\n+            struct_field_tys = ty::struct_fields(\n                 ccx.tcx, struct_id, struct_substs);\n         }\n         _ => {"}, {"sha": "59a1206bd0d027c97dacde0c7caf22993c1613ac", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -111,7 +111,7 @@ lvalues are *never* stored by value.\n \n */\n \n-use ty::class_items_as_mutable_fields;\n+use ty::struct_mutable_fields;\n use lib::llvm::ValueRef;\n use common::*;\n use datum::*;\n@@ -695,7 +695,7 @@ fn trans_def_dps_unadjusted(bcx: block, ref_expr: @ast::expr,\n                 return bcx;\n             }\n         }\n-        ast::def_class(*) => {\n+        ast::def_struct(*) => {\n             // Nothing to do here.\n             // XXX: May not be true in the case of classes with destructors.\n             return bcx;\n@@ -926,9 +926,9 @@ fn with_field_tys<R>(tcx: ty::ctxt,\n             op(false, *fields)\n         }\n \n-        ty::ty_class(did, ref substs) => {\n+        ty::ty_struct(did, ref substs) => {\n             let has_dtor = ty::ty_dtor(tcx, did).is_present();\n-            op(has_dtor, class_items_as_mutable_fields(tcx, did, substs))\n+            op(has_dtor, struct_mutable_fields(tcx, did, substs))\n         }\n \n         ty::ty_enum(_, ref substs) => {\n@@ -943,7 +943,7 @@ fn with_field_tys<R>(tcx: ty::ctxt,\n                 Some(node_id) => {\n                     match tcx.def_map.get(node_id) {\n                         ast::def_variant(_, variant_id) => {\n-                            op(false, class_items_as_mutable_fields(\n+                            op(false, struct_mutable_fields(\n                                 tcx, variant_id, substs))\n                         }\n                         _ => {\n@@ -1103,7 +1103,7 @@ fn trans_rec_or_struct(bcx: block,\n                               GEPi(bcx, addr, [0, 0]));\n                         GEPi(bcx, addr, [0, 1])\n                     };\n-                    let fields = ty::class_items_as_mutable_fields(\n+                    let fields = ty::struct_mutable_fields(\n                         tcx, variant_id, substs);\n                     let field_lltys = do fields.map |field| {\n                         type_of(bcx.ccx(),"}, {"sha": "647ed2275b5e1e538d2014e322562a9cd5d1c645", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -405,15 +405,15 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n       ty::ty_opaque_closure_ptr(ck) => {\n         closure::make_opaque_cbox_free_glue(bcx, ck, v)\n       }\n-      ty::ty_class(did, ref substs) => {\n+      ty::ty_struct(did, ref substs) => {\n         // Call the dtor if there is one\n         match ty::ty_dtor(bcx.tcx(), did) {\n             ty::NoDtor => bcx,\n             ty::LegacyDtor(ref dt_id) => {\n-                trans_class_drop(bcx, v, *dt_id, did, substs, false)\n+                trans_struct_drop(bcx, v, *dt_id, did, substs, false)\n             }\n             ty::TraitDtor(ref dt_id) => {\n-                trans_class_drop(bcx, v, *dt_id, did, substs, true)\n+                trans_struct_drop(bcx, v, *dt_id, did, substs, true)\n             }\n         }\n       }\n@@ -422,7 +422,7 @@ fn make_free_glue(bcx: block, v: ValueRef, t: ty::t) {\n     build_return(bcx);\n }\n \n-fn trans_class_drop(bcx: block,\n+fn trans_struct_drop(bcx: block,\n                     v0: ValueRef,\n                     dtor_did: ast::def_id,\n                     class_did: ast::def_id,\n@@ -461,7 +461,7 @@ fn trans_class_drop(bcx: block,\n \n         // Drop the fields\n         let field_tys =\n-            ty::class_items_as_mutable_fields(bcx.tcx(), class_did,\n+            ty::struct_mutable_fields(bcx.tcx(), class_did,\n                                               substs);\n         for vec::eachi(field_tys) |i, fld| {\n             let llfld_a = GEPi(bcx, v0, struct_field(i));\n@@ -490,14 +490,14 @@ fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n       ty::ty_unboxed_vec(_) => {\n         tvec::make_drop_glue_unboxed(bcx, v0, t)\n       }\n-      ty::ty_class(did, ref substs) => {\n+      ty::ty_struct(did, ref substs) => {\n         let tcx = bcx.tcx();\n         match ty::ty_dtor(tcx, did) {\n           ty::TraitDtor(dtor) => {\n-            trans_class_drop(bcx, v0, dtor, did, substs, true)\n+            trans_struct_drop(bcx, v0, dtor, did, substs, true)\n           }\n           ty::LegacyDtor(dtor) => {\n-            trans_class_drop(bcx, v0, dtor, did, substs, false)\n+            trans_struct_drop(bcx, v0, dtor, did, substs, false)\n           }\n           ty::NoDtor => {\n             // No dtor? Just the default case"}, {"sha": "1c6e500d80682e8dbe01955501ac1632ab3c2dd1", "filename": "src/librustc/middle/trans/machine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmachine.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -36,14 +36,14 @@ pub fn simplify_type(tcx: ty::ctxt, typ: ty::t) -> ty::t {\n           }\n           // Reduce a class type to a record type in which all the fields are\n           // simplified\n-          ty::ty_class(did, ref substs) => {\n+          ty::ty_struct(did, ref substs) => {\n             let simpl_fields = (if ty::ty_dtor(tcx, did).is_present() {\n                 // remember the drop flag\n                   ~[{ident: syntax::parse::token::special_idents::dtor,\n                      mt: {ty: ty::mk_u8(tcx),\n                           mutbl: ast::m_mutbl}}] }\n                 else { ~[] }) +\n-                do ty::lookup_class_fields(tcx, did).map |f| {\n+                do ty::lookup_struct_fields(tcx, did).map |f| {\n                  let t = ty::lookup_field_type(tcx, did, f.id, substs);\n                  {ident: f.ident,\n                   mt: {ty: simplify_type(tcx, t), mutbl: ast::m_const}}"}, {"sha": "b5c7e1f6195a66bfa751f5df73fd0ff49310c729", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -320,10 +320,6 @@ fn method_with_name(ccx: @crate_ctxt, impl_id: ast::def_id,\n           ast_map::node_item(@{node: ast::item_impl(_, _, _, ms), _}, _) => {\n             method_from_methods(ms, name).get()\n           }\n-          ast_map::node_item(@{node:\n-              ast::item_class(struct_def, _), _}, _) => {\n-            method_from_methods(struct_def.methods, name).get()\n-          }\n           _ => fail ~\"method_with_name\"\n         }\n     } else {\n@@ -365,7 +361,7 @@ fn method_with_name_or_default(ccx: @crate_ctxt, impl_id: ast::def_id,\n \n fn method_ty_param_count(ccx: @crate_ctxt, m_id: ast::def_id,\n                          i_id: ast::def_id) -> uint {\n-    debug!(\"mythod_ty_param_count: m_id: %?, i_id: %?\", m_id, i_id);\n+    debug!(\"method_ty_param_count: m_id: %?, i_id: %?\", m_id, i_id);\n     if m_id.crate == ast::local_crate {\n         match ccx.tcx.items.find(m_id.node) {\n             Some(ast_map::node_method(m, _, _)) => m.tps.len(),\n@@ -378,10 +374,11 @@ fn method_ty_param_count(ccx: @crate_ctxt, m_id: ast::def_id,\n                     None => fail\n                 }\n             }\n-            Some(ast_map::node_trait_method(@ast::provided(@m), _, _)) => {\n+            Some(ast_map::node_trait_method(@ast::provided(@ref m), _, _))\n+                => {\n                 m.tps.len()\n             }\n-            e => fail fmt!(\"method_ty_param_count %?\", e)\n+            copy e => fail fmt!(\"method_ty_param_count %?\", e)\n         }\n     } else {\n         csearch::get_type_param_count(ccx.sess.cstore, m_id) -"}, {"sha": "c5a93ecd89d3c7b374b8e20c7bcafee1ac5cc6e4", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -15,7 +15,7 @@ use syntax::ast_map::{path, path_mod, path_name};\n use base::{trans_item, get_item_val, no_self, self_arg, trans_fn,\n               impl_self, decl_internal_cdecl_fn,\n               set_inline_hint_if_appr, set_inline_hint,\n-              trans_enum_variant, trans_class_dtor,\n+              trans_enum_variant, trans_struct_dtor,\n               get_insn_ctxt};\n use syntax::parse::token::special_idents;\n use type_of::type_of_fn_from_ty;\n@@ -211,7 +211,7 @@ fn monomorphic_fn(ccx: @crate_ctxt,\n                 None      => ccx.sess.span_bug(dtor.span, ~\"Bad self ty in \\\n                                                             dtor\")\n         };\n-        trans_class_dtor(ccx, *pt, dtor.node.body,\n+        trans_struct_dtor(ccx, *pt, dtor.node.body,\n           dtor.node.id, psubsts, Some(hash_id), parent_id)\n       }\n       ast_map::node_trait_method(@ast::provided(mth), _, pt) => {"}, {"sha": "fbaa038b4cc9ae481cab23933d9fa3b362f37c48", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -111,21 +111,14 @@ fn traverse_public_item(cx: ctx, item: @item) {\n             }\n         }\n       }\n-      item_class(struct_def, tps) => {\n+      item_struct(struct_def, tps) => {\n         do option::iter(&struct_def.dtor) |dtor| {\n             cx.rmap.insert(dtor.node.id, ());\n             if tps.len() > 0u || attr::find_inline_attr(dtor.node.attrs)\n                      != attr::ia_none {\n                 traverse_inline_body(cx, dtor.node.body);\n             }\n         }\n-        for vec::each(struct_def.methods) |m| {\n-            cx.rmap.insert(m.id, ());\n-            if tps.len() > 0 ||\n-                    attr::find_inline_attr(m.attrs) != attr::ia_none {\n-                traverse_inline_body(cx, m.body);\n-            }\n-        }\n       }\n       item_ty(t, _) => {\n         traverse_ty(t, cx, mk_ty_visitor());\n@@ -217,7 +210,7 @@ fn traverse_all_resources_and_impls(cx: ctx, crate_mod: _mod) {\n         visit_item: |i, cx, v| {\n             visit::visit_item(i, cx, v);\n             match i.node {\n-              item_class(struct_def, _) if struct_def.dtor.is_some() => {\n+              item_struct(struct_def, _) if struct_def.dtor.is_some() => {\n                 traverse_public_item(cx, i);\n               }\n               item_impl(*) => {"}, {"sha": "bc85a57a64bb4958be52f43a27ef7abb12d4bf39", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -67,9 +67,10 @@ impl reflector {\n \n     fn visit(ty_name: ~str, args: ~[ValueRef]) {\n         let tcx = self.bcx.tcx();\n-        let mth_idx = option::get(ty::method_idx(\n+        let mth_idx = ty::method_idx(\n             tcx.sess.ident_of(~\"visit_\" + ty_name),\n-            *self.visitor_methods));\n+            *self.visitor_methods).expect(fmt!(\"Couldn't find visit method \\\n+                                                for %s\", ty_name));\n         let mth_ty = ty::mk_fn(tcx, self.visitor_methods[mth_idx].fty);\n         let v = self.visitor_val;\n         debug!(\"passing %u args:\", vec::len(args));\n@@ -230,12 +231,12 @@ impl reflector {\n             self.visit(~\"leave_fn\", extra);\n           }\n \n-          ty::ty_class(did, ref substs) => {\n+          ty::ty_struct(did, ref substs) => {\n             let bcx = self.bcx;\n             let tcx = bcx.ccx().tcx;\n-            let fields = ty::class_items_as_fields(tcx, did, substs);\n+            let fields = ty::struct_fields(tcx, did, substs);\n \n-            do self.bracketed(~\"class\", ~[self.c_uint(vec::len(fields))]\n+            do self.bracketed(~\"class\", ~[self.c_uint(fields.len())]\n                               + self.c_size_and_align(t)) {\n                 for fields.eachi |i, field| {\n                     self.visit(~\"class_field\","}, {"sha": "086407c8186b48257cb2e9b963d540e0c99dae1f", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -179,12 +179,12 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n         T_struct(tys)\n       }\n       ty::ty_opaque_closure_ptr(_) => T_opaque_box_ptr(cx),\n-      ty::ty_class(did, ref substs) => {\n+      ty::ty_struct(did, ref substs) => {\n         // Only create the named struct, but don't fill it in. We fill it\n         // in *after* placing it into the type cache. This prevents\n-        // infinite recursion with recursive class types.\n+        // infinite recursion with recursive struct types.\n \n-        common::T_named_struct(llvm_type_name(cx, a_class, did, substs.tps))\n+        common::T_named_struct(llvm_type_name(cx, a_struct, did, substs.tps))\n       }\n       ty::ty_self => cx.tcx.sess.unimpl(~\"type_of: ty_self\"),\n       ty::ty_infer(*) => cx.tcx.sess.bug(~\"type_of with ty_infer\"),\n@@ -194,14 +194,14 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n \n     cx.lltypes.insert(t, llty);\n \n-    // If this was an enum or class, fill in the type now.\n+    // If this was an enum or struct, fill in the type now.\n     match ty::get(t).sty {\n       ty::ty_enum(did, _) => {\n         fill_type_of_enum(cx, did, t, llty);\n       }\n-      ty::ty_class(did, ref substs) => {\n+      ty::ty_struct(did, ref substs) => {\n         // Only instance vars are record fields at runtime.\n-        let fields = ty::lookup_class_fields(cx.tcx, did);\n+        let fields = ty::lookup_struct_fields(cx.tcx, did);\n         let mut tys = do vec::map(fields) |f| {\n             let t = ty::lookup_field_type(cx.tcx, did, f.id, substs);\n             type_of(cx, t)\n@@ -244,14 +244,17 @@ fn fill_type_of_enum(cx: @crate_ctxt, did: ast::def_id, t: ty::t,\n }\n \n // Want refinements! (Or case classes, I guess\n-enum named_ty { a_class, an_enum }\n+enum named_ty { a_struct, an_enum }\n \n fn llvm_type_name(cx: @crate_ctxt,\n                   what: named_ty,\n                   did: ast::def_id,\n                   tps: ~[ty::t]\n                   ) -> ~str {\n-    let name = match what { a_class => { \"~class\" } an_enum => { \"~enum\" } };\n+    let name = match what {\n+        a_struct => { \"~struct\" }\n+        an_enum => { \"~enum\" }\n+    };\n     return fmt!(\n         \"%s %s[#%d]\",\n           name,"}, {"sha": "d244021763782b939d404f776c89e434b73a096c", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 87, "deletions": 137, "changes": 224, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -42,7 +42,7 @@ export node_id_to_type_params;\n export arg;\n export args_eq;\n export block_ty;\n-export class_items_as_fields, class_items_as_mutable_fields;\n+export struct_fields, struct_mutable_fields;\n export ctxt;\n export deref, deref_sty;\n export index, index_sty;\n@@ -64,14 +64,13 @@ export get_element_type;\n export has_dtor;\n export is_binopable;\n export is_pred_ty;\n-export lookup_class_field, lookup_class_fields;\n-export lookup_class_method_by_name;\n+export lookup_struct_field, lookup_struct_fields;\n export lookup_field_type;\n export lookup_item_type;\n export lookup_public_fields;\n export method;\n export method_idx;\n-export mk_class, mk_err;\n+export mk_struct, mk_err;\n export mk_ctxt;\n export mk_with_id, type_def_id;\n export mt;\n@@ -123,7 +122,7 @@ export ty_infer, mk_infer, type_is_ty_var, mk_var, mk_int_var, mk_float_var;\n export InferTy, TyVar, IntVar, FloatVar;\n export ValueMode, ReadValue, CopyValue, MoveValue;\n export ty_self, mk_self, type_has_self;\n-export ty_class;\n+export ty_struct;\n export Region, bound_region, encl_region;\n export re_bound, re_free, re_scope, re_static, re_infer;\n export ReVar, ReSkolemized;\n@@ -254,7 +253,7 @@ type field_ty = {\n   ident: ident,\n   id: def_id,\n   vis: ast::visibility,\n-  mutability: ast::class_mutability\n+  mutability: ast::struct_mutability\n };\n \n /// How an lvalue is to be used.\n@@ -604,7 +603,7 @@ enum Region {\n #[auto_serialize]\n #[auto_deserialize]\n enum bound_region {\n-    /// The self region for classes, impls (&T in a type defn or &self/T)\n+    /// The self region for structs, impls (&T in a type defn or &self/T)\n     br_self,\n \n     /// An anonymous region parameter for a given fn (&T)\n@@ -636,7 +635,7 @@ type opt_region = Option<Region>;\n  *   according to the order in which they were declared.\n  *\n  * - `self_r` indicates the region parameter `self` that is present on nominal\n- *   types (enums, classes) declared as having a region parameter.  `self_r`\n+ *   types (enums, structs) declared as having a region parameter.  `self_r`\n  *   should always be none for types that are not region-parameterized and\n  *   Some(_) for types that are.  The only bound region parameter that should\n  *   appear within a region-parameterized type is `self`.\n@@ -669,7 +668,7 @@ enum sty {\n     ty_rec(~[field]),\n     ty_fn(FnTy),\n     ty_trait(def_id, substs, vstore),\n-    ty_class(def_id, substs),\n+    ty_struct(def_id, substs),\n     ty_tup(~[t]),\n \n     ty_param(param_ty), // type parameter\n@@ -1054,7 +1053,7 @@ fn mk_t_with_id(cx: ctxt, +st: sty, o_def_id: Option<ast::def_id>) -> t {\n       ty_param(_) => flags |= has_params as uint,\n       ty_infer(_) => flags |= needs_infer as uint,\n       ty_self => flags |= has_self as uint,\n-      ty_enum(_, ref substs) | ty_class(_, ref substs)\n+      ty_enum(_, ref substs) | ty_struct(_, ref substs)\n       | ty_trait(_, ref substs, _) => {\n         flags |= sflags(substs);\n       }\n@@ -1187,9 +1186,9 @@ fn mk_trait(cx: ctxt, did: ast::def_id, +substs: substs, vstore: vstore)\n     mk_t(cx, ty_trait(did, substs, vstore))\n }\n \n-fn mk_class(cx: ctxt, class_id: ast::def_id, +substs: substs) -> t {\n+fn mk_struct(cx: ctxt, struct_id: ast::def_id, +substs: substs) -> t {\n     // take a copy of substs so that we own the vectors inside\n-    mk_t(cx, ty_class(class_id, substs))\n+    mk_t(cx, ty_struct(struct_id, substs))\n }\n \n fn mk_var(cx: ctxt, v: TyVid) -> t { mk_infer(cx, TyVar(v)) }\n@@ -1297,7 +1296,7 @@ fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n       ty_ptr(tm) | ty_rptr(_, tm) => {\n         maybe_walk_ty(tm.ty, f);\n       }\n-      ty_enum(_, ref substs) | ty_class(_, ref substs) |\n+      ty_enum(_, ref substs) | ty_struct(_, ref substs) |\n       ty_trait(_, ref substs, _) => {\n         for (*substs).tps.each |subty| { maybe_walk_ty(*subty, f); }\n       }\n@@ -1372,8 +1371,8 @@ fn fold_sty(sty: &sty, fldop: fn(t) -> t) -> sty {\n         ty_rptr(r, tm) => {\n             ty_rptr(r, {ty: fldop(tm.ty), mutbl: tm.mutbl})\n         }\n-        ty_class(did, ref substs) => {\n-            ty_class(did, fold_substs(substs, fldop))\n+        ty_struct(did, ref substs) => {\n+            ty_struct(did, fold_substs(substs, fldop))\n         }\n         ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n         ty_estr(_) | ty_type | ty_opaque_closure_ptr(_) | ty_err |\n@@ -1440,8 +1439,8 @@ fn fold_regions_and_ty(\n       ty_enum(def_id, ref substs) => {\n         ty::mk_enum(cx, def_id, fold_substs(substs, fldr, fldt))\n       }\n-      ty_class(def_id, ref substs) => {\n-        ty::mk_class(cx, def_id, fold_substs(substs, fldr, fldt))\n+      ty_struct(def_id, ref substs) => {\n+        ty::mk_struct(cx, def_id, fold_substs(substs, fldr, fldt))\n       }\n       ty_trait(def_id, ref substs, vst) => {\n         ty::mk_trait(cx, def_id, fold_substs(substs, fldr, fldt), vst)\n@@ -1657,7 +1656,7 @@ fn type_is_bool(ty: t) -> bool { get(ty).sty == ty_bool }\n \n fn type_is_structural(ty: t) -> bool {\n     match get(ty).sty {\n-      ty_rec(_) | ty_class(*) | ty_tup(_) | ty_enum(*) | ty_fn(_) |\n+      ty_rec(_) | ty_struct(*) | ty_tup(_) | ty_enum(*) | ty_fn(_) |\n       ty_trait(*) |\n       ty_evec(_, vstore_fixed(_)) | ty_estr(vstore_fixed(_)) |\n       ty_evec(_, vstore_slice(_)) | ty_estr(vstore_slice(_))\n@@ -1818,10 +1817,10 @@ fn type_needs_drop(cx: ctxt, ty: t) -> bool {\n         }\n         accum\n       }\n-      ty_class(did, ref substs) => {\n-         // Any class with a dtor needs a drop\n+      ty_struct(did, ref substs) => {\n+         // Any struct with a dtor needs a drop\n          ty_dtor(cx, did).is_present() || {\n-             for vec::each(ty::class_items_as_fields(cx, did, substs)) |f| {\n+             for vec::each(ty::struct_fields(cx, did, substs)) |f| {\n                  if type_needs_drop(cx, f.mt.ty) { accum = true; }\n              }\n              accum\n@@ -2229,16 +2228,16 @@ fn type_kind(cx: ctxt, ty: t) -> Kind {\n         lowest\n       }\n \n-      ty_class(did, ref substs) => {\n-        // Classes are sendable if all their fields are sendable,\n+      ty_struct(did, ref substs) => {\n+        // Structs are sendable if all their fields are sendable,\n         // likewise for copyable...\n         // also factor out this code, copied from the records case\n         let mut lowest = kind_top();\n-        let flds = class_items_as_fields(cx, did, substs);\n+        let flds = struct_fields(cx, did, substs);\n         for flds.each |f| {\n             lowest = lower_kind(lowest, mutable_type_kind(cx, f.mt));\n         }\n-        // ...but classes with dtors are never copyable (they can be\n+        // ...but structs with dtors are never copyable (they can be\n         // sendable)\n         if ty::has_dtor(cx, did) {\n            lowest = remove_copyable(lowest);\n@@ -2334,8 +2333,8 @@ fn type_size(cx: ctxt, ty: t) -> uint {\n         flds.foldl(0, |s, f| *s + type_size(cx, f.mt.ty))\n       }\n \n-      ty_class(did, ref substs) => {\n-        let flds = class_items_as_fields(cx, did, substs);\n+      ty_struct(did, ref substs) => {\n+        let flds = struct_fields(cx, did, substs);\n         flds.foldl(0, |s, f| *s + type_size(cx, f.mt.ty))\n       }\n \n@@ -2433,13 +2432,13 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             false\n           }\n \n-          ty_class(ref did, _) if vec::contains(*seen, did) => {\n+          ty_struct(ref did, _) if vec::contains(*seen, did) => {\n             false\n           }\n \n-          ty_class(did, ref substs) => {\n+          ty_struct(did, ref substs) => {\n               seen.push(did);\n-              let r = vec::any(class_items_as_fields(cx, did, substs),\n+              let r = vec::any(struct_fields(cx, did, substs),\n                                |f| type_requires(cx, seen, r_ty, f.mt.ty));\n               seen.pop();\n             r\n@@ -2502,8 +2501,8 @@ fn type_structurally_contains(cx: ctxt, ty: t, test: fn(x: &sty) -> bool) ->\n         }\n         return false;\n       }\n-      ty_class(did, ref substs) => {\n-        for lookup_class_fields(cx, did).each |field| {\n+      ty_struct(did, ref substs) => {\n+        for lookup_struct_fields(cx, did).each |field| {\n             let ft = lookup_field_type(cx, did, field.id, substs);\n             if type_structurally_contains(cx, ft, test) { return true; }\n         }\n@@ -2597,8 +2596,8 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       }\n       ty_param(_) => result = false,\n       ty_opaque_closure_ptr(_) => result = true,\n-      ty_class(did, ref substs) => {\n-        result = vec::any(lookup_class_fields(cx, did), |f| {\n+      ty_struct(did, ref substs) => {\n+        result = vec::any(lookup_struct_fields(cx, did), |f| {\n             let fty = ty::lookup_item_type(cx, f.id);\n             let sty = subst(cx, substs, fty.ty);\n             type_is_pod(cx, sty)\n@@ -2673,8 +2672,8 @@ fn deref_sty(cx: ctxt, sty: &sty, explicit: bool) -> Option<mt> {\n         }\n       }\n \n-      ty_class(did, ref substs) => {\n-        let fields = class_items_as_fields(cx, did, substs);\n+      ty_struct(did, ref substs) => {\n+        let fields = struct_fields(cx, did, substs);\n         if fields.len() == 1 && fields[0].ident ==\n                 syntax::parse::token::special_idents::unnamed_field {\n             Some({ty: fields[0].mt.ty, mutbl: ast::m_imm})\n@@ -2877,7 +2876,7 @@ impl sty : to_bytes::IterBytes {\n \n           ty_opaque_box => 22u8.iter_bytes(lsb0, f),\n \n-          ty_class(ref did, ref substs) =>\n+          ty_struct(ref did, ref substs) =>\n           to_bytes::iter_bytes_3(&23u8, did, substs, lsb0, f),\n \n           ty_rptr(ref r, ref mt) =>\n@@ -3014,8 +3013,8 @@ fn method_call_bounds(tcx: ctxt, method_map: typeck::method_map,\n     do method_map.find(id).map |method| {\n         match method.origin {\n           typeck::method_static(did) => {\n-            // n.b.: When we encode class/impl methods, the bounds\n-            // that we encode include both the class/impl bounds\n+            // n.b.: When we encode impl methods, the bounds\n+            // that we encode include both the impl bounds\n             // and then the method bounds themselves...\n             ty::lookup_item_type(tcx, did).bounds\n           }\n@@ -3083,7 +3082,7 @@ fn expr_kind(tcx: ctxt,\n         ast::expr_path(*) => {\n             match resolve_expr(tcx, expr) {\n                 ast::def_fn(*) | ast::def_static_method(*) |\n-                ast::def_variant(*) | ast::def_class(*) => RvalueDpsExpr,\n+                ast::def_variant(*) | ast::def_struct(*) => RvalueDpsExpr,\n \n                 // Note: there is actually a good case to be made that\n                 // def_args, particularly those of immediate type, ought to\n@@ -3377,7 +3376,7 @@ fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n       ty_rec(_) => ~\"record\",\n       ty_fn(_) => ~\"fn\",\n       ty_trait(id, _, _) => fmt!(\"trait %s\", item_path_str(cx, id)),\n-      ty_class(id, _) => fmt!(\"class %s\", item_path_str(cx, id)),\n+      ty_struct(id, _) => fmt!(\"struct %s\", item_path_str(cx, id)),\n       ty_tup(_) => ~\"tuple\",\n       ty_infer(TyVar(_)) => ~\"inferred type\",\n       ty_infer(IntVar(_)) => ~\"integral variable\",\n@@ -3550,7 +3549,7 @@ fn note_and_explain_type_err(cx: ctxt, err: &type_err) {\n \n fn def_has_ty_params(def: ast::def) -> bool {\n     match def {\n-      ast::def_fn(_, _) | ast::def_variant(_, _) | ast::def_class(_)\n+      ast::def_fn(_, _) | ast::def_variant(_, _) | ast::def_struct(_)\n         => true,\n       _ => false\n     }\n@@ -3655,13 +3654,6 @@ fn impl_traits(cx: ctxt, id: ast::def_id, vstore: vstore) -> ~[t] {\n                                    vstore)]\n                    }\n            }\n-           Some(ast_map::node_item(@{node: ast::item_class(sd,_),\n-                           _},_)) => {\n-               do vec::map(sd.traits) |trait_ref| {\n-                    vstoreify(cx, node_id_to_type(cx, trait_ref.ref_id),\n-                              vstore)\n-                }\n-           }\n            _ => ~[]\n         }\n     } else {\n@@ -3672,7 +3664,7 @@ fn impl_traits(cx: ctxt, id: ast::def_id, vstore: vstore) -> ~[t] {\n \n fn ty_to_def_id(ty: t) -> Option<ast::def_id> {\n     match get(ty).sty {\n-      ty_trait(id, _, _) | ty_class(id, _) | ty_enum(id, _) => Some(id),\n+      ty_trait(id, _, _) | ty_struct(id, _) | ty_enum(id, _) => Some(id),\n       _ => None\n     }\n }\n@@ -3689,7 +3681,7 @@ fn struct_ctor_id(cx: ctxt, struct_did: ast::def_id) -> Option<ast::def_id> {\n     match cx.items.find(struct_did.node) {\n         Some(ast_map::node_item(item, _)) => {\n             match item.node {\n-                ast::item_class(struct_def, _) => {\n+                ast::item_struct(struct_def, _) => {\n                     struct_def.ctor_id.map(|ctor_id|\n                         ast_util::local_def(*ctor_id))\n                 }\n@@ -3748,18 +3740,18 @@ impl DtorKind {\n     }\n }\n \n-/* If class_id names a class with a dtor, return Some(the dtor's id).\n+/* If struct_id names a struct with a dtor, return Some(the dtor's id).\n    Otherwise return none. */\n-fn ty_dtor(cx: ctxt, class_id: def_id) -> DtorKind {\n-    match cx.destructor_for_type.find(class_id) {\n+fn ty_dtor(cx: ctxt, struct_id: def_id) -> DtorKind {\n+    match cx.destructor_for_type.find(struct_id) {\n         Some(method_def_id) => return TraitDtor(method_def_id),\n         None => {}  // Continue.\n     }\n \n-    if is_local(class_id) {\n-       match cx.items.find(class_id.node) {\n+    if is_local(struct_id) {\n+       match cx.items.find(struct_id.node) {\n            Some(ast_map::node_item(@{\n-               node: ast::item_class(@{ dtor: Some(ref dtor), _ }, _),\n+               node: ast::item_struct(@{ dtor: Some(ref dtor), _ }, _),\n                _\n            }, _)) =>\n                LegacyDtor(local_def((*dtor).node.id)),\n@@ -3768,15 +3760,15 @@ fn ty_dtor(cx: ctxt, class_id: def_id) -> DtorKind {\n        }\n     }\n     else {\n-      match csearch::class_dtor(cx.sess.cstore, class_id) {\n+      match csearch::struct_dtor(cx.sess.cstore, struct_id) {\n         None => NoDtor,\n         Some(did) => LegacyDtor(did),\n       }\n     }\n }\n \n-fn has_dtor(cx: ctxt, class_id: def_id) -> bool {\n-    ty_dtor(cx, class_id).is_present()\n+fn has_dtor(cx: ctxt, struct_id: def_id) -> bool {\n+    ty_dtor(cx, struct_id).is_present()\n }\n \n fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n@@ -3943,8 +3935,8 @@ fn lookup_item_type(cx: ctxt, did: ast::def_id) -> ty_param_bounds_and_ty {\n }\n \n // Look up a field ID, whether or not it's local\n-// Takes a list of type substs in case the class is generic\n-fn lookup_field_type(tcx: ctxt, class_id: def_id, id: def_id,\n+// Takes a list of type substs in case the struct is generic\n+fn lookup_field_type(tcx: ctxt, struct_id: def_id, id: def_id,\n                      substs: &substs) -> ty::t {\n \n     let t = if id.crate == ast::local_crate {\n@@ -3954,7 +3946,7 @@ fn lookup_field_type(tcx: ctxt, class_id: def_id, id: def_id,\n         match tcx.tcache.find(id) {\n            Some(tpt) => tpt.ty,\n            None => {\n-               let tpt = csearch::get_field_type(tcx, class_id, id);\n+               let tpt = csearch::get_field_type(tcx, struct_id, id);\n                tcx.tcache.insert(id, tpt);\n                tpt.ty\n            }\n@@ -3963,23 +3955,23 @@ fn lookup_field_type(tcx: ctxt, class_id: def_id, id: def_id,\n     subst(tcx, substs, t)\n }\n \n-// Look up the list of field names and IDs for a given class\n-// Fails if the id is not bound to a class.\n-fn lookup_class_fields(cx: ctxt, did: ast::def_id) -> ~[field_ty] {\n+// Look up the list of field names and IDs for a given struct\n+// Fails if the id is not bound to a struct.\n+fn lookup_struct_fields(cx: ctxt, did: ast::def_id) -> ~[field_ty] {\n   if did.crate == ast::local_crate {\n     match cx.items.find(did.node) {\n        Some(ast_map::node_item(i,_)) => {\n          match i.node {\n-            ast::item_class(struct_def, _) => {\n-               class_field_tys(struct_def.fields)\n+            ast::item_struct(struct_def, _) => {\n+               struct_field_tys(struct_def.fields)\n             }\n-            _ => cx.sess.bug(~\"class ID bound to non-class\")\n+            _ => cx.sess.bug(~\"struct ID bound to non-struct\")\n          }\n        }\n        Some(ast_map::node_variant(ref variant, _, _)) => {\n           match (*variant).node.kind {\n             ast::struct_variant_kind(struct_def) => {\n-              class_field_tys(struct_def.fields)\n+              struct_field_tys(struct_def.fields)\n             }\n             _ => {\n               cx.sess.bug(~\"struct ID bound to enum variant that isn't \\\n@@ -3989,23 +3981,23 @@ fn lookup_class_fields(cx: ctxt, did: ast::def_id) -> ~[field_ty] {\n        }\n        _ => {\n            cx.sess.bug(\n-               fmt!(\"class ID not bound to an item: %s\",\n+               fmt!(\"struct ID not bound to an item: %s\",\n                     ast_map::node_id_to_str(cx.items, did.node,\n                                             cx.sess.parse_sess.interner)));\n        }\n     }\n         }\n   else {\n-        return csearch::get_class_fields(cx, did);\n+        return csearch::get_struct_fields(cx, did);\n     }\n }\n \n-fn lookup_class_field(cx: ctxt, parent: ast::def_id, field_id: ast::def_id)\n+fn lookup_struct_field(cx: ctxt, parent: ast::def_id, field_id: ast::def_id)\n     -> field_ty {\n-    match vec::find(lookup_class_fields(cx, parent),\n+    match vec::find(lookup_struct_fields(cx, parent),\n                  |f| f.id.node == field_id.node) {\n         Some(t) => t,\n-        None => cx.sess.bug(~\"class ID not found in parent's fields\")\n+        None => cx.sess.bug(~\"struct ID not found in parent's fields\")\n     }\n }\n \n@@ -4017,50 +4009,7 @@ pure fn is_public(f: field_ty) -> bool {\n     }\n }\n \n-/* Given a class def_id and a method name, return the method's\n- def_id. Needed so we can do static dispatch for methods\n- Doesn't care about the method's privacy. (It's assumed that\n- the caller already checked that.)\n-*/\n-fn lookup_class_method_by_name(cx:ctxt, did: ast::def_id, name: ident,\n-                               sp: span) -> def_id {\n-\n-    // Look up the list of method names and IDs for a given class\n-    // Fails if the id is not bound to a class.\n-    fn lookup_class_method_ids(cx: ctxt, did: ast::def_id)\n-        -> ~[{name: ident, id: node_id, vis: visibility}] {\n-\n-        assert is_local(did);\n-        match cx.items.find(did.node) {\n-          Some(ast_map::node_item(@{\n-            node: item_class(struct_def, _), _\n-          }, _)) => {\n-            vec::map(struct_def.methods, |m| {name: m.ident,\n-                                              id: m.id,\n-                                              vis: m.vis})\n-          }\n-          _ => {\n-            cx.sess.bug(~\"lookup_class_method_ids: id not bound to a class\");\n-          }\n-        }\n-    }\n-\n-    if is_local(did) {\n-       let ms = lookup_class_method_ids(cx, did);\n-        for ms.each |m| {\n-            if m.name == name {\n-                return ast_util::local_def(m.id);\n-            }\n-       }\n-       cx.sess.span_fatal(sp, fmt!(\"Class doesn't have a method \\\n-           named %s\", cx.sess.str_of(name)));\n-    }\n-    else {\n-      csearch::get_class_method(cx.sess.cstore, did, name)\n-    }\n-}\n-\n-fn class_field_tys(fields: ~[@struct_field]) -> ~[field_ty] {\n+fn struct_field_tys(fields: ~[@struct_field]) -> ~[field_ty] {\n     let mut rslt = ~[];\n     for fields.each |field| {\n         match field.node.kind {\n@@ -4075,43 +4024,43 @@ fn class_field_tys(fields: ~[@struct_field]) -> ~[field_ty] {\n                     syntax::parse::token::special_idents::unnamed_field,\n                            id: ast_util::local_def(field.node.id),\n                            vis: ast::public,\n-                           mutability: ast::class_immutable});\n+                           mutability: ast::struct_immutable});\n             }\n        }\n     }\n     rslt\n }\n \n-// Return a list of fields corresponding to the class's items\n-// (as if the class was a record). trans uses this\n+// Return a list of fields corresponding to the struct's items\n+// (as if the struct was a record). trans uses this\n // Takes a list of substs with which to instantiate field types\n // Keep in mind that this function reports that all fields are\n // mutable, regardless of how they were declared. It's meant to\n // be used in trans.\n-fn class_items_as_mutable_fields(cx:ctxt,\n+fn struct_mutable_fields(cx:ctxt,\n                                  did: ast::def_id,\n                                  substs: &substs) -> ~[field] {\n-    class_item_fields(cx, did, substs, |_mt| m_mutbl)\n+    struct_item_fields(cx, did, substs, |_mt| m_mutbl)\n }\n \n-// Same as class_items_as_mutable_fields, but doesn't change\n+// Same as struct_mutable_fields, but doesn't change\n // mutability.\n-fn class_items_as_fields(cx:ctxt,\n+fn struct_fields(cx:ctxt,\n                          did: ast::def_id,\n                          substs: &substs) -> ~[field] {\n-    class_item_fields(cx, did, substs, |mt| match mt {\n-      class_mutable => m_mutbl,\n-        class_immutable => m_imm })\n+    struct_item_fields(cx, did, substs, |mt| match mt {\n+      struct_mutable => m_mutbl,\n+        struct_immutable => m_imm })\n }\n \n \n-fn class_item_fields(cx:ctxt,\n+fn struct_item_fields(cx:ctxt,\n                      did: ast::def_id,\n                      substs: &substs,\n-                     frob_mutability: fn(class_mutability) -> mutability)\n+                     frob_mutability: fn(struct_mutability) -> mutability)\n     -> ~[field] {\n     let mut rslt = ~[];\n-    for lookup_class_fields(cx, did).each |f| {\n+    for lookup_struct_fields(cx, did).each |f| {\n        // consider all instance vars mut, because the\n        // constructor may mutate all vars\n        rslt.push({ident: f.ident, mt:\n@@ -4247,12 +4196,13 @@ fn normalize_ty(cx: ctxt, t: t) -> t {\n                     t\n             },\n \n-        ty_class(did, ref r) =>\n+        ty_struct(did, ref r) =>\n             match (*r).self_r {\n               Some(_) =>\n                 // Ditto.\n-                mk_class(cx, did, {self_r: Some(ty::re_static), self_ty: None,\n-                                   tps: (*r).tps}),\n+                mk_struct(cx, did, {self_r: Some(ty::re_static),\n+                                    self_ty: None,\n+                                    tps: (*r).tps}),\n               None =>\n                 t\n             },\n@@ -4654,9 +4604,9 @@ impl sty : cmp::Eq {\n                     _ => false\n                 }\n             }\n-            ty_class(e0a, ref e1a) => {\n+            ty_struct(e0a, ref e1a) => {\n                 match (*other) {\n-                    ty_class(e0b, ref e1b) => e0a == e0b && (*e1a) == (*e1b),\n+                    ty_struct(e0b, ref e1b) => e0a == e0b && (*e1a) == (*e1b),\n                     _ => false\n                 }\n             }"}, {"sha": "f037bffb4838e20de75e81755a38fe4e8f3c66cc", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -320,7 +320,7 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope Copy Owned>(\n           Some(d) => d\n         };\n         match a_def {\n-          ast::def_ty(did) | ast::def_class(did) => {\n+          ast::def_ty(did) | ast::def_struct(did) => {\n             ast_path_to_ty(self, rscope, did, path, id).ty\n           }\n           ast::def_prim_ty(nty) => {"}, {"sha": "19f3fad0710899d604fb859f3b533aba769ad9f5", "filename": "src/librustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -100,7 +100,7 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n \n             kind_name = \"variant\";\n         }\n-        ty::ty_class(struct_def_id, ref expected_substs) => {\n+        ty::ty_struct(struct_def_id, ref expected_substs) => {\n             // Assign the pattern the type of the struct.\n             let struct_tpt = ty::lookup_item_type(tcx, struct_def_id);\n             instantiate_path(pcx.fcx, path, struct_tpt, pat.span, pat.id,\n@@ -112,7 +112,7 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n             demand::suptype(fcx, pat.span, pat_ty, expected);\n \n             // Get the expected types of the arguments.\n-            let class_fields = ty::class_items_as_fields(\n+            let class_fields = ty::struct_fields(\n                 tcx, struct_def_id, expected_substs);\n             arg_types = class_fields.map(|field| field.mt.ty);\n \n@@ -232,15 +232,15 @@ fn check_struct_pat(pcx: pat_ctxt, pat_id: ast::node_id, span: span,\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    let class_fields = ty::lookup_class_fields(tcx, class_id);\n+    let class_fields = ty::lookup_struct_fields(tcx, class_id);\n \n     // Check to ensure that the struct is the one specified.\n     match tcx.def_map.find(pat_id) {\n-        Some(ast::def_class(supplied_def_id))\n+        Some(ast::def_struct(supplied_def_id))\n                 if supplied_def_id == class_id => {\n             // OK.\n         }\n-        Some(ast::def_class(*)) | Some(ast::def_variant(*)) => {\n+        Some(ast::def_struct(*)) | Some(ast::def_variant(*)) => {\n             let name = pprust::path_to_str(path, tcx.sess.intr());\n             tcx.sess.span_err(span,\n                               fmt!(\"mismatched types: expected `%s` but \\\n@@ -280,12 +280,12 @@ fn check_struct_like_enum_variant_pat(pcx: pat_ctxt,\n         Some(ast::def_variant(found_enum_id, variant_id))\n                 if found_enum_id == enum_id => {\n             // Get the struct fields from this struct-like enum variant.\n-            let class_fields = ty::lookup_class_fields(tcx, variant_id);\n+            let class_fields = ty::lookup_struct_fields(tcx, variant_id);\n \n             check_struct_pat_fields(pcx, span, path, fields, class_fields,\n                                     variant_id, substitutions, etc);\n         }\n-        Some(ast::def_class(*)) | Some(ast::def_variant(*)) => {\n+        Some(ast::def_struct(*)) | Some(ast::def_variant(*)) => {\n             let name = pprust::path_to_str(path, tcx.sess.intr());\n             tcx.sess.span_err(span,\n                               fmt!(\"mismatched types: expected `%s` but \\\n@@ -423,7 +423,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         // Grab the class data that we care about.\n         let structure = structure_of(fcx, pat.span, expected);\n         match structure {\n-            ty::ty_class(cid, ref substs) => {\n+            ty::ty_struct(cid, ref substs) => {\n                 check_struct_pat(pcx, pat.id, pat.span, expected, path,\n                                  fields, etc, cid, substs);\n             }"}, {"sha": "2b1078e7dd459de77351e92faca6e261e6dec480", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -277,7 +277,7 @@ impl LookupContext {\n                     self.push_inherent_candidates_from_self(\n                         self_ty, self_did, &substs);\n                 }\n-                ty_enum(did, _) | ty_class(did, _) => {\n+                ty_enum(did, _) | ty_struct(did, _) => {\n                     self.push_inherent_impl_candidates_for_type(did);\n                 }\n                 _ => { /* No inherent methods in these types */ }\n@@ -778,7 +778,7 @@ impl LookupContext {\n             ty_self | ty_param(*) | ty_nil | ty_bot | ty_bool |\n             ty_int(*) | ty_uint(*) |\n             ty_float(*) | ty_enum(*) | ty_ptr(*) | ty_rec(*) |\n-            ty_class(*) | ty_tup(*) | ty_estr(*) | ty_evec(*) |\n+            ty_struct(*) | ty_tup(*) | ty_estr(*) | ty_evec(*) |\n             ty_trait(*) | ty_fn(*) => {\n                 self.search_for_some_kind_of_autorefd_method(\n                     AutoPtr, autoderefs, [m_const, m_imm, m_mutbl],"}, {"sha": "7611f62609f332794185e4447334eb9c9130b199", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -483,7 +483,7 @@ fn check_struct(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n     let tcx = ccx.tcx;\n     let self_ty = ty::node_id_to_type(tcx, id);\n \n-    do option::iter(&struct_def.dtor) |dtor| {\n+    do struct_def.dtor.iter() |dtor| {\n         let class_t = {self_ty: self_ty,\n                        self_id: dtor.node.self_id,\n                        def_id: local_def(id),\n@@ -495,10 +495,6 @@ fn check_struct(ccx: @crate_ctxt, struct_def: @ast::struct_def,\n                       Some(class_t));\n     };\n \n-    // typecheck the methods\n-    for struct_def.methods.each |m| {\n-        check_method(ccx, *m, self_ty, local_def(id));\n-    }\n     // Check that the class is instantiable\n     check_instantiable(ccx.tcx, span, id);\n }\n@@ -539,7 +535,7 @@ fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n             }\n         }\n       }\n-      ast::item_class(struct_def, _) => {\n+      ast::item_struct(struct_def, _) => {\n         check_struct(ccx, struct_def, it.id, it.span);\n       }\n       ast::item_ty(t, tps) => {\n@@ -940,15 +936,15 @@ fn impl_self_ty(vcx: &VtableContext,\n              region_param: region_param,\n              raw_ty: vcx.ccx.to_ty(rscope::type_rscope(region_param), st)}\n           }\n-          Some(ast_map::node_item(@{node: ast::item_class(_, ts),\n+          Some(ast_map::node_item(@{node: ast::item_struct(_, ts),\n                                     id: class_id, _},_)) => {\n               /* If the impl is a class, the self ty is just the class ty\n                  (doing a no-op subst for the ty params; in the next step,\n                  we substitute in fresh vars for them)\n                */\n               {n_tps: ts.len(),\n                region_param: region_param,\n-               raw_ty: ty::mk_class(tcx, local_def(class_id),\n+               raw_ty: ty::mk_struct(tcx, local_def(class_id),\n                       {self_r: rscope::bound_self_region(region_param),\n                        self_ty: None,\n                        tps: ty::ty_params_to_tys(tcx, ts)})}\n@@ -1538,14 +1534,14 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                     _ => ()\n                 }\n             }\n-            ty::ty_class(base_id, ref substs) => {\n+            ty::ty_struct(base_id, ref substs) => {\n                 // This is just for fields -- the same code handles\n                 // methods in both classes and traits\n \n                 // (1) verify that the class id actually has a field called\n                 // field\n                 debug!(\"class named %s\", ty_to_str(tcx, base_t));\n-                let cls_items = ty::lookup_class_fields(tcx, base_id);\n+                let cls_items = ty::lookup_struct_fields(tcx, base_id);\n                 match lookup_field_ty(tcx, base_id, cls_items,\n                                       field, &(*substs)) {\n                     Some(field_ty) => {\n@@ -1685,7 +1681,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                 tcx.region_paramd_items.find(class_id.node);\n             match tcx.items.find(class_id.node) {\n                 Some(ast_map::node_item(@{\n-                        node: ast::item_class(_, type_parameters),\n+                        node: ast::item_struct(_, type_parameters),\n                         _\n                     }, _)) => {\n \n@@ -1694,7 +1690,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                     let self_region =\n                         bound_self_region(region_parameterized);\n \n-                    raw_type = ty::mk_class(tcx, class_id, {\n+                    raw_type = ty::mk_struct(tcx, class_id, {\n                         self_r: self_region,\n                         self_ty: None,\n                         tps: ty::ty_params_to_tys(tcx, type_parameters)\n@@ -1727,7 +1723,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let struct_type = ty::subst(tcx, &substitutions, raw_type);\n \n         // Look up and check the fields.\n-        let class_fields = ty::lookup_class_fields(tcx, class_id);\n+        let class_fields = ty::lookup_struct_fields(tcx, class_id);\n         bot = check_struct_or_variant_fields(fcx,\n                                              span,\n                                              class_id,\n@@ -1808,7 +1804,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let enum_type = ty::subst(tcx, &substitutions, raw_type);\n \n         // Look up and check the enum variant fields.\n-        let variant_fields = ty::lookup_class_fields(tcx, variant_id);\n+        let variant_fields = ty::lookup_struct_fields(tcx, variant_id);\n         bot = check_struct_or_variant_fields(fcx,\n                                              span,\n                                              variant_id,\n@@ -1927,7 +1923,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                          with a single variant which has a \\\n                          single argument\");\n                   }\n-                  ty::ty_class(*) => {\n+                  ty::ty_struct(*) => {\n                     tcx.sess.span_err(\n                         expr.span,\n                         ~\"can only dereference structs with one anonymous \\\n@@ -2351,7 +2347,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n       ast::expr_struct(path, ref fields, base_expr) => {\n         // Resolve the path.\n         match tcx.def_map.find(id) {\n-            Some(ast::def_class(type_def_id)) => {\n+            Some(ast::def_struct(type_def_id)) => {\n                 check_struct_constructor(fcx, id, expr.span, type_def_id,\n                                          (*fields), base_expr);\n             }\n@@ -2627,7 +2623,7 @@ fn check_enum_variants(ccx: @crate_ctxt,\n                     arg_tys = Some(~[]);\n                 }\n                 ast::struct_variant_kind(_) => {\n-                    arg_tys = Some(ty::lookup_class_fields(\n+                    arg_tys = Some(ty::lookup_struct_fields(\n                         ccx.tcx, local_def(v.node.id)).map(|cf|\n                             ty::node_id_to_type(ccx.tcx, cf.id.node)));\n                 }\n@@ -2731,7 +2727,7 @@ fn ty_param_bounds_and_ty_for_def(fcx: @fn_ctxt, sp: span, defn: ast::def) ->\n \n       ast::def_fn(id, _) | ast::def_static_method(id, _, _) |\n       ast::def_const(id) | ast::def_variant(_, id) |\n-      ast::def_class(id) => {\n+      ast::def_struct(id) => {\n         return ty::lookup_item_type(fcx.ccx.tcx, id);\n       }\n       ast::def_upvar(_, inner, _, _) => {"}, {"sha": "c2119471def53b108507acdabab7b2c85ae92843", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 5, "deletions": 29, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -21,7 +21,7 @@ use metadata::decoder::{dl_def, dl_field, dl_impl};\n use middle::resolve::{Impl, MethodInfo};\n use middle::ty::{DerivedMethodInfo, ProvidedMethodSource,\n                  ProvidedMethodInfo, get};\n-use middle::ty::{lookup_item_type, subst, t, ty_bot, ty_box, ty_class};\n+use middle::ty::{lookup_item_type, subst, t, ty_bot, ty_box, ty_struct};\n use middle::ty::{ty_bool, ty_enum, ty_int, ty_nil, ty_ptr, ty_rptr, ty_uint};\n use middle::ty::{ty_float, ty_estr, ty_evec, ty_rec, ty_uniq};\n use middle::ty::{ty_err, ty_fn, ty_trait, ty_tup, ty_infer};\n@@ -30,7 +30,7 @@ use middle::ty::{ty_opaque_closure_ptr, ty_unboxed_vec, type_is_ty_var};\n use middle::typeck::infer::{infer_ctxt, can_mk_subty};\n use middle::typeck::infer::{new_infer_ctxt, resolve_ivar, resolve_type};\n use syntax::ast::{crate, def_id, def_mod, def_ty};\n-use syntax::ast::{item, item_class, item_const, item_enum, item_fn};\n+use syntax::ast::{item, item_struct, item_const, item_enum, item_fn};\n use syntax::ast::{item_foreign_mod, item_impl, item_mac, item_mod};\n use syntax::ast::{item_trait, item_ty, local_crate, method, node_id};\n use syntax::ast::{trait_ref};\n@@ -78,7 +78,7 @@ fn get_base_type(inference_context: infer_ctxt, span: span, original_type: t)\n                           base_mutability_and_type.ty)\n         }\n \n-        ty_enum(*) | ty_trait(*) | ty_class(*) => {\n+        ty_enum(*) | ty_trait(*) | ty_struct(*) => {\n             debug!(\"(getting base type) found base type\");\n             Some(resolved_type)\n         }\n@@ -108,7 +108,7 @@ fn get_base_type_def_id(inference_context: infer_ctxt,\n         Some(base_type) => {\n             match get(base_type).sty {\n                 ty_enum(def_id, _) |\n-                ty_class(def_id, _) |\n+                ty_struct(def_id, _) |\n                 ty_trait(def_id, _, _) => {\n                     return Some(def_id);\n                 }\n@@ -188,9 +188,6 @@ impl CoherenceChecker {\n                     item_impl(_, opt_trait, _, _) => {\n                         self.check_implementation(item, opt_trait.to_vec());\n                     }\n-                    item_class(struct_def, _) => {\n-                        self.check_implementation(item, struct_def.traits);\n-                    }\n                     _ => {\n                         // Nothing to do.\n                     }\n@@ -772,10 +769,6 @@ impl CoherenceChecker {\n                     methods: methods\n                 };\n             }\n-            item_class(struct_def, _) => {\n-                return self.create_impl_from_struct(struct_def, item.ident,\n-                                                    item.id);\n-            }\n             _ => {\n                 self.crate_context.tcx.sess.span_bug(item.span,\n                                                      ~\"can't convert a \\\n@@ -784,23 +777,6 @@ impl CoherenceChecker {\n         }\n     }\n \n-    fn create_impl_from_struct(struct_def: @ast::struct_def,\n-                               ident: ast::ident,\n-                               id: node_id)\n-                            -> @Impl {\n-        let mut methods = ~[];\n-        for struct_def.methods.each |ast_method| {\n-            methods.push(@{\n-                did: local_def(ast_method.id),\n-                n_tps: ast_method.tps.len(),\n-                ident: ast_method.ident,\n-                self_type: ast_method.self_ty.node\n-            });\n-        }\n-\n-        return @{ did: local_def(id), ident: ident, methods: methods };\n-    }\n-\n     fn span_of_impl(implementation: @Impl) -> span {\n         assert implementation.did.crate == local_crate;\n         match self.crate_context.tcx.items.find(implementation.did.node) {\n@@ -999,7 +975,7 @@ impl CoherenceChecker {\n \n             let self_type = self.get_self_type_for_implementation(*impl_info);\n             match ty::get(self_type.ty).sty {\n-                ty::ty_class(type_def_id, _) => {\n+                ty::ty_struct(type_def_id, _) => {\n                     tcx.destructor_for_type.insert(type_def_id,\n                                                    method_def_id);\n                     tcx.destructors.insert(method_def_id, ());"}, {"sha": "5614c3aac80192ab008d1aede93e37e4160c1197", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -259,14 +259,7 @@ fn ensure_trait_methods(ccx: @crate_ctxt, id: ast::node_id, trait_ty: ty::t) {\n             method_ty\n         });\n       }\n-      ast_map::node_item(@{node: ast::item_class(struct_def, _), _}, _) => {\n-        // All methods need to be stored, since lookup_method\n-        // relies on the same method cache for self-calls\n-        store_methods::<@ast::method>(ccx, id, struct_def.methods, |m| {\n-            ty_of_method(ccx, *m, region_paramd)\n-        });\n-      }\n-      _ => { /* Ignore things that aren't traits or classes */ }\n+      _ => { /* Ignore things that aren't traits */ }\n     }\n }\n \n@@ -595,7 +588,7 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n         // check_methods_against_trait(ccx, tps, rp, selfty, *t, cms);\n         // }\n       }\n-      ast::item_class(struct_def, tps) => {\n+      ast::item_struct(struct_def, tps) => {\n         // Write the class type\n         let tpt = ty_of_item(ccx, it);\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n@@ -636,18 +629,13 @@ fn convert_struct(ccx: @crate_ctxt,\n                            region_param: rp,\n                            ty: t_dtor});\n     };\n-    ensure_trait_methods(ccx, id, tpt.ty);\n \n     // Write the type of each of the members\n     for struct_def.fields.each |f| {\n        convert_field(ccx, rp, tpt.bounds, *f);\n     }\n-    let {bounds: bounds, substs: substs} = mk_substs(ccx, tps, rp);\n-    let selfty = ty::mk_class(tcx, local_def(id), substs);\n-    let cms = convert_methods(ccx, struct_def.methods, rp, bounds);\n-    for struct_def.traits.each |trait_ref| {\n-        check_methods_against_trait(ccx, tps, rp, selfty, *trait_ref, cms);\n-    }\n+    let {bounds: _, substs: substs} = mk_substs(ccx, tps, rp);\n+    let selfty = ty::mk_struct(tcx, local_def(id), substs);\n \n     // If this struct is enum-like or tuple-like, create the type of its\n     // constructor.\n@@ -835,9 +823,9 @@ fn ty_of_item(ccx: @crate_ctxt, it: @ast::item)\n         tcx.tcache.insert(local_def(it.id), tpt);\n         return tpt;\n       }\n-      ast::item_class(_, tps) => {\n+      ast::item_struct(_, tps) => {\n           let {bounds: bounds, substs: substs} = mk_substs(ccx, tps, rp);\n-          let t = ty::mk_class(tcx, local_def(it.id), substs);\n+          let t = ty::mk_struct(tcx, local_def(it.id), substs);\n           let tpt = {bounds: bounds,\n                      region_param: rp,\n                      ty: t};"}, {"sha": "bdd286dd484bda35cbc1beeec45a637284ed820a", "filename": "src/librustc/middle/typeck/deriving.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fderiving.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -28,7 +28,7 @@ use syntax::visit::{default_simple_visitor, mk_simple_visitor, visit_crate};\n use middle::resolve::{Impl, MethodInfo};\n use middle::ty;\n use middle::ty::{DerivedFieldInfo, ReVar, re_infer, re_static, substs};\n-use middle::ty::{ty_class, ty_enum, ty_param_bounds_and_ty};\n+use middle::ty::{ty_struct, ty_enum, ty_param_bounds_and_ty};\n use /*middle::typeck::*/check::method;\n use /*middle::typeck::*/check::vtable;\n use /*middle::typeck::*/infer::infer_ctxt;\n@@ -182,7 +182,7 @@ impl DerivingChecker {\n                                  impl_span: span) {\n         let tcx = self.crate_context.tcx;\n         let field_info = dvec::DVec();\n-        for ty::lookup_class_fields(tcx, struct_def_id).each |field| {\n+        for ty::lookup_struct_fields(tcx, struct_def_id).each |field| {\n             let field_type = ty::lookup_field_type(\n                 tcx, struct_def_id, field.id, struct_substs);\n             match self.check_deriving_for_substructure_type(field_type,\n@@ -288,7 +288,7 @@ impl DerivingChecker {\n                                         item.id,\n                                         item.span);\n                                 }\n-                                ty_class(def_id, ref substs) => {\n+                                ty_struct(def_id, ref substs) => {\n                                     self.check_deriving_for_struct(\n                                         def_id,\n                                         substs,"}, {"sha": "1972be22b02fffc1c3840b86db5acc40853748db", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -452,10 +452,10 @@ fn super_tys<C:combine>(\n         }\n       }\n \n-      (ty::ty_class(a_id, ref a_substs), ty::ty_class(b_id, ref b_substs))\n+      (ty::ty_struct(a_id, ref a_substs), ty::ty_struct(b_id, ref b_substs))\n       if a_id == b_id => {\n         do self.substs(a_id, a_substs, b_substs).chain |substs| {\n-            Ok(ty::mk_class(tcx, a_id, substs))\n+            Ok(ty::mk_struct(tcx, a_id, substs))\n         }\n       }\n "}, {"sha": "c585b45e7ac00b6f9193a7ea00a5e460aef810a0", "filename": "src/librustc/middle/typeck/infer/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ftest.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -122,7 +122,7 @@ impl Env {\n                     None\n                 }\n \n-                ast::item_enum(*) | ast::item_class(*) |\n+                ast::item_enum(*) | ast::item_struct(*) |\n                 ast::item_trait(*) | ast::item_impl(*) |\n                 ast::item_mac(*) => {\n                     None"}, {"sha": "783c91c2ac62eb336c828126e199276ac95d0362", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -18,7 +18,7 @@ use middle::ty::{ctxt, field, method};\n use middle::ty::{mt, t, param_bound};\n use middle::ty::{re_bound, re_free, re_scope, re_infer, re_static, Region};\n use middle::ty::{ReSkolemized, ReVar};\n-use middle::ty::{ty_bool, ty_bot, ty_box, ty_class, ty_enum};\n+use middle::ty::{ty_bool, ty_bot, ty_box, ty_struct, ty_enum};\n use middle::ty::{ty_err, ty_estr, ty_evec, ty_float, ty_fn, ty_trait, ty_int};\n use middle::ty::{ty_nil, ty_opaque_box, ty_opaque_closure_ptr, ty_param};\n use middle::ty::{ty_ptr, ty_rec, ty_rptr, ty_self, ty_tup};\n@@ -408,7 +408,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         ~\"'\" + str::from_bytes(~[('a' as u8) + (id as u8)])\n       }\n       ty_self => ~\"self\",\n-      ty_enum(did, ref substs) | ty_class(did, ref substs) => {\n+      ty_enum(did, ref substs) | ty_struct(did, ref substs) => {\n         let path = ty::item_path(cx, did);\n         let base = ast_map::path_to_str(path, cx.sess.intr());\n         parameterized(cx, base, (*substs).self_r, (*substs).tps)"}, {"sha": "717ae9d7fba8e4514a1fc6e3fb6f80d6cfefcb53", "filename": "src/librustdoc/extract.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustdoc%2Fextract.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustdoc%2Fextract.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fextract.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -127,7 +127,7 @@ fn moddoc_from_mod(\n                     tydoc_from_ty(ItemDoc)\n                 ))\n               }\n-              ast::item_class(def, _) => {\n+              ast::item_struct(def, _) => {\n                 Some(doc::StructTag(\n                     structdoc_from_struct(ItemDoc, def)\n                 ))"}, {"sha": "4609454315f2633bf940454e58241f393989998a", "filename": "src/librustdoc/tystr_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustdoc%2Ftystr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibrustdoc%2Ftystr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftystr_pass.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -360,12 +360,12 @@ fn fold_struct(\n /// what I actually want\n fn strip_struct_extra_stuff(item: @ast::item) -> @ast::item {\n     let node = match item.node {\n-        ast::item_class(def, tys) => {\n+        ast::item_struct(def, tys) => {\n             let def = @{\n                 dtor: None, // Remove the drop { } block\n                 .. *def\n             };\n-            ast::item_class(def, tys)\n+            ast::item_struct(def, tys)\n         }\n         _ => fail ~\"not a struct\"\n     };"}, {"sha": "b36555e01ef7ed33d2d5a2ed4b4f711521f07039", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 26, "deletions": 38, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -134,8 +134,8 @@ enum def {\n               @def,     // closed over def\n               node_id,  // expr node that creates the closure\n               node_id), // id for the block/body of the closure expr\n-    def_class(def_id),\n-    def_typaram_binder(node_id), /* class, impl or trait that has ty params */\n+    def_struct(def_id),\n+    def_typaram_binder(node_id), /* struct, impl or trait with ty params */\n     def_region(node_id),\n     def_label(node_id)\n }\n@@ -235,9 +235,9 @@ impl def : cmp::Eq {\n                     _ => false\n                 }\n             }\n-            def_class(e0a) => {\n+            def_struct(e0a) => {\n                 match (*other) {\n-                    def_class(e0b) => e0a == e0b,\n+                    def_struct(e0b) => e0a == e0b,\n                     _ => false\n                 }\n             }\n@@ -1408,13 +1408,11 @@ impl attr_style : cmp::Eq {\n type attribute_ = {style: attr_style, value: meta_item, is_sugared_doc: bool};\n \n /*\n-  trait_refs appear in both impls and in classes that implement traits.\n+  trait_refs appear in impls.\n   resolve maps each trait_ref's ref_id to its defining trait; that's all\n   that the ref_id is for. The impl_id maps to the \"self type\" of this impl.\n   If this impl is an item_impl, the impl_id is redundant (it could be the\n-  same as the impl's node id). If this impl is actually an impl_class, then\n-  conceptually, the impl_id stands in for the pair of (this class, this\n-  trait)\n+  same as the impl's node id).\n  */\n #[auto_serialize]\n #[auto_deserialize]\n@@ -1451,19 +1449,19 @@ type struct_field = spanned<struct_field_>;\n #[auto_serialize]\n #[auto_deserialize]\n enum struct_field_kind {\n-    named_field(ident, class_mutability, visibility),\n+    named_field(ident, struct_mutability, visibility),\n     unnamed_field   // element of a tuple-like struct\n }\n \n impl struct_field_kind : cmp::Eq {\n     pure fn eq(&self, other: &struct_field_kind) -> bool {\n         match (*self) {\n-            named_field(ident_a, class_mutability_a, visibility_a) => {\n+            named_field(ident_a, struct_mutability_a, visibility_a) => {\n                 match *other {\n-                    named_field(ident_b, class_mutability_b, visibility_b)\n+                    named_field(ident_b, struct_mutability_b, visibility_b)\n                             => {\n                         ident_a == ident_b &&\n-                        class_mutability_a == class_mutability_b &&\n+                        struct_mutability_a == struct_mutability_b &&\n                         visibility_a == visibility_b\n                     }\n                     unnamed_field => false\n@@ -1485,12 +1483,10 @@ impl struct_field_kind : cmp::Eq {\n #[auto_serialize]\n #[auto_deserialize]\n type struct_def = {\n-    traits: ~[@trait_ref],   /* traits this struct implements */\n     fields: ~[@struct_field], /* fields */\n-    methods: ~[@method],    /* methods */\n     /* (not including ctor or dtor) */\n     /* dtor is optional */\n-    dtor: Option<class_dtor>,\n+    dtor: Option<struct_dtor>,\n     /* ID of the constructor. This is only used for tuple- or enum-like\n      * structs. */\n     ctor_id: Option<node_id>\n@@ -1515,7 +1511,7 @@ enum item_ {\n     item_foreign_mod(foreign_mod),\n     item_ty(@Ty, ~[ty_param]),\n     item_enum(enum_def, ~[ty_param]),\n-    item_class(@struct_def, ~[ty_param]),\n+    item_struct(@struct_def, ~[ty_param]),\n     item_trait(~[ty_param], ~[@trait_ref], ~[trait_method]),\n     item_impl(~[ty_param],\n               Option<@trait_ref>, /* (optional) trait this impl implements */\n@@ -1526,41 +1522,33 @@ enum item_ {\n \n #[auto_serialize]\n #[auto_deserialize]\n-enum class_mutability { class_mutable, class_immutable }\n+enum struct_mutability { struct_mutable, struct_immutable }\n \n-impl class_mutability : to_bytes::IterBytes {\n+impl struct_mutability : to_bytes::IterBytes {\n     pure fn iter_bytes(&self, +lsb0: bool, f: to_bytes::Cb) {\n         (*self as u8).iter_bytes(lsb0, f)\n     }\n }\n \n-impl class_mutability : cmp::Eq {\n-    pure fn eq(&self, other: &class_mutability) -> bool {\n+impl struct_mutability : cmp::Eq {\n+    pure fn eq(&self, other: &struct_mutability) -> bool {\n         match ((*self), (*other)) {\n-            (class_mutable, class_mutable) => true,\n-            (class_immutable, class_immutable) => true,\n-            (class_mutable, _) => false,\n-            (class_immutable, _) => false,\n+            (struct_mutable, struct_mutable) => true,\n+            (struct_immutable, struct_immutable) => true,\n+            (struct_mutable, _) => false,\n+            (struct_immutable, _) => false,\n         }\n     }\n-    pure fn ne(&self, other: &class_mutability) -> bool { !(*self).eq(other) }\n+    pure fn ne(&self, other: &struct_mutability) -> bool {\n+        !(*self).eq(other)\n+    }\n }\n \n-type class_ctor = spanned<class_ctor_>;\n-\n-#[auto_serialize]\n-#[auto_deserialize]\n-type class_ctor_ = {id: node_id,\n-                    attrs: ~[attribute],\n-                    self_id: node_id,\n-                    dec: fn_decl,\n-                    body: blk};\n-\n-type class_dtor = spanned<class_dtor_>;\n+type struct_dtor = spanned<struct_dtor_>;\n \n #[auto_serialize]\n #[auto_deserialize]\n-type class_dtor_ = {id: node_id,\n+type struct_dtor_ = {id: node_id,\n                     attrs: ~[attribute],\n                     self_id: node_id,\n                     body: blk};\n@@ -1591,7 +1579,7 @@ enum inlined_item {\n     ii_item(@item),\n     ii_method(def_id /* impl id */, @method),\n     ii_foreign(@foreign_item),\n-    ii_dtor(class_dtor, ident, ~[ty_param], def_id /* parent id */)\n+    ii_dtor(struct_dtor, ident, ~[ty_param], def_id /* parent id */)\n }\n \n "}, {"sha": "6e684d0daf4f32262acc9be2a9b46f09cbda152f", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -81,8 +81,8 @@ enum ast_node {\n     // order they are introduced.\n     node_arg(arg, uint),\n     node_local(uint),\n-    // Destructor for a class\n-    node_dtor(~[ty_param], @class_dtor, def_id, @path),\n+    // Destructor for a struct\n+    node_dtor(~[ty_param], @struct_dtor, def_id, @path),\n     node_block(blk),\n     node_struct_ctor(@struct_def, @item, @path),\n }\n@@ -245,13 +245,11 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n                                             }));\n         }\n       }\n-      item_class(struct_def, _) => {\n-        map_struct_def(struct_def, node_item(i, item_path), i.ident, i.id, cx,\n+      item_struct(struct_def, _) => {\n+        map_struct_def(struct_def, node_item(i, item_path), i.ident, cx,\n                        v);\n       }\n       item_trait(_, traits, ref methods) => {\n-        // Map trait refs to their parent classes. This is\n-        // so we can find the self_ty\n         for traits.each |p| {\n             cx.map.insert(p.ref_id, node_item(i, item_path));\n         }\n@@ -274,18 +272,8 @@ fn map_item(i: @item, cx: ctx, v: vt) {\n }\n \n fn map_struct_def(struct_def: @ast::struct_def, parent_node: ast_node,\n-                  ident: ast::ident, id: ast::node_id, cx: ctx, _v: vt) {\n-    // Map trait refs to their parent classes. This is\n-    // so we can find the self_ty\n-    for struct_def.traits.each |p| {\n-        cx.map.insert(p.ref_id, parent_node);\n-    }\n-    let d_id = ast_util::local_def(id);\n+                  ident: ast::ident, cx: ctx, _v: vt) {\n     let p = extend(cx, ident);\n-    // only need to handle methods\n-    for vec::each(struct_def.methods) |m| {\n-        map_method(d_id, p, *m, cx);\n-    }\n     // If this is a tuple-like struct, register the constructor.\n     match struct_def.ctor_id {\n         None => {}\n@@ -342,7 +330,7 @@ fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n           item_foreign_mod(*) => ~\"foreign mod\",\n           item_ty(*) => ~\"ty\",\n           item_enum(*) => ~\"enum\",\n-          item_class(*) => ~\"class\",\n+          item_struct(*) => ~\"struct\",\n           item_trait(*) => ~\"trait\",\n           item_impl(*) => ~\"impl\",\n           item_mac(*) => ~\"macro\""}, {"sha": "3a8d399a45cdbc590eb509a7ac5ffe66cd0f7060", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -68,7 +68,7 @@ pure fn def_id_of_def(d: def) -> def_id {\n       def_fn(id, _) | def_static_method(id, _, _) | def_mod(id) |\n       def_foreign_mod(id) | def_const(id) |\n       def_variant(_, id) | def_ty(id) | def_ty_param(id, _) |\n-      def_use(id) | def_class(id) => {\n+      def_use(id) | def_struct(id) => {\n         id\n       }\n       def_arg(id, _) | def_local(id, _) | def_self(id) |\n@@ -374,7 +374,7 @@ impl inlined_item: inlined_item_utils {\n           ii_foreign(i) => (v.visit_foreign_item)(i, e, v),\n           ii_method(_, m) => visit::visit_method_helper(m, e, v),\n           ii_dtor(ref dtor, _, tps, parent_id) => {\n-              visit::visit_class_dtor_helper((*dtor), tps, parent_id, e, v);\n+              visit::visit_struct_dtor_helper((*dtor), tps, parent_id, e, v);\n           }\n         }\n     }"}, {"sha": "44fa8ac7a1bc6c2c72584e032ed50a4c1b191c9d", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -131,7 +131,7 @@ fn expand_auto_serialize(\n \n                     ~[filter_attrs(*item), ser_impl]\n                 },\n-                ast::item_class(@{ fields, _}, tps) => {\n+                ast::item_struct(@{ fields, _}, tps) => {\n                     let ser_impl = mk_struct_ser_impl(\n                         cx,\n                         item.span,\n@@ -195,7 +195,7 @@ fn expand_auto_deserialize(\n \n                     ~[filter_attrs(*item), deser_impl]\n                 },\n-                ast::item_class(@{ fields, _}, tps) => {\n+                ast::item_struct(@{ fields, _}, tps) => {\n                     let deser_impl = mk_struct_deser_impl(\n                         cx,\n                         item.span,\n@@ -755,8 +755,8 @@ fn mk_struct_fields(fields: ~[@ast::struct_field]) -> ~[field] {\n             span: field.span,\n             ident: ident,\n             mutbl: match mutbl {\n-                ast::class_mutable => ast::m_mutbl,\n-                ast::class_immutable => ast::m_imm,\n+                ast::struct_mutable => ast::m_mutbl,\n+                ast::struct_immutable => ast::m_imm,\n             },\n         }\n     }"}, {"sha": "f37f1e268ce40cb676deefa1dd47c0888d4f4354", "filename": "src/libsyntax/ext/deriving.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibsyntax%2Fext%2Fderiving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibsyntax%2Fext%2Fderiving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -12,7 +12,7 @@\n /// #[deriving_iter_bytes] extensions.\n \n use ast::{Ty, and, bind_by_ref, binop, deref, enum_def, enum_variant_kind};\n-use ast::{expr, expr_match, ident, item, item_, item_class, item_enum};\n+use ast::{expr, expr_match, ident, item, item_, item_struct, item_enum};\n use ast::{item_impl, m_imm, meta_item, method, named_field, or, pat};\n use ast::{pat_ident, pat_wild, public, pure_fn, re_anon, stmt, struct_def};\n use ast::{struct_variant_kind, sty_by_ref, sty_region, tuple_variant_kind};\n@@ -83,7 +83,7 @@ fn expand_deriving(cx: ext_ctxt,\n     for in_items.each |item| {\n         result.push(copy *item);\n         match item.node {\n-            item_class(struct_def, copy ty_params) => {\n+            item_struct(struct_def, copy ty_params) => {\n                 result.push(expand_deriving_struct_def(cx,\n                                                        span,\n                                                        struct_def,"}, {"sha": "110fc664b070450015f278e1c8c69241f0e0bc42", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -234,9 +234,9 @@ fn noop_fold_item_underscore(i: item_, fld: ast_fold) -> item_ {\n                                     |x| fold_struct_def(*x, fld))\n             }), fold_ty_params(typms, fld))\n           }\n-          item_class(struct_def, typms) => {\n+          item_struct(struct_def, typms) => {\n             let struct_def = fold_struct_def(struct_def, fld);\n-              item_class(struct_def, /* FIXME (#2543) */ copy typms)\n+              item_struct(struct_def, /* FIXME (#2543) */ copy typms)\n           }\n           item_impl(tps, ifce, ty, ref methods) => {\n               item_impl(fold_ty_params(tps, fld),\n@@ -271,9 +271,7 @@ fn fold_struct_def(struct_def: @ast::struct_def, fld: ast_fold)\n                 id: dtor_id,.. dtor.node},\n             .. *dtor}};\n     return @{\n-        traits: vec::map(struct_def.traits, |p| fold_trait_ref(*p, fld)),\n         fields: vec::map(struct_def.fields, |f| fold_struct_field(*f, fld)),\n-        methods: vec::map(struct_def.methods, |m| fld.fold_method(*m)),\n         dtor: dtor,\n         ctor_id: option::map(&struct_def.ctor_id, |cid| fld.new_id(*cid))\n     };\n@@ -569,11 +567,8 @@ fn noop_fold_variant(v: variant_, fld: ast_fold) -> variant_ {\n                         id: dtor_id,.. dtor.node},\n                     .. *dtor}};\n             kind = struct_variant_kind(@{\n-                traits: ~[],\n                 fields: vec::map(struct_def.fields,\n                                  |f| fld.fold_struct_field(*f)),\n-                methods: vec::map(struct_def.methods,\n-                                  |m| fld.fold_method(*m)),\n                 dtor: dtor,\n                 ctor_id: option::map(&struct_def.ctor_id, |c| fld.new_id(*c))\n             })"}, {"sha": "79fe50ecd148fe202e0f988e9d5147876a675567", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 27, "deletions": 45, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -36,7 +36,7 @@ use ast::{_mod, add, arg, arm, attribute,\n              bind_by_ref, bind_infer, bind_by_value, bind_by_move,\n              bitand, bitor, bitxor, blk, blk_check_mode, box, by_copy,\n              by_move, by_ref, by_val, capture_clause,\n-             capture_item, class_immutable, class_mutable,\n+             capture_item, struct_immutable, struct_mutable,\n              crate, crate_cfg, decl, decl_item, decl_local,\n              default_blk, deref, div, enum_def, enum_variant_kind, expl, expr,\n              expr_, expr_addr_of, expr_match, expr_again, expr_assert,\n@@ -50,7 +50,7 @@ use ast::{_mod, add, arg, arm, attribute,\n              expr_vstore_mut_slice, expr_while, extern_fn, field, fn_decl,\n              foreign_item, foreign_item_const, foreign_item_fn, foreign_mod,\n              ident, impure_fn, infer, inherited,\n-             item, item_, item_class, item_const, item_enum, item_fn,\n+             item, item_, item_struct, item_const, item_enum, item_fn,\n              item_foreign_mod, item_impl, item_mac, item_mod, item_trait,\n              item_ty, lit, lit_, lit_bool, lit_float, lit_float_unsuffixed,\n              lit_int, lit_int_unsuffixed, lit_nil, lit_str, lit_uint, local,\n@@ -98,17 +98,10 @@ enum restriction {\n     RESTRICT_NO_BAR_OR_DOUBLEBAR_OP,\n }\n \n-enum class_member {\n-    field_member(@struct_field),\n-    method_member(@method)\n-}\n+//  So that we can distinguish a class dtor from other class members\n \n-/*\n-  So that we can distinguish a class ctor or dtor\n-  from other class members\n- */\n enum class_contents { dtor_decl(blk, ~[attribute], codemap::span),\n-                      members(~[@class_member]) }\n+                      members(~[@struct_field]) }\n \n type arg_or_capture_item = Either<arg, capture_item>;\n type item_info = (ident, item_, Option<~[attribute]>);\n@@ -2192,23 +2185,23 @@ impl Parser {\n     }\n \n     /* assumes \"let\" token has already been consumed */\n-    fn parse_instance_var(pr: visibility) -> @class_member {\n-        let mut is_mutbl = class_immutable;\n+    fn parse_instance_var(pr: visibility) -> @struct_field {\n+        let mut is_mutbl = struct_immutable;\n         let lo = self.span.lo;\n         if self.eat_keyword(~\"mut\") {\n-            is_mutbl = class_mutable;\n+            is_mutbl = struct_mutable;\n         }\n         if !is_plain_ident(self.token) {\n             self.fatal(~\"expected ident\");\n         }\n         let name = self.parse_ident();\n         self.expect(token::COLON);\n         let ty = self.parse_ty(false);\n-        return @field_member(@spanned(lo, self.last_span.hi, {\n+        return @spanned(lo, self.last_span.hi, {\n             kind: named_field(name, is_mutbl, pr),\n             id: self.get_id(),\n             ty: ty\n-        }));\n+        });\n     }\n \n     fn parse_stmt(+first_item_attrs: ~[attribute]) -> @stmt {\n@@ -2811,18 +2804,16 @@ impl Parser {\n             |p| p.parse_trait_ref())\n     }\n \n-    fn parse_item_class() -> item_info {\n+    fn parse_item_struct() -> item_info {\n         let class_name = self.parse_value_ident();\n         self.parse_region_param();\n         let ty_params = self.parse_ty_params();\n-        let traits : ~[@trait_ref] = if self.eat(token::COLON) {\n+        if self.eat(token::COLON) {\n             self.obsolete(copy self.span, ObsoleteClassTraits);\n-            self.parse_trait_ref_list(token::LBRACE)\n+            let _ = self.parse_trait_ref_list(token::LBRACE);\n         }\n-        else { ~[] };\n \n         let mut fields: ~[@struct_field];\n-        let mut methods: ~[@method] = ~[];\n         let mut the_dtor: Option<(blk, ~[attribute], codemap::span)> = None;\n         let is_tuple_like;\n \n@@ -2847,13 +2838,8 @@ impl Parser {\n                       }\n                   }\n                   members(mms) => {\n-                    for mms.each |mm| {\n-                        match *mm {\n-                            @field_member(struct_field) =>\n-                                fields.push(struct_field),\n-                            @method_member(the_method_member) =>\n-                                methods.push(the_method_member)\n-                        }\n+                    for mms.each |struct_field| {\n+                        fields.push(*struct_field)\n                     }\n                   }\n                 }\n@@ -2894,10 +2880,8 @@ impl Parser {\n         let _ = self.get_id();  // XXX: Workaround for crazy bug.\n         let new_id = self.get_id();\n         (class_name,\n-         item_class(@{\n-             traits: traits,\n+         item_struct(@{\n              fields: move fields,\n-             methods: move methods,\n              dtor: actual_dtor,\n              ctor_id: if is_tuple_like { Some(new_id) } else { None }\n          }, ty_params),\n@@ -2911,7 +2895,7 @@ impl Parser {\n         }\n     }\n \n-    fn parse_single_class_item(vis: visibility) -> @class_member {\n+    fn parse_single_class_item(vis: visibility) -> @struct_field {\n         let obsolete_let = self.eat_obsolete_ident(\"let\");\n         if obsolete_let { self.obsolete(copy self.last_span, ObsoleteLet) }\n \n@@ -2939,10 +2923,16 @@ impl Parser {\n                                                   self.token)));\n               }\n             }\n-            return a_var;\n+            a_var\n         } else {\n             self.obsolete(copy self.span, ObsoleteClassMethod);\n-            return @method_member(self.parse_method());\n+            self.parse_method();\n+            // bogus value\n+            @spanned(self.span.lo, self.span.hi,\n+                     { kind: unnamed_field, id: self.get_id(),\n+                       ty: @{id: self.get_id(),\n+                             node: ty_nil,\n+                             span: copy self.span} })\n         }\n     }\n \n@@ -3328,7 +3318,6 @@ impl Parser {\n     fn parse_struct_def() -> @struct_def {\n         let mut the_dtor: Option<(blk, ~[attribute], codemap::span)> = None;\n         let mut fields: ~[@struct_field] = ~[];\n-        let mut methods: ~[@method] = ~[];\n         while self.token != token::RBRACE {\n             match self.parse_class_item() {\n                 dtor_decl(ref blk, ref attrs, s) => {\n@@ -3346,13 +3335,8 @@ impl Parser {\n                     }\n                 }\n                 members(mms) => {\n-                    for mms.each |mm| {\n-                        match *mm {\n-                            @field_member(struct_field) =>\n-                                fields.push(struct_field),\n-                            @method_member(the_method_member) =>\n-                                methods.push(the_method_member)\n-                        }\n+                    for mms.each |struct_field| {\n+                        fields.push(*struct_field);\n                     }\n                 }\n             }\n@@ -3368,9 +3352,7 @@ impl Parser {\n         };\n \n         return @{\n-            traits: ~[],\n             fields: move fields,\n-            methods: move methods,\n             dtor: actual_dtor,\n             ctor_id: None\n         };\n@@ -3593,7 +3575,7 @@ impl Parser {\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));\n         } else if items_allowed && self.eat_keyword(~\"struct\") {\n-            let (ident, item_, extra_attrs) = self.parse_item_class();\n+            let (ident, item_, extra_attrs) = self.parse_item_struct();\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));"}, {"sha": "eda5ca1f91c1a35837c473e756fc9b0b95e14e29", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -527,7 +527,7 @@ fn print_item(s: ps, &&item: @ast::item) {\n         print_enum_def(s, (*enum_definition), params, item.ident,\n                        item.span, item.vis);\n       }\n-      ast::item_class(struct_def, tps) => {\n+      ast::item_struct(struct_def, tps) => {\n           head(s, visibility_qualified(item.vis, ~\"struct\"));\n           print_struct(s, struct_def, tps, item.ident, item.span);\n       }\n@@ -676,11 +676,6 @@ fn print_struct(s: ps, struct_def: @ast::struct_def, tps: ~[ast::ty_param],\n     print_ident(s, ident);\n     nbsp(s);\n     print_type_params(s, tps);\n-    if vec::len(struct_def.traits) != 0u {\n-        word_space(s, ~\":\");\n-        commasep(s, inconsistent, struct_def.traits, |s, p|\n-            print_path(s, p.path, false));\n-    }\n     if ast_util::struct_def_is_tuple_like(struct_def) {\n         popen(s);\n         let mut first = true;\n@@ -720,7 +715,7 @@ fn print_struct(s: ps, struct_def: @ast::struct_def, tps: ~[ast::ty_param],\n                     hardbreak_if_not_bol(s);\n                     maybe_print_comment(s, field.span.lo);\n                     print_visibility(s, visibility);\n-                    if mutability == ast::class_mutable {\n+                    if mutability == ast::struct_mutable {\n                         word_nbsp(s, ~\"mut\");\n                     }\n                     print_ident(s, ident);\n@@ -731,9 +726,6 @@ fn print_struct(s: ps, struct_def: @ast::struct_def, tps: ~[ast::ty_param],\n             }\n         }\n \n-        for struct_def.methods.each |method| {\n-            print_method(s, *method);\n-        }\n         bclose(s, span);\n     }\n }"}, {"sha": "72a605dcf1168f37d27b9e19a3d25cda54046d73", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -154,7 +154,7 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n             visit_method_helper(*m, e, v)\n         }\n       }\n-      item_class(struct_def, tps) => {\n+      item_struct(struct_def, tps) => {\n         (v.visit_ty_params)(tps, e, v);\n         (v.visit_struct_def)(struct_def, i.ident, tps, i.id, e, v);\n       }\n@@ -297,7 +297,7 @@ fn visit_method_helper<E>(m: @method, e: E, v: vt<E>) {\n                m.decl, m.body, m.span, m.id, e, v);\n }\n \n-fn visit_class_dtor_helper<E>(dtor: class_dtor, tps: ~[ty_param],\n+fn visit_struct_dtor_helper<E>(dtor: struct_dtor, tps: ~[ty_param],\n                               parent_id: def_id, e: E, v: vt<E>) {\n     (v.visit_fn)(fk_dtor(/* FIXME (#2543) */ copy tps, dtor.node.attrs,\n                        dtor.node.self_id, parent_id), ast_util::dtor_dec(),\n@@ -330,14 +330,8 @@ fn visit_struct_def<E>(sd: @struct_def, _nm: ast::ident, tps: ~[ty_param],\n     for sd.fields.each |f| {\n         (v.visit_struct_field)(*f, e, v);\n     }\n-    for sd.methods.each |m| {\n-        (v.visit_struct_method)(*m, e, v);\n-    }\n-    for sd.traits.each |p| {\n-        visit_path(p.path, e, v);\n-    }\n     do option::iter(&sd.dtor) |dtor| {\n-      visit_class_dtor_helper(*dtor, tps, ast_util::local_def(id), e, v)\n+      visit_struct_dtor_helper(*dtor, tps, ast_util::local_def(id), e, v)\n     };\n }\n "}, {"sha": "ab1aca4d76153476a30a2d819d1ee7e66cd9e307", "filename": "src/test/run-pass/guards-not-exhaustive.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Ftest%2Frun-pass%2Fguards-not-exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0046ed9462309896d6cef7208b2646c7437c8b21/src%2Ftest%2Frun-pass%2Fguards-not-exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fguards-not-exhaustive.rs?ref=0046ed9462309896d6cef7208b2646c7437c8b21", "patch": "@@ -0,0 +1,15 @@\n+use option::*;\n+\n+enum Q { R(Option<uint>) }\n+\n+fn xyzzy(q: Q) -> uint {\n+    match q {\n+        R(S) if S.is_some() => { 0 }\n+        _ => 1\n+    }\n+}\n+\n+\n+fn main() {\n+    assert xyzzy(R(Some(5))) == 0;\n+}\n\\ No newline at end of file"}]}