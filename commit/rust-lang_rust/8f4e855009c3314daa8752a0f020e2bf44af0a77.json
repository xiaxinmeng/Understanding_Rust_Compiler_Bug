{"sha": "8f4e855009c3314daa8752a0f020e2bf44af0a77", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmNGU4NTUwMDljMzMxNGRhYTg3NTJhMGYwMjBlMmJmNDRhZjBhNzc=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2014-10-05T17:32:18Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2014-10-07T03:19:14Z"}, "message": "library-level docs for collections", "tree": {"sha": "585d0132205f05744097d4f6e1396543b00322ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/585d0132205f05744097d4f6e1396543b00322ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f4e855009c3314daa8752a0f020e2bf44af0a77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f4e855009c3314daa8752a0f020e2bf44af0a77", "html_url": "https://github.com/rust-lang/rust/commit/8f4e855009c3314daa8752a0f020e2bf44af0a77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f4e855009c3314daa8752a0f020e2bf44af0a77/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2e7c4da9b331d337fba0b3911c6d3d7f48e8305", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2e7c4da9b331d337fba0b3911c6d3d7f48e8305", "html_url": "https://github.com/rust-lang/rust/commit/a2e7c4da9b331d337fba0b3911c6d3d7f48e8305"}], "stats": {"total": 323, "additions": 320, "deletions": 3}, "files": [{"sha": "336863edbab57473429dd8c30d48cc37f77a0713", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8f4e855009c3314daa8752a0f020e2bf44af0a77/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f4e855009c3314daa8752a0f020e2bf44af0a77/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=8f4e855009c3314daa8752a0f020e2bf44af0a77", "patch": "@@ -9,6 +9,9 @@\n // except according to those terms.\n \n //! Collection types.\n+//!\n+//! See [../std/collections](std::collections) for a detailed discussion of collections in Rust.\n+\n \n #![crate_name = \"collections\"]\n #![experimental]"}, {"sha": "c227aa65b48f2cc5e417c356fa727c7c01a4f284", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 317, "deletions": 3, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/8f4e855009c3314daa8752a0f020e2bf44af0a77/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f4e855009c3314daa8752a0f020e2bf44af0a77/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=8f4e855009c3314daa8752a0f020e2bf44af0a77", "patch": "@@ -8,9 +8,323 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-/*!\n- * Collection types.\n- */\n+//! Collection types.\n+//!\n+//! Rust's standard collection library provides efficient implementations of the most common\n+//! general purpose programming data structures. By using the standard implementations,\n+//! it should be possible for two libraries to communicate without significant data conversion.\n+//!\n+//! To get this out of the way: you should probably just use `Vec` or `HashMap`. These two\n+//! collections cover most use cases for generic data storage and processing. They are\n+//! exceptionally good at doing what they do. All the other collections in the standard\n+//! library have specific use cases where they are the optimal choice, but these cases are\n+//! borderline *niche* in comparison. Even when `Vec` and `HashMap` are technically suboptimal,\n+//! they're probably a good enough choice to get started.\n+//!\n+//! Rust's collections can be grouped into four major categories:\n+//!\n+//! * Sequences: `Vec`, `RingBuf`, `DList`, `BitV`\n+//! * Maps: `HashMap`, `BTreeMap`, `TreeMap`, `TrieMap`, `SmallIntMap`, `LruCache`\n+//! * Sets: `HashSet`, `BTreeSet`, `TreeSet`, `TrieSet`, `BitVSet`, `EnumSet`\n+//! * Misc: `PriorityQueue`\n+//!\n+//! # When Should You Use Which Collection?\n+//!\n+//! These are fairly high-level and quick break-downs of when each collection should be\n+//! considered. Detailed discussions of strengths and weaknesses of individual collections\n+//! can be found on their own documentation pages.\n+//!\n+//! ### Use a `Vec` when:\n+//! * You want to collect items up to be processed or sent elsewhere later, and don't care about\n+//! any properties of the actual values being stored.\n+//! * You want a sequence of elements in a particular order, and will only be appending to\n+//! (or near) the end.\n+//! * You want a stack.\n+//! * You want a resizable array.\n+//! * You want a heap-allocated array.\n+//!\n+//! ### Use a `RingBuf` when:\n+//! * You want a `Vec` that supports efficient insertion at both ends of the sequence.\n+//! * You want a queue.\n+//! * You want a double-ended queue (deque).\n+//!\n+//! ### Use a `DList` when:\n+//! * You want a `Vec` or `RingBuf` of unknown size, and can't tolerate inconsistent\n+//! performance during insertions.\n+//! * You are *absolutely* certain you *really*, *truly*, want a doubly linked list.\n+//!\n+//! ### Use a `HashMap` when:\n+//! * You want to associate arbitrary keys with an arbitrary value.\n+//! * You want a cache.\n+//! * You want a map, with no extra functionality.\n+//!\n+//! ### Use a `BTreeMap` when:\n+//! * You're interested in what the smallest or largest key-value pair is.\n+//! * You want to find the largest or smallest key that is smaller or larger than something\n+//! * You want to be able to get all of the entries in order on-demand.\n+//! * You want a sorted map.\n+//!\n+//! ### Use a `TreeMap` when:\n+//! * You want a `BTreeMap`, but can't tolerate inconsistent performance.\n+//! * You want a `BTreeMap`, but have *very large* keys or values.\n+//! * You want a `BTreeMap`, but have keys that are expensive to compare.\n+//! * You want a `BTreeMap`, but you accept arbitrary untrusted inputs.\n+//!\n+//! ### Use a `TrieMap` when:\n+//! * You want a `HashMap`, but with many potentially large `uint` keys.\n+//! * You want a `BTreeMap`, but with potentially large `uint` keys.\n+//!\n+//! ### Use a `SmallIntMap` when:\n+//! * You want a `HashMap` but with known to be small `uint` keys.\n+//! * You want a `BTreeMap`, but with known to be small `uint` keys.\n+//!\n+//! ### Use the `Set` variant of any of these `Map`s when:\n+//! * You just want to remember which keys you've seen.\n+//! * There is no meaningful value to associate with your keys.\n+//! * You just want a set.\n+//!\n+//! ### Use a `BitV` when:\n+//! * You want to store an unbounded number of booleans in a small space.\n+//! * You want a bitvector.\n+//!\n+//! ### Use a `BitVSet` when:\n+//! * You want a `SmallIntSet`.\n+//!\n+//! ### Use an `EnumSet` when:\n+//! * You want a C-like enum, stored in a single `uint`.\n+//!\n+//! ### Use a `PriorityQueue` when:\n+//! * You want to store a bunch of elements, but only ever want to process the \"biggest\"\n+//! or \"most important\" one at any given time.\n+//! * You want a priority queue.\n+//!\n+//! ### Use an `LruCache` when:\n+//! * You want a cache that discards infrequently used items when it becomes full.\n+//! * You want a least-recently-used cache.\n+//!\n+//! # Correct and Efficient Usage of Collections\n+//!\n+//! Of course, knowing which collection is the right one for the job doesn't instantly\n+//! permit you to use it correctly. Here are some quick tips for efficient and correct\n+//! usage of the standard collections in general. If you're interested in how to use a\n+//! specific collection in particular, consult its documentation for detailed discussion\n+//! and code examples.\n+//!\n+//! ## Capacity Management\n+//!\n+//! Many collections provide several constructors and methods that refer to \"capacity\".\n+//! These collections are generally built on top of an array. Optimally, this array would be\n+//! exactly the right size to fit only the elements stored in the collection, but for the\n+//! collection to do this would be very inefficient. If the backing array was exactly the\n+//! right size at all times, then every time an element is inserted, the collection would\n+//! have to grow the array to fit it. Due to the way memory is allocated and managed on most\n+//! computers, this would almost surely require allocating an entirely new array and\n+//! copying every single element from the old one into the new one. Hopefully you can\n+//! see that this wouldn't be very efficient to do on every operation.\n+//!\n+//! Most collections therefore use an *amortized* allocation strategy. They generally let\n+//! themselves have a fair amount of unoccupied space so that they only have to grow\n+//! on occasion. When they do grow, they allocate a substantially larger array to move\n+//! the elements into so that it will take a while for another grow to be required. While\n+//! this strategy is great in general, it would be even better if the collection *never*\n+//! had to resize its backing array. Unfortunately, the collection itself doesn't have\n+//! enough information to do this itself. Therefore, it is up to us programmers to give it\n+//! hints.\n+//!\n+//! Any `with_capacity` constructor will instruct the collection to allocate enough space\n+//! for the specified number of elements. Ideally this will be for exactly that many\n+//! elements, but some implementation details may prevent this. `Vec` and `RingBuf` can\n+//! be relied on to allocate exactly the requested amount, though. Use `with_capacity`\n+//! when you know exactly how many elements will be inserted, or at least have a\n+//! reasonable upper-bound on that number.\n+//!\n+//! When anticipating a large influx of elements, the `reserve` family of methods can\n+//! be used to hint to the collection how much room it should make for the coming items.\n+//! As with `with_capacity`, the precise behavior of these methods will be specific to\n+//! the collection of interest.\n+//!\n+//! For optimal performance, collections will generally avoid shrinking themselves.\n+//! If you believe that a collection will not soon contain any more elements, or\n+//! just really need the memory, the `shrink_to_fit` method prompts the collection\n+//! to shrink the backing array to the minimum size capable of holding its elements.\n+//!\n+//! Finally, if ever you're interested in what the actual capacity of the collection is,\n+//! most collections provide a `capacity` method to query this information on demand.\n+//! This can be useful for debugging purposes, or for use with the `reserve` methods.\n+//!\n+//! ## Iterators\n+//!\n+//! Iterators are a powerful and robust mechanism used throughout Rust's standard\n+//! libraries. Iterators provide a sequence of values in a generic, safe, efficient\n+//! and convenient way. The contents of an iterator are usually *lazily* evaluated,\n+//! so that only the values that are actually needed are ever actually produced, and\n+//! no allocation need be done to temporarily store them. Iterators are primarily\n+//! consumed using a `for` loop, although many functions also take iterators where\n+//! a collection or sequence of values is desired.\n+//!\n+//! All of the standard collections provide several iterators for performing bulk\n+//! manipulation of their contents. The three primary iterators almost every collection\n+//! should provide are `iter`, `iter_mut`, and `into_iter`. Some of these are not\n+//! provided on collections where it would be unsound or unreasonable to provide them.\n+//!\n+//! `iter` provides an iterator of immutable references to all the contents of a\n+//! collection in the most \"natural\" order. For sequence collections like `Vec`, this\n+//! means the items will be yielded in increasing order of index starting at 0. For ordered\n+//! collections like `BTreeMap`, this means that the items will be yielded in sorted order.\n+//! For unordered collections like `HashMap`, the items will be yielded in whatever order\n+//! the internal representation made most convenient. This is great for reading through\n+//! all the contents of the collection.\n+//!\n+//! ```\n+//! let vec = vec![1u, 2, 3, 4];\n+//! for x in vec.iter() {\n+//!    println!(\"vec contained {}\", x);\n+//! }\n+//! ```\n+//!\n+//! `iter_mut` provides an iterator of *mutable* references in the same order as `iter`.\n+//! This is great for mutating all the contents of the collection.\n+//!\n+//! ```\n+//! let mut vec = vec![1u, 2, 3, 4];\n+//! for x in vec.iter_mut() {\n+//!    *x += 1;\n+//! }\n+//! ```\n+//!\n+//! `into_iter` transforms the actual collection into an iterator over its contents\n+//! by-value. This is great when the collection itself is no longer needed, and the\n+//! values are needed elsewhere. Using `extend` with `into_iter` is the main way that\n+//! contents of one collection are moved into another. Calling `collect` on an iterator\n+//! itself is also a great way to convert one collection into another. Both of these\n+//! methods should internally use the capacity management tools discussed in the\n+//! previous section to do this as efficiently as possible.\n+//!\n+//! ```\n+//! let mut vec1 = vec![1u, 2, 3, 4];\n+//! let vec2 = vec![10u, 20, 30, 40];\n+//! vec1.extend(vec2.into_iter());\n+//! ```\n+//!\n+//! ```\n+//! use std::collections::RingBuf;\n+//!\n+//! let vec = vec![1u, 2, 3, 4];\n+//! let buf: RingBuf<uint> = vec.into_iter().collect();\n+//! ```\n+//!\n+//! Iterators also provide a series of *adapter* methods for performing common tasks to\n+//! sequences. Among the adapters are functional favorites like `map`, `fold`, `skip`,\n+//! and `take`. Of particular interest to collections is the `rev` adapter, that\n+//! reverses any iterator that supports this operation. Most collections provide reversible\n+//! iterators as the way to iterate over them in reverse order.\n+//!\n+//! ```\n+//! let vec = vec![1u, 2, 3, 4];\n+//! for x in vec.iter().rev() {\n+//!    println!(\"vec contained {}\", x);\n+//! }\n+//! ```\n+//!\n+//! Several other collection methods also return iterators to yield a sequence of results\n+//! but avoid allocating an entire collection to store the result in. This provides maximum\n+//! flexibility as `collect` or `extend` can be called to \"pipe\" the sequence into any\n+//! collection if desired. Otherwise, the sequence can be looped over with a `for` loop. The\n+//! iterator can also be discarded after partial use, preventing the computation of the unused\n+//! items.\n+//!\n+//! ## Entries\n+//!\n+//! The `entry` API is intended to provide an efficient mechanism for manipulating\n+//! the contents of a map conditionally on the presence of a key or not. The primary\n+//! motivating use case for this is to provide efficient accumulator maps. For instance,\n+//! if one wishes to maintain a count of the number of times each key has been seen,\n+//! they will have to perform some conditional logic on whether this is the first time\n+//! the key has been seen or not. Normally, this would require a `find` followed by an\n+//! `insert`, effectively duplicating the search effort on each insertion.\n+//!\n+//! When a user calls `map.entry(key)`, the map will search for the key and then yield\n+//! a variant of the `Entry` enum.\n+//!\n+//! If a `Vacant(entry)` is yielded, then the key *was not* found. In this case the\n+//! only valid operation is to `set` the value of the entry. When this is done,\n+//! the vacant entry is consumed and converted into a mutable reference to the\n+//! the value that was inserted. This allows for further manipulation of the value\n+//! beyond the lifetime of the search itself. This is useful if complex logic needs to\n+//! be performed on the value regardless of whether the value was just inserted.\n+//!\n+//! If an `Occupied(entry)` is yielded, then the key *was* found. In this case, the user\n+//! has several options: they can `get`, `set`, or `take` the value of the occupied\n+//! entry. Additionally, they can convert the occupied entry into a mutable reference\n+//! to its value, providing symmetry to the vacant `set` case.\n+//!\n+//! ### Examples\n+//!\n+//! Here are the two primary ways in which `entry` is used. First, a simple example\n+//! where the logic performed on the values is trivial.\n+//!\n+//! #### Counting the number of times each character in a string occurs\n+//!\n+//! ```\n+//! use std::collections::btree::{BTreeMap, Occupied, Vacant};\n+//!\n+//! let mut count = BTreeMap::new();\n+//! let message = \"she sells sea shells by the sea shore\";\n+//!\n+//! for c in message.chars() {\n+//!     match count.entry(c) {\n+//!         Vacant(entry) => { entry.set(1u); },\n+//!         Occupied(mut entry) => *entry.get_mut() += 1,\n+//!     }\n+//! }\n+//!\n+//! assert_eq!(count.find(&'s'), Some(&8));\n+//!\n+//! println!(\"Number of occurences of each character\");\n+//! for (char, count) in count.iter() {\n+//!     println!(\"{}: {}\", char, count);\n+//! }\n+//! ```\n+//!\n+//! When the logic to be performed on the value is more complex, we may simply use\n+//! the `entry` API to ensure that the value is initialized, and perform the logic\n+//! afterwards.\n+//!\n+//! #### Tracking the inebriation of customers at a bar\n+//!\n+//! ```\n+//! use std::collections::btree::{BTreeMap, Occupied, Vacant};\n+//!\n+//! // A client of the bar. They have an id and a blood alcohol level.\n+//! struct Person { id: u32, blood_alcohol: f32 };\n+//!\n+//! // All the orders made to the bar, by client id.\n+//! let orders = vec![1,2,1,2,3,4,1,2,2,3,4,1,1,1];\n+//!\n+//! // Our clients.\n+//! let mut blood_alcohol = BTreeMap::new();\n+//!\n+//! for id in orders.into_iter() {\n+//!     // If this is the first time we've seen this customer, initialize them\n+//!     // with no blood alcohol. Otherwise, just retrieve them.\n+//!     let person = match blood_alcohol.entry(id) {\n+//!         Vacant(entry) => entry.set(Person{id: id, blood_alcohol: 0.0}),\n+//!         Occupied(entry) => entry.into_mut(),\n+//!     };\n+//!\n+//!     // Reduce their blood alcohol level. It takes time to order and drink a beer!\n+//!     person.blood_alcohol *= 0.9;\n+//!\n+//!     // Check if they're sober enough to have another beer.\n+//!     if person.blood_alcohol > 0.3 {\n+//!         // Too drunk... for now.\n+//!         println!(\"Sorry {}, I have to cut you off\", person.id);\n+//!     } else {\n+//!         // Have another!\n+//!         person.blood_alcohol += 0.1;\n+//!     }\n+//! }\n+//! ```\n \n #![experimental]\n "}]}