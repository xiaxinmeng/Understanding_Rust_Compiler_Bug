{"sha": "987c73158e2120ef75b4b7fc46dcd88a621106d8", "node_id": "C_kwDOAAsO6NoAKDk4N2M3MzE1OGUyMTIwZWY3NWI0YjdmYzQ2ZGNkODhhNjIxMTA2ZDg", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-06-20T20:32:49Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-06-20T20:40:19Z"}, "message": "Integrate `generate_macro_def_id_path` into `href_with_root_path`", "tree": {"sha": "03da64caa52a835cab6df1fbe38d1fd56c94ba65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/03da64caa52a835cab6df1fbe38d1fd56c94ba65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/987c73158e2120ef75b4b7fc46dcd88a621106d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/987c73158e2120ef75b4b7fc46dcd88a621106d8", "html_url": "https://github.com/rust-lang/rust/commit/987c73158e2120ef75b4b7fc46dcd88a621106d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/987c73158e2120ef75b4b7fc46dcd88a621106d8/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4db07ed4c1ab8a0f7961efc60ec32193e971f5c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4db07ed4c1ab8a0f7961efc60ec32193e971f5c", "html_url": "https://github.com/rust-lang/rust/commit/f4db07ed4c1ab8a0f7961efc60ec32193e971f5c"}], "stats": {"total": 140, "additions": 72, "deletions": 68}, "files": [{"sha": "67b01245ef7ada227d7def069d9b4c974c0445ee", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 70, "deletions": 1, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/987c73158e2120ef75b4b7fc46dcd88a621106d8/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/987c73158e2120ef75b4b7fc46dcd88a621106d8/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=987c73158e2120ef75b4b7fc46dcd88a621106d8", "patch": "@@ -8,14 +8,16 @@\n use std::borrow::Cow;\n use std::cell::Cell;\n use std::fmt;\n-use std::iter;\n+use std::iter::{self, once};\n \n+use rustc_ast as ast;\n use rustc_attr::{ConstStability, StabilityLevel};\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n+use rustc_metadata::creader::{CStore, LoadedMacro};\n use rustc_middle::ty;\n use rustc_middle::ty::DefIdTree;\n use rustc_middle::ty::TyCtxt;\n@@ -557,6 +559,71 @@ pub(crate) fn join_with_double_colon(syms: &[Symbol]) -> String {\n     s\n }\n \n+/// This function is to get the external macro path because they are not in the cache used in\n+/// `href_with_root_path`.\n+fn generate_macro_def_id_path(\n+    def_id: DefId,\n+    cx: &Context<'_>,\n+    root_path: Option<&str>,\n+) -> (String, ItemType, Vec<Symbol>) {\n+    let tcx = cx.shared.tcx;\n+    let crate_name = tcx.crate_name(def_id.krate).to_string();\n+    let cache = cx.cache();\n+\n+    let fqp: Vec<Symbol> = tcx\n+        .def_path(def_id)\n+        .data\n+        .into_iter()\n+        .filter_map(|elem| {\n+            // extern blocks (and a few others things) have an empty name.\n+            match elem.data.get_opt_name() {\n+                Some(s) if !s.is_empty() => Some(s),\n+                _ => None,\n+            }\n+        })\n+        .collect();\n+    let relative = fqp.iter().map(|elem| elem.to_string());\n+    // Check to see if it is a macro 2.0 or built-in macro.\n+    // More information in <https://rust-lang.github.io/rfcs/1584-macros.html>.\n+    let is_macro_2 = match CStore::from_tcx(tcx).load_macro_untracked(def_id, tcx.sess) {\n+        LoadedMacro::MacroDef(def, _) => {\n+            // If `ast_def.macro_rules` is `true`, then it's not a macro 2.0.\n+            matches!(&def.kind, ast::ItemKind::MacroDef(ast_def) if !ast_def.macro_rules)\n+        }\n+        _ => false,\n+    };\n+\n+    let mut path = if is_macro_2 {\n+        once(crate_name.clone()).chain(relative).collect()\n+    } else {\n+        vec![crate_name.clone(), relative.last().unwrap()]\n+    };\n+    if path.len() < 2 {\n+        // The minimum we can have is the crate name followed by the macro name. If shorter, then\n+        // it means that that `relative` was empty, which is an error.\n+        panic!(\"macro path cannot be empty!\");\n+    }\n+\n+    if let Some(last) = path.last_mut() {\n+        *last = format!(\"macro.{}.html\", last);\n+    }\n+\n+    let url = match cache.extern_locations[&def_id.krate] {\n+        ExternalLocation::Remote(ref s) => {\n+            // `ExternalLocation::Remote` always end with a `/`.\n+            format!(\"{}{}\", s, path.join(\"/\"))\n+        }\n+        ExternalLocation::Local => {\n+            // `root_path` always end with a `/`.\n+            format!(\"{}{}/{}\", root_path.unwrap_or(\"\"), crate_name, path.join(\"/\"))\n+        }\n+        ExternalLocation::Unknown => {\n+            panic!(\"crate {} not in cache when linkifying macros\", crate_name)\n+        }\n+    };\n+    (url, ItemType::Macro, fqp)\n+}\n+\n pub(crate) fn href_with_root_path(\n     did: DefId,\n     cx: &Context<'_>,\n@@ -612,6 +679,8 @@ pub(crate) fn href_with_root_path(\n                         ExternalLocation::Unknown => return Err(HrefError::DocumentationNotBuilt),\n                     },\n                 )\n+            } else if matches!(def_kind, DefKind::Macro(_)) {\n+                return Ok(generate_macro_def_id_path(did, cx, root_path));\n             } else {\n                 return Err(HrefError::NotInExternalCache);\n             }"}, {"sha": "d2ef89078bf6d131751c33f49267359336fa8619", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 2, "deletions": 67, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/987c73158e2120ef75b4b7fc46dcd88a621106d8/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/987c73158e2120ef75b4b7fc46dcd88a621106d8/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=987c73158e2120ef75b4b7fc46dcd88a621106d8", "patch": "@@ -5,19 +5,15 @@\n //!\n //! Use the `render_with_highlighting` to highlight some rust code.\n \n-use crate::clean::{ExternalLocation, PrimitiveType};\n+use crate::clean::PrimitiveType;\n use crate::html::escape::Escape;\n use crate::html::render::Context;\n \n use std::collections::VecDeque;\n use std::fmt::{Display, Write};\n-use std::iter::once;\n \n-use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::def_id::DefId;\n use rustc_lexer::{LiteralKind, TokenKind};\n-use rustc_metadata::creader::{CStore, LoadedMacro};\n use rustc_span::edition::Edition;\n use rustc_span::symbol::Symbol;\n use rustc_span::{BytePos, Span, DUMMY_SP};\n@@ -784,17 +780,8 @@ fn string_without_closing_tag<T: Display>(\n                         .map(|s| format!(\"{}{}\", href_context.root_path, s)),\n                     LinkFromSrc::External(def_id) => {\n                         format::href_with_root_path(*def_id, context, Some(href_context.root_path))\n-                            .map(|(url, _, _)| url)\n-                            .or_else(|e| {\n-                                if e == format::HrefError::NotInExternalCache\n-                                    && matches!(klass, Class::Macro(_))\n-                                {\n-                                    Ok(generate_macro_def_id_path(href_context, *def_id))\n-                                } else {\n-                                    Err(e)\n-                                }\n-                            })\n                             .ok()\n+                            .map(|(url, _, _)| url)\n                     }\n                     LinkFromSrc::Primitive(prim) => format::href_with_root_path(\n                         PrimitiveType::primitive_locations(context.tcx())[prim],\n@@ -814,57 +801,5 @@ fn string_without_closing_tag<T: Display>(\n     Some(\"</span>\")\n }\n \n-/// This function is to get the external macro path because they are not in the cache used in\n-/// `href_with_root_path`.\n-fn generate_macro_def_id_path(href_context: &HrefContext<'_, '_, '_>, def_id: DefId) -> String {\n-    let tcx = href_context.context.shared.tcx;\n-    let crate_name = tcx.crate_name(def_id.krate).to_string();\n-    let cache = href_context.context.cache();\n-\n-    let relative = tcx.def_path(def_id).data.into_iter().filter_map(|elem| {\n-        // extern blocks have an empty name\n-        let s = elem.data.to_string();\n-        if !s.is_empty() { Some(s) } else { None }\n-    });\n-    // Check to see if it is a macro 2.0 or built-in macro.\n-    // More information in <https://rust-lang.github.io/rfcs/1584-macros.html>.\n-    let is_macro_2 = match CStore::from_tcx(tcx).load_macro_untracked(def_id, tcx.sess) {\n-        LoadedMacro::MacroDef(def, _) => {\n-            // If `ast_def.macro_rules` is `true`, then it's not a macro 2.0.\n-            matches!(&def.kind, ast::ItemKind::MacroDef(ast_def) if !ast_def.macro_rules)\n-        }\n-        _ => false,\n-    };\n-\n-    let mut path = if is_macro_2 {\n-        once(crate_name.clone()).chain(relative).collect()\n-    } else {\n-        vec![crate_name.clone(), relative.last().unwrap()]\n-    };\n-    if path.len() < 2 {\n-        // The minimum we can have is the crate name followed by the macro name. If shorter, then\n-        // it means that that `relative` was empty, which is an error.\n-        panic!(\"macro path cannot be empty!\");\n-    }\n-\n-    if let Some(last) = path.last_mut() {\n-        *last = format!(\"macro.{}.html\", last);\n-    }\n-\n-    match cache.extern_locations[&def_id.krate] {\n-        ExternalLocation::Remote(ref s) => {\n-            // `ExternalLocation::Remote` always end with a `/`.\n-            format!(\"{}{}\", s, path.join(\"/\"))\n-        }\n-        ExternalLocation::Local => {\n-            // `href_context.root_path` always end with a `/`.\n-            format!(\"{}{}/{}\", href_context.root_path, crate_name, path.join(\"/\"))\n-        }\n-        ExternalLocation::Unknown => {\n-            panic!(\"crate {} not in cache when linkifying macros\", crate_name)\n-        }\n-    }\n-}\n-\n #[cfg(test)]\n mod tests;"}]}