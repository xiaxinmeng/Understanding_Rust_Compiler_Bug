{"sha": "45e5a856a6551ae1b77fe8c5585e80f886b44b6e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1ZTVhODU2YTY1NTFhZTFiNzdmZThjNTU4NWU4MGY4ODZiNDRiNmU=", "commit": {"author": {"name": "Pietro Albini", "email": "pietro@pietroalbini.org", "date": "2018-11-25T16:05:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-11-25T16:05:02Z"}, "message": "Rollup merge of #56100 - RalfJung:visiting-generators, r=oli-obk\n\ngenerator fields are not necessarily initialized\n\nLooking at the MIR we generate for generators, I think we deliberately leave fields of the generator uninitialized in ways that would be illegal if this was a normal struct (or rather, one would have to use `MaybeUninit`). Consider [this example](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=417b4a2950421b726dd7b307e9ee3bec):\n```rust\n#![feature(generators, generator_trait)]\n\nfn main() {\n    let generator = || {\n        let mut x = Box::new(5);\n        {\n            let y = &mut *x;\n            *y = 5;\n            yield *y;\n            *y = 10;\n        }\n        *x\n    };\n    let _gen = generator;\n}\n```\n\nIt generates the MIR\n```\nfn main() -> (){\n    let mut _0: ();                      // return place\n    scope 1 {\n        scope 3 {\n        }\n        scope 4 {\n            let _2: [generator@src/main.rs:4:21: 13:6 for<'r> {std::boxed::Box<i32>, i32, &'r mut i32, ()}]; // \"_gen\" in scope 4 at src/main.rs:14:9: 14:13\n        }\n    }\n    scope 2 {\n        let _1: [generator@src/main.rs:4:21: 13:6 for<'r> {std::boxed::Box<i32>, i32, &'r mut i32, ()}]; // \"generator\" in scope 2 at src/main.rs:4:9: 4:18\n    }\n\n    bb0: {\n        StorageLive(_1);                 // bb0[0]: scope 0 at src/main.rs:4:9: 4:18\n        (_1.0: u32) = const 0u32;        // bb0[1]: scope 0 at src/main.rs:4:21: 13:6\n                                         // ty::Const\n                                         // + ty: u32\n                                         // + val: Scalar(Bits { size: 4, bits: 0 })\n                                         // mir::Constant\n                                         // + span: src/main.rs:4:21: 13:6\n                                         // + ty: u32\n                                         // + literal: Const { ty: u32, val: Scalar(Bits { size: 4, bits: 0 }) }\n        StorageLive(_2);                 // bb0[2]: scope 1 at src/main.rs:14:9: 14:13\n        _2 = move _1;                    // bb0[3]: scope 1 at src/main.rs:14:16: 14:25\n        drop(_2) -> bb1;                 // bb0[4]: scope 1 at src/main.rs:15:1: 15:2\n    }\n\n    bb1: {\n        StorageDead(_2);                 // bb1[0]: scope 1 at src/main.rs:15:1: 15:2\n        StorageDead(_1);                 // bb1[1]: scope 0 at src/main.rs:15:1: 15:2\n        return;                          // bb1[2]: scope 0 at src/main.rs:15:2: 15:2\n    }\n}\n```\nNotice how we only initialize the first field of `_1` (even though it contains a `Box`!), and then assign it to `_2`. This violates the rule \"on assignment, all data must satisfy the validity invariant\", and hence miri complains about this code.\n\nWhat this PR effectively does is to change the validity invariant for generators such that it says nothing about the fields of the generator. We behave as if every field of the generator was wrapped in a `MaybeUninit`.\n\nr? @oli-obk\n\nCc @nikomatsakis @eddyb @cramertj @withoutboats @Zoxc", "tree": {"sha": "fe2997101b59ed992a64340beaf41c4bd33b7ed8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe2997101b59ed992a64340beaf41c4bd33b7ed8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45e5a856a6551ae1b77fe8c5585e80f886b44b6e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJb+sguCRBK7hj4Ov3rIwAAdHIIAKphs1KwOTxSp/kM0e7hMixn\nTmXuBEeNMdjrGO5LF9w4qnX9mG4nFBd9I3aS4KjO5/KW/jcu11S1ZKRRzG48XWfA\npTPX/yhVagFHy1okCex2xY8U6PGLavzvmUoh0+JcNg9cKoosSKIeuhn8Jdjky7z6\nrwVDCltp/4YIURhIrw8F4Fq0Nc9y8qpX494vIriIvLYUBefKCiW6bu76Bhbq6tUS\nB6OVtImach0pSpVwilXm9uxRDG4lErTIWV7OFpiKUQZfrdgFEJgBJ/67/sNqKfQq\n4e6YSmSe7q1qEvnNkhmukN4+VGyLotAtU0Gcq4cG9r/Rs/EyFpPzPaNg5cCSk8o=\n=FOtl\n-----END PGP SIGNATURE-----\n", "payload": "tree fe2997101b59ed992a64340beaf41c4bd33b7ed8\nparent ab5e45ae6bf54c1162e51590297cc9c2073cdfcc\nparent 6befe6784f37d953884ef05982b41c3a11932170\nauthor Pietro Albini <pietro@pietroalbini.org> 1543161902 +0100\ncommitter GitHub <noreply@github.com> 1543161902 +0100\n\nRollup merge of #56100 - RalfJung:visiting-generators, r=oli-obk\n\ngenerator fields are not necessarily initialized\n\nLooking at the MIR we generate for generators, I think we deliberately leave fields of the generator uninitialized in ways that would be illegal if this was a normal struct (or rather, one would have to use `MaybeUninit`). Consider [this example](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=417b4a2950421b726dd7b307e9ee3bec):\n```rust\n#![feature(generators, generator_trait)]\n\nfn main() {\n    let generator = || {\n        let mut x = Box::new(5);\n        {\n            let y = &mut *x;\n            *y = 5;\n            yield *y;\n            *y = 10;\n        }\n        *x\n    };\n    let _gen = generator;\n}\n```\n\nIt generates the MIR\n```\nfn main() -> (){\n    let mut _0: ();                      // return place\n    scope 1 {\n        scope 3 {\n        }\n        scope 4 {\n            let _2: [generator@src/main.rs:4:21: 13:6 for<'r> {std::boxed::Box<i32>, i32, &'r mut i32, ()}]; // \"_gen\" in scope 4 at src/main.rs:14:9: 14:13\n        }\n    }\n    scope 2 {\n        let _1: [generator@src/main.rs:4:21: 13:6 for<'r> {std::boxed::Box<i32>, i32, &'r mut i32, ()}]; // \"generator\" in scope 2 at src/main.rs:4:9: 4:18\n    }\n\n    bb0: {\n        StorageLive(_1);                 // bb0[0]: scope 0 at src/main.rs:4:9: 4:18\n        (_1.0: u32) = const 0u32;        // bb0[1]: scope 0 at src/main.rs:4:21: 13:6\n                                         // ty::Const\n                                         // + ty: u32\n                                         // + val: Scalar(Bits { size: 4, bits: 0 })\n                                         // mir::Constant\n                                         // + span: src/main.rs:4:21: 13:6\n                                         // + ty: u32\n                                         // + literal: Const { ty: u32, val: Scalar(Bits { size: 4, bits: 0 }) }\n        StorageLive(_2);                 // bb0[2]: scope 1 at src/main.rs:14:9: 14:13\n        _2 = move _1;                    // bb0[3]: scope 1 at src/main.rs:14:16: 14:25\n        drop(_2) -> bb1;                 // bb0[4]: scope 1 at src/main.rs:15:1: 15:2\n    }\n\n    bb1: {\n        StorageDead(_2);                 // bb1[0]: scope 1 at src/main.rs:15:1: 15:2\n        StorageDead(_1);                 // bb1[1]: scope 0 at src/main.rs:15:1: 15:2\n        return;                          // bb1[2]: scope 0 at src/main.rs:15:2: 15:2\n    }\n}\n```\nNotice how we only initialize the first field of `_1` (even though it contains a `Box`!), and then assign it to `_2`. This violates the rule \"on assignment, all data must satisfy the validity invariant\", and hence miri complains about this code.\n\nWhat this PR effectively does is to change the validity invariant for generators such that it says nothing about the fields of the generator. We behave as if every field of the generator was wrapped in a `MaybeUninit`.\n\nr? @oli-obk\n\nCc @nikomatsakis @eddyb @cramertj @withoutboats @Zoxc\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45e5a856a6551ae1b77fe8c5585e80f886b44b6e", "html_url": "https://github.com/rust-lang/rust/commit/45e5a856a6551ae1b77fe8c5585e80f886b44b6e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45e5a856a6551ae1b77fe8c5585e80f886b44b6e/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ab5e45ae6bf54c1162e51590297cc9c2073cdfcc", "url": "https://api.github.com/repos/rust-lang/rust/commits/ab5e45ae6bf54c1162e51590297cc9c2073cdfcc", "html_url": "https://github.com/rust-lang/rust/commit/ab5e45ae6bf54c1162e51590297cc9c2073cdfcc"}, {"sha": "6befe6784f37d953884ef05982b41c3a11932170", "url": "https://api.github.com/repos/rust-lang/rust/commits/6befe6784f37d953884ef05982b41c3a11932170", "html_url": "https://github.com/rust-lang/rust/commit/6befe6784f37d953884ef05982b41c3a11932170"}], "stats": {"total": 54, "additions": 42, "deletions": 12}, "files": [{"sha": "81e56f3115d26cfd8aa1b39ef4d88d36e45c7839", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 42, "deletions": 12, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/45e5a856a6551ae1b77fe8c5585e80f886b44b6e/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45e5a856a6551ae1b77fe8c5585e80f886b44b6e/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=45e5a856a6551ae1b77fe8c5585e80f886b44b6e", "patch": "@@ -158,7 +158,9 @@ macro_rules! make_value_visitor {\n             ) -> EvalResult<'tcx> {\n                 self.walk_aggregate(v, fields)\n             }\n-            /// Called each time we recurse down to a field, passing in old and new value.\n+\n+            /// Called each time we recurse down to a field of a \"product-like\" aggregate\n+            /// (structs, tuples, arrays and the like, but not enums), passing in old and new value.\n             /// This gives the visitor the chance to track the stack of nested fields that\n             /// we are descending through.\n             #[inline(always)]\n@@ -171,6 +173,19 @@ macro_rules! make_value_visitor {\n                 self.visit_value(new_val)\n             }\n \n+            /// Called for recursing into the field of a generator.  These are not known to be\n+            /// initialized, so we treat them like unions.\n+            #[inline(always)]\n+            fn visit_generator_field(\n+                &mut self,\n+                _old_val: Self::V,\n+                _field: usize,\n+                new_val: Self::V,\n+            ) -> EvalResult<'tcx> {\n+                self.visit_union(new_val)\n+            }\n+\n+            /// Called when recursing into an enum variant.\n             #[inline(always)]\n             fn visit_variant(\n                 &mut self,\n@@ -291,17 +306,33 @@ macro_rules! make_value_visitor {\n                         // use that as an unambiguous signal for detecting primitives.  Make sure\n                         // we did not miss any primitive.\n                         debug_assert!(fields > 0);\n-                        self.visit_union(v)?;\n+                        self.visit_union(v)\n                     },\n                     layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n-                        // FIXME: We collect in a vec because otherwise there are lifetime errors:\n-                        // Projecting to a field needs (mutable!) access to `ecx`.\n-                        let fields: Vec<EvalResult<'tcx, Self::V>> =\n-                            (0..offsets.len()).map(|i| {\n-                                v.project_field(self.ecx(), i as u64)\n-                            })\n-                            .collect();\n-                        self.visit_aggregate(v, fields.into_iter())?;\n+                        // Special handling needed for generators: All but the first field\n+                        // (which is the state) are actually implicitly `MaybeUninit`, i.e.,\n+                        // they may or may not be initialized, so we cannot visit them.\n+                        match v.layout().ty.sty {\n+                            ty::Generator(..) => {\n+                                let field = v.project_field(self.ecx(), 0)?;\n+                                self.visit_aggregate(v, std::iter::once(Ok(field)))?;\n+                                for i in 1..offsets.len() {\n+                                    let field = v.project_field(self.ecx(), i as u64)?;\n+                                    self.visit_generator_field(v, i, field)?;\n+                                }\n+                                Ok(())\n+                            }\n+                            _ => {\n+                                // FIXME: We collect in a vec because otherwise there are lifetime\n+                                // errors: Projecting to a field needs access to `ecx`.\n+                                let fields: Vec<EvalResult<'tcx, Self::V>> =\n+                                    (0..offsets.len()).map(|i| {\n+                                        v.project_field(self.ecx(), i as u64)\n+                                    })\n+                                    .collect();\n+                                self.visit_aggregate(v, fields.into_iter())\n+                            }\n+                        }\n                     },\n                     layout::FieldPlacement::Array { .. } => {\n                         // Let's get an mplace first.\n@@ -317,10 +348,9 @@ macro_rules! make_value_visitor {\n                             .map(|f| f.and_then(|f| {\n                                 Ok(Value::from_mem_place(f))\n                             }));\n-                        self.visit_aggregate(v, iter)?;\n+                        self.visit_aggregate(v, iter)\n                     }\n                 }\n-                Ok(())\n             }\n         }\n     }"}]}