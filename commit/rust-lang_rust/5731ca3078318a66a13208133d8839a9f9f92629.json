{"sha": "5731ca3078318a66a13208133d8839a9f9f92629", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU3MzFjYTMwNzgzMThhNjZhMTMyMDgxMzNkODgzOWE5ZjlmOTI2Mjk=", "commit": {"author": {"name": "Erik Price", "email": "erik.price16@gmail.com", "date": "2013-12-10T07:16:18Z"}, "committer": {"name": "Erik Price", "email": "erik.price16@gmail.com", "date": "2013-12-11T18:54:06Z"}, "message": "Make 'self lifetime illegal.\n\nAlso remove all instances of 'self within the codebase.\n\nThis fixes #10889.", "tree": {"sha": "322fdafcb432387c0c8131dbd22d57ecc38144b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/322fdafcb432387c0c8131dbd22d57ecc38144b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5731ca3078318a66a13208133d8839a9f9f92629", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5731ca3078318a66a13208133d8839a9f9f92629", "html_url": "https://github.com/rust-lang/rust/commit/5731ca3078318a66a13208133d8839a9f9f92629", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5731ca3078318a66a13208133d8839a9f9f92629/comments", "author": {"login": "erik", "id": 188935, "node_id": "MDQ6VXNlcjE4ODkzNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/188935?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erik", "html_url": "https://github.com/erik", "followers_url": "https://api.github.com/users/erik/followers", "following_url": "https://api.github.com/users/erik/following{/other_user}", "gists_url": "https://api.github.com/users/erik/gists{/gist_id}", "starred_url": "https://api.github.com/users/erik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erik/subscriptions", "organizations_url": "https://api.github.com/users/erik/orgs", "repos_url": "https://api.github.com/users/erik/repos", "events_url": "https://api.github.com/users/erik/events{/privacy}", "received_events_url": "https://api.github.com/users/erik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erik", "id": 188935, "node_id": "MDQ6VXNlcjE4ODkzNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/188935?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erik", "html_url": "https://github.com/erik", "followers_url": "https://api.github.com/users/erik/followers", "following_url": "https://api.github.com/users/erik/following{/other_user}", "gists_url": "https://api.github.com/users/erik/gists{/gist_id}", "starred_url": "https://api.github.com/users/erik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erik/subscriptions", "organizations_url": "https://api.github.com/users/erik/orgs", "repos_url": "https://api.github.com/users/erik/repos", "events_url": "https://api.github.com/users/erik/events{/privacy}", "received_events_url": "https://api.github.com/users/erik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d441c5468814b0d8f9ccdba426baf1f16b5134fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/d441c5468814b0d8f9ccdba426baf1f16b5134fc", "html_url": "https://github.com/rust-lang/rust/commit/d441c5468814b0d8f9ccdba426baf1f16b5134fc"}], "stats": {"total": 2567, "additions": 1290, "deletions": 1277}, "files": [{"sha": "63fb30ef2f3750ba1f91ea79c6d6275301451664", "filename": "doc/rust.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -1239,9 +1239,9 @@ static BIT2: uint = 1 << 1;\n static BITS: [uint, ..2] = [BIT1, BIT2];\n static STRING: &'static str = \"bitstring\";\n \n-struct BitsNStrings<'self> {\n+struct BitsNStrings<'a> {\n     mybits: [uint, ..2],\n-    mystring: &'self str\n+    mystring: &'a str\n }\n \n static bits_n_strings: BitsNStrings<'static> = BitsNStrings {\n@@ -2281,7 +2281,7 @@ The following are examples of structure expressions:\n ~~~~\n # struct Point { x: f64, y: f64 }\n # struct TuplePoint(f64, f64);\n-# mod game { pub struct User<'self> { name: &'self str, age: uint, score: uint } }\n+# mod game { pub struct User<'a> { name: &'a str, age: uint, score: uint } }\n # struct Cookie; fn some_fn<T>(t: T) {}\n Point {x: 10.0, y: 20.0};\n TuplePoint(10.0, 20.0);\n@@ -3055,7 +3055,7 @@ order specified by the tuple type.\n An example of a tuple type and its use:\n \n ~~~~\n-type Pair<'self> = (int,&'self str);\n+type Pair<'a> = (int,&'a str);\n let p: Pair<'static> = (10,\"hello\");\n let (a, b) = p;\n assert!(b != \"world\");\n@@ -3220,7 +3220,7 @@ fn add(x: int, y: int) -> int {\n \n let mut x = add(5,7);\n \n-type Binop<'self> = 'self |int,int| -> int;\n+type Binop<'a> = 'a |int,int| -> int;\n let bo: Binop = add;\n x = bo(5,7);\n ~~~~"}, {"sha": "6389e3fdab06c6760a5b498d8e7c3ef7b45ff983", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -49,13 +49,13 @@ use std::task;\n use std::borrow;\n \n /// As sync::condvar, a mechanism for unlock-and-descheduling and signaling.\n-pub struct Condvar<'self> {\n+pub struct Condvar<'a> {\n     priv is_mutex: bool,\n-    priv failed: &'self mut bool,\n-    priv cond: &'self sync::Condvar<'self>\n+    priv failed: &'a mut bool,\n+    priv cond: &'a sync::Condvar<'a>\n }\n \n-impl<'self> Condvar<'self> {\n+impl<'a> Condvar<'a> {\n     /// Atomically exit the associated Arc and block until a signal is sent.\n     #[inline]\n     pub fn wait(&self) { self.wait_on(0) }\n@@ -523,19 +523,19 @@ fn borrow_rwlock<T:Freeze + Send>(state: *mut RWArcInner<T>) -> *RWLock {\n }\n \n /// The \"write permission\" token used for RWArc.write_downgrade().\n-pub struct RWWriteMode<'self, T> {\n-    priv data: &'self mut T,\n-    priv token: sync::RWLockWriteMode<'self>,\n+pub struct RWWriteMode<'a, T> {\n+    priv data: &'a mut T,\n+    priv token: sync::RWLockWriteMode<'a>,\n     priv poison: PoisonOnFail,\n }\n \n /// The \"read permission\" token used for RWArc.write_downgrade().\n-pub struct RWReadMode<'self, T> {\n-    priv data: &'self T,\n-    priv token: sync::RWLockReadMode<'self>,\n+pub struct RWReadMode<'a, T> {\n+    priv data: &'a T,\n+    priv token: sync::RWLockReadMode<'a>,\n }\n \n-impl<'self, T:Freeze + Send> RWWriteMode<'self, T> {\n+impl<'a, T:Freeze + Send> RWWriteMode<'a, T> {\n     /// Access the pre-downgrade RWArc in write mode.\n     pub fn write<U>(&mut self, blk: |x: &mut T| -> U) -> U {\n         match *self {\n@@ -574,7 +574,7 @@ impl<'self, T:Freeze + Send> RWWriteMode<'self, T> {\n     }\n }\n \n-impl<'self, T:Freeze + Send> RWReadMode<'self, T> {\n+impl<'a, T:Freeze + Send> RWReadMode<'a, T> {\n     /// Access the post-downgrade rwlock in read mode.\n     pub fn read<U>(&self, blk: |x: &T| -> U) -> U {\n         match *self {"}, {"sha": "0b06ed9d5de62dba61589cbe3a2375e362416346", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -56,7 +56,7 @@ pub trait ToBase64 {\n     fn to_base64(&self, config: Config) -> ~str;\n }\n \n-impl<'self> ToBase64 for &'self [u8] {\n+impl<'a> ToBase64 for &'a [u8] {\n     /**\n      * Turn a vector of `u8` bytes into a base64 string.\n      *\n@@ -157,7 +157,7 @@ pub trait FromBase64 {\n     fn from_base64(&self) -> Result<~[u8], ~str>;\n }\n \n-impl<'self> FromBase64 for &'self str {\n+impl<'a> FromBase64 for &'a str {\n     /**\n      * Convert any base64 encoded string (literal, `@`, `&`, or `~`)\n      * to the byte values it encodes."}, {"sha": "733a893221872f4ccc0939587622dd77ef042a7e", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -578,13 +578,13 @@ fn iterate_bits(base: uint, bits: uint, f: |uint| -> bool) -> bool {\n }\n \n /// An iterator for `Bitv`.\n-pub struct BitvIterator<'self> {\n-    priv bitv: &'self Bitv,\n+pub struct BitvIterator<'a> {\n+    priv bitv: &'a Bitv,\n     priv next_idx: uint,\n     priv end_idx: uint,\n }\n \n-impl<'self> Iterator<bool> for BitvIterator<'self> {\n+impl<'a> Iterator<bool> for BitvIterator<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<bool> {\n         if self.next_idx != self.end_idx {\n@@ -602,7 +602,7 @@ impl<'self> Iterator<bool> for BitvIterator<'self> {\n     }\n }\n \n-impl<'self> DoubleEndedIterator<bool> for BitvIterator<'self> {\n+impl<'a> DoubleEndedIterator<bool> for BitvIterator<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<bool> {\n         if self.next_idx != self.end_idx {\n@@ -614,9 +614,9 @@ impl<'self> DoubleEndedIterator<bool> for BitvIterator<'self> {\n     }\n }\n \n-impl<'self> ExactSize<bool> for BitvIterator<'self> {}\n+impl<'a> ExactSize<bool> for BitvIterator<'a> {}\n \n-impl<'self> RandomAccessIterator<bool> for BitvIterator<'self> {\n+impl<'a> RandomAccessIterator<bool> for BitvIterator<'a> {\n     #[inline]\n     fn indexable(&self) -> uint {\n         self.end_idx - self.next_idx\n@@ -903,12 +903,12 @@ impl BitvSet {\n     }\n }\n \n-pub struct BitvSetIterator<'self> {\n-    priv set: &'self BitvSet,\n+pub struct BitvSetIterator<'a> {\n+    priv set: &'a BitvSet,\n     priv next_idx: uint\n }\n \n-impl<'self> Iterator<uint> for BitvSetIterator<'self> {\n+impl<'a> Iterator<uint> for BitvSetIterator<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<uint> {\n         while self.next_idx < self.set.capacity() {"}, {"sha": "7da92704ceb01ad0f2442096e1c0afff479ef862", "filename": "src/libextra/dlist.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibextra%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibextra%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fdlist.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -48,15 +48,15 @@ struct Node<T> {\n \n /// Double-ended DList iterator\n #[deriving(Clone)]\n-pub struct DListIterator<'self, T> {\n-    priv head: &'self Link<T>,\n+pub struct DListIterator<'a, T> {\n+    priv head: &'a Link<T>,\n     priv tail: Rawlink<Node<T>>,\n     priv nelem: uint,\n }\n \n /// Double-ended mutable DList iterator\n-pub struct MutDListIterator<'self, T> {\n-    priv list: &'self mut DList<T>,\n+pub struct MutDListIterator<'a, T> {\n+    priv list: &'a mut DList<T>,\n     priv head: Rawlink<Node<T>>,\n     priv tail: Rawlink<Node<T>>,\n     priv nelem: uint,\n@@ -439,9 +439,9 @@ impl<T> Drop for DList<T> {\n }\n \n \n-impl<'self, A> Iterator<&'self A> for DListIterator<'self, A> {\n+impl<'a, A> Iterator<&'a A> for DListIterator<'a, A> {\n     #[inline]\n-    fn next(&mut self) -> Option<&'self A> {\n+    fn next(&mut self) -> Option<&'a A> {\n         if self.nelem == 0 {\n             return None;\n         }\n@@ -458,9 +458,9 @@ impl<'self, A> Iterator<&'self A> for DListIterator<'self, A> {\n     }\n }\n \n-impl<'self, A> DoubleEndedIterator<&'self A> for DListIterator<'self, A> {\n+impl<'a, A> DoubleEndedIterator<&'a A> for DListIterator<'a, A> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<&'self A> {\n+    fn next_back(&mut self) -> Option<&'a A> {\n         if self.nelem == 0 {\n             return None;\n         }\n@@ -473,11 +473,11 @@ impl<'self, A> DoubleEndedIterator<&'self A> for DListIterator<'self, A> {\n     }\n }\n \n-impl<'self, A> ExactSize<&'self A> for DListIterator<'self, A> {}\n+impl<'a, A> ExactSize<&'a A> for DListIterator<'a, A> {}\n \n-impl<'self, A> Iterator<&'self mut A> for MutDListIterator<'self, A> {\n+impl<'a, A> Iterator<&'a mut A> for MutDListIterator<'a, A> {\n     #[inline]\n-    fn next(&mut self) -> Option<&'self mut A> {\n+    fn next(&mut self) -> Option<&'a mut A> {\n         if self.nelem == 0 {\n             return None;\n         }\n@@ -497,9 +497,9 @@ impl<'self, A> Iterator<&'self mut A> for MutDListIterator<'self, A> {\n     }\n }\n \n-impl<'self, A> DoubleEndedIterator<&'self mut A> for MutDListIterator<'self, A> {\n+impl<'a, A> DoubleEndedIterator<&'a mut A> for MutDListIterator<'a, A> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<&'self mut A> {\n+    fn next_back(&mut self) -> Option<&'a mut A> {\n         if self.nelem == 0 {\n             return None;\n         }\n@@ -511,7 +511,7 @@ impl<'self, A> DoubleEndedIterator<&'self mut A> for MutDListIterator<'self, A>\n     }\n }\n \n-impl<'self, A> ExactSize<&'self mut A> for MutDListIterator<'self, A> {}\n+impl<'a, A> ExactSize<&'a mut A> for MutDListIterator<'a, A> {}\n \n /// Allow mutating the DList while iterating\n pub trait ListInsertion<A> {\n@@ -525,7 +525,7 @@ pub trait ListInsertion<A> {\n }\n \n // private methods for MutDListIterator\n-impl<'self, A> MutDListIterator<'self, A> {\n+impl<'a, A> MutDListIterator<'a, A> {\n     fn insert_next_node(&mut self, mut ins_node: ~Node<A>) {\n         // Insert before `self.head` so that it is between the\n         // previously yielded element and self.head.\n@@ -547,7 +547,7 @@ impl<'self, A> MutDListIterator<'self, A> {\n     }\n }\n \n-impl<'self, A> ListInsertion<A> for MutDListIterator<'self, A> {\n+impl<'a, A> ListInsertion<A> for MutDListIterator<'a, A> {\n     #[inline]\n     fn insert_next(&mut self, elt: A) {\n         self.insert_next_node(~Node::new(elt))"}, {"sha": "83dcc412f57f8edc924500b708b2eeb795e954c5", "filename": "src/libextra/hex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibextra%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibextra%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fhex.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -21,7 +21,7 @@ pub trait ToHex {\n \n static CHARS: &'static[u8] = bytes!(\"0123456789abcdef\");\n \n-impl<'self> ToHex for &'self [u8] {\n+impl<'a> ToHex for &'a [u8] {\n     /**\n      * Turn a vector of `u8` bytes into a hexadecimal string.\n      *\n@@ -57,7 +57,7 @@ pub trait FromHex {\n     fn from_hex(&self) -> Result<~[u8], ~str>;\n }\n \n-impl<'self> FromHex for &'self str {\n+impl<'a> FromHex for &'a str {\n     /**\n      * Convert any hexadecimal encoded string (literal, `@`, `&`, or `~`)\n      * to the byte values it encodes."}, {"sha": "aa2cc9c855e3c8b1d37bfa9223a7492d03e1fd27", "filename": "src/libextra/json.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -84,19 +84,19 @@ fn spaces(n: uint) -> ~str {\n }\n \n /// A structure for implementing serialization to JSON.\n-pub struct Encoder<'self> {\n-    priv wr: &'self mut io::Writer,\n+pub struct Encoder<'a> {\n+    priv wr: &'a mut io::Writer,\n }\n \n-impl<'self> Encoder<'self> {\n+impl<'a> Encoder<'a> {\n     /// Creates a new JSON encoder whose output will be written to the writer\n     /// specified.\n     pub fn new<'a>(wr: &'a mut io::Writer) -> Encoder<'a> {\n         Encoder { wr: wr }\n     }\n }\n \n-impl<'self> serialize::Encoder for Encoder<'self> {\n+impl<'a> serialize::Encoder for Encoder<'a> {\n     fn emit_nil(&mut self) { write!(self.wr, \"null\") }\n \n     fn emit_uint(&mut self, v: uint) { self.emit_f64(v as f64); }\n@@ -129,13 +129,13 @@ impl<'self> serialize::Encoder for Encoder<'self> {\n         write!(self.wr, \"{}\", escape_str(v))\n     }\n \n-    fn emit_enum(&mut self, _name: &str, f: |&mut Encoder<'self>|) { f(self) }\n+    fn emit_enum(&mut self, _name: &str, f: |&mut Encoder<'a>|) { f(self) }\n \n     fn emit_enum_variant(&mut self,\n                          name: &str,\n                          _id: uint,\n                          cnt: uint,\n-                         f: |&mut Encoder<'self>|) {\n+                         f: |&mut Encoder<'a>|) {\n         // enums are encoded as strings or objects\n         // Bunny => \"Bunny\"\n         // Kangaroo(34,\"William\") => {\"variant\": \"Kangaroo\", \"fields\": [34,\"William\"]}\n@@ -150,7 +150,7 @@ impl<'self> serialize::Encoder for Encoder<'self> {\n         }\n     }\n \n-    fn emit_enum_variant_arg(&mut self, idx: uint, f: |&mut Encoder<'self>|) {\n+    fn emit_enum_variant_arg(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n         if idx != 0 {\n             write!(self.wr, \",\");\n         }\n@@ -161,18 +161,18 @@ impl<'self> serialize::Encoder for Encoder<'self> {\n                                 name: &str,\n                                 id: uint,\n                                 cnt: uint,\n-                                f: |&mut Encoder<'self>|) {\n+                                f: |&mut Encoder<'a>|) {\n         self.emit_enum_variant(name, id, cnt, f)\n     }\n \n     fn emit_enum_struct_variant_field(&mut self,\n                                       _: &str,\n                                       idx: uint,\n-                                      f: |&mut Encoder<'self>|) {\n+                                      f: |&mut Encoder<'a>|) {\n         self.emit_enum_variant_arg(idx, f)\n     }\n \n-    fn emit_struct(&mut self, _: &str, _: uint, f: |&mut Encoder<'self>|) {\n+    fn emit_struct(&mut self, _: &str, _: uint, f: |&mut Encoder<'a>|) {\n         write!(self.wr, r\"\\{\");\n         f(self);\n         write!(self.wr, r\"\\}\");\n@@ -181,71 +181,71 @@ impl<'self> serialize::Encoder for Encoder<'self> {\n     fn emit_struct_field(&mut self,\n                          name: &str,\n                          idx: uint,\n-                         f: |&mut Encoder<'self>|) {\n+                         f: |&mut Encoder<'a>|) {\n         if idx != 0 { write!(self.wr, \",\") }\n         write!(self.wr, \"{}:\", escape_str(name));\n         f(self);\n     }\n \n-    fn emit_tuple(&mut self, len: uint, f: |&mut Encoder<'self>|) {\n+    fn emit_tuple(&mut self, len: uint, f: |&mut Encoder<'a>|) {\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_arg(&mut self, idx: uint, f: |&mut Encoder<'self>|) {\n+    fn emit_tuple_arg(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n         self.emit_seq_elt(idx, f)\n     }\n \n     fn emit_tuple_struct(&mut self,\n                          _name: &str,\n                          len: uint,\n-                         f: |&mut Encoder<'self>|) {\n+                         f: |&mut Encoder<'a>|) {\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_struct_arg(&mut self, idx: uint, f: |&mut Encoder<'self>|) {\n+    fn emit_tuple_struct_arg(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n         self.emit_seq_elt(idx, f)\n     }\n \n-    fn emit_option(&mut self, f: |&mut Encoder<'self>|) { f(self); }\n+    fn emit_option(&mut self, f: |&mut Encoder<'a>|) { f(self); }\n     fn emit_option_none(&mut self) { self.emit_nil(); }\n-    fn emit_option_some(&mut self, f: |&mut Encoder<'self>|) { f(self); }\n+    fn emit_option_some(&mut self, f: |&mut Encoder<'a>|) { f(self); }\n \n-    fn emit_seq(&mut self, _len: uint, f: |&mut Encoder<'self>|) {\n+    fn emit_seq(&mut self, _len: uint, f: |&mut Encoder<'a>|) {\n         write!(self.wr, \"[\");\n         f(self);\n         write!(self.wr, \"]\");\n     }\n \n-    fn emit_seq_elt(&mut self, idx: uint, f: |&mut Encoder<'self>|) {\n+    fn emit_seq_elt(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n         if idx != 0 {\n             write!(self.wr, \",\");\n         }\n         f(self)\n     }\n \n-    fn emit_map(&mut self, _len: uint, f: |&mut Encoder<'self>|) {\n+    fn emit_map(&mut self, _len: uint, f: |&mut Encoder<'a>|) {\n         write!(self.wr, r\"\\{\");\n         f(self);\n         write!(self.wr, r\"\\}\");\n     }\n \n-    fn emit_map_elt_key(&mut self, idx: uint, f: |&mut Encoder<'self>|) {\n+    fn emit_map_elt_key(&mut self, idx: uint, f: |&mut Encoder<'a>|) {\n         if idx != 0 { write!(self.wr, \",\") }\n         f(self)\n     }\n \n-    fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut Encoder<'self>|) {\n+    fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut Encoder<'a>|) {\n         write!(self.wr, \":\");\n         f(self)\n     }\n }\n \n /// Another encoder for JSON, but prints out human-readable JSON instead of\n /// compact data\n-pub struct PrettyEncoder<'self> {\n-    priv wr: &'self mut io::Writer,\n+pub struct PrettyEncoder<'a> {\n+    priv wr: &'a mut io::Writer,\n     priv indent: uint,\n }\n \n-impl<'self> PrettyEncoder<'self> {\n+impl<'a> PrettyEncoder<'a> {\n     /// Creates a new encoder whose output will be written to the specified writer\n     pub fn new<'a>(wr: &'a mut io::Writer) -> PrettyEncoder<'a> {\n         PrettyEncoder {\n@@ -255,7 +255,7 @@ impl<'self> PrettyEncoder<'self> {\n     }\n }\n \n-impl<'self> serialize::Encoder for PrettyEncoder<'self> {\n+impl<'a> serialize::Encoder for PrettyEncoder<'a> {\n     fn emit_nil(&mut self) { write!(self.wr, \"null\") }\n \n     fn emit_uint(&mut self, v: uint) { self.emit_f64(v as f64); }\n@@ -286,15 +286,15 @@ impl<'self> serialize::Encoder for PrettyEncoder<'self> {\n     fn emit_char(&mut self, v: char) { self.emit_str(str::from_char(v)) }\n     fn emit_str(&mut self, v: &str) { write!(self.wr, \"{}\", escape_str(v)); }\n \n-    fn emit_enum(&mut self, _name: &str, f: |&mut PrettyEncoder<'self>|) {\n+    fn emit_enum(&mut self, _name: &str, f: |&mut PrettyEncoder<'a>|) {\n         f(self)\n     }\n \n     fn emit_enum_variant(&mut self,\n                          name: &str,\n                          _: uint,\n                          cnt: uint,\n-                         f: |&mut PrettyEncoder<'self>|) {\n+                         f: |&mut PrettyEncoder<'a>|) {\n         if cnt == 0 {\n             write!(self.wr, \"{}\", escape_str(name));\n         } else {\n@@ -308,7 +308,7 @@ impl<'self> serialize::Encoder for PrettyEncoder<'self> {\n \n     fn emit_enum_variant_arg(&mut self,\n                              idx: uint,\n-                             f: |&mut PrettyEncoder<'self>|) {\n+                             f: |&mut PrettyEncoder<'a>|) {\n         if idx != 0 {\n             write!(self.wr, \",\\n\");\n         }\n@@ -320,22 +320,22 @@ impl<'self> serialize::Encoder for PrettyEncoder<'self> {\n                                 name: &str,\n                                 id: uint,\n                                 cnt: uint,\n-                                f: |&mut PrettyEncoder<'self>|) {\n+                                f: |&mut PrettyEncoder<'a>|) {\n         self.emit_enum_variant(name, id, cnt, f)\n     }\n \n     fn emit_enum_struct_variant_field(&mut self,\n                                       _: &str,\n                                       idx: uint,\n-                                      f: |&mut PrettyEncoder<'self>|) {\n+                                      f: |&mut PrettyEncoder<'a>|) {\n         self.emit_enum_variant_arg(idx, f)\n     }\n \n \n     fn emit_struct(&mut self,\n                    _: &str,\n                    len: uint,\n-                   f: |&mut PrettyEncoder<'self>|) {\n+                   f: |&mut PrettyEncoder<'a>|) {\n         if len == 0 {\n             write!(self.wr, \"\\\\{\\\\}\");\n         } else {\n@@ -350,7 +350,7 @@ impl<'self> serialize::Encoder for PrettyEncoder<'self> {\n     fn emit_struct_field(&mut self,\n                          name: &str,\n                          idx: uint,\n-                         f: |&mut PrettyEncoder<'self>|) {\n+                         f: |&mut PrettyEncoder<'a>|) {\n         if idx == 0 {\n             write!(self.wr, \"\\n\");\n         } else {\n@@ -360,30 +360,30 @@ impl<'self> serialize::Encoder for PrettyEncoder<'self> {\n         f(self);\n     }\n \n-    fn emit_tuple(&mut self, len: uint, f: |&mut PrettyEncoder<'self>|) {\n+    fn emit_tuple(&mut self, len: uint, f: |&mut PrettyEncoder<'a>|) {\n         self.emit_seq(len, f)\n     }\n-    fn emit_tuple_arg(&mut self, idx: uint, f: |&mut PrettyEncoder<'self>|) {\n+    fn emit_tuple_arg(&mut self, idx: uint, f: |&mut PrettyEncoder<'a>|) {\n         self.emit_seq_elt(idx, f)\n     }\n \n     fn emit_tuple_struct(&mut self,\n                          _: &str,\n                          len: uint,\n-                         f: |&mut PrettyEncoder<'self>|) {\n+                         f: |&mut PrettyEncoder<'a>|) {\n         self.emit_seq(len, f)\n     }\n     fn emit_tuple_struct_arg(&mut self,\n                              idx: uint,\n-                             f: |&mut PrettyEncoder<'self>|) {\n+                             f: |&mut PrettyEncoder<'a>|) {\n         self.emit_seq_elt(idx, f)\n     }\n \n-    fn emit_option(&mut self, f: |&mut PrettyEncoder<'self>|) { f(self); }\n+    fn emit_option(&mut self, f: |&mut PrettyEncoder<'a>|) { f(self); }\n     fn emit_option_none(&mut self) { self.emit_nil(); }\n-    fn emit_option_some(&mut self, f: |&mut PrettyEncoder<'self>|) { f(self); }\n+    fn emit_option_some(&mut self, f: |&mut PrettyEncoder<'a>|) { f(self); }\n \n-    fn emit_seq(&mut self, len: uint, f: |&mut PrettyEncoder<'self>|) {\n+    fn emit_seq(&mut self, len: uint, f: |&mut PrettyEncoder<'a>|) {\n         if len == 0 {\n             write!(self.wr, \"[]\");\n         } else {\n@@ -395,7 +395,7 @@ impl<'self> serialize::Encoder for PrettyEncoder<'self> {\n         }\n     }\n \n-    fn emit_seq_elt(&mut self, idx: uint, f: |&mut PrettyEncoder<'self>|) {\n+    fn emit_seq_elt(&mut self, idx: uint, f: |&mut PrettyEncoder<'a>|) {\n         if idx == 0 {\n             write!(self.wr, \"\\n\");\n         } else {\n@@ -405,7 +405,7 @@ impl<'self> serialize::Encoder for PrettyEncoder<'self> {\n         f(self)\n     }\n \n-    fn emit_map(&mut self, len: uint, f: |&mut PrettyEncoder<'self>|) {\n+    fn emit_map(&mut self, len: uint, f: |&mut PrettyEncoder<'a>|) {\n         if len == 0 {\n             write!(self.wr, \"\\\\{\\\\}\");\n         } else {\n@@ -417,7 +417,7 @@ impl<'self> serialize::Encoder for PrettyEncoder<'self> {\n         }\n     }\n \n-    fn emit_map_elt_key(&mut self, idx: uint, f: |&mut PrettyEncoder<'self>|) {\n+    fn emit_map_elt_key(&mut self, idx: uint, f: |&mut PrettyEncoder<'a>|) {\n         if idx == 0 {\n             write!(self.wr, \"\\n\");\n         } else {\n@@ -427,7 +427,7 @@ impl<'self> serialize::Encoder for PrettyEncoder<'self> {\n         f(self);\n     }\n \n-    fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut PrettyEncoder<'self>|) {\n+    fn emit_map_elt_val(&mut self, _idx: uint, f: |&mut PrettyEncoder<'a>|) {\n         write!(self.wr, \": \");\n         f(self);\n     }"}, {"sha": "77d1c5cdcf49e80c3b7ff9994404107cfeb76433", "filename": "src/libextra/priority_queue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibextra%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibextra%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpriority_queue.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -177,13 +177,13 @@ impl<T:Ord> PriorityQueue<T> {\n }\n \n /// PriorityQueue iterator\n-pub struct PriorityQueueIterator <'self, T> {\n-    priv iter: vec::VecIterator<'self, T>,\n+pub struct PriorityQueueIterator <'a, T> {\n+    priv iter: vec::VecIterator<'a, T>,\n }\n \n-impl<'self, T> Iterator<&'self T> for PriorityQueueIterator<'self, T> {\n+impl<'a, T> Iterator<&'a T> for PriorityQueueIterator<'a, T> {\n     #[inline]\n-    fn next(&mut self) -> Option<(&'self T)> { self.iter.next() }\n+    fn next(&mut self) -> Option<(&'a T)> { self.iter.next() }\n \n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }"}, {"sha": "19e293c94a2191be05193931d528c15f0eab3d7e", "filename": "src/libextra/ringbuf.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibextra%2Fringbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibextra%2Fringbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fringbuf.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -229,16 +229,16 @@ impl<T> RingBuf<T> {\n }\n \n /// RingBuf iterator\n-pub struct RingBufIterator<'self, T> {\n+pub struct RingBufIterator<'a, T> {\n     priv lo: uint,\n     priv index: uint,\n     priv rindex: uint,\n-    priv elts: &'self [Option<T>],\n+    priv elts: &'a [Option<T>],\n }\n \n-impl<'self, T> Iterator<&'self T> for RingBufIterator<'self, T> {\n+impl<'a, T> Iterator<&'a T> for RingBufIterator<'a, T> {\n     #[inline]\n-    fn next(&mut self) -> Option<&'self T> {\n+    fn next(&mut self) -> Option<&'a T> {\n         if self.index == self.rindex {\n             return None;\n         }\n@@ -254,9 +254,9 @@ impl<'self, T> Iterator<&'self T> for RingBufIterator<'self, T> {\n     }\n }\n \n-impl<'self, T> DoubleEndedIterator<&'self T> for RingBufIterator<'self, T> {\n+impl<'a, T> DoubleEndedIterator<&'a T> for RingBufIterator<'a, T> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<&'self T> {\n+    fn next_back(&mut self) -> Option<&'a T> {\n         if self.index == self.rindex {\n             return None;\n         }\n@@ -266,14 +266,14 @@ impl<'self, T> DoubleEndedIterator<&'self T> for RingBufIterator<'self, T> {\n     }\n }\n \n-impl<'self, T> ExactSize<&'self T> for RingBufIterator<'self, T> {}\n+impl<'a, T> ExactSize<&'a T> for RingBufIterator<'a, T> {}\n \n-impl<'self, T> RandomAccessIterator<&'self T> for RingBufIterator<'self, T> {\n+impl<'a, T> RandomAccessIterator<&'a T> for RingBufIterator<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint { self.rindex - self.index }\n \n     #[inline]\n-    fn idx(&self, j: uint) -> Option<&'self T> {\n+    fn idx(&self, j: uint) -> Option<&'a T> {\n         if j >= self.indexable() {\n             None\n         } else {\n@@ -284,15 +284,15 @@ impl<'self, T> RandomAccessIterator<&'self T> for RingBufIterator<'self, T> {\n }\n \n /// RingBuf mutable iterator\n-pub struct RingBufMutIterator<'self, T> {\n-    priv remaining1: &'self mut [Option<T>],\n-    priv remaining2: &'self mut [Option<T>],\n+pub struct RingBufMutIterator<'a, T> {\n+    priv remaining1: &'a mut [Option<T>],\n+    priv remaining2: &'a mut [Option<T>],\n     priv nelts: uint,\n }\n \n-impl<'self, T> Iterator<&'self mut T> for RingBufMutIterator<'self, T> {\n+impl<'a, T> Iterator<&'a mut T> for RingBufMutIterator<'a, T> {\n     #[inline]\n-    fn next(&mut self) -> Option<&'self mut T> {\n+    fn next(&mut self) -> Option<&'a mut T> {\n         if self.nelts == 0 {\n             return None;\n         }\n@@ -312,9 +312,9 @@ impl<'self, T> Iterator<&'self mut T> for RingBufMutIterator<'self, T> {\n     }\n }\n \n-impl<'self, T> DoubleEndedIterator<&'self mut T> for RingBufMutIterator<'self, T> {\n+impl<'a, T> DoubleEndedIterator<&'a mut T> for RingBufMutIterator<'a, T> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<&'self mut T> {\n+    fn next_back(&mut self) -> Option<&'a mut T> {\n         if self.nelts == 0 {\n             return None;\n         }\n@@ -329,7 +329,7 @@ impl<'self, T> DoubleEndedIterator<&'self mut T> for RingBufMutIterator<'self, T\n     }\n }\n \n-impl<'self, T> ExactSize<&'self mut T> for RingBufMutIterator<'self, T> {}\n+impl<'a, T> ExactSize<&'a mut T> for RingBufMutIterator<'a, T> {}\n \n /// Grow is only called on full elts, so nelts is also len(elts), unlike\n /// elsewhere."}, {"sha": "6b298d877da814a0fda5964738a70bdaaefd270a", "filename": "src/libextra/serialize.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibextra%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibextra%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fserialize.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -292,7 +292,7 @@ impl<D:Decoder> Decodable<D> for i64 {\n     }\n }\n \n-impl<'self, S:Encoder> Encodable<S> for &'self str {\n+impl<'a, S:Encoder> Encodable<S> for &'a str {\n     fn encode(&self, s: &mut S) {\n         s.emit_str(*self)\n     }\n@@ -382,7 +382,7 @@ impl<D:Decoder> Decodable<D> for () {\n     }\n }\n \n-impl<'self, S:Encoder,T:Encodable<S>> Encodable<S> for &'self T {\n+impl<'a, S:Encoder,T:Encodable<S>> Encodable<S> for &'a T {\n     fn encode(&self, s: &mut S) {\n         (**self).encode(s)\n     }\n@@ -438,7 +438,7 @@ impl<D:Decoder,T:Decodable<D> + 'static> Decodable<D> for @mut T {\n     }\n }\n \n-impl<'self, S:Encoder,T:Encodable<S>> Encodable<S> for &'self [T] {\n+impl<'a, S:Encoder,T:Encodable<S>> Encodable<S> for &'a [T] {\n     fn encode(&self, s: &mut S) {\n         s.emit_seq(self.len(), |s| {\n             for (i, e) in self.iter().enumerate() {"}, {"sha": "649ed281f87e28f1b511bfc0db477bcfb584da49", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -184,7 +184,7 @@ impl<V:Clone> SmallIntMap<V> {\n \n macro_rules! iterator {\n     (impl $name:ident -> $elem:ty, $getter:ident) => {\n-        impl<'self, T> Iterator<$elem> for $name<'self, T> {\n+        impl<'a, T> Iterator<$elem> for $name<'a, T> {\n             #[inline]\n             fn next(&mut self) -> Option<$elem> {\n                 while self.front < self.back {\n@@ -213,7 +213,7 @@ macro_rules! iterator {\n \n macro_rules! double_ended_iterator {\n     (impl $name:ident -> $elem:ty, $getter:ident) => {\n-        impl<'self, T> DoubleEndedIterator<$elem> for $name<'self, T> {\n+        impl<'a, T> DoubleEndedIterator<$elem> for $name<'a, T> {\n             #[inline]\n             fn next_back(&mut self) -> Option<$elem> {\n                 while self.front < self.back {\n@@ -234,25 +234,25 @@ macro_rules! double_ended_iterator {\n     }\n }\n \n-pub struct SmallIntMapIterator<'self, T> {\n+pub struct SmallIntMapIterator<'a, T> {\n     priv front: uint,\n     priv back: uint,\n-    priv iter: VecIterator<'self, Option<T>>\n+    priv iter: VecIterator<'a, Option<T>>\n }\n \n-iterator!(impl SmallIntMapIterator -> (uint, &'self T), get_ref)\n-double_ended_iterator!(impl SmallIntMapIterator -> (uint, &'self T), get_ref)\n-pub type SmallIntMapRevIterator<'self, T> = Invert<SmallIntMapIterator<'self, T>>;\n+iterator!(impl SmallIntMapIterator -> (uint, &'a T), get_ref)\n+double_ended_iterator!(impl SmallIntMapIterator -> (uint, &'a T), get_ref)\n+pub type SmallIntMapRevIterator<'a, T> = Invert<SmallIntMapIterator<'a, T>>;\n \n-pub struct SmallIntMapMutIterator<'self, T> {\n+pub struct SmallIntMapMutIterator<'a, T> {\n     priv front: uint,\n     priv back: uint,\n-    priv iter: VecMutIterator<'self, Option<T>>\n+    priv iter: VecMutIterator<'a, Option<T>>\n }\n \n-iterator!(impl SmallIntMapMutIterator -> (uint, &'self mut T), get_mut_ref)\n-double_ended_iterator!(impl SmallIntMapMutIterator -> (uint, &'self mut T), get_mut_ref)\n-pub type SmallIntMapMutRevIterator<'self, T> = Invert<SmallIntMapMutIterator<'self, T>>;\n+iterator!(impl SmallIntMapMutIterator -> (uint, &'a mut T), get_mut_ref)\n+double_ended_iterator!(impl SmallIntMapMutIterator -> (uint, &'a mut T), get_mut_ref)\n+pub type SmallIntMapMutRevIterator<'a, T> = Invert<SmallIntMapMutIterator<'a, T>>;\n \n #[cfg(test)]\n mod test_map {"}, {"sha": "bba26a16d4dadc4dc9d1dc63a41040889b20b10d", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -15,7 +15,7 @@ use std::cmp::{Eq, Ord};\n use std::util::swap;\n use std::vec;\n \n-type Le<'self, T> = 'self |v1: &T, v2: &T| -> bool;\n+type Le<'a, T> = 'a |v1: &T, v2: &T| -> bool;\n \n /**\n  * Merge sort. Returns a new vector containing the sorted list.\n@@ -173,7 +173,7 @@ pub trait Sort {\n     fn qsort(self);\n }\n \n-impl<'self, T:Clone + Ord + Eq> Sort for &'self mut [T] {\n+impl<'a, T:Clone + Ord + Eq> Sort for &'a mut [T] {\n     fn qsort(self) { quick_sort3(self); }\n }\n "}, {"sha": "b96b9dda6eb68b6819ca1e0415bf10e99a9dea4c", "filename": "src/libextra/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibextra%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibextra%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fstats.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -145,7 +145,7 @@ impl Summary {\n     }\n }\n \n-impl<'self> Stats for &'self [f64] {\n+impl<'a> Stats for &'a [f64] {\n \n     fn sum(self) -> f64 {\n         self.iter().fold(0.0, |p,q| p + *q)"}, {"sha": "f00c3d8db9a0c8b3222e193004e01af39c9efe48", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -155,28 +155,28 @@ impl Sem<~[WaitQueue]> {\n // FIXME(#3598): Want to use an Option down below, but we need a custom enum\n // that's not polymorphic to get around the fact that lifetimes are invariant\n // inside of type parameters.\n-enum ReacquireOrderLock<'self> {\n+enum ReacquireOrderLock<'a> {\n     Nothing, // c.c\n-    Just(&'self Semaphore),\n+    Just(&'a Semaphore),\n }\n \n /// A mechanism for atomic-unlock-and-deschedule blocking and signalling.\n-pub struct Condvar<'self> {\n+pub struct Condvar<'a> {\n     // The 'Sem' object associated with this condvar. This is the one that's\n     // atomically-unlocked-and-descheduled upon and reacquired during wakeup.\n-    priv sem: &'self Sem<~[WaitQueue]>,\n+    priv sem: &'a Sem<~[WaitQueue]>,\n     // This is (can be) an extra semaphore which is held around the reacquire\n     // operation on the first one. This is only used in cvars associated with\n     // rwlocks, and is needed to ensure that, when a downgrader is trying to\n     // hand off the access lock (which would be the first field, here), a 2nd\n     // writer waking up from a cvar wait can't race with a reader to steal it,\n     // See the comment in write_cond for more detail.\n-    priv order: ReacquireOrderLock<'self>,\n+    priv order: ReacquireOrderLock<'a>,\n     // Make sure condvars are non-copyable.\n     priv token: util::NonCopyable,\n }\n \n-impl<'self> Condvar<'self> {\n+impl<'a> Condvar<'a> {\n     /**\n      * Atomically drop the associated lock, and block until a signal is sent.\n      *\n@@ -644,12 +644,12 @@ impl RWLock {\n \n /// The \"write permission\" token used for rwlock.write_downgrade().\n \n-pub struct RWLockWriteMode<'self> { priv lock: &'self RWLock, priv token: NonCopyable }\n+pub struct RWLockWriteMode<'a> { priv lock: &'a RWLock, priv token: NonCopyable }\n /// The \"read permission\" token used for rwlock.write_downgrade().\n-pub struct RWLockReadMode<'self> { priv lock: &'self RWLock,\n+pub struct RWLockReadMode<'a> { priv lock: &'a RWLock,\n                                    priv token: NonCopyable }\n \n-impl<'self> RWLockWriteMode<'self> {\n+impl<'a> RWLockWriteMode<'a> {\n     /// Access the pre-downgrade rwlock in write mode.\n     pub fn write<U>(&self, blk: || -> U) -> U { blk() }\n     /// Access the pre-downgrade rwlock in write mode with a condvar.\n@@ -662,7 +662,7 @@ impl<'self> RWLockWriteMode<'self> {\n     }\n }\n \n-impl<'self> RWLockReadMode<'self> {\n+impl<'a> RWLockReadMode<'a> {\n     /// Access the post-downgrade rwlock in read mode.\n     pub fn read<U>(&self, blk: || -> U) -> U { blk() }\n }"}, {"sha": "7c41104814978aac9a29b915d6ba2bd0b8e0be57", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -228,9 +228,9 @@ impl<K: TotalOrd, V> TreeMap<K, V> {\n }\n \n /// Lazy forward iterator over a map\n-pub struct TreeMapIterator<'self, K, V> {\n-    priv stack: ~[&'self TreeNode<K, V>],\n-    priv node: Option<&'self TreeNode<K, V>>,\n+pub struct TreeMapIterator<'a, K, V> {\n+    priv stack: ~[&'a TreeNode<K, V>],\n+    priv node: Option<&'a TreeNode<K, V>>,\n     priv remaining_min: uint,\n     priv remaining_max: uint\n }\n@@ -245,9 +245,9 @@ fn deref<'a, K, V>(node: &'a Option<~TreeNode<K, V>>) -> Option<&'a TreeNode<K,\n     }\n }\n \n-impl<'self, K, V> TreeMapIterator<'self, K, V> {\n+impl<'a, K, V> TreeMapIterator<'a, K, V> {\n     #[inline(always)]\n-    fn next_(&mut self, forward: bool) -> Option<(&'self K, &'self V)> {\n+    fn next_(&mut self, forward: bool) -> Option<(&'a K, &'a V)> {\n         while !self.stack.is_empty() || self.node.is_some() {\n             match self.node {\n               Some(x) => {\n@@ -269,11 +269,11 @@ impl<'self, K, V> TreeMapIterator<'self, K, V> {\n     }\n }\n \n-impl<'self, K, V> Iterator<(&'self K, &'self V)> for TreeMapIterator<'self, K, V> {\n+impl<'a, K, V> Iterator<(&'a K, &'a V)> for TreeMapIterator<'a, K, V> {\n     /// Advance the iterator to the next node (in order) and return a\n     /// tuple with a reference to the key and value. If there are no\n     /// more nodes, return `None`.\n-    fn next(&mut self) -> Option<(&'self K, &'self V)> {\n+    fn next(&mut self) -> Option<(&'a K, &'a V)> {\n         self.next_(true)\n     }\n \n@@ -284,15 +284,15 @@ impl<'self, K, V> Iterator<(&'self K, &'self V)> for TreeMapIterator<'self, K, V\n }\n \n /// Lazy backward iterator over a map\n-pub struct TreeMapRevIterator<'self, K, V> {\n-    priv iter: TreeMapIterator<'self, K, V>,\n+pub struct TreeMapRevIterator<'a, K, V> {\n+    priv iter: TreeMapIterator<'a, K, V>,\n }\n \n-impl<'self, K, V> Iterator<(&'self K, &'self V)> for TreeMapRevIterator<'self, K, V> {\n+impl<'a, K, V> Iterator<(&'a K, &'a V)> for TreeMapRevIterator<'a, K, V> {\n     /// Advance the iterator to the next node (in order) and return a\n     /// tuple with a reference to the key and value. If there are no\n     /// more nodes, return `None`.\n-    fn next(&mut self) -> Option<(&'self K, &'self V)> {\n+    fn next(&mut self) -> Option<(&'a K, &'a V)> {\n         self.iter.next_(false)\n     }\n \n@@ -390,18 +390,18 @@ impl<K, V> Iterator<(K, V)> for TreeMapMoveIterator<K,V> {\n \n }\n \n-impl<'self, T> Iterator<&'self T> for TreeSetIterator<'self, T> {\n+impl<'a, T> Iterator<&'a T> for TreeSetIterator<'a, T> {\n     /// Advance the iterator to the next node (in order). If there are no more nodes, return `None`.\n     #[inline]\n-    fn next(&mut self) -> Option<&'self T> {\n+    fn next(&mut self) -> Option<&'a T> {\n         self.iter.next().map(|(value, _)| value)\n     }\n }\n \n-impl<'self, T> Iterator<&'self T> for TreeSetRevIterator<'self, T> {\n+impl<'a, T> Iterator<&'a T> for TreeSetRevIterator<'a, T> {\n     /// Advance the iterator to the next node (in order). If there are no more nodes, return `None`.\n     #[inline]\n-    fn next(&mut self) -> Option<&'self T> {\n+    fn next(&mut self) -> Option<&'a T> {\n         self.iter.next().map(|(value, _)| value)\n     }\n }\n@@ -561,37 +561,37 @@ impl<T: TotalOrd> TreeSet<T> {\n }\n \n /// Lazy forward iterator over a set\n-pub struct TreeSetIterator<'self, T> {\n-    priv iter: TreeMapIterator<'self, T, ()>\n+pub struct TreeSetIterator<'a, T> {\n+    priv iter: TreeMapIterator<'a, T, ()>\n }\n \n /// Lazy backward iterator over a set\n-pub struct TreeSetRevIterator<'self, T> {\n-    priv iter: TreeMapRevIterator<'self, T, ()>\n+pub struct TreeSetRevIterator<'a, T> {\n+    priv iter: TreeMapRevIterator<'a, T, ()>\n }\n \n /// Lazy iterator producing elements in the set difference (in-order)\n-pub struct Difference<'self, T> {\n-    priv a: Peekable<&'self T, TreeSetIterator<'self, T>>,\n-    priv b: Peekable<&'self T, TreeSetIterator<'self, T>>,\n+pub struct Difference<'a, T> {\n+    priv a: Peekable<&'a T, TreeSetIterator<'a, T>>,\n+    priv b: Peekable<&'a T, TreeSetIterator<'a, T>>,\n }\n \n /// Lazy iterator producing elements in the set symmetric difference (in-order)\n-pub struct SymDifference<'self, T> {\n-    priv a: Peekable<&'self T, TreeSetIterator<'self, T>>,\n-    priv b: Peekable<&'self T, TreeSetIterator<'self, T>>,\n+pub struct SymDifference<'a, T> {\n+    priv a: Peekable<&'a T, TreeSetIterator<'a, T>>,\n+    priv b: Peekable<&'a T, TreeSetIterator<'a, T>>,\n }\n \n /// Lazy iterator producing elements in the set intersection (in-order)\n-pub struct Intersection<'self, T> {\n-    priv a: Peekable<&'self T, TreeSetIterator<'self, T>>,\n-    priv b: Peekable<&'self T, TreeSetIterator<'self, T>>,\n+pub struct Intersection<'a, T> {\n+    priv a: Peekable<&'a T, TreeSetIterator<'a, T>>,\n+    priv b: Peekable<&'a T, TreeSetIterator<'a, T>>,\n }\n \n /// Lazy iterator producing elements in the set intersection (in-order)\n-pub struct Union<'self, T> {\n-    priv a: Peekable<&'self T, TreeSetIterator<'self, T>>,\n-    priv b: Peekable<&'self T, TreeSetIterator<'self, T>>,\n+pub struct Union<'a, T> {\n+    priv a: Peekable<&'a T, TreeSetIterator<'a, T>>,\n+    priv b: Peekable<&'a T, TreeSetIterator<'a, T>>,\n }\n \n /// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n@@ -604,8 +604,8 @@ fn cmp_opt<T: TotalOrd>(x: Option<&T>, y: Option<&T>,\n     }\n }\n \n-impl<'self, T: TotalOrd> Iterator<&'self T> for Difference<'self, T> {\n-    fn next(&mut self) -> Option<&'self T> {\n+impl<'a, T: TotalOrd> Iterator<&'a T> for Difference<'a, T> {\n+    fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match cmp_opt(self.a.peek(), self.b.peek(), Less, Less) {\n                 Less    => return self.a.next(),\n@@ -616,8 +616,8 @@ impl<'self, T: TotalOrd> Iterator<&'self T> for Difference<'self, T> {\n     }\n }\n \n-impl<'self, T: TotalOrd> Iterator<&'self T> for SymDifference<'self, T> {\n-    fn next(&mut self) -> Option<&'self T> {\n+impl<'a, T: TotalOrd> Iterator<&'a T> for SymDifference<'a, T> {\n+    fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n                 Less    => return self.a.next(),\n@@ -628,8 +628,8 @@ impl<'self, T: TotalOrd> Iterator<&'self T> for SymDifference<'self, T> {\n     }\n }\n \n-impl<'self, T: TotalOrd> Iterator<&'self T> for Intersection<'self, T> {\n-    fn next(&mut self) -> Option<&'self T> {\n+impl<'a, T: TotalOrd> Iterator<&'a T> for Intersection<'a, T> {\n+    fn next(&mut self) -> Option<&'a T> {\n         loop {\n             let o_cmp = match (self.a.peek(), self.b.peek()) {\n                 (None    , _       ) => None,\n@@ -646,8 +646,8 @@ impl<'self, T: TotalOrd> Iterator<&'self T> for Intersection<'self, T> {\n     }\n }\n \n-impl<'self, T: TotalOrd> Iterator<&'self T> for Union<'self, T> {\n-    fn next(&mut self) -> Option<&'self T> {\n+impl<'a, T: TotalOrd> Iterator<&'a T> for Union<'a, T> {\n+    fn next(&mut self) -> Option<&'a T> {\n         loop {\n             match cmp_opt(self.a.peek(), self.b.peek(), Greater, Less) {\n                 Less    => return self.a.next(),"}, {"sha": "91f1f1a0d0ba2a1cbbb115dd132bad46616c1774", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -239,9 +239,9 @@ pub struct Context {\n     priv freshness: Arc<FreshnessMap>\n }\n \n-pub struct Prep<'self> {\n-    priv ctxt: &'self Context,\n-    priv fn_name: &'self str,\n+pub struct Prep<'a> {\n+    priv ctxt: &'a Context,\n+    priv fn_name: &'a str,\n     priv declared_inputs: WorkMap,\n }\n \n@@ -250,12 +250,12 @@ pub struct Exec {\n     priv discovered_outputs: WorkMap\n }\n \n-enum Work<'self, T> {\n+enum Work<'a, T> {\n     WorkValue(T),\n-    WorkFromTask(&'self Prep<'self>, PortOne<(Exec, T)>),\n+    WorkFromTask(&'a Prep<'a>, PortOne<(Exec, T)>),\n }\n \n-fn json_encode<'self, T:Encodable<json::Encoder<'self>>>(t: &T) -> ~str {\n+fn json_encode<'a, T:Encodable<json::Encoder<'a>>>(t: &T) -> ~str {\n     let mut writer = MemWriter::new();\n     let mut encoder = json::Encoder::new(&mut writer as &mut io::Writer);\n     t.encode(&mut encoder);\n@@ -336,8 +336,8 @@ impl Exec {\n     }\n }\n \n-impl<'self> Prep<'self> {\n-    fn new(ctxt: &'self Context, fn_name: &'self str) -> Prep<'self> {\n+impl<'a> Prep<'a> {\n+    fn new(ctxt: &'a Context, fn_name: &'a str) -> Prep<'a> {\n         Prep {\n             ctxt: ctxt,\n             fn_name: fn_name,\n@@ -356,7 +356,7 @@ impl<'self> Prep<'self> {\n     }\n }\n \n-impl<'self> Prep<'self> {\n+impl<'a> Prep<'a> {\n     pub fn declare_input(&mut self, kind: &str, name: &str, val: &str) {\n         debug!(\"Declaring input {} {} {}\", kind, name, val);\n         self.declared_inputs.insert_work_key(WorkKey::new(kind, name),\n@@ -395,17 +395,17 @@ impl<'self> Prep<'self> {\n         return true;\n     }\n \n-    pub fn exec<'self, T:Send +\n-        Encodable<json::Encoder<'self>> +\n+    pub fn exec<'a, T:Send +\n+        Encodable<json::Encoder<'a>> +\n         Decodable<json::Decoder>>(\n-            &'self self, blk: proc(&mut Exec) -> T) -> T {\n+            &'a self, blk: proc(&mut Exec) -> T) -> T {\n         self.exec_work(blk).unwrap()\n     }\n \n-    fn exec_work<'self, T:Send +\n-        Encodable<json::Encoder<'self>> +\n+    fn exec_work<'a, T:Send +\n+        Encodable<json::Encoder<'a>> +\n         Decodable<json::Decoder>>( // FIXME(#5121)\n-            &'self self, blk: proc(&mut Exec) -> T) -> Work<'self, T> {\n+            &'a self, blk: proc(&mut Exec) -> T) -> Work<'a, T> {\n         let mut bo = Some(blk);\n \n         debug!(\"exec_work: looking up {} and {:?}\", self.fn_name,\n@@ -445,16 +445,16 @@ impl<'self> Prep<'self> {\n     }\n }\n \n-impl<'self, T:Send +\n-       Encodable<json::Encoder<'self>> +\n+impl<'a, T:Send +\n+       Encodable<json::Encoder<'a>> +\n        Decodable<json::Decoder>>\n-    Work<'self, T> { // FIXME(#5121)\n+    Work<'a, T> { // FIXME(#5121)\n \n-    pub fn from_value(elt: T) -> Work<'self, T> {\n+    pub fn from_value(elt: T) -> Work<'a, T> {\n         WorkValue(elt)\n     }\n-    pub fn from_task(prep: &'self Prep<'self>, port: PortOne<(Exec, T)>)\n-        -> Work<'self, T> {\n+    pub fn from_task(prep: &'a Prep<'a>, port: PortOne<(Exec, T)>)\n+        -> Work<'a, T> {\n         WorkFromTask(prep, port)\n     }\n "}, {"sha": "6694bee582fbec189bbb8f12dbc3dff2f6e02170", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -12,8 +12,8 @@\n use syntax::fold::ast_fold;\n use syntax::{ast, fold, attr};\n \n-struct Context<'self> {\n-    in_cfg: 'self |attrs: &[ast::Attribute]| -> bool,\n+struct Context<'a> {\n+    in_cfg: 'a |attrs: &[ast::Attribute]| -> bool,\n }\n \n // Support conditional compilation by transforming the AST, stripping out\n@@ -23,7 +23,7 @@ pub fn strip_unconfigured_items(crate: ast::Crate) -> ast::Crate {\n     strip_items(crate, |attrs| in_cfg(config, attrs))\n }\n \n-impl<'self> fold::ast_fold for Context<'self> {\n+impl<'a> fold::ast_fold for Context<'a> {\n     fn fold_mod(&self, module: &ast::_mod) -> ast::_mod {\n         fold_mod(self, module)\n     }"}, {"sha": "70d65bc54702f3235b199175c9411e79ba9714ff", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -73,7 +73,7 @@ fn lookup_hash(d: ebml::Doc, eq_fn: |&[u8]| -> bool, hash: u64) ->\n     ret\n }\n \n-pub type GetCrateDataCb<'self> = 'self |ast::CrateNum| -> Cmd;\n+pub type GetCrateDataCb<'a> = 'a |ast::CrateNum| -> Cmd;\n \n pub fn maybe_find_item(item_id: ast::NodeId, items: ebml::Doc) -> Option<ebml::Doc> {\n     fn eq_item(bytes: &[u8], item_id: ast::NodeId) -> bool {\n@@ -694,7 +694,7 @@ pub fn get_item_path(cdata: Cmd, id: ast::NodeId) -> ast_map::path {\n     item_path(lookup_item(id, cdata.data))\n }\n \n-pub type decode_inlined_item<'self> = 'self |cdata: @cstore::crate_metadata,\n+pub type decode_inlined_item<'a> = 'a |cdata: @cstore::crate_metadata,\n                                              tcx: ty::ctxt,\n                                              path: ast_map::path,\n                                              par_doc: ebml::Doc|"}, {"sha": "1ffadfb6ede8dbf054947f12a1a477300268900e", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -51,21 +51,21 @@ use writer = extra::ebml::writer;\n // used by astencode:\n type abbrev_map = @mut HashMap<ty::t, tyencode::ty_abbrev>;\n \n-pub type encode_inlined_item<'self> = 'self |ecx: &EncodeContext,\n+pub type encode_inlined_item<'a> = 'a |ecx: &EncodeContext,\n                                              ebml_w: &mut writer::Encoder,\n                                              path: &[ast_map::path_elt],\n                                              ii: ast::inlined_item|;\n \n-pub struct EncodeParams<'self> {\n+pub struct EncodeParams<'a> {\n     diag: @mut span_handler,\n     tcx: ty::ctxt,\n     reexports2: middle::resolve::ExportMap2,\n-    item_symbols: &'self HashMap<ast::NodeId, ~str>,\n-    discrim_symbols: &'self HashMap<ast::NodeId, @str>,\n-    non_inlineable_statics: &'self HashSet<ast::NodeId>,\n-    link_meta: &'self LinkMeta,\n+    item_symbols: &'a HashMap<ast::NodeId, ~str>,\n+    discrim_symbols: &'a HashMap<ast::NodeId, @str>,\n+    non_inlineable_statics: &'a HashSet<ast::NodeId>,\n+    link_meta: &'a LinkMeta,\n     cstore: @mut cstore::CStore,\n-    encode_inlined_item: encode_inlined_item<'self>,\n+    encode_inlined_item: encode_inlined_item<'a>,\n     reachable: @mut HashSet<ast::NodeId>,\n }\n \n@@ -85,17 +85,17 @@ struct Stats {\n     n_inlines: uint\n }\n \n-pub struct EncodeContext<'self> {\n+pub struct EncodeContext<'a> {\n     diag: @mut span_handler,\n     tcx: ty::ctxt,\n     stats: @mut Stats,\n     reexports2: middle::resolve::ExportMap2,\n-    item_symbols: &'self HashMap<ast::NodeId, ~str>,\n-    discrim_symbols: &'self HashMap<ast::NodeId, @str>,\n-    non_inlineable_statics: &'self HashSet<ast::NodeId>,\n-    link_meta: &'self LinkMeta,\n-    cstore: &'self cstore::CStore,\n-    encode_inlined_item: encode_inlined_item<'self>,\n+    item_symbols: &'a HashMap<ast::NodeId, ~str>,\n+    discrim_symbols: &'a HashMap<ast::NodeId, @str>,\n+    non_inlineable_statics: &'a HashSet<ast::NodeId>,\n+    link_meta: &'a LinkMeta,\n+    cstore: &'a cstore::CStore,\n+    encode_inlined_item: encode_inlined_item<'a>,\n     type_abbrevs: abbrev_map,\n     reachable: @mut HashSet<ast::NodeId>,\n }\n@@ -1605,12 +1605,12 @@ fn encode_native_libraries(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.end_tag();\n }\n \n-struct ImplVisitor<'self> {\n-    ecx: &'self EncodeContext<'self>,\n-    ebml_w: &'self mut writer::Encoder,\n+struct ImplVisitor<'a> {\n+    ecx: &'a EncodeContext<'a>,\n+    ebml_w: &'a mut writer::Encoder,\n }\n \n-impl<'self> Visitor<()> for ImplVisitor<'self> {\n+impl<'a> Visitor<()> for ImplVisitor<'a> {\n     fn visit_item(&mut self, item: @item, _: ()) {\n         match item.node {\n             item_impl(_, Some(ref trait_ref), _, _) => {"}, {"sha": "9b6da280be03270dae719f9cf54337456fc165c4", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -23,7 +23,7 @@ pub enum FileMatch { FileMatches, FileDoesntMatch }\n \n /// Functions with type `pick` take a parent directory as well as\n /// a file found in that directory.\n-pub type pick<'self> = 'self |path: &Path| -> FileMatch;\n+pub type pick<'a> = 'a |path: &Path| -> FileMatch;\n \n pub fn pick_file(file: Path, path: &Path) -> Option<Path> {\n     if path.filename() == Some(file.as_vec()) {"}, {"sha": "27f43a0ef5375bfa05af13519e7fec1ae4a0efc7", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -52,11 +52,11 @@ pub enum DefIdSource {\n     // Identifies a region parameter (`fn foo<'X>() { ... }`).\n     RegionParameter,\n }\n-type conv_did<'self> =\n-    'self |source: DefIdSource, ast::DefId| -> ast::DefId;\n+type conv_did<'a> =\n+    'a |source: DefIdSource, ast::DefId| -> ast::DefId;\n \n-pub struct PState<'self> {\n-    data: &'self [u8],\n+pub struct PState<'a> {\n+    data: &'a [u8],\n     crate: ast::CrateNum,\n     pos: uint,\n     tcx: ty::ctxt"}, {"sha": "b5dec466a089653bcf1ee24661de113885b3fcb8", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -765,7 +765,7 @@ trait get_ty_str_ctxt {\n     fn ty_str_ctxt(&self) -> @tyencode::ctxt;\n }\n \n-impl<'self> get_ty_str_ctxt for e::EncodeContext<'self> {\n+impl<'a> get_ty_str_ctxt for e::EncodeContext<'a> {\n     fn ty_str_ctxt(&self) -> @tyencode::ctxt {\n         @tyencode::ctxt {\n             diag: self.tcx.sess.diagnostic(),"}, {"sha": "0a93a57a9634ea85cfe15c8ba6e43b97ba26d876", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -32,15 +32,15 @@ use syntax::visit;\n use util::ppaux::Repr;\n \n #[deriving(Clone)]\n-struct CheckLoanCtxt<'self> {\n-    bccx: &'self BorrowckCtxt,\n-    dfcx_loans: &'self LoanDataFlow,\n+struct CheckLoanCtxt<'a> {\n+    bccx: &'a BorrowckCtxt,\n+    dfcx_loans: &'a LoanDataFlow,\n     move_data: @move_data::FlowedMoveData,\n-    all_loans: &'self [Loan],\n+    all_loans: &'a [Loan],\n     reported: @mut HashSet<ast::NodeId>,\n }\n \n-impl<'self> Visitor<()> for CheckLoanCtxt<'self> {\n+impl<'a> Visitor<()> for CheckLoanCtxt<'a> {\n \n     fn visit_expr(&mut self, ex:@ast::Expr, _:()) {\n         check_loans_in_expr(self, ex);\n@@ -86,7 +86,7 @@ enum MoveError {\n     MoveWhileBorrowed(/*loan*/@LoanPath, /*loan*/Span)\n }\n \n-impl<'self> CheckLoanCtxt<'self> {\n+impl<'a> CheckLoanCtxt<'a> {\n     pub fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n \n     pub fn each_issued_loan(&self, scope_id: ast::NodeId, op: |&Loan| -> bool)"}, {"sha": "8c6384c0296770973c5503264b049fdc2177fe67", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -45,8 +45,8 @@ pub fn guarantee_lifetime(bccx: &BorrowckCtxt,\n ///////////////////////////////////////////////////////////////////////////\n // Private\n \n-struct GuaranteeLifetimeContext<'self> {\n-    bccx: &'self BorrowckCtxt,\n+struct GuaranteeLifetimeContext<'a> {\n+    bccx: &'a BorrowckCtxt,\n \n     // the node id of the function body for the enclosing item\n     item_scope_id: ast::NodeId,\n@@ -61,7 +61,7 @@ struct GuaranteeLifetimeContext<'self> {\n     cmt_original: mc::cmt\n }\n \n-impl<'self> GuaranteeLifetimeContext<'self> {\n+impl<'a> GuaranteeLifetimeContext<'a> {\n     fn tcx(&self) -> ty::ctxt {\n         self.bccx.tcx\n     }"}, {"sha": "36dbfe8a2c1bd33215c664c60c3e1c68d4ccdca2", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -64,16 +64,16 @@ mod gather_moves;\n /// No good.  Instead what will happen is that `root_ub` will be set to the\n /// body of the while loop and we will refuse to root the pointer `&*x`\n /// because it would have to be rooted for a region greater than `root_ub`.\n-struct GatherLoanCtxt<'self> {\n-    bccx: &'self BorrowckCtxt,\n+struct GatherLoanCtxt<'a> {\n+    bccx: &'a BorrowckCtxt,\n     id_range: id_range,\n     move_data: @mut move_data::MoveData,\n     all_loans: @mut ~[Loan],\n     item_ub: ast::NodeId,\n     repeating_ids: ~[ast::NodeId]\n }\n \n-impl<'self> visit::Visitor<()> for GatherLoanCtxt<'self> {\n+impl<'a> visit::Visitor<()> for GatherLoanCtxt<'a> {\n     fn visit_expr(&mut self, ex:@Expr, _:()) {\n         gather_loans_in_expr(self, ex);\n     }\n@@ -333,7 +333,7 @@ fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n     }\n }\n \n-impl<'self> GatherLoanCtxt<'self> {\n+impl<'a> GatherLoanCtxt<'a> {\n     pub fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n \n     pub fn push_repeating_id(&mut self, id: ast::NodeId) {"}, {"sha": "ae6b828ecaaa563ea19313622d5590ae9a4f113c", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -42,14 +42,14 @@ pub fn compute_restrictions(bccx: &BorrowckCtxt,\n ///////////////////////////////////////////////////////////////////////////\n // Private\n \n-struct RestrictionsContext<'self> {\n-    bccx: &'self BorrowckCtxt,\n+struct RestrictionsContext<'a> {\n+    bccx: &'a BorrowckCtxt,\n     span: Span,\n     cmt_original: mc::cmt,\n     loan_region: ty::Region,\n }\n \n-impl<'self> RestrictionsContext<'self> {\n+impl<'a> RestrictionsContext<'a> {\n     fn restrict(&self,\n                 cmt: mc::cmt,\n                 restrictions: RestrictionSet) -> RestrictionResult {"}, {"sha": "6a6e8f958fffcd7c98d06ee0579afddfebc7d8d1", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -77,12 +77,12 @@ pub trait DataFlowOperator {\n     fn walk_closures(&self) -> bool;\n }\n \n-struct PropagationContext<'self, O> {\n-    dfcx: &'self mut DataFlowContext<O>,\n+struct PropagationContext<'a, O> {\n+    dfcx: &'a mut DataFlowContext<O>,\n     changed: bool\n }\n \n-struct LoopScope<'self> {\n+struct LoopScope<'a> {\n     loop_id: ast::NodeId,\n     break_bits: ~[uint]\n }\n@@ -363,7 +363,7 @@ impl<O:DataFlowOperator+Clone+'static> DataFlowContext<O> {\n     }\n }\n \n-impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n+impl<'a, O:DataFlowOperator> PropagationContext<'a, O> {\n     fn tcx(&self) -> ty::ctxt {\n         self.dfcx.tcx\n     }"}, {"sha": "d77f0cb054aae3f8cdc0250ddb13d1f5c574700e", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -103,11 +103,11 @@ struct LanguageItemCollector {\n     item_refs: HashMap<&'static str, uint>,\n }\n \n-struct LanguageItemVisitor<'self> {\n-    this: &'self mut LanguageItemCollector,\n+struct LanguageItemVisitor<'a> {\n+    this: &'a mut LanguageItemCollector,\n }\n \n-impl<'self> Visitor<()> for LanguageItemVisitor<'self> {\n+impl<'a> Visitor<()> for LanguageItemVisitor<'a> {\n     fn visit_item(&mut self, item: @ast::item, _: ()) {\n         match extract(item.attrs) {\n             Some(value) => {"}, {"sha": "feee3583f717a18dbad0e2fbc6dc03b9d326d561", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -352,15 +352,15 @@ pub fn get_lint_dict() -> LintDict {\n     return map;\n }\n \n-struct Context<'self> {\n+struct Context<'a> {\n     // All known lint modes (string versions)\n     dict: @LintDict,\n     // Current levels of each lint warning\n     cur: SmallIntMap<(level, LintSource)>,\n     // context we're checking in (used to access fields like sess)\n     tcx: ty::ctxt,\n     // Items exported by the crate; used by the missing_doc lint.\n-    exported_items: &'self privacy::ExportedItems,\n+    exported_items: &'a privacy::ExportedItems,\n     // The id of the current `ast::struct_def` being walked.\n     cur_struct_def_id: ast::NodeId,\n     // Whether some ancestor of the current node was marked\n@@ -376,7 +376,7 @@ struct Context<'self> {\n     negated_expr_id: ast::NodeId\n }\n \n-impl<'self> Context<'self> {\n+impl<'a> Context<'a> {\n     fn get_level(&self, lint: lint) -> level {\n         match self.cur.find(&(lint as uint)) {\n           Some(&(lvl, _)) => lvl,\n@@ -1234,7 +1234,7 @@ fn check_stability(cx: &Context, e: &ast::Expr) {\n     cx.span_lint(lint, e.span, msg);\n }\n \n-impl<'self> Visitor<()> for Context<'self> {\n+impl<'a> Visitor<()> for Context<'a> {\n     fn visit_item(&mut self, it: @ast::item, _: ()) {\n         self.with_lint_attrs(it.attrs, |cx| {\n             check_item_ctypes(cx, it);\n@@ -1369,7 +1369,7 @@ impl<'self> Visitor<()> for Context<'self> {\n     fn visit_ty(&mut self, _t: &ast::Ty, _: ()) {}\n }\n \n-impl<'self> IdVisitingOperation for Context<'self> {\n+impl<'a> IdVisitingOperation for Context<'a> {\n     fn visit_id(&self, id: ast::NodeId) {\n         match self.tcx.sess.lints.pop(&id) {\n             None => {}"}, {"sha": "ded8d11786a2edf6a3a32c620a0e58a26174a446", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -30,7 +30,7 @@ use syntax::opt_vec;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n-type Context<'self> = (&'self method_map, &'self resolve::ExportMap2);\n+type Context<'a> = (&'a method_map, &'a resolve::ExportMap2);\n \n /// A set of AST nodes exported by the crate.\n pub type ExportedItems = HashSet<ast::NodeId>;\n@@ -143,9 +143,9 @@ impl Visitor<()> for ParentVisitor {\n /// The embargo visitor, used to determine the exports of the ast\n ////////////////////////////////////////////////////////////////////////////////\n \n-struct EmbargoVisitor<'self> {\n+struct EmbargoVisitor<'a> {\n     tcx: ty::ctxt,\n-    exp_map2: &'self resolve::ExportMap2,\n+    exp_map2: &'a resolve::ExportMap2,\n \n     // This flag is an indicator of whether the previous item in the\n     // hierarchical chain was exported or not. This is the indicator of whether\n@@ -167,7 +167,7 @@ struct EmbargoVisitor<'self> {\n     reexports: HashSet<ast::NodeId>,\n }\n \n-impl<'self> Visitor<()> for EmbargoVisitor<'self> {\n+impl<'a> Visitor<()> for EmbargoVisitor<'a> {\n     fn visit_item(&mut self, item: @ast::item, _: ()) {\n         let orig_all_pub = self.prev_exported;\n         match item.node {\n@@ -308,12 +308,12 @@ impl<'self> Visitor<()> for EmbargoVisitor<'self> {\n /// The privacy visitor, where privacy checks take place (violations reported)\n ////////////////////////////////////////////////////////////////////////////////\n \n-struct PrivacyVisitor<'self> {\n+struct PrivacyVisitor<'a> {\n     tcx: ty::ctxt,\n     curitem: ast::NodeId,\n     in_fn: bool,\n     in_foreign: bool,\n-    method_map: &'self method_map,\n+    method_map: &'a method_map,\n     parents: HashMap<ast::NodeId, ast::NodeId>,\n     external_exports: resolve::ExternalExports,\n     last_private_map: resolve::LastPrivateMap,\n@@ -325,7 +325,7 @@ enum PrivacyResult {\n     DisallowedBy(ast::NodeId),\n }\n \n-impl<'self> PrivacyVisitor<'self> {\n+impl<'a> PrivacyVisitor<'a> {\n     // used when debugging\n     fn nodestr(&self, id: ast::NodeId) -> ~str {\n         ast_map::node_id_to_str(self.tcx.items, id, token::get_ident_interner())\n@@ -601,7 +601,7 @@ impl<'self> PrivacyVisitor<'self> {\n     }\n }\n \n-impl<'self> Visitor<()> for PrivacyVisitor<'self> {\n+impl<'a> Visitor<()> for PrivacyVisitor<'a> {\n     fn visit_item(&mut self, item: @ast::item, _: ()) {\n         // Do not check privacy inside items with the resolve_unexported\n         // attribute. This is used for the test runner."}, {"sha": "970b373f424e5c701f082a52410a0aa93a220275", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -185,9 +185,9 @@ impl<T> ResolveResult<T> {\n     }\n }\n \n-enum TypeParameters<'self> {\n+enum TypeParameters<'a> {\n     NoTypeParameters,                   //< No type parameters.\n-    HasTypeParameters(&'self Generics,  //< Type parameters.\n+    HasTypeParameters(&'a Generics,  //< Type parameters.\n                       NodeId,          //< ID of the enclosing item\n \n                       // The index to start numbering the type parameters at.\n@@ -881,11 +881,11 @@ struct Resolver {\n     used_imports: HashSet<NodeId>,\n }\n \n-struct BuildReducedGraphVisitor<'self> {\n-    resolver: &'self mut Resolver,\n+struct BuildReducedGraphVisitor<'a> {\n+    resolver: &'a mut Resolver,\n }\n \n-impl<'self> Visitor<ReducedGraphParent> for BuildReducedGraphVisitor<'self> {\n+impl<'a> Visitor<ReducedGraphParent> for BuildReducedGraphVisitor<'a> {\n \n     fn visit_item(&mut self, item:@item, context:ReducedGraphParent) {\n         let p = self.resolver.build_reduced_graph_for_item(item, context);\n@@ -913,9 +913,9 @@ impl<'self> Visitor<ReducedGraphParent> for BuildReducedGraphVisitor<'self> {\n \n }\n \n-struct UnusedImportCheckVisitor<'self> { resolver: &'self Resolver }\n+struct UnusedImportCheckVisitor<'a> { resolver: &'a Resolver }\n \n-impl<'self> Visitor<()> for UnusedImportCheckVisitor<'self> {\n+impl<'a> Visitor<()> for UnusedImportCheckVisitor<'a> {\n     fn visit_view_item(&mut self, vi:&view_item, _:()) {\n         self.resolver.check_for_item_unused_imports(vi);\n         visit::walk_view_item(self, vi, ());"}, {"sha": "6130887c0846533c974c62da868005a000f30fc4", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -36,10 +36,10 @@ struct LifetimeContext {\n     named_region_map: @mut NamedRegionMap,\n }\n \n-enum ScopeChain<'self> {\n-    ItemScope(&'self OptVec<ast::Lifetime>),\n-    FnScope(ast::NodeId, &'self OptVec<ast::Lifetime>, &'self ScopeChain<'self>),\n-    BlockScope(ast::NodeId, &'self ScopeChain<'self>),\n+enum ScopeChain<'a> {\n+    ItemScope(&'a OptVec<ast::Lifetime>),\n+    FnScope(ast::NodeId, &'a OptVec<ast::Lifetime>, &'a ScopeChain<'a>),\n+    BlockScope(ast::NodeId, &'a ScopeChain<'a>),\n     RootScope\n }\n \n@@ -55,10 +55,10 @@ pub fn crate(sess: session::Session,\n     ctxt.named_region_map\n }\n \n-impl<'self> Visitor<&'self ScopeChain<'self>> for LifetimeContext {\n+impl<'a> Visitor<&'a ScopeChain<'a>> for LifetimeContext {\n     fn visit_item(&mut self,\n                   item: @ast::item,\n-                  _: &'self ScopeChain<'self>) {\n+                  _: &'a ScopeChain<'a>) {\n         let scope = match item.node {\n             ast::item_fn(..) | // fn lifetimes get added in visit_fn below\n             ast::item_mod(..) |\n@@ -87,7 +87,7 @@ impl<'self> Visitor<&'self ScopeChain<'self>> for LifetimeContext {\n                 b: ast::P<ast::Block>,\n                 s: Span,\n                 n: ast::NodeId,\n-                scope: &'self ScopeChain<'self>) {\n+                scope: &'a ScopeChain<'a>) {\n         match *fk {\n             visit::fk_item_fn(_, generics, _, _) |\n             visit::fk_method(_, generics, _) => {\n@@ -105,7 +105,7 @@ impl<'self> Visitor<&'self ScopeChain<'self>> for LifetimeContext {\n \n     fn visit_ty(&mut self,\n                 ty: &ast::Ty,\n-                scope: &'self ScopeChain<'self>) {\n+                scope: &'a ScopeChain<'a>) {\n         match ty.node {\n             ast::ty_closure(@ast::TyClosure { lifetimes: ref lifetimes, .. }) |\n             ast::ty_bare_fn(@ast::TyBareFn { lifetimes: ref lifetimes, .. }) => {\n@@ -123,7 +123,7 @@ impl<'self> Visitor<&'self ScopeChain<'self>> for LifetimeContext {\n \n     fn visit_ty_method(&mut self,\n                        m: &ast::TypeMethod,\n-                       scope: &'self ScopeChain<'self>) {\n+                       scope: &'a ScopeChain<'a>) {\n         let scope1 = FnScope(m.id, &m.generics.lifetimes, scope);\n         self.check_lifetime_names(&m.generics.lifetimes);\n         debug!(\"pushing fn scope id={} due to ty_method\", m.id);\n@@ -133,7 +133,7 @@ impl<'self> Visitor<&'self ScopeChain<'self>> for LifetimeContext {\n \n     fn visit_block(&mut self,\n                    b: ast::P<ast::Block>,\n-                   scope: &'self ScopeChain<'self>) {\n+                   scope: &'a ScopeChain<'a>) {\n         let scope1 = BlockScope(b.id, scope);\n         debug!(\"pushing block scope {}\", b.id);\n         visit::walk_block(self, b, &scope1);\n@@ -142,7 +142,7 @@ impl<'self> Visitor<&'self ScopeChain<'self>> for LifetimeContext {\n \n     fn visit_lifetime_ref(&mut self,\n                           lifetime_ref: &ast::Lifetime,\n-                          scope: &'self ScopeChain<'self>) {\n+                          scope: &'a ScopeChain<'a>) {\n         if lifetime_ref.ident == special_idents::statik {\n             self.insert_lifetime(lifetime_ref, ast::DefStaticRegion);\n             return;"}, {"sha": "6062b30cfaeec4266adab1c076b96d7183581f5c", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -45,12 +45,12 @@ impl Subst for ty::t {\n     }\n }\n \n-struct SubstFolder<'self> {\n+struct SubstFolder<'a> {\n     tcx: ty::ctxt,\n-    substs: &'self ty::substs\n+    substs: &'a ty::substs\n }\n \n-impl<'self> TypeFolder for SubstFolder<'self> {\n+impl<'a> TypeFolder for SubstFolder<'a> {\n     fn tcx(&self) -> ty::ctxt { self.tcx }\n \n     fn fold_region(&mut self, r: ty::Region) -> ty::Region {"}, {"sha": "091614b6bc74c17163d408d67d07925afbb8cbc1", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -394,9 +394,9 @@ struct BindingInfo {\n type BindingsMap = HashMap<Ident, BindingInfo>;\n \n #[deriving(Clone)]\n-struct ArmData<'self> {\n+struct ArmData<'a> {\n     bodycx: @mut Block,\n-    arm: &'self ast::Arm,\n+    arm: &'a ast::Arm,\n     bindings_map: @BindingsMap\n }\n \n@@ -407,13 +407,13 @@ struct ArmData<'self> {\n  * these pointers are stored in llmatch variables just before executing `data` arm.\n  */\n #[deriving(Clone)]\n-struct Match<'self> {\n+struct Match<'a> {\n     pats: ~[@ast::Pat],\n-    data: ArmData<'self>,\n+    data: ArmData<'a>,\n     bound_ptrs: ~[(Ident, ValueRef)]\n }\n \n-impl<'self> Repr for Match<'self> {\n+impl<'a> Repr for Match<'a> {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n         if tcx.sess.verbose() {\n             // for many programs, this just take too long to serialize\n@@ -477,7 +477,7 @@ fn assert_is_binding_or_wild(bcx: @mut Block, p: @ast::Pat) {\n     }\n }\n \n-type enter_pat<'self> = 'self |@ast::Pat| -> Option<~[@ast::Pat]>;\n+type enter_pat<'a> = 'a |@ast::Pat| -> Option<~[@ast::Pat]>;\n \n fn enter_match<'r>(bcx: @mut Block,\n                        dm: DefMap,"}, {"sha": "d6fc48b52ea2c56522677d4cf8cc2ceef813099c", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -130,16 +130,16 @@ pub fn push_ctxt(s: &'static str) -> _InsnCtxt {\n     _InsnCtxt { _x: () }\n }\n \n-struct StatRecorder<'self> {\n+struct StatRecorder<'a> {\n     ccx: @mut CrateContext,\n-    name: &'self str,\n+    name: &'a str,\n     start: u64,\n     istart: uint,\n }\n \n-impl<'self> StatRecorder<'self> {\n+impl<'a> StatRecorder<'a> {\n     pub fn new(ccx: @mut CrateContext,\n-               name: &'self str) -> StatRecorder<'self> {\n+               name: &'a str) -> StatRecorder<'a> {\n         let start = if ccx.sess.trans_stats() {\n             time::precise_time_ns()\n         } else {\n@@ -156,7 +156,7 @@ impl<'self> StatRecorder<'self> {\n }\n \n #[unsafe_destructor]\n-impl<'self> Drop for StatRecorder<'self> {\n+impl<'a> Drop for StatRecorder<'a> {\n     fn drop(&mut self) {\n         if self.ccx.sess.trans_stats() {\n             let end = time::precise_time_ns();\n@@ -668,7 +668,7 @@ pub fn compare_scalar_values(cx: @mut Block,\n     }\n }\n \n-pub type val_and_ty_fn<'self> = 'self |@mut Block, ValueRef, ty::t|\n+pub type val_and_ty_fn<'a> = 'a |@mut Block, ValueRef, ty::t|\n                                        -> @mut Block;\n \n pub fn load_inbounds(cx: @mut Block, p: ValueRef, idxs: &[uint]) -> ValueRef {"}, {"sha": "15cbe53d2663b28c1749631c5c59adb912515a7e", "filename": "src/librustc/middle/trans/basic_block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbasic_block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbasic_block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbasic_block.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -14,7 +14,7 @@ use std::iter::{Filter, Map};\n \n pub struct BasicBlock(BasicBlockRef);\n \n-pub type PredIterator<'self> = Map<'self, Value, BasicBlock, Filter<'self, Value, UserIterator>>;\n+pub type PredIterator<'a> = Map<'a, Value, BasicBlock, Filter<'a, Value, UserIterator>>;\n \n /**\n  * Wrapper for LLVM BasicBlockRef"}, {"sha": "329651cb1941a8c28051deb5b240431145f922a9", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -67,7 +67,7 @@ trait ClassList {\n     fn is_ret_bysret(&self) -> bool;\n }\n \n-impl<'self> ClassList for &'self [RegClass] {\n+impl<'a> ClassList for &'a [RegClass] {\n     fn is_pass_byval(&self) -> bool {\n         if self.len() == 0 { return false; }\n "}, {"sha": "5230a5c81b2236f04636d870773cd77e583cf9eb", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -750,9 +750,9 @@ pub fn trans_call_inner(in_cx: @mut Block,\n     })\n }\n \n-pub enum CallArgs<'self> {\n-    ArgExprs(&'self [@ast::Expr]),\n-    ArgVals(&'self [ValueRef])\n+pub enum CallArgs<'a> {\n+    ArgExprs(&'a [@ast::Expr]),\n+    ArgVals(&'a [ValueRef])\n }\n \n pub fn trans_args(cx: @mut Block,"}, {"sha": "ab0013e73bf384fd9c4f0585e809d19111357949", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -214,12 +214,12 @@ struct FunctionDebugContextData {\n     source_locations_enabled: bool,\n }\n \n-enum VariableAccess<'self> {\n+enum VariableAccess<'a> {\n     // The llptr given is an alloca containing the variable's value\n     DirectVariable { alloca: ValueRef },\n     // The llptr given is an alloca containing the start of some pointer chain leading to the\n     // variable's content.\n-    IndirectVariable { alloca: ValueRef, address_operations: &'self [ValueRef] }\n+    IndirectVariable { alloca: ValueRef, address_operations: &'a [ValueRef] }\n }\n \n enum VariableKind {"}, {"sha": "3e3ba06538b166614c16510307a30e2154c2533b", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -641,7 +641,7 @@ pub fn declare_tydesc(ccx: &mut CrateContext, t: ty::t) -> @mut tydesc_info {\n     return inf;\n }\n \n-pub type glue_helper<'self> = 'self |@mut Block, ValueRef, ty::t|\n+pub type glue_helper<'a> = 'a |@mut Block, ValueRef, ty::t|\n                                      -> @mut Block;\n \n pub fn declare_generic_glue(ccx: &mut CrateContext, t: ty::t, llfnty: Type,"}, {"sha": "75908a0d8050624e15fe2cb915ae18f14e8117d1", "filename": "src/librustc/middle/trans/llrepr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftrans%2Fllrepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftrans%2Fllrepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fllrepr.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -16,7 +16,7 @@ pub trait LlvmRepr {\n     fn llrepr(&self, ccx: &CrateContext) -> ~str;\n }\n \n-impl<'self, T:LlvmRepr> LlvmRepr for &'self [T] {\n+impl<'a, T:LlvmRepr> LlvmRepr for &'a [T] {\n     fn llrepr(&self, ccx: &CrateContext) -> ~str {\n         let reprs = self.map(|t| t.llrepr(ccx));\n         format!(\"[{}]\", reprs.connect(\",\"))"}, {"sha": "52b89e0e0b6533137348cfb1be0749661d981569", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -539,7 +539,7 @@ pub fn get_base_and_len(bcx: @mut Block, llval: ValueRef, vec_ty: ty::t) -> (Val\n     }\n }\n \n-pub type iter_vec_block<'self> = 'self |@mut Block, ValueRef, ty::t|\n+pub type iter_vec_block<'a> = 'a |@mut Block, ValueRef, ty::t|\n                                         -> @mut Block;\n \n pub fn iter_vec_loop(bcx: @mut Block,"}, {"sha": "cb0e8d3241efd4e3cbc5b5ee8cc708cc2e8e63b1", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -1408,13 +1408,13 @@ pub fn subst_tps(tcx: ctxt, tps: &[t], self_ty_opt: Option<t>, typ: t) -> t {\n     let mut subst = TpsSubst { tcx: tcx, self_ty_opt: self_ty_opt, tps: tps };\n     return subst.fold_ty(typ);\n \n-    struct TpsSubst<'self> {\n+    struct TpsSubst<'a> {\n         tcx: ctxt,\n         self_ty_opt: Option<t>,\n-        tps: &'self [t],\n+        tps: &'a [t],\n     }\n \n-    impl<'self> TypeFolder for TpsSubst<'self> {\n+    impl<'a> TypeFolder for TpsSubst<'a> {\n         fn tcx(&self) -> ty::ctxt { self.tcx }\n \n         fn fold_ty(&mut self, t: ty::t) -> ty::t {"}, {"sha": "2d39352ebc4fa5de46942a0cd659521ea97aa59e", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -222,12 +222,12 @@ pub fn super_fold_trait_store<T:TypeFolder>(this: &mut T,\n ///////////////////////////////////////////////////////////////////////////\n // Some sample folders\n \n-pub struct BottomUpFolder<'self> {\n+pub struct BottomUpFolder<'a> {\n     tcx: ty::ctxt,\n-    fldop: 'self |ty::t| -> ty::t,\n+    fldop: 'a |ty::t| -> ty::t,\n }\n \n-impl<'self> TypeFolder for BottomUpFolder<'self> {\n+impl<'a> TypeFolder for BottomUpFolder<'a> {\n     fn tcx(&self) -> ty::ctxt { self.tcx }\n \n     fn fold_ty(&mut self, ty: ty::t) -> ty::t {\n@@ -239,26 +239,26 @@ impl<'self> TypeFolder for BottomUpFolder<'self> {\n ///////////////////////////////////////////////////////////////////////////\n // Region folder\n \n-pub struct RegionFolder<'self> {\n+pub struct RegionFolder<'a> {\n     tcx: ty::ctxt,\n-    fld_t: 'self |ty::t| -> ty::t,\n-    fld_r: 'self |ty::Region| -> ty::Region,\n+    fld_t: 'a |ty::t| -> ty::t,\n+    fld_r: 'a |ty::Region| -> ty::Region,\n }\n \n-impl<'self> RegionFolder<'self> {\n+impl<'a> RegionFolder<'a> {\n     pub fn general(tcx: ty::ctxt,\n-                   fld_r: 'self |ty::Region| -> ty::Region,\n-                   fld_t: 'self |ty::t| -> ty::t)\n-                   -> RegionFolder<'self> {\n+                   fld_r: 'a |ty::Region| -> ty::Region,\n+                   fld_t: 'a |ty::t| -> ty::t)\n+                   -> RegionFolder<'a> {\n         RegionFolder {\n             tcx: tcx,\n             fld_t: fld_t,\n             fld_r: fld_r\n         }\n     }\n \n-    pub fn regions(tcx: ty::ctxt, fld_r: 'self |ty::Region| -> ty::Region)\n-                   -> RegionFolder<'self> {\n+    pub fn regions(tcx: ty::ctxt, fld_r: 'a |ty::Region| -> ty::Region)\n+                   -> RegionFolder<'a> {\n         fn noop(t: ty::t) -> ty::t { t }\n \n         RegionFolder {\n@@ -269,7 +269,7 @@ impl<'self> RegionFolder<'self> {\n     }\n }\n \n-impl<'self> TypeFolder for RegionFolder<'self> {\n+impl<'a> TypeFolder for RegionFolder<'a> {\n     fn tcx(&self) -> ty::ctxt { self.tcx }\n \n     fn fold_ty(&mut self, ty: ty::t) -> ty::t {"}, {"sha": "5a437fce0a57dd3462e352622b36ec8071a7885a", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -40,7 +40,7 @@\n  * as it does not already appear in scope.\n  *\n  * Case (b) says that if you have a type:\n- *   type foo<'self> = ...;\n+ *   type foo<'a> = ...;\n  *   type bar = fn(&foo, &a.foo)\n  * The fully expanded version of type bar is:\n  *   type bar = fn(&'foo &, &a.foo<'a>)"}, {"sha": "22e0a60514fa93b917a7f59946d867b501b6f7b8", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -167,13 +167,13 @@ pub fn lookup(\n     return lcx.search(self_ty);\n }\n \n-pub struct LookupContext<'self> {\n+pub struct LookupContext<'a> {\n     fcx: @mut FnCtxt,\n     expr: @ast::Expr,\n     self_expr: @ast::Expr,\n     callee_id: NodeId,\n     m_name: ast::Name,\n-    supplied_tps: &'self [ty::t],\n+    supplied_tps: &'a [ty::t],\n     impl_dups: @mut HashSet<DefId>,\n     inherent_candidates: @mut ~[Candidate],\n     extension_candidates: @mut ~[Candidate],\n@@ -208,7 +208,7 @@ enum RcvrMatchCondition {\n     RcvrMatchesIfSubtype(ty::t)\n }\n \n-impl<'self> LookupContext<'self> {\n+impl<'a> LookupContext<'a> {\n     fn search(&self, self_ty: ty::t) -> Option<method_map_entry> {\n         let mut self_ty = self_ty;\n         let mut autoderefs = 0;"}, {"sha": "799f1a879da738a41fcf9360d0607f5a1fcd7231", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -918,7 +918,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n     // Create a substitution that maps the type parameters on the impl\n     // to themselves and which replace any references to bound regions\n     // in the self type with free regions.  So, for example, if the\n-    // impl type is \"&'self str\", then this would replace the self\n+    // impl type is \"&'a str\", then this would replace the self\n     // type with a free region `self`.\n     let dummy_impl_tps: ~[ty::t] =\n         impl_generics.type_param_defs.iter().enumerate()."}, {"sha": "23c1961b0c045c68aaeebc982113b38457a578b7", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -85,17 +85,17 @@ pub fn relate_nested_regions(tcx: ty::ctxt,\n     }\n     rr.fold_ty(ty);\n \n-    struct RegionRelator<'self> {\n+    struct RegionRelator<'a> {\n         tcx: ty::ctxt,\n         stack: ~[ty::Region],\n-        relate_op: 'self |ty::Region, ty::Region|,\n+        relate_op: 'a |ty::Region, ty::Region|,\n     }\n \n     // FIXME(#10151) -- Define more precisely when a region is\n     // considered \"nested\". Consider taking variance into account as\n     // well.\n \n-    impl<'self> TypeFolder for RegionRelator<'self> {\n+    impl<'a> TypeFolder for RegionRelator<'a> {\n         fn tcx(&self) -> ty::ctxt {\n             self.tcx\n         }\n@@ -124,7 +124,7 @@ pub fn relate_nested_regions(tcx: ty::ctxt,\n         }\n     }\n \n-    impl<'self> RegionRelator<'self> {\n+    impl<'a> RegionRelator<'a> {\n         fn relate(&mut self, r_sub: ty::Region) {\n             for &r in self.stack.iter() {\n                 if !r.is_bound() && !r_sub.is_bound() {"}, {"sha": "401a0ea898bec9dfd21ff48d64389b8518b26c83", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -69,12 +69,12 @@ pub struct LocationInfo {\n \n /// A vtable context includes an inference context, a crate context, and a\n /// callback function to call in case of type error.\n-pub struct VtableContext<'self> {\n+pub struct VtableContext<'a> {\n     infcx: @mut infer::InferCtxt,\n-    param_env: &'self ty::ParameterEnvironment,\n+    param_env: &'a ty::ParameterEnvironment,\n }\n \n-impl<'self> VtableContext<'self> {\n+impl<'a> VtableContext<'a> {\n     pub fn tcx(&self) -> ty::ctxt { self.infcx.tcx }\n }\n "}, {"sha": "8f702e59d0a39c3e235d9c976a1ae7497c331d27", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -51,8 +51,8 @@ pub trait LatticeValue {\n     fn glb(cf: &CombineFields, a: &Self, b: &Self) -> cres<Self>;\n }\n \n-pub type LatticeOp<'self, T> =\n-    'self |cf: &CombineFields, a: &T, b: &T| -> cres<T>;\n+pub type LatticeOp<'a, T> =\n+    'a |cf: &CombineFields, a: &T, b: &T| -> cres<T>;\n \n impl LatticeValue for ty::t {\n     fn sub(cf: &CombineFields, a: &ty::t, b: &ty::t) -> ures {\n@@ -405,7 +405,7 @@ pub fn super_lattice_tys<L:LatticeDir+TyLatticeDir+Combine>(this: &L,\n     }\n }\n \n-pub type LatticeDirOp<'self, T> = 'self |a: &T, b: &T| -> cres<T>;\n+pub type LatticeDirOp<'a, T> = 'a |a: &T, b: &T| -> cres<T>;\n \n #[deriving(Clone)]\n pub enum LatticeVarResult<V,T> {"}, {"sha": "09069ce46b282837d968f2eec5cc9392b2e24645", "filename": "src/librustc/middle/typeck/infer/region_inference/doc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -406,7 +406,7 @@ Now let's consider two more function types.  Here, we assume that the\n `self` lifetime is defined somewhere outside and hence is not a\n lifetime parameter bound by the function type (it \"appears free\"):\n \n-    fn<a>(&'a int) <: |&'self int|? (Yes, a => self)\n+    fn<a>(&'a int) <: |&'a int|? (Yes, a => self)\n \n This subtyping relation does in fact hold.  To see why, you have to\n consider what subtyping means.  One way to look at `T1 <: T2` is to\n@@ -423,7 +423,7 @@ to the same thing: a function that accepts pointers with any lifetime\n \n So, what if we reverse the order of the two function types, like this:\n \n-    fn(&'self int) <: <a>|&'a int|? (No)\n+    fn(&'a int) <: <a>|&'a int|? (No)\n \n Does the subtyping relationship still hold?  The answer of course is\n no.  In this case, the function accepts *only the lifetime `&self`*,\n@@ -491,12 +491,12 @@ So far we have encountered no error, so the subtype check succeeds.\n \n Now let's look first at the third example, which was:\n \n-    3. fn(&'self T)    <: <b>|&'b T|?        No!\n+    3. fn(&'a T)    <: <b>|&'b T|?        No!\n \n After steps 1 and 2 of the algorithm we will have replaced the types\n like so:\n \n-    3. fn(&'self T) <: |&'x T|?\n+    3. fn(&'a T) <: |&'x T|?\n \n This looks pretty much the same as before, except that on the LHS\n `&self` was not bound, and hence was left as-is and not replaced with"}, {"sha": "81489c1577fba03ef7312d1b6bd71e5ff8c52f00", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -218,25 +218,25 @@ pub fn infer_variance(tcx: ty::ctxt,\n  *\n  * Terms are structured as a straightforward tree. Rather than rely on\n  * GC, we allocate terms out of a bounded arena (the lifetime of this\n- * arena is the lifetime 'self that is threaded around).\n+ * arena is the lifetime 'a that is threaded around).\n  *\n  * We assign a unique index to each type/region parameter whose variance\n  * is to be inferred. We refer to such variables as \"inferreds\". An\n  * `InferredIndex` is a newtype'd int representing the index of such\n  * a variable.\n  */\n \n-type VarianceTermPtr<'self> = &'self VarianceTerm<'self>;\n+type VarianceTermPtr<'a> = &'a VarianceTerm<'a>;\n \n struct InferredIndex(uint);\n \n-enum VarianceTerm<'self> {\n+enum VarianceTerm<'a> {\n     ConstantTerm(ty::Variance),\n-    TransformTerm(VarianceTermPtr<'self>, VarianceTermPtr<'self>),\n+    TransformTerm(VarianceTermPtr<'a>, VarianceTermPtr<'a>),\n     InferredTerm(InferredIndex),\n }\n \n-impl<'self> ToStr for VarianceTerm<'self> {\n+impl<'a> ToStr for VarianceTerm<'a> {\n     fn to_str(&self) -> ~str {\n         match *self {\n             ConstantTerm(c1) => format!(\"{}\", c1.to_str()),\n@@ -251,9 +251,9 @@ impl<'self> ToStr for VarianceTerm<'self> {\n  * The first pass over the crate simply builds up the set of inferreds.\n  */\n \n-struct TermsContext<'self> {\n+struct TermsContext<'a> {\n     tcx: ty::ctxt,\n-    arena: &'self Arena,\n+    arena: &'a Arena,\n \n     empty_variances: @ty::ItemVariances,\n \n@@ -262,17 +262,17 @@ struct TermsContext<'self> {\n     inferred_map: HashMap<ast::NodeId, InferredIndex>,\n \n     // Maps from an InferredIndex to the info for that variable.\n-    inferred_infos: ~[InferredInfo<'self>],\n+    inferred_infos: ~[InferredInfo<'a>],\n }\n \n enum ParamKind { TypeParam, RegionParam, SelfParam }\n \n-struct InferredInfo<'self> {\n+struct InferredInfo<'a> {\n     item_id: ast::NodeId,\n     kind: ParamKind,\n     index: uint,\n     param_id: ast::NodeId,\n-    term: VarianceTermPtr<'self>,\n+    term: VarianceTermPtr<'a>,\n }\n \n fn determine_parameters_to_be_inferred<'a>(tcx: ty::ctxt,\n@@ -297,7 +297,7 @@ fn determine_parameters_to_be_inferred<'a>(tcx: ty::ctxt,\n     terms_cx\n }\n \n-impl<'self> TermsContext<'self> {\n+impl<'a> TermsContext<'a> {\n     fn add_inferred(&mut self,\n                     item_id: ast::NodeId,\n                     kind: ParamKind,\n@@ -326,7 +326,7 @@ impl<'self> TermsContext<'self> {\n     }\n }\n \n-impl<'self> Visitor<()> for TermsContext<'self> {\n+impl<'a> Visitor<()> for TermsContext<'a> {\n     fn visit_item(&mut self,\n                   item: @ast::item,\n                   (): ()) {\n@@ -392,23 +392,23 @@ impl<'self> Visitor<()> for TermsContext<'self> {\n  * We walk the set of items and, for each member, generate new constraints.\n  */\n \n-struct ConstraintContext<'self> {\n-    terms_cx: TermsContext<'self>,\n+struct ConstraintContext<'a> {\n+    terms_cx: TermsContext<'a>,\n \n     // These are pointers to common `ConstantTerm` instances\n-    covariant: VarianceTermPtr<'self>,\n-    contravariant: VarianceTermPtr<'self>,\n-    invariant: VarianceTermPtr<'self>,\n-    bivariant: VarianceTermPtr<'self>,\n+    covariant: VarianceTermPtr<'a>,\n+    contravariant: VarianceTermPtr<'a>,\n+    invariant: VarianceTermPtr<'a>,\n+    bivariant: VarianceTermPtr<'a>,\n \n-    constraints: ~[Constraint<'self>],\n+    constraints: ~[Constraint<'a>],\n }\n \n /// Declares that the variable `decl_id` appears in a location with\n /// variance `variance`.\n-struct Constraint<'self> {\n+struct Constraint<'a> {\n     inferred: InferredIndex,\n-    variance: &'self VarianceTerm<'self>,\n+    variance: &'a VarianceTerm<'a>,\n }\n \n fn add_constraints_from_crate<'a>(terms_cx: TermsContext<'a>,\n@@ -430,7 +430,7 @@ fn add_constraints_from_crate<'a>(terms_cx: TermsContext<'a>,\n     constraint_cx\n }\n \n-impl<'self> Visitor<()> for ConstraintContext<'self> {\n+impl<'a> Visitor<()> for ConstraintContext<'a> {\n     fn visit_item(&mut self,\n                   item: @ast::item,\n                   (): ()) {\n@@ -506,7 +506,7 @@ impl<'self> Visitor<()> for ConstraintContext<'self> {\n     }\n }\n \n-impl<'self> ConstraintContext<'self> {\n+impl<'a> ConstraintContext<'a> {\n     fn tcx(&self) -> ty::ctxt {\n         self.terms_cx.tcx\n     }\n@@ -529,7 +529,7 @@ impl<'self> ConstraintContext<'self> {\n                          item_def_id: ast::DefId,\n                          kind: ParamKind,\n                          index: uint)\n-                         -> VarianceTermPtr<'self> {\n+                         -> VarianceTermPtr<'a> {\n         /*!\n          * Returns a variance term representing the declared variance of\n          * the type/region parameter with the given id.\n@@ -557,26 +557,26 @@ impl<'self> ConstraintContext<'self> {\n \n     fn add_constraint(&mut self,\n                       index: InferredIndex,\n-                      variance: VarianceTermPtr<'self>) {\n+                      variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraint(index={}, variance={})\",\n                 *index, variance.to_str());\n         self.constraints.push(Constraint { inferred: index,\n                                            variance: variance });\n     }\n \n     fn contravariant(&mut self,\n-                     variance: VarianceTermPtr<'self>)\n-                     -> VarianceTermPtr<'self> {\n+                     variance: VarianceTermPtr<'a>)\n+                     -> VarianceTermPtr<'a> {\n         self.xform(variance, self.contravariant)\n     }\n \n     fn invariant(&mut self,\n-                 variance: VarianceTermPtr<'self>)\n-                 -> VarianceTermPtr<'self> {\n+                 variance: VarianceTermPtr<'a>)\n+                 -> VarianceTermPtr<'a> {\n         self.xform(variance, self.invariant)\n     }\n \n-    fn constant_term(&self, v: ty::Variance) -> VarianceTermPtr<'self> {\n+    fn constant_term(&self, v: ty::Variance) -> VarianceTermPtr<'a> {\n         match v {\n             ty::Covariant => self.covariant,\n             ty::Invariant => self.invariant,\n@@ -586,9 +586,9 @@ impl<'self> ConstraintContext<'self> {\n     }\n \n     fn xform(&mut self,\n-             v1: VarianceTermPtr<'self>,\n-             v2: VarianceTermPtr<'self>)\n-             -> VarianceTermPtr<'self> {\n+             v1: VarianceTermPtr<'a>,\n+             v2: VarianceTermPtr<'a>)\n+             -> VarianceTermPtr<'a> {\n         match (*v1, *v2) {\n             (_, ConstantTerm(ty::Covariant)) => {\n                 // Applying a \"covariant\" transform is always a no-op\n@@ -609,7 +609,7 @@ impl<'self> ConstraintContext<'self> {\n     /// in a context with ambient variance `variance`\n     fn add_constraints_from_ty(&mut self,\n                                ty: ty::t,\n-                               variance: VarianceTermPtr<'self>) {\n+                               variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_ty(ty={})\", ty.repr(self.tcx()));\n \n         match ty::get(ty).sty {\n@@ -704,7 +704,7 @@ impl<'self> ConstraintContext<'self> {\n     /// appearing in a context with ambient variance `variance`\n     fn add_constraints_from_vstore(&mut self,\n                                    vstore: ty::vstore,\n-                                   variance: VarianceTermPtr<'self>) {\n+                                   variance: VarianceTermPtr<'a>) {\n         match vstore {\n             ty::vstore_slice(r) => {\n                 let contra = self.contravariant(variance);\n@@ -722,7 +722,7 @@ impl<'self> ConstraintContext<'self> {\n                                    def_id: ast::DefId,\n                                    generics: &ty::Generics,\n                                    substs: &ty::substs,\n-                                   variance: VarianceTermPtr<'self>) {\n+                                   variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_substs(def_id={:?})\", def_id);\n \n         for (i, p) in generics.type_param_defs.iter().enumerate() {\n@@ -749,7 +749,7 @@ impl<'self> ConstraintContext<'self> {\n     /// `sig` appearing in a context with ambient variance `variance`\n     fn add_constraints_from_sig(&mut self,\n                                 sig: &ty::FnSig,\n-                                variance: VarianceTermPtr<'self>) {\n+                                variance: VarianceTermPtr<'a>) {\n         let contra = self.contravariant(variance);\n         for &input in sig.inputs.iter() {\n             self.add_constraints_from_ty(input, contra);\n@@ -761,7 +761,7 @@ impl<'self> ConstraintContext<'self> {\n     /// context with ambient variance `variance`\n     fn add_constraints_from_region(&mut self,\n                                    region: ty::Region,\n-                                   variance: VarianceTermPtr<'self>) {\n+                                   variance: VarianceTermPtr<'a>) {\n         match region {\n             ty::ReEarlyBound(param_id, _, _) => {\n                 let index = self.inferred_index(param_id);\n@@ -790,7 +790,7 @@ impl<'self> ConstraintContext<'self> {\n     /// appearing in a context with ambient variance `variance`\n     fn add_constraints_from_mt(&mut self,\n                                mt: &ty::mt,\n-                               variance: VarianceTermPtr<'self>) {\n+                               variance: VarianceTermPtr<'a>) {\n         match mt.mutbl {\n             ast::MutMutable => {\n                 let invar = self.invariant(variance);\n@@ -813,9 +813,9 @@ impl<'self> ConstraintContext<'self> {\n  * inferred is then written into the `variance_map` in the tcx.\n  */\n \n-struct SolveContext<'self> {\n-    terms_cx: TermsContext<'self>,\n-    constraints: ~[Constraint<'self>],\n+struct SolveContext<'a> {\n+    terms_cx: TermsContext<'a>,\n+    constraints: ~[Constraint<'a>],\n \n     // Maps from an InferredIndex to the inferred value for that variable.\n     solutions: ~[ty::Variance]\n@@ -833,7 +833,7 @@ fn solve_constraints(constraints_cx: ConstraintContext) {\n     solutions_cx.write();\n }\n \n-impl<'self> SolveContext<'self> {\n+impl<'a> SolveContext<'a> {\n     fn solve(&mut self) {\n         // Propagate constraints until a fixed point is reached.  Note\n         // that the maximum number of iterations is 2C where C is the\n@@ -925,7 +925,7 @@ impl<'self> SolveContext<'self> {\n         }\n     }\n \n-    fn evaluate(&self, term: VarianceTermPtr<'self>) -> ty::Variance {\n+    fn evaluate(&self, term: VarianceTermPtr<'a>) -> ty::Variance {\n         match *term {\n             ConstantTerm(v) => {\n                 v"}, {"sha": "ad55c8dcab95f2a66ceb60642bf3229b0373b1db", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -69,12 +69,12 @@ pub fn field_exprs(fields: ~[ast::Field]) -> ~[@ast::Expr] {\n     fields.map(|f| f.expr)\n }\n \n-struct LoopQueryVisitor<'self> {\n-    p: 'self |&ast::Expr_| -> bool,\n+struct LoopQueryVisitor<'a> {\n+    p: 'a |&ast::Expr_| -> bool,\n     flag: bool,\n }\n \n-impl<'self> Visitor<()> for LoopQueryVisitor<'self> {\n+impl<'a> Visitor<()> for LoopQueryVisitor<'a> {\n     fn visit_expr(&mut self, e: @ast::Expr, _: ()) {\n         self.flag |= (self.p)(&e.node);\n         match e.node {\n@@ -97,12 +97,12 @@ pub fn loop_query(b: ast::P<ast::Block>, p: |&ast::Expr_| -> bool) -> bool {\n     return v.flag;\n }\n \n-struct BlockQueryVisitor<'self> {\n-    p: 'self |@ast::Expr| -> bool,\n+struct BlockQueryVisitor<'a> {\n+    p: 'a |@ast::Expr| -> bool,\n     flag: bool,\n }\n \n-impl<'self> Visitor<()> for BlockQueryVisitor<'self> {\n+impl<'a> Visitor<()> for BlockQueryVisitor<'a> {\n     fn visit_expr(&mut self, e: @ast::Expr, _:()) {\n         self.flag |= (self.p)(e);\n         visit::walk_expr(self, e, ())"}, {"sha": "9cc2d7dbb636a22c2b2d665c796a1da138803f61", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -567,7 +567,7 @@ fn repr_vec<T:Repr>(tcx: ctxt, v: &[T]) -> ~str {\n     vec_map_to_str(v, |t| t.repr(tcx))\n }\n \n-impl<'self, T:Repr> Repr for &'self [T] {\n+impl<'a, T:Repr> Repr for &'a [T] {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         repr_vec(tcx, *self)\n     }"}, {"sha": "54323ddeb3253b0d489d4fdf502ff46b2cbc561e", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -239,7 +239,7 @@ impl Clean<Attribute> for ast::Attribute {\n }\n \n // This is a rough approximation that gets us what we want.\n-impl<'self> attr::AttrMetaMethods for &'self Attribute {\n+impl<'a> attr::AttrMetaMethods for &'a Attribute {\n     fn name(&self) -> @str {\n         match **self {\n             Word(ref n) | List(ref n, _) | NameValue(ref n, _) =>"}, {"sha": "0022dcf279c471772acaecbb04acd3b49d7b0870", "filename": "src/librustdoc/html/escape.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fescape.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -17,10 +17,10 @@ use std::fmt;\n \n /// Wrapper struct which will emit the HTML-escaped version of the contained\n /// string when passed to a format string.\n-pub struct Escape<'self>(&'self str);\n+pub struct Escape<'a>(&'a str);\n \n-impl<'self> fmt::Default for Escape<'self> {\n-    fn fmt(s: &Escape<'self>, fmt: &mut fmt::Formatter) {\n+impl<'a> fmt::Default for Escape<'a> {\n+    fn fmt(s: &Escape<'a>, fmt: &mut fmt::Formatter) {\n         // Because the internet is always right, turns out there's not that many\n         // characters to escape: http://stackoverflow.com/questions/7381974\n         let pile_o_bits = s.as_slice();"}, {"sha": "661f96e7c1a3c4228b524f209589add05d3bbe83", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -33,7 +33,7 @@ pub struct VisSpace(Option<ast::visibility>);\n /// space after it.\n pub struct PuritySpace(ast::purity);\n /// Wrapper struct for properly emitting a method declaration.\n-pub struct Method<'self>(&'self clean::SelfTy, &'self clean::FnDecl);\n+pub struct Method<'a>(&'a clean::SelfTy, &'a clean::FnDecl);\n \n impl fmt::Default for clean::Generics {\n     fn fmt(g: &clean::Generics, f: &mut fmt::Formatter) {\n@@ -393,8 +393,8 @@ impl fmt::Default for ~[clean::Argument] {\n     }\n }\n \n-impl<'self> fmt::Default for Method<'self> {\n-    fn fmt(m: &Method<'self>, f: &mut fmt::Formatter) {\n+impl<'a> fmt::Default for Method<'a> {\n+    fn fmt(m: &Method<'a>, f: &mut fmt::Formatter) {\n         let Method(selfty, d) = *m;\n         let mut args = ~\"\";\n         match *selfty {"}, {"sha": "fd8c957801dc187ab39b3edde51c982f03241f1b", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -18,10 +18,10 @@ pub struct Layout {\n     crate: ~str,\n }\n \n-pub struct Page<'self> {\n-    title: &'self str,\n-    ty: &'self str,\n-    root_path: &'self str,\n+pub struct Page<'a> {\n+    title: &'a str,\n+    ty: &'a str,\n+    root_path: &'a str,\n }\n \n pub fn render<T: fmt::Default, S: fmt::Default>("}, {"sha": "97cd7c20f51cbd74825cf941c6d01bb69011ea87", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -30,7 +30,7 @@ use std::vec;\n /// A unit struct which has the `fmt::Default` trait implemented. When\n /// formatted, this struct will emit the HTML corresponding to the rendered\n /// version of the contained markdown string.\n-pub struct Markdown<'self>(&'self str);\n+pub struct Markdown<'a>(&'a str);\n \n static OUTPUT_UNIT: libc::size_t = 64;\n static MKDEXT_NO_INTRA_EMPHASIS: libc::c_uint = 1 << 0;\n@@ -119,8 +119,8 @@ fn render(w: &mut io::Writer, s: &str) {\n     }\n }\n \n-impl<'self> fmt::Default for Markdown<'self> {\n-    fn fmt(md: &Markdown<'self>, fmt: &mut fmt::Formatter) {\n+impl<'a> fmt::Default for Markdown<'a> {\n+    fn fmt(md: &Markdown<'a>, fmt: &mut fmt::Formatter) {\n         // This is actually common enough to special-case\n         if md.len() == 0 { return; }\n         render(fmt.buf, md.as_slice());"}, {"sha": "0c703e780f19b728843ce0fee8832fe891a5ef8c", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -166,8 +166,8 @@ pub struct Cache {\n }\n \n /// Helper struct to render all source code to HTML pages\n-struct SourceCollector<'self> {\n-    cx: &'self mut Context,\n+struct SourceCollector<'a> {\n+    cx: &'a mut Context,\n \n     /// Processed source-file paths\n     seen: HashSet<~str>,\n@@ -177,13 +177,13 @@ struct SourceCollector<'self> {\n \n /// Wrapper struct to render the source code of a file. This will do things like\n /// adding line numbers to the left-hand side.\n-struct Source<'self>(&'self str);\n+struct Source<'a>(&'a str);\n \n // Helper structs for rendering items/sidebars and carrying along contextual\n // information\n \n-struct Item<'self> { cx: &'self Context, item: &'self clean::Item, }\n-struct Sidebar<'self> { cx: &'self Context, item: &'self clean::Item, }\n+struct Item<'a> { cx: &'a Context, item: &'a clean::Item, }\n+struct Sidebar<'a> { cx: &'a Context, item: &'a clean::Item, }\n \n /// Struct representing one entry in the JS search index. These are all emitted\n /// by hand to a large JS file at the end of cache-creation.\n@@ -380,7 +380,7 @@ fn extern_location(e: &clean::ExternalCrate, dst: &Path) -> ExternalLocation {\n     return Unknown;\n }\n \n-impl<'self> DocFolder for SourceCollector<'self> {\n+impl<'a> DocFolder for SourceCollector<'a> {\n     fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n         // If we're including source files, and we haven't seen this file yet,\n         // then we need to render it out to the filesystem\n@@ -406,7 +406,7 @@ impl<'self> DocFolder for SourceCollector<'self> {\n     }\n }\n \n-impl<'self> SourceCollector<'self> {\n+impl<'a> SourceCollector<'a> {\n     /// Renders the given filename into its corresponding HTML source file.\n     fn emit_source(&mut self, filename: &str) -> bool {\n         let p = Path::new(filename);\n@@ -632,7 +632,7 @@ impl DocFolder for Cache {\n     }\n }\n \n-impl<'self> Cache {\n+impl<'a> Cache {\n     fn generics(&mut self, generics: &clean::Generics) {\n         for typ in generics.type_params.iter() {\n             self.typarams.insert(typ.id, typ.name.clone());\n@@ -862,16 +862,16 @@ fn shortty(item: &clean::Item) -> &'static str {\n     }\n }\n \n-impl<'self> Item<'self> {\n+impl<'a> Item<'a> {\n     fn ismodule(&self) -> bool {\n         match self.item.inner {\n             clean::ModuleItem(..) => true, _ => false\n         }\n     }\n }\n \n-impl<'self> fmt::Default for Item<'self> {\n-    fn fmt(it: &Item<'self>, fmt: &mut fmt::Formatter) {\n+impl<'a> fmt::Default for Item<'a> {\n+    fn fmt(it: &Item<'a>, fmt: &mut fmt::Formatter) {\n         match attr::find_stability(it.item.attrs.iter()) {\n             Some(stability) => {\n                 write!(fmt.buf,\n@@ -1057,9 +1057,9 @@ fn item_module(w: &mut Writer, cx: &Context,\n \n         match myitem.inner {\n             clean::StaticItem(ref s) | clean::ForeignStaticItem(ref s) => {\n-                struct Initializer<'self>(&'self str);\n-                impl<'self> fmt::Default for Initializer<'self> {\n-                    fn fmt(s: &Initializer<'self>, f: &mut fmt::Formatter) {\n+                struct Initializer<'a>(&'a str);\n+                impl<'a> fmt::Default for Initializer<'a> {\n+                    fn fmt(s: &Initializer<'a>, f: &mut fmt::Formatter) {\n                         if s.len() == 0 { return; }\n                         write!(f.buf, \"<code> = </code>\");\n                         let tag = if s.contains(\"\\n\") { \"pre\" } else { \"code\" };\n@@ -1563,8 +1563,8 @@ fn item_typedef(w: &mut Writer, it: &clean::Item, t: &clean::Typedef) {\n     document(w, it);\n }\n \n-impl<'self> fmt::Default for Sidebar<'self> {\n-    fn fmt(s: &Sidebar<'self>, fmt: &mut fmt::Formatter) {\n+impl<'a> fmt::Default for Sidebar<'a> {\n+    fn fmt(s: &Sidebar<'a>, fmt: &mut fmt::Formatter) {\n         let cx = s.cx;\n         let it = s.item;\n         write!(fmt.buf, \"<p class='location'>\");\n@@ -1628,8 +1628,8 @@ fn build_sidebar(m: &clean::Module) -> HashMap<~str, ~[~str]> {\n     return map;\n }\n \n-impl<'self> fmt::Default for Source<'self> {\n-    fn fmt(s: &Source<'self>, fmt: &mut fmt::Formatter) {\n+impl<'a> fmt::Default for Source<'a> {\n+    fn fmt(s: &Source<'a>, fmt: &mut fmt::Formatter) {\n         let lines = s.lines().len();\n         let mut cols = 0;\n         let mut tmp = lines;"}, {"sha": "d9c3cf803169566cb4b4481e9e36d4f4eec937b1", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -76,12 +76,12 @@ pub fn strip_private(crate: clean::Crate) -> plugins::PluginResult {\n     (crate, None)\n }\n \n-struct Stripper<'self> {\n-    retained: &'self mut HashSet<ast::NodeId>,\n-    exported_items: &'self HashSet<ast::NodeId>,\n+struct Stripper<'a> {\n+    retained: &'a mut HashSet<ast::NodeId>,\n+    exported_items: &'a HashSet<ast::NodeId>,\n }\n \n-impl<'self> fold::DocFolder for Stripper<'self> {\n+impl<'a> fold::DocFolder for Stripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         match i.inner {\n             // These items can all get re-exported\n@@ -150,8 +150,8 @@ impl<'self> fold::DocFolder for Stripper<'self> {\n }\n \n // This stripper discards all private impls of traits\n-struct ImplStripper<'self>(&'self HashSet<ast::NodeId>);\n-impl<'self> fold::DocFolder for ImplStripper<'self> {\n+struct ImplStripper<'a>(&'a HashSet<ast::NodeId>);\n+impl<'a> fold::DocFolder for ImplStripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         match i.inner {\n             clean::ImplItem(ref imp) => {"}, {"sha": "cedb21eeb2adf74c6a87ed7bf20adeee3b293f8d", "filename": "src/librustpkg/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustpkg%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustpkg%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Flib.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -83,9 +83,9 @@ pub mod usage;\n /// A PkgScript represents user-supplied custom logic for\n /// special build hooks. This only exists for packages with\n /// an explicit package script.\n-struct PkgScript<'self> {\n+struct PkgScript<'a> {\n     /// Uniquely identifies this package\n-    id: &'self PkgId,\n+    id: &'a PkgId,\n     /// File path for the package script\n     input: Path,\n     /// The session to use *only* for compiling the custom\n@@ -99,7 +99,7 @@ struct PkgScript<'self> {\n     build_dir: Path\n }\n \n-impl<'self> PkgScript<'self> {\n+impl<'a> PkgScript<'a> {\n     /// Given the path name for a package script\n     /// and a package ID, parse the package script into\n     /// a PkgScript that we can then execute"}, {"sha": "ae490dc1f8a361c1489048b1b7f76048bbd0a631", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -427,18 +427,18 @@ pub fn compile_crate(ctxt: &BuildContext,\n     compile_input(ctxt, exec, pkg_id, crate, workspace, deps, flags, cfgs, opt, what)\n }\n \n-struct ViewItemVisitor<'self> {\n-    context: &'self BuildContext,\n-    parent: &'self PkgId,\n-    parent_crate: &'self Path,\n+struct ViewItemVisitor<'a> {\n+    context: &'a BuildContext,\n+    parent: &'a PkgId,\n+    parent_crate: &'a Path,\n     sess: session::Session,\n-    exec: &'self mut workcache::Exec,\n-    c: &'self ast::Crate,\n-    save: 'self |Path|,\n-    deps: &'self mut DepMap\n+    exec: &'a mut workcache::Exec,\n+    c: &'a ast::Crate,\n+    save: 'a |Path|,\n+    deps: &'a mut DepMap\n }\n \n-impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n+impl<'a> Visitor<()> for ViewItemVisitor<'a> {\n     fn visit_view_item(&mut self, vi: &ast::view_item, env: ()) {\n         use conditions::nonexistent_package::cond;\n "}, {"sha": "8bce687e245376590c689e0f8aa3bf6f0b4626ca", "filename": "src/libstd/any.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fany.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -65,16 +65,16 @@ impl<T: 'static> Any for T {\n ///////////////////////////////////////////////////////////////////////////////\n \n /// Extension methods for a referenced `Any` trait object\n-pub trait AnyRefExt<'self> {\n+pub trait AnyRefExt<'a> {\n     /// Returns true if the boxed type is the same as `T`\n     fn is<T: 'static>(self) -> bool;\n \n     /// Returns some reference to the boxed value if it is of type `T`, or\n     /// `None` if it isn't.\n-    fn as_ref<T: 'static>(self) -> Option<&'self T>;\n+    fn as_ref<T: 'static>(self) -> Option<&'a T>;\n }\n \n-impl<'self> AnyRefExt<'self> for &'self Any {\n+impl<'a> AnyRefExt<'a> for &'a Any {\n     #[inline]\n     fn is<T: 'static>(self) -> bool {\n         // Get TypeId of the type this function is instantiated with\n@@ -88,7 +88,7 @@ impl<'self> AnyRefExt<'self> for &'self Any {\n     }\n \n     #[inline]\n-    fn as_ref<T: 'static>(self) -> Option<&'self T> {\n+    fn as_ref<T: 'static>(self) -> Option<&'a T> {\n         if self.is::<T>() {\n             Some(unsafe { transmute(self.as_void_ptr()) })\n         } else {\n@@ -98,15 +98,15 @@ impl<'self> AnyRefExt<'self> for &'self Any {\n }\n \n /// Extension methods for a mutable referenced `Any` trait object\n-pub trait AnyMutRefExt<'self> {\n+pub trait AnyMutRefExt<'a> {\n     /// Returns some mutable reference to the boxed value if it is of type `T`, or\n     /// `None` if it isn't.\n-    fn as_mut<T: 'static>(self) -> Option<&'self mut T>;\n+    fn as_mut<T: 'static>(self) -> Option<&'a mut T>;\n }\n \n-impl<'self> AnyMutRefExt<'self> for &'self mut Any {\n+impl<'a> AnyMutRefExt<'a> for &'a mut Any {\n     #[inline]\n-    fn as_mut<T: 'static>(self) -> Option<&'self mut T> {\n+    fn as_mut<T: 'static>(self) -> Option<&'a mut T> {\n         if self.is::<T>() {\n             Some(unsafe { transmute(self.as_mut_void_ptr()) })\n         } else {\n@@ -149,7 +149,7 @@ impl ToStr for ~Any {\n     fn to_str(&self) -> ~str { ~\"~Any\" }\n }\n \n-impl<'self> ToStr for &'self Any {\n+impl<'a> ToStr for &'a Any {\n     fn to_str(&self) -> ~str { ~\"&Any\" }\n }\n "}, {"sha": "2242ded94f53faaa2a03a5067cf7459955452042", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -145,15 +145,15 @@ pub trait AsciiCast<T> {\n     fn is_ascii(&self) -> bool;\n }\n \n-impl<'self> AsciiCast<&'self[Ascii]> for &'self [u8] {\n+impl<'a> AsciiCast<&'a[Ascii]> for &'a [u8] {\n     #[inline]\n-    fn to_ascii(&self) -> &'self[Ascii] {\n+    fn to_ascii(&self) -> &'a[Ascii] {\n         assert!(self.is_ascii());\n         unsafe {self.to_ascii_nocheck()}\n     }\n \n     #[inline]\n-    unsafe fn to_ascii_nocheck(&self) -> &'self[Ascii] {\n+    unsafe fn to_ascii_nocheck(&self) -> &'a[Ascii] {\n         cast::transmute(*self)\n     }\n \n@@ -166,15 +166,15 @@ impl<'self> AsciiCast<&'self[Ascii]> for &'self [u8] {\n     }\n }\n \n-impl<'self> AsciiCast<&'self [Ascii]> for &'self str {\n+impl<'a> AsciiCast<&'a [Ascii]> for &'a str {\n     #[inline]\n-    fn to_ascii(&self) -> &'self [Ascii] {\n+    fn to_ascii(&self) -> &'a [Ascii] {\n         assert!(self.is_ascii());\n         unsafe { self.to_ascii_nocheck() }\n     }\n \n     #[inline]\n-    unsafe fn to_ascii_nocheck(&self) -> &'self [Ascii] {\n+    unsafe fn to_ascii_nocheck(&self) -> &'a [Ascii] {\n         cast::transmute(*self)\n     }\n \n@@ -272,7 +272,7 @@ pub trait AsciiStr {\n     fn eq_ignore_case(self, other: &[Ascii]) -> bool;\n }\n \n-impl<'self> AsciiStr for &'self [Ascii] {\n+impl<'a> AsciiStr for &'a [Ascii] {\n     #[inline]\n     fn as_str_ascii<'a>(&'a self) -> &'a str {\n         unsafe { cast::transmute(*self) }\n@@ -351,7 +351,7 @@ pub trait StrAsciiExt {\n     fn eq_ignore_ascii_case(&self, other: &str) -> bool;\n }\n \n-impl<'self> StrAsciiExt for &'self str {\n+impl<'a> StrAsciiExt for &'a str {\n     #[inline]\n     fn to_ascii_upper(&self) -> ~str {\n         unsafe { str_copy_map_bytes(*self, ASCII_UPPER_MAP) }"}, {"sha": "352d1abfb4b41c953793ee9f5cc97be310cedb5b", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -153,7 +153,7 @@ pub mod traits {\n     use ops::Add;\n     use vec::Vector;\n \n-    impl<'self,T:Clone, V: Vector<T>> Add<V,@[T]> for @[T] {\n+    impl<'a,T:Clone, V: Vector<T>> Add<V,@[T]> for @[T] {\n         #[inline]\n         fn add(&self, rhs: &V) -> @[T] {\n             append(*self, rhs.as_slice())"}, {"sha": "e8eda39537c848bf6ddd8e6643aed496a85d26e6", "filename": "src/libstd/borrow.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fborrow.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -27,48 +27,48 @@ pub fn ref_eq<'a, 'b, T>(thing: &'a T, other: &'b T) -> bool {\n \n // Equality for region pointers\n #[cfg(not(test))]\n-impl<'self, T: Eq> Eq for &'self T {\n+impl<'a, T: Eq> Eq for &'a T {\n     #[inline]\n-    fn eq(&self, other: & &'self T) -> bool {\n+    fn eq(&self, other: & &'a T) -> bool {\n         *(*self) == *(*other)\n     }\n     #[inline]\n-    fn ne(&self, other: & &'self T) -> bool {\n+    fn ne(&self, other: & &'a T) -> bool {\n         *(*self) != *(*other)\n     }\n }\n \n // Comparison for region pointers\n #[cfg(not(test))]\n-impl<'self, T: Ord> Ord for &'self T {\n+impl<'a, T: Ord> Ord for &'a T {\n     #[inline]\n-    fn lt(&self, other: & &'self T) -> bool {\n+    fn lt(&self, other: & &'a T) -> bool {\n         *(*self) < *(*other)\n     }\n     #[inline]\n-    fn le(&self, other: & &'self T) -> bool {\n+    fn le(&self, other: & &'a T) -> bool {\n         *(*self) <= *(*other)\n     }\n     #[inline]\n-    fn ge(&self, other: & &'self T) -> bool {\n+    fn ge(&self, other: & &'a T) -> bool {\n         *(*self) >= *(*other)\n     }\n     #[inline]\n-    fn gt(&self, other: & &'self T) -> bool {\n+    fn gt(&self, other: & &'a T) -> bool {\n         *(*self) > *(*other)\n     }\n }\n \n #[cfg(not(test))]\n-impl<'self, T: TotalOrd> TotalOrd for &'self T {\n+impl<'a, T: TotalOrd> TotalOrd for &'a T {\n     #[inline]\n-    fn cmp(&self, other: & &'self T) -> Ordering { (**self).cmp(*other) }\n+    fn cmp(&self, other: & &'a T) -> Ordering { (**self).cmp(*other) }\n }\n \n #[cfg(not(test))]\n-impl<'self, T: TotalEq> TotalEq for &'self T {\n+impl<'a, T: TotalEq> TotalEq for &'a T {\n     #[inline]\n-    fn equals(&self, other: & &'self T) -> bool { (**self).equals(*other) }\n+    fn equals(&self, other: & &'a T) -> bool { (**self).equals(*other) }\n }\n \n #[cfg(test)]"}, {"sha": "1563b7f99d193d6ce5ed7bf940d4d4fe881b8a47", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -234,7 +234,7 @@ pub trait ToCStr {\n     }\n }\n \n-impl<'self> ToCStr for &'self str {\n+impl<'a> ToCStr for &'a str {\n     #[inline]\n     fn to_c_str(&self) -> CString {\n         self.as_bytes().to_c_str()\n@@ -259,7 +259,7 @@ impl<'self> ToCStr for &'self str {\n // The length of the stack allocated buffer for `vec.with_c_str()`\n static BUF_LEN: uint = 128;\n \n-impl<'self> ToCStr for &'self [u8] {\n+impl<'a> ToCStr for &'a [u8] {\n     fn to_c_str(&self) -> CString {\n         let mut cs = unsafe { self.to_c_str_unchecked() };\n         cs.with_mut_ref(|buf| check_for_null(*self, buf));\n@@ -328,12 +328,12 @@ fn check_for_null(v: &[u8], buf: *mut libc::c_char) {\n /// External iterator for a CString's bytes.\n ///\n /// Use with the `std::iter` module.\n-pub struct CStringIterator<'self> {\n+pub struct CStringIterator<'a> {\n     priv ptr: *libc::c_char,\n-    priv lifetime: &'self libc::c_char, // FIXME: #5922\n+    priv lifetime: &'a libc::c_char, // FIXME: #5922\n }\n \n-impl<'self> Iterator<libc::c_char> for CStringIterator<'self> {\n+impl<'a> Iterator<libc::c_char> for CStringIterator<'a> {\n     fn next(&mut self) -> Option<libc::c_char> {\n         let ch = unsafe { *self.ptr };\n         if ch == 0 {"}, {"sha": "7b01a5c1b812e30aa615989a56706964547e30fe", "filename": "src/libstd/cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcleanup.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -15,7 +15,7 @@ use ptr;\n use unstable::intrinsics::TyDesc;\n use unstable::raw;\n \n-type DropGlue<'self> = 'self |**TyDesc, *c_void|;\n+type DropGlue<'a> = 'a |**TyDesc, *c_void|;\n \n /*\n  * Box annihilation"}, {"sha": "95d75138082b3b1463bc93874ff912cd82d84523", "filename": "src/libstd/clone.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fclone.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -64,22 +64,22 @@ impl<T> Clone for @mut T {\n     fn clone(&self) -> @mut T { *self }\n }\n \n-impl<'self, T> Clone for &'self T {\n+impl<'a, T> Clone for &'a T {\n     /// Return a shallow copy of the borrowed pointer.\n     #[inline]\n-    fn clone(&self) -> &'self T { *self }\n+    fn clone(&self) -> &'a T { *self }\n }\n \n-impl<'self, T> Clone for &'self [T] {\n+impl<'a, T> Clone for &'a [T] {\n     /// Return a shallow copy of the slice.\n     #[inline]\n-    fn clone(&self) -> &'self [T] { *self }\n+    fn clone(&self) -> &'a [T] { *self }\n }\n \n-impl<'self> Clone for &'self str {\n+impl<'a> Clone for &'a str {\n     /// Return a shallow copy of the slice.\n     #[inline]\n-    fn clone(&self) -> &'self str { *self }\n+    fn clone(&self) -> &'a str { *self }\n }\n \n macro_rules! clone_impl("}, {"sha": "df5154123f26499501bc235a8acda62936fc3a26", "filename": "src/libstd/condition.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcondition.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -162,12 +162,12 @@ impl<T, U> Condition<T, U> {\n ///\n /// Normally this object is not dealt with directly, but rather it's directly\n /// used after being returned from `trap`\n-pub struct Trap<'self, T, U> {\n-    priv cond: &'self Condition<T, U>,\n+pub struct Trap<'a, T, U> {\n+    priv cond: &'a Condition<T, U>,\n     priv handler: @Handler<T, U>\n }\n \n-impl<'self, T, U> Trap<'self, T, U> {\n+impl<'a, T, U> Trap<'a, T, U> {\n     /// Execute a block of code with this trap handler's exception handler\n     /// registered.\n     ///\n@@ -181,7 +181,7 @@ impl<'self, T, U> Trap<'self, T, U> {\n     /// });\n     /// assert_eq!(result, 7);\n     /// ```\n-    pub fn inside<V>(&self, inner: 'self || -> V) -> V {\n+    pub fn inside<V>(&self, inner: 'a || -> V) -> V {\n         let _g = Guard { cond: self.cond };\n         debug!(\"Trap: pushing handler to TLS\");\n         local_data::set(self.cond.key, self.handler);\n@@ -191,7 +191,7 @@ impl<'self, T, U> Trap<'self, T, U> {\n     /// Returns a guard that will automatically reset the condition upon\n     /// exit of the scope. This is useful if you want to use conditions with\n     /// an RAII pattern.\n-    pub fn guard(&self) -> Guard<'self,T,U> {\n+    pub fn guard(&self) -> Guard<'a,T,U> {\n         let guard = Guard {\n             cond: self.cond\n         };\n@@ -204,12 +204,12 @@ impl<'self, T, U> Trap<'self, T, U> {\n /// A guard that will automatically reset the condition handler upon exit of\n /// the scope. This is useful if you want to use conditions with an RAII\n /// pattern.\n-pub struct Guard<'self, T, U> {\n-    priv cond: &'self Condition<T, U>\n+pub struct Guard<'a, T, U> {\n+    priv cond: &'a Condition<T, U>\n }\n \n #[unsafe_destructor]\n-impl<'self, T, U> Drop for Guard<'self, T, U> {\n+impl<'a, T, U> Drop for Guard<'a, T, U> {\n     fn drop(&mut self) {\n         debug!(\"Guard: popping handler from TLS\");\n         let curr = local_data::pop(self.cond.key);"}, {"sha": "a98a110ac3b2689a75b78a4308941064f2f207db", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -476,7 +476,7 @@ pub mod rt;\n /// A struct to represent both where to emit formatting strings to and how they\n /// should be formatted. A mutable version of this is passed to all formatting\n /// traits.\n-pub struct Formatter<'self> {\n+pub struct Formatter<'a> {\n     /// Flags for formatting (packed version of rt::Flag)\n     flags: uint,\n     /// Character used as 'fill' whenever there is alignment\n@@ -489,21 +489,21 @@ pub struct Formatter<'self> {\n     precision: Option<uint>,\n \n     /// Output buffer.\n-    buf: &'self mut io::Writer,\n-    priv curarg: vec::VecIterator<'self, Argument<'self>>,\n-    priv args: &'self [Argument<'self>],\n+    buf: &'a mut io::Writer,\n+    priv curarg: vec::VecIterator<'a, Argument<'a>>,\n+    priv args: &'a [Argument<'a>],\n }\n \n /// This struct represents the generic \"argument\" which is taken by the Xprintf\n /// family of functions. It contains a function to format the given value. At\n /// compile time it is ensured that the function and the value have the correct\n /// types, and then this struct is used to canonicalize arguments to one type.\n-pub struct Argument<'self> {\n+pub struct Argument<'a> {\n     priv formatter: extern \"Rust\" fn(&util::Void, &mut Formatter),\n-    priv value: &'self util::Void,\n+    priv value: &'a util::Void,\n }\n \n-impl<'self> Arguments<'self> {\n+impl<'a> Arguments<'a> {\n     /// When using the format_args!() macro, this function is used to generate the\n     /// Arguments structure. The compiler inserts an `unsafe` block to call this,\n     /// which is valid because the compiler performs all necessary validation to\n@@ -524,9 +524,9 @@ impl<'self> Arguments<'self> {\n /// and pass it to a user-supplied function. The macro validates the format\n /// string at compile-time so usage of the `write` and `format` functions can\n /// be safely performed.\n-pub struct Arguments<'self> {\n-    priv fmt: &'self [rt::Piece<'self>],\n-    priv args: &'self [Argument<'self>],\n+pub struct Arguments<'a> {\n+    priv fmt: &'a [rt::Piece<'a>],\n+    priv args: &'a [Argument<'a>],\n }\n \n /// When a format is not otherwise specified, types are formatted by ascribing\n@@ -684,7 +684,7 @@ pub unsafe fn format_unsafe(fmt: &[rt::Piece], args: &[Argument]) -> ~str {\n     return str::from_utf8_owned(output.inner());\n }\n \n-impl<'self> Formatter<'self> {\n+impl<'a> Formatter<'a> {\n \n     // First up is the collection of functions used to execute a format string\n     // at runtime. This consumes all of the compile-time statics generated by\n@@ -988,7 +988,7 @@ impl Bool for bool {\n     }\n }\n \n-impl<'self, T: str::Str> String for T {\n+impl<'a, T: str::Str> String for T {\n     fn fmt(s: &T, f: &mut Formatter) {\n         f.pad(s.as_slice());\n     }\n@@ -1111,7 +1111,7 @@ impl<T> Pointer for *mut T {\n // Implementation of Default for various core types\n \n macro_rules! delegate(($ty:ty to $other:ident) => {\n-    impl<'self> Default for $ty {\n+    impl<'a> Default for $ty {\n         fn fmt(me: &$ty, f: &mut Formatter) {\n             $other::fmt(me, f)\n         }\n@@ -1129,7 +1129,7 @@ delegate!( u32 to Unsigned)\n delegate!( u64 to Unsigned)\n delegate!(@str to String)\n delegate!(~str to String)\n-delegate!(&'self str to String)\n+delegate!(&'a str to String)\n delegate!(bool to Bool)\n delegate!(char to Char)\n delegate!(f32 to Float)"}, {"sha": "e9f7af181a7629a897681874956ee1f37a9bf581", "filename": "src/libstd/fmt/parse.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Ffmt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Ffmt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fparse.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -24,52 +24,52 @@ condition! { pub parse_error: ~str -> (); }\n /// A piece is a portion of the format string which represents the next part to\n /// emit. These are emitted as a stream by the `Parser` class.\n #[deriving(Eq)]\n-pub enum Piece<'self> {\n+pub enum Piece<'a> {\n     /// A literal string which should directly be emitted\n-    String(&'self str),\n+    String(&'a str),\n     /// A back-reference to whatever the current argument is. This is used\n     /// inside of a method call to refer back to the original argument.\n     CurrentArgument,\n     /// This describes that formatting should process the next argument (as\n     /// specified inside) for emission.\n-    Argument(Argument<'self>),\n+    Argument(Argument<'a>),\n }\n \n /// Representation of an argument specification.\n #[deriving(Eq)]\n-pub struct Argument<'self> {\n+pub struct Argument<'a> {\n     /// Where to find this argument\n-    position: Position<'self>,\n+    position: Position<'a>,\n     /// How to format the argument\n-    format: FormatSpec<'self>,\n+    format: FormatSpec<'a>,\n     /// If not `None`, what method to invoke on the argument\n-    method: Option<~Method<'self>>\n+    method: Option<~Method<'a>>\n }\n \n /// Specification for the formatting of an argument in the format string.\n #[deriving(Eq)]\n-pub struct FormatSpec<'self> {\n+pub struct FormatSpec<'a> {\n     /// Optionally specified character to fill alignment with\n     fill: Option<char>,\n     /// Optionally specified alignment\n     align: Alignment,\n     /// Packed version of various flags provided\n     flags: uint,\n     /// The integer precision to use\n-    precision: Count<'self>,\n+    precision: Count<'a>,\n     /// The string width requested for the resulting format\n-    width: Count<'self>,\n+    width: Count<'a>,\n     /// The descriptor string representing the name of the format desired for\n     /// this argument, this can be empty or any number of characters, although\n     /// it is required to be one word.\n-    ty: &'self str\n+    ty: &'a str\n }\n \n /// Enum describing where an argument for a format can be located.\n #[deriving(Eq)]\n #[allow(missing_doc)]\n-pub enum Position<'self> {\n-    ArgumentNext, ArgumentIs(uint), ArgumentNamed(&'self str)\n+pub enum Position<'a> {\n+    ArgumentNext, ArgumentIs(uint), ArgumentNamed(&'a str)\n }\n \n /// Enum of alignments which are supported.\n@@ -92,9 +92,9 @@ pub enum Flag {\n /// can reference either an argument or a literal integer.\n #[deriving(Eq)]\n #[allow(missing_doc)]\n-pub enum Count<'self> {\n+pub enum Count<'a> {\n     CountIs(uint),\n-    CountIsName(&'self str),\n+    CountIsName(&'a str),\n     CountIsParam(uint),\n     CountIsNextParam,\n     CountImplied,\n@@ -103,7 +103,7 @@ pub enum Count<'self> {\n /// Enum describing all of the possible methods which the formatting language\n /// currently supports.\n #[deriving(Eq)]\n-pub enum Method<'self> {\n+pub enum Method<'a> {\n     /// A plural method selects on an integer over a list of either integer or\n     /// keyword-defined clauses. The meaning of the keywords is defined by the\n     /// current locale.\n@@ -113,23 +113,23 @@ pub enum Method<'self> {\n     ///\n     /// The final element of this enum is the default \"other\" case which is\n     /// always required to be specified.\n-    Plural(Option<uint>, ~[PluralArm<'self>], ~[Piece<'self>]),\n+    Plural(Option<uint>, ~[PluralArm<'a>], ~[Piece<'a>]),\n \n     /// A select method selects over a string. Each arm is a different string\n     /// which can be selected for.\n     ///\n     /// As with `Plural`, a default \"other\" case is required as well.\n-    Select(~[SelectArm<'self>], ~[Piece<'self>]),\n+    Select(~[SelectArm<'a>], ~[Piece<'a>]),\n }\n \n /// Structure representing one \"arm\" of the `plural` function.\n #[deriving(Eq)]\n-pub struct PluralArm<'self> {\n+pub struct PluralArm<'a> {\n     /// A selector can either be specified by a keyword or with an integer\n     /// literal.\n     selector: Either<PluralKeyword, uint>,\n     /// Array of pieces which are the format of this arm\n-    result: ~[Piece<'self>],\n+    result: ~[Piece<'a>],\n }\n \n /// Enum of the 5 CLDR plural keywords. There is one more, \"other\", but that is\n@@ -144,11 +144,11 @@ pub enum PluralKeyword {\n \n /// Structure representing one \"arm\" of the `select` function.\n #[deriving(Eq)]\n-pub struct SelectArm<'self> {\n+pub struct SelectArm<'a> {\n     /// String selector which guards this arm\n-    selector: &'self str,\n+    selector: &'a str,\n     /// Array of pieces which are the format of this arm\n-    result: ~[Piece<'self>],\n+    result: ~[Piece<'a>],\n }\n \n /// The parser structure for interpreting the input format string. This is\n@@ -157,14 +157,14 @@ pub struct SelectArm<'self> {\n ///\n /// This is a recursive-descent parser for the sake of simplicity, and if\n /// necessary there's probably lots of room for improvement performance-wise.\n-pub struct Parser<'self> {\n-    priv input: &'self str,\n-    priv cur: str::CharOffsetIterator<'self>,\n+pub struct Parser<'a> {\n+    priv input: &'a str,\n+    priv cur: str::CharOffsetIterator<'a>,\n     priv depth: uint,\n }\n \n-impl<'self> Iterator<Piece<'self>> for Parser<'self> {\n-    fn next(&mut self) -> Option<Piece<'self>> {\n+impl<'a> Iterator<Piece<'a>> for Parser<'a> {\n+    fn next(&mut self) -> Option<Piece<'a>> {\n         match self.cur.clone().next() {\n             Some((_, '#')) => { self.cur.next(); Some(CurrentArgument) }\n             Some((_, '{')) => {\n@@ -191,7 +191,7 @@ impl<'self> Iterator<Piece<'self>> for Parser<'self> {\n     }\n }\n \n-impl<'self> Parser<'self> {\n+impl<'a> Parser<'a> {\n     /// Creates a new parser for the given format string\n     pub fn new<'a>(s: &'a str) -> Parser<'a> {\n         Parser {\n@@ -276,7 +276,7 @@ impl<'self> Parser<'self> {\n \n     /// Parses all of a string which is to be considered a \"raw literal\" in a\n     /// format string. This is everything outside of the braces.\n-    fn string(&mut self, start: uint) -> &'self str {\n+    fn string(&mut self, start: uint) -> &'a str {\n         loop {\n             // we may not consume the character, so clone the iterator\n             match self.cur.clone().next() {\n@@ -295,7 +295,7 @@ impl<'self> Parser<'self> {\n \n     /// Parses an Argument structure, or what's contained within braces inside\n     /// the format string\n-    fn argument(&mut self) -> Argument<'self> {\n+    fn argument(&mut self) -> Argument<'a> {\n         Argument {\n             position: self.position(),\n             format: self.format(),\n@@ -305,7 +305,7 @@ impl<'self> Parser<'self> {\n \n     /// Parses a positional argument for a format. This could either be an\n     /// integer index of an argument, a named argument, or a blank string.\n-    fn position(&mut self) -> Position<'self> {\n+    fn position(&mut self) -> Position<'a> {\n         match self.integer() {\n             Some(i) => { ArgumentIs(i) }\n             None => {\n@@ -321,7 +321,7 @@ impl<'self> Parser<'self> {\n \n     /// Parses a format specifier at the current position, returning all of the\n     /// relevant information in the FormatSpec struct.\n-    fn format(&mut self) -> FormatSpec<'self> {\n+    fn format(&mut self) -> FormatSpec<'a> {\n         let mut spec = FormatSpec {\n             fill: None,\n             align: AlignUnknown,\n@@ -396,7 +396,7 @@ impl<'self> Parser<'self> {\n \n     /// Parses a method to be applied to the previously specified argument and\n     /// its format. The two current supported methods are 'plural' and 'select'\n-    fn method(&mut self) -> Option<~Method<'self>> {\n+    fn method(&mut self) -> Option<~Method<'a>> {\n         if !self.wsconsume(',') {\n             return None;\n         }\n@@ -422,7 +422,7 @@ impl<'self> Parser<'self> {\n     }\n \n     /// Parses a 'select' statement (after the initial 'select' word)\n-    fn select(&mut self) -> ~Method<'self> {\n+    fn select(&mut self) -> ~Method<'a> {\n         let mut other = None;\n         let mut arms = ~[];\n         // Consume arms one at a time\n@@ -464,7 +464,7 @@ impl<'self> Parser<'self> {\n     }\n \n     /// Parses a 'plural' statement (after the initial 'plural' word)\n-    fn plural(&mut self) -> ~Method<'self> {\n+    fn plural(&mut self) -> ~Method<'a> {\n         let mut offset = None;\n         let mut other = None;\n         let mut arms = ~[];\n@@ -564,7 +564,7 @@ impl<'self> Parser<'self> {\n     /// Parses a Count parameter at the current position. This does not check\n     /// for 'CountIsNextParam' because that is only used in precision, not\n     /// width.\n-    fn count(&mut self) -> Count<'self> {\n+    fn count(&mut self) -> Count<'a> {\n         match self.integer() {\n             Some(i) => {\n                 if self.consume('$') {\n@@ -591,7 +591,7 @@ impl<'self> Parser<'self> {\n     /// Parses a word starting at the current position. A word is considered to\n     /// be an alphabetic character followed by any number of alphanumeric\n     /// characters.\n-    fn word(&mut self) -> &'self str {\n+    fn word(&mut self) -> &'a str {\n         let start = match self.cur.clone().next() {\n             Some((pos, c)) if char::is_XID_start(c) => {\n                 self.cur.next();"}, {"sha": "c139a2f5734e86f62567341be6044536b772e5c3", "filename": "src/libstd/fmt/rt.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Frt.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -21,17 +21,17 @@ use either::Either;\n use fmt::parse;\n use option::Option;\n \n-pub enum Piece<'self> {\n-    String(&'self str),\n+pub enum Piece<'a> {\n+    String(&'a str),\n     // FIXME(#8259): this shouldn't require the unit-value here\n     CurrentArgument(()),\n-    Argument(Argument<'self>),\n+    Argument(Argument<'a>),\n }\n \n-pub struct Argument<'self> {\n+pub struct Argument<'a> {\n     position: Position,\n     format: FormatSpec,\n-    method: Option<&'self Method<'self>>\n+    method: Option<&'a Method<'a>>\n }\n \n pub struct FormatSpec {\n@@ -50,17 +50,17 @@ pub enum Position {\n     ArgumentNext, ArgumentIs(uint)\n }\n \n-pub enum Method<'self> {\n-    Plural(Option<uint>, &'self [PluralArm<'self>], &'self [Piece<'self>]),\n-    Select(&'self [SelectArm<'self>], &'self [Piece<'self>]),\n+pub enum Method<'a> {\n+    Plural(Option<uint>, &'a [PluralArm<'a>], &'a [Piece<'a>]),\n+    Select(&'a [SelectArm<'a>], &'a [Piece<'a>]),\n }\n \n-pub struct PluralArm<'self> {\n+pub struct PluralArm<'a> {\n     selector: Either<parse::PluralKeyword, uint>,\n-    result: &'self [Piece<'self>],\n+    result: &'a [Piece<'a>],\n }\n \n-pub struct SelectArm<'self> {\n-    selector: &'self str,\n-    result: &'self [Piece<'self>],\n+pub struct SelectArm<'a> {\n+    selector: &'a str,\n+    result: &'a [Piece<'a>],\n }"}, {"sha": "a135d66141a51d3385efd5bb5b72df2d2dc691a5", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -305,8 +305,8 @@ mod tests {\n     use prelude::*;\n \n     // Hash just the bytes of the slice, without length prefix\n-    struct Bytes<'self>(&'self [u8]);\n-    impl<'self> IterBytes for Bytes<'self> {\n+    struct Bytes<'a>(&'a [u8]);\n+    impl<'a> IterBytes for Bytes<'a> {\n         fn iter_bytes(&self, _lsb0: bool, f: |&[u8]| -> bool) -> bool {\n             f(**self)\n         }"}, {"sha": "335e77c647803bbbb81593da9aa2f52d15c6497c", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -521,13 +521,13 @@ impl<K:Hash + Eq + Clone,V:Clone> Clone for HashMap<K,V> {\n \n /// HashMap iterator\n #[deriving(Clone)]\n-pub struct HashMapIterator<'self, K, V> {\n-    priv iter: vec::VecIterator<'self, Option<Bucket<K, V>>>,\n+pub struct HashMapIterator<'a, K, V> {\n+    priv iter: vec::VecIterator<'a, Option<Bucket<K, V>>>,\n }\n \n /// HashMap mutable values iterator\n-pub struct HashMapMutIterator<'self, K, V> {\n-    priv iter: vec::VecMutIterator<'self, Option<Bucket<K, V>>>,\n+pub struct HashMapMutIterator<'a, K, V> {\n+    priv iter: vec::VecMutIterator<'a, Option<Bucket<K, V>>>,\n }\n \n /// HashMap move iterator\n@@ -537,18 +537,18 @@ pub struct HashMapMoveIterator<K, V> {\n \n /// HashSet iterator\n #[deriving(Clone)]\n-pub struct HashSetIterator<'self, K> {\n-    priv iter: vec::VecIterator<'self, Option<Bucket<K, ()>>>,\n+pub struct HashSetIterator<'a, K> {\n+    priv iter: vec::VecIterator<'a, Option<Bucket<K, ()>>>,\n }\n \n /// HashSet move iterator\n pub struct HashSetMoveIterator<K> {\n     priv iter: vec::MoveRevIterator<Option<Bucket<K, ()>>>,\n }\n \n-impl<'self, K, V> Iterator<(&'self K, &'self V)> for HashMapIterator<'self, K, V> {\n+impl<'a, K, V> Iterator<(&'a K, &'a V)> for HashMapIterator<'a, K, V> {\n     #[inline]\n-    fn next(&mut self) -> Option<(&'self K, &'self V)> {\n+    fn next(&mut self) -> Option<(&'a K, &'a V)> {\n         for elt in self.iter {\n             match elt {\n                 &Some(ref bucket) => return Some((&bucket.key, &bucket.value)),\n@@ -559,9 +559,9 @@ impl<'self, K, V> Iterator<(&'self K, &'self V)> for HashMapIterator<'self, K, V\n     }\n }\n \n-impl<'self, K, V> Iterator<(&'self K, &'self mut V)> for HashMapMutIterator<'self, K, V> {\n+impl<'a, K, V> Iterator<(&'a K, &'a mut V)> for HashMapMutIterator<'a, K, V> {\n     #[inline]\n-    fn next(&mut self) -> Option<(&'self K, &'self mut V)> {\n+    fn next(&mut self) -> Option<(&'a K, &'a mut V)> {\n         for elt in self.iter {\n             match elt {\n                 &Some(ref mut bucket) => return Some((&bucket.key, &mut bucket.value)),\n@@ -585,9 +585,9 @@ impl<K, V> Iterator<(K, V)> for HashMapMoveIterator<K, V> {\n     }\n }\n \n-impl<'self, K> Iterator<&'self K> for HashSetIterator<'self, K> {\n+impl<'a, K> Iterator<&'a K> for HashSetIterator<'a, K> {\n     #[inline]\n-    fn next(&mut self) -> Option<&'self K> {\n+    fn next(&mut self) -> Option<&'a K> {\n         for elt in self.iter {\n             match elt {\n                 &Some(ref bucket) => return Some(&bucket.key),\n@@ -798,9 +798,9 @@ impl<K: Eq + Hash> Default for HashSet<K> {\n // `Repeat` is used to feed the filter closure an explicit capture\n // of a reference to the other set\n /// Set operations iterator\n-pub type SetAlgebraIter<'self, T> =\n-    FilterMap<'static,(&'self HashSet<T>, &'self T), &'self T,\n-              Zip<Repeat<&'self HashSet<T>>,HashSetIterator<'self,T>>>;\n+pub type SetAlgebraIter<'a, T> =\n+    FilterMap<'static,(&'a HashSet<T>, &'a T), &'a T,\n+              Zip<Repeat<&'a HashSet<T>>,HashSetIterator<'a,T>>>;\n \n \n #[cfg(test)]"}, {"sha": "b6778d89c33222470f292ed050bdc17629f4f04f", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -148,12 +148,12 @@ impl Decorator<~[u8]> for MemReader {\n ///\n /// If a write will not fit in the buffer, it raises the `io_error`\n /// condition and does not write any data.\n-pub struct BufWriter<'self> {\n-    priv buf: &'self mut [u8],\n+pub struct BufWriter<'a> {\n+    priv buf: &'a mut [u8],\n     priv pos: uint\n }\n \n-impl<'self> BufWriter<'self> {\n+impl<'a> BufWriter<'a> {\n     pub fn new<'a>(buf: &'a mut [u8]) -> BufWriter<'a> {\n         BufWriter {\n             buf: buf,\n@@ -162,7 +162,7 @@ impl<'self> BufWriter<'self> {\n     }\n }\n \n-impl<'self> Writer for BufWriter<'self> {\n+impl<'a> Writer for BufWriter<'a> {\n     fn write(&mut self, buf: &[u8]) {\n         // raises a condition if the entire write does not fit in the buffer\n         let max_size = self.buf.len();\n@@ -182,7 +182,7 @@ impl<'self> Writer for BufWriter<'self> {\n }\n \n // FIXME(#10432)\n-impl<'self> Seek for BufWriter<'self> {\n+impl<'a> Seek for BufWriter<'a> {\n     fn tell(&self) -> u64 { self.pos as u64 }\n \n     fn seek(&mut self, pos: i64, style: SeekStyle) {\n@@ -199,12 +199,12 @@ impl<'self> Seek for BufWriter<'self> {\n \n \n /// Reads from a fixed-size byte slice\n-pub struct BufReader<'self> {\n-    priv buf: &'self [u8],\n+pub struct BufReader<'a> {\n+    priv buf: &'a [u8],\n     priv pos: uint\n }\n \n-impl<'self> BufReader<'self> {\n+impl<'a> BufReader<'a> {\n     pub fn new<'a>(buf: &'a [u8]) -> BufReader<'a> {\n         BufReader {\n             buf: buf,\n@@ -213,7 +213,7 @@ impl<'self> BufReader<'self> {\n     }\n }\n \n-impl<'self> Reader for BufReader<'self> {\n+impl<'a> Reader for BufReader<'a> {\n     fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n         { if self.eof() { return None; } }\n \n@@ -233,13 +233,13 @@ impl<'self> Reader for BufReader<'self> {\n     fn eof(&mut self) -> bool { self.pos == self.buf.len() }\n }\n \n-impl<'self> Seek for BufReader<'self> {\n+impl<'a> Seek for BufReader<'a> {\n     fn tell(&self) -> u64 { self.pos as u64 }\n \n     fn seek(&mut self, _pos: i64, _style: SeekStyle) { fail!() }\n }\n \n-impl<'self> Buffer for BufReader<'self> {\n+impl<'a> Buffer for BufReader<'a> {\n     fn fill<'a>(&'a mut self) -> &'a [u8] { self.buf.slice_from(self.pos) }\n     fn consume(&mut self, amt: uint) { self.pos += amt; }\n }"}, {"sha": "393262aa1dd6c430e9aa4a43fe9b8cc00589323d", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -811,7 +811,7 @@ impl Reader for ~Reader {\n     fn eof(&mut self) -> bool { self.eof() }\n }\n \n-impl<'self> Reader for &'self mut Reader {\n+impl<'a> Reader for &'a mut Reader {\n     fn read(&mut self, buf: &mut [u8]) -> Option<uint> { self.read(buf) }\n     fn eof(&mut self) -> bool { self.eof() }\n }\n@@ -972,7 +972,7 @@ impl Writer for ~Writer {\n     fn flush(&mut self) { self.flush() }\n }\n \n-impl<'self> Writer for &'self mut Writer {\n+impl<'a> Writer for &'a mut Writer {\n     fn write(&mut self, buf: &[u8]) { self.write(buf) }\n     fn flush(&mut self) { self.flush() }\n }\n@@ -1184,11 +1184,11 @@ pub trait Acceptor<T> {\n /// The Some contains another Option representing whether the connection attempt was succesful.\n /// A successful connection will be wrapped in Some.\n /// A failed connection is represented as a None and raises a condition.\n-struct IncomingIterator<'self, A> {\n-    priv inc: &'self mut A,\n+struct IncomingIterator<'a, A> {\n+    priv inc: &'a mut A,\n }\n \n-impl<'self, T, A: Acceptor<T>> Iterator<Option<T>> for IncomingIterator<'self, A> {\n+impl<'a, T, A: Acceptor<T>> Iterator<Option<T>> for IncomingIterator<'a, A> {\n     fn next(&mut self) -> Option<Option<T>> {\n         Some(self.inc.accept())\n     }"}, {"sha": "b4d14b57efca1998b431f26279481179c29cfb6b", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -62,14 +62,14 @@ impl ToStr for SocketAddr {\n     }\n }\n \n-struct Parser<'self> {\n+struct Parser<'a> {\n     // parsing as ASCII, so can use byte array\n-    s: &'self [u8],\n+    s: &'a [u8],\n     pos: uint,\n }\n \n-impl<'self> Parser<'self> {\n-    fn new(s: &'self str) -> Parser<'self> {\n+impl<'a> Parser<'a> {\n+    fn new(s: &'a str) -> Parser<'a> {\n         Parser {\n             s: s.as_bytes(),\n             pos: 0,"}, {"sha": "001faa1ecaf7b668ae8f5956e2de843fea8732dd", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -33,20 +33,20 @@ pub struct Process {\n \n /// This configuration describes how a new process should be spawned. This is\n /// translated to libuv's own configuration\n-pub struct ProcessConfig<'self> {\n+pub struct ProcessConfig<'a> {\n     /// Path to the program to run\n-    program: &'self str,\n+    program: &'a str,\n \n     /// Arguments to pass to the program (doesn't include the program itself)\n-    args: &'self [~str],\n+    args: &'a [~str],\n \n     /// Optional environment to specify for the program. If this is None, then\n     /// it will inherit the current process's environment.\n-    env: Option<&'self [(~str, ~str)]>,\n+    env: Option<&'a [(~str, ~str)]>,\n \n     /// Optional working directory for the new process. If this is None, then\n     /// the current directory of the running process is inherited.\n-    cwd: Option<&'self str>,\n+    cwd: Option<&'a str>,\n \n     /// Any number of streams/file descriptors/pipes may be attached to this\n     /// process. This list enumerates the file descriptors and such for the\n@@ -58,7 +58,7 @@ pub struct ProcessConfig<'self> {\n     ///     0 - stdin\n     ///     1 - stdout\n     ///     2 - stderr\n-    io: &'self [StdioContainer]\n+    io: &'a [StdioContainer]\n }\n \n /// Describes what to do with a standard io stream for a child process."}, {"sha": "3a7f8ab862944f44ef1222c9a0b67d9c1c712ff9", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -691,7 +691,7 @@ pub trait MutableDoubleEndedIterator {\n     fn reverse_(&mut self);\n }\n \n-impl<'self, A, T: DoubleEndedIterator<&'self mut A>> MutableDoubleEndedIterator for T {\n+impl<'a, A, T: DoubleEndedIterator<&'a mut A>> MutableDoubleEndedIterator for T {\n     // FIXME: #5898: should be called `reverse`\n     /// Use an iterator to reverse a container in-place\n     fn reverse_(&mut self) {\n@@ -754,9 +754,9 @@ pub trait ExactSize<A> : DoubleEndedIterator<A> {\n // All adaptors that preserve the size of the wrapped iterator are fine\n // Adaptors that may overflow in `size_hint` are not, i.e. `Chain`.\n impl<A, T: ExactSize<A>> ExactSize<(uint, A)> for Enumerate<T> {}\n-impl<'self, A, T: ExactSize<A>> ExactSize<A> for Inspect<'self, A, T> {}\n+impl<'a, A, T: ExactSize<A>> ExactSize<A> for Inspect<'a, A, T> {}\n impl<A, T: ExactSize<A>> ExactSize<A> for Invert<T> {}\n-impl<'self, A, B, T: ExactSize<A>> ExactSize<B> for Map<'self, A, B, T> {}\n+impl<'a, A, B, T: ExactSize<A>> ExactSize<B> for Map<'a, A, B, T> {}\n impl<A, B, T: ExactSize<A>, U: ExactSize<B>> ExactSize<(A, B)> for Zip<T, U> {}\n \n /// An double-ended iterator with the direction inverted\n@@ -788,17 +788,17 @@ impl<A, T: DoubleEndedIterator<A> + RandomAccessIterator<A>> RandomAccessIterato\n }\n \n /// A mutable reference to an iterator\n-pub struct ByRef<'self, T> {\n-    priv iter: &'self mut T\n+pub struct ByRef<'a, T> {\n+    priv iter: &'a mut T\n }\n \n-impl<'self, A, T: Iterator<A>> Iterator<A> for ByRef<'self, T> {\n+impl<'a, A, T: Iterator<A>> Iterator<A> for ByRef<'a, T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> { self.iter.next() }\n     // FIXME: #9629 we cannot implement &self methods like size_hint on ByRef\n }\n \n-impl<'self, A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for ByRef<'self, T> {\n+impl<'a, A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for ByRef<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> { self.iter.next_back() }\n }\n@@ -1121,12 +1121,12 @@ RandomAccessIterator<(A, B)> for Zip<T, U> {\n }\n \n /// An iterator which maps the values of `iter` with `f`\n-pub struct Map<'self, A, B, T> {\n+pub struct Map<'a, A, B, T> {\n     priv iter: T,\n-    priv f: 'self |A| -> B\n+    priv f: 'a |A| -> B\n }\n \n-impl<'self, A, B, T> Map<'self, A, B, T> {\n+impl<'a, A, B, T> Map<'a, A, B, T> {\n     #[inline]\n     fn do_map(&self, elt: Option<A>) -> Option<B> {\n         match elt {\n@@ -1136,7 +1136,7 @@ impl<'self, A, B, T> Map<'self, A, B, T> {\n     }\n }\n \n-impl<'self, A, B, T: Iterator<A>> Iterator<B> for Map<'self, A, B, T> {\n+impl<'a, A, B, T: Iterator<A>> Iterator<B> for Map<'a, A, B, T> {\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n         let next = self.iter.next();\n@@ -1149,15 +1149,15 @@ impl<'self, A, B, T: Iterator<A>> Iterator<B> for Map<'self, A, B, T> {\n     }\n }\n \n-impl<'self, A, B, T: DoubleEndedIterator<A>> DoubleEndedIterator<B> for Map<'self, A, B, T> {\n+impl<'a, A, B, T: DoubleEndedIterator<A>> DoubleEndedIterator<B> for Map<'a, A, B, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<B> {\n         let next = self.iter.next_back();\n         self.do_map(next)\n     }\n }\n \n-impl<'self, A, B, T: RandomAccessIterator<A>> RandomAccessIterator<B> for Map<'self, A, B, T> {\n+impl<'a, A, B, T: RandomAccessIterator<A>> RandomAccessIterator<B> for Map<'a, A, B, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n         self.iter.indexable()\n@@ -1170,12 +1170,12 @@ impl<'self, A, B, T: RandomAccessIterator<A>> RandomAccessIterator<B> for Map<'s\n }\n \n /// An iterator which filters the elements of `iter` with `predicate`\n-pub struct Filter<'self, A, T> {\n+pub struct Filter<'a, A, T> {\n     priv iter: T,\n-    priv predicate: 'self |&A| -> bool\n+    priv predicate: 'a |&A| -> bool\n }\n \n-impl<'self, A, T: Iterator<A>> Iterator<A> for Filter<'self, A, T> {\n+impl<'a, A, T: Iterator<A>> Iterator<A> for Filter<'a, A, T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         for x in self.iter {\n@@ -1195,7 +1195,7 @@ impl<'self, A, T: Iterator<A>> Iterator<A> for Filter<'self, A, T> {\n     }\n }\n \n-impl<'self, A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Filter<'self, A, T> {\n+impl<'a, A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Filter<'a, A, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         loop {\n@@ -1214,12 +1214,12 @@ impl<'self, A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Filter<'sel\n }\n \n /// An iterator which uses `f` to both filter and map elements from `iter`\n-pub struct FilterMap<'self, A, B, T> {\n+pub struct FilterMap<'a, A, B, T> {\n     priv iter: T,\n-    priv f: 'self |A| -> Option<B>\n+    priv f: 'a |A| -> Option<B>\n }\n \n-impl<'self, A, B, T: Iterator<A>> Iterator<B> for FilterMap<'self, A, B, T> {\n+impl<'a, A, B, T: Iterator<A>> Iterator<B> for FilterMap<'a, A, B, T> {\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n         for x in self.iter {\n@@ -1238,8 +1238,8 @@ impl<'self, A, B, T: Iterator<A>> Iterator<B> for FilterMap<'self, A, B, T> {\n     }\n }\n \n-impl<'self, A, B, T: DoubleEndedIterator<A>> DoubleEndedIterator<B>\n-for FilterMap<'self, A, B, T> {\n+impl<'a, A, B, T: DoubleEndedIterator<A>> DoubleEndedIterator<B>\n+for FilterMap<'a, A, B, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<B> {\n         loop {\n@@ -1340,11 +1340,11 @@ impl<A, T: Iterator<A>> Iterator<A> for Peekable<A, T> {\n     }\n }\n \n-impl<'self, A, T: Iterator<A>> Peekable<A, T> {\n+impl<'a, A, T: Iterator<A>> Peekable<A, T> {\n     /// Return a reference to the next element of the iterator with out advancing it,\n     /// or None if the iterator is exhausted.\n     #[inline]\n-    pub fn peek(&'self mut self) -> Option<&'self A> {\n+    pub fn peek(&'a mut self) -> Option<&'a A> {\n         if self.peeked.is_none() {\n             self.peeked = self.iter.next();\n         }\n@@ -1356,13 +1356,13 @@ impl<'self, A, T: Iterator<A>> Peekable<A, T> {\n }\n \n /// An iterator which rejects elements while `predicate` is true\n-pub struct SkipWhile<'self, A, T> {\n+pub struct SkipWhile<'a, A, T> {\n     priv iter: T,\n     priv flag: bool,\n-    priv predicate: 'self |&A| -> bool\n+    priv predicate: 'a |&A| -> bool\n }\n \n-impl<'self, A, T: Iterator<A>> Iterator<A> for SkipWhile<'self, A, T> {\n+impl<'a, A, T: Iterator<A>> Iterator<A> for SkipWhile<'a, A, T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         let mut next = self.iter.next();\n@@ -1394,13 +1394,13 @@ impl<'self, A, T: Iterator<A>> Iterator<A> for SkipWhile<'self, A, T> {\n }\n \n /// An iterator which only accepts elements while `predicate` is true\n-pub struct TakeWhile<'self, A, T> {\n+pub struct TakeWhile<'a, A, T> {\n     priv iter: T,\n     priv flag: bool,\n-    priv predicate: 'self |&A| -> bool\n+    priv predicate: 'a |&A| -> bool\n }\n \n-impl<'self, A, T: Iterator<A>> Iterator<A> for TakeWhile<'self, A, T> {\n+impl<'a, A, T: Iterator<A>> Iterator<A> for TakeWhile<'a, A, T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         if self.flag {\n@@ -1542,15 +1542,15 @@ impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Take<T> {\n \n \n /// An iterator to maintain state while iterating another iterator\n-pub struct Scan<'self, A, B, T, St> {\n+pub struct Scan<'a, A, B, T, St> {\n     priv iter: T,\n-    priv f: 'self |&mut St, A| -> Option<B>,\n+    priv f: 'a |&mut St, A| -> Option<B>,\n \n     /// The current internal state to be passed to the closure next.\n     state: St\n }\n \n-impl<'self, A, B, T: Iterator<A>, St> Iterator<B> for Scan<'self, A, B, T, St> {\n+impl<'a, A, B, T: Iterator<A>, St> Iterator<B> for Scan<'a, A, B, T, St> {\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n         self.iter.next().and_then(|a| (self.f)(&mut self.state, a))\n@@ -1566,14 +1566,14 @@ impl<'self, A, B, T: Iterator<A>, St> Iterator<B> for Scan<'self, A, B, T, St> {\n /// An iterator that maps each element to an iterator,\n /// and yields the elements of the produced iterators\n ///\n-pub struct FlatMap<'self, A, T, U> {\n+pub struct FlatMap<'a, A, T, U> {\n     priv iter: T,\n-    priv f: 'self |A| -> U,\n+    priv f: 'a |A| -> U,\n     priv frontiter: Option<U>,\n     priv backiter: Option<U>,\n }\n \n-impl<'self, A, T: Iterator<A>, B, U: Iterator<B>> Iterator<B> for FlatMap<'self, A, T, U> {\n+impl<'a, A, T: Iterator<A>, B, U: Iterator<B>> Iterator<B> for FlatMap<'a, A, T, U> {\n     #[inline]\n     fn next(&mut self) -> Option<B> {\n         loop {\n@@ -1601,10 +1601,10 @@ impl<'self, A, T: Iterator<A>, B, U: Iterator<B>> Iterator<B> for FlatMap<'self,\n     }\n }\n \n-impl<'self,\n+impl<'a,\n      A, T: DoubleEndedIterator<A>,\n      B, U: DoubleEndedIterator<B>> DoubleEndedIterator<B>\n-     for FlatMap<'self, A, T, U> {\n+     for FlatMap<'a, A, T, U> {\n     #[inline]\n     fn next_back(&mut self) -> Option<B> {\n         loop {\n@@ -1697,12 +1697,12 @@ impl<T> Fuse<T> {\n \n /// An iterator that calls a function with a reference to each\n /// element before yielding it.\n-pub struct Inspect<'self, A, T> {\n+pub struct Inspect<'a, A, T> {\n     priv iter: T,\n-    priv f: 'self |&A|\n+    priv f: 'a |&A|\n }\n \n-impl<'self, A, T> Inspect<'self, A, T> {\n+impl<'a, A, T> Inspect<'a, A, T> {\n     #[inline]\n     fn do_inspect(&self, elt: Option<A>) -> Option<A> {\n         match elt {\n@@ -1714,7 +1714,7 @@ impl<'self, A, T> Inspect<'self, A, T> {\n     }\n }\n \n-impl<'self, A, T: Iterator<A>> Iterator<A> for Inspect<'self, A, T> {\n+impl<'a, A, T: Iterator<A>> Iterator<A> for Inspect<'a, A, T> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         let next = self.iter.next();\n@@ -1727,17 +1727,17 @@ impl<'self, A, T: Iterator<A>> Iterator<A> for Inspect<'self, A, T> {\n     }\n }\n \n-impl<'self, A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A>\n-for Inspect<'self, A, T> {\n+impl<'a, A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A>\n+for Inspect<'a, A, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<A> {\n         let next = self.iter.next_back();\n         self.do_inspect(next)\n     }\n }\n \n-impl<'self, A, T: RandomAccessIterator<A>> RandomAccessIterator<A>\n-for Inspect<'self, A, T> {\n+impl<'a, A, T: RandomAccessIterator<A>> RandomAccessIterator<A>\n+for Inspect<'a, A, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n         self.iter.indexable()\n@@ -1750,13 +1750,13 @@ for Inspect<'self, A, T> {\n }\n \n /// An iterator which just modifies the contained state throughout iteration.\n-pub struct Unfold<'self, A, St> {\n-    priv f: 'self |&mut St| -> Option<A>,\n+pub struct Unfold<'a, A, St> {\n+    priv f: 'a |&mut St| -> Option<A>,\n     /// Internal state that will be yielded on the next iteration\n     state: St\n }\n \n-impl<'self, A, St> Unfold<'self, A, St> {\n+impl<'a, A, St> Unfold<'a, A, St> {\n     /// Creates a new iterator with the specified closure as the \"iterator\n     /// function\" and an initial state to eventually pass to the iterator\n     #[inline]\n@@ -1769,7 +1769,7 @@ impl<'self, A, St> Unfold<'self, A, St> {\n     }\n }\n \n-impl<'self, A, St> Iterator<A> for Unfold<'self, A, St> {\n+impl<'a, A, St> Iterator<A> for Unfold<'a, A, St> {\n     #[inline]\n     fn next(&mut self) -> Option<A> {\n         (self.f)(&mut self.state)"}, {"sha": "53948dc83099f85ea14f23f72d29d0f22c7b9dea", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -523,18 +523,18 @@ pub trait GenericPathUnsafe {\n }\n \n /// Helper struct for printing paths with format!()\n-pub struct Display<'self, P> {\n-    priv path: &'self P,\n+pub struct Display<'a, P> {\n+    priv path: &'a P,\n     priv filename: bool\n }\n \n-impl<'self, P: GenericPath> fmt::Default for Display<'self, P> {\n+impl<'a, P: GenericPath> fmt::Default for Display<'a, P> {\n     fn fmt(d: &Display<P>, f: &mut fmt::Formatter) {\n         d.with_str(|s| f.pad(s))\n     }\n }\n \n-impl<'self, P: GenericPath> ToStr for Display<'self, P> {\n+impl<'a, P: GenericPath> ToStr for Display<'a, P> {\n     /// Returns the path as a string\n     ///\n     /// If the path is not UTF-8, invalid sequences with be replaced with the\n@@ -551,7 +551,7 @@ impl<'self, P: GenericPath> ToStr for Display<'self, P> {\n     }\n }\n \n-impl<'self, P: GenericPath> Display<'self, P> {\n+impl<'a, P: GenericPath> Display<'a, P> {\n     /// Provides the path as a string to a closure\n     ///\n     /// If the path is not UTF-8, invalid sequences will be replaced with the\n@@ -570,7 +570,7 @@ impl<'self, P: GenericPath> Display<'self, P> {\n     }\n }\n \n-impl<'self> BytesContainer for &'self str {\n+impl<'a> BytesContainer for &'a str {\n     #[inline]\n     fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n         self.as_bytes()\n@@ -584,7 +584,7 @@ impl<'self> BytesContainer for &'self str {\n         Some(*self)\n     }\n     #[inline]\n-    fn is_str(_: Option<&'self str>) -> bool { true }\n+    fn is_str(_: Option<&'a str>) -> bool { true }\n }\n \n impl BytesContainer for ~str {\n@@ -625,7 +625,7 @@ impl BytesContainer for @str {\n     fn is_str(_: Option<@str>) -> bool { true }\n }\n \n-impl<'self> BytesContainer for &'self [u8] {\n+impl<'a> BytesContainer for &'a [u8] {\n     #[inline]\n     fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n         *self"}, {"sha": "3f2535765dd4a04e83282fc9513110111dd65286", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -25,16 +25,16 @@ use vec::{CopyableVector, RSplitIterator, SplitIterator, Vector, VectorVector};\n use super::{BytesContainer, GenericPath, GenericPathUnsafe};\n \n /// Iterator that yields successive components of a Path as &[u8]\n-pub type ComponentIter<'self> = SplitIterator<'self, u8>;\n+pub type ComponentIter<'a> = SplitIterator<'a, u8>;\n /// Iterator that yields components of a Path in reverse as &[u8]\n-pub type RevComponentIter<'self> = RSplitIterator<'self, u8>;\n+pub type RevComponentIter<'a> = RSplitIterator<'a, u8>;\n \n /// Iterator that yields successive components of a Path as Option<&str>\n-pub type StrComponentIter<'self> = Map<'self, &'self [u8], Option<&'self str>,\n-                                       ComponentIter<'self>>;\n+pub type StrComponentIter<'a> = Map<'a, &'a [u8], Option<&'a str>,\n+                                       ComponentIter<'a>>;\n /// Iterator that yields components of a Path in reverse as Option<&str>\n-pub type RevStrComponentIter<'self> = Map<'self, &'self [u8], Option<&'self str>,\n-                                          RevComponentIter<'self>>;\n+pub type RevStrComponentIter<'a> = Map<'a, &'a [u8], Option<&'a str>,\n+                                          RevComponentIter<'a>>;\n \n /// Represents a POSIX file path\n #[deriving(Clone, DeepClone)]\n@@ -103,7 +103,7 @@ impl BytesContainer for Path {\n     }\n }\n \n-impl<'self> BytesContainer for &'self Path {\n+impl<'a> BytesContainer for &'a Path {\n     #[inline]\n     fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n         self.as_vec()"}, {"sha": "114f675cdba91ff0f38152beb05d4ce1d401ec6b", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -27,21 +27,21 @@ use super::{contains_nul, BytesContainer, GenericPath, GenericPathUnsafe};\n ///\n /// Each component is yielded as Option<&str> for compatibility with PosixPath, but\n /// every component in WindowsPath is guaranteed to be Some.\n-pub type StrComponentIter<'self> = Map<'self, &'self str, Option<&'self str>,\n-                                       CharSplitIterator<'self, char>>;\n+pub type StrComponentIter<'a> = Map<'a, &'a str, Option<&'a str>,\n+                                       CharSplitIterator<'a, char>>;\n /// Iterator that yields components of a Path in reverse as &str\n ///\n /// Each component is yielded as Option<&str> for compatibility with PosixPath, but\n /// every component in WindowsPath is guaranteed to be Some.\n-pub type RevStrComponentIter<'self> = Invert<Map<'self, &'self str, Option<&'self str>,\n-                                                 CharSplitIterator<'self, char>>>;\n+pub type RevStrComponentIter<'a> = Invert<Map<'a, &'a str, Option<&'a str>,\n+                                                 CharSplitIterator<'a, char>>>;\n \n /// Iterator that yields successive components of a Path as &[u8]\n-pub type ComponentIter<'self> = Map<'self, Option<&'self str>, &'self [u8],\n-                                    StrComponentIter<'self>>;\n+pub type ComponentIter<'a> = Map<'a, Option<&'a str>, &'a [u8],\n+                                    StrComponentIter<'a>>;\n /// Iterator that yields components of a Path in reverse as &[u8]\n-pub type RevComponentIter<'self> = Map<'self, Option<&'self str>, &'self [u8],\n-                                       RevStrComponentIter<'self>>;\n+pub type RevComponentIter<'a> = Map<'a, Option<&'a str>, &'a [u8],\n+                                       RevStrComponentIter<'a>>;\n \n /// Represents a Windows path\n // Notes for Windows path impl:\n@@ -138,7 +138,7 @@ impl BytesContainer for Path {\n     fn is_str(_: Option<Path>) -> bool { true }\n }\n \n-impl<'self> BytesContainer for &'self Path {\n+impl<'a> BytesContainer for &'a Path {\n     #[inline]\n     fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n         self.as_vec()\n@@ -152,7 +152,7 @@ impl<'self> BytesContainer for &'self Path {\n         self.as_str()\n     }\n     #[inline]\n-    fn is_str(_: Option<&'self Path>) -> bool { true }\n+    fn is_str(_: Option<&'a Path>) -> bool { true }\n }\n \n impl GenericPathUnsafe for Path {"}, {"sha": "3dcf97212f5eb5d4c35429a06f592b961be439cf", "filename": "src/libstd/rand/isaac.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Frand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Frand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fisaac.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -188,8 +188,8 @@ impl Rng for IsaacRng {\n     }\n }\n \n-impl<'self> SeedableRng<&'self [u32]> for IsaacRng {\n-    fn reseed(&mut self, seed: &'self [u32]) {\n+impl<'a> SeedableRng<&'a [u32]> for IsaacRng {\n+    fn reseed(&mut self, seed: &'a [u32]) {\n         // make the seed into [seed[0], seed[1], ..., seed[seed.len()\n         // - 1], 0, 0, ...], to fill rng.rsl.\n         let seed_iter = seed.iter().map(|&x| x).chain(Repeat::new(0u32));\n@@ -210,7 +210,7 @@ impl<'self> SeedableRng<&'self [u32]> for IsaacRng {\n     /// 256 and any more will be silently ignored. A generator\n     /// constructed with a given seed will generate the same sequence\n     /// of values as all other generators constructed with that seed.\n-    fn from_seed(seed: &'self [u32]) -> IsaacRng {\n+    fn from_seed(seed: &'a [u32]) -> IsaacRng {\n         let mut rng = EMPTY;\n         rng.reseed(seed);\n         rng\n@@ -399,8 +399,8 @@ impl Rng for Isaac64Rng {\n     }\n }\n \n-impl<'self> SeedableRng<&'self [u64]> for Isaac64Rng {\n-    fn reseed(&mut self, seed: &'self [u64]) {\n+impl<'a> SeedableRng<&'a [u64]> for Isaac64Rng {\n+    fn reseed(&mut self, seed: &'a [u64]) {\n         // make the seed into [seed[0], seed[1], ..., seed[seed.len()\n         // - 1], 0, 0, ...], to fill rng.rsl.\n         let seed_iter = seed.iter().map(|&x| x).chain(Repeat::new(0u64));\n@@ -421,7 +421,7 @@ impl<'self> SeedableRng<&'self [u64]> for Isaac64Rng {\n     /// 256 and any more will be silently ignored. A generator\n     /// constructed with a given seed will generate the same sequence\n     /// of values as all other generators constructed with that seed.\n-    fn from_seed(seed: &'self [u64]) -> Isaac64Rng {\n+    fn from_seed(seed: &'a [u64]) -> Isaac64Rng {\n         let mut rng = EMPTY_64;\n         rng.reseed(seed);\n         rng"}, {"sha": "32c2402f39baf930b4d52fa7e499cb0b28896b0f", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -469,14 +469,14 @@ impl Rng for StdRng {\n     }\n }\n \n-impl<'self> SeedableRng<&'self [uint]> for StdRng {\n-    fn reseed(&mut self, seed: &'self [uint]) {\n+impl<'a> SeedableRng<&'a [uint]> for StdRng {\n+    fn reseed(&mut self, seed: &'a [uint]) {\n         // the internal RNG can just be seeded from the above\n         // randomness.\n         self.rng.reseed(unsafe {cast::transmute(seed)})\n     }\n \n-    fn from_seed(seed: &'self [uint]) -> StdRng {\n+    fn from_seed(seed: &'a [uint]) -> StdRng {\n         StdRng { rng: SeedableRng::from_seed(unsafe {cast::transmute(seed)}) }\n     }\n }"}, {"sha": "2f9478716a37b1509ed4dcaf911712b2f9133772", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -97,11 +97,11 @@ enum VariantState {\n     AlreadyFound\n }\n \n-pub struct ReprVisitor<'self> {\n+pub struct ReprVisitor<'a> {\n     priv ptr: *c_void,\n     priv ptr_stk: ~[*c_void],\n     priv var_stk: ~[VariantState],\n-    priv writer: &'self mut io::Writer\n+    priv writer: &'a mut io::Writer\n }\n \n pub fn ReprVisitor<'a>(ptr: *c_void,\n@@ -114,7 +114,7 @@ pub fn ReprVisitor<'a>(ptr: *c_void,\n     }\n }\n \n-impl<'self> MovePtr for ReprVisitor<'self> {\n+impl<'a> MovePtr for ReprVisitor<'a> {\n     #[inline]\n     fn move_ptr(&mut self, adjustment: |*c_void| -> *c_void) {\n         self.ptr = adjustment(self.ptr);\n@@ -127,7 +127,7 @@ impl<'self> MovePtr for ReprVisitor<'self> {\n     }\n }\n \n-impl<'self> ReprVisitor<'self> {\n+impl<'a> ReprVisitor<'a> {\n     // Various helpers for the TyVisitor impl\n \n     #[inline]\n@@ -242,7 +242,7 @@ impl<'self> ReprVisitor<'self> {\n     }\n }\n \n-impl<'self> TyVisitor for ReprVisitor<'self> {\n+impl<'a> TyVisitor for ReprVisitor<'a> {\n     fn visit_bot(&mut self) -> bool {\n         self.writer.write(\"!\".as_bytes());\n         true"}, {"sha": "2fa349942928e15d3da5eddaa0ce954ce118ee91", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -510,7 +510,7 @@ impl<T: Send> Peekable<T> for Port<T> {\n // of them, but a &Port<T> should also be selectable so you can select2 on it\n // alongside a PortOne<U> without passing the port by value in recv_ready.\n \n-impl<'self, T: Send> SelectInner for &'self Port<T> {\n+impl<'a, T: Send> SelectInner for &'a Port<T> {\n     #[inline]\n     fn optimistic_check(&mut self) -> bool {\n         self.next.with_mut(|pone| { pone.get_mut_ref().optimistic_check() })\n@@ -528,7 +528,7 @@ impl<'self, T: Send> SelectInner for &'self Port<T> {\n     }\n }\n \n-impl<'self, T: Send> Select for &'self Port<T> { }\n+impl<'a, T: Send> Select for &'a Port<T> { }\n \n impl<T: Send> SelectInner for Port<T> {\n     #[inline]\n@@ -549,7 +549,7 @@ impl<T: Send> SelectInner for Port<T> {\n \n impl<T: Send> Select for Port<T> { }\n \n-impl<'self, T: Send> SelectPortInner<T> for &'self Port<T> {\n+impl<'a, T: Send> SelectPortInner<T> for &'a Port<T> {\n     fn recv_ready(self) -> Option<T> {\n         let mut b = self.next.borrow_mut();\n         match b.get().take_unwrap().recv_ready() {\n@@ -562,7 +562,7 @@ impl<'self, T: Send> SelectPortInner<T> for &'self Port<T> {\n     }\n }\n \n-impl<'self, T: Send> SelectPort<T> for &'self Port<T> { }\n+impl<'a, T: Send> SelectPort<T> for &'a Port<T> { }\n \n pub struct SharedChan<T> {\n     // Just like Chan, but a shared AtomicOption"}, {"sha": "22fc3f0ab56c0a082da889eb4a1b7089d5f8401b", "filename": "src/libstd/rt/crate_map.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Frt%2Fcrate_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Frt%2Fcrate_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcrate_map.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -21,15 +21,15 @@ use rt::rtio::EventLoop;\n #[link_args = \"-Wl,-U,__rust_crate_map_toplevel\"]\n extern {}\n \n-pub struct ModEntry<'self> {\n-    name: &'self str,\n+pub struct ModEntry<'a> {\n+    name: &'a str,\n     log_level: *mut u32\n }\n \n-pub struct CrateMap<'self> {\n+pub struct CrateMap<'a> {\n     version: i32,\n-    entries: &'self [ModEntry<'self>],\n-    children: &'self [&'self CrateMap<'self>],\n+    entries: &'a [ModEntry<'a>],\n+    children: &'a [&'a CrateMap<'a>],\n     event_loop_factory: Option<extern \"C\" fn() -> ~EventLoop>,\n }\n "}, {"sha": "754c02e308f1b221f8adc83f737bbbbfd5ff3623", "filename": "src/libstd/run.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -33,7 +33,7 @@ pub struct Process {\n }\n \n /// Options that can be given when starting a Process.\n-pub struct ProcessOptions<'self> {\n+pub struct ProcessOptions<'a> {\n     /**\n      * If this is None then the new process will have the same initial\n      * environment as the parent process.\n@@ -50,7 +50,7 @@ pub struct ProcessOptions<'self> {\n      * If this is Some(path) then the new process will use the given path\n      * for its initial working directory.\n      */\n-    dir: Option<&'self Path>,\n+    dir: Option<&'a Path>,\n \n     /**\n      * If this is None then a new pipe will be created for the new process's\n@@ -83,7 +83,7 @@ pub struct ProcessOptions<'self> {\n     err_fd: Option<c_int>,\n }\n \n-impl <'self> ProcessOptions<'self> {\n+impl <'a> ProcessOptions<'a> {\n     /// Return a ProcessOptions that has None in every field.\n     pub fn new<'a>() -> ProcessOptions<'a> {\n         ProcessOptions {"}, {"sha": "cca64244db569f814ba9b95218047e251ee6947d", "filename": "src/libstd/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fselect.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -108,7 +108,7 @@ pub fn select<A: Select>(ports: &mut [A]) -> uint {\n \n /* FIXME(#5121, #7914) This all should be legal, but rust is not clever enough yet.\n \n-impl <'self> Select for &'self mut Select {\n+impl <'a> Select for &'a mut Select {\n     fn optimistic_check(&mut self) -> bool { self.optimistic_check() }\n     fn block_on(&mut self, sched: &mut Scheduler, task: BlockedTask) -> bool {\n         self.block_on(sched, task)"}, {"sha": "b0bc4c3f4679391a5f834a203a701bb117da81a9", "filename": "src/libstd/send_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fsend_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fsend_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsend_str.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -107,7 +107,7 @@ impl TotalOrd for SendStr {\n     }\n }\n \n-impl<'self, S: Str> Equiv<S> for SendStr {\n+impl<'a, S: Str> Equiv<S> for SendStr {\n     #[inline]\n     fn equiv(&self, other: &S) -> bool {\n         self.as_slice().equals(&other.as_slice())"}, {"sha": "af381ef3cf0074be9b630a97da1a45d4be9448c8", "filename": "src/libstd/str.rs", "status": "modified", "additions": 130, "deletions": 130, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -182,7 +182,7 @@ impl FromStr for ~str {\n     fn from_str(s: &str) -> Option<~str> { Some(s.to_owned()) }\n }\n \n-impl<'self> ToStr for &'self str {\n+impl<'a> ToStr for &'a str {\n     #[inline]\n     fn to_str(&self) -> ~str { self.to_owned() }\n }\n@@ -192,7 +192,7 @@ impl ToStr for @str {\n     fn to_str(&self) -> ~str { self.to_owned() }\n }\n \n-impl<'self> FromStr for @str {\n+impl<'a> FromStr for @str {\n     #[inline]\n     fn from_str(s: &str) -> Option<@str> { Some(s.to_managed()) }\n }\n@@ -238,7 +238,7 @@ pub trait StrVector {\n     fn connect(&self, sep: &str) -> ~str;\n }\n \n-impl<'self, S: Str> StrVector for &'self [S] {\n+impl<'a, S: Str> StrVector for &'a [S] {\n     fn concat(&self) -> ~str {\n         if self.is_empty() { return ~\"\"; }\n \n@@ -294,7 +294,7 @@ impl CharEq for char {\n     fn only_ascii(&self) -> bool { (*self as uint) < 128 }\n }\n \n-impl<'self> CharEq for 'self |char| -> bool {\n+impl<'a> CharEq for 'a |char| -> bool {\n     #[inline]\n     fn matches(&self, c: char) -> bool { (*self)(c) }\n \n@@ -308,7 +308,7 @@ impl CharEq for extern \"Rust\" fn(char) -> bool {\n     fn only_ascii(&self) -> bool { false }\n }\n \n-impl<'self, C: CharEq> CharEq for &'self [C] {\n+impl<'a, C: CharEq> CharEq for &'a [C] {\n     #[inline]\n     fn matches(&self, c: char) -> bool {\n         self.iter().any(|m| m.matches(c))\n@@ -326,12 +326,12 @@ Section: Iterators\n /// External iterator for a string's characters.\n /// Use with the `std::iter` module.\n #[deriving(Clone)]\n-pub struct CharIterator<'self> {\n+pub struct CharIterator<'a> {\n     /// The slice remaining to be iterated\n-    priv string: &'self str,\n+    priv string: &'a str,\n }\n \n-impl<'self> Iterator<char> for CharIterator<'self> {\n+impl<'a> Iterator<char> for CharIterator<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<char> {\n         // Decode the next codepoint, then update\n@@ -353,7 +353,7 @@ impl<'self> Iterator<char> for CharIterator<'self> {\n     }\n }\n \n-impl<'self> DoubleEndedIterator<char> for CharIterator<'self> {\n+impl<'a> DoubleEndedIterator<char> for CharIterator<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<char> {\n         if self.string.len() != 0 {\n@@ -371,13 +371,13 @@ impl<'self> DoubleEndedIterator<char> for CharIterator<'self> {\n /// External iterator for a string's characters and their byte offsets.\n /// Use with the `std::iter` module.\n #[deriving(Clone)]\n-pub struct CharOffsetIterator<'self> {\n+pub struct CharOffsetIterator<'a> {\n     /// The original string to be iterated\n-    priv string: &'self str,\n-    priv iter: CharIterator<'self>,\n+    priv string: &'a str,\n+    priv iter: CharIterator<'a>,\n }\n \n-impl<'self> Iterator<(uint, char)> for CharOffsetIterator<'self> {\n+impl<'a> Iterator<(uint, char)> for CharOffsetIterator<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<(uint, char)> {\n         // Compute the byte offset by using the pointer offset between\n@@ -396,7 +396,7 @@ impl<'self> Iterator<(uint, char)> for CharOffsetIterator<'self> {\n     }\n }\n \n-impl<'self> DoubleEndedIterator<(uint, char)> for CharOffsetIterator<'self> {\n+impl<'a> DoubleEndedIterator<(uint, char)> for CharOffsetIterator<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<(uint, char)> {\n         self.iter.next_back().map(|ch| {\n@@ -412,26 +412,26 @@ impl<'self> DoubleEndedIterator<(uint, char)> for CharOffsetIterator<'self> {\n \n /// External iterator for a string's characters in reverse order.\n /// Use with the `std::iter` module.\n-pub type CharRevIterator<'self> = Invert<CharIterator<'self>>;\n+pub type CharRevIterator<'a> = Invert<CharIterator<'a>>;\n \n /// External iterator for a string's characters and their byte offsets in reverse order.\n /// Use with the `std::iter` module.\n-pub type CharOffsetRevIterator<'self> = Invert<CharOffsetIterator<'self>>;\n+pub type CharOffsetRevIterator<'a> = Invert<CharOffsetIterator<'a>>;\n \n /// External iterator for a string's bytes.\n /// Use with the `std::iter` module.\n-pub type ByteIterator<'self> =\n-    Map<'self, &'self u8, u8, vec::VecIterator<'self, u8>>;\n+pub type ByteIterator<'a> =\n+    Map<'a, &'a u8, u8, vec::VecIterator<'a, u8>>;\n \n /// External iterator for a string's bytes in reverse order.\n /// Use with the `std::iter` module.\n-pub type ByteRevIterator<'self> = Invert<ByteIterator<'self>>;\n+pub type ByteRevIterator<'a> = Invert<ByteIterator<'a>>;\n \n /// An iterator over the substrings of a string, separated by `sep`.\n #[deriving(Clone)]\n-pub struct CharSplitIterator<'self, Sep> {\n+pub struct CharSplitIterator<'a, Sep> {\n     /// The slice remaining to be iterated\n-    priv string: &'self str,\n+    priv string: &'a str,\n     priv sep: Sep,\n     /// Whether an empty string at the end is allowed\n     priv allow_trailing_empty: bool,\n@@ -441,29 +441,29 @@ pub struct CharSplitIterator<'self, Sep> {\n \n /// An iterator over the substrings of a string, separated by `sep`,\n /// starting from the back of the string.\n-pub type CharRSplitIterator<'self, Sep> = Invert<CharSplitIterator<'self, Sep>>;\n+pub type CharRSplitIterator<'a, Sep> = Invert<CharSplitIterator<'a, Sep>>;\n \n /// An iterator over the substrings of a string, separated by `sep`,\n /// splitting at most `count` times.\n #[deriving(Clone)]\n-pub struct CharSplitNIterator<'self, Sep> {\n-    priv iter: CharSplitIterator<'self, Sep>,\n+pub struct CharSplitNIterator<'a, Sep> {\n+    priv iter: CharSplitIterator<'a, Sep>,\n     /// The number of splits remaining\n     priv count: uint,\n     priv invert: bool,\n }\n \n /// An iterator over the words of a string, separated by an sequence of whitespace\n-pub type WordIterator<'self> =\n-    Filter<'self, &'self str, CharSplitIterator<'self, extern \"Rust\" fn(char) -> bool>>;\n+pub type WordIterator<'a> =\n+    Filter<'a, &'a str, CharSplitIterator<'a, extern \"Rust\" fn(char) -> bool>>;\n \n /// An iterator over the lines of a string, separated by either `\\n` or (`\\r\\n`).\n-pub type AnyLineIterator<'self> =\n-    Map<'self, &'self str, &'self str, CharSplitIterator<'self, char>>;\n+pub type AnyLineIterator<'a> =\n+    Map<'a, &'a str, &'a str, CharSplitIterator<'a, char>>;\n \n-impl<'self, Sep> CharSplitIterator<'self, Sep> {\n+impl<'a, Sep> CharSplitIterator<'a, Sep> {\n     #[inline]\n-    fn get_end(&mut self) -> Option<&'self str> {\n+    fn get_end(&mut self) -> Option<&'a str> {\n         if !self.finished && (self.allow_trailing_empty || self.string.len() > 0) {\n             self.finished = true;\n             Some(self.string)\n@@ -473,9 +473,9 @@ impl<'self, Sep> CharSplitIterator<'self, Sep> {\n     }\n }\n \n-impl<'self, Sep: CharEq> Iterator<&'self str> for CharSplitIterator<'self, Sep> {\n+impl<'a, Sep: CharEq> Iterator<&'a str> for CharSplitIterator<'a, Sep> {\n     #[inline]\n-    fn next(&mut self) -> Option<&'self str> {\n+    fn next(&mut self) -> Option<&'a str> {\n         if self.finished { return None }\n \n         let mut next_split = None;\n@@ -505,10 +505,10 @@ impl<'self, Sep: CharEq> Iterator<&'self str> for CharSplitIterator<'self, Sep>\n     }\n }\n \n-impl<'self, Sep: CharEq> DoubleEndedIterator<&'self str>\n-for CharSplitIterator<'self, Sep> {\n+impl<'a, Sep: CharEq> DoubleEndedIterator<&'a str>\n+for CharSplitIterator<'a, Sep> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<&'self str> {\n+    fn next_back(&mut self) -> Option<&'a str> {\n         if self.finished { return None }\n \n         if !self.allow_trailing_empty {\n@@ -547,9 +547,9 @@ for CharSplitIterator<'self, Sep> {\n     }\n }\n \n-impl<'self, Sep: CharEq> Iterator<&'self str> for CharSplitNIterator<'self, Sep> {\n+impl<'a, Sep: CharEq> Iterator<&'a str> for CharSplitNIterator<'a, Sep> {\n     #[inline]\n-    fn next(&mut self) -> Option<&'self str> {\n+    fn next(&mut self) -> Option<&'a str> {\n         if self.count != 0 {\n             self.count -= 1;\n             if self.invert { self.iter.next_back() } else { self.iter.next() }\n@@ -562,22 +562,22 @@ impl<'self, Sep: CharEq> Iterator<&'self str> for CharSplitNIterator<'self, Sep>\n /// An iterator over the start and end indices of the matches of a\n /// substring within a larger string\n #[deriving(Clone)]\n-pub struct MatchesIndexIterator<'self> {\n-    priv haystack: &'self str,\n-    priv needle: &'self str,\n+pub struct MatchesIndexIterator<'a> {\n+    priv haystack: &'a str,\n+    priv needle: &'a str,\n     priv position: uint,\n }\n \n /// An iterator over the substrings of a string separated by a given\n /// search string\n #[deriving(Clone)]\n-pub struct StrSplitIterator<'self> {\n-    priv it: MatchesIndexIterator<'self>,\n+pub struct StrSplitIterator<'a> {\n+    priv it: MatchesIndexIterator<'a>,\n     priv last_end: uint,\n     priv finished: bool\n }\n \n-impl<'self> Iterator<(uint, uint)> for MatchesIndexIterator<'self> {\n+impl<'a> Iterator<(uint, uint)> for MatchesIndexIterator<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<(uint, uint)> {\n         // See Issue #1932 for why this is a naive search\n@@ -608,9 +608,9 @@ impl<'self> Iterator<(uint, uint)> for MatchesIndexIterator<'self> {\n     }\n }\n \n-impl<'self> Iterator<&'self str> for StrSplitIterator<'self> {\n+impl<'a> Iterator<&'a str> for StrSplitIterator<'a> {\n     #[inline]\n-    fn next(&mut self) -> Option<&'self str> {\n+    fn next(&mut self) -> Option<&'a str> {\n         if self.finished { return None; }\n \n         match self.it.next() {\n@@ -656,14 +656,14 @@ enum NormalizationForm {\n /// External iterator for a string's normalization's characters.\n /// Use with the `std::iter` module.\n #[deriving(Clone)]\n-struct NormalizationIterator<'self> {\n+struct NormalizationIterator<'a> {\n     priv kind: NormalizationForm,\n-    priv iter: CharIterator<'self>,\n+    priv iter: CharIterator<'a>,\n     priv buffer: ~[(char, u8)],\n     priv sorted: bool\n }\n \n-impl<'self> Iterator<char> for NormalizationIterator<'self> {\n+impl<'a> Iterator<char> for NormalizationIterator<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<char> {\n         use unicode::decompose::canonical_combining_class;\n@@ -1168,18 +1168,18 @@ pub mod traits {\n     use super::{Str, eq_slice};\n     use option::{Some, None};\n \n-    impl<'self> Add<&'self str,~str> for &'self str {\n+    impl<'a> Add<&'a str,~str> for &'a str {\n         #[inline]\n-        fn add(&self, rhs: & &'self str) -> ~str {\n+        fn add(&self, rhs: & &'a str) -> ~str {\n             let mut ret = self.to_owned();\n             ret.push_str(*rhs);\n             ret\n         }\n     }\n \n-    impl<'self> TotalOrd for &'self str {\n+    impl<'a> TotalOrd for &'a str {\n         #[inline]\n-        fn cmp(&self, other: & &'self str) -> Ordering {\n+        fn cmp(&self, other: & &'a str) -> Ordering {\n             for (s_b, o_b) in self.bytes().zip(other.bytes()) {\n                 match s_b.cmp(&o_b) {\n                     Greater => return Greater,\n@@ -1202,13 +1202,13 @@ pub mod traits {\n         fn cmp(&self, other: &@str) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n     }\n \n-    impl<'self> Eq for &'self str {\n+    impl<'a> Eq for &'a str {\n         #[inline]\n-        fn eq(&self, other: & &'self str) -> bool {\n+        fn eq(&self, other: & &'a str) -> bool {\n             eq_slice((*self), (*other))\n         }\n         #[inline]\n-        fn ne(&self, other: & &'self str) -> bool { !(*self).eq(other) }\n+        fn ne(&self, other: & &'a str) -> bool { !(*self).eq(other) }\n     }\n \n     impl Eq for ~str {\n@@ -1225,9 +1225,9 @@ pub mod traits {\n         }\n     }\n \n-    impl<'self> TotalEq for &'self str {\n+    impl<'a> TotalEq for &'a str {\n         #[inline]\n-        fn equals(&self, other: & &'self str) -> bool {\n+        fn equals(&self, other: & &'a str) -> bool {\n             eq_slice((*self), (*other))\n         }\n     }\n@@ -1246,9 +1246,9 @@ pub mod traits {\n         }\n     }\n \n-    impl<'self> Ord for &'self str {\n+    impl<'a> Ord for &'a str {\n         #[inline]\n-        fn lt(&self, other: & &'self str) -> bool { self.cmp(other) == Less }\n+        fn lt(&self, other: & &'a str) -> bool { self.cmp(other) == Less }\n     }\n \n     impl Ord for ~str {\n@@ -1261,17 +1261,17 @@ pub mod traits {\n         fn lt(&self, other: &@str) -> bool { self.cmp(other) == Less }\n     }\n \n-    impl<'self, S: Str> Equiv<S> for &'self str {\n+    impl<'a, S: Str> Equiv<S> for &'a str {\n         #[inline]\n         fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n     }\n \n-    impl<'self, S: Str> Equiv<S> for @str {\n+    impl<'a, S: Str> Equiv<S> for @str {\n         #[inline]\n         fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n     }\n \n-    impl<'self, S: Str> Equiv<S> for ~str {\n+    impl<'a, S: Str> Equiv<S> for ~str {\n         #[inline]\n         fn equiv(&self, other: &S) -> bool { eq_slice(*self, other.as_slice()) }\n     }\n@@ -1289,15 +1289,15 @@ pub trait Str {\n     fn into_owned(self) -> ~str;\n }\n \n-impl<'self> Str for &'self str {\n+impl<'a> Str for &'a str {\n     #[inline]\n     fn as_slice<'a>(&'a self) -> &'a str { *self }\n \n     #[inline]\n     fn into_owned(self) -> ~str { self.to_owned() }\n }\n \n-impl<'self> Str for ~str {\n+impl<'a> Str for ~str {\n     #[inline]\n     fn as_slice<'a>(&'a self) -> &'a str {\n         let s: &'a str = *self; s\n@@ -1307,7 +1307,7 @@ impl<'self> Str for ~str {\n     fn into_owned(self) -> ~str { self }\n }\n \n-impl<'self> Str for @str {\n+impl<'a> Str for @str {\n     #[inline]\n     fn as_slice<'a>(&'a self) -> &'a str {\n         let s: &'a str = *self; s\n@@ -1317,7 +1317,7 @@ impl<'self> Str for @str {\n     fn into_owned(self) -> ~str { self.to_owned() }\n }\n \n-impl<'self> Container for &'self str {\n+impl<'a> Container for &'a str {\n     #[inline]\n     fn len(&self) -> uint {\n         self.as_imm_buf(|_p, n| n)\n@@ -1345,7 +1345,7 @@ impl Mutable for ~str {\n }\n \n /// Methods for string slices\n-pub trait StrSlice<'self> {\n+pub trait StrSlice<'a> {\n     /// Returns true if one string contains another\n     ///\n     /// # Arguments\n@@ -1369,23 +1369,23 @@ pub trait StrSlice<'self> {\n     /// let v: ~[char] = \"abc \u00e5\u00e4\u00f6\".chars().collect();\n     /// assert_eq!(v, ~['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n     /// ```\n-    fn chars(&self) -> CharIterator<'self>;\n+    fn chars(&self) -> CharIterator<'a>;\n \n     /// An iterator over the characters of `self`, in reverse order.\n-    fn chars_rev(&self) -> CharRevIterator<'self>;\n+    fn chars_rev(&self) -> CharRevIterator<'a>;\n \n     /// An iterator over the bytes of `self`\n-    fn bytes(&self) -> ByteIterator<'self>;\n+    fn bytes(&self) -> ByteIterator<'a>;\n \n     /// An iterator over the bytes of `self`, in reverse order\n-    fn bytes_rev(&self) -> ByteRevIterator<'self>;\n+    fn bytes_rev(&self) -> ByteRevIterator<'a>;\n \n     /// An iterator over the characters of `self` and their byte offsets.\n-    fn char_indices(&self) -> CharOffsetIterator<'self>;\n+    fn char_indices(&self) -> CharOffsetIterator<'a>;\n \n     /// An iterator over the characters of `self` and their byte offsets,\n     /// in reverse order.\n-    fn char_indices_rev(&self) -> CharOffsetRevIterator<'self>;\n+    fn char_indices_rev(&self) -> CharOffsetRevIterator<'a>;\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`.\n@@ -1402,7 +1402,7 @@ pub trait StrSlice<'self> {\n     /// let v: ~[&str] = \"lionXXtigerXleopard\".split('X').collect();\n     /// assert_eq!(v, ~[\"lion\", \"\", \"tiger\", \"leopard\"]);\n     /// ```\n-    fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'self, Sep>;\n+    fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'a, Sep>;\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`, restricted to splitting at most `count`\n@@ -1420,7 +1420,7 @@ pub trait StrSlice<'self> {\n     /// let v: ~[&str] = \"lionXXtigerXleopard\".splitn('X', 2).collect();\n     /// assert_eq!(v, ~[\"lion\", \"\", \"tigerXleopard\"]);\n     /// ```\n-    fn splitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitNIterator<'self, Sep>;\n+    fn splitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitNIterator<'a, Sep>;\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`.\n@@ -1437,7 +1437,7 @@ pub trait StrSlice<'self> {\n     /// let v: ~[&str] = \"A..B..\".split_terminator('.').collect();\n     /// assert_eq!(v, ~[\"A\", \"\", \"B\", \"\"]);\n     /// ```\n-    fn split_terminator<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'self, Sep>;\n+    fn split_terminator<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'a, Sep>;\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`, in reverse order.\n@@ -1454,7 +1454,7 @@ pub trait StrSlice<'self> {\n     /// let v: ~[&str] = \"lionXXtigerXleopard\".rsplit('X').collect();\n     /// assert_eq!(v, ~[\"leopard\", \"tiger\", \"\", \"lion\"]);\n     /// ```\n-    fn rsplit<Sep: CharEq>(&self, sep: Sep) -> CharRSplitIterator<'self, Sep>;\n+    fn rsplit<Sep: CharEq>(&self, sep: Sep) -> CharRSplitIterator<'a, Sep>;\n \n     /// An iterator over substrings of `self`, separated by characters\n     /// matched by `sep`, starting from the end of the string.\n@@ -1472,7 +1472,7 @@ pub trait StrSlice<'self> {\n     /// let v: ~[&str] = \"lionXXtigerXleopard\".rsplitn('X', 2).collect();\n     /// assert_eq!(v, ~[\"leopard\", \"tiger\", \"lionX\"]);\n     /// ```\n-    fn rsplitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitNIterator<'self, Sep>;\n+    fn rsplitn<Sep: CharEq>(&self, sep: Sep, count: uint) -> CharSplitNIterator<'a, Sep>;\n \n     /// An iterator over the start and end indices of the disjoint\n     /// matches of `sep` within `self`.\n@@ -1494,7 +1494,7 @@ pub trait StrSlice<'self> {\n     /// let v: ~[(uint, uint)] = \"ababa\".split_str(\"aba\").collect();\n     /// assert_eq!(v, ~[(0, 3)]); // only the first `aba`\n     /// ```\n-    fn match_indices(&self, sep: &'self str) -> MatchesIndexIterator<'self>;\n+    fn match_indices(&self, sep: &'a str) -> MatchesIndexIterator<'a>;\n \n     /// An iterator over the substrings of `self` separated by `sep`.\n     ///\n@@ -1507,7 +1507,7 @@ pub trait StrSlice<'self> {\n     /// let v: ~[&str] = \"1abcabc2\".split_str(\"abc\").collect();\n     /// assert_eq!(v, ~[\"1\", \"\", \"2\"]);\n     /// ```\n-    fn split_str(&self, &'self str) -> StrSplitIterator<'self>;\n+    fn split_str(&self, &'a str) -> StrSplitIterator<'a>;\n \n     /// An iterator over the lines of a string (subsequences separated\n     /// by `\\n`). This does not include the empty string after a\n@@ -1520,7 +1520,7 @@ pub trait StrSlice<'self> {\n     /// let v: ~[&str] = four_lines.lines().collect();\n     /// assert_eq!(v, ~[\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n-    fn lines(&self) -> CharSplitIterator<'self, char>;\n+    fn lines(&self) -> CharSplitIterator<'a, char>;\n \n     /// An iterator over the lines of a string, separated by either\n     /// `\\n` or `\\r\\n`. As with `.lines()`, this does not include an\n@@ -1533,7 +1533,7 @@ pub trait StrSlice<'self> {\n     /// let v: ~[&str] = four_lines.lines_any().collect();\n     /// assert_eq!(v, ~[\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n-    fn lines_any(&self) -> AnyLineIterator<'self>;\n+    fn lines_any(&self) -> AnyLineIterator<'a>;\n \n     /// An iterator over the words of a string (subsequences separated\n     /// by any sequence of whitespace). Sequences of whitespace are\n@@ -1546,15 +1546,15 @@ pub trait StrSlice<'self> {\n     /// let v: ~[&str] = some_words.words().collect();\n     /// assert_eq!(v, ~[\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     /// ```\n-    fn words(&self) -> WordIterator<'self>;\n+    fn words(&self) -> WordIterator<'a>;\n \n     /// An Iterator over the string in Unicode Normalization Form D\n     /// (canonical decomposition).\n-    fn nfd_chars(&self) -> NormalizationIterator<'self>;\n+    fn nfd_chars(&self) -> NormalizationIterator<'a>;\n \n     /// An Iterator over the string in Unicode Normalization Form KD\n     /// (compatibility decomposition).\n-    fn nfkd_chars(&self) -> NormalizationIterator<'self>;\n+    fn nfkd_chars(&self) -> NormalizationIterator<'a>;\n \n     /// Returns true if the string contains only whitespace.\n     ///\n@@ -1647,7 +1647,7 @@ pub trait StrSlice<'self> {\n     /// // byte 100 is outside the string\n     /// // s.slice(3, 100);\n     /// ```\n-    fn slice(&self, begin: uint, end: uint) -> &'self str;\n+    fn slice(&self, begin: uint, end: uint) -> &'a str;\n \n     /// Returns a slice of the string from `begin` to its end.\n     ///\n@@ -1657,7 +1657,7 @@ pub trait StrSlice<'self> {\n     /// out of bounds.\n     ///\n     /// See also `slice`, `slice_to` and `slice_chars`.\n-    fn slice_from(&self, begin: uint) -> &'self str;\n+    fn slice_from(&self, begin: uint) -> &'a str;\n \n     /// Returns a slice of the string from the beginning to byte\n     /// `end`.\n@@ -1668,7 +1668,7 @@ pub trait StrSlice<'self> {\n     /// out of bounds.\n     ///\n     /// See also `slice`, `slice_from` and `slice_chars`.\n-    fn slice_to(&self, end: uint) -> &'self str;\n+    fn slice_to(&self, end: uint) -> &'a str;\n \n     /// Returns a slice of the string from the character range\n     /// [`begin`..`end`).\n@@ -1693,7 +1693,7 @@ pub trait StrSlice<'self> {\n     /// assert_eq!(s.slice_chars(0, 4), \"L\u00f6we\");\n     /// assert_eq!(s.slice_chars(6, 8), \"\u8001\u864e\");\n     /// ```\n-    fn slice_chars(&self, begin: uint, end: uint) -> &'self str;\n+    fn slice_chars(&self, begin: uint, end: uint) -> &'a str;\n \n     /// Returns true if `needle` is a prefix of the string.\n     fn starts_with(&self, needle: &str) -> bool;\n@@ -1708,13 +1708,13 @@ pub trait StrSlice<'self> {\n     fn escape_unicode(&self) -> ~str;\n \n     /// Returns a string with leading and trailing whitespace removed.\n-    fn trim(&self) -> &'self str;\n+    fn trim(&self) -> &'a str;\n \n     /// Returns a string with leading whitespace removed.\n-    fn trim_left(&self) -> &'self str;\n+    fn trim_left(&self) -> &'a str;\n \n     /// Returns a string with trailing whitespace removed.\n-    fn trim_right(&self) -> &'self str;\n+    fn trim_right(&self) -> &'a str;\n \n     /// Returns a string with characters that match `to_trim` removed.\n     ///\n@@ -1729,7 +1729,7 @@ pub trait StrSlice<'self> {\n     /// assert_eq!(\"12foo1bar12\".trim_chars(& &['1', '2']), \"foo1bar\")\n     /// assert_eq!(\"123foo1bar123\".trim_chars(&|c: char| c.is_digit()), \"foo1bar\")\n     /// ```\n-    fn trim_chars<C: CharEq>(&self, to_trim: &C) -> &'self str;\n+    fn trim_chars<C: CharEq>(&self, to_trim: &C) -> &'a str;\n \n     /// Returns a string with leading `chars_to_trim` removed.\n     ///\n@@ -1744,7 +1744,7 @@ pub trait StrSlice<'self> {\n     /// assert_eq!(\"12foo1bar12\".trim_left_chars(& &['1', '2']), \"foo1bar12\")\n     /// assert_eq!(\"123foo1bar123\".trim_left_chars(&|c: char| c.is_digit()), \"foo1bar123\")\n     /// ```\n-    fn trim_left_chars<C: CharEq>(&self, to_trim: &C) -> &'self str;\n+    fn trim_left_chars<C: CharEq>(&self, to_trim: &C) -> &'a str;\n \n     /// Returns a string with trailing `chars_to_trim` removed.\n     ///\n@@ -1759,7 +1759,7 @@ pub trait StrSlice<'self> {\n     /// assert_eq!(\"12foo1bar12\".trim_right_chars(& &['1', '2']), \"12foo1bar\")\n     /// assert_eq!(\"123foo1bar123\".trim_right_chars(&|c: char| c.is_digit()), \"123foo1bar\")\n     /// ```\n-    fn trim_right_chars<C: CharEq>(&self, to_trim: &C) -> &'self str;\n+    fn trim_right_chars<C: CharEq>(&self, to_trim: &C) -> &'a str;\n \n     /// Replace all occurrences of one string with another.\n     ///\n@@ -1891,7 +1891,7 @@ pub trait StrSlice<'self> {\n     fn char_at_reverse(&self, i: uint) -> char;\n \n     /// Work with the byte buffer of a string as a byte slice.\n-    fn as_bytes(&self) -> &'self [u8];\n+    fn as_bytes(&self) -> &'a [u8];\n \n     /// Returns the byte index of the first character of `self` that\n     /// matches `search`.\n@@ -1986,7 +1986,7 @@ pub trait StrSlice<'self> {\n     /// assert_eq!(c, '\u00f6');\n     /// assert_eq!(s2, \"we \u8001\u864e L\u00e9opard\");\n     /// ```\n-    fn slice_shift_char(&self) -> (char, &'self str);\n+    fn slice_shift_char(&self) -> (char, &'a str);\n \n     /// Levenshtein Distance between two strings.\n     fn lev_distance(&self, t: &str) -> uint;\n@@ -2013,7 +2013,7 @@ pub trait StrSlice<'self> {\n     fn as_imm_buf<T>(&self, f: |*u8, uint| -> T) -> T;\n }\n \n-impl<'self> StrSlice<'self> for &'self str {\n+impl<'a> StrSlice<'a> for &'a str {\n     #[inline]\n     fn contains<'a>(&self, needle: &'a str) -> bool {\n         self.find_str(needle).is_some()\n@@ -2025,37 +2025,37 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n \n     #[inline]\n-    fn chars(&self) -> CharIterator<'self> {\n+    fn chars(&self) -> CharIterator<'a> {\n         CharIterator{string: *self}\n     }\n \n     #[inline]\n-    fn chars_rev(&self) -> CharRevIterator<'self> {\n+    fn chars_rev(&self) -> CharRevIterator<'a> {\n         self.chars().invert()\n     }\n \n     #[inline]\n-    fn bytes(&self) -> ByteIterator<'self> {\n+    fn bytes(&self) -> ByteIterator<'a> {\n         self.as_bytes().iter().map(|&b| b)\n     }\n \n     #[inline]\n-    fn bytes_rev(&self) -> ByteRevIterator<'self> {\n+    fn bytes_rev(&self) -> ByteRevIterator<'a> {\n         self.bytes().invert()\n     }\n \n     #[inline]\n-    fn char_indices(&self) -> CharOffsetIterator<'self> {\n+    fn char_indices(&self) -> CharOffsetIterator<'a> {\n         CharOffsetIterator{string: *self, iter: self.chars()}\n     }\n \n     #[inline]\n-    fn char_indices_rev(&self) -> CharOffsetRevIterator<'self> {\n+    fn char_indices_rev(&self) -> CharOffsetRevIterator<'a> {\n         self.char_indices().invert()\n     }\n \n     #[inline]\n-    fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'self, Sep> {\n+    fn split<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'a, Sep> {\n         CharSplitIterator {\n             string: *self,\n             only_ascii: sep.only_ascii(),\n@@ -2067,7 +2067,7 @@ impl<'self> StrSlice<'self> for &'self str {\n \n     #[inline]\n     fn splitn<Sep: CharEq>(&self, sep: Sep, count: uint)\n-        -> CharSplitNIterator<'self, Sep> {\n+        -> CharSplitNIterator<'a, Sep> {\n         CharSplitNIterator {\n             iter: self.split(sep),\n             count: count,\n@@ -2077,21 +2077,21 @@ impl<'self> StrSlice<'self> for &'self str {\n \n     #[inline]\n     fn split_terminator<Sep: CharEq>(&self, sep: Sep)\n-        -> CharSplitIterator<'self, Sep> {\n+        -> CharSplitIterator<'a, Sep> {\n         CharSplitIterator {\n             allow_trailing_empty: false,\n             ..self.split(sep)\n         }\n     }\n \n     #[inline]\n-    fn rsplit<Sep: CharEq>(&self, sep: Sep) -> CharRSplitIterator<'self, Sep> {\n+    fn rsplit<Sep: CharEq>(&self, sep: Sep) -> CharRSplitIterator<'a, Sep> {\n         self.split(sep).invert()\n     }\n \n     #[inline]\n     fn rsplitn<Sep: CharEq>(&self, sep: Sep, count: uint)\n-        -> CharSplitNIterator<'self, Sep> {\n+        -> CharSplitNIterator<'a, Sep> {\n         CharSplitNIterator {\n             iter: self.split(sep),\n             count: count,\n@@ -2100,7 +2100,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n \n     #[inline]\n-    fn match_indices(&self, sep: &'self str) -> MatchesIndexIterator<'self> {\n+    fn match_indices(&self, sep: &'a str) -> MatchesIndexIterator<'a> {\n         assert!(!sep.is_empty())\n         MatchesIndexIterator {\n             haystack: *self,\n@@ -2110,7 +2110,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n \n     #[inline]\n-    fn split_str(&self, sep: &'self str) -> StrSplitIterator<'self> {\n+    fn split_str(&self, sep: &'a str) -> StrSplitIterator<'a> {\n         StrSplitIterator {\n             it: self.match_indices(sep),\n             last_end: 0,\n@@ -2119,11 +2119,11 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n \n     #[inline]\n-    fn lines(&self) -> CharSplitIterator<'self, char> {\n+    fn lines(&self) -> CharSplitIterator<'a, char> {\n         self.split_terminator('\\n')\n     }\n \n-    fn lines_any(&self) -> AnyLineIterator<'self> {\n+    fn lines_any(&self) -> AnyLineIterator<'a> {\n         self.lines().map(|line| {\n             let l = line.len();\n             if l > 0 && line[l - 1] == '\\r' as u8 { line.slice(0, l - 1) }\n@@ -2132,12 +2132,12 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n \n     #[inline]\n-    fn words(&self) -> WordIterator<'self> {\n+    fn words(&self) -> WordIterator<'a> {\n         self.split(char::is_whitespace).filter(|s| !s.is_empty())\n     }\n \n     #[inline]\n-    fn nfd_chars(&self) -> NormalizationIterator<'self> {\n+    fn nfd_chars(&self) -> NormalizationIterator<'a> {\n         NormalizationIterator {\n             iter: self.chars(),\n             buffer: ~[],\n@@ -2147,7 +2147,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n \n     #[inline]\n-    fn nfkd_chars(&self) -> NormalizationIterator<'self> {\n+    fn nfkd_chars(&self) -> NormalizationIterator<'a> {\n         NormalizationIterator {\n             iter: self.chars(),\n             buffer: ~[],\n@@ -2166,23 +2166,23 @@ impl<'self> StrSlice<'self> for &'self str {\n     fn char_len(&self) -> uint { self.chars().len() }\n \n     #[inline]\n-    fn slice(&self, begin: uint, end: uint) -> &'self str {\n+    fn slice(&self, begin: uint, end: uint) -> &'a str {\n         assert!(self.is_char_boundary(begin) && self.is_char_boundary(end));\n         unsafe { raw::slice_bytes(*self, begin, end) }\n     }\n \n     #[inline]\n-    fn slice_from(&self, begin: uint) -> &'self str {\n+    fn slice_from(&self, begin: uint) -> &'a str {\n         self.slice(begin, self.len())\n     }\n \n     #[inline]\n-    fn slice_to(&self, end: uint) -> &'self str {\n+    fn slice_to(&self, end: uint) -> &'a str {\n         assert!(self.is_char_boundary(end));\n         unsafe { raw::slice_bytes(*self, 0, end) }\n     }\n \n-    fn slice_chars(&self, begin: uint, end: uint) -> &'self str {\n+    fn slice_chars(&self, begin: uint, end: uint) -> &'a str {\n         assert!(begin <= end);\n         let mut count = 0;\n         let mut begin_byte = None;\n@@ -2236,35 +2236,35 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n \n     #[inline]\n-    fn trim(&self) -> &'self str {\n+    fn trim(&self) -> &'a str {\n         self.trim_left().trim_right()\n     }\n \n     #[inline]\n-    fn trim_left(&self) -> &'self str {\n+    fn trim_left(&self) -> &'a str {\n         self.trim_left_chars(&char::is_whitespace)\n     }\n \n     #[inline]\n-    fn trim_right(&self) -> &'self str {\n+    fn trim_right(&self) -> &'a str {\n         self.trim_right_chars(&char::is_whitespace)\n     }\n \n     #[inline]\n-    fn trim_chars<C: CharEq>(&self, to_trim: &C) -> &'self str {\n+    fn trim_chars<C: CharEq>(&self, to_trim: &C) -> &'a str {\n         self.trim_left_chars(to_trim).trim_right_chars(to_trim)\n     }\n \n     #[inline]\n-    fn trim_left_chars<C: CharEq>(&self, to_trim: &C) -> &'self str {\n+    fn trim_left_chars<C: CharEq>(&self, to_trim: &C) -> &'a str {\n         match self.find(|c: char| !to_trim.matches(c)) {\n             None => \"\",\n             Some(first) => unsafe { raw::slice_bytes(*self, first, self.len()) }\n         }\n     }\n \n     #[inline]\n-    fn trim_right_chars<C: CharEq>(&self, to_trim: &C) -> &'self str {\n+    fn trim_right_chars<C: CharEq>(&self, to_trim: &C) -> &'a str {\n         match self.rfind(|c: char| !to_trim.matches(c)) {\n             None => \"\",\n             Some(last) => {\n@@ -2408,7 +2408,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n \n     #[inline]\n-    fn as_bytes(&self) -> &'self [u8] {\n+    fn as_bytes(&self) -> &'a [u8] {\n         unsafe { cast::transmute(*self) }\n     }\n \n@@ -2453,7 +2453,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n \n     #[inline]\n-    fn slice_shift_char(&self) -> (char, &'self str) {\n+    fn slice_shift_char(&self) -> (char, &'a str) {\n         let CharRange {ch, next} = self.char_range_at(0u);\n         let next_s = unsafe { raw::slice_bytes(*self, next, self.len()) };\n         return (ch, next_s);\n@@ -2756,8 +2756,8 @@ impl Extendable<char> for ~str {\n }\n \n // This works because every lifetime is a sub-lifetime of 'static\n-impl<'self> Default for &'self str {\n-    fn default() -> &'self str { \"\" }\n+impl<'a> Default for &'a str {\n+    fn default() -> &'a str { \"\" }\n }\n \n impl Default for ~str {"}, {"sha": "815320be94e6a4178aa72e874b6a2ce85d5c152a", "filename": "src/libstd/to_bytes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_bytes.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -22,7 +22,7 @@ use rc::Rc;\n use str::{Str, StrSlice};\n use vec::{Vector, ImmutableVector};\n \n-pub type Cb<'self> = 'self |buf: &[u8]| -> bool;\n+pub type Cb<'a> = 'a |buf: &[u8]| -> bool;\n \n ///\n /// A trait to implement in order to make a type hashable;\n@@ -219,7 +219,7 @@ impl IterBytes for f64 {\n     }\n }\n \n-impl<'self,A:IterBytes> IterBytes for &'self [A] {\n+impl<'a,A:IterBytes> IterBytes for &'a [A] {\n     #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         self.len().iter_bytes(lsb0, |b| f(b)) &&\n@@ -273,7 +273,7 @@ impl<A:IterBytes> IterBytes for @[A] {\n     }\n }\n \n-impl<'self> IterBytes for &'self str {\n+impl<'a> IterBytes for &'a str {\n     #[inline]\n     fn iter_bytes(&self, _lsb0: bool, f: Cb) -> bool {\n         // Terminate the string with a byte that does not appear in UTF-8\n@@ -305,7 +305,7 @@ impl<A:IterBytes> IterBytes for Option<A> {\n     }\n }\n \n-impl<'self,A:IterBytes> IterBytes for &'self A {\n+impl<'a,A:IterBytes> IterBytes for &'a A {\n     #[inline]\n     fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n         (**self).iter_bytes(lsb0, f)"}, {"sha": "41c8aef18f47c2b79244a312224174e580ca2988", "filename": "src/libstd/to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_str.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -121,7 +121,7 @@ impl<A:ToStr,B:ToStr,C:ToStr> ToStr for (A, B, C) {\n     }\n }\n \n-impl<'self,A:ToStr> ToStr for &'self [A] {\n+impl<'a,A:ToStr> ToStr for &'a [A] {\n     #[inline]\n     fn to_str(&self) -> ~str {\n         let mut acc = ~\"[\";"}, {"sha": "09dd091d0e71667fb2dbdad0fdac59e007f24d93", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -443,14 +443,14 @@ fn remove<T>(count: &mut uint, child: &mut Child<T>, key: uint,\n }\n \n /// Forward iterator over a map\n-pub struct TrieMapIterator<'self, T> {\n-    priv stack: ~[vec::VecIterator<'self, Child<T>>],\n+pub struct TrieMapIterator<'a, T> {\n+    priv stack: ~[vec::VecIterator<'a, Child<T>>],\n     priv remaining_min: uint,\n     priv remaining_max: uint\n }\n \n-impl<'self, T> Iterator<(uint, &'self T)> for TrieMapIterator<'self, T> {\n-    fn next(&mut self) -> Option<(uint, &'self T)> {\n+impl<'a, T> Iterator<(uint, &'a T)> for TrieMapIterator<'a, T> {\n+    fn next(&mut self) -> Option<(uint, &'a T)> {\n         while !self.stack.is_empty() {\n             match self.stack[self.stack.len() - 1].next() {\n                 None => {\n@@ -483,11 +483,11 @@ impl<'self, T> Iterator<(uint, &'self T)> for TrieMapIterator<'self, T> {\n }\n \n /// Forward iterator over a set\n-pub struct TrieSetIterator<'self> {\n-    priv iter: TrieMapIterator<'self, ()>\n+pub struct TrieSetIterator<'a> {\n+    priv iter: TrieMapIterator<'a, ()>\n }\n \n-impl<'self> Iterator<uint> for TrieSetIterator<'self> {\n+impl<'a> Iterator<uint> for TrieSetIterator<'a> {\n     fn next(&mut self) -> Option<uint> {\n         self.iter.next().map(|(key, _)| key)\n     }"}, {"sha": "03b25fbd0442bbf902341aa0ca089e782f707e55", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -62,7 +62,7 @@ impl DynamicLibrary {\n \n     /// Access the value at the symbol of the dynamic library\n     pub unsafe fn symbol<T>(&self, symbol: &str) -> Result<T, ~str> {\n-        // This function should have a lifetime constraint of 'self on\n+        // This function should have a lifetime constraint of 'a on\n         // T but that feature is still unimplemented\n \n         let maybe_symbol_value = dl::check_for_errors_in(|| {"}, {"sha": "6f92da5e93e895d12ce5ff52451f5780cf8f29b3", "filename": "src/libstd/unstable/finally.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Funstable%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Funstable%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Ffinally.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -44,7 +44,7 @@ macro_rules! finally_fn {\n     }\n }\n \n-impl<'self,T> Finally<T> for 'self || -> T {\n+impl<'a,T> Finally<T> for 'a || -> T {\n     fn finally(&self, dtor: ||) -> T {\n         let _d = Finallyalizer {\n             dtor: dtor\n@@ -56,12 +56,12 @@ impl<'self,T> Finally<T> for 'self || -> T {\n \n finally_fn!(extern \"Rust\" fn() -> T)\n \n-struct Finallyalizer<'self> {\n-    dtor: 'self ||\n+struct Finallyalizer<'a> {\n+    dtor: 'a ||\n }\n \n #[unsafe_destructor]\n-impl<'self> Drop for Finallyalizer<'self> {\n+impl<'a> Drop for Finallyalizer<'a> {\n     fn drop(&mut self) {\n         (self.dtor)();\n     }"}, {"sha": "64a9a7c672a90fddcbbb3a8aeacba8c9af02cf5d", "filename": "src/libstd/unstable/raw.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Funstable%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Funstable%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fraw.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -53,8 +53,8 @@ pub trait Repr<T> {\n     fn repr(&self) -> T { unsafe { cast::transmute_copy(self) } }\n }\n \n-impl<'self, T> Repr<Slice<T>> for &'self [T] {}\n-impl<'self> Repr<Slice<u8>> for &'self str {}\n+impl<'a, T> Repr<Slice<T>> for &'a [T] {}\n+impl<'a> Repr<Slice<u8>> for &'a str {}\n impl<T> Repr<*Box<T>> for @T {}\n impl<T> Repr<*Box<Vec<T>>> for @[T] {}\n impl Repr<*String> for ~str {}"}, {"sha": "78ed58ba35633d45c2f116a4d2e671019ee188e7", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 145, "deletions": 145, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -219,16 +219,16 @@ pub fn build<A>(size: Option<uint>, builder: |push: |v: A||) -> ~[A] {\n \n /// An iterator over the slices of a vector separated by elements that\n /// match a predicate function.\n-pub struct SplitIterator<'self, T> {\n-    priv v: &'self [T],\n+pub struct SplitIterator<'a, T> {\n+    priv v: &'a [T],\n     priv n: uint,\n-    priv pred: 'self |t: &T| -> bool,\n+    priv pred: 'a |t: &T| -> bool,\n     priv finished: bool\n }\n \n-impl<'self, T> Iterator<&'self [T]> for SplitIterator<'self, T> {\n+impl<'a, T> Iterator<&'a [T]> for SplitIterator<'a, T> {\n     #[inline]\n-    fn next(&mut self) -> Option<&'self [T]> {\n+    fn next(&mut self) -> Option<&'a [T]> {\n         if self.finished { return None; }\n \n         if self.n == 0 {\n@@ -268,16 +268,16 @@ impl<'self, T> Iterator<&'self [T]> for SplitIterator<'self, T> {\n \n /// An iterator over the slices of a vector separated by elements that\n /// match a predicate function, from back to front.\n-pub struct RSplitIterator<'self, T> {\n-    priv v: &'self [T],\n+pub struct RSplitIterator<'a, T> {\n+    priv v: &'a [T],\n     priv n: uint,\n-    priv pred: 'self |t: &T| -> bool,\n+    priv pred: 'a |t: &T| -> bool,\n     priv finished: bool\n }\n \n-impl<'self, T> Iterator<&'self [T]> for RSplitIterator<'self, T> {\n+impl<'a, T> Iterator<&'a [T]> for RSplitIterator<'a, T> {\n     #[inline]\n-    fn next(&mut self) -> Option<&'self [T]> {\n+    fn next(&mut self) -> Option<&'a [T]> {\n         if self.finished { return None; }\n \n         if self.n == 0 {\n@@ -355,7 +355,7 @@ pub trait VectorVector<T> {\n     fn connect_vec(&self, sep: &T) -> ~[T];\n }\n \n-impl<'self, T: Clone, V: Vector<T>> VectorVector<T> for &'self [V] {\n+impl<'a, T: Clone, V: Vector<T>> VectorVector<T> for &'a [V] {\n     fn concat_vec(&self) -> ~[T] {\n         let size = self.iter().fold(0u, |acc, v| acc + v.as_slice().len());\n         let mut result = with_capacity(size);\n@@ -503,14 +503,14 @@ impl<T: Clone> Iterator<~[T]> for Permutations<T> {\n /// An iterator over the (overlapping) slices of length `size` within\n /// a vector.\n #[deriving(Clone)]\n-pub struct WindowIter<'self, T> {\n-    priv v: &'self [T],\n+pub struct WindowIter<'a, T> {\n+    priv v: &'a [T],\n     priv size: uint\n }\n \n-impl<'self, T> Iterator<&'self [T]> for WindowIter<'self, T> {\n+impl<'a, T> Iterator<&'a [T]> for WindowIter<'a, T> {\n     #[inline]\n-    fn next(&mut self) -> Option<&'self [T]> {\n+    fn next(&mut self) -> Option<&'a [T]> {\n         if self.size > self.v.len() {\n             None\n         } else {\n@@ -537,14 +537,14 @@ impl<'self, T> Iterator<&'self [T]> for WindowIter<'self, T> {\n /// When the vector len is not evenly divided by the chunk size,\n /// the last slice of the iteration will be the remainder.\n #[deriving(Clone)]\n-pub struct ChunkIter<'self, T> {\n-    priv v: &'self [T],\n+pub struct ChunkIter<'a, T> {\n+    priv v: &'a [T],\n     priv size: uint\n }\n \n-impl<'self, T> Iterator<&'self [T]> for ChunkIter<'self, T> {\n+impl<'a, T> Iterator<&'a [T]> for ChunkIter<'a, T> {\n     #[inline]\n-    fn next(&mut self) -> Option<&'self [T]> {\n+    fn next(&mut self) -> Option<&'a [T]> {\n         if self.v.len() == 0 {\n             None\n         } else {\n@@ -568,9 +568,9 @@ impl<'self, T> Iterator<&'self [T]> for ChunkIter<'self, T> {\n     }\n }\n \n-impl<'self, T> DoubleEndedIterator<&'self [T]> for ChunkIter<'self, T> {\n+impl<'a, T> DoubleEndedIterator<&'a [T]> for ChunkIter<'a, T> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<&'self [T]> {\n+    fn next_back(&mut self) -> Option<&'a [T]> {\n         if self.v.len() == 0 {\n             None\n         } else {\n@@ -584,14 +584,14 @@ impl<'self, T> DoubleEndedIterator<&'self [T]> for ChunkIter<'self, T> {\n     }\n }\n \n-impl<'self, T> RandomAccessIterator<&'self [T]> for ChunkIter<'self, T> {\n+impl<'a, T> RandomAccessIterator<&'a [T]> for ChunkIter<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n         self.v.len()/self.size + if self.v.len() % self.size != 0 { 1 } else { 0 }\n     }\n \n     #[inline]\n-    fn idx(&self, index: uint) -> Option<&'self [T]> {\n+    fn idx(&self, index: uint) -> Option<&'a [T]> {\n         if index < self.indexable() {\n             let lo = index * self.size;\n             let mut hi = lo + self.size;\n@@ -616,12 +616,12 @@ pub mod traits {\n     use iter::order;\n     use ops::Add;\n \n-    impl<'self,T:Eq> Eq for &'self [T] {\n-        fn eq(&self, other: & &'self [T]) -> bool {\n+    impl<'a,T:Eq> Eq for &'a [T] {\n+        fn eq(&self, other: & &'a [T]) -> bool {\n             self.len() == other.len() &&\n                 order::eq(self.iter(), other.iter())\n         }\n-        fn ne(&self, other: & &'self [T]) -> bool {\n+        fn ne(&self, other: & &'a [T]) -> bool {\n             self.len() != other.len() ||\n                 order::ne(self.iter(), other.iter())\n         }\n@@ -641,8 +641,8 @@ pub mod traits {\n         fn ne(&self, other: &@[T]) -> bool { !self.eq(other) }\n     }\n \n-    impl<'self,T:TotalEq> TotalEq for &'self [T] {\n-        fn equals(&self, other: & &'self [T]) -> bool {\n+    impl<'a,T:TotalEq> TotalEq for &'a [T] {\n+        fn equals(&self, other: & &'a [T]) -> bool {\n             self.len() == other.len() &&\n                 order::equals(self.iter(), other.iter())\n         }\n@@ -658,23 +658,23 @@ pub mod traits {\n         fn equals(&self, other: &@[T]) -> bool { self.as_slice().equals(&other.as_slice()) }\n     }\n \n-    impl<'self,T:Eq, V: Vector<T>> Equiv<V> for &'self [T] {\n+    impl<'a,T:Eq, V: Vector<T>> Equiv<V> for &'a [T] {\n         #[inline]\n         fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n     }\n \n-    impl<'self,T:Eq, V: Vector<T>> Equiv<V> for ~[T] {\n+    impl<'a,T:Eq, V: Vector<T>> Equiv<V> for ~[T] {\n         #[inline]\n         fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n     }\n \n-    impl<'self,T:Eq, V: Vector<T>> Equiv<V> for @[T] {\n+    impl<'a,T:Eq, V: Vector<T>> Equiv<V> for @[T] {\n         #[inline]\n         fn equiv(&self, other: &V) -> bool { self.as_slice() == other.as_slice() }\n     }\n \n-    impl<'self,T:TotalOrd> TotalOrd for &'self [T] {\n-        fn cmp(&self, other: & &'self [T]) -> Ordering {\n+    impl<'a,T:TotalOrd> TotalOrd for &'a [T] {\n+        fn cmp(&self, other: & &'a [T]) -> Ordering {\n             order::cmp(self.iter(), other.iter())\n         }\n     }\n@@ -689,20 +689,20 @@ pub mod traits {\n         fn cmp(&self, other: &@[T]) -> Ordering { self.as_slice().cmp(&other.as_slice()) }\n     }\n \n-    impl<'self, T: Eq + Ord> Ord for &'self [T] {\n-        fn lt(&self, other: & &'self [T]) -> bool {\n+    impl<'a, T: Eq + Ord> Ord for &'a [T] {\n+        fn lt(&self, other: & &'a [T]) -> bool {\n             order::lt(self.iter(), other.iter())\n         }\n         #[inline]\n-        fn le(&self, other: & &'self [T]) -> bool {\n+        fn le(&self, other: & &'a [T]) -> bool {\n             order::le(self.iter(), other.iter())\n         }\n         #[inline]\n-        fn ge(&self, other: & &'self [T]) -> bool {\n+        fn ge(&self, other: & &'a [T]) -> bool {\n             order::ge(self.iter(), other.iter())\n         }\n         #[inline]\n-        fn gt(&self, other: & &'self [T]) -> bool {\n+        fn gt(&self, other: & &'a [T]) -> bool {\n             order::gt(self.iter(), other.iter())\n         }\n     }\n@@ -729,7 +729,7 @@ pub mod traits {\n         fn gt(&self, other: &@[T]) -> bool { self.as_slice() > other.as_slice() }\n     }\n \n-    impl<'self,T:Clone, V: Vector<T>> Add<V, ~[T]> for &'self [T] {\n+    impl<'a,T:Clone, V: Vector<T>> Add<V, ~[T]> for &'a [T] {\n         #[inline]\n         fn add(&self, rhs: &V) -> ~[T] {\n             let mut res = with_capacity(self.len() + rhs.as_slice().len());\n@@ -756,7 +756,7 @@ pub trait Vector<T> {\n     fn as_slice<'a>(&'a self) -> &'a [T];\n }\n \n-impl<'self,T> Vector<T> for &'self [T] {\n+impl<'a,T> Vector<T> for &'a [T] {\n     #[inline(always)]\n     fn as_slice<'a>(&'a self) -> &'a [T] { *self }\n }\n@@ -771,7 +771,7 @@ impl<T> Vector<T> for @[T] {\n     fn as_slice<'a>(&'a self) -> &'a [T] { let v: &'a [T] = *self; v }\n }\n \n-impl<'self, T> Container for &'self [T] {\n+impl<'a, T> Container for &'a [T] {\n     /// Returns the length of a vector\n     #[inline]\n     fn len(&self) -> uint {\n@@ -797,7 +797,7 @@ pub trait CopyableVector<T> {\n }\n \n /// Extension methods for vector slices\n-impl<'self, T: Clone> CopyableVector<T> for &'self [T] {\n+impl<'a, T: Clone> CopyableVector<T> for &'a [T] {\n     /// Returns a copy of `v`.\n     #[inline]\n     fn to_owned(&self) -> ~[T] {\n@@ -831,52 +831,52 @@ impl<T: Clone> CopyableVector<T> for @[T] {\n }\n \n /// Extension methods for vectors\n-pub trait ImmutableVector<'self, T> {\n+pub trait ImmutableVector<'a, T> {\n     /**\n      * Returns a slice of self between `start` and `end`.\n      *\n      * Fails when `start` or `end` point outside the bounds of self,\n      * or when `start` > `end`.\n      */\n-    fn slice(&self, start: uint, end: uint) -> &'self [T];\n+    fn slice(&self, start: uint, end: uint) -> &'a [T];\n \n     /**\n      * Returns a slice of self from `start` to the end of the vec.\n      *\n      * Fails when `start` points outside the bounds of self.\n      */\n-    fn slice_from(&self, start: uint) -> &'self [T];\n+    fn slice_from(&self, start: uint) -> &'a [T];\n \n     /**\n      * Returns a slice of self from the start of the vec to `end`.\n      *\n      * Fails when `end` points outside the bounds of self.\n      */\n-    fn slice_to(&self, end: uint) -> &'self [T];\n+    fn slice_to(&self, end: uint) -> &'a [T];\n     /// Returns an iterator over the vector\n-    fn iter(self) -> VecIterator<'self, T>;\n+    fn iter(self) -> VecIterator<'a, T>;\n     /// Returns a reversed iterator over a vector\n-    fn rev_iter(self) -> RevIterator<'self, T>;\n+    fn rev_iter(self) -> RevIterator<'a, T>;\n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred`.  The matched element\n     /// is not contained in the subslices.\n-    fn split(self, pred: 'self |&T| -> bool) -> SplitIterator<'self, T>;\n+    fn split(self, pred: 'a |&T| -> bool) -> SplitIterator<'a, T>;\n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred`, limited to splitting\n     /// at most `n` times.  The matched element is not contained in\n     /// the subslices.\n-    fn splitn(self, n: uint, pred: 'self |&T| -> bool) -> SplitIterator<'self, T>;\n+    fn splitn(self, n: uint, pred: 'a |&T| -> bool) -> SplitIterator<'a, T>;\n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred`. This starts at the\n     /// end of the vector and works backwards.  The matched element is\n     /// not contained in the subslices.\n-    fn rsplit(self, pred: 'self |&T| -> bool) -> RSplitIterator<'self, T>;\n+    fn rsplit(self, pred: 'a |&T| -> bool) -> RSplitIterator<'a, T>;\n     /// Returns an iterator over the subslices of the vector which are\n     /// separated by elements that match `pred` limited to splitting\n     /// at most `n` times. This starts at the end of the vector and\n     /// works backwards.  The matched element is not contained in the\n     /// subslices.\n-    fn rsplitn(self,  n: uint, pred: 'self |&T| -> bool) -> RSplitIterator<'self, T>;\n+    fn rsplitn(self,  n: uint, pred: 'a |&T| -> bool) -> RSplitIterator<'a, T>;\n \n     /**\n      * Returns an iterator over all contiguous windows of length\n@@ -900,7 +900,7 @@ pub trait ImmutableVector<'self, T> {\n      * ```\n      *\n      */\n-    fn windows(self, size: uint) -> WindowIter<'self, T>;\n+    fn windows(self, size: uint) -> WindowIter<'a, T>;\n     /**\n      *\n      * Returns an iterator over `size` elements of the vector at a\n@@ -925,27 +925,27 @@ pub trait ImmutableVector<'self, T> {\n      * ```\n      *\n      */\n-    fn chunks(self, size: uint) -> ChunkIter<'self, T>;\n+    fn chunks(self, size: uint) -> ChunkIter<'a, T>;\n \n     /// Returns the element of a vector at the given index, or `None` if the\n     /// index is out of bounds\n-    fn get_opt(&self, index: uint) -> Option<&'self T>;\n+    fn get_opt(&self, index: uint) -> Option<&'a T>;\n     /// Returns the first element of a vector, failing if the vector is empty.\n-    fn head(&self) -> &'self T;\n+    fn head(&self) -> &'a T;\n     /// Returns the first element of a vector, or `None` if it is empty\n-    fn head_opt(&self) -> Option<&'self T>;\n+    fn head_opt(&self) -> Option<&'a T>;\n     /// Returns all but the first element of a vector\n-    fn tail(&self) -> &'self [T];\n+    fn tail(&self) -> &'a [T];\n     /// Returns all but the first `n' elements of a vector\n-    fn tailn(&self, n: uint) -> &'self [T];\n+    fn tailn(&self, n: uint) -> &'a [T];\n     /// Returns all but the last element of a vector\n-    fn init(&self) -> &'self [T];\n+    fn init(&self) -> &'a [T];\n     /// Returns all but the last `n' elemnts of a vector\n-    fn initn(&self, n: uint) -> &'self [T];\n+    fn initn(&self, n: uint) -> &'a [T];\n     /// Returns the last element of a vector, failing if the vector is empty.\n-    fn last(&self) -> &'self T;\n+    fn last(&self) -> &'a T;\n     /// Returns the last element of a vector, or `None` if it is empty.\n-    fn last_opt(&self) -> Option<&'self T>;\n+    fn last_opt(&self) -> Option<&'a T>;\n     /**\n      * Apply a function to each element of a vector and return a concatenation\n      * of each result vector\n@@ -995,7 +995,7 @@ pub trait ImmutableVector<'self, T> {\n      *\n      * Fails if slice is empty.\n      */\n-    fn shift_ref(&mut self) -> &'self T;\n+    fn shift_ref(&mut self) -> &'a T;\n \n     /**\n      * Returns a mutable reference to the last element in this slice\n@@ -1012,12 +1012,12 @@ pub trait ImmutableVector<'self, T> {\n      *\n      * Fails if slice is empty.\n      */\n-    fn pop_ref(&mut self) -> &'self T;\n+    fn pop_ref(&mut self) -> &'a T;\n }\n \n-impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n+impl<'a,T> ImmutableVector<'a, T> for &'a [T] {\n     #[inline]\n-    fn slice(&self, start: uint, end: uint) -> &'self [T] {\n+    fn slice(&self, start: uint, end: uint) -> &'a [T] {\n         assert!(start <= end);\n         assert!(end <= self.len());\n         self.as_imm_buf(|p, _len| {\n@@ -1031,17 +1031,17 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     }\n \n     #[inline]\n-    fn slice_from(&self, start: uint) -> &'self [T] {\n+    fn slice_from(&self, start: uint) -> &'a [T] {\n         self.slice(start, self.len())\n     }\n \n     #[inline]\n-    fn slice_to(&self, end: uint) -> &'self [T] {\n+    fn slice_to(&self, end: uint) -> &'a [T] {\n         self.slice(0, end)\n     }\n \n     #[inline]\n-    fn iter(self) -> VecIterator<'self, T> {\n+    fn iter(self) -> VecIterator<'a, T> {\n         unsafe {\n             let p = vec::raw::to_ptr(self);\n             if mem::size_of::<T>() == 0 {\n@@ -1057,17 +1057,17 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     }\n \n     #[inline]\n-    fn rev_iter(self) -> RevIterator<'self, T> {\n+    fn rev_iter(self) -> RevIterator<'a, T> {\n         self.iter().invert()\n     }\n \n     #[inline]\n-    fn split(self, pred: 'self |&T| -> bool) -> SplitIterator<'self, T> {\n+    fn split(self, pred: 'a |&T| -> bool) -> SplitIterator<'a, T> {\n         self.splitn(uint::max_value, pred)\n     }\n \n     #[inline]\n-    fn splitn(self, n: uint, pred: 'self |&T| -> bool) -> SplitIterator<'self, T> {\n+    fn splitn(self, n: uint, pred: 'a |&T| -> bool) -> SplitIterator<'a, T> {\n         SplitIterator {\n             v: self,\n             n: n,\n@@ -1077,12 +1077,12 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     }\n \n     #[inline]\n-    fn rsplit(self, pred: 'self |&T| -> bool) -> RSplitIterator<'self, T> {\n+    fn rsplit(self, pred: 'a |&T| -> bool) -> RSplitIterator<'a, T> {\n         self.rsplitn(uint::max_value, pred)\n     }\n \n     #[inline]\n-    fn rsplitn(self, n: uint, pred: 'self |&T| -> bool) -> RSplitIterator<'self, T> {\n+    fn rsplitn(self, n: uint, pred: 'a |&T| -> bool) -> RSplitIterator<'a, T> {\n         RSplitIterator {\n             v: self,\n             n: n,\n@@ -1092,57 +1092,57 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     }\n \n     #[inline]\n-    fn windows(self, size: uint) -> WindowIter<'self, T> {\n+    fn windows(self, size: uint) -> WindowIter<'a, T> {\n         assert!(size != 0);\n         WindowIter { v: self, size: size }\n     }\n \n     #[inline]\n-    fn chunks(self, size: uint) -> ChunkIter<'self, T> {\n+    fn chunks(self, size: uint) -> ChunkIter<'a, T> {\n         assert!(size != 0);\n         ChunkIter { v: self, size: size }\n     }\n \n     #[inline]\n-    fn get_opt(&self, index: uint) -> Option<&'self T> {\n+    fn get_opt(&self, index: uint) -> Option<&'a T> {\n         if index < self.len() { Some(&self[index]) } else { None }\n     }\n \n     #[inline]\n-    fn head(&self) -> &'self T {\n+    fn head(&self) -> &'a T {\n         if self.len() == 0 { fail!(\"head: empty vector\") }\n         &self[0]\n     }\n \n     #[inline]\n-    fn head_opt(&self) -> Option<&'self T> {\n+    fn head_opt(&self) -> Option<&'a T> {\n         if self.len() == 0 { None } else { Some(&self[0]) }\n     }\n \n     #[inline]\n-    fn tail(&self) -> &'self [T] { self.slice(1, self.len()) }\n+    fn tail(&self) -> &'a [T] { self.slice(1, self.len()) }\n \n     #[inline]\n-    fn tailn(&self, n: uint) -> &'self [T] { self.slice(n, self.len()) }\n+    fn tailn(&self, n: uint) -> &'a [T] { self.slice(n, self.len()) }\n \n     #[inline]\n-    fn init(&self) -> &'self [T] {\n+    fn init(&self) -> &'a [T] {\n         self.slice(0, self.len() - 1)\n     }\n \n     #[inline]\n-    fn initn(&self, n: uint) -> &'self [T] {\n+    fn initn(&self, n: uint) -> &'a [T] {\n         self.slice(0, self.len() - n)\n     }\n \n     #[inline]\n-    fn last(&self) -> &'self T {\n+    fn last(&self) -> &'a T {\n         if self.len() == 0 { fail!(\"last: empty vector\") }\n         &self[self.len() - 1]\n     }\n \n     #[inline]\n-    fn last_opt(&self) -> Option<&'self T> {\n+    fn last_opt(&self) -> Option<&'a T> {\n             if self.len() == 0 { None } else { Some(&self[self.len() - 1]) }\n     }\n \n@@ -1185,14 +1185,14 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n         f(s.data, s.len)\n     }\n \n-    fn shift_ref(&mut self) -> &'self T {\n+    fn shift_ref(&mut self) -> &'a T {\n         unsafe {\n             let s: &mut Slice<T> = cast::transmute(self);\n             &*raw::shift_ptr(s)\n         }\n     }\n \n-    fn pop_ref(&mut self) -> &'self T {\n+    fn pop_ref(&mut self) -> &'a T {\n         unsafe {\n             let s: &mut Slice<T> = cast::transmute(self);\n             &*raw::pop_ptr(s)\n@@ -1218,7 +1218,7 @@ pub trait ImmutableEqVector<T:Eq> {\n     fn ends_with(&self, needle: &[T]) -> bool;\n }\n \n-impl<'self,T:Eq> ImmutableEqVector<T> for &'self [T] {\n+impl<'a,T:Eq> ImmutableEqVector<T> for &'a [T] {\n     #[inline]\n     fn position_elem(&self, x: &T) -> Option<uint> {\n         self.iter().position(|y| *x == *y)\n@@ -1257,7 +1257,7 @@ pub trait ImmutableTotalOrdVector<T: TotalOrd> {\n     fn bsearch_elem(&self, x: &T) -> Option<uint>;\n }\n \n-impl<'self, T: TotalOrd> ImmutableTotalOrdVector<T> for &'self [T] {\n+impl<'a, T: TotalOrd> ImmutableTotalOrdVector<T> for &'a [T] {\n     fn bsearch_elem(&self, x: &T) -> Option<uint> {\n         self.bsearch(|p| p.cmp(x))\n     }\n@@ -1278,7 +1278,7 @@ pub trait ImmutableCopyableVector<T> {\n     fn permutations(self) -> Permutations<T>;\n }\n \n-impl<'self,T:Clone> ImmutableCopyableVector<T> for &'self [T] {\n+impl<'a,T:Clone> ImmutableCopyableVector<T> for &'a [T] {\n     #[inline]\n     fn partitioned(&self, f: |&T| -> bool) -> (~[T], ~[T]) {\n         let mut lefts  = ~[];\n@@ -1913,34 +1913,34 @@ impl<T:Eq> OwnedEqVector<T> for ~[T] {\n \n /// Extension methods for vectors such that their elements are\n /// mutable.\n-pub trait MutableVector<'self, T> {\n+pub trait MutableVector<'a, T> {\n     /// Return a slice that points into another slice.\n-    fn mut_slice(self, start: uint, end: uint) -> &'self mut [T];\n+    fn mut_slice(self, start: uint, end: uint) -> &'a mut [T];\n \n     /**\n      * Returns a slice of self from `start` to the end of the vec.\n      *\n      * Fails when `start` points outside the bounds of self.\n      */\n-    fn mut_slice_from(self, start: uint) -> &'self mut [T];\n+    fn mut_slice_from(self, start: uint) -> &'a mut [T];\n \n     /**\n      * Returns a slice of self from the start of the vec to `end`.\n      *\n      * Fails when `end` points outside the bounds of self.\n      */\n-    fn mut_slice_to(self, end: uint) -> &'self mut [T];\n+    fn mut_slice_to(self, end: uint) -> &'a mut [T];\n \n     /// Returns an iterator that allows modifying each value\n-    fn mut_iter(self) -> VecMutIterator<'self, T>;\n+    fn mut_iter(self) -> VecMutIterator<'a, T>;\n \n     /// Returns a reversed iterator that allows modifying each value\n-    fn mut_rev_iter(self) -> MutRevIterator<'self, T>;\n+    fn mut_rev_iter(self) -> MutRevIterator<'a, T>;\n \n     /// Returns an iterator over the mutable subslices of the vector\n     /// which are separated by elements that match `pred`.  The\n     /// matched element is not contained in the subslices.\n-    fn mut_split(self, pred: 'self |&T| -> bool) -> MutSplitIterator<'self, T>;\n+    fn mut_split(self, pred: 'a |&T| -> bool) -> MutSplitIterator<'a, T>;\n \n     /**\n      * Returns an iterator over `size` elements of the vector at a time.\n@@ -1952,7 +1952,7 @@ pub trait MutableVector<'self, T> {\n      *\n      * Fails if `size` is 0.\n      */\n-    fn mut_chunks(self, chunk_size: uint) -> MutChunkIter<'self, T>;\n+    fn mut_chunks(self, chunk_size: uint) -> MutChunkIter<'a, T>;\n \n     /**\n      * Returns a mutable reference to the first element in this slice\n@@ -1969,7 +1969,7 @@ pub trait MutableVector<'self, T> {\n      *\n      * Fails if slice is empty.\n      */\n-    fn mut_shift_ref(&mut self) -> &'self mut T;\n+    fn mut_shift_ref(&mut self) -> &'a mut T;\n \n     /**\n      * Returns a mutable reference to the last element in this slice\n@@ -1986,7 +1986,7 @@ pub trait MutableVector<'self, T> {\n      *\n      * Fails if slice is empty.\n      */\n-    fn mut_pop_ref(&mut self) -> &'self mut T;\n+    fn mut_pop_ref(&mut self) -> &'a mut T;\n \n     /**\n      * Swaps two elements in a vector\n@@ -2004,8 +2004,8 @@ pub trait MutableVector<'self, T> {\n      * itself) and the second will contain all indices from\n      * `mid..len` (excluding the index `len` itself).\n      */\n-    fn mut_split_at(self, mid: uint) -> (&'self mut [T],\n-                                      &'self mut [T]);\n+    fn mut_split_at(self, mid: uint) -> (&'a mut [T],\n+                                      &'a mut [T]);\n \n     /// Reverse the order of elements in a vector, in place\n     fn reverse(self);\n@@ -2034,9 +2034,9 @@ pub trait MutableVector<'self, T> {\n     fn as_mut_buf<U>(self, f: |*mut T, uint| -> U) -> U;\n }\n \n-impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n+impl<'a,T> MutableVector<'a, T> for &'a mut [T] {\n     #[inline]\n-    fn mut_slice(self, start: uint, end: uint) -> &'self mut [T] {\n+    fn mut_slice(self, start: uint, end: uint) -> &'a mut [T] {\n         assert!(start <= end);\n         assert!(end <= self.len());\n         self.as_mut_buf(|p, _len| {\n@@ -2050,27 +2050,27 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n     }\n \n     #[inline]\n-    fn mut_slice_from(self, start: uint) -> &'self mut [T] {\n+    fn mut_slice_from(self, start: uint) -> &'a mut [T] {\n         let len = self.len();\n         self.mut_slice(start, len)\n     }\n \n     #[inline]\n-    fn mut_slice_to(self, end: uint) -> &'self mut [T] {\n+    fn mut_slice_to(self, end: uint) -> &'a mut [T] {\n         self.mut_slice(0, end)\n     }\n \n     #[inline]\n-    fn mut_split_at(self, mid: uint) -> (&'self mut [T], &'self mut [T]) {\n+    fn mut_split_at(self, mid: uint) -> (&'a mut [T], &'a mut [T]) {\n         unsafe {\n             let len = self.len();\n-            let self2: &'self mut [T] = cast::transmute_copy(&self);\n+            let self2: &'a mut [T] = cast::transmute_copy(&self);\n             (self.mut_slice(0, mid), self2.mut_slice(mid, len))\n         }\n     }\n \n     #[inline]\n-    fn mut_iter(self) -> VecMutIterator<'self, T> {\n+    fn mut_iter(self) -> VecMutIterator<'a, T> {\n         unsafe {\n             let p = vec::raw::to_mut_ptr(self);\n             if mem::size_of::<T>() == 0 {\n@@ -2086,30 +2086,30 @@ impl<'self,T> MutableVector<'self, T> for &'self mut [T] {\n     }\n \n     #[inline]\n-    fn mut_rev_iter(self) -> MutRevIterator<'self, T> {\n+    fn mut_rev_iter(self) -> MutRevIterator<'a, T> {\n         self.mut_iter().invert()\n     }\n \n     #[inline]\n-    fn mut_split(self, pred: 'self |&T| -> bool) -> MutSplitIterator<'self, T> {\n+    fn mut_split(self, pred: 'a |&T| -> bool) -> MutSplitIterator<'a, T> {\n         MutSplitIterator { v: self, pred: pred, finished: false }\n     }\n \n     #[inline]\n-    fn mut_chunks(self, chunk_size: uint) -> MutChunkIter<'self, T> {\n+    fn mut_chunks(self, chunk_size: uint) -> MutChunkIter<'a, T> {\n         assert!(chunk_size > 0);\n         let len = self.len();\n         MutChunkIter { v: self, chunk_size: chunk_size, remaining: len }\n     }\n \n-    fn mut_shift_ref(&mut self) -> &'self mut T {\n+    fn mut_shift_ref(&mut self) -> &'a mut T {\n         unsafe {\n             let s: &mut Slice<T> = cast::transmute(self);\n             cast::transmute_mut(&*raw::shift_ptr(s))\n         }\n     }\n \n-    fn mut_pop_ref(&mut self) -> &'self mut T {\n+    fn mut_pop_ref(&mut self) -> &'a mut T {\n         unsafe {\n             let s: &mut Slice<T> = cast::transmute(self);\n             cast::transmute_mut(&*raw::pop_ptr(s))\n@@ -2167,7 +2167,7 @@ pub trait MutableCloneableVector<T> {\n     fn copy_from(self, &[T]) -> uint;\n }\n \n-impl<'self, T:Clone> MutableCloneableVector<T> for &'self mut [T] {\n+impl<'a, T:Clone> MutableCloneableVector<T> for &'a mut [T] {\n     #[inline]\n     fn copy_from(self, src: &[T]) -> uint {\n         for (a, b) in self.mut_iter().zip(src.iter()) {\n@@ -2368,7 +2368,7 @@ pub mod bytes {\n         fn set_memory(self, value: u8);\n     }\n \n-    impl<'self> MutableByteVector for &'self mut [u8] {\n+    impl<'a> MutableByteVector for &'a mut [u8] {\n         #[inline]\n         fn set_memory(self, value: u8) {\n             self.as_mut_buf(|p, len| {\n@@ -2483,8 +2483,8 @@ impl<A: DeepClone> DeepClone for ~[A] {\n }\n \n // This works because every lifetime is a sub-lifetime of 'static\n-impl<'self, A> Default for &'self [A] {\n-    fn default() -> &'self [A] { &'self [] }\n+impl<'a, A> Default for &'a [A] {\n+    fn default() -> &'a [A] { &'a [] }\n }\n \n impl<A> Default for ~[A] {\n@@ -2498,13 +2498,13 @@ impl<A> Default for @[A] {\n macro_rules! iterator {\n     (struct $name:ident -> $ptr:ty, $elem:ty) => {\n         /// An iterator for iterating over a vector.\n-        pub struct $name<'self, T> {\n+        pub struct $name<'a, T> {\n             priv ptr: $ptr,\n             priv end: $ptr,\n             priv lifetime: Option<$elem> // FIXME: #5922\n         }\n \n-        impl<'self, T> Iterator<$elem> for $name<'self, T> {\n+        impl<'a, T> Iterator<$elem> for $name<'a, T> {\n             #[inline]\n             fn next(&mut self) -> Option<$elem> {\n                 // could be implemented with slices, but this avoids bounds checks\n@@ -2535,7 +2535,7 @@ macro_rules! iterator {\n             }\n         }\n \n-        impl<'self, T> DoubleEndedIterator<$elem> for $name<'self, T> {\n+        impl<'a, T> DoubleEndedIterator<$elem> for $name<'a, T> {\n             #[inline]\n             fn next_back(&mut self) -> Option<$elem> {\n                 // could be implemented with slices, but this avoids bounds checks\n@@ -2557,15 +2557,15 @@ macro_rules! iterator {\n     }\n }\n \n-impl<'self, T> RandomAccessIterator<&'self T> for VecIterator<'self, T> {\n+impl<'a, T> RandomAccessIterator<&'a T> for VecIterator<'a, T> {\n     #[inline]\n     fn indexable(&self) -> uint {\n         let (exact, _) = self.size_hint();\n         exact\n     }\n \n     #[inline]\n-    fn idx(&self, index: uint) -> Option<&'self T> {\n+    fn idx(&self, index: uint) -> Option<&'a T> {\n         unsafe {\n             if index < self.indexable() {\n                 cast::transmute(self.ptr.offset(index as int))\n@@ -2576,30 +2576,30 @@ impl<'self, T> RandomAccessIterator<&'self T> for VecIterator<'self, T> {\n     }\n }\n \n-iterator!{struct VecIterator -> *T, &'self T}\n-pub type RevIterator<'self, T> = Invert<VecIterator<'self, T>>;\n+iterator!{struct VecIterator -> *T, &'a T}\n+pub type RevIterator<'a, T> = Invert<VecIterator<'a, T>>;\n \n-impl<'self, T> ExactSize<&'self T> for VecIterator<'self, T> {}\n-impl<'self, T> ExactSize<&'self mut T> for VecMutIterator<'self, T> {}\n+impl<'a, T> ExactSize<&'a T> for VecIterator<'a, T> {}\n+impl<'a, T> ExactSize<&'a mut T> for VecMutIterator<'a, T> {}\n \n-impl<'self, T> Clone for VecIterator<'self, T> {\n-    fn clone(&self) -> VecIterator<'self, T> { *self }\n+impl<'a, T> Clone for VecIterator<'a, T> {\n+    fn clone(&self) -> VecIterator<'a, T> { *self }\n }\n \n-iterator!{struct VecMutIterator -> *mut T, &'self mut T}\n-pub type MutRevIterator<'self, T> = Invert<VecMutIterator<'self, T>>;\n+iterator!{struct VecMutIterator -> *mut T, &'a mut T}\n+pub type MutRevIterator<'a, T> = Invert<VecMutIterator<'a, T>>;\n \n /// An iterator over the subslices of the vector which are separated\n /// by elements that match `pred`.\n-pub struct MutSplitIterator<'self, T> {\n-    priv v: &'self mut [T],\n-    priv pred: 'self |t: &T| -> bool,\n+pub struct MutSplitIterator<'a, T> {\n+    priv v: &'a mut [T],\n+    priv pred: 'a |t: &T| -> bool,\n     priv finished: bool\n }\n \n-impl<'self, T> Iterator<&'self mut [T]> for MutSplitIterator<'self, T> {\n+impl<'a, T> Iterator<&'a mut [T]> for MutSplitIterator<'a, T> {\n     #[inline]\n-    fn next(&mut self) -> Option<&'self mut [T]> {\n+    fn next(&mut self) -> Option<&'a mut [T]> {\n         if self.finished { return None; }\n \n         match self.v.iter().position(|x| (self.pred)(x)) {\n@@ -2632,9 +2632,9 @@ impl<'self, T> Iterator<&'self mut [T]> for MutSplitIterator<'self, T> {\n     }\n }\n \n-impl<'self, T> DoubleEndedIterator<&'self mut [T]> for MutSplitIterator<'self, T> {\n+impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutSplitIterator<'a, T> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<&'self mut [T]> {\n+    fn next_back(&mut self) -> Option<&'a mut [T]> {\n         if self.finished { return None; }\n \n         match self.v.iter().rposition(|x| (self.pred)(x)) {\n@@ -2659,15 +2659,15 @@ impl<'self, T> DoubleEndedIterator<&'self mut [T]> for MutSplitIterator<'self, T\n /// An iterator over a vector in (non-overlapping) mutable chunks (`size`  elements at a time). When\n /// the vector len is not evenly divided by the chunk size, the last slice of the iteration will be\n /// the remainder.\n-pub struct MutChunkIter<'self, T> {\n-    priv v: &'self mut [T],\n+pub struct MutChunkIter<'a, T> {\n+    priv v: &'a mut [T],\n     priv chunk_size: uint,\n     priv remaining: uint\n }\n \n-impl<'self, T> Iterator<&'self mut [T]> for MutChunkIter<'self, T> {\n+impl<'a, T> Iterator<&'a mut [T]> for MutChunkIter<'a, T> {\n     #[inline]\n-    fn next(&mut self) -> Option<&'self mut [T]> {\n+    fn next(&mut self) -> Option<&'a mut [T]> {\n         if self.remaining == 0 {\n             None\n         } else {\n@@ -2692,9 +2692,9 @@ impl<'self, T> Iterator<&'self mut [T]> for MutChunkIter<'self, T> {\n     }\n }\n \n-impl<'self, T> DoubleEndedIterator<&'self mut [T]> for MutChunkIter<'self, T> {\n+impl<'a, T> DoubleEndedIterator<&'a mut [T]> for MutChunkIter<'a, T> {\n     #[inline]\n-    fn next_back(&mut self) -> Option<&'self mut [T]> {\n+    fn next_back(&mut self) -> Option<&'a mut [T]> {\n         if self.remaining == 0 {\n             None\n         } else {"}, {"sha": "afbbb069354c1ab2d712c0e641453ad4c75b8237", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -390,13 +390,13 @@ pub trait IdVisitingOperation {\n     fn visit_id(&self, node_id: NodeId);\n }\n \n-pub struct IdVisitor<'self, O> {\n-    operation: &'self O,\n+pub struct IdVisitor<'a, O> {\n+    operation: &'a O,\n     pass_through_items: bool,\n     visited_outermost: bool,\n }\n \n-impl<'self, O: IdVisitingOperation> IdVisitor<'self, O> {\n+impl<'a, O: IdVisitingOperation> IdVisitor<'a, O> {\n     fn visit_generics_helper(&self, generics: &Generics) {\n         for type_parameter in generics.ty_params.iter() {\n             self.operation.visit_id(type_parameter.id)\n@@ -407,7 +407,7 @@ impl<'self, O: IdVisitingOperation> IdVisitor<'self, O> {\n     }\n }\n \n-impl<'self, O: IdVisitingOperation> Visitor<()> for IdVisitor<'self, O> {\n+impl<'a, O: IdVisitingOperation> Visitor<()> for IdVisitor<'a, O> {\n     fn visit_mod(&mut self,\n                  module: &_mod,\n                  _: Span,\n@@ -657,11 +657,11 @@ pub trait EachViewItem {\n     fn each_view_item(&self, f: |&ast::view_item| -> bool) -> bool;\n }\n \n-struct EachViewItemData<'self> {\n-    callback: 'self |&ast::view_item| -> bool,\n+struct EachViewItemData<'a> {\n+    callback: 'a |&ast::view_item| -> bool,\n }\n \n-impl<'self> Visitor<()> for EachViewItemData<'self> {\n+impl<'a> Visitor<()> for EachViewItemData<'a> {\n     fn visit_view_item(&mut self, view_item: &ast::view_item, _: ()) {\n         let _ = (self.callback)(view_item);\n     }"}, {"sha": "d5a64a5edbaea5cb2ba1c78dd8bf9b40dfbc07df", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -493,7 +493,7 @@ pub fn get_exprs_from_tts(cx: @ExtCtxt,\n // use a top-level managed pointer by some difficulties\n // with pushing and popping functionally, and the ownership\n // issues.  As a result, the values returned by the table\n-// also need to be managed; the &'self ... type that Maps\n+// also need to be managed; the &'a ... type that Maps\n // return won't work for things that need to get outside\n // of that managed pointer.  The easiest way to do this\n // is just to insist that the values in the tables are"}, {"sha": "b3e2503f8c460995d75156a9c29f5729f443ee0a", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -188,41 +188,41 @@ use std::vec;\n pub use self::ty::*;\n mod ty;\n \n-pub struct TraitDef<'self> {\n+pub struct TraitDef<'a> {\n     /// The extension context\n     cx: @ExtCtxt,\n     /// The span for the current #[deriving(Foo)] header.\n     span: Span,\n \n     /// Path of the trait, including any type parameters\n-    path: Path<'self>,\n+    path: Path<'a>,\n     /// Additional bounds required of any type parameters of the type,\n     /// other than the current trait\n-    additional_bounds: ~[Ty<'self>],\n+    additional_bounds: ~[Ty<'a>],\n \n     /// Any extra lifetimes and/or bounds, e.g. `D: extra::serialize::Decoder`\n-    generics: LifetimeBounds<'self>,\n+    generics: LifetimeBounds<'a>,\n \n-    methods: ~[MethodDef<'self>]\n+    methods: ~[MethodDef<'a>]\n }\n \n \n-pub struct MethodDef<'self> {\n+pub struct MethodDef<'a> {\n     /// name of the method\n-    name: &'self str,\n+    name: &'a str,\n     /// List of generics, e.g. `R: std::rand::Rng`\n-    generics: LifetimeBounds<'self>,\n+    generics: LifetimeBounds<'a>,\n \n     /// Whether there is a self argument (outer Option) i.e. whether\n     /// this is a static function, and whether it is a pointer (inner\n     /// Option)\n-    explicit_self: Option<Option<PtrTy<'self>>>,\n+    explicit_self: Option<Option<PtrTy<'a>>>,\n \n     /// Arguments other than the self argument\n-    args: ~[Ty<'self>],\n+    args: ~[Ty<'a>],\n \n     /// Return type\n-    ret_ty: Ty<'self>,\n+    ret_ty: Ty<'a>,\n \n     /// Whether to mark this as #[inline]\n     inline: bool,\n@@ -231,20 +231,20 @@ pub struct MethodDef<'self> {\n     /// actual enum variants, i.e. can use _ => .. match.\n     const_nonmatching: bool,\n \n-    combine_substructure: CombineSubstructureFunc<'self>\n+    combine_substructure: CombineSubstructureFunc<'a>\n }\n \n /// All the data about the data structure/method being derived upon.\n-pub struct Substructure<'self> {\n+pub struct Substructure<'a> {\n     /// ident of self\n     type_ident: Ident,\n     /// ident of the method\n     method_ident: Ident,\n     /// dereferenced access to any Self or Ptr(Self, _) arguments\n-    self_args: &'self [@Expr],\n+    self_args: &'a [@Expr],\n     /// verbatim access to any other arguments\n-    nonself_args: &'self [@Expr],\n-    fields: &'self SubstructureFields<'self>\n+    nonself_args: &'a [@Expr],\n+    fields: &'a SubstructureFields<'a>\n }\n \n /// Summary of the relevant parts of a struct/enum field.\n@@ -271,26 +271,26 @@ pub enum StaticFields {\n \n /// A summary of the possible sets of fields. See above for details\n /// and examples\n-pub enum SubstructureFields<'self> {\n+pub enum SubstructureFields<'a> {\n     Struct(~[FieldInfo]),\n     /**\n     Matching variants of the enum: variant index, ast::variant,\n     fields: the field name is only non-`None` in the case of a struct\n     variant.\n     */\n-    EnumMatching(uint, &'self ast::variant, ~[FieldInfo]),\n+    EnumMatching(uint, &'a ast::variant, ~[FieldInfo]),\n \n     /**\n     non-matching variants of the enum, [(variant index, ast::variant,\n     [field span, field ident, fields])] (i.e. all fields for self are in the\n     first tuple, for other1 are in the second tuple, etc.)\n     */\n-    EnumNonMatching(&'self [(uint, P<ast::variant>, ~[(Span, Option<Ident>, @Expr)])]),\n+    EnumNonMatching(&'a [(uint, P<ast::variant>, ~[(Span, Option<Ident>, @Expr)])]),\n \n     /// A static method where Self is a struct.\n-    StaticStruct(&'self ast::struct_def, StaticFields),\n+    StaticStruct(&'a ast::struct_def, StaticFields),\n     /// A static method where Self is an enum.\n-    StaticEnum(&'self ast::enum_def, ~[(Ident, StaticFields)])\n+    StaticEnum(&'a ast::enum_def, ~[(Ident, StaticFields)])\n }\n \n \n@@ -299,23 +299,23 @@ pub enum SubstructureFields<'self> {\n Combine the values of all the fields together. The last argument is\n all the fields of all the structures, see above for details.\n */\n-pub type CombineSubstructureFunc<'self> =\n-    'self |@ExtCtxt, Span, &Substructure| -> @Expr;\n+pub type CombineSubstructureFunc<'a> =\n+    'a |@ExtCtxt, Span, &Substructure| -> @Expr;\n \n /**\n Deal with non-matching enum variants, the arguments are a list\n representing each variant: (variant index, ast::variant instance,\n [variant fields]), and a list of the nonself args of the type\n */\n-pub type EnumNonMatchFunc<'self> =\n-    'self |@ExtCtxt,\n+pub type EnumNonMatchFunc<'a> =\n+    'a |@ExtCtxt,\n            Span,\n            &[(uint, P<ast::variant>, ~[(Span, Option<Ident>, @Expr)])],\n            &[@Expr]|\n            -> @Expr;\n \n \n-impl<'self> TraitDef<'self> {\n+impl<'a> TraitDef<'a> {\n     pub fn expand(&self,\n                   _mitem: @ast::MetaItem,\n                   in_items: ~[@ast::item]) -> ~[@ast::item] {\n@@ -467,7 +467,7 @@ impl<'self> TraitDef<'self> {\n     }\n }\n \n-impl<'self> MethodDef<'self> {\n+impl<'a> MethodDef<'a> {\n     fn call_substructure_method(&self,\n                                 trait_: &TraitDef,\n                                 type_ident: Ident,"}, {"sha": "d38f9b4d1b79e1dd05dfe7fa279b9335053628f2", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -46,13 +46,13 @@ pub mod totalord;\n \n pub mod generic;\n \n-pub type ExpandDerivingStructDefFn<'self> = 'self |@ExtCtxt,\n+pub type ExpandDerivingStructDefFn<'a> = 'a |@ExtCtxt,\n                                                    Span,\n                                                    x: &struct_def,\n                                                    Ident,\n                                                    y: &Generics|\n                                                    -> @item;\n-pub type ExpandDerivingEnumDefFn<'self> = 'self |@ExtCtxt,\n+pub type ExpandDerivingEnumDefFn<'a> = 'a |@ExtCtxt,\n                                                  Span,\n                                                  x: &enum_def,\n                                                  Ident,"}, {"sha": "e606cebc415c46193db4d992b10c5e7cbc84fae3", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -22,22 +22,22 @@ use opt_vec;\n use opt_vec::OptVec;\n \n /// The types of pointers\n-pub enum PtrTy<'self> {\n+pub enum PtrTy<'a> {\n     Send, // ~\n     Managed(ast::Mutability), // @[mut]\n-    Borrowed(Option<&'self str>, ast::Mutability), // &['lifetime] [mut]\n+    Borrowed(Option<&'a str>, ast::Mutability), // &['lifetime] [mut]\n }\n \n /// A path, e.g. `::std::option::Option::<int>` (global). Has support\n /// for type parameters and a lifetime.\n-pub struct Path<'self> {\n-    path: ~[&'self str],\n-    lifetime: Option<&'self str>,\n-    params: ~[~Ty<'self>],\n+pub struct Path<'a> {\n+    path: ~[&'a str],\n+    lifetime: Option<&'a str>,\n+    params: ~[~Ty<'a>],\n     global: bool\n }\n \n-impl<'self> Path<'self> {\n+impl<'a> Path<'a> {\n     pub fn new<'r>(path: ~[&'r str]) -> Path<'r> {\n         Path::new_(path, None, ~[], true)\n     }\n@@ -80,15 +80,15 @@ impl<'self> Path<'self> {\n }\n \n /// A type. Supports pointers (except for *), Self, and literals\n-pub enum Ty<'self> {\n+pub enum Ty<'a> {\n     Self,\n     // &/~/@ Ty\n-    Ptr(~Ty<'self>, PtrTy<'self>),\n+    Ptr(~Ty<'a>, PtrTy<'a>),\n     // mod::mod::Type<[lifetime], [Params...]>, including a plain type\n     // parameter, and things like `int`\n-    Literal(Path<'self>),\n+    Literal(Path<'a>),\n     // includes nil\n-    Tuple(~[Ty<'self>])\n+    Tuple(~[Ty<'a>])\n }\n \n pub fn borrowed_ptrty<'r>() -> PtrTy<'r> {\n@@ -124,7 +124,7 @@ fn mk_lifetimes(cx: @ExtCtxt, span: Span, lt: &Option<&str>) -> OptVec<ast::Life\n     }\n }\n \n-impl<'self> Ty<'self> {\n+impl<'a> Ty<'a> {\n     pub fn to_ty(&self,\n                  cx: @ExtCtxt,\n                  span: Span,\n@@ -207,12 +207,12 @@ fn mk_generics(lifetimes: ~[ast::Lifetime],  ty_params: ~[ast::TyParam]) -> Gene\n }\n \n /// Lifetimes and bounds on type parameters\n-pub struct LifetimeBounds<'self> {\n-    lifetimes: ~[&'self str],\n-    bounds: ~[(&'self str, ~[Path<'self>])]\n+pub struct LifetimeBounds<'a> {\n+    lifetimes: ~[&'a str],\n+    bounds: ~[(&'a str, ~[Path<'a>])]\n }\n \n-impl<'self> LifetimeBounds<'self> {\n+impl<'a> LifetimeBounds<'a> {\n     pub fn empty() -> LifetimeBounds<'static> {\n         LifetimeBounds {\n             lifetimes: ~[], bounds: ~[]"}, {"sha": "77cb02522a7e015ccf8b6663f3a75dc82ded49ab", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -80,7 +80,7 @@ pub mod rt {\n         }\n     }\n \n-    impl<'self> ToSource for &'self [@ast::item] {\n+    impl<'a> ToSource for &'a [@ast::item] {\n         fn to_source(&self) -> @str {\n             self.map(|i| i.to_source()).connect(\"\\n\\n\").to_managed()\n         }\n@@ -92,7 +92,7 @@ pub mod rt {\n         }\n     }\n \n-    impl<'self> ToSource for &'self [ast::Ty] {\n+    impl<'a> ToSource for &'a [ast::Ty] {\n         fn to_source(&self) -> @str {\n             self.map(|i| i.to_source()).connect(\", \").to_managed()\n         }\n@@ -116,7 +116,7 @@ pub mod rt {\n         }\n     }\n \n-    impl<'self> ToSource for &'self str {\n+    impl<'a> ToSource for &'a str {\n         fn to_source(&self) -> @str {\n             let lit = dummy_spanned(ast::lit_str(self.to_managed(), ast::CookedStr));\n             pprust::lit_to_str(&lit).to_managed()\n@@ -208,7 +208,7 @@ pub mod rt {\n \n     macro_rules! impl_to_tokens_self(\n         ($t:ty) => (\n-            impl<'self> ToTokens for $t {\n+            impl<'a> ToTokens for $t {\n                 fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n                     cx.parse_tts(self.to_source())\n                 }\n@@ -218,13 +218,13 @@ pub mod rt {\n \n     impl_to_tokens!(ast::Ident)\n     impl_to_tokens!(@ast::item)\n-    impl_to_tokens_self!(&'self [@ast::item])\n+    impl_to_tokens_self!(&'a [@ast::item])\n     impl_to_tokens!(ast::Ty)\n-    impl_to_tokens_self!(&'self [ast::Ty])\n+    impl_to_tokens_self!(&'a [ast::Ty])\n     impl_to_tokens!(Generics)\n     impl_to_tokens!(@ast::Expr)\n     impl_to_tokens!(ast::Block)\n-    impl_to_tokens_self!(&'self str)\n+    impl_to_tokens_self!(&'a str)\n     impl_to_tokens!(int)\n     impl_to_tokens!(i8)\n     impl_to_tokens!(i16)"}, {"sha": "247962e0b94243ef4f2626d8fc05f04293f5f4ef", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -144,13 +144,13 @@ impl<T> Default for OptVec<T> {\n     fn default() -> OptVec<T> { Empty }\n }\n \n-pub struct OptVecIterator<'self, T> {\n-    priv iter: Option<VecIterator<'self, T>>\n+pub struct OptVecIterator<'a, T> {\n+    priv iter: Option<VecIterator<'a, T>>\n }\n \n-impl<'self, T> Iterator<&'self T> for OptVecIterator<'self, T> {\n+impl<'a, T> Iterator<&'a T> for OptVecIterator<'a, T> {\n     #[inline]\n-    fn next(&mut self) -> Option<&'self T> {\n+    fn next(&mut self) -> Option<&'a T> {\n         match self.iter {\n             Some(ref mut x) => x.next(),\n             None => None"}, {"sha": "d48c1d9d8d7c93187e5b988498eca7fd735685d5", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -764,14 +764,15 @@ fn next_token_inner(rdr: @mut StringReader) -> token::Token {\n                 let ident = str_to_ident(lifetime_name);\n                 let tok = &token::IDENT(ident, false);\n \n-                if token::is_any_keyword(tok)\n-                    && !token::is_keyword(token::keywords::Static, tok)\n-                    && !token::is_keyword(token::keywords::Self, tok) {\n+                if token::is_keyword(token::keywords::Self, tok) {\n                     fatal_span(rdr, start, rdr.last_pos,\n-                        ~\"invalid lifetime name\");\n+                               ~\"invalid lifetime name: 'self is no longer a special lifetime\");\n+                } else if token::is_any_keyword(tok) &&\n+                    !token::is_keyword(token::keywords::Static, tok) {\n+                    fatal_span(rdr, start, rdr.last_pos, ~\"invalid lifetime name\");\n+                } else {\n+                    token::LIFETIME(ident)\n                 }\n-\n-                token::LIFETIME(ident)\n             })\n         }\n "}, {"sha": "aa37d859d7971672c1b9fc0c9408d5301b8d8c65", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -102,13 +102,13 @@ pub enum PathParsingMode {\n     /// A path with no type parameters; e.g. `foo::bar::Baz`\n     NoTypesAllowed,\n     /// A path with a lifetime and type parameters, with no double colons\n-    /// before the type parameters; e.g. `foo::bar<'self>::Baz<T>`\n+    /// before the type parameters; e.g. `foo::bar<'a>::Baz<T>`\n     LifetimeAndTypesWithoutColons,\n     /// A path with a lifetime and type parameters with double colons before\n-    /// the type parameters; e.g. `foo::bar::<'self>::Baz::<T>`\n+    /// the type parameters; e.g. `foo::bar::<'a>::Baz::<T>`\n     LifetimeAndTypesWithColons,\n     /// A path with a lifetime and type parameters with bounds before the last\n-    /// set of type parameters only; e.g. `foo::bar<'self>::Baz:X+Y<T>` This\n+    /// set of type parameters only; e.g. `foo::bar<'a>::Baz:X+Y<T>` This\n     /// form does not use extra double colons.\n     LifetimeAndTypesAndBounds,\n }"}, {"sha": "503d884c24d5094c8062bd16acf62bf020d68439", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -34,11 +34,11 @@ use std::io::Decorator;\n use std::io::mem::MemWriter;\n \n // The @ps is stored here to prevent recursive type.\n-pub enum ann_node<'self> {\n-    node_block(@ps, &'self ast::Block),\n-    node_item(@ps, &'self ast::item),\n-    node_expr(@ps, &'self ast::Expr),\n-    node_pat(@ps, &'self ast::Pat),\n+pub enum ann_node<'a> {\n+    node_block(@ps, &'a ast::Block),\n+    node_item(@ps, &'a ast::item),\n+    node_expr(@ps, &'a ast::Expr),\n+    node_pat(@ps, &'a ast::Pat),\n }\n \n pub trait pp_ann {"}, {"sha": "3bfc88e1e819ba75acd55472055d72e90680bfe6", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -28,12 +28,12 @@ use opt_vec::OptVec;\n // execute before AST node B, then A is visited first.  The borrow checker in\n // particular relies on this property.\n \n-pub enum fn_kind<'self> {\n+pub enum fn_kind<'a> {\n     // fn foo() or extern \"Abi\" fn foo()\n-    fk_item_fn(Ident, &'self Generics, purity, AbiSet),\n+    fk_item_fn(Ident, &'a Generics, purity, AbiSet),\n \n     // fn foo(&self)\n-    fk_method(Ident, &'self Generics, &'self method),\n+    fk_method(Ident, &'a Generics, &'a method),\n \n     // @fn(x, y) { ... }\n     fk_anon(ast::Sigil),"}, {"sha": "6be7d7ab214d323d1a6a53a2abe6723e330066ac", "filename": "src/test/auxiliary/iss.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fauxiliary%2Fiss.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fauxiliary%2Fiss.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fiss.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -14,8 +14,8 @@\n \n // part of issue-6919.rs\n \n-struct C<'self> {\n-    k: 'self ||,\n+struct C<'a> {\n+    k: 'a ||,\n }\n \n fn no_op() { }"}, {"sha": "f132bc491e8162289f305ef3329289448ec29614", "filename": "src/test/bench/shootout-binarytrees.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-binarytrees.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -14,9 +14,9 @@ use std::iter::range_step;\n use extra::arena::Arena;\n use extra::future::Future;\n \n-enum Tree<'self> {\n+enum Tree<'a> {\n     Nil,\n-    Node(&'self Tree<'self>, &'self Tree<'self>, int)\n+    Node(&'a Tree<'a>, &'a Tree<'a>, int)\n }\n \n fn item_check(t: &Tree) -> int {"}, {"sha": "b40996b1471e5f330801edcbc4742f3c66eb0266", "filename": "src/test/bench/shootout-meteor.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fbench%2Fshootout-meteor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-meteor.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -17,11 +17,11 @@\n fn iterate<'a, T>(x: T, f: 'a |&T| -> T) -> Iterate<'a, T> {\n     Iterate {f: f, next: x}\n }\n-struct Iterate<'self, T> {\n-    priv f: 'self |&T| -> T,\n+struct Iterate<'a, T> {\n+    priv f: 'a |&T| -> T,\n     priv next: T\n }\n-impl<'self, T> Iterator<T> for Iterate<'self, T> {\n+impl<'a, T> Iterator<T> for Iterate<'a, T> {\n     fn next(&mut self) -> Option<T> {\n         let mut res = (self.f)(&self.next);\n         std::util::swap(&mut res, &mut self.next);\n@@ -30,20 +30,20 @@ impl<'self, T> Iterator<T> for Iterate<'self, T> {\n }\n \n // a linked list using borrowed next.\n-enum List<'self, T> {\n+enum List<'a, T> {\n     Nil,\n-    Cons(T, &'self List<'self, T>)\n+    Cons(T, &'a List<'a, T>)\n }\n-struct ListIterator<'self, T> {\n-    priv cur: &'self List<'self, T>\n+struct ListIterator<'a, T> {\n+    priv cur: &'a List<'a, T>\n }\n-impl<'self, T> List<'self, T> {\n-    fn iter(&'self self) -> ListIterator<'self, T> {\n+impl<'a, T> List<'a, T> {\n+    fn iter(&'a self) -> ListIterator<'a, T> {\n         ListIterator{cur: self}\n     }\n }\n-impl<'self, T> Iterator<&'self T> for ListIterator<'self, T> {\n-    fn next(&mut self) -> Option<&'self T> {\n+impl<'a, T> Iterator<&'a T> for ListIterator<'a, T> {\n+    fn next(&mut self) -> Option<&'a T> {\n         match *self.cur {\n             Nil => None,\n             Cons(ref elt, next) => {"}, {"sha": "9f73955f29ebbb3164eace7b6d26cca49a65cd83", "filename": "src/test/compile-fail/auto-ref-slice-plus-ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fauto-ref-slice-plus-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fauto-ref-slice-plus-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauto-ref-slice-plus-ref.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -23,6 +23,6 @@ trait MyIter {\n     fn test_mut(&mut self);\n }\n \n-impl<'self> MyIter for &'self [int] {\n+impl<'a> MyIter for &'a [int] {\n     fn test_mut(&mut self) { }\n }"}, {"sha": "3fa840f6a4efbb817433b150ad7395168501c293", "filename": "src/test/compile-fail/borrowck-assign-to-andmut-in-aliasable-loc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-andmut-in-aliasable-loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-andmut-in-aliasable-loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-andmut-in-aliasable-loc.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -11,8 +11,8 @@\n // Test that assignments to an `&mut` pointer which is found in a\n // borrowed (but otherwise non-aliasable) location is illegal.\n \n-struct S<'self> {\n-    pointer: &'self mut int\n+struct S<'a> {\n+    pointer: &'a mut int\n }\n \n fn a(s: &S) {"}, {"sha": "ccbbc2ea6c3a01bb3462853cd87584a90db93644", "filename": "src/test/compile-fail/borrowck-assign-to-andmut-in-borrowed-loc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-andmut-in-borrowed-loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-andmut-in-borrowed-loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-to-andmut-in-borrowed-loc.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -11,8 +11,8 @@\n // Test that assignments to an `&mut` pointer which is found in a\n // borrowed (but otherwise non-aliasable) location is illegal.\n \n-struct S<'self> {\n-    pointer: &'self mut int\n+struct S<'a> {\n+    pointer: &'a mut int\n }\n \n fn copy_borrowed_ptr<'a>(p: &'a mut S<'a>) -> S<'a> {"}, {"sha": "646ec6928630445ccadc6b0a4d89963dde1a3cf4", "filename": "src/test/compile-fail/borrowck-borrowed-uniq-rvalue-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrowed-uniq-rvalue-2.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct defer<'self> {\n-    x: &'self [&'self str],\n+struct defer<'a> {\n+    x: &'a [&'a str],\n }\n \n #[unsafe_destructor]\n-impl<'self> Drop for defer<'self> {\n+impl<'a> Drop for defer<'a> {\n     fn drop(&mut self) {\n         unsafe {\n             error!(\"{:?}\", self.x);"}, {"sha": "962bf67f009d9b25abf55a97b1b4d6578910ce65", "filename": "src/test/compile-fail/builtin-superkinds-simple.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-simple.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -13,10 +13,10 @@\n \n trait Foo : Send { }\n \n-impl <'self> Foo for &'self mut () { } //~ ERROR cannot implement this trait\n+impl <'a> Foo for &'a mut () { } //~ ERROR cannot implement this trait\n \n trait Bar : Freeze { }\n \n-impl <'self> Bar for &'self mut () { } //~ ERROR cannot implement this trait\n+impl <'a> Bar for &'a mut () { } //~ ERROR cannot implement this trait\n \n fn main() { }"}, {"sha": "1cfed882d6c5119d12beaaaab85f4285934c96d1", "filename": "src/test/compile-fail/issue-3154.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fissue-3154.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fissue-3154.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3154.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct thing<'self, Q> {\n-    x: &'self Q\n+struct thing<'a, Q> {\n+    x: &'a Q\n }\n \n fn thing<Q>(x: &Q) -> thing<Q> {"}, {"sha": "6b1b84a940a8f9ccf5cf53477a7120d9276abf9d", "filename": "src/test/compile-fail/issue-5500-1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fissue-5500-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fissue-5500-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5500-1.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -10,8 +10,8 @@\n \n // xfail-test\n \n-struct TrieMapIterator<'self> {\n-    priv node: &'self uint\n+struct TrieMapIterator<'a> {\n+    priv node: &'a uint\n }\n \n fn main() {"}, {"sha": "670c4927a6f91031071c10b88a58454f616779b5", "filename": "src/test/compile-fail/kindck-owned-trait-scoped.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-owned-trait-scoped.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -12,14 +12,14 @@\n // except according to those terms.\n \n // A dummy trait/impl that work close over any type.  The trait will\n-// be parameterized by a region due to the &'self int constraint.\n+// be parameterized by a region due to the &'a int constraint.\n \n trait foo {\n-    fn foo(&self, i: &'self int) -> int;\n+    fn foo(&self, i: &'a int) -> int;\n }\n \n impl<T:Clone> foo for T {\n-    fn foo(&self, i: &'self int) -> int {*i}\n+    fn foo(&self, i: &'a int) -> int {*i}\n }\n \n fn to_foo<T:Clone>(t: T) {"}, {"sha": "0ef13d73fab2bb48ec138b180119c595bed3a85c", "filename": "src/test/compile-fail/lifetime-no-keyword.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Flifetime-no-keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Flifetime-no-keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-no-keyword.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -1,4 +1,3 @@\n-\n // Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n@@ -9,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn foo(a: &'let int) { } //~ ERROR invalid lifetime name\n-fn bar(a: &'static int) {\u00a0}\n-fn baz<'self>(a: &'self int) {\u00a0}\n+fn foo<'a>(a: &'a int) { }\n+fn bar(a: &'static int) { }\n+fn baz(a: &'let int) { } //~ ERROR invalid lifetime name\n \n fn main() { }"}, {"sha": "a99daaab24936d0ca5fc8a8e2636f2308803502b", "filename": "src/test/compile-fail/lifetime-obsoleted-self.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Flifetime-obsoleted-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Flifetime-obsoleted-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-obsoleted-self.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn baz(a: &'self int) { } //~ ERROR invalid lifetime name: 'self is no longer a special lifetime\n+\n+fn main() { }"}, {"sha": "03b9b7ba78f4da01731222b60588feadf7158744", "filename": "src/test/compile-fail/moves-based-on-type-no-recursive-stack-closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-no-recursive-stack-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-no-recursive-stack-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmoves-based-on-type-no-recursive-stack-closure.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -12,11 +12,11 @@\n // bound must be noncopyable. For details see\n // http://smallcultfollowing.com/babysteps/blog/2013/04/30/the-case-of-the-recurring-closure/\n \n-struct R<'self> {\n+struct R<'a> {\n     // This struct is needed to create the\n     // otherwise infinite type of a fn that\n     // accepts itself as argument:\n-    c: 'self |&R, bool|\n+    c: 'a |&R, bool|\n }\n \n fn innocent_looking_victim() {"}, {"sha": "f74244c49843789d455b6d727cc2b15219dc04c2", "filename": "src/test/compile-fail/regions-bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-bounds.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -12,8 +12,8 @@\n // nominal types (but not on other types) and that they are type\n // checked.\n \n-struct an_enum<'self>(&'self int);\n-struct a_class<'self> { x:&'self int }\n+struct an_enum<'a>(&'a int);\n+struct a_class<'a> { x:&'a int }\n \n fn a_fn1<'a,'b>(e: an_enum<'a>) -> an_enum<'b> {\n     return e; //~ ERROR mismatched types: expected `an_enum<'b>` but found `an_enum<'a>`"}, {"sha": "4fd3cd2704437fc38f04a5ae7ac2374666870993", "filename": "src/test/compile-fail/regions-creating-enums.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum ast<'self> {\n+enum ast<'a> {\n     num(uint),\n-    add(&'self ast<'self>, &'self ast<'self>)\n+    add(&'a ast<'a>, &'a ast<'a>)\n }\n \n fn build() {"}, {"sha": "9e36ecc2b75ec82ac4d71d12a1bae90825699a7c", "filename": "src/test/compile-fail/regions-creating-enums3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums3.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum ast<'self> {\n+enum ast<'a> {\n     num(uint),\n-    add(&'self ast<'self>, &'self ast<'self>)\n+    add(&'a ast<'a>, &'a ast<'a>)\n }\n \n fn mk_add_bad1<'a,'b>(x: &'a ast<'a>, y: &'b ast<'b>) -> ast<'a> {"}, {"sha": "7683b678b2b6a55abf6d298aab2117ce96968b53", "filename": "src/test/compile-fail/regions-creating-enums4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-creating-enums4.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum ast<'self> {\n+enum ast<'a> {\n     num(uint),\n-    add(&'self ast<'self>, &'self ast<'self>)\n+    add(&'a ast<'a>, &'a ast<'a>)\n }\n \n fn mk_add_bad2<'a>(x: &'a ast<'a>, y: &'a ast<'a>, z: &ast) -> ast {"}, {"sha": "7f54fe298a15e42a39cd831fd1674cab02de6a38", "filename": "src/test/compile-fail/regions-escape-via-trait-or-not.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-escape-via-trait-or-not.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -12,7 +12,7 @@ trait deref {\n     fn get(self) -> int;\n }\n \n-impl<'self> deref for &'self int {\n+impl<'a> deref for &'a int {\n     fn get(self) -> int {\n         *self\n     }"}, {"sha": "2f8caabb7f8e416dcb93c342462f2b2f72a8c19b", "filename": "src/test/compile-fail/regions-free-region-ordering-caller.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-caller.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-caller.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-caller.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -12,7 +12,7 @@\n // than the thing it points at and ensure that they result in\n // errors. See also regions-free-region-ordering-callee.rs\n \n-struct Paramd<'self> { x: &'self uint }\n+struct Paramd<'a> { x: &'a uint }\n \n fn call2<'a, 'b>(a: &'a uint, b: &'b uint) {\n     let z: Option<&'b &'a uint> = None;"}, {"sha": "54352092794c6bd350d4983852211b99f6e7d24b", "filename": "src/test/compile-fail/regions-free-region-ordering-incorrect.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-incorrect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-incorrect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-incorrect.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -9,19 +9,19 @@\n // except according to those terms.\n \n // Test that free regions ordering only goes one way. That is,\n-// we have `&'a Node<'self, T>`, which implies that `'a <= 'self`,\n-// but not `'self <= 'a`. Hence returning `&self.val` (which has lifetime\n-// `'a`) where `'self` is expected yields an error.\n+// we have `&'a Node<'b, T>`, which implies that `'a <= 'b`,\n+// but not `'b <= 'a`. Hence returning `&self.val` (which has lifetime\n+// `'a`) where `'b` is expected yields an error.\n //\n // This test began its life as a test for issue #4325.\n \n-struct Node<'self, T> {\n+struct Node<'b, T> {\n   val: T,\n-  next: Option<&'self Node<'self, T>>\n+  next: Option<&'b Node<'b, T>>\n }\n \n-impl<'self, T> Node<'self, T> {\n-  fn get<'a>(&'a self) -> &'self T {\n+impl<'b, T> Node<'b, T> {\n+  fn get<'a>(&'a self) -> &'b T {\n     match self.next {\n       Some(ref next) => next.get(),\n       None => &self.val //~ ERROR cannot infer an appropriate lifetime"}, {"sha": "8f6754b34bc09ef4cae1e38cee8d8a9987eed8b5", "filename": "src/test/compile-fail/regions-glb-free-free.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-glb-free-free.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -11,9 +11,9 @@\n mod argparse {\n     extern mod extra;\n \n-    pub struct Flag<'self> {\n-        name: &'self str,\n-        desc: &'self str,\n+    pub struct Flag<'a> {\n+        name: &'a str,\n+        desc: &'a str,\n         max_count: uint,\n         value: uint\n     }\n@@ -22,8 +22,8 @@ mod argparse {\n         Flag { name: name, desc: desc, max_count: 1, value: 0 }\n     }\n \n-    impl<'self> Flag<'self> {\n-        pub fn set_desc(self, s: &str) -> Flag<'self> {\n+    impl<'a> Flag<'a> {\n+        pub fn set_desc(self, s: &str) -> Flag<'a> {\n             Flag { //~ ERROR cannot infer an appropriate lifetime\n                 name: self.name,\n                 desc: s,"}, {"sha": "72b32e4a9af4582646f725d589d7a4e6b1f70117", "filename": "src/test/compile-fail/regions-in-enums.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-in-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-in-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-in-enums.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -15,16 +15,16 @@ enum yes0<'lt> {\n     X3(&'lt uint)\n }\n \n-enum yes1<'self> {\n-    X4(&'self uint)\n+enum yes1<'a> {\n+    X4(&'a uint)\n }\n \n enum no0 {\n     X5(&'foo uint) //~ ERROR use of undeclared lifetime name `'foo`\n }\n \n enum no1 {\n-    X6(&'self uint) //~ ERROR use of undeclared lifetime name `'self`\n+    X6(&'a uint) //~ ERROR use of undeclared lifetime name `'a`\n }\n \n fn main() {}"}, {"sha": "0c5cb98e6a4653efe61bb158b76ea8a51dfd761f", "filename": "src/test/compile-fail/regions-in-structs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-in-structs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-in-structs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-in-structs.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct yes1<'self> {\n-  x: &'self uint,\n+struct yes1<'a> {\n+  x: &'a uint,\n }\n \n struct yes2<'a> {\n@@ -18,7 +18,7 @@ struct yes2<'a> {\n \n struct StructDecl {\n     a: &'a int, //~ ERROR use of undeclared lifetime name `'a`\n-    b: &'self int, //~ ERROR use of undeclared lifetime name `'self`\n+    b: &'a int, //~ ERROR use of undeclared lifetime name `'a`\n }\n \n "}, {"sha": "46de570eaf4d08278aead0e27adc11d621df5a67", "filename": "src/test/compile-fail/regions-infer-at-fn-not-param.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-infer-at-fn-not-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-infer-at-fn-not-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-at-fn-not-param.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct parameterized1<'self> {\n-    g: 'self ||\n+struct parameterized1<'a> {\n+    g: 'a ||\n }\n \n struct not_parameterized1 {"}, {"sha": "6a6b8f95e63c8a0cf01a89184a5ed9fa497e0925", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-mutability-3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-3.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -10,8 +10,8 @@\n \n #[feature(managed_boxes)];\n \n-struct invariant<'self> {\n-    f: 'static |x: @mut &'self int|\n+struct invariant<'a> {\n+    f: 'static |x: @mut &'a int|\n }\n \n fn to_same_lifetime<'r>(bi: invariant<'r>) {"}, {"sha": "4210c52e7f6e4987cad9ad64c0ee0f63a21036a6", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-mutability-4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-4.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -10,8 +10,8 @@\n \n #[feature(managed_boxes)];\n \n-struct invariant<'self> {\n-    f: 'static || -> @mut &'self int\n+struct invariant<'a> {\n+    f: 'static || -> @mut &'a int\n }\n \n fn to_same_lifetime<'r>(bi: invariant<'r>) {"}, {"sha": "b5fce9e21bda7e10824177744c10147f7aad8720", "filename": "src/test/compile-fail/regions-infer-not-param.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-not-param.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -8,18 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct direct<'self> {\n-    f: &'self int\n+struct direct<'a> {\n+    f: &'a int\n }\n \n struct indirect1 {\n     // Here the lifetime parameter of direct is bound by the fn()\n     g: 'static |direct|\n }\n \n-struct indirect2<'self> {\n-    // But here it is set to 'self\n-    g: 'static |direct<'self>|\n+struct indirect2<'a> {\n+    // But here it is set to 'a\n+    g: 'static |direct<'a>|\n }\n \n fn take_direct(p: direct) -> direct { p } //~ ERROR mismatched types"}, {"sha": "63d3338cc8955a98b7ac60686f071ef286073ef8", "filename": "src/test/compile-fail/regions-infer-paramd-indirect.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-indirect.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -13,25 +13,25 @@\n // Check that we correctly infer that b and c must be region\n // parameterized because they reference a which requires a region.\n \n-type a<'self> = &'self int;\n-type b<'self> = @a<'self>;\n+type a<'a> = &'a int;\n+type b<'a> = @a<'a>;\n \n-struct c<'self> {\n-    f: @b<'self>\n+struct c<'a> {\n+    f: @b<'a>\n }\n \n-trait set_f<'self> {\n-    fn set_f_ok(&self, b: @b<'self>);\n+trait set_f<'a> {\n+    fn set_f_ok(&self, b: @b<'a>);\n     fn set_f_bad(&self, b: @b);\n }\n \n-impl<'self> set_f<'self> for c<'self> {\n-    fn set_f_ok(&self, b: @b<'self>) {\n+impl<'a> set_f<'a> for c<'a> {\n+    fn set_f_ok(&self, b: @b<'a>) {\n         self.f = b;\n     }\n \n     fn set_f_bad(&self, b: @b) {\n-        self.f = b; //~ ERROR mismatched types: expected `@@&'self int` but found `@@&int`\n+        self.f = b; //~ ERROR mismatched types: expected `@@&'a int` but found `@@&int`\n         //~^ ERROR cannot infer an appropriate lifetime\n     }\n }"}, {"sha": "62a65596f0651878a4a4a50f7f8dda36a25567c4", "filename": "src/test/compile-fail/regions-infer-paramd-method.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-paramd-method.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -14,21 +14,21 @@\n // Here: foo is parameterized because it contains a method that\n // refers to self.\n \n-trait foo<'self> {\n-    fn self_int(self) -> &'self int;\n+trait foo<'a> {\n+    fn self_int(self) -> &'a int;\n \n     fn any_int(self) -> &int;\n }\n \n-struct with_foo<'self> {\n-    f: @foo<'self>\n+struct with_foo<'a> {\n+    f: @foo<'a>\n }\n \n trait set_foo_foo {\n     fn set_foo(&mut self, f: @foo);\n }\n \n-impl<'self> set_foo_foo for with_foo<'self> {\n+impl<'a> set_foo_foo for with_foo<'a> {\n     fn set_foo(&mut self, f: @foo) {\n         self.f = f; //~ ERROR mismatched types: expected `@foo/&self` but found `@foo/&`\n     }"}, {"sha": "32fde3747c1d3f23cac1fa045321f0a1abb5e6b9", "filename": "src/test/compile-fail/regions-steal-closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-steal-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-steal-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-steal-closure.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct closure_box<'self> {\n-    cl: 'self ||\n+struct closure_box<'a> {\n+    cl: 'a ||\n }\n \n fn box_it<'r>(x: 'r ||) -> closure_box<'r> {"}, {"sha": "8e6b821294b26d620fa0059e702ffb773fe82269", "filename": "src/test/compile-fail/regions-trait-1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-1.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -17,13 +17,13 @@ trait get_ctxt {\n     fn get_ctxt(&self) -> &ctxt;\n }\n \n-struct has_ctxt<'self> { c: &'self ctxt }\n+struct has_ctxt<'a> { c: &'a ctxt }\n \n-impl<'self> get_ctxt for has_ctxt<'self> {\n+impl<'a> get_ctxt for has_ctxt<'a> {\n \n     // Here an error occurs because we used `&self` but\n     // the definition used `&`:\n-    fn get_ctxt(&self) -> &'self ctxt { //~ ERROR method `get_ctxt` has an incompatible type\n+    fn get_ctxt(&self) -> &'a ctxt { //~ ERROR method `get_ctxt` has an incompatible type\n         self.c\n     }\n "}, {"sha": "7639bc69c212c11b20ca25157732dffc8f424ab5", "filename": "src/test/compile-fail/regions-trait-2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-trait-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-trait-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-2.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -16,13 +16,13 @@\n struct ctxt { v: uint }\n \n trait get_ctxt {\n-    fn get_ctxt(&self) -> &'self ctxt;\n+    fn get_ctxt(&self) -> &'a ctxt;\n }\n \n-struct has_ctxt<'self> { c: &'self ctxt }\n+struct has_ctxt<'a> { c: &'a ctxt }\n \n-impl<'self> get_ctxt for has_ctxt<'self> {\n-    fn get_ctxt(&self) -> &'self ctxt { self.c }\n+impl<'a> get_ctxt for has_ctxt<'a> {\n+    fn get_ctxt(&self) -> &'a ctxt { self.c }\n }\n \n fn make_gc() -> @get_ctxt  {"}, {"sha": "01195d0ac944d8bb739f967fea57285359e0dbbf", "filename": "src/test/compile-fail/regions-trait-3.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-trait-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-trait-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-trait-3.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -11,20 +11,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-trait get_ctxt<'self> {\n-    fn get_ctxt(self) -> &'self uint;\n+trait get_ctxt<'a> {\n+    fn get_ctxt(self) -> &'a uint;\n }\n \n fn make_gc1(gc: @get_ctxt<'a>) -> @get_ctxt<'b>  {\n     return gc; //~ ERROR mismatched types: expected `@get_ctxt/&b` but found `@get_ctxt/&a`\n }\n \n struct Foo {\n-    r: &'self uint\n+    r: &'a uint\n }\n \n-impl get_ctxt for Foo<'self> {\n-    fn get_ctxt(&self) -> &'self uint { self.r }\n+impl get_ctxt for Foo<'a> {\n+    fn get_ctxt(&self) -> &'a uint { self.r }\n }\n \n fn make_gc2<'a,'b>(foo: Foo<'a>) -> @get_ctxt<'b>  {"}, {"sha": "2d1de23616b2fcd0edd5649f45ba688401b74cbe", "filename": "src/test/compile-fail/regions-undeclared.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-undeclared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Fregions-undeclared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-undeclared.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -12,11 +12,11 @@ static c_x: &'blk int = &22; //~ ERROR use of undeclared lifetime name `'blk`\n \n enum EnumDecl {\n     Foo(&'a int), //~ ERROR use of undeclared lifetime name `'a`\n-    Bar(&'self int), //~ ERROR use of undeclared lifetime name `'self`\n+    Bar(&'a int), //~ ERROR use of undeclared lifetime name `'a`\n }\n \n fn fnDecl(x: &'a int, //~ ERROR use of undeclared lifetime name `'a`\n-          y: &'self int) //~ ERROR use of undeclared lifetime name `'self`\n+          y: &'a int) //~ ERROR use of undeclared lifetime name `'a`\n {}\n \n fn main() {"}, {"sha": "a4125f94cd2dde8376d081f0e85255db5b282b7e", "filename": "src/test/compile-fail/unconstrained-ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Funconstrained-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fcompile-fail%2Funconstrained-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funconstrained-ref.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct S<'self, T> {\n-    o: &'self Option<T>\n+struct S<'a, T> {\n+    o: &'a Option<T>\n }\n \n fn main() {"}, {"sha": "c263d1155093e02eee63205997f31568899d876e", "filename": "src/test/debug-info/option-like-enum.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fdebug-info%2Foption-like-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Fdebug-info%2Foption-like-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Foption-like-enum.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -45,26 +45,26 @@\n // in the null-case is not defined. So we just read the discriminator field in\n // this case (by casting the value to a memory-equivalent struct).\n \n-enum MoreFields<'self> {\n-    Full(u32, &'self int, i16),\n+enum MoreFields<'a> {\n+    Full(u32, &'a int, i16),\n     Empty\n }\n \n-struct MoreFieldsRepr<'self> {\n+struct MoreFieldsRepr<'a> {\n     a: u32,\n-    discr: &'self int,\n+    discr: &'a int,\n     b: i16\n }\n \n-enum NamedFields<'self> {\n-    Droid { id: i32, range: i64, internals: &'self int },\n+enum NamedFields<'a> {\n+    Droid { id: i32, range: i64, internals: &'a int },\n     Void\n }\n \n-struct NamedFieldsRepr<'self> {\n+struct NamedFieldsRepr<'a> {\n     id: i32,\n     range: i64,\n-    internals: &'self int\n+    internals: &'a int\n }\n \n fn main() {"}, {"sha": "668fa54315e56fe1986c17dec1a9f33c619d9b16", "filename": "src/test/run-fail/borrowck-wg-one-mut-one-imm-slice-method.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-fail%2Fborrowck-wg-one-mut-one-imm-slice-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-fail%2Fborrowck-wg-one-mut-one-imm-slice-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fborrowck-wg-one-mut-one-imm-slice-method.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -7,8 +7,8 @@ trait MyMutSlice {\n     fn my_mut_slice(self) -> Self;\n }\n \n-impl<'self, T> MyMutSlice for &'self mut [T] {\n-    fn my_mut_slice(self) -> &'self mut [T] {\n+impl<'a, T> MyMutSlice for &'a mut [T] {\n+    fn my_mut_slice(self) -> &'a mut [T] {\n         self\n     }\n }\n@@ -17,8 +17,8 @@ trait MySlice {\n     fn my_slice(self) -> Self;\n }\n \n-impl<'self, T> MySlice for &'self [T] {\n-    fn my_slice(self) -> &'self [T] {\n+impl<'a, T> MySlice for &'a [T] {\n+    fn my_slice(self) -> &'a [T] {\n         self\n     }\n }"}, {"sha": "85c5ae444ebda9553424b812a161fb4530538045", "filename": "src/test/run-pass/assignability-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fassignability-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassignability-trait.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -16,7 +16,7 @@ trait iterable<A> {\n     fn iterate(&self, blk: |x: &A| -> bool) -> bool;\n }\n \n-impl<'self,A> iterable<A> for &'self [A] {\n+impl<'a,A> iterable<A> for &'a [A] {\n     fn iterate(&self, f: |x: &A| -> bool) -> bool {\n         self.iter().advance(f)\n     }"}, {"sha": "2b9870b84a5e8f72fb2cf352c568630bd136b89b", "filename": "src/test/run-pass/auto-ref-slice-plus-ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-slice-plus-ref.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -15,11 +15,11 @@ trait MyIter {\n     fn test_imm(&self);\n }\n \n-impl<'self> MyIter for &'self [int] {\n+impl<'a> MyIter for &'a [int] {\n     fn test_imm(&self) { assert_eq!(self[0], 1) }\n }\n \n-impl<'self> MyIter for &'self str {\n+impl<'a> MyIter for &'a str {\n     fn test_imm(&self) { assert_eq!(*self, \"test\") }\n }\n "}, {"sha": "386f5f673d69a3a3f05694800039b6aac7eff989", "filename": "src/test/run-pass/borrow-by-val-method-receiver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fborrow-by-val-method-receiver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fborrow-by-val-method-receiver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrow-by-val-method-receiver.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -12,7 +12,7 @@ trait Foo {\n     fn foo(self);\n }\n \n-impl<'self> Foo for &'self [int] {\n+impl<'a> Foo for &'a [int] {\n     fn foo(self) {}\n }\n "}, {"sha": "0ad8dfc277cbbd49da6b9e4c41ae7c665a35f70d", "filename": "src/test/run-pass/const-fn-val.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fconst-fn-val.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fconst-fn-val.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-fn-val.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -12,7 +12,7 @@ fn foo() -> int {\n     return 0xca7f000d;\n }\n \n-struct Bar<'self> { f: 'self || -> int }\n+struct Bar<'a> { f: 'a || -> int }\n \n static b : Bar<'static> = Bar { f: foo };\n "}, {"sha": "6dce262dd9a888e7d6415a7c2e51ced421aa7cff", "filename": "src/test/run-pass/const-region-ptrs-noncopy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fconst-region-ptrs-noncopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fconst-region-ptrs-noncopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-region-ptrs-noncopy.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -11,7 +11,7 @@\n use std::ptr;\n \n type Big = [u64, ..8];\n-struct Pair<'self> { a: int, b: &'self Big }\n+struct Pair<'a> { a: int, b: &'a Big }\n static x: &'static Big = &([13, 14, 10, 13, 11, 14, 14, 15]);\n static y: &'static Pair<'static> = &Pair {a: 15, b: x};\n "}, {"sha": "1d7ba0ed6c71e93f90096e10a1526e9b49dd51b6", "filename": "src/test/run-pass/const-region-ptrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fconst-region-ptrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fconst-region-ptrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-region-ptrs.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct Pair<'self> { a: int, b: &'self int }\n+struct Pair<'a> { a: int, b: &'a int }\n \n static x: &'static int = &10;\n "}, {"sha": "fa6633121c8407abfb42b1e07847ba138fc66dfa", "filename": "src/test/run-pass/const-vec-of-fns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-vec-of-fns.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -20,7 +20,7 @@\n \n fn f() { }\n static bare_fns: &'static [extern fn()] = &[f, f];\n-struct S<'self>('self ||);\n+struct S<'a>('a ||);\n static closures: &'static [S<'static>] = &[S(f), S(f)];\n \n pub fn main() {"}, {"sha": "fbeb0a05340aa7a9b524c5cbff3c1b9cc1360152", "filename": "src/test/run-pass/deriving-self-lifetime-totalord-totaleq.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fderiving-self-lifetime-totalord-totaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fderiving-self-lifetime-totalord-totaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-self-lifetime-totalord-totaleq.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -11,8 +11,8 @@\n use std::cmp::{Less,Equal,Greater};\n \n #[deriving(TotalEq,TotalOrd)]\n-struct A<'self> {\n-    x: &'self int\n+struct A<'a> {\n+    x: &'a int\n }\n pub fn main() {\n     let (a, b) = (A { x: &1 }, A { x: &2 });"}, {"sha": "3d7d58878f2189eec6bdc3a0b5774007956c7b81", "filename": "src/test/run-pass/deriving-self-lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fderiving-self-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fderiving-self-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-self-lifetime.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n #[deriving(Eq,Ord)]\n-struct A<'self> {\n-    x: &'self int\n+struct A<'a> {\n+    x: &'a int\n }\n \n pub fn main() {"}, {"sha": "aa205d8cc4012056dc463fe872413817dd4eae8e", "filename": "src/test/run-pass/expr-block-generic-box2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -12,7 +12,7 @@\n \n // xfail-fast\n \n-type compare<'self, T> = 'self |T, T| -> bool;\n+type compare<'a, T> = 'a |T, T| -> bool;\n \n fn test_generic<T:Clone>(expected: T, eq: compare<T>) {\n     let actual: T = { expected.clone() };"}, {"sha": "43ddfe6d58f3c5ef840496579dd17154b113a77e", "filename": "src/test/run-pass/expr-block-generic-unique1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique1.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -10,7 +10,7 @@\n \n \n \n-type compare<'self, T> = 'self |~T, ~T| -> bool;\n+type compare<'a, T> = 'a |~T, ~T| -> bool;\n \n fn test_generic<T:Clone>(expected: ~T, eq: compare<T>) {\n     let actual: ~T = { expected.clone() };"}, {"sha": "aadca91477c7f36a253977d34300d33ef0200c90", "filename": "src/test/run-pass/expr-block-generic-unique2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-unique2.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -10,7 +10,7 @@\n \n // xfail-fast\n \n-type compare<'self, T> = 'self |T, T| -> bool;\n+type compare<'a, T> = 'a |T, T| -> bool;\n \n fn test_generic<T:Clone>(expected: T, eq: compare<T>) {\n     let actual: T = { expected.clone() };"}, {"sha": "90f6ae25f9f9ab3677ec42a9f1ccd17181e87ffa", "filename": "src/test/run-pass/expr-block-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -12,7 +12,7 @@\n // xfail-fast\n \n // Tests for standalone blocks as expressions with dynamic type sizes\n-type compare<'self, T> = 'self |T, T| -> bool;\n+type compare<'a, T> = 'a |T, T| -> bool;\n \n fn test_generic<T:Clone>(expected: T, eq: compare<T>) {\n     let actual: T = { expected.clone() };"}, {"sha": "bcac6a082604f5af5de0a9f2fa526c7d5b1eba5c", "filename": "src/test/run-pass/expr-match-generic-unique2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fexpr-match-generic-unique2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fexpr-match-generic-unique2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-match-generic-unique2.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -10,7 +10,7 @@\n \n // xfail-fast\n \n-type compare<'self, T> = 'self |T, T| -> bool;\n+type compare<'a, T> = 'a |T, T| -> bool;\n \n fn test_generic<T:Clone>(expected: T, eq: compare<T>) {\n     let actual: T = match true {"}, {"sha": "e49b1e9ed61a66419b7761d0fdbcc89bec394625", "filename": "src/test/run-pass/fn-coerce-field.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Ffn-coerce-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Ffn-coerce-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-coerce-field.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct r<'self> {\n-    field: 'self ||\n+struct r<'a> {\n+    field: 'a ||\n }\n \n pub fn main() {"}, {"sha": "e16cfecb694bc6cc0be4668912ac804f9d56b3f1", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -24,7 +24,7 @@ mod map_reduce {\n     use std::str;\n     use std::task;\n \n-    pub type putter<'self> = 'self |~str, ~str|;\n+    pub type putter<'a> = 'a |~str, ~str|;\n \n     pub type mapper = extern fn(~str, putter);\n "}, {"sha": "2ee5b2e60de3e6495b61c8c49100af1e1182f202", "filename": "src/test/run-pass/issue-2502.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fissue-2502.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fissue-2502.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2502.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct font<'self> {\n-    fontbuf: &'self ~[u8],\n+struct font<'a> {\n+    fontbuf: &'a ~[u8],\n }\n \n-impl<'self> font<'self> {\n-    pub fn buf(&self) -> &'self ~[u8] {\n+impl<'a> font<'a> {\n+    pub fn buf(&self) -> &'a ~[u8] {\n         self.fontbuf\n     }\n }"}, {"sha": "455d22fe7f0f5bff9032eb00ac676951faf334cd", "filename": "src/test/run-pass/issue-2748-a.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fissue-2748-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fissue-2748-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2748-a.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct CMap<'self> {\n-    buf: &'self [u8],\n+struct CMap<'a> {\n+    buf: &'a [u8],\n }\n \n fn CMap<'r>(buf: &'r [u8]) -> CMap<'r> {"}, {"sha": "f5d2c38147293fed1c1f72adc6da073505f547b9", "filename": "src/test/run-pass/issue-5243.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fissue-5243.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fissue-5243.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5243.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -12,8 +12,8 @@\n // enough for trans to consider this as non-monomorphic,\n // which led to various assertions and failures in turn.\n \n-struct S<'self> {\n-    v: &'self int\n+struct S<'a> {\n+    v: &'a int\n }\n \n fn f<'lt>(_s: &'lt S<'lt>) {}"}, {"sha": "2743e3357323cc8cbf7363144e0a83d0d8e5595c", "filename": "src/test/run-pass/issue-5708.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fissue-5708.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fissue-5708.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5708.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -27,11 +27,11 @@ impl Inner for int {\n     fn print(&self) { print(format!(\"Inner: {}\\n\", *self)); }\n }\n \n-struct Outer<'self> {\n-    inner: &'self Inner\n+struct Outer<'a> {\n+    inner: &'a Inner\n }\n \n-impl<'self> Outer<'self> {\n+impl<'a> Outer<'a> {\n     fn new<'r>(inner: &'r Inner) -> Outer<'r> {\n         Outer {\n             inner: inner\n@@ -49,12 +49,12 @@ pub fn main() {\n // minimal\n trait MyTrait<T> { }\n \n-pub struct MyContainer<'self, T> {\n-    foos: ~[&'self MyTrait<T>],\n+pub struct MyContainer<'a, T> {\n+    foos: ~[&'a MyTrait<T>],\n }\n \n-impl<'self, T> MyContainer<'self, T> {\n-    pub fn add (&mut self, foo: &'self MyTrait<T>) {\n+impl<'a, T> MyContainer<'a, T> {\n+    pub fn add (&mut self, foo: &'a MyTrait<T>) {\n         self.foos.push(foo);\n     }\n }"}, {"sha": "593ca9de3af6f5a28f54b19061f52f0b19d7f402", "filename": "src/test/run-pass/issue-5884.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fissue-5884.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fissue-5884.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5884.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -14,9 +14,9 @@ pub struct Foo {\n     a: int,\n }\n \n-struct Bar<'self> {\n+struct Bar<'a> {\n     a: ~Option<int>,\n-    b: &'self Foo,\n+    b: &'a Foo,\n }\n \n fn check(a: @Foo) {"}, {"sha": "2bd233c9aedfad0b2f198c34c5ff6787103253c7", "filename": "src/test/run-pass/issue-7012.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fissue-7012.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fissue-7012.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7012.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -15,7 +15,7 @@ The expected behaviour would be that test==test1, therefore 'true'\n would be printed, however the below prints false.\n */\n \n-struct signature<'self> { pattern : &'self [u32] }\n+struct signature<'a> { pattern : &'a [u32] }\n \n static test1: signature<'static> =  signature {\n   pattern: &[0x243f6a88u32,0x85a308d3u32,0x13198a2eu32,0x03707344u32,0xa4093822u32,0x299f31d0u32]"}, {"sha": "1f172725b5ead2a978cda926047d72cdd2bb5006", "filename": "src/test/run-pass/issue-7563.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fissue-7563.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fissue-7563.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-7563.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -3,16 +3,16 @@ trait IDummy {\n }\n \n struct A { a: int }\n-struct B<'self> { b: int, pa: &'self A }\n+struct B<'a> { b: int, pa: &'a A }\n \n     impl IDummy for A {\n         fn do_nothing(&self) {\n             println(\"A::do_nothing() is called\");\n         }\n     }\n \n-impl<'self> B<'self> {\n-    fn get_pa(&self) -> &'self IDummy { self.pa as &'self IDummy }\n+impl<'a> B<'a> {\n+    fn get_pa(&self) -> &'a IDummy { self.pa as &'a IDummy }\n }\n \n pub fn main() {"}, {"sha": "3ca6c806ef59d0a4c2430bb03f0d35792502230e", "filename": "src/test/run-pass/issue-8249.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fissue-8249.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fissue-8249.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-8249.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -12,8 +12,8 @@ trait A {}\n struct B;\n impl A for B {}\n \n-struct C<'self> {\n-    foo: &'self mut A,\n+struct C<'a> {\n+    foo: &'a mut A,\n }\n \n fn foo(a: &mut A) {"}, {"sha": "d2bf6e29f87321a209a32e577535790aea88e2f9", "filename": "src/test/run-pass/issue-9382.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fissue-9382.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fissue-9382.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9382.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -15,13 +15,13 @@\n // from a vector to a slice. The drop glue was being invoked on\n // the temporary slice with a wrong type, triggering an LLVM assert.\n \n-struct Thing1<'self> {\n-    baz: &'self [~int],\n+struct Thing1<'a> {\n+    baz: &'a [~int],\n     bar: ~u64,\n }\n \n-struct Thing2<'self> {\n-    baz: &'self [~int],\n+struct Thing2<'a> {\n+    baz: &'a [~int],\n     bar: u64,\n }\n "}, {"sha": "7d07cab433f616e700e3b85fbeaecd47ff5ed3ca", "filename": "src/test/run-pass/rcvr-borrowed-to-region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-region.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -15,7 +15,7 @@ trait get {\n // Note: impl on a slice; we're checking that the pointers below\n // correctly get borrowed to `&`. (similar to impling for `int`, with\n // `&self` instead of `self`.)\n-impl<'self> get for &'self int {\n+impl<'a> get for &'a int {\n     fn get(self) -> int {\n         return *self;\n     }"}, {"sha": "050a51c958d57d4ad74997aaa47c910868f14a63", "filename": "src/test/run-pass/rcvr-borrowed-to-slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -13,7 +13,7 @@ trait sum {\n }\n \n // Note: impl on a slice\n-impl<'self> sum for &'self [int] {\n+impl<'a> sum for &'a [int] {\n     fn sum_(self) -> int {\n         self.iter().fold(0, |a, &b| a + b)\n     }"}, {"sha": "718394e943fe95bcc2bc05f821b70eb0696deae4", "filename": "src/test/run-pass/regions-copy-closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fregions-copy-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fregions-copy-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-copy-closure.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct closure_box<'self> {\n-    cl: 'self ||,\n+struct closure_box<'a> {\n+    cl: 'a ||,\n }\n \n fn box_it<'r>(x: 'r ||) -> closure_box<'r> {"}, {"sha": "fa795c2c87ba366f3181de7de5cae6635b11c74d", "filename": "src/test/run-pass/regions-creating-enums2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fregions-creating-enums2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fregions-creating-enums2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-creating-enums2.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum ast<'self> {\n+enum ast<'a> {\n     num(uint),\n-    add(&'self ast<'self>, &'self ast<'self>)\n+    add(&'a ast<'a>, &'a ast<'a>)\n }\n \n fn mk_add_ok<'r>(x: &'r ast<'r>, y: &'r ast<'r>) -> ast<'r> {"}, {"sha": "a95199901d51c3f0a712e212566a5636ac3c3042", "filename": "src/test/run-pass/regions-creating-enums5.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fregions-creating-enums5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fregions-creating-enums5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-creating-enums5.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum ast<'self> {\n+enum ast<'a> {\n     num(uint),\n-    add(&'self ast<'self>, &'self ast<'self>)\n+    add(&'a ast<'a>, &'a ast<'a>)\n }\n \n fn mk_add_ok<'a>(x: &'a ast<'a>, y: &'a ast<'a>, _z: &ast) -> ast<'a> {"}, {"sha": "7e328f3bb0354ce453f80f52b913e0dfdb26acf1", "filename": "src/test/run-pass/regions-infer-contravariance-due-to-ret.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fregions-infer-contravariance-due-to-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fregions-infer-contravariance-due-to-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-infer-contravariance-due-to-ret.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct boxed_int<'self> {\n-    f: &'self int,\n+struct boxed_int<'a> {\n+    f: &'a int,\n }\n \n fn max<'r>(bi: &'r boxed_int, f: &'r int) -> int {"}, {"sha": "8cac6e8558f310b0e93f904a5aa69aa81c37f999", "filename": "src/test/run-pass/regions-mock-trans.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -14,13 +14,13 @@ use std::mem;\n \n struct arena(());\n \n-struct Bcx<'self> {\n-    fcx: &'self Fcx<'self>\n+struct Bcx<'a> {\n+    fcx: &'a Fcx<'a>\n }\n \n-struct Fcx<'self> {\n-    arena: &'self arena,\n-    ccx: &'self Ccx\n+struct Fcx<'a> {\n+    arena: &'a arena,\n+    ccx: &'a Ccx\n }\n \n struct Ccx {"}, {"sha": "784424ad54c8aa1ec1652d7242e8c167fd495ee1", "filename": "src/test/run-pass/regions-nullary-variant.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fregions-nullary-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fregions-nullary-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-nullary-variant.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum roption<'self> {\n-    a, b(&'self uint)\n+enum roption<'a> {\n+    a, b(&'a uint)\n }\n \n fn mk<'r>(cond: bool, ptr: &'r uint) -> roption<'r> {"}, {"sha": "cc8174d0d320379ed7a451bdb651c967050d54b7", "filename": "src/test/run-pass/regions-self-impls.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fregions-self-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fregions-self-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-self-impls.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -8,16 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct Clam<'self> {\n-    chowder: &'self int\n+struct Clam<'a> {\n+    chowder: &'a int\n }\n \n-trait get_chowder<'self> {\n-    fn get_chowder(&self) -> &'self int;\n+trait get_chowder<'a> {\n+    fn get_chowder(&self) -> &'a int;\n }\n \n-impl<'self> get_chowder<'self> for Clam<'self> {\n-    fn get_chowder(&self) -> &'self int { return self.chowder; }\n+impl<'a> get_chowder<'a> for Clam<'a> {\n+    fn get_chowder(&self) -> &'a int { return self.chowder; }\n }\n \n pub fn main() {"}, {"sha": "6e2d62cce927660f8998dcdf5bc2e8b6cdfb54e1", "filename": "src/test/run-pass/regions-self-in-enums.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fregions-self-in-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fregions-self-in-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-self-in-enums.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-enum int_wrapper<'self> {\n-    int_wrapper_ctor(&'self int)\n+enum int_wrapper<'a> {\n+    int_wrapper_ctor(&'a int)\n }\n \n pub fn main() {"}, {"sha": "9d994c423c9a0034df5555453d569173fac49009", "filename": "src/test/run-pass/regions-static-closure.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fregions-static-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fregions-static-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-static-closure.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct closure_box<'self> {\n-    cl: 'self ||,\n+struct closure_box<'a> {\n+    cl: 'a ||,\n }\n \n fn box_it<'r>(x: 'r ||) -> closure_box<'r> {"}, {"sha": "86656b011dd4d8f877dd281afaa96c44f202d8cd", "filename": "src/test/run-pass/struct-field-assignability.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fstruct-field-assignability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Fstruct-field-assignability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-field-assignability.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -1,5 +1,5 @@\n-struct Foo<'self> {\n-    x: &'self int\n+struct Foo<'a> {\n+    x: &'a int\n }\n \n pub fn main() {"}, {"sha": "1c3eafb203291177bebf235abebba52fa5e2f215", "filename": "src/test/run-pass/unfold-cross-crate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Funfold-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5731ca3078318a66a13208133d8839a9f9f92629/src%2Ftest%2Frun-pass%2Funfold-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funfold-cross-crate.rs?ref=5731ca3078318a66a13208133d8839a9f9f92629", "patch": "@@ -10,7 +10,7 @@\n \n use std::iter::Unfold;\n \n-// Unfold had a bug with 'self that mean it didn't work\n+// Unfold had a bug with 'a that mean it didn't work\n // cross-crate\n \n pub fn main() {"}]}