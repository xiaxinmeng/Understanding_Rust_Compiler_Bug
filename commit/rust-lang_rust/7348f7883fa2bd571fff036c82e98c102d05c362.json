{"sha": "7348f7883fa2bd571fff036c82e98c102d05c362", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczNDhmNzg4M2ZhMmJkNTcxZmZmMDM2YzgyZTk4YzEwMmQwNWMzNjI=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2018-12-23T11:05:54Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2018-12-23T12:48:04Z"}, "message": "Add testing infrastructure for type inference\n\n - move dir_tests to test_utils for that.", "tree": {"sha": "e7882097498b6d85e631d570dac0d8a89cd24875", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7882097498b6d85e631d570dac0d8a89cd24875"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7348f7883fa2bd571fff036c82e98c102d05c362", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7348f7883fa2bd571fff036c82e98c102d05c362", "html_url": "https://github.com/rust-lang/rust/commit/7348f7883fa2bd571fff036c82e98c102d05c362", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7348f7883fa2bd571fff036c82e98c102d05c362/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3899898d75176ce3cd87f9e2acecd7e3a987dda5", "url": "https://api.github.com/repos/rust-lang/rust/commits/3899898d75176ce3cd87f9e2acecd7e3a987dda5", "html_url": "https://github.com/rust-lang/rust/commit/3899898d75176ce3cd87f9e2acecd7e3a987dda5"}], "stats": {"total": 346, "additions": 222, "deletions": 124}, "files": [{"sha": "4e0631679e5bd2a9e0cf57cae62a3b2680e0d137", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7348f7883fa2bd571fff036c82e98c102d05c362/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7348f7883fa2bd571fff036c82e98c102d05c362/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=7348f7883fa2bd571fff036c82e98c102d05c362", "patch": "@@ -5,7 +5,8 @@ use std::{\n \n use ra_editor::{self, find_node_at_offset, FileSymbol, LineIndex, LocalEdit};\n use ra_syntax::{\n-    ast::{self, ArgListOwner, Expr, NameOwner},\n+    ast::{self, ArgListOwner, Expr, NameOwner, FnDef},\n+    algo::find_covering_node,\n     AstNode, SourceFileNode,\n     SyntaxKind::*,\n     SyntaxNodeRef, TextRange, TextUnit,\n@@ -510,6 +511,17 @@ impl AnalysisImpl {\n         Ok(None)\n     }\n \n+    pub fn type_of(&self, file_id: FileId, range: TextRange) -> Cancelable<Option<String>> {\n+        let file = self.db.source_file(file_id);\n+        let syntax = file.syntax();\n+        let node = find_covering_node(syntax, range);\n+        let parent_fn = node.ancestors().filter_map(FnDef::cast).next();\n+        let parent_fn = if let Some(p) = parent_fn { p } else { return Ok(None) };\n+        let function = ctry!(source_binder::function_from_source(&*self.db, file_id, parent_fn)?);\n+        let infer = function.infer(&*self.db);\n+        Ok(infer.type_of_node(node).map(|t| t.to_string()))\n+    }\n+\n     fn index_resolve(&self, name_ref: ast::NameRef) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n         let name = name_ref.text();\n         let mut query = Query::new(name.to_string());"}, {"sha": "8308981405b52934ff9c911a845fd520ef41aa47", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7348f7883fa2bd571fff036c82e98c102d05c362/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7348f7883fa2bd571fff036c82e98c102d05c362/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=7348f7883fa2bd571fff036c82e98c102d05c362", "patch": "@@ -366,6 +366,9 @@ impl Analysis {\n     ) -> Cancelable<Option<(FnSignatureInfo, Option<usize>)>> {\n         self.imp.resolve_callable(position)\n     }\n+    pub fn type_of(&self, file_id: FileId, range: TextRange) -> Cancelable<Option<String>> {\n+        self.imp.type_of(file_id, range)\n+    }\n }\n \n pub struct LibraryData {"}, {"sha": "3020ee793e46633395893629d7ddecb8103eb8fa", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7348f7883fa2bd571fff036c82e98c102d05c362/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7348f7883fa2bd571fff036c82e98c102d05c362/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=7348f7883fa2bd571fff036c82e98c102d05c362", "patch": "@@ -24,6 +24,15 @@ impl MockDatabase {\n         (db, source_root)\n     }\n \n+    pub(crate) fn with_single_file(text: &str) -> (MockDatabase, SourceRoot, FileId) {\n+        let mut db = MockDatabase::default();\n+        let mut source_root = SourceRoot::default();\n+        let file_id = db.add_file(&mut source_root, \"/main.rs\", text);\n+        db.query_mut(ra_db::SourceRootQuery)\n+            .set(WORKSPACE, Arc::new(source_root.clone()));\n+        (db, source_root, file_id)\n+    }\n+\n     pub(crate) fn with_position(fixture: &str) -> (MockDatabase, FilePosition) {\n         let (db, _, position) = MockDatabase::from_fixture(fixture);\n         let position = position.expect(\"expected a marker ( <|> )\");"}, {"sha": "66b204dcd706dcaa4705517e1fa0ecfe7a37e0d0", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7348f7883fa2bd571fff036c82e98c102d05c362/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7348f7883fa2bd571fff036c82e98c102d05c362/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=7348f7883fa2bd571fff036c82e98c102d05c362", "patch": "@@ -6,6 +6,7 @@ use rustc_hash::{FxHashMap, FxHashSet};\n \n use std::sync::Arc;\n use std::collections::HashMap;\n+use std::fmt;\n \n use ra_db::LocalSyntaxPtr;\n use ra_syntax::{\n@@ -184,11 +185,40 @@ impl Ty {\n     }\n }\n \n+impl fmt::Display for Ty {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self {\n+            Ty::Bool => write!(f, \"bool\"),\n+            Ty::Char => write!(f, \"char\"),\n+            Ty::Int(t) => write!(f, \"{}\", t.ty_to_string()),\n+            Ty::Uint(t) => write!(f, \"{}\", t.ty_to_string()),\n+            Ty::Float(t) => write!(f, \"{}\", t.ty_to_string()),\n+            Ty::Str => write!(f, \"str\"),\n+            Ty::Slice(t) => write!(f, \"[{}]\", t),\n+            Ty::Never => write!(f, \"!\"),\n+            Ty::Tuple(ts) => {\n+                write!(f, \"(\")?;\n+                for t in ts {\n+                    write!(f, \"{},\", t)?;\n+                }\n+                write!(f, \")\")\n+            }\n+            Ty::Unknown => write!(f, \"[unknown]\")\n+        }\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct InferenceResult {\n     type_for: FxHashMap<LocalSyntaxPtr, Ty>,\n }\n \n+impl InferenceResult {\n+    pub fn type_of_node(&self, node: SyntaxNodeRef) -> Option<Ty> {\n+        self.type_for.get(&LocalSyntaxPtr::new(node)).cloned()\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct InferenceContext {\n     scopes: Arc<FnScopes>,"}, {"sha": "98eedaa3f9cf40d04c7b98227c9beb35003e4a44", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 39, "deletions": 23, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/7348f7883fa2bd571fff036c82e98c102d05c362/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7348f7883fa2bd571fff036c82e98c102d05c362/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=7348f7883fa2bd571fff036c82e98c102d05c362", "patch": "@@ -1,8 +1,11 @@\n+use std::fmt::Write;\n use std::sync::Arc;\n+use std::path::{Path, PathBuf};\n \n use salsa::Database;\n use ra_db::{FilesDatabase, CrateGraph, SyntaxDatabase};\n use ra_syntax::{SmolStr, algo::visit::{visitor, Visitor}, ast::{self, AstNode}};\n+use test_utils::{project_dir, dir_tests};\n use relative_path::RelativePath;\n \n use crate::{source_binder, mock::WORKSPACE, module::ModuleSourceNode};\n@@ -13,33 +16,46 @@ use crate::{\n     mock::MockDatabase,\n };\n \n-fn infer_all_fns(fixture: &str) -> () {\n-    let (db, source_root) = MockDatabase::with_files(fixture);\n-    for &file_id in source_root.files.values() {\n-        let source_file = db.source_file(file_id);\n-        for fn_def in source_file.syntax().descendants().filter_map(ast::FnDef::cast) {\n-            let func = source_binder::function_from_source(&db, file_id, fn_def).unwrap().unwrap();\n-            let inference_result = func.infer(&db);\n-            for (syntax_ptr, ty) in &inference_result.type_for {\n-                let node = syntax_ptr.resolve(&source_file);\n-                eprintln!(\"{} '{}': {:?}\", syntax_ptr.range(), node.text(), ty);\n-            }\n+fn infer_file(content: &str) -> String {\n+    let (db, source_root, file_id) = MockDatabase::with_single_file(content);\n+    let source_file = db.source_file(file_id);\n+    let mut acc = String::new();\n+    for fn_def in source_file.syntax().descendants().filter_map(ast::FnDef::cast) {\n+        let func = source_binder::function_from_source(&db, file_id, fn_def).unwrap().unwrap();\n+        let inference_result = func.infer(&db);\n+        for (syntax_ptr, ty) in &inference_result.type_for {\n+            let node = syntax_ptr.resolve(&source_file);\n+            write!(acc, \"{} '{}': {}\\n\", syntax_ptr.range(), ellipsize(node.text().to_string().replace(\"\\n\", \" \"), 15), ty);\n         }\n     }\n+    acc\n+}\n+\n+fn ellipsize(mut text: String, max_len: usize) -> String {\n+    if text.len() <= max_len {\n+        return text;\n+    }\n+    let ellipsis = \"...\";\n+    let e_len = ellipsis.len();\n+    let mut prefix_len = (max_len - e_len) / 2;\n+    while !text.is_char_boundary(prefix_len) {\n+        prefix_len += 1;\n+    }\n+    let mut suffix_len = max_len - e_len - prefix_len;\n+    while !text.is_char_boundary(text.len() - suffix_len) {\n+        suffix_len += 1;\n+    }\n+    text.replace_range(prefix_len..text.len() - suffix_len, ellipsis);\n+    text\n }\n \n #[test]\n-fn infer_smoke_test() {\n-    let text = \"\n-        //- /lib.rs\n-        fn foo(x: u32, y: !) -> i128 {\n-            x;\n-            y;\n-            return 1;\n-            \\\"hello\\\";\n-            0\n-        }\n-    \";\n+pub fn infer_tests() {\n+    dir_tests(&test_data_dir(), &[\".\"], |text, _path| {\n+        infer_file(text)\n+    });\n+}\n \n-    infer_all_fns(text);\n+fn test_data_dir() -> PathBuf {\n+    project_dir().join(\"crates/ra_hir/src/ty/tests/data\")\n }"}, {"sha": "59a60d0313da7f3d11b7d74a96af31f245ed36e0", "filename": "crates/ra_hir/src/ty/tests/data/0001_basics.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7348f7883fa2bd571fff036c82e98c102d05c362/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0001_basics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7348f7883fa2bd571fff036c82e98c102d05c362/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0001_basics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0001_basics.rs?ref=7348f7883fa2bd571fff036c82e98c102d05c362", "patch": "@@ -0,0 +1,11 @@\n+\n+fn test(a: u32, b: isize, c: !, d: &str) {\n+    a;\n+    b;\n+    c;\n+    d;\n+    1usize;\n+    1isize;\n+    \"test\";\n+    1.0f32;\n+}"}, {"sha": "0c46f243a8e04645f083df0b10587f7038c7591f", "filename": "crates/ra_hir/src/ty/tests/data/0001_basics.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7348f7883fa2bd571fff036c82e98c102d05c362/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0001_basics.txt", "raw_url": "https://github.com/rust-lang/rust/raw/7348f7883fa2bd571fff036c82e98c102d05c362/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0001_basics.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0001_basics.txt?ref=7348f7883fa2bd571fff036c82e98c102d05c362", "patch": "@@ -0,0 +1,13 @@\n+[33; 34) 'd': [unknown]\n+[88; 94) '1isize': [unknown]\n+[48; 49) 'a': u32\n+[55; 56) 'b': isize\n+[112; 118) '1.0f32': [unknown]\n+[76; 82) '1usize': [unknown]\n+[9; 10) 'a': u32\n+[27; 28) 'c': !\n+[62; 63) 'c': !\n+[17; 18) 'b': isize\n+[100; 106) '\"test\"': [unknown]\n+[42; 121) '{     ...f32; }': ()\n+[69; 70) 'd': [unknown]"}, {"sha": "9d94a1a23c3aca1b69a4bb5c9cbef9ce5664edb3", "filename": "crates/ra_syntax/tests/test.rs", "status": "modified", "additions": 5, "deletions": 100, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/7348f7883fa2bd571fff036c82e98c102d05c362/crates%2Fra_syntax%2Ftests%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7348f7883fa2bd571fff036c82e98c102d05c362/crates%2Fra_syntax%2Ftests%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftests%2Ftest.rs?ref=7348f7883fa2bd571fff036c82e98c102d05c362", "patch": "@@ -9,22 +9,23 @@ use std::{\n     path::{Path, PathBuf, Component},\n };\n \n+use test_utils::{project_dir, dir_tests, read_text, collect_tests};\n use ra_syntax::{\n     utils::{check_fuzz_invariants, dump_tree},\n     SourceFileNode,\n };\n \n #[test]\n fn lexer_tests() {\n-    dir_tests(&[\"lexer\"], |text, _| {\n+    dir_tests(&test_data_dir(), &[\"lexer\"], |text, _| {\n         let tokens = ra_syntax::tokenize(text);\n         dump_tokens(&tokens, text)\n     })\n }\n \n #[test]\n fn parser_tests() {\n-    dir_tests(&[\"parser/inline/ok\", \"parser/ok\"], |text, path| {\n+    dir_tests(&test_data_dir(), &[\"parser/inline/ok\", \"parser/ok\"], |text, path| {\n         let file = SourceFileNode::parse(text);\n         let errors = file.errors();\n         assert_eq!(\n@@ -35,7 +36,7 @@ fn parser_tests() {\n         );\n         dump_tree(file.syntax())\n     });\n-    dir_tests(&[\"parser/err\", \"parser/inline/err\"], |text, path| {\n+    dir_tests(&test_data_dir(), &[\"parser/err\", \"parser/inline/err\"], |text, path| {\n         let file = SourceFileNode::parse(text);\n         let errors = file.errors();\n         assert_ne!(\n@@ -50,7 +51,7 @@ fn parser_tests() {\n \n #[test]\n fn parser_fuzz_tests() {\n-    for (_, text) in collect_tests(&[\"parser/fuzz-failures\"]) {\n+    for (_, text) in collect_tests(&test_data_dir(), &[\"parser/fuzz-failures\"]) {\n         check_fuzz_invariants(&text)\n     }\n }\n@@ -92,102 +93,6 @@ fn self_hosting_parsing() {\n         \"self_hosting_parsing found too few files - is it running in the right directory?\"\n     )\n }\n-/// Read file and normalize newlines.\n-///\n-/// `rustc` seems to always normalize `\\r\\n` newlines to `\\n`:\n-///\n-/// ```\n-/// let s = \"\n-/// \";\n-/// assert_eq!(s.as_bytes(), &[10]);\n-/// ```\n-///\n-/// so this should always be correct.\n-fn read_text(path: &Path) -> String {\n-    fs::read_to_string(path)\n-        .expect(&format!(\"File at {:?} should be valid\", path))\n-        .replace(\"\\r\\n\", \"\\n\")\n-}\n-\n-fn dir_tests<F>(paths: &[&str], f: F)\n-where\n-    F: Fn(&str, &Path) -> String,\n-{\n-    for (path, input_code) in collect_tests(paths) {\n-        let parse_tree = f(&input_code, &path);\n-        let path = path.with_extension(\"txt\");\n-        if !path.exists() {\n-            println!(\"\\nfile: {}\", path.display());\n-            println!(\"No .txt file with expected result, creating...\\n\");\n-            println!(\"{}\\n{}\", input_code, parse_tree);\n-            fs::write(&path, &parse_tree).unwrap();\n-            panic!(\"No expected result\")\n-        }\n-        let expected = read_text(&path);\n-        let expected = expected.as_str();\n-        let parse_tree = parse_tree.as_str();\n-        assert_equal_text(expected, parse_tree, &path);\n-    }\n-}\n-\n-const REWRITE: bool = false;\n-\n-fn assert_equal_text(expected: &str, actual: &str, path: &Path) {\n-    if expected == actual {\n-        return;\n-    }\n-    let dir = project_dir();\n-    let pretty_path = path.strip_prefix(&dir).unwrap_or_else(|_| path);\n-    if expected.trim() == actual.trim() {\n-        println!(\"whitespace difference, rewriting\");\n-        println!(\"file: {}\\n\", pretty_path.display());\n-        fs::write(path, actual).unwrap();\n-        return;\n-    }\n-    if REWRITE {\n-        println!(\"rewriting {}\", pretty_path.display());\n-        fs::write(path, actual).unwrap();\n-        return;\n-    }\n-    assert_eq_text!(expected, actual, \"file: {}\", pretty_path.display());\n-}\n-\n-fn collect_tests(paths: &[&str]) -> Vec<(PathBuf, String)> {\n-    paths\n-        .iter()\n-        .flat_map(|path| {\n-            let path = test_data_dir().join(path);\n-            test_from_dir(&path).into_iter()\n-        })\n-        .map(|path| {\n-            let text = read_text(&path);\n-            (path, text)\n-        })\n-        .collect()\n-}\n-\n-fn test_from_dir(dir: &Path) -> Vec<PathBuf> {\n-    let mut acc = Vec::new();\n-    for file in fs::read_dir(&dir).unwrap() {\n-        let file = file.unwrap();\n-        let path = file.path();\n-        if path.extension().unwrap_or_default() == \"rs\" {\n-            acc.push(path);\n-        }\n-    }\n-    acc.sort();\n-    acc\n-}\n-\n-fn project_dir() -> PathBuf {\n-    let dir = env!(\"CARGO_MANIFEST_DIR\");\n-    PathBuf::from(dir)\n-        .parent()\n-        .unwrap()\n-        .parent()\n-        .unwrap()\n-        .to_owned()\n-}\n \n fn test_data_dir() -> PathBuf {\n     project_dir().join(\"crates/ra_syntax/tests/data\")"}, {"sha": "012b1d0b40218dd3889be719c80ae246bba92a3a", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/7348f7883fa2bd571fff036c82e98c102d05c362/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7348f7883fa2bd571fff036c82e98c102d05c362/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=7348f7883fa2bd571fff036c82e98c102d05c362", "patch": "@@ -1,4 +1,6 @@\n use std::fmt;\n+use std::fs;\n+use std::path::{Path, PathBuf};\n \n use itertools::Itertools;\n use text_unit::{TextRange, TextUnit};\n@@ -262,3 +264,100 @@ pub fn find_mismatch<'a>(expected: &'a Value, actual: &'a Value) -> Option<(&'a\n         _ => Some((expected, actual)),\n     }\n }\n+\n+pub fn dir_tests<F>(test_data_dir: &Path, paths: &[&str], f: F)\n+where\n+    F: Fn(&str, &Path) -> String,\n+{\n+    for (path, input_code) in collect_tests(test_data_dir, paths) {\n+        let parse_tree = f(&input_code, &path);\n+        let path = path.with_extension(\"txt\");\n+        if !path.exists() {\n+            println!(\"\\nfile: {}\", path.display());\n+            println!(\"No .txt file with expected result, creating...\\n\");\n+            println!(\"{}\\n{}\", input_code, parse_tree);\n+            fs::write(&path, &parse_tree).unwrap();\n+            panic!(\"No expected result\")\n+        }\n+        let expected = read_text(&path);\n+        let expected = expected.as_str();\n+        let parse_tree = parse_tree.as_str();\n+        assert_equal_text(expected, parse_tree, &path);\n+    }\n+}\n+\n+pub fn collect_tests(test_data_dir: &Path, paths: &[&str]) -> Vec<(PathBuf, String)> {\n+    paths\n+        .iter()\n+        .flat_map(|path| {\n+            let path = test_data_dir.to_owned().join(path);\n+            test_from_dir(&path).into_iter()\n+        })\n+        .map(|path| {\n+            let text = read_text(&path);\n+            (path, text)\n+        })\n+        .collect()\n+}\n+\n+fn test_from_dir(dir: &Path) -> Vec<PathBuf> {\n+    let mut acc = Vec::new();\n+    for file in fs::read_dir(&dir).unwrap() {\n+        let file = file.unwrap();\n+        let path = file.path();\n+        if path.extension().unwrap_or_default() == \"rs\" {\n+            acc.push(path);\n+        }\n+    }\n+    acc.sort();\n+    acc\n+}\n+\n+pub fn project_dir() -> PathBuf {\n+    let dir = env!(\"CARGO_MANIFEST_DIR\");\n+    PathBuf::from(dir)\n+        .parent()\n+        .unwrap()\n+        .parent()\n+        .unwrap()\n+        .to_owned()\n+}\n+\n+/// Read file and normalize newlines.\n+///\n+/// `rustc` seems to always normalize `\\r\\n` newlines to `\\n`:\n+///\n+/// ```\n+/// let s = \"\n+/// \";\n+/// assert_eq!(s.as_bytes(), &[10]);\n+/// ```\n+///\n+/// so this should always be correct.\n+pub fn read_text(path: &Path) -> String {\n+    fs::read_to_string(path)\n+        .expect(&format!(\"File at {:?} should be valid\", path))\n+        .replace(\"\\r\\n\", \"\\n\")\n+}\n+\n+const REWRITE: bool = false;\n+\n+fn assert_equal_text(expected: &str, actual: &str, path: &Path) {\n+    if expected == actual {\n+        return;\n+    }\n+    let dir = project_dir();\n+    let pretty_path = path.strip_prefix(&dir).unwrap_or_else(|_| path);\n+    if expected.trim() == actual.trim() {\n+        println!(\"whitespace difference, rewriting\");\n+        println!(\"file: {}\\n\", pretty_path.display());\n+        fs::write(path, actual).unwrap();\n+        return;\n+    }\n+    if REWRITE {\n+        println!(\"rewriting {}\", pretty_path.display());\n+        fs::write(path, actual).unwrap();\n+        return;\n+    }\n+    assert_eq_text!(expected, actual, \"file: {}\", pretty_path.display());\n+}"}]}