{"sha": "820a41580efb5c67df02dc511c2465d71b0e9f61", "node_id": "C_kwDOAAsO6NoAKDgyMGE0MTU4MGVmYjVjNjdkZjAyZGM1MTFjMjQ2NWQ3MWIwZTlmNjE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-11-20T17:21:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-20T17:21:48Z"}, "message": "Rollup merge of #104564 - RalfJung:either, r=oli-obk\n\ninterpret: use Either over Result when it is not representing an error condition\n\nr? `@oli-obk`", "tree": {"sha": "a5259817606fa963055df257fa35ac44b59d69c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5259817606fa963055df257fa35ac44b59d69c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/820a41580efb5c67df02dc511c2465d71b0e9f61", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjemIsCRBK7hj4Ov3rIwAAOF8IAFPf0BdgppRDmvhbE7B/x4Fd\nckKjJMMW2a7EwTMKm3q56P20CpVrUpkNmFkgBhhlQ/n3rXyLIlwfzYNskNdAytww\nzk4Q0ZigpltrgHilTO/lFP5V1Xd3BJc1ollEOp8aplb+KXF9qIClRznLIYMZea/G\nZwkE2LgHNcWTes9GZ7xild8CGnPEzrwek4TfHosyTIfoVr4mcbUCX5txGITzLh1h\nkAX/aWzgdGDpgRyKj94NUkVt7eNSx7zSDfUA+I7nj9wcvZXEq6YPZzam9O0DmMb5\nojRGBKWVVFDK00zUzPku5QnNPZxVnPPwnQRgmVJAh5EB7o/J0iPdWEf9L21cl0w=\n=4XZ+\n-----END PGP SIGNATURE-----\n", "payload": "tree a5259817606fa963055df257fa35ac44b59d69c1\nparent 379d3365fd16a9faf90c98a74f5e7d7b5c0ede23\nparent 09a887cebf917af04a45d37d9c39d6bf3072f6e1\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1668964908 +0100\ncommitter GitHub <noreply@github.com> 1668964908 +0100\n\nRollup merge of #104564 - RalfJung:either, r=oli-obk\n\ninterpret: use Either over Result when it is not representing an error condition\n\nr? `@oli-obk`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/820a41580efb5c67df02dc511c2465d71b0e9f61", "html_url": "https://github.com/rust-lang/rust/commit/820a41580efb5c67df02dc511c2465d71b0e9f61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/820a41580efb5c67df02dc511c2465d71b0e9f61/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "379d3365fd16a9faf90c98a74f5e7d7b5c0ede23", "url": "https://api.github.com/repos/rust-lang/rust/commits/379d3365fd16a9faf90c98a74f5e7d7b5c0ede23", "html_url": "https://github.com/rust-lang/rust/commit/379d3365fd16a9faf90c98a74f5e7d7b5c0ede23"}, {"sha": "09a887cebf917af04a45d37d9c39d6bf3072f6e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/09a887cebf917af04a45d37d9c39d6bf3072f6e1", "html_url": "https://github.com/rust-lang/rust/commit/09a887cebf917af04a45d37d9c39d6bf3072f6e1"}], "stats": {"total": 230, "additions": 128, "deletions": 102}, "files": [{"sha": "fb6140e74fea4bb65d291a6c50706e75908b1927", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/820a41580efb5c67df02dc511c2465d71b0e9f61/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/820a41580efb5c67df02dc511c2465d71b0e9f61/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=820a41580efb5c67df02dc511c2465d71b0e9f61", "patch": "@@ -3433,6 +3433,7 @@ dependencies = [\n name = \"rustc_const_eval\"\n version = \"0.0.0\"\n dependencies = [\n+ \"either\",\n  \"rustc_apfloat\",\n  \"rustc_ast\",\n  \"rustc_attr\",\n@@ -3927,6 +3928,7 @@ dependencies = [\n name = \"rustc_mir_build\"\n version = \"0.0.0\"\n dependencies = [\n+ \"either\",\n  \"rustc_apfloat\",\n  \"rustc_arena\",\n  \"rustc_ast\",\n@@ -3973,6 +3975,7 @@ name = \"rustc_mir_transform\"\n version = \"0.0.0\"\n dependencies = [\n  \"coverage_test_macros\",\n+ \"either\",\n  \"itertools\",\n  \"rustc_ast\",\n  \"rustc_attr\","}, {"sha": "51489e2936068c8519ddae244ec0006912098e2e", "filename": "compiler/rustc_const_eval/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_const_eval%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_const_eval%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2FCargo.toml?ref=820a41580efb5c67df02dc511c2465d71b0e9f61", "patch": "@@ -7,6 +7,7 @@ edition = \"2021\"\n \n [dependencies]\n tracing = \"0.1\"\n+either = \"1\"\n rustc_apfloat = { path = \"../rustc_apfloat\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_attr = { path = \"../rustc_attr\" }"}, {"sha": "c777a840f3fb661cfd56c25a51b38d6d9c811606", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=820a41580efb5c67df02dc511c2465d71b0e9f61", "patch": "@@ -1,10 +1,7 @@\n-use super::{CompileTimeEvalContext, CompileTimeInterpreter, ConstEvalErr};\n-use crate::interpret::eval_nullary_intrinsic;\n-use crate::interpret::{\n-    intern_const_alloc_recursive, Allocation, ConstAlloc, ConstValue, CtfeValidationMode, GlobalId,\n-    Immediate, InternKind, InterpCx, InterpError, InterpResult, MPlaceTy, MemoryKind, OpTy,\n-    RefTracking, StackPopCleanup,\n-};\n+use std::borrow::Cow;\n+use std::convert::TryInto;\n+\n+use either::{Left, Right};\n \n use rustc_hir::def::DefKind;\n use rustc_middle::mir;\n@@ -16,8 +13,14 @@ use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::{self, TyCtxt};\n use rustc_span::source_map::Span;\n use rustc_target::abi::{self, Abi};\n-use std::borrow::Cow;\n-use std::convert::TryInto;\n+\n+use super::{CompileTimeEvalContext, CompileTimeInterpreter, ConstEvalErr};\n+use crate::interpret::eval_nullary_intrinsic;\n+use crate::interpret::{\n+    intern_const_alloc_recursive, Allocation, ConstAlloc, ConstValue, CtfeValidationMode, GlobalId,\n+    Immediate, InternKind, InterpCx, InterpError, InterpResult, MPlaceTy, MemoryKind, OpTy,\n+    RefTracking, StackPopCleanup,\n+};\n \n const NOTE_ON_UNDEFINED_BEHAVIOR_ERROR: &str = \"The rules on what exactly is undefined behavior aren't clear, \\\n      so this check might be overzealous. Please open an issue on the rustc \\\n@@ -135,14 +138,14 @@ pub(super) fn op_to_const<'tcx>(\n         _ => false,\n     };\n     let immediate = if try_as_immediate {\n-        Err(ecx.read_immediate(op).expect(\"normalization works on validated constants\"))\n+        Right(ecx.read_immediate(op).expect(\"normalization works on validated constants\"))\n     } else {\n         // It is guaranteed that any non-slice scalar pair is actually ByRef here.\n         // When we come back from raw const eval, we are always by-ref. The only way our op here is\n         // by-val is if we are in destructure_mir_constant, i.e., if this is (a field of) something that we\n         // \"tried to make immediate\" before. We wouldn't do that for non-slice scalar pairs or\n         // structs containing such.\n-        op.try_as_mplace()\n+        op.as_mplace_or_imm()\n     };\n \n     debug!(?immediate);\n@@ -168,9 +171,9 @@ pub(super) fn op_to_const<'tcx>(\n         }\n     };\n     match immediate {\n-        Ok(ref mplace) => to_const_value(mplace),\n+        Left(ref mplace) => to_const_value(mplace),\n         // see comment on `let try_as_immediate` above\n-        Err(imm) => match *imm {\n+        Right(imm) => match *imm {\n             _ if imm.layout.is_zst() => ConstValue::ZeroSized,\n             Immediate::Scalar(x) => ConstValue::Scalar(x),\n             Immediate::ScalarPair(a, b) => {"}, {"sha": "79450fccfc4d8567e377320463034e0ebef3f15d", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=820a41580efb5c67df02dc511c2465d71b0e9f61", "patch": "@@ -2,6 +2,8 @@ use std::cell::Cell;\n use std::fmt;\n use std::mem;\n \n+use either::{Either, Left, Right};\n+\n use rustc_hir::{self as hir, def_id::DefId, definitions::DefPathData};\n use rustc_index::vec::IndexVec;\n use rustc_middle::mir;\n@@ -121,13 +123,12 @@ pub struct Frame<'mir, 'tcx, Prov: Provenance = AllocId, Extra = ()> {\n     ////////////////////////////////////////////////////////////////////////////////\n     // Current position within the function\n     ////////////////////////////////////////////////////////////////////////////////\n-    /// If this is `Err`, we are not currently executing any particular statement in\n+    /// If this is `Right`, we are not currently executing any particular statement in\n     /// this frame (can happen e.g. during frame initialization, and during unwinding on\n     /// frames without cleanup code).\n-    /// We basically abuse `Result` as `Either`.\n     ///\n     /// Needs to be public because ConstProp does unspeakable things to it.\n-    pub loc: Result<mir::Location, Span>,\n+    pub loc: Either<mir::Location, Span>,\n }\n \n /// What we store about a frame in an interpreter backtrace.\n@@ -227,25 +228,24 @@ impl<'mir, 'tcx, Prov: Provenance> Frame<'mir, 'tcx, Prov> {\n impl<'mir, 'tcx, Prov: Provenance, Extra> Frame<'mir, 'tcx, Prov, Extra> {\n     /// Get the current location within the Frame.\n     ///\n-    /// If this is `Err`, we are not currently executing any particular statement in\n+    /// If this is `Left`, we are not currently executing any particular statement in\n     /// this frame (can happen e.g. during frame initialization, and during unwinding on\n     /// frames without cleanup code).\n-    /// We basically abuse `Result` as `Either`.\n     ///\n     /// Used by priroda.\n-    pub fn current_loc(&self) -> Result<mir::Location, Span> {\n+    pub fn current_loc(&self) -> Either<mir::Location, Span> {\n         self.loc\n     }\n \n     /// Return the `SourceInfo` of the current instruction.\n     pub fn current_source_info(&self) -> Option<&mir::SourceInfo> {\n-        self.loc.ok().map(|loc| self.body.source_info(loc))\n+        self.loc.left().map(|loc| self.body.source_info(loc))\n     }\n \n     pub fn current_span(&self) -> Span {\n         match self.loc {\n-            Ok(loc) => self.body.source_info(loc).span,\n-            Err(span) => span,\n+            Left(loc) => self.body.source_info(loc).span,\n+            Right(span) => span,\n         }\n     }\n }\n@@ -679,7 +679,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // first push a stack frame so we have access to the local substs\n         let pre_frame = Frame {\n             body,\n-            loc: Err(body.span), // Span used for errors caused during preamble.\n+            loc: Right(body.span), // Span used for errors caused during preamble.\n             return_to_block,\n             return_place: return_place.clone(),\n             // empty local array, we fill it in below, after we are inside the stack frame and\n@@ -713,7 +713,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // done\n         self.frame_mut().locals = locals;\n         M::after_stack_push(self)?;\n-        self.frame_mut().loc = Ok(mir::Location::START);\n+        self.frame_mut().loc = Left(mir::Location::START);\n \n         let span = info_span!(\"frame\", \"{}\", instance);\n         self.frame_mut().tracing_span.enter(span);\n@@ -724,7 +724,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Jump to the given block.\n     #[inline]\n     pub fn go_to_block(&mut self, target: mir::BasicBlock) {\n-        self.frame_mut().loc = Ok(mir::Location { block: target, statement_index: 0 });\n+        self.frame_mut().loc = Left(mir::Location { block: target, statement_index: 0 });\n     }\n \n     /// *Return* to the given `target` basic block.\n@@ -750,8 +750,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// unwinding, and doing so is UB.\n     pub fn unwind_to_block(&mut self, target: StackPopUnwind) -> InterpResult<'tcx> {\n         self.frame_mut().loc = match target {\n-            StackPopUnwind::Cleanup(block) => Ok(mir::Location { block, statement_index: 0 }),\n-            StackPopUnwind::Skip => Err(self.frame_mut().body.span),\n+            StackPopUnwind::Cleanup(block) => Left(mir::Location { block, statement_index: 0 }),\n+            StackPopUnwind::Skip => Right(self.frame_mut().body.span),\n             StackPopUnwind::NotAllowed => {\n                 throw_ub_format!(\"unwinding past a stack frame that does not allow unwinding\")\n             }\n@@ -783,8 +783,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         assert_eq!(\n             unwinding,\n             match self.frame().loc {\n-                Ok(loc) => self.body().basic_blocks[loc.block].is_cleanup,\n-                Err(_) => true,\n+                Left(loc) => self.body().basic_blocks[loc.block].is_cleanup,\n+                Right(_) => true,\n             }\n         );\n         if unwinding && self.frame_idx() == 0 {"}, {"sha": "7d94a22c43d71e467d3c8eeed2963ebc0dbcbff4", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=820a41580efb5c67df02dc511c2465d71b0e9f61", "patch": "@@ -19,8 +19,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             debug!(\"find_closest_untracked_caller_location: checking frame {:?}\", frame.instance);\n \n             // Assert that the frame we look at is actually executing code currently\n-            // (`loc` is `Err` when we are unwinding and the frame does not require cleanup).\n-            let loc = frame.loc.unwrap();\n+            // (`loc` is `Right` when we are unwinding and the frame does not require cleanup).\n+            let loc = frame.loc.left().unwrap();\n \n             // This could be a non-`Call` terminator (such as `Drop`), or not a terminator at all\n             // (such as `box`). Use the normal span by default."}, {"sha": "3eb2b3a0b1b63ca361a7b98a532b42f9e94bb451", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=820a41580efb5c67df02dc511c2465d71b0e9f61", "patch": "@@ -1,6 +1,8 @@\n //! Functions concerning immediate values and operands, and reading from operands.\n //! All high-level functions to read from memory work on operands as sources.\n \n+use either::{Either, Left, Right};\n+\n use rustc_hir::def::Namespace;\n use rustc_middle::ty::layout::{LayoutOf, PrimitiveExt, TyAndLayout};\n use rustc_middle::ty::print::{FmtPrinter, PrettyPrinter};\n@@ -261,9 +263,9 @@ impl<'tcx, Prov: Provenance> OpTy<'tcx, Prov> {\n         layout: TyAndLayout<'tcx>,\n         cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx, Self> {\n-        match self.try_as_mplace() {\n-            Ok(mplace) => Ok(mplace.offset_with_meta(offset, meta, layout, cx)?.into()),\n-            Err(imm) => {\n+        match self.as_mplace_or_imm() {\n+            Left(mplace) => Ok(mplace.offset_with_meta(offset, meta, layout, cx)?.into()),\n+            Right(imm) => {\n                 assert!(\n                     matches!(*imm, Immediate::Uninit),\n                     \"Scalar/ScalarPair cannot be offset into\"\n@@ -353,25 +355,25 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     /// Try returning an immediate for the operand. If the layout does not permit loading this as an\n     /// immediate, return where in memory we can find the data.\n-    /// Note that for a given layout, this operation will either always fail or always\n-    /// succeed!  Whether it succeeds depends on whether the layout can be represented\n+    /// Note that for a given layout, this operation will either always return Left or Right!\n+    /// succeed!  Whether it returns Left depends on whether the layout can be represented\n     /// in an `Immediate`, not on which data is stored there currently.\n     ///\n     /// This is an internal function that should not usually be used; call `read_immediate` instead.\n     /// ConstProp needs it, though.\n     pub fn read_immediate_raw(\n         &self,\n         src: &OpTy<'tcx, M::Provenance>,\n-    ) -> InterpResult<'tcx, Result<ImmTy<'tcx, M::Provenance>, MPlaceTy<'tcx, M::Provenance>>> {\n-        Ok(match src.try_as_mplace() {\n-            Ok(ref mplace) => {\n+    ) -> InterpResult<'tcx, Either<MPlaceTy<'tcx, M::Provenance>, ImmTy<'tcx, M::Provenance>>> {\n+        Ok(match src.as_mplace_or_imm() {\n+            Left(ref mplace) => {\n                 if let Some(val) = self.read_immediate_from_mplace_raw(mplace)? {\n-                    Ok(val)\n+                    Right(val)\n                 } else {\n-                    Err(*mplace)\n+                    Left(*mplace)\n                 }\n             }\n-            Err(val) => Ok(val),\n+            Right(val) => Right(val),\n         })\n     }\n \n@@ -390,7 +392,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ) {\n             span_bug!(self.cur_span(), \"primitive read not possible for type: {:?}\", op.layout.ty);\n         }\n-        let imm = self.read_immediate_raw(op)?.unwrap();\n+        let imm = self.read_immediate_raw(op)?.right().unwrap();\n         if matches!(*imm, Immediate::Uninit) {\n             throw_ub!(InvalidUninitBytes(None));\n         }\n@@ -432,9 +434,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Basically we just transmute this place into an array following simd_size_and_type.\n         // This only works in memory, but repr(simd) types should never be immediates anyway.\n         assert!(op.layout.ty.is_simd());\n-        match op.try_as_mplace() {\n-            Ok(mplace) => self.mplace_to_simd(&mplace),\n-            Err(imm) => match *imm {\n+        match op.as_mplace_or_imm() {\n+            Left(mplace) => self.mplace_to_simd(&mplace),\n+            Right(imm) => match *imm {\n                 Immediate::Uninit => {\n                     throw_ub!(InvalidUninitBytes(None))\n                 }"}, {"sha": "c47cfe8bb69fd05831734e1f42cf16e3781d7049", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=820a41580efb5c67df02dc511c2465d71b0e9f61", "patch": "@@ -2,6 +2,8 @@\n //! into a place.\n //! All high-level functions to write to memory work on places as destinations.\n \n+use either::{Either, Left, Right};\n+\n use rustc_ast::Mutability;\n use rustc_middle::mir;\n use rustc_middle::ty;\n@@ -252,36 +254,36 @@ impl<'tcx, Prov: Provenance> MPlaceTy<'tcx, Prov> {\n // These are defined here because they produce a place.\n impl<'tcx, Prov: Provenance> OpTy<'tcx, Prov> {\n     #[inline(always)]\n-    pub fn try_as_mplace(&self) -> Result<MPlaceTy<'tcx, Prov>, ImmTy<'tcx, Prov>> {\n+    pub fn as_mplace_or_imm(&self) -> Either<MPlaceTy<'tcx, Prov>, ImmTy<'tcx, Prov>> {\n         match **self {\n             Operand::Indirect(mplace) => {\n-                Ok(MPlaceTy { mplace, layout: self.layout, align: self.align.unwrap() })\n+                Left(MPlaceTy { mplace, layout: self.layout, align: self.align.unwrap() })\n             }\n-            Operand::Immediate(imm) => Err(ImmTy::from_immediate(imm, self.layout)),\n+            Operand::Immediate(imm) => Right(ImmTy::from_immediate(imm, self.layout)),\n         }\n     }\n \n     #[inline(always)]\n     #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n     pub fn assert_mem_place(&self) -> MPlaceTy<'tcx, Prov> {\n-        self.try_as_mplace().unwrap()\n+        self.as_mplace_or_imm().left().unwrap()\n     }\n }\n \n impl<'tcx, Prov: Provenance> PlaceTy<'tcx, Prov> {\n     /// A place is either an mplace or some local.\n     #[inline]\n-    pub fn try_as_mplace(&self) -> Result<MPlaceTy<'tcx, Prov>, (usize, mir::Local)> {\n+    pub fn as_mplace_or_local(&self) -> Either<MPlaceTy<'tcx, Prov>, (usize, mir::Local)> {\n         match **self {\n-            Place::Ptr(mplace) => Ok(MPlaceTy { mplace, layout: self.layout, align: self.align }),\n-            Place::Local { frame, local } => Err((frame, local)),\n+            Place::Ptr(mplace) => Left(MPlaceTy { mplace, layout: self.layout, align: self.align }),\n+            Place::Local { frame, local } => Right((frame, local)),\n         }\n     }\n \n     #[inline(always)]\n     #[cfg_attr(debug_assertions, track_caller)] // only in debug builds due to perf (see #98980)\n     pub fn assert_mem_place(&self) -> MPlaceTy<'tcx, Prov> {\n-        self.try_as_mplace().unwrap()\n+        self.as_mplace_or_local().left().unwrap()\n     }\n }\n \n@@ -569,9 +571,9 @@ where\n     }\n \n     pub fn write_uninit(&mut self, dest: &PlaceTy<'tcx, M::Provenance>) -> InterpResult<'tcx> {\n-        let mplace = match dest.try_as_mplace() {\n-            Ok(mplace) => mplace,\n-            Err((frame, local)) => {\n+        let mplace = match dest.as_mplace_or_local() {\n+            Left(mplace) => mplace,\n+            Right((frame, local)) => {\n                 match M::access_local_mut(self, frame, local)? {\n                     Operand::Immediate(local) => {\n                         *local = Immediate::Uninit;\n@@ -639,7 +641,7 @@ where\n         // Let us see if the layout is simple so we take a shortcut,\n         // avoid force_allocation.\n         let src = match self.read_immediate_raw(src)? {\n-            Ok(src_val) => {\n+            Right(src_val) => {\n                 // FIXME(const_prop): Const-prop can possibly evaluate an\n                 // unsized copy operation when it thinks that the type is\n                 // actually sized, due to a trivially false where-clause\n@@ -669,7 +671,7 @@ where\n                     )\n                 };\n             }\n-            Err(mplace) => mplace,\n+            Left(mplace) => mplace,\n         };\n         // Slow path, this does not fit into an immediate. Just memcpy.\n         trace!(\"copy_op: {:?} <- {:?}: {}\", *dest, src, dest.layout.ty);"}, {"sha": "4966fd6ea80c11ae2e1380ce2f701090c6ae2809", "filename": "compiler/rustc_const_eval/src/interpret/projection.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fprojection.rs?ref=820a41580efb5c67df02dc511c2465d71b0e9f61", "patch": "@@ -7,6 +7,8 @@\n //! but we still need to do bounds checking and adjust the layout. To not duplicate that with MPlaceTy, we actually\n //! implement the logic on OpTy, and MPlaceTy calls that.\n \n+use either::{Left, Right};\n+\n use rustc_middle::mir;\n use rustc_middle::ty;\n use rustc_middle::ty::layout::LayoutOf;\n@@ -84,13 +86,13 @@ where\n         base: &OpTy<'tcx, M::Provenance>,\n         field: usize,\n     ) -> InterpResult<'tcx, OpTy<'tcx, M::Provenance>> {\n-        let base = match base.try_as_mplace() {\n-            Ok(ref mplace) => {\n+        let base = match base.as_mplace_or_imm() {\n+            Left(ref mplace) => {\n                 // We can reuse the mplace field computation logic for indirect operands.\n                 let field = self.mplace_field(mplace, field)?;\n                 return Ok(field.into());\n             }\n-            Err(value) => value,\n+            Right(value) => value,\n         };\n \n         let field_layout = base.layout.field(self, field);"}, {"sha": "73f8bf4362e6086da6a1a3325e189c8dc8875850", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=820a41580efb5c67df02dc511c2465d71b0e9f61", "patch": "@@ -2,6 +2,8 @@\n //!\n //! The main entry point is the `step` method.\n \n+use either::Either;\n+\n use rustc_middle::mir;\n use rustc_middle::mir::interpret::{InterpResult, Scalar};\n use rustc_middle::ty::layout::LayoutOf;\n@@ -46,7 +48,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return Ok(false);\n         }\n \n-        let Ok(loc) = self.frame().loc else {\n+        let Either::Left(loc) = self.frame().loc else {\n             // We are unwinding and this fn has no cleanup code.\n             // Just go on unwinding.\n             trace!(\"unwinding: skipping frame\");\n@@ -61,7 +63,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // Make sure we are not updating `statement_index` of the wrong frame.\n             assert_eq!(old_frames, self.frame_idx());\n             // Advance the program counter.\n-            self.frame_mut().loc.as_mut().unwrap().statement_index += 1;\n+            self.frame_mut().loc.as_mut().left().unwrap().statement_index += 1;\n             return Ok(true);\n         }\n \n@@ -305,7 +307,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         self.eval_terminator(terminator)?;\n         if !self.stack().is_empty() {\n-            if let Ok(loc) = self.frame().loc {\n+            if let Either::Left(loc) = self.frame().loc {\n                 info!(\"// executing {:?}\", loc.block);\n             }\n         }"}, {"sha": "cd7a472c0f0df367479771f0eecea77789dbeefa", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=820a41580efb5c67df02dc511c2465d71b0e9f61", "patch": "@@ -8,6 +8,8 @@ use std::convert::TryFrom;\n use std::fmt::{Display, Write};\n use std::num::NonZeroUsize;\n \n+use either::{Left, Right};\n+\n use rustc_ast::Mutability;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n@@ -852,9 +854,9 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     return Ok(());\n                 }\n                 // Now that we definitely have a non-ZST array, we know it lives in memory.\n-                let mplace = match op.try_as_mplace() {\n-                    Ok(mplace) => mplace,\n-                    Err(imm) => match *imm {\n+                let mplace = match op.as_mplace_or_imm() {\n+                    Left(mplace) => mplace,\n+                    Right(imm) => match *imm {\n                         Immediate::Uninit =>\n                             throw_validation_failure!(self.path, { \"uninitialized bytes\" }),\n                         Immediate::Scalar(..) | Immediate::ScalarPair(..) =>"}, {"sha": "f8a69f3c7d53f7b6a11de06c47f625eb3120ee70", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=820a41580efb5c67df02dc511c2465d71b0e9f61", "patch": "@@ -11,6 +11,8 @@ use std::hash;\n use std::ops::Range;\n use std::ptr;\n \n+use either::{Left, Right};\n+\n use rustc_ast::Mutability;\n use rustc_data_structures::intern::Interned;\n use rustc_span::DUMMY_SP;\n@@ -503,11 +505,11 @@ impl<Prov: Provenance, Extra> Allocation<Prov, Extra> {\n         // `to_bits_or_ptr_internal` is the right method because we just want to store this data\n         // as-is into memory.\n         let (bytes, provenance) = match val.to_bits_or_ptr_internal(range.size)? {\n-            Err(val) => {\n-                let (provenance, offset) = val.into_parts();\n+            Right(ptr) => {\n+                let (provenance, offset) = ptr.into_parts();\n                 (u128::from(offset.bytes()), Some(provenance))\n             }\n-            Ok(data) => (data, None),\n+            Left(data) => (data, None),\n         };\n \n         let endian = cx.data_layout().endian;"}, {"sha": "770c3ed05e8d2650557c62735f054a870aa7f432", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=820a41580efb5c67df02dc511c2465d71b0e9f61", "patch": "@@ -1,6 +1,8 @@\n use std::convert::{TryFrom, TryInto};\n use std::fmt;\n \n+use either::{Either, Left, Right};\n+\n use rustc_apfloat::{\n     ieee::{Double, Single},\n     Float,\n@@ -293,10 +295,10 @@ impl<Prov> Scalar<Prov> {\n     pub fn to_bits_or_ptr_internal(\n         self,\n         target_size: Size,\n-    ) -> Result<Result<u128, Pointer<Prov>>, ScalarSizeMismatch> {\n+    ) -> Result<Either<u128, Pointer<Prov>>, ScalarSizeMismatch> {\n         assert_ne!(target_size.bytes(), 0, \"you should never look at the bits of a ZST\");\n         Ok(match self {\n-            Scalar::Int(int) => Ok(int.to_bits(target_size).map_err(|size| {\n+            Scalar::Int(int) => Left(int.to_bits(target_size).map_err(|size| {\n                 ScalarSizeMismatch { target_size: target_size.bytes(), data_size: size.bytes() }\n             })?),\n             Scalar::Ptr(ptr, sz) => {\n@@ -306,7 +308,7 @@ impl<Prov> Scalar<Prov> {\n                         data_size: sz.into(),\n                     });\n                 }\n-                Err(ptr)\n+                Right(ptr)\n             }\n         })\n     }\n@@ -318,8 +320,8 @@ impl<'tcx, Prov: Provenance> Scalar<Prov> {\n             .to_bits_or_ptr_internal(cx.pointer_size())\n             .map_err(|s| err_ub!(ScalarSizeMismatch(s)))?\n         {\n-            Err(ptr) => Ok(ptr.into()),\n-            Ok(bits) => {\n+            Right(ptr) => Ok(ptr.into()),\n+            Left(bits) => {\n                 let addr = u64::try_from(bits).unwrap();\n                 Ok(Pointer::from_addr(addr))\n             }"}, {"sha": "2baa3bfcb6401f3570ee79012cab627d0a6b11f9", "filename": "compiler/rustc_mir_build/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_mir_build%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_mir_build%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2FCargo.toml?ref=820a41580efb5c67df02dc511c2465d71b0e9f61", "patch": "@@ -8,6 +8,7 @@ edition = \"2021\"\n [dependencies]\n rustc_arena = { path = \"../rustc_arena\" }\n tracing = \"0.1\"\n+either = \"1\"\n rustc_middle = { path = \"../rustc_middle\" }\n rustc_apfloat = { path = \"../rustc_apfloat\" }\n rustc_attr = { path = \"../rustc_attr\" }"}, {"sha": "d60e8722cb61d5c443e20ef22d8c061d100781e0", "filename": "compiler/rustc_mir_build/src/thir/pattern/deconstruct_pat.rs", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fdeconstruct_pat.rs?ref=820a41580efb5c67df02dc511c2465d71b0e9f61", "patch": "@@ -42,16 +42,17 @@\n //! wildcards, see [`SplitWildcard`]; for integer ranges, see [`SplitIntRange`]; for slices, see\n //! [`SplitVarLenSlice`].\n \n-use self::Constructor::*;\n-use self::SliceKind::*;\n+use std::cell::Cell;\n+use std::cmp::{self, max, min, Ordering};\n+use std::fmt;\n+use std::iter::{once, IntoIterator};\n+use std::ops::RangeInclusive;\n \n-use super::compare_const_vals;\n-use super::usefulness::{MatchCheckCtxt, PatCtxt};\n+use smallvec::{smallvec, SmallVec};\n \n use rustc_data_structures::captures::Captures;\n-use rustc_index::vec::Idx;\n-\n use rustc_hir::{HirId, RangeEnd};\n+use rustc_index::vec::Idx;\n use rustc_middle::mir::{self, Field};\n use rustc_middle::thir::{FieldPat, Pat, PatKind, PatRange};\n use rustc_middle::ty::layout::IntegerExt;\n@@ -61,12 +62,11 @@ use rustc_session::lint;\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi::{Integer, Size, VariantIdx};\n \n-use smallvec::{smallvec, SmallVec};\n-use std::cell::Cell;\n-use std::cmp::{self, max, min, Ordering};\n-use std::fmt;\n-use std::iter::{once, IntoIterator};\n-use std::ops::RangeInclusive;\n+use self::Constructor::*;\n+use self::SliceKind::*;\n+\n+use super::compare_const_vals;\n+use super::usefulness::{MatchCheckCtxt, PatCtxt};\n \n /// Recursively expand this pattern into its subpatterns. Only useful for or-patterns.\n fn expand_or_pat<'p, 'tcx>(pat: &'p Pat<'tcx>) -> Vec<&'p Pat<'tcx>> {\n@@ -147,11 +147,7 @@ impl IntRange {\n                         // straight to the result, after doing a bit of checking. (We\n                         // could remove this branch and just fall through, which\n                         // is more general but much slower.)\n-                        if let Ok(Ok(bits)) = scalar.to_bits_or_ptr_internal(target_size) {\n-                            return Some(bits);\n-                        } else {\n-                            return None;\n-                        }\n+                        return scalar.to_bits_or_ptr_internal(target_size).unwrap().left();\n                     }\n                     mir::ConstantKind::Ty(c) => match c.kind() {\n                         ty::ConstKind::Value(_) => bug!("}, {"sha": "962536669e0db41301c4eb337f91d1896204c65a", "filename": "compiler/rustc_mir_transform/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_mir_transform%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_mir_transform%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2FCargo.toml?ref=820a41580efb5c67df02dc511c2465d71b0e9f61", "patch": "@@ -9,6 +9,7 @@ edition = \"2021\"\n itertools = \"0.10.1\"\n smallvec = { version = \"1.8.1\", features = [\"union\", \"may_dangle\"] }\n tracing = \"0.1\"\n+either = \"1\"\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_attr = { path = \"../rustc_attr\" }\n rustc_data_structures = { path = \"../rustc_data_structures\" }"}, {"sha": "b0514e033566c9a65ebe8f5484a41d74ddb39898", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=820a41580efb5c67df02dc511c2465d71b0e9f61", "patch": "@@ -3,6 +3,8 @@\n \n use std::cell::Cell;\n \n+use either::Right;\n+\n use rustc_ast::Mutability;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def::DefKind;\n@@ -429,7 +431,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         // Try to read the local as an immediate so that if it is representable as a scalar, we can\n         // handle it as such, but otherwise, just return the value as is.\n         Some(match self.ecx.read_immediate_raw(&op) {\n-            Ok(Ok(imm)) => imm.into(),\n+            Ok(Right(imm)) => imm.into(),\n             _ => op,\n         })\n     }\n@@ -743,7 +745,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         // FIXME> figure out what to do when read_immediate_raw fails\n         let imm = self.use_ecx(|this| this.ecx.read_immediate_raw(value));\n \n-        if let Some(Ok(imm)) = imm {\n+        if let Some(Right(imm)) = imm {\n             match *imm {\n                 interpret::Immediate::Scalar(scalar) => {\n                     *rval = Rvalue::Use(self.operand_from_scalar("}, {"sha": "0ab67228f3f400fae076b6a06e5898320b7f1856", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/820a41580efb5c67df02dc511c2465d71b0e9f61/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=820a41580efb5c67df02dc511c2465d71b0e9f61", "patch": "@@ -1,10 +1,10 @@\n //! Propagates constants for early reporting of statically known\n //! assertion failures\n \n-use crate::const_prop::CanConstProp;\n-use crate::const_prop::ConstPropMachine;\n-use crate::const_prop::ConstPropMode;\n-use crate::MirLint;\n+use std::cell::Cell;\n+\n+use either::{Left, Right};\n+\n use rustc_const_eval::interpret::Immediate;\n use rustc_const_eval::interpret::{\n     self, InterpCx, InterpResult, LocalState, LocalValue, MemoryKind, OpTy, Scalar, StackPopCleanup,\n@@ -26,12 +26,17 @@ use rustc_session::lint;\n use rustc_span::Span;\n use rustc_target::abi::{HasDataLayout, Size, TargetDataLayout};\n use rustc_trait_selection::traits;\n-use std::cell::Cell;\n+\n+use crate::const_prop::CanConstProp;\n+use crate::const_prop::ConstPropMachine;\n+use crate::const_prop::ConstPropMode;\n+use crate::MirLint;\n \n /// The maximum number of bytes that we'll allocate space for a local or the return value.\n /// Needed for #66397, because otherwise we eval into large places and that can cause OOM or just\n /// Severely regress performance.\n const MAX_ALLOC_LIMIT: u64 = 1024;\n+\n pub struct ConstProp;\n \n impl<'tcx> MirLint<'tcx> for ConstProp {\n@@ -243,7 +248,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         // Try to read the local as an immediate so that if it is representable as a scalar, we can\n         // handle it as such, but otherwise, just return the value as is.\n         Some(match self.ecx.read_immediate_raw(&op) {\n-            Ok(Ok(imm)) => imm.into(),\n+            Ok(Left(imm)) => imm.into(),\n             _ => op,\n         })\n     }\n@@ -266,7 +271,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         F: FnOnce(&mut Self) -> InterpResult<'tcx, T>,\n     {\n         // Overwrite the PC -- whatever the interpreter does to it does not make any sense anyway.\n-        self.ecx.frame_mut().loc = Err(source_info.span);\n+        self.ecx.frame_mut().loc = Right(source_info.span);\n         match f(self) {\n             Ok(val) => Some(val),\n             Err(error) => {"}]}