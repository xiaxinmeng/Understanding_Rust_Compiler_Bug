{"sha": "2b907652ee76c150afaf8b599bb985d502d2afae", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiOTA3NjUyZWU3NmMxNTBhZmFmOGI1OTliYjk4NWQ1MDJkMmFmYWU=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-09-02T16:54:09Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-09-13T17:30:23Z"}, "message": "Speculatively expand attributes in completions", "tree": {"sha": "c5846824215521c3186acd3e3ee14a4decd71f8c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5846824215521c3186acd3e3ee14a4decd71f8c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b907652ee76c150afaf8b599bb985d502d2afae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b907652ee76c150afaf8b599bb985d502d2afae", "html_url": "https://github.com/rust-lang/rust/commit/2b907652ee76c150afaf8b599bb985d502d2afae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b907652ee76c150afaf8b599bb985d502d2afae/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3eb646487ba5acd301d26f304433978abf8ce62", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3eb646487ba5acd301d26f304433978abf8ce62", "html_url": "https://github.com/rust-lang/rust/commit/c3eb646487ba5acd301d26f304433978abf8ce62"}], "stats": {"total": 304, "additions": 238, "deletions": 66}, "files": [{"sha": "9eea5b9b340680a1407803682be89db0b1ca6e3d", "filename": "crates/base_db/src/fixture.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2b907652ee76c150afaf8b599bb985d502d2afae/crates%2Fbase_db%2Fsrc%2Ffixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b907652ee76c150afaf8b599bb985d502d2afae/crates%2Fbase_db%2Fsrc%2Ffixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2Fsrc%2Ffixture.rs?ref=2b907652ee76c150afaf8b599bb985d502d2afae", "patch": "@@ -210,14 +210,15 @@ impl ChangeFixture {\n             let proc_lib_file = file_id;\n             file_id.0 += 1;\n \n+            let (proc_macro, source) = test_proc_macros(&proc_macros);\n             let mut fs = FileSet::default();\n             fs.insert(\n                 proc_lib_file,\n                 VfsPath::new_virtual_path(\"/sysroot/proc_macros/lib.rs\".to_string()),\n             );\n             roots.push(SourceRoot::new_library(fs));\n \n-            change.change_file(proc_lib_file, Some(Arc::new(String::new())));\n+            change.change_file(proc_lib_file, Some(Arc::new(String::from(source))));\n \n             let all_crates = crate_graph.crates_in_topological_order();\n \n@@ -228,7 +229,7 @@ impl ChangeFixture {\n                 CfgOptions::default(),\n                 CfgOptions::default(),\n                 Env::default(),\n-                test_proc_macros(&proc_macros),\n+                proc_macro,\n             );\n \n             for krate in all_crates {\n@@ -250,14 +251,22 @@ impl ChangeFixture {\n     }\n }\n \n-fn test_proc_macros(proc_macros: &[String]) -> Vec<ProcMacro> {\n-    std::array::IntoIter::new([ProcMacro {\n+fn test_proc_macros(proc_macros: &[String]) -> (Vec<ProcMacro>, String) {\n+    // The source here is only required so that paths to the macros exist and are resolvable.\n+    let source = r#\"\n+#[proc_macro_attribute]\n+pub fn identity(_attr: TokenStream, item: TokenStream) -> TokenStream {\n+    item\n+}\n+\"#;\n+    let proc_macros = std::array::IntoIter::new([ProcMacro {\n         name: \"identity\".into(),\n         kind: crate::ProcMacroKind::Attr,\n         expander: Arc::new(IdentityProcMacroExpander),\n     }])\n     .filter(|pm| proc_macros.iter().any(|name| name == &pm.name))\n-    .collect()\n+    .collect();\n+    (proc_macros, source.into())\n }\n \n #[derive(Debug, Clone, Copy)]"}, {"sha": "b9b94fd22a9d211d9a1275731cfea959c0988e2c", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2b907652ee76c150afaf8b599bb985d502d2afae/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b907652ee76c150afaf8b599bb985d502d2afae/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=2b907652ee76c150afaf8b599bb985d502d2afae", "patch": "@@ -166,6 +166,15 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.speculative_expand(actual_macro_call, speculative_args, token_to_map)\n     }\n \n+    pub fn speculative_expand_attr_macro(\n+        &self,\n+        actual_macro_call: &ast::Item,\n+        speculative_args: &ast::Item,\n+        token_to_map: SyntaxToken,\n+    ) -> Option<(SyntaxNode, SyntaxToken)> {\n+        self.imp.speculative_expand_attr(actual_macro_call, speculative_args, token_to_map)\n+    }\n+\n     // FIXME: Rename to descend_into_macros_single\n     pub fn descend_into_macros(&self, token: SyntaxToken) -> SyntaxToken {\n         self.imp.descend_into_macros(token).pop().unwrap()\n@@ -452,7 +461,24 @@ impl<'db> SemanticsImpl<'db> {\n         hir_expand::db::expand_speculative(\n             self.db.upcast(),\n             macro_call_id,\n-            speculative_args,\n+            speculative_args.syntax(),\n+            token_to_map,\n+        )\n+    }\n+\n+    fn speculative_expand_attr(\n+        &self,\n+        actual_macro_call: &ast::Item,\n+        speculative_args: &ast::Item,\n+        token_to_map: SyntaxToken,\n+    ) -> Option<(SyntaxNode, SyntaxToken)> {\n+        let sa = self.analyze(actual_macro_call.syntax());\n+        let macro_call = InFile::new(sa.file_id, actual_macro_call.clone());\n+        let macro_call_id = self.with_ctx(|ctx| ctx.item_to_macro_call(macro_call))?;\n+        hir_expand::db::expand_speculative(\n+            self.db.upcast(),\n+            macro_call_id,\n+            speculative_args.syntax(),\n             token_to_map,\n         )\n     }"}, {"sha": "80ba7a8d148c75c182b2e80013e3563976f2fade", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 42, "deletions": 25, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/2b907652ee76c150afaf8b599bb985d502d2afae/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b907652ee76c150afaf8b599bb985d502d2afae/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=2b907652ee76c150afaf8b599bb985d502d2afae", "patch": "@@ -141,27 +141,40 @@ pub trait AstDatabase: SourceDatabase {\n pub fn expand_speculative(\n     db: &dyn AstDatabase,\n     actual_macro_call: MacroCallId,\n-    speculative_args: &ast::TokenTree,\n+    speculative_args: &SyntaxNode,\n     token_to_map: SyntaxToken,\n ) -> Option<(SyntaxNode, SyntaxToken)> {\n-    let (tt, tmap_1) = mbe::syntax_node_to_token_tree(speculative_args.syntax());\n-    let range =\n-        token_to_map.text_range().checked_sub(speculative_args.syntax().text_range().start())?;\n-    let token_id = tmap_1.token_by_range(range)?;\n-\n-    let macro_def = {\n-        let loc: MacroCallLoc = db.lookup_intern_macro(actual_macro_call);\n-        db.macro_def(loc.def)?\n-    };\n+    let loc = db.lookup_intern_macro(actual_macro_call);\n+    let macro_def = db.macro_def(loc.def)?;\n+\n+    // Fetch token id in the speculative args\n+    let censor = censor_for_macro_input(&loc, &speculative_args);\n+    let (tt, args_tmap) = mbe::syntax_node_to_token_tree_censored(&speculative_args, censor);\n+    let range = token_to_map.text_range().checked_sub(speculative_args.text_range().start())?;\n+    let token_id = args_tmap.token_by_range(range)?;\n+\n+    let speculative_expansion = if let MacroDefKind::ProcMacro(expander, ..) = loc.def.kind {\n+        let attr_arg = match &loc.kind {\n+            // FIXME make attr arg speculative as well\n+            MacroCallKind::Attr { attr_args, .. } => {\n+                let mut attr_args = attr_args.0.clone();\n+                mbe::Shift::new(&tt).shift_all(&mut attr_args);\n+                Some(attr_args)\n+            }\n+            _ => None,\n+        };\n \n-    let speculative_expansion = macro_def.expand(db, actual_macro_call, &tt);\n+        expander.expand(db, loc.krate, &tt, attr_arg.as_ref())\n+    } else {\n+        macro_def.expand(db, actual_macro_call, &tt)\n+    };\n \n     let expand_to = macro_expand_to(db, actual_macro_call);\n-\n-    let (node, tmap_2) = token_tree_to_syntax_node(&speculative_expansion.value, expand_to).ok()?;\n+    let (node, rev_tmap) =\n+        token_tree_to_syntax_node(&speculative_expansion.value, expand_to).ok()?;\n \n     let token_id = macro_def.map_id_down(token_id);\n-    let range = tmap_2.first_range_by_token(token_id, token_to_map.kind())?;\n+    let range = rev_tmap.first_range_by_token(token_id, token_to_map.kind())?;\n     let token = node.syntax_node().covering_element(range).into_token()?;\n     Some((node.syntax_node(), token))\n }\n@@ -259,7 +272,19 @@ fn macro_arg(db: &dyn AstDatabase, id: MacroCallId) -> Option<Arc<(tt::Subtree,\n     let loc = db.lookup_intern_macro(id);\n \n     let node = SyntaxNode::new_root(arg);\n-    let censor = match loc.kind {\n+    let censor = censor_for_macro_input(&loc, &node);\n+    let (mut tt, tmap) = mbe::syntax_node_to_token_tree_censored(&node, censor);\n+\n+    if loc.def.is_proc_macro() {\n+        // proc macros expect their inputs without parentheses, MBEs expect it with them included\n+        tt.delimiter = None;\n+    }\n+\n+    Some(Arc::new((tt, tmap)))\n+}\n+\n+fn censor_for_macro_input(loc: &MacroCallLoc, node: &SyntaxNode) -> Option<TextRange> {\n+    match loc.kind {\n         MacroCallKind::FnLike { .. } => None,\n         MacroCallKind::Derive { derive_attr_index, .. } => match ast::Item::cast(node.clone()) {\n             Some(item) => item\n@@ -275,15 +300,7 @@ fn macro_arg(db: &dyn AstDatabase, id: MacroCallId) -> Option<Arc<(tt::Subtree,\n             }\n             None => None,\n         },\n-    };\n-    let (mut tt, tmap) = mbe::syntax_node_to_token_tree_censored(&node, censor);\n-\n-    if loc.def.is_proc_macro() {\n-        // proc macros expect their inputs without parentheses, MBEs expect it with them included\n-        tt.delimiter = None;\n     }\n-\n-    Some(Arc::new((tt, tmap)))\n }\n \n fn macro_arg_text(db: &dyn AstDatabase, id: MacroCallId) -> Option<GreenNode> {\n@@ -367,11 +384,11 @@ fn macro_expand(db: &dyn AstDatabase, id: MacroCallId) -> ExpandResult<Option<Ar\n         None => return ExpandResult::str_err(\"Failed to lower macro args to token tree\".into()),\n     };\n \n-    let macro_rules = match db.macro_def(loc.def) {\n+    let expander = match db.macro_def(loc.def) {\n         Some(it) => it,\n         None => return ExpandResult::str_err(\"Failed to find macro definition\".into()),\n     };\n-    let ExpandResult { value: tt, err } = macro_rules.expand(db, id, &macro_arg.0);\n+    let ExpandResult { value: tt, err } = expander.expand(db, id, &macro_arg.0);\n     // Set a hard limit for the expanded tt\n     let count = tt.count();\n     // XXX: Make ExpandResult a real error and use .map_err instead?"}, {"sha": "871cccb83000e3c451d126b93b749636b7b7e797", "filename": "crates/hir_expand/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2b907652ee76c150afaf8b599bb985d502d2afae/crates%2Fhir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b907652ee76c150afaf8b599bb985d502d2afae/crates%2Fhir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Flib.rs?ref=2b907652ee76c150afaf8b599bb985d502d2afae", "patch": "@@ -370,6 +370,7 @@ impl ExpansionInfo {\n     ) -> Option<impl Iterator<Item = InFile<SyntaxToken>> + '_> {\n         assert_eq!(token.file_id, self.arg.file_id);\n         let token_id = if let Some(item) = item {\n+            // check if we are mapping down in an attribute input\n             let call_id = match self.expanded.file_id.0 {\n                 HirFileIdRepr::FileId(_) => return None,\n                 HirFileIdRepr::MacroFile(macro_file) => macro_file.macro_call_id,"}, {"sha": "b2e78bcfcf34ca7e4fab3553beeefaa6ccef4985", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 76, "deletions": 34, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/2b907652ee76c150afaf8b599bb985d502d2afae/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b907652ee76c150afaf8b599bb985d502d2afae/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=2b907652ee76c150afaf8b599bb985d502d2afae", "patch": "@@ -175,48 +175,90 @@ impl<'a> CompletionContext<'a> {\n             incomplete_let: false,\n             no_completion_required: false,\n         };\n-\n-        let mut original_file = original_file.syntax().clone();\n-        let mut speculative_file = file_with_fake_ident.syntax().clone();\n-        let mut offset = position.offset;\n-        let mut fake_ident_token = fake_ident_token;\n-\n-        // Are we inside a macro call?\n-        while let (Some(actual_macro_call), Some(macro_call_with_fake_ident)) = (\n-            find_node_at_offset::<ast::MacroCall>(&original_file, offset),\n-            find_node_at_offset::<ast::MacroCall>(&speculative_file, offset),\n-        ) {\n-            if actual_macro_call.path().as_ref().map(|s| s.syntax().text())\n-                != macro_call_with_fake_ident.path().as_ref().map(|s| s.syntax().text())\n-            {\n-                break;\n+        ctx.expand_and_fill(\n+            original_file.syntax().clone(),\n+            file_with_fake_ident.syntax().clone(),\n+            position.offset,\n+            fake_ident_token,\n+        );\n+        Some(ctx)\n+    }\n+    fn expand_and_fill(\n+        &mut self,\n+        mut original_file: SyntaxNode,\n+        mut speculative_file: SyntaxNode,\n+        mut offset: TextSize,\n+        mut fake_ident_token: SyntaxToken,\n+    ) {\n+        loop {\n+            if let (Some(actual_item), Some(item_with_fake_ident)) = (\n+                find_node_at_offset::<ast::Item>(&original_file, offset),\n+                find_node_at_offset::<ast::Item>(&speculative_file, offset),\n+            ) {\n+                match (\n+                    self.sema.expand_attr_macro(&actual_item),\n+                    self.sema.speculative_expand_attr_macro(\n+                        &actual_item,\n+                        &item_with_fake_ident,\n+                        fake_ident_token.clone(),\n+                    ),\n+                ) {\n+                    (Some(actual_expansion), Some(speculative_expansion)) => {\n+                        let new_offset = speculative_expansion.1.text_range().start();\n+                        if new_offset > actual_expansion.text_range().end() {\n+                            break;\n+                        }\n+                        original_file = actual_expansion;\n+                        speculative_file = speculative_expansion.0;\n+                        fake_ident_token = speculative_expansion.1;\n+                        offset = new_offset;\n+                        continue;\n+                    }\n+                    (None, None) => (),\n+                    _ => break,\n+                }\n             }\n-            let speculative_args = match macro_call_with_fake_ident.token_tree() {\n-                Some(tt) => tt,\n-                None => break,\n-            };\n-            if let (Some(actual_expansion), Some(speculative_expansion)) = (\n-                ctx.sema.expand(&actual_macro_call),\n-                ctx.sema.speculative_expand(\n-                    &actual_macro_call,\n-                    &speculative_args,\n-                    fake_ident_token,\n-                ),\n+\n+            if let (Some(actual_macro_call), Some(macro_call_with_fake_ident)) = (\n+                find_node_at_offset::<ast::MacroCall>(&original_file, offset),\n+                find_node_at_offset::<ast::MacroCall>(&speculative_file, offset),\n             ) {\n-                let new_offset = speculative_expansion.1.text_range().start();\n-                if new_offset > actual_expansion.text_range().end() {\n+                let mac_call_path0 = actual_macro_call.path().as_ref().map(|s| s.syntax().text());\n+                let mac_call_path1 =\n+                    macro_call_with_fake_ident.path().as_ref().map(|s| s.syntax().text());\n+                if mac_call_path0 != mac_call_path1 {\n+                    break;\n+                }\n+                let speculative_args = match macro_call_with_fake_ident.token_tree() {\n+                    Some(tt) => tt,\n+                    None => break,\n+                };\n+\n+                if let (Some(actual_expansion), Some(speculative_expansion)) = (\n+                    self.sema.expand(&actual_macro_call),\n+                    self.sema.speculative_expand(\n+                        &actual_macro_call,\n+                        &speculative_args,\n+                        fake_ident_token,\n+                    ),\n+                ) {\n+                    let new_offset = speculative_expansion.1.text_range().start();\n+                    if new_offset > actual_expansion.text_range().end() {\n+                        break;\n+                    }\n+                    original_file = actual_expansion;\n+                    speculative_file = speculative_expansion.0;\n+                    fake_ident_token = speculative_expansion.1;\n+                    offset = new_offset;\n+                } else {\n                     break;\n                 }\n-                original_file = actual_expansion;\n-                speculative_file = speculative_expansion.0;\n-                fake_ident_token = speculative_expansion.1;\n-                offset = new_offset;\n             } else {\n                 break;\n             }\n         }\n-        ctx.fill(&original_file, speculative_file, offset);\n-        Some(ctx)\n+\n+        self.fill(&original_file, speculative_file, offset);\n     }\n \n     /// Checks whether completions in that particular case don't make much sense."}, {"sha": "6872e3b8dc13273d572def53d0ab17c3e564c185", "filename": "crates/ide_completion/src/tests.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b907652ee76c150afaf8b599bb985d502d2afae/crates%2Fide_completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b907652ee76c150afaf8b599bb985d502d2afae/crates%2Fide_completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests.rs?ref=2b907652ee76c150afaf8b599bb985d502d2afae", "patch": "@@ -15,6 +15,7 @@ mod item_list;\n mod item;\n mod pattern;\n mod predicate;\n+mod proc_macros;\n mod record;\n mod sourcegen;\n mod type_pos;\n@@ -23,7 +24,7 @@ mod visibility;\n \n use std::mem;\n \n-use hir::{PrefixKind, Semantics};\n+use hir::{db::DefDatabase, PrefixKind, Semantics};\n use ide_db::{\n     base_db::{fixture::ChangeFixture, FileLoader, FilePosition},\n     helpers::{\n@@ -96,6 +97,7 @@ fn completion_list_with_config(config: CompletionConfig, ra_fixture: &str) -> St\n pub(crate) fn position(ra_fixture: &str) -> (RootDatabase, FilePosition) {\n     let change_fixture = ChangeFixture::parse(ra_fixture);\n     let mut database = RootDatabase::default();\n+    database.set_enable_proc_attr_macros(true);\n     database.apply_change(change_fixture.change);\n     let (file_id, range_or_offset) = change_fixture.file_position.expect(\"expected a marker ($0)\");\n     let offset = range_or_offset.expect_offset();"}, {"sha": "6a8133a448fe1f55a8f792c7112b09ddce9dd38a", "filename": "crates/ide_completion/src/tests/proc_macros.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/2b907652ee76c150afaf8b599bb985d502d2afae/crates%2Fide_completion%2Fsrc%2Ftests%2Fproc_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b907652ee76c150afaf8b599bb985d502d2afae/crates%2Fide_completion%2Fsrc%2Ftests%2Fproc_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fproc_macros.rs?ref=2b907652ee76c150afaf8b599bb985d502d2afae", "patch": "@@ -0,0 +1,75 @@\n+//! Completion tests for expressions.\n+use expect_test::{expect, Expect};\n+\n+use crate::tests::completion_list;\n+\n+fn check(ra_fixture: &str, expect: Expect) {\n+    let actual = completion_list(ra_fixture);\n+    expect.assert_eq(&actual)\n+}\n+\n+#[test]\n+fn complete_dot_in_attr() {\n+    check(\n+        r#\"\n+//- proc_macros: identity\n+pub struct Foo;\n+impl Foo {\n+    fn foo(&self) {}\n+}\n+\n+#[proc_macros::identity]\n+fn main() {\n+    Foo.$0\n+}\n+\"#,\n+        expect![[r#\"\n+            me foo() fn(&self)\n+            sn ref   &expr\n+            sn refm  &mut expr\n+            sn match match expr {}\n+            sn box   Box::new(expr)\n+            sn ok    Ok(expr)\n+            sn err   Err(expr)\n+            sn some  Some(expr)\n+            sn dbg   dbg!(expr)\n+            sn dbgr  dbg!(&expr)\n+            sn call  function(expr)\n+            sn let   let\n+            sn letm  let mut\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn complete_dot_in_attr2() {\n+    check(\n+        r#\"\n+//- proc_macros: identity\n+pub struct Foo;\n+impl Foo {\n+    fn foo(&self) {}\n+}\n+\n+#[proc_macros::identity]\n+fn main() {\n+    Foo.f$0\n+}\n+\"#,\n+        expect![[r#\"\n+            me foo() fn(&self)\n+            sn ref   &expr\n+            sn refm  &mut expr\n+            sn match match expr {}\n+            sn box   Box::new(expr)\n+            sn ok    Ok(expr)\n+            sn err   Err(expr)\n+            sn some  Some(expr)\n+            sn dbg   dbg!(expr)\n+            sn dbgr  dbg!(&expr)\n+            sn call  function(expr)\n+            sn let   let\n+            sn letm  let mut\n+        \"#]],\n+    )\n+}"}]}