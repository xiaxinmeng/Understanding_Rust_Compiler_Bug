{"sha": "f4fa7c8a07a96cc9d0aae0bfc6515fb747f25341", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0ZmE3YzhhMDdhOTZjYzlkMGFhZTBiZmM2NTE1ZmI3NDdmMjUzNDE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-30T00:32:50Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-30T22:52:23Z"}, "message": "Register new snapshots", "tree": {"sha": "6460c18d1af201ac4e5f620be2fb1c23da5320a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6460c18d1af201ac4e5f620be2fb1c23da5320a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4fa7c8a07a96cc9d0aae0bfc6515fb747f25341", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4fa7c8a07a96cc9d0aae0bfc6515fb747f25341", "html_url": "https://github.com/rust-lang/rust/commit/f4fa7c8a07a96cc9d0aae0bfc6515fb747f25341", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4fa7c8a07a96cc9d0aae0bfc6515fb747f25341/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5e865b8044cef76bd33ba268a8cdea8a401c96c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5e865b8044cef76bd33ba268a8cdea8a401c96c", "html_url": "https://github.com/rust-lang/rust/commit/e5e865b8044cef76bd33ba268a8cdea8a401c96c"}], "stats": {"total": 1278, "additions": 13, "deletions": 1265}, "files": [{"sha": "ba3180cefd665fc68dfb92155c84944f8ffb18ef", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f4fa7c8a07a96cc9d0aae0bfc6515fb747f25341/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4fa7c8a07a96cc9d0aae0bfc6515fb747f25341/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=f4fa7c8a07a96cc9d0aae0bfc6515fb747f25341", "patch": "@@ -133,14 +133,7 @@ unsafe fn exchange_malloc(size: uint, align: uint) -> *mut u8 {\n     }\n }\n \n-#[cfg(not(test), stage0)]\n-#[lang=\"exchange_free\"]\n-#[inline]\n-unsafe fn exchange_free(ptr: *mut u8) {\n-    deallocate(ptr, 0, 8);\n-}\n-\n-#[cfg(not(test), not(stage0))]\n+#[cfg(not(test))]\n #[lang=\"exchange_free\"]\n #[inline]\n unsafe fn exchange_free(ptr: *mut u8, size: uint, align: uint) {"}, {"sha": "d4571eb3a43511ca61d4b1ca9dafa414addc6130", "filename": "src/libcore/failure.rs", "status": "modified", "additions": 2, "deletions": 38, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f4fa7c8a07a96cc9d0aae0bfc6515fb747f25341/src%2Flibcore%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4fa7c8a07a96cc9d0aae0bfc6515fb747f25341/src%2Flibcore%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffailure.rs?ref=f4fa7c8a07a96cc9d0aae0bfc6515fb747f25341", "patch": "@@ -30,12 +30,10 @@\n \n use fmt;\n use intrinsics;\n-#[cfg(not(test), stage0)]\n-use str::raw::c_str_to_static_slice;\n \n #[cold] #[inline(never)] // this is the slow path, always\n #[lang=\"fail_\"]\n-#[cfg(not(test), not(stage0))]\n+#[cfg(not(test))]\n fn fail_(expr: &'static str, file: &'static str, line: uint) -> ! {\n     format_args!(|args| -> () {\n         begin_unwind(args, file, line);\n@@ -44,24 +42,9 @@ fn fail_(expr: &'static str, file: &'static str, line: uint) -> ! {\n     unsafe { intrinsics::abort() }\n }\n \n-#[cold] #[inline(never)] // this is the slow path, always\n-#[lang=\"fail_\"]\n-#[cfg(not(test), stage0)]\n-fn fail_(expr: *u8, file: *u8, line: uint) -> ! {\n-    unsafe {\n-        let expr = c_str_to_static_slice(expr as *i8);\n-        let file = c_str_to_static_slice(file as *i8);\n-        format_args!(|args| -> () {\n-            begin_unwind(args, file, line);\n-        }, \"{}\", expr);\n-\n-        intrinsics::abort()\n-    }\n-}\n-\n #[cold]\n #[lang=\"fail_bounds_check\"]\n-#[cfg(not(test), not(stage0))]\n+#[cfg(not(test))]\n fn fail_bounds_check(file: &'static str, line: uint,\n                      index: uint, len: uint) -> ! {\n     format_args!(|args| -> () {\n@@ -70,28 +53,9 @@ fn fail_bounds_check(file: &'static str, line: uint,\n     unsafe { intrinsics::abort() }\n }\n \n-#[cold]\n-#[lang=\"fail_bounds_check\"]\n-#[cfg(not(test), stage0)]\n-fn fail_bounds_check(file: *u8, line: uint, index: uint, len: uint) -> ! {\n-    let file = unsafe { c_str_to_static_slice(file as *i8) };\n-    format_args!(|args| -> () {\n-        begin_unwind(args, file, line);\n-    }, \"index out of bounds: the len is {} but the index is {}\", len, index);\n-    unsafe { intrinsics::abort() }\n-}\n-\n #[cold]\n pub fn begin_unwind(fmt: &fmt::Arguments, file: &'static str, line: uint) -> ! {\n     #[allow(ctypes)]\n-    #[cfg(stage0)]\n-    extern {\n-        #[link_name = \"rust_begin_unwind\"]\n-        fn begin_unwind(fmt: &fmt::Arguments, file: &'static str,\n-                        line: uint) -> !;\n-    }\n-    #[allow(ctypes)]\n-    #[cfg(not(stage0))]\n     extern {\n         #[lang = \"begin_unwind\"]\n         fn begin_unwind(fmt: &fmt::Arguments, file: &'static str,"}, {"sha": "8dc2dd4bdb6e1e760373b1145fe661be6bb44e60", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/f4fa7c8a07a96cc9d0aae0bfc6515fb747f25341/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4fa7c8a07a96cc9d0aae0bfc6515fb747f25341/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=f4fa7c8a07a96cc9d0aae0bfc6515fb747f25341", "patch": "@@ -492,10 +492,6 @@ will look like `\"\\\\{\"`.\n \n use io::Writer;\n use io;\n-#[cfg(stage0)]\n-use option::None;\n-#[cfg(stage0)]\n-use repr;\n use result::{Ok, Err};\n use str::{Str, StrAllocating};\n use str;\n@@ -524,21 +520,6 @@ pub use core::fmt::{secret_float, secret_upper_exp, secret_lower_exp};\n #[doc(hidden)]\n pub use core::fmt::{secret_pointer};\n \n-#[doc(hidden)]\n-#[cfg(stage0)]\n-pub fn secret_poly<T: Poly>(x: &T, fmt: &mut Formatter) -> Result {\n-    // FIXME #11938 - UFCS would make us able call the this method\n-    //                directly Poly::fmt(x, fmt).\n-    x.fmt(fmt)\n-}\n-\n-/// Format trait for the `?` character\n-#[cfg(stage0)]\n-pub trait Poly {\n-    /// Formats the value using the given formatter.\n-    fn fmt(&self, &mut Formatter) -> Result;\n-}\n-\n /// The format function takes a precompiled format string and a list of\n /// arguments, to return the resulting formatted string.\n ///\n@@ -562,27 +543,6 @@ pub fn format(args: &Arguments) -> string::String{\n     str::from_utf8(output.unwrap().as_slice()).unwrap().into_string()\n }\n \n-#[cfg(stage0)]\n-impl<T> Poly for T {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        match (f.width, f.precision) {\n-            (None, None) => {\n-                match repr::write_repr(f, self) {\n-                    Ok(()) => Ok(()),\n-                    Err(..) => Err(WriteError),\n-                }\n-            }\n-\n-            // If we have a specified width for formatting, then we have to make\n-            // this allocation of a new string\n-            _ => {\n-                let s = repr::repr_to_str(self);\n-                f.pad(s.as_slice())\n-            }\n-        }\n-    }\n-}\n-\n impl<'a> Writer for Formatter<'a> {\n     fn write(&mut self, b: &[u8]) -> io::IoResult<()> {\n         match (*self).write(b) {"}, {"sha": "a67ed1c0b7919bf59584e7b5f8cf132f5ee3001b", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f4fa7c8a07a96cc9d0aae0bfc6515fb747f25341/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4fa7c8a07a96cc9d0aae0bfc6515fb747f25341/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=f4fa7c8a07a96cc9d0aae0bfc6515fb747f25341", "patch": "@@ -241,13 +241,6 @@ pub mod path;\n pub mod fmt;\n pub mod cleanup;\n \n-/* Unsupported interfaces */\n-\n-#[unstable]\n-pub mod repr;\n-#[unstable]\n-pub mod reflect;\n-\n // Private APIs\n #[unstable]\n pub mod unstable;"}, {"sha": "f21dcdf2a469006afbf91457166dfb79049ab2d0", "filename": "src/libstd/reflect.rs", "status": "removed", "additions": 0, "deletions": 439, "changes": 439, "blob_url": "https://github.com/rust-lang/rust/blob/e5e865b8044cef76bd33ba268a8cdea8a401c96c/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5e865b8044cef76bd33ba268a8cdea8a401c96c/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=e5e865b8044cef76bd33ba268a8cdea8a401c96c", "patch": "@@ -1,439 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-Runtime type reflection\n-\n-*/\n-\n-#![allow(missing_doc)]\n-\n-use intrinsics::{Disr, Opaque, TyDesc, TyVisitor};\n-use mem;\n-use owned::Box;\n-\n-/**\n- * Trait for visitor that wishes to reflect on data. To use this, create a\n- * struct that encapsulates the set of pointers you wish to walk through a\n- * data structure, and implement both `MovePtr` for it as well as `TyVisitor`;\n- * then build a MovePtrAdaptor wrapped around your struct.\n- */\n-pub trait MovePtr {\n-    fn move_ptr(&mut self, adjustment: |*u8| -> *u8);\n-    fn push_ptr(&mut self);\n-    fn pop_ptr(&mut self);\n-}\n-\n-/// Helper function for alignment calculation.\n-#[inline]\n-pub fn align(size: uint, align: uint) -> uint {\n-    ((size + align) - 1u) & !(align - 1u)\n-}\n-\n-/// Adaptor to wrap around visitors implementing MovePtr.\n-pub struct MovePtrAdaptor<V> {\n-    inner: V\n-}\n-\n-impl<V:TyVisitor + MovePtr> MovePtrAdaptor<V> {\n-    pub fn new(v: V) -> MovePtrAdaptor<V> {\n-        MovePtrAdaptor { inner: v }\n-    }\n-\n-    #[inline]\n-    pub fn bump(&mut self, sz: uint) {\n-        self.inner.move_ptr(|p| ((p as uint) + sz) as *u8)\n-    }\n-\n-    #[inline]\n-    pub fn align(&mut self, a: uint) {\n-        self.inner.move_ptr(|p| align(p as uint, a) as *u8)\n-    }\n-\n-    #[inline]\n-    pub fn align_to<T>(&mut self) {\n-        self.align(mem::min_align_of::<T>());\n-    }\n-\n-    #[inline]\n-    pub fn bump_past<T>(&mut self) {\n-        self.bump(mem::size_of::<T>());\n-    }\n-\n-    pub fn unwrap(self) -> V { self.inner }\n-}\n-\n-/// Abstract type-directed pointer-movement using the MovePtr trait\n-impl<V:TyVisitor + MovePtr> TyVisitor for MovePtrAdaptor<V> {\n-    fn visit_bot(&mut self) -> bool {\n-        self.align_to::<()>();\n-        if ! self.inner.visit_bot() { return false; }\n-        self.bump_past::<()>();\n-        true\n-    }\n-\n-    fn visit_nil(&mut self) -> bool {\n-        self.align_to::<()>();\n-        if ! self.inner.visit_nil() { return false; }\n-        self.bump_past::<()>();\n-        true\n-    }\n-\n-    fn visit_bool(&mut self) -> bool {\n-        self.align_to::<bool>();\n-        if ! self.inner.visit_bool() { return false; }\n-        self.bump_past::<bool>();\n-        true\n-    }\n-\n-    fn visit_int(&mut self) -> bool {\n-        self.align_to::<int>();\n-        if ! self.inner.visit_int() { return false; }\n-        self.bump_past::<int>();\n-        true\n-    }\n-\n-    fn visit_i8(&mut self) -> bool {\n-        self.align_to::<i8>();\n-        if ! self.inner.visit_i8() { return false; }\n-        self.bump_past::<i8>();\n-        true\n-    }\n-\n-    fn visit_i16(&mut self) -> bool {\n-        self.align_to::<i16>();\n-        if ! self.inner.visit_i16() { return false; }\n-        self.bump_past::<i16>();\n-        true\n-    }\n-\n-    fn visit_i32(&mut self) -> bool {\n-        self.align_to::<i32>();\n-        if ! self.inner.visit_i32() { return false; }\n-        self.bump_past::<i32>();\n-        true\n-    }\n-\n-    fn visit_i64(&mut self) -> bool {\n-        self.align_to::<i64>();\n-        if ! self.inner.visit_i64() { return false; }\n-        self.bump_past::<i64>();\n-        true\n-    }\n-\n-    fn visit_uint(&mut self) -> bool {\n-        self.align_to::<uint>();\n-        if ! self.inner.visit_uint() { return false; }\n-        self.bump_past::<uint>();\n-        true\n-    }\n-\n-    fn visit_u8(&mut self) -> bool {\n-        self.align_to::<u8>();\n-        if ! self.inner.visit_u8() { return false; }\n-        self.bump_past::<u8>();\n-        true\n-    }\n-\n-    fn visit_u16(&mut self) -> bool {\n-        self.align_to::<u16>();\n-        if ! self.inner.visit_u16() { return false; }\n-        self.bump_past::<u16>();\n-        true\n-    }\n-\n-    fn visit_u32(&mut self) -> bool {\n-        self.align_to::<u32>();\n-        if ! self.inner.visit_u32() { return false; }\n-        self.bump_past::<u32>();\n-        true\n-    }\n-\n-    fn visit_u64(&mut self) -> bool {\n-        self.align_to::<u64>();\n-        if ! self.inner.visit_u64() { return false; }\n-        self.bump_past::<u64>();\n-        true\n-    }\n-\n-    fn visit_f32(&mut self) -> bool {\n-        self.align_to::<f32>();\n-        if ! self.inner.visit_f32() { return false; }\n-        self.bump_past::<f32>();\n-        true\n-    }\n-\n-    fn visit_f64(&mut self) -> bool {\n-        self.align_to::<f64>();\n-        if ! self.inner.visit_f64() { return false; }\n-        self.bump_past::<f64>();\n-        true\n-    }\n-\n-    fn visit_f128(&mut self) -> bool {\n-        self.align_to::<f128>();\n-        if ! self.inner.visit_f128() { return false; }\n-        self.bump_past::<f128>();\n-        true\n-    }\n-\n-    fn visit_char(&mut self) -> bool {\n-        self.align_to::<char>();\n-        if ! self.inner.visit_char() { return false; }\n-        self.bump_past::<char>();\n-        true\n-    }\n-\n-    fn visit_estr_box(&mut self) -> bool {\n-        true\n-    }\n-\n-    fn visit_estr_uniq(&mut self) -> bool {\n-        self.align_to::<~str>();\n-        if ! self.inner.visit_estr_uniq() { return false; }\n-        self.bump_past::<~str>();\n-        true\n-    }\n-\n-    fn visit_estr_slice(&mut self) -> bool {\n-        self.align_to::<&'static str>();\n-        if ! self.inner.visit_estr_slice() { return false; }\n-        self.bump_past::<&'static str>();\n-        true\n-    }\n-\n-    fn visit_estr_fixed(&mut self, n: uint,\n-                        sz: uint,\n-                        align: uint) -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_estr_fixed(n, sz, align) { return false; }\n-        self.bump(sz);\n-        true\n-    }\n-\n-    fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<@u8>();\n-        if ! self.inner.visit_box(mtbl, inner) { return false; }\n-        self.bump_past::<@u8>();\n-        true\n-    }\n-\n-    fn visit_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<Box<u8>>();\n-        if ! self.inner.visit_uniq(mtbl, inner) { return false; }\n-        self.bump_past::<Box<u8>>();\n-        true\n-    }\n-\n-    fn visit_ptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<*u8>();\n-        if ! self.inner.visit_ptr(mtbl, inner) { return false; }\n-        self.bump_past::<*u8>();\n-        true\n-    }\n-\n-    fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<&'static u8>();\n-        if ! self.inner.visit_rptr(mtbl, inner) { return false; }\n-        self.bump_past::<&'static u8>();\n-        true\n-    }\n-\n-    fn visit_evec_box(&mut self, _mtbl: uint, _inner: *TyDesc) -> bool {\n-        true\n-    }\n-\n-    fn visit_evec_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<~[u8]>();\n-        if ! self.inner.visit_evec_uniq(mtbl, inner) { return false; }\n-        self.bump_past::<~[u8]>();\n-        true\n-    }\n-\n-    fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align_to::<&'static [u8]>();\n-        if ! self.inner.visit_evec_slice(mtbl, inner) { return false; }\n-        self.bump_past::<&'static [u8]>();\n-        true\n-    }\n-\n-    fn visit_evec_fixed(&mut self, n: uint, sz: uint, align: uint,\n-                        mtbl: uint, inner: *TyDesc) -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_evec_fixed(n, sz, align, mtbl, inner) {\n-            return false;\n-        }\n-        self.bump(sz);\n-        true\n-    }\n-\n-    fn visit_enter_rec(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_enter_rec(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_rec_field(&mut self, i: uint, name: &str,\n-                       mtbl: uint, inner: *TyDesc) -> bool {\n-        unsafe { self.align((*inner).align); }\n-        if ! self.inner.visit_rec_field(i, name, mtbl, inner) {\n-            return false;\n-        }\n-        unsafe { self.bump((*inner).size); }\n-        true\n-    }\n-\n-    fn visit_leave_rec(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n-        if ! self.inner.visit_leave_rec(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_enter_class(&mut self, name: &str, named_fields: bool, n_fields: uint, sz: uint,\n-                         align: uint) -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_enter_class(name, named_fields, n_fields, sz, align) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_class_field(&mut self, i: uint, name: &str, named: bool, mtbl: uint,\n-                         inner: *TyDesc) -> bool {\n-        unsafe { self.align((*inner).align); }\n-        if ! self.inner.visit_class_field(i, name, named, mtbl, inner) {\n-            return false;\n-        }\n-        unsafe { self.bump((*inner).size); }\n-        true\n-    }\n-\n-    fn visit_leave_class(&mut self, name: &str, named_fields: bool, n_fields: uint, sz: uint,\n-                         align: uint) -> bool {\n-        if ! self.inner.visit_leave_class(name, named_fields, n_fields, sz, align) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_enter_tup(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_enter_tup(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_tup_field(&mut self, i: uint, inner: *TyDesc) -> bool {\n-        unsafe { self.align((*inner).align); }\n-        if ! self.inner.visit_tup_field(i, inner) { return false; }\n-        unsafe { self.bump((*inner).size); }\n-        true\n-    }\n-\n-    fn visit_leave_tup(&mut self, n_fields: uint, sz: uint, align: uint) -> bool {\n-        if ! self.inner.visit_leave_tup(n_fields, sz, align) { return false; }\n-        true\n-    }\n-\n-    fn visit_enter_fn(&mut self, purity: uint, proto: uint,\n-                      n_inputs: uint, retstyle: uint) -> bool {\n-        if ! self.inner.visit_enter_fn(purity, proto, n_inputs, retstyle) {\n-            return false\n-        }\n-        true\n-    }\n-\n-    fn visit_fn_input(&mut self, i: uint, mode: uint, inner: *TyDesc) -> bool {\n-        if ! self.inner.visit_fn_input(i, mode, inner) { return false; }\n-        true\n-    }\n-\n-    fn visit_fn_output(&mut self, retstyle: uint, variadic: bool, inner: *TyDesc) -> bool {\n-        if ! self.inner.visit_fn_output(retstyle, variadic, inner) { return false; }\n-        true\n-    }\n-\n-    fn visit_leave_fn(&mut self, purity: uint, proto: uint,\n-                      n_inputs: uint, retstyle: uint) -> bool {\n-        if ! self.inner.visit_leave_fn(purity, proto, n_inputs, retstyle) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_enter_enum(&mut self, n_variants: uint,\n-                        get_disr: unsafe extern fn(ptr: *Opaque) -> Disr,\n-                        sz: uint, align: uint)\n-                     -> bool {\n-        self.align(align);\n-        if ! self.inner.visit_enter_enum(n_variants, get_disr, sz, align) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_enter_enum_variant(&mut self, variant: uint,\n-                                disr_val: Disr,\n-                                n_fields: uint,\n-                                name: &str) -> bool {\n-        if ! self.inner.visit_enter_enum_variant(variant, disr_val,\n-                                                 n_fields, name) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_enum_variant_field(&mut self, i: uint, offset: uint, inner: *TyDesc) -> bool {\n-        self.inner.push_ptr();\n-        self.bump(offset);\n-        if ! self.inner.visit_enum_variant_field(i, offset, inner) { return false; }\n-        self.inner.pop_ptr();\n-        true\n-    }\n-\n-    fn visit_leave_enum_variant(&mut self, variant: uint,\n-                                disr_val: Disr,\n-                                n_fields: uint,\n-                                name: &str) -> bool {\n-        if ! self.inner.visit_leave_enum_variant(variant, disr_val,\n-                                                 n_fields, name) {\n-            return false;\n-        }\n-        true\n-    }\n-\n-    fn visit_leave_enum(&mut self, n_variants: uint,\n-                        get_disr: unsafe extern fn(ptr: *Opaque) -> Disr,\n-                        sz: uint, align: uint) -> bool {\n-        if ! self.inner.visit_leave_enum(n_variants, get_disr, sz, align) {\n-            return false;\n-        }\n-        self.bump(sz);\n-        true\n-    }\n-\n-    fn visit_trait(&mut self, name: &str) -> bool {\n-        self.align_to::<Box<TyVisitor>>();\n-        if ! self.inner.visit_trait(name) { return false; }\n-        self.bump_past::<Box<TyVisitor>>();\n-        true\n-    }\n-\n-    fn visit_param(&mut self, i: uint) -> bool {\n-        if ! self.inner.visit_param(i) { return false; }\n-        true\n-    }\n-\n-    fn visit_self(&mut self) -> bool {\n-        self.align_to::<&'static u8>();\n-        if ! self.inner.visit_self() { return false; }\n-        self.align_to::<&'static u8>();\n-        true\n-    }\n-}"}, {"sha": "0621cbf35fe22e78181b2287e2dd41f4caf094c2", "filename": "src/libstd/repr.rs", "status": "removed", "additions": 0, "deletions": 663, "changes": 663, "blob_url": "https://github.com/rust-lang/rust/blob/e5e865b8044cef76bd33ba268a8cdea8a401c96c/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5e865b8044cef76bd33ba268a8cdea8a401c96c/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=e5e865b8044cef76bd33ba268a8cdea8a401c96c", "patch": "@@ -1,663 +0,0 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n-\n-More runtime type reflection\n-\n-*/\n-\n-#![allow(missing_doc)]\n-\n-use char;\n-use container::Container;\n-use intrinsics::{Disr, Opaque, TyDesc, TyVisitor, get_tydesc, visit_tydesc};\n-use io;\n-use iter::Iterator;\n-use mem::transmute;\n-use option::{Some, None, Option};\n-use ptr::RawPtr;\n-use raw;\n-use reflect::{MovePtr, align};\n-use reflect;\n-use result::{Ok, Err};\n-use slice::Vector;\n-use str::{Str, StrSlice};\n-use string::String;\n-use to_str::ToStr;\n-use vec::Vec;\n-\n-macro_rules! try( ($me:expr, $e:expr) => (\n-    match $e {\n-        Ok(()) => {},\n-        Err(e) => { $me.last_err = Some(e); return false; }\n-    }\n-) )\n-\n-/// Representations\n-\n-trait Repr {\n-    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()>;\n-}\n-\n-impl Repr for () {\n-    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> {\n-        writer.write(\"()\".as_bytes())\n-    }\n-}\n-\n-impl Repr for bool {\n-    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> {\n-        let s = if *self { \"true\" } else { \"false\" };\n-        writer.write(s.as_bytes())\n-    }\n-}\n-\n-impl Repr for int {\n-    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> {\n-        write!(writer, \"{}\", *self)\n-    }\n-}\n-\n-macro_rules! int_repr(($ty:ident, $suffix:expr) => (impl Repr for $ty {\n-    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> {\n-        write!(writer, \"{}{}\", *self, $suffix)\n-    }\n-}))\n-\n-int_repr!(i8, \"i8\")\n-int_repr!(i16, \"i16\")\n-int_repr!(i32, \"i32\")\n-int_repr!(i64, \"i64\")\n-int_repr!(uint, \"u\")\n-int_repr!(u8, \"u8\")\n-int_repr!(u16, \"u16\")\n-int_repr!(u32, \"u32\")\n-int_repr!(u64, \"u64\")\n-\n-macro_rules! num_repr(($ty:ident, $suffix:expr) => (impl Repr for $ty {\n-    fn write_repr(&self, writer: &mut io::Writer) -> io::IoResult<()> {\n-        let s = self.to_str();\n-        writer.write(s.as_bytes()).and_then(|()| {\n-            writer.write(bytes!($suffix))\n-        })\n-    }\n-}))\n-\n-num_repr!(f32, \"f32\")\n-num_repr!(f64, \"f64\")\n-\n-// New implementation using reflect::MovePtr\n-\n-enum VariantState {\n-    SearchingFor(Disr),\n-    Matched,\n-    AlreadyFound\n-}\n-\n-pub struct ReprVisitor<'a> {\n-    ptr: *u8,\n-    ptr_stk: Vec<*u8>,\n-    var_stk: Vec<VariantState>,\n-    writer: &'a mut io::Writer,\n-    last_err: Option<io::IoError>,\n-}\n-\n-impl<'a> MovePtr for ReprVisitor<'a> {\n-    #[inline]\n-    fn move_ptr(&mut self, adjustment: |*u8| -> *u8) {\n-        self.ptr = adjustment(self.ptr);\n-    }\n-    fn push_ptr(&mut self) {\n-        self.ptr_stk.push(self.ptr);\n-    }\n-    fn pop_ptr(&mut self) {\n-        self.ptr = self.ptr_stk.pop().unwrap();\n-    }\n-}\n-\n-impl<'a> ReprVisitor<'a> {\n-    // Various helpers for the TyVisitor impl\n-    pub fn new(ptr: *u8, writer: &'a mut io::Writer) -> ReprVisitor<'a> {\n-        ReprVisitor {\n-            ptr: ptr,\n-            ptr_stk: vec!(),\n-            var_stk: vec!(),\n-            writer: writer,\n-            last_err: None,\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn get<T>(&mut self, f: |&mut ReprVisitor, &T| -> bool) -> bool {\n-        unsafe {\n-            f(self, transmute::<*u8,&T>(self.ptr))\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn visit_inner(&mut self, inner: *TyDesc) -> bool {\n-        self.visit_ptr_inner(self.ptr, inner)\n-    }\n-\n-    #[inline]\n-    pub fn visit_ptr_inner(&mut self, ptr: *u8, inner: *TyDesc) -> bool {\n-        unsafe {\n-            let u = ReprVisitor::new(ptr, ::mem::transmute_copy(&self.writer));\n-            let mut v = reflect::MovePtrAdaptor::new(u);\n-            // Obviously this should not be a thing, but blame #8401 for now\n-            visit_tydesc(inner, &mut v as &mut TyVisitor);\n-            match v.unwrap().last_err {\n-                Some(e) => {\n-                    self.last_err = Some(e);\n-                    false\n-                }\n-                None => true,\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn write<T:Repr>(&mut self) -> bool {\n-        self.get(|this, v:&T| {\n-            try!(this, v.write_repr(this.writer));\n-            true\n-        })\n-    }\n-\n-    pub fn write_escaped_slice(&mut self, slice: &str) -> bool {\n-        try!(self, self.writer.write(['\"' as u8]));\n-        for ch in slice.chars() {\n-            if !self.write_escaped_char(ch, true) { return false }\n-        }\n-        try!(self, self.writer.write(['\"' as u8]));\n-        true\n-    }\n-\n-    pub fn write_mut_qualifier(&mut self, mtbl: uint) -> bool {\n-        if mtbl == 0 {\n-            try!(self, self.writer.write(\"mut \".as_bytes()));\n-        } else if mtbl == 1 {\n-            // skip, this is ast::m_imm\n-        } else {\n-            fail!(\"invalid mutability value\");\n-        }\n-        true\n-    }\n-\n-    pub fn write_vec_range(&mut self, ptr: *(), len: uint, inner: *TyDesc) -> bool {\n-        let mut p = ptr as *u8;\n-        let (sz, al) = unsafe { ((*inner).size, (*inner).align) };\n-        try!(self, self.writer.write(['[' as u8]));\n-        let mut first = true;\n-        let mut left = len;\n-        // unit structs have 0 size, and don't loop forever.\n-        let dec = if sz == 0 {1} else {sz};\n-        while left > 0 {\n-            if first {\n-                first = false;\n-            } else {\n-                try!(self, self.writer.write(\", \".as_bytes()));\n-            }\n-            self.visit_ptr_inner(p as *u8, inner);\n-            p = align(unsafe { p.offset(sz as int) as uint }, al) as *u8;\n-            left -= dec;\n-        }\n-        try!(self, self.writer.write([']' as u8]));\n-        true\n-    }\n-\n-    pub fn write_unboxed_vec_repr(&mut self, _: uint, v: &raw::Vec<()>, inner: *TyDesc) -> bool {\n-        self.write_vec_range(&v.data, v.fill, inner)\n-    }\n-\n-    fn write_escaped_char(&mut self, ch: char, is_str: bool) -> bool {\n-        try!(self, match ch {\n-            '\\t' => self.writer.write(\"\\\\t\".as_bytes()),\n-            '\\r' => self.writer.write(\"\\\\r\".as_bytes()),\n-            '\\n' => self.writer.write(\"\\\\n\".as_bytes()),\n-            '\\\\' => self.writer.write(\"\\\\\\\\\".as_bytes()),\n-            '\\'' => {\n-                if is_str {\n-                    self.writer.write(\"'\".as_bytes())\n-                } else {\n-                    self.writer.write(\"\\\\'\".as_bytes())\n-                }\n-            }\n-            '\"' => {\n-                if is_str {\n-                    self.writer.write(\"\\\\\\\"\".as_bytes())\n-                } else {\n-                    self.writer.write(\"\\\"\".as_bytes())\n-                }\n-            }\n-            '\\x20'..'\\x7e' => self.writer.write([ch as u8]),\n-            _ => {\n-                char::escape_unicode(ch, |c| {\n-                    let _ = self.writer.write([c as u8]);\n-                });\n-                Ok(())\n-            }\n-        });\n-        return true;\n-    }\n-}\n-\n-impl<'a> TyVisitor for ReprVisitor<'a> {\n-    fn visit_bot(&mut self) -> bool {\n-        try!(self, self.writer.write(\"!\".as_bytes()));\n-        true\n-    }\n-    fn visit_nil(&mut self) -> bool { self.write::<()>() }\n-    fn visit_bool(&mut self) -> bool { self.write::<bool>() }\n-    fn visit_int(&mut self) -> bool { self.write::<int>() }\n-    fn visit_i8(&mut self) -> bool { self.write::<i8>() }\n-    fn visit_i16(&mut self) -> bool { self.write::<i16>() }\n-    fn visit_i32(&mut self) -> bool { self.write::<i32>()  }\n-    fn visit_i64(&mut self) -> bool { self.write::<i64>() }\n-\n-    fn visit_uint(&mut self) -> bool { self.write::<uint>() }\n-    fn visit_u8(&mut self) -> bool { self.write::<u8>() }\n-    fn visit_u16(&mut self) -> bool { self.write::<u16>() }\n-    fn visit_u32(&mut self) -> bool { self.write::<u32>() }\n-    fn visit_u64(&mut self) -> bool { self.write::<u64>() }\n-\n-    fn visit_f32(&mut self) -> bool { self.write::<f32>() }\n-    fn visit_f64(&mut self) -> bool { self.write::<f64>() }\n-    fn visit_f128(&mut self) -> bool { fail!(\"not implemented\") }\n-\n-    fn visit_char(&mut self) -> bool {\n-        self.get::<char>(|this, &ch| {\n-            try!(this, this.writer.write(['\\'' as u8]));\n-            if !this.write_escaped_char(ch, false) { return false }\n-            try!(this, this.writer.write(['\\'' as u8]));\n-            true\n-        })\n-    }\n-\n-    fn visit_estr_box(&mut self) -> bool {\n-        true\n-    }\n-\n-    fn visit_estr_uniq(&mut self) -> bool {\n-        true\n-    }\n-\n-    fn visit_estr_slice(&mut self) -> bool {\n-        self.get::<&str>(|this, s| this.write_escaped_slice(*s))\n-    }\n-\n-    // Type no longer exists, vestigial function.\n-    fn visit_estr_fixed(&mut self, _n: uint, _sz: uint,\n-                        _align: uint) -> bool { fail!(); }\n-\n-    fn visit_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        try!(self, self.writer.write(['@' as u8]));\n-        self.write_mut_qualifier(mtbl);\n-        self.get::<&raw::Box<()>>(|this, b| {\n-            let p = &b.data as *() as *u8;\n-            this.visit_ptr_inner(p, inner)\n-        })\n-    }\n-\n-    fn visit_uniq(&mut self, _mtbl: uint, inner: *TyDesc) -> bool {\n-        try!(self, self.writer.write(\"box \".as_bytes()));\n-        self.get::<*u8>(|this, b| {\n-            this.visit_ptr_inner(*b, inner)\n-        })\n-    }\n-\n-    fn visit_ptr(&mut self, mtbl: uint, _inner: *TyDesc) -> bool {\n-        self.get::<*u8>(|this, p| {\n-            try!(this, write!(this.writer, \"({} as *\", *p));\n-            this.write_mut_qualifier(mtbl);\n-            try!(this, this.writer.write(\"())\".as_bytes()));\n-            true\n-        })\n-    }\n-\n-    fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        try!(self, self.writer.write(['&' as u8]));\n-        self.write_mut_qualifier(mtbl);\n-        self.get::<*u8>(|this, p| {\n-            this.visit_ptr_inner(*p, inner)\n-        })\n-    }\n-\n-    fn visit_evec_box(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.get::<&raw::Box<raw::Vec<()>>>(|this, b| {\n-            try!(this, this.writer.write(['@' as u8]));\n-            this.write_mut_qualifier(mtbl);\n-            this.write_unboxed_vec_repr(mtbl, &b.data, inner)\n-        })\n-    }\n-\n-    fn visit_evec_uniq(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.get::<&raw::Vec<()>>(|this, b| {\n-            try!(this, this.writer.write(\"box \".as_bytes()));\n-            this.write_unboxed_vec_repr(mtbl, *b, inner)\n-        })\n-    }\n-\n-    fn visit_evec_slice(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n-        self.get::<raw::Slice<()>>(|this, s| {\n-            try!(this, this.writer.write(['&' as u8]));\n-            this.write_mut_qualifier(mtbl);\n-            let size = unsafe {\n-                if (*inner).size == 0 { 1 } else { (*inner).size }\n-            };\n-            this.write_vec_range(s.data, s.len * size, inner)\n-        })\n-    }\n-\n-    fn visit_evec_fixed(&mut self, n: uint, sz: uint, _align: uint,\n-                        _: uint, inner: *TyDesc) -> bool {\n-        let assumed_size = if sz == 0 { n } else { sz };\n-        self.get::<()>(|this, b| {\n-            this.write_vec_range(b, assumed_size, inner)\n-        })\n-    }\n-\n-    fn visit_enter_rec(&mut self, _n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool {\n-        try!(self, self.writer.write(['{' as u8]));\n-        true\n-    }\n-\n-    fn visit_rec_field(&mut self, i: uint, name: &str,\n-                       mtbl: uint, inner: *TyDesc) -> bool {\n-        if i != 0 {\n-            try!(self, self.writer.write(\", \".as_bytes()));\n-        }\n-        self.write_mut_qualifier(mtbl);\n-        try!(self, self.writer.write(name.as_bytes()));\n-        try!(self, self.writer.write(\": \".as_bytes()));\n-        self.visit_inner(inner);\n-        true\n-    }\n-\n-    fn visit_leave_rec(&mut self, _n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool {\n-        try!(self, self.writer.write(['}' as u8]));\n-        true\n-    }\n-\n-    fn visit_enter_class(&mut self, name: &str, named_fields: bool, n_fields: uint,\n-                         _sz: uint, _align: uint) -> bool {\n-        try!(self, self.writer.write(name.as_bytes()));\n-        if n_fields != 0 {\n-            if named_fields {\n-                try!(self, self.writer.write(['{' as u8]));\n-            } else {\n-                try!(self, self.writer.write(['(' as u8]));\n-            }\n-        }\n-        true\n-    }\n-\n-    fn visit_class_field(&mut self, i: uint, name: &str, named: bool,\n-                         _mtbl: uint, inner: *TyDesc) -> bool {\n-        if i != 0 {\n-            try!(self, self.writer.write(\", \".as_bytes()));\n-        }\n-        if named {\n-            try!(self, self.writer.write(name.as_bytes()));\n-            try!(self, self.writer.write(\": \".as_bytes()));\n-        }\n-        self.visit_inner(inner);\n-        true\n-    }\n-\n-    fn visit_leave_class(&mut self, _name: &str, named_fields: bool, n_fields: uint,\n-                         _sz: uint, _align: uint) -> bool {\n-        if n_fields != 0 {\n-            if named_fields {\n-                try!(self, self.writer.write(['}' as u8]));\n-            } else {\n-                try!(self, self.writer.write([')' as u8]));\n-            }\n-        }\n-        true\n-    }\n-\n-    fn visit_enter_tup(&mut self, _n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool {\n-        try!(self, self.writer.write(['(' as u8]));\n-        true\n-    }\n-\n-    fn visit_tup_field(&mut self, i: uint, inner: *TyDesc) -> bool {\n-        if i != 0 {\n-            try!(self, self.writer.write(\", \".as_bytes()));\n-        }\n-        self.visit_inner(inner);\n-        true\n-    }\n-\n-    fn visit_leave_tup(&mut self, _n_fields: uint,\n-                       _sz: uint, _align: uint) -> bool {\n-        if _n_fields == 1 {\n-            try!(self, self.writer.write([',' as u8]));\n-        }\n-        try!(self, self.writer.write([')' as u8]));\n-        true\n-    }\n-\n-    fn visit_enter_enum(&mut self,\n-                        _n_variants: uint,\n-                        get_disr: unsafe extern fn(ptr: *Opaque) -> Disr,\n-                        _sz: uint,\n-                        _align: uint) -> bool {\n-        let disr = unsafe {\n-            get_disr(transmute(self.ptr))\n-        };\n-        self.var_stk.push(SearchingFor(disr));\n-        true\n-    }\n-\n-    fn visit_enter_enum_variant(&mut self, _variant: uint,\n-                                disr_val: Disr,\n-                                n_fields: uint,\n-                                name: &str) -> bool {\n-        let mut write = false;\n-        match self.var_stk.pop().unwrap() {\n-            SearchingFor(sought) => {\n-                if disr_val == sought {\n-                    self.var_stk.push(Matched);\n-                    write = true;\n-                } else {\n-                    self.var_stk.push(SearchingFor(sought));\n-                }\n-            }\n-            Matched | AlreadyFound => {\n-                self.var_stk.push(AlreadyFound);\n-            }\n-        }\n-\n-        if write {\n-            try!(self, self.writer.write(name.as_bytes()));\n-            if n_fields > 0 {\n-                try!(self, self.writer.write(['(' as u8]));\n-            }\n-        }\n-        true\n-    }\n-\n-    fn visit_enum_variant_field(&mut self,\n-                                i: uint,\n-                                _offset: uint,\n-                                inner: *TyDesc)\n-                                -> bool {\n-        match *self.var_stk.get(self.var_stk.len() - 1) {\n-            Matched => {\n-                if i != 0 {\n-                    try!(self, self.writer.write(\", \".as_bytes()));\n-                }\n-                if ! self.visit_inner(inner) {\n-                    return false;\n-                }\n-            }\n-            _ => ()\n-        }\n-        true\n-    }\n-\n-    fn visit_leave_enum_variant(&mut self, _variant: uint,\n-                                _disr_val: Disr,\n-                                n_fields: uint,\n-                                _name: &str) -> bool {\n-        match *self.var_stk.get(self.var_stk.len() - 1) {\n-            Matched => {\n-                if n_fields > 0 {\n-                    try!(self, self.writer.write([')' as u8]));\n-                }\n-            }\n-            _ => ()\n-        }\n-        true\n-    }\n-\n-    fn visit_leave_enum(&mut self,\n-                        _n_variants: uint,\n-                        _get_disr: unsafe extern fn(ptr: *Opaque) -> Disr,\n-                        _sz: uint,\n-                        _align: uint)\n-                        -> bool {\n-        match self.var_stk.pop().unwrap() {\n-            SearchingFor(..) => fail!(\"enum value matched no variant\"),\n-            _ => true\n-        }\n-    }\n-\n-    fn visit_enter_fn(&mut self, _purity: uint, _proto: uint,\n-                      _n_inputs: uint, _retstyle: uint) -> bool {\n-        try!(self, self.writer.write(\"fn(\".as_bytes()));\n-        true\n-    }\n-\n-    fn visit_fn_input(&mut self, i: uint, _mode: uint, inner: *TyDesc) -> bool {\n-        if i != 0 {\n-            try!(self, self.writer.write(\", \".as_bytes()));\n-        }\n-        let name = unsafe { (*inner).name };\n-        try!(self, self.writer.write(name.as_bytes()));\n-        true\n-    }\n-\n-    fn visit_fn_output(&mut self, _retstyle: uint, variadic: bool,\n-                       inner: *TyDesc) -> bool {\n-        if variadic {\n-            try!(self, self.writer.write(\", ...\".as_bytes()));\n-        }\n-        try!(self, self.writer.write(\")\".as_bytes()));\n-        let name = unsafe { (*inner).name };\n-        if name != \"()\" {\n-            try!(self, self.writer.write(\" -> \".as_bytes()));\n-            try!(self, self.writer.write(name.as_bytes()));\n-        }\n-        true\n-    }\n-\n-    fn visit_leave_fn(&mut self, _purity: uint, _proto: uint,\n-                      _n_inputs: uint, _retstyle: uint) -> bool { true }\n-\n-\n-    fn visit_trait(&mut self, name: &str) -> bool {\n-        try!(self, self.writer.write(name.as_bytes()));\n-        true\n-    }\n-\n-    fn visit_param(&mut self, _i: uint) -> bool { true }\n-    fn visit_self(&mut self) -> bool { true }\n-}\n-\n-pub fn write_repr<T>(writer: &mut io::Writer, object: &T) -> io::IoResult<()> {\n-    unsafe {\n-        let ptr = object as *T as *u8;\n-        let tydesc = get_tydesc::<T>();\n-        let u = ReprVisitor::new(ptr, writer);\n-        let mut v = reflect::MovePtrAdaptor::new(u);\n-        visit_tydesc(tydesc, &mut v as &mut TyVisitor);\n-        match v.unwrap().last_err {\n-            Some(e) => Err(e),\n-            None => Ok(()),\n-        }\n-    }\n-}\n-\n-pub fn repr_to_str<T>(t: &T) -> String {\n-    use str;\n-    use str::StrAllocating;\n-    use io;\n-\n-    let mut result = io::MemWriter::new();\n-    write_repr(&mut result as &mut io::Writer, t).unwrap();\n-    str::from_utf8(result.unwrap().as_slice()).unwrap().to_string()\n-}\n-\n-#[cfg(test)]\n-struct P {a: int, b: f64}\n-\n-#[test]\n-fn test_repr() {\n-    use prelude::*;\n-    use str;\n-    use str::Str;\n-    use io::stdio::println;\n-    use char::is_alphabetic;\n-    use mem::swap;\n-\n-    fn exact_test<T>(t: &T, e:&str) {\n-        let mut m = io::MemWriter::new();\n-        write_repr(&mut m as &mut io::Writer, t).unwrap();\n-        let s = str::from_utf8(m.unwrap().as_slice()).unwrap().to_owned();\n-        assert_eq!(s.as_slice(), e);\n-    }\n-\n-    exact_test(&10, \"10\");\n-    exact_test(&true, \"true\");\n-    exact_test(&false, \"false\");\n-    exact_test(&1.234, \"1.234f64\");\n-    exact_test(&(\"hello\"), \"\\\"hello\\\"\");\n-\n-    exact_test(&(@10), \"@10\");\n-    exact_test(&(box 10), \"box 10\");\n-    exact_test(&(&10), \"&10\");\n-    let mut x = 10;\n-    exact_test(&(&mut x), \"&mut 10\");\n-\n-    exact_test(&(0 as *()), \"(0x0 as *())\");\n-    exact_test(&(0 as *mut ()), \"(0x0 as *mut ())\");\n-\n-    exact_test(&(1,), \"(1,)\");\n-    exact_test(&(&[\"hi\", \"there\"]),\n-               \"&[\\\"hi\\\", \\\"there\\\"]\");\n-    exact_test(&(P{a:10, b:1.234}),\n-               \"repr::P{a: 10, b: 1.234f64}\");\n-    exact_test(&(@P{a:10, b:1.234}),\n-               \"@repr::P{a: 10, b: 1.234f64}\");\n-    exact_test(&(box P{a:10, b:1.234}),\n-               \"box repr::P{a: 10, b: 1.234f64}\");\n-\n-    exact_test(&(&[1, 2]), \"&[1, 2]\");\n-    exact_test(&(&mut [1, 2]), \"&mut [1, 2]\");\n-\n-    exact_test(&'\\'', \"'\\\\''\");\n-    exact_test(&'\"', \"'\\\"'\");\n-    exact_test(&(\"'\"), \"\\\"'\\\"\");\n-    exact_test(&(\"\\\"\"), \"\\\"\\\\\\\"\\\"\");\n-\n-    exact_test(&println, \"fn(&str)\");\n-    exact_test(&swap::<int>, \"fn(&mut int, &mut int)\");\n-    exact_test(&is_alphabetic, \"fn(char) -> bool\");\n-\n-    struct Bar(int, int);\n-    exact_test(&(Bar(2, 2)), \"repr::test_repr::Bar(2, 2)\");\n-}"}, {"sha": "dc6ab494d643ebaa2cf122ac56d2de8312313c58", "filename": "src/libstd/rt/stack.rs", "status": "modified", "additions": 1, "deletions": 30, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f4fa7c8a07a96cc9d0aae0bfc6515fb747f25341/src%2Flibstd%2Frt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4fa7c8a07a96cc9d0aae0bfc6515fb747f25341/src%2Flibstd%2Frt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fstack.rs?ref=f4fa7c8a07a96cc9d0aae0bfc6515fb747f25341", "patch": "@@ -30,7 +30,7 @@ pub static RED_ZONE: uint = 20 * 1024;\n /// stacks are currently not enabled as segmented stacks, but rather one giant\n /// stack segment. This means that whenever we run out of stack, we want to\n /// truly consider it to be stack overflow rather than allocating a new stack.\n-#[cfg(not(test), not(stage0))] // in testing, use the original libstd's version\n+#[cfg(not(test))] // in testing, use the original libstd's version\n #[lang = \"stack_exhausted\"]\n extern fn stack_exhausted() {\n     use option::{Option, None, Some};\n@@ -103,35 +103,6 @@ extern fn stack_exhausted() {\n     }\n }\n \n-#[no_mangle]      // - this is called from C code\n-#[no_split_stack] // - it would be sad for this function to trigger __morestack\n-#[doc(hidden)]    // - Function must be `pub` to get exported, but it's\n-                  //   irrelevant for documentation purposes.\n-#[cfg(stage0, not(test))] // in testing, use the original libstd's version\n-pub extern \"C\" fn rust_stack_exhausted() {\n-    use option::{Option, None, Some};\n-    use owned::Box;\n-    use rt::local::Local;\n-    use rt::task::Task;\n-    use str::Str;\n-    use intrinsics;\n-\n-    unsafe {\n-        let limit = get_sp_limit();\n-        record_sp_limit(limit - RED_ZONE / 2);\n-        let task: Option<Box<Task>> = Local::try_take();\n-        let name = match task {\n-            Some(ref task) => {\n-                task.name.as_ref().map(|n| n.as_slice())\n-            }\n-            None => None\n-        };\n-        let name = name.unwrap_or(\"<unknown>\");\n-        rterrln!(\"task '{}' has overflowed its stack\", name);\n-        intrinsics::abort();\n-    }\n-}\n-\n #[inline(always)]\n pub unsafe fn record_stack_bounds(stack_lo: uint, stack_hi: uint) {\n     // When the old runtime had segmented stacks, it used a calculation that was"}, {"sha": "dc2646102d208ea6111c2751f115c6857dcc3321", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 1, "deletions": 40, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f4fa7c8a07a96cc9d0aae0bfc6515fb747f25341/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4fa7c8a07a96cc9d0aae0bfc6515fb747f25341/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=f4fa7c8a07a96cc9d0aae0bfc6515fb747f25341", "patch": "@@ -213,7 +213,6 @@ pub mod eabi {\n     }\n \n     #[lang=\"eh_personality\"]\n-    #[cfg(not(stage0))]\n     extern fn eh_personality(\n         version: c_int,\n         actions: uw::_Unwind_Action,\n@@ -227,22 +226,6 @@ pub mod eabi {\n                                  context)\n         }\n     }\n-    #[lang=\"eh_personality\"]\n-    #[no_mangle] // so we can reference it by name from middle/trans/base.rs\n-    #[cfg(stage0)]\n-    pub extern \"C\" fn rust_eh_personality(\n-        version: c_int,\n-        actions: uw::_Unwind_Action,\n-        exception_class: uw::_Unwind_Exception_Class,\n-        ue_header: *uw::_Unwind_Exception,\n-        context: *uw::_Unwind_Context\n-    ) -> uw::_Unwind_Reason_Code\n-    {\n-        unsafe {\n-            __gcc_personality_v0(version, actions, exception_class, ue_header,\n-                                 context)\n-        }\n-    }\n \n     #[no_mangle] // referenced from rust_try.ll\n     pub extern \"C\" fn rust_eh_personality_catch(\n@@ -281,7 +264,6 @@ pub mod eabi {\n     }\n \n     #[lang=\"eh_personality\"]\n-    #[cfg(not(stage0))]\n     extern \"C\" fn eh_personality(\n         state: uw::_Unwind_State,\n         ue_header: *uw::_Unwind_Exception,\n@@ -293,20 +275,6 @@ pub mod eabi {\n         }\n     }\n \n-    #[lang=\"eh_personality\"]\n-    #[no_mangle] // so we can reference it by name from middle/trans/base.rs\n-    #[cfg(stage0)]\n-    pub extern \"C\" fn rust_eh_personality(\n-        state: uw::_Unwind_State,\n-        ue_header: *uw::_Unwind_Exception,\n-        context: *uw::_Unwind_Context\n-    ) -> uw::_Unwind_Reason_Code\n-    {\n-        unsafe {\n-            __gcc_personality_v0(state, ue_header, context)\n-        }\n-    }\n-\n     #[no_mangle] // referenced from rust_try.ll\n     pub extern \"C\" fn rust_eh_personality_catch(\n         state: uw::_Unwind_State,\n@@ -327,20 +295,13 @@ pub mod eabi {\n }\n \n // Entry point of failure from the libcore crate\n-#[cfg(not(test), not(stage0))]\n+#[cfg(not(test))]\n #[lang = \"begin_unwind\"]\n pub extern fn rust_begin_unwind(msg: &fmt::Arguments,\n                                 file: &'static str, line: uint) -> ! {\n     begin_unwind_fmt(msg, file, line)\n }\n \n-#[no_mangle]\n-#[cfg(not(test), stage0)]\n-pub extern fn rust_begin_unwind(msg: &fmt::Arguments,\n-                                file: &'static str, line: uint) -> ! {\n-    begin_unwind_fmt(msg, file, line)\n-}\n-\n /// The entry point for unwinding with a formatted message.\n ///\n /// This is designed to reduce the amount of code required at the call"}, {"sha": "15c1405c4ce4781fd40c4a12fe46d23e3d81dfdd", "filename": "src/snapshots.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f4fa7c8a07a96cc9d0aae0bfc6515fb747f25341/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/f4fa7c8a07a96cc9d0aae0bfc6515fb747f25341/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=f4fa7c8a07a96cc9d0aae0bfc6515fb747f25341", "patch": "@@ -1,3 +1,11 @@\n+S 2014-05-29 50b8528\n+  freebsd-x86_64 cfa0dcc98a57f03a53bb53df6fd5db02143e2bee\n+  linux-i386 baf7c6ab5792f3d560a0f2adc94d7ff96d0cab3d\n+  linux-x86_64 ed97bc90842b96b95e860b9d21fe1ade3f682fd3\n+  macos-i386 2d0e27f72e34be53b1f16d704e9a3b8bedbdbd31\n+  macos-x86_64 f8912b07014c234ae2d625d6da84c752508a2b04\n+  winnt-i386 0af7b426f57015d8392e00ee9a9d1f2f5eb10761\n+\n S 2014-05-16 5327218\n   freebsd-x86_64 e91e235c808eb7e8a1e82f7e00c874de9b1df345\n   linux-i386 3a3b7d68ed42a144fa06c9a49c63966da9adeef2"}]}