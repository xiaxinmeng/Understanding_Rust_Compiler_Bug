{"sha": "f24e0e7b13be0bbead7d7f27b0af5943235c04da", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyNGUwZTdiMTNiZTBiYmVhZDdkN2YyN2IwYWY1OTQzMjM1YzA0ZGE=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-08-21T23:26:19Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2012-08-22T00:03:00Z"}, "message": "Have std::arena segregate POD data and non-POD data into different chunks.", "tree": {"sha": "fa09e61d25fe164cc4d01804aa3dbbb8749713f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa09e61d25fe164cc4d01804aa3dbbb8749713f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f24e0e7b13be0bbead7d7f27b0af5943235c04da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f24e0e7b13be0bbead7d7f27b0af5943235c04da", "html_url": "https://github.com/rust-lang/rust/commit/f24e0e7b13be0bbead7d7f27b0af5943235c04da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f24e0e7b13be0bbead7d7f27b0af5943235c04da/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f32e180118b8163821e3276d4234f4d7e2f1eeb", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f32e180118b8163821e3276d4234f4d7e2f1eeb", "html_url": "https://github.com/rust-lang/rust/commit/5f32e180118b8163821e3276d4234f4d7e2f1eeb"}], "stats": {"total": 99, "additions": 77, "deletions": 22}, "files": [{"sha": "ade04f0a3823783366953f641b59a19418306aff", "filename": "src/libstd/arena.rs", "status": "modified", "additions": 77, "deletions": 22, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/f24e0e7b13be0bbead7d7f27b0af5943235c04da/src%2Flibstd%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f24e0e7b13be0bbead7d7f27b0af5943235c04da/src%2Flibstd%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farena.rs?ref=f24e0e7b13be0bbead7d7f27b0af5943235c04da", "patch": "@@ -17,9 +17,10 @@\n // order bit of the tydesc pointer to encode whether the object it\n // describes has been fully initialized.\n \n-// A good extension of this scheme would be to segregate data with and\n-// without destructors in order to avoid the overhead in the\n-// plain-old-data case.\n+// As an optimization, objects with destructors are stored in\n+// different chunks than objects without destructors. This reduces\n+// overhead when initializing plain-old-data and means we don't need\n+// to waste time running the destructors of POD.\n \n export arena, arena_with_size;\n \n@@ -32,6 +33,7 @@ import libc::size_t;\n #[abi = \"rust-intrinsic\"]\n extern mod rusti {\n     fn move_val_init<T>(&dst: T, -src: T);\n+    fn needs_drop<T>() -> bool;\n }\n extern mod rustrt {\n     #[rust_stack]\n@@ -44,30 +46,34 @@ const tydesc_drop_glue_index: size_t = 3 as size_t;\n // The way arena uses arrays is really deeply awful. The arrays are\n // allocated, and have capacities reserved, but the fill for the array\n // will always stay at 0.\n-type chunk = {data: ~[u8], mut fill: uint};\n+type chunk = {data: ~[u8], mut fill: uint, is_pod: bool};\n \n struct arena {\n     // The head is seperated out from the list as a unbenchmarked\n     // microoptimization, to avoid needing to case on the list to\n     // access the head.\n     priv mut head: @chunk;\n+    priv mut pod_head: @chunk;\n     priv mut chunks: @list<@chunk>;\n     drop {\n         unsafe {\n             destroy_chunk(self.head);\n-            for list::each(self.chunks) |chunk| { destroy_chunk(chunk); }\n+            for list::each(self.chunks) |chunk| {\n+                if !chunk.is_pod { destroy_chunk(chunk); }\n+            }\n         }\n     }\n }\n \n-fn chunk(size: uint) -> @chunk {\n+fn chunk(size: uint, is_pod: bool) -> @chunk {\n     let mut v = ~[];\n     vec::reserve(v, size);\n-    @{ data: v, mut fill: 0u }\n+    @{ data: v, mut fill: 0u, is_pod: is_pod }\n }\n \n fn arena_with_size(initial_size: uint) -> arena {\n-    return arena {mut head: chunk(initial_size),\n+    return arena {mut head: chunk(initial_size, false),\n+                  mut pod_head: chunk(initial_size, true),\n                   mut chunks: @nil};\n }\n \n@@ -122,49 +128,90 @@ unsafe fn un_bitpack_tydesc_ptr(p: uint) -> (*TypeDesc, bool) {\n     (reinterpret_cast(p & !1), p & 1 == 1)\n }\n \n-\n+// The duplication between the POD and non-POD functions is annoying.\n impl &arena {\n-    fn alloc_grow(n_bytes: uint, align: uint) -> (*u8, *u8) {\n+    // Functions for the POD part of the arena\n+    fn alloc_pod_grow(n_bytes: uint, align: uint) -> *u8 {\n+        // Allocate a new chunk.\n+        let chunk_size = vec::capacity(self.pod_head.data);\n+        let new_min_chunk_size = uint::max(n_bytes, chunk_size);\n+        self.chunks = @cons(self.pod_head, self.chunks);\n+        self.pod_head =\n+            chunk(uint::next_power_of_two(new_min_chunk_size + 1u), true);\n+\n+        return self.alloc_pod_inner(n_bytes, align);\n+    }\n+\n+    #[inline(always)]\n+    fn alloc_pod_inner(n_bytes: uint, align: uint) -> *u8 {\n+        let head = self.pod_head;\n+\n+        let start = round_up_to(head.fill, align);\n+        let end = start + n_bytes;\n+        if end > vec::capacity(head.data) {\n+            return self.alloc_pod_grow(n_bytes, align);\n+        }\n+        head.fill = end;\n+\n+        //debug!(\"idx = %u, size = %u, align = %u, fill = %u\",\n+        //       start, n_bytes, align, head.fill);\n+\n+        unsafe {\n+            ptr::offset(vec::unsafe::to_ptr(head.data), start)\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn alloc_pod<T>(op: fn() -> T) -> &self/T {\n+        unsafe {\n+            let tydesc = sys::get_type_desc::<T>();\n+            let ptr = self.alloc_pod_inner((*tydesc).size, (*tydesc).align);\n+            let ptr: *mut T = reinterpret_cast(ptr);\n+            rusti::move_val_init(*ptr, op());\n+            return reinterpret_cast(ptr);\n+        }\n+    }\n+\n+    // Functions for the non-POD part of the arena\n+    fn alloc_nonpod_grow(n_bytes: uint, align: uint) -> (*u8, *u8) {\n         // Allocate a new chunk.\n         let chunk_size = vec::capacity(self.head.data);\n         let new_min_chunk_size = uint::max(n_bytes, chunk_size);\n         self.chunks = @cons(self.head, self.chunks);\n-        self.head = chunk(uint::next_power_of_two(new_min_chunk_size + 1u));\n+        self.head =\n+            chunk(uint::next_power_of_two(new_min_chunk_size + 1u), false);\n \n-        return self.alloc_inner(n_bytes, align);\n+        return self.alloc_nonpod_inner(n_bytes, align);\n     }\n \n     #[inline(always)]\n-    fn alloc_inner(n_bytes: uint, align: uint) -> (*u8, *u8) {\n+    fn alloc_nonpod_inner(n_bytes: uint, align: uint) -> (*u8, *u8) {\n         let head = self.head;\n \n+        let tydesc_start = head.fill;\n         let after_tydesc = head.fill + sys::size_of::<*TypeDesc>();\n-\n         let start = round_up_to(after_tydesc, align);\n         let end = start + n_bytes;\n         if end > vec::capacity(head.data) {\n-            return self.alloc_grow(n_bytes, align);\n+            return self.alloc_nonpod_grow(n_bytes, align);\n         }\n+        head.fill = round_up_to(end, sys::pref_align_of::<*TypeDesc>());\n \n         //debug!(\"idx = %u, size = %u, align = %u, fill = %u\",\n         //       start, n_bytes, align, head.fill);\n \n         unsafe {\n             let buf = vec::unsafe::to_ptr(head.data);\n-            let tydesc_p = ptr::offset(buf, head.fill);\n-            let p = ptr::offset(buf, start);\n-            head.fill = round_up_to(end, sys::pref_align_of::<*TypeDesc>());\n-\n-            return (tydesc_p, p);\n+            return (ptr::offset(buf, tydesc_start), ptr::offset(buf, start));\n         }\n     }\n \n     #[inline(always)]\n-    fn alloc<T>(op: fn() -> T) -> &self/T {\n+    fn alloc_nonpod<T>(op: fn() -> T) -> &self/T {\n         unsafe {\n             let tydesc = sys::get_type_desc::<T>();\n             let (ty_ptr, ptr) =\n-                self.alloc_inner((*tydesc).size, (*tydesc).align);\n+                self.alloc_nonpod_inner((*tydesc).size, (*tydesc).align);\n             let ty_ptr: *mut uint = reinterpret_cast(ty_ptr);\n             let ptr: *mut T = reinterpret_cast(ptr);\n             // Write in our tydesc along with a bit indicating that it\n@@ -179,6 +226,14 @@ impl &arena {\n             return reinterpret_cast(ptr);\n         }\n     }\n+\n+    // The external interface\n+    #[inline(always)]\n+    fn alloc<T>(op: fn() -> T) -> &self/T {\n+        if !rusti::needs_drop::<T>() {\n+            self.alloc_pod(op)\n+        } else { self.alloc_nonpod(op) }\n+    }\n }\n \n #[test]"}]}