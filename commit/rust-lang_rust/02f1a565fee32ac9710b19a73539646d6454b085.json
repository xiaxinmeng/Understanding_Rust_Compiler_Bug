{"sha": "02f1a565fee32ac9710b19a73539646d6454b085", "node_id": "C_kwDOAAsO6NoAKDAyZjFhNTY1ZmVlMzJhYzk3MTBiMTlhNzM1Mzk2NDZkNjQ1NGIwODU", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2022-01-19T04:03:55Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2022-01-19T04:12:42Z"}, "message": "Properly track `DepNode`s in trait evaluation provisional cache\n\nFixes #92987\n\nDuring evaluation of an auto trait predicate, we may encounter a cycle.\nThis causes us to store the evaluation result in a special 'provisional\ncache;. If we later end up determining that the type can legitimately\nimplement the auto trait despite the cycle, we remove the entry from\nthe provisional cache, and insert it into the evaluation cache.\n\nAdditionally, trait evaluation creates a special anonymous `DepNode`.\nAll queries invoked during the predicate evaluation are added as\noutoging dependency edges from the `DepNode`. This `DepNode` is then\nstore in the evaluation cache - if a different query ends up reading\nfrom the cache entry, it will also perform a read of the stored\n`DepNode`. As a result, the cached evaluation will still end up\n(transitively) incurring all of the same dependencies that it would\nif it actually performed the uncached evaluation (e.g. a call to\n`type_of` to determine constituent types).\n\nPreviously, we did not correctly handle the interaction between the\nprovisional cache and the created `DepNode`. Storing an evaluation\nresult in the provisional cache would cause us to lose the `DepNode`\ncreated during the evaluation. If we later moved the entry from the\nprovisional cache to the evaluation cache, we would use the `DepNode`\nassociated with the evaluation that caused us to 'complete' the cycle,\nnot the evaluatoon where we first discovered the cycle. As a result,\nfuture reads from the evaluation cache would miss some incremental\ncompilation dependencies that would have otherwise been added if the\nevaluation was *not* cached.\n\nUnder the right circumstances, this could lead to us trying to force\na query with a no-longer-existing `DefPathHash`, since we were missing\nthe (red) dependency edge that would have caused us to bail out before\nattempting forcing.\n\nThis commit makes the provisional cache store the `DepNode` create\nduring the provisional evaluation. When we move an entry from the\nprovisional cache to the evaluation cache, we create a *new* `DepNode`\nthat has dependencies going to *both* of the evaluation `DepNodes` we\nhave available. This ensures that cached reads will incur all of\nthe necessary dependency edges.", "tree": {"sha": "95ce9bb3f9283a928c7a63e0cdb097d1126dbf46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95ce9bb3f9283a928c7a63e0cdb097d1126dbf46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02f1a565fee32ac9710b19a73539646d6454b085", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAmHnkgAACgkQtAh+UQ6Y\nsWTg/hAAn+E/eng3LVRvSreYbG1Fe2i1wWNWB4TpOXpGquvEJaVGS29hYBHOW08/\n2sle9sVNsJPXOHVytY0Rh0hDSWTX05qzMiHwln0sUP2WpwU6rRs9L+1CXcqvY5sC\nGaHQSTuFuH7h5TuDKYes6PTOwJlQQn+EnicIcN7IvkD+7utZzhKnmJujKDxp1YQl\nNfpet76dYoArgLbBZqeNOCg0+eCs+6R1k7J+2+KvHR3K+3LCJ7pjBoM6bmMdnGx+\nmQhZKyssfwkFfICntwoema80wqHjHLr/mr9c0dWBCLgmfal/RRisNIiYRDpleUgq\nQRcaRESAX2dLvxhEATkRSL78Xj7GBen0hcTqSDfc2KTIbpO0TnS62XxGDX8Bxx2P\ns8pJK88X64oCcMqOt3VsAeKVq20p0Wzb3L4/ZIxFZchPXkHb3JTTQkMnd/nrYhuP\np02x90iDNtNQ9RDxNgKlvMjCjNherfblTi38kI7q6P36/Q5sNZ8S1OjL4UyOxX6/\nu3sJd62bHN9W3xjMG6EmkFk/rwMRb6j+yJXk7y+CSeVBEMMX1w1tqVjuBNIl0LBs\nBQvRvsvSd0rWvW3GkULXKMcHKGOvd9mPBR2h31EC5xIk0rHzVLj3ArU3UJs+qvwP\n1S2CdDaBAHqGgFeQxGo8MRK1CxPjs4+xjH8oAcuOyAJ5xxXdJv8=\n=mwWL\n-----END PGP SIGNATURE-----", "payload": "tree 95ce9bb3f9283a928c7a63e0cdb097d1126dbf46\nparent e5e2b0be26ea177527b60d355bd8f56cd473bd00\nauthor Aaron Hill <aa1ronham@gmail.com> 1642565035 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1642565562 -0500\n\nProperly track `DepNode`s in trait evaluation provisional cache\n\nFixes #92987\n\nDuring evaluation of an auto trait predicate, we may encounter a cycle.\nThis causes us to store the evaluation result in a special 'provisional\ncache;. If we later end up determining that the type can legitimately\nimplement the auto trait despite the cycle, we remove the entry from\nthe provisional cache, and insert it into the evaluation cache.\n\nAdditionally, trait evaluation creates a special anonymous `DepNode`.\nAll queries invoked during the predicate evaluation are added as\noutoging dependency edges from the `DepNode`. This `DepNode` is then\nstore in the evaluation cache - if a different query ends up reading\nfrom the cache entry, it will also perform a read of the stored\n`DepNode`. As a result, the cached evaluation will still end up\n(transitively) incurring all of the same dependencies that it would\nif it actually performed the uncached evaluation (e.g. a call to\n`type_of` to determine constituent types).\n\nPreviously, we did not correctly handle the interaction between the\nprovisional cache and the created `DepNode`. Storing an evaluation\nresult in the provisional cache would cause us to lose the `DepNode`\ncreated during the evaluation. If we later moved the entry from the\nprovisional cache to the evaluation cache, we would use the `DepNode`\nassociated with the evaluation that caused us to 'complete' the cycle,\nnot the evaluatoon where we first discovered the cycle. As a result,\nfuture reads from the evaluation cache would miss some incremental\ncompilation dependencies that would have otherwise been added if the\nevaluation was *not* cached.\n\nUnder the right circumstances, this could lead to us trying to force\na query with a no-longer-existing `DefPathHash`, since we were missing\nthe (red) dependency edge that would have caused us to bail out before\nattempting forcing.\n\nThis commit makes the provisional cache store the `DepNode` create\nduring the provisional evaluation. When we move an entry from the\nprovisional cache to the evaluation cache, we create a *new* `DepNode`\nthat has dependencies going to *both* of the evaluation `DepNodes` we\nhave available. This ensures that cached reads will incur all of\nthe necessary dependency edges.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02f1a565fee32ac9710b19a73539646d6454b085", "html_url": "https://github.com/rust-lang/rust/commit/02f1a565fee32ac9710b19a73539646d6454b085", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02f1a565fee32ac9710b19a73539646d6454b085/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5e2b0be26ea177527b60d355bd8f56cd473bd00", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5e2b0be26ea177527b60d355bd8f56cd473bd00", "html_url": "https://github.com/rust-lang/rust/commit/e5e2b0be26ea177527b60d355bd8f56cd473bd00"}], "stats": {"total": 87, "additions": 75, "deletions": 12}, "files": [{"sha": "947fcdea7ab25f8ba99cc807af18ea33ca185046", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 51, "deletions": 12, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/02f1a565fee32ac9710b19a73539646d6454b085/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f1a565fee32ac9710b19a73539646d6454b085/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=02f1a565fee32ac9710b19a73539646d6454b085", "patch": "@@ -765,14 +765,38 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             debug!(?result, \"CACHE MISS\");\n             self.insert_evaluation_cache(param_env, fresh_trait_pred, dep_node, result);\n \n-            stack.cache().on_completion(stack.dfn, |fresh_trait_pred, provisional_result| {\n-                self.insert_evaluation_cache(\n-                    param_env,\n-                    fresh_trait_pred,\n-                    dep_node,\n-                    provisional_result.max(result),\n-                );\n-            });\n+            stack.cache().on_completion(\n+                stack.dfn,\n+                |fresh_trait_pred, provisional_result, provisional_dep_node| {\n+                    // Create a new `DepNode` that has dependencies on:\n+                    // * The `DepNode` for the original evaluation that resulted in a provisional cache\n+                    // entry being crated\n+                    // * The `DepNode` for the *current* evaluation, which resulted in us completing\n+                    // provisional caches entries and inserting them into the evaluation cache\n+                    //\n+                    // This ensures that when a query reads this entry from the evaluation cache,\n+                    // it will end up (transitively) dependening on all of the incr-comp dependencies\n+                    // created during the evaluation of this trait. For example, evaluating a trait\n+                    // will usually require us to invoke `type_of(field_def_id)` to determine the\n+                    // constituent types, and we want any queries reading from this evaluation\n+                    // cache entry to end up with a transitive `type_of(field_def_id`)` dependency.\n+                    //\n+                    // By using `in_task`, we're also creating an edge from the *current* query\n+                    // to the newly-created `combined_dep_node`. This is probably redundant,\n+                    // but it's better to add too many dep graph edges than to add too few\n+                    // dep graph edges.\n+                    let ((), combined_dep_node) = self.in_task(|this| {\n+                        this.tcx().dep_graph.read_index(provisional_dep_node);\n+                        this.tcx().dep_graph.read_index(dep_node);\n+                    });\n+                    self.insert_evaluation_cache(\n+                        param_env,\n+                        fresh_trait_pred,\n+                        combined_dep_node,\n+                        provisional_result.max(result),\n+                    );\n+                },\n+            );\n         } else {\n             debug!(?result, \"PROVISIONAL\");\n             debug!(\n@@ -781,7 +805,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 fresh_trait_pred, stack.depth, reached_depth,\n             );\n \n-            stack.cache().insert_provisional(stack.dfn, reached_depth, fresh_trait_pred, result);\n+            stack.cache().insert_provisional(\n+                stack.dfn,\n+                reached_depth,\n+                fresh_trait_pred,\n+                result,\n+                dep_node,\n+            );\n         }\n \n         Ok(result)\n@@ -2506,6 +2536,11 @@ struct ProvisionalEvaluation {\n     from_dfn: usize,\n     reached_depth: usize,\n     result: EvaluationResult,\n+    /// The `DepNodeIndex` created for the `evaluate_stack` call for this provisional\n+    /// evaluation. When we create an entry in the evaluation cache using this provisional\n+    /// cache entry (see `on_completion`), we use this `dep_node` to ensure that future reads from\n+    /// the cache will have all of the necessary incr comp dependencies tracked.\n+    dep_node: DepNodeIndex,\n }\n \n impl<'tcx> Default for ProvisionalEvaluationCache<'tcx> {\n@@ -2548,6 +2583,7 @@ impl<'tcx> ProvisionalEvaluationCache<'tcx> {\n         reached_depth: usize,\n         fresh_trait_pred: ty::PolyTraitPredicate<'tcx>,\n         result: EvaluationResult,\n+        dep_node: DepNodeIndex,\n     ) {\n         debug!(?from_dfn, ?fresh_trait_pred, ?result, \"insert_provisional\");\n \n@@ -2573,7 +2609,10 @@ impl<'tcx> ProvisionalEvaluationCache<'tcx> {\n             }\n         }\n \n-        map.insert(fresh_trait_pred, ProvisionalEvaluation { from_dfn, reached_depth, result });\n+        map.insert(\n+            fresh_trait_pred,\n+            ProvisionalEvaluation { from_dfn, reached_depth, result, dep_node },\n+        );\n     }\n \n     /// Invoked when the node with dfn `dfn` does not get a successful\n@@ -2624,7 +2663,7 @@ impl<'tcx> ProvisionalEvaluationCache<'tcx> {\n     fn on_completion(\n         &self,\n         dfn: usize,\n-        mut op: impl FnMut(ty::PolyTraitPredicate<'tcx>, EvaluationResult),\n+        mut op: impl FnMut(ty::PolyTraitPredicate<'tcx>, EvaluationResult, DepNodeIndex),\n     ) {\n         debug!(?dfn, \"on_completion\");\n \n@@ -2633,7 +2672,7 @@ impl<'tcx> ProvisionalEvaluationCache<'tcx> {\n         {\n             debug!(?fresh_trait_pred, ?eval, \"on_completion\");\n \n-            op(fresh_trait_pred, eval.result);\n+            op(fresh_trait_pred, eval.result, eval.dep_node);\n         }\n     }\n }"}, {"sha": "a48a8373c2b593053cdec0146942e9aa21c0cf1e", "filename": "src/test/incremental/issue-92987-provisional-dep-node.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/02f1a565fee32ac9710b19a73539646d6454b085/src%2Ftest%2Fincremental%2Fissue-92987-provisional-dep-node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f1a565fee32ac9710b19a73539646d6454b085/src%2Ftest%2Fincremental%2Fissue-92987-provisional-dep-node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-92987-provisional-dep-node.rs?ref=02f1a565fee32ac9710b19a73539646d6454b085", "patch": "@@ -0,0 +1,24 @@\n+// revisions: rpass1 rpass2\n+\n+// Regression test for issue #92987\n+// Tests that we properly manage `DepNode`s during trait evaluation\n+// involing an auto-trait cycle.\n+\n+#[cfg(rpass1)]\n+struct CycleOne(Box<CycleTwo>);\n+\n+#[cfg(rpass2)]\n+enum CycleOne {\n+    Variant(Box<CycleTwo>)\n+}\n+\n+struct CycleTwo(CycleOne);\n+\n+fn assert_send<T: Send>() {}\n+\n+fn bar() {\n+    assert_send::<CycleOne>();\n+    assert_send::<CycleTwo>();\n+}\n+\n+fn main() {}"}]}