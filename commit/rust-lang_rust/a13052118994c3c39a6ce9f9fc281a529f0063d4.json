{"sha": "a13052118994c3c39a6ce9f9fc281a529f0063d4", "node_id": "C_kwDOAAsO6NoAKGExMzA1MjExODk5NGMzYzM5YTZjZTlmOWZjMjgxYTUyOWYwMDYzZDQ", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-06-25T13:14:07Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-25T13:14:07Z"}, "message": "Rollup merge of #98126 - fortanix:raoul/mitigate_stale_data_vulnerability, r=cuviper\n\nMitigate MMIO stale data vulnerability\n\nIntel publicly disclosed the MMIO stale data vulnerability on June 14. To mitigate this vulnerability, compiler changes are required for the `x86_64-fortanix-unknown-sgx` target.\ncc: ````@jethrogb````", "tree": {"sha": "6756b54a9d4c778662d81f34284b4f32c26ba059", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6756b54a9d4c778662d81f34284b4f32c26ba059"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a13052118994c3c39a6ce9f9fc281a529f0063d4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJitwofCRBK7hj4Ov3rIwAATIQIAHHsHc0JWPK0iOsRX2dtMI3G\n5Ye/5iRK6NCgy5dL84eACHkcOeMka/ISioxiSTyB8HrDQBqWV3GQ6kHC2Sryt/B3\n7HYAaUt2MKo8/N+DplelHH2jO6noT76MpNXIkhFE5mh7dyLKrwKJQBNBz47Qh94N\n7ugqNGu8eQdwZss3fHEV5N/4IYx1j6JgCrBeNl2m1YDKZHRwyjWFySwUdjdYEfVw\nexdKGA5MCpuhKXXdsSqOu3iIxh7kZY5O2tPtQFJzeUBcU5bLuzVpgi4SKYngfrSY\n/81krWHshFHgXMp2IkluDVaKuaZl1YIkfDMQD2JOIrmYBj9GW5/rEVODoyVOBBU=\n=WTwN\n-----END PGP SIGNATURE-----\n", "payload": "tree 6756b54a9d4c778662d81f34284b4f32c26ba059\nparent d7388d1857fa32c6659997b901631f087d68dbf0\nparent 6a6910e5a9bb8d00f9798dea93dcbe61df4c073d\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1656162847 +0200\ncommitter GitHub <noreply@github.com> 1656162847 +0200\n\nRollup merge of #98126 - fortanix:raoul/mitigate_stale_data_vulnerability, r=cuviper\n\nMitigate MMIO stale data vulnerability\n\nIntel publicly disclosed the MMIO stale data vulnerability on June 14. To mitigate this vulnerability, compiler changes are required for the `x86_64-fortanix-unknown-sgx` target.\ncc: ````@jethrogb````\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a13052118994c3c39a6ce9f9fc281a529f0063d4", "html_url": "https://github.com/rust-lang/rust/commit/a13052118994c3c39a6ce9f9fc281a529f0063d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a13052118994c3c39a6ce9f9fc281a529f0063d4/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7388d1857fa32c6659997b901631f087d68dbf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7388d1857fa32c6659997b901631f087d68dbf0", "html_url": "https://github.com/rust-lang/rust/commit/d7388d1857fa32c6659997b901631f087d68dbf0"}, {"sha": "6a6910e5a9bb8d00f9798dea93dcbe61df4c073d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a6910e5a9bb8d00f9798dea93dcbe61df4c073d", "html_url": "https://github.com/rust-lang/rust/commit/6a6910e5a9bb8d00f9798dea93dcbe61df4c073d"}], "stats": {"total": 152, "additions": 142, "deletions": 10}, "files": [{"sha": "ea24fedd0eb3dbe6d7a6bb701a677afcab612383", "filename": "library/std/src/sys/sgx/abi/usercalls/alloc.rs", "status": "modified", "additions": 110, "deletions": 10, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/a13052118994c3c39a6ce9f9fc281a529f0063d4/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a13052118994c3c39a6ce9f9fc281a529f0063d4/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Falloc.rs?ref=a13052118994c3c39a6ce9f9fc281a529f0063d4", "patch": "@@ -1,13 +1,16 @@\n #![allow(unused)]\n \n+use crate::arch::asm;\n use crate::cell::UnsafeCell;\n+use crate::cmp;\n+use crate::convert::TryInto;\n use crate::mem;\n use crate::ops::{CoerceUnsized, Deref, DerefMut, Index, IndexMut};\n use crate::ptr::{self, NonNull};\n use crate::slice;\n use crate::slice::SliceIndex;\n \n-use super::super::mem::is_user_range;\n+use super::super::mem::{is_enclave_range, is_user_range};\n use fortanix_sgx_abi::*;\n \n /// A type that can be safely read from or written to userspace.\n@@ -210,7 +213,9 @@ where\n         unsafe {\n             // Mustn't call alloc with size 0.\n             let ptr = if size > 0 {\n-                rtunwrap!(Ok, super::alloc(size, T::align_of())) as _\n+                // `copy_to_userspace` is more efficient when data is 8-byte aligned\n+                let alignment = cmp::max(T::align_of(), 8);\n+                rtunwrap!(Ok, super::alloc(size, alignment)) as _\n             } else {\n                 T::align_of() as _ // dangling pointer ok for size 0\n             };\n@@ -225,13 +230,9 @@ where\n     /// Copies `val` into freshly allocated space in user memory.\n     pub fn new_from_enclave(val: &T) -> Self {\n         unsafe {\n-            let ret = Self::new_uninit_bytes(mem::size_of_val(val));\n-            ptr::copy(\n-                val as *const T as *const u8,\n-                ret.0.as_ptr() as *mut u8,\n-                mem::size_of_val(val),\n-            );\n-            ret\n+            let mut user = Self::new_uninit_bytes(mem::size_of_val(val));\n+            user.copy_from_enclave(val);\n+            user\n         }\n     }\n \n@@ -304,6 +305,105 @@ where\n     }\n }\n \n+/// Copies `len` bytes of data from enclave pointer `src` to userspace `dst`\n+///\n+/// This function mitigates stale data vulnerabilities by ensuring all writes to untrusted memory are either:\n+///  - preceded by the VERW instruction and followed by the MFENCE; LFENCE instruction sequence\n+///  - or are in multiples of 8 bytes, aligned to an 8-byte boundary\n+///\n+/// # Panics\n+/// This function panics if:\n+///\n+/// * The `src` pointer is null\n+/// * The `dst` pointer is null\n+/// * The `src` memory range is not in enclave memory\n+/// * The `dst` memory range is not in user memory\n+///\n+/// # References\n+///  - https://www.intel.com/content/www/us/en/security-center/advisory/intel-sa-00615.html\n+///  - https://www.intel.com/content/www/us/en/developer/articles/technical/software-security-guidance/technical-documentation/processor-mmio-stale-data-vulnerabilities.html#inpage-nav-3-2-2\n+pub(crate) unsafe fn copy_to_userspace(src: *const u8, dst: *mut u8, len: usize) {\n+    unsafe fn copy_bytewise_to_userspace(src: *const u8, dst: *mut u8, len: usize) {\n+        unsafe {\n+            let mut seg_sel: u16 = 0;\n+            for off in 0..len {\n+                asm!(\"\n+                    mov %ds, ({seg_sel})\n+                    verw ({seg_sel})\n+                    movb {val}, ({dst})\n+                    mfence\n+                    lfence\n+                    \",\n+                    val = in(reg_byte) *src.offset(off as isize),\n+                    dst = in(reg) dst.offset(off as isize),\n+                    seg_sel = in(reg) &mut seg_sel,\n+                    options(nostack, att_syntax)\n+                );\n+            }\n+        }\n+    }\n+\n+    unsafe fn copy_aligned_quadwords_to_userspace(src: *const u8, dst: *mut u8, len: usize) {\n+        unsafe {\n+            asm!(\n+                \"rep movsq (%rsi), (%rdi)\",\n+                inout(\"rcx\") len / 8 => _,\n+                inout(\"rdi\") dst => _,\n+                inout(\"rsi\") src => _,\n+                options(att_syntax, nostack, preserves_flags)\n+            );\n+        }\n+    }\n+    assert!(!src.is_null());\n+    assert!(!dst.is_null());\n+    assert!(is_enclave_range(src, len));\n+    assert!(is_user_range(dst, len));\n+    assert!(len < isize::MAX as usize);\n+    assert!(!(src as usize).overflowing_add(len).1);\n+    assert!(!(dst as usize).overflowing_add(len).1);\n+\n+    if len < 8 {\n+        // Can't align on 8 byte boundary: copy safely byte per byte\n+        unsafe {\n+            copy_bytewise_to_userspace(src, dst, len);\n+        }\n+    } else if len % 8 == 0 && dst as usize % 8 == 0 {\n+        // Copying 8-byte aligned quadwords: copy quad word per quad word\n+        unsafe {\n+            copy_aligned_quadwords_to_userspace(src, dst, len);\n+        }\n+    } else {\n+        // Split copies into three parts:\n+        //   +--------+\n+        //   | small0 | Chunk smaller than 8 bytes\n+        //   +--------+\n+        //   |   big  | Chunk 8-byte aligned, and size a multiple of 8 bytes\n+        //   +--------+\n+        //   | small1 | Chunk smaller than 8 bytes\n+        //   +--------+\n+\n+        unsafe {\n+            // Copy small0\n+            let small0_size = (8 - dst as usize % 8) as u8;\n+            let small0_src = src;\n+            let small0_dst = dst;\n+            copy_bytewise_to_userspace(small0_src as _, small0_dst, small0_size as _);\n+\n+            // Copy big\n+            let small1_size = ((len - small0_size as usize) % 8) as u8;\n+            let big_size = len - small0_size as usize - small1_size as usize;\n+            let big_src = src.offset(small0_size as _);\n+            let big_dst = dst.offset(small0_size as _);\n+            copy_aligned_quadwords_to_userspace(big_src as _, big_dst, big_size);\n+\n+            // Copy small1\n+            let small1_src = src.offset(big_size as isize + small0_size as isize);\n+            let small1_dst = dst.offset(big_size as isize + small0_size as isize);\n+            copy_bytewise_to_userspace(small1_src, small1_dst, small1_size as _);\n+        }\n+    }\n+}\n+\n #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n impl<T: ?Sized> UserRef<T>\n where\n@@ -352,7 +452,7 @@ where\n     pub fn copy_from_enclave(&mut self, val: &T) {\n         unsafe {\n             assert_eq!(mem::size_of_val(val), mem::size_of_val(&*self.0.get()));\n-            ptr::copy(\n+            copy_to_userspace(\n                 val as *const T as *const u8,\n                 self.0.get() as *mut T as *mut u8,\n                 mem::size_of_val(val),"}, {"sha": "79d1db5e1c50db01029ae14b2461cbe927843594", "filename": "library/std/src/sys/sgx/abi/usercalls/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a13052118994c3c39a6ce9f9fc281a529f0063d4/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a13052118994c3c39a6ce9f9fc281a529f0063d4/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Fmod.rs?ref=a13052118994c3c39a6ce9f9fc281a529f0063d4", "patch": "@@ -6,6 +6,8 @@ use crate::time::{Duration, Instant};\n pub(crate) mod alloc;\n #[macro_use]\n pub(crate) mod raw;\n+#[cfg(test)]\n+mod tests;\n \n use self::raw::*;\n "}, {"sha": "cbf7d7d54f7a2f0dd475261a1a7dad74c84a4df4", "filename": "library/std/src/sys/sgx/abi/usercalls/tests.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a13052118994c3c39a6ce9f9fc281a529f0063d4/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a13052118994c3c39a6ce9f9fc281a529f0063d4/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fabi%2Fusercalls%2Ftests.rs?ref=a13052118994c3c39a6ce9f9fc281a529f0063d4", "patch": "@@ -0,0 +1,30 @@\n+use super::alloc::copy_to_userspace;\n+use super::alloc::User;\n+\n+#[test]\n+fn test_copy_function() {\n+    let mut src = [0u8; 100];\n+    let mut dst = User::<[u8]>::uninitialized(100);\n+\n+    for i in 0..src.len() {\n+        src[i] = i as _;\n+    }\n+\n+    for size in 0..48 {\n+        // For all possible alignment\n+        for offset in 0..8 {\n+            // overwrite complete dst\n+            dst.copy_from_enclave(&[0u8; 100]);\n+\n+            // Copy src[0..size] to dst + offset\n+            unsafe { copy_to_userspace(src.as_ptr(), dst.as_mut_ptr().offset(offset), size) };\n+\n+            // Verify copy\n+            for byte in 0..size {\n+                unsafe {\n+                    assert_eq!(*dst.as_ptr().offset(offset + byte as isize), src[byte as usize]);\n+                }\n+            }\n+        }\n+    }\n+}"}]}