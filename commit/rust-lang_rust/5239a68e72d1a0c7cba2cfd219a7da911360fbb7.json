{"sha": "5239a68e72d1a0c7cba2cfd219a7da911360fbb7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyMzlhNjhlNzJkMWEwYzdjYmEyY2ZkMjE5YTdkYTkxMTM2MGZiYjc=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-06-22T06:29:08Z"}, "committer": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2020-06-29T19:31:25Z"}, "message": "add spans to injected coverage counters\n\nadded regions with counter expressions and counters.\n\nAdded codegen_llvm/coverageinfo mod for upcoming coverage map\n\nMove coverage region collection to CodegenCx finalization\n\nMoved from `query coverageinfo` (renamed from `query coverage_data`),\nas discussed in the PR at:\n\nhttps://github.com/rust-lang/rust/pull/73684#issuecomment-649882503\n\nAddress merge conflict in MIR instrument_coverage test\n\nThe MIR test output format changed for int types.\n\nmoved debug messages out of block.rs\n\nThis makes the block.rs calls to add coverage mapping data to the\nCodegenCx much more concise and readable.\n\nmove coverage intrinsic handling into llvm impl\n\nI realized that having half of the coverage intrinsic handling in\n`rustc_codegen_ssa` and half in `rustc_codegen_llvm` meant that any\nnon-llvm backend would be bound to the same decisions about how the\ncoverage-related MIR terminators should be handled.\n\nTo fix this, I moved the non-codegen portion of coverage intrinsic\nhandling into its own trait, and implemented it in `rustc_codegen_llvm`\nalongside `codegen_intrinsic_call`.\n\nI also added the (required?) stubs for the new intrinsics to\n`IntrepretCx::emulate_intrinsic()`, to ensure calls to this function do\nnot fail if called with these new but known intrinsics.\n\naddress PR Feedback on 28 June 2020 2:48pm PDT", "tree": {"sha": "583ab073ee403925d571aeb7876449148e8e5156", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/583ab073ee403925d571aeb7876449148e8e5156"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5239a68e72d1a0c7cba2cfd219a7da911360fbb7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5239a68e72d1a0c7cba2cfd219a7da911360fbb7", "html_url": "https://github.com/rust-lang/rust/commit/5239a68e72d1a0c7cba2cfd219a7da911360fbb7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c977b8775dd72d191ff1d8e8dceaf4b4cd5db86c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c977b8775dd72d191ff1d8e8dceaf4b4cd5db86c", "html_url": "https://github.com/rust-lang/rust/commit/c977b8775dd72d191ff1d8e8dceaf4b4cd5db86c"}], "stats": {"total": 678, "additions": 585, "deletions": 93}, "files": [{"sha": "80be8c158023d5ca3b769c264fd4d3c8cfab796b", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=5239a68e72d1a0c7cba2cfd219a7da911360fbb7", "patch": "@@ -1956,7 +1956,40 @@ extern \"rust-intrinsic\" {\n     /// generation.\n     #[cfg(not(bootstrap))]\n     #[lang = \"count_code_region\"]\n-    pub fn count_code_region(index: u32);\n+    pub fn count_code_region(index: u32, start_byte_pos: u32, end_byte_pos: u32);\n+\n+    /// Internal marker for code coverage expressions, injected into the MIR when the\n+    /// \"instrument-coverage\" option is enabled. This intrinsic is not converted into a\n+    /// backend intrinsic call, but its arguments are extracted during the production of a\n+    /// \"coverage map\", which is injected into the generated code, as additional data.\n+    /// This marker identifies a code region and two other counters or counter expressions\n+    /// whose sum is the number of times the code region was executed.\n+    #[cfg(not(bootstrap))]\n+    pub fn coverage_counter_add(\n+        index: u32,\n+        left_index: u32,\n+        right_index: u32,\n+        start_byte_pos: u32,\n+        end_byte_pos: u32,\n+    );\n+\n+    /// This marker identifies a code region and two other counters or counter expressions\n+    /// whose difference is the number of times the code region was executed.\n+    /// (See `coverage_counter_add` for more information.)\n+    #[cfg(not(bootstrap))]\n+    pub fn coverage_counter_subtract(\n+        index: u32,\n+        left_index: u32,\n+        right_index: u32,\n+        start_byte_pos: u32,\n+        end_byte_pos: u32,\n+    );\n+\n+    /// This marker identifies a code region to be added to the \"coverage map\" to indicate source\n+    /// code that can never be reached.\n+    /// (See `coverage_counter_add` for more information.)\n+    #[cfg(not(bootstrap))]\n+    pub fn coverage_unreachable(start_byte_pos: u32, end_byte_pos: u32);\n \n     /// See documentation of `<*const T>::guaranteed_eq` for details.\n     #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]"}, {"sha": "d5e0d7d36ee7a010e2d257c42f5ca7e9ecbee62b", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=5239a68e72d1a0c7cba2cfd219a7da911360fbb7", "patch": "@@ -150,6 +150,11 @@ pub fn compile_codegen_unit(\n                 cx.create_used_variable()\n             }\n \n+            // Finalize code coverage by injecting the coverage map\n+            if cx.sess().opts.debugging_opts.instrument_coverage {\n+                cx.coverageinfo_finalize();\n+            }\n+\n             // Finalize debuginfo\n             if cx.sess().opts.debuginfo != DebugInfo::None {\n                 cx.debuginfo_finalize();"}, {"sha": "e9a001bab75405317cf8b311fb2516a0496b6fe4", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=5239a68e72d1a0c7cba2cfd219a7da911360fbb7", "patch": "@@ -1,5 +1,6 @@\n use crate::attributes;\n use crate::callee::get_fn;\n+use crate::coverageinfo;\n use crate::debuginfo;\n use crate::llvm;\n use crate::llvm_util;\n@@ -77,6 +78,7 @@ pub struct CodegenCx<'ll, 'tcx> {\n     pub pointee_infos: RefCell<FxHashMap<(Ty<'tcx>, Size), Option<PointeeInfo>>>,\n     pub isize_ty: &'ll Type,\n \n+    pub coverage_cx: Option<coverageinfo::CrateCoverageContext<'tcx>>,\n     pub dbg_cx: Option<debuginfo::CrateDebugContext<'ll, 'tcx>>,\n \n     eh_personality: Cell<Option<&'ll Value>>,\n@@ -256,6 +258,13 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n \n         let (llcx, llmod) = (&*llvm_module.llcx, llvm_module.llmod());\n \n+        let coverage_cx = if tcx.sess.opts.debugging_opts.instrument_coverage {\n+            let covctx = coverageinfo::CrateCoverageContext::new();\n+            Some(covctx)\n+        } else {\n+            None\n+        };\n+\n         let dbg_cx = if tcx.sess.opts.debuginfo != DebugInfo::None {\n             let dctx = debuginfo::CrateDebugContext::new(llmod);\n             debuginfo::metadata::compile_unit_metadata(tcx, &codegen_unit.name().as_str(), &dctx);\n@@ -285,6 +294,7 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n             scalar_lltypes: Default::default(),\n             pointee_infos: Default::default(),\n             isize_ty,\n+            coverage_cx,\n             dbg_cx,\n             eh_personality: Cell::new(None),\n             rust_try_fn: Cell::new(None),\n@@ -296,6 +306,11 @@ impl<'ll, 'tcx> CodegenCx<'ll, 'tcx> {\n     crate fn statics_to_rauw(&self) -> &RefCell<Vec<(&'ll Value, &'ll Value)>> {\n         &self.statics_to_rauw\n     }\n+\n+    #[inline]\n+    pub fn coverage_context(&'a self) -> &'a coverageinfo::CrateCoverageContext<'tcx> {\n+        self.coverage_cx.as_ref().unwrap()\n+    }\n }\n \n impl MiscMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n@@ -749,8 +764,6 @@ impl CodegenCx<'b, 'tcx> {\n         ifn!(\"llvm.lifetime.start.p0i8\", fn(t_i64, i8p) -> void);\n         ifn!(\"llvm.lifetime.end.p0i8\", fn(t_i64, i8p) -> void);\n \n-        ifn!(\"llvm.instrprof.increment\", fn(i8p, t_i64, t_i32, t_i32) -> void);\n-\n         ifn!(\"llvm.expect.i1\", fn(i1, i1) -> i1);\n         ifn!(\"llvm.eh.typeid.for\", fn(i8p) -> t_i32);\n         ifn!(\"llvm.localescape\", fn(...) -> void);\n@@ -765,6 +778,10 @@ impl CodegenCx<'b, 'tcx> {\n         ifn!(\"llvm.va_end\", fn(i8p) -> void);\n         ifn!(\"llvm.va_copy\", fn(i8p, i8p) -> void);\n \n+        if self.sess().opts.debugging_opts.instrument_coverage {\n+            ifn!(\"llvm.instrprof.increment\", fn(i8p, t_i64, t_i32, t_i32) -> void);\n+        }\n+\n         if self.sess().opts.debuginfo != DebugInfo::None {\n             ifn!(\"llvm.dbg.declare\", fn(self.type_metadata(), self.type_metadata()) -> void);\n             ifn!(\"llvm.dbg.value\", fn(self.type_metadata(), t_i64, self.type_metadata()) -> void);"}, {"sha": "ff9f8f7aeaa544ec591697a2528c5383edc037bd", "filename": "src/librustc_codegen_llvm/coverageinfo/mod.rs", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcoverageinfo%2Fmod.rs?ref=5239a68e72d1a0c7cba2cfd219a7da911360fbb7", "patch": "@@ -0,0 +1,126 @@\n+use crate::builder::Builder;\n+use crate::common::CodegenCx;\n+use log::debug;\n+use rustc_codegen_ssa::coverageinfo::map::*;\n+use rustc_codegen_ssa::traits::{CoverageInfoBuilderMethods, CoverageInfoMethods};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_middle::ty::Instance;\n+\n+use std::cell::RefCell;\n+\n+/// A context object for maintaining all state needed by the coverageinfo module.\n+pub struct CrateCoverageContext<'tcx> {\n+    // Coverage region data for each instrumented function identified by DefId.\n+    pub(crate) coverage_regions: RefCell<FxHashMap<Instance<'tcx>, FunctionCoverageRegions>>,\n+}\n+\n+impl<'tcx> CrateCoverageContext<'tcx> {\n+    pub fn new() -> Self {\n+        Self { coverage_regions: Default::default() }\n+    }\n+}\n+\n+/// Generates and exports the Coverage Map.\n+// FIXME(richkadel): Actually generate and export the coverage map to LLVM.\n+// The current implementation is actually just debug messages to show the data is available.\n+pub fn finalize(cx: &CodegenCx<'_, '_>) {\n+    let coverage_regions = &*cx.coverage_context().coverage_regions.borrow();\n+    for instance in coverage_regions.keys() {\n+        let coverageinfo = cx.tcx.coverageinfo(instance.def_id());\n+        debug_assert!(coverageinfo.num_counters > 0);\n+        debug!(\n+            \"Generate coverage map for: {:?}, hash: {}, num_counters: {}\",\n+            instance, coverageinfo.hash, coverageinfo.num_counters\n+        );\n+        let function_coverage_regions = &coverage_regions[instance];\n+        for (index, region) in function_coverage_regions.indexed_regions() {\n+            match region.kind {\n+                CoverageKind::Counter => debug!(\n+                    \"  Counter {}, for {}..{}\",\n+                    index, region.coverage_span.start_byte_pos, region.coverage_span.end_byte_pos\n+                ),\n+                CoverageKind::CounterExpression(lhs, op, rhs) => debug!(\n+                    \"  CounterExpression {} = {} {:?} {}, for {}..{}\",\n+                    index,\n+                    lhs,\n+                    op,\n+                    rhs,\n+                    region.coverage_span.start_byte_pos,\n+                    region.coverage_span.end_byte_pos\n+                ),\n+            }\n+        }\n+        for unreachable in function_coverage_regions.unreachable_regions() {\n+            debug!(\n+                \"  Unreachable code region: {}..{}\",\n+                unreachable.start_byte_pos, unreachable.end_byte_pos\n+            );\n+        }\n+    }\n+}\n+\n+impl CoverageInfoMethods for CodegenCx<'ll, 'tcx> {\n+    fn coverageinfo_finalize(&self) {\n+        finalize(self)\n+    }\n+}\n+\n+impl CoverageInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n+    fn add_counter_region(\n+        &mut self,\n+        instance: Instance<'tcx>,\n+        index: u32,\n+        start_byte_pos: u32,\n+        end_byte_pos: u32,\n+    ) {\n+        debug!(\n+            \"adding counter to coverage map: instance={:?}, index={}, byte range {}..{}\",\n+            instance, index, start_byte_pos, end_byte_pos,\n+        );\n+        let mut coverage_regions = self.coverage_context().coverage_regions.borrow_mut();\n+        coverage_regions.entry(instance).or_default().add_counter(\n+            index,\n+            start_byte_pos,\n+            end_byte_pos,\n+        );\n+    }\n+\n+    fn add_counter_expression_region(\n+        &mut self,\n+        instance: Instance<'tcx>,\n+        index: u32,\n+        lhs: u32,\n+        op: CounterOp,\n+        rhs: u32,\n+        start_byte_pos: u32,\n+        end_byte_pos: u32,\n+    ) {\n+        debug!(\n+            \"adding counter expression to coverage map: instance={:?}, index={}, {} {:?} {}, byte range {}..{}\",\n+            instance, index, lhs, op, rhs, start_byte_pos, end_byte_pos,\n+        );\n+        let mut coverage_regions = self.coverage_context().coverage_regions.borrow_mut();\n+        coverage_regions.entry(instance).or_default().add_counter_expression(\n+            index,\n+            lhs,\n+            op,\n+            rhs,\n+            start_byte_pos,\n+            end_byte_pos,\n+        );\n+    }\n+\n+    fn add_unreachable_region(\n+        &mut self,\n+        instance: Instance<'tcx>,\n+        start_byte_pos: u32,\n+        end_byte_pos: u32,\n+    ) {\n+        debug!(\n+            \"adding unreachable code to coverage map: instance={:?}, byte range {}..{}\",\n+            instance, start_byte_pos, end_byte_pos,\n+        );\n+        let mut coverage_regions = self.coverage_context().coverage_regions.borrow_mut();\n+        coverage_regions.entry(instance).or_default().add_unreachable(start_byte_pos, end_byte_pos);\n+    }\n+}"}, {"sha": "de90ac0bac1d333941cc52854096efa470e36f11", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 60, "deletions": 5, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=5239a68e72d1a0c7cba2cfd219a7da911360fbb7", "patch": "@@ -13,12 +13,15 @@ use rustc_ast::ast;\n use rustc_codegen_ssa::base::{compare_simd_types, to_immediate, wants_msvc_seh};\n use rustc_codegen_ssa::common::span_invalid_monomorphization_error;\n use rustc_codegen_ssa::common::{IntPredicate, TypeKind};\n+use rustc_codegen_ssa::coverageinfo::CounterOp;\n use rustc_codegen_ssa::glue;\n use rustc_codegen_ssa::mir::operand::{OperandRef, OperandValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::*;\n use rustc_codegen_ssa::MemFlags;\n use rustc_hir as hir;\n+use rustc_middle::mir::coverage;\n+use rustc_middle::mir::Operand;\n use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt};\n use rustc_middle::ty::{self, Ty};\n use rustc_middle::{bug, span_bug};\n@@ -81,6 +84,53 @@ fn get_simple_intrinsic(cx: &CodegenCx<'ll, '_>, name: &str) -> Option<&'ll Valu\n }\n \n impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n+    fn is_codegen_intrinsic(\n+        &mut self,\n+        intrinsic: &str,\n+        args: &Vec<Operand<'tcx>>,\n+        caller_instance: ty::Instance<'tcx>,\n+    ) -> bool {\n+        match intrinsic {\n+            \"count_code_region\" => {\n+                use coverage::count_code_region_args::*;\n+                self.add_counter_region(\n+                    caller_instance,\n+                    op_to_u32(&args[COUNTER_INDEX]),\n+                    op_to_u32(&args[START_BYTE_POS]),\n+                    op_to_u32(&args[END_BYTE_POS]),\n+                );\n+                true // Also inject the counter increment in the backend\n+            }\n+            \"coverage_counter_add\" | \"coverage_counter_subtract\" => {\n+                use coverage::coverage_counter_expression_args::*;\n+                self.add_counter_expression_region(\n+                    caller_instance,\n+                    op_to_u32(&args[COUNTER_EXPRESSION_INDEX]),\n+                    op_to_u32(&args[LEFT_INDEX]),\n+                    if intrinsic == \"coverage_counter_add\" {\n+                        CounterOp::Add\n+                    } else {\n+                        CounterOp::Subtract\n+                    },\n+                    op_to_u32(&args[RIGHT_INDEX]),\n+                    op_to_u32(&args[START_BYTE_POS]),\n+                    op_to_u32(&args[END_BYTE_POS]),\n+                );\n+                false // Does not inject backend code\n+            }\n+            \"coverage_unreachable\" => {\n+                use coverage::coverage_unreachable_args::*;\n+                self.add_unreachable_region(\n+                    caller_instance,\n+                    op_to_u32(&args[START_BYTE_POS]),\n+                    op_to_u32(&args[END_BYTE_POS]),\n+                );\n+                false // Does not inject backend code\n+            }\n+            _ => true, // Unhandled intrinsics should be passed to `codegen_intrinsic_call()`\n+        }\n+    }\n+\n     fn codegen_intrinsic_call(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n@@ -143,15 +193,16 @@ impl IntrinsicCallMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                 // FIXME(richkadel): The current implementation assumes the MIR for the given\n                 // caller_instance represents a single function. Validate and/or correct if inlining\n                 // and/or monomorphization invalidates these assumptions.\n-                let coverage_data = tcx.coverage_data(caller_instance.def_id());\n+                let coverageinfo = tcx.coverageinfo(caller_instance.def_id());\n                 let mangled_fn = tcx.symbol_name(caller_instance);\n                 let (mangled_fn_name, _len_val) = self.const_str(mangled_fn.name);\n-                let hash = self.const_u64(coverage_data.hash);\n-                let num_counters = self.const_u32(coverage_data.num_counters);\n-                let index = args[0].immediate();\n+                let hash = self.const_u64(coverageinfo.hash);\n+                let num_counters = self.const_u32(coverageinfo.num_counters);\n+                use coverage::count_code_region_args::*;\n+                let index = args[COUNTER_INDEX].immediate();\n                 debug!(\n                     \"count_code_region to LLVM intrinsic instrprof.increment(fn_name={}, hash={:?}, num_counters={:?}, index={:?})\",\n-                    mangled_fn.name, hash, num_counters, index\n+                    mangled_fn.name, hash, num_counters, index,\n                 );\n                 self.instrprof_increment(mangled_fn_name, hash, num_counters, index)\n             }\n@@ -2131,3 +2182,7 @@ fn float_type_width(ty: Ty<'_>) -> Option<u64> {\n         _ => None,\n     }\n }\n+\n+fn op_to_u32<'tcx>(op: &Operand<'tcx>) -> u32 {\n+    Operand::scalar_from_const(op).to_u32().expect(\"Scalar is u32\")\n+}"}, {"sha": "565968f9952e5755ae2e688da7442fd9869d2c92", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=5239a68e72d1a0c7cba2cfd219a7da911360fbb7", "patch": "@@ -55,6 +55,7 @@ mod callee;\n mod common;\n mod consts;\n mod context;\n+mod coverageinfo;\n mod debuginfo;\n mod declare;\n mod intrinsic;"}, {"sha": "3bd262cf2b21374915a0b2ff9c9bc82cf2cd82cd", "filename": "src/librustc_codegen_ssa/coverageinfo/map.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmap.rs?ref=5239a68e72d1a0c7cba2cfd219a7da911360fbb7", "patch": "@@ -0,0 +1,83 @@\n+use rustc_data_structures::fx::FxHashMap;\n+use std::collections::hash_map;\n+use std::slice;\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum CounterOp {\n+    Add,\n+    Subtract,\n+}\n+\n+pub enum CoverageKind {\n+    Counter,\n+    CounterExpression(u32, CounterOp, u32),\n+}\n+\n+pub struct CoverageSpan {\n+    pub start_byte_pos: u32,\n+    pub end_byte_pos: u32,\n+}\n+\n+pub struct CoverageRegion {\n+    pub kind: CoverageKind,\n+    pub coverage_span: CoverageSpan,\n+}\n+\n+/// Collects all of the coverage regions associated with (a) injected counters, (b) counter\n+/// expressions (additions or subtraction), and (c) unreachable regions (always counted as zero),\n+/// for a given Function. Counters and counter expressions are indexed because they can be operands\n+/// in an expression.\n+///\n+/// Note, it's important to distinguish the `unreachable` region type from what LLVM's refers to as\n+/// a \"gap region\" (or \"gap area\"). A gap region is a code region within a counted region (either\n+/// counter or expression), but the line or lines in the gap region are not executable (such as\n+/// lines with only whitespace or comments). According to LLVM Code Coverage Mapping documentation,\n+/// \"A count for a gap area is only used as the line execution count if there are no other regions\n+/// on a line.\"\n+#[derive(Default)]\n+pub struct FunctionCoverageRegions {\n+    indexed: FxHashMap<u32, CoverageRegion>,\n+    unreachable: Vec<CoverageSpan>,\n+}\n+\n+impl FunctionCoverageRegions {\n+    pub fn add_counter(&mut self, index: u32, start_byte_pos: u32, end_byte_pos: u32) {\n+        self.indexed.insert(\n+            index,\n+            CoverageRegion {\n+                kind: CoverageKind::Counter,\n+                coverage_span: CoverageSpan { start_byte_pos, end_byte_pos },\n+            },\n+        );\n+    }\n+\n+    pub fn add_counter_expression(\n+        &mut self,\n+        index: u32,\n+        lhs: u32,\n+        op: CounterOp,\n+        rhs: u32,\n+        start_byte_pos: u32,\n+        end_byte_pos: u32,\n+    ) {\n+        self.indexed.insert(\n+            index,\n+            CoverageRegion {\n+                kind: CoverageKind::CounterExpression(lhs, op, rhs),\n+                coverage_span: CoverageSpan { start_byte_pos, end_byte_pos },\n+            },\n+        );\n+    }\n+\n+    pub fn add_unreachable(&mut self, start_byte_pos: u32, end_byte_pos: u32) {\n+        self.unreachable.push(CoverageSpan { start_byte_pos, end_byte_pos });\n+    }\n+\n+    pub fn indexed_regions(&self) -> hash_map::Iter<'_, u32, CoverageRegion> {\n+        self.indexed.iter()\n+    }\n+\n+    pub fn unreachable_regions(&self) -> slice::Iter<'_, CoverageSpan> {\n+        self.unreachable.iter()\n+    }\n+}"}, {"sha": "304f8e19da4e672cbb0b49312552c6767760e5a1", "filename": "src/librustc_codegen_ssa/coverageinfo/mod.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fcoverageinfo%2Fmod.rs?ref=5239a68e72d1a0c7cba2cfd219a7da911360fbb7", "patch": "@@ -0,0 +1,3 @@\n+pub mod map;\n+\n+pub use map::CounterOp;"}, {"sha": "618df15f5bcbe7aa94736ed19642b7f05426c841", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=5239a68e72d1a0c7cba2cfd219a7da911360fbb7", "patch": "@@ -34,6 +34,7 @@ use std::path::{Path, PathBuf};\n pub mod back;\n pub mod base;\n pub mod common;\n+pub mod coverageinfo;\n pub mod debuginfo;\n pub mod glue;\n pub mod meth;"}, {"sha": "7514eb8e889a8cc58f7beffc4b46e0b675e31a76", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=5239a68e72d1a0c7cba2cfd219a7da911360fbb7", "patch": "@@ -651,6 +651,18 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         }\n \n         if intrinsic.is_some() && intrinsic != Some(\"drop_in_place\") {\n+            let intrinsic = intrinsic.unwrap();\n+\n+            // `is_codegen_intrinsic()` allows the backend implementation to perform compile-time\n+            // operations before converting the `args` to backend values.\n+            if !bx.is_codegen_intrinsic(intrinsic, &args, self.instance) {\n+                // If the intrinsic call was fully addressed by the `is_codegen_intrinsic()` call\n+                // (as a compile-time operation), return immediately. This avoids the need to\n+                // convert the arguments, the call to `codegen_intrinsic_call()`, and the return\n+                // value handling.\n+                return;\n+            }\n+\n             let dest = match ret_dest {\n                 _ if fn_abi.ret.is_indirect() => llargs[0],\n                 ReturnDest::Nothing => {\n@@ -670,7 +682,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     // third argument must be constant. This is\n                     // checked by const-qualification, which also\n                     // promotes any complex rvalues to constants.\n-                    if i == 2 && intrinsic.unwrap().starts_with(\"simd_shuffle\") {\n+                    if i == 2 && intrinsic.starts_with(\"simd_shuffle\") {\n                         if let mir::Operand::Constant(constant) = arg {\n                             let c = self.eval_mir_constant(constant);\n                             let (llval, ty) = self.simd_shuffle_indices("}, {"sha": "994d8e0395dc7d52334d7ecc0cfbba028698d9f0", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=5239a68e72d1a0c7cba2cfd219a7da911360fbb7", "patch": "@@ -1,5 +1,6 @@\n use super::abi::AbiBuilderMethods;\n use super::asm::AsmBuilderMethods;\n+use super::coverageinfo::CoverageInfoBuilderMethods;\n use super::debuginfo::DebugInfoBuilderMethods;\n use super::intrinsic::IntrinsicCallMethods;\n use super::type_::ArgAbiMethods;\n@@ -29,6 +30,7 @@ pub enum OverflowOp {\n \n pub trait BuilderMethods<'a, 'tcx>:\n     HasCodegen<'tcx>\n+    + CoverageInfoBuilderMethods<'tcx>\n     + DebugInfoBuilderMethods\n     + ArgAbiMethods<'tcx>\n     + AbiBuilderMethods<'tcx>"}, {"sha": "d80f90fa4fa0d7eb6412b83aa7ef387c2d58ae4c", "filename": "src/librustc_codegen_ssa/traits/coverageinfo.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fcoverageinfo.rs?ref=5239a68e72d1a0c7cba2cfd219a7da911360fbb7", "patch": "@@ -0,0 +1,35 @@\n+use super::BackendTypes;\n+use crate::coverageinfo::CounterOp;\n+use rustc_middle::ty::Instance;\n+\n+pub trait CoverageInfoMethods: BackendTypes {\n+    fn coverageinfo_finalize(&self);\n+}\n+\n+pub trait CoverageInfoBuilderMethods<'tcx>: BackendTypes {\n+    fn add_counter_region(\n+        &mut self,\n+        instance: Instance<'tcx>,\n+        index: u32,\n+        start_byte_pos: u32,\n+        end_byte_pos: u32,\n+    );\n+\n+    fn add_counter_expression_region(\n+        &mut self,\n+        instance: Instance<'tcx>,\n+        index: u32,\n+        lhs: u32,\n+        op: CounterOp,\n+        rhs: u32,\n+        start_byte_pos: u32,\n+        end_byte_pos: u32,\n+    );\n+\n+    fn add_unreachable_region(\n+        &mut self,\n+        instance: Instance<'tcx>,\n+        start_byte_pos: u32,\n+        end_byte_pos: u32,\n+    );\n+}"}, {"sha": "e713cc948c10d0869e77965a03610ff310943beb", "filename": "src/librustc_codegen_ssa/traits/intrinsic.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs?ref=5239a68e72d1a0c7cba2cfd219a7da911360fbb7", "patch": "@@ -1,5 +1,6 @@\n use super::BackendTypes;\n use crate::mir::operand::OperandRef;\n+use rustc_middle::mir::Operand;\n use rustc_middle::ty::{self, Ty};\n use rustc_span::Span;\n use rustc_target::abi::call::FnAbi;\n@@ -18,6 +19,16 @@ pub trait IntrinsicCallMethods<'tcx>: BackendTypes {\n         caller_instance: ty::Instance<'tcx>,\n     );\n \n+    /// Intrinsic-specific pre-codegen processing, if any is required. Some intrinsics are handled\n+    /// at compile time and do not generate code. Returns true if codegen is required or false if\n+    /// the intrinsic does not need code generation.\n+    fn is_codegen_intrinsic(\n+        &mut self,\n+        intrinsic: &str,\n+        args: &Vec<Operand<'tcx>>,\n+        caller_instance: ty::Instance<'tcx>,\n+    ) -> bool;\n+\n     fn abort(&mut self);\n     fn assume(&mut self, val: Self::Value);\n     fn expect(&mut self, cond: Self::Value, expected: bool) -> Self::Value;"}, {"sha": "0ac519dd0b17cb9e2b7a5891c96c44142d5c243e", "filename": "src/librustc_codegen_ssa/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs?ref=5239a68e72d1a0c7cba2cfd219a7da911360fbb7", "patch": "@@ -19,6 +19,7 @@ mod asm;\n mod backend;\n mod builder;\n mod consts;\n+mod coverageinfo;\n mod debuginfo;\n mod declare;\n mod intrinsic;\n@@ -32,6 +33,7 @@ pub use self::asm::{AsmBuilderMethods, AsmMethods, InlineAsmOperandRef};\n pub use self::backend::{Backend, BackendTypes, CodegenBackend, ExtraBackendMethods};\n pub use self::builder::{BuilderMethods, OverflowOp};\n pub use self::consts::ConstMethods;\n+pub use self::coverageinfo::{CoverageInfoBuilderMethods, CoverageInfoMethods};\n pub use self::debuginfo::{DebugInfoBuilderMethods, DebugInfoMethods};\n pub use self::declare::{DeclareMethods, PreDefineMethods};\n pub use self::intrinsic::IntrinsicCallMethods;\n@@ -56,6 +58,7 @@ pub trait CodegenMethods<'tcx>:\n     + MiscMethods<'tcx>\n     + ConstMethods<'tcx>\n     + StaticMethods\n+    + CoverageInfoMethods\n     + DebugInfoMethods<'tcx>\n     + DeclareMethods<'tcx>\n     + AsmMethods\n@@ -72,6 +75,7 @@ impl<'tcx, T> CodegenMethods<'tcx> for T where\n         + MiscMethods<'tcx>\n         + ConstMethods<'tcx>\n         + StaticMethods\n+        + CoverageInfoMethods\n         + DebugInfoMethods<'tcx>\n         + DeclareMethods<'tcx>\n         + AsmMethods"}, {"sha": "c5dedab979326ab6a6c2657c2db775e317de759c", "filename": "src/librustc_index/vec.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_index%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_index%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2Fvec.rs?ref=5239a68e72d1a0c7cba2cfd219a7da911360fbb7", "patch": "@@ -536,7 +536,8 @@ impl<I: Idx, T> IndexVec<I, T> {\n     }\n \n     /// Create an `IndexVec` with `n` elements, where the value of each\n-    /// element is the result of `func(i)`\n+    /// element is the result of `func(i)`. (The underlying vector will\n+    /// be allocated only once, with a capacity of at least `n`.)\n     #[inline]\n     pub fn from_fn_n(func: impl FnMut(I) -> T, n: usize) -> Self {\n         let indices = (0..n).map(I::new);"}, {"sha": "327f321bd7534d8eb02ba7890bdac3b30a11cb7c", "filename": "src/librustc_middle/mir/coverage/mod.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_middle%2Fmir%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_middle%2Fmir%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fcoverage%2Fmod.rs?ref=5239a68e72d1a0c7cba2cfd219a7da911360fbb7", "patch": "@@ -0,0 +1,24 @@\n+//! Metadata from source code coverage analysis and instrumentation.\n+\n+/// Positional arguments to `libcore::count_code_region()`\n+pub mod count_code_region_args {\n+    pub const COUNTER_INDEX: usize = 0;\n+    pub const START_BYTE_POS: usize = 1;\n+    pub const END_BYTE_POS: usize = 2;\n+}\n+\n+/// Positional arguments to `libcore::coverage_counter_add()` and\n+/// `libcore::coverage_counter_subtract()`\n+pub mod coverage_counter_expression_args {\n+    pub const COUNTER_EXPRESSION_INDEX: usize = 0;\n+    pub const LEFT_INDEX: usize = 1;\n+    pub const RIGHT_INDEX: usize = 2;\n+    pub const START_BYTE_POS: usize = 3;\n+    pub const END_BYTE_POS: usize = 4;\n+}\n+\n+/// Positional arguments to `libcore::coverage_unreachable()`\n+pub mod coverage_unreachable_args {\n+    pub const START_BYTE_POS: usize = 0;\n+    pub const END_BYTE_POS: usize = 1;\n+}"}, {"sha": "a3eddd3ff7ba78aeb9b358f840b0da365d790be9", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=5239a68e72d1a0c7cba2cfd219a7da911360fbb7", "patch": "@@ -40,6 +40,7 @@ use std::{iter, mem, option};\n use self::predecessors::{PredecessorCache, Predecessors};\n pub use self::query::*;\n \n+pub mod coverage;\n pub mod interpret;\n pub mod mono;\n mod predecessors;\n@@ -2307,6 +2308,18 @@ impl<'tcx> Operand<'tcx> {\n         })\n     }\n \n+    /// Convenience helper to make a `Scalar` from the given `Operand`, assuming that `Operand`\n+    /// wraps a constant literal value. Panics if this is not the case.\n+    pub fn scalar_from_const(operand: &Operand<'tcx>) -> Scalar {\n+        match operand {\n+            Operand::Constant(constant) => match constant.literal.val.try_to_scalar() {\n+                Some(scalar) => scalar,\n+                _ => panic!(\"{:?}: Scalar value expected\", constant.literal.val),\n+            },\n+            _ => panic!(\"{:?}: Constant expected\", operand),\n+        }\n+    }\n+\n     pub fn to_copy(&self) -> Self {\n         match *self {\n             Operand::Copy(_) | Operand::Constant(_) => self.clone(),\n@@ -2980,18 +2993,3 @@ impl Location {\n         }\n     }\n }\n-\n-/// Coverage data associated with each function (MIR) instrumented with coverage counters, when\n-/// compiled with `-Zinstrument_coverage`. The query `tcx.coverage_data(DefId)` computes these\n-/// values on demand (during code generation). This query is only valid after executing the MIR pass\n-/// `InstrumentCoverage`.\n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct CoverageData {\n-    /// A hash value that can be used by the consumer of the coverage profile data to detect\n-    /// changes to the instrumented source of the associated MIR body (typically, for an\n-    /// individual function).\n-    pub hash: u64,\n-\n-    /// The total number of coverage region counters added to the MIR `Body`.\n-    pub num_counters: u32,\n-}"}, {"sha": "8dddaf40c8264a12b7651def9b9764e00e8c9a45", "filename": "src/librustc_middle/mir/query.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fquery.rs?ref=5239a68e72d1a0c7cba2cfd219a7da911360fbb7", "patch": "@@ -309,3 +309,17 @@ pub struct DestructuredConst<'tcx> {\n     pub variant: Option<VariantIdx>,\n     pub fields: &'tcx [&'tcx ty::Const<'tcx>],\n }\n+\n+/// Coverage information summarized from a MIR if instrumented for source code coverage (see\n+/// compiler option `-Zinstrument-coverage`). This information is generated by the\n+/// `InstrumentCoverage` MIR pass and can be retrieved via the `coverageinfo` query.\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+pub struct CoverageInfo {\n+    /// A hash value that can be used by the consumer of the coverage profile data to detect\n+    /// changes to the instrumented source of the associated MIR body (typically, for an\n+    /// individual function).\n+    pub hash: u64,\n+\n+    /// The total number of coverage region counters added to the MIR `Body`.\n+    pub num_counters: u32,\n+}"}, {"sha": "c9201855462ee0f8f04524f710ac0b039a7ef4ad", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=5239a68e72d1a0c7cba2cfd219a7da911360fbb7", "patch": "@@ -231,8 +231,10 @@ rustc_queries! {\n             cache_on_disk_if { key.is_local() }\n         }\n \n-        query coverage_data(key: DefId) -> mir::CoverageData {\n-            desc { |tcx| \"retrieving coverage data from MIR for `{}`\", tcx.def_path_str(key) }\n+        /// Returns coverage summary info for a function, after executing the `InstrumentCoverage`\n+        /// MIR pass (assuming the -Zinstrument-coverage option is enabled).\n+        query coverageinfo(key: DefId) -> mir::CoverageInfo {\n+            desc { |tcx| \"retrieving coverage info from MIR for `{}`\", tcx.def_path_str(key) }\n             storage(ArenaCacheSelector<'tcx>)\n             cache_on_disk_if { key.is_local() }\n         }"}, {"sha": "a2bd65e82e24e56faefaa94a6de51791a15b1098", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=5239a68e72d1a0c7cba2cfd219a7da911360fbb7", "patch": "@@ -410,7 +410,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 self.copy_op(self.operand_index(args[0], index)?, dest)?;\n             }\n             // FIXME(#73156): Handle source code coverage in const eval\n-            sym::count_code_region => (),\n+            sym::count_code_region\n+            | sym::coverage_counter_add\n+            | sym::coverage_counter_subtract\n+            | sym::coverage_unreachable => (),\n             _ => return Ok(false),\n         }\n "}, {"sha": "c03be2a8fcd69c15d9d914784daf1977f4ca3073", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=5239a68e72d1a0c7cba2cfd219a7da911360fbb7", "patch": "@@ -39,7 +39,14 @@ struct CallSite<'tcx> {\n impl<'tcx> MirPass<'tcx> for Inline {\n     fn run_pass(&self, tcx: TyCtxt<'tcx>, source: MirSource<'tcx>, body: &mut Body<'tcx>) {\n         if tcx.sess.opts.debugging_opts.mir_opt_level >= 2 {\n-            Inliner { tcx, source }.run_pass(body);\n+            if tcx.sess.opts.debugging_opts.instrument_coverage {\n+                // The current implementation of source code coverage injects code region counters\n+                // into the MIR, and assumes a 1-to-1 correspondence between MIR and source-code-\n+                // based function.\n+                debug!(\"function inlining is disabled when compiling with `instrument_coverage`\");\n+            } else {\n+                Inliner { tcx, source }.run_pass(body);\n+            }\n         }\n     }\n }"}, {"sha": "25e154f2e95979f6f72be3ad7aa74f6515afcc92", "filename": "src/librustc_mir/transform/instrument_coverage.rs", "status": "modified", "additions": 72, "deletions": 55, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstrument_coverage.rs?ref=5239a68e72d1a0c7cba2cfd219a7da911360fbb7", "patch": "@@ -5,65 +5,71 @@ use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::lang_items;\n use rustc_middle::hir;\n use rustc_middle::ich::StableHashingContext;\n-use rustc_middle::mir::interpret::{ConstValue, Scalar};\n+use rustc_middle::mir::coverage::*;\n+use rustc_middle::mir::interpret::Scalar;\n+use rustc_middle::mir::CoverageInfo;\n use rustc_middle::mir::{\n-    self, traversal, BasicBlock, BasicBlockData, CoverageData, Operand, Place, SourceInfo,\n-    StatementKind, Terminator, TerminatorKind, START_BLOCK,\n+    self, traversal, BasicBlock, BasicBlockData, Operand, Place, SourceInfo, StatementKind,\n+    Terminator, TerminatorKind, START_BLOCK,\n };\n use rustc_middle::ty;\n use rustc_middle::ty::query::Providers;\n+use rustc_middle::ty::FnDef;\n use rustc_middle::ty::TyCtxt;\n-use rustc_middle::ty::{ConstKind, FnDef};\n use rustc_span::def_id::DefId;\n-use rustc_span::Span;\n+use rustc_span::{Pos, Span};\n \n /// Inserts call to count_code_region() as a placeholder to be replaced during code generation with\n /// the intrinsic llvm.instrprof.increment.\n pub struct InstrumentCoverage;\n \n-/// The `query` provider for `CoverageData`, requested by `codegen_intrinsic_call()` when\n+/// The `query` provider for `CoverageInfo`, requested by `codegen_intrinsic_call()` when\n /// constructing the arguments for `llvm.instrprof.increment`.\n pub(crate) fn provide(providers: &mut Providers<'_>) {\n-    providers.coverage_data = |tcx, def_id| {\n-        let mir_body = tcx.optimized_mir(def_id);\n-        // FIXME(richkadel): The current implementation assumes the MIR for the given DefId\n-        // represents a single function. Validate and/or correct if inlining and/or monomorphization\n-        // invalidates these assumptions.\n-        let count_code_region_fn =\n-            tcx.require_lang_item(lang_items::CountCodeRegionFnLangItem, None);\n-        let mut num_counters: u32 = 0;\n-        // The `num_counters` argument to `llvm.instrprof.increment` is the number of injected\n-        // counters, with each counter having an index from `0..num_counters-1`. MIR optimization\n-        // may split and duplicate some BasicBlock sequences. Simply counting the calls may not\n-        // not work; but computing the num_counters by adding `1` to the highest index (for a given\n-        // instrumented function) is valid.\n-        for (_, data) in traversal::preorder(mir_body) {\n-            if let Some(terminator) = &data.terminator {\n-                if let TerminatorKind::Call { func: Operand::Constant(func), args, .. } =\n-                    &terminator.kind\n-                {\n-                    if let FnDef(called_fn_def_id, _) = func.literal.ty.kind {\n-                        if called_fn_def_id == count_code_region_fn {\n-                            if let Operand::Constant(constant) =\n-                                args.get(0).expect(\"count_code_region has at least one arg\")\n-                            {\n-                                if let ConstKind::Value(ConstValue::Scalar(value)) =\n-                                    constant.literal.val\n-                                {\n-                                    let index = value\n-                                        .to_u32()\n-                                        .expect(\"count_code_region index at arg0 is u32\");\n-                                    num_counters = std::cmp::max(num_counters, index + 1);\n-                                }\n-                            }\n-                        }\n-                    }\n+    providers.coverageinfo = |tcx, def_id| coverageinfo_from_mir(tcx, def_id);\n+}\n+\n+fn coverageinfo_from_mir<'tcx>(tcx: TyCtxt<'tcx>, mir_def_id: DefId) -> CoverageInfo {\n+    let mir_body = tcx.optimized_mir(mir_def_id);\n+    // FIXME(richkadel): The current implementation assumes the MIR for the given DefId\n+    // represents a single function. Validate and/or correct if inlining (which should be disabled\n+    // if -Zinstrument-coverage is enabled) and/or monomorphization invalidates these assumptions.\n+    let count_code_region_fn = tcx.require_lang_item(lang_items::CountCodeRegionFnLangItem, None);\n+\n+    // The `num_counters` argument to `llvm.instrprof.increment` is the number of injected\n+    // counters, with each counter having an index from `0..num_counters-1`. MIR optimization\n+    // may split and duplicate some BasicBlock sequences. Simply counting the calls may not\n+    // not work; but computing the num_counters by adding `1` to the highest index (for a given\n+    // instrumented function) is valid.\n+    let mut num_counters: u32 = 0;\n+    for terminator in traversal::preorder(mir_body)\n+        .map(|(_, data)| (data, count_code_region_fn))\n+        .filter_map(terminators_that_call_given_fn)\n+    {\n+        if let TerminatorKind::Call { args, .. } = &terminator.kind {\n+            let index_arg = args.get(count_code_region_args::COUNTER_INDEX).expect(\"arg found\");\n+            let index =\n+                mir::Operand::scalar_from_const(index_arg).to_u32().expect(\"index arg is u32\");\n+            num_counters = std::cmp::max(num_counters, index + 1);\n+        }\n+    }\n+    let hash = if num_counters > 0 { hash_mir_source(tcx, mir_def_id) } else { 0 };\n+    CoverageInfo { num_counters, hash }\n+}\n+\n+fn terminators_that_call_given_fn(\n+    (data, fn_def_id): (&'tcx BasicBlockData<'tcx>, DefId),\n+) -> Option<&'tcx Terminator<'tcx>> {\n+    if let Some(terminator) = &data.terminator {\n+        if let TerminatorKind::Call { func: Operand::Constant(func), .. } = &terminator.kind {\n+            if let FnDef(called_fn_def_id, _) = func.literal.ty.kind {\n+                if called_fn_def_id == fn_def_id {\n+                    return Some(&terminator);\n                 }\n             }\n         }\n-        let hash = if num_counters > 0 { hash_mir_source(tcx, def_id) } else { 0 };\n-        CoverageData { num_counters, hash }\n-    };\n+    }\n+    None\n }\n \n struct Instrumentor<'tcx> {\n@@ -102,17 +108,16 @@ impl<'tcx> Instrumentor<'tcx> {\n     fn inject_counters(&mut self, mir_body: &mut mir::Body<'tcx>) {\n         // FIXME(richkadel): As a first step, counters are only injected at the top of each\n         // function. The complete solution will inject counters at each conditional code branch.\n-        let top_of_function = START_BLOCK;\n-        let entire_function = mir_body.span;\n-\n-        self.inject_counter(mir_body, top_of_function, entire_function);\n+        let code_region = mir_body.span;\n+        let next_block = START_BLOCK;\n+        self.inject_counter(mir_body, code_region, next_block);\n     }\n \n     fn inject_counter(\n         &mut self,\n         mir_body: &mut mir::Body<'tcx>,\n-        next_block: BasicBlock,\n         code_region: Span,\n+        next_block: BasicBlock,\n     ) {\n         let injection_point = code_region.shrink_to_lo();\n \n@@ -121,12 +126,20 @@ impl<'tcx> Instrumentor<'tcx> {\n             self.tcx.require_lang_item(lang_items::CountCodeRegionFnLangItem, None),\n             injection_point,\n         );\n-        let counter_index = Operand::const_from_scalar(\n-            self.tcx,\n-            self.tcx.types.u32,\n-            Scalar::from_u32(self.next_counter()),\n-            injection_point,\n-        );\n+\n+        let index = self.next_counter();\n+\n+        let mut args = Vec::new();\n+\n+        use count_code_region_args::*;\n+        debug_assert_eq!(COUNTER_INDEX, args.len());\n+        args.push(self.const_u32(index, injection_point));\n+\n+        debug_assert_eq!(START_BYTE_POS, args.len());\n+        args.push(self.const_u32(code_region.lo().to_u32(), injection_point));\n+\n+        debug_assert_eq!(END_BYTE_POS, args.len());\n+        args.push(self.const_u32(code_region.hi().to_u32(), injection_point));\n \n         let mut patch = MirPatch::new(mir_body);\n \n@@ -136,7 +149,7 @@ impl<'tcx> Instrumentor<'tcx> {\n             new_block,\n             TerminatorKind::Call {\n                 func: count_code_region_fn,\n-                args: vec![counter_index],\n+                args,\n                 // new_block will swapped with the next_block, after applying patch\n                 destination: Some((Place::from(temp), new_block)),\n                 cleanup: None,\n@@ -154,6 +167,10 @@ impl<'tcx> Instrumentor<'tcx> {\n         // `next_block`), just swap the indexes, leaving the rest of the graph unchanged.\n         mir_body.basic_blocks_mut().swap(next_block, new_block);\n     }\n+\n+    fn const_u32(&self, value: u32, span: Span) -> Operand<'tcx> {\n+        Operand::const_from_scalar(self.tcx, self.tcx.types.u32, Scalar::from_u32(value), span)\n+    }\n }\n \n fn function_handle<'tcx>(tcx: TyCtxt<'tcx>, fn_def_id: DefId, span: Span) -> Operand<'tcx> {"}, {"sha": "f65785d15d379675d26dedfdb954e30975329c67", "filename": "src/librustc_session/options.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_session%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_session%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Foptions.rs?ref=5239a68e72d1a0c7cba2cfd219a7da911360fbb7", "patch": "@@ -881,8 +881,9 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         (default: no)\"),\n     instrument_coverage: bool = (false, parse_bool, [TRACKED],\n         \"instrument the generated code with LLVM code region counters to (in the \\\n-        future) generate coverage reports (default: no; note, the compiler build \\\n-        config must include `profiler = true`)\"),\n+        future) generate coverage reports; disables/overrides some optimization \\\n+        options (note, the compiler build config must include `profiler = true`) \\\n+        (default: no)\"),\n     instrument_mcount: bool = (false, parse_bool, [TRACKED],\n         \"insert function instrument code for mcount-based tracing (default: no)\"),\n     keep_hygiene_data: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "1159269190224ab607bf2cf27c5a03ad5f529db7", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=5239a68e72d1a0c7cba2cfd219a7da911360fbb7", "patch": "@@ -242,6 +242,9 @@ symbols! {\n         core,\n         core_intrinsics,\n         count_code_region,\n+        coverage_counter_add,\n+        coverage_counter_subtract,\n+        coverage_unreachable,\n         crate_id,\n         crate_in_paths,\n         crate_local,"}, {"sha": "6205088adadb78384d60bfa222d1d564c4496933", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=5239a68e72d1a0c7cba2cfd219a7da911360fbb7", "patch": "@@ -352,7 +352,17 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n                 return;\n             }\n \n-            \"count_code_region\" => (0, vec![tcx.types.u32], tcx.mk_unit()),\n+            \"count_code_region\" => {\n+                (0, vec![tcx.types.u32, tcx.types.u32, tcx.types.u32], tcx.mk_unit())\n+            }\n+\n+            \"coverage_counter_add\" | \"coverage_counter_subtract\" => (\n+                0,\n+                vec![tcx.types.u32, tcx.types.u32, tcx.types.u32, tcx.types.u32, tcx.types.u32],\n+                tcx.mk_unit(),\n+            ),\n+\n+            \"coverage_unreachable\" => (0, vec![tcx.types.u32, tcx.types.u32], tcx.mk_unit()),\n \n             ref other => {\n                 struct_span_err!("}, {"sha": "af2899c887a949cc17ce55d119002c4d9904902a", "filename": "src/test/mir-opt/instrument_coverage/rustc.bar.InstrumentCoverage.diff", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.bar.InstrumentCoverage.diff", "raw_url": "https://github.com/rust-lang/rust/raw/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.bar.InstrumentCoverage.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.bar.InstrumentCoverage.diff?ref=5239a68e72d1a0c7cba2cfd219a7da911360fbb7", "patch": "@@ -7,19 +7,31 @@\n   \n       bb0: {\n +         StorageLive(_1);                 // scope 0 at $DIR/instrument_coverage.rs:18:1: 20:2\n-+         _1 = const std::intrinsics::count_code_region(const 0_u32) -> bb2; // scope 0 at $DIR/instrument_coverage.rs:18:1: 20:2\n++         _1 = const std::intrinsics::count_code_region(const 0_u32, const 484_u32, const 513_u32) -> bb2; // scope 0 at $DIR/instrument_coverage.rs:18:1: 20:2\n +                                          // ty::Const\n-+                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u32) {std::intrinsics::count_code_region}\n++                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u32, u32, u32) {std::intrinsics::count_code_region}\n +                                          // + val: Value(Scalar(<ZST>))\n +                                          // mir::Constant\n +                                          // + span: $DIR/instrument_coverage.rs:18:1: 18:1\n-+                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n++                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u32, u32, u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n +                                          // ty::Const\n +                                          // + ty: u32\n +                                          // + val: Value(Scalar(0x00000000))\n +                                          // mir::Constant\n +                                          // + span: $DIR/instrument_coverage.rs:18:1: 18:1\n +                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000000)) }\n++                                          // ty::Const\n++                                          // + ty: u32\n++                                          // + val: Value(Scalar(0x000001e4))\n++                                          // mir::Constant\n++                                          // + span: $DIR/instrument_coverage.rs:18:1: 18:1\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x000001e4)) }\n++                                          // ty::Const\n++                                          // + ty: u32\n++                                          // + val: Value(Scalar(0x00000201))\n++                                          // mir::Constant\n++                                          // + span: $DIR/instrument_coverage.rs:18:1: 18:1\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000201)) }\n +     }\n + \n +     bb1 (cleanup): {"}, {"sha": "4a300230f8a9728334eb680876ec48676a067696", "filename": "src/test/mir-opt/instrument_coverage/rustc.main.InstrumentCoverage.diff", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.main.InstrumentCoverage.diff", "raw_url": "https://github.com/rust-lang/rust/raw/5239a68e72d1a0c7cba2cfd219a7da911360fbb7/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.main.InstrumentCoverage.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finstrument_coverage%2Frustc.main.InstrumentCoverage.diff?ref=5239a68e72d1a0c7cba2cfd219a7da911360fbb7", "patch": "@@ -11,19 +11,31 @@\n       bb0: {\n -         falseUnwind -> [real: bb1, cleanup: bb2]; // scope 0 at $DIR/instrument_coverage.rs:10:5: 14:6\n +         StorageLive(_4);                 // scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n-+         _4 = const std::intrinsics::count_code_region(const 0_u32) -> bb7; // scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n++         _4 = const std::intrinsics::count_code_region(const 0_u32, const 387_u32, const 465_u32) -> bb7; // scope 0 at $DIR/instrument_coverage.rs:9:1: 15:2\n +                                          // ty::Const\n-+                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u32) {std::intrinsics::count_code_region}\n++                                          // + ty: unsafe extern \"rust-intrinsic\" fn(u32, u32, u32) {std::intrinsics::count_code_region}\n +                                          // + val: Value(Scalar(<ZST>))\n +                                          // mir::Constant\n +                                          // + span: $DIR/instrument_coverage.rs:9:1: 9:1\n-+                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n++                                          // + literal: Const { ty: unsafe extern \"rust-intrinsic\" fn(u32, u32, u32) {std::intrinsics::count_code_region}, val: Value(Scalar(<ZST>)) }\n +                                          // ty::Const\n +                                          // + ty: u32\n +                                          // + val: Value(Scalar(0x00000000))\n +                                          // mir::Constant\n +                                          // + span: $DIR/instrument_coverage.rs:9:1: 9:1\n +                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000000)) }\n++                                          // ty::Const\n++                                          // + ty: u32\n++                                          // + val: Value(Scalar(0x00000183))\n++                                          // mir::Constant\n++                                          // + span: $DIR/instrument_coverage.rs:9:1: 9:1\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x00000183)) }\n++                                          // ty::Const\n++                                          // + ty: u32\n++                                          // + val: Value(Scalar(0x000001d1))\n++                                          // mir::Constant\n++                                          // + span: $DIR/instrument_coverage.rs:9:1: 9:1\n++                                          // + literal: Const { ty: u32, val: Value(Scalar(0x000001d1)) }\n       }\n   \n       bb1: {"}]}