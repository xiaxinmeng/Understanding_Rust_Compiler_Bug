{"sha": "b73b4de982a16e8819e804cb648ff3ea63d22028", "node_id": "C_kwDOAAsO6NoAKGI3M2I0ZGU5ODJhMTZlODgxOWU4MDRjYjY0OGZmM2VhNjNkMjIwMjg", "commit": {"author": {"name": "Miguel Guarniz", "email": "mi9uel9@gmail.com", "date": "2022-04-03T19:50:33Z"}, "committer": {"name": "Miguel Guarniz", "email": "mi9uel9@gmail.com", "date": "2022-04-08T15:59:59Z"}, "message": "Refactor HIR item-like traversal (part 1)\n\n- Create hir_crate_items query which traverses tcx.hir_crate(()).owners to return a hir::ModuleItems\n- use tcx.hir_crate_items in tcx.hir().items() to return an iterator of hir::ItemId\n- add par_items(impl Fn(hir::ItemId)) to traverse all items in parallel\n\nSigned-off-by: Miguel Guarniz <mi9uel9@gmail.com>", "tree": {"sha": "bbf7b76b289b1f76aa31df21f870c9af8d6258c1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bbf7b76b289b1f76aa31df21f870c9af8d6258c1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b73b4de982a16e8819e804cb648ff3ea63d22028", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b73b4de982a16e8819e804cb648ff3ea63d22028", "html_url": "https://github.com/rust-lang/rust/commit/b73b4de982a16e8819e804cb648ff3ea63d22028", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b73b4de982a16e8819e804cb648ff3ea63d22028/comments", "author": {"login": "kckeiks", "id": 24687641, "node_id": "MDQ6VXNlcjI0Njg3NjQx", "avatar_url": "https://avatars.githubusercontent.com/u/24687641?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kckeiks", "html_url": "https://github.com/kckeiks", "followers_url": "https://api.github.com/users/kckeiks/followers", "following_url": "https://api.github.com/users/kckeiks/following{/other_user}", "gists_url": "https://api.github.com/users/kckeiks/gists{/gist_id}", "starred_url": "https://api.github.com/users/kckeiks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kckeiks/subscriptions", "organizations_url": "https://api.github.com/users/kckeiks/orgs", "repos_url": "https://api.github.com/users/kckeiks/repos", "events_url": "https://api.github.com/users/kckeiks/events{/privacy}", "received_events_url": "https://api.github.com/users/kckeiks/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kckeiks", "id": 24687641, "node_id": "MDQ6VXNlcjI0Njg3NjQx", "avatar_url": "https://avatars.githubusercontent.com/u/24687641?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kckeiks", "html_url": "https://github.com/kckeiks", "followers_url": "https://api.github.com/users/kckeiks/followers", "following_url": "https://api.github.com/users/kckeiks/following{/other_user}", "gists_url": "https://api.github.com/users/kckeiks/gists{/gist_id}", "starred_url": "https://api.github.com/users/kckeiks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kckeiks/subscriptions", "organizations_url": "https://api.github.com/users/kckeiks/orgs", "repos_url": "https://api.github.com/users/kckeiks/repos", "events_url": "https://api.github.com/users/kckeiks/events{/privacy}", "received_events_url": "https://api.github.com/users/kckeiks/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a9080b25e73d26aae94c3f6a13b31de58e66b5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a9080b25e73d26aae94c3f6a13b31de58e66b5a", "html_url": "https://github.com/rust-lang/rust/commit/6a9080b25e73d26aae94c3f6a13b31de58e66b5a"}], "stats": {"total": 129, "additions": 100, "deletions": 29}, "files": [{"sha": "79bbf591534975d1be49b39f8d3e9a2269e0dbdb", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 75, "deletions": 14, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/b73b4de982a16e8819e804cb648ff3ea63d22028/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b73b4de982a16e8819e804cb648ff3ea63d22028/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=b73b4de982a16e8819e804cb648ff3ea63d22028", "patch": "@@ -18,7 +18,6 @@ use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n use rustc_target::spec::abi::Abi;\n-use std::collections::VecDeque;\n \n fn fn_decl<'hir>(node: Node<'hir>) -> Option<&'hir FnDecl<'hir>> {\n     match node {\n@@ -159,12 +158,12 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn items(self) -> impl Iterator<Item = &'hir Item<'hir>> + 'hir {\n-        let krate = self.krate();\n-        krate.owners.iter().filter_map(|owner| match owner.as_owner()?.node() {\n-            OwnerNode::Item(item) => Some(item),\n-            _ => None,\n-        })\n+    pub fn items(self) -> impl Iterator<Item = ItemId> + 'hir {\n+        self.tcx.hir_crate_items(()).items.iter().map(|id| *id)\n+    }\n+\n+    pub fn par_items(self, f: impl Fn(ItemId) + Sync + Send) {\n+        par_for_each_in(self.tcx.hir_crate_items(()).items.to_vec(), f);\n     }\n \n     pub fn def_key(self, def_id: LocalDefId) -> DefKey {\n@@ -677,13 +676,9 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn for_each_module(self, f: impl Fn(LocalDefId)) {\n-        let mut queue = VecDeque::new();\n-        queue.push_back(CRATE_DEF_ID);\n-\n-        while let Some(id) = queue.pop_front() {\n-            f(id);\n-            let items = self.tcx.hir_module_items(id);\n-            queue.extend(items.submodules.iter().copied())\n+        let crate_items = self.tcx.hir_crate_items(());\n+        for module in crate_items.submodules.iter() {\n+            f(*module)\n         }\n     }\n \n@@ -1310,3 +1305,69 @@ pub(super) fn hir_module_items(tcx: TyCtxt<'_>, module_id: LocalDefId) -> Module\n         }\n     }\n }\n+\n+pub(crate) fn hir_crate_items(tcx: TyCtxt<'_>, _: ()) -> ModuleItems {\n+    let mut collector = CrateCollector {\n+        tcx,\n+        submodules: Vec::default(),\n+        items: Vec::default(),\n+        trait_items: Vec::default(),\n+        impl_items: Vec::default(),\n+        foreign_items: Vec::default(),\n+    };\n+\n+    tcx.hir().walk_toplevel_module(&mut collector);\n+\n+    let CrateCollector { submodules, items, trait_items, impl_items, foreign_items, .. } =\n+        collector;\n+\n+    return ModuleItems {\n+        submodules: submodules.into_boxed_slice(),\n+        items: items.into_boxed_slice(),\n+        trait_items: trait_items.into_boxed_slice(),\n+        impl_items: impl_items.into_boxed_slice(),\n+        foreign_items: foreign_items.into_boxed_slice(),\n+    };\n+\n+    struct CrateCollector<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+        submodules: Vec<LocalDefId>,\n+        items: Vec<ItemId>,\n+        trait_items: Vec<TraitItemId>,\n+        impl_items: Vec<ImplItemId>,\n+        foreign_items: Vec<ForeignItemId>,\n+    }\n+\n+    impl<'hir> Visitor<'hir> for CrateCollector<'hir> {\n+        type NestedFilter = nested_filter::All;\n+\n+        fn nested_visit_map(&mut self) -> Self::Map {\n+            self.tcx.hir()\n+        }\n+\n+        fn visit_item(&mut self, item: &'hir Item<'hir>) {\n+            self.items.push(item.item_id());\n+            intravisit::walk_item(self, item)\n+        }\n+\n+        fn visit_mod(&mut self, m: &'hir Mod<'hir>, _s: Span, n: HirId) {\n+            self.submodules.push(n.owner);\n+            intravisit::walk_mod(self, m, n);\n+        }\n+\n+        fn visit_foreign_item(&mut self, item: &'hir ForeignItem<'hir>) {\n+            self.foreign_items.push(item.foreign_item_id());\n+            intravisit::walk_foreign_item(self, item)\n+        }\n+\n+        fn visit_trait_item(&mut self, item: &'hir TraitItem<'hir>) {\n+            self.trait_items.push(item.trait_item_id());\n+            intravisit::walk_trait_item(self, item)\n+        }\n+\n+        fn visit_impl_item(&mut self, item: &'hir ImplItem<'hir>) {\n+            self.impl_items.push(item.impl_item_id());\n+            intravisit::walk_impl_item(self, item)\n+        }\n+    }\n+}"}, {"sha": "fcce2d005d79410f67f423d575df3c55dc6b1c4d", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b73b4de982a16e8819e804cb648ff3ea63d22028/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b73b4de982a16e8819e804cb648ff3ea63d22028/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=b73b4de982a16e8819e804cb648ff3ea63d22028", "patch": "@@ -68,6 +68,7 @@ pub fn provide(providers: &mut Providers) {\n         hir.get_module_parent_node(hir.local_def_id_to_hir_id(id))\n     };\n     providers.hir_crate = |tcx, ()| tcx.untracked_crate;\n+    providers.hir_crate_items = map::hir_crate_items;\n     providers.crate_hash = map::crate_hash;\n     providers.hir_module_items = map::hir_module_items;\n     providers.hir_owner = |tcx, id| {"}, {"sha": "6733e0f7f3c76d140a687f274d522bee30dc6d07", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b73b4de982a16e8819e804cb648ff3ea63d22028/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b73b4de982a16e8819e804cb648ff3ea63d22028/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=b73b4de982a16e8819e804cb648ff3ea63d22028", "patch": "@@ -45,6 +45,13 @@ rustc_queries! {\n         desc { \"get the crate HIR\" }\n     }\n \n+    /// All items in the crate.\n+    query hir_crate_items(_: ()) -> rustc_middle::hir::ModuleItems {\n+        storage(ArenaCacheSelector<'tcx>)\n+        eval_always\n+        desc { \"get HIR crate items\" }\n+    }\n+\n     /// The items in a module.\n     ///\n     /// This can be conveniently accessed by `tcx.hir().visit_item_likes_in_module`."}, {"sha": "61f078c0e48218080e18a95fa143b5f41f48b7bc", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b73b4de982a16e8819e804cb648ff3ea63d22028/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b73b4de982a16e8819e804cb648ff3ea63d22028/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=b73b4de982a16e8819e804cb648ff3ea63d22028", "patch": "@@ -2682,7 +2682,8 @@ define_print_and_forward_display! {\n fn for_each_def(tcx: TyCtxt<'_>, mut collect_fn: impl for<'b> FnMut(&'b Ident, Namespace, DefId)) {\n     // Iterate all local crate items no matter where they are defined.\n     let hir = tcx.hir();\n-    for item in hir.items() {\n+    for id in hir.items() {\n+        let item = hir.item(id);\n         if item.ident.name.as_str().is_empty() || matches!(item.kind, ItemKind::Use(_, _)) {\n             continue;\n         }"}, {"sha": "c76061867145e619c242c9327899b88ac76a4af3", "filename": "src/tools/clippy/clippy_lints/src/same_name_method.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b73b4de982a16e8819e804cb648ff3ea63d22028/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsame_name_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b73b4de982a16e8819e804cb648ff3ea63d22028/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsame_name_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsame_name_method.rs?ref=b73b4de982a16e8819e804cb648ff3ea63d22028", "patch": "@@ -50,7 +50,8 @@ impl<'tcx> LateLintPass<'tcx> for SameNameMethod {\n     fn check_crate_post(&mut self, cx: &LateContext<'tcx>) {\n         let mut map = FxHashMap::<Res, ExistingName>::default();\n \n-        for item in cx.tcx.hir().items() {\n+        for id in cx.tcx.hir().items() {\n+            let item = cx.tcx.hir().item(id);\n             if let ItemKind::Impl(Impl {\n                 items,\n                 of_trait,"}, {"sha": "cf06eb32e0c7fc041738d367cd6e6c19a4c31b85", "filename": "src/tools/clippy/tests/ui/same_name_method.stderr", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b73b4de982a16e8819e804cb648ff3ea63d22028/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsame_name_method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b73b4de982a16e8819e804cb648ff3ea63d22028/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsame_name_method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsame_name_method.stderr?ref=b73b4de982a16e8819e804cb648ff3ea63d22028", "patch": "@@ -11,6 +11,19 @@ note: existing `foo` defined here\n LL |             fn foo() {}\n    |             ^^^^^^^^^^^\n \n+error: method's name is the same as an existing method in a trait\n+  --> $DIR/same_name_method.rs:34:13\n+   |\n+LL |             fn clone() {}\n+   |             ^^^^^^^^^^^^^\n+   |\n+note: existing `clone` defined here\n+  --> $DIR/same_name_method.rs:30:18\n+   |\n+LL |         #[derive(Clone)]\n+   |                  ^^^^^\n+   = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n error: method's name is the same as an existing method in a trait\n   --> $DIR/same_name_method.rs:44:13\n    |\n@@ -47,18 +60,5 @@ note: existing `foo` defined here\n LL |         impl T1 for S {}\n    |         ^^^^^^^^^^^^^^^^\n \n-error: method's name is the same as an existing method in a trait\n-  --> $DIR/same_name_method.rs:34:13\n-   |\n-LL |             fn clone() {}\n-   |             ^^^^^^^^^^^^^\n-   |\n-note: existing `clone` defined here\n-  --> $DIR/same_name_method.rs:30:18\n-   |\n-LL |         #[derive(Clone)]\n-   |                  ^^^^^\n-   = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)\n-\n error: aborting due to 5 previous errors\n "}]}