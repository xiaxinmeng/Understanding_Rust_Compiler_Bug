{"sha": "0b620186fdac2a8a671d445ac25ef33d1df44153", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiNjIwMTg2ZmRhYzJhOGE2NzFkNDQ1YWMyNWVmMzNkMWRmNDQxNTM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-06-04T16:25:12Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2018-07-01T14:30:42Z"}, "message": "propagate boring vs interesting causal info for constraints/tests", "tree": {"sha": "0a15c7ae7984c7e8853e3dce5322912992a5e5e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a15c7ae7984c7e8853e3dce5322912992a5e5e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b620186fdac2a8a671d445ac25ef33d1df44153", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAls45ZMACgkQAXYLT59T\n8VQl5A/+JtqRI6jRgv5o+5gYJ9jfQaPKPVhg6cT+SA/6nHpxfDppf0QBXBTs6HDO\niaxSMMqZGMpUmx+xK2ak0FKZ8f6eKR22BBhmG1uOC4uOHKRP1CZdjIVC+uEfAVc1\ni6k3VKBbBcTuzADidCLLZUxaQ3Qg0vwz9i5dAMM6V0RdRj+QNTb0ixEYw1fgbQ9c\nXEw2cohPTQ46Xh844pPgvfYHaT86w7W2dQkuVTwMaOUyydqUzPRnod8I11+mFXFp\n0y2YjaSllQfwbF802g4dCUUQJkT7QERJ76b8bVVjgsiX7s1vVwXH97I5it70I2V8\nygmbDkx4f4s1yeMYrYBho1hsd4SnH1eegnrGjaUc9/w8bP0eZDS9Efb256N2ZuOa\nYzEAnXmiss36vsqmtO29yU1nfC6EvRMOhHSU/m/wy0GuE6uF1X1uHk4uTaHX+PvD\nGMrcHQmwnONUEsCn+kbddQmWcfvRoLJjHKR65WZ0jv7NIWS/PSJtjgfEakSiKbFK\nMiE9+FAfFpEgcE1j52Fbmv+spWX+TcU+mqQHDdiRPYQfGG0O7TSEvAjIGNfiuA7g\nRH4ZPJj97fGfp86VeyjXOQN+DDGIVYgQ6nF/o59SQtYmrsRcSWtlEN5dXdyxmccB\nALEzXGG2frEgKDnpNMVBLx6ylXuDuUqElE2W/PezehJizSLGkaU=\n=grMl\n-----END PGP SIGNATURE-----", "payload": "tree 0a15c7ae7984c7e8853e3dce5322912992a5e5e7\nparent 609bb27514fe71f08040aef1eb8a7acd098e9185\nauthor Niko Matsakis <niko@alum.mit.edu> 1528129512 -0400\ncommitter David Wood <david@davidtw.co> 1530455442 +0100\n\npropagate boring vs interesting causal info for constraints/tests\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b620186fdac2a8a671d445ac25ef33d1df44153", "html_url": "https://github.com/rust-lang/rust/commit/0b620186fdac2a8a671d445ac25ef33d1df44153", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b620186fdac2a8a671d445ac25ef33d1df44153/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "609bb27514fe71f08040aef1eb8a7acd098e9185", "url": "https://api.github.com/repos/rust-lang/rust/commits/609bb27514fe71f08040aef1eb8a7acd098e9185", "html_url": "https://github.com/rust-lang/rust/commit/609bb27514fe71f08040aef1eb8a7acd098e9185"}], "stats": {"total": 142, "additions": 70, "deletions": 72}, "files": [{"sha": "68aa9aeabf811ae75a2bcd3429edd8947f5ef4ec", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b620186fdac2a8a671d445ac25ef33d1df44153/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b620186fdac2a8a671d445ac25ef33d1df44153/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=0b620186fdac2a8a671d445ac25ef33d1df44153", "patch": "@@ -10,9 +10,10 @@\n \n use borrow_check::borrow_set::BorrowSet;\n use borrow_check::location::LocationTable;\n+use borrow_check::nll::ToRegionVid;\n use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::{Cause, RegionInferenceContext};\n-use borrow_check::nll::ToRegionVid;\n+use borrow_check::nll::type_check::AtLocation;\n use rustc::hir;\n use rustc::infer::InferCtxt;\n use rustc::mir::visit::TyContext;\n@@ -310,9 +311,8 @@ impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n                     debug!(\"add_reborrow_constraint - base_ty = {:?}\", base_ty);\n                     match base_ty.sty {\n                         ty::TyRef(ref_region, _, mutbl) => {\n-                            let span = self.mir.source_info(location).span;\n                             self.regioncx.add_outlives(\n-                                span,\n+                                location.boring(),\n                                 ref_region.to_region_vid(),\n                                 borrow_region.to_region_vid(),\n                             );"}, {"sha": "3bdf78ff3db54dc323ee1c178d22689ae887d464", "filename": "src/librustc_mir/borrow_check/nll/constraint_set.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0b620186fdac2a8a671d445ac25ef33d1df44153/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b620186fdac2a8a671d445ac25ef33d1df44153/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_set.rs?ref=0b620186fdac2a8a671d445ac25ef33d1df44153", "patch": "@@ -10,9 +10,9 @@\n \n use rustc::ty::RegionVid;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use borrow_check::nll::type_check::Locations;\n \n use std::fmt;\n-use syntax_pos::Span;\n use std::ops::Deref;\n \n #[derive(Clone, Default)]\n@@ -23,8 +23,8 @@ crate struct ConstraintSet {\n impl ConstraintSet {\n     pub fn push(&mut self, constraint: OutlivesConstraint) {\n         debug!(\n-            \"add_outlives({:?}: {:?})\",\n-            constraint.sup, constraint.sub\n+            \"add_outlives({:?}: {:?} @ {:?})\",\n+            constraint.sup, constraint.sub, constraint.locations\n         );\n         if constraint.sup == constraint.sub {\n             // 'a: 'a is pretty uninteresting\n@@ -96,15 +96,15 @@ pub struct OutlivesConstraint {\n     pub next: Option<ConstraintIndex>,\n \n     /// Where did this constraint arise?\n-    pub span: Span,\n+    pub locations: Locations,\n }\n \n impl fmt::Debug for OutlivesConstraint {\n     fn fmt(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n         write!(\n             formatter,\n             \"({:?}: {:?}) due to {:?}\",\n-            self.sup, self.sub, self.span\n+            self.sup, self.sub, self.locations\n         )\n     }\n }"}, {"sha": "88d9f46e340d33e204753915ecfbaec18790a45e", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dump_mir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b620186fdac2a8a671d445ac25ef33d1df44153/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b620186fdac2a8a671d445ac25ef33d1df44153/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs?ref=0b620186fdac2a8a671d445ac25ef33d1df44153", "patch": "@@ -82,14 +82,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             let OutlivesConstraint {\n                 sup,\n                 sub,\n-                span,\n+                locations,\n                 next: _,\n             } = constraint;\n             with_msg(&format!(\n                 \"{:?}: {:?} due to {:?}\",\n                 sup,\n                 sub,\n-                span\n+                locations,\n             ))?;\n         }\n "}, {"sha": "0116fbcfc8860d39e648cb4b7cf7e774985624be", "filename": "src/librustc_mir/borrow_check/nll/region_infer/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b620186fdac2a8a671d445ac25ef33d1df44153/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b620186fdac2a8a671d445ac25ef33d1df44153/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs?ref=0b620186fdac2a8a671d445ac25ef33d1df44153", "patch": "@@ -44,7 +44,7 @@ impl<'this, 'tcx> dot::Labeller<'this> for RegionInferenceContext<'tcx> {\n         dot::LabelText::LabelStr(format!(\"{:?}\", n).into_cow())\n     }\n     fn edge_label(&'this self, e: &OutlivesConstraint) -> dot::LabelText<'this> {\n-        dot::LabelText::LabelStr(format!(\"{:?}\", e.span).into_cow())\n+        dot::LabelText::LabelStr(format!(\"{:?}\", e.locations).into_cow())\n     }\n }\n "}, {"sha": "ace701eeb789c724260bfd2e58bc095835b1e602", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 18, "deletions": 15, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0b620186fdac2a8a671d445ac25ef33d1df44153/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b620186fdac2a8a671d445ac25ef33d1df44153/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=0b620186fdac2a8a671d445ac25ef33d1df44153", "patch": "@@ -11,6 +11,7 @@\n use super::universal_regions::UniversalRegions;\n use borrow_check::nll::region_infer::values::ToElementIndex;\n use borrow_check::nll::constraint_set::{ConstraintIndex, ConstraintSet, OutlivesConstraint};\n+use borrow_check::nll::type_check::Locations;\n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n@@ -154,11 +155,8 @@ pub struct TypeTest<'tcx> {\n     /// The region `'x` that the type must outlive.\n     pub lower_bound: RegionVid,\n \n-    /// The point where the outlives relation must hold.\n-    pub point: Location,\n-\n-    /// Where did this constraint arise?\n-    pub span: Span,\n+    /// Where did this constraint arise and why?\n+    pub locations: Locations,\n \n     /// A test which, if met by the region `'x`, proves that this type\n     /// constraint is satisfied.\n@@ -356,13 +354,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Indicates that the region variable `sup` must outlive `sub` is live at the point `point`.\n     pub(super) fn add_outlives(\n         &mut self,\n-        span: Span,\n+        locations: Locations,\n         sup: RegionVid,\n         sub: RegionVid,\n     ) {\n         assert!(self.inferred_values.is_none(), \"values already inferred\");\n         self.constraints.push(OutlivesConstraint {\n-            span,\n+            locations,\n             sup,\n             sub,\n             next: None,\n@@ -408,7 +406,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         self.check_type_tests(infcx, mir, mir_def_id, outlives_requirements.as_mut());\n \n-        self.check_universal_regions(infcx, mir_def_id, outlives_requirements.as_mut());\n+        self.check_universal_regions(infcx, mir, mir_def_id, outlives_requirements.as_mut());\n \n         let outlives_requirements = outlives_requirements.unwrap_or(vec![]);\n \n@@ -506,7 +504,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n \n             if let Some(propagated_outlives_requirements) = &mut propagated_outlives_requirements {\n-                if self.try_promote_type_test(infcx, type_test, propagated_outlives_requirements) {\n+                if self.try_promote_type_test(infcx, mir, type_test, propagated_outlives_requirements) {\n                     continue;\n                 }\n             }\n@@ -515,9 +513,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             let lower_bound_region = self.to_error_region(type_test.lower_bound);\n             if let Some(lower_bound_region) = lower_bound_region {\n                 let region_scope_tree = &tcx.region_scope_tree(mir_def_id);\n+                let type_test_span = type_test.locations.span(mir);\n                 infcx.report_generic_bound_failure(\n                     region_scope_tree,\n-                    type_test.span,\n+                    type_test_span,\n                     None,\n                     type_test.generic_kind,\n                     lower_bound_region,\n@@ -532,8 +531,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // to report it; we could probably handle it by\n                 // iterating over the universal regions and reporting\n                 // an error that multiple bounds are required.\n+                let type_test_span = type_test.locations.span(mir);\n                 tcx.sess.span_err(\n-                    type_test.span,\n+                    type_test_span,\n                     &format!(\"`{}` does not live long enough\", type_test.generic_kind,),\n                 );\n             }\n@@ -566,6 +566,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn try_promote_type_test<'gcx>(\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        mir: &Mir<'tcx>,\n         type_test: &TypeTest<'tcx>,\n         propagated_outlives_requirements: &mut Vec<ClosureOutlivesRequirement<'gcx>>,\n     ) -> bool {\n@@ -574,8 +575,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let TypeTest {\n             generic_kind,\n             lower_bound,\n-            point: _,\n-            span,\n+            locations,\n             test: _,\n         } = type_test;\n \n@@ -599,7 +599,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n             subject,\n             outlived_free_region: lower_bound_plus,\n-            blame_span: *span,\n+            blame_span: locations.span(mir),\n         });\n         true\n     }\n@@ -865,6 +865,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn check_universal_regions<'gcx>(\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        mir: &Mir<'tcx>,\n         mir_def_id: DefId,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n     ) {\n@@ -881,6 +882,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         for (fr, _) in universal_definitions {\n             self.check_universal_region(\n                 infcx,\n+                mir,\n                 mir_def_id,\n                 fr,\n                 &mut propagated_outlives_requirements,\n@@ -899,6 +901,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn check_universal_region<'gcx>(\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n+        mir: &Mir<'tcx>,\n         mir_def_id: DefId,\n         longer_fr: RegionVid,\n         propagated_outlives_requirements: &mut Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n@@ -921,7 +924,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             );\n \n             let blame_index = self.blame_constraint(longer_fr, shorter_fr);\n-            let blame_span = self.constraints[blame_index].span;\n+            let blame_span = self.constraints[blame_index].locations.span(mir);\n \n             if let Some(propagated_outlives_requirements) = propagated_outlives_requirements {\n                 // Shrink `fr` until we find a non-local region (if we do)."}, {"sha": "27bd50427772df4a465f5dadac14d7af27488c4b", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0b620186fdac2a8a671d445ac25ef33d1df44153/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b620186fdac2a8a671d445ac25ef33d1df44153/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=0b620186fdac2a8a671d445ac25ef33d1df44153", "patch": "@@ -19,14 +19,12 @@ use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::infer::outlives::obligations::{TypeOutlives, TypeOutlivesDelegate};\n use rustc::infer::region_constraints::{GenericKind, VerifyBound};\n use rustc::infer::{self, SubregionOrigin};\n-use rustc::mir::{Location, Mir};\n use rustc::ty::subst::UnpackedKind;\n use rustc::ty::{self, TyCtxt};\n-use syntax::codemap::Span;\n+use syntax_pos::DUMMY_SP;\n \n crate struct ConstraintConversion<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    mir: &'a Mir<'tcx>,\n     universal_regions: &'a UniversalRegions<'tcx>,\n     location_table: &'a LocationTable,\n     region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n@@ -41,7 +39,6 @@ crate struct ConstraintConversion<'a, 'gcx: 'tcx, 'tcx: 'a> {\n impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n     crate fn new(\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-        mir: &'a Mir<'tcx>,\n         universal_regions: &'a UniversalRegions<'tcx>,\n         location_table: &'a LocationTable,\n         region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n@@ -54,7 +51,6 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n     ) -> Self {\n         Self {\n             tcx,\n-            mir,\n             universal_regions,\n             location_table,\n             region_bound_pairs,\n@@ -91,8 +87,7 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n         // will start to fail.\n         let ty::OutlivesPredicate(k1, r2) =\n             query_constraint.no_late_bound_regions().unwrap_or_else(|| {\n-                span_bug!(\n-                    self.span(),\n+                bug!(\n                     \"query_constraint {:?} contained bound regions\",\n                     query_constraint,\n                 );\n@@ -125,7 +120,7 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n             UnpackedKind::Type(t1) => {\n                 // we don't actually use this for anything, but\n                 // the `TypeOutlives` code needs an origin.\n-                let origin = infer::RelateParamBound(self.span(), t1);\n+                let origin = infer::RelateParamBound(DUMMY_SP, t1);\n \n                 TypeOutlives::new(\n                     &mut *self,\n@@ -146,15 +141,12 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n     ) -> TypeTest<'tcx> {\n         let lower_bound = self.to_region_vid(region);\n \n-        let point = self.locations.from_location().unwrap_or(Location::START);\n-\n         let test = self.verify_bound_to_region_test(&bound);\n \n         TypeTest {\n             generic_kind,\n             lower_bound,\n-            point,\n-            span: self.span(),\n+            locations: self.locations,\n             test,\n         }\n     }\n@@ -189,17 +181,9 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n         self.universal_regions.to_region_vid(r)\n     }\n \n-    fn span(&self) -> Span {\n-        self.mir\n-            .source_info(self.locations.from_location().unwrap_or(Location::START))\n-            .span\n-    }\n-\n     fn add_outlives(&mut self, sup: ty::RegionVid, sub: ty::RegionVid) {\n-        let span = self.span();\n-\n         self.outlives_constraints.push(OutlivesConstraint {\n-            span,\n+            locations: self.locations,\n             sub,\n             sup,\n             next: None,"}, {"sha": "782b07d02f438916f619b17d0e32eb3896a23069", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 36, "deletions": 25, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/0b620186fdac2a8a671d445ac25ef33d1df44153/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b620186fdac2a8a671d445ac25ef33d1df44153/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=0b620186fdac2a8a671d445ac25ef33d1df44153", "patch": "@@ -147,7 +147,6 @@ fn type_check_internal<'gcx, 'tcx>(\n         region_bound_pairs,\n         implicit_region_bound,\n         borrowck_context,\n-        mir,\n     );\n     let errors_reported = {\n         let mut verifier = TypeVerifier::new(&mut checker, mir);\n@@ -597,7 +596,6 @@ struct TypeChecker<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n     constraints: MirTypeckRegionConstraints<'tcx>,\n     borrowck_context: Option<BorrowCheckContext<'a, 'tcx>>,\n-    mir: &'a Mir<'tcx>,\n }\n \n struct BorrowCheckContext<'a, 'tcx: 'a> {\n@@ -628,7 +626,7 @@ crate struct MirTypeckRegionConstraints<'tcx> {\n /// required to hold. Normally, this is at a particular point which\n /// created the obligation, but for constraints that the user gave, we\n /// want the constraint to hold at all points.\n-#[derive(Copy, Clone, Debug)]\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n pub enum Locations {\n     /// Indicates that a type constraint should always be true. This\n     /// is particularly important in the new borrowck analysis for\n@@ -663,21 +661,42 @@ pub enum Locations {\n     /// assigned to `x` are of `'static` lifetime.\n     All,\n \n-    Pair {\n-        /// The location in the MIR that generated these constraints.\n-        /// This is intended for error reporting and diagnosis; the\n-        /// constraints may *take effect* at a distinct spot.\n-        from_location: Location,\n-    },\n+    /// A \"boring\" constraint (caused by the given location) is one that\n+    /// the user probably doesn't want to see described in diagnostics,\n+    /// because it is kind of an artifact of the type system setup.\n+    ///\n+    /// Example: `x = Foo { field: y }` technically creates\n+    /// intermediate regions representing the \"type of `Foo { field: y\n+    /// }`\", and data flows from `y` into those variables, but they\n+    /// are not very interesting. The assignment into `x` on the other\n+    /// hand might be.\n+    Boring(Location),\n+\n+    /// An *important* outlives constraint (caused by the given\n+    /// location) is one that would be useful to highlight in\n+    /// diagnostics, because it represents a point where references\n+    /// flow from one spot to another (e.g., `x = y`)\n+    Interesting(Location),\n }\n \n impl Locations {\n     pub fn from_location(&self) -> Option<Location> {\n         match self {\n             Locations::All => None,\n-            Locations::Pair { from_location, .. } => Some(*from_location),\n+            Locations::Boring(from_location) | Locations::Interesting(from_location) => {\n+                Some(*from_location)\n+            }\n         }\n     }\n+\n+    /// Gets a span representing the location.\n+    pub fn span(&self, mir: &Mir<'_>) -> Span {\n+        let span_location = match self {\n+            Locations::All => Location::START,\n+            Locations::Boring(l) | Locations::Interesting(l) => *l,\n+        };\n+        mir.source_info(span_location).span\n+    }\n }\n \n impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n@@ -688,7 +707,6 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         region_bound_pairs: &'a [(ty::Region<'tcx>, GenericKind<'tcx>)],\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         borrowck_context: Option<BorrowCheckContext<'a, 'tcx>>,\n-        mir: &'a Mir<'tcx>,\n     ) -> Self {\n         TypeChecker {\n             infcx,\n@@ -698,7 +716,6 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             region_bound_pairs,\n             implicit_region_bound,\n             borrowck_context,\n-            mir,\n             reported_errors: FxHashSet(),\n             constraints: MirTypeckRegionConstraints::default(),\n         }\n@@ -741,7 +758,6 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         if let Some(borrowck_context) = &mut self.borrowck_context {\n             constraint_conversion::ConstraintConversion::new(\n                 self.infcx.tcx,\n-                self.mir,\n                 borrowck_context.universal_regions,\n                 borrowck_context.location_table,\n                 self.region_bound_pairs,\n@@ -886,9 +902,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 let place_ty = location.ty(mir, tcx).to_ty(tcx);\n                 let rv_ty = value.ty(mir, tcx);\n \n-                let locations = Locations::Pair {\n-                    from_location: term_location,\n-                };\n+                let locations = term_location.interesting();\n                 if let Err(terr) = self.sub_types(rv_ty, place_ty, locations) {\n                     span_mirbug!(\n                         self,\n@@ -988,7 +1002,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 match mir.yield_ty {\n                     None => span_mirbug!(self, term, \"yield in non-generator\"),\n                     Some(ty) => {\n-                        if let Err(terr) = self.sub_types(value_ty, ty, term_location.interesting()) {\n+                        if let Err(terr) = self.sub_types(value_ty, ty, term_location.interesting())\n+                        {\n                             span_mirbug!(\n                                 self,\n                                 term,\n@@ -1016,9 +1031,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         match *destination {\n             Some((ref dest, _target_block)) => {\n                 let dest_ty = dest.ty(mir, tcx).to_ty(tcx);\n-                let locations = Locations::Pair {\n-                    from_location: term_location,\n-                };\n+                let locations = term_location.interesting();\n                 if let Err(terr) = self.sub_types(sig.output(), dest_ty, locations) {\n                     span_mirbug!(\n                         self,\n@@ -1630,7 +1643,7 @@ impl MirPass for TypeckMir {\n     }\n }\n \n-trait AtLocation {\n+pub trait AtLocation {\n     /// Indicates a \"boring\" constraint that the user probably\n     /// woudln't want to see highlights.\n     fn boring(self) -> Locations;\n@@ -1642,13 +1655,11 @@ trait AtLocation {\n \n impl AtLocation for Location {\n     fn boring(self) -> Locations {\n-        Locations::Pair {\n-            from_location: self,\n-        }\n+        Locations::Boring(self)\n     }\n \n     fn interesting(self) -> Locations {\n-        self.boring()\n+        Locations::Interesting(self)\n     }\n }\n "}]}