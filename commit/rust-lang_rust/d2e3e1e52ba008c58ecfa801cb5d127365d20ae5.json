{"sha": "d2e3e1e52ba008c58ecfa801cb5d127365d20ae5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyZTNlMWU1MmJhMDA4YzU4ZWNmYTgwMWNiNWQxMjczNjVkMjBhZTU=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-27T12:36:27Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-27T12:37:00Z"}, "message": "Convert vec::{head, tail, init, last} (and similar fns) to methods.", "tree": {"sha": "e0e5ad79a68a35c2086d777efc2a093345a4176e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0e5ad79a68a35c2086d777efc2a093345a4176e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2e3e1e52ba008c58ecfa801cb5d127365d20ae5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2e3e1e52ba008c58ecfa801cb5d127365d20ae5", "html_url": "https://github.com/rust-lang/rust/commit/d2e3e1e52ba008c58ecfa801cb5d127365d20ae5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2e3e1e52ba008c58ecfa801cb5d127365d20ae5/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0512b1055eac15db86d83c994fb546cbfa62676", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0512b1055eac15db86d83c994fb546cbfa62676", "html_url": "https://github.com/rust-lang/rust/commit/d0512b1055eac15db86d83c994fb546cbfa62676"}], "stats": {"total": 92, "additions": 33, "deletions": 59}, "files": [{"sha": "b2ba05c550deffa225b8cfd3adac94d47a956835", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e3e1e52ba008c58ecfa801cb5d127365d20ae5/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e3e1e52ba008c58ecfa801cb5d127365d20ae5/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=d2e3e1e52ba008c58ecfa801cb5d127365d20ae5", "patch": "@@ -75,7 +75,7 @@ pub fn parse_config(args: ~[~str]) -> config {\n          ];\n \n     assert!(!args.is_empty());\n-    let args_ = vec::tail(args);\n+    let args_ = args.tail();\n     let matches =\n         &match getopts::getopts(args_, opts) {\n           Ok(m) => m,"}, {"sha": "bb03e3ab9bb272ac2f9012807a0313bc77a0493b", "filename": "src/libextra/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e3e1e52ba008c58ecfa801cb5d127365d20ae5/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e3e1e52ba008c58ecfa801cb5d127365d20ae5/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=d2e3e1e52ba008c58ecfa801cb5d127365d20ae5", "patch": "@@ -139,7 +139,7 @@ type OptRes = Either<TestOpts, ~str>;\n \n // Parses command line arguments into test options\n pub fn parse_opts(args: &[~str]) -> OptRes {\n-    let args_ = vec::tail(args);\n+    let args_ = args.tail();\n     let opts = ~[getopts::optflag(\"ignored\"),\n                  getopts::optflag(\"test\"),\n                  getopts::optflag(\"bench\"),"}, {"sha": "73323634c2b6c89c74f65f29d6efaf010b7ad77c", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e3e1e52ba008c58ecfa801cb5d127365d20ae5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e3e1e52ba008c58ecfa801cb5d127365d20ae5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=d2e3e1e52ba008c58ecfa801cb5d127365d20ae5", "patch": "@@ -312,7 +312,7 @@ fn llreg_ty(cls: &[RegClass]) -> Type {\n                 tys.push(Type::i64());\n             }\n             SSEFv => {\n-                let vec_len = llvec_len(vec::tailn(cls, i + 1u)) * 2u;\n+                let vec_len = llvec_len(cls.tailn(i + 1u)) * 2u;\n                 let vec_ty = Type::vector(&Type::f32(), vec_len as u64);\n                 tys.push(vec_ty);\n                 i += vec_len;"}, {"sha": "064a457c712700c464121208ee6fb5355721569a", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d2e3e1e52ba008c58ecfa801cb5d127365d20ae5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e3e1e52ba008c58ecfa801cb5d127365d20ae5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=d2e3e1e52ba008c58ecfa801cb5d127365d20ae5", "patch": "@@ -47,7 +47,6 @@ use util::ppaux::Repr;\n \n use middle::trans::type_::Type;\n \n-use core::vec;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::visit;\n@@ -503,7 +502,7 @@ pub fn trans_call_inner(in_cx: block,\n     do base::with_scope(in_cx, call_info, \"call\") |cx| {\n         let ret_in_loop = match args {\n           ArgExprs(args) => {\n-            args.len() > 0u && match vec::last(args).node {\n+            args.len() > 0u && match args.last().node {\n               ast::expr_loop_body(@ast::expr {\n                 node: ast::expr_fn_block(_, ref body),\n                 _"}, {"sha": "b6911a7eb96d5c4869e66fce8e0ad30147200c61", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d2e3e1e52ba008c58ecfa801cb5d127365d20ae5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e3e1e52ba008c58ecfa801cb5d127365d20ae5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=d2e3e1e52ba008c58ecfa801cb5d127365d20ae5", "patch": "@@ -492,8 +492,7 @@ pub fn combine_impl_and_methods_tps(bcx: block,\n     debug!(\"rcvr_substs=%?\", rcvr_substs.map(|t| bcx.ty_to_str(*t)));\n     let ty_substs\n         = vec::append(rcvr_substs.to_owned(),\n-                      vec::tailn(node_substs,\n-                                 node_substs.len() - n_m_tps));\n+                      node_substs.tailn(node_substs.len() - n_m_tps));\n     debug!(\"n_m_tps=%?\", n_m_tps);\n     debug!(\"node_substs=%?\", node_substs.map(|t| bcx.ty_to_str(*t)));\n     debug!(\"ty_substs=%?\", ty_substs.map(|t| bcx.ty_to_str(*t)));\n@@ -540,7 +539,7 @@ pub fn combine_impl_and_methods_origins(bcx: block,\n     };\n \n     // Extract those that belong to method:\n-    let m_origins = vec::tailn(*r_m_origins, r_m_origins.len() - m_vtables);\n+    let m_origins = r_m_origins.tailn(r_m_origins.len() - m_vtables);\n \n     // Combine rcvr + method to find the final result:\n     @vec::append(/*bad*/copy *rcvr_origins, m_origins)"}, {"sha": "939fecfe40aec207acd60a63757687d70d362e63", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d2e3e1e52ba008c58ecfa801cb5d127365d20ae5/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e3e1e52ba008c58ecfa801cb5d127365d20ae5/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=d2e3e1e52ba008c58ecfa801cb5d127365d20ae5", "patch": "@@ -3954,7 +3954,7 @@ pub fn item_path(cx: ctxt, id: ast::def_id) -> ast_map::path {\n           }\n \n           ast_map::node_variant(ref variant, _, path) => {\n-            vec::append_one(vec::to_owned(vec::init(*path)),\n+            vec::append_one(vec::to_owned(path.init()),\n                             ast_map::path_name((*variant).node.name))\n           }\n "}, {"sha": "3dae32d717de090bf07f68d05936eb4fde365f5d", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 26, "deletions": 50, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/d2e3e1e52ba008c58ecfa801cb5d127365d20ae5/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2e3e1e52ba008c58ecfa801cb5d127365d20ae5/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=d2e3e1e52ba008c58ecfa801cb5d127365d20ae5", "patch": "@@ -238,44 +238,6 @@ pub fn build_sized_opt<A>(size: Option<uint>,\n \n // Accessors\n \n-/// Returns the first element of a vector\n-pub fn head<'r,T>(v: &'r [T]) -> &'r T {\n-    if v.len() == 0 { fail!(\"head: empty vector\") }\n-    &v[0]\n-}\n-\n-/// Returns `Some(x)` where `x` is the first element of the slice `v`,\n-/// or `None` if the vector is empty.\n-pub fn head_opt<'r,T>(v: &'r [T]) -> Option<&'r T> {\n-    if v.len() == 0 { None } else { Some(&v[0]) }\n-}\n-\n-/// Returns a vector containing all but the first element of a slice\n-pub fn tail<'r,T>(v: &'r [T]) -> &'r [T] { v.slice(1, v.len()) }\n-\n-/// Returns a vector containing all but the first `n` elements of a slice\n-pub fn tailn<'r,T>(v: &'r [T], n: uint) -> &'r [T] { v.slice(n, v.len()) }\n-\n-/// Returns a vector containing all but the last element of a slice\n-pub fn init<'r,T>(v: &'r [T]) -> &'r [T] { v.slice(0, v.len() - 1) }\n-\n-/// Returns a vector containing all but the last `n' elements of a slice\n-pub fn initn<'r,T>(v: &'r [T], n: uint) -> &'r [T] {\n-    v.slice(0, v.len() - n)\n-}\n-\n-/// Returns the last element of the slice `v`, failing if the slice is empty.\n-pub fn last<'r,T>(v: &'r [T]) -> &'r T {\n-    if v.len() == 0 { fail!(\"last: empty vector\") }\n-    &v[v.len() - 1]\n-}\n-\n-/// Returns `Some(x)` where `x` is the last element of the slice `v`, or\n-/// `None` if the vector is empty.\n-pub fn last_opt<'r,T>(v: &'r [T]) -> Option<&'r T> {\n-    if v.len() == 0 { None } else { Some(&v[v.len() - 1]) }\n-}\n-\n /// Copies\n \n /// Split the vector `v` by applying each element against the predicate `f`.\n@@ -1678,35 +1640,49 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n \n     /// Returns the first element of a vector, failing if the vector is empty.\n     #[inline]\n-    fn head(&self) -> &'self T { head(*self) }\n+    fn head(&self) -> &'self T {\n+        if self.len() == 0 { fail!(\"head: empty vector\") }\n+        &self[0]\n+    }\n \n-    /// Returns the first element of a vector\n+    /// Returns the first element of a vector, or `None` if it is empty\n     #[inline]\n-    fn head_opt(&self) -> Option<&'self T> { head_opt(*self) }\n+    fn head_opt(&self) -> Option<&'self T> {\n+        if self.len() == 0 { None } else { Some(&self[0]) }\n+    }\n \n     /// Returns all but the first element of a vector\n     #[inline]\n-    fn tail(&self) -> &'self [T] { tail(*self) }\n+    fn tail(&self) -> &'self [T] { self.slice(1, self.len()) }\n \n     /// Returns all but the first `n' elements of a vector\n     #[inline]\n-    fn tailn(&self, n: uint) -> &'self [T] { tailn(*self, n) }\n+    fn tailn(&self, n: uint) -> &'self [T] { self.slice(n, self.len()) }\n \n-    /// Returns all but the last elemnt of a vector\n+    /// Returns all but the last element of a vector\n     #[inline]\n-    fn init(&self) -> &'self [T] { init(*self) }\n+    fn init(&self) -> &'self [T] {\n+        self.slice(0, self.len() - 1)\n+    }\n \n     /// Returns all but the last `n' elemnts of a vector\n     #[inline]\n-    fn initn(&self, n: uint) -> &'self [T] { initn(*self, n) }\n+    fn initn(&self, n: uint) -> &'self [T] {\n+        self.slice(0, self.len() - n)\n+    }\n \n-    /// Returns the last element of a `v`, failing if the vector is empty.\n+    /// Returns the last element of a vector, failing if the vector is empty.\n     #[inline]\n-    fn last(&self) -> &'self T { last(*self) }\n+    fn last(&self) -> &'self T {\n+        if self.len() == 0 { fail!(\"last: empty vector\") }\n+        &self[self.len() - 1]\n+    }\n \n-    /// Returns the last element of a `v`, failing if the vector is empty.\n+    /// Returns the last element of a vector, or `None` if it is empty.\n     #[inline]\n-    fn last_opt(&self) -> Option<&'self T> { last_opt(*self) }\n+    fn last_opt(&self) -> Option<&'self T> {\n+            if self.len() == 0 { None } else { Some(&self[self.len() - 1]) }\n+    }\n \n     /**\n      * Find the last index matching some predicate"}]}