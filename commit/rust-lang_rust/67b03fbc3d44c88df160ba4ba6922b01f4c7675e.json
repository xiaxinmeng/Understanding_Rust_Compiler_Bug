{"sha": "67b03fbc3d44c88df160ba4ba6922b01f4c7675e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3YjAzZmJjM2Q0NGM4OGRmMTYwYmE0YmE2OTIyYjAxZjRjNzY3NWU=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-02-23T03:07:38Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-02-23T03:07:38Z"}, "message": "int audit - libcore::fmt", "tree": {"sha": "d14abc9380bf0709d9d2425947369ed8f9ec3e10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d14abc9380bf0709d9d2425947369ed8f9ec3e10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67b03fbc3d44c88df160ba4ba6922b01f4c7675e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67b03fbc3d44c88df160ba4ba6922b01f4c7675e", "html_url": "https://github.com/rust-lang/rust/commit/67b03fbc3d44c88df160ba4ba6922b01f4c7675e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67b03fbc3d44c88df160ba4ba6922b01f4c7675e/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd", "html_url": "https://github.com/rust-lang/rust/commit/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd"}], "stats": {"total": 124, "additions": 73, "deletions": 51}, "files": [{"sha": "f92e631c1f25c4becc028f0056484346b26fa603", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/67b03fbc3d44c88df160ba4ba6922b01f4c7675e/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67b03fbc3d44c88df160ba4ba6922b01f4c7675e/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=67b03fbc3d44c88df160ba4ba6922b01f4c7675e", "patch": "@@ -40,10 +40,10 @@ pub enum ExponentFormat {\n pub enum SignificantDigits {\n     /// At most the given number of digits will be printed, truncating any\n     /// trailing zeroes.\n-    DigMax(uint),\n+    DigMax(usize),\n \n     /// Precisely the given number of digits will be printed.\n-    DigExact(uint)\n+    DigExact(usize)\n }\n \n /// How to emit the sign of a number.\n@@ -240,27 +240,27 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n                     // If reached left end of number, have to\n                     // insert additional digit:\n                     if i < 0\n-                    || buf[i as uint] == b'-'\n-                    || buf[i as uint] == b'+' {\n-                        for j in (i as uint + 1..end).rev() {\n+                    || buf[i as usize] == b'-'\n+                    || buf[i as usize] == b'+' {\n+                        for j in (i as usize + 1..end).rev() {\n                             buf[j + 1] = buf[j];\n                         }\n-                        buf[(i + 1) as uint] = value2ascii(1);\n+                        buf[(i + 1) as usize] = value2ascii(1);\n                         end += 1;\n                         break;\n                     }\n \n                     // Skip the '.'\n-                    if buf[i as uint] == b'.' { i -= 1; continue; }\n+                    if buf[i as usize] == b'.' { i -= 1; continue; }\n \n                     // Either increment the digit,\n                     // or set to 0 if max and carry the 1.\n-                    let current_digit = ascii2value(buf[i as uint]);\n+                    let current_digit = ascii2value(buf[i as usize]);\n                     if current_digit < (radix - 1) {\n-                        buf[i as uint] = value2ascii(current_digit+1);\n+                        buf[i as usize] = value2ascii(current_digit+1);\n                         break;\n                     } else {\n-                        buf[i as uint] = value2ascii(0);\n+                        buf[i as usize] = value2ascii(0);\n                         i -= 1;\n                     }\n                 }\n@@ -311,7 +311,7 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n \n             struct Filler<'a> {\n                 buf: &'a mut [u8],\n-                end: &'a mut uint,\n+                end: &'a mut usize,\n             }\n \n             impl<'a> fmt::Write for Filler<'a> {"}, {"sha": "175a70aeb9f460c98b4662a8d75cfa8392435b8c", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 38, "deletions": 23, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/67b03fbc3d44c88df160ba4ba6922b01f4c7675e/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67b03fbc3d44c88df160ba4ba6922b01f4c7675e/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=67b03fbc3d44c88df160ba4ba6922b01f4c7675e", "patch": "@@ -110,11 +110,14 @@ pub trait Write {\n /// traits.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Formatter<'a> {\n-    flags: uint,\n+    #[cfg(not(stage0))]\n+    flags: u32,\n+    #[cfg(stage0)]\n+    flags: usize,\n     fill: char,\n     align: rt::v1::Alignment,\n-    width: Option<uint>,\n-    precision: Option<uint>,\n+    width: Option<usize>,\n+    precision: Option<usize>,\n \n     buf: &'a mut (Write+'a),\n     curarg: slice::Iter<'a, ArgumentV1<'a>>,\n@@ -140,7 +143,7 @@ pub struct ArgumentV1<'a> {\n \n impl<'a> ArgumentV1<'a> {\n     #[inline(never)]\n-    fn show_uint(x: &uint, f: &mut Formatter) -> Result {\n+    fn show_usize(x: &usize, f: &mut Formatter) -> Result {\n         Display::fmt(x, f)\n     }\n \n@@ -156,15 +159,22 @@ impl<'a> ArgumentV1<'a> {\n         }\n     }\n \n+    #[cfg(stage0)]\n     #[doc(hidden)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn from_uint(x: &uint) -> ArgumentV1 {\n-        ArgumentV1::new(x, ArgumentV1::show_uint)\n+        ArgumentV1::new(x, ArgumentV1::show_usize)\n+    }\n+    #[cfg(not(stage0))]\n+    #[doc(hidden)]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn from_usize(x: &usize) -> ArgumentV1 {\n+        ArgumentV1::new(x, ArgumentV1::show_usize)\n     }\n \n-    fn as_uint(&self) -> Option<uint> {\n-        if self.formatter as uint == ArgumentV1::show_uint as uint {\n-            Some(unsafe { *(self.value as *const _ as *const uint) })\n+    fn as_usize(&self) -> Option<usize> {\n+        if self.formatter as usize == ArgumentV1::show_usize as usize {\n+            Some(unsafe { *(self.value as *const _ as *const usize) })\n         } else {\n             None\n         }\n@@ -194,7 +204,7 @@ impl<'a> Arguments<'a> {\n     /// The `pieces` array must be at least as long as `fmt` to construct\n     /// a valid Arguments structure. Also, any `Count` within `fmt` that is\n     /// `CountIsParam` or `CountIsNextParam` has to point to an argument\n-    /// created with `argumentuint`. However, failing to do so doesn't cause\n+    /// created with `argumentusize`. However, failing to do so doesn't cause\n     /// unsafety, but will ignore invalid .\n     #[doc(hidden)] #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -434,15 +444,15 @@ impl<'a> Formatter<'a> {\n         (value.formatter)(value.value, self)\n     }\n \n-    fn getcount(&mut self, cnt: &rt::v1::Count) -> Option<uint> {\n+    fn getcount(&mut self, cnt: &rt::v1::Count) -> Option<usize> {\n         match *cnt {\n             rt::v1::Count::Is(n) => Some(n),\n             rt::v1::Count::Implied => None,\n             rt::v1::Count::Param(i) => {\n-                self.args[i].as_uint()\n+                self.args[i].as_usize()\n             }\n             rt::v1::Count::NextParam => {\n-                self.curarg.next().and_then(|arg| arg.as_uint())\n+                self.curarg.next().and_then(|arg| arg.as_usize())\n             }\n         }\n     }\n@@ -476,12 +486,12 @@ impl<'a> Formatter<'a> {\n         let mut sign = None;\n         if !is_positive {\n             sign = Some('-'); width += 1;\n-        } else if self.flags & (1 << (FlagV1::SignPlus as uint)) != 0 {\n+        } else if self.flags & (1 << (FlagV1::SignPlus as u32)) != 0 {\n             sign = Some('+'); width += 1;\n         }\n \n         let mut prefixed = false;\n-        if self.flags & (1 << (FlagV1::Alternate as uint)) != 0 {\n+        if self.flags & (1 << (FlagV1::Alternate as u32)) != 0 {\n             prefixed = true; width += prefix.char_len();\n         }\n \n@@ -511,7 +521,7 @@ impl<'a> Formatter<'a> {\n             }\n             // The sign and prefix goes before the padding if the fill character\n             // is zero\n-            Some(min) if self.flags & (1 << (FlagV1::SignAwareZeroPad as uint)) != 0 => {\n+            Some(min) if self.flags & (1 << (FlagV1::SignAwareZeroPad as u32)) != 0 => {\n                 self.fill = '0';\n                 try!(write_prefix(self));\n                 self.with_padding(min - width, Alignment::Right, |f| {\n@@ -581,7 +591,7 @@ impl<'a> Formatter<'a> {\n \n     /// Runs a callback, emitting the correct padding either before or\n     /// afterwards depending on whether right or left alignment is requested.\n-    fn with_padding<F>(&mut self, padding: uint, default: Alignment,\n+    fn with_padding<F>(&mut self, padding: usize, default: Alignment,\n                        f: F) -> Result\n         where F: FnOnce(&mut Formatter) -> Result,\n     {\n@@ -627,6 +637,11 @@ impl<'a> Formatter<'a> {\n         write(self.buf, fmt)\n     }\n \n+    #[cfg(not(stage0))]\n+    /// Flags for formatting (packed version of rt::Flag)\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn flags(&self) -> u32 { self.flags }\n+    #[cfg(stage0)]\n     /// Flags for formatting (packed version of rt::Flag)\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn flags(&self) -> usize { self.flags }\n@@ -641,11 +656,11 @@ impl<'a> Formatter<'a> {\n \n     /// Optionally specified integer width that the output should be\n     #[unstable(feature = \"core\", reason = \"method was just created\")]\n-    pub fn width(&self) -> Option<uint> { self.width }\n+    pub fn width(&self) -> Option<usize> { self.width }\n \n     /// Optionally specified precision for numeric types\n     #[unstable(feature = \"core\", reason = \"method was just created\")]\n-    pub fn precision(&self) -> Option<uint> { self.precision }\n+    pub fn precision(&self) -> Option<usize> { self.precision }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -731,9 +746,9 @@ impl Display for char {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Pointer for *const T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        f.flags |= 1 << (FlagV1::Alternate as uint);\n-        let ret = LowerHex::fmt(&(*self as uint), f);\n-        f.flags &= !(1 << (FlagV1::Alternate as uint));\n+        f.flags |= 1 << (FlagV1::Alternate as u32);\n+        let ret = LowerHex::fmt(&(*self as u32), f);\n+        f.flags &= !(1 << (FlagV1::Alternate as u32));\n         ret\n     }\n }\n@@ -889,7 +904,7 @@ impl<'a> Debug for &'a (any::Any+'a) {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Debug> Debug for [T] {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n-        if f.flags & (1 << (FlagV1::Alternate as uint)) == 0 {\n+        if f.flags & (1 << (FlagV1::Alternate as u32)) == 0 {\n             try!(write!(f, \"[\"));\n         }\n         let mut is_first = true;\n@@ -901,7 +916,7 @@ impl<T: Debug> Debug for [T] {\n             }\n             try!(write!(f, \"{:?}\", *x))\n         }\n-        if f.flags & (1 << (FlagV1::Alternate as uint)) == 0 {\n+        if f.flags & (1 << (FlagV1::Alternate as u32)) == 0 {\n             try!(write!(f, \"]\"));\n         }\n         Ok(())"}, {"sha": "0175e21c8da6152b47bfbbae924118a19bc3bc64", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67b03fbc3d44c88df160ba4ba6922b01f4c7675e/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67b03fbc3d44c88df160ba4ba6922b01f4c7675e/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=67b03fbc3d44c88df160ba4ba6922b01f4c7675e", "patch": "@@ -214,7 +214,7 @@ macro_rules! integer {\n         show! { $Uint with $SU }\n     }\n }\n-integer! { int, uint, \"i\", \"u\" }\n+integer! { isize, usize, \"i\", \"u\" }\n integer! { i8, u8 }\n integer! { i16, u16 }\n integer! { i32, u32 }"}, {"sha": "c35611acb81428561ccb4634f72889588e534ec6", "filename": "src/libcore/fmt/rt/v1.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67b03fbc3d44c88df160ba4ba6922b01f4c7675e/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67b03fbc3d44c88df160ba4ba6922b01f4c7675e/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs?ref=67b03fbc3d44c88df160ba4ba6922b01f4c7675e", "patch": "@@ -32,8 +32,12 @@ pub struct FormatSpec {\n     pub fill: char,\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub align: Alignment,\n+    #[cfg(stage0)]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub flags: uint,\n+    pub flags: usize,\n+    #[cfg(not(stage0))]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub flags: u32,\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub precision: Count,\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "4e25e51e9a466075c58b49ae0207413b88a8b426", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/67b03fbc3d44c88df160ba4ba6922b01f4c7675e/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67b03fbc3d44c88df160ba4ba6922b01f4c7675e/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=67b03fbc3d44c88df160ba4ba6922b01f4c7675e", "patch": "@@ -24,7 +24,6 @@\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n-#![feature(int_uint)]\n #![feature(staged_api)]\n #![feature(unicode)]\n \n@@ -65,7 +64,7 @@ pub struct FormatSpec<'a> {\n     /// Optionally specified alignment\n     pub align: Alignment,\n     /// Packed version of various flags provided\n-    pub flags: uint,\n+    pub flags: u32,\n     /// The integer precision to use\n     pub precision: Count<'a>,\n     /// The string width requested for the resulting format\n@@ -82,7 +81,7 @@ pub enum Position<'a> {\n     /// The argument will be in the next position. This is the default.\n     ArgumentNext,\n     /// The argument is located at a specific index.\n-    ArgumentIs(uint),\n+    ArgumentIs(usize),\n     /// The argument has a name.\n     ArgumentNamed(&'a str),\n }\n@@ -121,11 +120,11 @@ pub enum Flag {\n #[derive(Copy, PartialEq)]\n pub enum Count<'a> {\n     /// The count is specified explicitly.\n-    CountIs(uint),\n+    CountIs(usize),\n     /// The count is specified by the argument with the given name.\n     CountIsName(&'a str),\n     /// The count is specified by the argument at the given index.\n-    CountIsParam(uint),\n+    CountIsParam(usize),\n     /// The count is specified by the next parameter.\n     CountIsNextParam,\n     /// The count is implied and cannot be explicitly specified.\n@@ -237,7 +236,7 @@ impl<'a> Parser<'a> {\n \n     /// Parses all of a string which is to be considered a \"raw literal\" in a\n     /// format string. This is everything outside of the braces.\n-    fn string(&mut self, start: uint) -> &'a str {\n+    fn string(&mut self, start: usize) -> &'a str {\n         loop {\n             // we may not consume the character, so clone the iterator\n             match self.cur.clone().next() {\n@@ -314,13 +313,13 @@ impl<'a> Parser<'a> {\n         }\n         // Sign flags\n         if self.consume('+') {\n-            spec.flags |= 1 << (FlagSignPlus as uint);\n+            spec.flags |= 1 << (FlagSignPlus as u32);\n         } else if self.consume('-') {\n-            spec.flags |= 1 << (FlagSignMinus as uint);\n+            spec.flags |= 1 << (FlagSignMinus as u32);\n         }\n         // Alternate marker\n         if self.consume('#') {\n-            spec.flags |= 1 << (FlagAlternate as uint);\n+            spec.flags |= 1 << (FlagAlternate as u32);\n         }\n         // Width and precision\n         let mut havewidth = false;\n@@ -333,7 +332,7 @@ impl<'a> Parser<'a> {\n                 spec.width = CountIsParam(0);\n                 havewidth = true;\n             } else {\n-                spec.flags |= 1 << (FlagSignAwareZeroPad as uint);\n+                spec.flags |= 1 << (FlagSignAwareZeroPad as u32);\n             }\n         }\n         if !havewidth {\n@@ -413,7 +412,7 @@ impl<'a> Parser<'a> {\n \n     /// Optionally parses an integer at the current position. This doesn't deal\n     /// with overflow at all, it's just accumulating digits.\n-    fn integer(&mut self) -> Option<uint> {\n+    fn integer(&mut self) -> Option<usize> {\n         let mut cur = 0;\n         let mut found = false;\n         loop {\n@@ -617,7 +616,7 @@ mod tests {\n             format: FormatSpec {\n                 fill: None,\n                 align: AlignUnknown,\n-                flags: (1 << FlagSignMinus as uint),\n+                flags: (1 << FlagSignMinus as u32),\n                 precision: CountImplied,\n                 width: CountImplied,\n                 ty: \"\",\n@@ -628,7 +627,7 @@ mod tests {\n             format: FormatSpec {\n                 fill: None,\n                 align: AlignUnknown,\n-                flags: (1 << FlagSignPlus as uint) | (1 << FlagAlternate as uint),\n+                flags: (1 << FlagSignPlus as u32) | (1 << FlagAlternate as u32),\n                 precision: CountImplied,\n                 width: CountImplied,\n                 ty: \"\","}, {"sha": "656d507ed69b826952ecbe61bb354f1c72c69836", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67b03fbc3d44c88df160ba4ba6922b01f4c7675e/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67b03fbc3d44c88df160ba4ba6922b01f4c7675e/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=67b03fbc3d44c88df160ba4ba6922b01f4c7675e", "patch": "@@ -148,6 +148,7 @@ pub trait AstBuilder {\n     fn expr_usize(&self, span: Span, i: usize) -> P<ast::Expr>;\n     fn expr_int(&self, sp: Span, i: isize) -> P<ast::Expr>;\n     fn expr_u8(&self, sp: Span, u: u8) -> P<ast::Expr>;\n+    fn expr_u32(&self, sp: Span, u: u32) -> P<ast::Expr>;\n     fn expr_bool(&self, sp: Span, value: bool) -> P<ast::Expr>;\n \n     fn expr_vec(&self, sp: Span, exprs: Vec<P<ast::Expr>>) -> P<ast::Expr>;\n@@ -701,6 +702,9 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr_lit(sp, ast::LitInt(i as u64, ast::SignedIntLit(ast::TyIs(false),\n                                                                   ast::Sign::new(i))))\n     }\n+    fn expr_u32(&self, sp: Span, u: u32) -> P<ast::Expr> {\n+        self.expr_lit(sp, ast::LitInt(u as u64, ast::UnsignedIntLit(ast::TyU32)))\n+    }\n     fn expr_u8(&self, sp: Span, u: u8) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitInt(u as u64, ast::UnsignedIntLit(ast::TyU8)))\n     }"}, {"sha": "91262556abd706f72ee4bcc91b90d279d1292221", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67b03fbc3d44c88df160ba4ba6922b01f4c7675e/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67b03fbc3d44c88df160ba4ba6922b01f4c7675e/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=67b03fbc3d44c88df160ba4ba6922b01f4c7675e", "patch": "@@ -417,7 +417,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     parse::AlignUnknown => align(\"Unknown\"),\n                 };\n                 let align = self.ecx.expr_path(align);\n-                let flags = self.ecx.expr_usize(sp, arg.format.flags);\n+                let flags = self.ecx.expr_u32(sp, arg.format.flags);\n                 let prec = self.trans_count(arg.format.precision);\n                 let width = self.trans_count(arg.format.width);\n                 let path = self.ecx.path_global(sp, Context::rtpath(self.ecx, \"FormatSpec\"));\n@@ -610,7 +610,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                         ecx.ident_of_std(\"core\"),\n                         ecx.ident_of(\"fmt\"),\n                         ecx.ident_of(\"ArgumentV1\"),\n-                        ecx.ident_of(\"from_uint\")], vec![arg])\n+                        ecx.ident_of(\"from_usize\")], vec![arg])\n             }\n         };\n "}]}