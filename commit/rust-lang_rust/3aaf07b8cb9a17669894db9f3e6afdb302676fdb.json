{"sha": "3aaf07b8cb9a17669894db9f3e6afdb302676fdb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhYWYwN2I4Y2I5YTE3NjY5ODk0ZGI5ZjNlNmFmZGIzMDI2NzZmZGI=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-06-10T20:03:16Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-06-10T20:43:46Z"}, "message": "Add more profiling for flyimports", "tree": {"sha": "40887b0852021392418f7369d9c3ec27ab966b62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/40887b0852021392418f7369d9c3ec27ab966b62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3aaf07b8cb9a17669894db9f3e6afdb302676fdb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3aaf07b8cb9a17669894db9f3e6afdb302676fdb", "html_url": "https://github.com/rust-lang/rust/commit/3aaf07b8cb9a17669894db9f3e6afdb302676fdb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3aaf07b8cb9a17669894db9f3e6afdb302676fdb/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4da4de7cdd4a7dfe40a417b0100b83ec50d1e1d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4da4de7cdd4a7dfe40a417b0100b83ec50d1e1d", "html_url": "https://github.com/rust-lang/rust/commit/f4da4de7cdd4a7dfe40a417b0100b83ec50d1e1d"}], "stats": {"total": 163, "additions": 92, "deletions": 71}, "files": [{"sha": "54baa3a63305a40f8bd55dd04011345f2533c820", "filename": "crates/base_db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3aaf07b8cb9a17669894db9f3e6afdb302676fdb/crates%2Fbase_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aaf07b8cb9a17669894db9f3e6afdb302676fdb/crates%2Fbase_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fbase_db%2Fsrc%2Flib.rs?ref=3aaf07b8cb9a17669894db9f3e6afdb302676fdb", "patch": "@@ -120,6 +120,7 @@ impl<T: SourceDatabaseExt> FileLoader for FileLoaderDelegate<&'_ T> {\n     }\n \n     fn relevant_crates(&self, file_id: FileId) -> Arc<FxHashSet<CrateId>> {\n+        let _p = profile::span(\"relevant_crates\");\n         let source_root = self.0.file_source_root(file_id);\n         self.0.source_root_crates(source_root)\n     }"}, {"sha": "b9c1dc44df0806bf738a6340726dde4e79b3dfaa", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3aaf07b8cb9a17669894db9f3e6afdb302676fdb/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aaf07b8cb9a17669894db9f3e6afdb302676fdb/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=3aaf07b8cb9a17669894db9f3e6afdb302676fdb", "patch": "@@ -191,6 +191,7 @@ impl Crate {\n         db: &dyn DefDatabase,\n         query: import_map::Query,\n     ) -> impl Iterator<Item = Either<ModuleDef, MacroDef>> {\n+        let _p = profile::span(\"query_external_importables\");\n         import_map::search_dependencies(db, self.into(), query).into_iter().map(|item| match item {\n             ItemInNs::Types(mod_id) | ItemInNs::Values(mod_id) => Either::Left(mod_id.into()),\n             ItemInNs::Macros(mac_id) => Either::Right(mac_id.into()),\n@@ -2185,6 +2186,7 @@ impl Type {\n         name: Option<&Name>,\n         mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n     ) -> Option<T> {\n+        let _p = profile::span(\"iterate_method_candidates\");\n         // There should be no inference vars in types passed here\n         // FIXME check that?\n         // FIXME replace Unknown by bound vars here\n@@ -2218,6 +2220,7 @@ impl Type {\n         name: Option<&Name>,\n         mut callback: impl FnMut(&Ty, AssocItem) -> Option<T>,\n     ) -> Option<T> {\n+        let _p = profile::span(\"iterate_path_candidates\");\n         let canonical = hir_ty::replace_errors_with_variables(&self.ty);\n \n         let env = self.env.clone();\n@@ -2255,6 +2258,7 @@ impl Type {\n         &'a self,\n         db: &'a dyn HirDatabase,\n     ) -> impl Iterator<Item = Trait> + 'a {\n+        let _p = profile::span(\"applicable_inherent_traits\");\n         self.autoderef(db)\n             .filter_map(|derefed_type| derefed_type.ty.dyn_trait())\n             .flat_map(move |dyn_trait_id| hir_ty::all_super_traits(db.upcast(), dyn_trait_id))"}, {"sha": "2055edc95af0e02f0258f076c640a0c49fc86e63", "filename": "crates/hir_def/src/import_map.rs", "status": "modified", "additions": 82, "deletions": 71, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/3aaf07b8cb9a17669894db9f3e6afdb302676fdb/crates%2Fhir_def%2Fsrc%2Fimport_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aaf07b8cb9a17669894db9f3e6afdb302676fdb/crates%2Fhir_def%2Fsrc%2Fimport_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fimport_map.rs?ref=3aaf07b8cb9a17669894db9f3e6afdb302676fdb", "patch": "@@ -69,80 +69,10 @@ pub struct ImportMap {\n impl ImportMap {\n     pub fn import_map_query(db: &dyn DefDatabase, krate: CrateId) -> Arc<Self> {\n         let _p = profile::span(\"import_map_query\");\n-        let def_map = db.crate_def_map(krate);\n-        let mut import_map = Self::default();\n-\n-        // We look only into modules that are public(ly reexported), starting with the crate root.\n-        let empty = ImportPath { segments: vec![] };\n-        let root = def_map.module_id(def_map.root());\n-        let mut worklist = vec![(root, empty)];\n-        while let Some((module, mod_path)) = worklist.pop() {\n-            let ext_def_map;\n-            let mod_data = if module.krate == krate {\n-                &def_map[module.local_id]\n-            } else {\n-                // The crate might reexport a module defined in another crate.\n-                ext_def_map = module.def_map(db);\n-                &ext_def_map[module.local_id]\n-            };\n-\n-            let visible_items = mod_data.scope.entries().filter_map(|(name, per_ns)| {\n-                let per_ns = per_ns.filter_visibility(|vis| vis == Visibility::Public);\n-                if per_ns.is_none() {\n-                    None\n-                } else {\n-                    Some((name, per_ns))\n-                }\n-            });\n \n-            for (name, per_ns) in visible_items {\n-                let mk_path = || {\n-                    let mut path = mod_path.clone();\n-                    path.segments.push(name.clone());\n-                    path\n-                };\n-\n-                for item in per_ns.iter_items() {\n-                    let path = mk_path();\n-                    let path_len = path.len();\n-                    let import_info =\n-                        ImportInfo { path, container: module, is_trait_assoc_item: false };\n-\n-                    if let Some(ModuleDefId::TraitId(tr)) = item.as_module_def_id() {\n-                        import_map.collect_trait_assoc_items(\n-                            db,\n-                            tr,\n-                            matches!(item, ItemInNs::Types(_)),\n-                            &import_info,\n-                        );\n-                    }\n-\n-                    match import_map.map.entry(item) {\n-                        Entry::Vacant(entry) => {\n-                            entry.insert(import_info);\n-                        }\n-                        Entry::Occupied(mut entry) => {\n-                            // If the new path is shorter, prefer that one.\n-                            if path_len < entry.get().path.len() {\n-                                *entry.get_mut() = import_info;\n-                            } else {\n-                                continue;\n-                            }\n-                        }\n-                    }\n-\n-                    // If we've just added a path to a module, descend into it. We might traverse\n-                    // modules multiple times, but only if the new path to it is shorter than the\n-                    // first (else we `continue` above).\n-                    if let Some(ModuleDefId::ModuleId(mod_id)) = item.as_module_def_id() {\n-                        worklist.push((mod_id, mk_path()));\n-                    }\n-                }\n-            }\n-        }\n+        let mut import_map = collect_import_map(db, krate);\n \n         let mut importables = import_map.map.iter().collect::<Vec<_>>();\n-\n         importables.sort_by(cmp);\n \n         // Build the FST, taking care not to insert duplicate values.\n@@ -185,6 +115,7 @@ impl ImportMap {\n         is_type_in_ns: bool,\n         original_import_info: &ImportInfo,\n     ) {\n+        let _p = profile::span(\"collect_trait_assoc_items\");\n         for (assoc_item_name, item) in &db.trait_data(tr).items {\n             let module_def_id = match item {\n                 AssocItemId::FunctionId(f) => ModuleDefId::from(*f),\n@@ -210,6 +141,84 @@ impl ImportMap {\n     }\n }\n \n+fn collect_import_map(db: &dyn DefDatabase, krate: CrateId) -> ImportMap {\n+    let _p = profile::span(\"collect_import_map\");\n+\n+    let def_map = db.crate_def_map(krate);\n+    let mut import_map = ImportMap::default();\n+\n+    // We look only into modules that are public(ly reexported), starting with the crate root.\n+    let empty = ImportPath { segments: vec![] };\n+    let root = def_map.module_id(def_map.root());\n+    let mut worklist = vec![(root, empty)];\n+    while let Some((module, mod_path)) = worklist.pop() {\n+        let ext_def_map;\n+        let mod_data = if module.krate == krate {\n+            &def_map[module.local_id]\n+        } else {\n+            // The crate might reexport a module defined in another crate.\n+            ext_def_map = module.def_map(db);\n+            &ext_def_map[module.local_id]\n+        };\n+\n+        let visible_items = mod_data.scope.entries().filter_map(|(name, per_ns)| {\n+            let per_ns = per_ns.filter_visibility(|vis| vis == Visibility::Public);\n+            if per_ns.is_none() {\n+                None\n+            } else {\n+                Some((name, per_ns))\n+            }\n+        });\n+\n+        for (name, per_ns) in visible_items {\n+            let mk_path = || {\n+                let mut path = mod_path.clone();\n+                path.segments.push(name.clone());\n+                path\n+            };\n+\n+            for item in per_ns.iter_items() {\n+                let path = mk_path();\n+                let path_len = path.len();\n+                let import_info =\n+                    ImportInfo { path, container: module, is_trait_assoc_item: false };\n+\n+                if let Some(ModuleDefId::TraitId(tr)) = item.as_module_def_id() {\n+                    import_map.collect_trait_assoc_items(\n+                        db,\n+                        tr,\n+                        matches!(item, ItemInNs::Types(_)),\n+                        &import_info,\n+                    );\n+                }\n+\n+                match import_map.map.entry(item) {\n+                    Entry::Vacant(entry) => {\n+                        entry.insert(import_info);\n+                    }\n+                    Entry::Occupied(mut entry) => {\n+                        // If the new path is shorter, prefer that one.\n+                        if path_len < entry.get().path.len() {\n+                            *entry.get_mut() = import_info;\n+                        } else {\n+                            continue;\n+                        }\n+                    }\n+                }\n+\n+                // If we've just added a path to a module, descend into it. We might traverse\n+                // modules multiple times, but only if the new path to it is shorter than the\n+                // first (else we `continue` above).\n+                if let Some(ModuleDefId::ModuleId(mod_id)) = item.as_module_def_id() {\n+                    worklist.push((mod_id, mk_path()));\n+                }\n+            }\n+        }\n+    }\n+\n+    import_map\n+}\n+\n impl PartialEq for ImportMap {\n     fn eq(&self, other: &Self) -> bool {\n         // `fst` and `importables` are built from `map`, so we don't need to compare them.\n@@ -240,6 +249,7 @@ impl fmt::Debug for ImportMap {\n }\n \n fn fst_path(path: &ImportPath) -> String {\n+    let _p = profile::span(\"fst_path\");\n     let mut s = path.to_string();\n     s.make_ascii_lowercase();\n     s\n@@ -338,6 +348,7 @@ impl Query {\n     }\n \n     fn import_matches(&self, import: &ImportInfo, enforce_lowercase: bool) -> bool {\n+        let _p = profile::span(\"import_map::Query::import_matches\");\n         if import.is_trait_assoc_item {\n             if self.exclude_import_kinds.contains(&ImportKind::AssociatedItem) {\n                 return false;"}, {"sha": "3a45cbfa1217855a368588441fe42c61b4175b31", "filename": "crates/hir_def/src/lang_item.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3aaf07b8cb9a17669894db9f3e6afdb302676fdb/crates%2Fhir_def%2Fsrc%2Flang_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aaf07b8cb9a17669894db9f3e6afdb302676fdb/crates%2Fhir_def%2Fsrc%2Flang_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flang_item.rs?ref=3aaf07b8cb9a17669894db9f3e6afdb302676fdb", "patch": "@@ -141,6 +141,7 @@ impl LangItems {\n     ) where\n         T: Into<AttrDefId> + Copy,\n     {\n+        let _p = profile::span(\"collect_lang_item\");\n         if let Some(lang_item_name) = lang_attr(db, item) {\n             self.items.entry(lang_item_name).or_insert_with(|| constructor(item));\n         }"}, {"sha": "a9f13cb82085ec4346531d98a08a8627d8e4be65", "filename": "crates/hir_def/src/per_ns.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3aaf07b8cb9a17669894db9f3e6afdb302676fdb/crates%2Fhir_def%2Fsrc%2Fper_ns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aaf07b8cb9a17669894db9f3e6afdb302676fdb/crates%2Fhir_def%2Fsrc%2Fper_ns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fper_ns.rs?ref=3aaf07b8cb9a17669894db9f3e6afdb302676fdb", "patch": "@@ -62,6 +62,7 @@ impl PerNs {\n     }\n \n     pub fn filter_visibility(self, mut f: impl FnMut(Visibility) -> bool) -> PerNs {\n+        let _p = profile::span(\"PerNs::filter_visibility\");\n         PerNs {\n             types: self.types.filter(|(_, v)| f(*v)),\n             values: self.values.filter(|(_, v)| f(*v)),\n@@ -86,6 +87,7 @@ impl PerNs {\n     }\n \n     pub fn iter_items(self) -> impl Iterator<Item = ItemInNs> {\n+        let _p = profile::span(\"PerNs::iter_items\");\n         self.types\n             .map(|it| ItemInNs::Types(it.0))\n             .into_iter()"}, {"sha": "000f87a8588c2b870d5397e3f51ac608fdce90bb", "filename": "crates/ide_db/src/symbol_index.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3aaf07b8cb9a17669894db9f3e6afdb302676fdb/crates%2Fide_db%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3aaf07b8cb9a17669894db9f3e6afdb302676fdb/crates%2Fide_db%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsymbol_index.rs?ref=3aaf07b8cb9a17669894db9f3e6afdb302676fdb", "patch": "@@ -197,6 +197,7 @@ pub fn world_symbols(db: &RootDatabase, query: Query) -> Vec<FileSymbol> {\n }\n \n pub fn crate_symbols(db: &RootDatabase, krate: CrateId, query: Query) -> Vec<FileSymbol> {\n+    let _p = profile::span(\"crate_symbols\").detail(|| format!(\"{:?}\", query));\n     // FIXME(#4842): This now depends on CrateDefMap, why not build the entire symbol index from\n     // that instead?\n \n@@ -321,6 +322,7 @@ impl SymbolIndex {\n \n impl Query {\n     pub(crate) fn search(self, indices: &[&SymbolIndex]) -> Vec<FileSymbol> {\n+        let _p = profile::span(\"symbol_index::Query::search\");\n         let mut op = fst::map::OpBuilder::new();\n         for file_symbols in indices.iter() {\n             let automaton = fst::automaton::Subsequence::new(&self.lowercased);"}]}