{"sha": "0312bf5fb919cb22280367ff445d4a9cbd842539", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzMTJiZjVmYjkxOWNiMjIyODAzNjdmZjQ0NWQ0YTljYmQ4NDI1Mzk=", "commit": {"author": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2021-04-30T07:14:51Z"}, "committer": {"name": "Rich Kadel", "email": "richkadel@google.com", "date": "2021-04-30T08:10:48Z"}, "message": "Rebuilt out of date tests and fixed an old bug now exposed", "tree": {"sha": "1261641075f5a6d8a1c504a3c44c007396165f80", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1261641075f5a6d8a1c504a3c44c007396165f80"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0312bf5fb919cb22280367ff445d4a9cbd842539", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0312bf5fb919cb22280367ff445d4a9cbd842539", "html_url": "https://github.com/rust-lang/rust/commit/0312bf5fb919cb22280367ff445d4a9cbd842539", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0312bf5fb919cb22280367ff445d4a9cbd842539/comments", "author": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "committer": {"login": "richkadel", "id": 3827298, "node_id": "MDQ6VXNlcjM4MjcyOTg=", "avatar_url": "https://avatars.githubusercontent.com/u/3827298?v=4", "gravatar_id": "", "url": "https://api.github.com/users/richkadel", "html_url": "https://github.com/richkadel", "followers_url": "https://api.github.com/users/richkadel/followers", "following_url": "https://api.github.com/users/richkadel/following{/other_user}", "gists_url": "https://api.github.com/users/richkadel/gists{/gist_id}", "starred_url": "https://api.github.com/users/richkadel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/richkadel/subscriptions", "organizations_url": "https://api.github.com/users/richkadel/orgs", "repos_url": "https://api.github.com/users/richkadel/repos", "events_url": "https://api.github.com/users/richkadel/events{/privacy}", "received_events_url": "https://api.github.com/users/richkadel/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eef546abb6ce8f153dd517db52fbc6c955f631dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/eef546abb6ce8f153dd517db52fbc6c955f631dc", "html_url": "https://github.com/rust-lang/rust/commit/eef546abb6ce8f153dd517db52fbc6c955f631dc"}], "stats": {"total": 288, "additions": 275, "deletions": 13}, "files": [{"sha": "b3fc2a0cb5e90cc1def39b9fed5ceb9a4cf06fe5", "filename": "compiler/rustc_mir/src/transform/coverage/spans.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/0312bf5fb919cb22280367ff445d4a9cbd842539/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0312bf5fb919cb22280367ff445d4a9cbd842539/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcoverage%2Fspans.rs?ref=0312bf5fb919cb22280367ff445d4a9cbd842539", "patch": "@@ -243,14 +243,18 @@ pub struct CoverageSpans<'a, 'tcx> {\n     /// iteration.\n     some_curr: Option<CoverageSpan>,\n \n-    /// The original `span` for `curr`, in case the `curr` span is modified.\n+    /// The original `span` for `curr`, in case `curr.span()` is modified. The `curr_original_span`\n+    /// **must not be mutated** (except when advancing to the next `curr`), even if `curr.span()`\n+    /// is mutated.\n     curr_original_span: Span,\n \n     /// The CoverageSpan from a prior iteration; typically assigned from that iteration's `curr`.\n     /// If that `curr` was discarded, `prev` retains its value from the previous iteration.\n     some_prev: Option<CoverageSpan>,\n \n-    /// Assigned from `curr_original_span` from the previous iteration.\n+    /// Assigned from `curr_original_span` from the previous iteration. The `prev_original_span`\n+    /// **must not be mutated** (except when advancing to the next `prev`), even if `prev.span()`\n+    /// is mutated.\n     prev_original_span: Span,\n \n     /// A copy of the expn_span from the prior iteration.\n@@ -400,8 +404,12 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n             } else if self.curr().is_closure {\n                 self.carve_out_span_for_closure();\n             } else if self.prev_original_span == self.curr().span {\n-                // Note that this compares the new span to `prev_original_span`, which may not\n-                // be the full `prev.span` (if merged during the previous iteration).\n+                // Note that this compares the new (`curr`) span to `prev_original_span`.\n+                // In this branch, the actual span byte range of `prev_original_span` is not\n+                // important. What is important is knowing whether the new `curr` span was\n+                // **originally** the same as the original span of `prev()`. The original spans\n+                // reflect their original sort order, and for equal spans, conveys a partial\n+                // ordering based on CFG dominator priority.\n                 if self.prev().is_macro_expansion() && self.curr().is_macro_expansion() {\n                     // Macros that expand to include branching (such as\n                     // `assert_eq!()`, `assert_ne!()`, `info!()`, `debug!()`, or\n@@ -663,10 +671,13 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n             self.push_refined_span(pre_closure);\n         }\n         if has_post_closure_span {\n-            // Update prev.span to start after the closure (and discard curr)\n+            // Mutate `prev.span()` to start after the closure (and discard curr).\n+            // (**NEVER** update `prev_original_span` because it affects the assumptions\n+            // about how the `CoverageSpan`s are ordered.)\n             self.prev_mut().span = self.prev().span.with_lo(right_cutoff);\n-            self.prev_original_span = self.prev().span;\n+            debug!(\"  Mutated prev.span to start after the closure. prev={:?}\", self.prev());\n             for dup in pending_dups.iter_mut() {\n+                debug!(\"    ...and at least one overlapping dup={:?}\", dup);\n                 dup.span = dup.span.with_lo(right_cutoff);\n             }\n             self.pending_dups.append(&mut pending_dups);\n@@ -678,8 +689,14 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n     }\n \n     /// Called if `curr.span` equals `prev_original_span` (and potentially equal to all\n-    /// `pending_dups` spans, if any); but keep in mind, `prev.span` may start at a `Span.lo()` that\n-    /// is less than (further left of) `prev_original_span.lo()`.\n+    /// `pending_dups` spans, if any). Keep in mind, `prev.span()` may have been changed.\n+    /// If prev.span() was merged into other spans (with matching BCB, for instance),\n+    /// `prev.span.hi()` will be greater than (further right of) `prev_original_span.hi()`.\n+    /// If prev.span() was split off to the right of a closure, prev.span().lo() will be\n+    /// greater than prev_original_span.lo(). The actual span of `prev_original_span` is\n+    /// not as important as knowing that `prev()` **used to have the same span** as `curr(),\n+    /// which means their sort order is still meaningful for determinating the dominator\n+    /// relationship.\n     ///\n     /// When two `CoverageSpan`s have the same `Span`, dominated spans can be discarded; but if\n     /// neither `CoverageSpan` dominates the other, both (or possibly more than two) are held,"}, {"sha": "a030035f13bae284c41182e4eb305b9e84e8bba3", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.closure_macro.txt", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/0312bf5fb919cb22280367ff445d4a9cbd842539/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure_macro.txt", "raw_url": "https://github.com/rust-lang/rust/raw/0312bf5fb919cb22280367ff445d4a9cbd842539/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure_macro.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure_macro.txt?ref=0312bf5fb919cb22280367ff445d4a9cbd842539", "patch": "@@ -0,0 +1,42 @@\n+    1|       |// compile-flags: --edition=2018\n+    2|       |#![feature(no_coverage)]\n+    3|       |\n+    4|       |macro_rules! bail {\n+    5|       |    ($msg:literal $(,)?) => {\n+    6|       |        if $msg.len() > 0 {\n+    7|       |            println!(\"no msg\");\n+    8|       |        } else {\n+    9|       |            println!($msg);\n+   10|       |        }\n+   11|       |        return Err(String::from($msg));\n+   12|       |    };\n+   13|       |}\n+   14|       |\n+   15|       |macro_rules! on_error {\n+   16|       |    ($value:expr, $error_message:expr) => {\n+   17|      0|        $value.or_else(|e| {\n+   18|      0|            let message = format!($error_message, e);\n+   19|      0|            if message.len() > 0 {\n+   20|      0|                println!(\"{}\", message);\n+   21|      0|                Ok(String::from(\"ok\"))\n+   22|       |            } else {\n+   23|      0|                bail!(\"error\");\n+   24|       |            }\n+   25|      0|        })\n+   26|       |    };\n+   27|       |}\n+   28|       |\n+   29|      1|fn load_configuration_files() -> Result<String, String> {\n+   30|      1|    Ok(String::from(\"config\"))\n+   31|      1|}\n+   32|       |\n+   33|      1|pub fn main() -> Result<(), String> {\n+   34|      1|    println!(\"Starting service\");\n+   35|      1|    let config = on_error!(load_configuration_files(), \"Error loading configs: {}\")?;\n+                                                                                                 ^0\n+   36|       |\n+   37|      1|    let startup_delay_duration = String::from(\"arg\");\n+   38|      1|    let _ = (config, startup_delay_duration);\n+   39|      1|    Ok(())\n+   40|      1|}\n+"}, {"sha": "a954eb3037832ef35b66dd59be8e59561daecf4c", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.closure_macro_async.txt", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/0312bf5fb919cb22280367ff445d4a9cbd842539/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure_macro_async.txt", "raw_url": "https://github.com/rust-lang/rust/raw/0312bf5fb919cb22280367ff445d4a9cbd842539/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure_macro_async.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.closure_macro_async.txt?ref=0312bf5fb919cb22280367ff445d4a9cbd842539", "patch": "@@ -0,0 +1,83 @@\n+    1|       |// compile-flags: --edition=2018\n+    2|       |#![feature(no_coverage)]\n+    3|       |\n+    4|       |macro_rules! bail {\n+    5|       |    ($msg:literal $(,)?) => {\n+    6|       |        if $msg.len() > 0 {\n+    7|       |            println!(\"no msg\");\n+    8|       |        } else {\n+    9|       |            println!($msg);\n+   10|       |        }\n+   11|       |        return Err(String::from($msg));\n+   12|       |    };\n+   13|       |}\n+   14|       |\n+   15|       |macro_rules! on_error {\n+   16|       |    ($value:expr, $error_message:expr) => {\n+   17|      0|        $value.or_else(|e| {\n+   18|      0|            let message = format!($error_message, e);\n+   19|      0|            if message.len() > 0 {\n+   20|      0|                println!(\"{}\", message);\n+   21|      0|                Ok(String::from(\"ok\"))\n+   22|       |            } else {\n+   23|      0|                bail!(\"error\");\n+   24|       |            }\n+   25|      0|        })\n+   26|       |    };\n+   27|       |}\n+   28|       |\n+   29|      1|fn load_configuration_files() -> Result<String, String> {\n+   30|      1|    Ok(String::from(\"config\"))\n+   31|      1|}\n+   32|       |\n+   33|      1|pub async fn test() -> Result<(), String> {\n+   34|      1|    println!(\"Starting service\");\n+   35|      1|    let config = on_error!(load_configuration_files(), \"Error loading configs: {}\")?;\n+                                                                                                 ^0\n+   36|       |\n+   37|      1|    let startup_delay_duration = String::from(\"arg\");\n+   38|      1|    let _ = (config, startup_delay_duration);\n+   39|      1|    Ok(())\n+   40|      1|}\n+   41|       |\n+   42|       |#[no_coverage]\n+   43|       |fn main() {\n+   44|       |    executor::block_on(test());\n+   45|       |}\n+   46|       |\n+   47|       |mod executor {\n+   48|       |    use core::{\n+   49|       |        future::Future,\n+   50|       |        pin::Pin,\n+   51|       |        task::{Context, Poll, RawWaker, RawWakerVTable, Waker},\n+   52|       |    };\n+   53|       |\n+   54|       |    #[no_coverage]\n+   55|       |    pub fn block_on<F: Future>(mut future: F) -> F::Output {\n+   56|       |        let mut future = unsafe { Pin::new_unchecked(&mut future) };\n+   57|       |        use std::hint::unreachable_unchecked;\n+   58|       |        static VTABLE: RawWakerVTable = RawWakerVTable::new(\n+   59|       |\n+   60|       |            #[no_coverage]\n+   61|       |            |_| unsafe { unreachable_unchecked() }, // clone\n+   62|       |\n+   63|       |            #[no_coverage]\n+   64|       |            |_| unsafe { unreachable_unchecked() }, // wake\n+   65|       |\n+   66|       |            #[no_coverage]\n+   67|       |            |_| unsafe { unreachable_unchecked() }, // wake_by_ref\n+   68|       |\n+   69|       |            #[no_coverage]\n+   70|       |            |_| (),\n+   71|       |        );\n+   72|       |        let waker = unsafe { Waker::from_raw(RawWaker::new(core::ptr::null(), &VTABLE)) };\n+   73|       |        let mut context = Context::from_waker(&waker);\n+   74|       |\n+   75|       |        loop {\n+   76|       |            if let Poll::Ready(val) = future.as_mut().poll(&mut context) {\n+   77|       |                break val;\n+   78|       |            }\n+   79|       |        }\n+   80|       |    }\n+   81|       |}\n+"}, {"sha": "de32c88b725dc1d2741a36fcf0ba8c23b484454d", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.issue-83601.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0312bf5fb919cb22280367ff445d4a9cbd842539/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.issue-83601.txt", "raw_url": "https://github.com/rust-lang/rust/raw/0312bf5fb919cb22280367ff445d4a9cbd842539/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.issue-83601.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.issue-83601.txt?ref=0312bf5fb919cb22280367ff445d4a9cbd842539", "patch": "@@ -12,9 +12,9 @@\n     5|       |\n     6|      1|fn main() {\n     7|      1|    let bar = Foo(1);\n-    8|      0|    assert_eq!(bar, Foo(1));\n+    8|      1|    assert_eq!(bar, Foo(1));\n     9|      1|    let baz = Foo(0);\n-   10|      0|    assert_ne!(baz, Foo(1));\n+   10|      1|    assert_ne!(baz, Foo(1));\n    11|      1|    println!(\"{:?}\", Foo(1));\n    12|      1|    println!(\"{:?}\", bar);\n    13|      1|    println!(\"{:?}\", baz);"}, {"sha": "f24f7c69404731214ef8cfad027233d6f6727c01", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.issue-84561.txt", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0312bf5fb919cb22280367ff445d4a9cbd842539/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.issue-84561.txt", "raw_url": "https://github.com/rust-lang/rust/raw/0312bf5fb919cb22280367ff445d4a9cbd842539/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.issue-84561.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.issue-84561.txt?ref=0312bf5fb919cb22280367ff445d4a9cbd842539", "patch": "@@ -2,7 +2,6 @@\n     2|       |\n     3|       |// expect-exit-status-101\n     4|     21|#[derive(PartialEq, Eq)]\n-                                  ^0\n   ------------------\n   | <issue_84561::Foo as core::cmp::PartialEq>::eq:\n   |    4|     21|#[derive(PartialEq, Eq)]"}, {"sha": "018d264234468af4ca4a4415f9baf139b97fe9f0", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.uses_crate.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0312bf5fb919cb22280367ff445d4a9cbd842539/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_crate.txt", "raw_url": "https://github.com/rust-lang/rust/raw/0312bf5fb919cb22280367ff445d4a9cbd842539/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_crate.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.uses_crate.txt?ref=0312bf5fb919cb22280367ff445d4a9cbd842539", "patch": "@@ -36,12 +36,12 @@\n    22|      2|    println!(\"used_only_from_this_lib_crate_generic_function with {:?}\", arg);\n    23|      2|}\n   ------------------\n-  | used_crate::used_only_from_this_lib_crate_generic_function::<&str>:\n+  | used_crate::used_only_from_this_lib_crate_generic_function::<alloc::vec::Vec<i32>>:\n   |   21|      1|pub fn used_only_from_this_lib_crate_generic_function<T: Debug>(arg: T) {\n   |   22|      1|    println!(\"used_only_from_this_lib_crate_generic_function with {:?}\", arg);\n   |   23|      1|}\n   ------------------\n-  | used_crate::used_only_from_this_lib_crate_generic_function::<alloc::vec::Vec<i32>>:\n+  | used_crate::used_only_from_this_lib_crate_generic_function::<&str>:\n   |   21|      1|pub fn used_only_from_this_lib_crate_generic_function<T: Debug>(arg: T) {\n   |   22|      1|    println!(\"used_only_from_this_lib_crate_generic_function with {:?}\", arg);\n   |   23|      1|}"}, {"sha": "10e434007b88487219b3659dff873de59e0c07bc", "filename": "src/test/run-make-fulldeps/coverage/closure_macro.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/0312bf5fb919cb22280367ff445d4a9cbd842539/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fclosure_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0312bf5fb919cb22280367ff445d4a9cbd842539/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fclosure_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fclosure_macro.rs?ref=0312bf5fb919cb22280367ff445d4a9cbd842539", "patch": "@@ -0,0 +1,40 @@\n+// compile-flags: --edition=2018\n+#![feature(no_coverage)]\n+\n+macro_rules! bail {\n+    ($msg:literal $(,)?) => {\n+        if $msg.len() > 0 {\n+            println!(\"no msg\");\n+        } else {\n+            println!($msg);\n+        }\n+        return Err(String::from($msg));\n+    };\n+}\n+\n+macro_rules! on_error {\n+    ($value:expr, $error_message:expr) => {\n+        $value.or_else(|e| {\n+            let message = format!($error_message, e);\n+            if message.len() > 0 {\n+                println!(\"{}\", message);\n+                Ok(String::from(\"ok\"))\n+            } else {\n+                bail!(\"error\");\n+            }\n+        })\n+    };\n+}\n+\n+fn load_configuration_files() -> Result<String, String> {\n+    Ok(String::from(\"config\"))\n+}\n+\n+pub fn main() -> Result<(), String> {\n+    println!(\"Starting service\");\n+    let config = on_error!(load_configuration_files(), \"Error loading configs: {}\")?;\n+\n+    let startup_delay_duration = String::from(\"arg\");\n+    let _ = (config, startup_delay_duration);\n+    Ok(())\n+}"}, {"sha": "bcdfd11f8990da2eaab02e0a592f637640981407", "filename": "src/test/run-make-fulldeps/coverage/closure_macro_async.rs", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/0312bf5fb919cb22280367ff445d4a9cbd842539/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fclosure_macro_async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0312bf5fb919cb22280367ff445d4a9cbd842539/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fclosure_macro_async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fclosure_macro_async.rs?ref=0312bf5fb919cb22280367ff445d4a9cbd842539", "patch": "@@ -0,0 +1,81 @@\n+// compile-flags: --edition=2018\n+#![feature(no_coverage)]\n+\n+macro_rules! bail {\n+    ($msg:literal $(,)?) => {\n+        if $msg.len() > 0 {\n+            println!(\"no msg\");\n+        } else {\n+            println!($msg);\n+        }\n+        return Err(String::from($msg));\n+    };\n+}\n+\n+macro_rules! on_error {\n+    ($value:expr, $error_message:expr) => {\n+        $value.or_else(|e| {\n+            let message = format!($error_message, e);\n+            if message.len() > 0 {\n+                println!(\"{}\", message);\n+                Ok(String::from(\"ok\"))\n+            } else {\n+                bail!(\"error\");\n+            }\n+        })\n+    };\n+}\n+\n+fn load_configuration_files() -> Result<String, String> {\n+    Ok(String::from(\"config\"))\n+}\n+\n+pub async fn test() -> Result<(), String> {\n+    println!(\"Starting service\");\n+    let config = on_error!(load_configuration_files(), \"Error loading configs: {}\")?;\n+\n+    let startup_delay_duration = String::from(\"arg\");\n+    let _ = (config, startup_delay_duration);\n+    Ok(())\n+}\n+\n+#[no_coverage]\n+fn main() {\n+    executor::block_on(test());\n+}\n+\n+mod executor {\n+    use core::{\n+        future::Future,\n+        pin::Pin,\n+        task::{Context, Poll, RawWaker, RawWakerVTable, Waker},\n+    };\n+\n+    #[no_coverage]\n+    pub fn block_on<F: Future>(mut future: F) -> F::Output {\n+        let mut future = unsafe { Pin::new_unchecked(&mut future) };\n+        use std::hint::unreachable_unchecked;\n+        static VTABLE: RawWakerVTable = RawWakerVTable::new(\n+\n+            #[no_coverage]\n+            |_| unsafe { unreachable_unchecked() }, // clone\n+\n+            #[no_coverage]\n+            |_| unsafe { unreachable_unchecked() }, // wake\n+\n+            #[no_coverage]\n+            |_| unsafe { unreachable_unchecked() }, // wake_by_ref\n+\n+            #[no_coverage]\n+            |_| (),\n+        );\n+        let waker = unsafe { Waker::from_raw(RawWaker::new(core::ptr::null(), &VTABLE)) };\n+        let mut context = Context::from_waker(&waker);\n+\n+        loop {\n+            if let Poll::Ready(val) = future.as_mut().poll(&mut context) {\n+                break val;\n+            }\n+        }\n+    }\n+}"}]}