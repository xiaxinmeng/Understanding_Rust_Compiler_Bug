{"sha": "05390b4b38b7ac9d7645afa0be9089a763677393", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1MzkwYjRiMzhiN2FjOWQ3NjQ1YWZhMGJlOTA4OWE3NjM2NzczOTM=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-11T23:01:46Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-07-11T23:02:16Z"}, "message": "rustc: Implement explicit global scope resolution via leading \"::\"; add a test case", "tree": {"sha": "58e1fe9f0d3d372f65d4e110d2e9fbc4b92b256a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58e1fe9f0d3d372f65d4e110d2e9fbc4b92b256a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/05390b4b38b7ac9d7645afa0be9089a763677393", "comment_count": 1, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/05390b4b38b7ac9d7645afa0be9089a763677393", "html_url": "https://github.com/rust-lang/rust/commit/05390b4b38b7ac9d7645afa0be9089a763677393", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/05390b4b38b7ac9d7645afa0be9089a763677393/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99a95b36133e45fc54e26e2ad86e97e2a7d13ff5", "url": "https://api.github.com/repos/rust-lang/rust/commits/99a95b36133e45fc54e26e2ad86e97e2a7d13ff5", "html_url": "https://github.com/rust-lang/rust/commit/99a95b36133e45fc54e26e2ad86e97e2a7d13ff5"}], "stats": {"total": 101, "additions": 70, "deletions": 31}, "files": [{"sha": "ae047b01a77fd063f1e4053cffd19c01a766ff8d", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/05390b4b38b7ac9d7645afa0be9089a763677393/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05390b4b38b7ac9d7645afa0be9089a763677393/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=05390b4b38b7ac9d7645afa0be9089a763677393", "patch": "@@ -228,7 +228,8 @@ fn mk_test_desc_rec(&test_ctxt cx, ast::ident[] path) -> @ast::expr {\n                                            ident = \"name\",\n                                            expr = @name_expr));\n \n-    let ast::path fn_path = nospan(rec(idents = path,\n+    let ast::path fn_path = nospan(rec(global = false,\n+                                       idents = path,\n                                        types = ~[]));\n \n     let ast::expr fn_expr = rec(id = cx.next_node_id(),\n@@ -280,7 +281,8 @@ fn mk_main(&test_ctxt cx) -> @ast::item {\n \n fn mk_test_main_call(&test_ctxt cx) -> @ast::expr {\n \n-    let ast::path test_path = nospan(rec(idents = ~[\"tests\"],\n+    let ast::path test_path = nospan(rec(global = false,\n+                                         idents = ~[\"tests\"],\n                                          types = ~[]));\n \n     let ast::expr_ test_path_expr_ = ast::expr_path(test_path);\n@@ -295,7 +297,8 @@ fn mk_test_main_call(&test_ctxt cx) -> @ast::expr {\n                                        node = test_call_expr_,\n                                        span = rec(lo=0u, hi=0u));\n \n-    let ast::path test_main_path = nospan(rec(idents = ~[\"std\",\n+    let ast::path test_main_path = nospan(rec(global = false,\n+                                              idents = ~[\"std\",\n                                                          \"test\",\n                                                          \"test_main\"],\n                                               types = ~[]));"}, {"sha": "c838c2d3a144bbe77a70f84d262b469d4cbd896b", "filename": "src/comp/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05390b4b38b7ac9d7645afa0be9089a763677393/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05390b4b38b7ac9d7645afa0be9089a763677393/src%2Fcomp%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Ftydecode.rs?ref=05390b4b38b7ac9d7645afa0be9089a763677393", "patch": "@@ -91,7 +91,7 @@ fn parse_path(@pstate st, str_def sd) -> ast::path {\n             case (?c) {\n                 if (c == '(') {\n                     ret respan(rec(lo=0u, hi=0u),\n-                               rec(idents=idents, types=~[]));\n+                               rec(global=false, idents=idents, types=~[]));\n                 }\n                 else {\n                     idents += ~[parse_ident_(st, sd, is_last)];"}, {"sha": "6fb22c34d199022d1392c5699d9a7a2eac4a6ea3", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 27, "deletions": 18, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/05390b4b38b7ac9d7645afa0be9089a763677393/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05390b4b38b7ac9d7645afa0be9089a763677393/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=05390b4b38b7ac9d7645afa0be9089a763677393", "patch": "@@ -44,7 +44,7 @@ export def_map;\n // (FIXME See https://github.com/graydon/rust/issues/358 for the reason this\n //  isn't a const.)\n tag scope {\n-    scope_crate(@ast::crate);\n+    scope_crate;\n     scope_item(@ast::item);\n     scope_fn(ast::fn_decl, ast::ty_param[]);\n     scope_native_item(@ast::native_item);\n@@ -154,7 +154,7 @@ fn map_crate(&@env e, &@ast::crate c) {\n         @rec(visit_view_item=bind index_vi(e, _, _, _),\n              visit_item=bind index_i(e, _, _, _)\n              with *visit::default_visitor[scopes]());\n-    visit::visit_crate(*c, cons(scope_crate(c), @nil),\n+    visit::visit_crate(*c, cons(scope_crate, @nil),\n                        visit::mk_vt(v_map_mod));\n     // Register the top-level mod \n \n@@ -199,7 +199,7 @@ fn map_crate(&@env e, &@ast::crate c) {\n         @rec(visit_view_item=bind link_glob(e, _, _, _),\n              visit_item=visit_item_with_scope\n              with *visit::default_visitor[scopes]());\n-    visit::visit_crate(*c, cons(scope_crate(c), @nil),\n+    visit::visit_crate(*c, cons(scope_crate, @nil),\n                        visit::mk_vt(v_link_glob));\n     fn link_glob(@env e, &@ast::view_item vi, &scopes sc, &vt[scopes] v) {\n         fn find_mod(@env e, scopes sc) -> @indexed_mod {\n@@ -253,16 +253,16 @@ fn resolve_names(&@env e, &@ast::crate c) {\n              visit_constr=bind walk_constr(e, _, _, _),\n              visit_fn=bind visit_fn_with_scope(e, _, _, _, _, _, _, _)\n              with *visit::default_visitor());\n-    visit::visit_crate(*c, cons(scope_crate(c), @nil), visit::mk_vt(v));\n+    visit::visit_crate(*c, cons(scope_crate, @nil), visit::mk_vt(v));\n     e.sess.abort_if_errors();\n \n     fn walk_expr(@env e, &@ast::expr exp, &scopes sc, &vt[scopes] v) {\n         visit_expr_with_scope(exp, sc, v);\n         alt (exp.node) {\n             case (ast::expr_path(?p)) {\n                 maybe_insert(e, exp.id,\n-                             lookup_path_strict(*e, sc, exp.span,\n-                                                p.node.idents, ns_value));\n+                             lookup_path_strict(*e, sc, exp.span, p.node,\n+                                                ns_value));\n             }\n             case (_) { }\n         }\n@@ -272,16 +272,16 @@ fn resolve_names(&@env e, &@ast::crate c) {\n         alt (t.node) {\n             case (ast::ty_path(?p, ?id)) {\n                 maybe_insert(e, id,\n-                             lookup_path_strict(*e, sc, t.span,\n-                                                p.node.idents, ns_type));\n+                             lookup_path_strict(*e, sc, t.span, p.node,\n+                                                ns_type));\n             }\n             case (_) { }\n         }\n     }\n     fn walk_constr(@env e, &@ast::constr c, &scopes sc, &vt[scopes] v) {\n         maybe_insert(e, c.node.id,\n-                     lookup_path_strict(*e, sc, c.span,\n-                                        c.node.path.node.idents, ns_value));\n+                     lookup_path_strict(*e, sc, c.span, c.node.path.node,\n+                                        ns_value));\n     }\n     fn walk_arm(@env e, &ast::arm a, &scopes sc, &vt[scopes] v) {\n         for (@ast::pat p in a.pats) { walk_pat(*e, sc, p); }\n@@ -291,8 +291,7 @@ fn resolve_names(&@env e, &@ast::crate c) {\n         alt (pat.node) {\n             case (ast::pat_tag(?p, ?children)) {\n                 auto fnd =\n-                    lookup_path_strict(e, sc, p.span, p.node.idents,\n-                                       ns_value);\n+                    lookup_path_strict(e, sc, p.span, p.node, ns_value);\n                 if (option::is_some(fnd)) {\n                     alt (option::get(fnd)) {\n                         case (ast::def_variant(?did, ?vid)) {\n@@ -396,7 +395,7 @@ fn follow_import(&env e, &scopes sc, &ident[] path, &span sp)\n fn resolve_constr(@env e, node_id id, &@ast::constr c, &scopes sc,\n                   &vt[scopes] v) {\n     auto new_def =\n-        lookup_path_strict(*e, sc, c.span, c.node.path.node.idents, ns_value);\n+        lookup_path_strict(*e, sc, c.span, c.node.path.node, ns_value);\n     if (option::is_some(new_def)) {\n         alt (option::get(new_def)) {\n             case (ast::def_fn(?pred_id, ast::pure_fn)) {\n@@ -543,16 +542,26 @@ fn mk_unresolved_msg(&ident id, &str kind) -> str {\n }\n \n // Lookup helpers\n-fn lookup_path_strict(&env e, &scopes sc, &span sp, &ident[] idents,\n+fn lookup_path_strict(&env e, &scopes sc, &span sp, &ast::path_ pth,\n                       namespace ns) -> option::t[def] {\n-    auto n_idents = ivec::len(idents);\n+    auto n_idents = ivec::len(pth.idents);\n     auto headns = if (n_idents == 1u) { ns } else { ns_module };\n-    auto dcur = lookup_in_scope_strict(e, sc, sp, idents.(0), headns);\n+\n+    auto first_scope;\n+    if (pth.global) {\n+        first_scope = list::cons(scope_crate, @list::nil);\n+    } else {\n+        first_scope = sc;\n+    }\n+\n+    auto dcur = lookup_in_scope_strict(e, first_scope, sp, pth.idents.(0),\n+                                       headns);\n+\n     auto i = 1u;\n     while (i < n_idents && option::is_some(dcur)) {\n         auto curns = if (n_idents == i + 1u) { ns } else { ns_module };\n         dcur = lookup_in_mod_strict(e, option::get(dcur),\n-                                    sp, idents.(i), curns, outside);\n+                                    sp, pth.idents.(i), curns, outside);\n         i += 1u;\n     }\n     ret dcur;\n@@ -592,7 +601,7 @@ fn lookup_in_scope(&env e, scopes sc, &span sp, &ident name, namespace ns) ->\n     fn in_scope(&env e, &span sp, &ident name, &scope s, namespace ns) ->\n        option::t[def] {\n         alt (s) {\n-            case (scope_crate(?c)) {\n+            case (scope_crate) {\n                 ret lookup_in_local_mod(e, -1, sp, name, ns, inside);\n             }\n             case (scope_item(?it)) {"}, {"sha": "b0efc763537a171e7d4bdb035be24ca444675bc8", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05390b4b38b7ac9d7645afa0be9089a763677393/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05390b4b38b7ac9d7645afa0be9089a763677393/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=05390b4b38b7ac9d7645afa0be9089a763677393", "patch": "@@ -16,7 +16,7 @@ type fn_ident = option::t[ident];\n // FIXME: with typestate constraint, could say\n // idents and types are the same length, and are\n // non-empty\n-type path_ = rec(ident[] idents, (@ty)[] types);\n+type path_ = rec(bool global, ident[] idents, (@ty)[] types);\n \n type path = spanned[path_];\n "}, {"sha": "4aae16f01cee2768fa996389ac11cb6e0b9ba180", "filename": "src/comp/syntax/ext/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/05390b4b38b7ac9d7645afa0be9089a763677393/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05390b4b38b7ac9d7645afa0be9089a763677393/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fext%2Ffmt.rs?ref=05390b4b38b7ac9d7645afa0be9089a763677393", "patch": "@@ -63,7 +63,7 @@ fn pieces_to_expr(&ext_ctxt cx, span sp, vec[piece] pieces,\n     }\n     fn make_path_expr(&ext_ctxt cx, span sp, &ast::ident[] idents)\n        -> @ast::expr {\n-        auto path = rec(idents=idents, types=~[]);\n+        auto path = rec(global=false, idents=idents, types=~[]);\n         auto sp_path = rec(node=path, span=sp);\n         auto pathexpr = ast::expr_path(sp_path);\n         ret @rec(id=cx.next_id(), node=pathexpr, span=sp);"}, {"sha": "e0774b68e301053e51e81d44ff4f1b207eb0cd21", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/05390b4b38b7ac9d7645afa0be9089a763677393/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05390b4b38b7ac9d7645afa0be9089a763677393/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=05390b4b38b7ac9d7645afa0be9089a763677393", "patch": "@@ -499,7 +499,8 @@ fn noop_fold_ident(&ident i, ast_fold fld) -> ident {\n }\n \n fn noop_fold_path(&path_ p, ast_fold fld) -> path_ {\n-    ret rec(idents=ivec::map(fld.fold_ident, p.idents),\n+    ret rec(global=p.global,\n+            idents=ivec::map(fld.fold_ident, p.idents),\n             types=ivec::map(fld.fold_ty, p.types));\n }\n "}, {"sha": "6fd0df76a0e91ff70fe55a630e4224b186e89d0a", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/05390b4b38b7ac9d7645afa0be9089a763677393/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05390b4b38b7ac9d7645afa0be9089a763677393/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=05390b4b38b7ac9d7645afa0be9089a763677393", "patch": "@@ -421,7 +421,8 @@ fn parse_ty_postfix(@ast::ty orig_t, &parser p) -> @ast::ty {\n                     auto hi = p.get_hi_pos();\n                     ret @spanned(lo, hi,\n                                  ast::ty_path(spanned(lo, hi,\n-                                              rec(idents=pth.node.idents,\n+                                              rec(global=pth.node.global,\n+                                                  idents=pth.node.idents,\n                                                   types=seq_ivec)),\n                                               ann));\n                 }\n@@ -556,7 +557,7 @@ fn parse_ty(&parser p) -> @ast::ty {\n         auto typ = parse_ty(p);\n         t = typ.node;\n         hi = typ.span.hi;\n-    } else if (is_ident(p.peek())) {\n+    } else if (p.peek() == token::MOD_SEP || is_ident(p.peek())) {\n         auto path = parse_path(p);\n         t = ast::ty_path(path, p.get_id());\n         hi = path.span.hi;\n@@ -673,6 +674,14 @@ fn is_ident(token::token t) -> bool {\n fn parse_path(&parser p) -> ast::path {\n     auto lo = p.get_lo_pos();\n     auto hi = lo;\n+\n+    auto global;\n+    if (p.peek() == token::MOD_SEP) {\n+        global = true; p.bump();\n+    } else {\n+        global = false;\n+    }\n+\n     let ast::ident[] ids = ~[];\n     while (true) {\n         alt (p.peek()) {\n@@ -686,7 +695,7 @@ fn parse_path(&parser p) -> ast::path {\n         }\n     }\n     hi = p.get_hi_pos();\n-    ret spanned(lo, hi, rec(idents=ids, types=~[]));\n+    ret spanned(lo, hi, rec(global=global, idents=ids, types=~[]));\n }\n \n fn parse_path_and_ty_param_substs(&parser p) -> ast::path {\n@@ -701,7 +710,9 @@ fn parse_path_and_ty_param_substs(&parser p) -> ast::path {\n         for (@ast::ty typ in seq.node) { seq_ivec += ~[typ]; }\n \n         auto hi = p.get_hi_pos();\n-        path = spanned(lo, hi, rec(idents=path.node.idents, types=seq_ivec));\n+        path = spanned(lo, hi, rec(global=path.node.global,\n+                                   idents=path.node.idents,\n+                                   types=seq_ivec));\n     }\n     ret path;\n }\n@@ -975,8 +986,9 @@ fn parse_bottom_expr(&parser p) -> @ast::expr {\n                            parse_expr, p);\n         hi = es.span.hi;\n         ex = ast::expr_call(f, es.node);\n-    } else if (is_ident(p.peek()) && !is_word(p, \"true\") &&\n-               !is_word(p, \"false\")) {\n+    } else if (p.peek() == token::MOD_SEP ||\n+               (is_ident(p.peek()) && !is_word(p, \"true\") &&\n+                !is_word(p, \"false\"))) {\n         check_bad_word(p);\n         auto pth = parse_path_and_ty_param_substs(p);\n         hi = pth.span.hi;"}, {"sha": "a3e3eb1a2bdcd506c2e6abdc434b8cd5310379b0", "filename": "src/test/run-pass/global-scope.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/05390b4b38b7ac9d7645afa0be9089a763677393/src%2Ftest%2Frun-pass%2Fglobal-scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/05390b4b38b7ac9d7645afa0be9089a763677393/src%2Ftest%2Frun-pass%2Fglobal-scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fglobal-scope.rs?ref=05390b4b38b7ac9d7645afa0be9089a763677393", "patch": "@@ -0,0 +1,14 @@\n+// xfail-stage0\n+\n+fn f() -> int { ret 1; }\n+\n+mod foo {\n+    fn f() -> int { ret 2; }\n+    fn g() {\n+        assert (f() == 2);\n+        assert (::f() == 1);\n+    }\n+}\n+\n+fn main() { ret foo::g(); }\n+"}]}