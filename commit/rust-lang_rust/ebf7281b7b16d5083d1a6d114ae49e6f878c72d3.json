{"sha": "ebf7281b7b16d5083d1a6d114ae49e6f878c72d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViZjcyODFiN2IxNmQ1MDgzZDFhNmQxMTRhZTQ5ZTZmODc4YzcyZDM=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-07T08:36:16Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-07T08:36:16Z"}, "message": "syntax: rewrite deriving(Ord) to not require Eq.\n\nlt and gt are implement directly in terms of the corresponding\nmethod on their elements, and le and ge are the negations of these.", "tree": {"sha": "4bd65c4ccd54870eebf175a70c2e2afa654932c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bd65c4ccd54870eebf175a70c2e2afa654932c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebf7281b7b16d5083d1a6d114ae49e6f878c72d3", "comment_count": 4, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebf7281b7b16d5083d1a6d114ae49e6f878c72d3", "html_url": "https://github.com/rust-lang/rust/commit/ebf7281b7b16d5083d1a6d114ae49e6f878c72d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebf7281b7b16d5083d1a6d114ae49e6f878c72d3/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d5beda6772230d8ec0e5e4b9e561100acf81a6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d5beda6772230d8ec0e5e4b9e561100acf81a6f", "html_url": "https://github.com/rust-lang/rust/commit/6d5beda6772230d8ec0e5e4b9e561100acf81a6f"}], "stats": {"total": 116, "additions": 59, "deletions": 57}, "files": [{"sha": "759576814d5aa8328bf72207ac908ad2c41b774a", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 59, "deletions": 57, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/ebf7281b7b16d5083d1a6d114ae49e6f878c72d3/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebf7281b7b16d5083d1a6d114ae49e6f878c72d3/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=ebf7281b7b16d5083d1a6d114ae49e6f878c72d3", "patch": "@@ -10,6 +10,7 @@\n \n use core::prelude::*;\n \n+use ast;\n use ast::{meta_item, item, expr};\n use codemap::span;\n use ext::base::ExtCtxt;\n@@ -21,104 +22,105 @@ pub fn expand_deriving_ord(cx: @ExtCtxt,\n                            mitem: @meta_item,\n                            in_items: ~[@item]) -> ~[@item] {\n     macro_rules! md (\n-        ($name:expr, $less:expr, $equal:expr) => {\n+        ($name:expr, $func:expr, $op:expr) => {\n             MethodDef {\n                 name: $name,\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n                 args: ~[borrowed_self()],\n                 ret_ty: Literal(Path::new(~[\"bool\"])),\n                 const_nonmatching: false,\n-                combine_substructure: |cx, span, substr|\n-                    cs_ord($less, $equal, cx, span, substr)\n+                combine_substructure: |cx, span, substr| $func($op, cx, span, substr)\n             }\n         }\n     );\n \n-\n-\n     let trait_def = TraitDef {\n         path: Path::new(~[\"std\", \"cmp\", \"Ord\"]),\n-        // XXX: Ord doesn't imply Eq yet\n-        additional_bounds: ~[Literal(Path::new(~[\"std\", \"cmp\", \"Eq\"]))],\n+        additional_bounds: ~[],\n         generics: LifetimeBounds::empty(),\n         methods: ~[\n-            md!(\"lt\", true,  false),\n-            md!(\"le\", true,  true),\n-            md!(\"gt\", false, false),\n-            md!(\"ge\", false, true)\n+            md!(\"lt\", cs_strict, true),\n+            md!(\"le\", cs_nonstrict, true), // inverse operation\n+            md!(\"gt\", cs_strict, false),\n+            md!(\"ge\", cs_nonstrict, false)\n         ]\n     };\n     trait_def.expand(cx, span, mitem, in_items)\n }\n \n-/// `less`: is this `lt` or `le`? `equal`: is this `le` or `ge`?\n-fn cs_ord(less: bool, equal: bool,\n-          cx: @ExtCtxt, span: span,\n-          substr: &Substructure) -> @expr {\n-    let binop = if less {\n-        cx.ident_of(\"lt\")\n-    } else {\n-        cx.ident_of(\"gt\")\n-    };\n-    let base = cx.expr_bool(span, equal);\n-\n+/// Strict inequality.\n+fn cs_strict(less: bool, cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n+    let op = if less {ast::lt} else {ast::gt};\n     cs_fold(\n         false, // need foldr,\n         |cx, span, subexpr, self_f, other_fs| {\n             /*\n-\n-            build up a series of nested ifs from the inside out to get\n-            lexical ordering (hence foldr), i.e.\n+            build up a series of chain ||'s and &&'s from the inside\n+            out (hence foldr) to get lexical ordering, i.e. for op ==\n+            `ast::lt`\n \n             ```\n-            if self.f1 `binop` other.f1 {\n-                true\n-            } else if self.f1 == other.f1 {\n-                if self.f2 `binop` other.f2 {\n-                    true\n-                } else if self.f2 == other.f2 {\n-                    `equal`\n-                } else {\n-                    false\n-                }\n-            } else {\n-                false\n-            }\n+            self.f1 < other.f1 || (!(other.f1 < self.f1) &&\n+                (self.f2 < other.f2 || (!(other.f2 < self.f2) &&\n+                    (false)\n+                ))\n+            )\n             ```\n \n-            The inner \"`equal`\" case is only reached if the two\n-            items have all fields equal.\n+            The optimiser should remove the redundancy. We explicitly\n+            get use the binops to avoid auto-deref derefencing too many\n+            layers of pointers, if the type includes pointers.\n             */\n-            if other_fs.len() != 1 {\n-                cx.span_bug(span, \"Not exactly 2 arguments in `deriving(Ord)`\");\n-            }\n+            let other_f = match other_fs {\n+                [o_f] => o_f,\n+                _ => cx.span_bug(span, \"Not exactly 2 arguments in `deriving(Ord)`\")\n+            };\n+\n+            let cmp = cx.expr_binary(span, op,\n+                                     cx.expr_deref(span, self_f),\n+                                     cx.expr_deref(span, other_f));\n \n-            let cmp = cx.expr_method_call(span,\n-                                          self_f, cx.ident_of(\"eq\"), other_fs.to_owned());\n-            let elseif = cx.expr_if(span, cmp,\n-                                    subexpr, Some(cx.expr_bool(span, false)));\n+            let not_cmp = cx.expr_binary(span, op,\n+                                         cx.expr_deref(span, other_f),\n+                                         cx.expr_deref(span, self_f));\n+            let not_cmp = cx.expr_unary(span, ast::not, not_cmp);\n \n-            let cmp = cx.expr_method_call(span,\n-                                          self_f, binop, other_fs.to_owned());\n-            cx.expr_if(span, cmp,\n-                        cx.expr_bool(span, true), Some(elseif))\n+            let and = cx.expr_binary(span, ast::and,\n+                                     not_cmp, subexpr);\n+            cx.expr_binary(span, ast::or, cmp, and)\n         },\n-        base,\n+        cx.expr_bool(span, false),\n         |cx, span, args, _| {\n             // nonmatching enums, order by the order the variants are\n             // written\n             match args {\n                 [(self_var, _, _),\n                  (other_var, _, _)] =>\n                     cx.expr_bool(span,\n-                                   if less {\n-                                       self_var < other_var\n-                                   } else {\n-                                       self_var > other_var\n-                                   }),\n+                                 if less {\n+                                     self_var < other_var\n+                                 } else {\n+                                     self_var > other_var\n+                                 }),\n                 _ => cx.span_bug(span, \"Not exactly 2 arguments in `deriving(Ord)`\")\n             }\n         },\n         cx, span, substr)\n }\n+\n+fn cs_nonstrict(less: bool, cx: @ExtCtxt, span: span, substr: &Substructure) -> @expr {\n+    // Example: ge becomes !(*self < *other), le becomes !(*self > *other)\n+\n+    let inverse_op = if less {ast::gt} else {ast::lt};\n+    match substr.self_args {\n+        [self_, other] => {\n+            let inverse_cmp = cx.expr_binary(span, inverse_op,\n+                                             cx.expr_deref(span, self_),\n+                                             cx.expr_deref(span, other));\n+\n+            cx.expr_unary(span, ast::not, inverse_cmp)\n+        }\n+        _ => cx.span_bug(span, \"Not exactly 2 arguments in `deriving(Ord)`\")\n+    }\n+}"}]}