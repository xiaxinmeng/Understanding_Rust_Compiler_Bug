{"sha": "e0bcf771d6e670988a3d4fdc785ecd5857916f10", "node_id": "C_kwDOAAsO6NoAKGUwYmNmNzcxZDZlNjcwOTg4YTNkNGZkYzc4NWVjZDU4NTc5MTZmMTA", "commit": {"author": {"name": "\u0410\u0440\u0442\u0451\u043c \u041f\u0430\u0432\u043b\u043e\u0432 [Artyom Pavlov]", "email": "newpavlov@gmail.com", "date": "2022-01-26T15:14:25Z"}, "committer": {"name": "\u0410\u0440\u0442\u0451\u043c \u041f\u0430\u0432\u043b\u043e\u0432 [Artyom Pavlov]", "email": "newpavlov@gmail.com", "date": "2022-01-26T15:14:25Z"}, "message": "Improve Duration::try_from_secs_f32/64 accuracy by directly processing exponent and mantissa", "tree": {"sha": "4b0d52ab19d5df71fd5b69f13784fee0aea40c04", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b0d52ab19d5df71fd5b69f13784fee0aea40c04"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0bcf771d6e670988a3d4fdc785ecd5857916f10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0bcf771d6e670988a3d4fdc785ecd5857916f10", "html_url": "https://github.com/rust-lang/rust/commit/e0bcf771d6e670988a3d4fdc785ecd5857916f10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0bcf771d6e670988a3d4fdc785ecd5857916f10/comments", "author": {"login": "newpavlov", "id": 329626, "node_id": "MDQ6VXNlcjMyOTYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/329626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/newpavlov", "html_url": "https://github.com/newpavlov", "followers_url": "https://api.github.com/users/newpavlov/followers", "following_url": "https://api.github.com/users/newpavlov/following{/other_user}", "gists_url": "https://api.github.com/users/newpavlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/newpavlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/newpavlov/subscriptions", "organizations_url": "https://api.github.com/users/newpavlov/orgs", "repos_url": "https://api.github.com/users/newpavlov/repos", "events_url": "https://api.github.com/users/newpavlov/events{/privacy}", "received_events_url": "https://api.github.com/users/newpavlov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "newpavlov", "id": 329626, "node_id": "MDQ6VXNlcjMyOTYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/329626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/newpavlov", "html_url": "https://github.com/newpavlov", "followers_url": "https://api.github.com/users/newpavlov/followers", "following_url": "https://api.github.com/users/newpavlov/following{/other_user}", "gists_url": "https://api.github.com/users/newpavlov/gists{/gist_id}", "starred_url": "https://api.github.com/users/newpavlov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/newpavlov/subscriptions", "organizations_url": "https://api.github.com/users/newpavlov/orgs", "repos_url": "https://api.github.com/users/newpavlov/repos", "events_url": "https://api.github.com/users/newpavlov/events{/privacy}", "received_events_url": "https://api.github.com/users/newpavlov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "788b1fe5b79a8b74215022f9df49b0eae68a50b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/788b1fe5b79a8b74215022f9df49b0eae68a50b9", "html_url": "https://github.com/rust-lang/rust/commit/788b1fe5b79a8b74215022f9df49b0eae68a50b9"}], "stats": {"total": 305, "additions": 202, "deletions": 103}, "files": [{"sha": "243c044b5d9d0a55ee918885637f9177d49226e7", "filename": "library/core/src/time.rs", "status": "modified", "additions": 200, "deletions": 101, "changes": 301, "blob_url": "https://github.com/rust-lang/rust/blob/e0bcf771d6e670988a3d4fdc785ecd5857916f10/library%2Fcore%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0bcf771d6e670988a3d4fdc785ecd5857916f10/library%2Fcore%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftime.rs?ref=e0bcf771d6e670988a3d4fdc785ecd5857916f10", "patch": "@@ -711,14 +711,28 @@ impl Duration {\n     /// as `f64`.\n     ///\n     /// # Panics\n-    /// This constructor will panic if `secs` is not finite, negative or overflows `Duration`.\n+    /// This constructor will panic if `secs` is negative, overflows `Duration` or not finite.\n     ///\n     /// # Examples\n     /// ```\n     /// use std::time::Duration;\n     ///\n-    /// let dur = Duration::from_secs_f64(2.7);\n-    /// assert_eq!(dur, Duration::new(2, 700_000_000));\n+    /// let res = Duration::from_secs_f64(0.0);\n+    /// assert_eq!(res, Duration::new(0, 0));\n+    /// let res = Duration::from_secs_f64(1e-20);\n+    /// assert_eq!(res, Duration::new(0, 0));\n+    /// let res = Duration::from_secs_f64(4.2e-7);\n+    /// assert_eq!(res, Duration::new(0, 420));\n+    /// let res = Duration::from_secs_f64(2.7);\n+    /// assert_eq!(res, Duration::new(2, 700_000_000));\n+    /// let res = Duration::from_secs_f64(3e10);\n+    /// assert_eq!(res, Duration::new(30_000_000_000, 0));\n+    /// // subnormal float\n+    /// let res = Duration::from_secs_f64(f64::from_bits(1));\n+    /// assert_eq!(res, Duration::new(0, 0));\n+    /// // conversion uses truncation, not rounding\n+    /// let res = Duration::from_secs_f64(0.999e-9);\n+    /// assert_eq!(res, Duration::new(0, 0));\n     /// ```\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[must_use]\n@@ -731,55 +745,32 @@ impl Duration {\n         }\n     }\n \n-    /// The checked version of [`from_secs_f64`].\n-    ///\n-    /// [`from_secs_f64`]: Duration::from_secs_f64\n-    ///\n-    /// This constructor will return an `Err` if `secs` is not finite, negative or overflows `Duration`.\n-    ///\n-    /// # Examples\n-    /// ```\n-    /// #![feature(duration_checked_float)]\n-    /// use std::time::Duration;\n-    ///\n-    /// let dur = Duration::try_from_secs_f64(2.7);\n-    /// assert_eq!(dur, Ok(Duration::new(2, 700_000_000)));\n-    ///\n-    /// let negative = Duration::try_from_secs_f64(-5.0);\n-    /// assert!(negative.is_err());\n-    /// ```\n-    #[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\n-    #[inline]\n-    pub const fn try_from_secs_f64(secs: f64) -> Result<Duration, FromSecsError> {\n-        const MAX_NANOS_F64: f64 = ((u64::MAX as u128 + 1) * (NANOS_PER_SEC as u128)) as f64;\n-        let nanos = secs * (NANOS_PER_SEC as f64);\n-        if !nanos.is_finite() {\n-            Err(FromSecsError { kind: FromSecsErrorKind::NonFinite })\n-        } else if nanos >= MAX_NANOS_F64 {\n-            Err(FromSecsError { kind: FromSecsErrorKind::Overflow })\n-        } else if nanos < 0.0 {\n-            Err(FromSecsError { kind: FromSecsErrorKind::Negative })\n-        } else {\n-            let nanos = nanos as u128;\n-            Ok(Duration {\n-                secs: (nanos / (NANOS_PER_SEC as u128)) as u64,\n-                nanos: (nanos % (NANOS_PER_SEC as u128)) as u32,\n-            })\n-        }\n-    }\n-\n     /// Creates a new `Duration` from the specified number of seconds represented\n     /// as `f32`.\n     ///\n     /// # Panics\n-    /// This constructor will panic if `secs` is not finite, negative or overflows `Duration`.\n+    /// This constructor will panic if `secs` is negative, overflows `Duration` or not finite.\n     ///\n     /// # Examples\n     /// ```\n     /// use std::time::Duration;\n     ///\n-    /// let dur = Duration::from_secs_f32(2.7);\n-    /// assert_eq!(dur, Duration::new(2, 700_000_000));\n+    /// let res = Duration::from_secs_f32(0.0);\n+    /// assert_eq!(res, Duration::new(0, 0));\n+    /// let res = Duration::from_secs_f32(1e-20);\n+    /// assert_eq!(res, Duration::new(0, 0));\n+    /// let res = Duration::from_secs_f32(4.2e-7);\n+    /// assert_eq!(res, Duration::new(0, 419));\n+    /// let res = Duration::from_secs_f32(2.7);\n+    /// assert_eq!(res, Duration::new(2, 700_000_047));\n+    /// let res = Duration::from_secs_f32(3e10);\n+    /// assert_eq!(res, Duration::new(30_000_001_024, 0));\n+    /// // subnormal float\n+    /// let res = Duration::from_secs_f32(f32::from_bits(1));\n+    /// assert_eq!(res, Duration::new(0, 0));\n+    /// // conversion uses truncation, not rounding\n+    /// let res = Duration::from_secs_f32(0.999e-9);\n+    /// assert_eq!(res, Duration::new(0, 0));\n     /// ```\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[must_use]\n@@ -792,47 +783,10 @@ impl Duration {\n         }\n     }\n \n-    /// The checked version of [`from_secs_f32`].\n-    ///\n-    /// [`from_secs_f32`]: Duration::from_secs_f32\n-    ///\n-    /// This constructor will return an `Err` if `secs` is not finite, negative or overflows `Duration`.\n-    ///\n-    /// # Examples\n-    /// ```\n-    /// #![feature(duration_checked_float)]\n-    /// use std::time::Duration;\n-    ///\n-    /// let dur = Duration::try_from_secs_f32(2.7);\n-    /// assert_eq!(dur, Ok(Duration::new(2, 700_000_000)));\n-    ///\n-    /// let negative = Duration::try_from_secs_f32(-5.0);\n-    /// assert!(negative.is_err());\n-    /// ```\n-    #[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\n-    #[inline]\n-    pub const fn try_from_secs_f32(secs: f32) -> Result<Duration, FromSecsError> {\n-        const MAX_NANOS_F32: f32 = ((u64::MAX as u128 + 1) * (NANOS_PER_SEC as u128)) as f32;\n-        let nanos = secs * (NANOS_PER_SEC as f32);\n-        if !nanos.is_finite() {\n-            Err(FromSecsError { kind: FromSecsErrorKind::NonFinite })\n-        } else if nanos >= MAX_NANOS_F32 {\n-            Err(FromSecsError { kind: FromSecsErrorKind::Overflow })\n-        } else if nanos < 0.0 {\n-            Err(FromSecsError { kind: FromSecsErrorKind::Negative })\n-        } else {\n-            let nanos = nanos as u128;\n-            Ok(Duration {\n-                secs: (nanos / (NANOS_PER_SEC as u128)) as u64,\n-                nanos: (nanos % (NANOS_PER_SEC as u128)) as u32,\n-            })\n-        }\n-    }\n-\n     /// Multiplies `Duration` by `f64`.\n     ///\n     /// # Panics\n-    /// This method will panic if result is not finite, negative or overflows `Duration`.\n+    /// This method will panic if result is negative, overflows `Duration` or not finite.\n     ///\n     /// # Examples\n     /// ```\n@@ -854,17 +808,15 @@ impl Duration {\n     /// Multiplies `Duration` by `f32`.\n     ///\n     /// # Panics\n-    /// This method will panic if result is not finite, negative or overflows `Duration`.\n+    /// This method will panic if result is negative, overflows `Duration` or not finite.\n     ///\n     /// # Examples\n     /// ```\n     /// use std::time::Duration;\n     ///\n     /// let dur = Duration::new(2, 700_000_000);\n-    /// // note that due to rounding errors result is slightly different\n-    /// // from 8.478 and 847800.0\n     /// assert_eq!(dur.mul_f32(3.14), Duration::new(8, 478_000_640));\n-    /// assert_eq!(dur.mul_f32(3.14e5), Duration::new(847799, 969_120_256));\n+    /// assert_eq!(dur.mul_f32(3.14e5), Duration::new(847800, 0));\n     /// ```\n     #[stable(feature = \"duration_float\", since = \"1.38.0\")]\n     #[must_use = \"this returns the result of the operation, \\\n@@ -878,7 +830,7 @@ impl Duration {\n     /// Divide `Duration` by `f64`.\n     ///\n     /// # Panics\n-    /// This method will panic if result is not finite, negative or overflows `Duration`.\n+    /// This method will panic if result is negative, overflows `Duration` or not finite.\n     ///\n     /// # Examples\n     /// ```\n@@ -901,7 +853,7 @@ impl Duration {\n     /// Divide `Duration` by `f32`.\n     ///\n     /// # Panics\n-    /// This method will panic if result is not finite, negative or overflows `Duration`.\n+    /// This method will panic if result is negative, overflows `Duration` or not finite.\n     ///\n     /// # Examples\n     /// ```\n@@ -910,7 +862,7 @@ impl Duration {\n     /// let dur = Duration::new(2, 700_000_000);\n     /// // note that due to rounding errors result is slightly\n     /// // different from 0.859_872_611\n-    /// assert_eq!(dur.div_f32(3.14), Duration::new(0, 859_872_576));\n+    /// assert_eq!(dur.div_f32(3.14), Duration::new(0, 859_872_579));\n     /// // note that truncation is used, not rounding\n     /// assert_eq!(dur.div_f32(3.14e5), Duration::new(0, 8_598));\n     /// ```\n@@ -1267,33 +1219,180 @@ impl fmt::Debug for Duration {\n /// ```\n #[derive(Debug, Clone, PartialEq, Eq)]\n #[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\n-pub struct FromSecsError {\n-    kind: FromSecsErrorKind,\n+pub struct FromFloatSecsError {\n+    kind: FromFloatSecsErrorKind,\n }\n \n-impl FromSecsError {\n+impl FromFloatSecsError {\n     const fn description(&self) -> &'static str {\n         match self.kind {\n-            FromSecsErrorKind::NonFinite => \"non-finite value when converting float to duration\",\n-            FromSecsErrorKind::Overflow => \"overflow when converting float to duration\",\n-            FromSecsErrorKind::Negative => \"negative value when converting float to duration\",\n+            FromFloatSecsErrorKind::Negative => {\n+                \"can not convert float seconds to Duration: value is negative\"\n+            }\n+            FromFloatSecsErrorKind::OverflowOrNan => {\n+                \"can not convert float seconds to Duration: value is either too big or NaN\"\n+            }\n         }\n     }\n }\n \n #[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\n-impl fmt::Display for FromSecsError {\n+impl fmt::Display for FromFloatSecsError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(self.description(), f)\n+        self.description().fmt(f)\n     }\n }\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n-enum FromSecsErrorKind {\n-    // Value is not a finite value (either + or - infinity or NaN).\n-    NonFinite,\n-    // Value is too large to store in a `Duration`.\n-    Overflow,\n+enum FromFloatSecsErrorKind {\n     // Value is negative.\n     Negative,\n+    // Value is either too big to be represented as `Duration` or `NaN`.\n+    OverflowOrNan,\n+}\n+\n+macro_rules! try_from_secs {\n+    (\n+        secs = $secs: expr,\n+        mantissa_bits = $mant_bits: literal,\n+        exponent_bits = $exp_bits: literal,\n+        offset = $offset: literal,\n+        bits_ty = $bits_ty:ty,\n+        double_ty = $double_ty:ty,\n+    ) => {{\n+        const MIN_EXP: i16 = 1 - (1i16 << $exp_bits) / 2;\n+        const MANT_MASK: $bits_ty = (1 << $mant_bits) - 1;\n+        const EXP_MASK: $bits_ty = (1 << $exp_bits) - 1;\n+\n+        if $secs.is_sign_negative() {\n+            return Err(FromFloatSecsError { kind: FromFloatSecsErrorKind::Negative });\n+        }\n+\n+        let bits = $secs.to_bits();\n+        let mant = (bits & MANT_MASK) | (MANT_MASK + 1);\n+        let exp = ((bits >> $mant_bits) & EXP_MASK) as i16 + MIN_EXP;\n+\n+        let (secs, nanos) = if exp < -30 {\n+            // the input represents less than 1ns.\n+            (0u64, 0u32)\n+        } else if exp < 0 {\n+            // the input is less than 1 second\n+            let t = <$double_ty>::from(mant) << ($offset + exp);\n+            let nanos = (u128::from(NANOS_PER_SEC) * u128::from(t)) >> ($mant_bits + $offset);\n+            (0, nanos as u32)\n+        } else if exp < $mant_bits {\n+            let secs = mant >> ($mant_bits - exp);\n+            let t = <$double_ty>::from((mant << exp) & MANT_MASK);\n+            let nanos = (<$double_ty>::from(NANOS_PER_SEC) * t) >> $mant_bits;\n+            (u64::from(secs), nanos as u32)\n+        } else if exp < 64 {\n+            // the input has no fractional part\n+            let secs = u64::from(mant) << (exp - $mant_bits);\n+            (secs, 0)\n+        } else {\n+            return Err(FromFloatSecsError { kind: FromFloatSecsErrorKind::OverflowOrNan });\n+        };\n+\n+        Ok(Duration { secs, nanos })\n+    }};\n+}\n+\n+impl Duration {\n+    /// The checked version of [`from_secs_f32`].\n+    ///\n+    /// [`from_secs_f32`]: Duration::from_secs_f32\n+    ///\n+    /// This constructor will return an `Err` if `secs` is negative, overflows `Duration` or not finite.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// #![feature(duration_checked_float)]\n+    ///\n+    /// use std::time::Duration;\n+    ///\n+    /// let res = Duration::try_from_secs_f32(0.0);\n+    /// assert_eq!(res, Ok(Duration::new(0, 0)));\n+    /// let res = Duration::try_from_secs_f32(1e-20);\n+    /// assert_eq!(res, Ok(Duration::new(0, 0)));\n+    /// let res = Duration::try_from_secs_f32(4.2e-7);\n+    /// assert_eq!(res, Ok(Duration::new(0, 419)));\n+    /// let res = Duration::try_from_secs_f32(2.7);\n+    /// assert_eq!(res, Ok(Duration::new(2, 700_000_047)));\n+    /// let res = Duration::try_from_secs_f32(3e10);\n+    /// assert_eq!(res, Ok(Duration::new(30_000_001_024, 0)));\n+    /// // subnormal float:\n+    /// let res = Duration::try_from_secs_f32(f32::from_bits(1));\n+    /// assert_eq!(res, Ok(Duration::new(0, 0)));\n+    /// // conversion uses truncation, not rounding\n+    /// let res = Duration::try_from_secs_f32(0.999e-9);\n+    /// assert_eq!(res, Ok(Duration::new(0, 0)));\n+    ///\n+    /// let res = Duration::try_from_secs_f32(-5.0);\n+    /// assert!(res.is_err());\n+    /// let res = Duration::try_from_secs_f32(f32::NAN);\n+    /// assert!(res.is_err());\n+    /// let res = Duration::try_from_secs_f32(2e19);\n+    /// assert!(res.is_err());\n+    /// ```\n+    #[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\n+    #[inline]\n+    pub const fn try_from_secs_f32(secs: f32) -> Result<Duration, FromFloatSecsError> {\n+        try_from_secs!(\n+            secs = secs,\n+            mantissa_bits = 23,\n+            exponent_bits = 8,\n+            offset = 41,\n+            bits_ty = u32,\n+            double_ty = u64,\n+        )\n+    }\n+\n+    /// The checked version of [`from_secs_f64`].\n+    ///\n+    /// [`from_secs_f64`]: Duration::from_secs_f64\n+    ///\n+    /// This constructor will return an `Err` if `secs` is negative, overflows `Duration` or not finite.\n+    ///\n+    /// # Examples\n+    /// ```\n+    /// #![feature(duration_checked_float)]\n+    ///\n+    /// use std::time::Duration;\n+    ///\n+    /// let res = Duration::try_from_secs_f64(0.0);\n+    /// assert_eq!(res, Ok(Duration::new(0, 0)));\n+    /// let res = Duration::try_from_secs_f64(1e-20);\n+    /// assert_eq!(res, Ok(Duration::new(0, 0)));\n+    /// let res = Duration::try_from_secs_f64(4.2e-7);\n+    /// assert_eq!(res, Ok(Duration::new(0, 420)));\n+    /// let res = Duration::try_from_secs_f64(2.7);\n+    /// assert_eq!(res, Ok(Duration::new(2, 700_000_000)));\n+    /// let res = Duration::try_from_secs_f64(3e10);\n+    /// assert_eq!(res, Ok(Duration::new(30_000_000_000, 0)));\n+    /// // subnormal float\n+    /// let res = Duration::try_from_secs_f64(f64::from_bits(1));\n+    /// assert_eq!(res, Ok(Duration::new(0, 0)));\n+    /// // conversion uses truncation, not rounding\n+    /// let res = Duration::try_from_secs_f32(0.999e-9);\n+    /// assert_eq!(res, Ok(Duration::new(0, 0)));\n+    ///\n+    /// let res = Duration::try_from_secs_f64(-5.0);\n+    /// assert!(res.is_err());\n+    /// let res = Duration::try_from_secs_f64(f64::NAN);\n+    /// assert!(res.is_err());\n+    /// let res = Duration::try_from_secs_f64(2e19);\n+    /// assert!(res.is_err());\n+    /// ```\n+    #[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\n+    #[inline]\n+    pub const fn try_from_secs_f64(secs: f64) -> Result<Duration, FromFloatSecsError> {\n+        try_from_secs!(\n+            secs = secs,\n+            mantissa_bits = 52,\n+            exponent_bits = 11,\n+            offset = 44,\n+            bits_ty = u64,\n+            double_ty = u128,\n+        )\n+    }\n }"}, {"sha": "1a96b9c928289b3e5be32ed09efe242632290992", "filename": "library/std/src/error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0bcf771d6e670988a3d4fdc785ecd5857916f10/library%2Fstd%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0bcf771d6e670988a3d4fdc785ecd5857916f10/library%2Fstd%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ferror.rs?ref=e0bcf771d6e670988a3d4fdc785ecd5857916f10", "patch": "@@ -602,7 +602,7 @@ impl Error for char::ParseCharError {\n impl Error for alloc::collections::TryReserveError {}\n \n #[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\n-impl Error for time::FromSecsError {}\n+impl Error for time::FromFloatSecsError {}\n \n // Copied from `any.rs`.\n impl dyn Error + 'static {"}, {"sha": "b4f9d8ea28d7b99cff2e2a5f6cc865663e05874a", "filename": "library/std/src/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0bcf771d6e670988a3d4fdc785ecd5857916f10/library%2Fstd%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0bcf771d6e670988a3d4fdc785ecd5857916f10/library%2Fstd%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime.rs?ref=e0bcf771d6e670988a3d4fdc785ecd5857916f10", "patch": "@@ -45,7 +45,7 @@ use crate::sys_common::FromInner;\n pub use core::time::Duration;\n \n #[unstable(feature = \"duration_checked_float\", issue = \"83400\")]\n-pub use core::time::FromSecsError;\n+pub use core::time::FromFloatSecsError;\n \n /// A measurement of a monotonically nondecreasing clock.\n /// Opaque and useful only with [`Duration`]."}]}