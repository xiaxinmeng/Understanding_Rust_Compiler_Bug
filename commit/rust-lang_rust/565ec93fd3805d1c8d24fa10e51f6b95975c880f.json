{"sha": "565ec93fd3805d1c8d24fa10e51f6b95975c880f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2NWVjOTNmZDM4MDVkMWM4ZDI0ZmExMGU1MWY2Yjk1OTc1Yzg4MGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-26T18:06:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-26T18:06:45Z"}, "message": "auto merge of #5110 : pcwalton/rust/and-const, r=pcwalton\n\nr? @brson", "tree": {"sha": "6722e7ca5ce29d2abf19869475220d7ee1b282b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6722e7ca5ce29d2abf19869475220d7ee1b282b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/565ec93fd3805d1c8d24fa10e51f6b95975c880f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/565ec93fd3805d1c8d24fa10e51f6b95975c880f", "html_url": "https://github.com/rust-lang/rust/commit/565ec93fd3805d1c8d24fa10e51f6b95975c880f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/565ec93fd3805d1c8d24fa10e51f6b95975c880f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6439e286f90a34d96cec91d82f941f7572817939", "url": "https://api.github.com/repos/rust-lang/rust/commits/6439e286f90a34d96cec91d82f941f7572817939", "html_url": "https://github.com/rust-lang/rust/commit/6439e286f90a34d96cec91d82f941f7572817939"}, {"sha": "c9dd917fad8ead284643b9873de60e3df894fb59", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9dd917fad8ead284643b9873de60e3df894fb59", "html_url": "https://github.com/rust-lang/rust/commit/c9dd917fad8ead284643b9873de60e3df894fb59"}], "stats": {"total": 985, "additions": 294, "deletions": 691}, "files": [{"sha": "9a3d087f3d7234ab8dcb2a19f13f43a9d47ce7b0", "filename": "doc/rust.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -1610,11 +1610,11 @@ The following are examples of structure expressions:\n ~~~~\n # struct Point { x: float, y: float }\n # struct TuplePoint(float, float);\n-# mod game { pub struct User { name: &str, age: uint, mut score: uint } }\n+# mod game { pub struct User { name: &str, age: uint, score: uint } }\n # use game;\n Point {x: 10f, y: 20f};\n TuplePoint(10f, 20f);\n-let u = game::User {name: \"Joe\", age: 35u, mut score: 100_000};\n+let u = game::User {name: \"Joe\", age: 35u, score: 100_000};\n ~~~~\n \n A structure expression forms a new value of the named structure type."}, {"sha": "0c1624706bfeb4df708bba26e4a0e94ce5423f8c", "filename": "doc/tutorial-borrowed-ptr.md", "status": "modified", "additions": 4, "deletions": 157, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/doc%2Ftutorial-borrowed-ptr.md", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/doc%2Ftutorial-borrowed-ptr.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-borrowed-ptr.md?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -348,12 +348,12 @@ mutations:\n ~~~ {.xfail-test}\n fn example3() -> int {\n     struct R { g: int }\n-    struct S { mut f: ~R }\n+    struct S { f: ~R }\n \n-    let mut x = ~S {mut f: ~R {g: 3}};\n+    let mut x = ~S {f: ~R {g: 3}};\n     let y = &x.f.g;\n-    x = ~S {mut f: ~R {g: 4}}; // Error reported here.\n-    x.f = ~R {g: 5};           // Error reported here.\n+    x = ~S {f: ~R {g: 4}};  // Error reported here.\n+    x.f = ~R {g: 5};        // Error reported here.\n     *y\n }\n ~~~\n@@ -362,91 +362,6 @@ In this case, two errors are reported, one when the variable `x` is\n modified and another when `x.f` is modified. Either modification would\n invalidate the pointer `y`.\n \n-Things get trickier when the unique box is not uniquely owned by the\n-stack frame, or when there is no way for the compiler to determine the\n-box's owner. Consider a program like this:\n-\n-~~~ {.xfail-test}\n-struct R { g: int }\n-struct S { mut f: ~R }\n-fn example5a(x: @S, callback: @fn()) -> int {\n-    let y = &x.f.g;   // Error reported here.\n-    ...\n-    callback();\n-    ...\n-#   return 0;\n-}\n-~~~\n-\n-Here the heap looks something like:\n-\n-~~~ {.notrust}\n-     Stack            Managed Heap       Exchange Heap\n-\n-  x +------+        +-------------+       +------+\n-    | @... | ---->  | mut f: ~... | --+-> | g: 3 |\n-  y +------+        +-------------+   |   +------+\n-    | &int | -------------------------+\n-    +------+\n-~~~\n-\n-In this case, the owning reference to the value being borrowed is\n-`x.f`. Moreover, `x.f` is both mutable and *aliasable*. Aliasable\n-means that there may be other pointers to that same managed box, so\n-even if the compiler were to prove an absence of mutations to `x.f`,\n-code could mutate `x.f` indirectly by changing an alias of\n-`x`. Therefore, to be safe, the compiler only accepts *pure* actions\n-during the lifetime of `y`. We define what \"pure\" means in the section\n-on [purity](#purity).\n-\n-Besides ensuring purity, the only way to borrow the interior of a\n-unique found in aliasable memory is to ensure that the borrowed field\n-itself is also unique, as in the following example:\n-\n-~~~\n-struct R { g: int }\n-struct S { f: ~R }\n-fn example5b(x: @S) -> int {\n-    let y = &x.f.g;\n-    ...\n-# return 0;\n-}\n-~~~\n-\n-Here, the field `f` is not declared as mutable. But that is enough for\n-the compiler to know that, even if aliases to `x` exist, the field `f`\n-cannot be changed and hence the unique box `g` will remain valid.\n-\n-If you do have a unique box in a mutable field, and you wish to borrow\n-it, one option is to use the swap operator to move that unique box\n-onto your stack:\n-\n-~~~\n-struct R { g: int }\n-struct S { mut f: ~R }\n-fn example5c(x: @S) -> int {\n-    let mut v = ~R {g: 0};\n-    v <-> x.f;         // Swap v and x.f\n-    { // Block constrains the scope of `y`:\n-        let y = &v.g;\n-        ...\n-    }\n-    x.f = v;          // Replace x.f\n-    ...\n-# return 0;\n-}\n-~~~\n-\n-Of course, this has the side effect of modifying your managed box for\n-the duration of the borrow, so it only works when you know that you\n-won't be accessing that same box for the duration of the loan. Also,\n-it is sometimes necessary to introduce additional blocks to constrain\n-the scope of the loan.  In this example, the borrowed pointer `y`\n-would still be in scope when you moved the value `v` back into `x.f`,\n-and hence moving `v` would be considered illegal.  You cannot move\n-values if they are the targets of valid outstanding loans. Introducing\n-the block restricts the scope of `y`, making the move legal.\n-\n # Borrowing and enums\n \n The previous example showed that the type system forbids any borrowing\n@@ -558,11 +473,6 @@ permit `ref` bindings into data owned by the stack frame even if the\n data are mutable, but otherwise it requires that the data reside in\n immutable memory.\n \n-> ***Note:*** Right now, pattern bindings not explicitly annotated\n-> with `ref` or `copy` use a special mode of \"implicit by reference\".\n-> This is changing as soon as we finish updating all the existing code\n-> in the compiler that relies on the current settings.\n-\n # Returning borrowed pointers\n \n So far, all of the examples we've looked at use borrowed pointers in a\n@@ -745,69 +655,6 @@ fn select<T>(shape: &Shape, threshold: float,\n \n This is equivalent to the previous definition.\n \n-# Purity\n-\n-As mentioned before, the Rust compiler offers a kind of escape hatch\n-that permits borrowing of any data, as long as the actions that occur\n-during the lifetime of the borrow are pure. Pure actions are those\n-that only modify data owned by the current stack frame. The compiler\n-can therefore permit arbitrary pointers into the heap, secure in the\n-knowledge that no pure action will ever cause them to become\n-invalidated (the compiler must still track data on the stack which is\n-borrowed and enforce those rules normally, of course). A pure function\n-in Rust is referentially transparent: it returns the same results\n-given the same (observably equivalent) inputs. That is because while\n-pure functions are allowed to modify data, they may only modify\n-*stack-local* data, which cannot be observed outside the scope of the\n-function itself. (Using an `unsafe` block invalidates this guarantee.)\n-\n-Let\u2019s revisit a previous example and show how purity can affect\n-typechecking. Here is `example5a()`, which borrows the interior of a\n-unique box found in an aliasable, mutable location, only now we\u2019ve\n-replaced the `...` with some specific code:\n-\n-~~~\n-struct R { g: int }\n-struct S { mut f: ~R }\n-fn example5a(x: @S ...) -> int {\n-    let y = &x.f.g;   // Unsafe\n-    *y + 1        \n-}\n-~~~\n-\n-The new code simply returns an incremented version of `y`. This code\n-clearly doesn't mutate the heap, so the compiler is satisfied.\n-\n-But suppose we wanted to pull the increment code into a helper, like\n-this:\n-\n-~~~\n-fn add_one(x: &int) -> int { *x + 1 }\n-~~~\n-\n-We can now update `example5a()` to use `add_one()`:\n-\n-~~~\n-# struct R { g: int }\n-# struct S { mut f: ~R }\n-# pure fn add_one(x: &int) -> int { *x + 1 }\n-fn example5a(x: @S ...) -> int {\n-    let y = &x.f.g;\n-    add_one(y)        // Error reported here\n-}\n-~~~\n-\n-But now the compiler will report an error again. The reason is that it\n-only considers one function at a time (like most typecheckers), and\n-so it does not know that `add_one()` consists of pure code. We can\n-help the compiler by labeling `add_one()` as pure:\n-\n-~~~\n-pure fn add_one(x: &int) -> int { *x + 1 }\n-~~~\n-\n-With this change, the modified version of `example5a()` will again compile.\n-\n # Conclusion\n \n So there you have it: a (relatively) brief tour of the borrowed pointer"}, {"sha": "b7659376ed65cddbf25bd8cc5dc007e8a456789f", "filename": "doc/tutorial-ffi.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -220,21 +220,21 @@ extern mod std;\n use libc::c_ulonglong;\n \n struct timeval {\n-    mut tv_sec: c_ulonglong,\n-    mut tv_usec: c_ulonglong\n+    tv_sec: c_ulonglong,\n+    tv_usec: c_ulonglong\n }\n \n #[nolink]\n extern mod lib_c {\n-    fn gettimeofday(tv: *timeval, tz: *()) -> i32;\n+    fn gettimeofday(tv: *mut timeval, tz: *()) -> i32;\n }\n fn unix_time_in_microseconds() -> u64 {\n     unsafe {\n-        let x = timeval {\n-            mut tv_sec: 0 as c_ulonglong,\n-            mut tv_usec: 0 as c_ulonglong\n+        let mut x = timeval {\n+            tv_sec: 0 as c_ulonglong,\n+            tv_usec: 0 as c_ulonglong\n         };\n-        lib_c::gettimeofday(ptr::addr_of(&x), ptr::null());\n+        lib_c::gettimeofday(&mut x, ptr::null());\n         return (x.tv_sec as u64) * 1000_000_u64 + (x.tv_usec as u64);\n     }\n }"}, {"sha": "909bad9e2f40b2ef570746a718695876ab55fd4b", "filename": "doc/tutorial.md", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -583,19 +583,16 @@ Inherited mutability means that any field of a struct may be mutable, if the\n struct is in a mutable slot (or a field of a struct in a mutable slot, and\n so forth).\n \n-A struct that is not mutable due to inherited mutability may declare some\n-of its fields nevertheless mutable, using the `mut` keyword.\n-\n ~~~~\n struct Stack {\n     content: ~[int],\n-    mut head: uint\n+    head: uint\n }\n ~~~~\n \n-With a value of such a type, you can do `mystack.head += 1`. If `mut` were\n-omitted from the type, such an assignment to a struct without inherited\n-mutability would result in a type error.\n+With a value (say, `mystack`) of such a type in a mutable location, you can do\n+`mystack.head += 1`. But in an immutable location, such an assignment to a\n+struct without inherited mutability would result in a type error.\n \n `match` patterns destructure structs. The basic syntax is\n `Name { fieldname: pattern, ... }`:\n@@ -938,19 +935,19 @@ type that contains managed boxes or other managed types.\n ~~~\n // A linked list node\n struct Node {\n-    mut next: MaybeNode,\n-    mut prev: MaybeNode,\n+    next: MaybeNode,\n+    prev: MaybeNode,\n     payload: int\n }\n \n enum MaybeNode {\n-    SomeNode(@Node),\n+    SomeNode(@mut Node),\n     NoNode\n }\n \n-let node1 = @Node { next: NoNode, prev: NoNode, payload: 1 };\n-let node2 = @Node { next: NoNode, prev: NoNode, payload: 2 };\n-let node3 = @Node { next: NoNode, prev: NoNode, payload: 3 };\n+let node1 = @mut Node { next: NoNode, prev: NoNode, payload: 1 };\n+let node2 = @mut Node { next: NoNode, prev: NoNode, payload: 2 };\n+let node3 = @mut Node { next: NoNode, prev: NoNode, payload: 3 };\n \n // Link the three list nodes together\n node1.next = SomeNode(node2);\n@@ -2300,8 +2297,8 @@ mod farm {\n # impl Human { fn rest(&self) { } }\n # pub fn make_me_a_farm() -> farm::Farm { farm::Farm { chickens: ~[], cows: ~[], farmer: Human(0) } }\n     pub struct Farm {\n-        priv mut chickens: ~[Chicken],\n-        priv mut cows: ~[Cow],\n+        priv chickens: ~[Chicken],\n+        priv cows: ~[Cow],\n         farmer: Human\n     }\n "}, {"sha": "5887df6802f57502ecb705fe08a2d9e64c7d498c", "filename": "src/libcore/cell.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::option;\n-use core::prelude::*;\n+use option;\n+use prelude::*;\n \n /// A dynamic, mutable location.\n ///", "previous_filename": "src/libstd/cell.rs"}, {"sha": "ed18388f5783b48633179280ff6da8721d21a5ff", "filename": "src/libcore/core.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -51,6 +51,7 @@ Implicitly, all crates behave as if they included the following prologue:\n #[warn(vecs_implicitly_copyable)];\n #[deny(non_camel_case_types)];\n #[allow(deprecated_self)];\n+#[allow(deprecated_mutable_fields)];\n \n /* The Prelude. */\n \n@@ -142,6 +143,7 @@ pub mod dlist;\n #[path=\"iter-trait.rs\"] #[merge = \"iter-trait/dlist.rs\"]\n pub mod dlist_iter;\n pub mod hashmap;\n+pub mod cell;\n \n \n /* Tasks and communication */"}, {"sha": "15a6e700ffd841a2479c1d124cfb47e1496e01f8", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -86,6 +86,7 @@ bounded and unbounded protocols allows for less code duplication.\n \n use cmp::Eq;\n use cast::{forget, reinterpret_cast, transmute};\n+use cell::Cell;\n use either::{Either, Left, Right};\n use kinds::Owned;\n use libc;\n@@ -917,11 +918,9 @@ pub fn spawn_service<T:Owned,Tb:Owned>(\n \n     // This is some nasty gymnastics required to safely move the pipe\n     // into a new task.\n-    let server = ~mut Some(server);\n-    do task::spawn || {\n-        let mut server_ = None;\n-        server_ <-> *server;\n-        service(option::unwrap(server_))\n+    let server = Cell(server);\n+    do task::spawn {\n+        service(server.take());\n     }\n \n     client\n@@ -941,11 +940,9 @@ pub fn spawn_service_recv<T:Owned,Tb:Owned>(\n \n     // This is some nasty gymnastics required to safely move the pipe\n     // into a new task.\n-    let server = ~mut Some(server);\n-    do task::spawn || {\n-        let mut server_ = None;\n-        server_ <-> *server;\n-        service(option::unwrap(server_))\n+    let server = Cell(server);\n+    do task::spawn {\n+        service(server.take())\n     }\n \n     client"}, {"sha": "2580efe6d09687dceff3e587cd4553b2dab2bc4e", "filename": "src/libcore/private.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -107,10 +107,14 @@ fn compare_and_swap(address: &mut int, oldval: int, newval: int) -> bool {\n  * Shared state & exclusive ARC\n  ****************************************************************************/\n \n+struct UnwrapProtoInner {\n+    contents: Option<(comm::ChanOne<()>,  comm::PortOne<bool>)>,\n+}\n+\n // An unwrapper uses this protocol to communicate with the \"other\" task that\n // drops the last refcount on an arc. Unfortunately this can't be a proper\n // pipe protocol because the unwrapper has to access both stages at once.\n-type UnwrapProto = ~mut Option<(comm::ChanOne<()>,  comm::PortOne<bool>)>;\n+type UnwrapProto = ~UnwrapProtoInner;\n \n struct ArcData<T> {\n     mut count:     libc::intptr_t,\n@@ -139,9 +143,10 @@ struct ArcDestruct<T> {\n                     // reference. In effect, being here means we're the only\n                     // *awake* task with the data.\n                     if data.unwrapper != 0 {\n-                        let p: UnwrapProto =\n+                        let mut p: UnwrapProto =\n                             cast::reinterpret_cast(&data.unwrapper);\n-                        let (message, response) = option::swap_unwrap(p);\n+                        let (message, response) =\n+                            option::swap_unwrap(&mut p.contents);\n                         // Send 'ready' and wait for a response.\n                         comm::send_one(message, ());\n                         // Unkillable wait. Message guaranteed to come.\n@@ -196,7 +201,9 @@ pub unsafe fn unwrap_shared_mutable_state<T:Owned>(rc: SharedMutableState<T>)\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&rc.data);\n         let (p1,c1) = comm::oneshot(); // ()\n         let (p2,c2) = comm::oneshot(); // bool\n-        let server: UnwrapProto = ~mut Some((c1,p2));\n+        let mut server: UnwrapProto = ~UnwrapProtoInner {\n+            contents: Some((c1,p2))\n+        };\n         let serverp: int = cast::transmute(server);\n         // Try to put our server end in the unwrapper slot.\n         if compare_and_swap(&mut ptr.unwrapper, 0, serverp) {\n@@ -409,8 +416,9 @@ pub fn unwrap_exclusive<T:Owned>(arc: Exclusive<T>) -> T {\n pub mod tests {\n     use core::option::{None, Some};\n \n-    use option;\n+    use cell::Cell;\n     use comm;\n+    use option;\n     use private::{exclusive, unwrap_exclusive};\n     use result;\n     use task;\n@@ -423,7 +431,7 @@ pub mod tests {\n         let num_tasks = 10;\n         let count = 10;\n \n-        let total = exclusive(~mut 0);\n+        let total = exclusive(~0);\n \n         for uint::range(0, num_tasks) |_i| {\n             let total = total.clone();\n@@ -472,21 +480,20 @@ pub mod tests {\n     #[test]\n     pub fn exclusive_unwrap_contended() {\n         let x = exclusive(~~\"hello\");\n-        let x2 = ~mut Some(x.clone());\n-        do task::spawn || {\n-            let x2 = option::swap_unwrap(x2);\n+        let x2 = Cell(x.clone());\n+        do task::spawn {\n+            let x2 = x2.take();\n             do x2.with |_hello| { }\n             task::yield();\n         }\n         assert unwrap_exclusive(x) == ~~\"hello\";\n \n         // Now try the same thing, but with the child task blocking.\n         let x = exclusive(~~\"hello\");\n-        let x2 = ~mut Some(x.clone());\n+        let x2 = Cell(x.clone());\n         let mut res = None;\n-        do task::task().future_result(|+r| res = Some(r)).spawn\n-              || {\n-            let x2 = option::swap_unwrap(x2);\n+        do task::task().future_result(|+r| res = Some(r)).spawn {\n+            let x2 = x2.take();\n             assert unwrap_exclusive(x2) == ~~\"hello\";\n         }\n         // Have to get rid of our reference before blocking.\n@@ -498,11 +505,10 @@ pub mod tests {\n     #[test] #[should_fail] #[ignore(cfg(windows))]\n     pub fn exclusive_unwrap_conflict() {\n         let x = exclusive(~~\"hello\");\n-        let x2 = ~mut Some(x.clone());\n+        let x2 = Cell(x.clone());\n         let mut res = None;\n-        do task::task().future_result(|+r| res = Some(r)).spawn\n-           || {\n-            let x2 = option::swap_unwrap(x2);\n+        do task::task().future_result(|+r| res = Some(r)).spawn {\n+            let x2 = x2.take();\n             assert unwrap_exclusive(x2) == ~~\"hello\";\n         }\n         assert unwrap_exclusive(x) == ~~\"hello\";"}, {"sha": "8445638850cd06bdc64a45fed087798757837b5a", "filename": "src/libcore/private/weak_task.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibcore%2Fprivate%2Fweak_task.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibcore%2Fprivate%2Fweak_task.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate%2Fweak_task.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -18,16 +18,17 @@ it is running, sending a notification to the task that the runtime\n is trying to shut down.\n */\n \n+use cell::Cell;\n+use comm::{GenericSmartChan, stream};\n+use comm::{Port, Chan, SharedChan, GenericChan, GenericPort};\n+use hashmap::linear::LinearMap;\n+use ops::Drop;\n use option::{Some, None, swap_unwrap};\n use private::at_exit::at_exit;\n-use private::global::global_data_clone_create;\n use private::finally::Finally;\n-use comm::{Port, Chan, SharedChan, GenericChan,\n-           GenericPort, GenericSmartChan, stream};\n-use task::{Task, task, spawn};\n+use private::global::global_data_clone_create;\n use task::rt::{task_id, get_task_id};\n-use hashmap::linear::LinearMap;\n-use ops::Drop;\n+use task::{Task, task, spawn};\n \n type ShutdownMsg = ();\n \n@@ -37,14 +38,13 @@ pub unsafe fn weaken_task(f: &fn(Port<ShutdownMsg>)) {\n     let service = global_data_clone_create(global_data_key,\n                                            create_global_service);\n     let (shutdown_port, shutdown_chan) = stream::<ShutdownMsg>();\n-    let shutdown_port = ~mut Some(shutdown_port);\n+    let shutdown_port = Cell(shutdown_port);\n     let task = get_task_id();\n     // Expect the weak task service to be alive\n     assert service.try_send(RegisterWeakTask(task, shutdown_chan));\n     unsafe { rust_dec_kernel_live_count(); }\n     do fn&() {\n-        let shutdown_port = swap_unwrap(&mut *shutdown_port);\n-        f(shutdown_port)\n+        f(shutdown_port.take())\n     }.finally || {\n         unsafe { rust_inc_kernel_live_count(); }\n         // Service my have already exited\n@@ -67,16 +67,15 @@ fn create_global_service() -> ~WeakTaskService {\n \n     debug!(\"creating global weak task service\");\n     let (port, chan) = stream::<ServiceMsg>();\n-    let port = ~mut Some(port);\n+    let port = Cell(port);\n     let chan = SharedChan(chan);\n     let chan_clone = chan.clone();\n \n     do task().unlinked().spawn {\n         debug!(\"running global weak task service\");\n-        let port = swap_unwrap(&mut *port);\n-        let port = ~mut Some(port);\n+        let port = Cell(port.take());\n         do fn&() {\n-            let port = swap_unwrap(&mut *port);\n+            let port = port.take();\n             // The weak task service is itself a weak task\n             debug!(\"weakening the weak service task\");\n             unsafe { rust_dec_kernel_live_count(); }"}, {"sha": "4c3abb09756e99b05d625e8afb1ba0a6f85335b4", "filename": "src/libcore/repr.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibcore%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibcore%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frepr.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -602,7 +602,6 @@ fn test_repr() {\n     exact_test(&(@10), \"@10\");\n     exact_test(&(@mut 10), \"@10\");\n     exact_test(&(~10), \"~10\");\n-    exact_test(&(~mut 10), \"~mut 10\");\n     exact_test(&(&10), \"&10\");\n     let mut x = 10;\n     exact_test(&(&mut x), \"&mut 10\");"}, {"sha": "2a640e4bf8cf731de5d4909e6caf99a41ac89044", "filename": "src/libcore/task/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibcore%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibcore%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fmod.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -34,6 +34,7 @@\n  */\n \n use cast;\n+use cell::Cell;\n use cmp;\n use cmp::Eq;\n use iter;\n@@ -397,9 +398,9 @@ impl TaskBuilder {\n     }\n     /// Runs a task, while transfering ownership of one argument to the child.\n     fn spawn_with<A:Owned>(arg: A, f: fn~(v: A)) {\n-        let arg = ~mut Some(arg);\n-        do self.spawn || {\n-            f(option::swap_unwrap(arg))\n+        let arg = Cell(arg);\n+        do self.spawn {\n+            f(arg.take());\n         }\n     }\n "}, {"sha": "5110f70ff11be9762f8616625e520b71cdc6b064", "filename": "src/libcore/task/spawn.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibcore%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibcore%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask%2Fspawn.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -73,6 +73,7 @@\n #[doc(hidden)]; // FIXME #3538\n \n use cast;\n+use cell::Cell;\n use container::Map;\n use option;\n use comm::{Chan, GenericChan, GenericPort, Port, stream};\n@@ -530,11 +531,11 @@ pub fn spawn_raw(opts: TaskOpts, f: fn~()) {\n         gen_child_taskgroup(opts.linked, opts.supervised);\n \n     unsafe {\n-        let child_data = ~mut Some((child_tg, ancestors, f));\n+        let child_data = Cell((child_tg, ancestors, f));\n         // Being killed with the unsafe task/closure pointers would leak them.\n         do unkillable {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)\n-            let (child_tg, ancestors, f) = option::swap_unwrap(child_data);\n+            let (child_tg, ancestors, f) = child_data.take();\n             // Create child task.\n             let new_task = match opts.sched.mode {\n                 DefaultScheduler => rt::new_task(),\n@@ -571,10 +572,10 @@ pub fn spawn_raw(opts: TaskOpts, f: fn~()) {\n                           ancestors: AncestorList, is_main: bool,\n                           notify_chan: Option<Chan<TaskResult>>,\n                           f: fn~()) -> fn~() {\n-        let child_data = ~mut Some((child_arc, ancestors));\n+        let child_data = Cell((child_arc, ancestors));\n         return fn~() {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)\n-            let mut (child_arc, ancestors) = option::swap_unwrap(child_data);\n+            let mut (child_arc, ancestors) = child_data.take();\n             // Child task runs this code.\n \n             // Even if the below code fails to kick the child off, we must"}, {"sha": "f4c3a1e8d12613062b1ea4590b07fc3274bc67d5", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -80,6 +80,7 @@ pub enum lint {\n     type_limits,\n     default_methods,\n     deprecated_self,\n+    deprecated_mutable_fields,\n \n     managed_heap_memory,\n     owned_heap_memory,\n@@ -254,6 +255,13 @@ pub fn get_lint_dict() -> LintDict {\n             default: warn\n          }),\n \n+        (@~\"deprecated_mutable_fields\",\n+         @LintSpec {\n+            lint: deprecated_mutable_fields,\n+            desc: \"deprecated mutable fields in structures\",\n+            default: deny\n+        }),\n+\n         /* FIXME(#3266)--make liveness warnings lintable\n         (@~\"unused_variable\",\n          @LintSpec {\n@@ -486,6 +494,7 @@ fn check_item(i: @ast::item, cx: ty::ctxt) {\n     check_item_type_limits(cx, i);\n     check_item_default_methods(cx, i);\n     check_item_deprecated_self(cx, i);\n+    check_item_deprecated_mutable_fields(cx, i);\n }\n \n // Take a visitor, and modify it so that it will not proceed past subitems.\n@@ -703,6 +712,26 @@ fn check_item_deprecated_self(cx: ty::ctxt, item: @ast::item) {\n     }\n }\n \n+fn check_item_deprecated_mutable_fields(cx: ty::ctxt, item: @ast::item) {\n+    match item.node {\n+        ast::item_struct(struct_def, _) => {\n+            for struct_def.fields.each |field| {\n+                match field.node.kind {\n+                    ast::named_field(_, ast::struct_mutable, _) => {\n+                        cx.sess.span_lint(deprecated_mutable_fields,\n+                                          item.id,\n+                                          item.id,\n+                                          field.span,\n+                                          ~\"mutable fields are deprecated\");\n+                    }\n+                    ast::named_field(*) | ast::unnamed_field => {}\n+                }\n+            }\n+        }\n+        _ => {}\n+    }\n+}\n+\n fn check_item_structural_records(cx: ty::ctxt, it: @ast::item) {\n     let visit = item_stopping_visitor(\n         visit::mk_simple_visitor(@visit::SimpleVisitor {"}, {"sha": "96aa41f78091359e19995f822199b5537a35c24d", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -667,8 +667,8 @@ struct Liveness {\n     tcx: ty::ctxt,\n     ir: @mut IrMaps,\n     s: Specials,\n-    successors: ~[mut LiveNode],\n-    users: ~[mut Users],\n+    successors: @mut ~[LiveNode],\n+    users: @mut ~[Users],\n     // The list of node IDs for the nested loop scopes\n     // we're in.\n     loop_scope: DVec<node_id>,\n@@ -684,14 +684,9 @@ fn Liveness(ir: @mut IrMaps, specials: Specials) -> Liveness {\n         ir: ir,\n         tcx: ir.tcx,\n         s: specials,\n-        successors:\n-            vec::cast_to_mut(\n-                vec::from_elem(ir.num_live_nodes,\n-                               invalid_node())),\n-        users:\n-            vec::cast_to_mut(\n-                vec::from_elem(ir.num_live_nodes * ir.num_vars,\n-                               invalid_users())),\n+        successors: @mut vec::from_elem(ir.num_live_nodes, invalid_node()),\n+        users: @mut vec::from_elem(ir.num_live_nodes * ir.num_vars,\n+                                   invalid_users()),\n         loop_scope: DVec(),\n         break_ln: HashMap(),\n         cont_ln: HashMap()\n@@ -916,12 +911,13 @@ impl Liveness {\n \n         let mut changed = false;\n         do self.indices2(ln, succ_ln) |idx, succ_idx| {\n-            changed |= copy_if_invalid(copy self.users[succ_idx].reader,\n-                                       &mut self.users[idx].reader);\n-            changed |= copy_if_invalid(copy self.users[succ_idx].writer,\n-                                       &mut self.users[idx].writer);\n-            if self.users[succ_idx].used && !self.users[idx].used {\n-                self.users[idx].used = true;\n+            let users = &mut *self.users;\n+            changed |= copy_if_invalid(copy users[succ_idx].reader,\n+                                       &mut users[idx].reader);\n+            changed |= copy_if_invalid(copy users[succ_idx].writer,\n+                                       &mut users[idx].writer);\n+            if users[succ_idx].used && !users[idx].used {\n+                users[idx].used = true;\n                 changed = true;\n             }\n         }\n@@ -956,7 +952,8 @@ impl Liveness {\n     // Either read, write, or both depending on the acc bitset\n     fn acc(&self, ln: LiveNode, var: Variable, acc: uint) {\n         let idx = self.idx(ln, var);\n-        let user = &mut self.users[idx];\n+        let users = &mut *self.users;\n+        let user = &mut users[idx];\n \n         if (acc & ACC_WRITE) != 0 {\n             user.reader = invalid_node();\n@@ -970,7 +967,7 @@ impl Liveness {\n         }\n \n         if (acc & ACC_USE) != 0 {\n-            self.users[idx].used = true;\n+            user.used = true;\n         }\n \n         debug!(\"%s accesses[%x] %s: %s\","}, {"sha": "2fc7497f5e33b2cc039c4a728755d3e0e200f3cf", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -51,7 +51,7 @@ pub const use_tydesc: uint = 2u; /* Takes the tydesc, or compares */\n \n pub struct Context {\n     ccx: @CrateContext,\n-    uses: ~[mut type_uses]\n+    uses: @mut ~[type_uses]\n }\n \n pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n@@ -72,7 +72,7 @@ pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n \n     let cx = Context {\n         ccx: ccx,\n-        uses: vec::cast_to_mut(vec::from_elem(n_tps, 0u))\n+        uses: @mut vec::from_elem(n_tps, 0u)\n     };\n     match ty::get(ty::lookup_item_type(cx.ccx.tcx, fn_id).ty).sty {\n         ty::ty_bare_fn(ty::BareFnTy {sig: ref sig, _}) |\n@@ -90,7 +90,7 @@ pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n     }\n \n     if fn_id_loc.crate != local_crate {\n-        let uses = vec::cast_from_mut(copy cx.uses);\n+        let uses = copy *cx.uses;\n         ccx.type_use_cache.insert(fn_id, copy uses);\n         return uses;\n     }\n@@ -175,16 +175,16 @@ pub fn type_uses_for(ccx: @CrateContext, fn_id: def_id, n_tps: uint)\n                                 ccx.tcx.sess.parse_sess.interner)));\n       }\n     }\n-    let uses = vec::cast_from_mut(copy cx.uses);\n-    // XXX: Bad copy, use @vec instead?\n+    // XXX: Bad copies, use @vec instead?\n+    let uses = copy *cx.uses;\n     ccx.type_use_cache.insert(fn_id, copy uses);\n     uses\n }\n \n pub fn type_needs(cx: Context, use_: uint, ty: ty::t) {\n     // Optimization -- don't descend type if all params already have this use\n-    for vec::each_mut(cx.uses) |u| {\n-        if *u & use_ != use_ {\n+    for uint::range(0, cx.uses.len()) |i| {\n+        if cx.uses[i] & use_ != use_ {\n             type_needs_inner(cx, use_, ty, @Nil);\n             return;\n         }"}, {"sha": "d0affaa170218b5284fc47ca1cec1d2f583dc0f6", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -216,7 +216,8 @@ pub fn ast_ty_to_ty<AC:AstConv,RS:region_scope + Copy + Durable>(\n         match a_seq_ty.ty.node {\n             ast::ty_vec(mt) => {\n                 let mut mt = ast_mt_to_mt(self, rscope, mt);\n-                if a_seq_ty.mutbl == ast::m_mutbl {\n+                if a_seq_ty.mutbl == ast::m_mutbl ||\n+                        a_seq_ty.mutbl == ast::m_const {\n                     mt = ty::mt { ty: mt.ty, mutbl: ast::m_mutbl };\n                 }\n                 return ty::mk_evec(tcx, mt, vst);"}, {"sha": "ee598686652522f070565cb2ece010de590fbd4f", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -549,6 +549,7 @@ use syntax::codemap;\n use util::common::indenter;\n use util::ppaux::note_and_explain_region;\n \n+use core::cell::{Cell, empty_cell};\n use core::cmp;\n use core::dvec::DVec;\n use core::to_bytes;\n@@ -557,7 +558,6 @@ use core::vec;\n use result::Result;\n use result::{Ok, Err};\n use std::oldmap::HashMap;\n-use std::cell::{Cell, empty_cell};\n use std::list::{List, Nil, Cons};\n use syntax::codemap::span;\n use syntax::codemap;"}, {"sha": "251e21578a5235b712aa570b3063a86b6ccbe311", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -314,8 +314,8 @@ fails without recording a fatal error then we've encountered a compiler\n bug and need to present an error.\n */\n pub fn monitor(+f: fn~(diagnostic::Emitter)) {\n+    use core::cell::Cell;\n     use core::comm::*;\n-    use std::cell::Cell;\n     let (p, ch) = stream();\n     let ch = SharedChan(ch);\n     let ch_capture = ch.clone();"}, {"sha": "1c45fdafa189c0757f5fd886e8d4e8c7749f05b9", "filename": "src/librustdoc/astsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibrustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibrustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fastsrv.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -21,8 +21,8 @@ use core::prelude::*;\n \n use parse;\n use util;\n-use std::cell::Cell;\n \n+use core::cell::Cell;\n use core::comm::{stream, Chan, SharedChan, Port};\n use core::vec;\n use core::ops::Drop;"}, {"sha": "11a1b9f357657568f2b563081011301c80f1948a", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -10,6 +10,7 @@\n \n use core::prelude::*;\n \n+use core::cell::Cell;\n use core::cmp;\n use core::os;\n use core::result;\n@@ -18,7 +19,6 @@ use core::run::ProgramOutput;\n use core::vec;\n use core::result::Result;\n use std::getopts;\n-use std::cell::Cell;\n \n /// The type of document to output\n pub enum OutputFormat {"}, {"sha": "f64f365496d838d935718d041f44c7f1232d7791", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -34,11 +34,11 @@ use sort_pass;\n use trim_pass;\n use unindent_pass;\n \n+use core::cell::Cell;\n use core::iter;\n use core::str;\n use core::vec;\n use std::par;\n-use std::cell::Cell;\n use syntax;\n \n pub fn mk_pass(writer_factory: WriterFactory) -> Pass {"}, {"sha": "83f35418b0b1f062e8dc72e55d91edb51069ef57", "filename": "src/librustdoc/text_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibrustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibrustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftext_pass.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -20,8 +20,8 @@ use fold;\n use pass::Pass;\n use util::NominalOp;\n \n+use core::cell::Cell;\n use std::par;\n-use std::cell::Cell;\n \n pub fn mk_pass(name: ~str, op: @fn(&str) -> ~str) -> Pass {\n     let op = Cell(op);"}, {"sha": "854abfdd112e67d99b4d1ffca0e0aab0cbfa2f52", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -29,6 +29,7 @@ not required in or otherwise suitable for the core library.\n #[allow(vecs_implicitly_copyable)];\n #[deny(non_camel_case_types)];\n #[allow(deprecated_self)];\n+#[allow(deprecated_mutable_fields)];\n \n #[no_core];\n \n@@ -53,7 +54,6 @@ pub mod uv_global_loop;\n \n pub mod c_vec;\n pub mod timer;\n-pub mod cell;\n pub mod io_util;\n \n // Concurrency"}, {"sha": "b345b116425ca2abcecd1c78348019f363c5ff64", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -1176,9 +1176,9 @@ mod test {\n         // all of the ones I was too lazy to handle:\n         CallToOther\n     }\n-    // using a mutable field rather than changing the\n+    // using `@mut` rather than changing the\n     // type of self in every method of every encoder everywhere.\n-    pub struct TestEncoder {mut call_log : ~[call]}\n+    pub struct TestEncoder {call_log : @mut ~[call]}\n \n     pub impl TestEncoder {\n         // these self's should be &mut self's, as well....\n@@ -1272,9 +1272,9 @@ mod test {\n     struct Node {id: uint}\n \n     fn to_call_log (val: Encodable<TestEncoder>) -> ~[call] {\n-        let mut te = TestEncoder {call_log: ~[]};\n+        let mut te = TestEncoder {call_log: @mut ~[]};\n         val.encode(&te);\n-        te.call_log\n+        copy *te.call_log\n     }\n /*\n     #[test] fn encode_test () {"}, {"sha": "7b3030124b72ff1fcd6413967256479f39fd3735", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -48,6 +48,7 @@ pub enum ObsoleteSyntax {\n     ObsoleteUnenforcedBound,\n     ObsoleteImplSyntax,\n     ObsoleteTraitBoundSeparator,\n+    ObsoleteMutOwnedPointer,\n }\n \n pub impl to_bytes::IterBytes for ObsoleteSyntax {\n@@ -126,6 +127,12 @@ pub impl Parser {\n                 \"space-separated trait bounds\",\n                 \"write `+` between trait bounds\"\n             ),\n+            ObsoleteMutOwnedPointer => (\n+                \"mutable owned pointer\",\n+                \"mutability inherits through `~` pointers; place the `~` box\n+                 in a mutable location, like a mutable local variable or an \\\n+                 `@mut` box\"\n+            ),\n         };\n \n         self.report(sp, kind, kind_str, desc);"}, {"sha": "af25a4f6e58dc832ef63b279587f063a1a0f59ab", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -75,7 +75,7 @@ use parse::obsolete::{ObsoleteMoveInit, ObsoleteBinaryMove};\n use parse::obsolete::{ObsoleteStructCtor, ObsoleteWith};\n use parse::obsolete::{ObsoleteSyntax, ObsoleteLowerCaseKindBounds};\n use parse::obsolete::{ObsoleteUnsafeBlock, ObsoleteImplSyntax};\n-use parse::obsolete::{ObsoleteTraitBoundSeparator};\n+use parse::obsolete::{ObsoleteTraitBoundSeparator, ObsoleteMutOwnedPointer};\n use parse::prec::{as_prec, token_to_binop};\n use parse::token::{can_begin_expr, is_ident, is_ident_or_path};\n use parse::token::{is_plain_ident, INTERPOLATED, special_idents};\n@@ -677,6 +677,11 @@ pub impl Parser {\n         // rather than boxed ptrs.  But the special casing of str/vec is not\n         // reflected in the AST type.\n         let mt = self.parse_mt();\n+\n+        if mt.mutbl == m_mutbl && sigil == OwnedSigil {\n+            self.obsolete(*self.last_span, ObsoleteMutOwnedPointer);\n+        }\n+\n         ctor(mt)\n     }\n "}, {"sha": "12060a87850a0bbd3fbf0159cb2665bb6d9bdb60", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -19,6 +19,7 @@ extern mod std;\n use std::time;\n use std::arc;\n use std::future;\n+use core::cell::Cell;\n \n // A poor man's pipe.\n type pipe = arc::MutexARC<~[uint]>;\n@@ -77,7 +78,7 @@ fn main() {\n     let msg_per_task = uint::from_str(args[2]).get();\n \n     let (num_chan, num_port) = init();\n-    let mut num_chan = Some(num_chan);\n+    let mut num_chan = Cell(num_chan);\n \n     let start = time::precise_time_s();\n \n@@ -87,24 +88,19 @@ fn main() {\n     for uint::range(1u, num_tasks) |i| {\n         //error!(\"spawning %?\", i);\n         let (new_chan, num_port) = init();\n-        let num_chan2 = ~mut None;\n-        *num_chan2 <-> num_chan;\n-        let num_port = ~mut Some(num_port);\n-        let new_future = do future::spawn() || {\n-            let mut num_chan = None;\n-            num_chan <-> *num_chan2;\n-            let mut num_port1 = None;\n-            num_port1 <-> *num_port;\n-            thread_ring(i, msg_per_task,\n-                        option::unwrap(num_chan),\n-                        option::unwrap(num_port1))\n+        let num_chan2 = Cell(num_chan.take());\n+        let num_port = Cell(num_port);\n+        let new_future = do future::spawn() {\n+            let num_chan = num_chan2.take();\n+            let num_port1 = num_port.take();\n+            thread_ring(i, msg_per_task, num_chan, num_port1)\n         };\n         futures.push(new_future);\n-        num_chan = Some(new_chan);\n+        num_chan.put_back(new_chan);\n     };\n \n     // do our iteration\n-    thread_ring(0, msg_per_task, option::unwrap(num_chan), num_port);\n+    thread_ring(0, msg_per_task, num_chan.take(), num_port);\n \n     // synchronize\n     for futures.each |f| { f.get() };"}, {"sha": "56a46d3e006cc2cdedc0df5948d61e4b50eec6ad", "filename": "src/test/bench/msgsend-ring-pipes.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-pipes.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -17,10 +17,11 @@\n // This version uses automatically compiled channel contracts.\n \n extern mod std;\n-use std::time;\n-use std::future;\n \n+use core::cell::Cell;\n use core::pipes::recv;\n+use std::time;\n+use std::future;\n \n proto! ring (\n     num:send {\n@@ -70,7 +71,7 @@ fn main() {\n     let msg_per_task = uint::from_str(args[2]).get();\n \n     let (num_chan, num_port) = ring::init();\n-    let mut num_chan = Some(num_chan);\n+    let mut num_chan = Cell(num_chan);\n \n     let start = time::precise_time_s();\n \n@@ -80,24 +81,19 @@ fn main() {\n     for uint::range(1u, num_tasks) |i| {\n         //error!(\"spawning %?\", i);\n         let (new_chan, num_port) = ring::init();\n-        let num_chan2 = ~mut None;\n-        *num_chan2 <-> num_chan;\n-        let num_port = ~mut Some(num_port);\n+        let num_chan2 = Cell(num_chan.take());\n+        let num_port = Cell(num_port);\n         let new_future = do future::spawn || {\n-            let mut num_chan = None;\n-            num_chan <-> *num_chan2;\n-            let mut num_port1 = None;\n-            num_port1 <-> *num_port;\n-            thread_ring(i, msg_per_task,\n-                        option::unwrap(num_chan),\n-                        option::unwrap(num_port1))\n+            let num_chan = num_chan2.take();\n+            let num_port1 = num_port.take();\n+            thread_ring(i, msg_per_task, num_chan, num_port1)\n         };\n         futures.push(new_future);\n-        num_chan = Some(new_chan);\n+        num_chan.put_back(new_chan);\n     };\n \n     // do our iteration\n-    thread_ring(0, msg_per_task, option::unwrap(num_chan), num_port);\n+    thread_ring(0, msg_per_task, num_chan.take(), num_port);\n \n     // synchronize\n     for futures.each |f| { f.get() };"}, {"sha": "57d04abb414c135fb4fe47fd85267eb88a001521", "filename": "src/test/bench/msgsend-ring-rw-arcs.rs", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-rw-arcs.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -16,6 +16,8 @@\n // This also serves as a pipes test, because ARCs are implemented with pipes.\n \n extern mod std;\n+\n+use core::cell::Cell;\n use std::time;\n use std::arc;\n use std::future;\n@@ -77,7 +79,7 @@ fn main() {\n     let msg_per_task = uint::from_str(args[2]).get();\n \n     let (num_chan, num_port) = init();\n-    let mut num_chan = Some(num_chan);\n+    let mut num_chan = Cell(num_chan);\n \n     let start = time::precise_time_s();\n \n@@ -87,24 +89,19 @@ fn main() {\n     for uint::range(1u, num_tasks) |i| {\n         //error!(\"spawning %?\", i);\n         let (new_chan, num_port) = init();\n-        let num_chan2 = ~mut None;\n-        *num_chan2 <-> num_chan;\n-        let num_port = ~mut Some(num_port);\n-        let new_future = do future::spawn || {\n-            let mut num_chan = None;\n-            num_chan <-> *num_chan2;\n-            let mut num_port1 = None;\n-            num_port1 <-> *num_port;\n-            thread_ring(i, msg_per_task,\n-                        option::unwrap(num_chan),\n-                        option::unwrap(num_port1))\n+        let num_chan2 = Cell(num_chan.take());\n+        let num_port = Cell(num_port);\n+        let new_future = do future::spawn {\n+            let num_chan = num_chan2.take();\n+            let num_port1 = num_port.take();\n+            thread_ring(i, msg_per_task, num_chan, num_port1)\n         };\n         futures.push(new_future);\n-        num_chan = Some(new_chan);\n+        num_chan.put_back(new_chan);\n     };\n \n     // do our iteration\n-    thread_ring(0, msg_per_task, option::unwrap(num_chan), num_port);\n+    thread_ring(0, msg_per_task, num_chan.take(), num_port);\n \n     // synchronize\n     for futures.each |f| { f.get() };"}, {"sha": "111219974d0987b8d2fe8e7406ad0c0162d80566", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -14,7 +14,7 @@ extern mod std;\n use std::oldmap;\n use std::oldmap::HashMap;\n use std::sort;\n-use std::cell::Cell;\n+use core::cell::Cell;\n use core::comm::*;\n \n fn print_complements() {"}, {"sha": "9bdc5aae3f2835fba69a917f01795e0ed54f95e6", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -17,13 +17,15 @@\n //\n // The filename is a song reference; google it in quotes.\n \n+use core::cell::Cell;\n+\n fn child_generation(gens_left: uint, -c: comm::Chan<()>) {\n     // This used to be O(n^2) in the number of generations that ever existed.\n     // With this code, only as many generations are alive at a time as tasks\n     // alive at a time,\n-    let c = ~mut Some(c);\n-    do task::spawn_supervised || {\n-        let c = option::swap_unwrap(c);\n+    let c = Cell(c);\n+    do task::spawn_supervised {\n+        let c = c.take();\n         if gens_left & 1 == 1 {\n             task::yield(); // shake things up a bit\n         }"}, {"sha": "17c7ff1bb6037bfc249e9db83cea547d4760c47b", "filename": "src/test/compile-fail/assign-super.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6439e286f90a34d96cec91d82f941f7572817939/src%2Ftest%2Fcompile-fail%2Fassign-super.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6439e286f90a34d96cec91d82f941f7572817939/src%2Ftest%2Fcompile-fail%2Fassign-super.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassign-super.rs?ref=6439e286f90a34d96cec91d82f941f7572817939", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    let mut x: ~[mut int] = ~[mut 3];\n-    let y: ~[int] = ~[3];\n-    x = y; //~ ERROR values differ in mutability\n-}"}, {"sha": "ded47fc9f7fe268c49fcd0f1a283cad887ab63c9", "filename": "src/test/compile-fail/borrowck-assign-comp-idx.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-assign-comp-idx.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -11,7 +11,7 @@\n type point = { x: int, y: int };\n \n fn a() {\n-    let mut p = ~[mut 1];\n+    let mut p = ~[1];\n \n     // Create an immutable pointer into p's contents:\n     let _q: &int = &p[0]; //~ NOTE loan of mutable vec content granted here\n@@ -25,7 +25,7 @@ fn b() {\n     // here we alias the mutable vector into an imm slice and try to\n     // modify the original:\n \n-    let mut p = ~[mut 1];\n+    let mut p = ~[1];\n \n     do borrow(p) { //~ NOTE loan of mutable vec content granted here\n         p[0] = 5; //~ ERROR assigning to mutable vec content prohibited due to outstanding loan\n@@ -35,7 +35,7 @@ fn b() {\n fn c() {\n     // Legal because the scope of the borrow does not include the\n     // modification:\n-    let mut p = ~[mut 1];\n+    let mut p = ~[1];\n     borrow(p, ||{});\n     p[0] = 5;\n }"}, {"sha": "8457fce255ea319bfcadae50c5fb06edd6276f66", "filename": "src/test/compile-fail/borrowck-loan-vec-content.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-loan-vec-content.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -17,13 +17,13 @@ fn takes_imm_elt(_v: &int, f: fn()) {\n }\n \n fn has_mut_vec_and_does_not_try_to_change_it() {\n-    let v = ~[mut 1, 2, 3];\n+    let mut v = ~[1, 2, 3];\n     do takes_imm_elt(&v[0]) {\n     }\n }\n \n fn has_mut_vec_but_tries_to_change_it() {\n-    let v = ~[mut 1, 2, 3];\n+    let mut v = ~[1, 2, 3];\n     do takes_imm_elt(&v[0]) { //~ NOTE loan of mutable vec content granted here\n         v[1] = 4; //~ ERROR assigning to mutable vec content prohibited due to outstanding loan\n     }\n@@ -34,7 +34,7 @@ fn takes_const_elt(_v: &const int, f: fn()) {\n }\n \n fn has_mut_vec_and_tries_to_change_it() {\n-    let v = ~[mut 1, 2, 3];\n+    let mut v = ~[1, 2, 3];\n     do takes_const_elt(&const v[0]) {\n         v[1] = 4;\n     }"}, {"sha": "bc0340983ae3491348db9d9806f51d1d5e50fbb6", "filename": "src/test/compile-fail/borrowck-mut-slice-of-imm-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-slice-of-imm-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-slice-of-imm-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-slice-of-imm-vec.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn write(v: &[mut int]) {\n+fn write(v: &mut [int]) {\n     v[0] += 1;\n }\n "}, {"sha": "43feb65c8b96b9492e4ab595c0405033dc2d77f1", "filename": "src/test/compile-fail/borrowck-mut-vec-as-imm-slice-bad.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6439e286f90a34d96cec91d82f941f7572817939/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-vec-as-imm-slice-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6439e286f90a34d96cec91d82f941f7572817939/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-vec-as-imm-slice-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-mut-vec-as-imm-slice-bad.rs?ref=6439e286f90a34d96cec91d82f941f7572817939", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn want_slice(v: &[int]) -> int {\n-    let mut sum = 0;\n-    for vec::each(v) |i| { sum += *i; }\n-    return sum;\n-}\n-\n-fn has_mut_vec(+v: @~[mut int]) -> int {\n-    want_slice(*v) //~ ERROR illegal borrow unless pure\n-        //~^ NOTE impure due to access to impure function\n-}\n-\n-fn main() {\n-    assert has_mut_vec(@~[mut 1, 2, 3]) == 6;\n-}"}, {"sha": "16b48aedb0c7fedc3d4d9949ed4a26b7890563f4", "filename": "src/test/compile-fail/borrowck-vec-pattern-move-tail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-move-tail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-move-tail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-vec-pattern-move-tail.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n-    let a = [mut 1, 2, 3, 4];\n+    let mut a = [1, 2, 3, 4];\n     let _ = match a {\n         [1, 2, ..tail] => tail,\n         _ => core::util::unreachable()"}, {"sha": "88c76fb31a1ff86add6c2cb20cda0b0f0b369b21", "filename": "src/test/compile-fail/issue-2969.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Fcompile-fail%2Fissue-2969.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Fcompile-fail%2Fissue-2969.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2969.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -12,7 +12,7 @@\n fn main()\n {\n // See #2969 -- error message should be improved\n-   let mut x = [mut 1, 2, 4];\n+   let mut x = [1, 2, 4];\n    let v : &int = &x[2];\n    x[2] = 6;\n    assert *v == 6;"}, {"sha": "443fae619ba7b0186785fbd80edeadcc0c938d04", "filename": "src/test/compile-fail/issue-3243.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Fcompile-fail%2Fissue-3243.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Fcompile-fail%2Fissue-3243.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3243.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n // xfail-test\n-fn function() -> &[mut int] {\n-    let mut x: &static/[mut int] = &[mut 1,2,3];\n+fn function() -> &mut [int] {\n+    let mut x: &static/mut [int] = &[1,2,3];\n     x[0] = 12345;\n     x //~ ERROR bad\n }"}, {"sha": "5c71ae38a64c019525e4f882a03001eff384dc80", "filename": "src/test/compile-fail/lub-in-args.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Fcompile-fail%2Flub-in-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Fcompile-fail%2Flub-in-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flub-in-args.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -11,8 +11,6 @@\n fn two_args<T>(x: T, y: T) { }\n \n fn main() {\n-    let x: ~[mut int] = ~[mut 3];\n-    let y: ~[int] = ~[3];\n     let a: @mut int = @mut 3;\n     let b: @int = @3;\n \n@@ -22,6 +20,5 @@ fn main() {\n     // shortcoming of the current inference algorithm.  These errors\n     // are *not* desirable.\n \n-    two_args(x, y); //~ ERROR (values differ in mutability)\n     two_args(a, b); //~ ERROR (values differ in mutability)\n }"}, {"sha": "316c832f0119e574f58001e2924f459f90086188", "filename": "src/test/compile-fail/mutable-huh-variance-box.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6439e286f90a34d96cec91d82f941f7572817939/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6439e286f90a34d96cec91d82f941f7572817939/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-box.rs?ref=6439e286f90a34d96cec91d82f941f7572817939", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: mismatched types\n-\n-fn main() {\n-    let v = @mut ~[0];\n-\n-    fn f(&&v: @mut ~[const int]) {\n-        *v = ~[mut 3]\n-    }\n-\n-    f(v);\n-}"}, {"sha": "4f0c6d7a4c87d7e59fe43e02593241c1b9ae0a4a", "filename": "src/test/compile-fail/mutable-huh-variance-deep.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6439e286f90a34d96cec91d82f941f7572817939/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-deep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6439e286f90a34d96cec91d82f941f7572817939/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-deep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-deep.rs?ref=6439e286f90a34d96cec91d82f941f7572817939", "patch": "@@ -1,20 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: mismatched types\n-\n-fn main() {\n-    let v = ~[mut @mut ~mut ~[0]];\n-\n-    fn f(&&v: ~[mut @mut ~mut ~[const int]]) {\n-    }\n-\n-    f(v);\n-}"}, {"sha": "dba6f9ae3fa0fb5df1db58067dc842f0e5086a7b", "filename": "src/test/compile-fail/mutable-huh-variance-ptr.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6439e286f90a34d96cec91d82f941f7572817939/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6439e286f90a34d96cec91d82f941f7572817939/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-ptr.rs?ref=6439e286f90a34d96cec91d82f941f7572817939", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: mismatched types\n-\n-extern mod std;\n-\n-fn main() {\n-    let mut a = ~[0];\n-    let v: *mut ~[int] = &mut a;\n-\n-    fn f(&&v: *mut ~[const int]) {\n-        unsafe {\n-            *v = ~[mut 3]\n-        }\n-    }\n-\n-    f(v);\n-}"}, {"sha": "f2188911346e99fb825884cb4bf2e5bd394d87e8", "filename": "src/test/compile-fail/mutable-huh-variance-unique.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6439e286f90a34d96cec91d82f941f7572817939/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6439e286f90a34d96cec91d82f941f7572817939/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-unique.rs?ref=6439e286f90a34d96cec91d82f941f7572817939", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// error-pattern: mismatched types\n-\n-fn main() {\n-    let v = ~mut ~[0];\n-\n-    fn f(&&v: ~mut ~[const int]) {\n-        *v = ~[mut 3]\n-    }\n-\n-    f(v);\n-}"}, {"sha": "c3f4636f898b19f892886a9184b4713db9c1ea44", "filename": "src/test/compile-fail/mutable-huh-variance-vec1.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6439e286f90a34d96cec91d82f941f7572817939/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6439e286f90a34d96cec91d82f941f7572817939/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec1.rs?ref=6439e286f90a34d96cec91d82f941f7572817939", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    // Note: explicit type annot is required here\n-    // because otherwise the inference gets smart\n-    // and assigns a type of ~[mut ~[const int]].\n-    let v: ~[mut ~[int]] = ~[mut ~[0]];\n-\n-    fn f(&&v: ~[mut ~[const int]]) {\n-        v[0] = ~[mut 3]\n-    }\n-\n-    f(v); //~ ERROR (values differ in mutability)\n-}"}, {"sha": "aeb06324341f46eae6c6b7cfd7debb335bb0c12b", "filename": "src/test/compile-fail/mutable-huh-variance-vec2.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6439e286f90a34d96cec91d82f941f7572817939/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6439e286f90a34d96cec91d82f941f7572817939/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec2.rs?ref=6439e286f90a34d96cec91d82f941f7572817939", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    // Note: explicit type annot is required here\n-    // because otherwise the inference gets smart\n-    // and assigns a type of ~[mut ~[const int]].\n-    let v: ~[mut ~[mut int]] = ~[mut ~[mut 0]];\n-\n-    fn f(&&v: ~[mut ~[const int]]) {\n-        v[0] = ~[3]\n-    }\n-\n-    f(v); //~ ERROR (values differ in mutability)\n-}"}, {"sha": "edc66536e9bac2f271b3701c55ff324fc6dd9ee5", "filename": "src/test/compile-fail/mutable-huh-variance-vec3.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6439e286f90a34d96cec91d82f941f7572817939/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6439e286f90a34d96cec91d82f941f7572817939/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec3.rs?ref=6439e286f90a34d96cec91d82f941f7572817939", "patch": "@@ -1,22 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-    // Note: explicit type annot is required here\n-    // because otherwise the inference gets smart\n-    // and assigns a type of ~[mut ~[const int]].\n-    let v: ~[mut ~[mut ~[int]]] = ~[mut ~[mut ~[0]]];\n-\n-    fn f(&&v: ~[mut ~[mut ~[const int]]]) {\n-        v[0][1] = ~[mut 3]\n-    }\n-\n-    f(v); //~ ERROR (values differ in mutability)\n-}"}, {"sha": "e0980826a2a599f2057fa387559524c238354bf2", "filename": "src/test/compile-fail/mutable-huh-variance-vec4.rs", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6439e286f90a34d96cec91d82f941f7572817939/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6439e286f90a34d96cec91d82f941f7572817939/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-huh-variance-vec4.rs?ref=6439e286f90a34d96cec91d82f941f7572817939", "patch": "@@ -1,56 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn main() {\n-\n-    // Note: here we do not have any type annotations\n-    // but we do express conflicting requirements:\n-\n-    let v = ~[mut ~[0]];\n-    let w = ~[mut ~[mut 0]];\n-    let x = ~[mut ~[mut 0]];\n-\n-    fn f(&&v: ~[mut ~[int]]) {\n-        v[0] = ~[3]\n-    }\n-\n-    fn g(&&v: ~[const ~[const int]]) {\n-    }\n-\n-    fn h(&&v: ~[mut ~[mut int]]) {\n-        v[0] = ~[mut 3]\n-    }\n-\n-    fn i(&&v: ~[mut ~[const int]]) {\n-        v[0] = ~[mut 3]\n-    }\n-\n-    fn j(&&v: ~[~[const int]]) {\n-    }\n-\n-    f(v);\n-    g(v);\n-    h(v); //~ ERROR (values differ in mutability)\n-    i(v); //~ ERROR (values differ in mutability)\n-    j(v); //~ ERROR (values differ in mutability)\n-\n-    f(w); //~ ERROR (values differ in mutability)\n-    g(w);\n-    h(w);\n-    i(w); //~ ERROR (values differ in mutability)\n-    j(w); //~ ERROR (values differ in mutability)\n-\n-    // Note that without adding f() or h() to the mix, it is valid for\n-    // x to have the type ~[mut ~[const int]], and thus we can safely\n-    // call g() and i() but not j():\n-    g(x);\n-    i(x);\n-    j(x); //~ ERROR (values differ in mutability)\n-}"}, {"sha": "0d7e2d2377c2057d01c5cd3888623f52ea2bcddd", "filename": "src/test/compile-fail/no-send-res-ports.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use core::cell::Cell;\n+\n struct Port<T>(@T);\n \n fn main() {\n@@ -25,11 +27,10 @@ fn main() {\n         }\n     }\n \n-    let x = ~mut Some(foo(Port(@())));\n+    let x = Cell(foo(Port(@())));\n \n     do task::spawn {\n-        let mut y = None;\n-        *x <-> y; //~ ERROR value has non-owned type\n+        let y = x.take();   //~ ERROR value has non-owned type\n         log(error, y);\n     }\n }"}, {"sha": "4b637b0195c31c7bc5eac21eef4f7c64aace4547", "filename": "src/test/compile-fail/regions-infer-invariance-due-to-mutability-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-infer-invariance-due-to-mutability-2.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n struct invariant {\n-    f: @[mut &int]\n+    f: @mut [&int]\n }\n \n fn to_same_lifetime(bi: invariant/&r) {"}, {"sha": "a3a197505a34022957fab8ae0a74859dbafecacc", "filename": "src/test/compile-fail/unique-mut.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6439e286f90a34d96cec91d82f941f7572817939/src%2Ftest%2Fcompile-fail%2Funique-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6439e286f90a34d96cec91d82f941f7572817939/src%2Ftest%2Fcompile-fail%2Funique-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-mut.rs?ref=6439e286f90a34d96cec91d82f941f7572817939", "patch": "@@ -1,14 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//error-pattern:mismatched types\n-fn main() {\n-    let i: ~int = ~mut 0;\n-}"}, {"sha": "0f51d34fc2ff2a284c2da3e8e95625b3be4243f2", "filename": "src/test/compile-fail/vec-add.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Fcompile-fail%2Fvec-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Fcompile-fail%2Fvec-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvec-add.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -14,7 +14,7 @@\n // the right hand side in all cases. We are getting compiler errors\n // about this now, so I'm xfailing the test for now. -eholk\n \n-fn add(i: ~[int], m: ~[mut int], c: ~[const int]) {\n+fn add(i: ~[int], mut m: ~[int], c: ~[const int]) {\n \n     // Check that:\n     //  (1) vectors of any two mutabilities can be added\n@@ -24,9 +24,9 @@ fn add(i: ~[int], m: ~[mut int], c: ~[const int]) {\n        m + ~[3],\n        ~[3]);\n \n-   add(i + ~[mut 3],\n-       m + ~[mut 3],\n-       ~[mut 3]);\n+   add(i + ~[3],\n+       m + ~[3],\n+       ~[3]);\n \n    add(i + i,\n        m + i,\n@@ -54,19 +54,19 @@ fn add(i: ~[int], m: ~[mut int], c: ~[const int]) {\n                 //~^ mismatched types\n        ~[3]);\n \n-   add(m + ~[mut 3], //~ ERROR mismatched types\n-       m + ~[mut 3],\n-       m + ~[mut 3]);\n+   add(m + ~[3], //~ ERROR mismatched types\n+       m + ~[3],\n+       m + ~[3]);\n \n-   add(i + ~[mut 3],\n-       i + ~[mut 3], //~ ERROR mismatched types\n-       i + ~[mut 3]);\n+   add(i + ~[3],\n+       i + ~[3], //~ ERROR mismatched types\n+       i + ~[3]);\n \n-   add(c + ~[mut 3], //~ ERROR binary operation + cannot be applied\n+   add(c + ~[3], //~ ERROR binary operation + cannot be applied\n                     //~^ mismatched types\n-       c + ~[mut 3], //~ ERROR binary operation + cannot be applied\n+       c + ~[3], //~ ERROR binary operation + cannot be applied\n                     //~^ mismatched types\n-       ~[mut 3]);\n+       ~[3]);\n \n    add(m + i, //~ ERROR mismatched types\n        m + i,"}, {"sha": "b11a5356f698cc7fef143bec8fd1f38502b12b04", "filename": "src/test/run-pass/borrowck-preserve-box-in-uniq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-preserve-box-in-uniq.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -20,7 +20,7 @@ fn borrow(x: &int, f: fn(x: &int)) {\n struct F { f: ~int }\n \n pub fn main() {\n-    let mut x = ~mut @F{f: ~3};\n+    let mut x = ~@F{f: ~3};\n     do borrow(x.f) |b_x| {\n         assert *b_x == 3;\n         assert ptr::addr_of(&(*x.f)) == ptr::addr_of(&(*b_x));"}, {"sha": "8a3139157fdf602dc59e9ad40a60d73c82eb1fa2", "filename": "src/test/run-pass/cycle-collection4.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Fcycle-collection4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Fcycle-collection4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcycle-collection4.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct foo { mut z : fn@() }\n+struct foo { z : fn@() }\n \n fn nop() { }\n-fn nop_foo(_y: ~[int], _x : @foo) { }\n+fn nop_foo(_y: ~[int], _x : @mut foo) { }\n \n pub fn main() {\n-    let w = @foo{ z: || nop() };\n+    let w = @mut foo{ z: || nop() };\n     let x : fn@() = || nop_foo(~[], w);\n     w.z = x;\n }"}, {"sha": "d40b2f72ae8bac67b76e4772bd6eccff70086369", "filename": "src/test/run-pass/explicit-self-closures.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Fexplicit-self-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Fexplicit-self-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-closures.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -21,9 +21,6 @@ impl Box {\n     fn set_many2(@mut self, xs: &[uint]) {\n         for xs.each |x| { self.x = *x; }\n     }\n-    fn set_many3(~mut self, xs: &[uint]) {\n-        for xs.each |x| { self.x = *x; }\n-    }\n }\n \n pub fn main() {}"}, {"sha": "7d5bf65dad7c168dc1e2db0dcc39b3f8521fb2c7", "filename": "src/test/run-pass/intrinsic-atomics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fintrinsic-atomics.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -29,7 +29,7 @@ extern mod rusti {\n \n pub fn main() {\n     unsafe {\n-        let x = ~mut 1;\n+        let mut x = ~1;\n \n         assert rusti::atomic_cxchg(x, 1, 2) == 1;\n         assert *x == 2;"}, {"sha": "95129851d5bcd979281e2ca0337db6b2d05b73cb", "filename": "src/test/run-pass/issue-1989.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Fissue-1989.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Fissue-1989.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-1989.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -12,23 +12,22 @@\n \n enum maybe_pointy {\n     none,\n-    p(@Pointy)\n+    p(@mut Pointy)\n }\n \n struct Pointy {\n-    mut a : maybe_pointy,\n-    mut f : fn@()->(),\n+    a : maybe_pointy,\n+    f : fn@()->(),\n }\n \n-fn empty_pointy() -> @Pointy {\n-    return @Pointy{\n-        mut a : none,\n-        mut f : fn@()->(){},\n+fn empty_pointy() -> @mut Pointy {\n+    return @mut Pointy{\n+        a : none,\n+        f : fn@()->(){},\n     }\n }\n \n-pub fn main()\n-{\n+pub fn main() {\n     let v = ~[empty_pointy(), empty_pointy()];\n     v[0].a = p(v[0]);\n }"}, {"sha": "b97ebb04f716d87d05f39a4712bbdc36817fcd4e", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -318,18 +318,16 @@ pub fn main() {\n //    Commented out because of option::get error\n \n     let (client_, server_) = pingpong::init();\n-    let client_ = ~mut Some(client_);\n-    let server_ = ~mut Some(server_);\n+    let client_ = Cell(client_);\n+    let server_ = Cell(server_);\n \n     task::spawn {|client_|\n-        let mut client__ = none;\n-        *client_ <-> client__;\n-        client(option::unwrap(client__));\n+        let client__ = client_.take();\n+        client(client__);\n     };\n     task::spawn {|server_|\n-        let mut server_\u02ca = none;\n-        *server_ <-> server_\u02ca;\n-        server(option::unwrap(server_\u02ca));\n+        let server__ = server_.take();\n+        server(server_\u02ca);\n     };\n   */\n }"}, {"sha": "e2e5dfcc7d5195bb4193c1abfc97fa9a17ec8a8c", "filename": "src/test/run-pass/issue-980.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Fissue-980.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Fissue-980.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-980.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -10,14 +10,14 @@\n \n enum maybe_pointy {\n     no_pointy,\n-    yes_pointy(@Pointy),\n+    yes_pointy(@mut Pointy),\n }\n \n struct Pointy {\n-    mut x : maybe_pointy\n+    x : maybe_pointy\n }\n \n pub fn main() {\n-    let m = @Pointy { mut x : no_pointy };\n+    let m = @mut Pointy { x : no_pointy };\n     m.x = yes_pointy(m);\n }"}, {"sha": "2b270a54d80a0128c0b0553af5d0ad6ff1e17c8a", "filename": "src/test/run-pass/pipe-pingpong-bounded.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-pingpong-bounded.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -14,6 +14,7 @@\n // experiment with what code the compiler should generate for bounded\n // protocols.\n \n+use core::cell::Cell;\n \n // This was generated initially by the pipe compiler, but it's been\n // modified in hopefully straightforward ways.\n@@ -111,16 +112,14 @@ mod test {\n \n pub fn main() {\n     let (client_, server_) = ::pingpong::init();\n-    let client_ = ~mut Some(client_);\n-    let server_ = ~mut Some(server_);\n-    do task::spawn || {\n-        let mut client__ = None;\n-        *client_ <-> client__;\n-        test::client(option::unwrap(client__));\n+    let client_ = Cell(client_);\n+    let server_ = Cell(server_);\n+    do task::spawn {\n+        let client__ = client_.take();\n+        test::client(client__);\n     };\n-    do task::spawn || {\n-        let mut server_\u02ca = None;\n-        *server_ <-> server_\u02ca;\n-        test::server(option::unwrap(server_\u02ca));\n+    do task::spawn {\n+        let server__ = server_.take();\n+        test::server(server__);\n     };\n }"}, {"sha": "c51c0733622780b27c6f4b3ba71706bf3d75e925", "filename": "src/test/run-pass/pipe-pingpong-proto.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Fpipe-pingpong-proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Fpipe-pingpong-proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-pingpong-proto.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -12,6 +12,7 @@\n \n // An example to make sure the protocol parsing syntax extension works.\n \n+use core::cell::Cell;\n use core::option;\n \n proto! pingpong (\n@@ -49,17 +50,15 @@ mod test {\n \n pub fn main() {\n     let (client_, server_) = pingpong::init();\n-    let client_ = ~mut Some(client_);\n-    let server_ = ~mut Some(server_);\n+    let client_ = Cell(client_);\n+    let server_ = Cell(server_);\n \n-    do task::spawn || {\n-        let mut client__ = None;\n-        *client_ <-> client__;\n-        test::client(option::unwrap(client__));\n+    do task::spawn {\n+        let client__ = client_.take();\n+        test::client(client__);\n     };\n-    do task::spawn || {\n-        let mut server_\u02ca = None;\n-        *server_ <-> server_\u02ca;\n-        test::server(option::unwrap(server_\u02ca));\n+    do task::spawn {\n+        let server__ = server_.take();\n+        test::server(server__);\n     };\n }"}, {"sha": "432c189ae423c742537d60264217430fa6edc524", "filename": "src/test/run-pass/private-method.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Fprivate-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Fprivate-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprivate-method.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -9,20 +9,20 @@\n // except according to those terms.\n \n struct cat {\n-  priv mut meows : uint,\n+    priv meows : uint,\n \n-  how_hungry : int,\n+    how_hungry : int,\n }\n \n impl cat {\n-  fn play() {\n-    self.meows += 1u;\n-    self.nap();\n-  }\n+    fn play(&mut self) {\n+        self.meows += 1u;\n+        self.nap();\n+    }\n }\n \n priv impl cat {\n-    fn nap() { for uint::range(1u, 10u) |_i| { }}\n+    fn nap(&mut self) { for uint::range(1u, 10u) |_i| { }}\n }\n \n fn cat(in_x : uint, in_y : int) -> cat {\n@@ -33,6 +33,6 @@ fn cat(in_x : uint, in_y : int) -> cat {\n }\n \n pub fn main() {\n-  let nyan : cat = cat(52u, 99);\n+  let mut nyan : cat = cat(52u, 99);\n   nyan.play();\n }"}, {"sha": "cac6b4ef349329941af62738891cb20242107adf", "filename": "src/test/run-pass/pure-sum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Fpure-sum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Fpure-sum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpure-sum.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -20,7 +20,7 @@ pure fn sums_to(v: ~[int], sum: int) -> bool {\n }\n \n pure fn sums_to_using_uniq(v: ~[int], sum: int) -> bool {\n-    let mut i = 0u, sum0 = ~mut 0;\n+    let mut i = 0u, sum0 = ~0;\n     while i < v.len() {\n         *sum0 += v[i];\n         i += 1u;\n@@ -40,7 +40,7 @@ pure fn sums_to_using_rec(v: ~[int], sum: int) -> bool {\n struct F<T> { f: T }\n \n pure fn sums_to_using_uniq_rec(v: ~[int], sum: int) -> bool {\n-    let mut i = 0u, sum0 = F {f: ~mut 0};\n+    let mut i = 0u, sum0 = F {f: ~0};\n     while i < v.len() {\n         *sum0.f += v[i];\n         i += 1u;"}, {"sha": "7011f5ba1add0a44ebfa64b9f444fc3207c38f7a", "filename": "src/test/run-pass/rcvr-borrowed-to-region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-region.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -31,7 +31,7 @@ pub fn main() {\n     debug!(\"y=%d\", y);\n     assert y == 6;\n \n-    let x = ~mut 6;\n+    let mut x = ~6;\n     let y = x.get();\n     debug!(\"y=%d\", y);\n     assert y == 6;"}, {"sha": "991025a1ad282cc4c396d6fc0853c9429a6b1ed4", "filename": "src/test/run-pass/task-killjoin-rsrc.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-killjoin-rsrc.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -13,6 +13,7 @@\n // A port of task-killjoin to use a class with a dtor to manage\n // the join.\n \n+use core::cell::Cell;\n use core::comm::*;\n \n struct notify {\n@@ -49,11 +50,9 @@ fn joinable(f: fn~()) -> Port<bool> {\n         *b = true;\n     }\n     let (p, c) = stream();\n-    let c = ~mut Some(c);\n+    let c = Cell(c);\n     do task::spawn_unlinked {\n-        let mut cc = None;\n-        *c <-> cc;\n-        let ccc = option::unwrap(cc);\n+        let ccc = c.take();\n         wrapper(ccc, f)\n     }\n     p"}, {"sha": "1b602ab7d3009bb8560d20dfdeb607d20098a38e", "filename": "src/test/run-pass/uniq-cc-generic.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -10,27 +10,26 @@\n \n enum maybe_pointy {\n     none,\n-    p(@Pointy),\n+    p(@mut Pointy),\n }\n \n struct Pointy {\n-    mut a : maybe_pointy,\n+    a : maybe_pointy,\n     d : fn~() -> uint,\n }\n \n fn make_uniq_closure<A:Owned + Copy>(a: A) -> fn~() -> uint {\n     fn~() -> uint { ptr::addr_of(&a) as uint }\n }\n \n-fn empty_pointy() -> @Pointy {\n-    return @Pointy {\n+fn empty_pointy() -> @mut Pointy {\n+    return @mut Pointy {\n         mut a : none,\n         d : make_uniq_closure(~\"hi\")\n     }\n }\n \n-pub fn main()\n-{\n+pub fn main() {\n     let v = empty_pointy();\n     v.a = p(v);\n }"}, {"sha": "3d72a41182868076cf16446004d4c5c7331bbafa", "filename": "src/test/run-pass/uniq-cc.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Funiq-cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Funiq-cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiq-cc.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -10,25 +10,24 @@\n \n enum maybe_pointy {\n     none,\n-    p(@Pointy),\n+    p(@mut Pointy),\n }\n \n struct Pointy {\n-    mut a : maybe_pointy,\n+    a : maybe_pointy,\n     c : ~int,\n     d : fn~()->(),\n }\n \n-fn empty_pointy() -> @Pointy {\n-    return @Pointy {\n-        mut a : none,\n+fn empty_pointy() -> @mut Pointy {\n+    return @mut Pointy {\n+        a : none,\n         c : ~22,\n         d : fn~()->(){},\n     }\n }\n \n-pub fn main()\n-{\n+pub fn main() {\n     let v = empty_pointy();\n     v.a = p(v);\n }"}, {"sha": "1bb04aef28687f4d5849decda0f39d8271b7ce88", "filename": "src/test/run-pass/unique-assign-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Funique-assign-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Funique-assign-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-assign-copy.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-    let i = ~mut 1;\n+    let mut i = ~1;\n     // Should be a copy\n     let mut j;\n     j = copy i;"}, {"sha": "67e59cb08e0c0b416ae9884760d87fe2676ae87c", "filename": "src/test/run-pass/unique-decl-init-copy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Funique-decl-init-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Funique-decl-init-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-decl-init-copy.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n pub fn main() {\n-    let i = ~mut 1;\n+    let mut i = ~1;\n     // Should be a copy\n-    let j = copy i;\n+    let mut j = copy i;\n     *i = 2;\n     *j = 3;\n     assert *i == 2;"}, {"sha": "ac8796674abb8213678407062b8da61f50a8d2ed", "filename": "src/test/run-pass/unique-in-vec-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Funique-in-vec-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Funique-in-vec-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-in-vec-copy.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-    let a = ~[~mut 10];\n+    let mut a = ~[~10];\n     let b = copy a;\n \n     assert *a[0] == 10;"}, {"sha": "8784dbeb0af404e85b238f801a046287bf98cb03", "filename": "src/test/run-pass/unique-mutable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Funique-mutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/565ec93fd3805d1c8d24fa10e51f6b95975c880f/src%2Ftest%2Frun-pass%2Funique-mutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-mutable.rs?ref=565ec93fd3805d1c8d24fa10e51f6b95975c880f", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n pub fn main() {\n-    let i = ~mut 0;\n+    let mut i = ~0;\n     *i = 1;\n     assert *i == 1;\n }"}]}