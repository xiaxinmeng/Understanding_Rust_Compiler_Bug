{"sha": "be76f357aff217fec6e613fac66eada8ef5f73d2", "node_id": "C_kwDOAAsO6NoAKGJlNzZmMzU3YWZmMjE3ZmVjNmU2MTNmYWM2NmVhZGE4ZWY1ZjczZDI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-31T10:37:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-31T10:37:50Z"}, "message": "Auto merge of #14034 - lnicola:tweak-change-collapsing, r=Veykril\n\ninternal: Tweak change collapsing\n\nCC https://github.com/rust-lang/rust-analyzer/pull/14025#discussion_r1087946555.", "tree": {"sha": "044b836f6e4333392ee82c8f0903e50261d7fa6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/044b836f6e4333392ee82c8f0903e50261d7fa6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be76f357aff217fec6e613fac66eada8ef5f73d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be76f357aff217fec6e613fac66eada8ef5f73d2", "html_url": "https://github.com/rust-lang/rust/commit/be76f357aff217fec6e613fac66eada8ef5f73d2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be76f357aff217fec6e613fac66eada8ef5f73d2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b75803ad31772d105d86f8ebee0cbc8844a4fa29", "url": "https://api.github.com/repos/rust-lang/rust/commits/b75803ad31772d105d86f8ebee0cbc8844a4fa29", "html_url": "https://github.com/rust-lang/rust/commit/b75803ad31772d105d86f8ebee0cbc8844a4fa29"}, {"sha": "deff5f22f6f4122b211211ae2f1ca2a7ad0c7e0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/deff5f22f6f4122b211211ae2f1ca2a7ad0c7e0f", "html_url": "https://github.com/rust-lang/rust/commit/deff5f22f6f4122b211211ae2f1ca2a7ad0c7e0f"}], "stats": {"total": 98, "additions": 48, "deletions": 50}, "files": [{"sha": "aca6c92357070752258d6b05dd6e7de61b671c31", "filename": "crates/rust-analyzer/src/global_state.rs", "status": "modified", "additions": 48, "deletions": 50, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/be76f357aff217fec6e613fac66eada8ef5f73d2/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be76f357aff217fec6e613fac66eada8ef5f73d2/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fglobal_state.rs?ref=be76f357aff217fec6e613fac66eada8ef5f73d2", "patch": "@@ -3,7 +3,7 @@\n //!\n //! Each tick provides an immutable snapshot of the state as `WorldSnapshot`.\n \n-use std::{mem, sync::Arc, time::Instant};\n+use std::{sync::Arc, time::Instant};\n \n use crossbeam_channel::{unbounded, Receiver, Sender};\n use flycheck::FlycheckHandle;\n@@ -179,10 +179,9 @@ impl GlobalState {\n \n     pub(crate) fn process_changes(&mut self) -> bool {\n         let _p = profile::span(\"GlobalState::process_changes\");\n-        // A file was added or deleted\n-        let mut has_structure_changes = false;\n         let mut workspace_structure_change = None;\n \n+        let mut file_changes = FxHashMap::default();\n         let (change, changed_files) = {\n             let mut change = Change::new();\n             let (vfs, line_endings_map) = &mut *self.vfs.write();\n@@ -191,57 +190,56 @@ impl GlobalState {\n                 return false;\n             }\n \n-            // important: this needs to be a stable sort, the order between changes is relevant\n-            // for the same file ids\n-            changed_files.sort_by_key(|file| file.file_id);\n-            // We need to fix up the changed events a bit, if we have a create or modify for a file\n-            // id that is followed by a delete we actually no longer observe the file text from the\n-            // create or modify which may cause problems later on\n-            let mut collapsed_create_delete = false;\n-            changed_files.dedup_by(|a, b| {\n+            // We need to fix up the changed events a bit. If we have a create or modify for a file\n+            // id that is followed by a delete we actually skip observing the file text from the\n+            // earlier event, to avoid problems later on.\n+            for changed_file in &changed_files {\n                 use vfs::ChangeKind::*;\n \n-                let has_collapsed_create_delete = mem::replace(&mut collapsed_create_delete, false);\n+                file_changes\n+                    .entry(changed_file.file_id)\n+                    .and_modify(|(change, just_created)| {\n+                        // None -> Delete => keep\n+                        // Create -> Delete => collapse\n+                        //\n+                        match (change, just_created, changed_file.change_kind) {\n+                            // latter `Delete` wins\n+                            (change, _, Delete) => *change = Delete,\n+                            // merge `Create` with `Create` or `Modify`\n+                            (Create, _, Create | Modify) => {}\n+                            // collapse identical `Modify`es\n+                            (Modify, _, Modify) => {}\n+                            // equivalent to `Modify`\n+                            (change @ Delete, just_created, Create) => {\n+                                *change = Modify;\n+                                *just_created = true;\n+                            }\n+                            // shouldn't occur, but collapse into `Create`\n+                            (change @ Delete, just_created, Modify) => {\n+                                *change = Create;\n+                                *just_created = true;\n+                            }\n+                            // shouldn't occur, but collapse into `Modify`\n+                            (Modify, _, Create) => {}\n+                        }\n+                    })\n+                    .or_insert((\n+                        changed_file.change_kind,\n+                        matches!(changed_file.change_kind, Create),\n+                    ));\n+            }\n \n-                if a.file_id != b.file_id {\n-                    return false;\n-                }\n+            changed_files.extend(\n+                file_changes\n+                    .into_iter()\n+                    .filter(|(_, (change_kind, just_created))| {\n+                        !matches!((change_kind, just_created), (vfs::ChangeKind::Delete, true))\n+                    })\n+                    .map(|(file_id, (change_kind, _))| vfs::ChangedFile { file_id, change_kind }),\n+            );\n \n-                // true => delete the second element (a), we swap them here as they are inverted by dedup_by\n-                match (b.change_kind, a.change_kind) {\n-                    // duplicate can be merged\n-                    (Create, Create) | (Modify, Modify) | (Delete, Delete) => true,\n-                    // just leave the create, modify is irrelevant\n-                    (Create, Modify) => true,\n-                    // modify becomes irrelevant if the file is deleted\n-                    (Modify, Delete) => {\n-                        mem::swap(a, b);\n-                        true\n-                    }\n-                    // Remove the create message, and in the following loop, also remove the delete\n-                    (Create, Delete) => {\n-                        collapsed_create_delete = true;\n-                        b.change_kind = Delete;\n-                        true\n-                    }\n-                    // trailing delete from earlier\n-                    (Delete, Create | Modify) if has_collapsed_create_delete => {\n-                        b.change_kind = Create;\n-                        true\n-                    }\n-                    // this is equivalent to a modify\n-                    (Delete, Create) => {\n-                        b.change_kind = Modify;\n-                        true\n-                    }\n-                    // can't really occur\n-                    (Modify, Create) => false,\n-                    (Delete, Modify) => false,\n-                }\n-            });\n-            if collapsed_create_delete {\n-                changed_files.pop();\n-            }\n+            // A file was added or deleted\n+            let mut has_structure_changes = false;\n             for file in &changed_files {\n                 if let Some(path) = vfs.file_path(file.file_id).as_path() {\n                     let path = path.to_path_buf();"}]}