{"sha": "c2533b64a32b44dfde9b6a8a2301403a6568c313", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyNTMzYjY0YTMyYjQ0ZGZkZTliNmE4YTIzMDE0MDNhNjU2OGMzMTM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-07-17T01:12:48Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-07-20T09:22:24Z"}, "message": "resolve: Remove `SingleImports` in favor of a simple set", "tree": {"sha": "a84a6bbe36e007fb4fd0e8310402a16a4ea3a534", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a84a6bbe36e007fb4fd0e8310402a16a4ea3a534"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2533b64a32b44dfde9b6a8a2301403a6568c313", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2533b64a32b44dfde9b6a8a2301403a6568c313", "html_url": "https://github.com/rust-lang/rust/commit/c2533b64a32b44dfde9b6a8a2301403a6568c313", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2533b64a32b44dfde9b6a8a2301403a6568c313/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22143491bc44287b42b6dfa22e9fd702a9d76a0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/22143491bc44287b42b6dfa22e9fd702a9d76a0c", "html_url": "https://github.com/rust-lang/rust/commit/22143491bc44287b42b6dfa22e9fd702a9d76a0c"}], "stats": {"total": 125, "additions": 26, "deletions": 99}, "files": [{"sha": "1b8d1e849b32997bc668299352ffa1368d01f0b5", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 26, "deletions": 99, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/c2533b64a32b44dfde9b6a8a2301403a6568c313/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2533b64a32b44dfde9b6a8a2301403a6568c313/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=c2533b64a32b44dfde9b6a8a2301403a6568c313", "patch": "@@ -33,7 +33,7 @@ use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::Span;\n \n use std::cell::{Cell, RefCell};\n-use std::{mem, ptr};\n+use std::mem;\n \n /// Contains data for specific types of import directives.\n #[derive(Clone, Debug)]\n@@ -104,67 +104,20 @@ impl<'a> ImportDirective<'a> {\n #[derive(Clone, Default, Debug)]\n /// Records information about the resolution of a name in a namespace of a module.\n pub struct NameResolution<'a> {\n-    /// The single imports that define the name in the namespace.\n-    single_imports: SingleImports<'a>,\n+    /// Single imports that may define the name in the namespace.\n+    /// Import directives are arena-allocated, so it's ok to use pointers as keys, they are stable.\n+    single_imports: FxHashSet<*const ImportDirective<'a>>,\n     /// The least shadowable known binding for this name, or None if there are no known bindings.\n     pub binding: Option<&'a NameBinding<'a>>,\n     shadowed_glob: Option<&'a NameBinding<'a>>,\n }\n \n-#[derive(Clone, Debug)]\n-enum SingleImports<'a> {\n-    /// No single imports can define the name in the namespace.\n-    None,\n-    /// Only the given single import can define the name in the namespace.\n-    MaybeOne(&'a ImportDirective<'a>),\n-    /// Only one of these two single imports can define the name in the namespace.\n-    MaybeTwo(&'a ImportDirective<'a>, &'a ImportDirective<'a>),\n-    /// At least one single import will define the name in the namespace.\n-    AtLeastOne,\n-}\n-\n-impl<'a> Default for SingleImports<'a> {\n-    /// Creates a `SingleImports<'a>` of None type.\n-    fn default() -> Self {\n-        SingleImports::None\n-    }\n-}\n-\n-impl<'a> SingleImports<'a> {\n-    fn add_directive(&mut self, directive: &'a ImportDirective<'a>, use_extern_macros: bool) {\n-        match *self {\n-            SingleImports::None => *self = SingleImports::MaybeOne(directive),\n-            SingleImports::MaybeOne(directive_one) => *self = if use_extern_macros {\n-                SingleImports::MaybeTwo(directive_one, directive)\n-            } else {\n-                SingleImports::AtLeastOne\n-            },\n-            // If three single imports can define the name in the namespace, we can assume that at\n-            // least one of them will define it since otherwise we'd get duplicate errors in one of\n-            // other namespaces.\n-            SingleImports::MaybeTwo(..) => *self = SingleImports::AtLeastOne,\n-            SingleImports::AtLeastOne => {}\n-        };\n-    }\n-\n-    fn directive_failed(&mut self, dir: &'a ImportDirective<'a>) {\n-        match *self {\n-            SingleImports::None => unreachable!(),\n-            SingleImports::MaybeOne(_) => *self = SingleImports::None,\n-            SingleImports::MaybeTwo(dir1, dir2) =>\n-                *self = SingleImports::MaybeOne(if ptr::eq(dir1, dir) { dir1 } else { dir2 }),\n-            SingleImports::AtLeastOne => {}\n-        }\n-    }\n-}\n-\n impl<'a> NameResolution<'a> {\n     // Returns the binding for the name if it is known or None if it not known.\n     fn binding(&self) -> Option<&'a NameBinding<'a>> {\n-        self.binding.and_then(|binding| match self.single_imports {\n-            SingleImports::None => Some(binding),\n-            _ if !binding.is_glob_import() => Some(binding),\n-            _ => None, // The binding could be shadowed by a single import, so it is not known.\n+        self.binding.and_then(|binding| {\n+            if !binding.is_glob_import() ||\n+               self.single_imports.is_empty() { Some(binding) } else { None }\n         })\n     }\n }\n@@ -227,58 +180,31 @@ impl<'a> Resolver<'a> {\n             if usable { Ok(binding) } else { Err(Determined) }\n         };\n \n-        // Items and single imports are not shadowable.\n+        // Items and single imports are not shadowable, if we have one, then it's determined.\n         if let Some(binding) = resolution.binding {\n             if !binding.is_glob_import() {\n                 return check_usable(self, binding);\n             }\n         }\n \n-        // Check if a single import can still define the name.\n-        let resolve_single_import = |this: &mut Self, directive: &'a ImportDirective<'a>| {\n-            let module = match directive.imported_module.get() {\n-                Some(module) => module,\n-                None => return false,\n-            };\n-            let ident = match directive.subclass {\n+        // From now on we either have a glob resolution or no resolution.\n+\n+        // Check if one of single imports can still define the name,\n+        // if it can then our result is not determined and can be invalidated.\n+        for single_import in &resolution.single_imports {\n+            let single_import = unsafe { &**single_import };\n+            if !self.is_accessible(single_import.vis.get()) {\n+                continue;\n+            }\n+            let module = unwrap_or!(single_import.imported_module.get(), return Err(Undetermined));\n+            let ident = match single_import.subclass {\n                 SingleImport { source, .. } => source,\n                 _ => unreachable!(),\n             };\n-            match this.resolve_ident_in_module(module, ident, ns, false, path_span) {\n-                Err(Determined) => {}\n-                _ => return false,\n-            }\n-            true\n-        };\n-        match resolution.single_imports {\n-            SingleImports::AtLeastOne => return Err(Undetermined),\n-            SingleImports::MaybeOne(directive) => {\n-                let accessible = self.is_accessible(directive.vis.get());\n-                if accessible {\n-                    if !resolve_single_import(self, directive) {\n-                        return Err(Undetermined)\n-                    }\n-                }\n-            }\n-            SingleImports::MaybeTwo(directive1, directive2) => {\n-                let accessible1 = self.is_accessible(directive1.vis.get());\n-                let accessible2 = self.is_accessible(directive2.vis.get());\n-                if accessible1 && accessible2 {\n-                    if !resolve_single_import(self, directive1) &&\n-                       !resolve_single_import(self, directive2) {\n-                        return Err(Undetermined)\n-                    }\n-                } else if accessible1 {\n-                    if !resolve_single_import(self, directive1) {\n-                        return Err(Undetermined)\n-                    }\n-                } else {\n-                    if !resolve_single_import(self, directive2) {\n-                        return Err(Undetermined)\n-                    }\n-                }\n+            match self.resolve_ident_in_module(module, ident, ns, false, path_span) {\n+                Err(Determined) => continue,\n+                Ok(_) | Err(Undetermined) => return Err(Undetermined),\n             }\n-            SingleImports::None => {},\n         }\n \n         let no_unresolved_invocations =\n@@ -348,7 +274,7 @@ impl<'a> Resolver<'a> {\n             SingleImport { target, type_ns_only, .. } => {\n                 self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n                     let mut resolution = this.resolution(current_module, target, ns).borrow_mut();\n-                    resolution.single_imports.add_directive(directive, this.use_extern_macros);\n+                    resolution.single_imports.insert(directive);\n                 });\n             }\n             // We don't add prelude imports to the globs since they only affect lexical scopes,\n@@ -640,7 +566,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                 Err(Undetermined) => indeterminate = true,\n                 Err(Determined) => {\n                     this.update_resolution(parent, target, ns, |_, resolution| {\n-                        resolution.single_imports.directive_failed(directive)\n+                        resolution.single_imports.remove(&(directive as *const _));\n                     });\n                 }\n                 Ok(binding) if !binding.is_importable() => {\n@@ -826,7 +752,8 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                                 _ => Some(&i.name),\n                             }\n                         },\n-                        NameResolution { single_imports: SingleImports::None, .. } => None,\n+                        NameResolution { ref single_imports, .. }\n+                            if single_imports.is_empty() => None,\n                         _ => Some(&i.name),\n                     }\n                 });"}]}