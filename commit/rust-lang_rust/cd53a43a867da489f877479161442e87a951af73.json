{"sha": "cd53a43a867da489f877479161442e87a951af73", "node_id": "C_kwDOAAsO6NoAKGNkNTNhNDNhODY3ZGE0ODlmODc3NDc5MTYxNDQyZTg3YTk1MWFmNzM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-14T18:44:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-14T18:44:15Z"}, "message": "Auto merge of #2843 - jsoref:spelling, r=RalfJung\n\nSpelling\n\nThis PR corrects misspellings identified by the [check-spelling action](https://github.com/marketplace/actions/check-spelling).\n\nThe misspellings have been reported at https://github.com/jsoref/miri/actions/runs/4699927237#summary-12751183650\n\nThe action reports that the changes in this PR would make it happy: https://github.com/jsoref/miri/actions/runs/4699927572#summary-12751184493", "tree": {"sha": "9c1a106422a69db8c53cd0957f16542535826d8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c1a106422a69db8c53cd0957f16542535826d8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd53a43a867da489f877479161442e87a951af73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd53a43a867da489f877479161442e87a951af73", "html_url": "https://github.com/rust-lang/rust/commit/cd53a43a867da489f877479161442e87a951af73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd53a43a867da489f877479161442e87a951af73/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf6b8623bc0ad4752dde34fbfce0e41272a51424", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf6b8623bc0ad4752dde34fbfce0e41272a51424", "html_url": "https://github.com/rust-lang/rust/commit/cf6b8623bc0ad4752dde34fbfce0e41272a51424"}, {"sha": "49be529ff5a1de92e07c12984ab8964c47996036", "url": "https://api.github.com/repos/rust-lang/rust/commits/49be529ff5a1de92e07c12984ab8964c47996036", "html_url": "https://github.com/rust-lang/rust/commit/49be529ff5a1de92e07c12984ab8964c47996036"}], "stats": {"total": 154, "additions": 77, "deletions": 77}, "files": [{"sha": "129fec8cc8f71530ff429103e0b4db65326698af", "filename": "src/tools/miri/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FREADME.md?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -403,7 +403,7 @@ to Miri failing to detect cases of undefined behavior in a program.\n * `-Zmiri-retag-fields=<all|none|scalar>` controls when Stacked Borrows retagging recurses into\n   fields. `all` means it always recurses (like `-Zmiri-retag-fields`), `none` means it never\n   recurses, `scalar` (the default) means it only recurses for types where we would also emit\n-  `noalias` annotations in the generated LLVM IR (types passed as indivudal scalars or pairs of\n+  `noalias` annotations in the generated LLVM IR (types passed as individual scalars or pairs of\n   scalars). Setting this to `none` is **unsound**.\n * `-Zmiri-tag-gc=<blocks>` configures how often the pointer tag garbage collector runs. The default\n   is to search for and remove unreachable tags once every `10000` basic blocks. Setting this to"}, {"sha": "85c9cdad7dfd21c52c73b2c87f8e44c4d7fc9db2", "filename": "src/tools/miri/cargo-miri/src/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fcargo-miri%2Fsrc%2Fmain.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -81,7 +81,7 @@ fn main() {\n         \"miri\" => phase_cargo_miri(args),\n         \"runner\" => phase_runner(args, RunnerPhase::Cargo),\n         arg if arg == env::var(\"RUSTC\").unwrap() => {\n-            // If the first arg is equal to the RUSTC env ariable (which should be set at this\n+            // If the first arg is equal to the RUSTC env variable (which should be set at this\n             // point), then we need to behave as rustc. This is the somewhat counter-intuitive\n             // behavior of having both RUSTC and RUSTC_WRAPPER set\n             // (see https://github.com/rust-lang/cargo/issues/10886)."}, {"sha": "cdf06b6a1072662a523961de27f3f34cf45e1d9e", "filename": "src/tools/miri/src/bin/miri.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -120,7 +120,7 @@ impl rustc_driver::Callbacks for MiriBeRustCompilerCalls {\n     #[allow(rustc::potential_query_instability)] // rustc_codegen_ssa (where this code is copied from) also allows this lint\n     fn config(&mut self, config: &mut Config) {\n         if config.opts.prints.is_empty() && self.target_crate {\n-            // Queries overriden here affect the data stored in `rmeta` files of dependencies,\n+            // Queries overridden here affect the data stored in `rmeta` files of dependencies,\n             // which will be used later in non-`MIRI_BE_RUSTC` mode.\n             config.override_queries = Some(|_, local_providers, _| {\n                 // `exported_symbols` and `reachable_non_generics` provided by rustc always returns"}, {"sha": "827dd2b62125e0d0b0617425086d86008479da57", "filename": "src/tools/miri/src/borrow_tracker/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -238,7 +238,7 @@ pub enum BorrowTrackerMethod {\n }\n \n impl BorrowTrackerMethod {\n-    pub fn instanciate_global_state(self, config: &MiriConfig) -> GlobalState {\n+    pub fn instantiate_global_state(self, config: &MiriConfig) -> GlobalState {\n         RefCell::new(GlobalStateInner::new(\n             self,\n             config.tracked_pointer_tags.clone(),"}, {"sha": "c9674e0a2fe2c2a7795b765ade1fb94c1d477ba4", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fdiagnostics.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -292,7 +292,7 @@ impl<'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'history, 'ecx, 'mir, 'tcx> {\n             .rev()\n             .find_map(|event| {\n                 // First, look for a Creation event where the tag and the offset matches. This\n-                // ensrues that we pick the right Creation event when a retag isn't uniform due to\n+                // ensures that we pick the right Creation event when a retag isn't uniform due to\n                 // Freeze.\n                 let range = event.retag.range;\n                 if event.retag.new_tag == tag"}, {"sha": "4d7bbb643b89635e5724da3ba7245185d814fc99", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -433,7 +433,7 @@ impl<'tcx> Stack {\n             let (Some(granting_idx), ProvenanceExtra::Concrete(_)) = (granting_idx, derived_from) else {\n                 // The parent is a wildcard pointer or matched the unknown bottom.\n                 // This is approximate. Nobody knows what happened, so forget everything.\n-                // The new thing is SRW anyway, so we cannot push it \"on top of the unkown part\"\n+                // The new thing is SRW anyway, so we cannot push it \"on top of the unknown part\"\n                 // (for all we know, it might join an SRW group inside the unknown).\n                 trace!(\"reborrow: forgetting stack entirely due to SharedReadWrite reborrow from wildcard or unknown\");\n                 self.set_unknown_bottom(global.next_ptr_tag);\n@@ -825,7 +825,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         Ok(Some(alloc_id))\n     }\n \n-    /// Retags an indidual pointer, returning the retagged version.\n+    /// Retags an individual pointer, returning the retagged version.\n     /// `kind` indicates what kind of reference is being created.\n     fn sb_retag_reference(\n         &mut self,"}, {"sha": "064dbe025af944b38a398c1699020fc2374e8614", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/stack.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fstack.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -51,7 +51,7 @@ impl Stack {\n         // Note that the algorithm below is based on considering the tag at read_idx - 1,\n         // so precisely considering the tag at index 0 for removal when we have an unknown\n         // bottom would complicate the implementation. The simplification of not considering\n-        // it does not have a significant impact on the degree to which the GC mititages\n+        // it does not have a significant impact on the degree to which the GC mitigates\n         // memory growth.\n         let mut read_idx = 1;\n         let mut write_idx = read_idx;"}, {"sha": "f73b2554ad88b2949e18cb242ec243d9e6940a2f", "filename": "src/tools/miri/src/borrow_tracker/tree_borrows/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fmod.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -283,7 +283,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         Ok(Some((alloc_id, new_tag)))\n     }\n \n-    /// Retags an indidual pointer, returning the retagged version.\n+    /// Retags an individual pointer, returning the retagged version.\n     fn tb_retag_reference(\n         &mut self,\n         val: &ImmTy<'tcx, Provenance>,"}, {"sha": "3b4fcfd190be96a8deccca0da6d7758d1a958402", "filename": "src/tools/miri/src/borrow_tracker/tree_borrows/perms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fperms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fperms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fperms.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -113,7 +113,7 @@ mod transition {\n }\n \n impl PermissionPriv {\n-    /// Determines whether a transition that occured is compatible with the presence\n+    /// Determines whether a transition that occurred is compatible with the presence\n     /// of a Protector. This is not included in the `transition` functions because\n     /// it would distract from the few places where the transition is modified\n     /// because of a protector, but not forbidden."}, {"sha": "4477ce0191feeb1f65943c1f58b2b9f2a73dacdb", "filename": "src/tools/miri/src/borrow_tracker/tree_borrows/tree.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Ftree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Ftree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Ftree.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -34,7 +34,7 @@ pub(super) struct LocationState {\n     /// Before initialization we still apply some preemptive transitions on\n     /// `permission` to know what to do in case it ever gets initialized,\n     /// but these can never cause any immediate UB. There can however be UB\n-    /// the moment we attempt to initalize (i.e. child-access) because some\n+    /// the moment we attempt to initialize (i.e. child-access) because some\n     /// foreign access done between the creation and the initialization is\n     /// incompatible with child accesses.\n     initialized: bool,"}, {"sha": "0080d0a9f65c08fc0304e48de22d49bda226ecec", "filename": "src/tools/miri/src/concurrency/data_race.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -1199,7 +1199,7 @@ pub struct GlobalState {\n \n     /// A flag to mark we are currently performing\n     /// a data race free action (such as atomic access)\n-    /// to supress the race detector\n+    /// to suppress the race detector\n     ongoing_action_data_race_free: Cell<bool>,\n \n     /// Mapping of a vector index to a known set of thread"}, {"sha": "47ebf1b38ed69502421fb6d0d173129cea19eea7", "filename": "src/tools/miri/src/concurrency/init_once.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Finit_once.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -151,7 +151,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         assert_eq!(\n             init_once.status,\n             InitOnceStatus::Uninitialized,\n-            \"begining already begun or complete init once\"\n+            \"beginning already begun or complete init once\"\n         );\n         init_once.status = InitOnceStatus::Begun;\n     }"}, {"sha": "89c009933bb03bf798c96bb70334bb5655c1250c", "filename": "src/tools/miri/src/concurrency/range_object_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Frange_object_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Frange_object_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Frange_object_map.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -25,9 +25,9 @@ pub struct RangeObjectMap<T> {\n \n #[derive(Clone, Debug, PartialEq)]\n pub enum AccessType {\n-    /// The access perfectly overlaps (same offset and range) with the exsiting allocation\n+    /// The access perfectly overlaps (same offset and range) with the existing allocation\n     PerfectlyOverlapping(Position),\n-    /// The access does not touch any exising allocation\n+    /// The access does not touch any existing allocation\n     Empty(Position),\n     /// The access overlaps with one or more existing allocations\n     ImperfectlyOverlapping(Range<Position>),\n@@ -115,7 +115,7 @@ impl<T> RangeObjectMap<T> {\n     // want to repeat the binary search on each time, so we ask the caller to supply Position\n     pub fn insert_at_pos(&mut self, pos: Position, range: AllocRange, data: T) {\n         self.v.insert(pos, Elem { range, data });\n-        // If we aren't the first element, then our start must be greater than the preivous element's end\n+        // If we aren't the first element, then our start must be greater than the previous element's end\n         if pos > 0 {\n             assert!(self.v[pos - 1].range.end() <= range.start);\n         }"}, {"sha": "08b13b956e2b5ad162f55aa0b435e08feda716d2", "filename": "src/tools/miri/src/concurrency/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -143,7 +143,7 @@ struct Condvar {\n     waiters: VecDeque<CondvarWaiter>,\n     /// Tracks the happens-before relationship\n     /// between a cond-var signal and a cond-var\n-    /// wait during a non-suprious signal event.\n+    /// wait during a non-spurious signal event.\n     /// Contains the clock of the last thread to\n     /// perform a futex-signal.\n     data_race: VClock,\n@@ -373,7 +373,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 .expect(\"invariant violation: lock_count == 0 iff the thread is unlocked\");\n             if mutex.lock_count == 0 {\n                 mutex.owner = None;\n-                // The mutex is completely unlocked. Try transfering ownership\n+                // The mutex is completely unlocked. Try transferring ownership\n                 // to another thread.\n                 if let Some(data_race) = &this.machine.data_race {\n                     data_race.validate_lock_release("}, {"sha": "0d8d941c19b2379fcd59452b29db6b5ccbf1cf28", "filename": "src/tools/miri/src/concurrency/thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fthread.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -821,7 +821,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n \n         // Write the current thread-id, switch to the next thread later\n-        // to treat this write operation as occuring on the current thread.\n+        // to treat this write operation as occurring on the current thread.\n         if let Some(thread_info_place) = thread {\n             this.write_scalar(\n                 Scalar::from_uint(new_thread_id.to_u32(), thread_info_place.layout.size),\n@@ -830,7 +830,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n \n         // Finally switch to new thread so that we can push the first stackframe.\n-        // After this all accesses will be treated as occuring in the new thread.\n+        // After this all accesses will be treated as occurring in the new thread.\n         let old_thread_id = this.set_active_thread(new_thread_id);\n \n         // Perform the function pointer load in the new thread frame."}, {"sha": "c1395468fee2ee5ab479772506790075d9f06eb6", "filename": "src/tools/miri/src/concurrency/weak_memory.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fweak_memory.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -24,16 +24,16 @@\n //! However, this model lacks SC accesses and is therefore unusable by Miri (SC accesses are everywhere in library code).\n //!\n //! If you find anything that proposes a relaxed memory model that is C++20-consistent, supports all orderings Rust's atomic accesses\n-//! and fences accept, and is implementable (with operational semanitcs), please open a GitHub issue!\n+//! and fences accept, and is implementable (with operational semantics), please open a GitHub issue!\n //!\n //! One characteristic of this implementation, in contrast to some other notable operational models such as ones proposed in\n //! Taming Release-Acquire Consistency by Ori Lahav et al. (<https://plv.mpi-sws.org/sra/paper.pdf>) or Promising Semantics noted above,\n //! is that this implementation does not require each thread to hold an isolated view of the entire memory. Here, store buffers are per-location\n //! and shared across all threads. This is more memory efficient but does require store elements (representing writes to a location) to record\n //! information about reads, whereas in the other two models it is the other way round: reads points to the write it got its value from.\n //! Additionally, writes in our implementation do not have globally unique timestamps attached. In the other two models this timestamp is\n-//! used to make sure a value in a thread's view is not overwritten by a write that occured earlier than the one in the existing view.\n-//! In our implementation, this is detected using read information attached to store elements, as there is no data strucutre representing reads.\n+//! used to make sure a value in a thread's view is not overwritten by a write that occurred earlier than the one in the existing view.\n+//! In our implementation, this is detected using read information attached to store elements, as there is no data structure representing reads.\n //!\n //! The C++ memory model is built around the notion of an 'atomic object', so it would be natural\n //! to attach store buffers to atomic objects. However, Rust follows LLVM in that it only has\n@@ -48,7 +48,7 @@\n //! One consequence of this difference is that safe/sound Rust allows for more operations on atomic locations\n //! than the C++20 atomic API was intended to allow, such as non-atomically accessing\n //! a previously atomically accessed location, or accessing previously atomically accessed locations with a differently sized operation\n-//! (such as accessing the top 16 bits of an AtomicU32). These senarios are generally undiscussed in formalisations of C++ memory model.\n+//! (such as accessing the top 16 bits of an AtomicU32). These scenarios are generally undiscussed in formalisations of C++ memory model.\n //! In Rust, these operations can only be done through a `&mut AtomicFoo` reference or one derived from it, therefore these operations\n //! can only happen after all previous accesses on the same locations. This implementation is adapted to allow these operations.\n //! A mixed atomicity read that races with writes, or a write that races with reads or writes will still cause UBs to be thrown.\n@@ -61,7 +61,7 @@\n //\n // 2. In the operational semantics, each store element keeps the timestamp of a thread when it loads from the store.\n // If the same thread loads from the same store element multiple times, then the timestamps at all loads are saved in a list of load elements.\n-// This is not necessary as later loads by the same thread will always have greater timetstamp values, so we only need to record the timestamp of the first\n+// This is not necessary as later loads by the same thread will always have greater timestamp values, so we only need to record the timestamp of the first\n // load by each thread. This optimisation is done in tsan11\n // (https://github.com/ChrisLidbury/tsan11/blob/ecbd6b81e9b9454e01cba78eb9d88684168132c7/lib/tsan/rtl/tsan_relaxed.h#L35-L37)\n // and here.\n@@ -193,7 +193,7 @@ impl StoreBufferAlloc {\n                     buffers.remove_pos_range(pos_range);\n                 }\n                 AccessType::Empty(_) => {\n-                    // The range had no weak behaivours attached, do nothing\n+                    // The range had no weak behaviours attached, do nothing\n                 }\n             }\n         }\n@@ -336,7 +336,7 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n         let mut found_sc = false;\n         // FIXME: we want an inclusive take_while (stops after a false predicate, but\n         // includes the element that gave the false), but such function doesn't yet\n-        // exist in the standard libary https://github.com/rust-lang/rust/issues/62208\n+        // exist in the standard library https://github.com/rust-lang/rust/issues/62208\n         // so we have to hack around it with keep_searching\n         let mut keep_searching = true;\n         let candidates = self"}, {"sha": "430229c132d5e969d38a4f574080d8b2bb3e25ad", "filename": "src/tools/miri/src/eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -372,7 +372,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n \n             // Inlining of `DEFAULT` from\n             // https://github.com/rust-lang/rust/blob/master/compiler/rustc_session/src/config/sigpipe.rs.\n-            // Alaways using DEFAULT is okay since we don't support signals in Miri anyway.\n+            // Always using DEFAULT is okay since we don't support signals in Miri anyway.\n             let sigpipe = 2;\n \n             ecx.call_function(\n@@ -456,7 +456,7 @@ pub fn eval_entry<'tcx>(\n             return None;\n         }\n         // Check for memory leaks.\n-        info!(\"Additonal static roots: {:?}\", ecx.machine.static_roots);\n+        info!(\"Additional static roots: {:?}\", ecx.machine.static_roots);\n         let leaks = ecx.leak_report(&ecx.machine.static_roots);\n         if leaks != 0 {\n             tcx.sess.err(\"the evaluated program leaked memory\");"}, {"sha": "a2b49e6f219d37216df75be725fa16883879b388", "filename": "src/tools/miri/src/helpers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -524,7 +524,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 }\n             }\n \n-            // Make sure we visit aggregrates in increasing offset order.\n+            // Make sure we visit aggregates in increasing offset order.\n             fn visit_aggregate(\n                 &mut self,\n                 place: &MPlaceTy<'tcx, Provenance>,"}, {"sha": "4fd0af35304ec7f58359299dc187ca7a20db8c3d", "filename": "src/tools/miri/src/intptrcast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -77,7 +77,7 @@ impl<'mir, 'tcx> GlobalStateInner {\n             Ok(pos) => Some(global_state.int_to_ptr_map[pos].1),\n             Err(0) => None,\n             Err(pos) => {\n-                // This is the largest of the adresses smaller than `int`,\n+                // This is the largest of the addresses smaller than `int`,\n                 // i.e. the greatest lower bound (glb)\n                 let (glb, alloc_id) = global_state.int_to_ptr_map[pos - 1];\n                 // This never overflows because `addr >= glb`"}, {"sha": "176e3758a6b51095d4f2c4347f2a9d17bb42a797", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -491,9 +491,9 @@ impl<'mir, 'tcx> MiriMachine<'mir, 'tcx> {\n             measureme::Profiler::new(out).expect(\"Couldn't create `measureme` profiler\")\n         });\n         let rng = StdRng::seed_from_u64(config.seed.unwrap_or(0));\n-        let borrow_tracker = config.borrow_tracker.map(|bt| bt.instanciate_global_state(config));\n+        let borrow_tracker = config.borrow_tracker.map(|bt| bt.instantiate_global_state(config));\n         let data_race = config.data_race_detector.then(|| data_race::GlobalState::new(config));\n-        // Determinine page size, stack address, and stack size.\n+        // Determine page size, stack address, and stack size.\n         // These values are mostly meaningless, but the stack address is also where we start\n         // allocating physical integer addresses for all allocations.\n         let page_size = if let Some(page_size) = config.page_size {"}, {"sha": "d101f8d3111d08be1ee1b8355d18108c4ff31c8d", "filename": "src/tools/miri/src/shims/intrinsics/simd.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fintrinsics%2Fsimd.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -585,9 +585,9 @@ fn simd_element_to_bool(elem: ImmTy<'_, Provenance>) -> InterpResult<'_, bool> {\n     })\n }\n \n-fn simd_bitmask_index(idx: u32, vec_len: u32, endianess: Endian) -> u32 {\n+fn simd_bitmask_index(idx: u32, vec_len: u32, endianness: Endian) -> u32 {\n     assert!(idx < vec_len);\n-    match endianess {\n+    match endianness {\n         Endian::Little => idx,\n         #[allow(clippy::integer_arithmetic)] // idx < vec_len\n         Endian::Big => vec_len - 1 - idx, // reverse order of bits"}, {"sha": "6bc5b8f39d5f06b2a6dfff8f504dadd7387f8332", "filename": "src/tools/miri/src/shims/os_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fos_str.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -329,7 +329,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             match direction {\n                 PathConversion::HostToTarget => {\n                     // If this start withs a `\\`, we add `\\\\?` so it starts with `\\\\?\\` which is\n-                    // some magic path on Windos that *is* considered absolute.\n+                    // some magic path on Windows that *is* considered absolute.\n                     if converted.get(0).copied() == Some(b'\\\\') {\n                         converted.splice(0..0, b\"\\\\\\\\?\".iter().copied());\n                     }"}, {"sha": "2f24c00ce14b365c6067b63a4104ff6f975b1451", "filename": "src/tools/miri/src/shims/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftime.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -40,7 +40,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     this.eval_libc_i32(\"CLOCK_REALTIME_COARSE\"),\n                 ];\n                 // The second kind is MONOTONIC clocks for which 0 is an arbitrary time point, but they are\n-                // never allowed to go backwards. We don't need to do any additonal monotonicity\n+                // never allowed to go backwards. We don't need to do any additional monotonicity\n                 // enforcement because std::time::Instant already guarantees that it is monotonic.\n                 relative_clocks = vec![\n                     this.eval_libc_i32(\"CLOCK_MONOTONIC\"),"}, {"sha": "685feeaf892f2812ec8aee93c5bda409c380a05f", "filename": "src/tools/miri/src/shims/tls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Ftls.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -79,7 +79,7 @@ impl<'tcx> TlsData<'tcx> {\n                 trace!(\"TLS key {} removed\", key);\n                 Ok(())\n             }\n-            None => throw_ub_format!(\"removing a non-existig TLS key: {}\", key),\n+            None => throw_ub_format!(\"removing a nonexistent TLS key: {}\", key),\n         }\n     }\n \n@@ -175,7 +175,7 @@ impl<'tcx> TlsData<'tcx> {\n             Some(key) => Excluded(key),\n             None => Unbounded,\n         };\n-        // We interpret the documentaion above (taken from POSIX) as saying that we need to iterate\n+        // We interpret the documentation above (taken from POSIX) as saying that we need to iterate\n         // over all keys and run each destructor at least once before running any destructor a 2nd\n         // time. That's why we have `key` to indicate how far we got in the current iteration. If we\n         // return `None`, `schedule_next_pthread_tls_dtor` will re-try with `ket` set to `None` to"}, {"sha": "385fa366b205fb285f3e9343d2bce84b0fb25766", "filename": "src/tools/miri/src/shims/unix/fs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Ffs.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -1015,8 +1015,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         let path = this.read_path_from_c_str(pathname_ptr)?.into_owned();\n         // See <https://github.com/rust-lang/rust/pull/79196> for a discussion of argument sizes.\n-        let at_ampty_path = this.eval_libc_i32(\"AT_EMPTY_PATH\");\n-        let empty_path_flag = flags & at_ampty_path == at_ampty_path;\n+        let at_empty_path = this.eval_libc_i32(\"AT_EMPTY_PATH\");\n+        let empty_path_flag = flags & at_empty_path == at_empty_path;\n         // We only support:\n         // * interpreting `path` as an absolute directory,\n         // * interpreting `path` as a path relative to `dirfd` when the latter is `AT_FDCWD`, or\n@@ -1053,7 +1053,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             return Ok(-1);\n         }\n \n-        // the `_mask_op` paramter specifies the file information that the caller requested.\n+        // the `_mask_op` parameter specifies the file information that the caller requested.\n         // However `statx` is allowed to return information that was not requested or to not\n         // return information that was requested. This `mask` represents the information we can\n         // actually provide for any target."}, {"sha": "4cb7ee8efca7c27beaf90a1a19eb133dec6b3cd0", "filename": "src/tools/miri/src/shims/unix/linux/foreign_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Flinux%2Fforeign_items.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -169,7 +169,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                             this.linux_statx(&args[1], &args[2], &args[3], &args[4], &args[5])?;\n                         this.write_scalar(Scalar::from_target_isize(result.into(), this), dest)?;\n                     }\n-                    // `futex` is used by some synchonization primitives.\n+                    // `futex` is used by some synchronization primitives.\n                     id if id == sys_futex => {\n                         futex(this, &args[1..], dest)?;\n                     }\n@@ -180,7 +180,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 }\n             }\n \n-            // Miscelanneous\n+            // Miscellaneous\n             \"getrandom\" => {\n                 let [ptr, len, flags] =\n                     this.check_shim(abi, Abi::C { unwind: false }, link_name, args)?;"}, {"sha": "05feeac45b5c1ae60c0867723b99904b48d969c4", "filename": "src/tools/miri/src/shims/unix/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -242,7 +242,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             //\n             // To distinguish these two cases in already constructed mutexes, we\n             // use the same trick as glibc: for the case when\n-            // `pthread_mutexattr_settype` is caled explicitly, we set the\n+            // `pthread_mutexattr_settype` is called explicitly, we set the\n             // `PTHREAD_MUTEX_NORMAL_FLAG` flag.\n             let normal_kind = kind | PTHREAD_MUTEX_NORMAL_FLAG;\n             // Check that after setting the flag, the kind is distinguishable"}, {"sha": "f72ba5cca7a02ea886b3cfce39cb9013343fe24a", "filename": "src/tools/miri/src/shims/windows/foreign_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -96,7 +96,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n                 if byte_offset != 0 {\n                     throw_unsup_format!(\n-                        \"`NtWriteFile` `ByteOffset` paremeter is non-null, which is unsupported\"\n+                        \"`NtWriteFile` `ByteOffset` parameter is non-null, which is unsupported\"\n                     );\n                 }\n "}, {"sha": "e11d8937fe40449929e6e6776187743df89aee97", "filename": "src/tools/miri/tests/fail/intrinsics/exact_div1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fexact_div1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fexact_div1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fexact_div1.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -1,5 +1,5 @@\n #![feature(core_intrinsics)]\n fn main() {\n-    // divison by 0\n+    // division by 0\n     unsafe { std::intrinsics::exact_div(2, 0) }; //~ ERROR: divisor of zero\n }"}, {"sha": "7914de403a7585fb275abb4d384daecbee718b76", "filename": "src/tools/miri/tests/fail/intrinsics/exact_div2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fexact_div2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fexact_div2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fexact_div2.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -1,5 +1,5 @@\n #![feature(core_intrinsics)]\n fn main() {\n-    // divison with a remainder\n+    // division with a remainder\n     unsafe { std::intrinsics::exact_div(2u16, 3) }; //~ ERROR: 2_u16 cannot be divided by 3_u16 without remainder\n }"}, {"sha": "50ee538646578277d22d48b35f13fcbad4d371f7", "filename": "src/tools/miri/tests/fail/intrinsics/exact_div3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fexact_div3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fexact_div3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fexact_div3.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -1,5 +1,5 @@\n #![feature(core_intrinsics)]\n fn main() {\n-    // signed divison with a remainder\n+    // signed division with a remainder\n     unsafe { std::intrinsics::exact_div(-19i8, 2) }; //~ ERROR: -19_i8 cannot be divided by 2_i8 without remainder\n }"}, {"sha": "48c55208238c43151dd529c62684c8bf166b9941", "filename": "src/tools/miri/tests/fail/intrinsics/exact_div4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fexact_div4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fexact_div4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fintrinsics%2Fexact_div4.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -1,5 +1,5 @@\n #![feature(core_intrinsics)]\n fn main() {\n-    // divison of MIN by -1\n+    // division of MIN by -1\n     unsafe { std::intrinsics::exact_div(i64::MIN, -1) }; //~ ERROR: overflow in signed remainder (dividing MIN by -1)\n }"}, {"sha": "9c0c974223b72361c40acfd65fafc2900f0f6e29", "filename": "src/tools/miri/tests/fail/stacked_borrows/illegal_read3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fillegal_read3.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -1,5 +1,5 @@\n // A callee may not read the destination of our `&mut` without us noticing.\n-// Thise code got carefully checked to not introduce any reborrows\n+// This code got carefully checked to not introduce any reborrows\n // that are not explicit in the source. Let's hope the compiler does not break this later!\n \n use std::mem;"}, {"sha": "ed43e552506d9e632b80d83942709158c3fedc02", "filename": "src/tools/miri/tests/fail/unaligned_pointers/intptrcast_alignment_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funaligned_pointers%2Fintptrcast_alignment_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funaligned_pointers%2Fintptrcast_alignment_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Funaligned_pointers%2Fintptrcast_alignment_check.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -1,7 +1,7 @@\n //@compile-flags: -Zmiri-symbolic-alignment-check -Zmiri-permissive-provenance -Cdebug-assertions=no\n // With the symbolic alignment check, even with intptrcast and without\n // validation, we want to be *sure* to catch bugs that arise from pointers being\n-// insufficiently aligned. The only way to achieve that is not not let programs\n+// insufficiently aligned. The only way to achieve that is not to let programs\n // exploit integer information for alignment, so here we test that this is\n // indeed the case.\n //"}, {"sha": "ae874740f2bc301dac48113b47b2ab538e4d117c", "filename": "src/tools/miri/tests/pass-dep/concurrency/tls_pthread_drop_order.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fconcurrency%2Ftls_pthread_drop_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fconcurrency%2Ftls_pthread_drop_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fconcurrency%2Ftls_pthread_drop_order.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -14,7 +14,7 @@ static mut RECORD: usize = 0;\n static mut KEYS: [Key; 2] = [0; 2];\n static mut GLOBALS: [u64; 2] = [1, 0];\n \n-static mut CANNARY: *mut u64 = ptr::null_mut(); // this serves as a cannary: if TLS dtors are not run properly, this will not get deallocated, making the test fail.\n+static mut CANARY: *mut u64 = ptr::null_mut(); // this serves as a canary: if TLS dtors are not run properly, this will not get deallocated, making the test fail.\n \n pub unsafe fn create(dtor: Option<unsafe extern \"C\" fn(*mut u8)>) -> Key {\n     let mut key = 0;\n@@ -33,7 +33,7 @@ pub fn record(r: usize) {\n }\n \n unsafe extern \"C\" fn dtor(ptr: *mut u64) {\n-    assert!(CANNARY != ptr::null_mut()); // make sure we do not get run too often\n+    assert!(CANARY != ptr::null_mut()); // make sure we do not get run too often\n     let val = *ptr;\n \n     let which_key =\n@@ -45,15 +45,15 @@ unsafe extern \"C\" fn dtor(ptr: *mut u64) {\n         set(KEYS[which_key], ptr as *mut _);\n     }\n \n-    // Check if the records matches what we expect. If yes, clear the cannary.\n-    // If the record is wrong, the cannary will never get cleared, leading to a leak -> test fails.\n+    // Check if the records matches what we expect. If yes, clear the canary.\n+    // If the record is wrong, the canary will never get cleared, leading to a leak -> test fails.\n     // If the record is incomplete (i.e., more dtor calls happen), the check at the beginning of this function will fail -> test fails.\n     // The correct sequence is: First key 0, then key 1, then key 0.\n     // Note that this relies on dtor order, which is not specified by POSIX, but seems to be\n     // consistent between Miri and Linux currently (as of Aug 2022).\n     if RECORD == 0_1_0 {\n-        drop(Box::from_raw(CANNARY));\n-        CANNARY = ptr::null_mut();\n+        drop(Box::from_raw(CANARY));\n+        CANARY = ptr::null_mut();\n     }\n }\n \n@@ -67,7 +67,7 @@ fn main() {\n             set(*key, global as *mut _ as *mut u8);\n         }\n \n-        // Initialize cannary\n-        CANNARY = Box::into_raw(Box::new(0u64));\n+        // Initialize canary\n+        CANARY = Box::into_raw(Box::new(0u64));\n     }\n }"}, {"sha": "fbdf27688a9c83331dec4eb3423aae418c975dd4", "filename": "src/tools/miri/tests/pass-dep/shims/libc-fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-fs.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -130,7 +130,7 @@ fn test_readlink() {\n     let mut large_buf = vec![0xFF; expected_path.len() + 1];\n     let res =\n         unsafe { libc::readlink(symlink_c_ptr, large_buf.as_mut_ptr().cast(), large_buf.len()) };\n-    // Check that the resovled path was properly written into the buf.\n+    // Check that the resolved path was properly written into the buf.\n     assert_eq!(&large_buf[..(large_buf.len() - 1)], expected_path);\n     assert_eq!(large_buf.last(), Some(&0xFF));\n     assert_eq!(res, large_buf.len() as isize - 1);"}, {"sha": "82ef59427ae837822d052338f4b39050463079db", "filename": "src/tools/miri/tests/pass-dep/shims/libc-misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-misc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-misc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass-dep%2Fshims%2Flibc-misc.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -90,7 +90,7 @@ fn test_posix_realpath_errors() {\n     use std::ffi::CString;\n     use std::io::ErrorKind;\n \n-    // Test non-existent path returns an error.\n+    // Test nonexistent path returns an error.\n     let c_path = CString::new(\"./nothing_to_see_here\").expect(\"CString::new failed\");\n     let r = unsafe { libc::realpath(c_path.as_ptr(), std::ptr::null_mut()) };\n     assert!(r.is_null());"}, {"sha": "3a531eede67fae11c85dd3888aa787cd477a4a81", "filename": "src/tools/miri/tests/pass/0weak_memory_consistency.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass%2F0weak_memory_consistency.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass%2F0weak_memory_consistency.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2F0weak_memory_consistency.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -10,7 +10,7 @@\n // the RNG and never observed in our tests.\n //\n // To mitigate this, each test is ran enough times such that the chance\n-// of spurious success is very low. These tests never supriously fail.\n+// of spurious success is very low. These tests never spuriously fail.\n \n // Test cases and their consistent outcomes are from\n // http://svr-pes20-cppmem.cl.cam.ac.uk/cppmem/"}, {"sha": "6be13b155f41001f3380082bbdb1c5a6b2e93562", "filename": "src/tools/miri/tests/pass/dyn-arbitrary-self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fdyn-arbitrary-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fdyn-arbitrary-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fdyn-arbitrary-self.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -93,7 +93,7 @@ fn pointers_and_wrappers() {\n \n     trait Trait {\n         // This method isn't object-safe yet. Unsized by-value `self` is object-safe (but not callable\n-        // without unsized_locals), but wrappers arond `Self` currently are not.\n+        // without unsized_locals), but wrappers around `Self` currently are not.\n         // FIXME (mikeyhew) uncomment this when unsized rvalues object-safety is implemented\n         // fn wrapper(self: Wrapper<Self>) -> i32;\n         fn ptr_wrapper(self: Ptr<Wrapper<Self>>) -> i32;"}, {"sha": "9a40c322b366e22bb40b7d01bfe4121ff173a24a", "filename": "src/tools/miri/tests/pass/global_allocator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fglobal_allocator.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -19,7 +19,7 @@ unsafe impl GlobalAlloc for Allocator {\n \n     unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n         if layout.size() == 123 {\n-            println!(\"Dellocated!\")\n+            println!(\"Deallocated!\")\n         }\n \n         System.dealloc(ptr, layout)"}, {"sha": "30c61946407c92271044bc03a6c644cec5a4a8e0", "filename": "src/tools/miri/tests/pass/global_allocator.stdout", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fglobal_allocator.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fglobal_allocator.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fglobal_allocator.stdout?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -1,2 +1,2 @@\n Allocated!\n-Dellocated!\n+Deallocated!"}, {"sha": "6b971c5217b7b326f2b335816521d8ffa7c32c1f", "filename": "src/tools/miri/tests/pass/issues/issue-29746.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fissues%2Fissue-29746.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fissues%2Fissue-29746.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fissues%2Fissue-29746.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -7,7 +7,7 @@ macro_rules! zip {\n     };\n \n     // Intermediate steps to build the zipped expression, the match pattern, and\n-    //  and the output tuple of the closure, using macro hygene to repeatedly\n+    //  and the output tuple of the closure, using macro hygiene to repeatedly\n     //  introduce new variables named 'x'.\n     ([$a:expr, $($rest:expr),*], $zip:expr, $pat:pat, [$($flat:expr),*]) => {\n         zip!([$($rest),*], $zip.zip($a), ($pat,x), [$($flat),*, x])"}, {"sha": "0b06167aec21190b922f19cf02a6862aaab1dfa3", "filename": "src/tools/miri/tests/pass/packed_struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpacked_struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpacked_struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpacked_struct.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -36,7 +36,7 @@ fn test_basic() {\n     let b = x.b;\n     assert_eq!(a, 42);\n     assert_eq!(b, 99);\n-    assert_eq!(&x.fill, &0); // `fill` just requirs 1-byte-align, so this is fine\n+    assert_eq!(&x.fill, &0); // `fill` just requires 1-byte-align, so this is fine\n     // can't do `assert_eq!(x.a, 42)`, because `assert_eq!` takes a reference\n     assert_eq!({ x.a }, 42);\n     assert_eq!({ x.b }, 99);"}, {"sha": "92b275b00327dc0bf29cc1113ea532a11198c4ea", "filename": "src/tools/miri/tests/pass/ptr_offset.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fptr_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fptr_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fptr_offset.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -63,7 +63,7 @@ fn ptr_arith_offset_overflow() {\n     let v = [1i16, 2];\n     let x = &mut ptr::null(); // going through memory as there are more sanity checks along that path\n     *x = v.as_ptr().wrapping_offset(1); // ptr to the 2nd element\n-    // Adding 2*isize::max and then 1 is like substracting 1\n+    // Adding 2*isize::max and then 1 is like subtracting 1\n     *x = x.wrapping_offset(isize::MAX);\n     *x = x.wrapping_offset(isize::MAX);\n     *x = x.wrapping_offset(1);"}, {"sha": "8f1ef1b75cfc4c1a11bce14874c6f6f5a2d0a169", "filename": "src/tools/miri/tests/pass/rfc1623.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Frfc1623.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Frfc1623.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Frfc1623.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -58,7 +58,7 @@ fn main() {\n     STATIC_SIMPLE_FN(x);\n     CONST_SIMPLE_FN(x);\n \n-    STATIC_BAZ(BYTES); // neees static lifetime\n+    STATIC_BAZ(BYTES); // needs static lifetime\n     CONST_BAZ(BYTES);\n \n     // make sure this works with different lifetimes"}, {"sha": "af245aa89aa36b1a732ab621c29a1a3fb0851085", "filename": "src/tools/miri/tests/pass/shims/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fshims%2Ffs.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -365,7 +365,7 @@ fn test_directory() {\n \n     // Deleting the directory should succeed.\n     remove_dir(&dir_path).unwrap();\n-    // Reading the metadata of a non-existent directory should fail with a \"not found\" error.\n+    // Reading the metadata of a nonexistent directory should fail with a \"not found\" error.\n     assert_eq!(ErrorKind::NotFound, check_metadata(&[], &dir_path).unwrap_err().kind());\n \n     // To test remove_dir_all, re-create the directory with a file and a directory in it."}, {"sha": "d7d7d1f97d6e5e924b91b094dfd5d53922d25223", "filename": "src/tools/miri/tests/pass/stacked-borrows/stacked-borrows.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstacked-borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstacked-borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstacked-borrows.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -90,7 +90,7 @@ fn mut_raw_mut() {\n         assert_eq!(unsafe { *xraw }, 4);\n         assert_eq!(*xref1, 4);\n         assert_eq!(unsafe { *xraw }, 4);\n-        // we cannot use xref2; see `compile-fail/stacked-borows/illegal_read4.rs`\n+        // we cannot use xref2; see `compile-fail/stacked-borrows/illegal_read4.rs`\n     }\n     assert_eq!(x, 4);\n }\n@@ -104,7 +104,7 @@ fn partially_invalidate_mut() {\n     assert_eq!(*data, (1, 1));\n }\n \n-// Make sure that we can handle the situation where a loaction is frozen when being dropped.\n+// Make sure that we can handle the situation where a location is frozen when being dropped.\n fn drop_after_sharing() {\n     let x = String::from(\"hello!\");\n     let _len = x.len();\n@@ -224,7 +224,7 @@ fn wide_raw_ptr_in_tuple() {\n fn not_unpin_not_protected() {\n     // `&mut !Unpin`, at least for now, does not get `noalias` nor `dereferenceable`, so we also\n     // don't add protectors. (We could, but until we have a better idea for where we want to go with\n-    // the self-referntial-generator situation, it does not seem worth the potential trouble.)\n+    // the self-referential-generator situation, it does not seem worth the potential trouble.)\n     use std::marker::PhantomPinned;\n \n     pub struct NotUnpin(i32, PhantomPinned);"}, {"sha": "72cdbe7ed5d6baa6cbc80532fb5834b17999d6a2", "filename": "src/tools/miri/tests/pass/strings.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstrings.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -29,7 +29,7 @@ fn unique_aliasing() {\n     // This is a regression test for the aliasing rules of a `Unique<T>` pointer.\n     // At the time of writing this test case, Miri does not treat `Unique<T>`\n     // pointers as a special case, these are treated like any other raw pointer.\n-    // However, there are existing Github issues which may lead to `Unique<T>`\n+    // However, there are existing GitHub issues which may lead to `Unique<T>`\n     // becoming a special case through asserting unique ownership over the pointee:\n     // - https://github.com/rust-lang/unsafe-code-guidelines/issues/258\n     // - https://github.com/rust-lang/unsafe-code-guidelines/issues/262"}, {"sha": "94df730808066aab85971a2ebdff4d37a15774a8", "filename": "src/tools/miri/tests/pass/weak_memory/extra_cpp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fweak_memory%2Fextra_cpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fweak_memory%2Fextra_cpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fweak_memory%2Fextra_cpp.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -1,6 +1,6 @@\n //@compile-flags: -Zmiri-ignore-leaks\n \n-// Tests operations not perfomable through C++'s atomic API\n+// Tests operations not performable through C++'s atomic API\n // but doable in safe (at least sound) Rust.\n \n #![feature(atomic_from_mut)]"}, {"sha": "48b15191b38b0fc1229ee09704e9c459831325ba", "filename": "src/tools/miri/tests/pass/weak_memory/extra_cpp_unsafe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fweak_memory%2Fextra_cpp_unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53a43a867da489f877479161442e87a951af73/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fweak_memory%2Fextra_cpp_unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fweak_memory%2Fextra_cpp_unsafe.rs?ref=cd53a43a867da489f877479161442e87a951af73", "patch": "@@ -1,6 +1,6 @@\n //@compile-flags: -Zmiri-ignore-leaks\n \n-// Tests operations not perfomable through C++'s atomic API\n+// Tests operations not performable through C++'s atomic API\n // but doable in unsafe Rust which we think *should* be fine.\n // Nonetheless they may be determined as inconsistent with the\n // memory model in the future."}]}