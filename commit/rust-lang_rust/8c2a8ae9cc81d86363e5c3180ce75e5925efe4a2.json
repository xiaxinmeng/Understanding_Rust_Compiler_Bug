{"sha": "8c2a8ae9cc81d86363e5c3180ce75e5925efe4a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjMmE4YWU5Y2M4MWQ4NjM2M2U1YzMxODBjZTc1ZTU5MjVlZmU0YTI=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-04-03T22:32:37Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-04-03T22:32:37Z"}, "message": "Give better spans for SpanEnd errors", "tree": {"sha": "a537f163169526418b0914e10550018e83b54a4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a537f163169526418b0914e10550018e83b54a4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c2a8ae9cc81d86363e5c3180ce75e5925efe4a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c2a8ae9cc81d86363e5c3180ce75e5925efe4a2", "html_url": "https://github.com/rust-lang/rust/commit/8c2a8ae9cc81d86363e5c3180ce75e5925efe4a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c2a8ae9cc81d86363e5c3180ce75e5925efe4a2/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8b8eb1fda90998832ba1cdf96a34dc676f7124b", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8b8eb1fda90998832ba1cdf96a34dc676f7124b", "html_url": "https://github.com/rust-lang/rust/commit/c8b8eb1fda90998832ba1cdf96a34dc676f7124b"}], "stats": {"total": 75, "additions": 60, "deletions": 15}, "files": [{"sha": "f369582bc5c30f674c5a8fe78462ab9345a520d0", "filename": "src/libsyntax/errors/json.rs", "status": "modified", "additions": 60, "deletions": 15, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/8c2a8ae9cc81d86363e5c3180ce75e5925efe4a2/src%2Flibsyntax%2Ferrors%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2a8ae9cc81d86363e5c3180ce75e5925efe4a2/src%2Flibsyntax%2Ferrors%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Fjson.rs?ref=8c2a8ae9cc81d86363e5c3180ce75e5925efe4a2", "patch": "@@ -20,7 +20,7 @@\n // FIXME spec the JSON output properly.\n \n \n-use codemap::{Span, MultiSpan, CodeMap};\n+use codemap::{self, Span, MultiSpan, CodeMap};\n use diagnostics::registry::Registry;\n use errors::{Level, DiagnosticBuilder, SubDiagnostic, RenderSpan, CodeSuggestion};\n use errors::emitter::Emitter;\n@@ -197,8 +197,8 @@ impl DiagnosticSpan {\n \n     fn from_render_span(rsp: &RenderSpan, je: &JsonEmitter) -> Vec<DiagnosticSpan> {\n         match *rsp {\n-            // FIXME(#30701) handle Suggestion properly\n             RenderSpan::FullSpan(ref msp) |\n+            // FIXME(#30701) handle Suggestion properly\n             RenderSpan::Suggestion(CodeSuggestion { ref msp, .. }) => {\n                 DiagnosticSpan::from_multispan(msp, je)\n             }\n@@ -207,13 +207,13 @@ impl DiagnosticSpan {\n                     let end = je.cm.lookup_char_pos(span.hi);\n                     DiagnosticSpan {\n                         file_name: end.file.name.clone(),\n-                        byte_start: span.lo.0,\n+                        byte_start: span.hi.0,\n                         byte_end: span.hi.0,\n-                        line_start: 0,\n+                        line_start: end.line,\n                         line_end: end.line,\n-                        column_start: 0,\n+                        column_start: end.col.0 + 1,\n                         column_end: end.col.0 + 1,\n-                        text: DiagnosticSpanLine::from_span(span, je),\n+                        text: DiagnosticSpanLine::from_span_end(span, je),\n                     }\n                 }).collect()\n             }\n@@ -237,25 +237,70 @@ impl DiagnosticSpan {\n     }\n }\n \n-impl DiagnosticSpanLine {\n-    fn from_span(span: &Span, je: &JsonEmitter) -> Vec<DiagnosticSpanLine> {\n-        let lines = match je.cm.span_to_lines(*span) {\n+macro_rules! get_lines_for_span {\n+    ($span: ident, $je: ident) => {\n+        match $je.cm.span_to_lines(*$span) {\n             Ok(lines) => lines,\n             Err(_) => {\n                 debug!(\"unprintable span\");\n                 return Vec::new();\n             }\n-        };\n+        }\n+    }\n+}\n+\n+impl DiagnosticSpanLine {\n+    fn line_from_filemap(fm: &codemap::FileMap,\n+                         index: usize,\n+                         h_start: usize,\n+                         h_end: usize)\n+                         -> DiagnosticSpanLine {\n+        DiagnosticSpanLine {\n+            text: fm.get_line(index).unwrap().to_owned(),\n+            highlight_start: h_start,\n+            highlight_end: h_end,\n+        }\n+    }\n+\n+    /// Create a list of DiagnosticSpanLines from span - each line with any part\n+    /// of `span` gets a DiagnosticSpanLine, with the highlight indicating the\n+    /// `span` within the line.\n+    fn from_span(span: &Span, je: &JsonEmitter) -> Vec<DiagnosticSpanLine> {\n+        let lines = get_lines_for_span!(span, je);\n \n         let mut result = Vec::new();\n         let fm = &*lines.file;\n \n         for line in &lines.lines {\n-            result.push(DiagnosticSpanLine {\n-                text: fm.get_line(line.line_index).unwrap().to_owned(),\n-                highlight_start: line.start_col.0 + 1,\n-                highlight_end: line.end_col.0 + 1,\n-            });\n+            result.push(DiagnosticSpanLine::line_from_filemap(fm,\n+                                                              line.line_index,\n+                                                              line.start_col.0 + 1,\n+                                                              line.end_col.0 + 1));\n+        }\n+\n+        result\n+    }\n+\n+    /// Create a list of DiagnosticSpanLines from span - the result covers all\n+    /// of `span`, but the highlight is zero-length and at the end of `span`.\n+    fn from_span_end(span: &Span, je: &JsonEmitter) -> Vec<DiagnosticSpanLine> {\n+        let lines = get_lines_for_span!(span, je);\n+\n+        let mut result = Vec::new();\n+        let fm = &*lines.file;\n+\n+        for (i, line) in lines.lines.iter().enumerate() {\n+            // Invariant - CodeMap::span_to_lines will not return extra context\n+            // lines - the last line returned is the last line of `span`.\n+            let highlight = if i == lines.lines.len() - 1 {\n+                (line.end_col.0 + 1, line.end_col.0 + 1)\n+            } else {\n+                (0, 0)\n+            };\n+            result.push(DiagnosticSpanLine::line_from_filemap(fm,\n+                                                              line.line_index,\n+                                                              highlight.0,\n+                                                              highlight.1));\n         }\n \n         result"}]}