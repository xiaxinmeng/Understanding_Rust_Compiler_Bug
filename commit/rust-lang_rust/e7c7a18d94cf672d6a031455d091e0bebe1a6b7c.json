{"sha": "e7c7a18d94cf672d6a031455d091e0bebe1a6b7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3YzdhMThkOTRjZjY3MmQ2YTAzMTQ1NWQwOTFlMGJlYmUxYTZiN2M=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-04-20T18:57:20Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-05-02T15:47:10Z"}, "message": "adapt JSON to new model\n\nEach Span now carries a `is_primary` boolean along with an optional\nlabel. If there are multiple labels for a span, it will appear multiple\ntimes.", "tree": {"sha": "ee98b75622f96471777a18882ad24b06e04af2ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee98b75622f96471777a18882ad24b06e04af2ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7c7a18d94cf672d6a031455d091e0bebe1a6b7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7c7a18d94cf672d6a031455d091e0bebe1a6b7c", "html_url": "https://github.com/rust-lang/rust/commit/e7c7a18d94cf672d6a031455d091e0bebe1a6b7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7c7a18d94cf672d6a031455d091e0bebe1a6b7c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a20ee76b56c46a593238ce7ac9b9f70a99c43ff4", "url": "https://api.github.com/repos/rust-lang/rust/commits/a20ee76b56c46a593238ce7ac9b9f70a99c43ff4", "html_url": "https://github.com/rust-lang/rust/commit/a20ee76b56c46a593238ce7ac9b9f70a99c43ff4"}], "stats": {"total": 249, "additions": 119, "deletions": 130}, "files": [{"sha": "b343c3f3fbbc5449a1867276668362b25285be50", "filename": "src/libsyntax/errors/json.rs", "status": "modified", "additions": 83, "deletions": 119, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/e7c7a18d94cf672d6a031455d091e0bebe1a6b7c/src%2Flibsyntax%2Ferrors%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c7a18d94cf672d6a031455d091e0bebe1a6b7c/src%2Flibsyntax%2Ferrors%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Fjson.rs?ref=e7c7a18d94cf672d6a031455d091e0bebe1a6b7c", "patch": "@@ -20,7 +20,7 @@\n // FIXME spec the JSON output properly.\n \n \n-use codemap::{self, Span, MacroBacktrace, MultiSpan, CodeMap};\n+use codemap::{self, MacroBacktrace, Span, SpanLabel, MultiSpan, CodeMap};\n use diagnostics::registry::Registry;\n use errors::{Level, DiagnosticBuilder, SubDiagnostic, RenderSpan, CodeSuggestion};\n use errors::emitter::Emitter;\n@@ -53,20 +53,13 @@ impl JsonEmitter {\n }\n \n impl Emitter for JsonEmitter {\n-    fn emit(&mut self, span: Option<&MultiSpan>, msg: &str, code: Option<&str>, level: Level) {\n+    fn emit(&mut self, span: &MultiSpan, msg: &str, code: Option<&str>, level: Level) {\n         let data = Diagnostic::new(span, msg, code, level, self);\n         if let Err(e) = writeln!(&mut self.dst, \"{}\", as_json(&data)) {\n             panic!(\"failed to print diagnostics: {:?}\", e);\n         }\n     }\n \n-    fn custom_emit(&mut self, sp: &RenderSpan, msg: &str, level: Level) {\n-        let data = Diagnostic::from_render_span(sp, msg, level, self);\n-        if let Err(e) = writeln!(&mut self.dst, \"{}\", as_json(&data)) {\n-            panic!(\"failed to print diagnostics: {:?}\", e);\n-        }\n-    }\n-\n     fn emit_struct(&mut self, db: &DiagnosticBuilder) {\n         let data = Diagnostic::from_diagnostic_builder(db, self);\n         if let Err(e) = writeln!(&mut self.dst, \"{}\", as_json(&data)) {\n@@ -104,8 +97,13 @@ struct DiagnosticSpan {\n     /// 1-based, character offset.\n     column_start: usize,\n     column_end: usize,\n+    /// Is this a \"primary\" span -- meaning the point, or one of the points,\n+    /// where the error occurred?\n+    is_primary: bool,\n     /// Source text from the start of line_start to the end of line_end.\n     text: Vec<DiagnosticSpanLine>,\n+    /// Label that should be placed at this location (if any)\n+    label: Option<String>,\n     /// If we are suggesting a replacement, this will contain text\n     /// that should be sliced in atop this span. You may prefer to\n     /// load the fully rendered version from the parent `Diagnostic`,\n@@ -148,7 +146,7 @@ struct DiagnosticCode {\n }\n \n impl<'a> Diagnostic<'a> {\n-    fn new(msp: Option<&MultiSpan>,\n+    fn new(msp: &MultiSpan,\n            msg: &'a str,\n            code: Option<&str>,\n            level: Level,\n@@ -158,35 +156,20 @@ impl<'a> Diagnostic<'a> {\n             message: msg,\n             code: DiagnosticCode::map_opt_string(code.map(|c| c.to_owned()), je),\n             level: level.to_str(),\n-            spans: msp.map_or(vec![], |msp| DiagnosticSpan::from_multispan(msp, je)),\n+            spans: DiagnosticSpan::from_multispan(msp, je),\n             children: vec![],\n             rendered: None,\n         }\n     }\n \n-    fn from_render_span(span: &RenderSpan,\n-                        msg: &'a str,\n-                        level: Level,\n-                        je: &JsonEmitter)\n-                        -> Diagnostic<'a> {\n-        Diagnostic {\n-            message: msg,\n-            code: None,\n-            level: level.to_str(),\n-            spans: DiagnosticSpan::from_render_span(span, je),\n-            children: vec![],\n-            rendered: je.render(span),\n-        }\n-    }\n-\n     fn from_diagnostic_builder<'c>(db: &'c DiagnosticBuilder,\n                                    je: &JsonEmitter)\n                                    -> Diagnostic<'c> {\n         Diagnostic {\n             message: &db.message,\n             code: DiagnosticCode::map_opt_string(db.code.clone(), je),\n             level: db.level.to_str(),\n-            spans: db.span.as_ref().map_or(vec![], |sp| DiagnosticSpan::from_multispan(sp, je)),\n+            spans: DiagnosticSpan::from_multispan(&db.span, je),\n             children: db.children.iter().map(|c| {\n                 Diagnostic::from_sub_diagnostic(c, je)\n             }).collect(),\n@@ -201,8 +184,7 @@ impl<'a> Diagnostic<'a> {\n             level: db.level.to_str(),\n             spans: db.render_span.as_ref()\n                      .map(|sp| DiagnosticSpan::from_render_span(sp, je))\n-                     .or_else(|| db.span.as_ref().map(|s| DiagnosticSpan::from_multispan(s, je)))\n-                     .unwrap_or(vec![]),\n+                     .unwrap_or_else(|| DiagnosticSpan::from_multispan(&db.span, je)),\n             children: vec![],\n             rendered: db.render_span.as_ref()\n                                     .and_then(|rsp| je.render(rsp)),\n@@ -211,44 +193,68 @@ impl<'a> Diagnostic<'a> {\n }\n \n impl DiagnosticSpan {\n-    fn from_span(span: Span, suggestion: Option<&String>, je: &JsonEmitter)\n-                 -> DiagnosticSpan {\n+    fn from_span_label(span: SpanLabel,\n+                       suggestion: Option<&String>,\n+                       je: &JsonEmitter)\n+                       -> DiagnosticSpan {\n+        Self::from_span_etc(span.span,\n+                            span.is_primary,\n+                            span.label,\n+                            suggestion,\n+                            je)\n+    }\n+\n+    fn from_span_etc(span: Span,\n+                     is_primary: bool,\n+                     label: Option<String>,\n+                     suggestion: Option<&String>,\n+                     je: &JsonEmitter)\n+                     -> DiagnosticSpan {\n         // obtain the full backtrace from the `macro_backtrace`\n         // helper; in some ways, it'd be better to expand the\n         // backtrace ourselves, but the `macro_backtrace` helper makes\n         // some decision, such as dropping some frames, and I don't\n         // want to duplicate that logic here.\n         let backtrace = je.cm.macro_backtrace(span).into_iter();\n-        DiagnosticSpan::from_span_and_backtrace(span, suggestion, backtrace, je)\n+        DiagnosticSpan::from_span_full(span,\n+                                       is_primary,\n+                                       label,\n+                                       suggestion,\n+                                       backtrace,\n+                                       je)\n     }\n \n-    fn from_span_and_backtrace(span: Span,\n-                               suggestion: Option<&String>,\n-                               mut backtrace: vec::IntoIter<MacroBacktrace>,\n-                               je: &JsonEmitter)\n-                               -> DiagnosticSpan {\n+    fn from_span_full(span: Span,\n+                      is_primary: bool,\n+                      label: Option<String>,\n+                      suggestion: Option<&String>,\n+                      mut backtrace: vec::IntoIter<MacroBacktrace>,\n+                      je: &JsonEmitter)\n+                      -> DiagnosticSpan {\n         let start = je.cm.lookup_char_pos(span.lo);\n         let end = je.cm.lookup_char_pos(span.hi);\n-        let backtrace_step =\n-            backtrace.next()\n-                     .map(|bt| {\n-                         let call_site =\n-                             Self::from_span_and_backtrace(bt.call_site,\n-                                                           None,\n-                                                           backtrace,\n-                                                           je);\n-                         let def_site_span = bt.def_site_span.map(|sp| {\n-                             Self::from_span_and_backtrace(sp,\n-                                                           None,\n-                                                           vec![].into_iter(),\n-                                                           je)\n-                         });\n-                         Box::new(DiagnosticSpanMacroExpansion {\n-                             span: call_site,\n-                             macro_decl_name: bt.macro_decl_name,\n-                             def_site_span: def_site_span,\n-                         })\n-                     });\n+        let backtrace_step = backtrace.next().map(|bt| {\n+            let call_site =\n+                Self::from_span_full(bt.call_site,\n+                                     false,\n+                                     None,\n+                                     None,\n+                                     backtrace,\n+                                     je);\n+            let def_site_span = bt.def_site_span.map(|sp| {\n+                Self::from_span_full(sp,\n+                                     false,\n+                                     None,\n+                                     None,\n+                                     vec![].into_iter(),\n+                                     je)\n+            });\n+            Box::new(DiagnosticSpanMacroExpansion {\n+                span: call_site,\n+                macro_decl_name: bt.macro_decl_name,\n+                def_site_span: def_site_span,\n+            })\n+        });\n         DiagnosticSpan {\n             file_name: start.file.name.clone(),\n             byte_start: span.lo.0,\n@@ -257,53 +263,42 @@ impl DiagnosticSpan {\n             line_end: end.line,\n             column_start: start.col.0 + 1,\n             column_end: end.col.0 + 1,\n+            is_primary: is_primary,\n             text: DiagnosticSpanLine::from_span(span, je),\n             suggested_replacement: suggestion.cloned(),\n             expansion: backtrace_step,\n+            label: label,\n         }\n     }\n \n     fn from_multispan(msp: &MultiSpan, je: &JsonEmitter) -> Vec<DiagnosticSpan> {\n-        msp.spans.iter().map(|&span| Self::from_span(span, None, je)).collect()\n+        msp.span_labels()\n+           .into_iter()\n+           .map(|span_str| Self::from_span_label(span_str, None, je))\n+           .collect()\n     }\n \n     fn from_suggestion(suggestion: &CodeSuggestion, je: &JsonEmitter)\n                        -> Vec<DiagnosticSpan> {\n-        assert_eq!(suggestion.msp.spans.len(), suggestion.substitutes.len());\n-        suggestion.msp.spans.iter()\n-                            .zip(&suggestion.substitutes)\n-                            .map(|(&span, suggestion)| {\n-                                DiagnosticSpan::from_span(span, Some(suggestion), je)\n-                            })\n-                            .collect()\n+        assert_eq!(suggestion.msp.span_labels().len(), suggestion.substitutes.len());\n+        suggestion.msp.span_labels()\n+                      .into_iter()\n+                      .zip(&suggestion.substitutes)\n+                      .map(|(span_label, suggestion)| {\n+                          DiagnosticSpan::from_span_label(span_label,\n+                                                          Some(suggestion),\n+                                                          je)\n+                      })\n+                      .collect()\n     }\n \n     fn from_render_span(rsp: &RenderSpan, je: &JsonEmitter) -> Vec<DiagnosticSpan> {\n         match *rsp {\n             RenderSpan::FileLine(ref msp) |\n-            RenderSpan::FullSpan(ref msp) => {\n-                DiagnosticSpan::from_multispan(msp, je)\n-            }\n-            RenderSpan::Suggestion(ref suggestion) => {\n-                DiagnosticSpan::from_suggestion(suggestion, je)\n-            }\n-            RenderSpan::EndSpan(ref msp) => {\n-                msp.spans.iter().map(|&span| {\n-                    let end = je.cm.lookup_char_pos(span.hi);\n-                    DiagnosticSpan {\n-                        file_name: end.file.name.clone(),\n-                        byte_start: span.hi.0,\n-                        byte_end: span.hi.0,\n-                        line_start: end.line,\n-                        line_end: end.line,\n-                        column_start: end.col.0 + 1,\n-                        column_end: end.col.0 + 1,\n-                        text: DiagnosticSpanLine::from_span_end(span, je),\n-                        suggested_replacement: None,\n-                        expansion: None,\n-                    }\n-                }).collect()\n-            }\n+            RenderSpan::FullSpan(ref msp) =>\n+                DiagnosticSpan::from_multispan(msp, je),\n+            RenderSpan::Suggestion(ref suggestion) =>\n+                DiagnosticSpan::from_suggestion(suggestion, je),\n         }\n     }\n }\n@@ -340,34 +335,6 @@ impl DiagnosticSpanLine {\n              })\n             .unwrap_or(vec![])\n     }\n-\n-    /// Create a list of DiagnosticSpanLines from span - the result covers all\n-    /// of `span`, but the highlight is zero-length and at the end of `span`.\n-    fn from_span_end(span: Span, je: &JsonEmitter) -> Vec<DiagnosticSpanLine> {\n-        je.cm.span_to_lines(span)\n-             .map(|lines| {\n-                 let fm = &*lines.file;\n-                 lines.lines.iter()\n-                            .enumerate()\n-                            .map(|(i, line)| {\n-                                // Invariant - CodeMap::span_to_lines\n-                                // will not return extra context lines\n-                                // - the last line returned is the last\n-                                // line of `span`.\n-                                let highlight = if i == lines.lines.len() - 1 {\n-                                    (line.end_col.0 + 1, line.end_col.0 + 1)\n-                                } else {\n-                                    (0, 0)\n-                                };\n-                                DiagnosticSpanLine::line_from_filemap(fm,\n-                                                                      line.line_index,\n-                                                                      highlight.0,\n-                                                                      highlight.1)\n-                            })\n-                            .collect()\n-             })\n-            .unwrap_or(vec![])\n-    }\n }\n \n impl DiagnosticCode {\n@@ -396,9 +363,6 @@ impl JsonEmitter {\n             RenderSpan::Suggestion(ref suggestion) => {\n                 Some(suggestion.splice_lines(&self.cm))\n             }\n-            RenderSpan::EndSpan(_) => {\n-                None\n-            }\n         }\n     }\n }"}, {"sha": "3501b335205ed495f105fb1fc7b1f8bd24b8f3aa", "filename": "src/tools/compiletest/src/json.rs", "status": "modified", "additions": 36, "deletions": 11, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/e7c7a18d94cf672d6a031455d091e0bebe1a6b7c/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7c7a18d94cf672d6a031455d091e0bebe1a6b7c/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fjson.rs?ref=e7c7a18d94cf672d6a031455d091e0bebe1a6b7c", "patch": "@@ -33,6 +33,8 @@ struct DiagnosticSpan {\n     line_end: usize,\n     column_start: usize,\n     column_end: usize,\n+    is_primary: bool,\n+    label: Option<String>,\n     expansion: Option<Box<DiagnosticSpanMacroExpansion>>,\n }\n \n@@ -66,7 +68,7 @@ fn parse_line(file_name: &str, line: &str) -> Vec<Error> {\n         match json::decode::<Diagnostic>(line) {\n             Ok(diagnostic) => {\n                 let mut expected_errors = vec![];\n-                push_expected_errors(&mut expected_errors, &diagnostic, file_name);\n+                push_expected_errors(&mut expected_errors, &diagnostic, &[], file_name);\n                 expected_errors\n             }\n             Err(error) => {\n@@ -80,12 +82,24 @@ fn parse_line(file_name: &str, line: &str) -> Vec<Error> {\n \n fn push_expected_errors(expected_errors: &mut Vec<Error>,\n                         diagnostic: &Diagnostic,\n+                        default_spans: &[&DiagnosticSpan],\n                         file_name: &str) {\n-    // We only consider messages pertaining to the current file.\n-    let matching_spans = || {\n-        diagnostic.spans.iter().filter(|span| {\n-            Path::new(&span.file_name) == Path::new(&file_name)\n-        })\n+    let spans_in_this_file: Vec<_> =\n+        diagnostic.spans.iter()\n+                        .filter(|span| Path::new(&span.file_name) == Path::new(&file_name))\n+                        .collect();\n+\n+    let primary_spans: Vec<_> =\n+        spans_in_this_file.iter()\n+                          .cloned()\n+                          .filter(|span| span.is_primary)\n+                          .collect();\n+    let primary_spans = if primary_spans.is_empty() {\n+        // subdiagnostics often don't have a span of their own;\n+        // inherit the span from the parent in that case\n+        default_spans\n+    } else {\n+        &primary_spans\n     };\n \n     // We break the output into multiple lines, and then append the\n@@ -124,7 +138,7 @@ fn push_expected_errors(expected_errors: &mut Vec<Error>,\n     // more structured shortly anyhow.\n     let mut message_lines = diagnostic.message.lines();\n     if let Some(first_line) = message_lines.next() {\n-        for span in matching_spans() {\n+        for span in primary_spans {\n             let msg = with_code(span, first_line);\n             let kind = ErrorKind::from_str(&diagnostic.level).ok();\n             expected_errors.push(\n@@ -137,7 +151,7 @@ fn push_expected_errors(expected_errors: &mut Vec<Error>,\n         }\n     }\n     for next_line in message_lines {\n-        for span in matching_spans() {\n+        for span in primary_spans {\n             expected_errors.push(\n                 Error {\n                     line_num: span.line_start,\n@@ -150,7 +164,7 @@ fn push_expected_errors(expected_errors: &mut Vec<Error>,\n \n     // If the message has a suggestion, register that.\n     if let Some(ref rendered) = diagnostic.rendered {\n-        let start_line = matching_spans().map(|s| s.line_start).min().expect(\"\\\n+        let start_line = primary_spans.iter().map(|s| s.line_start).min().expect(\"\\\n             every suggestion should have at least one span\");\n         for (index, line) in rendered.lines().enumerate() {\n             expected_errors.push(\n@@ -164,17 +178,28 @@ fn push_expected_errors(expected_errors: &mut Vec<Error>,\n     }\n \n     // Add notes for the backtrace\n-    for span in matching_spans() {\n+    for span in primary_spans {\n         for frame in &span.expansion {\n             push_backtrace(expected_errors,\n                            frame,\n                            file_name);\n         }\n     }\n \n+    // Add notes for any labels that appear in the message.\n+    for span in spans_in_this_file.iter()\n+                                  .filter(|span| span.label.is_some())\n+    {\n+        expected_errors.push(Error {\n+            line_num: span.line_start,\n+            kind: Some(ErrorKind::Note),\n+            msg: span.label.clone().unwrap()\n+        });\n+    }\n+\n     // Flatten out the children.\n     for child in &diagnostic.children {\n-        push_expected_errors(expected_errors, child, file_name);\n+        push_expected_errors(expected_errors, child, primary_spans, file_name);\n     }\n }\n "}]}