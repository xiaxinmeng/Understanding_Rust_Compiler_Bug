{"sha": "a6d9930525bee48e250bc9527f48c501e53d861d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2ZDk5MzA1MjViZWU0OGUyNTBiYzk1MjdmNDhjNTAxZTUzZDg2MWQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-03-10T19:32:25Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-03-31T13:51:17Z"}, "message": "Extract more `ty` and `infer` dependencies from the unification engine\nso that it is closer to standalone.", "tree": {"sha": "3f3a0f5a2ceb2b200adbfa3b7631d1d26ed6de82", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f3a0f5a2ceb2b200adbfa3b7631d1d26ed6de82"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a6d9930525bee48e250bc9527f48c501e53d861d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a6d9930525bee48e250bc9527f48c501e53d861d", "html_url": "https://github.com/rust-lang/rust/commit/a6d9930525bee48e250bc9527f48c501e53d861d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a6d9930525bee48e250bc9527f48c501e53d861d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c581840dcce6991cf55379dd5cf8e2a92a94e994", "url": "https://api.github.com/repos/rust-lang/rust/commits/c581840dcce6991cf55379dd5cf8e2a92a94e994", "html_url": "https://github.com/rust-lang/rust/commit/c581840dcce6991cf55379dd5cf8e2a92a94e994"}], "stats": {"total": 129, "additions": 66, "deletions": 63}, "files": [{"sha": "fdff750bf469032ed0015c9bc6d3c0eadb4c5eb3", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 36, "deletions": 8, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/a6d9930525bee48e250bc9527f48c501e53d861d/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6d9930525bee48e250bc9527f48c501e53d861d/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=a6d9930525bee48e250bc9527f48c501e53d861d", "patch": "@@ -436,8 +436,17 @@ pub fn expected_found<'tcx, C, T>(this: &C,\n                                   a: T,\n                                   b: T)\n                                   -> ty::expected_found<T>\n-                                  where C: Combine<'tcx> {\n-    if this.a_is_expected() {\n+                                  where C: Combine<'tcx>\n+{\n+    expected_found_bool(this.a_is_expected(), a, b)\n+}\n+\n+fn expected_found_bool<T>(a_is_expected: bool,\n+                          a: T,\n+                          b: T)\n+                          -> ty::expected_found<T>\n+{\n+    if a_is_expected {\n         ty::expected_found {expected: a, found: b}\n     } else {\n         ty::expected_found {expected: b, found: a}\n@@ -469,7 +478,8 @@ pub fn super_tys<'tcx, C>(this: &C,\n         (&ty::ty_infer(IntVar(a_id)), &ty::ty_infer(IntVar(b_id))) => {\n             try!(this.infcx().int_unification_table\n                              .borrow_mut()\n-                             .unify_var_var(this.a_is_expected(), a_id, b_id));\n+                             .unify_var_var(a_id, b_id)\n+                             .map_err(|e| int_unification_error(this.a_is_expected(), e)));\n             Ok(a)\n         }\n         (&ty::ty_infer(IntVar(v_id)), &ty::ty_int(v)) => {\n@@ -489,7 +499,8 @@ pub fn super_tys<'tcx, C>(this: &C,\n         (&ty::ty_infer(FloatVar(a_id)), &ty::ty_infer(FloatVar(b_id))) => {\n             try!(this.infcx().float_unification_table\n                              .borrow_mut()\n-                             .unify_var_var(this.a_is_expected(), a_id, b_id));\n+                             .unify_var_var(a_id, b_id)\n+                             .map_err(|e| float_unification_error(this.a_is_expected(), e)));\n             Ok(a)\n         }\n         (&ty::ty_infer(FloatVar(v_id)), &ty::ty_float(v)) => {\n@@ -617,9 +628,11 @@ pub fn super_tys<'tcx, C>(this: &C,\n                                         -> CombineResult<'tcx, Ty<'tcx>>\n         where C: Combine<'tcx>\n     {\n-        try!(this.infcx().int_unification_table\n-                         .borrow_mut()\n-                         .unify_var_value(vid_is_expected, vid, val));\n+        try!(this.infcx()\n+                 .int_unification_table\n+                 .borrow_mut()\n+                 .unify_var_value(vid, val)\n+                 .map_err(|e| int_unification_error(vid_is_expected, e)));\n         match val {\n             IntType(v) => Ok(ty::mk_mach_int(this.tcx(), v)),\n             UintType(v) => Ok(ty::mk_mach_uint(this.tcx(), v)),\n@@ -635,7 +648,8 @@ pub fn super_tys<'tcx, C>(this: &C,\n     {\n         try!(this.infcx().float_unification_table\n                          .borrow_mut()\n-                         .unify_var_value(vid_is_expected, vid, val));\n+                         .unify_var_value(vid, val)\n+                         .map_err(|e| float_unification_error(vid_is_expected, e)));\n         Ok(ty::mk_mach_float(this.tcx(), val))\n     }\n }\n@@ -863,3 +877,17 @@ impl<'tcx, T:Clone + PartialEq> CombineResultCompare<'tcx, T> for CombineResult<\n     }\n }\n \n+fn int_unification_error<'tcx>(a_is_expected: bool, v: (ty::IntVarValue, ty::IntVarValue))\n+                               -> ty::type_err<'tcx>\n+{\n+    let (a, b) = v;\n+    ty::terr_int_mismatch(expected_found_bool(a_is_expected, a, b))\n+}\n+\n+fn float_unification_error<'tcx>(a_is_expected: bool,\n+                                 v: (ast::FloatTy, ast::FloatTy))\n+                                 -> ty::type_err<'tcx>\n+{\n+    let (a, b) = v;\n+    ty::terr_float_mismatch(expected_found_bool(a_is_expected, a, b))\n+}"}, {"sha": "29f74d12ea3e814bb82c3030687b78d9eb7bd534", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a6d9930525bee48e250bc9527f48c501e53d861d/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6d9930525bee48e250bc9527f48c501e53d861d/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=a6d9930525bee48e250bc9527f48c501e53d861d", "patch": "@@ -37,6 +37,7 @@ use middle::ty_fold::TypeFolder;\n use std::collections::hash_map::{self, Entry};\n \n use super::InferCtxt;\n+use super::unify::ToType;\n \n pub struct TypeFreshener<'a, 'tcx:'a> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n@@ -115,14 +116,18 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n \n             ty::ty_infer(ty::IntVar(v)) => {\n                 self.freshen(\n-                    self.infcx.int_unification_table.borrow_mut().probe(tcx, v),\n+                    self.infcx.int_unification_table.borrow_mut()\n+                                                    .probe(v)\n+                                                    .map(|v| v.to_type(tcx)),\n                     ty::IntVar(v),\n                     ty::FreshIntTy)\n             }\n \n             ty::ty_infer(ty::FloatVar(v)) => {\n                 self.freshen(\n-                    self.infcx.float_unification_table.borrow_mut().probe(tcx, v),\n+                    self.infcx.float_unification_table.borrow_mut()\n+                                                      .probe(v)\n+                                                      .map(|v| v.to_type(tcx)),\n                     ty::FloatVar(v),\n                     ty::FreshIntTy)\n             }"}, {"sha": "7e9c4d8e076881f054a01d978f3f9002df2e49db", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a6d9930525bee48e250bc9527f48c501e53d861d/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6d9930525bee48e250bc9527f48c501e53d861d/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=a6d9930525bee48e250bc9527f48c501e53d861d", "patch": "@@ -43,7 +43,7 @@ use self::region_inference::{RegionVarBindings, RegionSnapshot};\n use self::equate::Equate;\n use self::sub::Sub;\n use self::lub::Lub;\n-use self::unify::UnificationTable;\n+use self::unify::{ToType, UnificationTable};\n use self::error_reporting::ErrorReporting;\n \n pub mod bivariate;\n@@ -885,14 +885,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             ty::ty_infer(ty::IntVar(v)) => {\n                 self.int_unification_table\n                     .borrow_mut()\n-                    .probe(self.tcx, v)\n+                    .probe(v)\n+                    .map(|v| v.to_type(self.tcx))\n                     .unwrap_or(typ)\n             }\n \n             ty::ty_infer(ty::FloatVar(v)) => {\n                 self.float_unification_table\n                     .borrow_mut()\n-                    .probe(self.tcx, v)\n+                    .probe(v)\n+                    .map(|v| v.to_type(self.tcx))\n                     .unwrap_or(typ)\n             }\n "}, {"sha": "a240917d6c1e4931027f2b1eb9262b0de7274e2d", "filename": "src/librustc/middle/infer/unify.rs", "status": "modified", "additions": 17, "deletions": 48, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/a6d9930525bee48e250bc9527f48c501e53d861d/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6d9930525bee48e250bc9527f48c501e53d861d/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs?ref=a6d9930525bee48e250bc9527f48c501e53d861d", "patch": "@@ -14,7 +14,6 @@ use std::marker;\n \n use middle::ty::{expected_found, IntVarValue};\n use middle::ty::{self, Ty};\n-use middle::infer::{UnitResult};\n use std::fmt::Debug;\n use std::marker::PhantomData;\n use syntax::ast;\n@@ -224,36 +223,15 @@ impl<K:UnifyKey> sv::SnapshotVecDelegate for Delegate<K> {\n // floats---anything that doesn't have a subtyping relationship we\n // need to worry about.\n \n-/// Indicates a type that does not have any kind of subtyping\n-/// relationship.\n-pub trait SimplyUnifiable<'tcx> : Clone + PartialEq + Debug {\n-    fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx>;\n-    fn to_type_err(expected_found<Self>) -> ty::type_err<'tcx>;\n-}\n-\n-pub fn err<'tcx, V:SimplyUnifiable<'tcx>>(a_is_expected: bool,\n-                                          a_t: V,\n-                                          b_t: V)\n-                                          -> UnitResult<'tcx> {\n-    if a_is_expected {\n-        Err(SimplyUnifiable::to_type_err(\n-            ty::expected_found {expected: a_t, found: b_t}))\n-    } else {\n-        Err(SimplyUnifiable::to_type_err(\n-            ty::expected_found {expected: b_t, found: a_t}))\n-    }\n-}\n-\n impl<'tcx,K,V> UnificationTable<K>\n-    where K : UnifyKey<Value=Option<V>>,\n-          V : SimplyUnifiable<'tcx>,\n-          Option<V> : UnifyValue,\n+    where K: UnifyKey<Value=Option<V>>,\n+          V: Clone+PartialEq,\n+          Option<V>: UnifyValue,\n {\n     pub fn unify_var_var(&mut self,\n-                         a_is_expected: bool,\n                          a_id: K,\n                          b_id: K)\n-                         -> UnitResult<'tcx>\n+                         -> Result<(),(V,V)>\n     {\n         let node_a = self.get(a_id);\n         let node_b = self.get(b_id);\n@@ -268,13 +246,13 @@ impl<'tcx,K,V> UnificationTable<K>\n                     None\n                 }\n                 (&Some(ref v), &None) | (&None, &Some(ref v)) => {\n-                    Some((*v).clone())\n+                    Some(v.clone())\n                 }\n                 (&Some(ref v1), &Some(ref v2)) => {\n                     if *v1 != *v2 {\n-                        return err(a_is_expected, (*v1).clone(), (*v2).clone())\n+                        return Err((v1.clone(), v2.clone()));\n                     }\n-                    Some((*v1).clone())\n+                    Some(v1.clone())\n                 }\n             }\n         };\n@@ -285,10 +263,9 @@ impl<'tcx,K,V> UnificationTable<K>\n     /// Sets the value of the key `a_id` to `b`. Because simple keys do not have any subtyping\n     /// relationships, if `a_id` already has a value, it must be the same as `b`.\n     pub fn unify_var_value(&mut self,\n-                           a_is_expected: bool,\n                            a_id: K,\n                            b: V)\n-                           -> UnitResult<'tcx>\n+                           -> Result<(),(V,V)>\n     {\n         let node_a = self.get(a_id);\n         let a_id = node_a.key.clone();\n@@ -303,7 +280,7 @@ impl<'tcx,K,V> UnificationTable<K>\n                 if *a_t == b {\n                     Ok(())\n                 } else {\n-                    err(a_is_expected, (*a_t).clone(), b)\n+                    Err((a_t.clone(), b))\n                 }\n             }\n         }\n@@ -313,37 +290,33 @@ impl<'tcx,K,V> UnificationTable<K>\n         self.get(id).value.is_some()\n     }\n \n-    pub fn probe(&mut self, tcx: &ty::ctxt<'tcx>, a_id: K) -> Option<Ty<'tcx>> {\n-        let node_a = self.get(a_id);\n-        match node_a.value {\n-            None => None,\n-            Some(ref a_t) => Some(a_t.to_type(tcx))\n-        }\n+    pub fn probe(&mut self, a_id: K) -> Option<V> {\n+        self.get(a_id).value.clone()\n     }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n \n // Integral type keys\n \n+pub trait ToType<'tcx> {\n+    fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx>;\n+}\n+\n impl UnifyKey for ty::IntVid {\n     type Value = Option<IntVarValue>;\n     fn index(&self) -> u32 { self.index }\n     fn from_index(i: u32) -> ty::IntVid { ty::IntVid { index: i } }\n     fn tag(_: Option<ty::IntVid>) -> &'static str { \"IntVid\" }\n }\n \n-impl<'tcx> SimplyUnifiable<'tcx> for IntVarValue {\n+impl<'tcx> ToType<'tcx> for IntVarValue {\n     fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n         match *self {\n             ty::IntType(i) => ty::mk_mach_int(tcx, i),\n             ty::UintType(i) => ty::mk_mach_uint(tcx, i),\n         }\n     }\n-\n-    fn to_type_err(err: expected_found<IntVarValue>) -> ty::type_err<'tcx> {\n-        return ty::terr_int_mismatch(err);\n-    }\n }\n \n impl UnifyValue for Option<IntVarValue> { }\n@@ -360,12 +333,8 @@ impl UnifyKey for ty::FloatVid {\n impl UnifyValue for Option<ast::FloatTy> {\n }\n \n-impl<'tcx> SimplyUnifiable<'tcx> for ast::FloatTy {\n+impl<'tcx> ToType<'tcx> for ast::FloatTy {\n     fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx> {\n         ty::mk_mach_float(tcx, *self)\n     }\n-\n-    fn to_type_err(err: expected_found<ast::FloatTy>) -> ty::type_err<'tcx> {\n-        ty::terr_float_mismatch(err)\n-    }\n }"}, {"sha": "1ba0194f84ecb304fcac5dfaa4c2a74a312dac82", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a6d9930525bee48e250bc9527f48c501e53d861d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a6d9930525bee48e250bc9527f48c501e53d861d/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=a6d9930525bee48e250bc9527f48c501e53d861d", "patch": "@@ -62,9 +62,8 @@\n \n use check::{autoderef, FnCtxt, NoPreference, PreferMutLvalue, UnresolvedTypeAction};\n \n-use middle::infer::{self, CombineResult, Coercion, TypeTrace};\n+use middle::infer::{self, CombineResult, Coercion};\n use middle::infer::combine::Combine;\n-use middle::infer::sub::Sub;\n use middle::subst;\n use middle::ty::{AutoPtr, AutoDerefRef, AdjustDerefRef, AutoUnsize, AutoUnsafe};\n use middle::ty::{self, mt, Ty};"}]}