{"sha": "b42c5ced68c019108e079dc01d0bd29606efc10c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0MmM1Y2VkNjhjMDE5MTA4ZTA3OWRjMDFkMGJkMjk2MDZlZmMxMGM=", "commit": {"author": {"name": "Michael Killough", "email": "michaeljkillough@gmail.com", "date": "2019-03-16T18:13:13Z"}, "committer": {"name": "Michael Killough", "email": "michaeljkillough@gmail.com", "date": "2019-03-16T18:13:13Z"}, "message": "Implement BindingMode for pattern matching.\n\nImplement `BindingMode` for pattern matching, so that types can be\ncorrectly inferred using match ergonomics. The binding mode defaults to\n`Move` (referred to as 'BindingMode::BindByValue` in rustc), and is\nupdated by automatic dereferencing of the value being matched.", "tree": {"sha": "340dd45df03b6841103cad9e3980dfe261f8b4e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/340dd45df03b6841103cad9e3980dfe261f8b4e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b42c5ced68c019108e079dc01d0bd29606efc10c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b42c5ced68c019108e079dc01d0bd29606efc10c", "html_url": "https://github.com/rust-lang/rust/commit/b42c5ced68c019108e079dc01d0bd29606efc10c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b42c5ced68c019108e079dc01d0bd29606efc10c/comments", "author": {"login": "mjkillough", "id": 532855, "node_id": "MDQ6VXNlcjUzMjg1NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/532855?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mjkillough", "html_url": "https://github.com/mjkillough", "followers_url": "https://api.github.com/users/mjkillough/followers", "following_url": "https://api.github.com/users/mjkillough/following{/other_user}", "gists_url": "https://api.github.com/users/mjkillough/gists{/gist_id}", "starred_url": "https://api.github.com/users/mjkillough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mjkillough/subscriptions", "organizations_url": "https://api.github.com/users/mjkillough/orgs", "repos_url": "https://api.github.com/users/mjkillough/repos", "events_url": "https://api.github.com/users/mjkillough/events{/privacy}", "received_events_url": "https://api.github.com/users/mjkillough/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mjkillough", "id": 532855, "node_id": "MDQ6VXNlcjUzMjg1NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/532855?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mjkillough", "html_url": "https://github.com/mjkillough", "followers_url": "https://api.github.com/users/mjkillough/followers", "following_url": "https://api.github.com/users/mjkillough/following{/other_user}", "gists_url": "https://api.github.com/users/mjkillough/gists{/gist_id}", "starred_url": "https://api.github.com/users/mjkillough/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mjkillough/subscriptions", "organizations_url": "https://api.github.com/users/mjkillough/orgs", "repos_url": "https://api.github.com/users/mjkillough/repos", "events_url": "https://api.github.com/users/mjkillough/events{/privacy}", "received_events_url": "https://api.github.com/users/mjkillough/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "97a87bf3a68338b1acc2b7a02dfa43096bf47e05", "url": "https://api.github.com/repos/rust-lang/rust/commits/97a87bf3a68338b1acc2b7a02dfa43096bf47e05", "html_url": "https://github.com/rust-lang/rust/commit/97a87bf3a68338b1acc2b7a02dfa43096bf47e05"}], "stats": {"total": 216, "additions": 154, "deletions": 62}, "files": [{"sha": "7200446bad8beedb13f850a7b45eb32f8901217f", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 78, "deletions": 17, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/b42c5ced68c019108e079dc01d0bd29606efc10c/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42c5ced68c019108e079dc01d0bd29606efc10c/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=b42c5ced68c019108e079dc01d0bd29606efc10c", "patch": "@@ -63,6 +63,24 @@ enum ExprOrPatId {\n \n impl_froms!(ExprOrPatId: ExprId, PatId);\n \n+/// Binding modes inferred for patterns.\n+/// https://doc.rust-lang.org/reference/patterns.html#binding-modes\n+#[derive(Copy, Clone, Debug, Eq, PartialEq)]\n+enum BindingMode {\n+    Move,\n+    Ref(Mutability),\n+}\n+\n+impl BindingMode {\n+    pub fn convert(annotation: &BindingAnnotation) -> BindingMode {\n+        match annotation {\n+            BindingAnnotation::Unannotated | BindingAnnotation::Mutable => BindingMode::Move,\n+            BindingAnnotation::Ref => BindingMode::Ref(Mutability::Shared),\n+            BindingAnnotation::RefMut => BindingMode::Ref(Mutability::Mut),\n+        }\n+    }\n+}\n+\n /// The result of type inference: A mapping from expressions and patterns to types.\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct InferenceResult {\n@@ -530,6 +548,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         path: Option<&Path>,\n         subpats: &[PatId],\n         expected: &Ty,\n+        default_bm: BindingMode,\n     ) -> Ty {\n         let (ty, def) = self.resolve_variant(path);\n \n@@ -542,13 +561,19 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 .and_then(|d| d.field(self.db, &Name::tuple_field_name(i)))\n                 .map_or(Ty::Unknown, |field| field.ty(self.db))\n                 .subst(&substs);\n-            self.infer_pat(subpat, &expected_ty);\n+            self.infer_pat(subpat, &expected_ty, default_bm);\n         }\n \n         ty\n     }\n \n-    fn infer_struct_pat(&mut self, path: Option<&Path>, subpats: &[FieldPat], expected: &Ty) -> Ty {\n+    fn infer_struct_pat(\n+        &mut self,\n+        path: Option<&Path>,\n+        subpats: &[FieldPat],\n+        expected: &Ty,\n+        default_bm: BindingMode,\n+    ) -> Ty {\n         let (ty, def) = self.resolve_variant(path);\n \n         self.unify(&ty, expected);\n@@ -559,15 +584,42 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             let matching_field = def.and_then(|it| it.field(self.db, &subpat.name));\n             let expected_ty =\n                 matching_field.map_or(Ty::Unknown, |field| field.ty(self.db)).subst(&substs);\n-            self.infer_pat(subpat.pat, &expected_ty);\n+            self.infer_pat(subpat.pat, &expected_ty, default_bm);\n         }\n \n         ty\n     }\n \n-    fn infer_pat(&mut self, pat: PatId, expected: &Ty) -> Ty {\n+    fn infer_pat(&mut self, pat: PatId, mut expected: &Ty, mut default_bm: BindingMode) -> Ty {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n \n+        let is_non_ref_pat = match &body[pat] {\n+            Pat::Tuple(..)\n+            | Pat::TupleStruct { .. }\n+            | Pat::Struct { .. }\n+            | Pat::Range { .. }\n+            | Pat::Slice { .. } => true,\n+            // TODO: Path/Lit might actually evaluate to ref, but inference is unimplemented.\n+            Pat::Path(..) | Pat::Lit(..) => true,\n+            Pat::Wild | Pat::Bind { .. } | Pat::Ref { .. } | Pat::Missing => false,\n+        };\n+        if is_non_ref_pat {\n+            while let Ty::Ref(inner, mutability) = expected {\n+                expected = inner;\n+                default_bm = match default_bm {\n+                    BindingMode::Move => BindingMode::Ref(*mutability),\n+                    BindingMode::Ref(Mutability::Shared) => BindingMode::Ref(Mutability::Shared),\n+                    BindingMode::Ref(Mutability::Mut) => BindingMode::Ref(*mutability),\n+                }\n+            }\n+        } else if let Pat::Ref { .. } = &body[pat] {\n+            default_bm = BindingMode::Move;\n+        }\n+\n+        // Lose mutability.\n+        let default_bm = default_bm;\n+        let expected = expected;\n+\n         let ty = match &body[pat] {\n             Pat::Tuple(ref args) => {\n                 let expectations = match *expected {\n@@ -579,7 +631,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let inner_tys = args\n                     .iter()\n                     .zip(expectations_iter)\n-                    .map(|(&pat, ty)| self.infer_pat(pat, ty))\n+                    .map(|(&pat, ty)| self.infer_pat(pat, ty, default_bm))\n                     .collect::<Vec<_>>()\n                     .into();\n \n@@ -595,32 +647,41 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     }\n                     _ => &Ty::Unknown,\n                 };\n-                let subty = self.infer_pat(*pat, expectation);\n+                let subty = self.infer_pat(*pat, expectation, default_bm);\n                 Ty::Ref(subty.into(), *mutability)\n             }\n             Pat::TupleStruct { path: ref p, args: ref subpats } => {\n-                self.infer_tuple_struct_pat(p.as_ref(), subpats, expected)\n+                self.infer_tuple_struct_pat(p.as_ref(), subpats, expected, default_bm)\n             }\n             Pat::Struct { path: ref p, args: ref fields } => {\n-                self.infer_struct_pat(p.as_ref(), fields, expected)\n+                self.infer_struct_pat(p.as_ref(), fields, expected, default_bm)\n             }\n             Pat::Path(path) => {\n                 // TODO use correct resolver for the surrounding expression\n                 let resolver = self.resolver.clone();\n                 self.infer_path_expr(&resolver, &path, pat.into()).unwrap_or(Ty::Unknown)\n             }\n             Pat::Bind { mode, name: _name, subpat } => {\n+                let mode = if mode == &BindingAnnotation::Unannotated {\n+                    default_bm\n+                } else {\n+                    BindingMode::convert(mode)\n+                };\n                 let inner_ty = if let Some(subpat) = subpat {\n-                    self.infer_pat(*subpat, expected)\n+                    self.infer_pat(*subpat, expected, default_bm)\n                 } else {\n                     expected.clone()\n                 };\n                 let inner_ty = self.insert_type_vars_shallow(inner_ty);\n \n                 let bound_ty = match mode {\n-                    BindingAnnotation::Ref => Ty::Ref(inner_ty.clone().into(), Mutability::Shared),\n-                    BindingAnnotation::RefMut => Ty::Ref(inner_ty.clone().into(), Mutability::Mut),\n-                    BindingAnnotation::Mutable | BindingAnnotation::Unannotated => inner_ty.clone(),\n+                    BindingMode::Ref(Mutability::Shared) => {\n+                        Ty::Ref(inner_ty.clone().into(), Mutability::Shared)\n+                    }\n+                    BindingMode::Ref(Mutability::Mut) => {\n+                        Ty::Ref(inner_ty.clone().into(), Mutability::Mut)\n+                    }\n+                    BindingMode::Move => inner_ty.clone(),\n                 };\n                 let bound_ty = self.resolve_ty_as_possible(&mut vec![], bound_ty);\n                 self.write_pat_ty(pat, bound_ty);\n@@ -700,7 +761,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             }\n             Expr::For { iterable, body, pat } => {\n                 let _iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n-                self.infer_pat(*pat, &Ty::Unknown);\n+                self.infer_pat(*pat, &Ty::Unknown, BindingMode::Move);\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n                 Ty::unit()\n             }\n@@ -714,7 +775,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     } else {\n                         Ty::Unknown\n                     };\n-                    self.infer_pat(*arg_pat, &expected);\n+                    self.infer_pat(*arg_pat, &expected, BindingMode::Move);\n                 }\n \n                 // TODO: infer lambda type etc.\n@@ -804,7 +865,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n \n                 for arm in arms {\n                     for &pat in &arm.pats {\n-                        let _pat_ty = self.infer_pat(pat, &input_ty);\n+                        let _pat_ty = self.infer_pat(pat, &input_ty, BindingMode::Move);\n                     }\n                     if let Some(guard_expr) = arm.guard {\n                         self.infer_expr(guard_expr, &Expectation::has_type(Ty::Bool));\n@@ -1004,7 +1065,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         decl_ty\n                     };\n \n-                    self.infer_pat(*pat, &ty);\n+                    self.infer_pat(*pat, &ty, BindingMode::Move);\n                 }\n                 Statement::Expr(expr) => {\n                     self.infer_expr(*expr, &Expectation::none());\n@@ -1020,7 +1081,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         for (type_ref, pat) in signature.params().iter().zip(body.params()) {\n             let ty = self.make_ty(type_ref);\n \n-            self.infer_pat(*pat, &ty);\n+            self.infer_pat(*pat, &ty, BindingMode::Move);\n         }\n         self.return_ty = self.make_ty(signature.ret_type());\n     }"}, {"sha": "b12ea4334f1bde6e504123e779b16c14410e1f40", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 76, "deletions": 45, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/b42c5ced68c019108e079dc01d0bd29606efc10c/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b42c5ced68c019108e079dc01d0bd29606efc10c/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=b42c5ced68c019108e079dc01d0bd29606efc10c", "patch": "@@ -756,6 +756,8 @@ fn test(x: &str, y: isize) {\n fn infer_pattern() {\n     assert_snapshot_matches!(\n         infer(r#\"\n+struct A<T>(T);\n+\n fn test(x: &i32) {\n     let y = x;\n     let &z = x;\n@@ -772,60 +774,89 @@ fn test(x: &i32) {\n \n     let lambda = |a: u64, b, c: i32| { a + b; c };\n \n+    let A(n) = &A(1);\n+    let A(n) = &mut A(1);\n+\n+    let v = &(1, &2);\n+    let (_, &w) = v;\n+\n     let ref ref_to_x = x;\n     let mut mut_x = x;\n     let ref mut mut_ref_to_x = x;\n     let k = mut_ref_to_x;\n }\n \"#),\n         @r###\"\n-[9; 10) 'x': &i32\n-[18; 369) '{     ...o_x; }': ()\n-[28; 29) 'y': &i32\n-[32; 33) 'x': &i32\n-[43; 45) '&z': &i32\n-[44; 45) 'z': i32\n-[48; 49) 'x': &i32\n-[59; 60) 'a': i32\n-[63; 64) 'z': i32\n-[74; 80) '(c, d)': (i32, &str)\n-[75; 76) 'c': i32\n-[78; 79) 'd': &str\n-[83; 95) '(1, \"hello\")': (i32, &str)\n-[84; 85) '1': i32\n-[87; 94) '\"hello\"': &str\n-[102; 152) 'for (e...     }': ()\n-[106; 112) '(e, f)': ({unknown}, {unknown})\n-[107; 108) 'e': {unknown}\n-[110; 111) 'f': {unknown}\n-[116; 125) 'some_iter': {unknown}\n-[126; 152) '{     ...     }': ()\n-[140; 141) 'g': {unknown}\n-[144; 145) 'e': {unknown}\n-[158; 205) 'if let...     }': ()\n-[165; 170) '[val]': {unknown}\n-[173; 176) 'opt': {unknown}\n-[177; 205) '{     ...     }': ()\n-[191; 192) 'h': {unknown}\n-[195; 198) 'val': {unknown}\n-[215; 221) 'lambda': {unknown}\n-[224; 256) '|a: u6...b; c }': {unknown}\n-[225; 226) 'a': u64\n-[233; 234) 'b': u64\n-[236; 237) 'c': i32\n-[244; 256) '{ a + b; c }': i32\n-[246; 247) 'a': u64\n-[246; 251) 'a + b': u64\n+[26; 27) 'x': &i32\n+[35; 479) '{     ...o_x; }': ()\n+[45; 46) 'y': &i32\n+[49; 50) 'x': &i32\n+[60; 62) '&z': &i32\n+[61; 62) 'z': i32\n+[65; 66) 'x': &i32\n+[76; 77) 'a': i32\n+[80; 81) 'z': i32\n+[91; 97) '(c, d)': (i32, &str)\n+[92; 93) 'c': i32\n+[95; 96) 'd': &str\n+[100; 112) '(1, \"hello\")': (i32, &str)\n+[101; 102) '1': i32\n+[104; 111) '\"hello\"': &str\n+[119; 169) 'for (e...     }': ()\n+[123; 129) '(e, f)': ({unknown}, {unknown})\n+[124; 125) 'e': {unknown}\n+[127; 128) 'f': {unknown}\n+[133; 142) 'some_iter': {unknown}\n+[143; 169) '{     ...     }': ()\n+[157; 158) 'g': {unknown}\n+[161; 162) 'e': {unknown}\n+[175; 222) 'if let...     }': ()\n+[182; 187) '[val]': {unknown}\n+[190; 193) 'opt': {unknown}\n+[194; 222) '{     ...     }': ()\n+[208; 209) 'h': {unknown}\n+[212; 215) 'val': {unknown}\n+[232; 238) 'lambda': {unknown}\n+[241; 273) '|a: u6...b; c }': {unknown}\n+[242; 243) 'a': u64\n [250; 251) 'b': u64\n [253; 254) 'c': i32\n-[267; 279) 'ref ref_to_x': &&i32\n-[282; 283) 'x': &i32\n-[293; 302) 'mut mut_x': &i32\n-[305; 306) 'x': &i32\n-[316; 336) 'ref mu...f_to_x': &mut &i32\n-[339; 340) 'x': &i32\n-[350; 351) 'k': &mut &i32\n-[354; 366) 'mut_ref_to_x': &mut &i32\"###\n+[261; 273) '{ a + b; c }': i32\n+[263; 264) 'a': u64\n+[263; 268) 'a + b': u64\n+[267; 268) 'b': u64\n+[270; 271) 'c': i32\n+[284; 288) 'A(n)': A<i32>\n+[286; 287) 'n': &i32\n+[291; 296) '&A(1)': &A<i32>\n+[292; 293) 'A': A<i32>(T) -> A<T>\n+[292; 296) 'A(1)': A<i32>\n+[294; 295) '1': i32\n+[306; 310) 'A(n)': A<i32>\n+[308; 309) 'n': &mut i32\n+[313; 322) '&mut A(1)': &mut A<i32>\n+[318; 319) 'A': A<i32>(T) -> A<T>\n+[318; 322) 'A(1)': A<i32>\n+[320; 321) '1': i32\n+[333; 334) 'v': &(i32, &i32)\n+[337; 345) '&(1, &2)': &(i32, &i32)\n+[338; 345) '(1, &2)': (i32, &i32)\n+[339; 340) '1': i32\n+[342; 344) '&2': &i32\n+[343; 344) '2': i32\n+[355; 362) '(_, &w)': (i32, &i32)\n+[356; 357) '_': i32\n+[359; 361) '&w': &i32\n+[360; 361) 'w': i32\n+[365; 366) 'v': &(i32, &i32)\n+[377; 389) 'ref ref_to_x': &&i32\n+[392; 393) 'x': &i32\n+[403; 412) 'mut mut_x': &i32\n+[415; 416) 'x': &i32\n+[426; 446) 'ref mu...f_to_x': &mut &i32\n+[449; 450) 'x': &i32\n+[460; 461) 'k': &mut &i32\n+[464; 476) 'mut_ref_to_x': &mut &i32\"###\n     );\n }\n "}]}