{"sha": "7f91697b5035f8620df4de47057024c3539b55a6", "node_id": "C_kwDOAAsO6NoAKDdmOTE2OTdiNTAzNWY4NjIwZGY0ZGU0NzA1NzAyNGMzNTM5YjU1YTY", "commit": {"author": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-03-26T07:27:43Z"}, "committer": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-04-05T06:01:02Z"}, "message": "errors: implement fallback diagnostic translation\n\nThis commit updates the signatures of all diagnostic functions to accept\ntypes that can be converted into a `DiagnosticMessage`. This enables\nexisting diagnostic calls to continue to work as before and Fluent\nidentifiers to be provided. The `SessionDiagnostic` derive just\ngenerates normal diagnostic calls, so these APIs had to be modified to\naccept Fluent identifiers.\n\nIn addition, loading of the \"fallback\" Fluent bundle, which contains the\nbuilt-in English messages, has been implemented.\n\nEach diagnostic now has \"arguments\" which correspond to variables in the\nFluent messages (necessary to render a Fluent message) but no API for\nadding arguments has been added yet. Therefore, diagnostics (that do not\nrequire interpolation) can be converted to use Fluent identifiers and\nwill be output as before.", "tree": {"sha": "a7f6e303b30ec5b3d675c362d474e1de0f3419ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7f6e303b30ec5b3d675c362d474e1de0f3419ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f91697b5035f8620df4de47057024c3539b55a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f91697b5035f8620df4de47057024c3539b55a6", "html_url": "https://github.com/rust-lang/rust/commit/7f91697b5035f8620df4de47057024c3539b55a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f91697b5035f8620df4de47057024c3539b55a6/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c45f29595df6f6a178b7998bc33c76099f3c12b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c45f29595df6f6a178b7998bc33c76099f3c12b7", "html_url": "https://github.com/rust-lang/rust/commit/c45f29595df6f6a178b7998bc33c76099f3c12b7"}], "stats": {"total": 1214, "additions": 920, "deletions": 294}, "files": [{"sha": "7983b79d5d6ebaf99eb45e5c0b360f5a71d23ed1", "filename": "Cargo.lock", "status": "modified", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -1238,6 +1238,50 @@ dependencies = [\n  \"miniz_oxide\",\n ]\n \n+[[package]]\n+name = \"fluent\"\n+version = \"0.16.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"61f69378194459db76abd2ce3952b790db103ceb003008d3d50d97c41ff847a7\"\n+dependencies = [\n+ \"fluent-bundle\",\n+ \"unic-langid\",\n+]\n+\n+[[package]]\n+name = \"fluent-bundle\"\n+version = \"0.15.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e242c601dec9711505f6d5bbff5bedd4b61b2469f2e8bb8e57ee7c9747a87ffd\"\n+dependencies = [\n+ \"fluent-langneg\",\n+ \"fluent-syntax\",\n+ \"intl-memoizer\",\n+ \"intl_pluralrules\",\n+ \"rustc-hash\",\n+ \"self_cell\",\n+ \"smallvec\",\n+ \"unic-langid\",\n+]\n+\n+[[package]]\n+name = \"fluent-langneg\"\n+version = \"0.13.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2c4ad0989667548f06ccd0e306ed56b61bd4d35458d54df5ec7587c0e8ed5e94\"\n+dependencies = [\n+ \"unic-langid\",\n+]\n+\n+[[package]]\n+name = \"fluent-syntax\"\n+version = \"0.11.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c0abed97648395c902868fee9026de96483933faa54ea3b40d652f7dfe61ca78\"\n+dependencies = [\n+ \"thiserror\",\n+]\n+\n [[package]]\n name = \"fnv\"\n version = \"1.0.7\"\n@@ -1782,6 +1826,26 @@ dependencies = [\n  \"cfg-if 1.0.0\",\n ]\n \n+[[package]]\n+name = \"intl-memoizer\"\n+version = \"0.5.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c310433e4a310918d6ed9243542a6b83ec1183df95dff8f23f87bb88a264a66f\"\n+dependencies = [\n+ \"type-map\",\n+ \"unic-langid\",\n+]\n+\n+[[package]]\n+name = \"intl_pluralrules\"\n+version = \"7.0.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b18f988384267d7066cc2be425e6faf352900652c046b6971d2e228d3b1c5ecf\"\n+dependencies = [\n+ \"tinystr\",\n+ \"unic-langid\",\n+]\n+\n [[package]]\n name = \"itertools\"\n version = \"0.10.1\"\n@@ -2812,6 +2876,12 @@ dependencies = [\n  \"version_check\",\n ]\n \n+[[package]]\n+name = \"proc-macro-hack\"\n+version = \"0.5.19\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"dbf0c48bc1d91375ae5c3cd81e3722dff1abcf81a30960240640d223f59fe0e5\"\n+\n [[package]]\n name = \"proc-macro2\"\n version = \"1.0.30\"\n@@ -3649,9 +3719,13 @@ version = \"0.0.0\"\n name = \"rustc_error_messages\"\n version = \"0.0.0\"\n dependencies = [\n+ \"fluent\",\n+ \"rustc_data_structures\",\n  \"rustc_macros\",\n  \"rustc_serialize\",\n  \"rustc_span\",\n+ \"tracing\",\n+ \"unic-langid\",\n ]\n \n [[package]]\n@@ -4585,6 +4659,12 @@ dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"self_cell\"\n+version = \"0.10.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1ef965a420fe14fdac7dd018862966a4c14094f900e1650bbc71ddd7d580c8af\"\n+\n [[package]]\n name = \"semver\"\n version = \"1.0.3\"\n@@ -5116,6 +5196,12 @@ dependencies = [\n  \"winapi\",\n ]\n \n+[[package]]\n+name = \"tinystr\"\n+version = \"0.3.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"29738eedb4388d9ea620eeab9384884fc3f06f586a2eddb56bedc5885126c7c1\"\n+\n [[package]]\n name = \"tinyvec\"\n version = \"0.3.4\"\n@@ -5274,6 +5360,15 @@ dependencies = [\n  \"tracing-subscriber\",\n ]\n \n+[[package]]\n+name = \"type-map\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b6d3364c5e96cb2ad1603037ab253ddd34d7fb72a58bdddf4b7350760fc69a46\"\n+dependencies = [\n+ \"rustc-hash\",\n+]\n+\n [[package]]\n name = \"typenum\"\n version = \"1.12.0\"\n@@ -5328,6 +5423,49 @@ dependencies = [\n  \"unic-ucd-version\",\n ]\n \n+[[package]]\n+name = \"unic-langid\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"73328fcd730a030bdb19ddf23e192187a6b01cd98be6d3140622a89129459ce5\"\n+dependencies = [\n+ \"unic-langid-impl\",\n+ \"unic-langid-macros\",\n+]\n+\n+[[package]]\n+name = \"unic-langid-impl\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"1a4a8eeaf0494862c1404c95ec2f4c33a2acff5076f64314b465e3ddae1b934d\"\n+dependencies = [\n+ \"tinystr\",\n+]\n+\n+[[package]]\n+name = \"unic-langid-macros\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"18f980d6d87e8805f2836d64b4138cc95aa7986fa63b1f51f67d5fbff64dd6e5\"\n+dependencies = [\n+ \"proc-macro-hack\",\n+ \"tinystr\",\n+ \"unic-langid-impl\",\n+ \"unic-langid-macros-impl\",\n+]\n+\n+[[package]]\n+name = \"unic-langid-macros-impl\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"29396ffd97e27574c3e01368b1a64267d3064969e4848e2e130ff668be9daa9f\"\n+dependencies = [\n+ \"proc-macro-hack\",\n+ \"quote\",\n+ \"syn\",\n+ \"unic-langid-impl\",\n+]\n+\n [[package]]\n name = \"unic-ucd-version\"\n version = \"0.9.0\""}, {"sha": "723adb8da1b173efe1669d9b8c306810ba017420", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -109,7 +109,7 @@ impl RegionName {\n                     *span,\n                     format!(\"lifetime `{}` represents this closure's body\", self),\n                 );\n-                diag.note(&note);\n+                diag.note(note);\n             }\n             RegionNameSource::AnonRegionFromArgument(RegionNameHighlight::CannotMatchHirTy(\n                 span,"}, {"sha": "92c4ab7eb8627b447dfb805d6e8fac4f79a31f4e", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -1707,23 +1707,33 @@ impl SharedEmitter {\n \n impl Emitter for SharedEmitter {\n     fn emit_diagnostic(&mut self, diag: &rustc_errors::Diagnostic) {\n+        let fluent_args = self.to_fluent_args(diag.args());\n         drop(self.sender.send(SharedEmitterMessage::Diagnostic(Diagnostic {\n-            msg: diag.message().to_string(),\n+            msg: self.translate_messages(&diag.message, &fluent_args).to_string(),\n             code: diag.code.clone(),\n             lvl: diag.level(),\n         })));\n         for child in &diag.children {\n             drop(self.sender.send(SharedEmitterMessage::Diagnostic(Diagnostic {\n-                msg: child.message().to_string(),\n+                msg: self.translate_messages(&child.message, &fluent_args).to_string(),\n                 code: None,\n                 lvl: child.level,\n             })));\n         }\n         drop(self.sender.send(SharedEmitterMessage::AbortIfErrors));\n     }\n+\n     fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n         None\n     }\n+\n+    fn fluent_bundle(&self) -> Option<&Lrc<rustc_errors::FluentBundle>> {\n+        None\n+    }\n+\n+    fn fallback_fluent_bundle(&self) -> &Lrc<rustc_errors::FluentBundle> {\n+        panic!(\"shared emitter attempted to translate a diagnostic\");\n+    }\n }\n \n impl SharedEmitterMain {\n@@ -1754,9 +1764,9 @@ impl SharedEmitterMain {\n                     let msg = msg.strip_prefix(\"error: \").unwrap_or(&msg);\n \n                     let mut err = match level {\n-                        Level::Error { lint: false } => sess.struct_err(&msg).forget_guarantee(),\n-                        Level::Warning => sess.struct_warn(&msg),\n-                        Level::Note => sess.struct_note_without_error(&msg),\n+                        Level::Error { lint: false } => sess.struct_err(msg).forget_guarantee(),\n+                        Level::Warning => sess.struct_warn(msg),\n+                        Level::Note => sess.struct_note_without_error(msg),\n                         _ => bug!(\"Invalid inline asm diagnostic level\"),\n                     };\n "}, {"sha": "c95c59904d1ff86fa45ba85b5f37ef64a841ef2f", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -1172,9 +1172,11 @@ static DEFAULT_HOOK: SyncLazy<Box<dyn Fn(&panic::PanicInfo<'_>) + Sync + Send +\n /// When `install_ice_hook` is called, this function will be called as the panic\n /// hook.\n pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n+    let fallback_bundle = rustc_errors::fallback_fluent_bundle();\n     let emitter = Box::new(rustc_errors::emitter::EmitterWriter::stderr(\n         rustc_errors::ColorConfig::Auto,\n         None,\n+        fallback_bundle,\n         false,\n         false,\n         None,\n@@ -1209,7 +1211,7 @@ pub fn report_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n     }\n \n     for note in &xs {\n-        handler.note_without_error(note);\n+        handler.note_without_error(note.as_ref());\n     }\n \n     // If backtraces are enabled, also print the query stack"}, {"sha": "abd565cd5296f9d726ed318a44f09a2de7bb3bf3", "filename": "compiler/rustc_error_messages/Cargo.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_error_messages%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_error_messages%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2FCargo.toml?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -7,6 +7,10 @@ edition = \"2021\"\n doctest = false\n \n [dependencies]\n+fluent = \"0.16.0\"\n+rustc_data_structures = { path = \"../rustc_data_structures\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_span = { path = \"../rustc_span\" }\n rustc_macros = { path = \"../rustc_macros\" }\n+tracing = \"0.1\"\n+unic-langid = { version = \"0.9.0\", features = [\"macros\"] }"}, {"sha": "e89fa586d2a8d081e13e233aff0d00432e41d490", "filename": "compiler/rustc_error_messages/locales/en-US/diagnostics.ftl", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdiagnostics.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdiagnostics.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fdiagnostics.ftl?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -0,0 +1,2 @@\n+parser-struct-literal-body-without-path = struct literal body without path\n+    .suggestion = you might have forgotten to add the struct literal inside the block"}, {"sha": "105bf1413de2eb1caba490cb9e94540ee18297ff", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 57, "deletions": 17, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -1,31 +1,75 @@\n+use rustc_data_structures::sync::Lrc;\n use rustc_macros::{Decodable, Encodable};\n use rustc_span::Span;\n+use std::borrow::Cow;\n+use tracing::debug;\n+\n+pub use fluent::{FluentArgs, FluentValue};\n+\n+static FALLBACK_FLUENT_RESOURCE: &'static str = include_str!(\"../locales/en-US/diagnostics.ftl\");\n+\n+pub type FluentBundle = fluent::FluentBundle<fluent::FluentResource>;\n+\n+/// Return the default `FluentBundle` with standard en-US diagnostic messages.\n+pub fn fallback_fluent_bundle() -> Lrc<FluentBundle> {\n+    let fallback_resource = fluent::FluentResource::try_new(FALLBACK_FLUENT_RESOURCE.to_string())\n+        .expect(\"failed to parse ftl resource\");\n+    debug!(?fallback_resource);\n+    let mut fallback_bundle = FluentBundle::new(vec![unic_langid::langid!(\"en-US\")]);\n+    fallback_bundle.add_resource(fallback_resource).expect(\"failed to add resource to bundle\");\n+    let fallback_bundle = Lrc::new(fallback_bundle);\n+    fallback_bundle\n+}\n+\n+/// Identifier for the Fluent message/attribute corresponding to a diagnostic message.\n+type FluentId = Cow<'static, str>;\n \n /// Abstraction over a message in a diagnostic to support both translatable and non-translatable\n /// diagnostic messages.\n+///\n+/// Intended to be removed once diagnostics are entirely translatable.\n #[derive(Clone, Debug, PartialEq, Eq, Hash, Encodable, Decodable)]\n pub enum DiagnosticMessage {\n     /// Non-translatable diagnostic message.\n+    // FIXME(davidtwco): can a `Cow<'static, str>` be used here?\n     Str(String),\n     /// Identifier for a Fluent message corresponding to the diagnostic message.\n-    FluentIdentifier(String),\n+    FluentIdentifier(FluentId, Option<FluentId>),\n }\n \n impl DiagnosticMessage {\n-    /// Convert `DiagnosticMessage` to a `&str`.\n-    pub fn as_str(&self) -> &str {\n+    /// Returns the `String` contained within the `DiagnosticMessage::Str` variant, assuming that\n+    /// this diagnostic message is of the legacy, non-translatable variety. Panics if this\n+    /// assumption does not hold.\n+    ///\n+    /// Don't use this - it exists to support some places that do comparison with diagnostic\n+    /// strings.\n+    pub fn expect_str(&self) -> &str {\n         match self {\n-            DiagnosticMessage::Str(msg) => msg,\n-            DiagnosticMessage::FluentIdentifier(..) => unimplemented!(),\n+            DiagnosticMessage::Str(s) => s,\n+            _ => panic!(\"expected non-translatable diagnostic message\"),\n         }\n     }\n \n-    /// Convert `DiagnosticMessage` to an owned `String`.\n-    pub fn to_string(self) -> String {\n-        match self {\n-            DiagnosticMessage::Str(msg) => msg,\n-            DiagnosticMessage::FluentIdentifier(..) => unimplemented!(),\n-        }\n+    /// Create a `DiagnosticMessage` for the provided Fluent identifier.\n+    pub fn fluent(id: impl Into<Cow<'static, str>>) -> Self {\n+        DiagnosticMessage::FluentIdentifier(id.into(), None)\n+    }\n+\n+    /// Create a `DiagnosticMessage` for the provided Fluent identifier and attribute.\n+    pub fn fluent_attr(\n+        id: impl Into<Cow<'static, str>>,\n+        attr: impl Into<Cow<'static, str>>,\n+    ) -> Self {\n+        DiagnosticMessage::FluentIdentifier(id.into(), Some(attr.into()))\n+    }\n+}\n+\n+/// `From` impl that enables existing diagnostic calls to functions which now take\n+/// `impl Into<DiagnosticMessage>` to continue to work as before.\n+impl<S: Into<String>> From<S> for DiagnosticMessage {\n+    fn from(s: S) -> Self {\n+        DiagnosticMessage::Str(s.into())\n     }\n }\n \n@@ -72,12 +116,8 @@ impl MultiSpan {\n         MultiSpan { primary_spans: vec, span_labels: vec![] }\n     }\n \n-    pub fn push_span_label(&mut self, span: Span, label: String) {\n-        self.span_labels.push((span, DiagnosticMessage::Str(label)));\n-    }\n-\n-    pub fn push_span_message(&mut self, span: Span, message: DiagnosticMessage) {\n-        self.span_labels.push((span, message));\n+    pub fn push_span_label(&mut self, span: Span, label: impl Into<DiagnosticMessage>) {\n+        self.span_labels.push((span, label.into()));\n     }\n \n     /// Selects the first primary span (if any)."}, {"sha": "4dc99b8dd0f9cc7953af908c807653fdd57bc7c1", "filename": "compiler/rustc_errors/src/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -7,16 +7,22 @@\n \n use crate::emitter::FileWithAnnotatedLines;\n use crate::snippet::Line;\n-use crate::{CodeSuggestion, Diagnostic, DiagnosticId, Emitter, Level, MultiSpan, SubDiagnostic};\n+use crate::{\n+    CodeSuggestion, Diagnostic, DiagnosticId, DiagnosticMessage, Emitter, FluentBundle, Level,\n+    MultiSpan, Style, SubDiagnostic,\n+};\n use annotate_snippets::display_list::{DisplayList, FormatOptions};\n use annotate_snippets::snippet::*;\n use rustc_data_structures::sync::Lrc;\n+use rustc_error_messages::FluentArgs;\n use rustc_span::source_map::SourceMap;\n use rustc_span::SourceFile;\n \n /// Generates diagnostics using annotate-snippet\n pub struct AnnotateSnippetEmitterWriter {\n     source_map: Option<Lrc<SourceMap>>,\n+    fallback_bundle: Lrc<FluentBundle>,\n+\n     /// If true, hides the longer explanation text\n     short_message: bool,\n     /// If true, will normalize line numbers with `LL` to prevent noise in UI test diffs.\n@@ -28,8 +34,10 @@ pub struct AnnotateSnippetEmitterWriter {\n impl Emitter for AnnotateSnippetEmitterWriter {\n     /// The entry point for the diagnostics generation\n     fn emit_diagnostic(&mut self, diag: &Diagnostic) {\n+        let fluent_args = self.to_fluent_args(diag.args());\n+\n         let mut children = diag.children.clone();\n-        let (mut primary_span, suggestions) = self.primary_span_formatted(&diag);\n+        let (mut primary_span, suggestions) = self.primary_span_formatted(&diag, &fluent_args);\n \n         self.fix_multispans_in_extern_macros_and_render_macro_backtrace(\n             &self.source_map,\n@@ -41,7 +49,8 @@ impl Emitter for AnnotateSnippetEmitterWriter {\n \n         self.emit_messages_default(\n             &diag.level,\n-            diag.message().to_string(),\n+            &diag.message,\n+            &fluent_args,\n             &diag.code,\n             &primary_span,\n             &children,\n@@ -53,6 +62,14 @@ impl Emitter for AnnotateSnippetEmitterWriter {\n         self.source_map.as_ref()\n     }\n \n+    fn fluent_bundle(&self) -> Option<&Lrc<FluentBundle>> {\n+        None\n+    }\n+\n+    fn fallback_fluent_bundle(&self) -> &Lrc<FluentBundle> {\n+        &self.fallback_bundle\n+    }\n+\n     fn should_show_explain(&self) -> bool {\n         !self.short_message\n     }\n@@ -82,10 +99,11 @@ fn annotation_type_for_level(level: Level) -> AnnotationType {\n impl AnnotateSnippetEmitterWriter {\n     pub fn new(\n         source_map: Option<Lrc<SourceMap>>,\n+        fallback_bundle: Lrc<FluentBundle>,\n         short_message: bool,\n         macro_backtrace: bool,\n     ) -> Self {\n-        Self { source_map, short_message, ui_testing: false, macro_backtrace }\n+        Self { source_map, fallback_bundle, short_message, ui_testing: false, macro_backtrace }\n     }\n \n     /// Allows to modify `Self` to enable or disable the `ui_testing` flag.\n@@ -99,12 +117,14 @@ impl AnnotateSnippetEmitterWriter {\n     fn emit_messages_default(\n         &mut self,\n         level: &Level,\n-        message: String,\n+        messages: &[(DiagnosticMessage, Style)],\n+        args: &FluentArgs<'_>,\n         code: &Option<DiagnosticId>,\n         msp: &MultiSpan,\n         _children: &[SubDiagnostic],\n         _suggestions: &[CodeSuggestion],\n     ) {\n+        let message = self.translate_messages(messages, args);\n         if let Some(source_map) = &self.source_map {\n             // Make sure our primary file comes first\n             let primary_lo = if let Some(ref primary_span) = msp.primary_span().as_ref() {\n@@ -120,8 +140,7 @@ impl AnnotateSnippetEmitterWriter {\n                 // should be done if it happens\n                 return;\n             };\n-            let mut annotated_files =\n-                FileWithAnnotatedLines::collect_annotations(msp, &self.source_map);\n+            let mut annotated_files = FileWithAnnotatedLines::collect_annotations(self, args, msp);\n             if let Ok(pos) =\n                 annotated_files.binary_search_by(|x| x.file.name.cmp(&primary_lo.file.name))\n             {"}, {"sha": "4a140eaf0b59b01f46e5c0ed902b914253f68698", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 90, "deletions": 51, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -4,10 +4,12 @@ use crate::{\n     SuggestionStyle, ToolMetadata,\n };\n use rustc_data_structures::stable_map::FxHashMap;\n+use rustc_error_messages::FluentValue;\n use rustc_lint_defs::{Applicability, LintExpectationId};\n use rustc_serialize::json::Json;\n use rustc_span::edition::LATEST_STABLE_EDITION;\n use rustc_span::{Span, DUMMY_SP};\n+use std::borrow::Cow;\n use std::fmt;\n use std::hash::{Hash, Hasher};\n \n@@ -16,6 +18,28 @@ use std::hash::{Hash, Hasher};\n #[derive(Clone, Debug, PartialEq, Eq, Hash, Encodable, Decodable)]\n pub struct SuggestionsDisabled;\n \n+/// Simplified version of `FluentArg` that can implement `Encodable` and `Decodable`. Collection of\n+/// `DiagnosticArg` are converted to `FluentArgs` (consuming the collection) at the start of\n+/// diagnostic emission.\n+pub type DiagnosticArg<'source> = (Cow<'source, str>, DiagnosticArgValue<'source>);\n+\n+/// Simplified version of `FluentValue` that can implement `Encodable` and `Decodable`. Converted\n+/// to a `FluentValue` by the emitter to be used in diagnostic translation.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Encodable, Decodable)]\n+pub enum DiagnosticArgValue<'source> {\n+    Str(Cow<'source, str>),\n+    Number(usize),\n+}\n+\n+impl<'source> Into<FluentValue<'source>> for DiagnosticArgValue<'source> {\n+    fn into(self) -> FluentValue<'source> {\n+        match self {\n+            DiagnosticArgValue::Str(s) => From::from(s),\n+            DiagnosticArgValue::Number(n) => From::from(n),\n+        }\n+    }\n+}\n+\n #[must_use]\n #[derive(Clone, Debug, Encodable, Decodable)]\n pub struct Diagnostic {\n@@ -28,6 +52,7 @@ pub struct Diagnostic {\n     pub span: MultiSpan,\n     pub children: Vec<SubDiagnostic>,\n     pub suggestions: Result<Vec<CodeSuggestion>, SuggestionsDisabled>,\n+    args: Vec<DiagnosticArg<'static>>,\n \n     /// This is not used for highlighting or rendering any error message.  Rather, it can be used\n     /// as a sort key to sort a buffer of diagnostics.  By default, it is the primary span of\n@@ -103,18 +128,23 @@ impl StringPart {\n }\n \n impl Diagnostic {\n-    pub fn new(level: Level, message: &str) -> Self {\n+    pub fn new<M: Into<DiagnosticMessage>>(level: Level, message: M) -> Self {\n         Diagnostic::new_with_code(level, None, message)\n     }\n \n-    pub fn new_with_code(level: Level, code: Option<DiagnosticId>, message: &str) -> Self {\n+    pub fn new_with_code<M: Into<DiagnosticMessage>>(\n+        level: Level,\n+        code: Option<DiagnosticId>,\n+        message: M,\n+    ) -> Self {\n         Diagnostic {\n             level,\n-            message: vec![(DiagnosticMessage::Str(message.to_owned()), Style::NoStyle)],\n+            message: vec![(message.into(), Style::NoStyle)],\n             code,\n             span: MultiSpan::new(),\n             children: vec![],\n             suggestions: Ok(vec![]),\n+            args: vec![],\n             sort_span: DUMMY_SP,\n             is_lint: false,\n         }\n@@ -232,7 +262,7 @@ impl Diagnostic {\n         self.set_span(after);\n         for span_label in before.span_labels() {\n             if let Some(label) = span_label.label {\n-                self.span.push_span_message(after, label);\n+                self.span.push_span_label(after, label);\n             }\n         }\n         self\n@@ -326,52 +356,67 @@ impl Diagnostic {\n     }\n \n     /// Add a note attached to this diagnostic.\n-    pub fn note(&mut self, msg: &str) -> &mut Self {\n+    pub fn note(&mut self, msg: impl Into<DiagnosticMessage>) -> &mut Self {\n         self.sub(Level::Note, msg, MultiSpan::new(), None);\n         self\n     }\n \n-    pub fn highlighted_note(&mut self, msg: Vec<(String, Style)>) -> &mut Self {\n+    pub fn highlighted_note<M: Into<DiagnosticMessage>>(\n+        &mut self,\n+        msg: Vec<(M, Style)>,\n+    ) -> &mut Self {\n         self.sub_with_highlights(Level::Note, msg, MultiSpan::new(), None);\n         self\n     }\n \n     /// Prints the span with a note above it.\n     /// This is like [`Diagnostic::note()`], but it gets its own span.\n-    pub fn note_once(&mut self, msg: &str) -> &mut Self {\n+    pub fn note_once(&mut self, msg: impl Into<DiagnosticMessage>) -> &mut Self {\n         self.sub(Level::OnceNote, msg, MultiSpan::new(), None);\n         self\n     }\n \n     /// Prints the span with a note above it.\n     /// This is like [`Diagnostic::note()`], but it gets its own span.\n-    pub fn span_note<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n+    pub fn span_note<S: Into<MultiSpan>>(\n+        &mut self,\n+        sp: S,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> &mut Self {\n         self.sub(Level::Note, msg, sp.into(), None);\n         self\n     }\n \n     /// Prints the span with a note above it.\n     /// This is like [`Diagnostic::note()`], but it gets its own span.\n-    pub fn span_note_once<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n+    pub fn span_note_once<S: Into<MultiSpan>>(\n+        &mut self,\n+        sp: S,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> &mut Self {\n         self.sub(Level::OnceNote, msg, sp.into(), None);\n         self\n     }\n \n     /// Add a warning attached to this diagnostic.\n-    pub fn warn(&mut self, msg: &str) -> &mut Self {\n+    pub fn warn(&mut self, msg: impl Into<DiagnosticMessage>) -> &mut Self {\n         self.sub(Level::Warning, msg, MultiSpan::new(), None);\n         self\n     }\n \n     /// Prints the span with a warning above it.\n     /// This is like [`Diagnostic::warn()`], but it gets its own span.\n-    pub fn span_warn<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n+    pub fn span_warn<S: Into<MultiSpan>>(\n+        &mut self,\n+        sp: S,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> &mut Self {\n         self.sub(Level::Warning, msg, sp.into(), None);\n         self\n     }\n \n     /// Add a help message attached to this diagnostic.\n-    pub fn help(&mut self, msg: &str) -> &mut Self {\n+    pub fn help(&mut self, msg: impl Into<DiagnosticMessage>) -> &mut Self {\n         self.sub(Level::Help, msg, MultiSpan::new(), None);\n         self\n     }\n@@ -384,7 +429,11 @@ impl Diagnostic {\n \n     /// Prints the span with some help above it.\n     /// This is like [`Diagnostic::help()`], but it gets its own span.\n-    pub fn span_help<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n+    pub fn span_help<S: Into<MultiSpan>>(\n+        &mut self,\n+        sp: S,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> &mut Self {\n         self.sub(Level::Help, msg, sp.into(), None);\n         self\n     }\n@@ -420,7 +469,7 @@ impl Diagnostic {\n     /// In other words, multiple changes need to be applied as part of this suggestion.\n     pub fn multipart_suggestion(\n         &mut self,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n     ) -> &mut Self {\n@@ -436,7 +485,7 @@ impl Diagnostic {\n     /// In other words, multiple changes need to be applied as part of this suggestion.\n     pub fn multipart_suggestion_verbose(\n         &mut self,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n     ) -> &mut Self {\n@@ -450,7 +499,7 @@ impl Diagnostic {\n     /// [`Diagnostic::multipart_suggestion()`] but you can set the [`SuggestionStyle`].\n     pub fn multipart_suggestion_with_style(\n         &mut self,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n         style: SuggestionStyle,\n@@ -463,7 +512,7 @@ impl Diagnostic {\n                     .map(|(span, snippet)| SubstitutionPart { snippet, span })\n                     .collect(),\n             }],\n-            msg: DiagnosticMessage::Str(msg.to_owned()),\n+            msg: msg.into(),\n             style,\n             applicability,\n             tool_metadata: Default::default(),\n@@ -479,7 +528,7 @@ impl Diagnostic {\n     /// improve understandability.\n     pub fn tool_only_multipart_suggestion(\n         &mut self,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n     ) -> &mut Self {\n@@ -491,7 +540,7 @@ impl Diagnostic {\n                     .map(|(span, snippet)| SubstitutionPart { snippet, span })\n                     .collect(),\n             }],\n-            msg: DiagnosticMessage::Str(msg.to_owned()),\n+            msg: msg.into(),\n             style: SuggestionStyle::CompletelyHidden,\n             applicability,\n             tool_metadata: Default::default(),\n@@ -519,7 +568,7 @@ impl Diagnostic {\n     pub fn span_suggestion(\n         &mut self,\n         sp: Span,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: String,\n         applicability: Applicability,\n     ) -> &mut Self {\n@@ -537,7 +586,7 @@ impl Diagnostic {\n     pub fn span_suggestion_with_style(\n         &mut self,\n         sp: Span,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: String,\n         applicability: Applicability,\n         style: SuggestionStyle,\n@@ -546,7 +595,7 @@ impl Diagnostic {\n             substitutions: vec![Substitution {\n                 parts: vec![SubstitutionPart { snippet: suggestion, span: sp }],\n             }],\n-            msg: DiagnosticMessage::Str(msg.to_owned()),\n+            msg: msg.into(),\n             style,\n             applicability,\n             tool_metadata: Default::default(),\n@@ -558,7 +607,7 @@ impl Diagnostic {\n     pub fn span_suggestion_verbose(\n         &mut self,\n         sp: Span,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: String,\n         applicability: Applicability,\n     ) -> &mut Self {\n@@ -577,7 +626,7 @@ impl Diagnostic {\n     pub fn span_suggestions(\n         &mut self,\n         sp: Span,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestions: impl Iterator<Item = String>,\n         applicability: Applicability,\n     ) -> &mut Self {\n@@ -589,7 +638,7 @@ impl Diagnostic {\n             .collect();\n         self.push_suggestion(CodeSuggestion {\n             substitutions,\n-            msg: DiagnosticMessage::Str(msg.to_owned()),\n+            msg: msg.into(),\n             style: SuggestionStyle::ShowCode,\n             applicability,\n             tool_metadata: Default::default(),\n@@ -601,7 +650,7 @@ impl Diagnostic {\n     /// See also [`Diagnostic::span_suggestion()`].\n     pub fn multipart_suggestions(\n         &mut self,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestions: impl Iterator<Item = Vec<(Span, String)>>,\n         applicability: Applicability,\n     ) -> &mut Self {\n@@ -614,7 +663,7 @@ impl Diagnostic {\n                         .collect(),\n                 })\n                 .collect(),\n-            msg: DiagnosticMessage::Str(msg.to_owned()),\n+            msg: msg.into(),\n             style: SuggestionStyle::ShowCode,\n             applicability,\n             tool_metadata: Default::default(),\n@@ -628,7 +677,7 @@ impl Diagnostic {\n     pub fn span_suggestion_short(\n         &mut self,\n         sp: Span,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: String,\n         applicability: Applicability,\n     ) -> &mut Self {\n@@ -651,7 +700,7 @@ impl Diagnostic {\n     pub fn span_suggestion_hidden(\n         &mut self,\n         sp: Span,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: String,\n         applicability: Applicability,\n     ) -> &mut Self {\n@@ -672,7 +721,7 @@ impl Diagnostic {\n     pub fn tool_only_span_suggestion(\n         &mut self,\n         sp: Span,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: String,\n         applicability: Applicability,\n     ) -> &mut Self {\n@@ -690,13 +739,13 @@ impl Diagnostic {\n     /// the suggestion in a tool-specific way, as it may not even directly involve Rust code.\n     pub fn tool_only_suggestion_with_metadata(\n         &mut self,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         applicability: Applicability,\n         tool_metadata: Json,\n     ) {\n         self.push_suggestion(CodeSuggestion {\n             substitutions: vec![],\n-            msg: DiagnosticMessage::Str(msg.to_owned()),\n+            msg: msg.into(),\n             style: SuggestionStyle::CompletelyHidden,\n             applicability,\n             tool_metadata: ToolMetadata::new(tool_metadata),\n@@ -730,13 +779,13 @@ impl Diagnostic {\n         self.code.clone()\n     }\n \n-    pub fn set_primary_message<M: Into<String>>(&mut self, msg: M) -> &mut Self {\n-        self.message[0] = (DiagnosticMessage::Str(msg.into()), Style::NoStyle);\n+    pub fn set_primary_message(&mut self, msg: impl Into<DiagnosticMessage>) -> &mut Self {\n+        self.message[0] = (msg.into(), Style::NoStyle);\n         self\n     }\n \n-    pub fn message(&self) -> DiagnosticMessage {\n-        DiagnosticMessage::Str(self.message.iter().map(|i| i.0.as_str()).collect::<String>())\n+    pub fn args(&self) -> &[DiagnosticArg<'static>] {\n+        &self.args\n     }\n \n     pub fn styled_message(&self) -> &Vec<(DiagnosticMessage, Style)> {\n@@ -750,13 +799,13 @@ impl Diagnostic {\n     pub fn sub(\n         &mut self,\n         level: Level,\n-        message: &str,\n+        message: impl Into<DiagnosticMessage>,\n         span: MultiSpan,\n         render_span: Option<MultiSpan>,\n     ) {\n         let sub = SubDiagnostic {\n             level,\n-            message: vec![(DiagnosticMessage::Str(message.to_owned()), Style::NoStyle)],\n+            message: vec![(message.into(), Style::NoStyle)],\n             span,\n             render_span,\n         };\n@@ -765,14 +814,14 @@ impl Diagnostic {\n \n     /// Convenience function for internal use, clients should use one of the\n     /// public methods above.\n-    fn sub_with_highlights(\n+    fn sub_with_highlights<M: Into<DiagnosticMessage>>(\n         &mut self,\n         level: Level,\n-        mut message: Vec<(String, Style)>,\n+        mut message: Vec<(M, Style)>,\n         span: MultiSpan,\n         render_span: Option<MultiSpan>,\n     ) {\n-        let message = message.drain(..).map(|m| (DiagnosticMessage::Str(m.0), m.1)).collect();\n+        let message = message.drain(..).map(|m| (m.0.into(), m.1)).collect();\n         let sub = SubDiagnostic { level, message, span, render_span };\n         self.children.push(sub);\n     }\n@@ -813,13 +862,3 @@ impl PartialEq for Diagnostic {\n         self.keys() == other.keys()\n     }\n }\n-\n-impl SubDiagnostic {\n-    pub fn message(&self) -> DiagnosticMessage {\n-        DiagnosticMessage::Str(self.message.iter().map(|i| i.0.as_str()).collect::<String>())\n-    }\n-\n-    pub fn styled_message(&self) -> &Vec<(DiagnosticMessage, Style)> {\n-        &self.message\n-    }\n-}"}, {"sha": "9669941fd085ecf7daa6eeb24ae985d3db88da8b", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 32, "deletions": 23, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -1,4 +1,4 @@\n-use crate::{Diagnostic, DiagnosticId, DiagnosticStyledString, ErrorGuaranteed};\n+use crate::{Diagnostic, DiagnosticId, DiagnosticMessage, DiagnosticStyledString, ErrorGuaranteed};\n use crate::{Handler, Level, MultiSpan, StashKey};\n use rustc_lint_defs::Applicability;\n \n@@ -99,7 +99,10 @@ mod sealed_level_is_error {\n impl<'a> DiagnosticBuilder<'a, ErrorGuaranteed> {\n     /// Convenience function for internal use, clients should use one of the\n     /// `struct_*` methods on [`Handler`].\n-    crate fn new_guaranteeing_error<const L: Level>(handler: &'a Handler, message: &str) -> Self\n+    crate fn new_guaranteeing_error<M: Into<DiagnosticMessage>, const L: Level>(\n+        handler: &'a Handler,\n+        message: M,\n+    ) -> Self\n     where\n         (): sealed_level_is_error::IsError<L>,\n     {\n@@ -163,7 +166,11 @@ impl EmissionGuarantee for ErrorGuaranteed {\n impl<'a> DiagnosticBuilder<'a, ()> {\n     /// Convenience function for internal use, clients should use one of the\n     /// `struct_*` methods on [`Handler`].\n-    crate fn new(handler: &'a Handler, level: Level, message: &str) -> Self {\n+    crate fn new<M: Into<DiagnosticMessage>>(\n+        handler: &'a Handler,\n+        level: Level,\n+        message: M,\n+    ) -> Self {\n         let diagnostic = Diagnostic::new_with_code(level, None, message);\n         Self::new_diagnostic(handler, diagnostic)\n     }\n@@ -201,7 +208,7 @@ impl EmissionGuarantee for () {\n impl<'a> DiagnosticBuilder<'a, !> {\n     /// Convenience function for internal use, clients should use one of the\n     /// `struct_*` methods on [`Handler`].\n-    crate fn new_fatal(handler: &'a Handler, message: &str) -> Self {\n+    crate fn new_fatal(handler: &'a Handler, message: impl Into<DiagnosticMessage>) -> Self {\n         let diagnostic = Diagnostic::new_with_code(Level::Fatal, None, message);\n         Self::new_diagnostic_fatal(handler, diagnostic)\n     }\n@@ -346,7 +353,7 @@ impl<'a, G: EmissionGuarantee> DiagnosticBuilder<'a, G> {\n         }\n \n         // Take the `Diagnostic` by replacing it with a dummy.\n-        let dummy = Diagnostic::new(Level::Allow, \"\");\n+        let dummy = Diagnostic::new(Level::Allow, DiagnosticMessage::Str(\"\".to_string()));\n         let diagnostic = std::mem::replace(&mut *self.inner.diagnostic, dummy);\n \n         // Disable the ICE on `Drop`.\n@@ -434,25 +441,25 @@ impl<'a, G: EmissionGuarantee> DiagnosticBuilder<'a, G> {\n         found: DiagnosticStyledString,\n     ) -> &mut Self);\n \n-    forward!(pub fn note(&mut self, msg: &str) -> &mut Self);\n-    forward!(pub fn note_once(&mut self, msg: &str) -> &mut Self);\n+    forward!(pub fn note(&mut self, msg: impl Into<DiagnosticMessage>) -> &mut Self);\n+    forward!(pub fn note_once(&mut self, msg: impl Into<DiagnosticMessage>) -> &mut Self);\n     forward!(pub fn span_note(\n         &mut self,\n         sp: impl Into<MultiSpan>,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n     ) -> &mut Self);\n     forward!(pub fn span_note_once(\n         &mut self,\n         sp: impl Into<MultiSpan>,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n     ) -> &mut Self);\n-    forward!(pub fn warn(&mut self, msg: &str) -> &mut Self);\n+    forward!(pub fn warn(&mut self, msg: impl Into<DiagnosticMessage>) -> &mut Self);\n     forward!(pub fn span_warn(&mut self, sp: impl Into<MultiSpan>, msg: &str) -> &mut Self);\n-    forward!(pub fn help(&mut self, msg: &str) -> &mut Self);\n+    forward!(pub fn help(&mut self, msg: impl Into<DiagnosticMessage>) -> &mut Self);\n     forward!(pub fn span_help(\n         &mut self,\n         sp: impl Into<MultiSpan>,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n     ) -> &mut Self);\n     forward!(pub fn help_use_latest_edition(&mut self,) -> &mut Self);\n     forward!(pub fn set_is_lint(&mut self,) -> &mut Self);\n@@ -461,67 +468,67 @@ impl<'a, G: EmissionGuarantee> DiagnosticBuilder<'a, G> {\n \n     forward!(pub fn multipart_suggestion(\n         &mut self,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n     ) -> &mut Self);\n     forward!(pub fn multipart_suggestion_verbose(\n         &mut self,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n     ) -> &mut Self);\n     forward!(pub fn tool_only_multipart_suggestion(\n         &mut self,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: Vec<(Span, String)>,\n         applicability: Applicability,\n     ) -> &mut Self);\n     forward!(pub fn span_suggestion(\n         &mut self,\n         sp: Span,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: String,\n         applicability: Applicability,\n     ) -> &mut Self);\n     forward!(pub fn span_suggestions(\n         &mut self,\n         sp: Span,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestions: impl Iterator<Item = String>,\n         applicability: Applicability,\n     ) -> &mut Self);\n     forward!(pub fn multipart_suggestions(\n         &mut self,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestions: impl Iterator<Item = Vec<(Span, String)>>,\n         applicability: Applicability,\n     ) -> &mut Self);\n     forward!(pub fn span_suggestion_short(\n         &mut self,\n         sp: Span,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: String,\n         applicability: Applicability,\n     ) -> &mut Self);\n     forward!(pub fn span_suggestion_verbose(\n         &mut self,\n         sp: Span,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: String,\n         applicability: Applicability,\n     ) -> &mut Self);\n     forward!(pub fn span_suggestion_hidden(\n         &mut self,\n         sp: Span,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: String,\n         applicability: Applicability,\n     ) -> &mut Self);\n     forward!(pub fn tool_only_span_suggestion(\n         &mut self,\n         sp: Span,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         suggestion: String,\n         applicability: Applicability,\n     ) -> &mut Self);\n@@ -547,7 +554,9 @@ impl Drop for DiagnosticBuilderInner<'_> {\n                 if !panicking() {\n                     handler.emit_diagnostic(&mut Diagnostic::new(\n                         Level::Bug,\n-                        \"the following error was constructed but not emitted\",\n+                        DiagnosticMessage::Str(\n+                            \"the following error was constructed but not emitted\".to_string(),\n+                        ),\n                     ));\n                     handler.emit_diagnostic(&mut self.diagnostic);\n                     panic!();"}, {"sha": "43bcaa646f345c1873e6c2ab43e6c34822ae1d74", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 135, "deletions": 21, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -15,14 +15,15 @@ use rustc_span::{SourceFile, Span};\n use crate::snippet::{Annotation, AnnotationType, Line, MultilineAnnotation, Style, StyledString};\n use crate::styled_buffer::StyledBuffer;\n use crate::{\n-    CodeSuggestion, Diagnostic, DiagnosticId, DiagnosticMessage, Handler, Level, MultiSpan,\n-    SubDiagnostic, SubstitutionHighlight, SuggestionStyle,\n+    CodeSuggestion, Diagnostic, DiagnosticArg, DiagnosticId, DiagnosticMessage, FluentBundle,\n+    Handler, Level, MultiSpan, SubDiagnostic, SubstitutionHighlight, SuggestionStyle,\n };\n \n use rustc_lint_defs::pluralize;\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::Lrc;\n+use rustc_error_messages::FluentArgs;\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n use std::borrow::Cow;\n use std::cmp::{max, min, Reverse};\n@@ -58,13 +59,23 @@ impl HumanReadableErrorType {\n         self,\n         dst: Box<dyn Write + Send>,\n         source_map: Option<Lrc<SourceMap>>,\n+        fallback_bundle: Lrc<FluentBundle>,\n         teach: bool,\n         terminal_width: Option<usize>,\n         macro_backtrace: bool,\n     ) -> EmitterWriter {\n         let (short, color_config) = self.unzip();\n         let color = color_config.suggests_using_colors();\n-        EmitterWriter::new(dst, source_map, short, teach, color, terminal_width, macro_backtrace)\n+        EmitterWriter::new(\n+            dst,\n+            source_map,\n+            fallback_bundle,\n+            short,\n+            teach,\n+            color,\n+            terminal_width,\n+            macro_backtrace,\n+        )\n     }\n }\n \n@@ -212,6 +223,68 @@ pub trait Emitter {\n \n     fn source_map(&self) -> Option<&Lrc<SourceMap>>;\n \n+    /// Return `FluentBundle` with localized diagnostics for the locale requested by the user. If no\n+    /// language was requested by the user then this will be `None` and `fallback_fluent_bundle`\n+    /// should be used.\n+    fn fluent_bundle(&self) -> Option<&Lrc<FluentBundle>>;\n+\n+    /// Return `FluentBundle` with localized diagnostics for the default locale of the compiler.\n+    /// Used when the user has not requested a specific language or when a localized diagnostic is\n+    /// unavailable for the requested locale.\n+    fn fallback_fluent_bundle(&self) -> &Lrc<FluentBundle>;\n+\n+    /// Convert diagnostic arguments (a rustc internal type that exists to implement\n+    /// `Encodable`/`Decodable`) into `FluentArgs` which is necessary to perform translation.\n+    ///\n+    /// Typically performed once for each diagnostic at the start of `emit_diagnostic` and then\n+    /// passed around as a reference thereafter.\n+    fn to_fluent_args<'arg>(&self, args: &[DiagnosticArg<'arg>]) -> FluentArgs<'arg> {\n+        FromIterator::from_iter(args.to_vec().drain(..))\n+    }\n+\n+    /// Convert `DiagnosticMessage`s to a string, performing translation if necessary.\n+    fn translate_messages(\n+        &self,\n+        messages: &[(DiagnosticMessage, Style)],\n+        args: &FluentArgs<'_>,\n+    ) -> Cow<'_, str> {\n+        Cow::Owned(\n+            messages.iter().map(|(m, _)| self.translate_message(m, args)).collect::<String>(),\n+        )\n+    }\n+\n+    /// Convert a `DiagnosticMessage` to a string, performing translation if necessary.\n+    fn translate_message<'a>(\n+        &'a self,\n+        message: &'a DiagnosticMessage,\n+        args: &'a FluentArgs<'_>,\n+    ) -> Cow<'_, str> {\n+        trace!(?message);\n+        let (identifier, attr) = match message {\n+            DiagnosticMessage::Str(msg) => return Cow::Borrowed(&msg),\n+            DiagnosticMessage::FluentIdentifier(identifier, attr) => (identifier, attr),\n+        };\n+\n+        let bundle = match self.fluent_bundle() {\n+            Some(bundle) if bundle.has_message(&identifier) => bundle,\n+            _ => self.fallback_fluent_bundle(),\n+        };\n+\n+        let message = bundle.get_message(&identifier).expect(\"missing diagnostic in fluent bundle\");\n+        let value = match attr {\n+            Some(attr) => {\n+                message.get_attribute(attr).expect(\"missing attribute in fluent message\").value()\n+            }\n+            None => message.value().expect(\"missing value in fluent message\"),\n+        };\n+\n+        let mut err = vec![];\n+        let translated = bundle.format_pattern(value, Some(&args), &mut err);\n+        trace!(?translated, ?err);\n+        debug_assert!(err.is_empty());\n+        translated\n+    }\n+\n     /// Formats the substitutions of the primary_span\n     ///\n     /// There are a lot of conditions to this method, but in short:\n@@ -225,18 +298,20 @@ pub trait Emitter {\n     fn primary_span_formatted<'a>(\n         &mut self,\n         diag: &'a Diagnostic,\n+        fluent_args: &FluentArgs<'_>,\n     ) -> (MultiSpan, &'a [CodeSuggestion]) {\n         let mut primary_span = diag.span.clone();\n         let suggestions = diag.suggestions.as_ref().map_or(&[][..], |suggestions| &suggestions[..]);\n         if let Some((sugg, rest)) = suggestions.split_first() {\n+            let msg = self.translate_message(&sugg.msg, fluent_args);\n             if rest.is_empty() &&\n                // ^ if there is only one suggestion\n                // don't display multi-suggestions as labels\n                sugg.substitutions.len() == 1 &&\n                // don't display multipart suggestions as labels\n                sugg.substitutions[0].parts.len() == 1 &&\n                // don't display long messages as labels\n-               sugg.msg.as_str().split_whitespace().count() < 10 &&\n+               msg.split_whitespace().count() < 10 &&\n                // don't display multiline suggestions as labels\n                !sugg.substitutions[0].parts[0].snippet.contains('\\n') &&\n                ![\n@@ -252,12 +327,12 @@ pub trait Emitter {\n                 let msg = if substitution.is_empty() || sugg.style.hide_inline() {\n                     // This substitution is only removal OR we explicitly don't want to show the\n                     // code inline (`hide_inline`). Therefore, we don't show the substitution.\n-                    format!(\"help: {}\", sugg.msg.as_str())\n+                    format!(\"help: {}\", &msg)\n                 } else {\n                     // Show the default suggestion text with the substitution\n                     format!(\n                         \"help: {}{}: `{}`\",\n-                        sugg.msg.as_str(),\n+                        &msg,\n                         if self\n                             .source_map()\n                             .map(|sm| is_case_difference(\n@@ -492,9 +567,19 @@ impl Emitter for EmitterWriter {\n         self.sm.as_ref()\n     }\n \n+    fn fluent_bundle(&self) -> Option<&Lrc<FluentBundle>> {\n+        None\n+    }\n+\n+    fn fallback_fluent_bundle(&self) -> &Lrc<FluentBundle> {\n+        &self.fallback_bundle\n+    }\n+\n     fn emit_diagnostic(&mut self, diag: &Diagnostic) {\n+        let fluent_args = self.to_fluent_args(diag.args());\n+\n         let mut children = diag.children.clone();\n-        let (mut primary_span, suggestions) = self.primary_span_formatted(&diag);\n+        let (mut primary_span, suggestions) = self.primary_span_formatted(&diag, &fluent_args);\n         debug!(\"emit_diagnostic: suggestions={:?}\", suggestions);\n \n         self.fix_multispans_in_extern_macros_and_render_macro_backtrace(\n@@ -507,7 +592,8 @@ impl Emitter for EmitterWriter {\n \n         self.emit_messages_default(\n             &diag.level,\n-            &diag.styled_message(),\n+            &diag.message,\n+            &fluent_args,\n             &diag.code,\n             &primary_span,\n             &children,\n@@ -536,6 +622,15 @@ impl Emitter for SilentEmitter {\n     fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n         None\n     }\n+\n+    fn fluent_bundle(&self) -> Option<&Lrc<FluentBundle>> {\n+        None\n+    }\n+\n+    fn fallback_fluent_bundle(&self) -> &Lrc<FluentBundle> {\n+        panic!(\"silent emitter attempted to translate message\")\n+    }\n+\n     fn emit_diagnostic(&mut self, d: &Diagnostic) {\n         if d.level == Level::Fatal {\n             let mut d = d.clone();\n@@ -591,6 +686,7 @@ impl ColorConfig {\n pub struct EmitterWriter {\n     dst: Destination,\n     sm: Option<Lrc<SourceMap>>,\n+    fallback_bundle: Lrc<FluentBundle>,\n     short_message: bool,\n     teach: bool,\n     ui_testing: bool,\n@@ -610,6 +706,7 @@ impl EmitterWriter {\n     pub fn stderr(\n         color_config: ColorConfig,\n         source_map: Option<Lrc<SourceMap>>,\n+        fallback_bundle: Lrc<FluentBundle>,\n         short_message: bool,\n         teach: bool,\n         terminal_width: Option<usize>,\n@@ -619,6 +716,7 @@ impl EmitterWriter {\n         EmitterWriter {\n             dst,\n             sm: source_map,\n+            fallback_bundle,\n             short_message,\n             teach,\n             ui_testing: false,\n@@ -630,6 +728,7 @@ impl EmitterWriter {\n     pub fn new(\n         dst: Box<dyn Write + Send>,\n         source_map: Option<Lrc<SourceMap>>,\n+        fallback_bundle: Lrc<FluentBundle>,\n         short_message: bool,\n         teach: bool,\n         colored: bool,\n@@ -639,6 +738,7 @@ impl EmitterWriter {\n         EmitterWriter {\n             dst: Raw(dst, colored),\n             sm: source_map,\n+            fallback_bundle,\n             short_message,\n             teach,\n             ui_testing: false,\n@@ -1177,6 +1277,7 @@ impl EmitterWriter {\n         &self,\n         buffer: &mut StyledBuffer,\n         msg: &[(DiagnosticMessage, Style)],\n+        args: &FluentArgs<'_>,\n         padding: usize,\n         label: &str,\n         override_style: Option<Style>,\n@@ -1229,7 +1330,7 @@ impl EmitterWriter {\n         //                very *weird* formats\n         //                see?\n         for &(ref text, ref style) in msg.iter() {\n-            let text = text.as_str();\n+            let text = self.translate_message(text, args);\n             let lines = text.split('\\n').collect::<Vec<_>>();\n             if lines.len() > 1 {\n                 for (i, line) in lines.iter().enumerate() {\n@@ -1240,7 +1341,7 @@ impl EmitterWriter {\n                     buffer.append(line_number, line, style_or_override(*style, override_style));\n                 }\n             } else {\n-                buffer.append(line_number, text, style_or_override(*style, override_style));\n+                buffer.append(line_number, &text, style_or_override(*style, override_style));\n             }\n         }\n     }\n@@ -1249,6 +1350,7 @@ impl EmitterWriter {\n         &mut self,\n         msp: &MultiSpan,\n         msg: &[(DiagnosticMessage, Style)],\n+        args: &FluentArgs<'_>,\n         code: &Option<DiagnosticId>,\n         level: &Level,\n         max_line_num_len: usize,\n@@ -1267,7 +1369,7 @@ impl EmitterWriter {\n                 buffer.append(0, level.to_str(), Style::MainHeaderMsg);\n                 buffer.append(0, \": \", Style::NoStyle);\n             }\n-            self.msg_to_buffer(&mut buffer, msg, max_line_num_len, \"note\", None);\n+            self.msg_to_buffer(&mut buffer, msg, args, max_line_num_len, \"note\", None);\n         } else {\n             let mut label_width = 0;\n             // The failure note level itself does not provide any useful diagnostic information\n@@ -1288,9 +1390,9 @@ impl EmitterWriter {\n                 label_width += 2;\n             }\n             for &(ref text, _) in msg.iter() {\n-                let text = text.as_str();\n+                let text = self.translate_message(text, args);\n                 // Account for newlines to align output to its label.\n-                for (line, text) in normalize_whitespace(text).lines().enumerate() {\n+                for (line, text) in normalize_whitespace(&text).lines().enumerate() {\n                     buffer.append(\n                         0 + line,\n                         &format!(\n@@ -1304,7 +1406,7 @@ impl EmitterWriter {\n             }\n         }\n \n-        let mut annotated_files = FileWithAnnotatedLines::collect_annotations(msp, &self.sm);\n+        let mut annotated_files = FileWithAnnotatedLines::collect_annotations(self, args, msp);\n \n         // Make sure our primary file comes first\n         let (primary_lo, sm) = if let (Some(sm), Some(ref primary_span)) =\n@@ -1588,6 +1690,7 @@ impl EmitterWriter {\n     fn emit_suggestion_default(\n         &mut self,\n         suggestion: &CodeSuggestion,\n+        args: &FluentArgs<'_>,\n         level: &Level,\n         max_line_num_len: usize,\n     ) -> io::Result<()> {\n@@ -1614,6 +1717,7 @@ impl EmitterWriter {\n         self.msg_to_buffer(\n             &mut buffer,\n             &[(suggestion.msg.to_owned(), Style::NoStyle)],\n+            args,\n             max_line_num_len,\n             \"suggestion\",\n             Some(Style::HeaderMsg),\n@@ -1855,6 +1959,7 @@ impl EmitterWriter {\n         &mut self,\n         level: &Level,\n         message: &[(DiagnosticMessage, Style)],\n+        args: &FluentArgs<'_>,\n         code: &Option<DiagnosticId>,\n         span: &MultiSpan,\n         children: &[SubDiagnostic],\n@@ -1867,7 +1972,7 @@ impl EmitterWriter {\n             num_decimal_digits(n)\n         };\n \n-        match self.emit_message_default(span, message, code, level, max_line_num_len, false) {\n+        match self.emit_message_default(span, message, args, code, level, max_line_num_len, false) {\n             Ok(()) => {\n                 if !children.is_empty()\n                     || suggestions.iter().any(|s| s.style != SuggestionStyle::CompletelyHidden)\n@@ -1890,7 +1995,8 @@ impl EmitterWriter {\n                         let span = child.render_span.as_ref().unwrap_or(&child.span);\n                         if let Err(err) = self.emit_message_default(\n                             &span,\n-                            &child.styled_message(),\n+                            &child.message,\n+                            args,\n                             &None,\n                             &child.level,\n                             max_line_num_len,\n@@ -1906,6 +2012,7 @@ impl EmitterWriter {\n                             if let Err(e) = self.emit_message_default(\n                                 &MultiSpan::new(),\n                                 &[(sugg.msg.to_owned(), Style::HeaderMsg)],\n+                                args,\n                                 &None,\n                                 &Level::Help,\n                                 max_line_num_len,\n@@ -1914,7 +2021,7 @@ impl EmitterWriter {\n                                 panic!(\"failed to emit error: {}\", e);\n                             }\n                         } else if let Err(e) =\n-                            self.emit_suggestion_default(sugg, &Level::Help, max_line_num_len)\n+                            self.emit_suggestion_default(sugg, args, &Level::Help, max_line_num_len)\n                         {\n                             panic!(\"failed to emit error: {}\", e);\n                         };\n@@ -1940,8 +2047,9 @@ impl FileWithAnnotatedLines {\n     /// Preprocess all the annotations so that they are grouped by file and by line number\n     /// This helps us quickly iterate over the whole message (including secondary file spans)\n     pub fn collect_annotations(\n+        emitter: &dyn Emitter,\n+        args: &FluentArgs<'_>,\n         msp: &MultiSpan,\n-        source_map: &Option<Lrc<SourceMap>>,\n     ) -> Vec<FileWithAnnotatedLines> {\n         fn add_annotation_to_file(\n             file_vec: &mut Vec<FileWithAnnotatedLines>,\n@@ -1976,7 +2084,7 @@ impl FileWithAnnotatedLines {\n         let mut output = vec![];\n         let mut multiline_annotations = vec![];\n \n-        if let Some(ref sm) = source_map {\n+        if let Some(ref sm) = emitter.source_map() {\n             for span_label in msp.span_labels() {\n                 if span_label.span.is_dummy() {\n                     continue;\n@@ -2003,7 +2111,10 @@ impl FileWithAnnotatedLines {\n                         start_col: lo.col_display,\n                         end_col: hi.col_display,\n                         is_primary: span_label.is_primary,\n-                        label: span_label.label.map(|m| m.to_string()),\n+                        label: span_label\n+                            .label\n+                            .as_ref()\n+                            .map(|m| emitter.translate_message(m, args).to_string()),\n                         overlaps_exactly: false,\n                     };\n                     multiline_annotations.push((lo.file, ml));\n@@ -2012,7 +2123,10 @@ impl FileWithAnnotatedLines {\n                         start_col: lo.col_display,\n                         end_col: hi.col_display,\n                         is_primary: span_label.is_primary,\n-                        label: span_label.label.map(|m| m.to_string()),\n+                        label: span_label\n+                            .label\n+                            .as_ref()\n+                            .map(|m| emitter.translate_message(m, args).to_string()),\n                         annotation_type: AnnotationType::Singleline,\n                     };\n                     add_annotation_to_file(&mut output, lo.file, lo.line, ann);"}, {"sha": "3e7bcf2d37e59074a5bb5ef5e2518743da259a84", "filename": "compiler/rustc_errors/src/json.rs", "status": "modified", "additions": 57, "deletions": 20, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -15,10 +15,11 @@ use crate::emitter::{Emitter, HumanReadableErrorType};\n use crate::registry::Registry;\n use crate::DiagnosticId;\n use crate::ToolMetadata;\n-use crate::{CodeSuggestion, MultiSpan, SpanLabel, SubDiagnostic};\n+use crate::{CodeSuggestion, FluentBundle, MultiSpan, SpanLabel, SubDiagnostic};\n use rustc_lint_defs::Applicability;\n \n use rustc_data_structures::sync::Lrc;\n+use rustc_error_messages::FluentArgs;\n use rustc_span::hygiene::ExpnData;\n use rustc_span::Span;\n use std::io::{self, Write};\n@@ -36,6 +37,7 @@ pub struct JsonEmitter {\n     dst: Box<dyn Write + Send>,\n     registry: Option<Registry>,\n     sm: Lrc<SourceMap>,\n+    fallback_bundle: Lrc<FluentBundle>,\n     pretty: bool,\n     ui_testing: bool,\n     json_rendered: HumanReadableErrorType,\n@@ -47,6 +49,7 @@ impl JsonEmitter {\n     pub fn stderr(\n         registry: Option<Registry>,\n         source_map: Lrc<SourceMap>,\n+        fallback_bundle: Lrc<FluentBundle>,\n         pretty: bool,\n         json_rendered: HumanReadableErrorType,\n         terminal_width: Option<usize>,\n@@ -56,6 +59,7 @@ impl JsonEmitter {\n             dst: Box::new(io::BufWriter::new(io::stderr())),\n             registry,\n             sm: source_map,\n+            fallback_bundle,\n             pretty,\n             ui_testing: false,\n             json_rendered,\n@@ -67,13 +71,15 @@ impl JsonEmitter {\n     pub fn basic(\n         pretty: bool,\n         json_rendered: HumanReadableErrorType,\n+        fallback_bundle: Lrc<FluentBundle>,\n         terminal_width: Option<usize>,\n         macro_backtrace: bool,\n     ) -> JsonEmitter {\n         let file_path_mapping = FilePathMapping::empty();\n         JsonEmitter::stderr(\n             None,\n             Lrc::new(SourceMap::new(file_path_mapping)),\n+            fallback_bundle,\n             pretty,\n             json_rendered,\n             terminal_width,\n@@ -85,6 +91,7 @@ impl JsonEmitter {\n         dst: Box<dyn Write + Send>,\n         registry: Option<Registry>,\n         source_map: Lrc<SourceMap>,\n+        fallback_bundle: Lrc<FluentBundle>,\n         pretty: bool,\n         json_rendered: HumanReadableErrorType,\n         terminal_width: Option<usize>,\n@@ -94,6 +101,7 @@ impl JsonEmitter {\n             dst,\n             registry,\n             sm: source_map,\n+            fallback_bundle,\n             pretty,\n             ui_testing: false,\n             json_rendered,\n@@ -173,6 +181,14 @@ impl Emitter for JsonEmitter {\n         Some(&self.sm)\n     }\n \n+    fn fluent_bundle(&self) -> Option<&Lrc<FluentBundle>> {\n+        None\n+    }\n+\n+    fn fallback_fluent_bundle(&self) -> &Lrc<FluentBundle> {\n+        &self.fallback_bundle\n+    }\n+\n     fn should_show_explain(&self) -> bool {\n         !matches!(self.json_rendered, HumanReadableErrorType::Short(_))\n     }\n@@ -345,14 +361,18 @@ struct UnusedExterns<'a, 'b, 'c> {\n \n impl Diagnostic {\n     fn from_errors_diagnostic(diag: &crate::Diagnostic, je: &JsonEmitter) -> Diagnostic {\n-        let sugg = diag.suggestions.iter().flatten().map(|sugg| Diagnostic {\n-            message: sugg.msg.clone().to_string(),\n-            code: None,\n-            level: \"help\",\n-            spans: DiagnosticSpan::from_suggestion(sugg, je),\n-            children: vec![],\n-            rendered: None,\n-            tool_metadata: sugg.tool_metadata.clone(),\n+        let args = je.to_fluent_args(diag.args());\n+        let sugg = diag.suggestions.iter().flatten().map(|sugg| {\n+            let translated_message = je.translate_message(&sugg.msg, &args);\n+            Diagnostic {\n+                message: translated_message.to_string(),\n+                code: None,\n+                level: \"help\",\n+                spans: DiagnosticSpan::from_suggestion(sugg, &args, je),\n+                children: vec![],\n+                rendered: None,\n+                tool_metadata: sugg.tool_metadata.clone(),\n+            }\n         });\n \n         // generate regular command line output and store it in the json\n@@ -375,6 +395,7 @@ impl Diagnostic {\n             .new_emitter(\n                 Box::new(buf),\n                 Some(je.sm.clone()),\n+                je.fallback_bundle.clone(),\n                 false,\n                 je.terminal_width,\n                 je.macro_backtrace,\n@@ -384,32 +405,38 @@ impl Diagnostic {\n         let output = Arc::try_unwrap(output.0).unwrap().into_inner().unwrap();\n         let output = String::from_utf8(output).unwrap();\n \n+        let translated_message = je.translate_messages(&diag.message, &args);\n         Diagnostic {\n-            message: diag.message().to_string(),\n+            message: translated_message.to_string(),\n             code: DiagnosticCode::map_opt_string(diag.code.clone(), je),\n             level: diag.level.to_str(),\n-            spans: DiagnosticSpan::from_multispan(&diag.span, je),\n+            spans: DiagnosticSpan::from_multispan(&diag.span, &args, je),\n             children: diag\n                 .children\n                 .iter()\n-                .map(|c| Diagnostic::from_sub_diagnostic(c, je))\n+                .map(|c| Diagnostic::from_sub_diagnostic(c, &args, je))\n                 .chain(sugg)\n                 .collect(),\n             rendered: Some(output),\n             tool_metadata: ToolMetadata::default(),\n         }\n     }\n \n-    fn from_sub_diagnostic(diag: &SubDiagnostic, je: &JsonEmitter) -> Diagnostic {\n+    fn from_sub_diagnostic(\n+        diag: &SubDiagnostic,\n+        args: &FluentArgs<'_>,\n+        je: &JsonEmitter,\n+    ) -> Diagnostic {\n+        let translated_message = je.translate_messages(&diag.message, args);\n         Diagnostic {\n-            message: diag.message().to_string(),\n+            message: translated_message.to_string(),\n             code: None,\n             level: diag.level.to_str(),\n             spans: diag\n                 .render_span\n                 .as_ref()\n-                .map(|sp| DiagnosticSpan::from_multispan(sp, je))\n-                .unwrap_or_else(|| DiagnosticSpan::from_multispan(&diag.span, je)),\n+                .map(|sp| DiagnosticSpan::from_multispan(sp, args, je))\n+                .unwrap_or_else(|| DiagnosticSpan::from_multispan(&diag.span, args, je)),\n             children: vec![],\n             rendered: None,\n             tool_metadata: ToolMetadata::default(),\n@@ -421,12 +448,13 @@ impl DiagnosticSpan {\n     fn from_span_label(\n         span: SpanLabel,\n         suggestion: Option<(&String, Applicability)>,\n+        args: &FluentArgs<'_>,\n         je: &JsonEmitter,\n     ) -> DiagnosticSpan {\n         Self::from_span_etc(\n             span.span,\n             span.is_primary,\n-            span.label.map(|m| m.to_string()),\n+            span.label.as_ref().map(|m| je.translate_message(m, args)).map(|m| m.to_string()),\n             suggestion,\n             je,\n         )\n@@ -492,14 +520,22 @@ impl DiagnosticSpan {\n         }\n     }\n \n-    fn from_multispan(msp: &MultiSpan, je: &JsonEmitter) -> Vec<DiagnosticSpan> {\n+    fn from_multispan(\n+        msp: &MultiSpan,\n+        args: &FluentArgs<'_>,\n+        je: &JsonEmitter,\n+    ) -> Vec<DiagnosticSpan> {\n         msp.span_labels()\n             .into_iter()\n-            .map(|span_str| Self::from_span_label(span_str, None, je))\n+            .map(|span_str| Self::from_span_label(span_str, None, args, je))\n             .collect()\n     }\n \n-    fn from_suggestion(suggestion: &CodeSuggestion, je: &JsonEmitter) -> Vec<DiagnosticSpan> {\n+    fn from_suggestion(\n+        suggestion: &CodeSuggestion,\n+        args: &FluentArgs<'_>,\n+        je: &JsonEmitter,\n+    ) -> Vec<DiagnosticSpan> {\n         suggestion\n             .substitutions\n             .iter()\n@@ -510,6 +546,7 @@ impl DiagnosticSpan {\n                     DiagnosticSpan::from_span_label(\n                         span_label,\n                         Some((&suggestion_inner.snippet, suggestion.applicability)),\n+                        args,\n                         je,\n                     )\n                 })"}, {"sha": "fa0ccd65d069d6da88a4aba7e0cb1181aabdc1aa", "filename": "compiler/rustc_errors/src/json/tests.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_errors%2Fsrc%2Fjson%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_errors%2Fsrc%2Fjson%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson%2Ftests.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -39,12 +39,14 @@ fn test_positions(code: &str, span: (u32, u32), expected_output: SpanTestData) {\n     rustc_span::create_default_session_globals_then(|| {\n         let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n         sm.new_source_file(Path::new(\"test.rs\").to_owned().into(), code.to_owned());\n+        let fallback_bundle = crate::fallback_fluent_bundle();\n \n         let output = Arc::new(Mutex::new(Vec::new()));\n         let je = JsonEmitter::new(\n             Box::new(Shared { data: output.clone() }),\n             None,\n             sm,\n+            fallback_bundle,\n             true,\n             HumanReadableErrorType::Short(ColorConfig::Never),\n             None,"}, {"sha": "04a0a9f7b73e5ea7e21a7b31190826874967ec67", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 101, "deletions": 46, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -31,7 +31,9 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::sync::{self, Lock, Lrc};\n use rustc_data_structures::AtomicRef;\n-pub use rustc_error_messages::{DiagnosticMessage, MultiSpan, SpanLabel};\n+pub use rustc_error_messages::{\n+    fallback_fluent_bundle, DiagnosticMessage, FluentBundle, MultiSpan, SpanLabel,\n+};\n pub use rustc_lint_defs::{pluralize, Applicability};\n use rustc_serialize::json::Json;\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n@@ -402,7 +404,9 @@ impl fmt::Display for ExplicitBug {\n \n impl error::Error for ExplicitBug {}\n \n-pub use diagnostic::{Diagnostic, DiagnosticId, DiagnosticStyledString, SubDiagnostic};\n+pub use diagnostic::{\n+    Diagnostic, DiagnosticArg, DiagnosticId, DiagnosticStyledString, SubDiagnostic,\n+};\n pub use diagnostic_builder::{DiagnosticBuilder, EmissionGuarantee};\n use std::backtrace::Backtrace;\n \n@@ -540,22 +544,26 @@ impl Handler {\n         can_emit_warnings: bool,\n         treat_err_as_bug: Option<NonZeroUsize>,\n         sm: Option<Lrc<SourceMap>>,\n+        fallback_bundle: Lrc<FluentBundle>,\n     ) -> Self {\n         Self::with_tty_emitter_and_flags(\n             color_config,\n             sm,\n+            fallback_bundle,\n             HandlerFlags { can_emit_warnings, treat_err_as_bug, ..Default::default() },\n         )\n     }\n \n     pub fn with_tty_emitter_and_flags(\n         color_config: ColorConfig,\n         sm: Option<Lrc<SourceMap>>,\n+        fallback_bundle: Lrc<FluentBundle>,\n         flags: HandlerFlags,\n     ) -> Self {\n         let emitter = Box::new(EmitterWriter::stderr(\n             color_config,\n             sm,\n+            fallback_bundle,\n             false,\n             false,\n             None,\n@@ -660,7 +668,7 @@ impl Handler {\n     pub fn struct_span_warn(\n         &self,\n         span: impl Into<MultiSpan>,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n     ) -> DiagnosticBuilder<'_, ()> {\n         let mut result = self.struct_warn(msg);\n         result.set_span(span);\n@@ -671,7 +679,7 @@ impl Handler {\n     pub fn struct_span_allow(\n         &self,\n         span: impl Into<MultiSpan>,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n     ) -> DiagnosticBuilder<'_, ()> {\n         let mut result = self.struct_allow(msg);\n         result.set_span(span);\n@@ -683,7 +691,7 @@ impl Handler {\n     pub fn struct_span_warn_with_code(\n         &self,\n         span: impl Into<MultiSpan>,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         code: DiagnosticId,\n     ) -> DiagnosticBuilder<'_, ()> {\n         let mut result = self.struct_span_warn(span, msg);\n@@ -696,25 +704,29 @@ impl Handler {\n     /// Attempting to `.emit()` the builder will only emit if either:\n     /// * `can_emit_warnings` is `true`\n     /// * `is_force_warn` was set in `DiagnosticId::Lint`\n-    pub fn struct_warn(&self, msg: &str) -> DiagnosticBuilder<'_, ()> {\n+    pub fn struct_warn(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, ()> {\n         DiagnosticBuilder::new(self, Level::Warning, msg)\n     }\n \n     /// Construct a builder at the `Allow` level with the `msg`.\n-    pub fn struct_allow(&self, msg: &str) -> DiagnosticBuilder<'_, ()> {\n+    pub fn struct_allow(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, ()> {\n         DiagnosticBuilder::new(self, Level::Allow, msg)\n     }\n \n     /// Construct a builder at the `Expect` level with the `msg`.\n-    pub fn struct_expect(&self, msg: &str, id: LintExpectationId) -> DiagnosticBuilder<'_, ()> {\n+    pub fn struct_expect(\n+        &self,\n+        msg: impl Into<DiagnosticMessage>,\n+        id: LintExpectationId,\n+    ) -> DiagnosticBuilder<'_, ()> {\n         DiagnosticBuilder::new(self, Level::Expect(id), msg)\n     }\n \n     /// Construct a builder at the `Error` level at the given `span` and with the `msg`.\n     pub fn struct_span_err(\n         &self,\n         span: impl Into<MultiSpan>,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n     ) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n         let mut result = self.struct_err(msg);\n         result.set_span(span);\n@@ -725,7 +737,7 @@ impl Handler {\n     pub fn struct_span_err_with_code(\n         &self,\n         span: impl Into<MultiSpan>,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         code: DiagnosticId,\n     ) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n         let mut result = self.struct_span_err(span, msg);\n@@ -735,20 +747,23 @@ impl Handler {\n \n     /// Construct a builder at the `Error` level with the `msg`.\n     // FIXME: This method should be removed (every error should have an associated error code).\n-    pub fn struct_err(&self, msg: &str) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n-        DiagnosticBuilder::new_guaranteeing_error::<{ Level::Error { lint: false } }>(self, msg)\n+    pub fn struct_err(\n+        &self,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n+        DiagnosticBuilder::new_guaranteeing_error::<_, { Level::Error { lint: false } }>(self, msg)\n     }\n \n     /// This should only be used by `rustc_middle::lint::struct_lint_level`. Do not use it for hard errors.\n     #[doc(hidden)]\n-    pub fn struct_err_lint(&self, msg: &str) -> DiagnosticBuilder<'_, ()> {\n+    pub fn struct_err_lint(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, ()> {\n         DiagnosticBuilder::new(self, Level::Error { lint: true }, msg)\n     }\n \n     /// Construct a builder at the `Error` level with the `msg` and the `code`.\n     pub fn struct_err_with_code(\n         &self,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         code: DiagnosticId,\n     ) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n         let mut result = self.struct_err(msg);\n@@ -760,7 +775,7 @@ impl Handler {\n     pub fn struct_span_fatal(\n         &self,\n         span: impl Into<MultiSpan>,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n     ) -> DiagnosticBuilder<'_, !> {\n         let mut result = self.struct_fatal(msg);\n         result.set_span(span);\n@@ -771,7 +786,7 @@ impl Handler {\n     pub fn struct_span_fatal_with_code(\n         &self,\n         span: impl Into<MultiSpan>,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         code: DiagnosticId,\n     ) -> DiagnosticBuilder<'_, !> {\n         let mut result = self.struct_span_fatal(span, msg);\n@@ -780,102 +795,131 @@ impl Handler {\n     }\n \n     /// Construct a builder at the `Error` level with the `msg`.\n-    pub fn struct_fatal(&self, msg: &str) -> DiagnosticBuilder<'_, !> {\n+    pub fn struct_fatal(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, !> {\n         DiagnosticBuilder::new_fatal(self, msg)\n     }\n \n     /// Construct a builder at the `Help` level with the `msg`.\n-    pub fn struct_help(&self, msg: &str) -> DiagnosticBuilder<'_, ()> {\n+    pub fn struct_help(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, ()> {\n         DiagnosticBuilder::new(self, Level::Help, msg)\n     }\n \n     /// Construct a builder at the `Note` level with the `msg`.\n-    pub fn struct_note_without_error(&self, msg: &str) -> DiagnosticBuilder<'_, ()> {\n+    pub fn struct_note_without_error(\n+        &self,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> DiagnosticBuilder<'_, ()> {\n         DiagnosticBuilder::new(self, Level::Note, msg)\n     }\n \n-    pub fn span_fatal(&self, span: impl Into<MultiSpan>, msg: &str) -> ! {\n+    pub fn span_fatal(&self, span: impl Into<MultiSpan>, msg: impl Into<DiagnosticMessage>) -> ! {\n         self.emit_diag_at_span(Diagnostic::new(Fatal, msg), span);\n         FatalError.raise()\n     }\n \n     pub fn span_fatal_with_code(\n         &self,\n         span: impl Into<MultiSpan>,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         code: DiagnosticId,\n     ) -> ! {\n         self.emit_diag_at_span(Diagnostic::new_with_code(Fatal, Some(code), msg), span);\n         FatalError.raise()\n     }\n \n-    pub fn span_err(&self, span: impl Into<MultiSpan>, msg: &str) -> ErrorGuaranteed {\n+    pub fn span_err(\n+        &self,\n+        span: impl Into<MultiSpan>,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> ErrorGuaranteed {\n         self.emit_diag_at_span(Diagnostic::new(Error { lint: false }, msg), span).unwrap()\n     }\n \n-    pub fn span_err_with_code(&self, span: impl Into<MultiSpan>, msg: &str, code: DiagnosticId) {\n+    pub fn span_err_with_code(\n+        &self,\n+        span: impl Into<MultiSpan>,\n+        msg: impl Into<DiagnosticMessage>,\n+        code: DiagnosticId,\n+    ) {\n         self.emit_diag_at_span(\n             Diagnostic::new_with_code(Error { lint: false }, Some(code), msg),\n             span,\n         );\n     }\n \n-    pub fn span_warn(&self, span: impl Into<MultiSpan>, msg: &str) {\n+    pub fn span_warn(&self, span: impl Into<MultiSpan>, msg: impl Into<DiagnosticMessage>) {\n         self.emit_diag_at_span(Diagnostic::new(Warning, msg), span);\n     }\n \n-    pub fn span_warn_with_code(&self, span: impl Into<MultiSpan>, msg: &str, code: DiagnosticId) {\n+    pub fn span_warn_with_code(\n+        &self,\n+        span: impl Into<MultiSpan>,\n+        msg: impl Into<DiagnosticMessage>,\n+        code: DiagnosticId,\n+    ) {\n         self.emit_diag_at_span(Diagnostic::new_with_code(Warning, Some(code), msg), span);\n     }\n \n-    pub fn span_bug(&self, span: impl Into<MultiSpan>, msg: &str) -> ! {\n+    pub fn span_bug(&self, span: impl Into<MultiSpan>, msg: impl Into<DiagnosticMessage>) -> ! {\n         self.inner.borrow_mut().span_bug(span, msg)\n     }\n \n     #[track_caller]\n-    pub fn delay_span_bug(&self, span: impl Into<MultiSpan>, msg: &str) -> ErrorGuaranteed {\n+    pub fn delay_span_bug(\n+        &self,\n+        span: impl Into<MultiSpan>,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> ErrorGuaranteed {\n         self.inner.borrow_mut().delay_span_bug(span, msg)\n     }\n \n     // FIXME(eddyb) note the comment inside `impl Drop for HandlerInner`, that's\n     // where the explanation of what \"good path\" is (also, it should be renamed).\n-    pub fn delay_good_path_bug(&self, msg: &str) {\n+    pub fn delay_good_path_bug(&self, msg: impl Into<DiagnosticMessage>) {\n         self.inner.borrow_mut().delay_good_path_bug(msg)\n     }\n \n-    pub fn span_bug_no_panic(&self, span: impl Into<MultiSpan>, msg: &str) {\n+    pub fn span_bug_no_panic(&self, span: impl Into<MultiSpan>, msg: impl Into<DiagnosticMessage>) {\n         self.emit_diag_at_span(Diagnostic::new(Bug, msg), span);\n     }\n \n-    pub fn span_note_without_error(&self, span: impl Into<MultiSpan>, msg: &str) {\n+    pub fn span_note_without_error(\n+        &self,\n+        span: impl Into<MultiSpan>,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) {\n         self.emit_diag_at_span(Diagnostic::new(Note, msg), span);\n     }\n \n-    pub fn span_note_diag(&self, span: Span, msg: &str) -> DiagnosticBuilder<'_, ()> {\n+    pub fn span_note_diag(\n+        &self,\n+        span: Span,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> DiagnosticBuilder<'_, ()> {\n         let mut db = DiagnosticBuilder::new(self, Note, msg);\n         db.set_span(span);\n         db\n     }\n \n     // NOTE: intentionally doesn't raise an error so rustc_codegen_ssa only reports fatal errors in the main thread\n-    pub fn fatal(&self, msg: &str) -> FatalError {\n+    pub fn fatal(&self, msg: impl Into<DiagnosticMessage>) -> FatalError {\n         self.inner.borrow_mut().fatal(msg)\n     }\n \n-    pub fn err(&self, msg: &str) -> ErrorGuaranteed {\n+    pub fn err(&self, msg: impl Into<DiagnosticMessage>) -> ErrorGuaranteed {\n         self.inner.borrow_mut().err(msg)\n     }\n \n-    pub fn warn(&self, msg: &str) {\n+    pub fn warn(&self, msg: impl Into<DiagnosticMessage>) {\n         let mut db = DiagnosticBuilder::new(self, Warning, msg);\n         db.emit();\n     }\n \n-    pub fn note_without_error(&self, msg: &str) {\n+    pub fn note_without_error(&self, msg: impl Into<DiagnosticMessage>) {\n         DiagnosticBuilder::new(self, Note, msg).emit();\n     }\n \n-    pub fn bug(&self, msg: &str) -> ! {\n+    pub fn bug(&self, msg: impl Into<DiagnosticMessage>) -> ! {\n         self.inner.borrow_mut().bug(msg)\n     }\n \n@@ -1145,7 +1189,10 @@ impl HandlerInner {\n \n         match (errors.len(), warnings.len()) {\n             (0, 0) => return,\n-            (0, _) => self.emitter.emit_diagnostic(&Diagnostic::new(Level::Warning, &warnings)),\n+            (0, _) => self.emitter.emit_diagnostic(&Diagnostic::new(\n+                Level::Warning,\n+                DiagnosticMessage::Str(warnings.to_owned()),\n+            )),\n             (_, 0) => {\n                 let _ = self.fatal(&errors);\n             }\n@@ -1220,7 +1267,7 @@ impl HandlerInner {\n         }\n     }\n \n-    fn span_bug(&mut self, sp: impl Into<MultiSpan>, msg: &str) -> ! {\n+    fn span_bug(&mut self, sp: impl Into<MultiSpan>, msg: impl Into<DiagnosticMessage>) -> ! {\n         self.emit_diag_at_span(Diagnostic::new(Bug, msg), sp);\n         panic::panic_any(ExplicitBug);\n     }\n@@ -1230,7 +1277,11 @@ impl HandlerInner {\n     }\n \n     #[track_caller]\n-    fn delay_span_bug(&mut self, sp: impl Into<MultiSpan>, msg: &str) -> ErrorGuaranteed {\n+    fn delay_span_bug(\n+        &mut self,\n+        sp: impl Into<MultiSpan>,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> ErrorGuaranteed {\n         // This is technically `self.treat_err_as_bug()` but `delay_span_bug` is called before\n         // incrementing `err_count` by one, so we need to +1 the comparing.\n         // FIXME: Would be nice to increment err_count in a more coherent way.\n@@ -1246,7 +1297,7 @@ impl HandlerInner {\n \n     // FIXME(eddyb) note the comment inside `impl Drop for HandlerInner`, that's\n     // where the explanation of what \"good path\" is (also, it should be renamed).\n-    fn delay_good_path_bug(&mut self, msg: &str) {\n+    fn delay_good_path_bug(&mut self, msg: impl Into<DiagnosticMessage>) {\n         let mut diagnostic = Diagnostic::new(Level::DelayedBug, msg);\n         if self.flags.report_delayed_bugs {\n             self.emit_diagnostic(&mut diagnostic);\n@@ -1255,33 +1306,37 @@ impl HandlerInner {\n         self.delayed_good_path_bugs.push(DelayedDiagnostic::with_backtrace(diagnostic, backtrace));\n     }\n \n-    fn failure(&mut self, msg: &str) {\n+    fn failure(&mut self, msg: impl Into<DiagnosticMessage>) {\n         self.emit_diagnostic(&mut Diagnostic::new(FailureNote, msg));\n     }\n \n-    fn fatal(&mut self, msg: &str) -> FatalError {\n+    fn fatal(&mut self, msg: impl Into<DiagnosticMessage>) -> FatalError {\n         self.emit(Fatal, msg);\n         FatalError\n     }\n \n-    fn err(&mut self, msg: &str) -> ErrorGuaranteed {\n+    fn err(&mut self, msg: impl Into<DiagnosticMessage>) -> ErrorGuaranteed {\n         self.emit(Error { lint: false }, msg)\n     }\n \n     /// Emit an error; level should be `Error` or `Fatal`.\n-    fn emit(&mut self, level: Level, msg: &str) -> ErrorGuaranteed {\n+    fn emit(&mut self, level: Level, msg: impl Into<DiagnosticMessage>) -> ErrorGuaranteed {\n         if self.treat_err_as_bug() {\n             self.bug(msg);\n         }\n         self.emit_diagnostic(&mut Diagnostic::new(level, msg)).unwrap()\n     }\n \n-    fn bug(&mut self, msg: &str) -> ! {\n+    fn bug(&mut self, msg: impl Into<DiagnosticMessage>) -> ! {\n         self.emit_diagnostic(&mut Diagnostic::new(Bug, msg));\n         panic::panic_any(ExplicitBug);\n     }\n \n-    fn flush_delayed(&mut self, bugs: impl IntoIterator<Item = Diagnostic>, explanation: &str) {\n+    fn flush_delayed(\n+        &mut self,\n+        bugs: impl IntoIterator<Item = Diagnostic>,\n+        explanation: impl Into<DiagnosticMessage> + Copy,\n+    ) {\n         let mut no_bugs = true;\n         for mut bug in bugs {\n             if no_bugs {"}, {"sha": "0e20e0970f401ba975ac27dea7f9a6858f155a71", "filename": "compiler/rustc_expand/src/mbe/macro_check.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_check.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -250,7 +250,7 @@ fn check_binders(\n             if let Some(prev_info) = binders.get(&name) {\n                 // 1. The meta-variable is already bound in the current LHS: This is an error.\n                 let mut span = MultiSpan::from_span(span);\n-                span.push_span_label(prev_info.span, \"previous declaration\".into());\n+                span.push_span_label(prev_info.span, \"previous declaration\");\n                 buffer_lint(sess, span, node_id, \"duplicate matcher binding\");\n             } else if get_binder_info(macros, binders, name).is_none() {\n                 // 2. The meta-variable is free: This is a binder.\n@@ -622,16 +622,16 @@ fn ops_is_prefix(\n     for (i, binder) in binder_ops.iter().enumerate() {\n         if i >= occurrence_ops.len() {\n             let mut span = MultiSpan::from_span(span);\n-            span.push_span_label(binder.span, \"expected repetition\".into());\n+            span.push_span_label(binder.span, \"expected repetition\");\n             let message = &format!(\"variable '{}' is still repeating at this depth\", name);\n             buffer_lint(sess, span, node_id, message);\n             return;\n         }\n         let occurrence = &occurrence_ops[i];\n         if occurrence.op != binder.op {\n             let mut span = MultiSpan::from_span(span);\n-            span.push_span_label(binder.span, \"expected repetition\".into());\n-            span.push_span_label(occurrence.span, \"conflicting repetition\".into());\n+            span.push_span_label(binder.span, \"expected repetition\");\n+            span.push_span_label(occurrence.span, \"conflicting repetition\");\n             let message = \"meta-variable repeats with different Kleene operator\";\n             buffer_lint(sess, span, node_id, message);\n             return;"}, {"sha": "7fef87ed9778ff0bb0417db39f4c46c68f7783a2", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -69,7 +69,7 @@ fn emit_frag_parse_err(\n     kind: AstFragmentKind,\n ) {\n     // FIXME(davidtwco): avoid depending on the error message text\n-    if parser.token == token::Eof && e.message().as_str().ends_with(\", found `<eof>`\") {\n+    if parser.token == token::Eof && e.message[0].0.expect_str().ends_with(\", found `<eof>`\") {\n         if !e.span.is_dummy() {\n             // early end of macro arm (#52866)\n             e.replace_span_with(parser.sess.source_map().next_point(parser.token.span));\n@@ -78,7 +78,7 @@ fn emit_frag_parse_err(\n         e.message[0] = (\n             rustc_errors::DiagnosticMessage::Str(format!(\n                 \"macro expansion ends with an incomplete expression: {}\",\n-                msg.0.as_str().replace(\", found `<eof>`\", \"\"),\n+                msg.0.expect_str().replace(\", found `<eof>`\", \"\"),\n             )),\n             msg.1,\n         );"}, {"sha": "52a656e1d1c14e11546cca2720bd08730873b39d", "filename": "compiler/rustc_expand/src/mbe/metavar_expr.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmetavar_expr.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -128,13 +128,15 @@ fn parse_ident<'sess>(\n     sess: &'sess ParseSess,\n     span: Span,\n ) -> PResult<'sess, Ident> {\n-    let err_fn = |msg| sess.span_diagnostic.struct_span_err(span, msg);\n     if let Some(tt) = iter.next() && let TokenTree::Token(token) = tt {\n         if let Some((elem, false)) = token.ident() {\n             return Ok(elem);\n         }\n         let token_str = pprust::token_to_string(&token);\n-        let mut err = err_fn(&format!(\"expected identifier, found `{}`\", &token_str));\n+        let mut err = sess.span_diagnostic.struct_span_err(\n+            span,\n+            &format!(\"expected identifier, found `{}`\", &token_str)\n+        );\n         err.span_suggestion(\n             token.span,\n             &format!(\"try removing `{}`\", &token_str),\n@@ -143,7 +145,7 @@ fn parse_ident<'sess>(\n         );\n         return Err(err);\n     }\n-    Err(err_fn(\"expected identifier\"))\n+    Err(sess.span_diagnostic.struct_span_err(span, \"expected identifier\"))\n }\n \n /// Tries to move the iterator forward returning `true` if there is a comma. If not, then the"}, {"sha": "65128b917709f87556c4dd0952be6eb4c10c8105", "filename": "compiler/rustc_expand/src/tests.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_expand%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_expand%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ftests.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -127,6 +127,7 @@ fn test_harness(file_text: &str, span_labels: Vec<SpanLabel>, expected_output: &\n     create_default_session_if_not_set_then(|_| {\n         let output = Arc::new(Mutex::new(Vec::new()));\n \n+        let fallback_bundle = rustc_errors::fallback_fluent_bundle();\n         let source_map = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n         source_map.new_source_file(Path::new(\"test.rs\").to_owned().into(), file_text.to_owned());\n \n@@ -142,6 +143,7 @@ fn test_harness(file_text: &str, span_labels: Vec<SpanLabel>, expected_output: &\n         let emitter = EmitterWriter::new(\n             Box::new(Shared { data: output.clone() }),\n             Some(source_map.clone()),\n+            fallback_bundle,\n             false,\n             false,\n             false,"}, {"sha": "f25215fe813d6d10b0856d2c697c771934d74aee", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -2075,7 +2075,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         {\n                             diag.span_suggestion(\n                                 span,\n-                                msg,\n+                                *msg,\n                                 format!(\"{}.as_ref()\", snippet),\n                                 Applicability::MachineApplicable,\n                             );"}, {"sha": "80500f3fe65bac6e4b606e8649cac403d0fdb80f", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mismatched_static_lifetime.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -41,8 +41,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let mut err = self.tcx().sess.struct_span_err(cause.span, \"incompatible lifetime on type\");\n         // FIXME: we should point at the lifetime\n         let mut multi_span: MultiSpan = vec![binding_span].into();\n-        multi_span\n-            .push_span_label(binding_span, \"introduces a `'static` lifetime requirement\".into());\n+        multi_span.push_span_label(binding_span, \"introduces a `'static` lifetime requirement\");\n         err.span_note(multi_span, \"because this has an unmet lifetime requirement\");\n         note_and_explain_region(self.tcx(), &mut err, \"\", sup, \"...\", Some(binding_span));\n         if let Some(impl_node) = self.tcx().hir().get_if_local(*impl_def_id) {"}, {"sha": "baea3e8285af26c078a90fd908cb78215191f0bc", "filename": "compiler/rustc_infer/src/infer/error_reporting/note.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -7,7 +7,7 @@ use rustc_middle::ty::{self, Region};\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub(super) fn note_region_origin(&self, err: &mut Diagnostic, origin: &SubregionOrigin<'tcx>) {\n-        let mut label_or_note = |span, msg| {\n+        let mut label_or_note = |span, msg: &str| {\n             let sub_count = err.children.iter().filter(|d| d.span.is_dummy()).count();\n             let expanded_sub_count = err.children.iter().filter(|d| !d.span.is_dummy()).count();\n             let span_is_primary = err.span.primary_spans().iter().all(|&sp| sp == span);"}, {"sha": "e6f9246d73242f4b1c2ebe200a15075b2f30db0d", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -1571,7 +1571,7 @@ impl<'tcx> LateLintPass<'tcx> for TypeAliasBounds {\n                         lint.build(\"bounds on generic parameters are not enforced in type aliases\");\n                     let msg = \"the bound will not be checked when the type alias is used, \\\n                                    and should be removed\";\n-                    err.multipart_suggestion(&msg, suggestion, Applicability::MachineApplicable);\n+                    err.multipart_suggestion(msg, suggestion, Applicability::MachineApplicable);\n                     if !suggested_changing_assoc_types {\n                         TypeAliasBounds::suggest_changing_assoc_types(ty, &mut err);\n                         suggested_changing_assoc_types = true;"}, {"sha": "67f5aa0540fbe19c42eb9a331189d3c3e47ec09b", "filename": "compiler/rustc_lint/src/expect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -37,7 +37,7 @@ fn emit_unfulfilled_expectation_lint(\n         |diag| {\n             let mut diag = diag.build(\"this lint expectation is unfulfilled\");\n             if let Some(rationale) = expectation.reason {\n-                diag.note(&rationale.as_str());\n+                diag.note(rationale.as_str());\n             }\n \n             if expectation.is_unfulfilled_lint_expectations {"}, {"sha": "14ac30987b35cb35656d1299be91565cabfe3b4a", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -154,7 +154,7 @@ fn lint_overflowing_range_endpoint<'tcx>(\n                     let suggestion = format!(\"{}..={}{}\", start, lit_val - 1, suffix);\n                     err.span_suggestion(\n                         parent_expr.span,\n-                        &\"use an inclusive range instead\",\n+                        \"use an inclusive range instead\",\n                         suggestion,\n                         Applicability::MachineApplicable,\n                     );\n@@ -399,7 +399,7 @@ fn lint_uint_literal<'tcx>(\n                             lint.build(\"only `u8` can be cast into `char`\")\n                                 .span_suggestion(\n                                     par_e.span,\n-                                    &\"use a `char` literal instead\",\n+                                    \"use a `char` literal instead\",\n                                     format!(\"'\\\\u{{{:X}}}'\", lit_val),\n                                     Applicability::MachineApplicable,\n                                 )"}, {"sha": "ed2640451705b6080e89b48cfc58e9b69dd2bd47", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -18,7 +18,9 @@ use rustc_ast::{\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{pluralize, struct_span_err, Diagnostic, EmissionGuarantee, ErrorGuaranteed};\n-use rustc_errors::{Applicability, DiagnosticBuilder, Handler, MultiSpan, PResult};\n+use rustc_errors::{\n+    Applicability, DiagnosticBuilder, DiagnosticMessage, Handler, MultiSpan, PResult,\n+};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, Ident};\n use rustc_span::{Span, SpanSnippetError, DUMMY_SP};\n@@ -273,12 +275,12 @@ impl<'a> Parser<'a> {\n     pub fn struct_span_err<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n-        m: &str,\n+        m: impl Into<DiagnosticMessage>,\n     ) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n         self.sess.span_diagnostic.struct_span_err(sp, m)\n     }\n \n-    pub fn span_bug<S: Into<MultiSpan>>(&self, sp: S, m: &str) -> ! {\n+    pub fn span_bug<S: Into<MultiSpan>>(&self, sp: S, m: impl Into<DiagnosticMessage>) -> ! {\n         self.sess.span_diagnostic.span_bug(sp, m)\n     }\n \n@@ -584,16 +586,22 @@ impl<'a> Parser<'a> {\n                     //     field: value,\n                     // } }\n                     err.delay_as_bug();\n-                    self.struct_span_err(expr.span, \"struct literal body without path\")\n-                        .multipart_suggestion(\n-                            \"you might have forgotten to add the struct literal inside the block\",\n-                            vec![\n-                                (expr.span.shrink_to_lo(), \"{ SomeStruct \".to_string()),\n-                                (expr.span.shrink_to_hi(), \" }\".to_string()),\n-                            ],\n-                            Applicability::MaybeIncorrect,\n-                        )\n-                        .emit();\n+                    self.struct_span_err(\n+                        expr.span,\n+                        DiagnosticMessage::fluent(\"parser-struct-literal-body-without-path\"),\n+                    )\n+                    .multipart_suggestion(\n+                        DiagnosticMessage::fluent_attr(\n+                            \"parser-struct-literal-body-without-path\",\n+                            \"suggestion\",\n+                        ),\n+                        vec![\n+                            (expr.span.shrink_to_lo(), \"{ SomeStruct \".to_string()),\n+                            (expr.span.shrink_to_hi(), \" }\".to_string()),\n+                        ],\n+                        Applicability::MaybeIncorrect,\n+                    )\n+                    .emit();\n                     self.restore_snapshot(snapshot);\n                     let mut tail = self.mk_block(\n                         vec![self.mk_stmt_err(expr.span)],\n@@ -1752,7 +1760,7 @@ impl<'a> Parser<'a> {\n                     let mut primary_span: MultiSpan = primary_span.into();\n                     for span_label in err.span.span_labels() {\n                         if let Some(label) = span_label.label {\n-                            primary_span.push_span_message(span_label.span, label);\n+                            primary_span.push_span_label(span_label.span, label);\n                         }\n                     }\n                     err.set_span(primary_span);"}, {"sha": "7978a1a7f5fff53a4ed770bd82fe1d174c42e905", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -1703,7 +1703,7 @@ impl<'a> Parser<'a> {\n                     if matches!(expr.kind, ExprKind::Err) {\n                         let mut err = self\n                             .diagnostic()\n-                            .struct_span_err(self.token.span, &\"invalid interpolated expression\");\n+                            .struct_span_err(self.token.span, \"invalid interpolated expression\");\n                         err.downgrade_to_delayed_bug();\n                         return err;\n                     }\n@@ -1820,7 +1820,7 @@ impl<'a> Parser<'a> {\n                 } else if let Some(fixed) = fix_base_capitalisation(suf) {\n                     let msg = \"invalid base prefix for number literal\";\n \n-                    self.struct_span_err(span, &msg)\n+                    self.struct_span_err(span, msg)\n                         .note(\"base prefixes (`0xff`, `0b1010`, `0o755`) are lowercase\")\n                         .span_suggestion(\n                             span,"}, {"sha": "5bf6f22b5d06452f760134a1b5d6756e980fb649", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -1011,7 +1011,7 @@ impl<'a> Parser<'a> {\n                 let current_qual_sp = current_qual_sp.to(sp_start);\n                 if let Ok(current_qual) = self.span_to_snippet(current_qual_sp) {\n                     // FIXME(davidtwco): avoid depending on the error message text\n-                    if err.message().as_str() == \"expected `{`, found keyword `unsafe`\" {\n+                    if err.message[0].0.expect_str() == \"expected `{`, found keyword `unsafe`\" {\n                         let invalid_qual_sp = self.token.uninterpolated_span();\n                         let invalid_qual = self.span_to_snippet(invalid_qual_sp).unwrap();\n "}, {"sha": "700290d67a41b23594d12dffb06b9cf5f2749020", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -620,8 +620,8 @@ fn incremental_verify_ich_cold(sess: &Session, dep_node: DebugArg<'_>, result: D\n     } else {\n         sess.struct_err(&format!(\"internal compiler error: encountered incremental compilation error with {:?}\", dep_node))\n                 .help(&format!(\"This is a known issue with the compiler. Run {} to allow your project to compile\", run_cmd))\n-                .note(&\"Please follow the instructions below to create a bug report with the provided information\")\n-                .note(&\"See <https://github.com/rust-lang/rust/issues/84970> for more information\")\n+                .note(\"Please follow the instructions below to create a bug report with the provided information\")\n+                .note(\"See <https://github.com/rust-lang/rust/issues/84970> for more information\")\n                 .emit();\n         panic!(\"Found unstable fingerprints for {:?}: {:?}\", dep_node, result);\n     }"}, {"sha": "609dbd1fe1b4e8606bb0e2f8946cfd3532f11c13", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -1341,7 +1341,7 @@ impl<'a> Resolver<'a> {\n             let def_span = self.session.source_map().guess_head_span(binding.span);\n             let mut note_span = MultiSpan::from_span(def_span);\n             if !first && binding.vis.is_public() {\n-                note_span.push_span_label(def_span, \"consider importing it directly\".into());\n+                note_span.push_span_label(def_span, \"consider importing it directly\");\n             }\n             err.span_note(note_span, &msg);\n         }"}, {"sha": "02abdbaa98354b9e37b09c9cf5a9b252ad3152d8", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -739,7 +739,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n \n         if let Some((_, UnresolvedImportError { note, .. })) = errors.iter().last() {\n             for message in note {\n-                diag.note(&message);\n+                diag.note(message);\n             }\n         }\n "}, {"sha": "1e943f0e44abd5b24c44fb1eb5bb5af3f817ff13", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -1140,7 +1140,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                         }\n                         err.span_suggestion(\n                             span,\n-                            &\"use this syntax instead\",\n+                            \"use this syntax instead\",\n                             path_str.to_string(),\n                             Applicability::MaybeIncorrect,\n                         );"}, {"sha": "d5053034ed88298a0c885e6da5410e4b80c39a10", "filename": "compiler/rustc_serialize/src/serialize.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -431,6 +431,20 @@ where\n     }\n }\n \n+impl<'a, S: Encoder> Encodable<S> for Cow<'a, str> {\n+    fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n+        let val: &str = self;\n+        val.encode(s)\n+    }\n+}\n+\n+impl<'a, D: Decoder> Decodable<D> for Cow<'a, str> {\n+    fn decode(d: &mut D) -> Cow<'static, str> {\n+        let v: String = Decodable::decode(d);\n+        Cow::Owned(v)\n+    }\n+}\n+\n impl<S: Encoder, T: Encodable<S>> Encodable<S> for Option<T> {\n     fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_option(|s| match *self {"}, {"sha": "49c1a1be2018dfcde43205482252acd9fbd5d6c2", "filename": "compiler/rustc_session/src/parse.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_session%2Fsrc%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fparse.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -8,7 +8,8 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{Lock, Lrc};\n use rustc_errors::{emitter::SilentEmitter, ColorConfig, Handler};\n use rustc_errors::{\n-    error_code, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, MultiSpan,\n+    error_code, fallback_fluent_bundle, Applicability, Diagnostic, DiagnosticBuilder,\n+    ErrorGuaranteed, MultiSpan,\n };\n use rustc_feature::{find_feature_issue, GateIssue, UnstableFeatures};\n use rustc_span::edition::Edition;\n@@ -173,8 +174,15 @@ pub struct ParseSess {\n impl ParseSess {\n     /// Used for testing.\n     pub fn new(file_path_mapping: FilePathMapping) -> Self {\n+        let fallback_bundle = fallback_fluent_bundle();\n         let sm = Lrc::new(SourceMap::new(file_path_mapping));\n-        let handler = Handler::with_tty_emitter(ColorConfig::Auto, true, None, Some(sm.clone()));\n+        let handler = Handler::with_tty_emitter(\n+            ColorConfig::Auto,\n+            true,\n+            None,\n+            Some(sm.clone()),\n+            fallback_bundle,\n+        );\n         ParseSess::with_span_handler(handler, sm)\n     }\n \n@@ -203,8 +211,10 @@ impl ParseSess {\n     }\n \n     pub fn with_silent_emitter(fatal_note: Option<String>) -> Self {\n+        let fallback_bundle = fallback_fluent_bundle();\n         let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-        let fatal_handler = Handler::with_tty_emitter(ColorConfig::Auto, false, None, None);\n+        let fatal_handler =\n+            Handler::with_tty_emitter(ColorConfig::Auto, false, None, None, fallback_bundle);\n         let handler = Handler::with_emitter(\n             false,\n             None,"}, {"sha": "9a11f537c256c88305153c8fe16e23ac35cdccb7", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 92, "deletions": 35, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -19,7 +19,10 @@ use rustc_errors::annotate_snippet_emitter_writer::AnnotateSnippetEmitterWriter;\n use rustc_errors::emitter::{Emitter, EmitterWriter, HumanReadableErrorType};\n use rustc_errors::json::JsonEmitter;\n use rustc_errors::registry::Registry;\n-use rustc_errors::{DiagnosticBuilder, DiagnosticId, ErrorGuaranteed, MultiSpan};\n+use rustc_errors::{\n+    fallback_fluent_bundle, DiagnosticBuilder, DiagnosticId, DiagnosticMessage, ErrorGuaranteed,\n+    FluentBundle, MultiSpan,\n+};\n use rustc_macros::HashStable_Generic;\n pub use rustc_span::def_id::StableCrateId;\n use rustc_span::edition::Edition;\n@@ -279,111 +282,128 @@ impl Session {\n     pub fn struct_span_warn<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n     ) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_span_warn(sp, msg)\n     }\n     pub fn struct_span_warn_with_code<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         code: DiagnosticId,\n     ) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_span_warn_with_code(sp, msg, code)\n     }\n-    pub fn struct_warn(&self, msg: &str) -> DiagnosticBuilder<'_, ()> {\n+    pub fn struct_warn(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_warn(msg)\n     }\n     pub fn struct_span_allow<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n     ) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_span_allow(sp, msg)\n     }\n-    pub fn struct_allow(&self, msg: &str) -> DiagnosticBuilder<'_, ()> {\n+    pub fn struct_allow(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_allow(msg)\n     }\n     pub fn struct_expect(\n         &self,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         id: lint::LintExpectationId,\n     ) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_expect(msg, id)\n     }\n     pub fn struct_span_err<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n     ) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n         self.diagnostic().struct_span_err(sp, msg)\n     }\n     pub fn struct_span_err_with_code<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         code: DiagnosticId,\n     ) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n         self.diagnostic().struct_span_err_with_code(sp, msg, code)\n     }\n     // FIXME: This method should be removed (every error should have an associated error code).\n-    pub fn struct_err(&self, msg: &str) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n+    pub fn struct_err(\n+        &self,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n         self.diagnostic().struct_err(msg)\n     }\n     pub fn struct_err_with_code(\n         &self,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         code: DiagnosticId,\n     ) -> DiagnosticBuilder<'_, ErrorGuaranteed> {\n         self.diagnostic().struct_err_with_code(msg, code)\n     }\n     pub fn struct_span_fatal<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n     ) -> DiagnosticBuilder<'_, !> {\n         self.diagnostic().struct_span_fatal(sp, msg)\n     }\n     pub fn struct_span_fatal_with_code<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         code: DiagnosticId,\n     ) -> DiagnosticBuilder<'_, !> {\n         self.diagnostic().struct_span_fatal_with_code(sp, msg, code)\n     }\n-    pub fn struct_fatal(&self, msg: &str) -> DiagnosticBuilder<'_, !> {\n+    pub fn struct_fatal(&self, msg: impl Into<DiagnosticMessage>) -> DiagnosticBuilder<'_, !> {\n         self.diagnostic().struct_fatal(msg)\n     }\n \n-    pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n+    pub fn span_fatal<S: Into<MultiSpan>>(&self, sp: S, msg: impl Into<DiagnosticMessage>) -> ! {\n         self.diagnostic().span_fatal(sp, msg)\n     }\n     pub fn span_fatal_with_code<S: Into<MultiSpan>>(\n         &self,\n         sp: S,\n-        msg: &str,\n+        msg: impl Into<DiagnosticMessage>,\n         code: DiagnosticId,\n     ) -> ! {\n         self.diagnostic().span_fatal_with_code(sp, msg, code)\n     }\n-    pub fn fatal(&self, msg: &str) -> ! {\n+    pub fn fatal(&self, msg: impl Into<DiagnosticMessage>) -> ! {\n         self.diagnostic().fatal(msg).raise()\n     }\n-    pub fn span_err_or_warn<S: Into<MultiSpan>>(&self, is_warning: bool, sp: S, msg: &str) {\n+    pub fn span_err_or_warn<S: Into<MultiSpan>>(\n+        &self,\n+        is_warning: bool,\n+        sp: S,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) {\n         if is_warning {\n             self.span_warn(sp, msg);\n         } else {\n             self.span_err(sp, msg);\n         }\n     }\n-    pub fn span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ErrorGuaranteed {\n+    pub fn span_err<S: Into<MultiSpan>>(\n+        &self,\n+        sp: S,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> ErrorGuaranteed {\n         self.diagnostic().span_err(sp, msg)\n     }\n-    pub fn span_err_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: DiagnosticId) {\n-        self.diagnostic().span_err_with_code(sp, &msg, code)\n+    pub fn span_err_with_code<S: Into<MultiSpan>>(\n+        &self,\n+        sp: S,\n+        msg: impl Into<DiagnosticMessage>,\n+        code: DiagnosticId,\n+    ) {\n+        self.diagnostic().span_err_with_code(sp, msg, code)\n     }\n-    pub fn err(&self, msg: &str) -> ErrorGuaranteed {\n+    pub fn err(&self, msg: impl Into<DiagnosticMessage>) -> ErrorGuaranteed {\n         self.diagnostic().err(msg)\n     }\n     pub fn emit_err<'a>(&'a self, err: impl SessionDiagnostic<'a>) -> ErrorGuaranteed {\n@@ -423,25 +443,34 @@ impl Session {\n             Err(ErrorGuaranteed::unchecked_claim_error_was_emitted())\n         }\n     }\n-    pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n+    pub fn span_warn<S: Into<MultiSpan>>(&self, sp: S, msg: impl Into<DiagnosticMessage>) {\n         self.diagnostic().span_warn(sp, msg)\n     }\n-    pub fn span_warn_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: DiagnosticId) {\n+    pub fn span_warn_with_code<S: Into<MultiSpan>>(\n+        &self,\n+        sp: S,\n+        msg: impl Into<DiagnosticMessage>,\n+        code: DiagnosticId,\n+    ) {\n         self.diagnostic().span_warn_with_code(sp, msg, code)\n     }\n-    pub fn warn(&self, msg: &str) {\n+    pub fn warn(&self, msg: impl Into<DiagnosticMessage>) {\n         self.diagnostic().warn(msg)\n     }\n     /// Delay a span_bug() call until abort_if_errors()\n     #[track_caller]\n-    pub fn delay_span_bug<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ErrorGuaranteed {\n+    pub fn delay_span_bug<S: Into<MultiSpan>>(\n+        &self,\n+        sp: S,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> ErrorGuaranteed {\n         self.diagnostic().delay_span_bug(sp, msg)\n     }\n \n     /// Used for code paths of expensive computations that should only take place when\n     /// warnings or errors are emitted. If no messages are emitted (\"good path\"), then\n     /// it's likely a bug.\n-    pub fn delay_good_path_bug(&self, msg: &str) {\n+    pub fn delay_good_path_bug(&self, msg: impl Into<DiagnosticMessage>) {\n         if self.opts.debugging_opts.print_type_sizes\n             || self.opts.debugging_opts.query_dep_graph\n             || self.opts.debugging_opts.dump_mir.is_some()\n@@ -455,13 +484,20 @@ impl Session {\n         self.diagnostic().delay_good_path_bug(msg)\n     }\n \n-    pub fn note_without_error(&self, msg: &str) {\n+    pub fn note_without_error(&self, msg: impl Into<DiagnosticMessage>) {\n         self.diagnostic().note_without_error(msg)\n     }\n-    pub fn span_note_without_error<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n+    pub fn span_note_without_error<S: Into<MultiSpan>>(\n+        &self,\n+        sp: S,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) {\n         self.diagnostic().span_note_without_error(sp, msg)\n     }\n-    pub fn struct_note_without_error(&self, msg: &str) -> DiagnosticBuilder<'_, ()> {\n+    pub fn struct_note_without_error(\n+        &self,\n+        msg: impl Into<DiagnosticMessage>,\n+    ) -> DiagnosticBuilder<'_, ()> {\n         self.diagnostic().struct_note_without_error(msg)\n     }\n \n@@ -1033,6 +1069,7 @@ fn default_emitter(\n     sopts: &config::Options,\n     registry: rustc_errors::registry::Registry,\n     source_map: Lrc<SourceMap>,\n+    fallback_bundle: Lrc<FluentBundle>,\n     emitter_dest: Option<Box<dyn Write + Send>>,\n ) -> Box<dyn Emitter + sync::Send> {\n     let macro_backtrace = sopts.debugging_opts.macro_backtrace;\n@@ -1041,14 +1078,19 @@ fn default_emitter(\n             let (short, color_config) = kind.unzip();\n \n             if let HumanReadableErrorType::AnnotateSnippet(_) = kind {\n-                let emitter =\n-                    AnnotateSnippetEmitterWriter::new(Some(source_map), short, macro_backtrace);\n+                let emitter = AnnotateSnippetEmitterWriter::new(\n+                    Some(source_map),\n+                    fallback_bundle,\n+                    short,\n+                    macro_backtrace,\n+                );\n                 Box::new(emitter.ui_testing(sopts.debugging_opts.ui_testing))\n             } else {\n                 let emitter = match dst {\n                     None => EmitterWriter::stderr(\n                         color_config,\n                         Some(source_map),\n+                        fallback_bundle,\n                         short,\n                         sopts.debugging_opts.teach,\n                         sopts.debugging_opts.terminal_width,\n@@ -1057,6 +1099,7 @@ fn default_emitter(\n                     Some(dst) => EmitterWriter::new(\n                         dst,\n                         Some(source_map),\n+                        fallback_bundle,\n                         short,\n                         false, // no teach messages when writing to a buffer\n                         false, // no colors when writing to a buffer\n@@ -1071,6 +1114,7 @@ fn default_emitter(\n             JsonEmitter::stderr(\n                 Some(registry),\n                 source_map,\n+                fallback_bundle,\n                 pretty,\n                 json_rendered,\n                 sopts.debugging_opts.terminal_width,\n@@ -1083,6 +1127,7 @@ fn default_emitter(\n                 dst,\n                 Some(registry),\n                 source_map,\n+                fallback_bundle,\n                 pretty,\n                 json_rendered,\n                 sopts.debugging_opts.terminal_width,\n@@ -1152,7 +1197,10 @@ pub fn build_session(\n         sopts.file_path_mapping(),\n         hash_kind,\n     ));\n-    let emitter = default_emitter(&sopts, registry, source_map.clone(), write_dest);\n+\n+    let fallback_bundle = fallback_fluent_bundle();\n+    let emitter =\n+        default_emitter(&sopts, registry, source_map.clone(), fallback_bundle.clone(), write_dest);\n \n     let span_diagnostic = rustc_errors::Handler::with_emitter_and_flags(\n         emitter,\n@@ -1385,13 +1433,22 @@ pub enum IncrCompSession {\n }\n \n fn early_error_handler(output: config::ErrorOutputType) -> rustc_errors::Handler {\n+    let fallback_bundle = fallback_fluent_bundle();\n     let emitter: Box<dyn Emitter + sync::Send> = match output {\n         config::ErrorOutputType::HumanReadable(kind) => {\n             let (short, color_config) = kind.unzip();\n-            Box::new(EmitterWriter::stderr(color_config, None, short, false, None, false))\n+            Box::new(EmitterWriter::stderr(\n+                color_config,\n+                None,\n+                fallback_bundle,\n+                short,\n+                false,\n+                None,\n+                false,\n+            ))\n         }\n         config::ErrorOutputType::Json { pretty, json_rendered } => {\n-            Box::new(JsonEmitter::basic(pretty, json_rendered, None, false))\n+            Box::new(JsonEmitter::basic(pretty, json_rendered, fallback_bundle, None, false))\n         }\n     };\n     rustc_errors::Handler::with_emitter(true, None, emitter)"}, {"sha": "8dac56120e6605c2294661290d51324807eea2bd", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -597,7 +597,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     Some(format!(\"{}\", name))\n                 }\n                 _ => {\n-                    err.note(&msg);\n+                    err.note(msg);\n                     None\n                 }\n             }\n@@ -2481,7 +2481,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     .opt_associated_item(trait_item_def_id)\n                     .and_then(|i| self.tcx.opt_item_name(i.container.id()))\n                 {\n-                    assoc_span.push_span_label(ident.span, \"in this trait\".into());\n+                    assoc_span.push_span_label(ident.span, \"in this trait\");\n                 }\n                 err.span_note(assoc_span, &msg);\n             }\n@@ -2506,7 +2506,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     .opt_associated_item(trait_item_def_id)\n                     .and_then(|i| self.tcx.opt_item_name(i.container.id()))\n                 {\n-                    assoc_span.push_span_label(ident.span, \"in this trait\".into());\n+                    assoc_span.push_span_label(ident.span, \"in this trait\");\n                 }\n                 err.span_note(assoc_span, &msg);\n             }"}, {"sha": "84958136cac97b98dadea1239e44162882d4fd63", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -169,10 +169,7 @@ fn lint_object_unsafe_trait(\n         let node = tcx.hir().get_if_local(trait_def_id);\n         let mut spans = MultiSpan::from_span(span);\n         if let Some(hir::Node::Item(item)) = node {\n-            spans.push_span_label(\n-                item.ident.span,\n-                \"this trait cannot be made into an object...\".into(),\n-            );\n+            spans.push_span_label(item.ident.span, \"this trait cannot be made into an object...\");\n             spans.push_span_label(span, format!(\"...because {}\", violation.error_msg()));\n         } else {\n             spans.push_span_label("}, {"sha": "44b6b4b62ce48f82912cd3e2a18d5709ccf88a3f", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -143,13 +143,15 @@ crate fn new_handler(\n     source_map: Option<Lrc<source_map::SourceMap>>,\n     debugging_opts: &DebuggingOptions,\n ) -> rustc_errors::Handler {\n+    let fallback_bundle = rustc_errors::fallback_fluent_bundle();\n     let emitter: Box<dyn Emitter + sync::Send> = match error_format {\n         ErrorOutputType::HumanReadable(kind) => {\n             let (short, color_config) = kind.unzip();\n             Box::new(\n                 EmitterWriter::stderr(\n                     color_config,\n                     source_map.map(|sm| sm as _),\n+                    fallback_bundle,\n                     short,\n                     debugging_opts.teach,\n                     debugging_opts.terminal_width,\n@@ -166,6 +168,7 @@ crate fn new_handler(\n                 JsonEmitter::stderr(\n                     None,\n                     source_map,\n+                    fallback_bundle,\n                     pretty,\n                     json_rendered,\n                     debugging_opts.terminal_width,"}, {"sha": "fc079619786db352adc9e69b2289a16c1d0363f5", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -537,12 +537,28 @@ crate fn make_test(\n             // Any errors in parsing should also appear when the doctest is compiled for real, so just\n             // send all the errors that librustc_ast emits directly into a `Sink` instead of stderr.\n             let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-            supports_color =\n-                EmitterWriter::stderr(ColorConfig::Auto, None, false, false, Some(80), false)\n-                    .supports_color();\n-\n-            let emitter =\n-                EmitterWriter::new(box io::sink(), None, false, false, false, None, false);\n+            let fallback_bundle = rustc_errors::fallback_fluent_bundle();\n+            supports_color = EmitterWriter::stderr(\n+                ColorConfig::Auto,\n+                None,\n+                fallback_bundle.clone(),\n+                false,\n+                false,\n+                Some(80),\n+                false,\n+            )\n+            .supports_color();\n+\n+            let emitter = EmitterWriter::new(\n+                box io::sink(),\n+                None,\n+                fallback_bundle,\n+                false,\n+                false,\n+                false,\n+                None,\n+                false,\n+            );\n \n             // FIXME(misdreavus): pass `-Z treat-err-as-bug` to the doctest parser\n             let handler = Handler::with_emitter(false, None, box emitter);"}, {"sha": "10f1fc054045ea05b0bc5ccc80930338b2cf83a3", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -32,7 +32,8 @@ struct SyntaxChecker<'a, 'tcx> {\n impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n     fn check_rust_syntax(&self, item: &clean::Item, dox: &str, code_block: RustCodeBlock) {\n         let buffer = Lrc::new(Lock::new(Buffer::default()));\n-        let emitter = BufferEmitter { buffer: Lrc::clone(&buffer) };\n+        let fallback_bundle = rustc_errors::fallback_fluent_bundle();\n+        let emitter = BufferEmitter { buffer: Lrc::clone(&buffer), fallback_bundle };\n \n         let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n         let handler = Handler::with_emitter(false, None, Box::new(emitter));\n@@ -171,12 +172,14 @@ struct Buffer {\n \n struct BufferEmitter {\n     buffer: Lrc<Lock<Buffer>>,\n+    fallback_bundle: Lrc<rustc_errors::FluentBundle>,\n }\n \n impl Emitter for BufferEmitter {\n     fn emit_diagnostic(&mut self, diag: &Diagnostic) {\n         let mut buffer = self.buffer.borrow_mut();\n-        buffer.messages.push(format!(\"error from rustc: {}\", diag.message[0].0.as_str()));\n+        // FIXME(davidtwco): need to support translation here eventually\n+        buffer.messages.push(format!(\"error from rustc: {}\", diag.message[0].0.expect_str()));\n         if diag.is_error() {\n             buffer.has_errors = true;\n         }\n@@ -185,4 +188,12 @@ impl Emitter for BufferEmitter {\n     fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n         None\n     }\n+\n+    fn fluent_bundle(&self) -> Option<&Lrc<rustc_errors::FluentBundle>> {\n+        None\n+    }\n+\n+    fn fallback_fluent_bundle(&self) -> &Lrc<rustc_errors::FluentBundle> {\n+        &self.fallback_bundle\n+    }\n }"}, {"sha": "cc354b50afa39faa68159d1d16ae8027ff8f5658", "filename": "src/tools/clippy/clippy_lints/src/collapsible_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_match.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -130,8 +130,8 @@ fn check_arm<'tcx>(\n                 &msg,\n                 |diag| {\n                     let mut help_span = MultiSpan::from_spans(vec![binding_span, inner_then_pat.span]);\n-                    help_span.push_span_label(binding_span, \"replace this binding\".into());\n-                    help_span.push_span_label(inner_then_pat.span, \"with this pattern\".into());\n+                    help_span.push_span_label(binding_span, \"replace this binding\");\n+                    help_span.push_span_label(inner_then_pat.span, \"with this pattern\");\n                     diag.span_help(help_span, \"the outer pattern can be modified to include the inner pattern\");\n                 },\n             );"}, {"sha": "b836363b31b556c85b48af114b0d69c8778723f3", "filename": "src/tools/clippy/clippy_lints/src/doc.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -621,7 +621,17 @@ fn check_code(cx: &LateContext<'_>, text: &str, edition: Edition, span: Span) {\n                 let filename = FileName::anon_source_code(&code);\n \n                 let sm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n-                let emitter = EmitterWriter::new(Box::new(io::sink()), None, false, false, false, None, false);\n+                let fallback_bundle = rustc_errors::fallback_fluent_bundle();\n+                let emitter = EmitterWriter::new(\n+                    Box::new(io::sink()),\n+                    None,\n+                    fallback_bundle,\n+                    false,\n+                    false,\n+                    false,\n+                    None,\n+                    false,\n+                );\n                 let handler = Handler::with_emitter(false, None, Box::new(emitter));\n                 let sess = ParseSess::with_span_handler(handler, sm);\n "}, {"sha": "ddaffc751880db30251f01d8c246af8c9d8568d6", "filename": "src/tools/clippy/clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -102,7 +102,7 @@ fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCo\n \n                     // Suggest replacing iter_call with iter_replacement, and removing stmt\n                     let mut span = MultiSpan::from_span(method_name.ident.span);\n-                    span.push_span_label(iter_call.span, \"the iterator could be used here instead\".into());\n+                    span.push_span_label(iter_call.span, \"the iterator could be used here instead\");\n                     span_lint_hir_and_then(\n                         cx,\n                         super::NEEDLESS_COLLECT,"}, {"sha": "06209bfe7b08ada6cb6dc2f349d6cbe95decab2a", "filename": "src/tools/clippy/clippy_lints/src/missing_const_for_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_const_for_fn.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -148,7 +148,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingConstForFn {\n \n         if let Err((span, err)) = is_min_const_fn(cx.tcx, mir, self.msrv.as_ref()) {\n             if cx.tcx.is_const_fn_raw(def_id.to_def_id()) {\n-                cx.tcx.sess.span_err(span, &err);\n+                cx.tcx.sess.span_err(span, err.as_ref());\n             }\n         } else {\n             span_lint(cx, MISSING_CONST_FOR_FN, span, \"this could be a `const fn`\");"}, {"sha": "d29d07da7b0ffdcc8aa85a28443b6d8f1623357f", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -235,11 +235,12 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                                 for (span, suggestion) in clone_spans {\n                                     diag.span_suggestion(\n                                         span,\n-                                        &snippet_opt(cx, span)\n+                                        snippet_opt(cx, span)\n                                             .map_or(\n                                                 \"change the call to\".into(),\n                                                 |x| Cow::from(format!(\"change `{}` to\", x)),\n-                                            ),\n+                                            )\n+                                            .as_ref(),\n                                         suggestion.into(),\n                                         Applicability::Unspecified,\n                                     );\n@@ -264,11 +265,12 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                                 for (span, suggestion) in clone_spans {\n                                     diag.span_suggestion(\n                                         span,\n-                                        &snippet_opt(cx, span)\n+                                        snippet_opt(cx, span)\n                                             .map_or(\n                                                 \"change the call to\".into(),\n                                                 |x| Cow::from(format!(\"change `{}` to\", x))\n-                                            ),\n+                                            )\n+                                            .as_ref(),\n                                         suggestion.into(),\n                                         Applicability::Unspecified,\n                                     );"}, {"sha": "bfce787af5ea826d37896a20806d3f9861b5ce5d", "filename": "src/tools/clippy/src/driver.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -165,9 +165,11 @@ fn report_clippy_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n     // Separate the output with an empty line\n     eprintln!();\n \n+    let fallback_bundle = rustc_errors::fallback_fluent_bundle();\n     let emitter = Box::new(rustc_errors::emitter::EmitterWriter::stderr(\n         rustc_errors::ColorConfig::Auto,\n         None,\n+        fallback_bundle,\n         false,\n         false,\n         None,\n@@ -191,7 +193,7 @@ fn report_clippy_ice(info: &panic::PanicInfo<'_>, bug_report_url: &str) {\n     ];\n \n     for note in &xs {\n-        handler.note_without_error(note);\n+        handler.note_without_error(note.as_ref());\n     }\n \n     // If backtraces are enabled, also print the query stack"}, {"sha": "4563dbf6c16b022e755c4ec71c8b994882cbb035", "filename": "src/tools/rustfmt/src/parse/session.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7f91697b5035f8620df4de47057024c3539b55a6/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f91697b5035f8620df4de47057024c3539b55a6/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustfmt%2Fsrc%2Fparse%2Fsession.rs?ref=7f91697b5035f8620df4de47057024c3539b55a6", "patch": "@@ -33,6 +33,12 @@ impl Emitter for SilentEmitter {\n         None\n     }\n     fn emit_diagnostic(&mut self, _db: &Diagnostic) {}\n+    fn fluent_bundle(&self) -> Option<&Lrc<rustc_errors::FluentBundle>> {\n+        None\n+    }\n+    fn fallback_fluent_bundle(&self) -> &Lrc<rustc_errors::FluentBundle> {\n+        panic!(\"silent emitter attempted to translate a diagnostic\");\n+    }\n }\n \n fn silent_emitter() -> Box<dyn Emitter + Send> {\n@@ -82,6 +88,14 @@ impl Emitter for SilentOnIgnoredFilesEmitter {\n         }\n         self.handle_non_ignoreable_error(db);\n     }\n+\n+    fn fluent_bundle(&self) -> Option<&Lrc<rustc_errors::FluentBundle>> {\n+        self.emitter.fluent_bundle()\n+    }\n+\n+    fn fallback_fluent_bundle(&self) -> &Lrc<rustc_errors::FluentBundle> {\n+        self.emitter.fallback_fluent_bundle()\n+    }\n }\n \n fn default_handler(\n@@ -100,9 +114,11 @@ fn default_handler(\n     let emitter = if hide_parse_errors {\n         silent_emitter()\n     } else {\n+        let fallback_bundle = rustc_errors::fallback_fluent_bundle();\n         Box::new(EmitterWriter::stderr(\n             color_cfg,\n             Some(source_map.clone()),\n+            fallback_bundle,\n             false,\n             false,\n             None,\n@@ -329,6 +345,12 @@ mod tests {\n             fn emit_diagnostic(&mut self, _db: &Diagnostic) {\n                 self.num_emitted_errors.fetch_add(1, Ordering::Release);\n             }\n+            fn fluent_bundle(&self) -> Option<&Lrc<rustc_errors::FluentBundle>> {\n+                None\n+            }\n+            fn fallback_fluent_bundle(&self) -> &Lrc<rustc_errors::FluentBundle> {\n+                panic!(\"test emitter attempted to translate a diagnostic\");\n+            }\n         }\n \n         fn build_diagnostic(level: DiagnosticLevel, span: Option<MultiSpan>) -> Diagnostic {"}]}