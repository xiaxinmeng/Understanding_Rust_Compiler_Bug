{"sha": "7f6e160875f375bb71d1ae761cb5cab8f0b02e19", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmNmUxNjA4NzVmMzc1YmI3MWQxYWU3NjFjYjVjYWI4ZjBiMDJlMTk=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-09-17T04:23:32Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2019-09-17T05:32:29Z"}, "message": "Rename some index variables.\n\nNow that all indices have type `usize`, it makes sense to be more\nconsistent about their naming. This commit removes all uses of `i` in\nfavour of `index`.", "tree": {"sha": "7798bafc87d7cf324a756e2c8c995938c647170b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7798bafc87d7cf324a756e2c8c995938c647170b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f6e160875f375bb71d1ae761cb5cab8f0b02e19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f6e160875f375bb71d1ae761cb5cab8f0b02e19", "html_url": "https://github.com/rust-lang/rust/commit/7f6e160875f375bb71d1ae761cb5cab8f0b02e19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f6e160875f375bb71d1ae761cb5cab8f0b02e19/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf3a562c981252f2f4e4c89d7cae353ea00529e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf3a562c981252f2f4e4c89d7cae353ea00529e3", "html_url": "https://github.com/rust-lang/rust/commit/cf3a562c981252f2f4e4c89d7cae353ea00529e3"}], "stats": {"total": 88, "additions": 44, "deletions": 44}, "files": [{"sha": "98ae1a58324476c5c1731d32a20b1d13f97a0bb3", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/7f6e160875f375bb71d1ae761cb5cab8f0b02e19/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f6e160875f375bb71d1ae761cb5cab8f0b02e19/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=7f6e160875f375bb71d1ae761cb5cab8f0b02e19", "patch": "@@ -353,9 +353,9 @@ impl<O: ForestObligation> ObligationForest<O> {\n     /// Converts all remaining obligations to the given error.\n     pub fn to_errors<E: Clone>(&mut self, error: E) -> Vec<Error<O, E>> {\n         let mut errors = vec![];\n-        for (i, node) in self.nodes.iter().enumerate() {\n+        for (index, node) in self.nodes.iter().enumerate() {\n             if let NodeState::Pending = node.state.get() {\n-                let backtrace = self.error_at(i);\n+                let backtrace = self.error_at(index);\n                 errors.push(Error {\n                     error: error.clone(),\n                     backtrace,\n@@ -399,10 +399,10 @@ impl<O: ForestObligation> ObligationForest<O> {\n         let mut errors = vec![];\n         let mut stalled = true;\n \n-        for i in 0..self.nodes.len() {\n-            let node = &mut self.nodes[i];\n+        for index in 0..self.nodes.len() {\n+            let node = &mut self.nodes[index];\n \n-            debug!(\"process_obligations: node {} == {:?}\", i, node);\n+            debug!(\"process_obligations: node {} == {:?}\", index, node);\n \n             // `processor.process_obligation` can modify the predicate within\n             // `node.obligation`, and that predicate is the key used for\n@@ -414,7 +414,7 @@ impl<O: ForestObligation> ObligationForest<O> {\n                 _ => continue\n             };\n \n-            debug!(\"process_obligations: node {} got result {:?}\", i, result);\n+            debug!(\"process_obligations: node {} got result {:?}\", index, result);\n \n             match result {\n                 ProcessResult::Unchanged => {\n@@ -428,18 +428,18 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     for child in children {\n                         let st = self.register_obligation_at(\n                             child,\n-                            Some(i)\n+                            Some(index)\n                         );\n                         if let Err(()) = st {\n                             // Error already reported - propagate it\n                             // to our node.\n-                            self.error_at(i);\n+                            self.error_at(index);\n                         }\n                     }\n                 }\n                 ProcessResult::Error(err) => {\n                     stalled = false;\n-                    let backtrace = self.error_at(i);\n+                    let backtrace = self.error_at(index);\n                     errors.push(Error {\n                         error: err,\n                         backtrace,\n@@ -483,14 +483,14 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n         debug!(\"process_cycles()\");\n \n-        for (i, node) in self.nodes.iter().enumerate() {\n+        for (index, node) in self.nodes.iter().enumerate() {\n             // For rustc-benchmarks/inflate-0.1.0 this state test is extremely\n             // hot and the state is almost always `Pending` or `Waiting`. It's\n             // a win to handle the no-op cases immediately to avoid the cost of\n             // the function call.\n             match node.state.get() {\n                 NodeState::Waiting | NodeState::Pending | NodeState::Done | NodeState::Error => {},\n-                _ => self.find_cycles_from_node(&mut stack, processor, i),\n+                _ => self.find_cycles_from_node(&mut stack, processor, index),\n             }\n         }\n \n@@ -500,19 +500,19 @@ impl<O: ForestObligation> ObligationForest<O> {\n         self.scratch.replace(stack);\n     }\n \n-    fn find_cycles_from_node<P>(&self, stack: &mut Vec<usize>, processor: &mut P, i: usize)\n+    fn find_cycles_from_node<P>(&self, stack: &mut Vec<usize>, processor: &mut P, index: usize)\n         where P: ObligationProcessor<Obligation=O>\n     {\n-        let node = &self.nodes[i];\n+        let node = &self.nodes[index];\n         match node.state.get() {\n             NodeState::OnDfsStack => {\n-                let i = stack.iter().rposition(|n| *n == i).unwrap();\n-                processor.process_backedge(stack[i..].iter().map(GetObligation(&self.nodes)),\n+                let index = stack.iter().rposition(|&n| n == index).unwrap();\n+                processor.process_backedge(stack[index..].iter().map(GetObligation(&self.nodes)),\n                                            PhantomData);\n             }\n             NodeState::Success => {\n                 node.state.set(NodeState::OnDfsStack);\n-                stack.push(i);\n+                stack.push(index);\n                 for &index in node.dependents.iter() {\n                     self.find_cycles_from_node(stack, processor, index);\n                 }\n@@ -531,28 +531,28 @@ impl<O: ForestObligation> ObligationForest<O> {\n \n     /// Returns a vector of obligations for `p` and all of its\n     /// ancestors, putting them into the error state in the process.\n-    fn error_at(&self, mut i: usize) -> Vec<O> {\n+    fn error_at(&self, mut index: usize) -> Vec<O> {\n         let mut error_stack = self.scratch.replace(vec![]);\n         let mut trace = vec![];\n \n         loop {\n-            let node = &self.nodes[i];\n+            let node = &self.nodes[index];\n             node.state.set(NodeState::Error);\n             trace.push(node.obligation.clone());\n             if node.has_parent {\n                 // The first dependent is the parent, which is treated\n                 // specially.\n                 error_stack.extend(node.dependents.iter().skip(1));\n-                i = node.dependents[0];\n+                index = node.dependents[0];\n             } else {\n                 // No parent; treat all dependents non-specially.\n                 error_stack.extend(node.dependents.iter());\n                 break;\n             }\n         }\n \n-        while let Some(i) = error_stack.pop() {\n-            let node = &self.nodes[i];\n+        while let Some(index) = error_stack.pop() {\n+            let node = &self.nodes[index];\n             match node.state.get() {\n                 NodeState::Error => continue,\n                 _ => node.state.set(NodeState::Error),\n@@ -568,8 +568,8 @@ impl<O: ForestObligation> ObligationForest<O> {\n     // This always-inlined function is for the hot call site.\n     #[inline(always)]\n     fn inlined_mark_neighbors_as_waiting_from(&self, node: &Node<O>) {\n-        for &dependent in node.dependents.iter() {\n-            self.mark_as_waiting_from(&self.nodes[dependent]);\n+        for &index in node.dependents.iter() {\n+            self.mark_as_waiting_from(&self.nodes[index]);\n         }\n     }\n \n@@ -622,16 +622,16 @@ impl<O: ForestObligation> ObligationForest<O> {\n         // Now move all popped nodes to the end. Try to keep the order.\n         //\n         // LOOP INVARIANT:\n-        //     self.nodes[0..i - dead_nodes] are the first remaining nodes\n-        //     self.nodes[i - dead_nodes..i] are all dead\n-        //     self.nodes[i..] are unchanged\n-        for i in 0..self.nodes.len() {\n-            let node = &self.nodes[i];\n+        //     self.nodes[0..index - dead_nodes] are the first remaining nodes\n+        //     self.nodes[index - dead_nodes..index] are all dead\n+        //     self.nodes[index..] are unchanged\n+        for index in 0..self.nodes.len() {\n+            let node = &self.nodes[index];\n             match node.state.get() {\n                 NodeState::Pending | NodeState::Waiting => {\n                     if dead_nodes > 0 {\n-                        self.nodes.swap(i, i - dead_nodes);\n-                        node_rewrites[i] -= dead_nodes;\n+                        self.nodes.swap(index, index - dead_nodes);\n+                        node_rewrites[index] -= dead_nodes;\n                     }\n                 }\n                 NodeState::Done => {\n@@ -646,17 +646,17 @@ impl<O: ForestObligation> ObligationForest<O> {\n                     } else {\n                         self.done_cache.insert(node.obligation.as_predicate().clone());\n                     }\n-                    node_rewrites[i] = nodes_len;\n+                    node_rewrites[index] = nodes_len;\n                     dead_nodes += 1;\n                 }\n                 NodeState::Error => {\n                     // We *intentionally* remove the node from the cache at this point. Otherwise\n                     // tests must come up with a different type on every type error they\n                     // check against.\n                     self.waiting_cache.remove(node.obligation.as_predicate());\n-                    node_rewrites[i] = nodes_len;\n+                    node_rewrites[index] = nodes_len;\n                     dead_nodes += 1;\n-                    self.insert_into_error_cache(i);\n+                    self.insert_into_error_cache(index);\n                 }\n                 NodeState::OnDfsStack | NodeState::Success => unreachable!()\n             }\n@@ -697,30 +697,30 @@ impl<O: ForestObligation> ObligationForest<O> {\n         let nodes_len = node_rewrites.len();\n \n         for node in &mut self.nodes {\n-            let mut i = 0;\n-            while i < node.dependents.len() {\n-                let new_i = node_rewrites[node.dependents[i]];\n-                if new_i >= nodes_len {\n-                    node.dependents.swap_remove(i);\n-                    if i == 0 && node.has_parent {\n+            let mut index = 0;\n+            while index < node.dependents.len() {\n+                let new_index = node_rewrites[node.dependents[index]];\n+                if new_index >= nodes_len {\n+                    node.dependents.swap_remove(index);\n+                    if index == 0 && node.has_parent {\n                         // We just removed the parent.\n                         node.has_parent = false;\n                     }\n                 } else {\n-                    node.dependents[i] = new_i;\n-                    i += 1;\n+                    node.dependents[index] = new_index;\n+                    index += 1;\n                 }\n             }\n         }\n \n         // This updating of `self.waiting_cache` is necessary because the\n         // removal of nodes within `compress` can fail. See above.\n         self.waiting_cache.retain(|_predicate, index| {\n-            let new_i = node_rewrites[*index];\n-            if new_i >= nodes_len {\n+            let new_index = node_rewrites[*index];\n+            if new_index >= nodes_len {\n                 false\n             } else {\n-                *index = new_i;\n+                *index = new_index;\n                 true\n             }\n         });"}]}