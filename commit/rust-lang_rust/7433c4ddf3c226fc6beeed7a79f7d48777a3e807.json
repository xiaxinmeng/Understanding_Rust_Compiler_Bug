{"sha": "7433c4ddf3c226fc6beeed7a79f7d48777a3e807", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0MzNjNGRkZjNjMjI2ZmM2YmVlZWQ3YTc5ZjdkNDg3NzdhM2U4MDc=", "commit": {"author": {"name": "Diggory Blake", "email": "diggsey@googlemail.com", "date": "2020-04-27T21:50:55Z"}, "committer": {"name": "Diggory Blake", "email": "diggsey@googlemail.com", "date": "2020-05-15T18:53:05Z"}, "message": "Improve the documentation for ManuallyDrop to resolve conflicting usage of terminology.", "tree": {"sha": "e95daa7ab89ebaa40bb69bbc4b881a17c8e4d24b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e95daa7ab89ebaa40bb69bbc4b881a17c8e4d24b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7433c4ddf3c226fc6beeed7a79f7d48777a3e807", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7433c4ddf3c226fc6beeed7a79f7d48777a3e807", "html_url": "https://github.com/rust-lang/rust/commit/7433c4ddf3c226fc6beeed7a79f7d48777a3e807", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7433c4ddf3c226fc6beeed7a79f7d48777a3e807/comments", "author": {"login": "Diggsey", "id": 451321, "node_id": "MDQ6VXNlcjQ1MTMyMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/451321?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Diggsey", "html_url": "https://github.com/Diggsey", "followers_url": "https://api.github.com/users/Diggsey/followers", "following_url": "https://api.github.com/users/Diggsey/following{/other_user}", "gists_url": "https://api.github.com/users/Diggsey/gists{/gist_id}", "starred_url": "https://api.github.com/users/Diggsey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Diggsey/subscriptions", "organizations_url": "https://api.github.com/users/Diggsey/orgs", "repos_url": "https://api.github.com/users/Diggsey/repos", "events_url": "https://api.github.com/users/Diggsey/events{/privacy}", "received_events_url": "https://api.github.com/users/Diggsey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Diggsey", "id": 451321, "node_id": "MDQ6VXNlcjQ1MTMyMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/451321?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Diggsey", "html_url": "https://github.com/Diggsey", "followers_url": "https://api.github.com/users/Diggsey/followers", "following_url": "https://api.github.com/users/Diggsey/following{/other_user}", "gists_url": "https://api.github.com/users/Diggsey/gists{/gist_id}", "starred_url": "https://api.github.com/users/Diggsey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Diggsey/subscriptions", "organizations_url": "https://api.github.com/users/Diggsey/orgs", "repos_url": "https://api.github.com/users/Diggsey/repos", "events_url": "https://api.github.com/users/Diggsey/events{/privacy}", "received_events_url": "https://api.github.com/users/Diggsey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46ec74e60f238f694b46c976d6217e7cf8d4cf1a", "url": "https://api.github.com/repos/rust-lang/rust/commits/46ec74e60f238f694b46c976d6217e7cf8d4cf1a", "html_url": "https://github.com/rust-lang/rust/commit/46ec74e60f238f694b46c976d6217e7cf8d4cf1a"}], "stats": {"total": 47, "additions": 36, "deletions": 11}, "files": [{"sha": "17863dd38afeeceb086d859d3a7896c829d62b17", "filename": "src/libcore/mem/manually_drop.rs", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7433c4ddf3c226fc6beeed7a79f7d48777a3e807/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7433c4ddf3c226fc6beeed7a79f7d48777a3e807/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmanually_drop.rs?ref=7433c4ddf3c226fc6beeed7a79f7d48777a3e807", "patch": "@@ -7,14 +7,14 @@ use crate::ptr;\n ///\n /// `ManuallyDrop<T>` is subject to the same layout optimizations as `T`.\n /// As a consequence, it has *no effect* on the assumptions that the compiler makes\n-/// about all values being initialized at their type.  In particular, initializing\n-/// a `ManuallyDrop<&mut T>` with [`mem::zeroed`] is undefined behavior.\n+/// about its contents. For example, initializing a `ManuallyDrop<&mut T>`\n+/// with [`mem::zeroed`] is undefined behavior.\n /// If you need to handle uninitialized data, use [`MaybeUninit<T>`] instead.\n ///\n /// # Examples\n ///\n-/// This wrapper helps with explicitly documenting the drop order dependencies between fields of\n-/// the type:\n+/// This wrapper can be used to enforce a particular drop order on fields, regardless\n+/// of how they are defined in the struct:\n ///\n /// ```rust\n /// use std::mem::ManuallyDrop;\n@@ -43,8 +43,18 @@ use crate::ptr;\n /// }\n /// ```\n ///\n+/// However, care should be taken when using this pattern as it can lead to *leak amplification*.\n+/// In this example, if the `Drop` implementation for `Peach` were to panic, the `banana` field\n+/// would also be leaked.\n+///\n+/// In contrast, the automatically-generated compiler drop implementation would have ensured\n+/// that all fields are dropped even in the presence of panics. This is especially important when\n+/// working with [pinned] data, where reusing the memory without calling the destructor could lead\n+/// to Undefined Behaviour.\n+///\n /// [`mem::zeroed`]: fn.zeroed.html\n /// [`MaybeUninit<T>`]: union.MaybeUninit.html\n+/// [pinned]: ../pin/index.html\n #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n #[lang = \"manually_drop\"]\n #[derive(Copy, Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -113,19 +123,28 @@ impl<T> ManuallyDrop<T> {\n }\n \n impl<T: ?Sized> ManuallyDrop<T> {\n-    /// Manually drops the contained value.\n+    /// Manually drops the contained value. This is exactly equivalent to calling\n+    /// [`ptr::drop_in_place`] with a pointer to the contained value. As such, unless\n+    /// the contained value is a packed struct, the destructor will be called in-place\n+    /// without moving the value, and thus can be used to safely drop [pinned] data.\n     ///\n     /// If you have ownership of the value, you can use [`ManuallyDrop::into_inner`] instead.\n     ///\n     /// # Safety\n     ///\n-    /// This function runs the destructor of the contained value and thus the wrapped value\n-    /// now represents uninitialized data. It is up to the user of this method to ensure the\n-    /// uninitialized data is not actually used.\n-    /// In particular, this function can only be called at most once\n-    /// for a given instance of `ManuallyDrop<T>`.\n+    /// This function runs the destructor of the contained value. Other than changes made by\n+    /// the destructor itself, the memory is left unchanged, and so as far as the compiler is\n+    /// concerned still holds a bit-pattern which is valid for the type `T`.\n+    ///\n+    /// However, this \"zombie\" value should not be exposed to safe code, and this function\n+    /// should not be called more than once. To use a value after it's been dropped, or drop\n+    /// a value multiple times, can cause Undefined Behavior (depending on what `drop` does).\n+    /// This is normally prevented by the type system, but users of `ManuallyDrop` must\n+    /// uphold those guarantees without assistance from the compiler.\n     ///\n     /// [`ManuallyDrop::into_inner`]: #method.into_inner\n+    /// [`ptr::drop_in_place`]: ../ptr/fn.drop_in_place.html\n+    /// [pinned]: ../pin/index.html\n     #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n     #[inline]\n     pub unsafe fn drop(slot: &mut ManuallyDrop<T>) {"}, {"sha": "115194a65a0c2026d751af5736bcfa79671bdc91", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7433c4ddf3c226fc6beeed7a79f7d48777a3e807/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7433c4ddf3c226fc6beeed7a79f7d48777a3e807/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=7433c4ddf3c226fc6beeed7a79f7d48777a3e807", "patch": "@@ -112,11 +112,17 @@ mod mut_ptr;\n ///   as the compiler doesn't need to prove that it's sound to elide the\n ///   copy.\n ///\n+/// * It can be used to drop [pinned] data when `T` is not `repr(packed)`\n+///   (pinned data must not be moved before it is dropped).\n+///\n /// Unaligned values cannot be dropped in place, they must be copied to an aligned\n-/// location first using [`ptr::read_unaligned`].\n+/// location first using [`ptr::read_unaligned`]. For packed structs, this move is\n+/// done automatically by the compiler. This means the fields of packed structs\n+/// are not dropped in-place.\n ///\n /// [`ptr::read`]: ../ptr/fn.read.html\n /// [`ptr::read_unaligned`]: ../ptr/fn.read_unaligned.html\n+/// [pinned]: ../pin/index.html\n ///\n /// # Safety\n ///"}]}