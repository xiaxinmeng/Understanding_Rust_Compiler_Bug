{"sha": "7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlNzc3NWNlN2JmYzkxNmNlNzIzYmQxZmRhZjRhZTU0NjYyYzY2Mjc=", "commit": {"author": {"name": "Jeremy Soller", "email": "jackpot51@gmail.com", "date": "2016-12-12T21:55:09Z"}, "committer": {"name": "Jeremy Soller", "email": "jackpot51@gmail.com", "date": "2016-12-12T21:55:09Z"}, "message": "Merge branch 'master' into redox", "tree": {"sha": "235a9c38e42bacdb671da33bc49ffc8a4aba17a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/235a9c38e42bacdb671da33bc49ffc8a4aba17a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "html_url": "https://github.com/rust-lang/rust/commit/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/comments", "author": {"login": "jackpot51", "id": 7741236, "node_id": "MDQ6VXNlcjc3NDEyMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/7741236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackpot51", "html_url": "https://github.com/jackpot51", "followers_url": "https://api.github.com/users/jackpot51/followers", "following_url": "https://api.github.com/users/jackpot51/following{/other_user}", "gists_url": "https://api.github.com/users/jackpot51/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackpot51/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackpot51/subscriptions", "organizations_url": "https://api.github.com/users/jackpot51/orgs", "repos_url": "https://api.github.com/users/jackpot51/repos", "events_url": "https://api.github.com/users/jackpot51/events{/privacy}", "received_events_url": "https://api.github.com/users/jackpot51/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackpot51", "id": 7741236, "node_id": "MDQ6VXNlcjc3NDEyMzY=", "avatar_url": "https://avatars.githubusercontent.com/u/7741236?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackpot51", "html_url": "https://github.com/jackpot51", "followers_url": "https://api.github.com/users/jackpot51/followers", "following_url": "https://api.github.com/users/jackpot51/following{/other_user}", "gists_url": "https://api.github.com/users/jackpot51/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackpot51/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackpot51/subscriptions", "organizations_url": "https://api.github.com/users/jackpot51/orgs", "repos_url": "https://api.github.com/users/jackpot51/repos", "events_url": "https://api.github.com/users/jackpot51/events{/privacy}", "received_events_url": "https://api.github.com/users/jackpot51/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c61baa0fc7a85bd2bcce34aac05ed739261cf037", "url": "https://api.github.com/repos/rust-lang/rust/commits/c61baa0fc7a85bd2bcce34aac05ed739261cf037", "html_url": "https://github.com/rust-lang/rust/commit/c61baa0fc7a85bd2bcce34aac05ed739261cf037"}, {"sha": "6483bdd860fd89fc68846d4cc94c7ae3307a84c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/6483bdd860fd89fc68846d4cc94c7ae3307a84c1", "html_url": "https://github.com/rust-lang/rust/commit/6483bdd860fd89fc68846d4cc94c7ae3307a84c1"}], "stats": {"total": 32097, "additions": 20729, "deletions": 11368}, "files": [{"sha": "996e5ec07b5453d3eec7d76f9567dd49070792ad", "filename": ".travis.yml", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -1,4 +1,4 @@\n-language: rust\n+language: minimal\n sudo: required\n dist: trusty\n services:\n@@ -20,7 +20,7 @@ matrix:\n     - env: IMAGE=x86_64-gnu-cargotest\n     - env: IMAGE=x86_64-gnu-debug\n     - env: IMAGE=x86_64-gnu-nopt\n-    - env: IMAGE=x86_64-gnu-rustbuild\n+    - env: IMAGE=x86_64-gnu-make\n     - env: IMAGE=x86_64-gnu-llvm-3.7 ALLOW_PR=1 RUST_BACKTRACE=1\n     - env: IMAGE=x86_64-musl\n \n@@ -39,7 +39,7 @@ matrix:\n       install: brew install ccache\n     - env: >\n         RUST_CHECK_TARGET=check\n-        RUST_CONFIGURE_ARGS=--target=x86_64-apple-darwin --enable-rustbuild\n+        RUST_CONFIGURE_ARGS=--target=x86_64-apple-darwin --disable-rustbuild\n         SRC=.\n       os: osx\n       install: brew install ccache\n@@ -51,17 +51,16 @@ matrix:\n       install: brew install ccache\n \n script:\n-  - if [ -z \"$ALLOW_PR\" ] && [ \"$TRAVIS_BRANCH\" != \"auto\" ]; then\n-        echo skipping, not a full build;\n-    elif [ -z \"$ENABLE_AUTO\" ] then\n-        echo skipping, not quite ready yet\n-    elif [ \"$TRAVIS_OS_NAME\" = \"osx\" ]; then\n-        git submodule update --init;\n-        src/ci/run.sh;\n-    else\n-        git submodule update --init;\n-        src/ci/docker/run.sh $IMAGE;\n-    fi\n+  - >\n+      if [ \"$ALLOW_PR\" = \"\" ] && [ \"$TRAVIS_BRANCH\" != \"auto\" ]; then\n+          echo skipping, not a full build;\n+      elif [ \"$TRAVIS_OS_NAME\" = \"osx\" ]; then\n+          git submodule update --init;\n+          src/ci/run.sh;\n+      else\n+          git submodule update --init;\n+          src/ci/docker/run.sh $IMAGE;\n+      fi\n \n # Save tagged docker images we created and load them if they're available\n before_cache:"}, {"sha": "20a0bd2e256d921352de2d102bb041dfc5fe4907", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 111, "deletions": 40, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -86,13 +86,17 @@ benchmarks, generate documentation, install a fresh build of Rust, and more.\n It's your best friend when working on Rust, allowing you to compile & test\n your contributions before submission.\n \n-All the configuration for the build system lives in [the `mk` directory][mkdir]\n-in the project root. It can be hard to follow in places, as it uses some\n-advanced Make features which make for some challenging reading. If you have\n-questions on the build system internals, try asking in\n-[`#rust-internals`][pound-rust-internals].\n+The build system lives in [the `src/bootstrap` directory][bootstrap] in the\n+project root. Our build system is itself written in Rust and is based on Cargo\n+to actually build all the compiler's crates. If you have questions on the build\n+system internals, try asking in [`#rust-internals`][pound-rust-internals].\n \n-[mkdir]: https://github.com/rust-lang/rust/tree/master/mk/\n+[bootstrap]: https://github.com/rust-lang/rust/tree/master/src/bootstrap/\n+\n+> **Note**: the build system was recently rewritten from a jungle of makefiles\n+> to the current incarnation you'll see in `src/bootstrap`. If you experience\n+> bugs you can temporarily revert back to the makefiles with\n+> `--disable-rustbuild` passed to `./configure`.\n \n ### Configuration\n \n@@ -119,42 +123,111 @@ configuration used later in the build process. Some options to note:\n \n To see a full list of options, run `./configure --help`.\n \n-### Useful Targets\n-\n-Some common make targets are:\n-\n-- `make tips` - show useful targets, variables and other tips for working with\n-   the build system.\n-- `make rustc-stage1` - build up to (and including) the first stage. For most\n-  cases we don't need to build the stage2 compiler, so we can save time by not\n-  building it. The stage1 compiler is a fully functioning compiler and\n-  (probably) will be enough to determine if your change works as expected.\n-- `make $host/stage1/bin/rustc` - Where $host is a target triple like x86_64-unknown-linux-gnu.\n-  This will build just rustc, without libstd. This is the fastest way to recompile after\n-  you changed only rustc source code. Note however that the resulting rustc binary\n-  won't have a stdlib to link against by default. You can build libstd once with\n-  `make rustc-stage1`, rustc will pick it up afterwards. libstd is only guaranteed to\n-  work if recompiled, so if there are any issues recompile it.\n-- `make check` - build the full compiler & run all tests (takes a while). This\n+### Building\n+\n+Although the `./configure` script will generate a `Makefile`, this is actually\n+just a thin veneer over the actual build system driver, `x.py`. This file, at\n+the root of the repository, is used to build, test, and document various parts\n+of the compiler. You can execute it as:\n+\n+```sh\n+python x.py build\n+```\n+\n+On some systems you can also use the shorter version:\n+\n+```sh\n+./x.py build\n+```\n+\n+To learn more about the driver and top-level targets, you can execute:\n+\n+```sh\n+python x.py --help\n+```\n+\n+The general format for the driver script is:\n+\n+```sh\n+python x.py <command> [<directory>]\n+```\n+\n+Some example commands are `build`, `test`, and `doc`. These will build, test,\n+and document the specified directory. The second argument, `<directory>`, is\n+optional and defaults to working over the entire compiler. If specified,\n+however, only that specific directory will be built. For example:\n+\n+```sh\n+# build the entire compiler\n+python x.py build\n+\n+# build all documentation\n+python x.py doc\n+\n+# run all test suites\n+python x.py test\n+\n+# build only the standard library\n+python x.py build src/libstd\n+\n+# test only one particular test suite\n+python x.py test src/test/rustdoc\n+\n+# build only the stage0 libcore library\n+python x.py build src/libcore --stage 0\n+```\n+\n+You can explore the build system throught the various `--help` pages for each\n+subcommand. For example to learn more about a command you can run:\n+\n+```\n+python x.py build --help\n+```\n+\n+To learn about all possible rules you can execute, run:\n+\n+```\n+python x.py build --help --verbose\n+```\n+\n+### Useful commands\n+\n+Some common invocations of `x.py` are:\n+\n+- `x.py build --help` - show the help message and explain the subcommand\n+- `x.py build src/libtest --stage 1` - build up to (and including) the first\n+  stage. For most cases we don't need to build the stage2 compiler, so we can\n+  save time by not building it. The stage1 compiler is a fully functioning\n+  compiler and (probably) will be enough to determine if your change works as\n+  expected.\n+- `x.py build src/rustc --stage 1` - This will build just rustc, without libstd.\n+  This is the fastest way to recompile after you changed only rustc source code.\n+  Note however that the resulting rustc binary won't have a stdlib to link\n+  against by default. You can build libstd once with `x.py build src/libstd`,\n+  but it is is only guaranteed to work if recompiled, so if there are any issues\n+  recompile it.\n+- `x.py test` - build the full compiler & run all tests (takes a while). This\n   is what gets run by the continuous integration system against your pull\n   request. You should run this before submitting to make sure your tests pass\n   & everything builds in the correct manner.\n-- `make check-stage1-std NO_REBUILD=1` - test the standard library without\n-  rebuilding the entire compiler\n-- `make check TESTNAME=<substring-of-test-name>` - Run a matching set of tests.\n+- `x.py test src/libstd --stage 1` - test the standard library without\n+  recompiling stage 2.\n+- `x.py test src/test/run-pass --filter TESTNAME` - Run a matching set of tests.\n   - `TESTNAME` should be a substring of the tests to match against e.g. it could\n     be the fully qualified test name, or just a part of it.\n     `TESTNAME=collections::hash::map::test_map::test_capacity_not_less_than_len`\n     or `TESTNAME=test_capacity_not_less_than_len`.\n-- `make check-stage1-rpass TESTNAME=<substring-of-test-name>` - Run a single\n-  rpass test with the stage1 compiler (this will be quicker than running the\n-  command above as we only build the stage1 compiler, not the entire thing).\n-  You can also leave off the `-rpass` to run all stage1 test types.\n-- `make check-stage1-coretest` - Run stage1 tests in `libcore`.\n-- `make tidy` - Check that the source code is in compliance with Rust's style\n-  guidelines. There is no official document describing Rust's full guidelines \n-  as of yet, but basic rules like 4 spaces for indentation and no more than 99\n-  characters in a single line should be kept in mind when writing code.\n+- `x.py test src/test/run-pass --stage 1 --filter <substring-of-test-name>` -\n+  Run a single rpass test with the stage1 compiler (this will be quicker than\n+  running the command above as we only build the stage1 compiler, not the entire\n+  thing).  You can also leave off the directory argument to run all stage1 test\n+  types.\n+- `x.py test src/libcore --stage 1` - Run stage1 tests in `libcore`.\n+- `x.py test src/tools/tidy` - Check that the source code is in compliance with\n+  Rust's style guidelines. There is no official document describing Rust's full\n+  guidelines as of yet, but basic rules like 4 spaces for indentation and no\n+  more than 99 characters in a single line should be kept in mind when writing\n+  code.\n \n ## Pull Requests\n \n@@ -172,19 +245,17 @@ amount of time you have to wait. You need to have built the compiler at least\n once before running these will work, but that\u2019s only one full build rather than\n one each time.\n \n-    $ make -j8 rustc-stage1 && make check-stage1\n+    $ python x.py test --stage 1\n \n is one such example, which builds just `rustc`, and then runs the tests. If\n you\u2019re adding something to the standard library, try\n \n-    $ make -j8 check-stage1-std NO_REBUILD=1\n-\n-This will not rebuild the compiler, but will run the tests.\n+    $ python x.py test src/libstd --stage 1\n \n Please make sure your pull request is in compliance with Rust's style\n guidelines by running\n \n-    $ make tidy\n+    $ python x.py test src/tools/tidy\n \n Make this check before every pull request (and every new commit in a pull\n request) ; you can add [git hooks](https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks)"}, {"sha": "2133b17de0fbbe214a26807b540b9804520afb56", "filename": "README.md", "status": "modified", "additions": 13, "deletions": 33, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -36,16 +36,14 @@ Read [\"Installing Rust\"] from [The Book].\n \n     ```sh\n     $ ./configure\n-    $ make && make install\n+    $ make && sudo make install\n     ```\n \n-    > ***Note:*** You may need to use `sudo make install` if you do not\n-    > normally have permission to modify the destination directory. The\n-    > install locations can be adjusted by passing a `--prefix` argument\n-    > to `configure`. Various other options are also supported \u2013 pass\n+    > ***Note:*** Install locations can be adjusted by passing a `--prefix`\n+    > argument to `configure`. Various other options are also supported \u2013 pass\n     > `--help` for more information on them.\n \n-    When complete, `make install` will place several programs into\n+    When complete, `sudo make install` will place several programs into\n     `/usr/local/bin`: `rustc`, the Rust compiler, and `rustdoc`, the\n     API-documentation tool. This install does not include [Cargo],\n     Rust's package manager, which you may also want to build.\n@@ -108,30 +106,22 @@ MSVC builds of Rust additionally require an installation of Visual Studio 2013\n (or later) so `rustc` can use its linker. Make sure to check the \u201cC++ tools\u201d\n option.\n \n-With these dependencies installed, the build takes two steps:\n+With these dependencies installed, you can build the compiler in a `cmd.exe`\n+shell with:\n \n ```sh\n-$ ./configure\n-$ make && make install\n+> python x.py build\n ```\n \n-#### MSVC with rustbuild\n-\n-The old build system, based on makefiles, is currently being rewritten into a\n-Rust-based build system called rustbuild. This can be used to bootstrap the\n-compiler on MSVC without needing to install MSYS or MinGW. All you need are\n-[Python 2](https://www.python.org/downloads/),\n-[CMake](https://cmake.org/download/), and\n-[Git](https://git-scm.com/downloads) in your PATH (make sure you do not use the\n-ones from MSYS if you have it installed). You'll also need Visual Studio 2013 or\n-newer with the C++ tools. Then all you need to do is to kick off rustbuild.\n+If you're running inside of an msys shell, however, you can run:\n \n-```\n-python x.py build\n+```sh\n+$ ./configure --build=x86_64-pc-windows-msvc\n+$ make && make install\n ```\n \n-Currently rustbuild only works with some known versions of Visual Studio. If you\n-have a more recent version installed that a part of rustbuild doesn't understand\n+Currently building Rust only works with some known versions of Visual Studio. If\n+you have a more recent version installed the build system doesn't understand\n then you may need to force rustbuild to use an older version. This can be done\n by manually calling the appropriate vcvars file before running the bootstrap.\n \n@@ -149,16 +139,6 @@ $ ./configure\n $ make docs\n ```\n \n-Building the documentation requires building the compiler, so the above\n-details will apply. Once you have the compiler built, you can\n-\n-```sh\n-$ make docs NO_REBUILD=1\n-```\n-\n-To make sure you don\u2019t re-build the compiler because you made a change\n-to some documentation.\n-\n The generated documentation will appear in a top-level `doc` directory,\n created by the `make` rule.\n "}, {"sha": "bf75439b74a47d31438043106387235b2ce429b7", "filename": "appveyor.yml", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -2,25 +2,22 @@ environment:\n   matrix:\n   # 32/64 bit MSVC\n   - MSYS_BITS: 64\n-    TARGET: x86_64-pc-windows-msvc\n-    CHECK: check\n-    CONFIGURE_ARGS: --enable-llvm-assertions --enable-debug-assertions\n+    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n+    RUST_CHECK_TARGET: check\n   - MSYS_BITS: 32\n-    TARGET: i686-pc-windows-msvc\n-    CHECK: check\n-    CONFIGURE_ARGS: --enable-llvm-assertions --enable-debug-assertions\n+    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n+    RUST_CHECK_TARGET: check\n \n-  # MSVC rustbuild\n+  # MSVC makefiles\n   - MSYS_BITS: 64\n-    CONFIGURE_ARGS: --enable-rustbuild --enable-llvm-assertions --enable-debug-assertions\n-    TARGET: x86_64-pc-windows-msvc\n-    CHECK: check\n+    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --disable-rustbuild\n+    RUST_CHECK_TARGET: check\n \n   # MSVC cargotest\n   - MSYS_BITS: 64\n-    CONFIGURE_ARGS: --enable-rustbuild --enable-llvm-assertions --enable-debug-assertions\n-    TARGET: x86_64-pc-windows-msvc\n-    CHECK: check-cargotest\n+    NO_VENDOR: 1\n+    RUST_CHECK_TARGET: check-cargotest\n+    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n \n   # 32/64-bit MinGW builds.\n   #\n@@ -47,24 +44,22 @@ environment:\n   # *not* use debug assertions and llvm assertions. This is because they take\n   # too long on appveyor and this is tested by rustbuild below.\n   - MSYS_BITS: 32\n-    TARGET: i686-pc-windows-gnu\n-    CHECK: check\n+    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n+    RUST_CHECK_TARGET: check\n     MINGW_URL: https://s3.amazonaws.com/rust-lang-ci\n     MINGW_ARCHIVE: i686-4.9.2-release-win32-dwarf-rt_v4-rev4.7z\n     MINGW_DIR: mingw32\n \n   - MSYS_BITS: 32\n-    CONFIGURE_ARGS: --enable-rustbuild --enable-llvm-assertions --enable-debug-assertions\n-    TARGET: i686-pc-windows-gnu\n-    CHECK: check\n+    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu --disable-rustbuild\n+    RUST_CHECK_TARGET: check\n     MINGW_URL: https://s3.amazonaws.com/rust-lang-ci\n     MINGW_ARCHIVE: i686-4.9.2-release-win32-dwarf-rt_v4-rev4.7z\n     MINGW_DIR: mingw32\n \n   - MSYS_BITS: 64\n-    CONFIGURE_ARGS: --enable-llvm-assertions --enable-debug-assertions\n-    TARGET: x86_64-pc-windows-gnu\n-    CHECK: check\n+    RUST_CHECK_TARGET: check\n+    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu\n     MINGW_URL: https://s3.amazonaws.com/rust-lang-ci\n     MINGW_ARCHIVE: x86_64-4.9.2-release-win32-seh-rt_v4-rev4.7z\n     MINGW_DIR: mingw64\n@@ -90,15 +85,20 @@ install:\n   - if NOT defined MINGW_URL set PATH=C:\\msys64\\mingw%MSYS_BITS%\\bin;C:\\msys64\\usr\\bin;%PATH%\n \n test_script:\n-  - sh ./configure\n-          %CONFIGURE_ARGS%\n-          --build=%TARGET%\n-  - bash -c \"make -j$(nproc)\"\n-  - bash -c \"make %CHECK% -j$(nproc)\"\n+  - git submodule update --init\n+  - set SRC=.\n+  - set NO_CCACHE=1\n+  - sh src/ci/run.sh\n \n cache:\n-  - build/%TARGET%/llvm -> src/rustllvm/llvm-auto-clean-trigger\n-  - \"%TARGET%/llvm -> src/rustllvm/llvm-auto-clean-trigger\"\n+  - \"build/i686-pc-windows-gnu/llvm -> src/rustllvm/llvm-auto-clean-trigger\"\n+  - \"build/x86_64-pc-windows-gnu/llvm -> src/rustllvm/llvm-auto-clean-trigger\"\n+  - \"build/i686-pc-windows-msvc/llvm -> src/rustllvm/llvm-auto-clean-trigger\"\n+  - \"build/x86_64-pc-windows-msvc/llvm -> src/rustllvm/llvm-auto-clean-trigger\"\n+  - \"i686-pc-windows-gnu/llvm -> src/rustllvm/llvm-auto-clean-trigger\"\n+  - \"x86_64-pc-windows-gnu/llvm -> src/rustllvm/llvm-auto-clean-trigger\"\n+  - \"i686-pc-windows-msvc/llvm -> src/rustllvm/llvm-auto-clean-trigger\"\n+  - \"x86_64-pc-windows-msvc/llvm -> src/rustllvm/llvm-auto-clean-trigger\"\n \n branches:\n   only:"}, {"sha": "0a07e41fb974ffe3e9900670a8b3bd1b1d4dff8b", "filename": "configure", "status": "modified", "additions": 39, "deletions": 13, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/configure", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -631,7 +631,7 @@ opt stage0-landing-pads 1 \"enable landing pads during bootstrap with stage0\"\n opt dist-host-only 0 \"only install bins for the host architecture\"\n opt inject-std-version 1 \"inject the current compiler version of libstd into programs\"\n opt llvm-version-check 1 \"check if the LLVM version is supported, build anyway\"\n-opt rustbuild 0 \"use the rust and cargo based build system\"\n+opt rustbuild 1 \"use the rust and cargo based build system\"\n opt codegen-tests 1 \"run the src/test/codegen tests\"\n opt option-checking 1 \"complain about unrecognized options in this configure script\"\n opt ninja 0 \"build LLVM using the Ninja generator (for MSVC, requires building in the correct environment)\"\n@@ -664,11 +664,11 @@ valopt armv7-linux-androideabi-ndk \"\" \"armv7-linux-androideabi NDK standalone pa\n valopt aarch64-linux-android-ndk \"\" \"aarch64-linux-android NDK standalone path\"\n valopt nacl-cross-path  \"\" \"NaCl SDK path (Pepper Canary is recommended). Must be absolute!\"\n valopt musl-root \"/usr/local\" \"MUSL root installation directory (deprecated)\"\n-valopt musl-root-x86_64 \"/usr/local\" \"x86_64-unknown-linux-musl install directory\"\n-valopt musl-root-i686 \"/usr/local\" \"i686-unknown-linux-musl install directory\"\n-valopt musl-root-arm \"/usr/local\" \"arm-unknown-linux-musleabi install directory\"\n-valopt musl-root-armhf \"/usr/local\" \"arm-unknown-linux-musleabihf install directory\"\n-valopt musl-root-armv7 \"/usr/local\" \"armv7-unknown-linux-musleabihf install directory\"\n+valopt musl-root-x86_64 \"\" \"x86_64-unknown-linux-musl install directory\"\n+valopt musl-root-i686 \"\" \"i686-unknown-linux-musl install directory\"\n+valopt musl-root-arm \"\" \"arm-unknown-linux-musleabi install directory\"\n+valopt musl-root-armhf \"\" \"arm-unknown-linux-musleabihf install directory\"\n+valopt musl-root-armv7 \"\" \"armv7-unknown-linux-musleabihf install directory\"\n valopt extra-filename \"\" \"Additional data that is hashed and passed to the -C extra-filename flag\"\n \n if [ -e ${CFG_SRC_DIR}.git ]\n@@ -848,7 +848,10 @@ then\n fi\n \n # For building LLVM\n-probe_need CFG_CMAKE cmake\n+if [ -z \"$CFG_LLVM_ROOT\" ]\n+then\n+  probe_need CFG_CMAKE cmake\n+fi\n \n # On MacOS X, invoking `javac` pops up a dialog if the JDK is not\n # installed. Since `javac` is only used if `antlr4` is available,\n@@ -1371,7 +1374,7 @@ then\n     fi\n fi\n \n-if [ -z \"$CFG_ENABLE_RUSTBUILD\" ]; then\n+if [ -n \"$CFG_DISABLE_RUSTBUILD\" ]; then\n \n   step_msg \"making directories\"\n \n@@ -1471,7 +1474,7 @@ fi\n step_msg \"configuring submodules\"\n \n # Have to be in the top of src directory for this\n-if [ -z $CFG_DISABLE_MANAGE_SUBMODULES ] && [ -z $CFG_ENABLE_RUSTBUILD ]\n+if [ -z \"$CFG_DISABLE_MANAGE_SUBMODULES\" ] && [ -n \"$CFG_DISABLE_RUSTBUILD\" ]\n then\n     cd ${CFG_SRC_DIR}\n \n@@ -1543,11 +1546,11 @@ do\n         ;;\n     esac\n \n-    if [ -n \"$CFG_ENABLE_RUSTBUILD\" ]\n+    if [ -z \"$CFG_DISABLE_RUSTBUILD\" ]\n     then\n         msg \"not configuring LLVM, rustbuild in use\"\n         do_reconfigure=0\n-    elif [ -z $CFG_LLVM_ROOT ]\n+    elif [ -z \"$CFG_LLVM_ROOT\" ]\n     then\n         LLVM_BUILD_DIR=${CFG_BUILD_DIR}$t/llvm\n         LLVM_INST_DIR=$LLVM_BUILD_DIR\n@@ -1868,7 +1871,7 @@ do\n     putvar $CFG_LLVM_INST_DIR\n done\n \n-if [ -n \"$CFG_ENABLE_RUSTBUILD\" ]\n+if [ -z \"$CFG_DISABLE_RUSTBUILD\" ]\n then\n     INPUT_MAKEFILE=src/bootstrap/mk/Makefile.in\n else\n@@ -1887,5 +1890,28 @@ else\n     step_msg \"complete\"\n fi\n \n-msg \"run \\`make help\\`\"\n+if [ \"$CFG_SRC_DIR\" = `pwd` ]; then\n+    X_PY=x.py\n+else\n+    X_PY=${CFG_SRC_DIR_RELATIVE}x.py\n+fi\n+\n+if [ -z \"$CFG_DISABLE_RUSTBUILD\" ]; then\n+    msg \"NOTE you have now configured rust to use a rewritten build system\"\n+    msg \"     called rustbuild, and as a result this may have bugs that \"\n+    msg \"     you did not see before. If you experience any issues you can\"\n+    msg \"     go back to the old build system with --disable-rustbuild and\"\n+    msg \"     please feel free to report any bugs!\"\n+    msg \"\"\n+    msg \"run \\`python ${X_PY} --help\\`\"\n+else\n+    warn \"the makefile-based build system is deprecated in favor of rustbuild\"\n+    msg \"\"\n+    msg \"It is recommended you avoid passing --disable-rustbuild to get your\"\n+    msg \"build working as the makefiles will be deleted on 2017-02-02. If you\"\n+    msg \"encounter bugs with rustbuild please file issues against rust-lang/rust\"\n+    msg \"\"\n+    msg \"run \\`make help\\`\"\n+fi\n+\n msg"}, {"sha": "b839937c9768b3c7ee151be4295ac9b4d7ca68d7", "filename": "mk/cfg/i686-unknown-openbsd.mk", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/mk%2Fcfg%2Fi686-unknown-openbsd.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/mk%2Fcfg%2Fi686-unknown-openbsd.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcfg%2Fi686-unknown-openbsd.mk?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -0,0 +1,24 @@\n+# i686-unknown-openbsd configuration\n+CC_i686-unknown-openbsd=$(CC)\n+CXX_i686-unknown-openbsd=$(CXX)\n+CPP_i686-unknown-openbsd=$(CPP)\n+AR_i686-unknown-openbsd=$(AR)\n+CFG_LIB_NAME_i686-unknown-openbsd=lib$(1).so\n+CFG_STATIC_LIB_NAME_i686-unknown-openbsd=lib$(1).a\n+CFG_LIB_GLOB_i686-unknown-openbsd=lib$(1)-*.so\n+CFG_LIB_DSYM_GLOB_i686-unknown-openbsd=$(1)-*.dylib.dSYM\n+CFG_JEMALLOC_CFLAGS_i686-unknown-openbsd := -m32 -I/usr/include $(CFLAGS)\n+CFG_GCCISH_CFLAGS_i686-unknown-openbsd :=  -g -fPIC -m32 -I/usr/include $(CFLAGS)\n+CFG_GCCISH_LINK_FLAGS_i686-unknown-openbsd := -shared -fPIC -g -pthread -m32\n+CFG_GCCISH_DEF_FLAG_i686-unknown-openbsd := -Wl,--export-dynamic,--dynamic-list=\n+CFG_LLC_FLAGS_i686-unknown-openbsd :=\n+CFG_INSTALL_NAME_i686-unknown-openbsd =\n+CFG_EXE_SUFFIX_i686-unknown-openbsd :=\n+CFG_WINDOWSY_i686-unknown-openbsd :=\n+CFG_UNIXY_i686-unknown-openbsd := 1\n+CFG_LDPATH_i686-unknown-openbsd :=\n+CFG_RUN_i686-unknown-openbsd=$(2)\n+CFG_RUN_TARG_i686-unknown-openbsd=$(call CFG_RUN_i686-unknown-openbsd,,$(2))\n+CFG_GNU_TRIPLE_i686-unknown-openbsd := i686-unknown-openbsd\n+RUSTC_FLAGS_i686-unknown-openbsd=-C linker=$(call FIND_COMPILER,$(CC))\n+CFG_DISABLE_JEMALLOC_i686-unknown-openbsd := 1"}, {"sha": "79df941aeb3eec482b1f166bec2e8d2379cb6c29", "filename": "mk/crates.mk", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -52,7 +52,7 @@\n TARGET_CRATES := libc std term \\\n                  getopts collections test rand \\\n                  compiler_builtins core alloc \\\n-                 rustc_unicode rustc_bitflags \\\n+                 std_unicode rustc_bitflags \\\n \t\t alloc_system alloc_jemalloc \\\n \t\t panic_abort panic_unwind unwind\n RUSTC_CRATES := rustc rustc_typeck rustc_mir rustc_borrowck rustc_resolve rustc_driver \\\n@@ -65,27 +65,23 @@ HOST_CRATES := syntax syntax_ext proc_macro_tokens proc_macro_plugin syntax_pos\n TOOLS := compiletest rustdoc rustc rustbook error_index_generator\n \n DEPS_core :=\n-DEPS_compiler_builtins := core\n+DEPS_compiler_builtins := core native:compiler-rt\n DEPS_alloc := core libc alloc_system\n DEPS_alloc_system := core libc\n DEPS_alloc_jemalloc := core libc native:jemalloc\n-DEPS_collections := core alloc rustc_unicode\n+DEPS_collections := core alloc std_unicode\n DEPS_libc := core\n DEPS_rand := core\n DEPS_rustc_bitflags := core\n-DEPS_rustc_unicode := core\n+DEPS_std_unicode := core\n DEPS_panic_abort := libc alloc\n DEPS_panic_unwind := libc alloc unwind\n DEPS_unwind := libc\n \n RUSTFLAGS_compiler_builtins := -lstatic=compiler-rt\n+RUSTFLAGS_panic_abort := -C panic=abort\n \n-# FIXME(stage0): change this to just `RUSTFLAGS_panic_abort := ...`\n-RUSTFLAGS1_panic_abort := -C panic=abort\n-RUSTFLAGS2_panic_abort := -C panic=abort\n-RUSTFLAGS3_panic_abort := -C panic=abort\n-\n-DEPS_std := core libc rand alloc collections compiler_builtins rustc_unicode \\\n+DEPS_std := core libc rand alloc collections compiler_builtins std_unicode \\\n \tnative:backtrace \\\n \talloc_system panic_abort panic_unwind unwind\n DEPS_arena := std\n@@ -100,7 +96,7 @@ DEPS_serialize := std log\n DEPS_term := std\n DEPS_test := std getopts term native:rust_test_helpers\n \n-DEPS_syntax := std term serialize log arena libc rustc_bitflags rustc_unicode rustc_errors syntax_pos rustc_data_structures\n+DEPS_syntax := std term serialize log arena libc rustc_bitflags std_unicode rustc_errors syntax_pos rustc_data_structures\n DEPS_syntax_ext := syntax syntax_pos rustc_errors fmt_macros proc_macro\n DEPS_syntax_pos := serialize\n DEPS_proc_macro_tokens := syntax syntax_pos log\n@@ -140,7 +136,7 @@ DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back \\\n DEPS_rustc_incremental := rustc syntax_pos serialize rustc_data_structures\n DEPS_rustc_save_analysis := rustc log syntax syntax_pos serialize\n DEPS_rustc_typeck := rustc syntax syntax_pos rustc_platform_intrinsics rustc_const_math \\\n-                     rustc_const_eval rustc_errors\n+                     rustc_const_eval rustc_errors rustc_data_structures\n \n DEPS_rustdoc := rustc rustc_driver native:hoedown serialize getopts test \\\n                 rustc_lint rustc_const_eval syntax_pos rustc_data_structures\n@@ -162,7 +158,7 @@ ONLY_RLIB_libc := 1\n ONLY_RLIB_alloc := 1\n ONLY_RLIB_rand := 1\n ONLY_RLIB_collections := 1\n-ONLY_RLIB_rustc_unicode := 1\n+ONLY_RLIB_std_unicode := 1\n ONLY_RLIB_rustc_bitflags := 1\n ONLY_RLIB_alloc_system := 1\n ONLY_RLIB_alloc_jemalloc := 1\n@@ -173,7 +169,7 @@ ONLY_RLIB_unwind := 1\n TARGET_SPECIFIC_alloc_jemalloc := 1\n \n # Documented-by-default crates\n-DOC_CRATES := std alloc collections core libc rustc_unicode\n+DOC_CRATES := std alloc collections core libc std_unicode\n \n ifeq ($(CFG_DISABLE_JEMALLOC),)\n RUSTFLAGS_rustc_back := --cfg 'feature=\"jemalloc\"'"}, {"sha": "49fdfc4118df5cb3b263d16c6bcdf437c9d3c911", "filename": "mk/main.mk", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -372,15 +372,12 @@ CFG_INFO := $(info cfg: disabling unstable features (CFG_DISABLE_UNSTABLE_FEATUR\n # Turn on feature-staging\n export CFG_DISABLE_UNSTABLE_FEATURES\n # Subvert unstable feature lints to do the self-build\n-export RUSTC_BOOTSTRAP=1\n endif\n ifdef CFG_MUSL_ROOT\n export CFG_MUSL_ROOT\n endif\n \n-# FIXME: Transitionary measure to bootstrap using the old bootstrap logic.\n-# Remove this once the bootstrap compiler uses the new login in Issue #36548.\n-export RUSTC_BOOTSTRAP_KEY=62b3e239\n+export RUSTC_BOOTSTRAP := 1\n \n ######################################################################\n # Per-stage targets and runner\n@@ -443,10 +440,7 @@ endif\n TSREQ$(1)_T_$(2)_H_$(3) = \\\n \t$$(HSREQ$(1)_H_$(3)) \\\n \t$$(foreach obj,$$(REQUIRED_OBJECTS_$(2)),\\\n-\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(obj)) \\\n-\t$$(TLIB0_T_$(2)_H_$(3))/$$(call CFG_STATIC_LIB_NAME_$(2),compiler-rt)\n-# ^ This copies `libcompiler-rt.a` to the stage0 sysroot\n-# ^ TODO(stage0) update this to not copy `libcompiler-rt.a` to stage0\n+\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(obj))\n \n # Prerequisites for a working stageN compiler and libraries, for a specific\n # target"}, {"sha": "345fc1679b00f9b85d6b1fdd5ca6a2e47962d2c8", "filename": "mk/tests.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -15,7 +15,7 @@\n \n # The names of crates that must be tested\n \n-# libcore/librustc_unicode tests are in a separate crate\n+# libcore/libstd_unicode tests are in a separate crate\n DEPS_coretest :=\n $(eval $(call RUST_CRATE,coretest))\n "}, {"sha": "4c6aeeddd386c8d3f756059155da71445c819e24", "filename": "src/Cargo.lock", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -45,7 +45,6 @@ dependencies = [\n  \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"md5 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -73,7 +72,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"alloc 0.0.0\",\n  \"core 0.0.0\",\n- \"rustc_unicode 0.0.0\",\n+ \"std_unicode 0.0.0\",\n ]\n \n [[package]]\n@@ -172,11 +171,6 @@ name = \"log\"\n version = \"0.3.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n-[[package]]\n-name = \"md5\"\n-version = \"0.1.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [[package]]\n name = \"num_cpus\"\n version = \"0.2.13\"\n@@ -409,6 +403,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"build_helper 0.1.0\",\n  \"gcc 0.3.38 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc_bitflags 0.0.0\",\n ]\n \n [[package]]\n@@ -550,13 +545,6 @@ dependencies = [\n  \"syntax_pos 0.0.0\",\n ]\n \n-[[package]]\n-name = \"rustc_unicode\"\n-version = \"0.0.0\"\n-dependencies = [\n- \"core 0.0.0\",\n-]\n-\n [[package]]\n name = \"rustdoc\"\n version = \"0.0.0\"\n@@ -604,7 +592,7 @@ dependencies = [\n  \"panic_abort 0.0.0\",\n  \"panic_unwind 0.0.0\",\n  \"rand 0.0.0\",\n- \"rustc_unicode 0.0.0\",\n+ \"std_unicode 0.0.0\",\n  \"unwind 0.0.0\",\n ]\n \n@@ -616,6 +604,13 @@ dependencies = [\n  \"std 0.0.0\",\n ]\n \n+[[package]]\n+name = \"std_unicode\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"core 0.0.0\",\n+]\n+\n [[package]]\n name = \"syntax\"\n version = \"0.0.0\"\n@@ -686,7 +681,6 @@ dependencies = [\n \"checksum getopts 0.2.14 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d9047cfbd08a437050b363d35ef160452c5fe8ea5187ae0a624708c91581d685\"\n \"checksum libc 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\" = \"044d1360593a78f5c8e5e710beccdc24ab71d1f01bc19a29bcacdba22e8475d8\"\n \"checksum log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ab83497bf8bf4ed2a74259c1c802351fcd67a65baa86394b6ba73c36f4838054\"\n-\"checksum md5 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a5539a8dee9b4ae308c9c406a379838b435a8f2c84cf9fedc6d5a576be9888db\"\n \"checksum num_cpus 0.2.13 (registry+https://github.com/rust-lang/crates.io-index)\" = \"cee7e88156f3f9e19bdd598f8d6c9db7bf4078f99f8381f43a55b09648d1a6e3\"\n \"checksum rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\" = \"6159e4e6e559c81bd706afe9c8fd68f547d3e851ce12e76b1de7914bab61691b\"\n \"checksum toml 0.1.30 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0590d72182e50e879c4da3b11c6488dae18fccb1ae0c7a3eda18e16795844796\""}, {"sha": "8fb5c70c41bf1a3c8bc6d7db934bc1c25e9b7a4e", "filename": "src/Cargo.toml", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.toml?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -11,3 +11,20 @@ members = [\n   \"tools/rustbook\",\n   \"tools/tidy\",\n ]\n+\n+# Curiously, compiletest will segfault if compiled with opt-level=3 on 64-bit\n+# MSVC when running the compile-fail test suite when a should-fail test panics.\n+# But hey if this is removed and it gets past the bots, sounds good to me.\n+[profile.release]\n+opt-level = 2\n+[profile.bench]\n+opt-level = 2\n+\n+# These options are controlled from our rustc wrapper script, so turn them off\n+# here and have them controlled elsewhere.\n+[profile.dev]\n+debug = false\n+debug-assertions = false\n+[profile.test]\n+debug = false\n+debug-assertions = false"}, {"sha": "35f8fb43f7b562b6321bcd5e3fe1ef425b7aca89", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -29,4 +29,3 @@ getopts = \"0.2\"\n rustc-serialize = \"0.3\"\n gcc = \"0.3.38\"\n libc = \"0.2\"\n-md5 = \"0.1\""}, {"sha": "d0b501e4d89697895bbc011af8dddacd295ee329", "filename": "src/bootstrap/README.md", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FREADME.md?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -32,7 +32,7 @@ The script accepts commands, flags, and filters to determine what to do:\n   # build the whole compiler\n   ./x.py build\n \n-  # build the stage1 compier\n+  # build the stage1 compiler\n   ./x.py build --stage 1\n \n   # build stage0 libstd\n@@ -66,17 +66,6 @@ The script accepts commands, flags, and filters to determine what to do:\n * `doc` - a command for building documentation. Like above can take arguments\n   for what to document.\n \n-If you're more used to `./configure` and `make`, however, then you can also\n-configure the build system to use rustbuild instead of the old makefiles:\n-\n-```\n-./configure --enable-rustbuild\n-make\n-```\n-\n-Afterwards the `Makefile` which is generated will have a few commands like\n-`make check`, `make tidy`, etc.\n-\n ## Configuring rustbuild\n \n There are currently two primary methods for configuring the rustbuild build\n@@ -90,6 +79,13 @@ be found at `src/bootstrap/config.toml.example`, and the configuration file\n can also be passed as `--config path/to/config.toml` if the build system is\n being invoked manually (via the python script).\n \n+Finally, rustbuild makes use of the [gcc-rs crate] which has [its own\n+method][env-vars] of configuring C compilers and C flags via environment\n+variables.\n+\n+[gcc-rs crate]: https://github.com/alexcrichton/gcc-rs\n+[env-vars]: https://github.com/alexcrichton/gcc-rs#external-configuration-via-environment-variables\n+\n ## Build stages\n \n The rustbuild build system goes through a few phases to actually build the\n@@ -273,16 +269,17 @@ After that, each module in rustbuild should have enough documentation to keep\n you up and running. Some general areas that you may be interested in modifying\n are:\n \n-* Adding a new build tool? Take a look at `build/step.rs` for examples of other\n-  tools, as well as `build/mod.rs`.\n+* Adding a new build tool? Take a look at `bootstrap/step.rs` for examples of\n+  other tools.\n * Adding a new compiler crate? Look no further! Adding crates can be done by\n   adding a new directory with `Cargo.toml` followed by configuring all\n   `Cargo.toml` files accordingly.\n * Adding a new dependency from crates.io? We're still working on that, so hold\n   off on that for now.\n-* Adding a new configuration option? Take a look at `build/config.rs` or perhaps\n-  `build/flags.rs` and then modify the build elsewhere to read that option.\n-* Adding a sanity check? Take a look at `build/sanity.rs`.\n+* Adding a new configuration option? Take a look at `bootstrap/config.rs` or\n+  perhaps `bootstrap/flags.rs` and then modify the build elsewhere to read that\n+  option.\n+* Adding a sanity check? Take a look at `bootstrap/sanity.rs`.\n \n If you have any questions feel free to reach out on `#rust-internals` on IRC or\n open an issue in the bug tracker!"}, {"sha": "2f674a311fef4d09245e4be3937d2bb4c7f44e34", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -125,6 +125,11 @@ fn main() {\n             cmd.arg(\"-C\").arg(format!(\"codegen-units={}\", s));\n         }\n \n+        // Emit save-analysis info.\n+        if env::var(\"RUSTC_SAVE_ANALYSIS\") == Ok(\"api\".to_string()) {\n+            cmd.arg(\"-Zsave-analysis-api\");\n+        }\n+\n         // Dealing with rpath here is a little special, so let's go into some\n         // detail. First off, `-rpath` is a linker option on Unix platforms\n         // which adds to the runtime dynamic loader path when looking for"}, {"sha": "0dda7f12007a4b281dd963dee9cd9d17b399fca3", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 67, "deletions": 26, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -30,50 +30,60 @@ def get(url, path, verbose=False):\n         sha_path = sha_file.name\n \n     try:\n-        download(sha_path, sha_url, verbose)\n+        download(sha_path, sha_url, False, verbose)\n         if os.path.exists(path):\n             if verify(path, sha_path, False):\n-                print(\"using already-download file \" + path)\n+                if verbose:\n+                    print(\"using already-download file \" + path)\n                 return\n             else:\n-                print(\"ignoring already-download file \" + path + \" due to failed verification\")\n+                if verbose:\n+                    print(\"ignoring already-download file \" + path + \" due to failed verification\")\n                 os.unlink(path)\n-        download(temp_path, url, verbose)\n-        if not verify(temp_path, sha_path, True):\n+        download(temp_path, url, True, verbose)\n+        if not verify(temp_path, sha_path, verbose):\n             raise RuntimeError(\"failed verification\")\n-        print(\"moving {} to {}\".format(temp_path, path))\n+        if verbose:\n+            print(\"moving {} to {}\".format(temp_path, path))\n         shutil.move(temp_path, path)\n     finally:\n-        delete_if_present(sha_path)\n-        delete_if_present(temp_path)\n+        delete_if_present(sha_path, verbose)\n+        delete_if_present(temp_path, verbose)\n \n \n-def delete_if_present(path):\n+def delete_if_present(path, verbose):\n     if os.path.isfile(path):\n-        print(\"removing \" + path)\n+        if verbose:\n+            print(\"removing \" + path)\n         os.unlink(path)\n \n \n-def download(path, url, verbose):\n-    print(\"downloading {} to {}\".format(url, path))\n+def download(path, url, probably_big, verbose):\n+    if probably_big or verbose:\n+        print(\"downloading {}\".format(url))\n     # see http://serverfault.com/questions/301128/how-to-download\n     if sys.platform == 'win32':\n         run([\"PowerShell.exe\", \"/nologo\", \"-Command\",\n              \"(New-Object System.Net.WebClient)\"\n              \".DownloadFile('{}', '{}')\".format(url, path)],\n             verbose=verbose)\n     else:\n-        run([\"curl\", \"-o\", path, url], verbose=verbose)\n+        if probably_big or verbose:\n+            option = \"-#\"\n+        else:\n+            option = \"-s\"\n+        run([\"curl\", option, \"-Sf\", \"-o\", path, url], verbose=verbose)\n \n \n def verify(path, sha_path, verbose):\n-    print(\"verifying \" + path)\n+    if verbose:\n+        print(\"verifying \" + path)\n     with open(path, \"rb\") as f:\n         found = hashlib.sha256(f.read()).hexdigest()\n     with open(sha_path, \"r\") as f:\n         expected, _ = f.readline().split()\n     verified = found == expected\n-    if not verified and verbose:\n+    if not verified:\n         print(\"invalid checksum:\\n\"\n                \"    found:    {}\\n\"\n                \"    expected: {}\".format(found, expected))\n@@ -144,6 +154,7 @@ def download_stage0(self):\n \n         if self.rustc().startswith(self.bin_root()) and \\\n                 (not os.path.exists(self.rustc()) or self.rustc_out_of_date()):\n+            self.print_what_it_means_to_bootstrap()\n             if os.path.exists(self.bin_root()):\n                 shutil.rmtree(self.bin_root())\n             channel = self.stage0_rustc_channel()\n@@ -167,6 +178,7 @@ def download_stage0(self):\n \n         if self.cargo().startswith(self.bin_root()) and \\\n                 (not os.path.exists(self.cargo()) or self.cargo_out_of_date()):\n+            self.print_what_it_means_to_bootstrap()\n             channel = self.stage0_cargo_channel()\n             filename = \"cargo-{}-{}.tar.gz\".format(channel, self.build)\n             url = \"https://static.rust-lang.org/cargo-dist/\" + self.stage0_cargo_date()\n@@ -251,7 +263,27 @@ def exe_suffix(self):\n         else:\n             return ''\n \n+    def print_what_it_means_to_bootstrap(self):\n+        if hasattr(self, 'printed'):\n+            return\n+        self.printed = True\n+        if os.path.exists(self.bootstrap_binary()):\n+            return\n+        if not '--help' in sys.argv or len(sys.argv) == 1:\n+            return\n+\n+        print('info: the build system for Rust is written in Rust, so this')\n+        print('      script is now going to download a stage0 rust compiler')\n+        print('      and then compile the build system itself')\n+        print('')\n+        print('info: in the meantime you can read more about rustbuild at')\n+        print('      src/bootstrap/README.md before the download finishes')\n+\n+    def bootstrap_binary(self):\n+        return os.path.join(self.build_dir, \"bootstrap/debug/bootstrap\")\n+\n     def build_bootstrap(self):\n+        self.print_what_it_means_to_bootstrap()\n         build_dir = os.path.join(self.build_dir, \"bootstrap\")\n         if self.clean and os.path.exists(build_dir):\n             shutil.rmtree(build_dir)\n@@ -408,22 +440,31 @@ def main():\n     rb.use_vendored_sources = '\\nvendor = true' in rb.config_toml or \\\n                               'CFG_ENABLE_VENDOR' in rb.config_mk\n \n+    if 'SUDO_USER' in os.environ:\n+        if os.environ['USER'] != os.environ['SUDO_USER']:\n+            rb.use_vendored_sources = True\n+            print('info: looks like you are running this command under `sudo`')\n+            print('      and so in order to preserve your $HOME this will now')\n+            print('      use vendored sources by default. Note that if this')\n+            print('      does not work you should run a normal build first')\n+            print('      before running a command like `sudo make intall`')\n+\n     if rb.use_vendored_sources:\n         if not os.path.exists('.cargo'):\n             os.makedirs('.cargo')\n-        f = open('.cargo/config','w')\n-        f.write(\"\"\"\n-            [source.crates-io]\n-            replace-with = 'vendored-sources'\n-            registry = 'https://example.com'\n-\n-            [source.vendored-sources]\n-            directory = '{}/src/vendor'\n-        \"\"\".format(rb.rust_root))\n-        f.close()\n+        with open('.cargo/config','w') as f:\n+            f.write(\"\"\"\n+                [source.crates-io]\n+                replace-with = 'vendored-sources'\n+                registry = 'https://example.com'\n+\n+                [source.vendored-sources]\n+                directory = '{}/src/vendor'\n+            \"\"\".format(rb.rust_root))\n     else:\n         if os.path.exists('.cargo'):\n             shutil.rmtree('.cargo')\n+\n     data = stage0_data(rb.rust_root)\n     rb._rustc_channel, rb._rustc_date = data['rustc'].split('-', 1)\n     rb._cargo_channel, rb._cargo_date = data['cargo'].split('-', 1)\n@@ -438,7 +479,7 @@ def main():\n     sys.stdout.flush()\n \n     # Run the bootstrap\n-    args = [os.path.join(rb.build_dir, \"bootstrap/debug/bootstrap\")]\n+    args = [rb.bootstrap_binary()]\n     args.extend(sys.argv[1:])\n     env = os.environ.copy()\n     env[\"BUILD\"] = rb.build"}, {"sha": "aa70e24d95222ee5d608d9a887927e957ef919d9", "filename": "src/bootstrap/cc.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Fcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Fcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -51,7 +51,7 @@ pub fn find(build: &mut Build) {\n         if let Some(cc) = config.and_then(|c| c.cc.as_ref()) {\n             cfg.compiler(cc);\n         } else {\n-            set_compiler(&mut cfg, \"gcc\", target, config);\n+            set_compiler(&mut cfg, \"gcc\", target, config, build);\n         }\n \n         let compiler = cfg.get_compiler();\n@@ -72,7 +72,7 @@ pub fn find(build: &mut Build) {\n         if let Some(cxx) = config.and_then(|c| c.cxx.as_ref()) {\n             cfg.compiler(cxx);\n         } else {\n-            set_compiler(&mut cfg, \"g++\", host, config);\n+            set_compiler(&mut cfg, \"g++\", host, config, build);\n         }\n         let compiler = cfg.get_compiler();\n         build.verbose(&format!(\"CXX_{} = {:?}\", host, compiler.path()));\n@@ -83,7 +83,8 @@ pub fn find(build: &mut Build) {\n fn set_compiler(cfg: &mut gcc::Config,\n                 gnu_compiler: &str,\n                 target: &str,\n-                config: Option<&Target>) {\n+                config: Option<&Target>,\n+                build: &Build) {\n     match target {\n         // When compiling for android we may have the NDK configured in the\n         // config.toml in which case we look there. Otherwise the default\n@@ -119,6 +120,22 @@ fn set_compiler(cfg: &mut gcc::Config,\n             }\n         }\n \n+        \"mips-unknown-linux-musl\" => {\n+            cfg.compiler(\"mips-linux-musl-gcc\");\n+        }\n+        \"mipsel-unknown-linux-musl\" => {\n+            cfg.compiler(\"mipsel-linux-musl-gcc\");\n+        }\n+\n+        t if t.contains(\"musl\") => {\n+            if let Some(root) = build.musl_root(target) {\n+                let guess = root.join(\"bin/musl-gcc\");\n+                if guess.exists() {\n+                    cfg.compiler(guess);\n+                }\n+            }\n+        }\n+\n         _ => {}\n     }\n }"}, {"sha": "b2341f5978704d828d10cfa0e2e8b140b33cae07", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -20,7 +20,6 @@ use std::io::prelude::*;\n use std::process::Command;\n \n use build_helper::output;\n-use md5;\n \n use Build;\n \n@@ -91,20 +90,4 @@ pub fn collect(build: &mut Build) {\n         build.ver_hash = Some(ver_hash);\n         build.short_ver_hash = Some(short_ver_hash);\n     }\n-\n-    // Calculate this compiler's bootstrap key, which is currently defined as\n-    // the first 8 characters of the md5 of the release string.\n-    let key = md5::compute(build.release.as_bytes());\n-    build.bootstrap_key = format!(\"{:02x}{:02x}{:02x}{:02x}\",\n-                                  key[0], key[1], key[2], key[3]);\n-\n-    // Slurp up the stage0 bootstrap key as we're bootstrapping from an\n-    // otherwise stable compiler.\n-    let mut s = String::new();\n-    t!(t!(File::open(build.src.join(\"src/stage0.txt\"))).read_to_string(&mut s));\n-    if let Some(line) = s.lines().find(|l| l.starts_with(\"rustc_key\")) {\n-        if let Some(key) = line.split(\": \").nth(1) {\n-            build.bootstrap_key_stage0 = key.to_string();\n-        }\n-    }\n }"}, {"sha": "e07988602759840f816bb6aa95462f01880377e1", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 99, "deletions": 20, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -8,31 +8,63 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Implementation of the various `check-*` targets of the build system.\n+//! Implementation of the test-related targets of the build system.\n //!\n //! This file implements the various regression test suites that we execute on\n //! our CI.\n \n use std::collections::HashSet;\n use std::env;\n+use std::fmt;\n use std::fs;\n use std::path::{PathBuf, Path};\n use std::process::Command;\n \n use build_helper::output;\n \n use {Build, Compiler, Mode};\n+use dist;\n use util::{self, dylib_path, dylib_path_var};\n \n const ADB_TEST_DIR: &'static str = \"/data/tmp\";\n \n+/// The two modes of the test runner; tests or benchmarks.\n+#[derive(Copy, Clone)]\n+pub enum TestKind {\n+    /// Run `cargo test`\n+    Test,\n+    /// Run `cargo bench`\n+    Bench,\n+}\n+\n+impl TestKind {\n+    // Return the cargo subcommand for this test kind\n+    fn subcommand(self) -> &'static str {\n+        match self {\n+            TestKind::Test => \"test\",\n+            TestKind::Bench => \"bench\",\n+        }\n+    }\n+}\n+\n+impl fmt::Display for TestKind {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        f.write_str(match *self {\n+            TestKind::Test => \"Testing\",\n+            TestKind::Bench => \"Benchmarking\",\n+        })\n+    }\n+}\n+\n /// Runs the `linkchecker` tool as compiled in `stage` by the `host` compiler.\n ///\n /// This tool in `src/tools` will verify the validity of all our links in the\n /// documentation to ensure we don't have a bunch of dead ones.\n pub fn linkcheck(build: &Build, stage: u32, host: &str) {\n     println!(\"Linkcheck stage{} ({})\", stage, host);\n     let compiler = Compiler::new(stage, host);\n+\n+    let _time = util::timeit();\n     build.run(build.tool_cmd(&compiler, \"linkchecker\")\n                    .arg(build.out.join(host).join(\"doc\")));\n }\n@@ -58,6 +90,7 @@ pub fn cargotest(build: &Build, stage: u32, host: &str) {\n     let out_dir = build.out.join(\"ct\");\n     t!(fs::create_dir_all(&out_dir));\n \n+    let _time = util::timeit();\n     build.run(build.tool_cmd(compiler, \"cargotest\")\n                    .env(\"PATH\", newpath)\n                    .arg(&build.cargo)\n@@ -90,7 +123,8 @@ pub fn compiletest(build: &Build,\n                    target: &str,\n                    mode: &str,\n                    suite: &str) {\n-    println!(\"Check compiletest {} ({} -> {})\", suite, compiler.host, target);\n+    println!(\"Check compiletest suite={} mode={} ({} -> {})\",\n+             suite, mode, compiler.host, target);\n     let mut cmd = build.tool_cmd(compiler, \"compiletest\");\n \n     // compiletest currently has... a lot of arguments, so let's just pass all\n@@ -184,14 +218,18 @@ pub fn compiletest(build: &Build,\n \n     // Running a C compiler on MSVC requires a few env vars to be set, to be\n     // sure to set them here.\n+    //\n+    // Note that if we encounter `PATH` we make sure to append to our own `PATH`\n+    // rather than stomp over it.\n     if target.contains(\"msvc\") {\n         for &(ref k, ref v) in build.cc[target].0.env() {\n             if k != \"PATH\" {\n                 cmd.env(k, v);\n             }\n         }\n     }\n-    build.add_bootstrap_key(&mut cmd);\n+    cmd.env(\"RUSTC_BOOTSTRAP\", \"1\");\n+    build.add_rust_test_threads(&mut cmd);\n \n     cmd.arg(\"--adb-path\").arg(\"adb\");\n     cmd.arg(\"--adb-test-dir\").arg(ADB_TEST_DIR);\n@@ -203,6 +241,7 @@ pub fn compiletest(build: &Build,\n         cmd.arg(\"--android-cross-path\").arg(\"\");\n     }\n \n+    let _time = util::timeit();\n     build.run(&mut cmd);\n }\n \n@@ -215,6 +254,7 @@ pub fn docs(build: &Build, compiler: &Compiler) {\n     // Do a breadth-first traversal of the `src/doc` directory and just run\n     // tests for all files that end in `*.md`\n     let mut stack = vec![build.src.join(\"src/doc\")];\n+    let _time = util::timeit();\n \n     while let Some(p) = stack.pop() {\n         if p.is_dir() {\n@@ -243,6 +283,8 @@ pub fn error_index(build: &Build, compiler: &Compiler) {\n     let dir = testdir(build, compiler.host);\n     t!(fs::create_dir_all(&dir));\n     let output = dir.join(\"error-index.md\");\n+\n+    let _time = util::timeit();\n     build.run(build.tool_cmd(compiler, \"error_index_generator\")\n                    .arg(\"markdown\")\n                    .arg(&output)\n@@ -254,6 +296,7 @@ pub fn error_index(build: &Build, compiler: &Compiler) {\n fn markdown_test(build: &Build, compiler: &Compiler, markdown: &Path) {\n     let mut cmd = Command::new(build.rustdoc(compiler));\n     build.add_rustc_lib_path(compiler, &mut cmd);\n+    build.add_rust_test_threads(&mut cmd);\n     cmd.arg(\"--test\");\n     cmd.arg(markdown);\n \n@@ -278,6 +321,7 @@ pub fn krate(build: &Build,\n              compiler: &Compiler,\n              target: &str,\n              mode: Mode,\n+             test_kind: TestKind,\n              krate: Option<&str>) {\n     let (name, path, features, root) = match mode {\n         Mode::Libstd => {\n@@ -291,15 +335,15 @@ pub fn krate(build: &Build,\n         }\n         _ => panic!(\"can only test libraries\"),\n     };\n-    println!(\"Testing {} stage{} ({} -> {})\", name, compiler.stage,\n+    println!(\"{} {} stage{} ({} -> {})\", test_kind, name, compiler.stage,\n              compiler.host, target);\n \n     // Build up the base `cargo test` command.\n     //\n     // Pass in some standard flags then iterate over the graph we've discovered\n     // in `cargo metadata` with the maps above and figure out what `-p`\n     // arguments need to get passed.\n-    let mut cargo = build.cargo(compiler, mode, target, \"test\");\n+    let mut cargo = build.cargo(compiler, mode, target, test_kind.subcommand());\n     cargo.arg(\"--manifest-path\")\n          .arg(build.src.join(path).join(\"Cargo.toml\"))\n          .arg(\"--features\").arg(features);\n@@ -336,16 +380,25 @@ pub fn krate(build: &Build,\n     dylib_path.insert(0, build.sysroot_libdir(compiler, target));\n     cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n \n+    if target.contains(\"android\") {\n+        cargo.arg(\"--no-run\");\n+    } else if target.contains(\"emscripten\") {\n+        cargo.arg(\"--no-run\");\n+    }\n+\n+    cargo.arg(\"--\");\n+\n     if build.config.quiet_tests {\n-        cargo.arg(\"--\");\n         cargo.arg(\"--quiet\");\n     }\n \n+    let _time = util::timeit();\n+\n     if target.contains(\"android\") {\n-        build.run(cargo.arg(\"--no-run\"));\n+        build.run(&mut cargo);\n         krate_android(build, compiler, target, mode);\n     } else if target.contains(\"emscripten\") {\n-        build.run(cargo.arg(\"--no-run\"));\n+        build.run(&mut cargo);\n         krate_emscripten(build, compiler, target, mode);\n     } else {\n         cargo.args(&build.flags.cmd.test_args());\n@@ -372,14 +425,17 @@ fn krate_android(build: &Build,\n                           target,\n                           compiler.host,\n                           test_file_name);\n+        let quiet = if build.config.quiet_tests { \"--quiet\" } else { \"\" };\n         let program = format!(\"(cd {dir}; \\\n                                 LD_LIBRARY_PATH=./{target} ./{test} \\\n                                     --logfile {log} \\\n+                                    {quiet} \\\n                                     {args})\",\n                               dir = ADB_TEST_DIR,\n                               target = target,\n                               test = test_file_name,\n                               log = log,\n+                              quiet = quiet,\n                               args = build.flags.cmd.test_args().join(\" \"));\n \n         let output = output(Command::new(\"adb\").arg(\"shell\").arg(&program));\n@@ -408,18 +464,12 @@ fn krate_emscripten(build: &Build,\n          let test_file_name = test.to_string_lossy().into_owned();\n          println!(\"running {}\", test_file_name);\n          let nodejs = build.config.nodejs.as_ref().expect(\"nodejs not configured\");\n-         let status = Command::new(nodejs)\n-             .arg(&test_file_name)\n-             .stderr(::std::process::Stdio::inherit())\n-             .status();\n-         match status {\n-             Ok(status) => {\n-                 if !status.success() {\n-                     panic!(\"some tests failed\");\n-                 }\n-             }\n-             Err(e) => panic!(format!(\"failed to execute command: {}\", e)),\n-         };\n+         let mut cmd = Command::new(nodejs);\n+         cmd.arg(&test_file_name);\n+         if build.config.quiet_tests {\n+             cmd.arg(\"--quiet\");\n+         }\n+         build.run(&mut cmd);\n      }\n  }\n \n@@ -467,3 +517,32 @@ pub fn android_copy_libs(build: &Build,\n         }\n     }\n }\n+\n+/// Run \"distcheck\", a 'make check' from a tarball\n+pub fn distcheck(build: &Build) {\n+    if build.config.build != \"x86_64-unknown-linux-gnu\" {\n+        return\n+    }\n+    if !build.config.host.iter().any(|s| s == \"x86_64-unknown-linux-gnu\") {\n+        return\n+    }\n+    if !build.config.target.iter().any(|s| s == \"x86_64-unknown-linux-gnu\") {\n+        return\n+    }\n+\n+    let dir = build.out.join(\"tmp\").join(\"distcheck\");\n+    let _ = fs::remove_dir_all(&dir);\n+    t!(fs::create_dir_all(&dir));\n+\n+    let mut cmd = Command::new(\"tar\");\n+    cmd.arg(\"-xzf\")\n+       .arg(dist::rust_src_location(build))\n+       .arg(\"--strip-components=1\")\n+       .current_dir(&dir);\n+    build.run(&mut cmd);\n+    build.run(Command::new(\"./configure\")\n+                     .current_dir(&dir));\n+    build.run(Command::new(\"make\")\n+                     .arg(\"check\")\n+                     .current_dir(&dir));\n+}"}, {"sha": "e7655458aed8a71128437a1ff921b5bfa39a3417", "filename": "src/bootstrap/clean.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fclean.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -46,6 +46,9 @@ fn rm_rf(build: &Build, path: &Path) {\n     if !path.exists() {\n         return\n     }\n+    if path.is_file() {\n+        return do_op(path, \"remove file\", |p| fs::remove_file(p));\n+    }\n \n     for file in t!(fs::read_dir(path)) {\n         let file = t!(file).path();"}, {"sha": "b268686ca6c3b15dcb7c52655263eb4c1728e123", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -120,8 +120,8 @@ fn build_startup_objects(build: &Build, target: &str, into: &Path) {\n     for file in t!(fs::read_dir(build.src.join(\"src/rtstartup\"))) {\n         let file = t!(file);\n         let mut cmd = Command::new(&compiler_path);\n-        build.add_bootstrap_key(&mut cmd);\n-        build.run(cmd.arg(\"--target\").arg(target)\n+        build.run(cmd.env(\"RUSTC_BOOTSTRAP\", \"1\")\n+                     .arg(\"--target\").arg(target)\n                      .arg(\"--emit=obj\")\n                      .arg(\"--out-dir\").arg(into)\n                      .arg(file.path()));"}, {"sha": "1d3445a9eac451277c6c5853f2dd878ab5aa37fe", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 51, "deletions": 2, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -23,7 +23,7 @@ use std::io::Write;\n use std::path::{PathBuf, Path};\n use std::process::Command;\n \n-use {Build, Compiler};\n+use {Build, Compiler, Mode};\n use util::{cp_r, libdir, is_dylib, cp_filtered, copy};\n \n pub fn package_vers(build: &Build) -> &str {\n@@ -284,6 +284,55 @@ pub fn std(build: &Build, compiler: &Compiler, target: &str) {\n     t!(fs::remove_dir_all(&image));\n }\n \n+pub fn rust_src_location(build: &Build) -> PathBuf {\n+    let plain_name = format!(\"rustc-{}-src\", package_vers(build));\n+    distdir(build).join(&format!(\"{}.tar.gz\", plain_name))\n+}\n+\n+/// Creates a tarball of save-analysis metadata, if available.\n+pub fn analysis(build: &Build, compiler: &Compiler, target: &str) {\n+    println!(\"Dist analysis\");\n+\n+    if build.config.channel != \"nightly\" {\n+        println!(\"Skipping dist-analysis - not on nightly channel\");\n+        return;\n+    }\n+    if compiler.stage != 2 {\n+        return\n+    }\n+\n+    let name = format!(\"rust-analysis-{}\", package_vers(build));\n+    let image = tmpdir(build).join(format!(\"{}-{}-image\", name, target));\n+\n+    let src = build.stage_out(compiler, Mode::Libstd).join(target).join(\"release\").join(\"deps\");\n+\n+    let image_src = src.join(\"save-analysis\");\n+    let dst = image.join(\"lib/rustlib\").join(target).join(\"analysis\");\n+    t!(fs::create_dir_all(&dst));\n+    cp_r(&image_src, &dst);\n+\n+    let mut cmd = Command::new(\"sh\");\n+    cmd.arg(sanitize_sh(&build.src.join(\"src/rust-installer/gen-installer.sh\")))\n+       .arg(\"--product-name=Rust\")\n+       .arg(\"--rel-manifest-dir=rustlib\")\n+       .arg(\"--success-message=save-analysis-saved.\")\n+       .arg(format!(\"--image-dir={}\", sanitize_sh(&image)))\n+       .arg(format!(\"--work-dir={}\", sanitize_sh(&tmpdir(build))))\n+       .arg(format!(\"--output-dir={}\", sanitize_sh(&distdir(build))))\n+       .arg(format!(\"--package-name={}-{}\", name, target))\n+       .arg(format!(\"--component-name=rust-analysis-{}\", target))\n+       .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n+    build.run(&mut cmd);\n+    t!(fs::remove_dir_all(&image));\n+\n+    // Create plain source tarball\n+    let mut cmd = Command::new(\"tar\");\n+    cmd.arg(\"-czf\").arg(sanitize_sh(&distdir(build).join(&format!(\"{}.tar.gz\", name))))\n+       .arg(\"analysis\")\n+       .current_dir(&src);\n+    build.run(&mut cmd);\n+}\n+\n /// Creates the `rust-src` installer component and the plain source tarball\n pub fn rust_src(build: &Build) {\n     println!(\"Dist src\");\n@@ -374,7 +423,7 @@ pub fn rust_src(build: &Build) {\n \n     // Create plain source tarball\n     let mut cmd = Command::new(\"tar\");\n-    cmd.arg(\"-czf\").arg(sanitize_sh(&distdir(build).join(&format!(\"{}.tar.gz\", plain_name))))\n+    cmd.arg(\"-czf\").arg(sanitize_sh(&rust_src_location(build)))\n        .arg(&plain_name)\n        .current_dir(&dst);\n     build.run(&mut cmd);"}, {"sha": "7a2d56fc5d3cc87dbea07c046e2fffba709b6261", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -49,6 +49,10 @@ pub enum Subcommand {\n         paths: Vec<PathBuf>,\n         test_args: Vec<String>,\n     },\n+    Bench {\n+        paths: Vec<PathBuf>,\n+        test_args: Vec<String>,\n+    },\n     Clean,\n     Dist {\n         install: bool,\n@@ -141,6 +145,7 @@ Arguments:\n                    command == \"dist\" ||\n                    command == \"doc\" ||\n                    command == \"test\" ||\n+                   command == \"bench\" ||\n                    command == \"clean\"  {\n                     println!(\"Available invocations:\");\n                     if args.iter().any(|a| a == \"-v\") {\n@@ -163,6 +168,7 @@ println!(\"\\\n Subcommands:\n     build       Compile either the compiler or libraries\n     test        Build and run some test suites\n+    bench       Build and run some benchmarks\n     doc         Build documentation\n     clean       Clean out build directories\n     dist        Build and/or install distribution artifacts\n@@ -210,6 +216,14 @@ To learn more about a subcommand, run `./x.py <command> -h`\n                     test_args: m.opt_strs(\"test-args\"),\n                 }\n             }\n+            \"bench\" => {\n+                opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n+                m = parse(&opts);\n+                Subcommand::Bench {\n+                    paths: remaining_as_path(&m),\n+                    test_args: m.opt_strs(\"test-args\"),\n+                }\n+            }\n             \"clean\" => {\n                 m = parse(&opts);\n                 if m.free.len() > 0 {\n@@ -225,6 +239,7 @@ To learn more about a subcommand, run `./x.py <command> -h`\n                     install: m.opt_present(\"install\"),\n                 }\n             }\n+            \"--help\" => usage(0, &opts),\n             cmd => {\n                 println!(\"unknown command: {}\", cmd);\n                 usage(1, &opts);\n@@ -259,7 +274,8 @@ To learn more about a subcommand, run `./x.py <command> -h`\n impl Subcommand {\n     pub fn test_args(&self) -> Vec<&str> {\n         match *self {\n-            Subcommand::Test { ref test_args, .. } => {\n+            Subcommand::Test { ref test_args, .. } |\n+            Subcommand::Bench { ref test_args, .. } => {\n                 test_args.iter().flat_map(|s| s.split_whitespace()).collect()\n             }\n             _ => Vec::new(),"}, {"sha": "c3859275e6fb4d3b9eb86c1ba860f3a4aad45e54", "filename": "src/bootstrap/job.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fjob.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -51,6 +51,7 @@ type LPVOID = *mut u8;\n type JOBOBJECTINFOCLASS = i32;\n type SIZE_T = usize;\n type LARGE_INTEGER = i64;\n+type UINT = u32;\n type ULONG_PTR = usize;\n type ULONGLONG = u64;\n \n@@ -59,6 +60,8 @@ const DUPLICATE_SAME_ACCESS: DWORD = 0x2;\n const PROCESS_DUP_HANDLE: DWORD = 0x40;\n const JobObjectExtendedLimitInformation: JOBOBJECTINFOCLASS = 9;\n const JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE: DWORD = 0x2000;\n+const SEM_FAILCRITICALERRORS: UINT = 0x0001;\n+const SEM_NOGPFAULTERRORBOX: UINT = 0x0002;\n \n extern \"system\" {\n     fn CreateJobObjectW(lpJobAttributes: *mut u8, lpName: *const u8) -> HANDLE;\n@@ -79,6 +82,7 @@ extern \"system\" {\n                                JobObjectInformationClass: JOBOBJECTINFOCLASS,\n                                lpJobObjectInformation: LPVOID,\n                                cbJobObjectInformationLength: DWORD) -> BOOL;\n+    fn SetErrorMode(mode: UINT) -> UINT;\n }\n \n #[repr(C)]\n@@ -115,6 +119,13 @@ struct JOBOBJECT_BASIC_LIMIT_INFORMATION {\n }\n \n pub unsafe fn setup() {\n+    // Tell Windows to not show any UI on errors (such as not finding a required dll\n+    // during startup or terminating abnormally).  This is important for running tests,\n+    // since some of them use abnormal termination by design.\n+    // This mode is inherited by all child processes.\n+    let mode = SetErrorMode(SEM_NOGPFAULTERRORBOX); // read inherited flags\n+    SetErrorMode(mode | SEM_FAILCRITICALERRORS | SEM_NOGPFAULTERRORBOX);\n+\n     // Create a new job object for us to use\n     let job = CreateJobObjectW(0 as *mut _, 0 as *const _);\n     assert!(job != 0 as *mut _, \"{}\", io::Error::last_os_error());"}, {"sha": "cd80c4298dc41b594616afcd86b96789bf4f9ec3", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 99, "deletions": 19, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -13,22 +13,69 @@\n //! This module, and its descendants, are the implementation of the Rust build\n //! system. Most of this build system is backed by Cargo but the outer layer\n //! here serves as the ability to orchestrate calling Cargo, sequencing Cargo\n-//! builds, building artifacts like LLVM, etc.\n+//! builds, building artifacts like LLVM, etc. The goals of rustbuild are:\n //!\n-//! More documentation can be found in each respective module below.\n+//! * To be an easily understandable, easily extensible, and maintainable build\n+//!   system.\n+//! * Leverage standard tools in the Rust ecosystem to build the compiler, aka\n+//!   crates.io and Cargo.\n+//! * A standard interface to build across all platforms, including MSVC\n+//!\n+//! ## Architecture\n+//!\n+//! Although this build system defers most of the complicated logic to Cargo\n+//! itself, it still needs to maintain a list of targets and dependencies which\n+//! it can itself perform. Rustbuild is made up of a list of rules with\n+//! dependencies amongst them (created in the `step` module) and then knows how\n+//! to execute each in sequence. Each time rustbuild is invoked, it will simply\n+//! iterate through this list of steps and execute each serially in turn.  For\n+//! each step rustbuild relies on the step internally being incremental and\n+//! parallel. Note, though, that the `-j` parameter to rustbuild gets forwarded\n+//! to appropriate test harnesses and such.\n+//!\n+//! Most of the \"meaty\" steps that matter are backed by Cargo, which does indeed\n+//! have its own parallelism and incremental management. Later steps, like\n+//! tests, aren't incremental and simply run the entire suite currently.\n+//!\n+//! When you execute `x.py build`, the steps which are executed are:\n+//!\n+//! * First, the python script is run. This will automatically download the\n+//!   stage0 rustc and cargo according to `src/stage0.txt`, or using the cached\n+//!   versions if they're available. These are then used to compile rustbuild\n+//!   itself (using Cargo). Finally, control is then transferred to rustbuild.\n+//!\n+//! * Rustbuild takes over, performs sanity checks, probes the environment,\n+//!   reads configuration, builds up a list of steps, and then starts executing\n+//!   them.\n+//!\n+//! * The stage0 libstd is compiled\n+//! * The stage0 libtest is compiled\n+//! * The stage0 librustc is compiled\n+//! * The stage1 compiler is assembled\n+//! * The stage1 libstd, libtest, librustc are compiled\n+//! * The stage2 compiler is assembled\n+//! * The stage2 libstd, libtest, librustc are compiled\n+//!\n+//! Each step is driven by a separate Cargo project and rustbuild orchestrates\n+//! copying files between steps and otherwise preparing for Cargo to run.\n+//!\n+//! ## Further information\n+//!\n+//! More documentation can be found in each respective module below, and you can\n+//! also check out the `src/bootstrap/README.md` file for more information.\n \n extern crate build_helper;\n extern crate cmake;\n extern crate filetime;\n extern crate gcc;\n extern crate getopts;\n-extern crate md5;\n extern crate num_cpus;\n extern crate rustc_serialize;\n extern crate toml;\n \n use std::collections::HashMap;\n use std::env;\n+use std::ffi::OsString;\n use std::fs::{self, File};\n use std::path::{Component, PathBuf, Path};\n use std::process::Command;\n@@ -120,8 +167,6 @@ pub struct Build {\n     version: String,\n     package_vers: String,\n     local_rebuild: bool,\n-    bootstrap_key: String,\n-    bootstrap_key_stage0: String,\n \n     // Probed tools at runtime\n     lldb_version: Option<String>,\n@@ -131,6 +176,7 @@ pub struct Build {\n     cc: HashMap<String, (gcc::Tool, Option<PathBuf>)>,\n     cxx: HashMap<String, gcc::Tool>,\n     crates: HashMap<String, Crate>,\n+    is_sudo: bool,\n }\n \n #[derive(Debug)]\n@@ -141,6 +187,7 @@ struct Crate {\n     doc_step: String,\n     build_step: String,\n     test_step: String,\n+    bench_step: String,\n }\n \n /// The various \"modes\" of invoking Cargo.\n@@ -189,6 +236,16 @@ impl Build {\n         };\n         let local_rebuild = config.local_rebuild;\n \n+        let is_sudo = match env::var_os(\"SUDO_USER\") {\n+            Some(sudo_user) => {\n+                match env::var_os(\"USER\") {\n+                    Some(user) => user != sudo_user,\n+                    None => false,\n+                }\n+            }\n+            None => false,\n+        };\n+\n         Build {\n             flags: flags,\n             config: config,\n@@ -204,14 +261,13 @@ impl Build {\n             ver_date: None,\n             version: String::new(),\n             local_rebuild: local_rebuild,\n-            bootstrap_key: String::new(),\n-            bootstrap_key_stage0: String::new(),\n             package_vers: String::new(),\n             cc: HashMap::new(),\n             cxx: HashMap::new(),\n             crates: HashMap::new(),\n             lldb_version: None,\n             lldb_python_dir: None,\n+            is_sudo: is_sudo,\n         }\n     }\n \n@@ -418,7 +474,7 @@ impl Build {\n         // how the actual compiler itself is called.\n         //\n         // These variables are primarily all read by\n-        // src/bootstrap/{rustc,rustdoc.rs}\n+        // src/bootstrap/bin/{rustc.rs,rustdoc.rs}\n         cargo.env(\"RUSTC\", self.out.join(\"bootstrap/debug/rustc\"))\n              .env(\"RUSTC_REAL\", self.compiler_path(compiler))\n              .env(\"RUSTC_STAGE\", stage.to_string())\n@@ -437,7 +493,9 @@ impl Build {\n              .env(\"RUSTDOC_REAL\", self.rustdoc(compiler))\n              .env(\"RUSTC_FLAGS\", self.rustc_flags(target).join(\" \"));\n \n-        self.add_bootstrap_key(&mut cargo);\n+        // Enable usage of unstable features\n+        cargo.env(\"RUSTC_BOOTSTRAP\", \"1\");\n+        self.add_rust_test_threads(&mut cargo);\n \n         // Specify some various options for build scripts used throughout\n         // the build.\n@@ -449,6 +507,10 @@ impl Build {\n                  .env(format!(\"CFLAGS_{}\", target), self.cflags(target).join(\" \"));\n         }\n \n+        if self.config.channel == \"nightly\" && compiler.stage == 2 {\n+            cargo.env(\"RUSTC_SAVE_ANALYSIS\", \"api\".to_string());\n+        }\n+\n         // Environment variables *required* needed throughout the build\n         //\n         // FIXME: should update code to not require this env var\n@@ -457,10 +519,11 @@ impl Build {\n         if self.config.verbose || self.flags.verbose {\n             cargo.arg(\"-v\");\n         }\n-        if self.config.rust_optimize {\n+        // FIXME: cargo bench does not accept `--release`\n+        if self.config.rust_optimize && cmd != \"bench\" {\n             cargo.arg(\"--release\");\n         }\n-        if self.config.vendor {\n+        if self.config.vendor || self.is_sudo {\n             cargo.arg(\"--frozen\");\n         }\n         return cargo\n@@ -494,20 +557,38 @@ impl Build {\n     fn tool_cmd(&self, compiler: &Compiler, tool: &str) -> Command {\n         let mut cmd = Command::new(self.tool(&compiler, tool));\n         let host = compiler.host;\n-        let paths = vec![\n+        let mut paths = vec![\n             self.cargo_out(compiler, Mode::Libstd, host).join(\"deps\"),\n             self.cargo_out(compiler, Mode::Libtest, host).join(\"deps\"),\n             self.cargo_out(compiler, Mode::Librustc, host).join(\"deps\"),\n             self.cargo_out(compiler, Mode::Tool, host).join(\"deps\"),\n         ];\n+\n+        // On MSVC a tool may invoke a C compiler (e.g. compiletest in run-make\n+        // mode) and that C compiler may need some extra PATH modification. Do\n+        // so here.\n+        if compiler.host.contains(\"msvc\") {\n+            let curpaths = env::var_os(\"PATH\").unwrap_or(OsString::new());\n+            let curpaths = env::split_paths(&curpaths).collect::<Vec<_>>();\n+            for &(ref k, ref v) in self.cc[compiler.host].0.env() {\n+                if k != \"PATH\" {\n+                    continue\n+                }\n+                for path in env::split_paths(v) {\n+                    if !curpaths.contains(&path) {\n+                        paths.push(path);\n+                    }\n+                }\n+            }\n+        }\n         add_lib_path(paths, &mut cmd);\n         return cmd\n     }\n \n     /// Get the space-separated set of activated features for the standard\n     /// library.\n     fn std_features(&self) -> String {\n-        let mut features = String::new();\n+        let mut features = \"panic-unwind\".to_string();\n         if self.config.debug_jemalloc {\n             features.push_str(\" debug-jemalloc\");\n         }\n@@ -653,12 +734,11 @@ impl Build {\n         add_lib_path(vec![self.rustc_libdir(compiler)], cmd);\n     }\n \n-    /// Adds the compiler's bootstrap key to the environment of `cmd`.\n-    fn add_bootstrap_key(&self, cmd: &mut Command) {\n-        cmd.env(\"RUSTC_BOOTSTRAP\", \"1\");\n-        // FIXME: Transitionary measure to bootstrap using the old bootstrap logic.\n-        // Remove this once the bootstrap compiler uses the new login in Issue #36548.\n-        cmd.env(\"RUSTC_BOOTSTRAP_KEY\", \"62b3e239\");\n+    /// Adds the `RUST_TEST_THREADS` env var if necessary\n+    fn add_rust_test_threads(&self, cmd: &mut Command) {\n+        if env::var_os(\"RUST_TEST_THREADS\").is_none() {\n+            cmd.env(\"RUST_TEST_THREADS\", self.jobs().to_string());\n+        }\n     }\n \n     /// Returns the compiler's libdir where it stores the dynamic libraries that"}, {"sha": "8befb105ff618974e5650bf7977fd7d720578eed", "filename": "src/bootstrap/metadata.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmetadata.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -70,6 +70,7 @@ fn build_krate(build: &mut Build, krate: &str) {\n                 build_step: format!(\"build-crate-{}\", package.name),\n                 doc_step: format!(\"doc-crate-{}\", package.name),\n                 test_step: format!(\"test-crate-{}\", package.name),\n+                bench_step: format!(\"bench-crate-{}\", package.name),\n                 name: package.name,\n                 deps: Vec::new(),\n                 path: path,"}, {"sha": "1fa70081938ff2b446f034d9a40d25a2aad01103", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -1,4 +1,4 @@\n-# Copyright 20126 The Rust Project Developers. See the COPYRIGHT\n+# Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n # file at the top-level directory of this distribution and at\n # http://rust-lang.org/COPYRIGHT.\n #\n@@ -23,9 +23,14 @@ all:\n \t$(Q)$(BOOTSTRAP) build $(BOOTSTRAP_ARGS)\n \t$(Q)$(BOOTSTRAP) doc $(BOOTSTRAP_ARGS)\n \n-# Don\u2019t use $(Q) here, always show how to invoke the bootstrap script directly\n help:\n-\t$(BOOTSTRAP) --help\n+\t$(Q)echo 'Welcome to the rustbuild build system!'\n+\t$(Q)echo\n+\t$(Q)echo This makefile is a thin veneer over the ./x.py script located\n+\t$(Q)echo in this directory. To get the full power of the build system\n+\t$(Q)echo you can run x.py directly.\n+\t$(Q)echo\n+\t$(Q)echo To learn more run \\`./x.py --help\\`\n \n clean:\n \t$(Q)$(BOOTSTRAP) clean $(BOOTSTRAP_ARGS)\n@@ -50,16 +55,17 @@ check-cargotest:\n \t$(Q)$(BOOTSTRAP) test src/tools/cargotest $(BOOTSTRAP_ARGS)\n dist:\n \t$(Q)$(BOOTSTRAP) dist $(BOOTSTRAP_ARGS)\n+distcheck:\n+\t$(Q)$(BOOTSTRAP) test distcheck\n install:\n-ifeq (root user, $(USER) $(patsubst %,user,$(SUDO_USER)))\n-\t$(Q)echo \"'sudo make install' is not supported currently.\"\n-else\n \t$(Q)$(BOOTSTRAP) dist --install $(BOOTSTRAP_ARGS)\n-endif\n tidy:\n \t$(Q)$(BOOTSTRAP) test src/tools/tidy $(BOOTSTRAP_ARGS) --stage 0\n \n-check-stage2-android:\n-\t$(Q)$(BOOTSTRAP) --step check-target --target arm-linux-androideabi\n+check-stage2-T-arm-linux-androideabi-H-x86_64-unknown-linux-gnu:\n+\t$(Q)$(BOOTSTRAP) test --target arm-linux-androideabi\n+check-stage2-T-x86_64-unknown-linux-musl-H-x86_64-unknown-linux-gnu:\n+\t$(Q)$(BOOTSTRAP) test --target x86_64-unknown-linux-gnu\n+\n \n .PHONY: dist"}, {"sha": "ffa3fe1cbf2fd54d10af32fc9a47a7c0b18fce5b", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -28,7 +28,7 @@ use cmake;\n use gcc;\n \n use Build;\n-use util::up_to_date;\n+use util::{self, up_to_date};\n \n /// Compile LLVM for `target`.\n pub fn llvm(build: &Build, target: &str) {\n@@ -58,6 +58,7 @@ pub fn llvm(build: &Build, target: &str) {\n \n     println!(\"Building LLVM for {}\", target);\n \n+    let _time = util::timeit();\n     let _ = fs::remove_dir_all(&dst.join(\"build\"));\n     t!(fs::create_dir_all(&dst.join(\"build\")));\n     let assertions = if build.config.llvm_assertions {\"ON\"} else {\"OFF\"};\n@@ -158,6 +159,17 @@ pub fn test_helpers(build: &Build, target: &str) {\n     println!(\"Building test helpers\");\n     t!(fs::create_dir_all(&dst));\n     let mut cfg = gcc::Config::new();\n+\n+    // We may have found various cross-compilers a little differently due to our\n+    // extra configuration, so inform gcc of these compilers. Note, though, that\n+    // on MSVC we still need gcc's detection of env vars (ugh).\n+    if !target.contains(\"msvc\") {\n+        if let Some(ar) = build.ar(target) {\n+            cfg.archiver(ar);\n+        }\n+        cfg.compiler(build.cc(target));\n+    }\n+\n     cfg.cargo_metadata(false)\n        .out_dir(&dst)\n        .target(target)"}, {"sha": "f3fe22698bb9099bffd8683f15a308944680db30", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -41,10 +41,14 @@ pub fn check(build: &mut Build) {\n         }\n     }\n     let have_cmd = |cmd: &OsStr| {\n-        for path in env::split_paths(&path).map(|p| p.join(cmd)) {\n-            if fs::metadata(&path).is_ok() ||\n-               fs::metadata(path.with_extension(\"exe\")).is_ok() {\n-                return Some(path);\n+        for path in env::split_paths(&path) {\n+            let target = path.join(cmd);\n+            let mut cmd_alt = cmd.to_os_string();\n+            cmd_alt.push(\".exe\");\n+            if target.exists() ||\n+               target.with_extension(\"exe\").exists() ||\n+               target.join(cmd_alt).exists() {\n+                return Some(target);\n             }\n         }\n         return None;"}, {"sha": "884cc7da8eaf8f6f39492a313540602263bdc205", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 278, "deletions": 65, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -8,10 +8,28 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Definition of steps of the build system.\n+//!\n+//! This is where some of the real meat of rustbuild is located, in how we\n+//! define targets and the dependencies amongst them. This file can sort of be\n+//! viewed as just defining targets in a makefile which shell out to predefined\n+//! functions elsewhere about how to execute the target.\n+//!\n+//! The primary function here you're likely interested in is the `build_rules`\n+//! function. This will create a `Rules` structure which basically just lists\n+//! everything that rustbuild can do. Each rule has a human-readable name, a\n+//! path associated with it, some dependencies, and then a closure of how to\n+//! actually perform the rule.\n+//!\n+//! All steps below are defined in self-contained units, so adding a new target\n+//! to the build system should just involve adding the meta information here\n+//! along with the actual implementation elsewhere. You can find more comments\n+//! about how to define rules themselves below.\n+\n use std::collections::{HashMap, HashSet};\n use std::mem;\n \n-use check;\n+use check::{self, TestKind};\n use compile;\n use dist;\n use doc;\n@@ -20,51 +38,98 @@ use install;\n use native;\n use {Compiler, Build, Mode};\n \n-#[derive(PartialEq, Eq, Hash, Clone, Debug)]\n-struct Step<'a> {\n-    name: &'a str,\n-    stage: u32,\n-    host: &'a str,\n-    target: &'a str,\n-}\n-\n-impl<'a> Step<'a> {\n-    fn name(&self, name: &'a str) -> Step<'a> {\n-        Step { name: name, ..*self }\n-    }\n-\n-    fn stage(&self, stage: u32) -> Step<'a> {\n-        Step { stage: stage, ..*self }\n-    }\n-\n-    fn host(&self, host: &'a str) -> Step<'a> {\n-        Step { host: host, ..*self }\n-    }\n-\n-    fn target(&self, target: &'a str) -> Step<'a> {\n-        Step { target: target, ..*self }\n-    }\n-\n-    fn compiler(&self) -> Compiler<'a> {\n-        Compiler::new(self.stage, self.host)\n-    }\n-}\n-\n pub fn run(build: &Build) {\n     let rules = build_rules(build);\n     let steps = rules.plan();\n     rules.run(&steps);\n }\n \n pub fn build_rules(build: &Build) -> Rules {\n-    let mut rules: Rules = Rules::new(build);\n+    let mut rules = Rules::new(build);\n+\n+    // This is the first rule that we're going to define for rustbuild, which is\n+    // used to compile LLVM itself. All rules are added through the `rules`\n+    // structure created above and are configured through a builder-style\n+    // interface.\n+    //\n+    // First up we see the `build` method. This represents a rule that's part of\n+    // the top-level `build` subcommand. For example `./x.py build` is what this\n+    // is associating with. Note that this is normally only relevant if you flag\n+    // a rule as `default`, which we'll talk about later.\n+    //\n+    // Next up we'll see two arguments to this method:\n+    //\n+    // * `llvm` - this is the \"human readable\" name of this target. This name is\n+    //            not accessed anywhere outside this file itself (e.g. not in\n+    //            the CLI nor elsewhere in rustbuild). The purpose of this is to\n+    //            easily define dependencies between rules. That is, other rules\n+    //            will depend on this with the name \"llvm\".\n+    // * `src/llvm` - this is the relevant path to the rule that we're working\n+    //                with. This path is the engine behind how commands like\n+    //                `./x.py build src/llvm` work. This should typically point\n+    //                to the relevant component, but if there's not really a\n+    //                path to be assigned here you can pass something like\n+    //                `path/to/nowhere` to ignore it.\n+    //\n+    // After we create the rule with the `build` method we can then configure\n+    // various aspects of it. For example this LLVM rule uses `.host(true)` to\n+    // flag that it's a rule only for host targets. In other words, LLVM isn't\n+    // compiled for targets configured through `--target` (e.g. those we're just\n+    // building a standard library for).\n+    //\n+    // Next up the `dep` method will add a dependency to this rule. The closure\n+    // is yielded the step that represents executing the `llvm` rule itself\n+    // (containing information like stage, host, target, ...) and then it must\n+    // return a target that the step depends on. Here LLVM is actually\n+    // interesting where a cross-compiled LLVM depends on the host LLVM, but\n+    // otherwise it has no dependencies.\n+    //\n+    // To handle this we do a bit of dynamic dispatch to see what the dependency\n+    // is. If we're building a LLVM for the build triple, then we don't actually\n+    // have any dependencies! To do that we return a dependency on the \"dummy\"\n+    // target which does nothing.\n+    //\n+    // If we're build a cross-compiled LLVM, however, we need to assemble the\n+    // libraries from the previous compiler. This step has the same name as\n+    // ours (llvm) but we want it for a different target, so we use the\n+    // builder-style methods on `Step` to configure this target to the build\n+    // triple.\n+    //\n+    // Finally, to finish off this rule, we define how to actually execute it.\n+    // That logic is all defined in the `native` module so we just delegate to\n+    // the relevant function there. The argument to the closure passed to `run`\n+    // is a `Step` (defined below) which encapsulates information like the\n+    // stage, target, host, etc.\n+    rules.build(\"llvm\", \"src/llvm\")\n+         .host(true)\n+         .dep(move |s| {\n+             if s.target == build.config.build {\n+                 dummy(s, build)\n+             } else {\n+                 s.target(&build.config.build)\n+             }\n+         })\n+         .run(move |s| native::llvm(build, s.target));\n+\n+    // Ok! After that example rule  that's hopefully enough to explain what's\n+    // going on here. You can check out the API docs below and also see a bunch\n+    // more examples of rules directly below as well.\n+\n     // dummy rule to do nothing, useful when a dep maps to no deps\n     rules.build(\"dummy\", \"path/to/nowhere\");\n-    fn dummy<'a>(s: &Step<'a>, build: &'a Build) -> Step<'a> {\n-        s.name(\"dummy\").stage(0)\n-         .target(&build.config.build)\n-         .host(&build.config.build)\n-    }\n+\n+    // the compiler with no target libraries ready to go\n+    rules.build(\"rustc\", \"src/rustc\")\n+         .dep(move |s| {\n+             if s.stage == 0 {\n+                 dummy(s, build)\n+             } else {\n+                 s.name(\"librustc\")\n+                  .host(&build.config.build)\n+                  .stage(s.stage - 1)\n+             }\n+         })\n+         .run(move |s| compile::assemble_rustc(build, s.stage, s.target));\n \n     // Helper for loading an entire DAG of crates, rooted at `name`\n     let krates = |name: &str| {\n@@ -85,21 +150,6 @@ pub fn build_rules(build: &Build) -> Rules {\n         return ret\n     };\n \n-    rules.build(\"rustc\", \"path/to/nowhere\")\n-         .dep(move |s| {\n-             if s.stage == 0 {\n-                 dummy(s, build)\n-             } else {\n-                 s.name(\"librustc\")\n-                  .host(&build.config.build)\n-                  .stage(s.stage - 1)\n-             }\n-         })\n-         .run(move |s| compile::assemble_rustc(build, s.stage, s.target));\n-    rules.build(\"llvm\", \"src/llvm\")\n-         .host(true)\n-         .run(move |s| native::llvm(build, s.target));\n-\n     // ========================================================================\n     // Crate compilations\n     //\n@@ -268,37 +318,55 @@ pub fn build_rules(build: &Build) -> Rules {\n         rules.test(&krate.test_step, path)\n              .dep(|s| s.name(\"libtest\"))\n              .run(move |s| check::krate(build, &s.compiler(), s.target,\n-                                        Mode::Libstd, Some(&krate.name)));\n+                                        Mode::Libstd, TestKind::Test,\n+                                        Some(&krate.name)));\n     }\n     rules.test(\"check-std-all\", \"path/to/nowhere\")\n          .dep(|s| s.name(\"libtest\"))\n          .default(true)\n-         .run(move |s| check::krate(build, &s.compiler(), s.target, Mode::Libstd,\n-                               None));\n+         .run(move |s| check::krate(build, &s.compiler(), s.target,\n+                                    Mode::Libstd, TestKind::Test, None));\n+\n+    // std benchmarks\n+    for (krate, path, _default) in krates(\"std_shim\") {\n+        rules.bench(&krate.bench_step, path)\n+             .dep(|s| s.name(\"libtest\"))\n+             .run(move |s| check::krate(build, &s.compiler(), s.target,\n+                                        Mode::Libstd, TestKind::Bench,\n+                                        Some(&krate.name)));\n+    }\n+    rules.bench(\"bench-std-all\", \"path/to/nowhere\")\n+         .dep(|s| s.name(\"libtest\"))\n+         .default(true)\n+         .run(move |s| check::krate(build, &s.compiler(), s.target,\n+                                    Mode::Libstd, TestKind::Bench, None));\n+\n     for (krate, path, _default) in krates(\"test_shim\") {\n         rules.test(&krate.test_step, path)\n              .dep(|s| s.name(\"libtest\"))\n              .run(move |s| check::krate(build, &s.compiler(), s.target,\n-                                        Mode::Libtest, Some(&krate.name)));\n+                                        Mode::Libtest, TestKind::Test,\n+                                        Some(&krate.name)));\n     }\n     rules.test(\"check-test-all\", \"path/to/nowhere\")\n          .dep(|s| s.name(\"libtest\"))\n          .default(true)\n-         .run(move |s| check::krate(build, &s.compiler(), s.target, Mode::Libtest,\n-                               None));\n+         .run(move |s| check::krate(build, &s.compiler(), s.target,\n+                                    Mode::Libtest, TestKind::Test, None));\n     for (krate, path, _default) in krates(\"rustc-main\") {\n         rules.test(&krate.test_step, path)\n              .dep(|s| s.name(\"librustc\"))\n              .host(true)\n              .run(move |s| check::krate(build, &s.compiler(), s.target,\n-                                        Mode::Librustc, Some(&krate.name)));\n+                                        Mode::Librustc, TestKind::Test,\n+                                        Some(&krate.name)));\n     }\n     rules.test(\"check-rustc-all\", \"path/to/nowhere\")\n          .dep(|s| s.name(\"librustc\"))\n          .default(true)\n          .host(true)\n-         .run(move |s| check::krate(build, &s.compiler(), s.target, Mode::Librustc,\n-                               None));\n+         .run(move |s| check::krate(build, &s.compiler(), s.target,\n+                                    Mode::Librustc, TestKind::Test, None));\n \n     rules.test(\"check-linkchecker\", \"src/tools/linkchecker\")\n          .dep(|s| s.name(\"tool-linkchecker\"))\n@@ -312,10 +380,10 @@ pub fn build_rules(build: &Build) -> Rules {\n          .host(true)\n          .run(move |s| check::cargotest(build, s.stage, s.target));\n     rules.test(\"check-tidy\", \"src/tools/tidy\")\n-         .dep(|s| s.name(\"tool-tidy\"))\n+         .dep(|s| s.name(\"tool-tidy\").stage(0))\n          .default(true)\n          .host(true)\n-         .run(move |s| check::tidy(build, s.stage, s.target));\n+         .run(move |s| check::tidy(build, 0, s.target));\n     rules.test(\"check-error-index\", \"src/tools/error_index_generator\")\n          .dep(|s| s.name(\"libstd\"))\n          .dep(|s| s.name(\"tool-error-index\").host(s.host))\n@@ -327,6 +395,10 @@ pub fn build_rules(build: &Build) -> Rules {\n          .default(true)\n          .host(true)\n          .run(move |s| check::docs(build, &s.compiler()));\n+    rules.test(\"check-distcheck\", \"distcheck\")\n+         .dep(|s| s.name(\"dist-src\"))\n+         .run(move |_| check::distcheck(build));\n+\n \n     rules.build(\"test-helpers\", \"src/rt/rust_test_helpers.c\")\n          .run(move |s| native::test_helpers(build, s.target));\n@@ -427,28 +499,106 @@ pub fn build_rules(build: &Build) -> Rules {\n          .default(true)\n          .dep(|s| s.name(\"default:doc\"))\n          .run(move |s| dist::docs(build, s.stage, s.target));\n+    rules.dist(\"dist-analysis\", \"src/libstd\")\n+         .dep(|s| s.name(\"dist-std\"))\n+         .default(true)\n+         .run(move |s| dist::analysis(build, &s.compiler(), s.target));\n     rules.dist(\"install\", \"src\")\n          .dep(|s| s.name(\"default:dist\"))\n          .run(move |s| install::install(build, s.stage, s.target));\n \n     rules.verify();\n-    return rules\n+    return rules;\n+\n+    fn dummy<'a>(s: &Step<'a>, build: &'a Build) -> Step<'a> {\n+        s.name(\"dummy\").stage(0)\n+         .target(&build.config.build)\n+         .host(&build.config.build)\n+    }\n+}\n+\n+#[derive(PartialEq, Eq, Hash, Clone, Debug)]\n+struct Step<'a> {\n+    /// Human readable name of the rule this step is executing. Possible names\n+    /// are all defined above in `build_rules`.\n+    name: &'a str,\n+\n+    /// The stage this step is executing in. This is typically 0, 1, or 2.\n+    stage: u32,\n+\n+    /// This step will likely involve a compiler, and the target that compiler\n+    /// itself is built for is called the host, this variable. Typically this is\n+    /// the target of the build machine itself.\n+    host: &'a str,\n+\n+    /// The target that this step represents generating. If you're building a\n+    /// standard library for a new suite of targets, for example, this'll be set\n+    /// to those targets.\n+    target: &'a str,\n+}\n+\n+impl<'a> Step<'a> {\n+    /// Creates a new step which is the same as this, except has a new name.\n+    fn name(&self, name: &'a str) -> Step<'a> {\n+        Step { name: name, ..*self }\n+    }\n+\n+    /// Creates a new step which is the same as this, except has a new stage.\n+    fn stage(&self, stage: u32) -> Step<'a> {\n+        Step { stage: stage, ..*self }\n+    }\n+\n+    /// Creates a new step which is the same as this, except has a new host.\n+    fn host(&self, host: &'a str) -> Step<'a> {\n+        Step { host: host, ..*self }\n+    }\n+\n+    /// Creates a new step which is the same as this, except has a new target.\n+    fn target(&self, target: &'a str) -> Step<'a> {\n+        Step { target: target, ..*self }\n+    }\n+\n+    /// Returns the `Compiler` structure that this step corresponds to.\n+    fn compiler(&self) -> Compiler<'a> {\n+        Compiler::new(self.stage, self.host)\n+    }\n }\n \n struct Rule<'a> {\n+    /// The human readable name of this target, defined in `build_rules`.\n     name: &'a str,\n+\n+    /// The path associated with this target, used in the `./x.py` driver for\n+    /// easy and ergonomic specification of what to do.\n     path: &'a str,\n+\n+    /// The \"kind\" of top-level command that this rule is associated with, only\n+    /// relevant if this is a default rule.\n     kind: Kind,\n+\n+    /// List of dependencies this rule has. Each dependency is a function from a\n+    /// step that's being executed to another step that should be executed.\n     deps: Vec<Box<Fn(&Step<'a>) -> Step<'a> + 'a>>,\n+\n+    /// How to actually execute this rule. Takes a step with contextual\n+    /// information and then executes it.\n     run: Box<Fn(&Step<'a>) + 'a>,\n+\n+    /// Whether or not this is a \"default\" rule. That basically means that if\n+    /// you run, for example, `./x.py test` whether it's included or not.\n     default: bool,\n+\n+    /// Whether or not this is a \"host\" rule, or in other words whether this is\n+    /// only intended for compiler hosts and not for targets that are being\n+    /// generated.\n     host: bool,\n }\n \n #[derive(PartialEq)]\n enum Kind {\n     Build,\n     Test,\n+    Bench,\n     Dist,\n     Doc,\n }\n@@ -467,6 +617,8 @@ impl<'a> Rule<'a> {\n     }\n }\n \n+/// Builder pattern returned from the various methods on `Rules` which will add\n+/// the rule to the internal list on `Drop`.\n struct RuleBuilder<'a: 'b, 'b> {\n     rules: &'b mut Rules<'a>,\n     rule: Rule<'a>,\n@@ -528,21 +680,35 @@ impl<'a> Rules<'a> {\n         }\n     }\n \n+    /// Creates a new rule of `Kind::Build` with the specified human readable\n+    /// name and path associated with it.\n+    ///\n+    /// The builder returned should be configured further with information such\n+    /// as how to actually run this rule.\n     fn build<'b>(&'b mut self, name: &'a str, path: &'a str)\n                  -> RuleBuilder<'a, 'b> {\n         self.rule(name, path, Kind::Build)\n     }\n \n+    /// Same as `build`, but for `Kind::Test`.\n     fn test<'b>(&'b mut self, name: &'a str, path: &'a str)\n                 -> RuleBuilder<'a, 'b> {\n         self.rule(name, path, Kind::Test)\n     }\n \n+    /// Same as `build`, but for `Kind::Bench`.\n+    fn bench<'b>(&'b mut self, name: &'a str, path: &'a str)\n+                -> RuleBuilder<'a, 'b> {\n+        self.rule(name, path, Kind::Bench)\n+    }\n+\n+    /// Same as `build`, but for `Kind::Doc`.\n     fn doc<'b>(&'b mut self, name: &'a str, path: &'a str)\n                -> RuleBuilder<'a, 'b> {\n         self.rule(name, path, Kind::Doc)\n     }\n \n+    /// Same as `build`, but for `Kind::Dist`.\n     fn dist<'b>(&'b mut self, name: &'a str, path: &'a str)\n                 -> RuleBuilder<'a, 'b> {\n         self.rule(name, path, Kind::Dist)\n@@ -583,6 +749,7 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n             \"build\" => Kind::Build,\n             \"doc\" => Kind::Doc,\n             \"test\" => Kind::Test,\n+            \"bench\" => Kind::Bench,\n             \"dist\" => Kind::Dist,\n             _ => return,\n         };\n@@ -602,10 +769,36 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n     /// Construct the top-level build steps that we're going to be executing,\n     /// given the subcommand that our build is performing.\n     fn plan(&self) -> Vec<Step<'a>> {\n+        // Ok, the logic here is pretty subtle, and involves quite a few\n+        // conditionals. The basic idea here is to:\n+        //\n+        // 1. First, filter all our rules to the relevant ones. This means that\n+        //    the command specified corresponds to one of our `Kind` variants,\n+        //    and we filter all rules based on that.\n+        //\n+        // 2. Next, we determine which rules we're actually executing. If a\n+        //    number of path filters were specified on the command line we look\n+        //    for those, otherwise we look for anything tagged `default`.\n+        //\n+        // 3. Finally, we generate some steps with host and target information.\n+        //\n+        // The last step is by far the most complicated and subtle. The basic\n+        // thinking here is that we want to take the cartesian product of\n+        // specified hosts and targets and build rules with that. The list of\n+        // hosts and targets, if not specified, come from the how this build was\n+        // configured. If the rule we're looking at is a host-only rule the we\n+        // ignore the list of targets and instead consider the list of hosts\n+        // also the list of targets.\n+        //\n+        // Once the host and target lists are generated we take the cartesian\n+        // product of the two and then create a step based off them. Note that\n+        // the stage each step is associated was specified with the `--step`\n+        // flag on the command line.\n         let (kind, paths) = match self.build.flags.cmd {\n             Subcommand::Build { ref paths } => (Kind::Build, &paths[..]),\n             Subcommand::Doc { ref paths } => (Kind::Doc, &paths[..]),\n             Subcommand::Test { ref paths, test_args: _ } => (Kind::Test, &paths[..]),\n+            Subcommand::Bench { ref paths, test_args: _ } => (Kind::Bench, &paths[..]),\n             Subcommand::Dist { install } => {\n                 if install {\n                     return vec![self.sbuild.name(\"install\")]\n@@ -631,7 +824,18 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n             } else {\n                 &self.build.config.target\n             };\n-            let arr = if rule.host {hosts} else {targets};\n+            // If --target was specified but --host wasn't specified, don't run\n+            // any host-only tests\n+            let arr = if rule.host {\n+                if self.build.flags.target.len() > 0 &&\n+                   self.build.flags.host.len() == 0 {\n+                    &hosts[..0]\n+                } else {\n+                    hosts\n+                }\n+            } else {\n+                targets\n+            };\n \n             hosts.iter().flat_map(move |host| {\n                 arr.iter().map(move |target| {\n@@ -672,6 +876,15 @@ invalid rule dependency graph detected, was a rule added and maybe typo'd?\n         }\n     }\n \n+    /// Performs topological sort of dependencies rooted at the `step`\n+    /// specified, pushing all results onto the `order` vector provided.\n+    ///\n+    /// In other words, when this method returns, the `order` vector will\n+    /// contain a list of steps which if executed in order will eventually\n+    /// complete the `step` specified as well.\n+    ///\n+    /// The `added` set specified here is the set of steps that are already\n+    /// present in `order` (and hence don't need to be added again).\n     fn fill(&self,\n             step: Step<'a>,\n             order: &mut Vec<Step<'a>>,"}, {"sha": "cb5b456a0f2fe9c63c7d6fc899669d0ec2ac064e", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -18,6 +18,7 @@ use std::ffi::OsString;\n use std::fs;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n+use std::time::Instant;\n \n use filetime::FileTime;\n \n@@ -189,3 +190,19 @@ pub fn push_exe_path(mut buf: PathBuf, components: &[&str]) -> PathBuf {\n \n     buf\n }\n+\n+pub struct TimeIt(Instant);\n+\n+/// Returns an RAII structure that prints out how long it took to drop.\n+pub fn timeit() -> TimeIt {\n+    TimeIt(Instant::now())\n+}\n+\n+impl Drop for TimeIt {\n+    fn drop(&mut self) {\n+        let time = self.0.elapsed();\n+        println!(\"\\tfinished in {}.{:03}\",\n+                 time.as_secs(),\n+                 time.subsec_nanos() / 1_000_000);\n+    }\n+}"}, {"sha": "07f9c91d3c787b17f17c23be5225d1016d7142b3", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -21,7 +21,8 @@ pub fn run(cmd: &mut Command) {\n pub fn run_silent(cmd: &mut Command) {\n     let status = match cmd.status() {\n         Ok(status) => status,\n-        Err(e) => fail(&format!(\"failed to execute command: {}\", e)),\n+        Err(e) => fail(&format!(\"failed to execute command: {:?}\\nerror: {}\",\n+                                cmd, e)),\n     };\n     if !status.success() {\n         fail(&format!(\"command did not execute successfully: {:?}\\n\\\n@@ -63,7 +64,8 @@ pub fn cc2ar(cc: &Path, target: &str) -> Option<PathBuf> {\n pub fn output(cmd: &mut Command) -> String {\n     let output = match cmd.stderr(Stdio::inherit()).output() {\n         Ok(status) => status,\n-        Err(e) => fail(&format!(\"failed to execute command: {}\", e)),\n+        Err(e) => fail(&format!(\"failed to execute command: {:?}\\nerror: {}\",\n+                                cmd, e)),\n     };\n     if !output.status.success() {\n         panic!(\"command did not execute successfully: {:?}\\n\\"}, {"sha": "121c0263cbccb5f62b73a53a2f29257e75f4ebc7", "filename": "src/ci/docker/arm-android/Dockerfile", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farm-android%2FDockerfile?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -9,7 +9,6 @@ RUN dpkg --add-architecture i386 && \\\n   curl \\\n   ca-certificates \\\n   python2.7 \\\n-  python-minimal \\\n   git \\\n   cmake \\\n   ccache \\\n@@ -39,8 +38,7 @@ ENV RUST_CONFIGURE_ARGS \\\n       --arm-linux-androideabi-ndk=/android/ndk-arm-9 \\\n       --armv7-linux-androideabi-ndk=/android/ndk-arm-9 \\\n       --i686-linux-android-ndk=/android/ndk-x86-9 \\\n-      --aarch64-linux-android-ndk=/android/ndk-aarch64 \\\n-      --enable-rustbuild\n-ENV RUST_CHECK_TARGET check-stage2-android\n+      --aarch64-linux-android-ndk=/android/ndk-aarch64\n+ENV XPY_CHECK test --target arm-linux-androideabi\n RUN mkdir /tmp/obj\n RUN chmod 777 /tmp/obj"}, {"sha": "b7b23d74c9dadaa49c3345609dd8ee32b339c56b", "filename": "src/ci/docker/cross/Dockerfile", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fci%2Fdocker%2Fcross%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fci%2Fdocker%2Fcross%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fcross%2FDockerfile?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -7,7 +7,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   curl \\\n   ca-certificates \\\n   python2.7 \\\n-  python-minimal \\\n   git \\\n   cmake \\\n   ccache \\"}, {"sha": "ff5345d3aac9d5c133be0b7ac7968a1bf93c47a2", "filename": "src/ci/docker/run.sh", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -19,17 +19,21 @@ ci_dir=\"`dirname $docker_dir`\"\n src_dir=\"`dirname $ci_dir`\"\n root_dir=\"`dirname $src_dir`\"\n \n-docker build \\\n+docker \\\n+  build \\\n   --rm \\\n   -t rust-ci \\\n   \"`dirname \"$script\"`/$image\"\n \n mkdir -p $HOME/.ccache\n mkdir -p $HOME/.cargo\n+mkdir -p $root_dir/obj\n \n-exec docker run \\\n+exec docker \\\n+  run \\\n   --volume \"$root_dir:/checkout:ro\" \\\n-  --workdir /tmp/obj \\\n+  --volume \"$root_dir/obj:/checkout/obj\" \\\n+  --workdir /checkout/obj \\\n   --env SRC=/checkout \\\n   --env CCACHE_DIR=/ccache \\\n   --volume \"$HOME/.ccache:/ccache\" \\"}, {"sha": "a3a52f9e6ff95fcb8522993675a3b677c6d161ff", "filename": "src/ci/docker/x86_64-freebsd/Dockerfile", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fci%2Fdocker%2Fx86_64-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fci%2Fdocker%2Fx86_64-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-freebsd%2FDockerfile?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -7,7 +7,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   curl \\\n   ca-certificates \\\n   python2.7 \\\n-  python-minimal \\\n   git \\\n   cmake \\\n   ccache \\\n@@ -23,7 +22,7 @@ ENV \\\n     AR_x86_64_unknown_freebsd=x86_64-unknown-freebsd10-ar \\\n     CC_x86_64_unknown_freebsd=x86_64-unknown-freebsd10-gcc\n \n-ENV RUST_CONFIGURE_ARGS --target=x86_64-unknown-freebsd --enable-rustbuild\n+ENV RUST_CONFIGURE_ARGS --target=x86_64-unknown-freebsd\n ENV RUST_CHECK_TARGET \"\"\n RUN mkdir /tmp/obj\n RUN chmod 777 /tmp/obj"}, {"sha": "107e2bf8a121e2bb92e6b949915f24fda341529a", "filename": "src/ci/docker/x86_64-gnu-cargotest/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fci%2Fdocker%2Fx86_64-gnu-cargotest%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fci%2Fdocker%2Fx86_64-gnu-cargotest%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-cargotest%2FDockerfile?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -7,14 +7,14 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   curl \\\n   ca-certificates \\\n   python2.7 \\\n-  python-minimal \\\n   git \\\n   cmake \\\n   ccache \\\n   libssl-dev \\\n   sudo\n \n-ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu --enable-rustbuild\n+ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu\n ENV RUST_CHECK_TARGET check-cargotest\n+ENV NO_VENDOR 1\n RUN mkdir /tmp/obj\n RUN chmod 777 /tmp/obj"}, {"sha": "c27e3d1325fe8570c7cbea4f7eb0b1edaeafabc8", "filename": "src/ci/docker/x86_64-gnu-llvm-3.7/Dockerfile", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.7%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.7%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.7%2FDockerfile?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -7,7 +7,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   curl \\\n   ca-certificates \\\n   python2.7 \\\n-  python2.7-minimal \\\n   git \\\n   cmake \\\n   ccache \\\n@@ -19,7 +18,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n \n ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n-      --enable-rustbuild \\\n       --llvm-root=/usr/lib/llvm-3.7\n ENV RUST_CHECK_TARGET check\n RUN mkdir /tmp/obj"}, {"sha": "93229b2a0103e91ade2b026cc4721714ea33d923", "filename": "src/ci/docker/x86_64-gnu-make/Dockerfile", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fci%2Fdocker%2Fx86_64-gnu-make%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fci%2Fdocker%2Fx86_64-gnu-make%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-make%2FDockerfile?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -7,14 +7,13 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   curl \\\n   ca-certificates \\\n   python2.7 \\\n-  python-minimal \\\n   git \\\n   cmake \\\n   ccache \\\n   sudo \\\n   gdb\n \n-ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu --enable-rustbuild\n+ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu --disable-rustbuild\n ENV RUST_CHECK_TARGET check\n RUN mkdir /tmp/obj\n RUN chmod 777 /tmp/obj", "previous_filename": "src/ci/docker/x86_64-gnu-rustbuild/Dockerfile"}, {"sha": "967940fb1f3ae093b2caf604f9e2ac95d856816a", "filename": "src/ci/docker/x86_64-musl/Dockerfile", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fci%2Fdocker%2Fx86_64-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fci%2Fdocker%2Fx86_64-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-musl%2FDockerfile?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -20,8 +20,10 @@ RUN sh /build/build-musl.sh && rm -rf /build\n \n ENV RUST_CONFIGURE_ARGS \\\n       --target=x86_64-unknown-linux-musl \\\n-      --musl-root=/musl-x86_64\n+      --musl-root-x86_64=/musl-x86_64\n ENV RUST_CHECK_TARGET check-stage2-T-x86_64-unknown-linux-musl-H-x86_64-unknown-linux-gnu\n+ENV PATH=$PATH:/musl-x86_64/bin\n+ENV XPY_CHECK test --target x86_64-unknown-linux-musl\n \n RUN mkdir /tmp/obj\n RUN chmod 777 /tmp/obj"}, {"sha": "10f2d15da343c08cba2670cfb8f54efb8befec33", "filename": "src/ci/run.sh", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -14,12 +14,20 @@ set -e\n if [ \"$LOCAL_USER_ID\" != \"\" ]; then\n   useradd --shell /bin/bash -u $LOCAL_USER_ID -o -c \"\" -m user\n   export HOME=/home/user\n-  export LOCAL_USER_ID=\n-  exec sudo -E -u user env PATH=$PATH \"$0\"\n+  unset LOCAL_USER_ID\n+  exec su --preserve-environment -c \"env PATH=$PATH \\\"$0\\\"\" user\n fi\n \n if [ \"$NO_LLVM_ASSERTIONS\" = \"\" ]; then\n-  LLVM_ASSERTIONS=--enable-llvm-assertions\n+  ENABLE_LLVM_ASSERTIONS=--enable-llvm-assertions\n+fi\n+\n+if [ \"$NO_VENDOR\" = \"\" ]; then\n+  ENABLE_VENDOR=--enable-vendor\n+fi\n+\n+if [ \"$NO_CCACHE\" = \"\" ]; then\n+  ENABLE_CCACHE=--enable-ccache\n fi\n \n set -ex\n@@ -28,9 +36,9 @@ $SRC/configure \\\n   --disable-manage-submodules \\\n   --enable-debug-assertions \\\n   --enable-quiet-tests \\\n-  --enable-ccache \\\n-  --enable-vendor \\\n-  $LLVM_ASSERTIONS \\\n+  $ENABLE_CCACHE \\\n+  $ENABLE_VENDOR \\\n+  $ENABLE_LLVM_ASSERTIONS \\\n   $RUST_CONFIGURE_ARGS\n \n if [ \"$TRAVIS_OS_NAME\" = \"osx\" ]; then\n@@ -41,4 +49,8 @@ fi\n \n make -j $ncpus tidy\n make -j $ncpus\n-exec make $RUST_CHECK_TARGET -j $ncpus\n+if [ ! -z \"$XPY_CHECK\" ]; then\n+  exec python2.7 $SRC/x.py $XPY_CHECK\n+else\n+  exec make $RUST_CHECK_TARGET -j $ncpus\n+fi"}, {"sha": "a8fc4c169fac43a5dc204d4fd56ddb1739f8c178", "filename": "src/compiler-rt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiler-rt?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -1 +1 @@\n-Subproject commit 3bc0272cab9fdcfc2ef4df9625ec3c9d5909db79\n+Subproject commit a8fc4c169fac43a5dc204d4fd56ddb1739f8c178"}, {"sha": "b53af694428da2648c9d4c8be9aeaf3a2ff08b7b", "filename": "src/doc/book/ffi.md", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fdoc%2Fbook%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fdoc%2Fbook%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fffi.md?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -662,26 +662,31 @@ attribute turns off Rust's name mangling, so that it is easier to link to.\n \n It\u2019s important to be mindful of `panic!`s when working with FFI. A `panic!`\n across an FFI boundary is undefined behavior. If you\u2019re writing code that may\n-panic, you should run it in another thread, so that the panic doesn\u2019t bubble up\n-to C:\n+panic, you should run it in a closure with [`catch_unwind()`]:\n \n ```rust\n-use std::thread;\n+use std::panic::catch_unwind;\n \n #[no_mangle]\n pub extern fn oh_no() -> i32 {\n-    let h = thread::spawn(|| {\n+    let result = catch_unwind(|| {\n         panic!(\"Oops!\");\n     });\n-\n-    match h.join() {\n-        Ok(_) => 1,\n-        Err(_) => 0,\n+    match result {\n+        Ok(_) => 0,\n+        Err(_) => 1,\n     }\n }\n-# fn main() {}\n+\n+fn main() {}\n ```\n \n+Please note that [`catch_unwind()`] will only catch unwinding panics, not\n+those who abort the process. See the documentation of [`catch_unwind()`]\n+for more information.\n+\n+[`catch_unwind()`]: https://doc.rust-lang.org/std/panic/fn.catch_unwind.html\n+\n # Representing opaque structs\n \n Sometimes, a C library wants to provide a pointer to something, but not let you"}, {"sha": "ebeb9923197a9aca4a680f15670b47032f56b324", "filename": "src/doc/book/testing.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fdoc%2Fbook%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fdoc%2Fbook%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ftesting.md?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -589,11 +589,11 @@ please see the [Documentation chapter](documentation.html).\n \n # Testing and concurrency\n \n-One thing that is important to note when writing tests are run concurrently\n-using threads. For this reason you should take care that your tests are written\n-in such a way as to not depend on each-other, or on any shared state. \"Shared\n-state\" can also include the environment, such as the current working directory,\n-or environment variables.\n+One thing that is important to note when writing tests is that they may be run\n+concurrently using threads. For this reason you should take care that your tests\n+are written in such a way as to not depend on each-other, or on any shared\n+state. \"Shared state\" can also include the environment, such as the current\n+working directory, or environment variables.\n \n If this is an issue it is possible to control this concurrency, either by\n setting the environment variable `RUST_TEST_THREADS`, or by passing the argument"}, {"sha": "37b6c0513fc9647feef5562e6e31158e66e4c6bd", "filename": "src/doc/book/variable-bindings.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fdoc%2Fbook%2Fvariable-bindings.md", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fdoc%2Fbook%2Fvariable-bindings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fvariable-bindings.md?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -47,7 +47,7 @@ let x: i32 = 5;\n ```\n \n If I asked you to read this out loud to the rest of the class, you\u2019d say \u201c`x`\n-is a binding with the type `i32` and the value `five`.\u201d\n+is a binding with the type `i32` and the value `5`.\u201d\n \n In this case we chose to represent `x` as a 32-bit signed integer. Rust has\n many different primitive integer types. They begin with `i` for signed integers"}, {"sha": "71dfcf0b067ec2395b45fb0652b36036d1dd6e7f", "filename": "src/doc/index.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -17,7 +17,7 @@ the language.\n \n [**The Rust Reference**][ref]. While Rust does not have a\n specification, the reference tries to describe its working in\n-detail. It tends to be out of date.\n+detail. It is accurate, but not necessarily complete.\n \n [**Standard Library API Reference**][api]. Documentation for the\n standard library."}, {"sha": "bf286aaec4bb34631366b5d224bfa949f3a54fb7", "filename": "src/doc/reference.md", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -603,7 +603,8 @@ syntax named by _designator_. Valid designators are:\n * `ty`: a [type](#types)\n * `ident`: an [identifier](#identifiers)\n * `path`: a [path](#paths)\n-* `tt`: either side of the `=>` in macro rules\n+* `tt`: a token tree (a single [token](#tokens) or a sequence of token trees surrounded\n+  by matching `()`, `[]`, or `{}`)\n * `meta`: the contents of an [attribute](#attributes)\n \n In the transcriber, the\n@@ -740,13 +741,14 @@ There are several kinds of item:\n * [`extern crate` declarations](#extern-crate-declarations)\n * [`use` declarations](#use-declarations)\n * [modules](#modules)\n-* [functions](#functions)\n+* [function definitions](#functions)\n+* [`extern` blocks](#external-blocks)\n * [type definitions](grammar.html#type-definitions)\n-* [structs](#structs)\n-* [enumerations](#enumerations)\n+* [struct definitions](#structs)\n+* [enumeration definitions](#enumerations)\n * [constant items](#constant-items)\n * [static items](#static-items)\n-* [traits](#traits)\n+* [trait definitions](#traits)\n * [implementations](#implementations)\n \n Some items form an implicit scope for the declaration of sub-items. In other\n@@ -2462,11 +2464,6 @@ The currently implemented features of the reference compiler are:\n * `unboxed_closures` - Rust's new closure design, which is currently a work in\n                        progress feature with many known bugs.\n \n-* `unmarked_api` - Allows use of items within a `#![staged_api]` crate\n-                   which have not been marked with a stability marker.\n-                   Such items should not be allowed by the compiler to exist,\n-                   so if you need this there probably is a compiler bug.\n-\n * `allow_internal_unstable` - Allows `macro_rules!` macros to be tagged with the\n                               `#[allow_internal_unstable]` attribute, designed\n                               to allow `std` macros to call"}, {"sha": "6642da858e551e2be5b4d6e552e3d4df58c1dfdd", "filename": "src/etc/generate-deriving-span-tests.py", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fetc%2Fgenerate-deriving-span-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fetc%2Fgenerate-deriving-span-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-deriving-span-tests.py?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -37,8 +37,6 @@\n \n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n-extern crate rand;\n-\n {error_deriving}\n struct Error;\n {code}\n@@ -106,7 +104,6 @@ def write_file(name, string):\n ALL = STRUCT | ENUM\n \n traits = {\n-    'Zero': (STRUCT, [], 1),\n     'Default': (STRUCT, [], 1),\n     'FromPrimitive': (0, [], 0), # only works for C-like enums\n \n@@ -116,7 +113,7 @@ def write_file(name, string):\n \n for (trait, supers, errs) in [('Clone', [], 1),\n                               ('PartialEq', [], 2),\n-                              ('PartialOrd', ['PartialEq'], 8),\n+                              ('PartialOrd', ['PartialEq'], 9),\n                               ('Eq', ['PartialEq'], 1),\n                               ('Ord', ['Eq', 'PartialOrd', 'PartialEq'], 1),\n                               ('Debug', [], 1),"}, {"sha": "919fc98e438c52a0ceb21bf41f38d2fecd48a274", "filename": "src/grammar/verify.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fgrammar%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fgrammar%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fverify.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -23,23 +23,23 @@ use std::fs::File;\n use std::io::{BufRead, Read};\n use std::path::Path;\n \n-use syntax::parse;\n use syntax::parse::lexer;\n use rustc::dep_graph::DepGraph;\n use rustc::session::{self, config};\n use rustc::middle::cstore::DummyCrateStore;\n \n use std::rc::Rc;\n use syntax::ast;\n-use syntax::ast::Name;\n use syntax::codemap;\n use syntax::parse::token::{self, BinOpToken, DelimToken, Lit, Token};\n use syntax::parse::lexer::TokenAndSpan;\n use syntax_pos::Pos;\n \n+use syntax::symbol::{Symbol, keywords};\n+\n fn parse_token_list(file: &str) -> HashMap<String, token::Token> {\n     fn id() -> token::Token {\n-        Token::Ident(ast::Ident::with_empty_ctxt(Name(0)))\n+        Token::Ident(ast::Ident::with_empty_ctxt(keywords::Invalid.name()))\n     }\n \n     let mut res = HashMap::new();\n@@ -65,7 +65,7 @@ fn parse_token_list(file: &str) -> HashMap<String, token::Token> {\n             \"SHL\"               => Token::BinOp(BinOpToken::Shl),\n             \"LBRACE\"            => Token::OpenDelim(DelimToken::Brace),\n             \"RARROW\"            => Token::RArrow,\n-            \"LIT_STR\"           => Token::Literal(Lit::Str_(Name(0)), None),\n+            \"LIT_STR\"           => Token::Literal(Lit::Str_(keywords::Invalid.name()), None),\n             \"DOTDOT\"            => Token::DotDot,\n             \"MOD_SEP\"           => Token::ModSep,\n             \"DOTDOTDOT\"         => Token::DotDotDot,\n@@ -75,21 +75,22 @@ fn parse_token_list(file: &str) -> HashMap<String, token::Token> {\n             \"ANDAND\"            => Token::AndAnd,\n             \"AT\"                => Token::At,\n             \"LBRACKET\"          => Token::OpenDelim(DelimToken::Bracket),\n-            \"LIT_STR_RAW\"       => Token::Literal(Lit::StrRaw(Name(0), 0), None),\n+            \"LIT_STR_RAW\"       => Token::Literal(Lit::StrRaw(keywords::Invalid.name(), 0), None),\n             \"RPAREN\"            => Token::CloseDelim(DelimToken::Paren),\n             \"SLASH\"             => Token::BinOp(BinOpToken::Slash),\n             \"COMMA\"             => Token::Comma,\n-            \"LIFETIME\"          => Token::Lifetime(ast::Ident::with_empty_ctxt(Name(0))),\n+            \"LIFETIME\"          => Token::Lifetime(\n+                                            ast::Ident::with_empty_ctxt(keywords::Invalid.name())),\n             \"CARET\"             => Token::BinOp(BinOpToken::Caret),\n             \"TILDE\"             => Token::Tilde,\n             \"IDENT\"             => id(),\n             \"PLUS\"              => Token::BinOp(BinOpToken::Plus),\n-            \"LIT_CHAR\"          => Token::Literal(Lit::Char(Name(0)), None),\n-            \"LIT_BYTE\"          => Token::Literal(Lit::Byte(Name(0)), None),\n+            \"LIT_CHAR\"          => Token::Literal(Lit::Char(keywords::Invalid.name()), None),\n+            \"LIT_BYTE\"          => Token::Literal(Lit::Byte(keywords::Invalid.name()), None),\n             \"EQ\"                => Token::Eq,\n             \"RBRACKET\"          => Token::CloseDelim(DelimToken::Bracket),\n             \"COMMENT\"           => Token::Comment,\n-            \"DOC_COMMENT\"       => Token::DocComment(Name(0)),\n+            \"DOC_COMMENT\"       => Token::DocComment(keywords::Invalid.name()),\n             \"DOT\"               => Token::Dot,\n             \"EQEQ\"              => Token::EqEq,\n             \"NE\"                => Token::Ne,\n@@ -99,9 +100,9 @@ fn parse_token_list(file: &str) -> HashMap<String, token::Token> {\n             \"BINOP\"             => Token::BinOp(BinOpToken::Plus),\n             \"POUND\"             => Token::Pound,\n             \"OROR\"              => Token::OrOr,\n-            \"LIT_INTEGER\"       => Token::Literal(Lit::Integer(Name(0)), None),\n+            \"LIT_INTEGER\"       => Token::Literal(Lit::Integer(keywords::Invalid.name()), None),\n             \"BINOPEQ\"           => Token::BinOpEq(BinOpToken::Plus),\n-            \"LIT_FLOAT\"         => Token::Literal(Lit::Float(Name(0)), None),\n+            \"LIT_FLOAT\"         => Token::Literal(Lit::Float(keywords::Invalid.name()), None),\n             \"WHITESPACE\"        => Token::Whitespace,\n             \"UNDERSCORE\"        => Token::Underscore,\n             \"MINUS\"             => Token::BinOp(BinOpToken::Minus),\n@@ -111,10 +112,11 @@ fn parse_token_list(file: &str) -> HashMap<String, token::Token> {\n             \"OR\"                => Token::BinOp(BinOpToken::Or),\n             \"GT\"                => Token::Gt,\n             \"LE\"                => Token::Le,\n-            \"LIT_BINARY\"        => Token::Literal(Lit::ByteStr(Name(0)), None),\n-            \"LIT_BINARY_RAW\"    => Token::Literal(Lit::ByteStrRaw(Name(0), 0), None),\n+            \"LIT_BINARY\"        => Token::Literal(Lit::ByteStr(keywords::Invalid.name()), None),\n+            \"LIT_BINARY_RAW\"    => Token::Literal(\n+                                            Lit::ByteStrRaw(keywords::Invalid.name(), 0), None),\n             \"QUESTION\"          => Token::Question,\n-            \"SHEBANG\"           => Token::Shebang(Name(0)),\n+            \"SHEBANG\"           => Token::Shebang(keywords::Invalid.name()),\n             _                   => continue,\n         };\n \n@@ -158,7 +160,7 @@ fn fix(mut lit: &str) -> ast::Name {\n     let leading_hashes = count(lit);\n \n     // +1/-1 to adjust for single quotes\n-    parse::token::intern(&lit[leading_hashes + 1..lit.len() - leading_hashes - 1])\n+    Symbol::intern(&lit[leading_hashes + 1..lit.len() - leading_hashes - 1])\n }\n \n /// Assuming a char/byte literal, strip the 'b' prefix and the single quotes.\n@@ -168,7 +170,7 @@ fn fixchar(mut lit: &str) -> ast::Name {\n         lit = &lit[1..];\n     }\n \n-    parse::token::intern(&lit[1..lit.len() - 1])\n+    Symbol::intern(&lit[1..lit.len() - 1])\n }\n \n fn count(lit: &str) -> usize {\n@@ -196,7 +198,7 @@ fn parse_antlr_token(s: &str, tokens: &HashMap<String, token::Token>, surrogate_\n     let not_found = format!(\"didn't find token {:?} in the map\", toknum);\n     let proto_tok = tokens.get(toknum).expect(&not_found[..]);\n \n-    let nm = parse::token::intern(content);\n+    let nm = Symbol::intern(content);\n \n     debug!(\"What we got: content (`{}`), proto: {:?}\", content, proto_tok);\n "}, {"sha": "addb056f53429f38511b0d63d0d0b691b60f4f99", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -524,6 +524,9 @@ impl<I: Iterator + ?Sized> Iterator for Box<I> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (**self).size_hint()\n     }\n+    fn nth(&mut self, n: usize) -> Option<I::Item> {\n+        (**self).nth(n)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for Box<I> {\n@@ -532,7 +535,14 @@ impl<I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for Box<I> {\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I: ExactSizeIterator + ?Sized> ExactSizeIterator for Box<I> {}\n+impl<I: ExactSizeIterator + ?Sized> ExactSizeIterator for Box<I> {\n+    fn len(&self) -> usize {\n+        (**self).len()\n+    }\n+    fn is_empty(&self) -> bool {\n+        (**self).is_empty()\n+    }\n+}\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<I: FusedIterator + ?Sized> FusedIterator for Box<I> {}"}, {"sha": "f9dfdc0e0753632ad0340a0cb07e96fb4dfdb4a5", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -74,11 +74,13 @@\n \n #![feature(allocator)]\n #![feature(box_syntax)]\n+#![feature(cfg_target_has_atomic)]\n #![feature(coerce_unsized)]\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n #![feature(custom_attribute)]\n #![feature(dropck_parametricity)]\n+#![cfg_attr(not(test), feature(exact_size_is_empty))]\n #![feature(fundamental)]\n #![feature(lang_items)]\n #![feature(needs_allocator)]\n@@ -121,6 +123,7 @@ mod boxed {\n }\n #[cfg(test)]\n mod boxed_test;\n+#[cfg(target_has_atomic = \"ptr\")]\n pub mod arc;\n pub mod rc;\n pub mod raw_vec;"}, {"sha": "3640156fec2ae2fc3bcc07a5bf0fb17ad13af169", "filename": "src/liballoc/oom.rs", "status": "modified", "additions": 34, "deletions": 15, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fliballoc%2Foom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fliballoc%2Foom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Foom.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -8,12 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::sync::atomic::{AtomicPtr, Ordering};\n-use core::mem;\n+#[cfg(target_has_atomic = \"ptr\")]\n+pub use self::imp::set_oom_handler;\n use core::intrinsics;\n \n-static OOM_HANDLER: AtomicPtr<()> = AtomicPtr::new(default_oom_handler as *mut ());\n-\n fn default_oom_handler() -> ! {\n     // The default handler can't do much more since we can't assume the presence\n     // of libc or any way of printing an error message.\n@@ -26,17 +24,38 @@ fn default_oom_handler() -> ! {\n #[unstable(feature = \"oom\", reason = \"not a scrutinized interface\",\n            issue = \"27700\")]\n pub fn oom() -> ! {\n-    let value = OOM_HANDLER.load(Ordering::SeqCst);\n-    let handler: fn() -> ! = unsafe { mem::transmute(value) };\n-    handler();\n+    self::imp::oom()\n }\n \n-/// Set a custom handler for out-of-memory conditions\n-///\n-/// To avoid recursive OOM failures, it is critical that the OOM handler does\n-/// not allocate any memory itself.\n-#[unstable(feature = \"oom\", reason = \"not a scrutinized interface\",\n-           issue = \"27700\")]\n-pub fn set_oom_handler(handler: fn() -> !) {\n-    OOM_HANDLER.store(handler as *mut (), Ordering::SeqCst);\n+#[cfg(target_has_atomic = \"ptr\")]\n+mod imp {\n+    use core::mem;\n+    use core::sync::atomic::{AtomicPtr, Ordering};\n+\n+    static OOM_HANDLER: AtomicPtr<()> = AtomicPtr::new(super::default_oom_handler as *mut ());\n+\n+    #[inline(always)]\n+    pub fn oom() -> ! {\n+        let value = OOM_HANDLER.load(Ordering::SeqCst);\n+        let handler: fn() -> ! = unsafe { mem::transmute(value) };\n+        handler();\n+    }\n+\n+    /// Set a custom handler for out-of-memory conditions\n+    ///\n+    /// To avoid recursive OOM failures, it is critical that the OOM handler does\n+    /// not allocate any memory itself.\n+    #[unstable(feature = \"oom\", reason = \"not a scrutinized interface\",\n+               issue = \"27700\")]\n+    pub fn set_oom_handler(handler: fn() -> !) {\n+        OOM_HANDLER.store(handler as *mut (), Ordering::SeqCst);\n+    }\n+}\n+\n+#[cfg(not(target_has_atomic = \"ptr\"))]\n+mod imp {\n+    #[inline(always)]\n+    pub fn oom() -> ! {\n+        super::default_oom_handler()\n+    }\n }"}, {"sha": "d1e0e333b8f3aa7b538779e0d0ff4b9526f5e842", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 45, "deletions": 43, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -12,35 +12,35 @@\n \n //! Single-threaded reference-counting pointers.\n //!\n-//! The type [`Rc<T>`][rc] provides shared ownership of a value of type `T`,\n-//! allocated in the heap. Invoking [`clone`][clone] on `Rc` produces a new\n-//! pointer to the same value in the heap. When the last `Rc` pointer to a\n+//! The type [`Rc<T>`][`Rc`] provides shared ownership of a value of type `T`,\n+//! allocated in the heap. Invoking [`clone()`][clone] on [`Rc`] produces a new\n+//! pointer to the same value in the heap. When the last [`Rc`] pointer to a\n //! given value is destroyed, the pointed-to value is also destroyed.\n //!\n //! Shared references in Rust disallow mutation by default, and `Rc` is no\n-//! exception. If you need to mutate through an `Rc`, use [`Cell`][cell] or\n-//! [`RefCell`][refcell].\n+//! exception. If you need to mutate through an [`Rc`], use [`Cell`] or\n+//! [`RefCell`].\n //!\n-//! `Rc` uses non-atomic reference counting. This means that overhead is very\n-//! low, but an `Rc` cannot be sent between threads, and consequently `Rc`\n+//! [`Rc`] uses non-atomic reference counting. This means that overhead is very\n+//! low, but an [`Rc`] cannot be sent between threads, and consequently [`Rc`]\n //! does not implement [`Send`][send]. As a result, the Rust compiler\n-//! will check *at compile time* that you are not sending `Rc`s between\n+//! will check *at compile time* that you are not sending [`Rc`]s between\n //! threads. If you need multi-threaded, atomic reference counting, use\n //! [`sync::Arc`][arc].\n //!\n-//! The [`downgrade`][downgrade] method can be used to create a non-owning\n-//! [`Weak`][weak] pointer. A `Weak` pointer can be [`upgrade`][upgrade]d\n-//! to an `Rc`, but this will return [`None`][option] if the value has\n+//! The [`downgrade()`][downgrade] method can be used to create a non-owning\n+//! [`Weak`] pointer. A [`Weak`] pointer can be [`upgrade`][upgrade]d\n+//! to an [`Rc`], but this will return [`None`] if the value has\n //! already been dropped.\n //!\n-//! A cycle between `Rc` pointers will never be deallocated. For this reason,\n-//! `Weak` is used to break cycles. For example, a tree could have strong\n-//! `Rc` pointers from parent nodes to children, and `Weak` pointers from\n+//! A cycle between [`Rc`] pointers will never be deallocated. For this reason,\n+//! [`Weak`] is used to break cycles. For example, a tree could have strong\n+//! [`Rc`] pointers from parent nodes to children, and [`Weak`] pointers from\n //! children back to their parents.\n //!\n-//! `Rc<T>` automatically dereferences to `T` (via the [`Deref`][deref] trait),\n-//! so you can call `T`'s methods on a value of type `Rc<T>`. To avoid name\n-//! clashes with `T`'s methods, the methods of `Rc<T>` itself are [associated\n+//! `Rc<T>` automatically dereferences to `T` (via the [`Deref`] trait),\n+//! so you can call `T`'s methods on a value of type [`Rc<T>`][`Rc`]. To avoid name\n+//! clashes with `T`'s methods, the methods of [`Rc<T>`][`Rc`] itself are [associated\n //! functions][assoc], called using function-like syntax:\n //!\n //! ```\n@@ -50,28 +50,15 @@\n //! Rc::downgrade(&my_rc);\n //! ```\n //!\n-//! `Weak<T>` does not auto-dereference to `T`, because the value may have\n+//! [`Weak<T>`][`Weak`] does not auto-dereference to `T`, because the value may have\n //! already been destroyed.\n //!\n-//! [rc]: struct.Rc.html\n-//! [weak]: struct.Weak.html\n-//! [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n-//! [cell]: ../../std/cell/struct.Cell.html\n-//! [refcell]: ../../std/cell/struct.RefCell.html\n-//! [send]: ../../std/marker/trait.Send.html\n-//! [arc]: ../../std/sync/struct.Arc.html\n-//! [deref]: ../../std/ops/trait.Deref.html\n-//! [downgrade]: struct.Rc.html#method.downgrade\n-//! [upgrade]: struct.Weak.html#method.upgrade\n-//! [option]: ../../std/option/enum.Option.html\n-//! [assoc]: ../../book/method-syntax.html#associated-functions\n-//!\n //! # Examples\n //!\n //! Consider a scenario where a set of `Gadget`s are owned by a given `Owner`.\n //! We want to have our `Gadget`s point to their `Owner`. We can't do this with\n //! unique ownership, because more than one gadget may belong to the same\n-//! `Owner`. `Rc` allows us to share an `Owner` between multiple `Gadget`s,\n+//! `Owner`. [`Rc`] allows us to share an `Owner` between multiple `Gadget`s,\n //! and have the `Owner` remain allocated as long as any `Gadget` points at it.\n //!\n //! ```\n@@ -127,20 +114,20 @@\n //! ```\n //!\n //! If our requirements change, and we also need to be able to traverse from\n-//! `Owner` to\u00a0`Gadget`, we will run into problems. An `Rc` pointer from `Owner`\n+//! `Owner` to\u00a0`Gadget`, we will run into problems. An [`Rc`] pointer from `Owner`\n //! to `Gadget` introduces a cycle between the values. This means that their\n //! reference counts can never reach 0, and the values will remain allocated\n-//! forever: a memory leak. In order to get around this, we can use `Weak`\n+//! forever: a memory leak. In order to get around this, we can use [`Weak`]\n //! pointers.\n //!\n //! Rust actually makes it somewhat difficult to produce this loop in the first\n //! place. In order to end up with two values that point at each other, one of\n-//! them needs to be mutable. This is difficult because `Rc` enforces\n+//! them needs to be mutable. This is difficult because [`Rc`] enforces\n //! memory safety by only giving out shared references to the value it wraps,\n //! and these don't allow direct mutation. We need to wrap the part of the\n-//! value we wish to mutate in a [`RefCell`][refcell], which provides *interior\n+//! value we wish to mutate in a [`RefCell`], which provides *interior\n //! mutability*: a method to achieve mutability through a shared reference.\n-//! `RefCell` enforces Rust's borrowing rules at runtime.\n+//! [`RefCell`] enforces Rust's borrowing rules at runtime.\n //!\n //! ```\n //! use std::rc::Rc;\n@@ -214,6 +201,19 @@\n //!     // Gadget Man, so he gets destroyed as well.\n //! }\n //! ```\n+//!\n+//! [`Rc`]: struct.Rc.html\n+//! [`Weak`]: struct.Weak.html\n+//! [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n+//! [`Cell`]: ../../std/cell/struct.Cell.html\n+//! [`RefCell`]: ../../std/cell/struct.RefCell.html\n+//! [send]: ../../std/marker/trait.Send.html\n+//! [arc]: ../../std/sync/struct.Arc.html\n+//! [`Deref`]: ../../std/ops/trait.Deref.html\n+//! [downgrade]: struct.Rc.html#method.downgrade\n+//! [upgrade]: struct.Weak.html#method.upgrade\n+//! [`None`]: ../../std/option/enum.Option.html#variant.None\n+//! [assoc]: ../../book/method-syntax.html#associated-functions\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -251,9 +251,11 @@ struct RcBox<T: ?Sized> {\n /// See the [module-level documentation](./index.html) for more details.\n ///\n /// The inherent methods of `Rc` are all associated functions, which means\n-/// that you have to call them as e.g. `Rc::get_mut(&value)` instead of\n-/// `value.get_mut()`.  This avoids conflicts with methods of the inner\n+/// that you have to call them as e.g. [`Rc::get_mut(&value)`][get_mut] instead of\n+/// `value.get_mut()`. This avoids conflicts with methods of the inner\n /// type `T`.\n+///\n+/// [get_mut]: #method.get_mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Rc<T: ?Sized> {\n     ptr: Shared<RcBox<T>>,\n@@ -337,10 +339,10 @@ impl<T> Rc<T> {\n     }\n \n     /// Checks whether [`Rc::try_unwrap`][try_unwrap] would return\n-    /// [`Ok`][result].\n+    /// [`Ok`].\n     ///\n     /// [try_unwrap]: struct.Rc.html#method.try_unwrap\n-    /// [result]: ../../std/result/enum.Result.html\n+    /// [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n     ///\n     /// # Examples\n     ///\n@@ -543,14 +545,14 @@ impl<T: ?Sized> Rc<T> {\n     /// Returns a mutable reference to the inner value, if there are\n     /// no other `Rc` or [`Weak`][weak] pointers to the same value.\n     ///\n-    /// Returns [`None`][option] otherwise, because it is not safe to\n+    /// Returns [`None`] otherwise, because it is not safe to\n     /// mutate a shared value.\n     ///\n     /// See also [`make_mut`][make_mut], which will [`clone`][clone]\n     /// the inner value when it's shared.\n     ///\n     /// [weak]: struct.Weak.html\n-    /// [option]: ../../std/option/enum.Option.html\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n     /// [make_mut]: struct.Rc.html#method.make_mut\n     /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n     ///"}, {"sha": "fc849e7a50cc40abda3fbdcff2b756189d8a2057", "filename": "src/liballoc_jemalloc/build.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fliballoc_jemalloc%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Fliballoc_jemalloc%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Fbuild.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -69,6 +69,7 @@ fn main() {\n         .read_dir()\n         .unwrap()\n         .map(|e| e.unwrap())\n+        .filter(|e| &*e.file_name() != \".git\")\n         .collect::<Vec<_>>();\n     while let Some(entry) = stack.pop() {\n         let path = entry.path();\n@@ -150,11 +151,17 @@ fn main() {\n     cmd.arg(format!(\"--build={}\", build_helper::gnu_target(&host)));\n \n     run(&mut cmd);\n-    run(Command::new(\"make\")\n-        .current_dir(&build_dir)\n-        .arg(\"build_lib_static\")\n-        .arg(\"-j\")\n-        .arg(env::var(\"NUM_JOBS\").expect(\"NUM_JOBS was not set\")));\n+    let mut make = Command::new(\"make\");\n+    make.current_dir(&build_dir)\n+        .arg(\"build_lib_static\");\n+\n+    // mingw make seems... buggy? unclear...\n+    if !host.contains(\"windows\") {\n+        make.arg(\"-j\")\n+            .arg(env::var(\"NUM_JOBS\").expect(\"NUM_JOBS was not set\"));\n+    }\n+\n+    run(&mut make);\n \n     if target.contains(\"windows\") {\n         println!(\"cargo:rustc-link-lib=static=jemalloc\");"}, {"sha": "ab882fde9c2775683f0b63f48f3cc843232a319e", "filename": "src/libcollections/Cargo.toml", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcollections%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcollections%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2FCargo.toml?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -10,8 +10,12 @@ path = \"lib.rs\"\n [dependencies]\n alloc = { path = \"../liballoc\" }\n core = { path = \"../libcore\" }\n-rustc_unicode = { path = \"../librustc_unicode\" }\n+std_unicode = { path = \"../libstd_unicode\" }\n \n [[test]]\n name = \"collectionstest\"\n path = \"../libcollectionstest/lib.rs\"\n+\n+[[bench]]\n+name = \"collectionstest\"\n+path = \"../libcollectionstest/lib.rs\""}, {"sha": "8d0c76c36468c86028de4bfd0f772b7bbddc5206", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -986,7 +986,11 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n+impl<'a, T> ExactSizeIterator for Iter<'a, T> {\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T> FusedIterator for Iter<'a, T> {}\n@@ -1022,7 +1026,11 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ExactSizeIterator for IntoIter<T> {}\n+impl<T> ExactSizeIterator for IntoIter<T> {\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<T> FusedIterator for IntoIter<T> {}\n@@ -1057,7 +1065,11 @@ impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> {\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {}\n+impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T: 'a> FusedIterator for Drain<'a, T> {}"}, {"sha": "79e0021b148a049f34e9f06a493cbd400ad618ea", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -16,7 +16,7 @@\n #![unstable(feature = \"enumset\",\n             reason = \"matches collection reform specification, \\\n                       waiting for dust to settle\",\n-            issue = \"0\")]\n+            issue = \"37966\")]\n \n use core::marker;\n use core::fmt;"}, {"sha": "68b067012d3fa72db822c122427a4fa21228484e", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -36,6 +36,7 @@\n #![cfg_attr(not(test), feature(char_escape_debug))]\n #![feature(core_intrinsics)]\n #![feature(dropck_parametricity)]\n+#![feature(exact_size_is_empty)]\n #![feature(fmt_internals)]\n #![feature(fused)]\n #![feature(heap_api)]\n@@ -46,18 +47,19 @@\n #![feature(placement_in)]\n #![feature(placement_new_protocol)]\n #![feature(shared)]\n+#![feature(slice_get_slice)]\n #![feature(slice_patterns)]\n #![feature(specialization)]\n #![feature(staged_api)]\n-#![feature(step_by)]\n #![feature(trusted_len)]\n #![feature(unicode)]\n #![feature(unique)]\n+#![feature(untagged_unions)]\n #![cfg_attr(test, feature(rand, test))]\n \n #![no_std]\n \n-extern crate rustc_unicode;\n+extern crate std_unicode;\n extern crate alloc;\n \n #[cfg(test)]"}, {"sha": "5fb8cd6e1e2b7a7b8b10f8135240c4629915b838", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 313, "deletions": 184, "changes": 497, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -98,8 +98,7 @@\n #![cfg_attr(test, allow(unused_imports, dead_code))]\n \n use alloc::boxed::Box;\n-use core::cmp::Ordering::{self, Greater, Less};\n-use core::cmp;\n+use core::cmp::Ordering::{self, Greater};\n use core::mem::size_of;\n use core::mem;\n use core::ptr;\n@@ -118,6 +117,8 @@ pub use core::slice::{SplitMut, ChunksMut, Split};\n pub use core::slice::{SplitN, RSplitN, SplitNMut, RSplitNMut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::slice::{from_raw_parts, from_raw_parts_mut};\n+#[unstable(feature = \"slice_get_slice\", issue = \"35729\")]\n+pub use core::slice::SliceIndex;\n \n ////////////////////////////////////////////////////////////////////////////////\n // Basic slice extension methods\n@@ -353,7 +354,9 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn get(&self, index: usize) -> Option<&T> {\n+    pub fn get<I>(&self, index: I) -> Option<&I::Output>\n+        where I: SliceIndex<T>\n+    {\n         core_slice::SliceExt::get(self, index)\n     }\n \n@@ -372,7 +375,9 @@ impl<T> [T] {\n     /// or `None` if the index is out of bounds\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn get_mut(&mut self, index: usize) -> Option<&mut T> {\n+    pub fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n+        where I: SliceIndex<T>\n+    {\n         core_slice::SliceExt::get_mut(self, index)\n     }\n \n@@ -390,7 +395,9 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub unsafe fn get_unchecked(&self, index: usize) -> &T {\n+    pub unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output\n+        where I: SliceIndex<T>\n+    {\n         core_slice::SliceExt::get_unchecked(self, index)\n     }\n \n@@ -410,7 +417,9 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub unsafe fn get_unchecked_mut(&mut self, index: usize) -> &mut T {\n+    pub unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n+        where I: SliceIndex<T>\n+    {\n         core_slice::SliceExt::get_unchecked_mut(self, index)\n     }\n \n@@ -1032,8 +1041,8 @@ impl<T> [T] {\n \n     /// This is equivalent to `self.sort_by(|a, b| a.cmp(b))`.\n     ///\n-    /// This sort is stable and `O(n log n)` worst-case but allocates\n-    /// approximately `2 * n` where `n` is the length of `self`.\n+    /// This sort is stable and `O(n log n)` worst-case, but allocates\n+    /// temporary storage half the size of `self`.\n     ///\n     /// # Examples\n     ///\n@@ -1054,8 +1063,8 @@ impl<T> [T] {\n     /// Sorts the slice, in place, using `f` to extract a key by which to\n     /// order the sort by.\n     ///\n-    /// This sort is stable and `O(n log n)` worst-case but allocates\n-    /// approximately `2 * n`, where `n` is the length of `self`.\n+    /// This sort is stable and `O(n log n)` worst-case, but allocates\n+    /// temporary storage half the size of `self`.\n     ///\n     /// # Examples\n     ///\n@@ -1076,8 +1085,8 @@ impl<T> [T] {\n     /// Sorts the slice, in place, using `compare` to compare\n     /// elements.\n     ///\n-    /// This sort is stable and `O(n log n)` worst-case but allocates\n-    /// approximately `2 * n`, where `n` is the length of `self`.\n+    /// This sort is stable and `O(n log n)` worst-case, but allocates\n+    /// temporary storage half the size of `self`.\n     ///\n     /// # Examples\n     ///\n@@ -1295,213 +1304,333 @@ impl<T: Clone> ToOwned for [T] {\n // Sorting\n ////////////////////////////////////////////////////////////////////////////////\n \n-fn insertion_sort<T, F>(v: &mut [T], mut compare: F)\n+/// Inserts `v[0]` into pre-sorted sequence `v[1..]` so that whole `v[..]` becomes sorted.\n+///\n+/// This is the integral subroutine of insertion sort.\n+fn insert_head<T, F>(v: &mut [T], compare: &mut F)\n     where F: FnMut(&T, &T) -> Ordering\n {\n-    let len = v.len() as isize;\n-    let buf_v = v.as_mut_ptr();\n-\n-    // 1 <= i < len;\n-    for i in 1..len {\n-        // j satisfies: 0 <= j <= i;\n-        let mut j = i;\n+    if v.len() >= 2 && compare(&v[0], &v[1]) == Greater {\n         unsafe {\n-            // `i` is in bounds.\n-            let read_ptr = buf_v.offset(i) as *const T;\n-\n-            // find where to insert, we need to do strict <,\n-            // rather than <=, to maintain stability.\n-\n-            // 0 <= j - 1 < len, so .offset(j - 1) is in bounds.\n-            while j > 0 && compare(&*read_ptr, &*buf_v.offset(j - 1)) == Less {\n-                j -= 1;\n+            // There are three ways to implement insertion here:\n+            //\n+            // 1. Swap adjacent elements until the first one gets to its final destination.\n+            //    However, this way we copy data around more than is necessary. If elements are big\n+            //    structures (costly to copy), this method will be slow.\n+            //\n+            // 2. Iterate until the right place for the first element is found. Then shift the\n+            //    elements succeeding it to make room for it and finally place it into the\n+            //    remaining hole. This is a good method.\n+            //\n+            // 3. Copy the first element into a temporary variable. Iterate until the right place\n+            //    for it is found. As we go along, copy every traversed element into the slot\n+            //    preceding it. Finally, copy data from the temporary variable into the remaining\n+            //    hole. This method is very good. Benchmarks demonstrated slightly better\n+            //    performance than with the 2nd method.\n+            //\n+            // All methods were benchmarked, and the 3rd showed best results. So we chose that one.\n+            let mut tmp = NoDrop { value: ptr::read(&v[0]) };\n+\n+            // Intermediate state of the insertion process is always tracked by `hole`, which\n+            // serves two purposes:\n+            // 1. Protects integrity of `v` from panics in `compare`.\n+            // 2. Fills the remaining hole in `v` in the end.\n+            //\n+            // Panic safety:\n+            //\n+            // If `compare` panics at any point during the process, `hole` will get dropped and\n+            // fill the hole in `v` with `tmp`, thus ensuring that `v` still holds every object it\n+            // initially held exactly once.\n+            let mut hole = InsertionHole {\n+                src: &mut tmp.value,\n+                dest: &mut v[1],\n+            };\n+            ptr::copy_nonoverlapping(&v[1], &mut v[0], 1);\n+\n+            for i in 2..v.len() {\n+                if compare(&tmp.value, &v[i]) != Greater {\n+                    break;\n+                }\n+                ptr::copy_nonoverlapping(&v[i], &mut v[i - 1], 1);\n+                hole.dest = &mut v[i];\n             }\n+            // `hole` gets dropped and thus copies `tmp` into the remaining hole in `v`.\n+        }\n+    }\n \n-            // shift everything to the right, to make space to\n-            // insert this value.\n+    // Holds a value, but never drops it.\n+    #[allow(unions_with_drop_fields)]\n+    union NoDrop<T> {\n+        value: T\n+    }\n \n-            // j + 1 could be `len` (for the last `i`), but in\n-            // that case, `i == j` so we don't copy. The\n-            // `.offset(j)` is always in bounds.\n+    // When dropped, copies from `src` into `dest`.\n+    struct InsertionHole<T> {\n+        src: *mut T,\n+        dest: *mut T,\n+    }\n \n-            if i != j {\n-                let tmp = ptr::read(read_ptr);\n-                ptr::copy(&*buf_v.offset(j), buf_v.offset(j + 1), (i - j) as usize);\n-                ptr::copy_nonoverlapping(&tmp, buf_v.offset(j), 1);\n-                mem::forget(tmp);\n-            }\n+    impl<T> Drop for InsertionHole<T> {\n+        fn drop(&mut self) {\n+            unsafe { ptr::copy_nonoverlapping(self.src, self.dest, 1); }\n         }\n     }\n }\n \n-fn merge_sort<T, F>(v: &mut [T], mut compare: F)\n+/// Merges non-decreasing runs `v[..mid]` and `v[mid..]` using `buf` as temporary storage, and\n+/// stores the result into `v[..]`.\n+///\n+/// # Safety\n+///\n+/// The two slices must be non-empty and `mid` must be in bounds. Buffer `buf` must be long enough\n+/// to hold a copy of the shorter slice. Also, `T` must not be a zero-sized type.\n+unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, compare: &mut F)\n     where F: FnMut(&T, &T) -> Ordering\n {\n-    // warning: this wildly uses unsafe.\n-    const BASE_INSERTION: usize = 32;\n-    const LARGE_INSERTION: usize = 16;\n-\n-    // FIXME #12092: smaller insertion runs seems to make sorting\n-    // vectors of large elements a little faster on some platforms,\n-    // but hasn't been tested/tuned extensively\n-    let insertion = if size_of::<T>() <= 16 {\n-        BASE_INSERTION\n+    let len = v.len();\n+    let v = v.as_mut_ptr();\n+    let v_mid = v.offset(mid as isize);\n+    let v_end = v.offset(len as isize);\n+\n+    // The merge process first copies the shorter run into `buf`. Then it traces the newly copied\n+    // run and the longer run forwards (or backwards), comparing their next unconsumed elements and\n+    // copying the lesser (or greater) one into `v`.\n+    //\n+    // As soon as the shorter run is fully consumed, the process is done. If the longer run gets\n+    // consumed first, then we must copy whatever is left of the shorter run into the remaining\n+    // hole in `v`.\n+    //\n+    // Intermediate state of the process is always tracked by `hole`, which serves two purposes:\n+    // 1. Protects integrity of `v` from panics in `compare`.\n+    // 2. Fills the remaining hole in `v` if the longer run gets consumed first.\n+    //\n+    // Panic safety:\n+    //\n+    // If `compare` panics at any point during the process, `hole` will get dropped and fill the\n+    // hole in `v` with the unconsumed range in `buf`, thus ensuring that `v` still holds every\n+    // object it initially held exactly once.\n+    let mut hole;\n+\n+    if mid <= len - mid {\n+        // The left run is shorter.\n+        ptr::copy_nonoverlapping(v, buf, mid);\n+        hole = MergeHole {\n+            start: buf,\n+            end: buf.offset(mid as isize),\n+            dest: v,\n+        };\n+\n+        // Initially, these pointers point to the beginnings of their arrays.\n+        let left = &mut hole.start;\n+        let mut right = v_mid;\n+        let out = &mut hole.dest;\n+\n+        while *left < hole.end && right < v_end {\n+            // Consume the lesser side.\n+            // If equal, prefer the left run to maintain stability.\n+            let to_copy = if compare(&**left, &*right) == Greater {\n+                get_and_increment(&mut right)\n+            } else {\n+                get_and_increment(left)\n+            };\n+            ptr::copy_nonoverlapping(to_copy, get_and_increment(out), 1);\n+        }\n     } else {\n-        LARGE_INSERTION\n-    };\n+        // The right run is shorter.\n+        ptr::copy_nonoverlapping(v_mid, buf, len - mid);\n+        hole = MergeHole {\n+            start: buf,\n+            end: buf.offset((len - mid) as isize),\n+            dest: v_mid,\n+        };\n+\n+        // Initially, these pointers point past the ends of their arrays.\n+        let left = &mut hole.dest;\n+        let right = &mut hole.end;\n+        let mut out = v_end;\n+\n+        while v < *left && buf < *right {\n+            // Consume the greater side.\n+            // If equal, prefer the right run to maintain stability.\n+            let to_copy = if compare(&*left.offset(-1), &*right.offset(-1)) == Greater {\n+                decrement_and_get(left)\n+            } else {\n+                decrement_and_get(right)\n+            };\n+            ptr::copy_nonoverlapping(to_copy, decrement_and_get(&mut out), 1);\n+        }\n+    }\n+    // Finally, `hole` gets dropped. If the shorter run was not fully consumed, whatever remains of\n+    // it will now be copied into the hole in `v`.\n \n-    let len = v.len();\n+    unsafe fn get_and_increment<T>(ptr: &mut *mut T) -> *mut T {\n+        let old = *ptr;\n+        *ptr = ptr.offset(1);\n+        old\n+    }\n \n-    // short vectors get sorted in-place via insertion sort to avoid allocations\n-    if len <= insertion {\n-        insertion_sort(v, compare);\n-        return;\n+    unsafe fn decrement_and_get<T>(ptr: &mut *mut T) -> *mut T {\n+        *ptr = ptr.offset(-1);\n+        *ptr\n     }\n \n-    // allocate some memory to use as scratch memory, we keep the\n-    // length 0 so we can keep shallow copies of the contents of `v`\n-    // without risking the dtors running on an object twice if\n-    // `compare` panics.\n-    let mut working_space = Vec::with_capacity(2 * len);\n-    // these both are buffers of length `len`.\n-    let mut buf_dat = working_space.as_mut_ptr();\n-    let mut buf_tmp = unsafe { buf_dat.offset(len as isize) };\n-\n-    // length `len`.\n-    let buf_v = v.as_ptr();\n-\n-    // step 1. sort short runs with insertion sort. This takes the\n-    // values from `v` and sorts them into `buf_dat`, leaving that\n-    // with sorted runs of length INSERTION.\n-\n-    // We could hardcode the sorting comparisons here, and we could\n-    // manipulate/step the pointers themselves, rather than repeatedly\n-    // .offset-ing.\n-    for start in (0..len).step_by(insertion) {\n-        // start <= i < len;\n-        for i in start..cmp::min(start + insertion, len) {\n-            // j satisfies: start <= j <= i;\n-            let mut j = i as isize;\n-            unsafe {\n-                // `i` is in bounds.\n-                let read_ptr = buf_v.offset(i as isize);\n+    // When dropped, copies the range `start..end` into `dest..`.\n+    struct MergeHole<T> {\n+        start: *mut T,\n+        end: *mut T,\n+        dest: *mut T,\n+    }\n \n-                // find where to insert, we need to do strict <,\n-                // rather than <=, to maintain stability.\n+    impl<T> Drop for MergeHole<T> {\n+        fn drop(&mut self) {\n+            // `T` is not a zero-sized type, so it's okay to divide by it's size.\n+            let len = (self.end as usize - self.start as usize) / mem::size_of::<T>();\n+            unsafe { ptr::copy_nonoverlapping(self.start, self.dest, len); }\n+        }\n+    }\n+}\n \n-                // start <= j - 1 < len, so .offset(j - 1) is in\n-                // bounds.\n-                while j > start as isize && compare(&*read_ptr, &*buf_dat.offset(j - 1)) == Less {\n-                    j -= 1;\n-                }\n+/// This merge sort borrows some (but not all) ideas from TimSort, which is described in detail\n+/// [here](http://svn.python.org/projects/python/trunk/Objects/listsort.txt).\n+///\n+/// The algorithm identifies strictly descending and non-descending subsequences, which are called\n+/// natural runs. There is a stack of pending runs yet to be merged. Each newly found run is pushed\n+/// onto the stack, and then some pairs of adjacent runs are merged until these two invariants are\n+/// satisfied, for every `i` in `0 .. runs.len() - 2`:\n+///\n+/// 1. `runs[i].len > runs[i + 1].len`\n+/// 2. `runs[i].len > runs[i + 1].len + runs[i + 2].len`\n+///\n+/// The invariants ensure that the total running time is `O(n log n)` worst-case.\n+fn merge_sort<T, F>(v: &mut [T], mut compare: F)\n+    where F: FnMut(&T, &T) -> Ordering\n+{\n+    // Sorting has no meaningful behavior on zero-sized types.\n+    if size_of::<T>() == 0 {\n+        return;\n+    }\n \n-                // shift everything to the right, to make space to\n-                // insert this value.\n+    // FIXME #12092: These numbers are platform-specific and need more extensive testing/tuning.\n+    //\n+    // If `v` has length up to `insertion_len`, simply switch to insertion sort because it is going\n+    // to perform better than merge sort. For bigger types `T`, the threshold is smaller.\n+    //\n+    // Short runs are extended using insertion sort to span at least `min_run` elements, in order\n+    // to improve performance.\n+    let (max_insertion, min_run) = if size_of::<T>() <= 16 {\n+        (64, 32)\n+    } else {\n+        (32, 16)\n+    };\n \n-                // j + 1 could be `len` (for the last `i`), but in\n-                // that case, `i == j` so we don't copy. The\n-                // `.offset(j)` is always in bounds.\n-                ptr::copy(&*buf_dat.offset(j), buf_dat.offset(j + 1), i - j as usize);\n-                ptr::copy_nonoverlapping(read_ptr, buf_dat.offset(j), 1);\n+    let len = v.len();\n+\n+    // Short arrays get sorted in-place via insertion sort to avoid allocations.\n+    if len <= max_insertion {\n+        if len >= 2 {\n+            for i in (0..len-1).rev() {\n+                insert_head(&mut v[i..], &mut compare);\n             }\n         }\n+        return;\n     }\n \n-    // step 2. merge the sorted runs.\n-    let mut width = insertion;\n-    while width < len {\n-        // merge the sorted runs of length `width` in `buf_dat` two at\n-        // a time, placing the result in `buf_tmp`.\n-\n-        // 0 <= start <= len.\n-        for start in (0..len).step_by(2 * width) {\n-            // manipulate pointers directly for speed (rather than\n-            // using a `for` loop with `range` and `.offset` inside\n-            // that loop).\n-            unsafe {\n-                // the end of the first run & start of the\n-                // second. Offset of `len` is defined, since this is\n-                // precisely one byte past the end of the object.\n-                let right_start = buf_dat.offset(cmp::min(start + width, len) as isize);\n-                // end of the second. Similar reasoning to the above re safety.\n-                let right_end_idx = cmp::min(start + 2 * width, len);\n-                let right_end = buf_dat.offset(right_end_idx as isize);\n-\n-                // the pointers to the elements under consideration\n-                // from the two runs.\n-\n-                // both of these are in bounds.\n-                let mut left = buf_dat.offset(start as isize);\n-                let mut right = right_start;\n-\n-                // where we're putting the results, it is a run of\n-                // length `2*width`, so we step it once for each step\n-                // of either `left` or `right`.  `buf_tmp` has length\n-                // `len`, so these are in bounds.\n-                let mut out = buf_tmp.offset(start as isize);\n-                let out_end = buf_tmp.offset(right_end_idx as isize);\n-\n-                // If left[last] <= right[0], they are already in order:\n-                // fast-forward the left side (the right side is handled\n-                // in the loop).\n-                // If `right` is not empty then left is not empty, and\n-                // the offsets are in bounds.\n-                if right != right_end && compare(&*right.offset(-1), &*right) != Greater {\n-                    let elems = (right_start as usize - left as usize) / mem::size_of::<T>();\n-                    ptr::copy_nonoverlapping(&*left, out, elems);\n-                    out = out.offset(elems as isize);\n-                    left = right_start;\n+    // Allocate a buffer to use as scratch memory. We keep the length 0 so we can keep in it\n+    // shallow copies of the contents of `v` without risking the dtors running on copies if\n+    // `compare` panics. When merging two sorted runs, this buffer holds a copy of the shorter run,\n+    // which will always have length at most `len / 2`.\n+    let mut buf = Vec::with_capacity(len / 2);\n+\n+    // In order to identify natural runs in `v`, we traverse it backwards. That might seem like a\n+    // strange decision, but consider the fact that merges more often go in the opposite direction\n+    // (forwards). According to benchmarks, merging forwards is slightly faster than merging\n+    // backwards. To conclude, identifying runs by traversing backwards improves performance.\n+    let mut runs = vec![];\n+    let mut end = len;\n+    while end > 0 {\n+        // Find the next natural run, and reverse it if it's strictly descending.\n+        let mut start = end - 1;\n+        if start > 0 {\n+            start -= 1;\n+            if compare(&v[start], &v[start + 1]) == Greater {\n+                while start > 0 && compare(&v[start - 1], &v[start]) == Greater {\n+                    start -= 1;\n                 }\n-\n-                while out < out_end {\n-                    // Either the left or the right run are exhausted,\n-                    // so just copy the remainder from the other run\n-                    // and move on; this gives a huge speed-up (order\n-                    // of 25%) for mostly sorted vectors (the best\n-                    // case).\n-                    if left == right_start {\n-                        // the number remaining in this run.\n-                        let elems = (right_end as usize - right as usize) / mem::size_of::<T>();\n-                        ptr::copy_nonoverlapping(&*right, out, elems);\n-                        break;\n-                    } else if right == right_end {\n-                        let elems = (right_start as usize - left as usize) / mem::size_of::<T>();\n-                        ptr::copy_nonoverlapping(&*left, out, elems);\n-                        break;\n-                    }\n-\n-                    // check which side is smaller, and that's the\n-                    // next element for the new run.\n-\n-                    // `left < right_start` and `right < right_end`,\n-                    // so these are valid.\n-                    let to_copy = if compare(&*left, &*right) == Greater {\n-                        step(&mut right)\n-                    } else {\n-                        step(&mut left)\n-                    };\n-                    ptr::copy_nonoverlapping(&*to_copy, out, 1);\n-                    step(&mut out);\n+                v[start..end].reverse();\n+            } else {\n+                while start > 0 && compare(&v[start - 1], &v[start]) != Greater {\n+                    start -= 1;\n                 }\n             }\n         }\n \n-        mem::swap(&mut buf_dat, &mut buf_tmp);\n+        // Insert some more elements into the run if it's too short. Insertion sort is faster than\n+        // merge sort on short sequences, so this significantly improves performance.\n+        while start > 0 && end - start < min_run {\n+            start -= 1;\n+            insert_head(&mut v[start..end], &mut compare);\n+        }\n \n-        width *= 2;\n+        // Push this run onto the stack.\n+        runs.push(Run {\n+            start: start,\n+            len: end - start,\n+        });\n+        end = start;\n+\n+        // Merge some pairs of adjacent runs to satisfy the invariants.\n+        while let Some(r) = collapse(&runs) {\n+            let left = runs[r + 1];\n+            let right = runs[r];\n+            unsafe {\n+                merge(&mut v[left.start .. right.start + right.len], left.len, buf.as_mut_ptr(),\n+                      &mut compare);\n+            }\n+            runs[r] = Run {\n+                start: left.start,\n+                len: left.len + right.len,\n+            };\n+            runs.remove(r + 1);\n+        }\n     }\n \n-    // write the result to `v` in one go, so that there are never two copies\n-    // of the same object in `v`.\n-    unsafe {\n-        ptr::copy_nonoverlapping(&*buf_dat, v.as_mut_ptr(), len);\n+    // Finally, exactly one run must remain in the stack.\n+    debug_assert!(runs.len() == 1 && runs[0].start == 0 && runs[0].len == len);\n+\n+    // Examines the stack of runs and identifies the next pair of runs to merge. More specifically,\n+    // if `Some(r)` is returned, that means `runs[r]` and `runs[r + 1]` must be merged next. If the\n+    // algorithm should continue building a new run instead, `None` is returned.\n+    //\n+    // TimSort is infamous for it's buggy implementations, as described here:\n+    // http://envisage-project.eu/timsort-specification-and-verification/\n+    //\n+    // The gist of the story is: we must enforce the invariants on the top four runs on the stack.\n+    // Enforcing them on just top three is not sufficient to ensure that the invariants will still\n+    // hold for *all* runs in the stack.\n+    //\n+    // This function correctly checks invariants for the top four runs. Additionally, if the top\n+    // run starts at index 0, it will always demand a merge operation until the stack is fully\n+    // collapsed, in order to complete the sort.\n+    #[inline]\n+    fn collapse(runs: &[Run]) -> Option<usize> {\n+        let n = runs.len();\n+        if n >= 2 && (runs[n - 1].start == 0 ||\n+                      runs[n - 2].len <= runs[n - 1].len ||\n+                      (n >= 3 && runs[n - 3].len <= runs[n - 2].len + runs[n - 1].len) ||\n+                      (n >= 4 && runs[n - 4].len <= runs[n - 3].len + runs[n - 2].len)) {\n+            if n >= 3 && runs[n - 3].len < runs[n - 1].len {\n+                Some(n - 3)\n+            } else {\n+                Some(n - 2)\n+            }\n+        } else {\n+            None\n+        }\n     }\n \n-    // increment the pointer, returning the old pointer.\n-    #[inline(always)]\n-    unsafe fn step<T>(ptr: &mut *mut T) -> *mut T {\n-        let old = *ptr;\n-        *ptr = ptr.offset(1);\n-        old\n+    #[derive(Clone, Copy)]\n+    struct Run {\n+        start: usize,\n+        len: usize,\n     }\n }"}, {"sha": "d4be0914f15c83598b7d79f7e87c1e7e2d868339", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -24,12 +24,12 @@ use core::str::pattern::Pattern;\n use core::str::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n use core::mem;\n use core::iter::FusedIterator;\n-use rustc_unicode::str::{UnicodeStr, Utf16Encoder};\n+use std_unicode::str::{UnicodeStr, Utf16Encoder};\n \n use vec_deque::VecDeque;\n use borrow::{Borrow, ToOwned};\n use string::String;\n-use rustc_unicode;\n+use std_unicode;\n use vec::Vec;\n use slice::SliceConcatExt;\n use boxed::Box;\n@@ -54,7 +54,7 @@ pub use core::str::{from_utf8, Chars, CharIndices, Bytes};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::str::{from_utf8_unchecked, ParseBoolError};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use rustc_unicode::str::SplitWhitespace;\n+pub use std_unicode::str::SplitWhitespace;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::str::pattern;\n \n@@ -1705,7 +1705,7 @@ impl str {\n         }\n \n         fn case_ignoreable_then_cased<I: Iterator<Item = char>>(iter: I) -> bool {\n-            use rustc_unicode::derived_property::{Cased, Case_Ignorable};\n+            use std_unicode::derived_property::{Cased, Case_Ignorable};\n             match iter.skip_while(|&c| Case_Ignorable(c)).next() {\n                 Some(c) => Cased(c),\n                 None => false,"}, {"sha": "b4c41a99a6b971715f679d2e62a560c23cb7b2f7", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 34, "deletions": 5, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -63,8 +63,8 @@ use core::mem;\n use core::ops::{self, Add, AddAssign, Index, IndexMut};\n use core::ptr;\n use core::str::pattern::Pattern;\n-use rustc_unicode::char::{decode_utf16, REPLACEMENT_CHARACTER};\n-use rustc_unicode::str as unicode_str;\n+use std_unicode::char::{decode_utf16, REPLACEMENT_CHARACTER};\n+use std_unicode::str as unicode_str;\n \n use borrow::{Cow, ToOwned};\n use range::RangeArgument;\n@@ -1129,8 +1129,6 @@ impl String {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, idx: usize, ch: char) {\n-        let len = self.len();\n-        assert!(idx <= len);\n         assert!(self.is_char_boundary(idx));\n         let mut bits = [0; 4];\n         let bits = ch.encode_utf8(&mut bits).as_bytes();\n@@ -1184,7 +1182,6 @@ impl String {\n                reason = \"recent addition\",\n                issue = \"35553\")]\n     pub fn insert_str(&mut self, idx: usize, string: &str) {\n-        assert!(idx <= self.len());\n         assert!(self.is_char_boundary(idx));\n \n         unsafe {\n@@ -1260,6 +1257,38 @@ impl String {\n         self.len() == 0\n     }\n \n+    /// Divide one string into two at an index.\n+    ///\n+    /// The argument, `mid`, should be a byte offset from the start of the string. It must also\n+    /// be on the boundary of a UTF-8 code point.\n+    ///\n+    /// The two strings returned go from the start of the string to `mid`, and from `mid` to the end\n+    /// of the string.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `mid` is not on a `UTF-8` code point boundary, or if it is beyond the last\n+    /// code point of the string.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![feature(string_split_off)]\n+    /// # fn main() {\n+    /// let mut hello = String::from(\"Hello, World!\");\n+    /// let world = hello.split_off(7);\n+    /// assert_eq!(hello, \"Hello, \");\n+    /// assert_eq!(world, \"World!\");\n+    /// # }\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"string_split_off\", issue = \"38080\")]\n+    pub fn split_off(&mut self, mid: usize) -> String {\n+        assert!(self.is_char_boundary(mid));\n+        let other = self.vec.split_off(mid);\n+        unsafe { String::from_utf8_unchecked(other) }\n+    }\n+\n     /// Truncates this `String`, removing all contents.\n     ///\n     /// While this means the `String` will have a length of zero, it does not"}, {"sha": "c9f9e513ef3d6f7a34e789eb1d839af1916ebb9e", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 43, "deletions": 8, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -1244,7 +1244,7 @@ impl<T: Clone> Vec<T> {\n     /// ```\n     #[stable(feature = \"vec_extend_from_slice\", since = \"1.6.0\")]\n     pub fn extend_from_slice(&mut self, other: &[T]) {\n-        self.extend(other.iter().cloned())\n+        self.spec_extend(other.iter())\n     }\n }\n \n@@ -1499,7 +1499,7 @@ impl<T> ops::DerefMut for Vec<T> {\n impl<T> FromIterator<T> for Vec<T> {\n     #[inline]\n     fn from_iter<I: IntoIterator<Item = T>>(iter: I) -> Vec<T> {\n-        <Self as SpecExtend<_>>::from_iter(iter.into_iter())\n+        <Self as SpecExtend<_, _>>::from_iter(iter.into_iter())\n     }\n }\n \n@@ -1572,12 +1572,12 @@ impl<T> Extend<T> for Vec<T> {\n }\n \n // Specialization trait used for Vec::from_iter and Vec::extend\n-trait SpecExtend<I> {\n+trait SpecExtend<T, I> {\n     fn from_iter(iter: I) -> Self;\n     fn spec_extend(&mut self, iter: I);\n }\n \n-impl<I, T> SpecExtend<I> for Vec<T>\n+impl<T, I> SpecExtend<T, I> for Vec<T>\n     where I: Iterator<Item=T>,\n {\n     default fn from_iter(mut iterator: I) -> Self {\n@@ -1607,7 +1607,7 @@ impl<I, T> SpecExtend<I> for Vec<T>\n     }\n }\n \n-impl<I, T> SpecExtend<I> for Vec<T>\n+impl<T, I> SpecExtend<T, I> for Vec<T>\n     where I: TrustedLen<Item=T>,\n {\n     fn from_iter(iterator: I) -> Self {\n@@ -1642,6 +1642,33 @@ impl<I, T> SpecExtend<I> for Vec<T>\n     }\n }\n \n+impl<'a, T: 'a, I> SpecExtend<&'a T, I> for Vec<T>\n+    where I: Iterator<Item=&'a T>,\n+          T: Clone,\n+{\n+    default fn from_iter(iterator: I) -> Self {\n+        SpecExtend::from_iter(iterator.cloned())\n+    }\n+\n+    default fn spec_extend(&mut self, iterator: I) {\n+        self.spec_extend(iterator.cloned())\n+    }\n+}\n+\n+impl<'a, T: 'a> SpecExtend<&'a T, slice::Iter<'a, T>> for Vec<T>\n+    where T: Copy,\n+{\n+    fn spec_extend(&mut self, iterator: slice::Iter<'a, T>) {\n+        let slice = iterator.as_slice();\n+        self.reserve(slice.len());\n+        unsafe {\n+            let len = self.len();\n+            self.set_len(len + slice.len());\n+            self.get_unchecked_mut(len..).copy_from_slice(slice);\n+        }\n+    }\n+}\n+\n impl<T> Vec<T> {\n     fn extend_desugared<I: Iterator<Item = T>>(&mut self, mut iterator: I) {\n         // This is the case for a general iterator.\n@@ -1669,7 +1696,7 @@ impl<T> Vec<T> {\n #[stable(feature = \"extend_ref\", since = \"1.2.0\")]\n impl<'a, T: 'a + Copy> Extend<&'a T> for Vec<T> {\n     fn extend<I: IntoIterator<Item = &'a T>>(&mut self, iter: I) {\n-        self.extend(iter.into_iter().map(|&x| x))\n+        self.spec_extend(iter.into_iter())\n     }\n }\n \n@@ -1988,7 +2015,11 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ExactSizeIterator for IntoIter<T> {}\n+impl<T> ExactSizeIterator for IntoIter<T> {\n+    fn is_empty(&self) -> bool {\n+        self.ptr == self.end\n+    }\n+}\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<T> FusedIterator for IntoIter<T> {}\n@@ -2082,7 +2113,11 @@ impl<'a, T> Drop for Drain<'a, T> {\n \n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<'a, T> ExactSizeIterator for Drain<'a, T> {}\n+impl<'a, T> ExactSizeIterator for Drain<'a, T> {\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T> FusedIterator for Drain<'a, T> {}"}, {"sha": "dbe3fec205cb268ee7fa01e80b8194ef934bb131", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -810,7 +810,7 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_empty(&self) -> bool {\n-        self.len() == 0\n+        self.tail == self.head\n     }\n \n     /// Create a draining iterator that removes the specified range in the\n@@ -1916,7 +1916,11 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n+impl<'a, T> ExactSizeIterator for Iter<'a, T> {\n+    fn is_empty(&self) -> bool {\n+        self.head == self.tail\n+    }\n+}\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T> FusedIterator for Iter<'a, T> {}\n@@ -1980,7 +1984,11 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n+impl<'a, T> ExactSizeIterator for IterMut<'a, T> {\n+    fn is_empty(&self) -> bool {\n+        self.head == self.tail\n+    }\n+}\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T> FusedIterator for IterMut<'a, T> {}\n@@ -2017,7 +2025,11 @@ impl<T> DoubleEndedIterator for IntoIter<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ExactSizeIterator for IntoIter<T> {}\n+impl<T> ExactSizeIterator for IntoIter<T> {\n+    fn is_empty(&self) -> bool {\n+        self.inner.is_empty()\n+    }\n+}\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<T> FusedIterator for IntoIter<T> {}"}, {"sha": "0fe0a1bad64554805cf3d91e1b01239cf3d39d48", "filename": "src/libcollectionstest/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcollectionstest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcollectionstest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Flib.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -18,20 +18,22 @@\n #![feature(const_fn)]\n #![feature(dedup_by)]\n #![feature(enumset)]\n+#![feature(exact_size_is_empty)]\n #![feature(pattern)]\n #![feature(rand)]\n #![feature(repeat_str)]\n #![feature(step_by)]\n #![feature(str_escape)]\n #![feature(str_replacen)]\n+#![feature(string_split_off)]\n #![feature(test)]\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(vec_into_iter_as_slice)]\n \n extern crate collections;\n extern crate test;\n-extern crate rustc_unicode;\n+extern crate std_unicode;\n \n use std::hash::{Hash, Hasher};\n use std::collections::hash_map::DefaultHasher;"}, {"sha": "1b52214dee6aebd0c7cf31eca00f8573764eab2c", "filename": "src/libcollectionstest/slice.rs", "status": "modified", "additions": 98, "deletions": 66, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcollectionstest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcollectionstest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fslice.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -383,7 +383,7 @@ fn test_reverse() {\n \n #[test]\n fn test_sort() {\n-    for len in 4..25 {\n+    for len in (2..25).chain(500..510) {\n         for _ in 0..100 {\n             let mut v: Vec<_> = thread_rng().gen_iter::<i32>().take(len).collect();\n             let mut v1 = v.clone();\n@@ -410,7 +410,7 @@ fn test_sort() {\n \n #[test]\n fn test_sort_stability() {\n-    for len in 4..25 {\n+    for len in (2..25).chain(500..510) {\n         for _ in 0..10 {\n             let mut counts = [0; 10];\n \n@@ -441,6 +441,13 @@ fn test_sort_stability() {\n     }\n }\n \n+#[test]\n+fn test_sort_zero_sized_type() {\n+    // Should not panic.\n+    [(); 10].sort();\n+    [(); 100].sort();\n+}\n+\n #[test]\n fn test_concat() {\n     let v: [Vec<i32>; 0] = [];\n@@ -633,6 +640,16 @@ fn test_iter_clone() {\n     assert_eq!(it.next(), jt.next());\n }\n \n+#[test]\n+fn test_iter_is_empty() {\n+    let xs = [1, 2, 5, 10, 11];\n+    for i in 0..xs.len() {\n+        for j in i..xs.len() {\n+            assert_eq!(xs[i..j].iter().is_empty(), xs[i..j].is_empty());\n+        }\n+    }\n+}\n+\n #[test]\n fn test_mut_iterator() {\n     let mut xs = [1, 2, 3, 4, 5];\n@@ -1328,89 +1345,104 @@ mod bench {\n         })\n     }\n \n-    #[bench]\n-    fn sort_random_small(b: &mut Bencher) {\n-        let mut rng = thread_rng();\n-        b.iter(|| {\n-            let mut v: Vec<_> = rng.gen_iter::<u64>().take(5).collect();\n-            v.sort();\n-        });\n-        b.bytes = 5 * mem::size_of::<u64>() as u64;\n+    fn gen_ascending(len: usize) -> Vec<u64> {\n+        (0..len as u64).collect()\n     }\n \n-    #[bench]\n-    fn sort_random_medium(b: &mut Bencher) {\n-        let mut rng = thread_rng();\n-        b.iter(|| {\n-            let mut v: Vec<_> = rng.gen_iter::<u64>().take(100).collect();\n-            v.sort();\n-        });\n-        b.bytes = 100 * mem::size_of::<u64>() as u64;\n+    fn gen_descending(len: usize) -> Vec<u64> {\n+        (0..len as u64).rev().collect()\n     }\n \n-    #[bench]\n-    fn sort_random_large(b: &mut Bencher) {\n+    fn gen_random(len: usize) -> Vec<u64> {\n         let mut rng = thread_rng();\n-        b.iter(|| {\n-            let mut v: Vec<_> = rng.gen_iter::<u64>().take(10000).collect();\n-            v.sort();\n-        });\n-        b.bytes = 10000 * mem::size_of::<u64>() as u64;\n+        rng.gen_iter::<u64>().take(len).collect()\n     }\n \n-    #[bench]\n-    fn sort_sorted(b: &mut Bencher) {\n-        let mut v: Vec<_> = (0..10000).collect();\n-        b.iter(|| {\n-            v.sort();\n-        });\n-        b.bytes = (v.len() * mem::size_of_val(&v[0])) as u64;\n+    fn gen_mostly_ascending(len: usize) -> Vec<u64> {\n+        let mut rng = thread_rng();\n+        let mut v = gen_ascending(len);\n+        for _ in (0usize..).take_while(|x| x * x <= len) {\n+            let x = rng.gen::<usize>() % len;\n+            let y = rng.gen::<usize>() % len;\n+            v.swap(x, y);\n+        }\n+        v\n     }\n \n-    type BigSortable = (u64, u64, u64, u64);\n-\n-    #[bench]\n-    fn sort_big_random_small(b: &mut Bencher) {\n+    fn gen_mostly_descending(len: usize) -> Vec<u64> {\n         let mut rng = thread_rng();\n-        b.iter(|| {\n-            let mut v = rng.gen_iter::<BigSortable>()\n-                .take(5)\n-                .collect::<Vec<BigSortable>>();\n-            v.sort();\n-        });\n-        b.bytes = 5 * mem::size_of::<BigSortable>() as u64;\n+        let mut v = gen_descending(len);\n+        for _ in (0usize..).take_while(|x| x * x <= len) {\n+            let x = rng.gen::<usize>() % len;\n+            let y = rng.gen::<usize>() % len;\n+            v.swap(x, y);\n+        }\n+        v\n     }\n \n-    #[bench]\n-    fn sort_big_random_medium(b: &mut Bencher) {\n+    fn gen_big_random(len: usize) -> Vec<[u64; 16]> {\n         let mut rng = thread_rng();\n-        b.iter(|| {\n-            let mut v = rng.gen_iter::<BigSortable>()\n-                .take(100)\n-                .collect::<Vec<BigSortable>>();\n-            v.sort();\n-        });\n-        b.bytes = 100 * mem::size_of::<BigSortable>() as u64;\n+        rng.gen_iter().map(|x| [x; 16]).take(len).collect()\n     }\n \n-    #[bench]\n-    fn sort_big_random_large(b: &mut Bencher) {\n-        let mut rng = thread_rng();\n-        b.iter(|| {\n-            let mut v = rng.gen_iter::<BigSortable>()\n-                .take(10000)\n-                .collect::<Vec<BigSortable>>();\n-            v.sort();\n-        });\n-        b.bytes = 10000 * mem::size_of::<BigSortable>() as u64;\n+    fn gen_big_ascending(len: usize) -> Vec<[u64; 16]> {\n+        (0..len as u64).map(|x| [x; 16]).take(len).collect()\n+    }\n+\n+    fn gen_big_descending(len: usize) -> Vec<[u64; 16]> {\n+        (0..len as u64).rev().map(|x| [x; 16]).take(len).collect()\n+    }\n+\n+    macro_rules! sort_bench {\n+        ($name:ident, $gen:expr, $len:expr) => {\n+            #[bench]\n+            fn $name(b: &mut Bencher) {\n+                b.iter(|| $gen($len).sort());\n+                b.bytes = $len * mem::size_of_val(&$gen(1)[0]) as u64;\n+            }\n+        }\n     }\n \n+    sort_bench!(sort_small_random, gen_random, 10);\n+    sort_bench!(sort_small_ascending, gen_ascending, 10);\n+    sort_bench!(sort_small_descending, gen_descending, 10);\n+\n+    sort_bench!(sort_small_big_random, gen_big_random, 10);\n+    sort_bench!(sort_small_big_ascending, gen_big_ascending, 10);\n+    sort_bench!(sort_small_big_descending, gen_big_descending, 10);\n+\n+    sort_bench!(sort_medium_random, gen_random, 100);\n+    sort_bench!(sort_medium_ascending, gen_ascending, 100);\n+    sort_bench!(sort_medium_descending, gen_descending, 100);\n+\n+    sort_bench!(sort_large_random, gen_random, 10000);\n+    sort_bench!(sort_large_ascending, gen_ascending, 10000);\n+    sort_bench!(sort_large_descending, gen_descending, 10000);\n+    sort_bench!(sort_large_mostly_ascending, gen_mostly_ascending, 10000);\n+    sort_bench!(sort_large_mostly_descending, gen_mostly_descending, 10000);\n+\n+    sort_bench!(sort_large_big_random, gen_big_random, 10000);\n+    sort_bench!(sort_large_big_ascending, gen_big_ascending, 10000);\n+    sort_bench!(sort_large_big_descending, gen_big_descending, 10000);\n+\n     #[bench]\n-    fn sort_big_sorted(b: &mut Bencher) {\n-        let mut v: Vec<BigSortable> = (0..10000).map(|i| (i, i, i, i)).collect();\n+    fn sort_large_random_expensive(b: &mut Bencher) {\n+        let len = 10000;\n         b.iter(|| {\n-            v.sort();\n+            let mut count = 0;\n+            let cmp = move |a: &u64, b: &u64| {\n+                count += 1;\n+                if count % 1_000_000_000 == 0 {\n+                    panic!(\"should not happen\");\n+                }\n+                (*a as f64).cos().partial_cmp(&(*b as f64).cos()).unwrap()\n+            };\n+\n+            let mut v = gen_random(len);\n+            v.sort_by(cmp);\n+\n+            black_box(count);\n         });\n-        b.bytes = (v.len() * mem::size_of_val(&v[0])) as u64;\n+        b.bytes = len as u64 * mem::size_of::<u64>() as u64;\n     }\n }"}, {"sha": "384579ce6b8b46af7ef6feb7bc2aba6f42ee8f47", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -530,7 +530,7 @@ fn from_utf8_mostly_ascii() {\n \n #[test]\n fn test_is_utf16() {\n-    use rustc_unicode::str::is_utf16;\n+    use std_unicode::str::is_utf16;\n \n     macro_rules! pos {\n         ($($e:expr),*) => { { $(assert!(is_utf16($e));)* } }\n@@ -1186,7 +1186,7 @@ fn test_rev_split_char_iterator_no_trailing() {\n \n #[test]\n fn test_utf16_code_units() {\n-    use rustc_unicode::str::Utf16Encoder;\n+    use std_unicode::str::Utf16Encoder;\n     assert_eq!(Utf16Encoder::new(vec!['\u00e9', '\\u{1F4A9}'].into_iter()).collect::<Vec<u16>>(),\n                [0xE9, 0xD83D, 0xDCA9])\n }"}, {"sha": "a7d85d0bea13a76a22ccc355b87ea821af637e22", "filename": "src/libcollectionstest/string.rs", "status": "modified", "additions": 40, "deletions": 1, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcollectionstest%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcollectionstest%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstring.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -132,7 +132,7 @@ fn test_from_utf16() {\n         let s_as_utf16 = s.encode_utf16().collect::<Vec<u16>>();\n         let u_as_string = String::from_utf16(&u).unwrap();\n \n-        assert!(::rustc_unicode::str::is_utf16(&u));\n+        assert!(::std_unicode::str::is_utf16(&u));\n         assert_eq!(s_as_utf16, u);\n \n         assert_eq!(u_as_string, s);\n@@ -231,6 +231,45 @@ fn test_pop() {\n     assert_eq!(data, \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\");\n }\n \n+#[test]\n+fn test_split_off_empty() {\n+    let orig = \"Hello, world!\";\n+    let mut split = String::from(orig);\n+    let empty: String = split.split_off(orig.len());\n+    assert!(empty.is_empty());\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_split_off_past_end() {\n+    let orig = \"Hello, world!\";\n+    let mut split = String::from(orig);\n+    split.split_off(orig.len() + 1);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_split_off_mid_char() {\n+    let mut orig = String::from(\"\u5c71\");\n+    orig.split_off(1);\n+}\n+\n+#[test]\n+fn test_split_off_ascii() {\n+    let mut ab = String::from(\"ABCD\");\n+    let cd = ab.split_off(2);\n+    assert_eq!(ab, \"AB\");\n+    assert_eq!(cd, \"CD\");\n+}\n+\n+#[test]\n+fn test_split_off_unicode() {\n+    let mut nihon = String::from(\"\u65e5\u672c\u8a9e\");\n+    let go = nihon.split_off(\"\u65e5\u672c\".len());\n+    assert_eq!(nihon, \"\u65e5\u672c\");\n+    assert_eq!(go, \"\u8a9e\");\n+}\n+\n #[test]\n fn test_str_truncate() {\n     let mut s = String::from(\"12345\");"}, {"sha": "cdf022e4f02f36ec4e4a623bc26a0d8131d92e06", "filename": "src/libcollectionstest/vec_deque.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcollectionstest%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcollectionstest%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec_deque.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -1007,3 +1007,24 @@ fn assert_covariance() {\n         d\n     }\n }\n+\n+#[test]\n+fn test_is_empty() {\n+    let mut v = VecDeque::<i32>::new();\n+    assert!(v.is_empty());\n+    assert!(v.iter().is_empty());\n+    assert!(v.iter_mut().is_empty());\n+    v.extend(&[2, 3, 4]);\n+    assert!(!v.is_empty());\n+    assert!(!v.iter().is_empty());\n+    assert!(!v.iter_mut().is_empty());\n+    while let Some(_) = v.pop_front() {\n+        assert_eq!(v.is_empty(), v.len() == 0);\n+        assert_eq!(v.iter().is_empty(), v.iter().len() == 0);\n+        assert_eq!(v.iter_mut().is_empty(), v.iter_mut().len() == 0);\n+    }\n+    assert!(v.is_empty());\n+    assert!(v.iter().is_empty());\n+    assert!(v.iter_mut().is_empty());\n+    assert!(v.into_iter().is_empty());\n+}"}, {"sha": "79570dc025219efb8e352777d95d53cc7b32d081", "filename": "src/libcompiler_builtins/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcompiler_builtins%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcompiler_builtins%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins%2FCargo.toml?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -8,6 +8,7 @@ version = \"0.0.0\"\n name = \"compiler_builtins\"\n path = \"lib.rs\"\n test = false\n+bench = false\n \n [dependencies]\n core = { path = \"../libcore\" }"}, {"sha": "f61e2281a5c3057b168fe29ba96bf5ce55ad1335", "filename": "src/libcompiler_builtins/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcompiler_builtins%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcompiler_builtins%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins%2Fbuild.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -94,6 +94,7 @@ fn main() {\n         cfg.flag(\"-fvisibility=hidden\");\n         cfg.flag(\"-fomit-frame-pointer\");\n         cfg.flag(\"-ffreestanding\");\n+        cfg.define(\"VISIBILITY_HIDDEN\", None);\n     }\n \n     let mut sources = Sources::new();"}, {"sha": "a72c712ad1733c4d29ae1f5f688092acf69b5526", "filename": "src/libcore/Cargo.toml", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcore%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcore%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2FCargo.toml?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -7,7 +7,12 @@ version = \"0.0.0\"\n name = \"core\"\n path = \"lib.rs\"\n test = false\n+bench = false\n \n [[test]]\n name = \"coretest\"\n path = \"../libcoretest/lib.rs\"\n+\n+[[bench]]\n+name = \"coretest\"\n+path = \"../libcoretest/lib.rs\""}, {"sha": "7f3ac13bac1f3a6049311f1e834b142e4a7beb1a", "filename": "src/libcore/char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -10,7 +10,7 @@\n \n //! Character manipulation.\n //!\n-//! For more details, see ::rustc_unicode::char (a.k.a. std::char)\n+//! For more details, see ::std_unicode::char (a.k.a. std::char)\n \n #![allow(non_snake_case)]\n #![stable(feature = \"core_char\", since = \"1.2.0\")]\n@@ -238,7 +238,7 @@ impl fmt::Display for CharTryFromError {\n /// A 'radix' here is sometimes also called a 'base'. A radix of two\n /// indicates a binary number, a radix of ten, decimal, and a radix of\n /// sixteen, hexadecimal, to give some common values. Arbitrary\n-/// radicum are supported.\n+/// radices are supported.\n ///\n /// `from_digit()` will return `None` if the input is not a digit in\n /// the given radix."}, {"sha": "9167264ba9d12f4297ecb936aa1bdec370da7a0f", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -166,7 +166,9 @@ pub struct Formatter<'a> {\n // NB. Argument is essentially an optimized partially applied formatting function,\n // equivalent to `exists T.(&T, fn(&T, &mut Formatter) -> Result`.\n \n-enum Void {}\n+struct Void {\n+    _priv: (),\n+}\n \n /// This struct represents the generic \"argument\" which is taken by the Xprintf\n /// family of functions. It contains a function to format the given value. At"}, {"sha": "48808b601c10c713ed017334e7e40ec725434b7d", "filename": "src/libcore/iter/iterator.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcore%2Fiter%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcore%2Fiter%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fiterator.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -247,7 +247,7 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn nth(&mut self, mut n: usize) -> Option<Self::Item> where Self: Sized {\n+    fn nth(&mut self, mut n: usize) -> Option<Self::Item> {\n         for x in self {\n             if n == 0 { return Some(x) }\n             n -= 1;\n@@ -2179,4 +2179,7 @@ impl<'a, I: Iterator + ?Sized> Iterator for &'a mut I {\n     type Item = I::Item;\n     fn next(&mut self) -> Option<I::Item> { (**self).next() }\n     fn size_hint(&self) -> (usize, Option<usize>) { (**self).size_hint() }\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        (**self).nth(n)\n+    }\n }"}, {"sha": "3999db0d63c99ac8770076f537e8807d5a8e33cc", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 61, "deletions": 10, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -225,12 +225,12 @@\n //! often called 'iterator adapters', as they're a form of the 'adapter\n //! pattern'.\n //!\n-//! Common iterator adapters include [`map()`], [`take()`], and [`collect()`].\n+//! Common iterator adapters include [`map()`], [`take()`], and [`filter()`].\n //! For more, see their documentation.\n //!\n //! [`map()`]: trait.Iterator.html#method.map\n //! [`take()`]: trait.Iterator.html#method.take\n-//! [`collect()`]: trait.Iterator.html#method.collect\n+//! [`filter()`]: trait.Iterator.html#method.filter\n //!\n //! # Laziness\n //!\n@@ -268,7 +268,7 @@\n //! [`map()`]: trait.Iterator.html#method.map\n //!\n //! The two most common ways to evaluate an iterator are to use a `for` loop\n-//! like this, or using the [`collect()`] adapter to produce a new collection.\n+//! like this, or using the [`collect()`] method to produce a new collection.\n //!\n //! [`collect()`]: trait.Iterator.html#method.collect\n //!\n@@ -368,7 +368,16 @@ impl<I> DoubleEndedIterator for Rev<I> where I: DoubleEndedIterator {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I> ExactSizeIterator for Rev<I>\n-    where I: ExactSizeIterator + DoubleEndedIterator {}\n+    where I: ExactSizeIterator + DoubleEndedIterator\n+{\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<I> FusedIterator for Rev<I>\n@@ -425,7 +434,15 @@ impl<'a, I, T: 'a> DoubleEndedIterator for Cloned<I>\n #[stable(feature = \"iter_cloned\", since = \"1.1.0\")]\n impl<'a, I, T: 'a> ExactSizeIterator for Cloned<I>\n     where I: ExactSizeIterator<Item=&'a T>, T: Clone\n-{}\n+{\n+    fn len(&self) -> usize {\n+        self.it.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.it.is_empty()\n+    }\n+}\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, I, T: 'a> FusedIterator for Cloned<I>\n@@ -920,7 +937,7 @@ unsafe impl<A, B> TrustedLen for Zip<A, B>\n /// you can also [`map()`] backwards:\n ///\n /// ```rust\n-/// let v: Vec<i32> = vec![1, 2, 3].into_iter().rev().map(|x| x + 1).collect();\n+/// let v: Vec<i32> = vec![1, 2, 3].into_iter().map(|x| x + 1).rev().collect();\n ///\n /// assert_eq!(v, [4, 3, 2]);\n /// ```\n@@ -1007,7 +1024,16 @@ impl<B, I: DoubleEndedIterator, F> DoubleEndedIterator for Map<I, F> where\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<B, I: ExactSizeIterator, F> ExactSizeIterator for Map<I, F>\n-    where F: FnMut(I::Item) -> B {}\n+    where F: FnMut(I::Item) -> B\n+{\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<B, I: FusedIterator, F> FusedIterator for Map<I, F>\n@@ -1236,7 +1262,15 @@ impl<I> DoubleEndedIterator for Enumerate<I> where\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Enumerate<I> where I: ExactSizeIterator {}\n+impl<I> ExactSizeIterator for Enumerate<I> where I: ExactSizeIterator {\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n \n #[doc(hidden)]\n unsafe impl<I> TrustedRandomAccess for Enumerate<I>\n@@ -1945,7 +1979,15 @@ impl<I> DoubleEndedIterator for Fuse<I>\n \n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<I> ExactSizeIterator for Fuse<I> where I: ExactSizeIterator {}\n+impl<I> ExactSizeIterator for Fuse<I> where I: ExactSizeIterator {\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n \n /// An iterator that calls a function with a reference to each element before\n /// yielding it.\n@@ -2012,7 +2054,16 @@ impl<I: DoubleEndedIterator, F> DoubleEndedIterator for Inspect<I, F>\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: ExactSizeIterator, F> ExactSizeIterator for Inspect<I, F>\n-    where F: FnMut(&I::Item) {}\n+    where F: FnMut(&I::Item)\n+{\n+    fn len(&self) -> usize {\n+        self.iter.len()\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.iter.is_empty()\n+    }\n+}\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<I: FusedIterator, F> FusedIterator for Inspect<I, F>"}, {"sha": "c5465549adf70c6f37bf2cc349c1b31e5426bf9a", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -552,7 +552,14 @@ pub trait ExactSizeIterator: Iterator {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, I: ExactSizeIterator + ?Sized> ExactSizeIterator for &'a mut I {}\n+impl<'a, I: ExactSizeIterator + ?Sized> ExactSizeIterator for &'a mut I {\n+    fn len(&self) -> usize {\n+        (**self).len()\n+    }\n+    fn is_empty(&self) -> bool {\n+        (**self).is_empty()\n+    }\n+}\n \n /// Trait to represent types that can be created by summing up an iterator.\n ///"}, {"sha": "9834fca5fdc78d80561bf609587f11835aedc549", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -89,7 +89,6 @@\n #![feature(specialization)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n-#![cfg_attr(stage0, feature(question_mark))]\n #![feature(never_type)]\n #![feature(prelude_import)]\n "}, {"sha": "8871e1fa840ef7cc6cc5b8a5593a785b23dca20b", "filename": "src/libcore/option.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -659,6 +659,16 @@ impl<T> Option<T> {\n impl<'a, T: Clone> Option<&'a T> {\n     /// Maps an `Option<&T>` to an `Option<T>` by cloning the contents of the\n     /// option.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let x = 12;\n+    /// let opt_x = Some(&x);\n+    /// assert_eq!(opt_x, Some(&12));\n+    /// let cloned = opt_x.cloned();\n+    /// assert_eq!(cloned, Some(12));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn cloned(self) -> Option<T> {\n         self.map(|t| t.clone())"}, {"sha": "a4a90e7a9da7a3bc80df580ea4b86bf25d054e5d", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 341, "deletions": 170, "changes": 511, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -38,10 +38,14 @@ use cmp;\n use fmt;\n use intrinsics::assume;\n use iter::*;\n-use ops::{self, RangeFull};\n+use ops::{FnMut, self};\n+use option::Option;\n+use option::Option::{None, Some};\n+use result::Result;\n+use result::Result::{Ok, Err};\n use ptr;\n use mem;\n-use marker;\n+use marker::{Copy, Send, Sync, Sized, self};\n use iter_private::TrustedRandomAccess;\n \n #[repr(C)]\n@@ -80,7 +84,8 @@ pub trait SliceExt {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn chunks(&self, size: usize) -> Chunks<Self::Item>;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn get(&self, index: usize) -> Option<&Self::Item>;\n+    fn get<I>(&self, index: I) -> Option<&I::Output>\n+        where I: SliceIndex<Self::Item>;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn first(&self) -> Option<&Self::Item>;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n@@ -90,7 +95,8 @@ pub trait SliceExt {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn last(&self) -> Option<&Self::Item>;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n-    unsafe fn get_unchecked(&self, index: usize) -> &Self::Item;\n+    unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output\n+        where I: SliceIndex<Self::Item>;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn as_ptr(&self) -> *const Self::Item;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n@@ -108,7 +114,8 @@ pub trait SliceExt {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn is_empty(&self) -> bool { self.len() == 0 }\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn get_mut(&mut self, index: usize) -> Option<&mut Self::Item>;\n+    fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n+        where I: SliceIndex<Self::Item>;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn iter_mut(&mut self) -> IterMut<Self::Item>;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n@@ -137,7 +144,8 @@ pub trait SliceExt {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn reverse(&mut self);\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n-    unsafe fn get_unchecked_mut(&mut self, index: usize) -> &mut Self::Item;\n+    unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n+        where I: SliceIndex<Self::Item>;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn as_mut_ptr(&mut self) -> *mut Self::Item;\n \n@@ -258,8 +266,10 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn get(&self, index: usize) -> Option<&T> {\n-        if index < self.len() { Some(&self[index]) } else { None }\n+    fn get<I>(&self, index: I) -> Option<&I::Output>\n+        where I: SliceIndex<T>\n+    {\n+        index.get(self)\n     }\n \n     #[inline]\n@@ -284,8 +294,10 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked(&self, index: usize) -> &T {\n-        &*(self.as_ptr().offset(index as isize))\n+    unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output\n+        where I: SliceIndex<T>\n+    {\n+        index.get_unchecked(self)\n     }\n \n     #[inline]\n@@ -323,8 +335,10 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn get_mut(&mut self, index: usize) -> Option<&mut T> {\n-        if index < self.len() { Some(&mut self[index]) } else { None }\n+    fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n+        where I: SliceIndex<T>\n+    {\n+        index.get_mut(self)\n     }\n \n     #[inline]\n@@ -451,8 +465,10 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked_mut(&mut self, index: usize) -> &mut T {\n-        &mut *self.as_mut_ptr().offset(index as isize)\n+    unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n+        where I: SliceIndex<T>\n+    {\n+        index.get_unchecked_mut(self)\n     }\n \n     #[inline]\n@@ -515,23 +531,26 @@ impl<T> SliceExt for [T] {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n-impl<T> ops::Index<usize> for [T] {\n-    type Output = T;\n+#[rustc_on_unimplemented = \"slice indices are of type `usize` or ranges of `usize`\"]\n+impl<T, I> ops::Index<I> for [T]\n+    where I: SliceIndex<T>\n+{\n+    type Output = I::Output;\n \n-    fn index(&self, index: usize) -> &T {\n-        // NB built-in indexing\n-        &(*self)[index]\n+    #[inline]\n+    fn index(&self, index: I) -> &I::Output {\n+        index.index(self)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n-impl<T> ops::IndexMut<usize> for [T] {\n+#[rustc_on_unimplemented = \"slice indices are of type `usize` or ranges of `usize`\"]\n+impl<T, I> ops::IndexMut<I> for [T]\n+    where I: SliceIndex<T>\n+{\n     #[inline]\n-    fn index_mut(&mut self, index: usize) -> &mut T {\n-        // NB built-in indexing\n-        &mut (*self)[index]\n+    fn index_mut(&mut self, index: I) -> &mut I::Output {\n+        index.index_mut(self)\n     }\n }\n \n@@ -547,205 +566,349 @@ fn slice_index_order_fail(index: usize, end: usize) -> ! {\n     panic!(\"slice index starts at {} but ends at {}\", index, end);\n }\n \n+/// A helper trait used for indexing operations.\n+#[unstable(feature = \"slice_get_slice\", issue = \"35729\")]\n+#[rustc_on_unimplemented = \"slice indices are of type `usize` or ranges of `usize`\"]\n+pub trait SliceIndex<T> {\n+    /// The output type returned by methods.\n+    type Output: ?Sized;\n \n-/// Implements slicing with syntax `&self[begin .. end]`.\n-///\n-/// Returns a slice of self for the index range [`begin`..`end`).\n-///\n-/// This operation is `O(1)`.\n-///\n-/// # Panics\n-///\n-/// Requires that `begin <= end` and `end <= self.len()`,\n-/// otherwise slicing will panic.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n-impl<T> ops::Index<ops::Range<usize>> for [T] {\n+    /// Returns a shared reference to the output at this location, if in\n+    /// bounds.\n+    fn get(self, slice: &[T]) -> Option<&Self::Output>;\n+\n+    /// Returns a mutable reference to the output at this location, if in\n+    /// bounds.\n+    fn get_mut(self, slice: &mut [T]) -> Option<&mut Self::Output>;\n+\n+    /// Returns a shared reference to the output at this location, without\n+    /// performing any bounds checking.\n+    unsafe fn get_unchecked(self, slice: &[T]) -> &Self::Output;\n+\n+    /// Returns a mutable reference to the output at this location, without\n+    /// performing any bounds checking.\n+    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut Self::Output;\n+\n+    /// Returns a shared reference to the output at this location, panicking\n+    /// if out of bounds.\n+    fn index(self, slice: &[T]) -> &Self::Output;\n+\n+    /// Returns a mutable reference to the output at this location, panicking\n+    /// if out of bounds.\n+    fn index_mut(self, slice: &mut [T]) -> &mut Self::Output;\n+}\n+\n+#[stable(feature = \"slice-get-slice-impls\", since = \"1.13.0\")]\n+impl<T> SliceIndex<T> for usize {\n+    type Output = T;\n+\n+    #[inline]\n+    fn get(self, slice: &[T]) -> Option<&T> {\n+        if self < slice.len() {\n+            unsafe {\n+                Some(self.get_unchecked(slice))\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn get_mut(self, slice: &mut [T]) -> Option<&mut T> {\n+        if self < slice.len() {\n+            unsafe {\n+                Some(self.get_unchecked_mut(slice))\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: &[T]) -> &T {\n+        &*slice.as_ptr().offset(self as isize)\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut T {\n+        &mut *slice.as_mut_ptr().offset(self as isize)\n+    }\n+\n+    #[inline]\n+    fn index(self, slice: &[T]) -> &T {\n+        // NB: use intrinsic indexing\n+        &(*slice)[self]\n+    }\n+\n+    #[inline]\n+    fn index_mut(self, slice: &mut [T]) -> &mut T {\n+        // NB: use intrinsic indexing\n+        &mut (*slice)[self]\n+    }\n+}\n+\n+#[stable(feature = \"slice-get-slice-impls\", since = \"1.13.0\")]\n+impl<T> SliceIndex<T> for  ops::Range<usize> {\n     type Output = [T];\n \n     #[inline]\n-    fn index(&self, index: ops::Range<usize>) -> &[T] {\n-        if index.start > index.end {\n-            slice_index_order_fail(index.start, index.end);\n-        } else if index.end > self.len() {\n-            slice_index_len_fail(index.end, self.len());\n+    fn get(self, slice: &[T]) -> Option<&[T]> {\n+        if self.start > self.end || self.end > slice.len() {\n+            None\n+        } else {\n+            unsafe {\n+                Some(self.get_unchecked(slice))\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n+        if self.start > self.end || self.end > slice.len() {\n+            None\n+        } else {\n+            unsafe {\n+                Some(self.get_unchecked_mut(slice))\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n+        from_raw_parts(slice.as_ptr().offset(self.start as isize), self.end - self.start)\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n+        from_raw_parts_mut(slice.as_mut_ptr().offset(self.start as isize), self.end - self.start)\n+    }\n+\n+    #[inline]\n+    fn index(self, slice: &[T]) -> &[T] {\n+        if self.start > self.end {\n+            slice_index_order_fail(self.start, self.end);\n+        } else if self.end > slice.len() {\n+            slice_index_len_fail(self.end, slice.len());\n+        }\n+        unsafe {\n+            self.get_unchecked(slice)\n+        }\n+    }\n+\n+    #[inline]\n+    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n+        if self.start > self.end {\n+            slice_index_order_fail(self.start, self.end);\n+        } else if self.end > slice.len() {\n+            slice_index_len_fail(self.end, slice.len());\n         }\n         unsafe {\n-            from_raw_parts (\n-                self.as_ptr().offset(index.start as isize),\n-                index.end - index.start\n-            )\n+            self.get_unchecked_mut(slice)\n         }\n     }\n }\n \n-/// Implements slicing with syntax `&self[.. end]`.\n-///\n-/// Returns a slice of self from the beginning until but not including\n-/// the index `end`.\n-///\n-/// Equivalent to `&self[0 .. end]`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n-impl<T> ops::Index<ops::RangeTo<usize>> for [T] {\n+#[stable(feature = \"slice-get-slice-impls\", since = \"1.13.0\")]\n+impl<T> SliceIndex<T> for ops::RangeTo<usize> {\n     type Output = [T];\n \n     #[inline]\n-    fn index(&self, index: ops::RangeTo<usize>) -> &[T] {\n-        self.index(0 .. index.end)\n+    fn get(self, slice: &[T]) -> Option<&[T]> {\n+        (0..self.end).get(slice)\n+    }\n+\n+    #[inline]\n+    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n+        (0..self.end).get_mut(slice)\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n+        (0..self.end).get_unchecked(slice)\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n+        (0..self.end).get_unchecked_mut(slice)\n+    }\n+\n+    #[inline]\n+    fn index(self, slice: &[T]) -> &[T] {\n+        (0..self.end).index(slice)\n+    }\n+\n+    #[inline]\n+    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n+        (0..self.end).index_mut(slice)\n     }\n }\n \n-/// Implements slicing with syntax `&self[begin ..]`.\n-///\n-/// Returns a slice of self from and including the index `begin` until the end.\n-///\n-/// Equivalent to `&self[begin .. self.len()]`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n-impl<T> ops::Index<ops::RangeFrom<usize>> for [T] {\n+#[stable(feature = \"slice-get-slice-impls\", since = \"1.13.0\")]\n+impl<T> SliceIndex<T> for ops::RangeFrom<usize> {\n     type Output = [T];\n \n     #[inline]\n-    fn index(&self, index: ops::RangeFrom<usize>) -> &[T] {\n-        self.index(index.start .. self.len())\n+    fn get(self, slice: &[T]) -> Option<&[T]> {\n+        (self.start..slice.len()).get(slice)\n+    }\n+\n+    #[inline]\n+    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n+        (self.start..slice.len()).get_mut(slice)\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n+        (self.start..slice.len()).get_unchecked(slice)\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n+        (self.start..slice.len()).get_unchecked_mut(slice)\n+    }\n+\n+    #[inline]\n+    fn index(self, slice: &[T]) -> &[T] {\n+        (self.start..slice.len()).index(slice)\n+    }\n+\n+    #[inline]\n+    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n+        (self.start..slice.len()).index_mut(slice)\n     }\n }\n \n-/// Implements slicing with syntax `&self[..]`.\n-///\n-/// Returns a slice of the whole slice. This operation cannot panic.\n-///\n-/// Equivalent to `&self[0 .. self.len()]`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::Index<RangeFull> for [T] {\n+#[stable(feature = \"slice-get-slice-impls\", since = \"1.13.0\")]\n+impl<T> SliceIndex<T> for ops::RangeFull {\n     type Output = [T];\n \n     #[inline]\n-    fn index(&self, _index: RangeFull) -> &[T] {\n-        self\n+    fn get(self, slice: &[T]) -> Option<&[T]> {\n+        Some(slice)\n+    }\n+\n+    #[inline]\n+    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n+        Some(slice)\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n+        slice\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n+        slice\n+    }\n+\n+    #[inline]\n+    fn index(self, slice: &[T]) -> &[T] {\n+        slice\n+    }\n+\n+    #[inline]\n+    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n+        slice\n     }\n }\n \n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n-impl<T> ops::Index<ops::RangeInclusive<usize>> for [T] {\n+\n+#[stable(feature = \"slice-get-slice-impls\", since = \"1.13.0\")]\n+impl<T> SliceIndex<T> for ops::RangeInclusive<usize> {\n     type Output = [T];\n \n     #[inline]\n-    fn index(&self, index: ops::RangeInclusive<usize>) -> &[T] {\n-        match index {\n+    fn get(self, slice: &[T]) -> Option<&[T]> {\n+        match self {\n+            ops::RangeInclusive::Empty { .. } => Some(&[]),\n+            ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() => None,\n+            ops::RangeInclusive::NonEmpty { start, end } => (start..end + 1).get(slice),\n+        }\n+    }\n+\n+    #[inline]\n+    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n+        match self {\n+            ops::RangeInclusive::Empty { .. } => Some(&mut []),\n+            ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() => None,\n+            ops::RangeInclusive::NonEmpty { start, end } => (start..end + 1).get_mut(slice),\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n+        match self {\n             ops::RangeInclusive::Empty { .. } => &[],\n-            ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() =>\n-                panic!(\"attempted to index slice up to maximum usize\"),\n-            ops::RangeInclusive::NonEmpty { start, end } =>\n-                self.index(start .. end+1)\n+            ops::RangeInclusive::NonEmpty { start, end } => (start..end + 1).get_unchecked(slice),\n         }\n     }\n-}\n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n-impl<T> ops::Index<ops::RangeToInclusive<usize>> for [T] {\n-    type Output = [T];\n \n     #[inline]\n-    fn index(&self, index: ops::RangeToInclusive<usize>) -> &[T] {\n-        self.index(0...index.end)\n+    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n+        match self {\n+            ops::RangeInclusive::Empty { .. } => &mut [],\n+            ops::RangeInclusive::NonEmpty { start, end } => {\n+                (start..end + 1).get_unchecked_mut(slice)\n+            }\n+        }\n     }\n-}\n \n-/// Implements mutable slicing with syntax `&mut self[begin .. end]`.\n-///\n-/// Returns a slice of self for the index range [`begin`..`end`).\n-///\n-/// This operation is `O(1)`.\n-///\n-/// # Panics\n-///\n-/// Requires that `begin <= end` and `end <= self.len()`,\n-/// otherwise slicing will panic.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n-impl<T> ops::IndexMut<ops::Range<usize>> for [T] {\n     #[inline]\n-    fn index_mut(&mut self, index: ops::Range<usize>) -> &mut [T] {\n-        if index.start > index.end {\n-            slice_index_order_fail(index.start, index.end);\n-        } else if index.end > self.len() {\n-            slice_index_len_fail(index.end, self.len());\n+    fn index(self, slice: &[T]) -> &[T] {\n+        match self {\n+            ops::RangeInclusive::Empty { .. } => &[],\n+            ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() => {\n+                panic!(\"attempted to index slice up to maximum usize\");\n+            },\n+            ops::RangeInclusive::NonEmpty { start, end } => (start..end + 1).index(slice),\n         }\n-        unsafe {\n-            from_raw_parts_mut(\n-                self.as_mut_ptr().offset(index.start as isize),\n-                index.end - index.start\n-            )\n+    }\n+\n+    #[inline]\n+    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n+        match self {\n+            ops::RangeInclusive::Empty { .. } => &mut [],\n+            ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() => {\n+                panic!(\"attempted to index slice up to maximum usize\");\n+            },\n+            ops::RangeInclusive::NonEmpty { start, end } => (start..end + 1).index_mut(slice),\n         }\n     }\n }\n \n-/// Implements mutable slicing with syntax `&mut self[.. end]`.\n-///\n-/// Returns a slice of self from the beginning until but not including\n-/// the index `end`.\n-///\n-/// Equivalent to `&mut self[0 .. end]`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n-impl<T> ops::IndexMut<ops::RangeTo<usize>> for [T] {\n+#[stable(feature = \"slice-get-slice-impls\", since = \"1.13.0\")]\n+impl<T> SliceIndex<T> for ops::RangeToInclusive<usize> {\n+    type Output = [T];\n+\n     #[inline]\n-    fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] {\n-        self.index_mut(0 .. index.end)\n+    fn get(self, slice: &[T]) -> Option<&[T]> {\n+        (0...self.end).get(slice)\n     }\n-}\n \n-/// Implements mutable slicing with syntax `&mut self[begin ..]`.\n-///\n-/// Returns a slice of self from and including the index `begin` until the end.\n-///\n-/// Equivalent to `&mut self[begin .. self.len()]`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n-impl<T> ops::IndexMut<ops::RangeFrom<usize>> for [T] {\n     #[inline]\n-    fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] {\n-        let len = self.len();\n-        self.index_mut(index.start .. len)\n+    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n+        (0...self.end).get_mut(slice)\n     }\n-}\n \n-/// Implements mutable slicing with syntax `&mut self[..]`.\n-///\n-/// Returns a slice of the whole slice. This operation can not panic.\n-///\n-/// Equivalent to `&mut self[0 .. self.len()]`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::IndexMut<RangeFull> for [T] {\n     #[inline]\n-    fn index_mut(&mut self, _index: RangeFull) -> &mut [T] {\n-        self\n+    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n+        (0...self.end).get_unchecked(slice)\n     }\n-}\n \n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n-impl<T> ops::IndexMut<ops::RangeInclusive<usize>> for [T] {\n     #[inline]\n-    fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut [T] {\n-        match index {\n-            ops::RangeInclusive::Empty { .. } => &mut [],\n-            ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() =>\n-                panic!(\"attempted to index slice up to maximum usize\"),\n-            ops::RangeInclusive::NonEmpty { start, end } =>\n-                self.index_mut(start .. end+1)\n-        }\n+    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n+        (0...self.end).get_unchecked_mut(slice)\n     }\n-}\n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n-impl<T> ops::IndexMut<ops::RangeToInclusive<usize>> for [T] {\n+\n     #[inline]\n-    fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut [T] {\n-        self.index_mut(0...index.end)\n+    fn index(self, slice: &[T]) -> &[T] {\n+        (0...self.end).index(slice)\n+    }\n+\n+    #[inline]\n+    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n+        (0...self.end).index_mut(slice)\n     }\n }\n \n@@ -983,7 +1146,11 @@ impl<'a, T> Iter<'a, T> {\n iterator!{struct Iter -> *const T, &'a T}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n+impl<'a, T> ExactSizeIterator for Iter<'a, T> {\n+    fn is_empty(&self) -> bool {\n+        self.ptr == self.end\n+    }\n+}\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T> FusedIterator for Iter<'a, T> {}\n@@ -1107,7 +1274,11 @@ impl<'a, T> IterMut<'a, T> {\n iterator!{struct IterMut -> *mut T, &'a mut T}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n+impl<'a, T> ExactSizeIterator for IterMut<'a, T> {\n+    fn is_empty(&self) -> bool {\n+        self.ptr == self.end\n+    }\n+}\n \n #[unstable(feature = \"fused\", issue = \"35602\")]\n impl<'a, T> FusedIterator for IterMut<'a, T> {}"}, {"sha": "de418b831cc8842f0061c6df8319c2fdf26eebc7", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -618,6 +618,11 @@ impl<'a> ExactSizeIterator for Bytes<'a> {\n     fn len(&self) -> usize {\n         self.0.len()\n     }\n+\n+    #[inline]\n+    fn is_empty(&self) -> bool {\n+        self.0.is_empty()\n+    }\n }\n \n #[unstable(feature = \"fused\", issue = \"35602\")]"}, {"sha": "92fb01e535c9d993fd1fa6bec38b4d47e1c0a9ee", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -40,7 +40,7 @@\n extern crate core;\n extern crate test;\n extern crate libc;\n-extern crate rustc_unicode;\n+extern crate std_unicode;\n extern crate rand;\n \n mod any;"}, {"sha": "ad39e6b081b425b7223a5b4d1459633caf0150f7", "filename": "src/libcoretest/slice.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcoretest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibcoretest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fslice.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -180,3 +180,47 @@ fn test_windows_last() {\n     let c2 = v2.windows(2);\n     assert_eq!(c2.last().unwrap()[0], 3);\n }\n+\n+#[test]\n+fn get_range() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    assert_eq!(v.get(..), Some(&[0, 1, 2, 3, 4, 5][..]));\n+    assert_eq!(v.get(..2), Some(&[0, 1][..]));\n+    assert_eq!(v.get(2..), Some(&[2, 3, 4, 5][..]));\n+    assert_eq!(v.get(1..4), Some(&[1, 2, 3][..]));\n+    assert_eq!(v.get(7..), None);\n+    assert_eq!(v.get(7..10), None);\n+}\n+\n+#[test]\n+fn get_mut_range() {\n+    let mut v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    assert_eq!(v.get_mut(..), Some(&mut [0, 1, 2, 3, 4, 5][..]));\n+    assert_eq!(v.get_mut(..2), Some(&mut [0, 1][..]));\n+    assert_eq!(v.get_mut(2..), Some(&mut [2, 3, 4, 5][..]));\n+    assert_eq!(v.get_mut(1..4), Some(&mut [1, 2, 3][..]));\n+    assert_eq!(v.get_mut(7..), None);\n+    assert_eq!(v.get_mut(7..10), None);\n+}\n+\n+#[test]\n+fn get_unchecked_range() {\n+    unsafe {\n+        let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+        assert_eq!(v.get_unchecked(..), &[0, 1, 2, 3, 4, 5][..]);\n+        assert_eq!(v.get_unchecked(..2), &[0, 1][..]);\n+        assert_eq!(v.get_unchecked(2..), &[2, 3, 4, 5][..]);\n+        assert_eq!(v.get_unchecked(1..4), &[1, 2, 3][..]);\n+    }\n+}\n+\n+#[test]\n+fn get_unchecked_mut_range() {\n+    unsafe {\n+        let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+        assert_eq!(v.get_unchecked_mut(..), &mut [0, 1, 2, 3, 4, 5][..]);\n+        assert_eq!(v.get_unchecked_mut(..2), &mut [0, 1][..]);\n+        assert_eq!(v.get_unchecked_mut(2..), &mut[2, 3, 4, 5][..]);\n+        assert_eq!(v.get_unchecked_mut(1..4), &mut [1, 2, 3][..]);\n+    }\n+}"}, {"sha": "220051c9d35eabde71d89e0580c0c22aba62c1cb", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -295,7 +295,6 @@\n #![cfg_attr(not(stage0), deny(warnings))]\n \n #![feature(str_escape)]\n-#![cfg_attr(stage0, feature(question_mark))]\n \n use self::LabelText::*;\n "}, {"sha": "0ac39c5ccf6a04395b7c40dd62321cb91f63f160", "filename": "src/liblibc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -1 +1 @@\n-Subproject commit 6e8c1b490ccbe5e84d248bab883515bc85394b5f\n+Subproject commit 0ac39c5ccf6a04395b7c40dd62321cb91f63f160"}, {"sha": "d90d2864813c9b3f094dd73cc9b33b611bf0d2d1", "filename": "src/libpanic_abort/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibpanic_abort%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibpanic_abort%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2FCargo.toml?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -6,6 +6,7 @@ version = \"0.0.0\"\n [lib]\n path = \"lib.rs\"\n test = false\n+bench = false\n \n [dependencies]\n core = { path = \"../libcore\" }"}, {"sha": "90c16fff6f1f169d5dcf84f12349828cbcefaa7d", "filename": "src/libpanic_unwind/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibpanic_unwind%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibpanic_unwind%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2FCargo.toml?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -6,6 +6,7 @@ version = \"0.0.0\"\n [lib]\n path = \"lib.rs\"\n test = false\n+bench = false\n \n [dependencies]\n alloc = { path = \"../liballoc\" }"}, {"sha": "f21d98a0fc7f97a5eedbb2f9fc3d6b353b375517", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -10,8 +10,6 @@\n \n use rustc_data_structures::graph;\n use cfg::*;\n-use hir::def::Def;\n-use hir::pat_util;\n use ty::{self, TyCtxt};\n use syntax::ast;\n use syntax::ptr::P;\n@@ -100,7 +98,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n     fn pat(&mut self, pat: &hir::Pat, pred: CFGIndex) -> CFGIndex {\n         match pat.node {\n             PatKind::Binding(.., None) |\n-            PatKind::Path(..) |\n+            PatKind::Path(_) |\n             PatKind::Lit(..) |\n             PatKind::Range(..) |\n             PatKind::Wild => {\n@@ -284,15 +282,15 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n             hir::ExprBreak(label, ref opt_expr) => {\n                 let v = self.opt_expr(opt_expr, pred);\n-                let loop_scope = self.find_scope(expr, label.map(|l| l.node));\n+                let loop_scope = self.find_scope(expr, label);\n                 let b = self.add_ast_node(expr.id, &[v]);\n                 self.add_exiting_edge(expr, b,\n                                       loop_scope, loop_scope.break_index);\n                 self.add_unreachable_node()\n             }\n \n             hir::ExprAgain(label) => {\n-                let loop_scope = self.find_scope(expr, label.map(|l| l.node));\n+                let loop_scope = self.find_scope(expr, label);\n                 let a = self.add_ast_node(expr.id, &[pred]);\n                 self.add_exiting_edge(expr, a,\n                                       loop_scope, loop_scope.continue_index);\n@@ -361,7 +359,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n             hir::ExprClosure(..) |\n             hir::ExprLit(..) |\n-            hir::ExprPath(..) => {\n+            hir::ExprPath(_) => {\n                 self.straightline(expr, pred, None::<hir::Expr>.iter())\n             }\n         }\n@@ -457,7 +455,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                     // Visit the guard expression\n                     let guard_exit = self.expr(&guard, guard_start);\n \n-                    let this_has_bindings = pat_util::pat_contains_bindings_or_wild(&pat);\n+                    let this_has_bindings = pat.contains_bindings_or_wild();\n \n                     // If both this pattern and the previous pattern\n                     // were free of bindings, they must consist only\n@@ -570,23 +568,16 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n     fn find_scope(&self,\n                   expr: &hir::Expr,\n-                  label: Option<ast::Name>) -> LoopScope {\n-        if label.is_none() {\n-            return *self.loop_scopes.last().unwrap();\n-        }\n-\n-        match self.tcx.expect_def(expr.id) {\n-            Def::Label(loop_id) => {\n+                  label: Option<hir::Label>) -> LoopScope {\n+        match label {\n+            None => *self.loop_scopes.last().unwrap(),\n+            Some(label) => {\n                 for l in &self.loop_scopes {\n-                    if l.loop_id == loop_id {\n+                    if l.loop_id == label.loop_id {\n                         return *l;\n                     }\n                 }\n-                span_bug!(expr.span, \"no loop scope for id {}\", loop_id);\n-            }\n-\n-            r => {\n-                span_bug!(expr.span, \"bad entry `{:?}` in def_map for label\", r);\n+                span_bug!(expr.span, \"no loop scope for id {}\", label.loop_id);\n             }\n         }\n     }"}, {"sha": "e261c699b6ac60a03a16d5a340f1cef80a3491bc", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -42,6 +42,10 @@ pub enum DepNode<D: Clone + Debug> {\n     // Represents the HIR node with the given node-id\n     Hir(D),\n \n+    // Represents the body of a function or method. The def-id is that of the\n+    // function/method.\n+    HirBody(D),\n+\n     // Represents the metadata for a given HIR node, typically found\n     // in an extern crate.\n     MetaData(D),\n@@ -59,6 +63,7 @@ pub enum DepNode<D: Clone + Debug> {\n     PluginRegistrar,\n     StabilityIndex,\n     CollectItem(D),\n+    CollectItemSig(D),\n     Coherence,\n     EffectCheck,\n     Liveness,\n@@ -90,7 +95,7 @@ pub enum DepNode<D: Clone + Debug> {\n     RvalueCheck(D),\n     Reachability,\n     DeadCheck,\n-    StabilityCheck,\n+    StabilityCheck(D),\n     LateLintCheck,\n     TransCrate,\n     TransCrateItem(D),\n@@ -105,7 +110,6 @@ pub enum DepNode<D: Clone + Debug> {\n     // predicates for an item wind up in `ItemSignature`).\n     AssociatedItems(D),\n     ItemSignature(D),\n-    FieldTy(D),\n     SizedConstraint(D),\n     AssociatedItemDefIds(D),\n     InherentImpls(D),\n@@ -150,12 +154,12 @@ impl<D: Clone + Debug> DepNode<D> {\n             CollectItem,\n             BorrowCheck,\n             Hir,\n+            HirBody,\n             TransCrateItem,\n             TypeckItemType,\n             TypeckItemBody,\n             AssociatedItems,\n             ItemSignature,\n-            FieldTy,\n             AssociatedItemDefIds,\n             InherentImpls,\n             TraitImpls,\n@@ -189,7 +193,6 @@ impl<D: Clone + Debug> DepNode<D> {\n             Privacy => Some(Privacy),\n             Reachability => Some(Reachability),\n             DeadCheck => Some(DeadCheck),\n-            StabilityCheck => Some(StabilityCheck),\n             LateLintCheck => Some(LateLintCheck),\n             TransCrate => Some(TransCrate),\n             TransWriteMetadata => Some(TransWriteMetadata),\n@@ -200,8 +203,10 @@ impl<D: Clone + Debug> DepNode<D> {\n             WorkProduct(ref id) => Some(WorkProduct(id.clone())),\n \n             Hir(ref d) => op(d).map(Hir),\n+            HirBody(ref d) => op(d).map(HirBody),\n             MetaData(ref d) => op(d).map(MetaData),\n             CollectItem(ref d) => op(d).map(CollectItem),\n+            CollectItemSig(ref d) => op(d).map(CollectItemSig),\n             CoherenceCheckImpl(ref d) => op(d).map(CoherenceCheckImpl),\n             CoherenceOverlapCheck(ref d) => op(d).map(CoherenceOverlapCheck),\n             CoherenceOverlapCheckSpecial(ref d) => op(d).map(CoherenceOverlapCheckSpecial),\n@@ -217,11 +222,11 @@ impl<D: Clone + Debug> DepNode<D> {\n             Mir(ref d) => op(d).map(Mir),\n             BorrowCheck(ref d) => op(d).map(BorrowCheck),\n             RvalueCheck(ref d) => op(d).map(RvalueCheck),\n+            StabilityCheck(ref d) => op(d).map(StabilityCheck),\n             TransCrateItem(ref d) => op(d).map(TransCrateItem),\n             TransInlinedItem(ref d) => op(d).map(TransInlinedItem),\n             AssociatedItems(ref d) => op(d).map(AssociatedItems),\n             ItemSignature(ref d) => op(d).map(ItemSignature),\n-            FieldTy(ref d) => op(d).map(FieldTy),\n             SizedConstraint(ref d) => op(d).map(SizedConstraint),\n             AssociatedItemDefIds(ref d) => op(d).map(AssociatedItemDefIds),\n             InherentImpls(ref d) => op(d).map(InherentImpls),"}, {"sha": "6f5f548aa7802de93df4aa1d1068ec6d4f301113", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -129,8 +129,8 @@ impl<'a> CheckAttrVisitor<'a> {\n     }\n }\n \n-impl<'a> Visitor for CheckAttrVisitor<'a> {\n-    fn visit_item(&mut self, item: &ast::Item) {\n+impl<'a> Visitor<'a> for CheckAttrVisitor<'a> {\n+    fn visit_item(&mut self, item: &'a ast::Item) {\n         let target = Target::from_item(item);\n         for attr in &item.attrs {\n             self.check_attribute(attr, target);"}, {"sha": "b6fce2d6ca0be1d6474c92e0a36ab43b4e04df75", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -83,14 +83,6 @@ impl PathResolution {\n         PathResolution { base_def: def, depth: 0 }\n     }\n \n-    /// Get the definition, if fully resolved, otherwise panic.\n-    pub fn full_def(&self) -> Def {\n-        if self.depth != 0 {\n-            bug!(\"path not fully resolved: {:?}\", self);\n-        }\n-        self.base_def\n-    }\n-\n     pub fn kind_name(&self) -> &'static str {\n         if self.depth != 0 {\n             \"associated item\""}, {"sha": "625bde2ca8b67c52dd99ea0be8df8cb602017336", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 169, "deletions": 91, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -38,6 +38,7 @@ use syntax::ast::{NodeId, CRATE_NODE_ID, Name, Attribute};\n use syntax::codemap::Spanned;\n use syntax_pos::Span;\n use hir::*;\n+use hir::def::Def;\n use hir::map::Map;\n use super::itemlikevisit::DeepVisitor;\n \n@@ -66,6 +67,62 @@ impl<'a> FnKind<'a> {\n     }\n }\n \n+/// Specifies what nested things a visitor wants to visit. The most\n+/// common choice is `OnlyBodies`, which will cause the visitor to\n+/// visit fn bodies for fns that it encounters, but skip over nested\n+/// item-like things.\n+///\n+/// See the comments on `ItemLikeVisitor` for more details on the overall\n+/// visit strategy.\n+pub enum NestedVisitorMap<'this, 'tcx: 'this> {\n+    /// Do not visit any nested things. When you add a new\n+    /// \"non-nested\" thing, you will want to audit such uses to see if\n+    /// they remain valid.\n+    ///\n+    /// Use this if you are only walking some particular kind of tree\n+    /// (i.e., a type, or fn signature) and you don't want to thread a\n+    /// HIR map around.\n+    None,\n+\n+    /// Do not visit nested item-like things, but visit nested things\n+    /// that are inside of an item-like.\n+    ///\n+    /// **This is the most common choice.** A very commmon pattern is\n+    /// to use `tcx.visit_all_item_likes_in_krate()` as an outer loop,\n+    /// and to have the visitor that visits the contents of each item\n+    /// using this setting.\n+    OnlyBodies(&'this Map<'tcx>),\n+\n+    /// Visit all nested things, including item-likes.\n+    ///\n+    /// **This is an unusual choice.** It is used when you want to\n+    /// process everything within their lexical context. Typically you\n+    /// kick off the visit by doing `walk_krate()`.\n+    All(&'this Map<'tcx>),\n+}\n+\n+impl<'this, 'tcx> NestedVisitorMap<'this, 'tcx> {\n+    /// Returns the map to use for an \"intra item-like\" thing (if any).\n+    /// e.g., function body.\n+    pub fn intra(self) -> Option<&'this Map<'tcx>> {\n+        match self {\n+            NestedVisitorMap::None => None,\n+            NestedVisitorMap::OnlyBodies(map) => Some(map),\n+            NestedVisitorMap::All(map) => Some(map),\n+        }\n+    }\n+\n+    /// Returns the map to use for an \"item-like\" thing (if any).\n+    /// e.g., item, impl-item.\n+    pub fn inter(self) -> Option<&'this Map<'tcx>> {\n+        match self {\n+            NestedVisitorMap::None => None,\n+            NestedVisitorMap::OnlyBodies(_) => None,\n+            NestedVisitorMap::All(map) => Some(map),\n+        }\n+    }\n+}\n+\n /// Each method of the Visitor trait is a hook to be potentially\n /// overridden.  Each method's default implementation recursively visits\n /// the substructure of the input via the corresponding `walk` method;\n@@ -87,23 +144,22 @@ pub trait Visitor<'v> : Sized {\n     // Nested items.\n \n     /// The default versions of the `visit_nested_XXX` routines invoke\n-    /// this method to get a map to use; if they get back `None`, they\n-    /// just skip nested things. Otherwise, they will lookup the\n-    /// nested item-like things in the map and visit it. So the best\n-    /// way to implement a nested visitor is to override this method\n-    /// to return a `Map`; one advantage of this is that if we add\n-    /// more types of nested things in the future, they will\n-    /// automatically work.\n+    /// this method to get a map to use. By selecting an enum variant,\n+    /// you control which kinds of nested HIR are visited; see\n+    /// `NestedVisitorMap` for details. By \"nested HIR\", we are\n+    /// referring to bits of HIR that are not directly embedded within\n+    /// one another but rather indirectly, through a table in the\n+    /// crate. This is done to control dependencies during incremental\n+    /// compilation: the non-inline bits of HIR can be tracked and\n+    /// hashed separately.\n     ///\n     /// **If for some reason you want the nested behavior, but don't\n     /// have a `Map` are your disposal:** then you should override the\n     /// `visit_nested_XXX` methods, and override this method to\n     /// `panic!()`. This way, if a new `visit_nested_XXX` variant is\n     /// added in the future, we will see the panic in your code and\n     /// fix it appropriately.\n-    fn nested_visit_map(&mut self) -> Option<&Map<'v>> {\n-        None\n-    }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v>;\n \n     /// Invoked when a nested item is encountered. By default does\n     /// nothing unless you override `nested_visit_map` to return\n@@ -115,8 +171,7 @@ pub trait Visitor<'v> : Sized {\n     /// but cannot supply a `Map`; see `nested_visit_map` for advice.\n     #[allow(unused_variables)]\n     fn visit_nested_item(&mut self, id: ItemId) {\n-        let opt_item = self.nested_visit_map()\n-                           .map(|map| map.expect_item(id.id));\n+        let opt_item = self.nested_visit_map().inter().map(|map| map.expect_item(id.id));\n         if let Some(item) = opt_item {\n             self.visit_item(item);\n         }\n@@ -127,13 +182,23 @@ pub trait Visitor<'v> : Sized {\n     /// method.\n     #[allow(unused_variables)]\n     fn visit_nested_impl_item(&mut self, id: ImplItemId) {\n-        let opt_item = self.nested_visit_map()\n-                           .map(|map| map.impl_item(id));\n+        let opt_item = self.nested_visit_map().inter().map(|map| map.impl_item(id));\n         if let Some(item) = opt_item {\n             self.visit_impl_item(item);\n         }\n     }\n \n+    /// Invoked to visit the body of a function, method or closure. Like\n+    /// visit_nested_item, does nothing by default unless you override\n+    /// `nested_visit_map` to return `Some(_)`, in which case it will walk the\n+    /// body.\n+    fn visit_body(&mut self, id: ExprId) {\n+        let opt_expr = self.nested_visit_map().intra().map(|map| map.expr(id));\n+        if let Some(expr) = opt_expr {\n+            self.visit_expr(expr);\n+        }\n+    }\n+\n     /// Visit the top-level item and (optionally) nested items / impl items. See\n     /// `visit_nested_item` for details.\n     fn visit_item(&mut self, i: &'v Item) {\n@@ -155,6 +220,9 @@ pub trait Visitor<'v> : Sized {\n     fn visit_id(&mut self, _node_id: NodeId) {\n         // Nothing to do.\n     }\n+    fn visit_def_mention(&mut self, _def: Def) {\n+        // Nothing to do.\n+    }\n     fn visit_name(&mut self, _span: Span, _name: Name) {\n         // Nothing to do.\n     }\n@@ -196,7 +264,7 @@ pub trait Visitor<'v> : Sized {\n     fn visit_where_predicate(&mut self, predicate: &'v WherePredicate) {\n         walk_where_predicate(self, predicate)\n     }\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: &'v Expr, s: Span, id: NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl, b: ExprId, s: Span, id: NodeId) {\n         walk_fn(self, fk, fd, b, s, id)\n     }\n     fn visit_trait_item(&mut self, ti: &'v TraitItem) {\n@@ -244,12 +312,12 @@ pub trait Visitor<'v> : Sized {\n     fn visit_lifetime_def(&mut self, lifetime: &'v LifetimeDef) {\n         walk_lifetime_def(self, lifetime)\n     }\n+    fn visit_qpath(&mut self, qpath: &'v QPath, id: NodeId, span: Span) {\n+        walk_qpath(self, qpath, id, span)\n+    }\n     fn visit_path(&mut self, path: &'v Path, _id: NodeId) {\n         walk_path(self, path)\n     }\n-    fn visit_path_list_item(&mut self, prefix: &'v Path, item: &'v PathListItem) {\n-        walk_path_list_item(self, prefix, item)\n-    }\n     fn visit_path_segment(&mut self, path_span: Span, path_segment: &'v PathSegment) {\n         walk_path_segment(self, path_span, path_segment)\n     }\n@@ -349,31 +417,17 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_id(item.id);\n             walk_opt_name(visitor, item.span, opt_name)\n         }\n-        ItemUse(ref vp) => {\n+        ItemUse(ref path, _) => {\n             visitor.visit_id(item.id);\n-            match vp.node {\n-                ViewPathSimple(name, ref path) => {\n-                    visitor.visit_name(vp.span, name);\n-                    visitor.visit_path(path, item.id);\n-                }\n-                ViewPathGlob(ref path) => {\n-                    visitor.visit_path(path, item.id);\n-                }\n-                ViewPathList(ref prefix, ref list) => {\n-                    visitor.visit_path(prefix, item.id);\n-                    for item in list {\n-                        visitor.visit_path_list_item(prefix, item)\n-                    }\n-                }\n-            }\n+            visitor.visit_path(path, item.id);\n         }\n         ItemStatic(ref typ, _, ref expr) |\n         ItemConst(ref typ, ref expr) => {\n             visitor.visit_id(item.id);\n             visitor.visit_ty(typ);\n             visitor.visit_expr(expr);\n         }\n-        ItemFn(ref declaration, unsafety, constness, abi, ref generics, ref body) => {\n+        ItemFn(ref declaration, unsafety, constness, abi, ref generics, body_id) => {\n             visitor.visit_fn(FnKind::ItemFn(item.name,\n                                             generics,\n                                             unsafety,\n@@ -382,7 +436,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n                                             &item.vis,\n                                             &item.attrs),\n                              declaration,\n-                             body,\n+                             body_id,\n                              item.span,\n                              item.id)\n         }\n@@ -481,11 +535,8 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             walk_fn_decl(visitor, &function_declaration.decl);\n             walk_list!(visitor, visit_lifetime_def, &function_declaration.lifetimes);\n         }\n-        TyPath(ref maybe_qself, ref path) => {\n-            if let Some(ref qself) = *maybe_qself {\n-                visitor.visit_ty(&qself.ty);\n-            }\n-            visitor.visit_path(path, typ.id);\n+        TyPath(ref qpath) => {\n+            visitor.visit_qpath(qpath, typ.id, typ.span);\n         }\n         TyObjectSum(ref ty, ref bounds) => {\n             visitor.visit_ty(ty);\n@@ -508,20 +559,28 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n     }\n }\n \n+pub fn walk_qpath<'v, V: Visitor<'v>>(visitor: &mut V, qpath: &'v QPath, id: NodeId, span: Span) {\n+    match *qpath {\n+        QPath::Resolved(ref maybe_qself, ref path) => {\n+            if let Some(ref qself) = *maybe_qself {\n+                visitor.visit_ty(qself);\n+            }\n+            visitor.visit_path(path, id)\n+        }\n+        QPath::TypeRelative(ref qself, ref segment) => {\n+            visitor.visit_ty(qself);\n+            visitor.visit_path_segment(span, segment);\n+        }\n+    }\n+}\n+\n pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path) {\n+    visitor.visit_def_mention(path.def);\n     for segment in &path.segments {\n         visitor.visit_path_segment(path.span, segment);\n     }\n }\n \n-pub fn walk_path_list_item<'v, V>(visitor: &mut V, _prefix: &'v Path, item: &'v PathListItem)\n-    where V: Visitor<'v>,\n-{\n-    visitor.visit_id(item.node.id);\n-    visitor.visit_name(item.span, item.node.name);\n-    walk_opt_name(visitor, item.span, item.node.rename);\n-}\n-\n pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V,\n                                              path_span: Span,\n                                              segment: &'v PathSegment) {\n@@ -555,18 +614,15 @@ pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V,\n pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n     visitor.visit_id(pattern.id);\n     match pattern.node {\n-        PatKind::TupleStruct(ref path, ref children, _) => {\n-            visitor.visit_path(path, pattern.id);\n+        PatKind::TupleStruct(ref qpath, ref children, _) => {\n+            visitor.visit_qpath(qpath, pattern.id, pattern.span);\n             walk_list!(visitor, visit_pat, children);\n         }\n-        PatKind::Path(ref opt_qself, ref path) => {\n-            if let Some(ref qself) = *opt_qself {\n-                visitor.visit_ty(&qself.ty);\n-            }\n-            visitor.visit_path(path, pattern.id)\n+        PatKind::Path(ref qpath) => {\n+            visitor.visit_qpath(qpath, pattern.id, pattern.span);\n         }\n-        PatKind::Struct(ref path, ref fields, _) => {\n-            visitor.visit_path(path, pattern.id);\n+        PatKind::Struct(ref qpath, ref fields, _) => {\n+            visitor.visit_qpath(qpath, pattern.id, pattern.span);\n             for field in fields {\n                 visitor.visit_name(field.span, field.node.name);\n                 visitor.visit_pat(&field.node.pat)\n@@ -579,7 +635,8 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n         PatKind::Ref(ref subpattern, _) => {\n             visitor.visit_pat(subpattern)\n         }\n-        PatKind::Binding(_, ref pth1, ref optional_subpattern) => {\n+        PatKind::Binding(_, def_id, ref pth1, ref optional_subpattern) => {\n+            visitor.visit_def_mention(Def::Local(def_id));\n             visitor.visit_name(pth1.span, pth1.node);\n             walk_list!(visitor, visit_pat, optional_subpattern);\n         }\n@@ -704,13 +761,25 @@ pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V, function_kind: FnKind<'\n pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n                                    function_kind: FnKind<'v>,\n                                    function_declaration: &'v FnDecl,\n-                                   function_body: &'v Expr,\n+                                   body_id: ExprId,\n                                    _span: Span,\n                                    id: NodeId) {\n     visitor.visit_id(id);\n     walk_fn_decl(visitor, function_declaration);\n     walk_fn_kind(visitor, function_kind);\n-    visitor.visit_expr(function_body)\n+    visitor.visit_body(body_id)\n+}\n+\n+pub fn walk_fn_with_body<'v, V: Visitor<'v>>(visitor: &mut V,\n+                                             function_kind: FnKind<'v>,\n+                                             function_declaration: &'v FnDecl,\n+                                             body: &'v Expr,\n+                                             _span: Span,\n+                                             id: NodeId) {\n+    visitor.visit_id(id);\n+    walk_fn_decl(visitor, function_declaration);\n+    walk_fn_kind(visitor, function_kind);\n+    visitor.visit_expr(body)\n }\n \n pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem) {\n@@ -727,13 +796,13 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n             visitor.visit_generics(&sig.generics);\n             walk_fn_decl(visitor, &sig.decl);\n         }\n-        MethodTraitItem(ref sig, Some(ref body)) => {\n+        MethodTraitItem(ref sig, Some(body_id)) => {\n             visitor.visit_fn(FnKind::Method(trait_item.name,\n                                             sig,\n                                             None,\n                                             &trait_item.attrs),\n                              &sig.decl,\n-                             body,\n+                             body_id,\n                              trait_item.span,\n                              trait_item.id);\n         }\n@@ -759,13 +828,13 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n             visitor.visit_ty(ty);\n             visitor.visit_expr(expr);\n         }\n-        ImplItemKind::Method(ref sig, ref body) => {\n+        ImplItemKind::Method(ref sig, body_id) => {\n             visitor.visit_fn(FnKind::Method(impl_item.name,\n                                             sig,\n                                             Some(&impl_item.vis),\n                                             &impl_item.attrs),\n                              &sig.decl,\n-                             body,\n+                             body_id,\n                              impl_item.span,\n                              impl_item.id);\n         }\n@@ -840,8 +909,8 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(element);\n             visitor.visit_expr(count)\n         }\n-        ExprStruct(ref path, ref fields, ref optional_base) => {\n-            visitor.visit_path(path, expression.id);\n+        ExprStruct(ref qpath, ref fields, ref optional_base) => {\n+            visitor.visit_qpath(qpath, expression.id, expression.span);\n             for field in fields {\n                 visitor.visit_name(field.name.span, field.name.node);\n                 visitor.visit_expr(&field.expr)\n@@ -890,7 +959,7 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(subexpression);\n             walk_list!(visitor, visit_arm, arms);\n         }\n-        ExprClosure(_, ref function_declaration, ref body, _fn_decl_span) => {\n+        ExprClosure(_, ref function_declaration, body, _fn_decl_span) => {\n             visitor.visit_fn(FnKind::Closure(&expression.attrs),\n                              function_declaration,\n                              body,\n@@ -917,18 +986,21 @@ pub fn walk_expr<'v, V: Visitor<'v>>(visitor: &mut V, expression: &'v Expr) {\n             visitor.visit_expr(main_expression);\n             visitor.visit_expr(index_expression)\n         }\n-        ExprPath(ref maybe_qself, ref path) => {\n-            if let Some(ref qself) = *maybe_qself {\n-                visitor.visit_ty(&qself.ty);\n-            }\n-            visitor.visit_path(path, expression.id)\n+        ExprPath(ref qpath) => {\n+            visitor.visit_qpath(qpath, expression.id, expression.span);\n         }\n-        ExprBreak(ref opt_sp_name, ref opt_expr) => {\n-            walk_opt_sp_name(visitor, opt_sp_name);\n+        ExprBreak(None, ref opt_expr) => {\n             walk_list!(visitor, visit_expr, opt_expr);\n         }\n-        ExprAgain(ref opt_sp_name) => {\n-            walk_opt_sp_name(visitor, opt_sp_name);\n+        ExprBreak(Some(label), ref opt_expr) => {\n+            visitor.visit_def_mention(Def::Label(label.loop_id));\n+            visitor.visit_name(label.span, label.name);\n+            walk_list!(visitor, visit_expr, opt_expr);\n+        }\n+        ExprAgain(None) => {}\n+        ExprAgain(Some(label)) => {\n+            visitor.visit_def_mention(Def::Label(label.loop_id));\n+            visitor.visit_name(label.span, label.name);\n         }\n         ExprRet(ref optional_expression) => {\n             walk_list!(visitor, visit_expr, optional_expression);\n@@ -1002,34 +1074,40 @@ impl IdRange {\n }\n \n \n-pub struct IdRangeComputingVisitor {\n-    pub result: IdRange,\n+pub struct IdRangeComputingVisitor<'a, 'ast: 'a> {\n+    result: IdRange,\n+    map: &'a map::Map<'ast>,\n }\n \n-impl IdRangeComputingVisitor {\n-    pub fn new() -> IdRangeComputingVisitor {\n-        IdRangeComputingVisitor { result: IdRange::max() }\n+impl<'a, 'ast> IdRangeComputingVisitor<'a, 'ast> {\n+    pub fn new(map: &'a map::Map<'ast>) -> IdRangeComputingVisitor<'a, 'ast> {\n+        IdRangeComputingVisitor { result: IdRange::max(), map: map }\n     }\n \n     pub fn result(&self) -> IdRange {\n         self.result\n     }\n }\n \n-impl<'v> Visitor<'v> for IdRangeComputingVisitor {\n+impl<'a, 'ast> Visitor<'ast> for IdRangeComputingVisitor<'a, 'ast> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'ast> {\n+        NestedVisitorMap::OnlyBodies(&self.map)\n+    }\n+\n     fn visit_id(&mut self, id: NodeId) {\n         self.result.add(id);\n     }\n }\n \n /// Computes the id range for a single fn body, ignoring nested items.\n-pub fn compute_id_range_for_fn_body(fk: FnKind,\n-                                    decl: &FnDecl,\n-                                    body: &Expr,\n-                                    sp: Span,\n-                                    id: NodeId)\n-                                    -> IdRange {\n-    let mut visitor = IdRangeComputingVisitor::new();\n-    visitor.visit_fn(fk, decl, body, sp, id);\n+pub fn compute_id_range_for_fn_body<'v>(fk: FnKind<'v>,\n+                                        decl: &'v FnDecl,\n+                                        body: &'v Expr,\n+                                        sp: Span,\n+                                        id: NodeId,\n+                                        map: &map::Map<'v>)\n+                                        -> IdRange {\n+    let mut visitor = IdRangeComputingVisitor::new(map);\n+    walk_fn_with_body(&mut visitor, fk, decl, body, sp, id);\n     visitor.result()\n }"}, {"sha": "71ef7131440b80393fa90c3e3880437befd77909", "filename": "src/librustc/hir/itemlikevisit.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -41,8 +41,10 @@ use super::intravisit::Visitor;\n ///    item-like things.\n ///    - Example: Lifetime resolution, which wants to bring lifetimes declared on the\n ///      impl into scope while visiting the impl-items, and then back out again.\n-///    - How: Implement `intravisit::Visitor` and override the `visit_nested_foo()` foo methods\n-///      as needed. Walk your crate with `intravisit::walk_crate()` invoked on `tcx.map.krate()`.\n+///    - How: Implement `intravisit::Visitor` and override the\n+///      `visit_nested_map()` methods to return\n+///      `NestedVisitorMap::All`. Walk your crate with\n+///      `intravisit::walk_crate()` invoked on `tcx.map.krate()`.\n ///    - Pro: Visitor methods for any kind of HIR node, not just item-like things.\n ///    - Pro: Preserves nesting information\n ///    - Con: Does not integrate well into dependency tracking."}, {"sha": "74876eb59ee9a12eac05a524cff6393fc00ef507", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 508, "deletions": 340, "changes": 848, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -46,15 +46,20 @@ use hir::map::definitions::DefPathData;\n use hir::def_id::{DefIndex, DefId};\n use hir::def::{Def, PathResolution};\n use session::Session;\n+use util::nodemap::NodeMap;\n+use rustc_data_structures::fnv::FnvHashMap;\n \n use std::collections::BTreeMap;\n use std::iter;\n+use std::mem;\n+\n use syntax::ast::*;\n use syntax::errors;\n use syntax::ptr::P;\n-use syntax::codemap::{respan, Spanned};\n+use syntax::codemap::{self, respan, Spanned};\n use syntax::std_inject;\n use syntax::symbol::{Symbol, keywords};\n+use syntax::util::small_vector::SmallVector;\n use syntax::visit::{self, Visitor};\n use syntax_pos::Span;\n \n@@ -66,19 +71,22 @@ pub struct LoweringContext<'a> {\n     // the form of a DefIndex) so that if we create a new node which introduces\n     // a definition, then we can properly create the def id.\n     parent_def: Option<DefIndex>,\n+    exprs: FnvHashMap<hir::ExprId, hir::Expr>,\n     resolver: &'a mut Resolver,\n+\n+    /// The items being lowered are collected here.\n+    items: BTreeMap<NodeId, hir::Item>,\n+\n+    impl_items: BTreeMap<hir::ImplItemId, hir::ImplItem>,\n }\n \n pub trait Resolver {\n     // Resolve a global hir path generated by the lowerer when expanding `for`, `if let`, etc.\n-    fn resolve_generated_global_path(&mut self, path: &hir::Path, is_value: bool) -> Def;\n+    fn resolve_hir_path(&mut self, path: &mut hir::Path, is_value: bool);\n \n     // Obtain the resolution for a node id\n     fn get_resolution(&mut self, id: NodeId) -> Option<PathResolution>;\n \n-    // Record the resolution of a path or binding generated by the lowerer when expanding.\n-    fn record_resolution(&mut self, id: NodeId, def: Def);\n-\n     // We must keep the set of definitions up to date as we add nodes that weren't in the AST.\n     // This should only return `None` during testing.\n     fn definitions(&mut self) -> &mut Definitions;\n@@ -97,53 +105,82 @@ pub fn lower_crate(sess: &Session,\n         crate_root: std_inject::injected_crate_name(krate),\n         sess: sess,\n         parent_def: None,\n+        exprs: FnvHashMap(),\n         resolver: resolver,\n+        items: BTreeMap::new(),\n+        impl_items: BTreeMap::new(),\n     }.lower_crate(krate)\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq)]\n+enum ParamMode {\n+    /// Any path in a type context.\n+    Explicit,\n+    /// The `module::Type` in `module::Type::method` in an expression.\n+    Optional\n+}\n+\n impl<'a> LoweringContext<'a> {\n-    fn lower_crate(&mut self, c: &Crate) -> hir::Crate {\n+    fn lower_crate(mut self, c: &Crate) -> hir::Crate {\n+        self.lower_items(c);\n+        let module = self.lower_mod(&c.module);\n+        let attrs = self.lower_attrs(&c.attrs);\n+        let exported_macros = c.exported_macros.iter().map(|m| self.lower_macro_def(m)).collect();\n+\n+        hir::Crate {\n+            module: module,\n+            attrs: attrs,\n+            span: c.span,\n+            exported_macros: exported_macros,\n+            items: self.items,\n+            impl_items: self.impl_items,\n+            exprs: mem::replace(&mut self.exprs, FnvHashMap()),\n+        }\n+    }\n+\n+    fn lower_items(&mut self, c: &Crate) {\n         struct ItemLowerer<'lcx, 'interner: 'lcx> {\n-            items: BTreeMap<NodeId, hir::Item>,\n-            impl_items: BTreeMap<hir::ImplItemId, hir::ImplItem>,\n             lctx: &'lcx mut LoweringContext<'interner>,\n         }\n \n-        impl<'lcx, 'interner> Visitor for ItemLowerer<'lcx, 'interner> {\n-            fn visit_item(&mut self, item: &Item) {\n-                self.items.insert(item.id, self.lctx.lower_item(item));\n+        impl<'lcx, 'interner> Visitor<'lcx> for ItemLowerer<'lcx, 'interner> {\n+            fn visit_item(&mut self, item: &'lcx Item) {\n+                let hir_item = self.lctx.lower_item(item);\n+                self.lctx.items.insert(item.id, hir_item);\n                 visit::walk_item(self, item);\n             }\n \n-            fn visit_impl_item(&mut self, item: &ImplItem) {\n+            fn visit_impl_item(&mut self, item: &'lcx ImplItem) {\n                 let id = self.lctx.lower_impl_item_ref(item).id;\n-                self.impl_items.insert(id, self.lctx.lower_impl_item(item));\n+                let hir_item = self.lctx.lower_impl_item(item);\n+                self.lctx.impl_items.insert(id, hir_item);\n                 visit::walk_impl_item(self, item);\n             }\n         }\n \n-        let (items, impl_items) = {\n-            let mut item_lowerer = ItemLowerer { items: BTreeMap::new(),\n-                                                 impl_items: BTreeMap::new(),\n-                                                 lctx: self };\n-            visit::walk_crate(&mut item_lowerer, c);\n-            (item_lowerer.items, item_lowerer.impl_items)\n-        };\n+        let mut item_lowerer = ItemLowerer { lctx: self };\n+        visit::walk_crate(&mut item_lowerer, c);\n+    }\n \n-        hir::Crate {\n-            module: self.lower_mod(&c.module),\n-            attrs: self.lower_attrs(&c.attrs),\n-            span: c.span,\n-            exported_macros: c.exported_macros.iter().map(|m| self.lower_macro_def(m)).collect(),\n-            items: items,\n-            impl_items: impl_items,\n-        }\n+    fn record_expr(&mut self, expr: hir::Expr) -> hir::ExprId {\n+        let id = hir::ExprId(expr.id);\n+        self.exprs.insert(id, expr);\n+        id\n     }\n \n     fn next_id(&self) -> NodeId {\n         self.sess.next_node_id()\n     }\n \n+    fn expect_full_def(&mut self, id: NodeId) -> Def {\n+        self.resolver.get_resolution(id).map_or(Def::Err, |pr| {\n+            if pr.depth != 0 {\n+                bug!(\"path not fully resolved: {:?}\", pr);\n+            }\n+            pr.base_def\n+        })\n+    }\n+\n     fn diagnostic(&self) -> &errors::Handler {\n         self.sess.diagnostic()\n     }\n@@ -152,6 +189,18 @@ impl<'a> LoweringContext<'a> {\n         Symbol::gensym(s)\n     }\n \n+    fn allow_internal_unstable(&self, reason: &'static str, mut span: Span) -> Span {\n+        span.expn_id = self.sess.codemap().record_expansion(codemap::ExpnInfo {\n+            call_site: span,\n+            callee: codemap::NameAndSpan {\n+                format: codemap::CompilerDesugaring(Symbol::intern(reason)),\n+                span: Some(span),\n+                allow_internal_unstable: true,\n+            },\n+        });\n+        span\n+    }\n+\n     fn with_parent_def<T, F>(&mut self, parent_id: NodeId, f: F) -> T\n         where F: FnOnce(&mut LoweringContext) -> T\n     {\n@@ -171,39 +220,21 @@ impl<'a> LoweringContext<'a> {\n         o_id.map(|sp_ident| respan(sp_ident.span, sp_ident.node.name))\n     }\n \n-    fn lower_attrs(&mut self, attrs: &Vec<Attribute>) -> hir::HirVec<Attribute> {\n-        attrs.clone().into()\n-    }\n-\n-    fn lower_view_path(&mut self, view_path: &ViewPath) -> P<hir::ViewPath> {\n-        P(Spanned {\n-            node: match view_path.node {\n-                ViewPathSimple(ident, ref path) => {\n-                    hir::ViewPathSimple(ident.name, self.lower_path(path))\n-                }\n-                ViewPathGlob(ref path) => {\n-                    hir::ViewPathGlob(self.lower_path(path))\n+    fn lower_label(&mut self, id: NodeId, label: Option<Spanned<Ident>>) -> Option<hir::Label> {\n+        label.map(|sp_ident| {\n+            hir::Label {\n+                span: sp_ident.span,\n+                name: sp_ident.node.name,\n+                loop_id: match self.expect_full_def(id) {\n+                    Def::Label(loop_id) => loop_id,\n+                    _ => DUMMY_NODE_ID\n                 }\n-                ViewPathList(ref path, ref path_list_idents) => {\n-                    hir::ViewPathList(self.lower_path(path),\n-                                      path_list_idents.iter()\n-                                                      .map(|item| self.lower_path_list_item(item))\n-                                                      .collect())\n-                }\n-            },\n-            span: view_path.span,\n+            }\n         })\n     }\n \n-    fn lower_path_list_item(&mut self, path_list_ident: &PathListItem) -> hir::PathListItem {\n-        Spanned {\n-            node: hir::PathListItem_ {\n-                id: path_list_ident.node.id,\n-                name: path_list_ident.node.name.name,\n-                rename: path_list_ident.node.rename.map(|rename| rename.name),\n-            },\n-            span: path_list_ident.span,\n-        }\n+    fn lower_attrs(&mut self, attrs: &Vec<Attribute>) -> hir::HirVec<Attribute> {\n+        attrs.clone().into()\n     }\n \n     fn lower_arm(&mut self, arm: &Arm) -> hir::Arm {\n@@ -250,13 +281,7 @@ impl<'a> LoweringContext<'a> {\n                     return self.lower_ty(ty);\n                 }\n                 TyKind::Path(ref qself, ref path) => {\n-                    let qself = qself.as_ref().map(|&QSelf { ref ty, position }| {\n-                        hir::QSelf {\n-                            ty: self.lower_ty(ty),\n-                            position: position,\n-                        }\n-                    });\n-                    hir::TyPath(qself, self.lower_path(path))\n+                    hir::TyPath(self.lower_qpath(t.id, qself, path, ParamMode::Explicit))\n                 }\n                 TyKind::ObjectSum(ref ty, ref bounds) => {\n                     hir::TyObjectSum(self.lower_ty(ty), self.lower_bounds(bounds))\n@@ -298,38 +323,140 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_path(&mut self, p: &Path) -> hir::Path {\n+    fn lower_qpath(&mut self,\n+                   id: NodeId,\n+                   qself: &Option<QSelf>,\n+                   p: &Path,\n+                   param_mode: ParamMode)\n+                   -> hir::QPath {\n+        let qself_position = qself.as_ref().map(|q| q.position);\n+        let qself = qself.as_ref().map(|q| self.lower_ty(&q.ty));\n+\n+        let resolution = self.resolver.get_resolution(id)\n+                                      .unwrap_or(PathResolution::new(Def::Err));\n+\n+        let proj_start = p.segments.len() - resolution.depth;\n+        let path = P(hir::Path {\n+            global: p.global,\n+            def: resolution.base_def,\n+            segments: p.segments[..proj_start].iter().enumerate().map(|(i, segment)| {\n+                let param_mode = match (qself_position, param_mode) {\n+                    (Some(j), ParamMode::Optional) if i < j => {\n+                        // This segment is part of the trait path in a\n+                        // qualified path - one of `a`, `b` or `Trait`\n+                        // in `<X as a::b::Trait>::T::U::method`.\n+                        ParamMode::Explicit\n+                    }\n+                    _ => param_mode\n+                };\n+                self.lower_path_segment(segment, param_mode)\n+            }).collect(),\n+            span: p.span,\n+        });\n+\n+        // Simple case, either no projections, or only fully-qualified.\n+        // E.g. `std::mem::size_of` or `<I as Iterator>::Item`.\n+        if resolution.depth == 0 {\n+            return hir::QPath::Resolved(qself, path);\n+        }\n+\n+        // Create the innermost type that we're projecting from.\n+        let mut ty = if path.segments.is_empty() {\n+            // If the base path is empty that means there exists a\n+            // syntactical `Self`, e.g. `&i32` in `<&i32>::clone`.\n+            qself.expect(\"missing QSelf for <T>::...\")\n+        } else {\n+            // Otherwise, the base path is an implicit `Self` type path,\n+            // e.g. `Vec` in `Vec::new` or `<I as Iterator>::Item` in\n+            // `<I as Iterator>::Item::default`.\n+            self.ty(p.span, hir::TyPath(hir::QPath::Resolved(qself, path)))\n+        };\n+\n+        // Anything after the base path are associated \"extensions\",\n+        // out of which all but the last one are associated types,\n+        // e.g. for `std::vec::Vec::<T>::IntoIter::Item::clone`:\n+        // * base path is `std::vec::Vec<T>`\n+        // * \"extensions\" are `IntoIter`, `Item` and `clone`\n+        // * type nodes are:\n+        //   1. `std::vec::Vec<T>` (created above)\n+        //   2. `<std::vec::Vec<T>>::IntoIter`\n+        //   3. `<<std::vec::Vec<T>>::IntoIter>::Item`\n+        // * final path is `<<<std::vec::Vec<T>>::IntoIter>::Item>::clone`\n+        for (i, segment) in p.segments.iter().enumerate().skip(proj_start) {\n+            let segment = P(self.lower_path_segment(segment, param_mode));\n+            let qpath = hir::QPath::TypeRelative(ty, segment);\n+\n+            // It's finished, return the extension of the right node type.\n+            if i == p.segments.len() - 1 {\n+                return qpath;\n+            }\n+\n+            // Wrap the associated extension in another type node.\n+            ty = self.ty(p.span, hir::TyPath(qpath));\n+        }\n+\n+        // Should've returned in the for loop above.\n+        span_bug!(p.span, \"lower_qpath: no final extension segment in {}..{}\",\n+                  proj_start, p.segments.len())\n+    }\n+\n+    fn lower_path_extra(&mut self,\n+                        id: NodeId,\n+                        p: &Path,\n+                        name: Option<Name>,\n+                        param_mode: ParamMode)\n+                        -> hir::Path {\n         hir::Path {\n             global: p.global,\n-            segments: p.segments\n-                       .iter()\n-                       .map(|&PathSegment { identifier, ref parameters }| {\n-                           hir::PathSegment {\n-                               name: identifier.name,\n-                               parameters: self.lower_path_parameters(parameters),\n-                           }\n-                       })\n-                       .collect(),\n+            def: self.expect_full_def(id),\n+            segments: p.segments.iter().map(|segment| {\n+                self.lower_path_segment(segment, param_mode)\n+            }).chain(name.map(|name| {\n+                hir::PathSegment {\n+                    name: name,\n+                    parameters: hir::PathParameters::none()\n+                }\n+            })).collect(),\n             span: p.span,\n         }\n     }\n \n-    fn lower_path_parameters(&mut self, path_parameters: &PathParameters) -> hir::PathParameters {\n-        match *path_parameters {\n-            PathParameters::AngleBracketed(ref data) =>\n-                hir::AngleBracketedParameters(self.lower_angle_bracketed_parameter_data(data)),\n+    fn lower_path(&mut self,\n+                  id: NodeId,\n+                  p: &Path,\n+                  param_mode: ParamMode)\n+                  -> hir::Path {\n+        self.lower_path_extra(id, p, None, param_mode)\n+    }\n+\n+    fn lower_path_segment(&mut self,\n+                          segment: &PathSegment,\n+                          param_mode: ParamMode)\n+                          -> hir::PathSegment {\n+        let parameters = match segment.parameters {\n+            PathParameters::AngleBracketed(ref data) => {\n+                let data = self.lower_angle_bracketed_parameter_data(data, param_mode);\n+                hir::AngleBracketedParameters(data)\n+            }\n             PathParameters::Parenthesized(ref data) =>\n                 hir::ParenthesizedParameters(self.lower_parenthesized_parameter_data(data)),\n+        };\n+\n+        hir::PathSegment {\n+            name: segment.identifier.name,\n+            parameters: parameters,\n         }\n     }\n \n     fn lower_angle_bracketed_parameter_data(&mut self,\n-                                            data: &AngleBracketedParameterData)\n+                                            data: &AngleBracketedParameterData,\n+                                            param_mode: ParamMode)\n                                             -> hir::AngleBracketedParameterData {\n         let &AngleBracketedParameterData { ref lifetimes, ref types, ref bindings } = data;\n         hir::AngleBracketedParameterData {\n             lifetimes: self.lower_lifetimes(lifetimes),\n             types: types.iter().map(|ty| self.lower_ty(ty)).collect(),\n+            infer_types: types.is_empty() && param_mode == ParamMode::Optional,\n             bindings: bindings.iter().map(|b| self.lower_ty_binding(b)).collect(),\n         }\n     }\n@@ -394,7 +521,7 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_ty_param(&mut self, tp: &TyParam) -> hir::TyParam {\n+    fn lower_ty_param(&mut self, tp: &TyParam, add_bounds: &[TyParamBound]) -> hir::TyParam {\n         let mut name = tp.ident.name;\n \n         // Don't expose `Self` (recovered \"keyword used as ident\" parse error).\n@@ -404,18 +531,26 @@ impl<'a> LoweringContext<'a> {\n             name = Symbol::gensym(\"Self\");\n         }\n \n+        let mut bounds = self.lower_bounds(&tp.bounds);\n+        if !add_bounds.is_empty() {\n+            bounds = bounds.into_iter().chain(self.lower_bounds(add_bounds).into_iter()).collect();\n+        }\n+\n         hir::TyParam {\n             id: tp.id,\n             name: name,\n-            bounds: self.lower_bounds(&tp.bounds),\n+            bounds: bounds,\n             default: tp.default.as_ref().map(|x| self.lower_ty(x)),\n             span: tp.span,\n             pure_wrt_drop: tp.attrs.iter().any(|attr| attr.check_name(\"may_dangle\")),\n         }\n     }\n \n-    fn lower_ty_params(&mut self, tps: &P<[TyParam]>) -> hir::HirVec<hir::TyParam> {\n-        tps.iter().map(|tp| self.lower_ty_param(tp)).collect()\n+    fn lower_ty_params(&mut self, tps: &P<[TyParam]>, add_bounds: &NodeMap<Vec<TyParamBound>>)\n+                       -> hir::HirVec<hir::TyParam> {\n+        tps.iter().map(|tp| {\n+            self.lower_ty_param(tp, add_bounds.get(&tp.id).map_or(&[][..], |x| &x))\n+        }).collect()\n     }\n \n     fn lower_lifetime(&mut self, l: &Lifetime) -> hir::Lifetime {\n@@ -447,8 +582,47 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_generics(&mut self, g: &Generics) -> hir::Generics {\n+        // Collect `?Trait` bounds in where clause and move them to parameter definitions.\n+        let mut add_bounds = NodeMap();\n+        for pred in &g.where_clause.predicates {\n+            if let WherePredicate::BoundPredicate(ref bound_pred) = *pred {\n+                'next_bound: for bound in &bound_pred.bounds {\n+                    if let TraitTyParamBound(_, TraitBoundModifier::Maybe) = *bound {\n+                        let report_error = |this: &mut Self| {\n+                            this.diagnostic().span_err(bound_pred.bounded_ty.span,\n+                                                       \"`?Trait` bounds are only permitted at the \\\n+                                                        point where a type parameter is declared\");\n+                        };\n+                        // Check if the where clause type is a plain type parameter.\n+                        match bound_pred.bounded_ty.node {\n+                            TyKind::Path(None, ref path)\n+                                    if !path.global && path.segments.len() == 1 &&\n+                                        bound_pred.bound_lifetimes.is_empty() => {\n+                                if let Some(Def::TyParam(def_id)) =\n+                                        self.resolver.get_resolution(bound_pred.bounded_ty.id)\n+                                                     .map(|d| d.base_def) {\n+                                    if let Some(node_id) =\n+                                            self.resolver.definitions().as_local_node_id(def_id) {\n+                                        for ty_param in &g.ty_params {\n+                                            if node_id == ty_param.id {\n+                                                add_bounds.entry(ty_param.id).or_insert(Vec::new())\n+                                                                            .push(bound.clone());\n+                                                continue 'next_bound;\n+                                            }\n+                                        }\n+                                    }\n+                                }\n+                                report_error(self)\n+                            }\n+                            _ => report_error(self)\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n         hir::Generics {\n-            ty_params: self.lower_ty_params(&g.ty_params),\n+            ty_params: self.lower_ty_params(&g.ty_params, &add_bounds),\n             lifetimes: self.lower_lifetime_defs(&g.lifetimes),\n             where_clause: self.lower_where_clause(&g.where_clause),\n             span: g.span,\n@@ -474,7 +648,11 @@ impl<'a> LoweringContext<'a> {\n                 hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n                     bound_lifetimes: self.lower_lifetime_defs(bound_lifetimes),\n                     bounded_ty: self.lower_ty(bounded_ty),\n-                    bounds: bounds.iter().map(|x| self.lower_ty_param_bound(x)).collect(),\n+                    bounds: bounds.iter().filter_map(|bound| match *bound {\n+                        // Ignore `?Trait` bounds, they were copied into type parameters already.\n+                        TraitTyParamBound(_, TraitBoundModifier::Maybe) => None,\n+                        _ => Some(self.lower_ty_param_bound(bound))\n+                    }).collect(),\n                     span: span,\n                 })\n             }\n@@ -493,7 +671,7 @@ impl<'a> LoweringContext<'a> {\n                                                           span}) => {\n                 hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n                     id: id,\n-                    path: self.lower_path(path),\n+                    path: self.lower_path(id, path, ParamMode::Explicit),\n                     ty: self.lower_ty(ty),\n                     span: span,\n                 })\n@@ -523,7 +701,7 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_trait_ref(&mut self, p: &TraitRef) -> hir::TraitRef {\n         hir::TraitRef {\n-            path: self.lower_path(&p.path),\n+            path: self.lower_path(p.ref_id, &p.path, ParamMode::Explicit),\n             ref_id: p.ref_id,\n         }\n     }\n@@ -563,17 +741,15 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_bounds(&mut self, bounds: &TyParamBounds) -> hir::TyParamBounds {\n+    fn lower_bounds(&mut self, bounds: &[TyParamBound]) -> hir::TyParamBounds {\n         bounds.iter().map(|bound| self.lower_ty_param_bound(bound)).collect()\n     }\n \n     fn lower_block(&mut self, b: &Block) -> P<hir::Block> {\n-        let mut stmts = Vec::new();\n         let mut expr = None;\n \n-        if let Some((last, rest)) = b.stmts.split_last() {\n-            stmts = rest.iter().map(|s| self.lower_stmt(s)).collect::<Vec<_>>();\n-            let last = self.lower_stmt(last);\n+        let mut stmts = b.stmts.iter().flat_map(|s| self.lower_stmt(s)).collect::<Vec<_>>();\n+        if let Some(last) = stmts.pop() {\n             if let hir::StmtExpr(e, _) = last.node {\n                 expr = Some(e);\n             } else {\n@@ -590,11 +766,66 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn lower_item_kind(&mut self, i: &ItemKind) -> hir::Item_ {\n+    fn lower_item_kind(&mut self,\n+                       id: NodeId,\n+                       name: &mut Name,\n+                       attrs: &hir::HirVec<Attribute>,\n+                       vis: &mut hir::Visibility,\n+                       i: &ItemKind)\n+                       -> hir::Item_ {\n         match *i {\n             ItemKind::ExternCrate(string) => hir::ItemExternCrate(string),\n             ItemKind::Use(ref view_path) => {\n-                hir::ItemUse(self.lower_view_path(view_path))\n+                let path = match view_path.node {\n+                    ViewPathSimple(_, ref path) => path,\n+                    ViewPathGlob(ref path) => path,\n+                    ViewPathList(ref path, ref path_list_idents) => {\n+                        for &Spanned { node: ref import, span } in path_list_idents {\n+                            // `use a::{self as x, b as y};` lowers to\n+                            // `use a as x; use a::b as y;`\n+                            let mut ident = import.name;\n+                            let suffix = if ident.name == keywords::SelfValue.name() {\n+                                if let Some(last) = path.segments.last() {\n+                                    ident = last.identifier;\n+                                }\n+                                None\n+                            } else {\n+                                Some(ident.name)\n+                            };\n+\n+                            let mut path = self.lower_path_extra(import.id, path, suffix,\n+                                                                 ParamMode::Explicit);\n+                            path.span = span;\n+                            self.items.insert(import.id, hir::Item {\n+                                id: import.id,\n+                                name: import.rename.unwrap_or(ident).name,\n+                                attrs: attrs.clone(),\n+                                node: hir::ItemUse(P(path), hir::UseKind::Single),\n+                                vis: vis.clone(),\n+                                span: span,\n+                            });\n+                        }\n+                        path\n+                    }\n+                };\n+                let path = P(self.lower_path(id, path, ParamMode::Explicit));\n+                let kind = match view_path.node {\n+                    ViewPathSimple(ident, _) => {\n+                        *name = ident.name;\n+                        hir::UseKind::Single\n+                    }\n+                    ViewPathGlob(_) => {\n+                        hir::UseKind::Glob\n+                    }\n+                    ViewPathList(..) => {\n+                        // Privatize the degenerate import base, used only to check\n+                        // the stability of `use a::{};`, to avoid it showing up as\n+                        // a reexport by accident when `pub`, e.g. in documentation.\n+                        *vis = hir::Inherited;\n+                        hir::UseKind::ListStem\n+                    }\n+                };\n+                hir::ItemUse(path, kind)\n             }\n             ItemKind::Static(ref t, m, ref e) => {\n                 hir::ItemStatic(self.lower_ty(t),\n@@ -606,12 +837,14 @@ impl<'a> LoweringContext<'a> {\n             }\n             ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n                 let body = self.lower_block(body);\n+                let body = self.expr_block(body, ThinVec::new());\n+                let body_id = self.record_expr(body);\n                 hir::ItemFn(self.lower_fn_decl(decl),\n                             self.lower_unsafety(unsafety),\n                             self.lower_constness(constness),\n                             abi,\n                             self.lower_generics(generics),\n-                            P(self.expr_block(body, ThinVec::new())))\n+                            body_id)\n             }\n             ItemKind::Mod(ref m) => hir::ItemMod(self.lower_mod(m)),\n             ItemKind::ForeignMod(ref nm) => hir::ItemForeignMod(self.lower_foreign_mod(nm)),\n@@ -678,7 +911,8 @@ impl<'a> LoweringContext<'a> {\n                         hir::MethodTraitItem(this.lower_method_sig(sig),\n                                              body.as_ref().map(|x| {\n                             let body = this.lower_block(x);\n-                            P(this.expr_block(body, ThinVec::new()))\n+                            let expr = this.expr_block(body, ThinVec::new());\n+                            this.record_expr(expr)\n                         }))\n                     }\n                     TraitItemKind::Type(ref bounds, ref default) => {\n@@ -706,8 +940,9 @@ impl<'a> LoweringContext<'a> {\n                     }\n                     ImplItemKind::Method(ref sig, ref body) => {\n                         let body = this.lower_block(body);\n-                        hir::ImplItemKind::Method(this.lower_method_sig(sig),\n-                                                  P(this.expr_block(body, ThinVec::new())))\n+                        let expr = this.expr_block(body, ThinVec::new());\n+                        let expr_id = this.record_expr(expr);\n+                        hir::ImplItemKind::Method(this.lower_method_sig(sig), expr_id)\n                     }\n                     ImplItemKind::Type(ref ty) => hir::ImplItemKind::Type(this.lower_ty(ty)),\n                     ImplItemKind::Macro(..) => panic!(\"Shouldn't exist any more\"),\n@@ -742,7 +977,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_mod(&mut self, m: &Mod) -> hir::Mod {\n         hir::Mod {\n             inner: m.inner,\n-            item_ids: m.items.iter().map(|x| self.lower_item_id(x)).collect(),\n+            item_ids: m.items.iter().flat_map(|x| self.lower_item_id(x)).collect(),\n         }\n     }\n \n@@ -758,21 +993,30 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_item_id(&mut self, i: &Item) -> hir::ItemId {\n-        hir::ItemId { id: i.id }\n+    fn lower_item_id(&mut self, i: &Item) -> SmallVector<hir::ItemId> {\n+        if let ItemKind::Use(ref view_path) = i.node {\n+            if let ViewPathList(_, ref imports) = view_path.node {\n+                return iter::once(i.id).chain(imports.iter().map(|import| import.node.id))\n+                    .map(|id| hir::ItemId { id: id }).collect();\n+            }\n+        }\n+        SmallVector::one(hir::ItemId { id: i.id })\n     }\n \n     pub fn lower_item(&mut self, i: &Item) -> hir::Item {\n+        let mut name = i.ident.name;\n+        let attrs = self.lower_attrs(&i.attrs);\n+        let mut vis = self.lower_visibility(&i.vis);\n         let node = self.with_parent_def(i.id, |this| {\n-            this.lower_item_kind(&i.node)\n+            this.lower_item_kind(i.id, &mut name, &attrs, &mut vis, &i.node)\n         });\n \n         hir::Item {\n             id: i.id,\n-            name: i.ident.name,\n-            attrs: self.lower_attrs(&i.attrs),\n+            name: name,\n+            attrs: attrs,\n             node: node,\n-            vis: self.lower_visibility(&i.vis),\n+            vis: vis,\n             span: i.span,\n         }\n     }\n@@ -875,29 +1119,41 @@ impl<'a> LoweringContext<'a> {\n                     self.with_parent_def(p.id, |this| {\n                         match this.resolver.get_resolution(p.id).map(|d| d.base_def) {\n                             // `None` can occur in body-less function signatures\n-                            None | Some(Def::Local(..)) => {\n+                            def @ None | def @ Some(Def::Local(_)) => {\n+                                let def_id = def.map(|d| d.def_id()).unwrap_or_else(|| {\n+                                    this.resolver.definitions().local_def_id(p.id)\n+                                });\n                                 hir::PatKind::Binding(this.lower_binding_mode(binding_mode),\n+                                                      def_id,\n                                                       respan(pth1.span, pth1.node.name),\n                                                       sub.as_ref().map(|x| this.lower_pat(x)))\n                             }\n-                            _ => hir::PatKind::Path(None, hir::Path::from_name(pth1.span,\n-                                                                               pth1.node.name))\n+                            Some(def) => {\n+                                hir::PatKind::Path(hir::QPath::Resolved(None, P(hir::Path {\n+                                    span: pth1.span,\n+                                    global: false,\n+                                    def: def,\n+                                    segments: hir_vec![\n+                                        hir::PathSegment::from_name(pth1.node.name)\n+                                    ],\n+                                })))\n+                            }\n                         }\n                     })\n                 }\n                 PatKind::Lit(ref e) => hir::PatKind::Lit(P(self.lower_expr(e))),\n                 PatKind::TupleStruct(ref path, ref pats, ddpos) => {\n-                    hir::PatKind::TupleStruct(self.lower_path(path),\n-                                        pats.iter().map(|x| self.lower_pat(x)).collect(), ddpos)\n+                    let qpath = self.lower_qpath(p.id, &None, path, ParamMode::Optional);\n+                    hir::PatKind::TupleStruct(qpath,\n+                                              pats.iter().map(|x| self.lower_pat(x)).collect(),\n+                                              ddpos)\n                 }\n-                PatKind::Path(ref opt_qself, ref path) => {\n-                    let opt_qself = opt_qself.as_ref().map(|qself| {\n-                        hir::QSelf { ty: self.lower_ty(&qself.ty), position: qself.position }\n-                    });\n-                    hir::PatKind::Path(opt_qself, self.lower_path(path))\n+                PatKind::Path(ref qself, ref path) => {\n+                    hir::PatKind::Path(self.lower_qpath(p.id, qself, path, ParamMode::Optional))\n                 }\n-                PatKind::Struct(ref pth, ref fields, etc) => {\n-                    let pth = self.lower_path(pth);\n+                PatKind::Struct(ref path, ref fields, etc) => {\n+                    let qpath = self.lower_qpath(p.id, &None, path, ParamMode::Optional);\n+\n                     let fs = fields.iter()\n                                    .map(|f| {\n                                        Spanned {\n@@ -910,7 +1166,7 @@ impl<'a> LoweringContext<'a> {\n                                        }\n                                    })\n                                    .collect();\n-                    hir::PatKind::Struct(pth, fs, etc)\n+                    hir::PatKind::Struct(qpath, fs, etc)\n                 }\n                 PatKind::Tuple(ref elts, ddpos) => {\n                     hir::PatKind::Tuple(elts.iter().map(|x| self.lower_pat(x)).collect(), ddpos)\n@@ -980,9 +1236,9 @@ impl<'a> LoweringContext<'a> {\n                     let move_val_init = [\"intrinsics\", \"move_val_init\"];\n                     let inplace_finalize = [\"ops\", \"InPlace\", \"finalize\"];\n \n+                    let unstable_span = self.allow_internal_unstable(\"<-\", e.span);\n                     let make_call = |this: &mut LoweringContext, p, args| {\n-                        let path = this.std_path(e.span, p);\n-                        let path = this.expr_path(path, ThinVec::new());\n+                        let path = P(this.expr_std_path(unstable_span, p, ThinVec::new()));\n                         P(this.expr_call(e.span, path, args))\n                     };\n \n@@ -996,11 +1252,6 @@ impl<'a> LoweringContext<'a> {\n \n                     // let placer = <placer_expr> ;\n                     let (s1, placer_binding) = {\n-                        let placer_expr = P(self.signal_block_expr(hir_vec![],\n-                                                                   placer_expr,\n-                                                                   e.span,\n-                                                                   hir::PopUnstableBlock,\n-                                                                   ThinVec::new()));\n                         mk_stmt_let(self, placer_ident, placer_expr)\n                     };\n \n@@ -1021,11 +1272,6 @@ impl<'a> LoweringContext<'a> {\n \n                     // pop_unsafe!(EXPR));\n                     let pop_unsafe_expr = {\n-                        let value_expr = P(self.signal_block_expr(hir_vec![],\n-                                                                  value_expr,\n-                                                                  e.span,\n-                                                                  hir::PopUnstableBlock,\n-                                                                  ThinVec::new()));\n                         self.signal_block_expr(hir_vec![],\n                                                value_expr,\n                                                e.span,\n@@ -1054,11 +1300,9 @@ impl<'a> LoweringContext<'a> {\n                                                  ThinVec::new()))\n                     };\n \n-                    return self.signal_block_expr(hir_vec![s1, s2, s3],\n-                                                  expr,\n-                                                  e.span,\n-                                                  hir::PushUnstableBlock,\n-                                                  e.attrs.clone());\n+                    let block = self.block_all(e.span, hir_vec![s1, s2, s3], Some(expr));\n+                    // add the attributes to the outer returned expr node\n+                    return self.expr_block(P(block), e.attrs.clone());\n                 }\n \n                 ExprKind::Vec(ref exprs) => {\n@@ -1147,9 +1391,10 @@ impl<'a> LoweringContext<'a> {\n                 }\n                 ExprKind::Closure(capture_clause, ref decl, ref body, fn_decl_span) => {\n                     self.with_parent_def(e.id, |this| {\n+                        let expr = this.lower_expr(body);\n                         hir::ExprClosure(this.lower_capture_clause(capture_clause),\n                                          this.lower_fn_decl(decl),\n-                                         P(this.lower_expr(body)),\n+                                         this.record_expr(expr),\n                                          fn_decl_span)\n                     })\n                 }\n@@ -1176,33 +1421,23 @@ impl<'a> LoweringContext<'a> {\n                                    ast_expr: &Expr,\n                                    path: &[&str],\n                                    fields: &[(&str, &P<Expr>)]) -> hir::Expr {\n-                        let struct_path = this.std_path(ast_expr.span,\n-                                                        &iter::once(&\"ops\").chain(path)\n-                                                                           .map(|s| *s)\n-                                                                           .collect::<Vec<_>>());\n+                        let struct_path = &iter::once(&\"ops\").chain(path).map(|s| *s)\n+                                                             .collect::<Vec<_>>();\n+                        let unstable_span = this.allow_internal_unstable(\"...\", ast_expr.span);\n \n-                        let hir_expr = if fields.len() == 0 {\n-                            this.expr_path(struct_path, ast_expr.attrs.clone())\n+                        if fields.len() == 0 {\n+                            this.expr_std_path(unstable_span, struct_path,\n+                                               ast_expr.attrs.clone())\n                         } else {\n                             let fields = fields.into_iter().map(|&(s, e)| {\n                                 let expr = P(this.lower_expr(&e));\n-                                let signal_block = P(this.signal_block_expr(hir_vec![],\n-                                                                            expr,\n-                                                                            e.span,\n-                                                                            hir::PopUnstableBlock,\n-                                                                            ThinVec::new()));\n-                                this.field(Symbol::intern(s), signal_block, ast_expr.span)\n+                                let unstable_span = this.allow_internal_unstable(\"...\", e.span);\n+                                this.field(Symbol::intern(s), expr, unstable_span)\n                             }).collect();\n                             let attrs = ast_expr.attrs.clone();\n \n-                            this.expr_struct(ast_expr.span, struct_path, fields, None, attrs)\n-                        };\n-\n-                        this.signal_block_expr(hir_vec![],\n-                                               hir_expr,\n-                                               ast_expr.span,\n-                                               hir::PushUnstableBlock,\n-                                               ThinVec::new())\n+                            this.expr_std_struct(unstable_span, struct_path, fields, None, attrs)\n+                        }\n                     }\n \n                     use syntax::ast::RangeLimits::*;\n@@ -1236,19 +1471,13 @@ impl<'a> LoweringContext<'a> {\n                     };\n                 }\n                 ExprKind::Path(ref qself, ref path) => {\n-                    let hir_qself = qself.as_ref().map(|&QSelf { ref ty, position }| {\n-                        hir::QSelf {\n-                            ty: self.lower_ty(ty),\n-                            position: position,\n-                        }\n-                    });\n-                    hir::ExprPath(hir_qself, self.lower_path(path))\n+                    hir::ExprPath(self.lower_qpath(e.id, qself, path, ParamMode::Optional))\n                 }\n                 ExprKind::Break(opt_ident, ref opt_expr) => {\n-                    hir::ExprBreak(self.lower_opt_sp_ident(opt_ident),\n+                    hir::ExprBreak(self.lower_label(e.id, opt_ident),\n                                    opt_expr.as_ref().map(|x| P(self.lower_expr(x))))\n                 }\n-                ExprKind::Continue(opt_ident) => hir::ExprAgain(self.lower_opt_sp_ident(opt_ident)),\n+                ExprKind::Continue(opt_ident) => hir::ExprAgain(self.lower_label(e.id, opt_ident)),\n                 ExprKind::Ret(ref e) => hir::ExprRet(e.as_ref().map(|x| P(self.lower_expr(x)))),\n                 ExprKind::InlineAsm(ref asm) => {\n                     let hir_asm = hir::InlineAsm {\n@@ -1275,7 +1504,7 @@ impl<'a> LoweringContext<'a> {\n                     hir::ExprInlineAsm(P(hir_asm), outputs, inputs)\n                 }\n                 ExprKind::Struct(ref path, ref fields, ref maybe_expr) => {\n-                    hir::ExprStruct(P(self.lower_path(path)),\n+                    hir::ExprStruct(self.lower_qpath(e.id, &None, path, ParamMode::Optional),\n                                     fields.iter().map(|x| self.lower_field(x)).collect(),\n                                     maybe_expr.as_ref().map(|x| P(self.lower_expr(x))))\n                 }\n@@ -1475,10 +1704,10 @@ impl<'a> LoweringContext<'a> {\n \n                     // `match ::std::iter::Iterator::next(&mut iter) { ... }`\n                     let match_expr = {\n-                        let next_path = self.std_path(e.span, &[\"iter\", \"Iterator\", \"next\"]);\n                         let iter = P(self.expr_ident(e.span, iter, iter_pat.id));\n                         let ref_mut_iter = self.expr_mut_addr_of(e.span, iter);\n-                        let next_path = self.expr_path(next_path, ThinVec::new());\n+                        let next_path = &[\"iter\", \"Iterator\", \"next\"];\n+                        let next_path = P(self.expr_std_path(e.span, next_path, ThinVec::new()));\n                         let next_expr = P(self.expr_call(e.span, next_path,\n                                           hir_vec![ref_mut_iter]));\n                         let arms = hir_vec![pat_arm, break_arm];\n@@ -1505,10 +1734,9 @@ impl<'a> LoweringContext<'a> {\n \n                     // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n                     let into_iter_expr = {\n-                        let into_iter_path = self.std_path(e.span,\n-                                                           &[\"iter\", \"IntoIterator\", \"into_iter\"]);\n-\n-                        let into_iter = self.expr_path(into_iter_path, ThinVec::new());\n+                        let into_iter_path = &[\"iter\", \"IntoIterator\", \"into_iter\"];\n+                        let into_iter = P(self.expr_std_path(e.span, into_iter_path,\n+                                                             ThinVec::new()));\n                         P(self.expr_call(e.span, into_iter, hir_vec![head]))\n                     };\n \n@@ -1534,32 +1762,20 @@ impl<'a> LoweringContext<'a> {\n                 ExprKind::Try(ref sub_expr) => {\n                     // to:\n                     //\n-                    // {\n-                    //     match { Carrier::translate( { <expr> } ) } {\n-                    //         Ok(val) => val,\n-                    //         Err(err) => { return Carrier::from_error(From::from(err)); }\n-                    //     }\n+                    // match Carrier::translate(<expr>) {\n+                    //     Ok(val) => val,\n+                    //     Err(err) => return Carrier::from_error(From::from(err))\n                     // }\n+                    let unstable_span = self.allow_internal_unstable(\"?\", e.span);\n \n-                    // { Carrier::translate( { <expr> } ) }\n+                    // Carrier::translate(<expr>)\n                     let discr = {\n                         // expand <expr>\n-                        let sub_expr = P(self.lower_expr(sub_expr));\n-                        let sub_expr = self.signal_block_expr(hir_vec![],\n-                                                              sub_expr,\n-                                                              e.span,\n-                                                              hir::PopUnstableBlock,\n-                                                              ThinVec::new());\n-\n-                        let path = self.std_path(e.span, &[\"ops\", \"Carrier\", \"translate\"]);\n-                        let path = self.expr_path(path, ThinVec::new());\n-                        let call = P(self.expr_call(e.span, path, hir_vec![sub_expr]));\n-\n-                        P(self.signal_block_expr(hir_vec![],\n-                                                 call,\n-                                                 e.span,\n-                                                 hir::PushUnstableBlock,\n-                                                 ThinVec::new()))\n+                        let sub_expr = self.lower_expr(sub_expr);\n+\n+                        let path = &[\"ops\", \"Carrier\", \"translate\"];\n+                        let path = P(self.expr_std_path(unstable_span, path, ThinVec::new()));\n+                        P(self.expr_call(e.span, path, hir_vec![sub_expr]))\n                     };\n \n                     // Ok(val) => val\n@@ -1572,33 +1788,30 @@ impl<'a> LoweringContext<'a> {\n                         self.arm(hir_vec![ok_pat], val_expr)\n                     };\n \n-                    // Err(err) => { return Carrier::from_error(From::from(err)); }\n+                    // Err(err) => return Carrier::from_error(From::from(err))\n                     let err_arm = {\n                         let err_ident = self.str_to_ident(\"err\");\n                         let err_local = self.pat_ident(e.span, err_ident);\n                         let from_expr = {\n-                            let path = self.std_path(e.span, &[\"convert\", \"From\", \"from\"]);\n-                            let from = self.expr_path(path, ThinVec::new());\n+                            let path = &[\"convert\", \"From\", \"from\"];\n+                            let from = P(self.expr_std_path(e.span, path, ThinVec::new()));\n                             let err_expr = self.expr_ident(e.span, err_ident, err_local.id);\n \n                             self.expr_call(e.span, from, hir_vec![err_expr])\n                         };\n                         let from_err_expr = {\n-                            let path = self.std_path(e.span, &[\"ops\", \"Carrier\", \"from_error\"]);\n-                            let from_err = self.expr_path(path, ThinVec::new());\n+                            let path = &[\"ops\", \"Carrier\", \"from_error\"];\n+                            let from_err = P(self.expr_std_path(unstable_span, path,\n+                                                                ThinVec::new()));\n                             P(self.expr_call(e.span, from_err, hir_vec![from_expr]))\n                         };\n \n                         let ret_expr = P(self.expr(e.span,\n                                                    hir::Expr_::ExprRet(Some(from_err_expr)),\n                                                                        ThinVec::new()));\n-                        let ret_stmt = self.stmt_expr(ret_expr);\n-                        let block = P(self.signal_block_stmt(ret_stmt, e.span,\n-                                                             hir::PushUnstableBlock,\n-                                                             ThinVec::new()));\n \n                         let err_pat = self.pat_err(e.span, err_local);\n-                        self.arm(hir_vec![err_pat], block)\n+                        self.arm(hir_vec![err_pat], ret_expr)\n                     };\n \n                     return self.expr_match(e.span, discr, hir_vec![err_arm, ok_arm],\n@@ -1612,22 +1825,26 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_stmt(&mut self, s: &Stmt) -> hir::Stmt {\n-        match s.node {\n+    fn lower_stmt(&mut self, s: &Stmt) -> SmallVector<hir::Stmt> {\n+        SmallVector::one(match s.node {\n             StmtKind::Local(ref l) => Spanned {\n                 node: hir::StmtDecl(P(Spanned {\n                     node: hir::DeclLocal(self.lower_local(l)),\n                     span: s.span,\n                 }), s.id),\n                 span: s.span,\n             },\n-            StmtKind::Item(ref it) => Spanned {\n-                node: hir::StmtDecl(P(Spanned {\n-                    node: hir::DeclItem(self.lower_item_id(it)),\n+            StmtKind::Item(ref it) => {\n+                // Can only use the ID once.\n+                let mut id = Some(s.id);\n+                return self.lower_item_id(it).into_iter().map(|item_id| Spanned {\n+                    node: hir::StmtDecl(P(Spanned {\n+                        node: hir::DeclItem(item_id),\n+                        span: s.span,\n+                    }), id.take().unwrap_or_else(|| self.next_id())),\n                     span: s.span,\n-                }), s.id),\n-                span: s.span,\n-            },\n+                }).collect();\n+            }\n             StmtKind::Expr(ref e) => {\n                 Spanned {\n                     node: hir::StmtExpr(P(self.lower_expr(e)), s.id),\n@@ -1641,7 +1858,7 @@ impl<'a> LoweringContext<'a> {\n                 }\n             }\n             StmtKind::Mac(..) => panic!(\"Shouldn't exist here\"),\n-        }\n+        })\n     }\n \n     fn lower_capture_clause(&mut self, c: CaptureBy) -> hir::CaptureClause {\n@@ -1655,8 +1872,12 @@ impl<'a> LoweringContext<'a> {\n         match *v {\n             Visibility::Public => hir::Public,\n             Visibility::Crate(_) => hir::Visibility::Crate,\n-            Visibility::Restricted { ref path, id } =>\n-                hir::Visibility::Restricted { path: P(self.lower_path(path)), id: id },\n+            Visibility::Restricted { ref path, id } => {\n+                hir::Visibility::Restricted {\n+                    path: P(self.lower_path(id, path, ParamMode::Explicit)),\n+                    id: id\n+                }\n+            }\n             Visibility::Inherited => hir::Inherited,\n         }\n     }\n@@ -1739,27 +1960,32 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn expr_ident(&mut self, span: Span, id: Name, binding: NodeId) -> hir::Expr {\n-        let expr_path = hir::ExprPath(None, self.path_ident(span, id));\n-        let expr = self.expr(span, expr_path, ThinVec::new());\n-\n         let def = {\n             let defs = self.resolver.definitions();\n             Def::Local(defs.local_def_id(binding))\n         };\n-        self.resolver.record_resolution(expr.id, def);\n \n-        expr\n+        let expr_path = hir::ExprPath(hir::QPath::Resolved(None, P(hir::Path {\n+            span: span,\n+            global: false,\n+            def: def,\n+            segments: hir_vec![hir::PathSegment::from_name(id)],\n+        })));\n+\n+        self.expr(span, expr_path, ThinVec::new())\n     }\n \n     fn expr_mut_addr_of(&mut self, span: Span, e: P<hir::Expr>) -> hir::Expr {\n         self.expr(span, hir::ExprAddrOf(hir::MutMutable, e), ThinVec::new())\n     }\n \n-    fn expr_path(&mut self, path: hir::Path, attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n-        let def = self.resolver.resolve_generated_global_path(&path, true);\n-        let expr = P(self.expr(path.span, hir::ExprPath(None, path), attrs));\n-        self.resolver.record_resolution(expr.id, def);\n-        expr\n+    fn expr_std_path(&mut self,\n+                     span: Span,\n+                     components: &[&str],\n+                     attrs: ThinVec<Attribute>)\n+                     -> hir::Expr {\n+        let path = self.std_path(span, components, true);\n+        self.expr(span, hir::ExprPath(hir::QPath::Resolved(None, P(path))), attrs)\n     }\n \n     fn expr_match(&mut self,\n@@ -1779,16 +2005,15 @@ impl<'a> LoweringContext<'a> {\n         P(self.expr(sp, hir::ExprTup(exprs), ThinVec::new()))\n     }\n \n-    fn expr_struct(&mut self,\n-                   sp: Span,\n-                   path: hir::Path,\n-                   fields: hir::HirVec<hir::Field>,\n-                   e: Option<P<hir::Expr>>,\n-                   attrs: ThinVec<Attribute>) -> P<hir::Expr> {\n-        let def = self.resolver.resolve_generated_global_path(&path, false);\n-        let expr = P(self.expr(sp, hir::ExprStruct(P(path), fields, e), attrs));\n-        self.resolver.record_resolution(expr.id, def);\n-        expr\n+    fn expr_std_struct(&mut self,\n+                       span: Span,\n+                       components: &[&str],\n+                       fields: hir::HirVec<hir::Field>,\n+                       e: Option<P<hir::Expr>>,\n+                       attrs: ThinVec<Attribute>) -> hir::Expr {\n+        let path = self.std_path(span, components, false);\n+        let qpath = hir::QPath::Resolved(None, P(path));\n+        self.expr(span, hir::ExprStruct(qpath, fields, e), attrs)\n     }\n \n     fn expr(&mut self, span: Span, node: hir::Expr_, attrs: ThinVec<Attribute>) -> hir::Expr {\n@@ -1820,15 +2045,6 @@ impl<'a> LoweringContext<'a> {\n         (respan(sp, hir::StmtDecl(P(decl), self.next_id())), pat_id)\n     }\n \n-    // Turns `<expr>` into `<expr>;`, note that this produces a StmtSemi, not a\n-    // StmtExpr.\n-    fn stmt_expr(&self, expr: P<hir::Expr>) -> hir::Stmt {\n-        hir::Stmt {\n-            span: expr.span,\n-            node: hir::StmtSemi(expr, self.next_id()),\n-        }\n-    }\n-\n     fn block_expr(&mut self, expr: P<hir::Expr>) -> hir::Block {\n         self.block_all(expr.span, hir::HirVec::new(), Some(expr))\n     }\n@@ -1845,36 +2061,34 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn pat_ok(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n-        let path = self.std_path(span, &[\"result\", \"Result\", \"Ok\"]);\n-        self.pat_enum(span, path, hir_vec![pat])\n+        self.pat_std_enum(span, &[\"result\", \"Result\", \"Ok\"], hir_vec![pat])\n     }\n \n     fn pat_err(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n-        let path = self.std_path(span, &[\"result\", \"Result\", \"Err\"]);\n-        self.pat_enum(span, path, hir_vec![pat])\n+        self.pat_std_enum(span, &[\"result\", \"Result\", \"Err\"], hir_vec![pat])\n     }\n \n     fn pat_some(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n-        let path = self.std_path(span, &[\"option\", \"Option\", \"Some\"]);\n-        self.pat_enum(span, path, hir_vec![pat])\n+        self.pat_std_enum(span, &[\"option\", \"Option\", \"Some\"], hir_vec![pat])\n     }\n \n     fn pat_none(&mut self, span: Span) -> P<hir::Pat> {\n-        let path = self.std_path(span, &[\"option\", \"Option\", \"None\"]);\n-        self.pat_enum(span, path, hir_vec![])\n+        self.pat_std_enum(span, &[\"option\", \"Option\", \"None\"], hir_vec![])\n     }\n \n-    fn pat_enum(&mut self, span: Span, path: hir::Path, subpats: hir::HirVec<P<hir::Pat>>)\n-                -> P<hir::Pat> {\n-        let def = self.resolver.resolve_generated_global_path(&path, true);\n+    fn pat_std_enum(&mut self,\n+                    span: Span,\n+                    components: &[&str],\n+                    subpats: hir::HirVec<P<hir::Pat>>)\n+                    -> P<hir::Pat> {\n+        let path = self.std_path(span, components, true);\n+        let qpath = hir::QPath::Resolved(None, P(path));\n         let pt = if subpats.is_empty() {\n-            hir::PatKind::Path(None, path)\n+            hir::PatKind::Path(qpath)\n         } else {\n-            hir::PatKind::TupleStruct(path, subpats, None)\n+            hir::PatKind::TupleStruct(qpath, subpats, None)\n         };\n-        let pat = self.pat(span, pt);\n-        self.resolver.record_resolution(pat.id, def);\n-        pat\n+        self.pat(span, pt)\n     }\n \n     fn pat_ident(&mut self, span: Span, name: Name) -> P<hir::Pat> {\n@@ -1883,25 +2097,26 @@ impl<'a> LoweringContext<'a> {\n \n     fn pat_ident_binding_mode(&mut self, span: Span, name: Name, bm: hir::BindingMode)\n                               -> P<hir::Pat> {\n-        let pat_ident = hir::PatKind::Binding(bm,\n-                                            Spanned {\n-                                                span: span,\n-                                                node: name,\n-                                            },\n-                                            None);\n-\n-        let pat = self.pat(span, pat_ident);\n-\n+        let id = self.next_id();\n         let parent_def = self.parent_def;\n-        let def = {\n+        let def_id = {\n             let defs = self.resolver.definitions();\n             let def_path_data = DefPathData::Binding(name.as_str());\n-            let def_index = defs.create_def_with_parent(parent_def, pat.id, def_path_data);\n-            Def::Local(DefId::local(def_index))\n+            let def_index = defs.create_def_with_parent(parent_def, id, def_path_data);\n+            DefId::local(def_index)\n         };\n-        self.resolver.record_resolution(pat.id, def);\n \n-        pat\n+        P(hir::Pat {\n+            id: id,\n+            node: hir::PatKind::Binding(bm,\n+                                        def_id,\n+                                        Spanned {\n+                                            span: span,\n+                                            node: name,\n+                                        },\n+                                        None),\n+            span: span,\n+        })\n     }\n \n     fn pat_wild(&mut self, span: Span) -> P<hir::Pat> {\n@@ -1916,63 +2131,25 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn path_ident(&mut self, span: Span, id: Name) -> hir::Path {\n-        self.path(span, vec![id])\n-    }\n-\n-    fn path(&mut self, span: Span, strs: Vec<Name>) -> hir::Path {\n-        self.path_all(span, false, strs, hir::HirVec::new(), hir::HirVec::new(), hir::HirVec::new())\n-    }\n-\n-    fn path_global(&mut self, span: Span, strs: Vec<Name>) -> hir::Path {\n-        self.path_all(span, true, strs, hir::HirVec::new(), hir::HirVec::new(), hir::HirVec::new())\n-    }\n+    /// Given suffix [\"b\",\"c\",\"d\"], returns path `::std::b::c::d` when\n+    /// `fld.cx.use_std`, and `::core::b::c::d` otherwise.\n+    /// The path is also resolved according to `is_value`.\n+    fn std_path(&mut self, span: Span, components: &[&str], is_value: bool) -> hir::Path {\n+        let idents = self.crate_root.iter().chain(components);\n \n-    fn path_all(&mut self,\n-                sp: Span,\n-                global: bool,\n-                mut names: Vec<Name>,\n-                lifetimes: hir::HirVec<hir::Lifetime>,\n-                types: hir::HirVec<P<hir::Ty>>,\n-                bindings: hir::HirVec<hir::TypeBinding>)\n-                -> hir::Path {\n-        let last_identifier = names.pop().unwrap();\n-        let mut segments: Vec<hir::PathSegment> = names.into_iter().map(|name| {\n-            hir::PathSegment {\n-                name: name,\n-                parameters: hir::PathParameters::none(),\n-           }\n+        let segments: Vec<_> = idents.map(|name| {\n+            hir::PathSegment::from_name(Symbol::intern(name))\n         }).collect();\n \n-        segments.push(hir::PathSegment {\n-            name: last_identifier,\n-            parameters: hir::AngleBracketedParameters(hir::AngleBracketedParameterData {\n-                lifetimes: lifetimes,\n-                types: types,\n-                bindings: bindings,\n-            }),\n-        });\n-        hir::Path {\n-            span: sp,\n-            global: global,\n+        let mut path = hir::Path {\n+            span: span,\n+            global: true,\n+            def: Def::Err,\n             segments: segments.into(),\n-        }\n-    }\n-\n-    fn std_path_components(&mut self, components: &[&str]) -> Vec<Name> {\n-        let mut v = Vec::new();\n-        if let Some(s) = self.crate_root {\n-            v.push(Symbol::intern(s));\n-        }\n-        v.extend(components.iter().map(|s| Symbol::intern(s)));\n-        return v;\n-    }\n+        };\n \n-    // Given suffix [\"b\",\"c\",\"d\"], returns path `::std::b::c::d` when\n-    // `fld.cx.use_std`, and `::core::b::c::d` otherwise.\n-    fn std_path(&mut self, span: Span, components: &[&str]) -> hir::Path {\n-        let idents = self.std_path_components(components);\n-        self.path_global(span, idents)\n+        self.resolver.resolve_hir_path(&mut path, is_value);\n+        path\n     }\n \n     fn signal_block_expr(&mut self,\n@@ -1993,20 +2170,11 @@ impl<'a> LoweringContext<'a> {\n         self.expr_block(block, attrs)\n     }\n \n-    fn signal_block_stmt(&mut self,\n-                         stmt: hir::Stmt,\n-                         span: Span,\n-                         rule: hir::BlockCheckMode,\n-                         attrs: ThinVec<Attribute>)\n-                         -> hir::Expr {\n-        let id = self.next_id();\n-        let block = P(hir::Block {\n-            rules: rule,\n+    fn ty(&mut self, span: Span, node: hir::Ty_) -> P<hir::Ty> {\n+        P(hir::Ty {\n+            id: self.next_id(),\n+            node: node,\n             span: span,\n-            id: id,\n-            stmts: hir_vec![stmt],\n-            expr: None,\n-        });\n-        self.expr_block(block, attrs)\n+        })\n     }\n }"}, {"sha": "068e7ed8624ed77300f10252a13fa392639634ee", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 27, "deletions": 15, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -48,7 +48,7 @@ pub trait MaybeFnLike { fn is_fn_like(&self) -> bool; }\n /// Components shared by fn-like things (fn items, methods, closures).\n pub struct FnParts<'a> {\n     pub decl: &'a FnDecl,\n-    pub body: &'a Expr,\n+    pub body: ast::ExprId,\n     pub kind: FnKind<'a>,\n     pub span: Span,\n     pub id:   NodeId,\n@@ -115,7 +115,7 @@ struct ItemFnParts<'a> {\n     abi:      abi::Abi,\n     vis:      &'a ast::Visibility,\n     generics: &'a ast::Generics,\n-    body:     &'a Expr,\n+    body:     ast::ExprId,\n     id:       NodeId,\n     span:     Span,\n     attrs:    &'a [Attribute],\n@@ -125,14 +125,14 @@ struct ItemFnParts<'a> {\n /// for use when implementing FnLikeNode operations.\n struct ClosureParts<'a> {\n     decl: &'a FnDecl,\n-    body: &'a Expr,\n+    body: ast::ExprId,\n     id: NodeId,\n     span: Span,\n     attrs: &'a [Attribute],\n }\n \n impl<'a> ClosureParts<'a> {\n-    fn new(d: &'a FnDecl, b: &'a Expr, id: NodeId, s: Span, attrs: &'a [Attribute]) -> Self {\n+    fn new(d: &'a FnDecl, b: ast::ExprId, id: NodeId, s: Span, attrs: &'a [Attribute]) -> Self {\n         ClosureParts {\n             decl: d,\n             body: b,\n@@ -172,9 +172,9 @@ impl<'a> FnLikeNode<'a> {\n         }\n     }\n \n-    pub fn body(self) -> &'a Expr {\n-        self.handle(|i: ItemFnParts<'a>|  &*i.body,\n-                    |_, _, _: &'a ast::MethodSig, _, body: &'a ast::Expr, _, _|  body,\n+    pub fn body(self) -> ast::ExprId {\n+        self.handle(|i: ItemFnParts<'a>|  i.body,\n+                    |_, _, _: &'a ast::MethodSig, _, body: ast::ExprId, _, _|  body,\n                     |c: ClosureParts<'a>| c.body)\n     }\n \n@@ -196,6 +196,18 @@ impl<'a> FnLikeNode<'a> {\n                     |c: ClosureParts|    c.id)\n     }\n \n+    pub fn constness(self) -> ast::Constness {\n+        match self.kind() {\n+            FnKind::ItemFn(_, _, _, constness, ..) => {\n+                constness\n+            }\n+            FnKind::Method(_, m, ..) => {\n+                m.constness\n+            }\n+            _ => ast::Constness::NotConst\n+        }\n+    }\n+\n     pub fn kind(self) -> FnKind<'a> {\n         let item = |p: ItemFnParts<'a>| -> FnKind<'a> {\n             FnKind::ItemFn(p.name, p.generics, p.unsafety, p.constness, p.abi, p.vis, p.attrs)\n@@ -215,21 +227,21 @@ impl<'a> FnLikeNode<'a> {\n                   Name,\n                   &'a ast::MethodSig,\n                   Option<&'a ast::Visibility>,\n-                  &'a ast::Expr,\n+                  ast::ExprId,\n                   Span,\n                   &'a [Attribute])\n                   -> A,\n         C: FnOnce(ClosureParts<'a>) -> A,\n     {\n         match self.node {\n             map::NodeItem(i) => match i.node {\n-                ast::ItemFn(ref decl, unsafety, constness, abi, ref generics, ref block) =>\n+                ast::ItemFn(ref decl, unsafety, constness, abi, ref generics, block) =>\n                     item_fn(ItemFnParts {\n                         id: i.id,\n                         name: i.name,\n                         decl: &decl,\n                         unsafety: unsafety,\n-                        body: &block,\n+                        body: block,\n                         generics: generics,\n                         abi: abi,\n                         vis: &i.vis,\n@@ -240,24 +252,24 @@ impl<'a> FnLikeNode<'a> {\n                 _ => bug!(\"item FnLikeNode that is not fn-like\"),\n             },\n             map::NodeTraitItem(ti) => match ti.node {\n-                ast::MethodTraitItem(ref sig, Some(ref body)) => {\n+                ast::MethodTraitItem(ref sig, Some(body)) => {\n                     method(ti.id, ti.name, sig, None, body, ti.span, &ti.attrs)\n                 }\n                 _ => bug!(\"trait method FnLikeNode that is not fn-like\"),\n             },\n             map::NodeImplItem(ii) => {\n                 match ii.node {\n-                    ast::ImplItemKind::Method(ref sig, ref body) => {\n+                    ast::ImplItemKind::Method(ref sig, body) => {\n                         method(ii.id, ii.name, sig, Some(&ii.vis), body, ii.span, &ii.attrs)\n                     }\n                     _ => {\n                         bug!(\"impl method FnLikeNode that is not fn-like\")\n                     }\n                 }\n-            }\n+            },\n             map::NodeExpr(e) => match e.node {\n-                ast::ExprClosure(_, ref decl, ref block, _fn_decl_span) =>\n-                    closure(ClosureParts::new(&decl, &block, e.id, e.span, &e.attrs)),\n+                ast::ExprClosure(_, ref decl, block, _fn_decl_span) =>\n+                    closure(ClosureParts::new(&decl, block, e.id, e.span, &e.attrs)),\n                 _ => bug!(\"expr FnLikeNode that is not fn-like\"),\n             },\n             _ => bug!(\"other FnLikeNode that is not fn-like\"),"}, {"sha": "c46c8f044e0ffc3863feb0bfb7bd85b5fac414dd", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 36, "deletions": 20, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -10,7 +10,7 @@\n \n use super::*;\n \n-use hir::intravisit::Visitor;\n+use hir::intravisit::{Visitor, NestedVisitorMap};\n use hir::def_id::DefId;\n use middle::cstore::InlinedItem;\n use std::iter::repeat;\n@@ -91,7 +91,7 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n     /// deep walking so that we walk nested items in the context of\n     /// their outer items.\n \n-    fn nested_visit_map(&mut self) -> Option<&map::Map<'ast>> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'ast> {\n         panic!(\"visit_nested_xxx must be manually implemented in this visitor\")\n     }\n \n@@ -106,6 +106,10 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         self.visit_impl_item(self.krate.impl_item(item_id))\n     }\n \n+    fn visit_body(&mut self, id: ExprId) {\n+        self.visit_expr(self.krate.expr(id))\n+    }\n+\n     fn visit_item(&mut self, i: &'ast Item) {\n         debug!(\"visit_item: {:?}\", i);\n \n@@ -124,23 +128,6 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n                         this.insert(struct_def.id(), NodeStructCtor(struct_def));\n                     }\n                 }\n-                ItemTrait(.., ref bounds, _) => {\n-                    for b in bounds.iter() {\n-                        if let TraitTyParamBound(ref t, TraitBoundModifier::None) = *b {\n-                            this.insert(t.trait_ref.ref_id, NodeItem(i));\n-                        }\n-                    }\n-                }\n-                ItemUse(ref view_path) => {\n-                    match view_path.node {\n-                        ViewPathList(_, ref paths) => {\n-                            for path in paths {\n-                                this.insert(path.node.id, NodeItem(i));\n-                            }\n-                        }\n-                        _ => ()\n-                    }\n-                }\n                 _ => {}\n             }\n             intravisit::walk_item(this, i);\n@@ -217,8 +204,16 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         });\n     }\n \n+    fn visit_trait_ref(&mut self, tr: &'ast TraitRef) {\n+        self.insert(tr.ref_id, NodeTraitRef(tr));\n+\n+        self.with_parent(tr.ref_id, |this| {\n+            intravisit::walk_trait_ref(this, tr);\n+        });\n+    }\n+\n     fn visit_fn(&mut self, fk: intravisit::FnKind<'ast>, fd: &'ast FnDecl,\n-                b: &'ast Expr, s: Span, id: NodeId) {\n+                b: ExprId, s: Span, id: NodeId) {\n         assert_eq!(self.parent_node, id);\n         intravisit::walk_fn(self, fk, fd, b, s, id);\n     }\n@@ -234,7 +229,28 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         self.insert(lifetime.id, NodeLifetime(lifetime));\n     }\n \n+    fn visit_vis(&mut self, visibility: &'ast Visibility) {\n+        match *visibility {\n+            Visibility::Public |\n+            Visibility::Crate |\n+            Visibility::Inherited => {}\n+            Visibility::Restricted { id, .. } => {\n+                self.insert(id, NodeVisibility(visibility));\n+                self.with_parent(id, |this| {\n+                    intravisit::walk_vis(this, visibility);\n+                });\n+            }\n+        }\n+    }\n+\n     fn visit_macro_def(&mut self, macro_def: &'ast MacroDef) {\n         self.insert_entry(macro_def.id, NotPresent);\n     }\n+\n+    fn visit_struct_field(&mut self, field: &'ast StructField) {\n+        self.insert(field.id, NodeField(field));\n+        self.with_parent(field.id, |this| {\n+            intravisit::walk_struct_field(this, field);\n+        });\n+    }\n }"}, {"sha": "eb5a89f320e7b3d325e9741e5e4802766dd4e599", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 40, "deletions": 16, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -11,7 +11,7 @@\n use hir::map::definitions::*;\n \n use hir;\n-use hir::intravisit;\n+use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n \n use middle::cstore::InlinedItem;\n@@ -135,8 +135,8 @@ impl<'a> DefCollector<'a> {\n     }\n }\n \n-impl<'a> visit::Visitor for DefCollector<'a> {\n-    fn visit_item(&mut self, i: &Item) {\n+impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n+    fn visit_item(&mut self, i: &'a Item) {\n         debug!(\"visit_item: {:?}\", i);\n \n         // Pick the def data. This need not be unique, but the more\n@@ -155,7 +155,20 @@ impl<'a> visit::Visitor for DefCollector<'a> {\n                 DefPathData::ValueNs(i.ident.name.as_str()),\n             ItemKind::Mac(..) if i.id == DUMMY_NODE_ID => return, // Scope placeholder\n             ItemKind::Mac(..) => return self.visit_macro_invoc(i.id, false),\n-            ItemKind::Use(..) => DefPathData::Misc,\n+            ItemKind::Use(ref view_path) => {\n+                match view_path.node {\n+                    ViewPathGlob(..) => {}\n+\n+                    // FIXME(eddyb) Should use the real name. Which namespace?\n+                    ViewPathSimple(..) => {}\n+                    ViewPathList(_, ref imports) => {\n+                        for import in imports {\n+                            self.create_def(import.node.id, DefPathData::Misc);\n+                        }\n+                    }\n+                }\n+                DefPathData::Misc\n+            }\n         };\n         let def = self.create_def(i.id, def_data);\n \n@@ -198,7 +211,7 @@ impl<'a> visit::Visitor for DefCollector<'a> {\n         });\n     }\n \n-    fn visit_foreign_item(&mut self, foreign_item: &ForeignItem) {\n+    fn visit_foreign_item(&mut self, foreign_item: &'a ForeignItem) {\n         let def = self.create_def(foreign_item.id,\n                                   DefPathData::ValueNs(foreign_item.ident.name.as_str()));\n \n@@ -207,15 +220,15 @@ impl<'a> visit::Visitor for DefCollector<'a> {\n         });\n     }\n \n-    fn visit_generics(&mut self, generics: &Generics) {\n+    fn visit_generics(&mut self, generics: &'a Generics) {\n         for ty_param in generics.ty_params.iter() {\n             self.create_def(ty_param.id, DefPathData::TypeParam(ty_param.ident.name.as_str()));\n         }\n \n         visit::walk_generics(self, generics);\n     }\n \n-    fn visit_trait_item(&mut self, ti: &TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'a TraitItem) {\n         let def_data = match ti.node {\n             TraitItemKind::Method(..) | TraitItemKind::Const(..) =>\n                 DefPathData::ValueNs(ti.ident.name.as_str()),\n@@ -233,7 +246,7 @@ impl<'a> visit::Visitor for DefCollector<'a> {\n         });\n     }\n \n-    fn visit_impl_item(&mut self, ii: &ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'a ImplItem) {\n         let def_data = match ii.node {\n             ImplItemKind::Method(..) | ImplItemKind::Const(..) =>\n                 DefPathData::ValueNs(ii.ident.name.as_str()),\n@@ -251,7 +264,7 @@ impl<'a> visit::Visitor for DefCollector<'a> {\n         });\n     }\n \n-    fn visit_pat(&mut self, pat: &Pat) {\n+    fn visit_pat(&mut self, pat: &'a Pat) {\n         let parent_def = self.parent_def;\n \n         match pat.node {\n@@ -267,7 +280,7 @@ impl<'a> visit::Visitor for DefCollector<'a> {\n         self.parent_def = parent_def;\n     }\n \n-    fn visit_expr(&mut self, expr: &Expr) {\n+    fn visit_expr(&mut self, expr: &'a Expr) {\n         let parent_def = self.parent_def;\n \n         match expr.node {\n@@ -284,7 +297,7 @@ impl<'a> visit::Visitor for DefCollector<'a> {\n         self.parent_def = parent_def;\n     }\n \n-    fn visit_ty(&mut self, ty: &Ty) {\n+    fn visit_ty(&mut self, ty: &'a Ty) {\n         match ty.node {\n             TyKind::Mac(..) => return self.visit_macro_invoc(ty.id, false),\n             TyKind::Array(_, ref length) => self.visit_ast_const_integer(length),\n@@ -296,15 +309,15 @@ impl<'a> visit::Visitor for DefCollector<'a> {\n         visit::walk_ty(self, ty);\n     }\n \n-    fn visit_lifetime_def(&mut self, def: &LifetimeDef) {\n+    fn visit_lifetime_def(&mut self, def: &'a LifetimeDef) {\n         self.create_def(def.lifetime.id, DefPathData::LifetimeDef(def.lifetime.name.as_str()));\n     }\n \n-    fn visit_macro_def(&mut self, macro_def: &MacroDef) {\n+    fn visit_macro_def(&mut self, macro_def: &'a MacroDef) {\n         self.create_def(macro_def.id, DefPathData::MacroDef(macro_def.ident.name.as_str()));\n     }\n \n-    fn visit_stmt(&mut self, stmt: &Stmt) {\n+    fn visit_stmt(&mut self, stmt: &'a Stmt) {\n         match stmt.node {\n             StmtKind::Mac(..) => self.visit_macro_invoc(stmt.id, false),\n             _ => visit::walk_stmt(self, stmt),\n@@ -313,7 +326,18 @@ impl<'a> visit::Visitor for DefCollector<'a> {\n }\n \n // We walk the HIR rather than the AST when reading items from metadata.\n-impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n+impl<'ast> Visitor<'ast> for DefCollector<'ast> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'ast> {\n+        // note however that we override `visit_body` below\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_body(&mut self, id: hir::ExprId) {\n+        if let Some(krate) = self.hir_crate {\n+            self.visit_expr(krate.expr(id));\n+        }\n+    }\n+\n     fn visit_item(&mut self, i: &'ast hir::Item) {\n         debug!(\"visit_item: {:?}\", i);\n \n@@ -423,7 +447,7 @@ impl<'ast> intravisit::Visitor<'ast> for DefCollector<'ast> {\n     fn visit_pat(&mut self, pat: &'ast hir::Pat) {\n         let parent_def = self.parent_def;\n \n-        if let hir::PatKind::Binding(_, name, _) = pat.node {\n+        if let hir::PatKind::Binding(_, _, name, _) = pat.node {\n             let def = self.create_def(pat.id, DefPathData::Binding(name.node.as_str()));\n             self.parent_def = Some(def);\n         }"}, {"sha": "117edcf14a1d169a5e718eb70cfc91a2e60ee79d", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 138, "deletions": 57, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -18,7 +18,6 @@ pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n use dep_graph::{DepGraph, DepNode};\n \n use middle::cstore::InlinedItem;\n-use middle::cstore::InlinedItem as II;\n use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n \n use syntax::abi::Abi;\n@@ -46,9 +45,11 @@ pub enum Node<'ast> {\n     NodeTraitItem(&'ast TraitItem),\n     NodeImplItem(&'ast ImplItem),\n     NodeVariant(&'ast Variant),\n+    NodeField(&'ast StructField),\n     NodeExpr(&'ast Expr),\n     NodeStmt(&'ast Stmt),\n     NodeTy(&'ast Ty),\n+    NodeTraitRef(&'ast TraitRef),\n     NodeLocal(&'ast Pat),\n     NodePat(&'ast Pat),\n     NodeBlock(&'ast Block),\n@@ -57,7 +58,10 @@ pub enum Node<'ast> {\n     NodeStructCtor(&'ast VariantData),\n \n     NodeLifetime(&'ast Lifetime),\n-    NodeTyParam(&'ast TyParam)\n+    NodeTyParam(&'ast TyParam),\n+    NodeVisibility(&'ast Visibility),\n+\n+    NodeInlinedItem(&'ast InlinedItem),\n }\n \n /// Represents an entry and its parent NodeID.\n@@ -73,15 +77,18 @@ pub enum MapEntry<'ast> {\n     EntryTraitItem(NodeId, &'ast TraitItem),\n     EntryImplItem(NodeId, &'ast ImplItem),\n     EntryVariant(NodeId, &'ast Variant),\n+    EntryField(NodeId, &'ast StructField),\n     EntryExpr(NodeId, &'ast Expr),\n     EntryStmt(NodeId, &'ast Stmt),\n     EntryTy(NodeId, &'ast Ty),\n+    EntryTraitRef(NodeId, &'ast TraitRef),\n     EntryLocal(NodeId, &'ast Pat),\n     EntryPat(NodeId, &'ast Pat),\n     EntryBlock(NodeId, &'ast Block),\n     EntryStructCtor(NodeId, &'ast VariantData),\n     EntryLifetime(NodeId, &'ast Lifetime),\n     EntryTyParam(NodeId, &'ast TyParam),\n+    EntryVisibility(NodeId, &'ast Visibility),\n \n     /// Roots for node trees.\n     RootCrate,\n@@ -102,15 +109,20 @@ impl<'ast> MapEntry<'ast> {\n             NodeTraitItem(n) => EntryTraitItem(p, n),\n             NodeImplItem(n) => EntryImplItem(p, n),\n             NodeVariant(n) => EntryVariant(p, n),\n+            NodeField(n) => EntryField(p, n),\n             NodeExpr(n) => EntryExpr(p, n),\n             NodeStmt(n) => EntryStmt(p, n),\n             NodeTy(n) => EntryTy(p, n),\n+            NodeTraitRef(n) => EntryTraitRef(p, n),\n             NodeLocal(n) => EntryLocal(p, n),\n             NodePat(n) => EntryPat(p, n),\n             NodeBlock(n) => EntryBlock(p, n),\n             NodeStructCtor(n) => EntryStructCtor(p, n),\n             NodeLifetime(n) => EntryLifetime(p, n),\n             NodeTyParam(n) => EntryTyParam(p, n),\n+            NodeVisibility(n) => EntryVisibility(p, n),\n+\n+            NodeInlinedItem(n) => RootInlinedParent(n),\n         }\n     }\n \n@@ -121,15 +133,18 @@ impl<'ast> MapEntry<'ast> {\n             EntryTraitItem(id, _) => id,\n             EntryImplItem(id, _) => id,\n             EntryVariant(id, _) => id,\n+            EntryField(id, _) => id,\n             EntryExpr(id, _) => id,\n             EntryStmt(id, _) => id,\n             EntryTy(id, _) => id,\n+            EntryTraitRef(id, _) => id,\n             EntryLocal(id, _) => id,\n             EntryPat(id, _) => id,\n             EntryBlock(id, _) => id,\n             EntryStructCtor(id, _) => id,\n             EntryLifetime(id, _) => id,\n             EntryTyParam(id, _) => id,\n+            EntryVisibility(id, _) => id,\n \n             NotPresent |\n             RootCrate |\n@@ -144,15 +159,19 @@ impl<'ast> MapEntry<'ast> {\n             EntryTraitItem(_, n) => NodeTraitItem(n),\n             EntryImplItem(_, n) => NodeImplItem(n),\n             EntryVariant(_, n) => NodeVariant(n),\n+            EntryField(_, n) => NodeField(n),\n             EntryExpr(_, n) => NodeExpr(n),\n             EntryStmt(_, n) => NodeStmt(n),\n             EntryTy(_, n) => NodeTy(n),\n+            EntryTraitRef(_, n) => NodeTraitRef(n),\n             EntryLocal(_, n) => NodeLocal(n),\n             EntryPat(_, n) => NodePat(n),\n             EntryBlock(_, n) => NodeBlock(n),\n             EntryStructCtor(_, n) => NodeStructCtor(n),\n             EntryLifetime(_, n) => NodeLifetime(n),\n             EntryTyParam(_, n) => NodeTyParam(n),\n+            EntryVisibility(_, n) => NodeVisibility(n),\n+            RootInlinedParent(n) => NodeInlinedItem(n),\n             _ => return None\n         })\n     }\n@@ -237,45 +256,63 @@ impl<'ast> Map<'ast> {\n         let map = self.map.borrow();\n         let mut id = id0;\n         if !self.is_inlined_node_id(id) {\n+            let mut last_expr = None;\n             loop {\n                 match map[id.as_usize()] {\n                     EntryItem(_, item) => {\n-                        let def_id = self.local_def_id(item.id);\n-                        // NB                          ^~~~~~~\n-                        //\n-                        // You would expect that `item.id == id`, but this\n-                        // is not always the case. In particular, for a\n-                        // ViewPath item like `use self::{mem, foo}`, we\n-                        // map the ids for `mem` and `foo` to the\n-                        // enclosing view path item. This seems mega super\n-                        // ultra wrong, but then who am I to judge?\n-                        // -nmatsakis\n+                        assert_eq!(id, item.id);\n+                        let def_id = self.local_def_id(id);\n                         assert!(!self.is_inlined_def_id(def_id));\n+\n+                        if let Some(last_id) = last_expr {\n+                            // The body of the item may have a separate dep node\n+                            // (Note that trait items don't currently have\n+                            // their own dep node, so there's also just one\n+                            // HirBody node for all the items)\n+                            if self.is_body(last_id, item) {\n+                                return DepNode::HirBody(def_id);\n+                            }\n+                        }\n                         return DepNode::Hir(def_id);\n                     }\n \n-                    EntryImplItem(..) => {\n+                    EntryImplItem(_, item) => {\n                         let def_id = self.local_def_id(id);\n                         assert!(!self.is_inlined_def_id(def_id));\n+\n+                        if let Some(last_id) = last_expr {\n+                            // The body of the item may have a separate dep node\n+                            if self.is_impl_item_body(last_id, item) {\n+                                return DepNode::HirBody(def_id);\n+                            }\n+                        }\n                         return DepNode::Hir(def_id);\n                     }\n \n                     EntryForeignItem(p, _) |\n                     EntryTraitItem(p, _) |\n                     EntryVariant(p, _) |\n-                    EntryExpr(p, _) |\n+                    EntryField(p, _) |\n                     EntryStmt(p, _) |\n                     EntryTy(p, _) |\n+                    EntryTraitRef(p, _) |\n                     EntryLocal(p, _) |\n                     EntryPat(p, _) |\n                     EntryBlock(p, _) |\n                     EntryStructCtor(p, _) |\n                     EntryLifetime(p, _) |\n-                    EntryTyParam(p, _) =>\n+                    EntryTyParam(p, _) |\n+                    EntryVisibility(p, _) =>\n                         id = p,\n \n-                    RootCrate =>\n-                        return DepNode::Krate,\n+                    EntryExpr(p, _) => {\n+                        last_expr = Some(id);\n+                        id = p;\n+                    }\n+\n+                    RootCrate => {\n+                        return DepNode::Hir(DefId::local(CRATE_DEF_INDEX));\n+                    }\n \n                     RootInlinedParent(_) =>\n                         bug!(\"node {} has inlined ancestor but is not inlined\", id0),\n@@ -304,23 +341,22 @@ impl<'ast> Map<'ast> {\n                     EntryTraitItem(p, _) |\n                     EntryImplItem(p, _) |\n                     EntryVariant(p, _) |\n+                    EntryField(p, _) |\n                     EntryExpr(p, _) |\n                     EntryStmt(p, _) |\n                     EntryTy(p, _) |\n+                    EntryTraitRef(p, _) |\n                     EntryLocal(p, _) |\n                     EntryPat(p, _) |\n                     EntryBlock(p, _) |\n                     EntryStructCtor(p, _) |\n                     EntryLifetime(p, _) |\n-                    EntryTyParam(p, _) =>\n+                    EntryTyParam(p, _) |\n+                    EntryVisibility(p, _) =>\n                         id = p,\n \n-                    RootInlinedParent(parent) => match *parent {\n-                        InlinedItem::Item(def_id, _) |\n-                        InlinedItem::TraitItem(def_id, _) |\n-                        InlinedItem::ImplItem(def_id, _) =>\n-                            return DepNode::MetaData(def_id)\n-                    },\n+                    RootInlinedParent(parent) =>\n+                        return DepNode::MetaData(parent.def_id),\n \n                     RootCrate =>\n                         bug!(\"node {} has crate ancestor but is inlined\", id0),\n@@ -332,6 +368,29 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n+    fn is_body(&self, node_id: NodeId, item: &Item) -> bool {\n+        match item.node {\n+            ItemFn(_, _, _, _, _, body) => body.node_id() == node_id,\n+            // Since trait items currently don't get their own dep nodes,\n+            // we check here whether node_id is the body of any of the items.\n+            // If they get their own dep nodes, this can go away\n+            ItemTrait(_, _, _, ref trait_items) => {\n+                trait_items.iter().any(|trait_item| { match trait_item.node {\n+                    MethodTraitItem(_, Some(body)) => body.node_id() == node_id,\n+                    _ => false\n+                }})\n+            }\n+            _ => false\n+        }\n+    }\n+\n+    fn is_impl_item_body(&self, node_id: NodeId, item: &ImplItem) -> bool {\n+        match item.node {\n+            ImplItemKind::Method(_, body) => body.node_id() == node_id,\n+            _ => false\n+        }\n+    }\n+\n     pub fn num_local_def_ids(&self) -> usize {\n         self.definitions.borrow().len()\n     }\n@@ -543,8 +602,7 @@ impl<'ast> Map<'ast> {\n     pub fn get_parent_did(&self, id: NodeId) -> DefId {\n         let parent = self.get_parent(id);\n         match self.find_entry(parent) {\n-            Some(RootInlinedParent(&II::TraitItem(did, _))) |\n-            Some(RootInlinedParent(&II::ImplItem(did, _))) => did,\n+            Some(RootInlinedParent(ii)) => ii.def_id,\n             _ => self.local_def_id(parent)\n         }\n     }\n@@ -642,6 +700,10 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n+    pub fn expr(&self, id: ExprId) -> &'ast Expr {\n+        self.expect_expr(id.node_id())\n+    }\n+\n     /// Returns the name associated with the given NodeId's AST.\n     pub fn name(&self, id: NodeId) -> Name {\n         match self.get(id) {\n@@ -650,9 +712,10 @@ impl<'ast> Map<'ast> {\n             NodeImplItem(ii) => ii.name,\n             NodeTraitItem(ti) => ti.name,\n             NodeVariant(v) => v.node.name,\n+            NodeField(f) => f.name,\n             NodeLifetime(lt) => lt.name,\n             NodeTyParam(tp) => tp.name,\n-            NodeLocal(&Pat { node: PatKind::Binding(_,l,_), .. }) => l.node,\n+            NodeLocal(&Pat { node: PatKind::Binding(_,_,l,_), .. }) => l.node,\n             NodeStructCtor(_) => self.name(self.get_parent(id)),\n             _ => bug!(\"no name for {}\", self.node_to_string(id))\n         }\n@@ -668,6 +731,7 @@ impl<'ast> Map<'ast> {\n             Some(NodeTraitItem(ref ti)) => Some(&ti.attrs[..]),\n             Some(NodeImplItem(ref ii)) => Some(&ii.attrs[..]),\n             Some(NodeVariant(ref v)) => Some(&v.node.attrs[..]),\n+            Some(NodeField(ref f)) => Some(&f.attrs[..]),\n             Some(NodeExpr(ref e)) => Some(&*e.attrs),\n             Some(NodeStmt(ref s)) => Some(s.node.attrs()),\n             // unit/tuple structs take the attributes straight from\n@@ -697,44 +761,40 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n-    pub fn opt_span(&self, id: NodeId) -> Option<Span> {\n-        let sp = match self.find(id) {\n-            Some(NodeItem(item)) => item.span,\n-            Some(NodeForeignItem(foreign_item)) => foreign_item.span,\n-            Some(NodeTraitItem(trait_method)) => trait_method.span,\n-            Some(NodeImplItem(ref impl_item)) => impl_item.span,\n-            Some(NodeVariant(variant)) => variant.span,\n-            Some(NodeExpr(expr)) => expr.span,\n-            Some(NodeStmt(stmt)) => stmt.span,\n-            Some(NodeTy(ty)) => ty.span,\n-            Some(NodeLocal(pat)) => pat.span,\n-            Some(NodePat(pat)) => pat.span,\n-            Some(NodeBlock(block)) => block.span,\n-            Some(NodeStructCtor(_)) => self.expect_item(self.get_parent(id)).span,\n-            Some(NodeTyParam(ty_param)) => ty_param.span,\n-            _ => return None,\n-        };\n-        Some(sp)\n-    }\n-\n     pub fn span(&self, id: NodeId) -> Span {\n         self.read(id); // reveals span from node\n-        self.opt_span(id)\n-            .unwrap_or_else(|| bug!(\"AstMap.span: could not find span for id {:?}\", id))\n+        match self.find_entry(id) {\n+            Some(EntryItem(_, item)) => item.span,\n+            Some(EntryForeignItem(_, foreign_item)) => foreign_item.span,\n+            Some(EntryTraitItem(_, trait_method)) => trait_method.span,\n+            Some(EntryImplItem(_, impl_item)) => impl_item.span,\n+            Some(EntryVariant(_, variant)) => variant.span,\n+            Some(EntryField(_, field)) => field.span,\n+            Some(EntryExpr(_, expr)) => expr.span,\n+            Some(EntryStmt(_, stmt)) => stmt.span,\n+            Some(EntryTy(_, ty)) => ty.span,\n+            Some(EntryTraitRef(_, tr)) => tr.path.span,\n+            Some(EntryLocal(_, pat)) => pat.span,\n+            Some(EntryPat(_, pat)) => pat.span,\n+            Some(EntryBlock(_, block)) => block.span,\n+            Some(EntryStructCtor(_, _)) => self.expect_item(self.get_parent(id)).span,\n+            Some(EntryLifetime(_, lifetime)) => lifetime.span,\n+            Some(EntryTyParam(_, ty_param)) => ty_param.span,\n+            Some(EntryVisibility(_, &Visibility::Restricted { ref path, .. })) => path.span,\n+            Some(EntryVisibility(_, v)) => bug!(\"unexpected Visibility {:?}\", v),\n+\n+            Some(RootCrate) => self.forest.krate.span,\n+            Some(RootInlinedParent(parent)) => parent.body.span,\n+            Some(NotPresent) | None => {\n+                bug!(\"hir::map::Map::span: id not in map: {:?}\", id)\n+            }\n+        }\n     }\n \n     pub fn span_if_local(&self, id: DefId) -> Option<Span> {\n         self.as_local_node_id(id).map(|id| self.span(id))\n     }\n \n-    pub fn def_id_span(&self, def_id: DefId, fallback: Span) -> Span {\n-        if let Some(node_id) = self.as_local_node_id(def_id) {\n-            self.opt_span(node_id).unwrap_or(fallback)\n-        } else {\n-            fallback\n-        }\n-    }\n-\n     pub fn node_to_string(&self, id: NodeId) -> String {\n         node_id_to_string(self, id, true)\n     }\n@@ -823,6 +883,7 @@ impl<'a, 'ast> Iterator for NodesMatchingSuffix<'a, 'ast> {\n                 Some(EntryTraitItem(_, n))  => n.name(),\n                 Some(EntryImplItem(_, n))   => n.name(),\n                 Some(EntryVariant(_, n))    => n.name(),\n+                Some(EntryField(_, n))      => n.name(),\n                 _ => continue,\n             };\n             if self.matches_names(self.map.get_parent(idx), name) {\n@@ -841,6 +902,7 @@ impl<T:Named> Named for Spanned<T> { fn name(&self) -> Name { self.node.name() }\n impl Named for Item { fn name(&self) -> Name { self.name } }\n impl Named for ForeignItem { fn name(&self) -> Name { self.name } }\n impl Named for Variant_ { fn name(&self) -> Name { self.name } }\n+impl Named for StructField { fn name(&self) -> Name { self.name } }\n impl Named for TraitItem { fn name(&self) -> Name { self.name } }\n impl Named for ImplItem { fn name(&self) -> Name { self.name } }\n \n@@ -926,15 +988,20 @@ impl<'a> NodePrinter for pprust::State<'a> {\n             NodeExpr(a)        => self.print_expr(&a),\n             NodeStmt(a)        => self.print_stmt(&a),\n             NodeTy(a)          => self.print_type(&a),\n+            NodeTraitRef(a)    => self.print_trait_ref(&a),\n             NodePat(a)         => self.print_pat(&a),\n             NodeBlock(a)       => self.print_block(&a),\n             NodeLifetime(a)    => self.print_lifetime(&a),\n+            NodeVisibility(a)  => self.print_visibility(&a),\n             NodeTyParam(_)     => bug!(\"cannot print TyParam\"),\n+            NodeField(_)       => bug!(\"cannot print StructField\"),\n             // these cases do not carry enough information in the\n             // ast_map to reconstruct their full structure for pretty\n             // printing.\n             NodeLocal(_)       => bug!(\"cannot print isolated Local\"),\n             NodeStructCtor(_)  => bug!(\"cannot print isolated StructCtor\"),\n+\n+            NodeInlinedItem(_) => bug!(\"cannot print inlined item\"),\n         }\n     }\n }\n@@ -1009,6 +1076,11 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n                     variant.node.name,\n                     path_str(), id_str)\n         }\n+        Some(NodeField(ref field)) => {\n+            format!(\"field {} in {}{}\",\n+                    field.name,\n+                    path_str(), id_str)\n+        }\n         Some(NodeExpr(ref expr)) => {\n             format!(\"expr {}{}\", pprust::expr_to_string(&expr), id_str)\n         }\n@@ -1018,6 +1090,9 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         Some(NodeTy(ref ty)) => {\n             format!(\"type {}{}\", pprust::ty_to_string(&ty), id_str)\n         }\n+        Some(NodeTraitRef(ref tr)) => {\n+            format!(\"trait_ref {}{}\", pprust::path_to_string(&tr.path), id_str)\n+        }\n         Some(NodeLocal(ref pat)) => {\n             format!(\"local {}{}\", pprust::pat_to_string(&pat), id_str)\n         }\n@@ -1037,6 +1112,12 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         Some(NodeTyParam(ref ty_param)) => {\n             format!(\"typaram {:?}{}\", ty_param, id_str)\n         }\n+        Some(NodeVisibility(ref vis)) => {\n+            format!(\"visibility {:?}{}\", vis, id_str)\n+        }\n+        Some(NodeInlinedItem(_)) => {\n+            format!(\"inlined item {}\", id_str)\n+        }\n         None => {\n             format!(\"unknown node{}\", id_str)\n         }"}, {"sha": "4fd8f96ba046a7a74526317c37d12a2bd09a69f6", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 111, "deletions": 86, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -27,13 +27,13 @@ pub use self::Ty_::*;\n pub use self::TyParamBound::*;\n pub use self::UnOp::*;\n pub use self::UnsafeSource::*;\n-pub use self::ViewPath_::*;\n pub use self::Visibility::{Public, Inherited};\n pub use self::PathParameters::*;\n \n use hir::def::Def;\n use hir::def_id::DefId;\n use util::nodemap::{NodeMap, FxHashSet};\n+use rustc_data_structures::fnv::FnvHashMap;\n \n use syntax_pos::{mk_sp, Span, ExpnId, DUMMY_SP};\n use syntax::codemap::{self, respan, Spanned};\n@@ -108,6 +108,8 @@ pub struct Path {\n     /// A `::foo` path, is relative to the crate root rather than current\n     /// module (like paths in an import).\n     pub global: bool,\n+    /// The definition that the path resolved to.\n+    pub def: Def,\n     /// The segments in the path: the things separated by `::`.\n     pub segments: HirVec<PathSegment>,\n }\n@@ -124,21 +126,6 @@ impl fmt::Display for Path {\n     }\n }\n \n-impl Path {\n-    /// Convert a span and an identifier to the corresponding\n-    /// 1-segment path.\n-    pub fn from_name(s: Span, name: Name) -> Path {\n-        Path {\n-            span: s,\n-            global: false,\n-            segments: hir_vec![PathSegment {\n-                name: name,\n-                parameters: PathParameters::none()\n-            }],\n-        }\n-    }\n-}\n-\n /// A segment of a path: an identifier, an optional lifetime, and a set of\n /// types.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -154,6 +141,16 @@ pub struct PathSegment {\n     pub parameters: PathParameters,\n }\n \n+impl PathSegment {\n+    /// Convert an identifier to the corresponding segment.\n+    pub fn from_name(name: Name) -> PathSegment {\n+        PathSegment {\n+            name: name,\n+            parameters: PathParameters::none()\n+        }\n+    }\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum PathParameters {\n     /// The `<'a, A,B,C>` in `foo::bar::baz::<'a, A,B,C>`\n@@ -167,6 +164,7 @@ impl PathParameters {\n         AngleBracketedParameters(AngleBracketedParameterData {\n             lifetimes: HirVec::new(),\n             types: HirVec::new(),\n+            infer_types: true,\n             bindings: HirVec::new(),\n         })\n     }\n@@ -241,6 +239,11 @@ pub struct AngleBracketedParameterData {\n     pub lifetimes: HirVec<Lifetime>,\n     /// The type parameters for this path segment, if present.\n     pub types: HirVec<P<Ty>>,\n+    /// Whether to infer remaining type parameters, if any.\n+    /// This only applies to expression and pattern paths, and\n+    /// out of those only the segments with no type parameters\n+    /// to begin with, e.g. `Vec::new` is `<Vec<..>>::new::<..>`.\n+    pub infer_types: bool,\n     /// Bindings (equality constraints) on associated types, if present.\n     /// E.g., `Foo<A=Bar>`.\n     pub bindings: HirVec<TypeBinding>,\n@@ -426,6 +429,7 @@ pub struct Crate {\n     pub items: BTreeMap<NodeId, Item>,\n \n     pub impl_items: BTreeMap<ImplItemId, ImplItem>,\n+    pub exprs: FnvHashMap<ExprId, Expr>,\n }\n \n impl Crate {\n@@ -456,6 +460,10 @@ impl Crate {\n             visitor.visit_impl_item(impl_item);\n         }\n     }\n+\n+    pub fn expr(&self, id: ExprId) -> &Expr {\n+        &self.exprs[&id]\n+    }\n }\n \n /// A macro definition, in this crate or imported from another.\n@@ -527,7 +535,7 @@ impl Pat {\n             PatKind::Lit(_) |\n             PatKind::Range(..) |\n             PatKind::Binding(..) |\n-            PatKind::Path(..) => {\n+            PatKind::Path(_) => {\n                 true\n             }\n         }\n@@ -566,20 +574,20 @@ pub enum PatKind {\n     Wild,\n \n     /// A fresh binding `ref mut binding @ OPT_SUBPATTERN`.\n-    Binding(BindingMode, Spanned<Name>, Option<P<Pat>>),\n+    /// The `DefId` is for the definition of the variable being bound.\n+    Binding(BindingMode, DefId, Spanned<Name>, Option<P<Pat>>),\n \n     /// A struct or struct variant pattern, e.g. `Variant {x, y, ..}`.\n     /// The `bool` is `true` in the presence of a `..`.\n-    Struct(Path, HirVec<Spanned<FieldPat>>, bool),\n+    Struct(QPath, HirVec<Spanned<FieldPat>>, bool),\n \n     /// A tuple struct/variant pattern `Variant(x, y, .., z)`.\n     /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n     /// 0 <= position <= subpats.len()\n-    TupleStruct(Path, HirVec<P<Pat>>, Option<usize>),\n+    TupleStruct(QPath, HirVec<P<Pat>>, Option<usize>),\n \n-    /// A possibly qualified path pattern.\n-    /// Such pattern can be resolved to a unit struct/variant or a constant.\n-    Path(Option<QSelf>, Path),\n+    /// A path pattern for an unit struct/variant or a (maybe-associated) constant.\n+    Path(QPath),\n \n     /// A tuple pattern `(a, b)`.\n     /// If the `..` pattern fragment is present, then `Option<usize>` denotes its position.\n@@ -836,9 +844,6 @@ pub enum BlockCheckMode {\n     UnsafeBlock(UnsafeSource),\n     PushUnsafeBlock(UnsafeSource),\n     PopUnsafeBlock(UnsafeSource),\n-    // Within this block (but outside a PopUnstableBlock), we suspend checking of stability.\n-    PushUnstableBlock,\n-    PopUnstableBlock,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n@@ -847,6 +852,15 @@ pub enum UnsafeSource {\n     UserProvided,\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub struct ExprId(NodeId);\n+\n+impl ExprId {\n+    pub fn node_id(self) -> NodeId {\n+        self.0\n+    }\n+}\n+\n /// An expression\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash)]\n pub struct Expr {\n@@ -856,6 +870,12 @@ pub struct Expr {\n     pub attrs: ThinVec<Attribute>,\n }\n \n+impl Expr {\n+    pub fn expr_id(&self) -> ExprId {\n+        ExprId(self.id)\n+    }\n+}\n+\n impl fmt::Debug for Expr {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"expr({}: {})\", self.id, print::expr_to_string(self))\n@@ -915,7 +935,7 @@ pub enum Expr_ {\n     /// A closure (for example, `move |a, b, c| {a + b + c}`).\n     ///\n     /// The final span is the span of the argument block `|...|`\n-    ExprClosure(CaptureClause, P<FnDecl>, P<Expr>, Span),\n+    ExprClosure(CaptureClause, P<FnDecl>, ExprId, Span),\n     /// A block (`{ ... }`)\n     ExprBlock(P<Block>),\n \n@@ -934,19 +954,15 @@ pub enum Expr_ {\n     /// An indexing operation (`foo[2]`)\n     ExprIndex(P<Expr>, P<Expr>),\n \n-    /// Variable reference, possibly containing `::` and/or type\n-    /// parameters, e.g. foo::bar::<baz>.\n-    ///\n-    /// Optionally \"qualified\",\n-    /// e.g. `<HirVec<T> as SomeTrait>::SomeType`.\n-    ExprPath(Option<QSelf>, Path),\n+    /// Path to a definition, possibly containing lifetime or type parameters.\n+    ExprPath(QPath),\n \n     /// A referencing operation (`&a` or `&mut a`)\n     ExprAddrOf(Mutability, P<Expr>),\n     /// A `break`, with an optional label to break\n-    ExprBreak(Option<Spanned<Name>>, Option<P<Expr>>),\n+    ExprBreak(Option<Label>, Option<P<Expr>>),\n     /// A `continue`, with an optional label\n-    ExprAgain(Option<Spanned<Name>>),\n+    ExprAgain(Option<Label>),\n     /// A `return`, with an optional value to be returned\n     ExprRet(Option<P<Expr>>),\n \n@@ -957,7 +973,7 @@ pub enum Expr_ {\n     ///\n     /// For example, `Foo {x: 1, y: 2}`, or\n     /// `Foo {x: 1, .. base}`, where `base` is the `Option<Expr>`.\n-    ExprStruct(P<Path>, HirVec<Field>, Option<P<Expr>>),\n+    ExprStruct(QPath, HirVec<Field>, Option<P<Expr>>),\n \n     /// An array literal constructed from one repeated element.\n     ///\n@@ -966,22 +982,30 @@ pub enum Expr_ {\n     ExprRepeat(P<Expr>, P<Expr>),\n }\n \n-/// The explicit Self type in a \"qualified path\". The actual\n-/// path, including the trait and the associated item, is stored\n-/// separately. `position` represents the index of the associated\n-/// item qualified with this Self type.\n-///\n-///     <HirVec<T> as a::b::Trait>::AssociatedItem\n-///      ^~~~~     ~~~~~~~~~~~~~~^\n-///      ty        position = 3\n-///\n-///     <HirVec<T>>::AssociatedItem\n-///      ^~~~~    ^\n-///      ty       position = 0\n+/// Optionally `Self`-qualified value/type path or associated extension.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub struct QSelf {\n-    pub ty: P<Ty>,\n-    pub position: usize,\n+pub enum QPath {\n+    /// Path to a definition, optionally \"fully-qualified\" with a `Self`\n+    /// type, if the path points to an associated item in a trait.\n+    ///\n+    /// E.g. an unqualified path like `Clone::clone` has `None` for `Self`,\n+    /// while `<Vec<T> as Clone>::clone` has `Some(Vec<T>)` for `Self`,\n+    /// even though they both have the same two-segment `Clone::clone` `Path`.\n+    Resolved(Option<P<Ty>>, P<Path>),\n+\n+    /// Type-related paths, e.g. `<T>::default` or `<T>::Output`.\n+    /// Will be resolved by type-checking to an associated item.\n+    ///\n+    /// UFCS source paths can desugar into this, with `Vec::new` turning into\n+    /// `<Vec>::new`, and `T::X::Y::method` into `<<<T>::X>::Y>::method`,\n+    /// the `X` and `Y` nodes being each a `TyPath(QPath::TypeRelative(..))`.\n+    TypeRelative(P<Ty>, P<PathSegment>)\n+}\n+\n+impl fmt::Display for QPath {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", print::qpath_to_string(self))\n+    }\n }\n \n /// Hints at the original code for a `match _ { .. }`\n@@ -1014,6 +1038,13 @@ pub enum LoopSource {\n }\n \n \n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+pub struct Label {\n+    pub span: Span,\n+    pub name: Name,\n+    pub loop_id: NodeId\n+}\n+\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n pub enum CaptureClause {\n     CaptureByValue,\n@@ -1058,7 +1089,7 @@ pub enum TraitItem_ {\n     /// must contain a value)\n     ConstTraitItem(P<Ty>, Option<P<Expr>>),\n     /// A method with an optional body\n-    MethodTraitItem(MethodSig, Option<P<Expr>>),\n+    MethodTraitItem(MethodSig, Option<ExprId>),\n     /// An associated type with (possibly empty) bounds and optional concrete\n     /// type\n     TypeTraitItem(TyParamBounds, Option<P<Ty>>),\n@@ -1091,7 +1122,7 @@ pub enum ImplItemKind {\n     /// of the expression\n     Const(P<Ty>, P<Expr>),\n     /// A method implementation with the given signature and body\n-    Method(MethodSig, P<Expr>),\n+    Method(MethodSig, ExprId),\n     /// An associated type\n     Type(P<Ty>),\n }\n@@ -1155,11 +1186,12 @@ pub enum Ty_ {\n     TyNever,\n     /// A tuple (`(A, B, C, D,...)`)\n     TyTup(HirVec<P<Ty>>),\n-    /// A path (`module::module::...::Type`), optionally\n-    /// \"qualified\", e.g. `<HirVec<T> as SomeTrait>::SomeType`.\n+    /// A path to a type definition (`module::module::...::Type`), or an\n+    /// associated type, e.g. `<Vec<T> as Trait>::Type` or `<T>::Target`.\n     ///\n-    /// Type parameters are stored in the Path itself\n-    TyPath(Option<QSelf>, Path),\n+    /// Type parameters may be stored in each `PathSegment`.\n+    TyPath(QPath),\n+\n     /// Something like `A+B`. Note that `B` must always be a path.\n     TyObjectSum(P<Ty>, TyParamBounds),\n     /// A type like `for<'a> Foo<&'a Bar>`\n@@ -1216,7 +1248,7 @@ pub type ExplicitSelf = Spanned<SelfKind>;\n \n impl Arg {\n     pub fn to_self(&self) -> Option<ExplicitSelf> {\n-        if let PatKind::Binding(BindByValue(mutbl), name, _) = self.pat.node {\n+        if let PatKind::Binding(BindByValue(mutbl), _, name, _) = self.pat.node {\n             if name.node == keywords::SelfValue.name() {\n                 return match self.ty.node {\n                     TyInfer => Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n@@ -1232,7 +1264,7 @@ impl Arg {\n     }\n \n     pub fn is_self(&self) -> bool {\n-        if let PatKind::Binding(_, name, _) = self.pat.node {\n+        if let PatKind::Binding(_, _, name, _) = self.pat.node {\n             name.node == keywords::SelfValue.name()\n         } else {\n             false\n@@ -1375,32 +1407,20 @@ pub struct Variant_ {\n \n pub type Variant = Spanned<Variant_>;\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n-pub struct PathListItem_ {\n-    pub name: Name,\n-    /// renamed in list, eg `use foo::{bar as baz};`\n-    pub rename: Option<Name>,\n-    pub id: NodeId,\n-}\n-\n-pub type PathListItem = Spanned<PathListItem_>;\n-\n-pub type ViewPath = Spanned<ViewPath_>;\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum ViewPath_ {\n-    /// `foo::bar::baz as quux`\n-    ///\n-    /// or just\n-    ///\n-    /// `foo::bar::baz` (with `as baz` implicitly on the right)\n-    ViewPathSimple(Name, Path),\n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum UseKind {\n+    /// One import, e.g. `use foo::bar` or `use foo::bar as baz`.\n+    /// Also produced for each element of a list `use`, e.g.\n+    // `use foo::{a, b}` lowers to `use foo::a; use foo::b;`.\n+    Single,\n \n-    /// `foo::bar::*`\n-    ViewPathGlob(Path),\n+    /// Glob import, e.g. `use foo::*`.\n+    Glob,\n \n-    /// `foo::bar::{a,b,c}`\n-    ViewPathList(Path, HirVec<PathListItem>),\n+    /// Degenerate list import, e.g. `use foo::{a, b}` produces\n+    /// an additional `use foo::{}` for performing checks such as\n+    /// unstable feature gating. May be removed in the future.\n+    ListStem,\n }\n \n /// TraitRef's appear in impls.\n@@ -1534,15 +1554,20 @@ pub enum Item_ {\n     ///\n     /// e.g. `extern crate foo` or `extern crate foo_bar as foo`\n     ItemExternCrate(Option<Name>),\n-    /// A `use` or `pub use` item\n-    ItemUse(P<ViewPath>),\n+\n+    /// `use foo::bar::*;` or `use foo::bar::baz as quux;`\n+    ///\n+    /// or just\n+    ///\n+    /// `use foo::bar::baz;` (with `as baz` implicitly on the right)\n+    ItemUse(P<Path>, UseKind),\n \n     /// A `static` item\n     ItemStatic(P<Ty>, Mutability, P<Expr>),\n     /// A `const` item\n     ItemConst(P<Ty>, P<Expr>),\n     /// A function declaration\n-    ItemFn(P<FnDecl>, Unsafety, Constness, Abi, Generics, P<Expr>),\n+    ItemFn(P<FnDecl>, Unsafety, Constness, Abi, Generics, ExprId),\n     /// A module\n     ItemMod(Mod),\n     /// An external module"}, {"sha": "0190e74df69533e0be712482fe9fe99a24c1d78e", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 122, "deletions": 118, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -8,13 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hir::def::*;\n+use hir::def::Def;\n use hir::def_id::DefId;\n use hir::{self, PatKind};\n-use ty::TyCtxt;\n use syntax::ast;\n use syntax::codemap::Spanned;\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::Span;\n \n use std::iter::{Enumerate, ExactSizeIterator};\n \n@@ -51,139 +50,144 @@ impl<T: ExactSizeIterator> EnumerateAndAdjustIterator for T {\n     }\n }\n \n-pub fn pat_is_refutable(dm: &DefMap, pat: &hir::Pat) -> bool {\n-    match pat.node {\n-        PatKind::Lit(_) | PatKind::Range(..) | PatKind::Path(Some(..), _) => true,\n-        PatKind::TupleStruct(..) |\n-        PatKind::Path(..) |\n-        PatKind::Struct(..) => {\n-            match dm.get(&pat.id).map(|d| d.full_def()) {\n-                Some(Def::Variant(..)) | Some(Def::VariantCtor(..)) => true,\n-                _ => false\n+impl hir::Pat {\n+    pub fn is_refutable(&self) -> bool {\n+        match self.node {\n+            PatKind::Lit(_) |\n+            PatKind::Range(..) |\n+            PatKind::Path(hir::QPath::Resolved(Some(..), _)) |\n+            PatKind::Path(hir::QPath::TypeRelative(..)) => true,\n+\n+            PatKind::Path(hir::QPath::Resolved(_, ref path)) |\n+            PatKind::TupleStruct(hir::QPath::Resolved(_, ref path), ..) |\n+            PatKind::Struct(hir::QPath::Resolved(_, ref path), ..) => {\n+                match path.def {\n+                    Def::Variant(..) | Def::VariantCtor(..) => true,\n+                    _ => false\n+                }\n             }\n+            PatKind::Slice(..) => true,\n+            _ => false\n         }\n-        PatKind::Slice(..) => true,\n-        _ => false\n     }\n-}\n \n-pub fn pat_is_const(dm: &DefMap, pat: &hir::Pat) -> bool {\n-    match pat.node {\n-        PatKind::Path(..) => {\n-            match dm.get(&pat.id).map(|d| d.full_def()) {\n-                Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => true,\n-                _ => false\n+    pub fn is_const(&self) -> bool {\n+        match self.node {\n+            PatKind::Path(hir::QPath::TypeRelative(..)) => true,\n+            PatKind::Path(hir::QPath::Resolved(_, ref path)) => {\n+                match path.def {\n+                    Def::Const(..) | Def::AssociatedConst(..) => true,\n+                    _ => false\n+                }\n             }\n+            _ => false\n         }\n-        _ => false\n     }\n-}\n \n-/// Call `f` on every \"binding\" in a pattern, e.g., on `a` in\n-/// `match foo() { Some(a) => (), None => () }`\n-pub fn pat_bindings<F>(pat: &hir::Pat, mut f: F)\n-    where F: FnMut(hir::BindingMode, ast::NodeId, Span, &Spanned<ast::Name>),\n-{\n-    pat.walk(|p| {\n-        if let PatKind::Binding(binding_mode, ref pth, _) = p.node {\n-            f(binding_mode, p.id, p.span, pth);\n-        }\n-        true\n-    });\n-}\n-\n-/// Checks if the pattern contains any patterns that bind something to\n-/// an ident, e.g. `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n-pub fn pat_contains_bindings(pat: &hir::Pat) -> bool {\n-    let mut contains_bindings = false;\n-    pat.walk(|p| {\n-        if let PatKind::Binding(..) = p.node {\n-            contains_bindings = true;\n-            false // there's at least one binding, can short circuit now.\n-        } else {\n+    /// Call `f` on every \"binding\" in a pattern, e.g., on `a` in\n+    /// `match foo() { Some(a) => (), None => () }`\n+    pub fn each_binding<F>(&self, mut f: F)\n+        where F: FnMut(hir::BindingMode, ast::NodeId, Span, &Spanned<ast::Name>),\n+    {\n+        self.walk(|p| {\n+            if let PatKind::Binding(binding_mode, _, ref pth, _) = p.node {\n+                f(binding_mode, p.id, p.span, pth);\n+            }\n             true\n-        }\n-    });\n-    contains_bindings\n-}\n+        });\n+    }\n \n-/// Checks if the pattern contains any `ref` or `ref mut` bindings,\n-/// and if yes whether its containing mutable ones or just immutables ones.\n-pub fn pat_contains_ref_binding(pat: &hir::Pat) -> Option<hir::Mutability> {\n-    let mut result = None;\n-    pat_bindings(pat, |mode, _, _, _| {\n-        if let hir::BindingMode::BindByRef(m) = mode {\n-            // Pick Mutable as maximum\n-            match result {\n-                None | Some(hir::MutImmutable) => result = Some(m),\n-                _ => (),\n+    /// Checks if the pattern contains any patterns that bind something to\n+    /// an ident, e.g. `foo`, or `Foo(foo)` or `foo @ Bar(..)`.\n+    pub fn contains_bindings(&self) -> bool {\n+        let mut contains_bindings = false;\n+        self.walk(|p| {\n+            if let PatKind::Binding(..) = p.node {\n+                contains_bindings = true;\n+                false // there's at least one binding, can short circuit now.\n+            } else {\n+                true\n             }\n-        }\n-    });\n-    result\n-}\n-\n-/// Checks if the patterns for this arm contain any `ref` or `ref mut`\n-/// bindings, and if yes whether its containing mutable ones or just immutables ones.\n-pub fn arm_contains_ref_binding(arm: &hir::Arm) -> Option<hir::Mutability> {\n-    arm.pats.iter()\n-            .filter_map(|pat| pat_contains_ref_binding(pat))\n-            .max_by_key(|m| match *m {\n-                hir::MutMutable => 1,\n-                hir::MutImmutable => 0,\n-            })\n-}\n+        });\n+        contains_bindings\n+    }\n \n-/// Checks if the pattern contains any patterns that bind something to\n-/// an ident or wildcard, e.g. `foo`, or `Foo(_)`, `foo @ Bar(..)`,\n-pub fn pat_contains_bindings_or_wild(pat: &hir::Pat) -> bool {\n-    let mut contains_bindings = false;\n-    pat.walk(|p| {\n-        match p.node {\n-            PatKind::Binding(..) | PatKind::Wild => {\n-                contains_bindings = true;\n-                false // there's at least one binding/wildcard, can short circuit now.\n+    /// Checks if the pattern contains any patterns that bind something to\n+    /// an ident or wildcard, e.g. `foo`, or `Foo(_)`, `foo @ Bar(..)`,\n+    pub fn contains_bindings_or_wild(&self) -> bool {\n+        let mut contains_bindings = false;\n+        self.walk(|p| {\n+            match p.node {\n+                PatKind::Binding(..) | PatKind::Wild => {\n+                    contains_bindings = true;\n+                    false // there's at least one binding/wildcard, can short circuit now.\n+                }\n+                _ => true\n             }\n-            _ => true\n-        }\n-    });\n-    contains_bindings\n-}\n+        });\n+        contains_bindings\n+    }\n \n-pub fn simple_name<'a>(pat: &'a hir::Pat) -> Option<ast::Name> {\n-    match pat.node {\n-        PatKind::Binding(hir::BindByValue(..), ref path1, None) => {\n-            Some(path1.node)\n-        }\n-        _ => {\n-            None\n+    pub fn simple_name(&self) -> Option<ast::Name> {\n+        match self.node {\n+            PatKind::Binding(hir::BindByValue(..), _, ref path1, None) => {\n+                Some(path1.node)\n+            }\n+            _ => {\n+                None\n+            }\n         }\n     }\n-}\n \n-pub fn def_to_path<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> hir::Path {\n-    hir::Path::from_name(DUMMY_SP, tcx.item_name(id))\n-}\n+    /// Return variants that are necessary to exist for the pattern to match.\n+    pub fn necessary_variants(&self) -> Vec<DefId> {\n+        let mut variants = vec![];\n+        self.walk(|p| {\n+            match p.node {\n+                PatKind::Path(hir::QPath::Resolved(_, ref path)) |\n+                PatKind::TupleStruct(hir::QPath::Resolved(_, ref path), ..) |\n+                PatKind::Struct(hir::QPath::Resolved(_, ref path), ..) => {\n+                    match path.def {\n+                        Def::Variant(id) |\n+                        Def::VariantCtor(id, ..) => variants.push(id),\n+                        _ => ()\n+                    }\n+                }\n+                _ => ()\n+            }\n+            true\n+        });\n+        variants.sort();\n+        variants.dedup();\n+        variants\n+    }\n \n-/// Return variants that are necessary to exist for the pattern to match.\n-pub fn necessary_variants(dm: &DefMap, pat: &hir::Pat) -> Vec<DefId> {\n-    let mut variants = vec![];\n-    pat.walk(|p| {\n-        match p.node {\n-            PatKind::TupleStruct(..) |\n-            PatKind::Path(..) |\n-            PatKind::Struct(..) => {\n-                match dm.get(&p.id).map(|d| d.full_def()) {\n-                    Some(Def::Variant(id)) |\n-                    Some(Def::VariantCtor(id, ..)) => variants.push(id),\n-                    _ => ()\n+    /// Checks if the pattern contains any `ref` or `ref mut` bindings,\n+    /// and if yes whether its containing mutable ones or just immutables ones.\n+    pub fn contains_ref_binding(&self) -> Option<hir::Mutability> {\n+        let mut result = None;\n+        self.each_binding(|mode, _, _, _| {\n+            if let hir::BindingMode::BindByRef(m) = mode {\n+                // Pick Mutable as maximum\n+                match result {\n+                    None | Some(hir::MutImmutable) => result = Some(m),\n+                    _ => (),\n                 }\n             }\n-            _ => ()\n-        }\n-        true\n-    });\n-    variants.sort();\n-    variants.dedup();\n-    variants\n+        });\n+        result\n+    }\n+}\n+\n+impl hir::Arm {\n+    /// Checks if the patterns for this arm contain any `ref` or `ref mut`\n+    /// bindings, and if yes whether its containing mutable ones or just immutables ones.\n+    pub fn contains_ref_binding(&self) -> Option<hir::Mutability> {\n+        self.pats.iter()\n+                 .filter_map(|pat| pat.contains_ref_binding())\n+                 .max_by_key(|m| match *m {\n+                    hir::MutMutable => 1,\n+                    hir::MutImmutable => 0,\n+                 })\n+    }\n }"}, {"sha": "74920b1328076d392dd9212fe903cd8ea0e80993", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 115, "deletions": 94, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -272,7 +272,11 @@ pub fn fn_block_to_string(p: &hir::FnDecl) -> String {\n }\n \n pub fn path_to_string(p: &hir::Path) -> String {\n-    to_string(|s| s.print_path(p, false, 0))\n+    to_string(|s| s.print_path(p, false))\n+}\n+\n+pub fn qpath_to_string(p: &hir::QPath) -> String {\n+    to_string(|s| s.print_qpath(p, false))\n }\n \n pub fn name_to_string(name: ast::Name) -> String {\n@@ -528,11 +532,8 @@ impl<'a> State<'a> {\n                 };\n                 self.print_ty_fn(f.abi, f.unsafety, &f.decl, None, &generics)?;\n             }\n-            hir::TyPath(None, ref path) => {\n-                self.print_path(path, false, 0)?;\n-            }\n-            hir::TyPath(Some(ref qself), ref path) => {\n-                self.print_qpath(path, qself, false)?\n+            hir::TyPath(ref qpath) => {\n+                self.print_qpath(qpath, false)?\n             }\n             hir::TyObjectSum(ref ty, ref bounds) => {\n                 self.print_type(&ty)?;\n@@ -643,6 +644,15 @@ impl<'a> State<'a> {\n         }\n     }\n \n+    pub fn print_expr_id(&mut self, expr_id: &hir::ExprId) -> io::Result<()> {\n+        if let Some(krate) = self.krate {\n+            let expr = &krate.exprs[expr_id];\n+            self.print_expr(expr)\n+        } else {\n+            Ok(())\n+        }\n+    }\n+\n     /// Pretty-print an item\n     pub fn print_item(&mut self, item: &hir::Item) -> io::Result<()> {\n         self.hardbreak_if_not_bol()?;\n@@ -668,10 +678,22 @@ impl<'a> State<'a> {\n                 self.end()?; // end inner head-block\n                 self.end()?; // end outer head-block\n             }\n-            hir::ItemUse(ref vp) => {\n+            hir::ItemUse(ref path, kind) => {\n                 self.head(&visibility_qualified(&item.vis, \"use\"))?;\n-                self.print_view_path(&vp)?;\n-                word(&mut self.s, \";\")?;\n+                self.print_path(path, false)?;\n+\n+                match kind {\n+                    hir::UseKind::Single => {\n+                        if path.segments.last().unwrap().name != item.name {\n+                            space(&mut self.s)?;\n+                            self.word_space(\"as\")?;\n+                            self.print_name(item.name)?;\n+                        }\n+                        word(&mut self.s, \";\")?;\n+                    }\n+                    hir::UseKind::Glob => word(&mut self.s, \"::*;\")?,\n+                    hir::UseKind::ListStem => word(&mut self.s, \"::{};\")?\n+                }\n                 self.end()?; // end inner head-block\n                 self.end()?; // end outer head-block\n             }\n@@ -716,7 +738,7 @@ impl<'a> State<'a> {\n                 word(&mut self.s, \" \")?;\n                 self.end()?; // need to close a box\n                 self.end()?; // need to close a box\n-                self.print_expr(&body)?;\n+                self.print_expr_id(body)?;\n             }\n             hir::ItemMod(ref _mod) => {\n                 self.head(&visibility_qualified(&item.vis, \"mod\"))?;\n@@ -844,8 +866,8 @@ impl<'a> State<'a> {\n         self.ann.post(self, NodeItem(item))\n     }\n \n-    fn print_trait_ref(&mut self, t: &hir::TraitRef) -> io::Result<()> {\n-        self.print_path(&t.path, false, 0)\n+    pub fn print_trait_ref(&mut self, t: &hir::TraitRef) -> io::Result<()> {\n+        self.print_path(&t.path, false)\n     }\n \n     fn print_formal_lifetime_list(&mut self, lifetimes: &[hir::LifetimeDef]) -> io::Result<()> {\n@@ -1007,7 +1029,7 @@ impl<'a> State<'a> {\n                     self.nbsp()?;\n                     self.end()?; // need to close a box\n                     self.end()?; // need to close a box\n-                    self.print_expr(body)?;\n+                    self.print_expr_id(body)?;\n                 } else {\n                     word(&mut self.s, \";\")?;\n                 }\n@@ -1052,7 +1074,7 @@ impl<'a> State<'a> {\n                 self.nbsp()?;\n                 self.end()?; // need to close a box\n                 self.end()?; // need to close a box\n-                self.print_expr(body)?;\n+                self.print_expr_id(body)?;\n             }\n             hir::ImplItemKind::Type(ref ty) => {\n                 self.print_associated_type(ii.name, None, Some(ty))?;\n@@ -1115,8 +1137,6 @@ impl<'a> State<'a> {\n             hir::UnsafeBlock(..) => self.word_space(\"unsafe\")?,\n             hir::PushUnsafeBlock(..) => self.word_space(\"push_unsafe\")?,\n             hir::PopUnsafeBlock(..) => self.word_space(\"pop_unsafe\")?,\n-            hir::PushUnstableBlock => self.word_space(\"push_unstable\")?,\n-            hir::PopUnstableBlock => self.word_space(\"pop_unstable\")?,\n             hir::DefaultBlock => (),\n         }\n         self.maybe_print_comment(blk.span.lo)?;\n@@ -1237,11 +1257,11 @@ impl<'a> State<'a> {\n     }\n \n     fn print_expr_struct(&mut self,\n-                         path: &hir::Path,\n+                         qpath: &hir::QPath,\n                          fields: &[hir::Field],\n                          wth: &Option<P<hir::Expr>>)\n                          -> io::Result<()> {\n-        self.print_path(path, true, 0)?;\n+        self.print_qpath(qpath, true)?;\n         word(&mut self.s, \"{\")?;\n         self.commasep_cmnt(Consistent,\n                            &fields[..],\n@@ -1345,8 +1365,8 @@ impl<'a> State<'a> {\n             hir::ExprRepeat(ref element, ref count) => {\n                 self.print_expr_repeat(&element, &count)?;\n             }\n-            hir::ExprStruct(ref path, ref fields, ref wth) => {\n-                self.print_expr_struct(path, &fields[..], wth)?;\n+            hir::ExprStruct(ref qpath, ref fields, ref wth) => {\n+                self.print_expr_struct(qpath, &fields[..], wth)?;\n             }\n             hir::ExprTup(ref exprs) => {\n                 self.print_expr_tup(exprs)?;\n@@ -1421,7 +1441,7 @@ impl<'a> State<'a> {\n                 space(&mut self.s)?;\n \n                 // this is a bare expression\n-                self.print_expr(body)?;\n+                self.print_expr_id(body)?;\n                 self.end()?; // need to close a box\n \n                 // a box will be closed by print_expr, but we didn't want an overall\n@@ -1465,29 +1485,26 @@ impl<'a> State<'a> {\n                 self.print_expr(&index)?;\n                 word(&mut self.s, \"]\")?;\n             }\n-            hir::ExprPath(None, ref path) => {\n-                self.print_path(path, true, 0)?\n-            }\n-            hir::ExprPath(Some(ref qself), ref path) => {\n-                self.print_qpath(path, qself, true)?\n+            hir::ExprPath(ref qpath) => {\n+                self.print_qpath(qpath, true)?\n             }\n-            hir::ExprBreak(opt_name, ref opt_expr) => {\n+            hir::ExprBreak(opt_label, ref opt_expr) => {\n                 word(&mut self.s, \"break\")?;\n                 space(&mut self.s)?;\n-                if let Some(name) = opt_name {\n-                    self.print_name(name.node)?;\n+                if let Some(label) = opt_label {\n+                    self.print_name(label.name)?;\n                     space(&mut self.s)?;\n                 }\n                 if let Some(ref expr) = *opt_expr {\n                     self.print_expr(expr)?;\n                     space(&mut self.s)?;\n                 }\n             }\n-            hir::ExprAgain(opt_name) => {\n+            hir::ExprAgain(opt_label) => {\n                 word(&mut self.s, \"continue\")?;\n                 space(&mut self.s)?;\n-                if let Some(name) = opt_name {\n-                    self.print_name(name.node)?;\n+                if let Some(label) = opt_label {\n+                    self.print_name(label.name)?;\n                     space(&mut self.s)?\n                 }\n             }\n@@ -1622,13 +1639,12 @@ impl<'a> State<'a> {\n \n     fn print_path(&mut self,\n                   path: &hir::Path,\n-                  colons_before_params: bool,\n-                  depth: usize)\n+                  colons_before_params: bool)\n                   -> io::Result<()> {\n         self.maybe_print_comment(path.span.lo)?;\n \n         let mut first = !path.global;\n-        for segment in &path.segments[..path.segments.len() - depth] {\n+        for segment in &path.segments {\n             if first {\n                 first = false\n             } else {\n@@ -1644,31 +1660,61 @@ impl<'a> State<'a> {\n     }\n \n     fn print_qpath(&mut self,\n-                   path: &hir::Path,\n-                   qself: &hir::QSelf,\n+                   qpath: &hir::QPath,\n                    colons_before_params: bool)\n                    -> io::Result<()> {\n-        word(&mut self.s, \"<\")?;\n-        self.print_type(&qself.ty)?;\n-        if qself.position > 0 {\n-            space(&mut self.s)?;\n-            self.word_space(\"as\")?;\n-            let depth = path.segments.len() - qself.position;\n-            self.print_path(&path, false, depth)?;\n+        match *qpath {\n+            hir::QPath::Resolved(None, ref path) => {\n+                self.print_path(path, colons_before_params)\n+            }\n+            hir::QPath::Resolved(Some(ref qself), ref path) => {\n+                word(&mut self.s, \"<\")?;\n+                self.print_type(qself)?;\n+                space(&mut self.s)?;\n+                self.word_space(\"as\")?;\n+\n+                let mut first = !path.global;\n+                for segment in &path.segments[..path.segments.len() - 1] {\n+                    if first {\n+                        first = false\n+                    } else {\n+                        word(&mut self.s, \"::\")?\n+                    }\n+                    self.print_name(segment.name)?;\n+                    self.print_path_parameters(&segment.parameters, colons_before_params)?;\n+                }\n+\n+                word(&mut self.s, \">\")?;\n+                word(&mut self.s, \"::\")?;\n+                let item_segment = path.segments.last().unwrap();\n+                self.print_name(item_segment.name)?;\n+                self.print_path_parameters(&item_segment.parameters, colons_before_params)\n+            }\n+            hir::QPath::TypeRelative(ref qself, ref item_segment) => {\n+                word(&mut self.s, \"<\")?;\n+                self.print_type(qself)?;\n+                word(&mut self.s, \">\")?;\n+                word(&mut self.s, \"::\")?;\n+                self.print_name(item_segment.name)?;\n+                self.print_path_parameters(&item_segment.parameters, colons_before_params)\n+            }\n         }\n-        word(&mut self.s, \">\")?;\n-        word(&mut self.s, \"::\")?;\n-        let item_segment = path.segments.last().unwrap();\n-        self.print_name(item_segment.name)?;\n-        self.print_path_parameters(&item_segment.parameters, colons_before_params)\n     }\n \n     fn print_path_parameters(&mut self,\n                              parameters: &hir::PathParameters,\n                              colons_before_params: bool)\n                              -> io::Result<()> {\n         if parameters.is_empty() {\n-            return Ok(());\n+            let infer_types = match *parameters {\n+                hir::AngleBracketedParameters(ref data) => data.infer_types,\n+                hir::ParenthesizedParameters(_) => false\n+            };\n+\n+            // FIXME(eddyb) See the comment below about infer_types.\n+            if !(infer_types && false) {\n+                return Ok(());\n+            }\n         }\n \n         if colons_before_params {\n@@ -1696,6 +1742,16 @@ impl<'a> State<'a> {\n                     comma = true;\n                 }\n \n+                // FIXME(eddyb) This would leak into error messages, e.g.:\n+                // \"non-exhaustive patterns: `Some::<..>(_)` not covered\".\n+                if data.infer_types && false {\n+                    if comma {\n+                        self.word_space(\",\")?\n+                    }\n+                    word(&mut self.s, \"..\")?;\n+                    comma = true;\n+                }\n+\n                 for binding in data.bindings.iter() {\n                     if comma {\n                         self.word_space(\",\")?\n@@ -1733,7 +1789,7 @@ impl<'a> State<'a> {\n         // is that it doesn't matter\n         match pat.node {\n             PatKind::Wild => word(&mut self.s, \"_\")?,\n-            PatKind::Binding(binding_mode, ref path1, ref sub) => {\n+            PatKind::Binding(binding_mode, _, ref path1, ref sub) => {\n                 match binding_mode {\n                     hir::BindByRef(mutbl) => {\n                         self.word_nbsp(\"ref\")?;\n@@ -1750,8 +1806,8 @@ impl<'a> State<'a> {\n                     self.print_pat(&p)?;\n                 }\n             }\n-            PatKind::TupleStruct(ref path, ref elts, ddpos) => {\n-                self.print_path(path, true, 0)?;\n+            PatKind::TupleStruct(ref qpath, ref elts, ddpos) => {\n+                self.print_qpath(qpath, true)?;\n                 self.popen()?;\n                 if let Some(ddpos) = ddpos {\n                     self.commasep(Inconsistent, &elts[..ddpos], |s, p| s.print_pat(&p))?;\n@@ -1768,14 +1824,11 @@ impl<'a> State<'a> {\n                 }\n                 self.pclose()?;\n             }\n-            PatKind::Path(None, ref path) => {\n-                self.print_path(path, true, 0)?;\n-            }\n-            PatKind::Path(Some(ref qself), ref path) => {\n-                self.print_qpath(path, qself, false)?;\n+            PatKind::Path(ref qpath) => {\n+                self.print_qpath(qpath, true)?;\n             }\n-            PatKind::Struct(ref path, ref fields, etc) => {\n-                self.print_path(path, true, 0)?;\n+            PatKind::Struct(ref qpath, ref fields, etc) => {\n+                self.print_qpath(qpath, true)?;\n                 self.nbsp()?;\n                 self.word_space(\"{\")?;\n                 self.commasep_cmnt(Consistent,\n@@ -2108,7 +2161,7 @@ impl<'a> State<'a> {\n                     }\n                 }\n                 &hir::WherePredicate::EqPredicate(hir::WhereEqPredicate{ref path, ref ty, ..}) => {\n-                    self.print_path(path, false, 0)?;\n+                    self.print_path(path, false)?;\n                     space(&mut self.s)?;\n                     self.word_space(\"=\")?;\n                     self.print_type(&ty)?;\n@@ -2119,38 +2172,6 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n \n-    pub fn print_view_path(&mut self, vp: &hir::ViewPath) -> io::Result<()> {\n-        match vp.node {\n-            hir::ViewPathSimple(name, ref path) => {\n-                self.print_path(path, false, 0)?;\n-\n-                if path.segments.last().unwrap().name != name {\n-                    space(&mut self.s)?;\n-                    self.word_space(\"as\")?;\n-                    self.print_name(name)?;\n-                }\n-\n-                Ok(())\n-            }\n-\n-            hir::ViewPathGlob(ref path) => {\n-                self.print_path(path, false, 0)?;\n-                word(&mut self.s, \"::*\")\n-            }\n-\n-            hir::ViewPathList(ref path, ref segments) => {\n-                if path.segments.is_empty() {\n-                    word(&mut self.s, \"{\")?;\n-                } else {\n-                    self.print_path(path, false, 0)?;\n-                    word(&mut self.s, \"::{\")?;\n-                }\n-                self.commasep(Inconsistent, &segments[..], |s, w| s.print_name(w.node.name))?;\n-                word(&mut self.s, \"}\")\n-            }\n-        }\n-    }\n-\n     pub fn print_mutability(&mut self, mutbl: hir::Mutability) -> io::Result<()> {\n         match mutbl {\n             hir::MutMutable => self.word_nbsp(\"mut\"),\n@@ -2171,7 +2192,7 @@ impl<'a> State<'a> {\n                 if let Some(eself) = input.to_self() {\n                     self.print_explicit_self(&eself)?;\n                 } else {\n-                    let invalid = if let PatKind::Binding(_, name, _) = input.pat.node {\n+                    let invalid = if let PatKind::Binding(_, _, name, _) = input.pat.node {\n                         name.node == keywords::Invalid.name()\n                     } else {\n                         false"}, {"sha": "90d752ae6ee297db8100658c6e236c59739d0b4c", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -1440,8 +1440,8 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                     }\n                     ty_queue.push(&mut_ty.ty);\n                 }\n-                hir::TyPath(ref maybe_qself, ref path) => {\n-                    match self.tcx.expect_def(cur_ty.id) {\n+                hir::TyPath(hir::QPath::Resolved(ref maybe_qself, ref path)) => {\n+                    match path.def {\n                         Def::Enum(did) | Def::TyAlias(did) |\n                         Def::Struct(did) | Def::Union(did) => {\n                             let generics = self.tcx.item_generics(did);\n@@ -1476,15 +1476,12 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                             };\n                             let new_path = self.rebuild_path(rebuild_info, lifetime);\n                             let qself = maybe_qself.as_ref().map(|qself| {\n-                                hir::QSelf {\n-                                    ty: self.rebuild_arg_ty_or_output(&qself.ty, lifetime,\n-                                                                      anon_nums, region_names),\n-                                    position: qself.position\n-                                }\n+                                self.rebuild_arg_ty_or_output(qself, lifetime,\n+                                                              anon_nums, region_names)\n                             });\n                             let to = hir::Ty {\n                                 id: cur_ty.id,\n-                                node: hir::TyPath(qself, new_path),\n+                                node: hir::TyPath(hir::QPath::Resolved(qself, P(new_path))),\n                                 span: cur_ty.span\n                             };\n                             new_ty = self.rebuild_ty(new_ty, P(to));\n@@ -1609,6 +1606,7 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n                 hir::AngleBracketedParameters(hir::AngleBracketedParameterData {\n                     lifetimes: new_lts.into(),\n                     types: new_types,\n+                    infer_types: data.infer_types,\n                     bindings: new_bindings,\n                })\n             }\n@@ -1623,6 +1621,7 @@ impl<'a, 'gcx, 'tcx> Rebuilder<'a, 'gcx, 'tcx> {\n         hir::Path {\n             span: path.span,\n             global: path.global,\n+            def: path.def,\n             segments: new_segs.into()\n         }\n     }"}, {"sha": "19183892e4b0c16cb68629d14b3ad7212341e9d6", "filename": "src/librustc/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ffreshen.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -165,7 +165,7 @@ impl<'a, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for TypeFreshener<'a, 'gcx, 'tcx> {\n             ty::TyRef(..) |\n             ty::TyFnDef(..) |\n             ty::TyFnPtr(_) |\n-            ty::TyTrait(..) |\n+            ty::TyDynamic(..) |\n             ty::TyClosure(..) |\n             ty::TyNever |\n             ty::TyTuple(..) |"}, {"sha": "8ccadc6b2af044819d5c7a2f4586d4ef6cf5b8f8", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -13,6 +13,7 @@ use super::InferCtxt;\n use super::lattice::{self, LatticeDir};\n use super::Subtype;\n \n+use traits::ObligationCause;\n use ty::{self, Ty, TyCtxt};\n use ty::relate::{Relate, RelateResult, TypeRelation};\n \n@@ -83,6 +84,10 @@ impl<'combine, 'infcx, 'gcx, 'tcx> LatticeDir<'infcx, 'gcx, 'tcx>\n         self.fields.infcx\n     }\n \n+    fn cause(&self) -> &ObligationCause<'tcx> {\n+        &self.fields.trace.cause\n+    }\n+\n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n         let mut sub = self.fields.sub(self.a_is_expected);\n         sub.relate(&v, &a)?;"}, {"sha": "f7b26a918b3a200d182c5651aab55e7ea562cac1", "filename": "src/librustc/infer/lattice.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flattice.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -30,14 +30,18 @@\n //! a lattice.\n \n use super::InferCtxt;\n+use super::type_variable::TypeVariableOrigin;\n \n+use traits::ObligationCause;\n use ty::TyVar;\n use ty::{self, Ty};\n use ty::relate::{RelateResult, TypeRelation};\n \n pub trait LatticeDir<'f, 'gcx: 'f+'tcx, 'tcx: 'f> : TypeRelation<'f, 'gcx, 'tcx> {\n     fn infcx(&self) -> &'f InferCtxt<'f, 'gcx, 'tcx>;\n \n+    fn cause(&self) -> &ObligationCause<'tcx>;\n+\n     // Relates the type `v` to `a` and `b` such that `v` represents\n     // the LUB/GLB of `a` and `b` as appropriate.\n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()>;\n@@ -64,14 +68,15 @@ pub fn super_lattice_tys<'a, 'gcx, 'tcx, L>(this: &mut L,\n     match (&a.sty, &b.sty) {\n         (&ty::TyInfer(TyVar(..)), &ty::TyInfer(TyVar(..)))\n             if infcx.type_var_diverges(a) && infcx.type_var_diverges(b) => {\n-            let v = infcx.next_diverging_ty_var();\n+            let v = infcx.next_diverging_ty_var(\n+                TypeVariableOrigin::LatticeVariable(this.cause().span));\n             this.relate_bound(v, a, b)?;\n             Ok(v)\n         }\n \n         (&ty::TyInfer(TyVar(..)), _) |\n         (_, &ty::TyInfer(TyVar(..))) => {\n-            let v = infcx.next_ty_var();\n+            let v = infcx.next_ty_var(TypeVariableOrigin::LatticeVariable(this.cause().span));\n             this.relate_bound(v, a, b)?;\n             Ok(v)\n         }"}, {"sha": "89571dea10c3425b56c3cdefadcc0d59f0994a96", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -13,6 +13,7 @@ use super::InferCtxt;\n use super::lattice::{self, LatticeDir};\n use super::Subtype;\n \n+use traits::ObligationCause;\n use ty::{self, Ty, TyCtxt};\n use ty::relate::{Relate, RelateResult, TypeRelation};\n \n@@ -83,6 +84,10 @@ impl<'combine, 'infcx, 'gcx, 'tcx> LatticeDir<'infcx, 'gcx, 'tcx>\n         self.fields.infcx\n     }\n \n+    fn cause(&self) -> &ObligationCause<'tcx> {\n+        &self.fields.trace.cause\n+    }\n+\n     fn relate_bound(&mut self, v: Ty<'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, ()> {\n         let mut sub = self.fields.sub(self.a_is_expected);\n         sub.relate(&a, &v)?;"}, {"sha": "9b58334e65805a6822fa4446bf9271ff81dd037b", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -24,6 +24,7 @@ use middle::free_region::FreeRegionMap;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::McResult;\n use middle::region::CodeExtent;\n+use middle::lang_items;\n use mir::tcx::LvalueTy;\n use ty::subst::{Kind, Subst, Substs};\n use ty::adjustment;\n@@ -44,6 +45,7 @@ use util::nodemap::{FxHashMap, FxHashSet, NodeMap};\n use self::combine::CombineFields;\n use self::higher_ranked::HrMatchResult;\n use self::region_inference::{RegionVarBindings, RegionSnapshot};\n+use self::type_variable::TypeVariableOrigin;\n use self::unify_key::ToType;\n \n mod bivariate;\n@@ -113,7 +115,7 @@ pub struct InferCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     // We instantiate UnificationTable with bounds<Ty> because the\n     // types that might instantiate a general type variable have an\n     // order, represented by its upper and lower bounds.\n-    type_variables: RefCell<type_variable::TypeVariableTable<'tcx>>,\n+    pub type_variables: RefCell<type_variable::TypeVariableTable<'tcx>>,\n \n     // Map from integral variable to the kind of integer it represents\n     int_unification_table: RefCell<UnificationTable<ty::IntVid>>,\n@@ -1053,18 +1055,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn next_ty_var_id(&self, diverging: bool) -> TyVid {\n+    pub fn next_ty_var_id(&self, diverging: bool, origin: TypeVariableOrigin) -> TyVid {\n         self.type_variables\n             .borrow_mut()\n-            .new_var(diverging, None)\n+            .new_var(diverging, origin, None)\n     }\n \n-    pub fn next_ty_var(&self) -> Ty<'tcx> {\n-        self.tcx.mk_var(self.next_ty_var_id(false))\n+    pub fn next_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n+        self.tcx.mk_var(self.next_ty_var_id(false, origin))\n     }\n \n-    pub fn next_diverging_ty_var(&self) -> Ty<'tcx> {\n-        self.tcx.mk_var(self.next_ty_var_id(true))\n+    pub fn next_diverging_ty_var(&self, origin: TypeVariableOrigin) -> Ty<'tcx> {\n+        self.tcx.mk_var(self.next_ty_var_id(true, origin))\n     }\n \n     pub fn next_int_var_id(&self) -> IntVid {\n@@ -1117,7 +1119,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         let ty_var_id = self.type_variables\n                             .borrow_mut()\n-                            .new_var(false, default);\n+                            .new_var(false,\n+                                     TypeVariableOrigin::TypeParameterDefinition(span, def.name),\n+                                     default);\n \n         self.tcx.mk_var(ty_var_id)\n     }\n@@ -1492,11 +1496,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n         }\n \n+        let copy_def_id = self.tcx.require_lang_item(lang_items::CopyTraitLangItem);\n+\n         // this can get called from typeck (by euv), and moves_by_default\n         // rightly refuses to work with inference variables, but\n         // moves_by_default has a cache, which we want to use in other\n         // cases.\n-        !traits::type_known_to_meet_builtin_bound(self, ty, ty::BoundCopy, span)\n+        !traits::type_known_to_meet_bound(self, ty, copy_def_id, span)\n     }\n \n     pub fn node_method_ty(&self, method_call: ty::MethodCall)"}, {"sha": "9c8419d9546d24b4f03745e4738a9f179f54f3ff", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -13,6 +13,7 @@ use self::TypeVariableValue::*;\n use self::UndoEntry::*;\n use hir::def_id::{DefId};\n use syntax::util::small_vector::SmallVector;\n+use syntax::ast;\n use syntax_pos::Span;\n use ty::{self, Ty};\n \n@@ -28,8 +29,24 @@ pub struct TypeVariableTable<'tcx> {\n     eq_relations: ut::UnificationTable<ty::TyVid>,\n }\n \n+/// Reasons to create a type inference variable\n+pub enum TypeVariableOrigin {\n+    MiscVariable(Span),\n+    NormalizeProjectionType(Span),\n+    TypeInference(Span),\n+    TypeParameterDefinition(Span, ast::Name),\n+    TransformedUpvar(Span),\n+    SubstitutionPlaceholder(Span),\n+    AutoDeref(Span),\n+    AdjustmentType(Span),\n+    DivergingStmt(Span),\n+    DivergingBlockExpr(Span),\n+    LatticeVariable(Span),\n+}\n+\n struct TypeVariableData<'tcx> {\n     value: TypeVariableValue<'tcx>,\n+    origin: TypeVariableOrigin,\n     diverging: bool\n }\n \n@@ -107,6 +124,10 @@ impl<'tcx> TypeVariableTable<'tcx> {\n         self.values.get(vid.index as usize).diverging\n     }\n \n+    pub fn var_origin(&self, vid: ty::TyVid) -> &TypeVariableOrigin {\n+        &self.values.get(vid.index as usize).origin\n+    }\n+\n     /// Records that `a <: b`, `a :> b`, or `a == b`, depending on `dir`.\n     ///\n     /// Precondition: neither `a` nor `b` are known.\n@@ -173,10 +194,12 @@ impl<'tcx> TypeVariableTable<'tcx> {\n \n     pub fn new_var(&mut self,\n                    diverging: bool,\n-                   default: Option<Default<'tcx>>) -> ty::TyVid {\n+                   origin: TypeVariableOrigin,\n+                   default: Option<Default<'tcx>>,) -> ty::TyVid {\n         self.eq_relations.new_key(());\n         let index = self.values.push(TypeVariableData {\n             value: Bounded { relations: vec![], default: default },\n+            origin: origin,\n             diverging: diverging\n         });\n         let v = ty::TyVid { index: index as u32 };"}, {"sha": "7c26b710a53cb3710b5ff9dce2fe1b4c406d5314", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -31,8 +31,6 @@\n #![feature(conservative_impl_trait)]\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n-#![cfg_attr(stage0, feature(dotdot_in_tuple_patterns))]\n-#![feature(enumset)]\n #![cfg_attr(stage0, feature(item_like_imports))]\n #![feature(libc)]\n #![feature(nonzero)]\n@@ -42,7 +40,6 @@\n #![feature(slice_patterns)]\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n-#![cfg_attr(stage0, feature(question_mark))]\n #![cfg_attr(test, feature(test))]\n \n extern crate arena;"}, {"sha": "02c1ece163497665e1a57207f0a2337a78284300", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -211,6 +211,12 @@ declare_lint! {\n      not named `mod.rs`\"\n }\n \n+declare_lint! {\n+    pub DEPRECATED,\n+    Warn,\n+    \"detects use of deprecated items\"\n+}\n+\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler.\n #[derive(Copy, Clone)]\n@@ -250,9 +256,10 @@ impl LintPass for HardwiredLints {\n             SAFE_EXTERN_STATICS,\n             PATTERNS_IN_FNS_WITHOUT_BODY,\n             EXTRA_REQUIREMENT_IN_IMPL,\n-            LEGACY_DIRECTORY_OWNERSHIP\n+            LEGACY_DIRECTORY_OWNERSHIP,\n+            DEPRECATED\n         )\n     }\n }\n \n-impl LateLintPass for HardwiredLints {}\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for HardwiredLints {}"}, {"sha": "3ff2abac277b580fc14e66990ff1338a6fc45d53", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -496,13 +496,13 @@ pub fn raw_struct_lint<'a, S>(sess: &'a Session,\n     err\n }\n \n-pub trait LintContext: Sized {\n+pub trait LintContext<'tcx>: Sized {\n     fn sess(&self) -> &Session;\n     fn lints(&self) -> &LintStore;\n     fn mut_lints(&mut self) -> &mut LintStore;\n     fn level_stack(&mut self) -> &mut Vec<(LintId, LevelSource)>;\n-    fn enter_attrs(&mut self, attrs: &[ast::Attribute]);\n-    fn exit_attrs(&mut self, attrs: &[ast::Attribute]);\n+    fn enter_attrs(&mut self, attrs: &'tcx [ast::Attribute]);\n+    fn exit_attrs(&mut self, attrs: &'tcx [ast::Attribute]);\n \n     /// Get the level of `lint` at the current position of the lint\n     /// traversal.\n@@ -606,7 +606,7 @@ pub trait LintContext: Sized {\n     /// current lint context, call the provided function, then reset the\n     /// lints in effect to their previous state.\n     fn with_lint_attrs<F>(&mut self,\n-                          attrs: &[ast::Attribute],\n+                          attrs: &'tcx [ast::Attribute],\n                           f: F)\n         where F: FnOnce(&mut Self),\n     {\n@@ -719,17 +719,17 @@ impl<'a, 'tcx> LateContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_ids<F>(&mut self, f: F)\n-        where F: FnOnce(&mut IdVisitor)\n+    fn visit_ids<'b, F: 'b>(&'b mut self, f: F)\n+        where F: FnOnce(&mut IdVisitor<'b, 'a, 'tcx>)\n     {\n-        let mut v = IdVisitor {\n+        let mut v = IdVisitor::<'b, 'a, 'tcx> {\n             cx: self\n         };\n         f(&mut v);\n     }\n }\n \n-impl<'a, 'tcx> LintContext for LateContext<'a, 'tcx> {\n+impl<'a, 'tcx> LintContext<'tcx> for LateContext<'a, 'tcx> {\n     /// Get the overall compiler `Session` object.\n     fn sess(&self) -> &Session {\n         &self.tcx.sess\n@@ -747,18 +747,18 @@ impl<'a, 'tcx> LintContext for LateContext<'a, 'tcx> {\n         &mut self.level_stack\n     }\n \n-    fn enter_attrs(&mut self, attrs: &[ast::Attribute]) {\n+    fn enter_attrs(&mut self, attrs: &'tcx [ast::Attribute]) {\n         debug!(\"late context: enter_attrs({:?})\", attrs);\n         run_lints!(self, enter_lint_attrs, late_passes, attrs);\n     }\n \n-    fn exit_attrs(&mut self, attrs: &[ast::Attribute]) {\n+    fn exit_attrs(&mut self, attrs: &'tcx [ast::Attribute]) {\n         debug!(\"late context: exit_attrs({:?})\", attrs);\n         run_lints!(self, exit_lint_attrs, late_passes, attrs);\n     }\n }\n \n-impl<'a> LintContext for EarlyContext<'a> {\n+impl<'a> LintContext<'a> for EarlyContext<'a> {\n     /// Get the overall compiler `Session` object.\n     fn sess(&self) -> &Session {\n         &self.sess\n@@ -776,12 +776,12 @@ impl<'a> LintContext for EarlyContext<'a> {\n         &mut self.level_stack\n     }\n \n-    fn enter_attrs(&mut self, attrs: &[ast::Attribute]) {\n+    fn enter_attrs(&mut self, attrs: &'a [ast::Attribute]) {\n         debug!(\"early context: enter_attrs({:?})\", attrs);\n         run_lints!(self, enter_lint_attrs, early_passes, attrs);\n     }\n \n-    fn exit_attrs(&mut self, attrs: &[ast::Attribute]) {\n+    fn exit_attrs(&mut self, attrs: &'a [ast::Attribute]) {\n         debug!(\"early context: exit_attrs({:?})\", attrs);\n         run_lints!(self, exit_lint_attrs, early_passes, attrs);\n     }\n@@ -791,8 +791,8 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     /// Because lints are scoped lexically, we want to walk nested\n     /// items in the context of the outer item, so enable\n     /// deep-walking.\n-    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n-        Some(&self.tcx.map)\n+    fn nested_visit_map<'this>(&'this mut self) -> hir_visit::NestedVisitorMap<'this, 'tcx> {\n+        hir_visit::NestedVisitorMap::All(&self.tcx.map)\n     }\n \n     fn visit_item(&mut self, it: &'tcx hir::Item) {\n@@ -835,9 +835,10 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: hir_visit::FnKind<'tcx>, decl: &'tcx hir::FnDecl,\n-                body: &'tcx hir::Expr, span: Span, id: ast::NodeId) {\n+                body_id: hir::ExprId, span: Span, id: ast::NodeId) {\n+        let body = self.tcx.map.expr(body_id);\n         run_lints!(self, check_fn, late_passes, fk, decl, body, span, id);\n-        hir_visit::walk_fn(self, fk, decl, body, span, id);\n+        hir_visit::walk_fn(self, fk, decl, body_id, span, id);\n         run_lints!(self, check_fn_post, late_passes, fk, decl, body, span, id);\n     }\n \n@@ -948,85 +949,80 @@ impl<'a, 'tcx> hir_visit::Visitor<'tcx> for LateContext<'a, 'tcx> {\n         hir_visit::walk_path(self, p);\n     }\n \n-    fn visit_path_list_item(&mut self, prefix: &'tcx hir::Path, item: &'tcx hir::PathListItem) {\n-        run_lints!(self, check_path_list_item, late_passes, item);\n-        hir_visit::walk_path_list_item(self, prefix, item);\n-    }\n-\n-    fn visit_attribute(&mut self, attr: &ast::Attribute) {\n+    fn visit_attribute(&mut self, attr: &'tcx ast::Attribute) {\n         check_lint_name_attribute(self, attr);\n         run_lints!(self, check_attribute, late_passes, attr);\n     }\n }\n \n-impl<'a> ast_visit::Visitor for EarlyContext<'a> {\n-    fn visit_item(&mut self, it: &ast::Item) {\n+impl<'a> ast_visit::Visitor<'a> for EarlyContext<'a> {\n+    fn visit_item(&mut self, it: &'a ast::Item) {\n         self.with_lint_attrs(&it.attrs, |cx| {\n             run_lints!(cx, check_item, early_passes, it);\n             ast_visit::walk_item(cx, it);\n             run_lints!(cx, check_item_post, early_passes, it);\n         })\n     }\n \n-    fn visit_foreign_item(&mut self, it: &ast::ForeignItem) {\n+    fn visit_foreign_item(&mut self, it: &'a ast::ForeignItem) {\n         self.with_lint_attrs(&it.attrs, |cx| {\n             run_lints!(cx, check_foreign_item, early_passes, it);\n             ast_visit::walk_foreign_item(cx, it);\n             run_lints!(cx, check_foreign_item_post, early_passes, it);\n         })\n     }\n \n-    fn visit_pat(&mut self, p: &ast::Pat) {\n+    fn visit_pat(&mut self, p: &'a ast::Pat) {\n         run_lints!(self, check_pat, early_passes, p);\n         ast_visit::walk_pat(self, p);\n     }\n \n-    fn visit_expr(&mut self, e: &ast::Expr) {\n+    fn visit_expr(&mut self, e: &'a ast::Expr) {\n         self.with_lint_attrs(&e.attrs, |cx| {\n             run_lints!(cx, check_expr, early_passes, e);\n             ast_visit::walk_expr(cx, e);\n         })\n     }\n \n-    fn visit_stmt(&mut self, s: &ast::Stmt) {\n+    fn visit_stmt(&mut self, s: &'a ast::Stmt) {\n         run_lints!(self, check_stmt, early_passes, s);\n         ast_visit::walk_stmt(self, s);\n     }\n \n-    fn visit_fn(&mut self, fk: ast_visit::FnKind, decl: &ast::FnDecl,\n+    fn visit_fn(&mut self, fk: ast_visit::FnKind<'a>, decl: &'a ast::FnDecl,\n                 span: Span, id: ast::NodeId) {\n         run_lints!(self, check_fn, early_passes, fk, decl, span, id);\n         ast_visit::walk_fn(self, fk, decl, span);\n         run_lints!(self, check_fn_post, early_passes, fk, decl, span, id);\n     }\n \n     fn visit_variant_data(&mut self,\n-                        s: &ast::VariantData,\n+                        s: &'a ast::VariantData,\n                         ident: ast::Ident,\n-                        g: &ast::Generics,\n+                        g: &'a ast::Generics,\n                         item_id: ast::NodeId,\n                         _: Span) {\n         run_lints!(self, check_struct_def, early_passes, s, ident, g, item_id);\n         ast_visit::walk_struct_def(self, s);\n         run_lints!(self, check_struct_def_post, early_passes, s, ident, g, item_id);\n     }\n \n-    fn visit_struct_field(&mut self, s: &ast::StructField) {\n+    fn visit_struct_field(&mut self, s: &'a ast::StructField) {\n         self.with_lint_attrs(&s.attrs, |cx| {\n             run_lints!(cx, check_struct_field, early_passes, s);\n             ast_visit::walk_struct_field(cx, s);\n         })\n     }\n \n-    fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics, item_id: ast::NodeId) {\n+    fn visit_variant(&mut self, v: &'a ast::Variant, g: &'a ast::Generics, item_id: ast::NodeId) {\n         self.with_lint_attrs(&v.node.attrs, |cx| {\n             run_lints!(cx, check_variant, early_passes, v, g);\n             ast_visit::walk_variant(cx, v, g, item_id);\n             run_lints!(cx, check_variant_post, early_passes, v, g);\n         })\n     }\n \n-    fn visit_ty(&mut self, t: &ast::Ty) {\n+    fn visit_ty(&mut self, t: &'a ast::Ty) {\n         run_lints!(self, check_ty, early_passes, t);\n         ast_visit::walk_ty(self, t);\n     }\n@@ -1035,74 +1031,74 @@ impl<'a> ast_visit::Visitor for EarlyContext<'a> {\n         run_lints!(self, check_ident, early_passes, sp, id);\n     }\n \n-    fn visit_mod(&mut self, m: &ast::Mod, s: Span, n: ast::NodeId) {\n+    fn visit_mod(&mut self, m: &'a ast::Mod, s: Span, n: ast::NodeId) {\n         run_lints!(self, check_mod, early_passes, m, s, n);\n         ast_visit::walk_mod(self, m);\n         run_lints!(self, check_mod_post, early_passes, m, s, n);\n     }\n \n-    fn visit_local(&mut self, l: &ast::Local) {\n+    fn visit_local(&mut self, l: &'a ast::Local) {\n         self.with_lint_attrs(&l.attrs, |cx| {\n             run_lints!(cx, check_local, early_passes, l);\n             ast_visit::walk_local(cx, l);\n         })\n     }\n \n-    fn visit_block(&mut self, b: &ast::Block) {\n+    fn visit_block(&mut self, b: &'a ast::Block) {\n         run_lints!(self, check_block, early_passes, b);\n         ast_visit::walk_block(self, b);\n         run_lints!(self, check_block_post, early_passes, b);\n     }\n \n-    fn visit_arm(&mut self, a: &ast::Arm) {\n+    fn visit_arm(&mut self, a: &'a ast::Arm) {\n         run_lints!(self, check_arm, early_passes, a);\n         ast_visit::walk_arm(self, a);\n     }\n \n-    fn visit_expr_post(&mut self, e: &ast::Expr) {\n+    fn visit_expr_post(&mut self, e: &'a ast::Expr) {\n         run_lints!(self, check_expr_post, early_passes, e);\n     }\n \n-    fn visit_generics(&mut self, g: &ast::Generics) {\n+    fn visit_generics(&mut self, g: &'a ast::Generics) {\n         run_lints!(self, check_generics, early_passes, g);\n         ast_visit::walk_generics(self, g);\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n+    fn visit_trait_item(&mut self, trait_item: &'a ast::TraitItem) {\n         self.with_lint_attrs(&trait_item.attrs, |cx| {\n             run_lints!(cx, check_trait_item, early_passes, trait_item);\n             ast_visit::walk_trait_item(cx, trait_item);\n             run_lints!(cx, check_trait_item_post, early_passes, trait_item);\n         });\n     }\n \n-    fn visit_impl_item(&mut self, impl_item: &ast::ImplItem) {\n+    fn visit_impl_item(&mut self, impl_item: &'a ast::ImplItem) {\n         self.with_lint_attrs(&impl_item.attrs, |cx| {\n             run_lints!(cx, check_impl_item, early_passes, impl_item);\n             ast_visit::walk_impl_item(cx, impl_item);\n             run_lints!(cx, check_impl_item_post, early_passes, impl_item);\n         });\n     }\n \n-    fn visit_lifetime(&mut self, lt: &ast::Lifetime) {\n+    fn visit_lifetime(&mut self, lt: &'a ast::Lifetime) {\n         run_lints!(self, check_lifetime, early_passes, lt);\n     }\n \n-    fn visit_lifetime_def(&mut self, lt: &ast::LifetimeDef) {\n+    fn visit_lifetime_def(&mut self, lt: &'a ast::LifetimeDef) {\n         run_lints!(self, check_lifetime_def, early_passes, lt);\n     }\n \n-    fn visit_path(&mut self, p: &ast::Path, id: ast::NodeId) {\n+    fn visit_path(&mut self, p: &'a ast::Path, id: ast::NodeId) {\n         run_lints!(self, check_path, early_passes, p, id);\n         ast_visit::walk_path(self, p);\n     }\n \n-    fn visit_path_list_item(&mut self, prefix: &ast::Path, item: &ast::PathListItem) {\n+    fn visit_path_list_item(&mut self, prefix: &'a ast::Path, item: &'a ast::PathListItem) {\n         run_lints!(self, check_path_list_item, early_passes, item);\n         ast_visit::walk_path_list_item(self, prefix, item);\n     }\n \n-    fn visit_attribute(&mut self, attr: &ast::Attribute) {\n+    fn visit_attribute(&mut self, attr: &'a ast::Attribute) {\n         run_lints!(self, check_attribute, early_passes, attr);\n     }\n }\n@@ -1112,7 +1108,11 @@ struct IdVisitor<'a, 'b: 'a, 'tcx: 'a+'b> {\n }\n \n // Output any lints that were previously added to the session.\n-impl<'a, 'b, 'tcx, 'v> hir_visit::Visitor<'v> for IdVisitor<'a, 'b, 'tcx> {\n+impl<'a, 'b, 'tcx> hir_visit::Visitor<'tcx> for IdVisitor<'a, 'b, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> hir_visit::NestedVisitorMap<'this, 'tcx> {\n+        hir_visit::NestedVisitorMap::OnlyBodies(&self.cx.tcx.map)\n+    }\n+\n     fn visit_id(&mut self, id: ast::NodeId) {\n         if let Some(lints) = self.cx.sess().lints.borrow_mut().remove(&id) {\n             debug!(\"LateContext::visit_id: id={:?} lints={:?}\", id, lints);\n@@ -1122,12 +1122,12 @@ impl<'a, 'b, 'tcx, 'v> hir_visit::Visitor<'v> for IdVisitor<'a, 'b, 'tcx> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _ti: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, _ti: &'tcx hir::TraitItem) {\n         // Do not recurse into trait or impl items automatically. These are\n         // processed separately by calling hir_visit::walk_trait_item()\n     }\n \n-    fn visit_impl_item(&mut self, _ii: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, _ii: &'tcx hir::ImplItem) {\n         // See visit_trait_item()\n     }\n }"}, {"sha": "ccf53f01cd5323112bfe2b3e9d21bde83ef65e58", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 74, "deletions": 43, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -129,54 +129,85 @@ pub trait LintPass {\n //\n // FIXME: eliminate the duplication with `Visitor`. But this also\n // contains a few lint-specific methods with no equivalent in `Visitor`.\n-pub trait LateLintPass: LintPass {\n+pub trait LateLintPass<'a, 'tcx>: LintPass {\n     fn check_name(&mut self, _: &LateContext, _: Span, _: ast::Name) { }\n-    fn check_crate(&mut self, _: &LateContext, _: &hir::Crate) { }\n-    fn check_crate_post(&mut self, _: &LateContext, _: &hir::Crate) { }\n-    fn check_mod(&mut self, _: &LateContext, _: &hir::Mod, _: Span, _: ast::NodeId) { }\n-    fn check_mod_post(&mut self, _: &LateContext, _: &hir::Mod, _: Span, _: ast::NodeId) { }\n-    fn check_foreign_item(&mut self, _: &LateContext, _: &hir::ForeignItem) { }\n-    fn check_foreign_item_post(&mut self, _: &LateContext, _: &hir::ForeignItem) { }\n-    fn check_item(&mut self, _: &LateContext, _: &hir::Item) { }\n-    fn check_item_post(&mut self, _: &LateContext, _: &hir::Item) { }\n-    fn check_local(&mut self, _: &LateContext, _: &hir::Local) { }\n-    fn check_block(&mut self, _: &LateContext, _: &hir::Block) { }\n-    fn check_block_post(&mut self, _: &LateContext, _: &hir::Block) { }\n-    fn check_stmt(&mut self, _: &LateContext, _: &hir::Stmt) { }\n-    fn check_arm(&mut self, _: &LateContext, _: &hir::Arm) { }\n-    fn check_pat(&mut self, _: &LateContext, _: &hir::Pat) { }\n-    fn check_decl(&mut self, _: &LateContext, _: &hir::Decl) { }\n-    fn check_expr(&mut self, _: &LateContext, _: &hir::Expr) { }\n-    fn check_expr_post(&mut self, _: &LateContext, _: &hir::Expr) { }\n-    fn check_ty(&mut self, _: &LateContext, _: &hir::Ty) { }\n-    fn check_generics(&mut self, _: &LateContext, _: &hir::Generics) { }\n-    fn check_fn(&mut self, _: &LateContext,\n-        _: FnKind, _: &hir::FnDecl, _: &hir::Expr, _: Span, _: ast::NodeId) { }\n-    fn check_fn_post(&mut self, _: &LateContext,\n-        _: FnKind, _: &hir::FnDecl, _: &hir::Expr, _: Span, _: ast::NodeId) { }\n-    fn check_trait_item(&mut self, _: &LateContext, _: &hir::TraitItem) { }\n-    fn check_trait_item_post(&mut self, _: &LateContext, _: &hir::TraitItem) { }\n-    fn check_impl_item(&mut self, _: &LateContext, _: &hir::ImplItem) { }\n-    fn check_impl_item_post(&mut self, _: &LateContext, _: &hir::ImplItem) { }\n-    fn check_struct_def(&mut self, _: &LateContext,\n-        _: &hir::VariantData, _: ast::Name, _: &hir::Generics, _: ast::NodeId) { }\n-    fn check_struct_def_post(&mut self, _: &LateContext,\n-        _: &hir::VariantData, _: ast::Name, _: &hir::Generics, _: ast::NodeId) { }\n-    fn check_struct_field(&mut self, _: &LateContext, _: &hir::StructField) { }\n-    fn check_variant(&mut self, _: &LateContext, _: &hir::Variant, _: &hir::Generics) { }\n-    fn check_variant_post(&mut self, _: &LateContext, _: &hir::Variant, _: &hir::Generics) { }\n-    fn check_lifetime(&mut self, _: &LateContext, _: &hir::Lifetime) { }\n-    fn check_lifetime_def(&mut self, _: &LateContext, _: &hir::LifetimeDef) { }\n-    fn check_path(&mut self, _: &LateContext, _: &hir::Path, _: ast::NodeId) { }\n-    fn check_path_list_item(&mut self, _: &LateContext, _: &hir::PathListItem) { }\n-    fn check_attribute(&mut self, _: &LateContext, _: &ast::Attribute) { }\n+    fn check_crate(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Crate) { }\n+    fn check_crate_post(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Crate) { }\n+    fn check_mod(&mut self,\n+                 _: &LateContext<'a, 'tcx>,\n+                 _: &'tcx hir::Mod,\n+                 _: Span,\n+                 _: ast::NodeId) { }\n+    fn check_mod_post(&mut self,\n+                      _: &LateContext<'a, 'tcx>,\n+                      _: &'tcx hir::Mod,\n+                      _: Span,\n+                      _: ast::NodeId) { }\n+    fn check_foreign_item(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::ForeignItem) { }\n+    fn check_foreign_item_post(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::ForeignItem) { }\n+    fn check_item(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Item) { }\n+    fn check_item_post(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Item) { }\n+    fn check_local(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Local) { }\n+    fn check_block(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Block) { }\n+    fn check_block_post(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Block) { }\n+    fn check_stmt(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Stmt) { }\n+    fn check_arm(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Arm) { }\n+    fn check_pat(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Pat) { }\n+    fn check_decl(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Decl) { }\n+    fn check_expr(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Expr) { }\n+    fn check_expr_post(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Expr) { }\n+    fn check_ty(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Ty) { }\n+    fn check_generics(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Generics) { }\n+    fn check_fn(&mut self,\n+                _: &LateContext<'a, 'tcx>,\n+                _: FnKind<'tcx>,\n+                _: &'tcx hir::FnDecl,\n+                _: &'tcx hir::Expr,\n+                _: Span,\n+                _: ast::NodeId) { }\n+    fn check_fn_post(&mut self,\n+                     _: &LateContext<'a, 'tcx>,\n+                     _: FnKind<'tcx>,\n+                     _: &'tcx hir::FnDecl,\n+                     _: &'tcx hir::Expr,\n+                     _: Span,\n+                     _: ast::NodeId) { }\n+    fn check_trait_item(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::TraitItem) { }\n+    fn check_trait_item_post(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::TraitItem) { }\n+    fn check_impl_item(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::ImplItem) { }\n+    fn check_impl_item_post(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::ImplItem) { }\n+    fn check_struct_def(&mut self,\n+                        _: &LateContext<'a, 'tcx>,\n+                        _: &'tcx hir::VariantData,\n+                        _: ast::Name,\n+                        _: &'tcx hir::Generics,\n+                        _: ast::NodeId) { }\n+    fn check_struct_def_post(&mut self,\n+                             _: &LateContext<'a, 'tcx>,\n+                             _: &'tcx hir::VariantData,\n+                             _: ast::Name,\n+                             _: &'tcx hir::Generics,\n+                             _: ast::NodeId) { }\n+    fn check_struct_field(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::StructField) { }\n+    fn check_variant(&mut self,\n+                     _: &LateContext<'a, 'tcx>,\n+                     _: &'tcx hir::Variant,\n+                     _: &'tcx hir::Generics) { }\n+    fn check_variant_post(&mut self,\n+                          _: &LateContext<'a, 'tcx>,\n+                          _: &'tcx hir::Variant,\n+                          _: &'tcx hir::Generics) { }\n+    fn check_lifetime(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Lifetime) { }\n+    fn check_lifetime_def(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::LifetimeDef) { }\n+    fn check_path(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx hir::Path, _: ast::NodeId) { }\n+    fn check_attribute(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx ast::Attribute) { }\n \n     /// Called when entering a syntax node that can have lint attributes such\n     /// as `#[allow(...)]`. Called with *all* the attributes of that node.\n-    fn enter_lint_attrs(&mut self, _: &LateContext, _: &[ast::Attribute]) { }\n+    fn enter_lint_attrs(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx [ast::Attribute]) { }\n \n     /// Counterpart to `enter_lint_attrs`.\n-    fn exit_lint_attrs(&mut self, _: &LateContext, _: &[ast::Attribute]) { }\n+    fn exit_lint_attrs(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx [ast::Attribute]) { }\n }\n \n pub trait EarlyLintPass: LintPass {\n@@ -230,7 +261,7 @@ pub trait EarlyLintPass: LintPass {\n \n /// A lint pass boxed up as a trait object.\n pub type EarlyLintPassObject = Box<EarlyLintPass + 'static>;\n-pub type LateLintPassObject = Box<LateLintPass + 'static>;\n+pub type LateLintPassObject = Box<for<'a, 'tcx> LateLintPass<'a, 'tcx> + 'static>;\n \n /// Identifies a lint known to the compiler.\n #[derive(Clone, Copy, Debug)]"}, {"sha": "3418034b069d606c7b4f084b0fa6ce5035d6bb17", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -14,14 +14,14 @@\n  * Almost certainly this could (and should) be refactored out of existence.\n  */\n \n+use hir;\n use hir::def::Def;\n use ty::{Ty, TyCtxt};\n \n use syntax_pos::Span;\n-use hir as ast;\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn prohibit_type_params(self, segments: &[ast::PathSegment]) {\n+    pub fn prohibit_type_params(self, segments: &[hir::PathSegment]) {\n         for segment in segments {\n             for typ in segment.parameters.types() {\n                 struct_span_err!(self.sess, typ.span, E0109,\n@@ -53,25 +53,25 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn prim_ty_to_ty(self,\n-                         segments: &[ast::PathSegment],\n-                         nty: ast::PrimTy)\n+                         segments: &[hir::PathSegment],\n+                         nty: hir::PrimTy)\n                          -> Ty<'tcx> {\n         self.prohibit_type_params(segments);\n         match nty {\n-            ast::TyBool => self.types.bool,\n-            ast::TyChar => self.types.char,\n-            ast::TyInt(it) => self.mk_mach_int(it),\n-            ast::TyUint(uit) => self.mk_mach_uint(uit),\n-            ast::TyFloat(ft) => self.mk_mach_float(ft),\n-            ast::TyStr => self.mk_str()\n+            hir::TyBool => self.types.bool,\n+            hir::TyChar => self.types.char,\n+            hir::TyInt(it) => self.mk_mach_int(it),\n+            hir::TyUint(uit) => self.mk_mach_uint(uit),\n+            hir::TyFloat(ft) => self.mk_mach_float(ft),\n+            hir::TyStr => self.mk_str()\n         }\n     }\n \n     /// If a type in the AST is a primitive type, return the ty::Ty corresponding\n     /// to it.\n-    pub fn ast_ty_to_prim_ty(self, ast_ty: &ast::Ty) -> Option<Ty<'tcx>> {\n-        if let ast::TyPath(None, ref path) = ast_ty.node {\n-            if let Def::PrimTy(nty) = self.expect_def(ast_ty.id) {\n+    pub fn ast_ty_to_prim_ty(self, ast_ty: &hir::Ty) -> Option<Ty<'tcx>> {\n+        if let hir::TyPath(hir::QPath::Resolved(None, ref path)) = ast_ty.node {\n+            if let Def::PrimTy(nty) = path.def {\n                 Some(self.prim_ty_to_ty(&path.segments, nty))\n             } else {\n                 None"}, {"sha": "f2be97c832370b2e5d5be2c0510d6ee9b9326dc2", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 127, "deletions": 33, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -67,6 +67,9 @@ pub struct CrateSource {\n \n #[derive(RustcEncodable, RustcDecodable, Copy, Clone, Ord, PartialOrd, Eq, PartialEq, Debug)]\n pub enum DepKind {\n+    /// A dependency that is only used for its macros, none of which are visible from other crates.\n+    /// These are included in the metadata only as placeholders and are ignored when decoding.\n+    UnexportedMacrosOnly,\n     /// A dependency that is only used for its macros.\n     MacrosOnly,\n     /// A dependency that is always injected into the dependency list and so\n@@ -77,6 +80,15 @@ pub enum DepKind {\n     Explicit,\n }\n \n+impl DepKind {\n+    pub fn macros_only(self) -> bool {\n+        match self {\n+            DepKind::UnexportedMacrosOnly | DepKind::MacrosOnly => true,\n+            DepKind::Implicit | DepKind::Explicit => false,\n+        }\n+    }\n+}\n+\n #[derive(PartialEq, Clone, Debug)]\n pub enum LibSource {\n     Some(PathBuf),\n@@ -119,24 +131,103 @@ pub struct NativeLibrary {\n     pub kind: NativeLibraryKind,\n     pub name: Symbol,\n     pub cfg: Option<ast::MetaItem>,\n+    pub foreign_items: Vec<DefIndex>,\n }\n \n /// The data we save and restore about an inlined item or method.  This is not\n /// part of the AST that we parse from a file, but it becomes part of the tree\n /// that we trans.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum InlinedItem {\n-    Item(DefId /* def-id in source crate */, P<hir::Item>),\n-    TraitItem(DefId /* impl id */, P<hir::TraitItem>),\n-    ImplItem(DefId /* impl id */, P<hir::ImplItem>)\n+pub struct InlinedItem {\n+    pub def_id: DefId,\n+    pub body: P<hir::Expr>,\n+    pub const_fn_args: Vec<Option<DefId>>,\n }\n \n-/// A borrowed version of `hir::InlinedItem`.\n-#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, Hash, Debug)]\n-pub enum InlinedItemRef<'a> {\n-    Item(DefId, &'a hir::Item),\n-    TraitItem(DefId, &'a hir::TraitItem),\n-    ImplItem(DefId, &'a hir::ImplItem)\n+/// A borrowed version of `hir::InlinedItem`. This is what's encoded when saving\n+/// a crate; it then gets read as an InlinedItem.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, Hash, Debug)]\n+pub struct InlinedItemRef<'a> {\n+    pub def_id: DefId,\n+    pub body: &'a hir::Expr,\n+    pub const_fn_args: Vec<Option<DefId>>,\n+}\n+\n+fn get_fn_args(decl: &hir::FnDecl) -> Vec<Option<DefId>> {\n+    decl.inputs.iter().map(|arg| match arg.pat.node {\n+        hir::PatKind::Binding(_, def_id, _, _) => Some(def_id),\n+        _ => None\n+    }).collect()\n+}\n+\n+impl<'a> InlinedItemRef<'a> {\n+    pub fn from_item<'b, 'tcx>(def_id: DefId,\n+                               item: &'a hir::Item,\n+                               tcx: TyCtxt<'b, 'a, 'tcx>)\n+                               -> InlinedItemRef<'a> {\n+        let (body, args) = match item.node {\n+            hir::ItemFn(ref decl, _, _, _, _, body_id) =>\n+                (tcx.map.expr(body_id), get_fn_args(decl)),\n+            hir::ItemConst(_, ref body) => (&**body, Vec::new()),\n+            _ => bug!(\"InlinedItemRef::from_item wrong kind\")\n+        };\n+        InlinedItemRef {\n+            def_id: def_id,\n+            body: body,\n+            const_fn_args: args\n+        }\n+    }\n+\n+    pub fn from_trait_item(def_id: DefId,\n+                           item: &'a hir::TraitItem,\n+                           _tcx: TyCtxt)\n+                           -> InlinedItemRef<'a> {\n+        let (body, args) = match item.node {\n+            hir::ConstTraitItem(_, Some(ref body)) =>\n+                (&**body, Vec::new()),\n+            hir::ConstTraitItem(_, None) => {\n+                bug!(\"InlinedItemRef::from_trait_item called for const without body\")\n+            },\n+            _ => bug!(\"InlinedItemRef::from_trait_item wrong kind\")\n+        };\n+        InlinedItemRef {\n+            def_id: def_id,\n+            body: body,\n+            const_fn_args: args\n+        }\n+    }\n+\n+    pub fn from_impl_item<'b, 'tcx>(def_id: DefId,\n+                                    item: &'a hir::ImplItem,\n+                                    tcx: TyCtxt<'b, 'a, 'tcx>)\n+                                    -> InlinedItemRef<'a> {\n+        let (body, args) = match item.node {\n+            hir::ImplItemKind::Method(ref sig, body_id) =>\n+                (tcx.map.expr(body_id), get_fn_args(&sig.decl)),\n+            hir::ImplItemKind::Const(_, ref body) =>\n+                (&**body, Vec::new()),\n+            _ => bug!(\"InlinedItemRef::from_impl_item wrong kind\")\n+        };\n+        InlinedItemRef {\n+            def_id: def_id,\n+            body: body,\n+            const_fn_args: args\n+        }\n+    }\n+\n+    pub fn visit<V>(&self, visitor: &mut V)\n+        where V: Visitor<'a>\n+    {\n+        visitor.visit_expr(&self.body);\n+    }\n+}\n+\n+impl InlinedItem {\n+    pub fn visit<'ast,V>(&'ast self, visitor: &mut V)\n+        where V: Visitor<'ast>\n+    {\n+        visitor.visit_expr(&self.body);\n+    }\n }\n \n pub enum LoadedMacro {\n@@ -170,6 +261,7 @@ pub struct ExternCrate {\n pub trait CrateStore<'tcx> {\n     // item info\n     fn describe_def(&self, def: DefId) -> Option<Def>;\n+    fn def_span(&self, sess: &Session, def: DefId) -> Span;\n     fn stability(&self, def: DefId) -> Option<attr::Stability>;\n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation>;\n     fn visibility(&self, def: DefId) -> ty::Visibility;\n@@ -187,8 +279,8 @@ pub trait CrateStore<'tcx> {\n     fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                          -> ty::Generics<'tcx>;\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>;\n-    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef<'tcx>;\n-    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>;\n+    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef;\n+    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> &'tcx ty::AdtDef;\n     fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name>;\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>;\n \n@@ -214,12 +306,14 @@ pub trait CrateStore<'tcx> {\n     fn is_defaulted_trait(&self, did: DefId) -> bool;\n     fn is_default_impl(&self, impl_did: DefId) -> bool;\n     fn is_foreign_item(&self, did: DefId) -> bool;\n-    fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool;\n+    fn is_dllimport_foreign_item(&self, def: DefId) -> bool;\n+    fn is_statically_included_foreign_item(&self, def_id: DefId) -> bool;\n \n     // crate metadata\n     fn dylib_dependency_formats(&self, cnum: CrateNum)\n                                     -> Vec<(CrateNum, LinkagePreference)>;\n     fn dep_kind(&self, cnum: CrateNum) -> DepKind;\n+    fn export_macros(&self, cnum: CrateNum);\n     fn lang_items(&self, cnum: CrateNum) -> Vec<(DefIndex, usize)>;\n     fn missing_lang_items(&self, cnum: CrateNum) -> Vec<lang_items::LangItem>;\n     fn is_staged_api(&self, cnum: CrateNum) -> bool;\n@@ -236,8 +330,9 @@ pub trait CrateStore<'tcx> {\n     fn crate_hash(&self, cnum: CrateNum) -> Svh;\n     fn crate_disambiguator(&self, cnum: CrateNum) -> Symbol;\n     fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>;\n+    fn derive_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>;\n     fn native_libraries(&self, cnum: CrateNum) -> Vec<NativeLibrary>;\n-    fn reachable_ids(&self, cnum: CrateNum) -> Vec<DefId>;\n+    fn exported_symbols(&self, cnum: CrateNum) -> Vec<DefId>;\n     fn is_no_builtins(&self, cnum: CrateNum) -> bool;\n \n     // resolve\n@@ -260,6 +355,11 @@ pub trait CrateStore<'tcx> {\n     fn get_item_mir<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> Mir<'tcx>;\n     fn is_item_mir_available(&self, def: DefId) -> bool;\n \n+    /// Take a look if we need to inline or monomorphize this. If so, we\n+    /// will emit code for this item in the local crate, and thus\n+    /// create a translation item for it.\n+    fn can_have_local_instance<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> bool;\n+\n     // This is basically a 1-based range of ints, which is a little\n     // silly - I may fix that.\n     fn crates(&self) -> Vec<CrateNum>;\n@@ -279,18 +379,6 @@ pub trait CrateStore<'tcx> {\n     fn metadata_encoding_version(&self) -> &[u8];\n }\n \n-impl InlinedItem {\n-    pub fn visit<'ast,V>(&'ast self, visitor: &mut V)\n-        where V: Visitor<'ast>\n-    {\n-        match *self {\n-            InlinedItem::Item(_, ref i) => visitor.visit_item(&i),\n-            InlinedItem::TraitItem(_, ref ti) => visitor.visit_trait_item(ti),\n-            InlinedItem::ImplItem(_, ref ii) => visitor.visit_impl_item(ii),\n-        }\n-    }\n-}\n-\n // FIXME: find a better place for this?\n pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n     let mut err_count = 0;\n@@ -325,6 +413,7 @@ pub struct DummyCrateStore;\n impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     // item info\n     fn describe_def(&self, def: DefId) -> Option<Def> { bug!(\"describe_def\") }\n+    fn def_span(&self, sess: &Session, def: DefId) -> Span { bug!(\"def_span\") }\n     fn stability(&self, def: DefId) -> Option<attr::Stability> { bug!(\"stability\") }\n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation> { bug!(\"deprecation\") }\n     fn visibility(&self, def: DefId) -> ty::Visibility { bug!(\"visibility\") }\n@@ -344,9 +433,9 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                          -> ty::Generics<'tcx> { bug!(\"item_generics\") }\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute> { bug!(\"item_attrs\") }\n-    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef<'tcx>\n+    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef\n         { bug!(\"trait_def\") }\n-    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n+    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> &'tcx ty::AdtDef\n         { bug!(\"adt_def\") }\n     fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name> { bug!(\"fn_arg_names\") }\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId> { vec![] }\n@@ -381,7 +470,8 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn is_defaulted_trait(&self, did: DefId) -> bool { bug!(\"is_defaulted_trait\") }\n     fn is_default_impl(&self, impl_did: DefId) -> bool { bug!(\"is_default_impl\") }\n     fn is_foreign_item(&self, did: DefId) -> bool { bug!(\"is_foreign_item\") }\n-    fn is_statically_included_foreign_item(&self, id: ast::NodeId) -> bool { false }\n+    fn is_dllimport_foreign_item(&self, id: DefId) -> bool { false }\n+    fn is_statically_included_foreign_item(&self, def_id: DefId) -> bool { false }\n \n     // crate metadata\n     fn dylib_dependency_formats(&self, cnum: CrateNum)\n@@ -393,6 +483,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n         { bug!(\"missing_lang_items\") }\n     fn is_staged_api(&self, cnum: CrateNum) -> bool { bug!(\"is_staged_api\") }\n     fn dep_kind(&self, cnum: CrateNum) -> DepKind { bug!(\"is_explicitly_linked\") }\n+    fn export_macros(&self, cnum: CrateNum) { bug!(\"export_macros\") }\n     fn is_allocator(&self, cnum: CrateNum) -> bool { bug!(\"is_allocator\") }\n     fn is_panic_runtime(&self, cnum: CrateNum) -> bool { bug!(\"is_panic_runtime\") }\n     fn is_compiler_builtins(&self, cnum: CrateNum) -> bool { bug!(\"is_compiler_builtins\") }\n@@ -409,9 +500,11 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n                            -> Symbol { bug!(\"crate_disambiguator\") }\n     fn plugin_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n         { bug!(\"plugin_registrar_fn\") }\n+    fn derive_registrar_fn(&self, cnum: CrateNum) -> Option<DefId>\n+        { bug!(\"derive_registrar_fn\") }\n     fn native_libraries(&self, cnum: CrateNum) -> Vec<NativeLibrary>\n         { bug!(\"native_libraries\") }\n-    fn reachable_ids(&self, cnum: CrateNum) -> Vec<DefId> { bug!(\"reachable_ids\") }\n+    fn exported_symbols(&self, cnum: CrateNum) -> Vec<DefId> { bug!(\"exported_symbols\") }\n     fn is_no_builtins(&self, cnum: CrateNum) -> bool { bug!(\"is_no_builtins\") }\n \n     // resolve\n@@ -440,13 +533,14 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn is_item_mir_available(&self, def: DefId) -> bool {\n         bug!(\"is_item_mir_available\")\n     }\n+    fn can_have_local_instance<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> bool {\n+        bug!(\"can_have_local_instance\")\n+    }\n \n     // This is basically a 1-based range of ints, which is a little\n     // silly - I may fix that.\n     fn crates(&self) -> Vec<CrateNum> { vec![] }\n-    fn used_libraries(&self) -> Vec<NativeLibrary> {\n-        vec![]\n-    }\n+    fn used_libraries(&self) -> Vec<NativeLibrary> { vec![] }\n     fn used_link_args(&self) -> Vec<String> { vec![] }\n \n     // utility functions"}, {"sha": "f7a34c43cccbd8335afcbd0dfd85a655e16cd5f4", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -193,6 +193,10 @@ fn build_nodeid_to_index(decl: Option<&hir::FnDecl>,\n         let mut formals = Formals { entry: entry, index: index };\n         intravisit::walk_fn_decl(&mut formals, decl);\n         impl<'a, 'v> intravisit::Visitor<'v> for Formals<'a> {\n+            fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'v> {\n+                panic!(\"should not encounter fn bodies or items\")\n+            }\n+\n             fn visit_pat(&mut self, p: &hir::Pat) {\n                 self.index.entry(p.id).or_insert(vec![]).push(self.entry);\n                 intravisit::walk_pat(self, p)"}, {"sha": "1bf6b837fd998d2f201540621297a8e8a6839ff2", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 34, "deletions": 36, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -14,8 +14,8 @@\n \n use dep_graph::DepNode;\n use hir::map as ast_map;\n-use hir::{self, pat_util, PatKind};\n-use hir::intravisit::{self, Visitor};\n+use hir::{self, PatKind};\n+use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir::itemlikevisit::ItemLikeVisitor;\n \n use middle::privacy;\n@@ -86,9 +86,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn lookup_and_handle_definition(&mut self, id: ast::NodeId) {\n-        let def = self.tcx.expect_def(id);\n-\n+    fn handle_definition(&mut self, id: ast::NodeId, def: Def) {\n         // If `bar` is a trait item, make sure to mark Foo as alive in `Foo::bar`\n         match def {\n             Def::AssociatedTy(..) | Def::Method(_) | Def::AssociatedConst(_)\n@@ -147,12 +145,10 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn handle_field_pattern_match(&mut self, lhs: &hir::Pat,\n+    fn handle_field_pattern_match(&mut self, lhs: &hir::Pat, def: Def,\n                                   pats: &[codemap::Spanned<hir::FieldPat>]) {\n         let variant = match self.tcx.tables().node_id_to_type(lhs.id).sty {\n-            ty::TyAdt(adt, _) => {\n-                adt.variant_of_def(self.tcx.expect_def(lhs.id))\n-            }\n+            ty::TyAdt(adt, _) => adt.variant_of_def(def),\n             _ => span_bug!(lhs.span, \"non-ADT in struct pattern\")\n         };\n         for pat in pats {\n@@ -179,7 +175,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_node(&mut self, node: &ast_map::Node) {\n+    fn visit_node(&mut self, node: &ast_map::Node<'tcx>) {\n         let had_extern_repr = self.struct_has_extern_repr;\n         self.struct_has_extern_repr = false;\n         let had_inherited_pub_visibility = self.inherited_pub_visibility;\n@@ -224,9 +220,12 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+    }\n \n-    fn visit_variant_data(&mut self, def: &hir::VariantData, _: ast::Name,\n+    fn visit_variant_data(&mut self, def: &'tcx hir::VariantData, _: ast::Name,\n                         _: &hir::Generics, _: ast::NodeId, _: syntax_pos::Span) {\n         let has_extern_repr = self.struct_has_extern_repr;\n         let inherited_pub_visibility = self.inherited_pub_visibility;\n@@ -238,8 +237,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n         intravisit::walk_struct_def(self, def);\n     }\n \n-    fn visit_expr(&mut self, expr: &hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n+            hir::ExprPath(ref qpath @ hir::QPath::TypeRelative(..)) => {\n+                let def = self.tcx.tables().qpath_def(qpath, expr.id);\n+                self.handle_definition(expr.id, def);\n+            }\n             hir::ExprMethodCall(..) => {\n                 self.lookup_and_handle_method(expr.id);\n             }\n@@ -255,10 +258,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n         intravisit::walk_expr(self, expr);\n     }\n \n-    fn visit_arm(&mut self, arm: &hir::Arm) {\n+    fn visit_arm(&mut self, arm: &'tcx hir::Arm) {\n         if arm.pats.len() == 1 {\n-            let pat = &*arm.pats[0];\n-            let variants = pat_util::necessary_variants(&self.tcx.def_map.borrow(), pat);\n+            let variants = arm.pats[0].necessary_variants();\n \n             // Inside the body, ignore constructions of variants\n             // necessary for the pattern to match. Those construction sites\n@@ -272,15 +274,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_pat(&mut self, pat: &hir::Pat) {\n-        let def_map = &self.tcx.def_map;\n+    fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n         match pat.node {\n-            PatKind::Struct(_, ref fields, _) => {\n-                self.handle_field_pattern_match(pat, fields);\n+            PatKind::Struct(hir::QPath::Resolved(_, ref path), ref fields, _) => {\n+                self.handle_field_pattern_match(pat, path.def, fields);\n             }\n-            _ if pat_util::pat_is_const(&def_map.borrow(), pat) => {\n-                // it might be the only use of a const\n-                self.lookup_and_handle_definition(pat.id)\n+            PatKind::Path(ref qpath @ hir::QPath::TypeRelative(..)) => {\n+                let def = self.tcx.tables().qpath_def(qpath, pat.id);\n+                self.handle_definition(pat.id, def);\n             }\n             _ => ()\n         }\n@@ -290,15 +291,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MarkSymbolVisitor<'a, 'tcx> {\n         self.ignore_non_const_paths = false;\n     }\n \n-    fn visit_path(&mut self, path: &hir::Path, id: ast::NodeId) {\n-        self.lookup_and_handle_definition(id);\n+    fn visit_path(&mut self, path: &'tcx hir::Path, id: ast::NodeId) {\n+        self.handle_definition(id, path.def);\n         intravisit::walk_path(self, path);\n     }\n-\n-    fn visit_path_list_item(&mut self, path: &hir::Path, item: &hir::PathListItem) {\n-        self.lookup_and_handle_definition(item.node.id);\n-        intravisit::walk_path_list_item(self, path, item);\n-    }\n }\n \n fn has_allow_dead_code_or_lang_attr(attrs: &[ast::Attribute]) -> bool {\n@@ -514,8 +510,8 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n     /// on inner functions when the outer function is already getting\n     /// an error. We could do this also by checking the parents, but\n     /// this is how the code is setup and it seems harmless enough.\n-    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n-        Some(&self.tcx.map)\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.tcx.map)\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n@@ -569,12 +565,12 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n                 }\n                 intravisit::walk_expr(self, expr)\n             }\n-            hir::ImplItemKind::Method(_, ref body) => {\n+            hir::ImplItemKind::Method(_, body_id) => {\n                 if !self.symbol_is_live(impl_item.id, None) {\n                     self.warn_dead_code(impl_item.id, impl_item.span,\n                                         impl_item.name, \"method\");\n                 }\n-                intravisit::walk_expr(self, body)\n+                self.visit_body(body_id)\n             }\n             hir::ImplItemKind::Type(..) => {}\n         }\n@@ -583,10 +579,12 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n     // Overwrite so that we don't warn the trait item itself.\n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         match trait_item.node {\n-            hir::ConstTraitItem(_, Some(ref body))|\n-            hir::MethodTraitItem(_, Some(ref body)) => {\n+            hir::ConstTraitItem(_, Some(ref body)) => {\n                 intravisit::walk_expr(self, body)\n             }\n+            hir::MethodTraitItem(_, Some(body_id)) => {\n+                self.visit_body(body_id)\n+            }\n             hir::ConstTraitItem(_, None) |\n             hir::MethodTraitItem(_, None) |\n             hir::TypeTraitItem(..) => {}"}, {"sha": "075b3d7a8e90c9e2588bac8f87a5d7dc0f175e75", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -124,7 +124,7 @@ fn calculate_type(sess: &session::Session,\n                 return v;\n             }\n             for cnum in sess.cstore.crates() {\n-                if sess.cstore.dep_kind(cnum) == DepKind::MacrosOnly { continue }\n+                if sess.cstore.dep_kind(cnum).macros_only() { continue }\n                 let src = sess.cstore.used_crate_source(cnum);\n                 if src.rlib.is_some() { continue }\n                 sess.err(&format!(\"dependency `{}` not found in rlib format\",\n@@ -157,7 +157,7 @@ fn calculate_type(sess: &session::Session,\n     // dependencies, ensuring there are no conflicts. The only valid case for a\n     // dependency to be relied upon twice is for both cases to rely on a dylib.\n     for cnum in sess.cstore.crates() {\n-        if sess.cstore.dep_kind(cnum) == DepKind::MacrosOnly { continue }\n+        if sess.cstore.dep_kind(cnum).macros_only() { continue }\n         let name = sess.cstore.crate_name(cnum);\n         let src = sess.cstore.used_crate_source(cnum);\n         if src.dylib.is_some() {"}, {"sha": "2ec7aa4c4d9031c316c0ac37d3557008203de98f", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -21,7 +21,7 @@ use syntax::ast;\n use syntax_pos::Span;\n use hir::{self, PatKind};\n use hir::def::Def;\n-use hir::intravisit::{self, FnKind, Visitor};\n+use hir::intravisit::{self, FnKind, Visitor, NestedVisitorMap};\n \n #[derive(Copy, Clone)]\n struct UnsafeContext {\n@@ -92,9 +92,13 @@ impl<'a, 'tcx> EffectCheckVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n-    fn visit_fn(&mut self, fn_kind: FnKind<'v>, fn_decl: &'v hir::FnDecl,\n-                block: &'v hir::Expr, span: Span, id: ast::NodeId) {\n+impl<'a, 'tcx> Visitor<'tcx> for EffectCheckVisitor<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+    }\n+\n+    fn visit_fn(&mut self, fn_kind: FnKind<'tcx>, fn_decl: &'tcx hir::FnDecl,\n+                body_id: hir::ExprId, span: Span, id: ast::NodeId) {\n \n         let (is_item_fn, is_unsafe_fn) = match fn_kind {\n             FnKind::ItemFn(_, _, unsafety, ..) =>\n@@ -111,12 +115,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n             self.unsafe_context = UnsafeContext::new(SafeContext)\n         }\n \n-        intravisit::walk_fn(self, fn_kind, fn_decl, block, span, id);\n+        intravisit::walk_fn(self, fn_kind, fn_decl, body_id, span, id);\n \n         self.unsafe_context = old_unsafe_context\n     }\n \n-    fn visit_block(&mut self, block: &hir::Block) {\n+    fn visit_block(&mut self, block: &'tcx hir::Block) {\n         let old_unsafe_context = self.unsafe_context;\n         match block.rules {\n             hir::UnsafeBlock(source) => {\n@@ -147,15 +151,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 self.unsafe_context.push_unsafe_count =\n                     self.unsafe_context.push_unsafe_count.checked_sub(1).unwrap();\n             }\n-            hir::DefaultBlock | hir::PushUnstableBlock | hir:: PopUnstableBlock => {}\n+            hir::DefaultBlock => {}\n         }\n \n         intravisit::walk_block(self, block);\n \n         self.unsafe_context = old_unsafe_context\n     }\n \n-    fn visit_expr(&mut self, expr: &hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprMethodCall(..) => {\n                 let method_call = MethodCall::expr(expr.id);\n@@ -186,8 +190,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n             hir::ExprInlineAsm(..) => {\n                 self.require_unsafe(expr.span, \"use of inline assembly\");\n             }\n-            hir::ExprPath(..) => {\n-                if let Def::Static(def_id, mutbl) = self.tcx.expect_def(expr.id) {\n+            hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+                if let Def::Static(def_id, mutbl) = path.def {\n                     if mutbl {\n                         self.require_unsafe(expr.span, \"use of mutable static\");\n                     } else if match self.tcx.map.get_if_local(def_id) {\n@@ -212,7 +216,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n         intravisit::walk_expr(self, expr);\n     }\n \n-    fn visit_pat(&mut self, pat: &hir::Pat) {\n+    fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n         if let PatKind::Struct(_, ref fields, _) = pat.node {\n             if let ty::TyAdt(adt, ..) = self.tcx.tables().pat_ty(pat).sty {\n                 if adt.is_union() {"}, {"sha": "e927843a984b8c351a307ca2e625d4ba69f831bf", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -47,6 +47,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for EntryContext<'a, 'tcx> {\n         find_item(item, self, at_root);\n     }\n \n+\n     fn visit_impl_item(&mut self, _impl_item: &'tcx ImplItem) {\n         // entry fn is never an impl item\n     }"}, {"sha": "b3e61f1e5706772c1eeffc77f0c19c3d9fa6c399", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -19,7 +19,6 @@ pub use self::MatchMode::*;\n use self::TrackMatchMode::*;\n use self::OverloadedCallType::*;\n \n-use hir::pat_util;\n use hir::def::Def;\n use hir::def_id::{DefId};\n use infer::InferCtxt;\n@@ -374,7 +373,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         self.walk_adjustment(expr);\n \n         match expr.node {\n-            hir::ExprPath(..) => { }\n+            hir::ExprPath(_) => { }\n \n             hir::ExprType(ref subexpr, _) => {\n                 self.walk_expr(&subexpr)\n@@ -622,7 +621,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         match local.init {\n             None => {\n                 let delegate = &mut self.delegate;\n-                pat_util::pat_bindings(&local.pat, |_, id, span, _| {\n+                local.pat.each_binding(|_, id, span, _| {\n                     delegate.decl_without_init(id, span);\n                 })\n             }\n@@ -702,7 +701,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         // are properly handled.\n         self.walk_expr(with_expr);\n \n-        fn contains_field_named(field: ty::FieldDef,\n+        fn contains_field_named(field: &ty::FieldDef,\n                                 fields: &[hir::Field])\n                                 -> bool\n         {\n@@ -957,16 +956,16 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         let infcx = self.mc.infcx;\n         let delegate = &mut self.delegate;\n         return_if_err!(mc.cat_pattern(cmt_discr.clone(), pat, |mc, cmt_pat, pat| {\n-            if let PatKind::Binding(bmode, ..) = pat.node {\n+            if let PatKind::Binding(bmode, def_id, ..) = pat.node {\n                 debug!(\"binding cmt_pat={:?} pat={:?} match_mode={:?}\", cmt_pat, pat, match_mode);\n \n                 // pat_ty: the type of the binding being produced.\n                 let pat_ty = return_if_err!(infcx.node_ty(pat.id));\n \n                 // Each match binding is effectively an assignment to the\n                 // binding being produced.\n-                if let Ok(binding_cmt) = mc.cat_def(pat.id, pat.span, pat_ty,\n-                                                    tcx.expect_def(pat.id)) {\n+                let def = Def::Local(def_id);\n+                if let Ok(binding_cmt) = mc.cat_def(pat.id, pat.span, pat_ty, def) {\n                     delegate.mutate(pat.id, pat.span, binding_cmt, MutateMode::Init);\n                 }\n \n@@ -992,9 +991,16 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         // to the above loop's visit of than the bindings that form\n         // the leaves of the pattern tree structure.\n         return_if_err!(mc.cat_pattern(cmt_discr, pat, |mc, cmt_pat, pat| {\n-            match tcx.expect_def_or_none(pat.id) {\n-                Some(Def::Variant(variant_did)) |\n-                Some(Def::VariantCtor(variant_did, ..)) => {\n+            let qpath = match pat.node {\n+                PatKind::Path(ref qpath) |\n+                PatKind::TupleStruct(ref qpath, ..) |\n+                PatKind::Struct(ref qpath, ..) => qpath,\n+                _ => return\n+            };\n+            let def = tcx.tables().qpath_def(qpath, pat.id);\n+            match def {\n+                Def::Variant(variant_did) |\n+                Def::VariantCtor(variant_did, ..) => {\n                     let enum_did = tcx.parent_def_id(variant_did).unwrap();\n                     let downcast_cmt = if tcx.lookup_adt_def(enum_did).is_univariant() {\n                         cmt_pat\n@@ -1006,14 +1012,12 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                     debug!(\"variant downcast_cmt={:?} pat={:?}\", downcast_cmt, pat);\n                     delegate.matched_pat(pat, downcast_cmt, match_mode);\n                 }\n-                Some(Def::Struct(..)) | Some(Def::StructCtor(..)) | Some(Def::Union(..)) |\n-                Some(Def::TyAlias(..)) | Some(Def::AssociatedTy(..)) | Some(Def::SelfTy(..)) => {\n+                Def::Struct(..) | Def::StructCtor(..) | Def::Union(..) |\n+                Def::TyAlias(..) | Def::AssociatedTy(..) | Def::SelfTy(..) => {\n                     debug!(\"struct cmt_pat={:?} pat={:?}\", cmt_pat, pat);\n                     delegate.matched_pat(pat, cmt_pat, match_mode);\n                 }\n-                None | Some(Def::Local(..)) |\n-                Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => {}\n-                def => bug!(\"unexpected definition: {:?}\", def)\n+                _ => {}\n             }\n         }));\n     }"}, {"sha": "2357549c82e081fedfaea3737221985ebe01a904", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 35, "deletions": 24, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -19,7 +19,7 @@ use ty::layout::{LayoutError, Pointer, SizeSkeleton};\n use syntax::abi::Abi::RustIntrinsic;\n use syntax::ast;\n use syntax_pos::Span;\n-use hir::intravisit::{self, Visitor, FnKind};\n+use hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n use hir;\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n@@ -34,7 +34,7 @@ struct ItemVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> ItemVisitor<'a, 'tcx> {\n-    fn visit_const(&mut self, item_id: ast::NodeId, expr: &hir::Expr) {\n+    fn visit_const(&mut self, item_id: ast::NodeId, expr: &'tcx hir::Expr) {\n         let param_env = ty::ParameterEnvironment::for_item(self.tcx, item_id);\n         self.tcx.infer_ctxt(None, Some(param_env), Reveal::All).enter(|infcx| {\n             let mut visitor = ExprVisitor {\n@@ -116,9 +116,13 @@ impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for ItemVisitor<'a, 'tcx> {\n+impl<'a, 'tcx> Visitor<'tcx> for ItemVisitor<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+    }\n+\n     // const, static and N in [T; N].\n-    fn visit_expr(&mut self, expr: &hir::Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         self.tcx.infer_ctxt(None, None, Reveal::All).enter(|infcx| {\n             let mut visitor = ExprVisitor {\n                 infcx: &infcx\n@@ -127,24 +131,24 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ItemVisitor<'a, 'tcx> {\n         });\n     }\n \n-    fn visit_trait_item(&mut self, item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem) {\n         if let hir::ConstTraitItem(_, Some(ref expr)) = item.node {\n             self.visit_const(item.id, expr);\n         } else {\n             intravisit::walk_trait_item(self, item);\n         }\n     }\n \n-    fn visit_impl_item(&mut self, item: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem) {\n         if let hir::ImplItemKind::Const(_, ref expr) = item.node {\n             self.visit_const(item.id, expr);\n         } else {\n             intravisit::walk_impl_item(self, item);\n         }\n     }\n \n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Expr, s: Span, id: ast::NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n+                b: hir::ExprId, s: Span, id: ast::NodeId) {\n         if let FnKind::Closure(..) = fk {\n             span_bug!(s, \"intrinsicck: closure outside of function\")\n         }\n@@ -158,25 +162,32 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ItemVisitor<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx, 'v> Visitor<'v> for ExprVisitor<'a, 'gcx, 'tcx> {\n-    fn visit_expr(&mut self, expr: &hir::Expr) {\n-        if let hir::ExprPath(..) = expr.node {\n-            match self.infcx.tcx.expect_def(expr.id) {\n-                Def::Fn(did) if self.def_id_is_transmute(did) => {\n-                    let typ = self.infcx.tcx.tables().node_id_to_type(expr.id);\n-                    match typ.sty {\n-                        ty::TyFnDef(.., ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n-                            let from = bare_fn_ty.sig.0.inputs[0];\n-                            let to = bare_fn_ty.sig.0.output;\n-                            self.check_transmute(expr.span, from, to, expr.id);\n-                        }\n-                        _ => {\n-                            span_bug!(expr.span, \"transmute wasn't a bare fn?!\");\n-                        }\n+impl<'a, 'gcx, 'tcx> Visitor<'gcx> for ExprVisitor<'a, 'gcx, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n+        NestedVisitorMap::OnlyBodies(&self.infcx.tcx.map)\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'gcx hir::Expr) {\n+        let def = if let hir::ExprPath(ref qpath) = expr.node {\n+            self.infcx.tcx.tables().qpath_def(qpath, expr.id)\n+        } else {\n+            Def::Err\n+        };\n+        match def {\n+            Def::Fn(did) if self.def_id_is_transmute(did) => {\n+                let typ = self.infcx.tcx.tables().node_id_to_type(expr.id);\n+                match typ.sty {\n+                    ty::TyFnDef(.., ref bare_fn_ty) if bare_fn_ty.abi == RustIntrinsic => {\n+                        let from = bare_fn_ty.sig.skip_binder().inputs()[0];\n+                        let to = bare_fn_ty.sig.skip_binder().output();\n+                        self.check_transmute(expr.span, from, to, expr.id);\n+                    }\n+                    _ => {\n+                        span_bug!(expr.span, \"transmute wasn't a bare fn?!\");\n                     }\n                 }\n-                _ => {}\n             }\n+            _ => {}\n         }\n \n         intravisit::walk_expr(self, expr);"}, {"sha": "1efc211b8c35be608b29cfd05cf2b103c67607bc", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 8, "deletions": 25, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -90,31 +90,6 @@ impl LanguageItems {\n         self.require(OwnedBoxLangItem)\n     }\n \n-    pub fn from_builtin_kind(&self, bound: ty::BuiltinBound)\n-                             -> Result<DefId, String>\n-    {\n-        match bound {\n-            ty::BoundSend => self.require(SendTraitLangItem),\n-            ty::BoundSized => self.require(SizedTraitLangItem),\n-            ty::BoundCopy => self.require(CopyTraitLangItem),\n-            ty::BoundSync => self.require(SyncTraitLangItem),\n-        }\n-    }\n-\n-    pub fn to_builtin_kind(&self, id: DefId) -> Option<ty::BuiltinBound> {\n-        if Some(id) == self.send_trait() {\n-            Some(ty::BoundSend)\n-        } else if Some(id) == self.sized_trait() {\n-            Some(ty::BoundSized)\n-        } else if Some(id) == self.copy_trait() {\n-            Some(ty::BoundCopy)\n-        } else if Some(id) == self.sync_trait() {\n-            Some(ty::BoundSync)\n-        } else {\n-            None\n-        }\n-    }\n-\n     pub fn fn_trait_kind(&self, id: DefId) -> Option<ty::ClosureKind> {\n         let def_id_kinds = [\n             (self.fn_trait(), ty::ClosureKind::Fn),\n@@ -381,3 +356,11 @@ language_item_table! {\n \n     DebugTraitLangItem,              \"debug_trait\",             debug_trait;\n }\n+\n+impl<'a, 'tcx, 'gcx> ty::TyCtxt<'a, 'tcx, 'gcx> {\n+    pub fn require_lang_item(&self, lang_item: LangItem) -> DefId {\n+        self.lang_items.require(lang_item).unwrap_or_else(|msg| {\n+            self.sess.fatal(&msg)\n+        })\n+    }\n+}"}, {"sha": "445aed8f97d600fe3eeb547b24d2ca96e008d3ee", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 67, "deletions": 68, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -111,7 +111,6 @@ use self::VarKind::*;\n \n use dep_graph::DepNode;\n use hir::def::*;\n-use hir::pat_util;\n use ty::{self, TyCtxt, ParameterEnvironment};\n use traits::{self, Reveal};\n use ty::subst::Subst;\n@@ -129,7 +128,7 @@ use syntax_pos::Span;\n use hir::Expr;\n use hir;\n use hir::print::{expr_to_string, block_to_string};\n-use hir::intravisit::{self, Visitor, FnKind};\n+use hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n \n /// For use with `propagate_through_loop`.\n enum LoopKind<'a> {\n@@ -183,14 +182,18 @@ fn live_node_kind_to_string(lnk: LiveNodeKind, tcx: TyCtxt) -> String {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for IrMaps<'a, 'tcx> {\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Expr, s: Span, id: NodeId) {\n+impl<'a, 'tcx> Visitor<'tcx> for IrMaps<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+    }\n+\n+    fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n+                b: hir::ExprId, s: Span, id: NodeId) {\n         visit_fn(self, fk, fd, b, s, id);\n     }\n-    fn visit_local(&mut self, l: &hir::Local) { visit_local(self, l); }\n-    fn visit_expr(&mut self, ex: &Expr) { visit_expr(self, ex); }\n-    fn visit_arm(&mut self, a: &hir::Arm) { visit_arm(self, a); }\n+    fn visit_local(&mut self, l: &'tcx hir::Local) { visit_local(self, l); }\n+    fn visit_expr(&mut self, ex: &'tcx Expr) { visit_expr(self, ex); }\n+    fn visit_arm(&mut self, a: &'tcx hir::Arm) { visit_arm(self, a); }\n }\n \n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n@@ -349,28 +352,32 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for Liveness<'a, 'tcx> {\n-    fn visit_fn(&mut self, _: FnKind<'v>, _: &'v hir::FnDecl,\n-                _: &'v hir::Expr, _: Span, _: NodeId) {\n+impl<'a, 'tcx> Visitor<'tcx> for Liveness<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.ir.tcx.map)\n+    }\n+\n+    fn visit_fn(&mut self, _: FnKind<'tcx>, _: &'tcx hir::FnDecl,\n+                _: hir::ExprId, _: Span, _: NodeId) {\n         // do not check contents of nested fns\n     }\n-    fn visit_local(&mut self, l: &hir::Local) {\n+    fn visit_local(&mut self, l: &'tcx hir::Local) {\n         check_local(self, l);\n     }\n-    fn visit_expr(&mut self, ex: &Expr) {\n+    fn visit_expr(&mut self, ex: &'tcx Expr) {\n         check_expr(self, ex);\n     }\n-    fn visit_arm(&mut self, a: &hir::Arm) {\n+    fn visit_arm(&mut self, a: &'tcx hir::Arm) {\n         check_arm(self, a);\n     }\n }\n \n-fn visit_fn(ir: &mut IrMaps,\n-            fk: FnKind,\n-            decl: &hir::FnDecl,\n-            body: &hir::Expr,\n-            sp: Span,\n-            id: ast::NodeId) {\n+fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n+                          fk: FnKind<'tcx>,\n+                          decl: &'tcx hir::FnDecl,\n+                          body_id: hir::ExprId,\n+                          sp: Span,\n+                          id: ast::NodeId) {\n     debug!(\"visit_fn\");\n \n     // swap in a new set of IR maps for this function body:\n@@ -379,7 +386,7 @@ fn visit_fn(ir: &mut IrMaps,\n     debug!(\"creating fn_maps: {:?}\", &fn_maps as *const IrMaps);\n \n     for arg in &decl.inputs {\n-        pat_util::pat_bindings(&arg.pat, |_bm, arg_id, _x, path1| {\n+        arg.pat.each_binding(|_bm, arg_id, _x, path1| {\n             debug!(\"adding argument {}\", arg_id);\n             let name = path1.node;\n             fn_maps.add_variable(Arg(arg_id, name));\n@@ -388,7 +395,7 @@ fn visit_fn(ir: &mut IrMaps,\n \n     // gather up the various local variables, significant expressions,\n     // and so forth:\n-    intravisit::walk_fn(&mut fn_maps, fk, decl, body, sp, id);\n+    intravisit::walk_fn(&mut fn_maps, fk, decl, body_id, sp, id);\n \n     // Special nodes and variables:\n     // - exit_ln represents the end of the fn, either by return or panic\n@@ -401,6 +408,8 @@ fn visit_fn(ir: &mut IrMaps,\n         clean_exit_var: fn_maps.add_variable(CleanExit)\n     };\n \n+    let body = ir.tcx.map.expr(body_id);\n+\n     // compute liveness\n     let mut lsets = Liveness::new(&mut fn_maps, specials);\n     let entry_ln = lsets.compute(body);\n@@ -411,8 +420,8 @@ fn visit_fn(ir: &mut IrMaps,\n     lsets.warn_about_unused_args(decl, entry_ln);\n }\n \n-fn visit_local(ir: &mut IrMaps, local: &hir::Local) {\n-    pat_util::pat_bindings(&local.pat, |_, p_id, sp, path1| {\n+fn visit_local<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, local: &'tcx hir::Local) {\n+    local.pat.each_binding(|_, p_id, sp, path1| {\n         debug!(\"adding local variable {}\", p_id);\n         let name = path1.node;\n         ir.add_live_node_for_node(p_id, VarDefNode(sp));\n@@ -424,9 +433,9 @@ fn visit_local(ir: &mut IrMaps, local: &hir::Local) {\n     intravisit::walk_local(ir, local);\n }\n \n-fn visit_arm(ir: &mut IrMaps, arm: &hir::Arm) {\n+fn visit_arm<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, arm: &'tcx hir::Arm) {\n     for pat in &arm.pats {\n-        pat_util::pat_bindings(&pat, |bm, p_id, sp, path1| {\n+        pat.each_binding(|bm, p_id, sp, path1| {\n             debug!(\"adding local variable {} from match with bm {:?}\",\n                    p_id, bm);\n             let name = path1.node;\n@@ -440,13 +449,12 @@ fn visit_arm(ir: &mut IrMaps, arm: &hir::Arm) {\n     intravisit::walk_arm(ir, arm);\n }\n \n-fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n+fn visit_expr<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, expr: &'tcx Expr) {\n     match expr.node {\n       // live nodes required for uses or definitions of variables:\n-      hir::ExprPath(..) => {\n-        let def = ir.tcx.expect_def(expr.id);\n-        debug!(\"expr {}: path that leads to {:?}\", expr.id, def);\n-        if let Def::Local(..) = def {\n+      hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+        debug!(\"expr {}: path that leads to {:?}\", expr.id, path.def);\n+        if let Def::Local(..) = path.def {\n             ir.add_live_node_for_node(expr.id, ExprNode(expr.span));\n         }\n         intravisit::walk_expr(ir, expr);\n@@ -495,7 +503,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       hir::ExprBlock(..) | hir::ExprAssign(..) | hir::ExprAssignOp(..) |\n       hir::ExprStruct(..) | hir::ExprRepeat(..) |\n       hir::ExprInlineAsm(..) | hir::ExprBox(..) |\n-      hir::ExprType(..) => {\n+      hir::ExprType(..) | hir::ExprPath(hir::QPath::TypeRelative(..)) => {\n           intravisit::walk_expr(ir, expr);\n       }\n     }\n@@ -587,7 +595,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn pat_bindings<F>(&mut self, pat: &hir::Pat, mut f: F) where\n         F: FnMut(&mut Liveness<'a, 'tcx>, LiveNode, Variable, Span, NodeId),\n     {\n-        pat_util::pat_bindings(pat, |_bm, p_id, sp, _n| {\n+        pat.each_binding(|_bm, p_id, sp, _n| {\n             let ln = self.live_node(p_id, sp);\n             let var = self.variable(p_id, sp);\n             f(self, ln, var, sp, p_id);\n@@ -684,22 +692,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn find_loop_scope(&self,\n-                       opt_label: Option<ast::Name>,\n-                       id: NodeId,\n+                       opt_label: Option<hir::Label>,\n                        sp: Span)\n                        -> NodeId {\n         match opt_label {\n-            Some(_) => {\n-                // Refers to a labeled loop. Use the results of resolve\n-                // to find with one\n-                match self.ir.tcx.expect_def(id) {\n-                    Def::Label(loop_id) => loop_id,\n-                    _ => span_bug!(sp, \"label on break/loop \\\n-                                        doesn't refer to a loop\")\n-                }\n-            }\n+            Some(label) => label.loop_id,\n             None => {\n-                // Vanilla 'break' or 'loop', so use the enclosing\n+                // Vanilla 'break' or 'continue', so use the enclosing\n                 // loop scope\n                 if self.loop_scope.is_empty() {\n                     span_bug!(sp, \"break outside loop\");\n@@ -922,8 +921,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         match expr.node {\n           // Interesting cases with control flow or which gen/kill\n \n-          hir::ExprPath(..) => {\n-              self.access_path(expr, succ, ACC_READ | ACC_USE)\n+          hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+              self.access_path(expr.id, path, succ, ACC_READ | ACC_USE)\n           }\n \n           hir::ExprField(ref e, _) => {\n@@ -934,7 +933,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               self.propagate_through_expr(&e, succ)\n           }\n \n-          hir::ExprClosure(.., ref blk, _) => {\n+          hir::ExprClosure(.., blk_id, _) => {\n               debug!(\"{} is an ExprClosure\",\n                      expr_to_string(expr));\n \n@@ -943,7 +942,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               loop. The next-node for a continue is the top of this loop.\n               */\n               let node = self.live_node(expr.id, expr.span);\n-              self.with_loop_nodes(blk.id, succ, node, |this| {\n+              self.with_loop_nodes(blk_id.node_id(), succ, node, |this| {\n \n                  // the construction of a closure itself is not important,\n                  // but we have to consider the closed over variables.\n@@ -1037,7 +1036,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprBreak(opt_label, ref opt_expr) => {\n               // Find which label this break jumps to\n-              let sc = self.find_loop_scope(opt_label.map(|l| l.node), expr.id, expr.span);\n+              let sc = self.find_loop_scope(opt_label, expr.span);\n \n               // Now that we know the label we're going to,\n               // look it up in the break loop nodes table\n@@ -1050,7 +1049,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprAgain(opt_label) => {\n               // Find which label this expr continues to\n-              let sc = self.find_loop_scope(opt_label.map(|l| l.node), expr.id, expr.span);\n+              let sc = self.find_loop_scope(opt_label, expr.span);\n \n               // Now that we know the label we're going to,\n               // look it up in the continue loop nodes table\n@@ -1171,7 +1170,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             self.propagate_through_exprs(inputs, succ)\n           }\n \n-          hir::ExprLit(..) => {\n+          hir::ExprLit(..) | hir::ExprPath(hir::QPath::TypeRelative(..)) => {\n             succ\n           }\n \n@@ -1235,7 +1234,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         // just ignore such cases and treat them as reads.\n \n         match expr.node {\n-            hir::ExprPath(..) => succ,\n+            hir::ExprPath(_) => succ,\n             hir::ExprField(ref e, _) => self.propagate_through_expr(&e, succ),\n             hir::ExprTupField(ref e, _) => self.propagate_through_expr(&e, succ),\n             _ => self.propagate_through_expr(expr, succ)\n@@ -1246,8 +1245,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     fn write_lvalue(&mut self, expr: &Expr, succ: LiveNode, acc: u32)\n                     -> LiveNode {\n         match expr.node {\n-          hir::ExprPath(..) => {\n-              self.access_path(expr, succ, acc)\n+          hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+              self.access_path(expr.id, path, succ, acc)\n           }\n \n           // We do not track other lvalues, so just propagate through\n@@ -1258,15 +1257,15 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    fn access_path(&mut self, expr: &Expr, succ: LiveNode, acc: u32)\n+    fn access_path(&mut self, id: NodeId, path: &hir::Path, succ: LiveNode, acc: u32)\n                    -> LiveNode {\n-        match self.ir.tcx.expect_def(expr.id) {\n+        match path.def {\n           Def::Local(def_id) => {\n             let nid = self.ir.tcx.map.as_local_node_id(def_id).unwrap();\n-            let ln = self.live_node(expr.id, expr.span);\n+            let ln = self.live_node(id, path.span);\n             if acc != 0 {\n                 self.init_from_succ(ln, succ);\n-                let var = self.variable(nid, expr.span);\n+                let var = self.variable(nid, path.span);\n                 self.acc(ln, var, acc);\n             }\n             ln\n@@ -1365,7 +1364,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n // _______________________________________________________________________\n // Checking for error conditions\n \n-fn check_local(this: &mut Liveness, local: &hir::Local) {\n+fn check_local<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, local: &'tcx hir::Local) {\n     match local.init {\n         Some(_) => {\n             this.warn_about_unused_or_dead_vars_in_pat(&local.pat);\n@@ -1380,7 +1379,7 @@ fn check_local(this: &mut Liveness, local: &hir::Local) {\n     intravisit::walk_local(this, local);\n }\n \n-fn check_arm(this: &mut Liveness, arm: &hir::Arm) {\n+fn check_arm<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, arm: &'tcx hir::Arm) {\n     // only consider the first pattern; any later patterns must have\n     // the same bindings, and we also consider the first pattern to be\n     // the \"authoritative\" set of ids\n@@ -1390,7 +1389,7 @@ fn check_arm(this: &mut Liveness, arm: &hir::Arm) {\n     intravisit::walk_arm(this, arm);\n }\n \n-fn check_expr(this: &mut Liveness, expr: &Expr) {\n+fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n     match expr.node {\n       hir::ExprAssign(ref l, _) => {\n         this.check_lvalue(&l);\n@@ -1431,8 +1430,8 @@ fn check_expr(this: &mut Liveness, expr: &Expr) {\n       hir::ExprBreak(..) | hir::ExprAgain(..) | hir::ExprLit(_) |\n       hir::ExprBlock(..) | hir::ExprAddrOf(..) |\n       hir::ExprStruct(..) | hir::ExprRepeat(..) |\n-      hir::ExprClosure(..) | hir::ExprPath(..) | hir::ExprBox(..) |\n-      hir::ExprType(..) => {\n+      hir::ExprClosure(..) | hir::ExprPath(_) |\n+      hir::ExprBox(..) | hir::ExprType(..) => {\n         intravisit::walk_expr(this, expr);\n       }\n     }\n@@ -1480,10 +1479,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    fn check_lvalue(&mut self, expr: &Expr) {\n+    fn check_lvalue(&mut self, expr: &'tcx Expr) {\n         match expr.node {\n-            hir::ExprPath(..) => {\n-                if let Def::Local(def_id) = self.ir.tcx.expect_def(expr.id) {\n+            hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+                if let Def::Local(def_id) = path.def {\n                     // Assignment to an immutable variable or argument: only legal\n                     // if there is no later assignment. If this local is actually\n                     // mutable, then check for a reassignment to flag the mutability\n@@ -1513,7 +1512,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn warn_about_unused_args(&self, decl: &hir::FnDecl, entry_ln: LiveNode) {\n         for arg in &decl.inputs {\n-            pat_util::pat_bindings(&arg.pat, |_bm, p_id, sp, path1| {\n+            arg.pat.each_binding(|_bm, p_id, sp, path1| {\n                 let var = self.variable(p_id, sp);\n                 // Ignore unused self.\n                 let name = path1.node;"}, {"sha": "4c3b102e540399f1c38d2f3b1b5841617a541ecd", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -488,8 +488,9 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n           }\n \n-          hir::ExprPath(..) => {\n-            self.cat_def(expr.id, expr.span, expr_ty, self.tcx().expect_def(expr.id))\n+          hir::ExprPath(ref qpath) => {\n+            let def = self.infcx.tables.borrow().qpath_def(qpath, expr.id);\n+            self.cat_def(expr.id, expr.span, expr_ty, def)\n           }\n \n           hir::ExprType(ref e, _) => {\n@@ -704,7 +705,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             };\n \n             match fn_expr.node {\n-                hir::ExprClosure(.., ref body, _) => body.id,\n+                hir::ExprClosure(.., body_id, _) => body_id.node_id(),\n                 _ => bug!()\n             }\n         };\n@@ -1062,24 +1063,32 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n \n         // Note: This goes up here (rather than within the PatKind::TupleStruct arm\n         // alone) because PatKind::Struct can also refer to variants.\n-        let cmt = match self.tcx().expect_def_or_none(pat.id) {\n-            Some(Def::Err) => return Err(()),\n-            Some(Def::Variant(variant_did)) |\n-            Some(Def::VariantCtor(variant_did, ..)) => {\n-                // univariant enums do not need downcasts\n-                let enum_did = self.tcx().parent_def_id(variant_did).unwrap();\n-                if !self.tcx().lookup_adt_def(enum_did).is_univariant() {\n-                    self.cat_downcast(pat, cmt.clone(), cmt.ty, variant_did)\n-                } else {\n-                    cmt\n+        let cmt = match pat.node {\n+            PatKind::Path(hir::QPath::Resolved(_, ref path)) |\n+            PatKind::TupleStruct(hir::QPath::Resolved(_, ref path), ..) |\n+            PatKind::Struct(hir::QPath::Resolved(_, ref path), ..) => {\n+                match path.def {\n+                    Def::Err => return Err(()),\n+                    Def::Variant(variant_did) |\n+                    Def::VariantCtor(variant_did, ..) => {\n+                        // univariant enums do not need downcasts\n+                        let enum_did = self.tcx().parent_def_id(variant_did).unwrap();\n+                        if !self.tcx().lookup_adt_def(enum_did).is_univariant() {\n+                            self.cat_downcast(pat, cmt.clone(), cmt.ty, variant_did)\n+                        } else {\n+                            cmt\n+                        }\n+                    }\n+                    _ => cmt\n                 }\n             }\n             _ => cmt\n         };\n \n         match pat.node {\n-          PatKind::TupleStruct(_, ref subpats, ddpos) => {\n-            let expected_len = match self.tcx().expect_def(pat.id) {\n+          PatKind::TupleStruct(ref qpath, ref subpats, ddpos) => {\n+            let def = self.infcx.tables.borrow().qpath_def(qpath, pat.id);\n+            let expected_len = match def {\n                 Def::VariantCtor(def_id, CtorKind::Fn) => {\n                     let enum_def = self.tcx().parent_def_id(def_id).unwrap();\n                     self.tcx().lookup_adt_def(enum_def).variant_with_id(def_id).fields.len()\n@@ -1157,7 +1166,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             }\n           }\n \n-          PatKind::Path(..) | PatKind::Binding(.., None) |\n+          PatKind::Path(_) | PatKind::Binding(.., None) |\n           PatKind::Lit(..) | PatKind::Range(..) | PatKind::Wild => {\n             // always ok\n           }"}, {"sha": "2c4710f1e452b6559c2709bfc55df0eb538b928e", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 68, "deletions": 46, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -28,7 +28,7 @@ use syntax::abi::Abi;\n use syntax::ast;\n use syntax::attr;\n use hir;\n-use hir::intravisit::Visitor;\n+use hir::intravisit::{Visitor, NestedVisitorMap};\n use hir::itemlikevisit::ItemLikeVisitor;\n use hir::intravisit;\n \n@@ -88,47 +88,46 @@ struct ReachableContext<'a, 'tcx: 'a> {\n     any_library: bool,\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for ReachableContext<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &hir::Expr) {\n-        match expr.node {\n-            hir::ExprPath(..) => {\n-                let def = self.tcx.expect_def(expr.id);\n-                let def_id = def.def_id();\n-                if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n-                    if self.def_id_represents_local_inlined_item(def_id) {\n-                        self.worklist.push(node_id);\n-                    } else {\n-                        match def {\n-                            // If this path leads to a constant, then we need to\n-                            // recurse into the constant to continue finding\n-                            // items that are reachable.\n-                            Def::Const(..) | Def::AssociatedConst(..) => {\n-                                self.worklist.push(node_id);\n-                            }\n+impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+    }\n \n-                            // If this wasn't a static, then the destination is\n-                            // surely reachable.\n-                            _ => {\n-                                self.reachable_symbols.insert(node_id);\n-                            }\n-                        }\n-                    }\n-                }\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n+        let def = match expr.node {\n+            hir::ExprPath(ref qpath) => {\n+                Some(self.tcx.tables().qpath_def(qpath, expr.id))\n             }\n             hir::ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(expr.id);\n-                let def_id = self.tcx.tables().method_map[&method_call].def_id;\n+                let def_id = self.tcx.tables.borrow().method_map[&method_call].def_id;\n+                Some(Def::Method(def_id))\n+            }\n+            _ => None\n+        };\n+\n+        if let Some(def) = def {\n+            let def_id = def.def_id();\n+            if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n+                if self.def_id_represents_local_inlined_item(def_id) {\n+                    self.worklist.push(node_id);\n+                } else {\n+                    match def {\n+                        // If this path leads to a constant, then we need to\n+                        // recurse into the constant to continue finding\n+                        // items that are reachable.\n+                        Def::Const(..) | Def::AssociatedConst(..) => {\n+                            self.worklist.push(node_id);\n+                        }\n \n-                // Mark the trait item (and, possibly, its default impl) as reachable\n-                // Or mark inherent impl item as reachable\n-                if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n-                    if self.def_id_represents_local_inlined_item(def_id) {\n-                        self.worklist.push(node_id)\n+                        // If this wasn't a static, then the destination is\n+                        // surely reachable.\n+                        _ => {\n+                            self.reachable_symbols.insert(node_id);\n+                        }\n                     }\n-                    self.reachable_symbols.insert(node_id);\n                 }\n             }\n-            _ => {}\n         }\n \n         intravisit::walk_expr(self, expr)\n@@ -221,7 +220,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         }\n     }\n \n-    fn propagate_node(&mut self, node: &ast_map::Node,\n+    fn propagate_node(&mut self, node: &ast_map::Node<'tcx>,\n                       search_item: ast::NodeId) {\n         if !self.any_library {\n             // If we are building an executable, only explicitly extern\n@@ -249,9 +248,9 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         match *node {\n             ast_map::NodeItem(item) => {\n                 match item.node {\n-                    hir::ItemFn(.., ref body) => {\n+                    hir::ItemFn(.., body) => {\n                         if item_might_be_inlined(&item) {\n-                            self.visit_expr(body);\n+                            self.visit_body(body);\n                         }\n                     }\n \n@@ -265,7 +264,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     // These are normal, nothing reachable about these\n                     // inherently and their children are already in the\n                     // worklist, as determined by the privacy pass\n-                    hir::ItemExternCrate(_) | hir::ItemUse(_) |\n+                    hir::ItemExternCrate(_) | hir::ItemUse(..) |\n                     hir::ItemTy(..) | hir::ItemStatic(..) |\n                     hir::ItemMod(..) | hir::ItemForeignMod(..) |\n                     hir::ItemImpl(..) | hir::ItemTrait(..) |\n@@ -279,10 +278,12 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::MethodTraitItem(_, None) => {\n                         // Keep going, nothing to get exported\n                     }\n-                    hir::ConstTraitItem(_, Some(ref body)) |\n-                    hir::MethodTraitItem(_, Some(ref body)) => {\n+                    hir::ConstTraitItem(_, Some(ref body)) => {\n                         self.visit_expr(body);\n                     }\n+                    hir::MethodTraitItem(_, Some(body_id)) => {\n+                        self.visit_body(body_id);\n+                    }\n                     hir::TypeTraitItem(..) => {}\n                 }\n             }\n@@ -291,10 +292,10 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::ImplItemKind::Const(_, ref expr) => {\n                         self.visit_expr(&expr);\n                     }\n-                    hir::ImplItemKind::Method(ref sig, ref body) => {\n+                    hir::ImplItemKind::Method(ref sig, body) => {\n                         let did = self.tcx.map.get_parent_did(search_item);\n                         if method_might_be_inlined(self.tcx, sig, impl_item, did) {\n-                            self.visit_expr(body)\n+                            self.visit_body(body)\n                         }\n                     }\n                     hir::ImplItemKind::Type(_) => {}\n@@ -303,7 +304,9 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             // Nothing to recurse on for these\n             ast_map::NodeForeignItem(_) |\n             ast_map::NodeVariant(_) |\n-            ast_map::NodeStructCtor(_) => {}\n+            ast_map::NodeStructCtor(_) |\n+            ast_map::NodeField(_) |\n+            ast_map::NodeTy(_) => {}\n             _ => {\n                 bug!(\"found unexpected thingy in worklist: {}\",\n                      self.tcx.map.node_to_string(search_item))\n@@ -320,19 +323,37 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n // items of non-exported traits (or maybe all local traits?) unless their respective\n // trait items are used from inlinable code through method call syntax or UFCS, or their\n // trait is a lang item.\n-struct CollectPrivateImplItemsVisitor<'a> {\n+struct CollectPrivateImplItemsVisitor<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     access_levels: &'a privacy::AccessLevels,\n     worklist: &'a mut Vec<ast::NodeId>,\n }\n \n-impl<'a, 'v> ItemLikeVisitor<'v> for CollectPrivateImplItemsVisitor<'a> {\n+impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         // We need only trait impls here, not inherent impls, and only non-exported ones\n-        if let hir::ItemImpl(.., Some(_), _, ref impl_item_refs) = item.node {\n+        if let hir::ItemImpl(.., Some(ref trait_ref), _, ref impl_item_refs) = item.node {\n             if !self.access_levels.is_reachable(item.id) {\n                 for impl_item_ref in impl_item_refs {\n                     self.worklist.push(impl_item_ref.id.node_id);\n                 }\n+\n+                let trait_def_id = match trait_ref.path.def {\n+                    Def::Trait(def_id) => def_id,\n+                    _ => unreachable!()\n+                };\n+\n+                if !trait_def_id.is_local() {\n+                    return\n+                }\n+\n+                for default_method in self.tcx.provided_trait_methods(trait_def_id) {\n+                    let node_id = self.tcx\n+                                      .map\n+                                      .as_local_node_id(default_method.def_id)\n+                                      .unwrap();\n+                    self.worklist.push(node_id);\n+                }\n             }\n         }\n     }\n@@ -366,6 +387,7 @@ pub fn find_reachable<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n     {\n         let mut collect_private_impl_items = CollectPrivateImplItemsVisitor {\n+            tcx: tcx,\n             access_levels: access_levels,\n             worklist: &mut reachable_context.worklist,\n         };"}, {"sha": "6c87f750376faaea4fd60d411edb8088bf45e83d", "filename": "src/librustc/middle/recursion_limit.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Frecursion_limit.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -18,20 +18,31 @@\n use session::Session;\n use syntax::ast;\n \n-pub fn update_recursion_limit(sess: &Session, krate: &ast::Crate) {\n+use std::cell::Cell;\n+\n+pub fn update_limits(sess: &Session, krate: &ast::Crate) {\n+    update_limit(sess, krate, &sess.recursion_limit, \"recursion_limit\",\n+                 \"recursion limit\");\n+    update_limit(sess, krate, &sess.type_length_limit, \"type_length_limit\",\n+                 \"type length limit\");\n+}\n+\n+fn update_limit(sess: &Session, krate: &ast::Crate, limit: &Cell<usize>,\n+                name: &str, description: &str) {\n     for attr in &krate.attrs {\n-        if !attr.check_name(\"recursion_limit\") {\n+        if !attr.check_name(name) {\n             continue;\n         }\n \n         if let Some(s) = attr.value_str() {\n             if let Some(n) = s.as_str().parse().ok() {\n-                sess.recursion_limit.set(n);\n+                limit.set(n);\n                 return;\n             }\n         }\n \n-        span_err!(sess, attr.span, E0296, \"malformed recursion limit attribute, \\\n-                                  expected #![recursion_limit=\\\"N\\\"]\");\n+        span_err!(sess, attr.span, E0296,\n+                  \"malformed {} attribute, expected #![{}=\\\"N\\\"]\",\n+                  description, name);\n     }\n }"}, {"sha": "b1e35e54eb9bb8c89a8c9a8e6bab0d257f74d0d8", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 53, "deletions": 43, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -31,7 +31,7 @@ use syntax::ast::{self, NodeId};\n use syntax_pos::Span;\n \n use hir;\n-use hir::intravisit::{self, Visitor, FnKind};\n+use hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n use hir::{Block, Item, FnDecl, Arm, Pat, PatKind, Stmt, Expr, Local};\n \n #[derive(Clone, PartialEq, PartialOrd, Eq, Ord, Hash, RustcEncodable,\n@@ -302,14 +302,16 @@ pub struct Context {\n     parent: CodeExtent\n }\n \n-struct RegionResolutionVisitor<'a> {\n+struct RegionResolutionVisitor<'ast: 'a, 'a> {\n     sess: &'a Session,\n \n     // Generated maps:\n     region_maps: &'a RegionMaps,\n \n     cx: Context,\n \n+    map: &'a ast_map::Map<'ast>,\n+\n     /// `terminating_scopes` is a set containing the ids of each\n     /// statement, or conditional/repeating expression. These scopes\n     /// are calling \"terminating scopes\" because, when attempting to\n@@ -660,7 +662,7 @@ fn record_var_lifetime(visitor: &mut RegionResolutionVisitor,\n     }\n }\n \n-fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &hir::Block) {\n+fn resolve_block<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, blk: &'tcx hir::Block) {\n     debug!(\"resolve_block(blk.id={:?})\", blk.id);\n \n     let prev_cx = visitor.cx;\n@@ -731,7 +733,7 @@ fn resolve_block(visitor: &mut RegionResolutionVisitor, blk: &hir::Block) {\n     visitor.cx = prev_cx;\n }\n \n-fn resolve_arm(visitor: &mut RegionResolutionVisitor, arm: &hir::Arm) {\n+fn resolve_arm<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, arm: &'tcx hir::Arm) {\n     visitor.terminating_scopes.insert(arm.body.id);\n \n     if let Some(ref expr) = arm.guard {\n@@ -741,7 +743,7 @@ fn resolve_arm(visitor: &mut RegionResolutionVisitor, arm: &hir::Arm) {\n     intravisit::walk_arm(visitor, arm);\n }\n \n-fn resolve_pat(visitor: &mut RegionResolutionVisitor, pat: &hir::Pat) {\n+fn resolve_pat<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, pat: &'tcx hir::Pat) {\n     visitor.new_node_extent(pat.id);\n \n     // If this is a binding then record the lifetime of that binding.\n@@ -752,7 +754,7 @@ fn resolve_pat(visitor: &mut RegionResolutionVisitor, pat: &hir::Pat) {\n     intravisit::walk_pat(visitor, pat);\n }\n \n-fn resolve_stmt(visitor: &mut RegionResolutionVisitor, stmt: &hir::Stmt) {\n+fn resolve_stmt<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, stmt: &'tcx hir::Stmt) {\n     let stmt_id = stmt.node.id();\n     debug!(\"resolve_stmt(stmt.id={:?})\", stmt_id);\n \n@@ -770,7 +772,7 @@ fn resolve_stmt(visitor: &mut RegionResolutionVisitor, stmt: &hir::Stmt) {\n     visitor.cx.parent = prev_parent;\n }\n \n-fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &hir::Expr) {\n+fn resolve_expr<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>, expr: &'tcx hir::Expr) {\n     debug!(\"resolve_expr(expr.id={:?})\", expr.id);\n \n     let expr_extent = visitor.new_node_extent_with_dtor(expr.id);\n@@ -848,7 +850,8 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &hir::Expr) {\n     visitor.cx = prev_cx;\n }\n \n-fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &hir::Local) {\n+fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n+                           local: &'tcx hir::Local) {\n     debug!(\"resolve_local(local.id={:?},local.init={:?})\",\n            local.id,local.init.is_some());\n \n@@ -1063,7 +1066,11 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &hir::Local) {\n     }\n }\n \n-fn resolve_item(visitor: &mut RegionResolutionVisitor, item: &hir::Item) {\n+fn resolve_item_like<'a, 'tcx, F>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n+                                  id: ast::NodeId,\n+                                  walk: F)\n+    where F: FnOnce(&mut RegionResolutionVisitor<'tcx, 'a>)\n+{\n     // Items create a new outer block scope as far as we're concerned.\n     let prev_cx = visitor.cx;\n     let prev_ts = mem::replace(&mut visitor.terminating_scopes, NodeSet());\n@@ -1072,44 +1079,44 @@ fn resolve_item(visitor: &mut RegionResolutionVisitor, item: &hir::Item) {\n         var_parent: ROOT_CODE_EXTENT,\n         parent: ROOT_CODE_EXTENT\n     };\n-    intravisit::walk_item(visitor, item);\n-    visitor.create_item_scope_if_needed(item.id);\n+    walk(visitor);\n+    visitor.create_item_scope_if_needed(id);\n     visitor.cx = prev_cx;\n     visitor.terminating_scopes = prev_ts;\n }\n \n-fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n-              kind: FnKind,\n-              decl: &hir::FnDecl,\n-              body: &hir::Expr,\n-              sp: Span,\n-              id: ast::NodeId) {\n+fn resolve_fn<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'tcx, 'a>,\n+                        kind: FnKind<'tcx>,\n+                        decl: &'tcx hir::FnDecl,\n+                        body_id: hir::ExprId,\n+                        sp: Span,\n+                        id: ast::NodeId) {\n     debug!(\"region::resolve_fn(id={:?}, \\\n                                span={:?}, \\\n                                body.id={:?}, \\\n                                cx.parent={:?})\",\n            id,\n            visitor.sess.codemap().span_to_string(sp),\n-           body.id,\n+           body_id,\n            visitor.cx.parent);\n \n     visitor.cx.parent = visitor.new_code_extent(\n-        CodeExtentData::CallSiteScope { fn_id: id, body_id: body.id });\n+        CodeExtentData::CallSiteScope { fn_id: id, body_id: body_id.node_id() });\n \n     let fn_decl_scope = visitor.new_code_extent(\n-        CodeExtentData::ParameterScope { fn_id: id, body_id: body.id });\n+        CodeExtentData::ParameterScope { fn_id: id, body_id: body_id.node_id() });\n \n     if let Some(root_id) = visitor.cx.root_id {\n-        visitor.region_maps.record_fn_parent(body.id, root_id);\n+        visitor.region_maps.record_fn_parent(body_id.node_id(), root_id);\n     }\n \n     let outer_cx = visitor.cx;\n     let outer_ts = mem::replace(&mut visitor.terminating_scopes, NodeSet());\n-    visitor.terminating_scopes.insert(body.id);\n+    visitor.terminating_scopes.insert(body_id.node_id());\n \n     // The arguments and `self` are parented to the fn.\n     visitor.cx = Context {\n-        root_id: Some(body.id),\n+        root_id: Some(body_id.node_id()),\n         parent: ROOT_CODE_EXTENT,\n         var_parent: fn_decl_scope,\n     };\n@@ -1119,18 +1126,18 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n \n     // The body of the every fn is a root scope.\n     visitor.cx = Context {\n-        root_id: Some(body.id),\n+        root_id: Some(body_id.node_id()),\n         parent: fn_decl_scope,\n         var_parent: fn_decl_scope\n     };\n-    visitor.visit_expr(body);\n+    visitor.visit_body(body_id);\n \n     // Restore context we had at the start.\n     visitor.cx = outer_cx;\n     visitor.terminating_scopes = outer_ts;\n }\n \n-impl<'a> RegionResolutionVisitor<'a> {\n+impl<'ast, 'a> RegionResolutionVisitor<'ast, 'a> {\n     /// Records the current parent (if any) as the parent of `child_scope`.\n     fn new_code_extent(&mut self, child_scope: CodeExtentData) -> CodeExtent {\n         self.region_maps.intern_code_extent(child_scope, self.cx.parent)\n@@ -1166,42 +1173,44 @@ impl<'a> RegionResolutionVisitor<'a> {\n     }\n }\n \n-impl<'a, 'v> Visitor<'v> for RegionResolutionVisitor<'a> {\n-    fn visit_block(&mut self, b: &Block) {\n+impl<'ast, 'a> Visitor<'ast> for RegionResolutionVisitor<'ast, 'a> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'ast> {\n+        NestedVisitorMap::OnlyBodies(&self.map)\n+    }\n+\n+    fn visit_block(&mut self, b: &'ast Block) {\n         resolve_block(self, b);\n     }\n \n-    fn visit_item(&mut self, i: &Item) {\n-        resolve_item(self, i);\n+    fn visit_item(&mut self, i: &'ast Item) {\n+        resolve_item_like(self, i.id, |this| intravisit::walk_item(this, i));\n     }\n \n-    fn visit_impl_item(&mut self, ii: &hir::ImplItem) {\n-        intravisit::walk_impl_item(self, ii);\n-        self.create_item_scope_if_needed(ii.id);\n+    fn visit_impl_item(&mut self, ii: &'ast hir::ImplItem) {\n+        resolve_item_like(self, ii.id, |this| intravisit::walk_impl_item(this, ii));\n     }\n \n-    fn visit_trait_item(&mut self, ti: &hir::TraitItem) {\n-        intravisit::walk_trait_item(self, ti);\n-        self.create_item_scope_if_needed(ti.id);\n+    fn visit_trait_item(&mut self, ti: &'ast hir::TraitItem) {\n+        resolve_item_like(self, ti.id, |this| intravisit::walk_trait_item(this, ti));\n     }\n \n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v FnDecl,\n-                b: &'v Expr, s: Span, n: NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'ast>, fd: &'ast FnDecl,\n+                b: hir::ExprId, s: Span, n: NodeId) {\n         resolve_fn(self, fk, fd, b, s, n);\n     }\n-    fn visit_arm(&mut self, a: &Arm) {\n+    fn visit_arm(&mut self, a: &'ast Arm) {\n         resolve_arm(self, a);\n     }\n-    fn visit_pat(&mut self, p: &Pat) {\n+    fn visit_pat(&mut self, p: &'ast Pat) {\n         resolve_pat(self, p);\n     }\n-    fn visit_stmt(&mut self, s: &Stmt) {\n+    fn visit_stmt(&mut self, s: &'ast Stmt) {\n         resolve_stmt(self, s);\n     }\n-    fn visit_expr(&mut self, ex: &Expr) {\n+    fn visit_expr(&mut self, ex: &'ast Expr) {\n         resolve_expr(self, ex);\n     }\n-    fn visit_local(&mut self, l: &Local) {\n+    fn visit_local(&mut self, l: &'ast Local) {\n         resolve_local(self, l);\n     }\n }\n@@ -1228,6 +1237,7 @@ pub fn resolve_crate(sess: &Session, map: &ast_map::Map) -> RegionMaps {\n         let mut visitor = RegionResolutionVisitor {\n             sess: sess,\n             region_maps: &maps,\n+            map: map,\n             cx: Context {\n                 root_id: None,\n                 parent: ROOT_CODE_EXTENT,"}, {"sha": "c5b03a4a32add5b64a3a0309b6d3979cf39e4edb", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 30, "deletions": 21, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -21,7 +21,7 @@ use self::ScopeChain::*;\n use dep_graph::DepNode;\n use hir::map::Map;\n use session::Session;\n-use hir::def::{Def, DefMap};\n+use hir::def::Def;\n use hir::def_id::DefId;\n use middle::region;\n use ty;\n@@ -34,7 +34,7 @@ use util::nodemap::NodeMap;\n use rustc_data_structures::fx::FxHashSet;\n use hir;\n use hir::print::lifetime_to_string;\n-use hir::intravisit::{self, Visitor, FnKind};\n+use hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub enum DefRegion {\n@@ -65,7 +65,6 @@ struct LifetimeContext<'a, 'tcx: 'a> {\n     hir_map: &'a Map<'tcx>,\n     map: &'a mut NamedRegionMap,\n     scope: Scope<'a>,\n-    def_map: &'a DefMap,\n     // Deep breath. Our representation for poly trait refs contains a single\n     // binder and thus we only allow a single level of quantification. However,\n     // the syntax of Rust permits quantification in two places, e.g., `T: for <'a> Foo<'a>`\n@@ -109,8 +108,7 @@ type Scope<'a> = &'a ScopeChain<'a>;\n static ROOT_SCOPE: ScopeChain<'static> = RootScope;\n \n pub fn krate(sess: &Session,\n-             hir_map: &Map,\n-             def_map: &DefMap)\n+             hir_map: &Map)\n              -> Result<NamedRegionMap, usize> {\n     let _task = hir_map.dep_graph.in_task(DepNode::ResolveLifetimes);\n     let krate = hir_map.krate();\n@@ -124,7 +122,6 @@ pub fn krate(sess: &Session,\n             hir_map: hir_map,\n             map: &mut map,\n             scope: &ROOT_SCOPE,\n-            def_map: def_map,\n             trait_ref_hack: false,\n             labels_in_fn: vec![],\n         }, krate);\n@@ -135,8 +132,8 @@ pub fn krate(sess: &Session,\n impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     // Override the nested functions -- lifetimes follow lexical scope,\n     // so it's convenient to walk the tree in lexical order.\n-    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n-        Some(&self.hir_map)\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.hir_map)\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n@@ -151,7 +148,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     intravisit::walk_item(this, item);\n                 }\n                 hir::ItemExternCrate(_) |\n-                hir::ItemUse(_) |\n+                hir::ItemUse(..) |\n                 hir::ItemMod(..) |\n                 hir::ItemDefaultImpl(..) |\n                 hir::ItemForeignMod(..) |\n@@ -209,7 +206,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_fn(&mut self, fk: FnKind<'tcx>, decl: &'tcx hir::FnDecl,\n-                b: &'tcx hir::Expr, s: Span, fn_id: ast::NodeId) {\n+                b: hir::ExprId, s: Span, fn_id: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(_, generics, ..) => {\n                 self.visit_early_late(fn_id,decl, generics, |this| {\n@@ -244,11 +241,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     intravisit::walk_ty(this, ty);\n                 });\n             }\n-            hir::TyPath(None, ref path) => {\n+            hir::TyPath(hir::QPath::Resolved(None, ref path)) => {\n                 // if this path references a trait, then this will resolve to\n                 // a trait ref, which introduces a binding scope.\n-                match self.def_map.get(&ty.id).map(|d| (d.base_def, d.depth)) {\n-                    Some((Def::Trait(..), 0)) => {\n+                match path.def {\n+                    Def::Trait(..) => {\n                         self.with(LateScope(&[], self.scope), |_, this| {\n                             this.visit_path(path, ty.id);\n                         });\n@@ -410,7 +407,7 @@ fn signal_shadowing_problem(sess: &Session, name: ast::Name, orig: Original, sha\n \n // Adds all labels in `b` to `ctxt.labels_in_fn`, signalling a warning\n // if one of the label shadows a lifetime or another label.\n-fn extract_labels(ctxt: &mut LifetimeContext, b: &hir::Expr) {\n+fn extract_labels(ctxt: &mut LifetimeContext, b: hir::ExprId) {\n     struct GatherLabels<'a> {\n         sess: &'a Session,\n         scope: Scope<'a>,\n@@ -422,10 +419,14 @@ fn extract_labels(ctxt: &mut LifetimeContext, b: &hir::Expr) {\n         scope: ctxt.scope,\n         labels_in_fn: &mut ctxt.labels_in_fn,\n     };\n-    gather.visit_expr(b);\n+    gather.visit_expr(ctxt.hir_map.expr(b));\n     return;\n \n     impl<'v, 'a> Visitor<'v> for GatherLabels<'a> {\n+        fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v> {\n+            NestedVisitorMap::None\n+        }\n+\n         fn visit_expr(&mut self, ex: &'v hir::Expr) {\n             // do not recurse into closures defined in the block\n             // since they are treated as separate fns from the POV of\n@@ -500,7 +501,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     fn add_scope_and_walk_fn(&mut self,\n                              fk: FnKind<'tcx>,\n                              fd: &'tcx hir::FnDecl,\n-                             fb: &'tcx hir::Expr,\n+                             fb: hir::ExprId,\n                              _span: Span,\n                              fn_id: ast::NodeId) {\n         match fk {\n@@ -521,8 +522,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // `self.labels_in_fn`.\n         extract_labels(self, fb);\n \n-        self.with(FnScope { fn_id: fn_id, body_id: fb.id, s: self.scope },\n-                  |_old_scope, this| this.visit_expr(fb))\n+        self.with(FnScope { fn_id: fn_id, body_id: fb.node_id(), s: self.scope },\n+                  |_old_scope, this| this.visit_body(fb))\n     }\n \n     // FIXME(#37666) this works around a limitation in the region inferencer\n@@ -541,7 +542,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             hir_map: hir_map,\n             map: *map,\n             scope: &wrap_scope,\n-            def_map: self.def_map,\n             trait_ref_hack: self.trait_ref_hack,\n             labels_in_fn: self.labels_in_fn.clone(),\n         };\n@@ -942,15 +942,20 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n     }\n \n     impl<'v> Visitor<'v> for ConstrainedCollector {\n+        fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v> {\n+            NestedVisitorMap::None\n+        }\n+\n         fn visit_ty(&mut self, ty: &'v hir::Ty) {\n             match ty.node {\n-                hir::TyPath(Some(_), _) => {\n+                hir::TyPath(hir::QPath::Resolved(Some(_), _)) |\n+                hir::TyPath(hir::QPath::TypeRelative(..)) => {\n                     // ignore lifetimes appearing in associated type\n                     // projections, as they are not *constrained*\n                     // (defined above)\n                 }\n \n-                hir::TyPath(None, ref path) => {\n+                hir::TyPath(hir::QPath::Resolved(None, ref path)) => {\n                     // consider only the lifetimes on the final\n                     // segment; I am not sure it's even currently\n                     // valid to have them elsewhere, but even if it\n@@ -978,6 +983,10 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n     }\n \n     impl<'v> Visitor<'v> for AllCollector {\n+        fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v> {\n+            NestedVisitorMap::None\n+        }\n+\n         fn visit_lifetime(&mut self, lifetime_ref: &'v hir::Lifetime) {\n             self.regions.insert(lifetime_ref.name);\n         }"}, {"sha": "3e32957aecfe07ab60fc0d8d5edf5685602e7d5b", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 208, "deletions": 307, "changes": 515, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -15,11 +15,10 @@ pub use self::StabilityLevel::*;\n \n use dep_graph::DepNode;\n use hir::map as hir_map;\n-use session::Session;\n use lint;\n use hir::def::Def;\n use hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, DefIndex, LOCAL_CRATE};\n-use ty::{self, TyCtxt, AdtKind};\n+use ty::TyCtxt;\n use middle::privacy::AccessLevels;\n use syntax::symbol::Symbol;\n use syntax_pos::{Span, DUMMY_SP};\n@@ -30,9 +29,8 @@ use syntax::attr::{self, Stability, Deprecation};\n use util::nodemap::{DefIdMap, FxHashSet, FxHashMap};\n \n use hir;\n-use hir::{Item, Generics, StructField, Variant, PatKind};\n-use hir::intravisit::{self, Visitor};\n-use hir::pat_util::EnumerateAndAdjustIterator;\n+use hir::{Item, Generics, StructField, Variant};\n+use hir::intravisit::{self, Visitor, NestedVisitorMap};\n \n use std::mem::replace;\n use std::cmp::Ordering;\n@@ -101,7 +99,13 @@ pub struct Index<'tcx> {\n     depr_map: DefIdMap<Option<DeprecationEntry>>,\n \n     /// Maps for each crate whether it is part of the staged API.\n-    staged_api: FxHashMap<CrateNum, bool>\n+    staged_api: FxHashMap<CrateNum, bool>,\n+\n+    /// Features enabled for this crate.\n+    active_features: FxHashSet<Symbol>,\n+\n+    /// Features used by this crate. Updated before and during typeck.\n+    used_features: FxHashMap<Symbol, attr::StabilityLevel>\n }\n \n // A private tree-walker for producing an Index.\n@@ -110,7 +114,6 @@ struct Annotator<'a, 'tcx: 'a> {\n     index: &'a mut Index<'tcx>,\n     parent_stab: Option<&'tcx Stability>,\n     parent_depr: Option<DeprecationEntry>,\n-    access_levels: &'a AccessLevels,\n     in_trait_impl: bool,\n }\n \n@@ -183,20 +186,12 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n                 self.parent_stab = orig_parent_stab;\n             } else {\n                 debug!(\"annotate: not found, parent = {:?}\", self.parent_stab);\n-                let mut is_error = kind == AnnotationKind::Required &&\n-                                   self.access_levels.is_reachable(id) &&\n-                                   !self.tcx.sess.opts.test;\n                 if let Some(stab) = self.parent_stab {\n                     if stab.level.is_unstable() {\n                         let def_id = self.tcx.map.local_def_id(id);\n                         self.index.stab_map.insert(def_id, Some(stab));\n-                        is_error = false;\n                     }\n                 }\n-                if is_error {\n-                    self.tcx.sess.span_err(item_sp, \"This node does not have \\\n-                                                     a stability attribute\");\n-                }\n                 visit_children(self);\n             }\n         } else {\n@@ -238,8 +233,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n     /// Because stability levels are scoped lexically, we want to walk\n     /// nested items in the context of the outer item, so enable\n     /// deep-walking.\n-    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n-        Some(&self.tcx.map)\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.tcx.map)\n     }\n \n     fn visit_item(&mut self, i: &'tcx Item) {\n@@ -313,17 +308,92 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n     }\n }\n \n+struct MissingStabilityAnnotations<'a, 'tcx: 'a> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    access_levels: &'a AccessLevels,\n+}\n+\n+impl<'a, 'tcx: 'a> MissingStabilityAnnotations<'a, 'tcx> {\n+    fn check_missing_stability(&self, id: NodeId, span: Span) {\n+        let def_id = self.tcx.map.local_def_id(id);\n+        let is_error = !self.tcx.sess.opts.test &&\n+                        !self.tcx.stability.borrow().stab_map.contains_key(&def_id) &&\n+                        self.access_levels.is_reachable(id);\n+        if is_error {\n+            self.tcx.sess.span_err(span, \"This node does not have a stability attribute\");\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+    }\n+\n+    fn visit_item(&mut self, i: &'tcx Item) {\n+        match i.node {\n+            // Inherent impls and foreign modules serve only as containers for other items,\n+            // they don't have their own stability. They still can be annotated as unstable\n+            // and propagate this unstability to children, but this annotation is completely\n+            // optional. They inherit stability from their parents when unannotated.\n+            hir::ItemImpl(.., None, _, _) | hir::ItemForeignMod(..) => {}\n+\n+            _ => self.check_missing_stability(i.id, i.span)\n+        }\n+\n+        intravisit::walk_item(self, i)\n+    }\n+\n+    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n+        self.check_missing_stability(ti.id, ti.span);\n+        intravisit::walk_trait_item(self, ti);\n+    }\n+\n+    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n+        let impl_def_id = self.tcx.map.local_def_id(self.tcx.map.get_parent(ii.id));\n+        if self.tcx.impl_trait_ref(impl_def_id).is_none() {\n+            self.check_missing_stability(ii.id, ii.span);\n+        }\n+        intravisit::walk_impl_item(self, ii);\n+    }\n+\n+    fn visit_variant(&mut self, var: &'tcx Variant, g: &'tcx Generics, item_id: NodeId) {\n+        self.check_missing_stability(var.node.data.id(), var.span);\n+        intravisit::walk_variant(self, var, g, item_id);\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &'tcx StructField) {\n+        self.check_missing_stability(s.id, s.span);\n+        intravisit::walk_struct_field(self, s);\n+    }\n+\n+    fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem) {\n+        self.check_missing_stability(i.id, i.span);\n+        intravisit::walk_foreign_item(self, i);\n+    }\n+\n+    fn visit_macro_def(&mut self, md: &'tcx hir::MacroDef) {\n+        if md.imported_from.is_none() {\n+            self.check_missing_stability(md.id, md.span);\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> Index<'tcx> {\n     /// Construct the stability index for a crate being compiled.\n-    pub fn build(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>, access_levels: &AccessLevels) {\n+    pub fn build(&mut self, tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+        let ref active_lib_features = tcx.sess.features.borrow().declared_lib_features;\n+\n+        // Put the active features into a map for quick lookup\n+        self.active_features = active_lib_features.iter().map(|&(ref s, _)| s.clone()).collect();\n+\n         let _task = tcx.dep_graph.in_task(DepNode::StabilityIndex);\n         let krate = tcx.map.krate();\n         let mut annotator = Annotator {\n             tcx: tcx,\n             index: self,\n             parent_stab: None,\n             parent_depr: None,\n-            access_levels: access_levels,\n             in_trait_impl: false,\n         };\n         annotator.annotate(ast::CRATE_NODE_ID, &krate.attrs, krate.span, AnnotationKind::Required,\n@@ -348,96 +418,102 @@ impl<'a, 'tcx> Index<'tcx> {\n             staged_api: staged_api,\n             stab_map: DefIdMap(),\n             depr_map: DefIdMap(),\n+            active_features: FxHashSet(),\n+            used_features: FxHashMap(),\n         }\n     }\n }\n \n /// Cross-references the feature names of unstable APIs with enabled\n-/// features and possibly prints errors. Returns a list of all\n-/// features used.\n-pub fn check_unstable_api_usage<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                                          -> FxHashMap<Symbol, attr::StabilityLevel> {\n-    let _task = tcx.dep_graph.in_task(DepNode::StabilityCheck);\n-    let ref active_lib_features = tcx.sess.features.borrow().declared_lib_features;\n-\n-    // Put the active features into a map for quick lookup\n-    let active_features = active_lib_features.iter().map(|&(ref s, _)| s.clone()).collect();\n-\n-    let mut checker = Checker {\n-        tcx: tcx,\n-        active_features: active_features,\n-        used_features: FxHashMap(),\n-        in_skip_block: 0,\n-    };\n-    intravisit::walk_crate(&mut checker, tcx.map.krate());\n-\n-    checker.used_features\n+/// features and possibly prints errors.\n+pub fn check_unstable_api_usage<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n+    let mut checker = Checker { tcx: tcx };\n+    tcx.visit_all_item_likes_in_krate(DepNode::StabilityCheck, &mut checker.as_deep_visitor());\n }\n \n struct Checker<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    active_features: FxHashSet<Symbol>,\n-    used_features: FxHashMap<Symbol, attr::StabilityLevel>,\n-    // Within a block where feature gate checking can be skipped.\n-    in_skip_block: u32,\n }\n \n-impl<'a, 'tcx> Checker<'a, 'tcx> {\n-    fn check(&mut self, id: DefId, span: Span,\n-             stab: &Option<&Stability>, _depr: &Option<DeprecationEntry>) {\n-        if !is_staged_api(self.tcx, id) {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    pub fn check_stability(self, def_id: DefId, id: NodeId, span: Span) {\n+        if self.sess.codemap().span_allows_unstable(span) {\n+            debug!(\"stability: \\\n+                    skipping span={:?} since it is internal\", span);\n             return;\n         }\n+\n+        let lint_deprecated = |note: Option<Symbol>| {\n+            let msg = if let Some(note) = note {\n+                format!(\"use of deprecated item: {}\", note)\n+            } else {\n+                format!(\"use of deprecated item\")\n+            };\n+\n+            self.sess.add_lint(lint::builtin::DEPRECATED, id, span, msg);\n+        };\n+\n+        // Deprecated attributes apply in-crate and cross-crate.\n+        if let Some(depr_entry) = self.lookup_deprecation_entry(def_id) {\n+            let skip = if id == ast::DUMMY_NODE_ID {\n+                true\n+            } else {\n+                let parent_def_id = self.map.local_def_id(self.map.get_parent(id));\n+                self.lookup_deprecation_entry(parent_def_id).map_or(false, |parent_depr| {\n+                    parent_depr.same_origin(&depr_entry)\n+                })\n+            };\n+\n+            if !skip {\n+                lint_deprecated(depr_entry.attr.note);\n+            }\n+        }\n+\n+        let is_staged_api = *self.stability.borrow_mut().staged_api.entry(def_id.krate)\n+            .or_insert_with(|| self.sess.cstore.is_staged_api(def_id.krate));\n+        if !is_staged_api {\n+            return;\n+        }\n+\n+        let stability = self.lookup_stability(def_id);\n+        debug!(\"stability: \\\n+                inspecting def_id={:?} span={:?} of stability={:?}\", def_id, span, stability);\n+\n+        if let Some(&Stability{rustc_depr: Some(attr::RustcDeprecation { reason, .. }), ..})\n+                = stability {\n+            if id != ast::DUMMY_NODE_ID {\n+                lint_deprecated(Some(reason));\n+            }\n+        }\n+\n         // Only the cross-crate scenario matters when checking unstable APIs\n-        let cross_crate = !id.is_local();\n+        let cross_crate = !def_id.is_local();\n         if !cross_crate {\n             return\n         }\n \n-        // We don't need to check for stability - presumably compiler generated code.\n-        if self.in_skip_block > 0 {\n-            return;\n+        if let Some(&Stability { ref level, ref feature, .. }) = stability {\n+            self.stability.borrow_mut().used_features.insert(feature.clone(), level.clone());\n         }\n \n-        match *stab {\n+        match stability {\n             Some(&Stability { level: attr::Unstable {ref reason, issue}, ref feature, .. }) => {\n-                self.used_features.insert(feature.clone(),\n-                                          attr::Unstable { reason: reason.clone(), issue: issue });\n-\n-                if !self.active_features.contains(feature) {\n+                if !self.stability.borrow().active_features.contains(feature) {\n                     let msg = match *reason {\n                         Some(ref r) => format!(\"use of unstable library feature '{}': {}\",\n                                                &feature.as_str(), &r),\n                         None => format!(\"use of unstable library feature '{}'\", &feature)\n                     };\n-                    emit_feature_err(&self.tcx.sess.parse_sess, &feature.as_str(), span,\n+                    emit_feature_err(&self.sess.parse_sess, &feature.as_str(), span,\n                                      GateIssue::Library(Some(issue)), &msg);\n                 }\n             }\n-            Some(&Stability { ref level, ref feature, .. }) => {\n-                self.used_features.insert(feature.clone(), level.clone());\n-\n+            Some(_) => {\n                 // Stable APIs are always ok to call and deprecated APIs are\n-                // handled by a lint.\n+                // handled by the lint emitting logic above.\n             }\n             None => {\n-                // This is an 'unmarked' API, which should not exist\n-                // in the standard library.\n-                if self.tcx.sess.features.borrow().unmarked_api {\n-                    self.tcx.sess.struct_span_warn(span, \"use of unmarked library feature\")\n-                                 .span_note(span, \"this is either a bug in the library you are \\\n-                                                   using or a bug in the compiler - please \\\n-                                                   report it in both places\")\n-                                 .emit()\n-                } else {\n-                    self.tcx.sess.struct_span_err(span, \"use of unmarked library feature\")\n-                                 .span_note(span, \"this is either a bug in the library you are \\\n-                                                   using or a bug in the compiler - please \\\n-                                                   report it in both places\")\n-                                 .span_note(span, \"use #![feature(unmarked_api)] in the \\\n-                                                   crate attributes to override this\")\n-                                 .emit()\n-                }\n+                span_bug!(span, \"encountered unmarked API\");\n             }\n         }\n     }\n@@ -447,248 +523,59 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n     /// Because stability levels are scoped lexically, we want to walk\n     /// nested items in the context of the outer item, so enable\n     /// deep-walking.\n-    fn nested_visit_map(&mut self) -> Option<&hir::map::Map<'tcx>> {\n-        Some(&self.tcx.map)\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        // When compiling with --test we don't enforce stability on the\n-        // compiler-generated test module, demarcated with `DUMMY_SP` plus the\n-        // name `__test`\n-        if item.span == DUMMY_SP && item.name == \"__test\" { return }\n-\n-        check_item(self.tcx, item, true,\n-                   &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n-        intravisit::walk_item(self, item);\n-    }\n-\n-    fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n-        check_expr(self.tcx, ex,\n-                   &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n-        intravisit::walk_expr(self, ex);\n-    }\n-\n-    fn visit_path(&mut self, path: &'tcx hir::Path, id: ast::NodeId) {\n-        check_path(self.tcx, path, id,\n-                   &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n-        intravisit::walk_path(self, path)\n-    }\n-\n-    fn visit_path_list_item(&mut self, prefix: &'tcx hir::Path, item: &'tcx hir::PathListItem) {\n-        check_path_list_item(self.tcx, item,\n-                   &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n-        intravisit::walk_path_list_item(self, prefix, item)\n-    }\n-\n-    fn visit_pat(&mut self, pat: &'tcx hir::Pat) {\n-        check_pat(self.tcx, pat,\n-                  &mut |id, sp, stab, depr| self.check(id, sp, stab, depr));\n-        intravisit::walk_pat(self, pat)\n-    }\n-\n-    fn visit_block(&mut self, b: &'tcx hir::Block) {\n-        let old_skip_count = self.in_skip_block;\n-        match b.rules {\n-            hir::BlockCheckMode::PushUnstableBlock => {\n-                self.in_skip_block += 1;\n+        match item.node {\n+            hir::ItemExternCrate(_) => {\n+                // compiler-generated `extern crate` items have a dummy span.\n+                if item.span == DUMMY_SP { return }\n+\n+                let cnum = match self.tcx.sess.cstore.extern_mod_stmt_cnum(item.id) {\n+                    Some(cnum) => cnum,\n+                    None => return,\n+                };\n+                let def_id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n+                self.tcx.check_stability(def_id, item.id, item.span);\n             }\n-            hir::BlockCheckMode::PopUnstableBlock => {\n-                self.in_skip_block = self.in_skip_block.checked_sub(1).unwrap();\n-            }\n-            _ => {}\n-        }\n-        intravisit::walk_block(self, b);\n-        self.in_skip_block = old_skip_count;\n-    }\n-}\n \n-/// Helper for discovering nodes to check for stability\n-pub fn check_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            item: &hir::Item,\n-                            warn_about_defns: bool,\n-                            cb: &mut FnMut(DefId, Span,\n-                                           &Option<&Stability>,\n-                                           &Option<DeprecationEntry>)) {\n-    match item.node {\n-        hir::ItemExternCrate(_) => {\n-            // compiler-generated `extern crate` items have a dummy span.\n-            if item.span == DUMMY_SP { return }\n-\n-            let cnum = match tcx.sess.cstore.extern_mod_stmt_cnum(item.id) {\n-                Some(cnum) => cnum,\n-                None => return,\n-            };\n-            let id = DefId { krate: cnum, index: CRATE_DEF_INDEX };\n-            maybe_do_stability_check(tcx, id, item.span, cb);\n-        }\n-\n-        // For implementations of traits, check the stability of each item\n-        // individually as it's possible to have a stable trait with unstable\n-        // items.\n-        hir::ItemImpl(.., Some(ref t), _, ref impl_item_refs) => {\n-            let trait_did = tcx.expect_def(t.ref_id).def_id();\n-            for impl_item_ref in impl_item_refs {\n-                let impl_item = tcx.map.impl_item(impl_item_ref.id);\n-                let item = tcx.associated_items(trait_did)\n-                    .find(|item| item.name == impl_item.name).unwrap();\n-                if warn_about_defns {\n-                    maybe_do_stability_check(tcx, item.def_id, impl_item.span, cb);\n-                }\n-            }\n-        }\n-\n-        _ => (/* pass */)\n-    }\n-}\n-\n-/// Helper for discovering nodes to check for stability\n-pub fn check_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, e: &hir::Expr,\n-                            cb: &mut FnMut(DefId, Span,\n-                                           &Option<&Stability>,\n-                                           &Option<DeprecationEntry>)) {\n-    let span;\n-    let id = match e.node {\n-        hir::ExprMethodCall(i, ..) => {\n-            span = i.span;\n-            let method_call = ty::MethodCall::expr(e.id);\n-            tcx.tables().method_map[&method_call].def_id\n-        }\n-        hir::ExprField(ref base_e, ref field) => {\n-            span = field.span;\n-            match tcx.tables().expr_ty_adjusted(base_e).sty {\n-                ty::TyAdt(def, _) => {\n-                    def.struct_variant().field_named(field.node).did\n-                }\n-                _ => span_bug!(e.span,\n-                               \"stability::check_expr: named field access on non-ADT\")\n-            }\n-        }\n-        hir::ExprTupField(ref base_e, ref field) => {\n-            span = field.span;\n-            match tcx.tables().expr_ty_adjusted(base_e).sty {\n-                ty::TyAdt(def, _) => {\n-                    def.struct_variant().fields[field.node].did\n-                }\n-                ty::TyTuple(..) => return,\n-                _ => span_bug!(e.span,\n-                               \"stability::check_expr: unnamed field access on \\\n-                                something other than a tuple or struct\")\n-            }\n-        }\n-        hir::ExprStruct(_, ref expr_fields, _) => {\n-            match tcx.tables().expr_ty(e).sty {\n-                ty::TyAdt(adt, ..) => match adt.adt_kind() {\n-                    AdtKind::Struct | AdtKind::Union => {\n-                        // check the stability of each field that appears\n-                        // in the construction expression.\n-                        for field in expr_fields {\n-                            let did = adt.struct_variant().field_named(field.name.node).did;\n-                            maybe_do_stability_check(tcx, did, field.span, cb);\n+            // For implementations of traits, check the stability of each item\n+            // individually as it's possible to have a stable trait with unstable\n+            // items.\n+            hir::ItemImpl(.., Some(ref t), _, ref impl_item_refs) => {\n+                if let Def::Trait(trait_did) = t.path.def {\n+                    for impl_item_ref in impl_item_refs {\n+                        let impl_item = self.tcx.map.impl_item(impl_item_ref.id);\n+                        let trait_item_def_id = self.tcx.associated_items(trait_did)\n+                            .find(|item| item.name == impl_item.name).map(|item| item.def_id);\n+                        if let Some(def_id) = trait_item_def_id {\n+                            // Pass `DUMMY_NODE_ID` to skip deprecation warnings.\n+                            self.tcx.check_stability(def_id, ast::DUMMY_NODE_ID, impl_item.span);\n                         }\n-\n-                        // we're done.\n-                        return\n-                    }\n-                    AdtKind::Enum => {\n-                        // we don't look at stability attributes on\n-                        // struct-like enums (yet...), but it's definitely not\n-                        // a bug to have construct one.\n-                        return\n                     }\n-                },\n-                ref ty => span_bug!(e.span, \"stability::check_expr: struct \\\n-                                         construction of non-ADT type: {:?}\", ty)\n+                }\n             }\n-        }\n-        _ => return\n-    };\n \n-    maybe_do_stability_check(tcx, id, span, cb);\n-}\n-\n-pub fn check_path<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            path: &hir::Path, id: ast::NodeId,\n-                            cb: &mut FnMut(DefId, Span,\n-                                           &Option<&Stability>,\n-                                           &Option<DeprecationEntry>)) {\n-    // Paths in import prefixes may have no resolution.\n-    match tcx.expect_def_or_none(id) {\n-        None | Some(Def::PrimTy(..)) | Some(Def::SelfTy(..)) => {}\n-        Some(def) => maybe_do_stability_check(tcx, def.def_id(), path.span, cb)\n+            _ => (/* pass */)\n+        }\n+        intravisit::walk_item(self, item);\n     }\n-}\n \n-pub fn check_path_list_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                      item: &hir::PathListItem,\n-                                      cb: &mut FnMut(DefId, Span,\n-                                                     &Option<&Stability>,\n-                                                     &Option<DeprecationEntry>)) {\n-    maybe_do_stability_check(tcx, tcx.expect_def(item.node.id).def_id(), item.span, cb);\n-}\n-\n-pub fn check_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, pat: &hir::Pat,\n-                           cb: &mut FnMut(DefId, Span,\n-                                          &Option<&Stability>,\n-                                          &Option<DeprecationEntry>)) {\n-    debug!(\"check_pat(pat = {:?})\", pat);\n-    if is_internal(tcx, pat.span) { return; }\n-\n-    let v = match tcx.tables().pat_ty_opt(pat).map(|ty| &ty.sty) {\n-        Some(&ty::TyAdt(adt, _)) if !adt.is_enum() => adt.struct_variant(),\n-        _ => return,\n-    };\n-    match pat.node {\n-        // Foo(a, b, c)\n-        PatKind::TupleStruct(_, ref pat_fields, ddpos) => {\n-            for (i, field) in pat_fields.iter().enumerate_and_adjust(v.fields.len(), ddpos) {\n-                maybe_do_stability_check(tcx, v.fields[i].did, field.span, cb)\n-            }\n-        }\n-        // Foo { a, b, c }\n-        PatKind::Struct(_, ref pat_fields, _) => {\n-            for field in pat_fields {\n-                let did = v.field_named(field.node.name).did;\n-                maybe_do_stability_check(tcx, did, field.span, cb);\n-            }\n+    fn visit_path(&mut self, path: &'tcx hir::Path, id: ast::NodeId) {\n+        match path.def {\n+            Def::PrimTy(..) | Def::SelfTy(..) | Def::Err => {}\n+            _ => self.tcx.check_stability(path.def.def_id(), id, path.span)\n         }\n-        // everything else is fine.\n-        _ => {}\n+        intravisit::walk_path(self, path)\n     }\n }\n \n-fn maybe_do_stability_check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                      id: DefId, span: Span,\n-                                      cb: &mut FnMut(DefId, Span,\n-                                                     &Option<&Stability>,\n-                                                     &Option<DeprecationEntry>)) {\n-    if is_internal(tcx, span) {\n-        debug!(\"maybe_do_stability_check: \\\n-                skipping span={:?} since it is internal\", span);\n-        return;\n-    }\n-    let (stability, deprecation) = if is_staged_api(tcx, id) {\n-        (tcx.lookup_stability(id), None)\n-    } else {\n-        (None, tcx.lookup_deprecation_entry(id))\n-    };\n-    debug!(\"maybe_do_stability_check: \\\n-            inspecting id={:?} span={:?} of stability={:?}\", id, span, stability);\n-    cb(id, span, &stability, &deprecation);\n-}\n-\n-fn is_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, span: Span) -> bool {\n-    tcx.sess.codemap().span_allows_unstable(span)\n-}\n-\n-fn is_staged_api<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, id: DefId) -> bool {\n-    *tcx.stability.borrow_mut().staged_api.entry(id.krate).or_insert_with(\n-        || tcx.sess.cstore.is_staged_api(id.krate))\n-}\n-\n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// Lookup the stability for a node, loading external crate\n     /// metadata as necessary.\n-    pub fn lookup_stability(self, id: DefId) -> Option<&'tcx Stability> {\n+    pub fn lookup_stability(self, id: DefId) -> Option<&'gcx Stability> {\n         if let Some(st) = self.stability.borrow().stab_map.get(&id) {\n             return *st;\n         }\n@@ -712,7 +599,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         depr\n     }\n \n-    fn lookup_stability_uncached(self, id: DefId) -> Option<&'tcx Stability> {\n+    fn lookup_stability_uncached(self, id: DefId) -> Option<&'gcx Stability> {\n         debug!(\"lookup(id={:?})\", id);\n         if id.is_local() {\n             None // The stability cache is filled partially lazily\n@@ -734,9 +621,22 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n /// Given the list of enabled features that were not language features (i.e. that\n /// were expected to be library features), and the list of features used from\n /// libraries, identify activated features that don't exist and error about them.\n-pub fn check_unused_or_stable_features(sess: &Session,\n-                                       lib_features_used: &FxHashMap<Symbol,\n-                                                                     attr::StabilityLevel>) {\n+pub fn check_unused_or_stable_features<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                 access_levels: &AccessLevels) {\n+    let sess = &tcx.sess;\n+\n+    if tcx.stability.borrow().staged_api[&LOCAL_CRATE] && tcx.sess.features.borrow().staged_api {\n+        let _task = tcx.dep_graph.in_task(DepNode::StabilityIndex);\n+        let krate = tcx.map.krate();\n+        let mut missing = MissingStabilityAnnotations {\n+            tcx: tcx,\n+            access_levels: access_levels,\n+        };\n+        missing.check_missing_stability(ast::CRATE_NODE_ID, krate.span);\n+        intravisit::walk_crate(&mut missing, krate);\n+        krate.visit_all_item_likes(&mut missing.as_deep_visitor());\n+    }\n+\n     let ref declared_lib_features = sess.features.borrow().declared_lib_features;\n     let mut remaining_lib_features: FxHashMap<Symbol, Span>\n         = declared_lib_features.clone().into_iter().collect();\n@@ -754,7 +654,8 @@ pub fn check_unused_or_stable_features(sess: &Session,\n                       format_stable_since_msg(version));\n     }\n \n-    for (used_lib_feature, level) in lib_features_used {\n+    let index = tcx.stability.borrow();\n+    for (used_lib_feature, level) in &index.used_features {\n         match remaining_lib_features.remove(used_lib_feature) {\n             Some(span) => {\n                 if let &attr::StabilityLevel::Stable { since: ref version } = level {"}, {"sha": "c6df1497e681dd3ac3c4587d0c7d45e772ff3c29", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -18,7 +18,7 @@ use rustc_back::PanicStrategy;\n use syntax::ast;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n-use hir::intravisit::Visitor;\n+use hir::intravisit::{Visitor, NestedVisitorMap};\n use hir::intravisit;\n use hir;\n \n@@ -125,6 +125,10 @@ impl<'a> Context<'a> {\n }\n \n impl<'a, 'v> Visitor<'v> for Context<'a> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v> {\n+        NestedVisitorMap::None\n+    }\n+\n     fn visit_foreign_item(&mut self, i: &hir::ForeignItem) {\n         if let Some(lang_item) = lang_items::extract(&i.attrs) {\n             self.register(&lang_item.as_str(), i.span);"}, {"sha": "3cd35804732926d9689679b5c5d0dde745b6406b", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -462,7 +462,7 @@ pub enum TerminatorKind<'tcx> {\n     /// lvalue evaluates to some enum; jump depending on the branch\n     Switch {\n         discr: Lvalue<'tcx>,\n-        adt_def: AdtDef<'tcx>,\n+        adt_def: &'tcx AdtDef,\n         targets: Vec<BasicBlock>,\n     },\n \n@@ -866,7 +866,7 @@ pub enum ProjectionElem<'tcx, V> {\n     /// \"Downcast\" to a variant of an ADT. Currently, we only introduce\n     /// this for ADTs with more than one variant. It may be better to\n     /// just introduce it always, or always for enums.\n-    Downcast(AdtDef<'tcx>, usize),\n+    Downcast(&'tcx AdtDef, usize),\n }\n \n /// Alias for projections as they appear in lvalues, where the base is an lvalue\n@@ -1035,7 +1035,7 @@ pub enum AggregateKind<'tcx> {\n     /// The second field is variant number (discriminant), it's equal to 0\n     /// for struct and union expressions. The fourth field is active field\n     /// number and is present only for union expressions.\n-    Adt(AdtDef<'tcx>, usize, &'tcx Substs<'tcx>, Option<usize>),\n+    Adt(&'tcx AdtDef, usize, &'tcx Substs<'tcx>, Option<usize>),\n     Closure(DefId, ClosureSubsts<'tcx>),\n }\n "}, {"sha": "03530945e046df3651199a4438ffed8f80610f3d", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -25,7 +25,7 @@ pub enum LvalueTy<'tcx> {\n     Ty { ty: Ty<'tcx> },\n \n     /// Downcast to a particular variant of an enum.\n-    Downcast { adt_def: AdtDef<'tcx>,\n+    Downcast { adt_def: &'tcx AdtDef,\n                substs: &'tcx Substs<'tcx>,\n                variant_index: usize },\n }"}, {"sha": "8308c54d70bf49a3a574b908a3fb165c244ef5c2", "filename": "src/librustc/session/code_stats.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fsession%2Fcode_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fsession%2Fcode_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fcode_stats.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -0,0 +1,173 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ty::AdtKind;\n+use ty::layout::{Align, Size};\n+\n+use rustc_data_structures::fx::{FxHashSet};\n+\n+use std::cmp::{self, Ordering};\n+\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct VariantInfo {\n+    pub name: Option<String>,\n+    pub kind: SizeKind,\n+    pub size: u64,\n+    pub align: u64,\n+    pub fields: Vec<FieldInfo>,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum SizeKind { Exact, Min }\n+\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct FieldInfo {\n+    pub name: String,\n+    pub offset: u64,\n+    pub size: u64,\n+    pub align: u64,\n+}\n+\n+impl From<AdtKind> for DataTypeKind {\n+    fn from(kind: AdtKind) -> Self {\n+        match kind {\n+            AdtKind::Struct => DataTypeKind::Struct,\n+            AdtKind::Enum => DataTypeKind::Enum,\n+            AdtKind::Union => DataTypeKind::Union,\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum DataTypeKind {\n+    Struct,\n+    Union,\n+    Enum,\n+    Closure,\n+}\n+\n+#[derive(PartialEq, Eq, Hash, Debug)]\n+pub struct TypeSizeInfo {\n+    pub kind: DataTypeKind,\n+    pub type_description: String,\n+    pub align: u64,\n+    pub overall_size: u64,\n+    pub opt_discr_size: Option<u64>,\n+    pub variants: Vec<VariantInfo>,\n+}\n+\n+#[derive(PartialEq, Eq, Debug)]\n+pub struct CodeStats {\n+    type_sizes: FxHashSet<TypeSizeInfo>,\n+}\n+\n+impl CodeStats {\n+    pub fn new() -> Self { CodeStats { type_sizes: FxHashSet() } }\n+\n+    pub fn record_type_size<S: ToString>(&mut self,\n+                                         kind: DataTypeKind,\n+                                         type_desc: S,\n+                                         align: Align,\n+                                         overall_size: Size,\n+                                         opt_discr_size: Option<Size>,\n+                                         variants: Vec<VariantInfo>) {\n+        let info = TypeSizeInfo {\n+            kind: kind,\n+            type_description: type_desc.to_string(),\n+            align: align.abi(),\n+            overall_size: overall_size.bytes(),\n+            opt_discr_size: opt_discr_size.map(|s| s.bytes()),\n+            variants: variants,\n+        };\n+        self.type_sizes.insert(info);\n+    }\n+\n+    pub fn print_type_sizes(&self) {\n+        let mut sorted: Vec<_> = self.type_sizes.iter().collect();\n+\n+        // Primary sort: large-to-small.\n+        // Secondary sort: description (dictionary order)\n+        sorted.sort_by(|info1, info2| {\n+            // (reversing cmp order to get large-to-small ordering)\n+            match info2.overall_size.cmp(&info1.overall_size) {\n+                Ordering::Equal => info1.type_description.cmp(&info2.type_description),\n+                other => other,\n+            }\n+        });\n+\n+        for info in &sorted {\n+            println!(\"print-type-size type: `{}`: {} bytes, alignment: {} bytes\",\n+                     info.type_description, info.overall_size, info.align);\n+            let indent = \"    \";\n+\n+            let discr_size = if let Some(discr_size) = info.opt_discr_size {\n+                println!(\"print-type-size {}discriminant: {} bytes\",\n+                         indent, discr_size);\n+                discr_size\n+            } else {\n+                0\n+            };\n+\n+            // We start this at discr_size (rather than 0) because\n+            // things like C-enums do not have variants but we still\n+            // want the max_variant_size at the end of the loop below\n+            // to reflect the presence of the discriminant.\n+            let mut max_variant_size = discr_size;\n+\n+            let struct_like = match info.kind {\n+                DataTypeKind::Struct | DataTypeKind::Closure => true,\n+                DataTypeKind::Enum | DataTypeKind::Union => false,\n+            };\n+            for (i, variant_info) in info.variants.iter().enumerate() {\n+                let VariantInfo { ref name, kind: _, align: _, size, ref fields } = *variant_info;\n+                let indent = if !struct_like {\n+                    let name = match name.as_ref() {\n+                        Some(name) => format!(\"{}\", name),\n+                        None => format!(\"{}\", i),\n+                    };\n+                    println!(\"print-type-size {}variant `{}`: {} bytes\",\n+                             indent, name, size - discr_size);\n+                    \"        \"\n+                } else {\n+                    assert!(i < 1);\n+                    \"    \"\n+                };\n+                max_variant_size = cmp::max(max_variant_size, size);\n+\n+                let mut min_offset = discr_size;\n+                for field in fields {\n+                    let FieldInfo { ref name, offset, size, align } = *field;\n+\n+                    // Include field alignment in output only if it caused padding injection\n+                    if min_offset != offset {\n+                        let pad = offset - min_offset;\n+                        println!(\"print-type-size {}padding: {} bytes\",\n+                                 indent, pad);\n+                        println!(\"print-type-size {}field `.{}`: {} bytes, alignment: {} bytes\",\n+                                 indent, name, size, align);\n+                    } else {\n+                        println!(\"print-type-size {}field `.{}`: {} bytes\",\n+                                 indent, name, size);\n+                    }\n+\n+                    min_offset = offset + size;\n+                }\n+            }\n+\n+            assert!(max_variant_size <= info.overall_size,\n+                    \"max_variant_size {} !<= {} overall_size\",\n+                    max_variant_size, info.overall_size);\n+            if max_variant_size < info.overall_size {\n+                println!(\"print-type-size {}end padding: {} bytes\",\n+                         indent, info.overall_size - max_variant_size);\n+            }\n+        }\n+    }\n+}"}, {"sha": "e500c08ce6e32d32719b45962fadab5feba43767", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 72, "deletions": 33, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -262,14 +262,13 @@ top_level_options!(\n         //            much sense: The search path can stay the same while the\n         //            things discovered there might have changed on disk.\n         search_paths: SearchPaths [TRACKED],\n-        libs: Vec<(String, cstore::NativeLibraryKind)> [TRACKED],\n+        libs: Vec<(String, Option<String>, cstore::NativeLibraryKind)> [TRACKED],\n         maybe_sysroot: Option<PathBuf> [TRACKED],\n \n         target_triple: String [TRACKED],\n \n         test: bool [TRACKED],\n         error_format: ErrorOutputType [UNTRACKED],\n-        mir_opt_level: usize [TRACKED],\n \n         // if Some, enable incremental compilation, using the given\n         // directory to store intermediate results\n@@ -308,6 +307,7 @@ pub enum PrintRequest {\n     TargetFeatures,\n     RelocationModels,\n     CodeModels,\n+    TargetSpec,\n }\n \n pub enum Input {\n@@ -434,7 +434,6 @@ pub fn basic_options() -> Options {\n         maybe_sysroot: None,\n         target_triple: host_triple().to_string(),\n         test: false,\n-        mir_opt_level: 1,\n         incremental: None,\n         debugging_opts: basic_debugging_options(),\n         prints: Vec::new(),\n@@ -885,6 +884,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"enable incremental compilation (experimental)\"),\n     incremental_info: bool = (false, parse_bool, [UNTRACKED],\n         \"print high-level information about incremental reuse (or the lack thereof)\"),\n+    incremental_dump_hash: bool = (false, parse_bool, [UNTRACKED],\n+        \"dump hash information in textual format to stdout\"),\n     dump_dep_graph: bool = (false, parse_bool, [UNTRACKED],\n           \"dump the dependency graph to $RUST_DEP_GRAPH (default: /tmp/dep_graph.gv)\"),\n     query_dep_graph: bool = (false, parse_bool, [UNTRACKED],\n@@ -909,10 +910,12 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"keep the AST after lowering it to HIR\"),\n     show_span: Option<String> = (None, parse_opt_string, [TRACKED],\n           \"show spans for compiler debugging (expr|pat|ty)\"),\n+    print_type_sizes: bool = (false, parse_bool, [UNTRACKED],\n+          \"print layout information for each type encountered\"),\n     print_trans_items: Option<String> = (None, parse_opt_string, [UNTRACKED],\n           \"print the result of the translation item collection pass\"),\n-    mir_opt_level: Option<usize> = (None, parse_opt_uint, [TRACKED],\n-          \"set the MIR optimization level (0-3)\"),\n+    mir_opt_level: usize = (1, parse_uint, [TRACKED],\n+          \"set the MIR optimization level (0-3, default: 1)\"),\n     dump_mir: Option<String> = (None, parse_opt_string, [UNTRACKED],\n           \"dump MIR state at various points in translation\"),\n     dump_mir_dir: Option<String> = (None, parse_opt_string, [UNTRACKED],\n@@ -921,6 +924,10 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"print some performance-related statistics\"),\n     hir_stats: bool = (false, parse_bool, [UNTRACKED],\n           \"print some statistics about AST and HIR\"),\n+    mir_stats: bool = (false, parse_bool, [UNTRACKED],\n+          \"print some statistics about MIR\"),\n+    always_encode_mir: bool = (false, parse_bool, [TRACKED],\n+          \"encode MIR of all functions into the crate metadata\"),\n }\n \n pub fn default_lib_output() -> CrateType {\n@@ -1136,6 +1143,13 @@ mod opt {\n /// including metadata for each option, such as whether the option is\n /// part of the stable long-term interface for rustc.\n pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n+    let mut print_opts = vec![\"crate-name\", \"file-names\", \"sysroot\", \"cfg\",\n+                              \"target-list\", \"target-cpus\", \"target-features\",\n+                              \"relocation-models\", \"code-models\"];\n+    if nightly_options::is_nightly_build() {\n+        print_opts.push(\"target-spec-json\");\n+    }\n+\n     vec![\n         opt::flag_s(\"h\", \"help\", \"Display this message\"),\n         opt::multi_s(\"\", \"cfg\", \"Configure the compilation environment\", \"SPEC\"),\n@@ -1155,9 +1169,7 @@ pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n                               the compiler to emit\",\n                  \"[asm|llvm-bc|llvm-ir|obj|link|dep-info]\"),\n         opt::multi_s(\"\", \"print\", \"Comma separated list of compiler information to \\\n-                               print on stdout\",\n-                 \"[crate-name|file-names|sysroot|cfg|target-list|target-cpus|\\\n-                   target-features|relocation-models|code-models]\"),\n+                               print on stdout\", &print_opts.join(\"|\")),\n         opt::flagmulti_s(\"g\",  \"\",  \"Equivalent to -C debuginfo=2\"),\n         opt::flagmulti_s(\"O\", \"\", \"Equivalent to -C opt-level=2\"),\n         opt::opt_s(\"o\", \"\", \"Write output to <filename>\", \"FILENAME\"),\n@@ -1308,8 +1320,6 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n \n     let debugging_opts = build_debugging_options(matches, error_format);\n \n-    let mir_opt_level = debugging_opts.mir_opt_level.unwrap_or(1);\n-\n     let mut output_types = BTreeMap::new();\n     if !debugging_opts.parse_only {\n         for list in matches.opt_strs(\"emit\") {\n@@ -1437,6 +1447,8 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n     }\n \n     let libs = matches.opt_strs(\"l\").into_iter().map(|s| {\n+        // Parse string of the form \"[KIND=]lib[:new_name]\",\n+        // where KIND is one of \"dylib\", \"framework\", \"static\".\n         let mut parts = s.splitn(2, '=');\n         let kind = parts.next().unwrap();\n         let (name, kind) = match (parts.next(), kind) {\n@@ -1450,7 +1462,10 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n                                                  s));\n             }\n         };\n-        (name.to_string(), kind)\n+        let mut name_parts = name.splitn(2, ':');\n+        let name = name_parts.next().unwrap();\n+        let new_name = name_parts.next();\n+        (name.to_string(), new_name.map(|n| n.to_string()), kind)\n     }).collect();\n \n     let cfg = parse_cfgspecs(matches.opt_strs(\"cfg\"));\n@@ -1467,6 +1482,8 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n             \"target-features\" => PrintRequest::TargetFeatures,\n             \"relocation-models\" => PrintRequest::RelocationModels,\n             \"code-models\" => PrintRequest::CodeModels,\n+            \"target-spec-json\" if nightly_options::is_unstable_enabled(matches)\n+                => PrintRequest::TargetSpec,\n             req => {\n                 early_error(error_format, &format!(\"unknown print request `{}`\", req))\n             }\n@@ -1511,7 +1528,6 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n         maybe_sysroot: sysroot_opt,\n         target_triple: target,\n         test: test,\n-        mir_opt_level: mir_opt_level,\n         incremental: incremental,\n         debugging_opts: debugging_opts,\n         prints: prints,\n@@ -1714,8 +1730,8 @@ mod dep_tracking {\n     impl_dep_tracking_hash_for_sortable_vec_of!(String);\n     impl_dep_tracking_hash_for_sortable_vec_of!(CrateType);\n     impl_dep_tracking_hash_for_sortable_vec_of!((String, lint::Level));\n-    impl_dep_tracking_hash_for_sortable_vec_of!((String, cstore::NativeLibraryKind));\n-\n+    impl_dep_tracking_hash_for_sortable_vec_of!((String, Option<String>,\n+                                                 cstore::NativeLibraryKind));\n     impl DepTrackingHash for SearchPaths {\n         fn hash(&self, hasher: &mut DefaultHasher, _: ErrorOutputType) {\n             let mut elems: Vec<_> = self\n@@ -1738,6 +1754,21 @@ mod dep_tracking {\n         }\n     }\n \n+    impl<T1, T2, T3> DepTrackingHash for (T1, T2, T3)\n+        where T1: DepTrackingHash,\n+              T2: DepTrackingHash,\n+              T3: DepTrackingHash\n+    {\n+        fn hash(&self, hasher: &mut DefaultHasher, error_format: ErrorOutputType) {\n+            Hash::hash(&0, hasher);\n+            DepTrackingHash::hash(&self.0, hasher, error_format);\n+            Hash::hash(&1, hasher);\n+            DepTrackingHash::hash(&self.1, hasher, error_format);\n+            Hash::hash(&2, hasher);\n+            DepTrackingHash::hash(&self.2, hasher, error_format);\n+        }\n+    }\n+\n     // This is a stable hash because BTreeMap is a sorted container\n     pub fn stable_hash(sub_hashes: BTreeMap<&'static str, &DepTrackingHash>,\n                        hasher: &mut DefaultHasher,\n@@ -2141,29 +2172,37 @@ mod tests {\n         let mut v1 = super::basic_options();\n         let mut v2 = super::basic_options();\n         let mut v3 = super::basic_options();\n+        let mut v4 = super::basic_options();\n \n         // Reference\n-        v1.libs = vec![(String::from(\"a\"), cstore::NativeStatic),\n-                       (String::from(\"b\"), cstore::NativeFramework),\n-                       (String::from(\"c\"), cstore::NativeUnknown)];\n+        v1.libs = vec![(String::from(\"a\"), None, cstore::NativeStatic),\n+                       (String::from(\"b\"), None, cstore::NativeFramework),\n+                       (String::from(\"c\"), None, cstore::NativeUnknown)];\n \n         // Change label\n-        v2.libs = vec![(String::from(\"a\"), cstore::NativeStatic),\n-                       (String::from(\"X\"), cstore::NativeFramework),\n-                       (String::from(\"c\"), cstore::NativeUnknown)];\n+        v2.libs = vec![(String::from(\"a\"), None, cstore::NativeStatic),\n+                       (String::from(\"X\"), None, cstore::NativeFramework),\n+                       (String::from(\"c\"), None, cstore::NativeUnknown)];\n \n         // Change kind\n-        v3.libs = vec![(String::from(\"a\"), cstore::NativeStatic),\n-                       (String::from(\"b\"), cstore::NativeStatic),\n-                       (String::from(\"c\"), cstore::NativeUnknown)];\n+        v3.libs = vec![(String::from(\"a\"), None, cstore::NativeStatic),\n+                       (String::from(\"b\"), None, cstore::NativeStatic),\n+                       (String::from(\"c\"), None, cstore::NativeUnknown)];\n+\n+        // Change new-name\n+        v4.libs = vec![(String::from(\"a\"), None, cstore::NativeStatic),\n+                       (String::from(\"b\"), Some(String::from(\"X\")), cstore::NativeFramework),\n+                       (String::from(\"c\"), None, cstore::NativeUnknown)];\n \n         assert!(v1.dep_tracking_hash() != v2.dep_tracking_hash());\n         assert!(v1.dep_tracking_hash() != v3.dep_tracking_hash());\n+        assert!(v1.dep_tracking_hash() != v4.dep_tracking_hash());\n \n         // Check clone\n         assert_eq!(v1.dep_tracking_hash(), v1.clone().dep_tracking_hash());\n         assert_eq!(v2.dep_tracking_hash(), v2.clone().dep_tracking_hash());\n         assert_eq!(v3.dep_tracking_hash(), v3.clone().dep_tracking_hash());\n+        assert_eq!(v4.dep_tracking_hash(), v4.clone().dep_tracking_hash());\n     }\n \n     #[test]\n@@ -2173,17 +2212,17 @@ mod tests {\n         let mut v3 = super::basic_options();\n \n         // Reference\n-        v1.libs = vec![(String::from(\"a\"), cstore::NativeStatic),\n-                       (String::from(\"b\"), cstore::NativeFramework),\n-                       (String::from(\"c\"), cstore::NativeUnknown)];\n+        v1.libs = vec![(String::from(\"a\"), None, cstore::NativeStatic),\n+                       (String::from(\"b\"), None, cstore::NativeFramework),\n+                       (String::from(\"c\"), None, cstore::NativeUnknown)];\n \n-        v2.libs = vec![(String::from(\"b\"), cstore::NativeFramework),\n-                       (String::from(\"a\"), cstore::NativeStatic),\n-                       (String::from(\"c\"), cstore::NativeUnknown)];\n+        v2.libs = vec![(String::from(\"b\"), None, cstore::NativeFramework),\n+                       (String::from(\"a\"), None, cstore::NativeStatic),\n+                       (String::from(\"c\"), None, cstore::NativeUnknown)];\n \n-        v3.libs = vec![(String::from(\"c\"), cstore::NativeUnknown),\n-                       (String::from(\"a\"), cstore::NativeStatic),\n-                       (String::from(\"b\"), cstore::NativeFramework)];\n+        v3.libs = vec![(String::from(\"c\"), None, cstore::NativeUnknown),\n+                       (String::from(\"a\"), None, cstore::NativeStatic),\n+                       (String::from(\"b\"), None, cstore::NativeFramework)];\n \n         assert!(v1.dep_tracking_hash() == v2.dep_tracking_hash());\n         assert!(v1.dep_tracking_hash() == v3.dep_tracking_hash());\n@@ -2431,7 +2470,7 @@ mod tests {\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n \n         opts = reference.clone();\n-        opts.debugging_opts.mir_opt_level = Some(1);\n+        opts.debugging_opts.mir_opt_level = 3;\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n     }\n }"}, {"sha": "91765e68ae6e1a678c04f9cc34af957111da7dcb", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+pub use self::code_stats::{CodeStats, DataTypeKind, FieldInfo};\n+pub use self::code_stats::{SizeKind, TypeSizeInfo, VariantInfo};\n+\n use dep_graph::DepGraph;\n use hir::def_id::{CrateNum, DefIndex};\n use hir::svh::Svh;\n@@ -49,6 +52,7 @@ use std::fmt;\n use std::time::Duration;\n use libc::c_int;\n \n+mod code_stats;\n pub mod config;\n pub mod filesearch;\n pub mod search_paths;\n@@ -96,6 +100,9 @@ pub struct Session {\n     /// operations such as auto-dereference and monomorphization.\n     pub recursion_limit: Cell<usize>,\n \n+    /// The maximum length of types during monomorphization.\n+    pub type_length_limit: Cell<usize>,\n+\n     /// The metadata::creader module may inject an allocator/panic_runtime\n     /// dependency if it didn't already find one, and this tracks what was\n     /// injected.\n@@ -112,6 +119,9 @@ pub struct Session {\n     /// Some measurements that are being gathered during compilation.\n     pub perf_stats: PerfStats,\n \n+    /// Data about code being compiled, gathered during compilation.\n+    pub code_stats: RefCell<CodeStats>,\n+\n     next_node_id: Cell<ast::NodeId>,\n }\n \n@@ -613,6 +623,7 @@ pub fn build_session_(sopts: config::Options,\n         crate_disambiguator: RefCell::new(Symbol::intern(\"\")),\n         features: RefCell::new(feature_gate::Features::new()),\n         recursion_limit: Cell::new(64),\n+        type_length_limit: Cell::new(1048576),\n         next_node_id: Cell::new(NodeId::new(1)),\n         injected_allocator: Cell::new(None),\n         injected_panic_runtime: Cell::new(None),\n@@ -624,7 +635,8 @@ pub fn build_session_(sopts: config::Options,\n             incr_comp_hashes_count: Cell::new(0),\n             incr_comp_bytes_hashed: Cell::new(0),\n             symbol_hash_time: Cell::new(Duration::from_secs(0)),\n-        }\n+        },\n+        code_stats: RefCell::new(CodeStats::new()),\n     };\n \n     init_llvm(&sess);"}, {"sha": "58cb52e897786a5687a0fe6eb13ea2f1bfa1cd1a", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -225,14 +225,12 @@ fn ty_is_local(tcx: TyCtxt, ty: Ty, infer_is_local: InferIsLocal) -> bool {\n \n fn fundamental_ty(tcx: TyCtxt, ty: Ty) -> bool {\n     match ty.sty {\n-        ty::TyBox(..) | ty::TyRef(..) =>\n-            true,\n-        ty::TyAdt(def, _) =>\n-            def.is_fundamental(),\n-        ty::TyTrait(ref data) =>\n-            tcx.has_attr(data.principal.def_id(), \"fundamental\"),\n-        _ =>\n-            false\n+        ty::TyBox(..) | ty::TyRef(..) => true,\n+        ty::TyAdt(def, _) => def.is_fundamental(),\n+        ty::TyDynamic(ref data, ..) => {\n+            data.principal().map_or(false, |p| tcx.has_attr(p.def_id(), \"fundamental\"))\n+        }\n+        _ => false\n     }\n }\n \n@@ -272,8 +270,8 @@ fn ty_is_local_constructor(tcx: TyCtxt, ty: Ty, infer_is_local: InferIsLocal)->\n             krate == Some(LOCAL_CRATE)\n         }\n \n-        ty::TyTrait(ref tt) => {\n-            tt.principal.def_id().is_local()\n+        ty::TyDynamic(ref tt, ..) => {\n+            tt.principal().map_or(false, |p| p.def_id().is_local())\n         }\n \n         ty::TyError => {"}, {"sha": "0c0d0c010e2e279dd58ee2750d36abda07688796", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 27, "deletions": 20, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -27,6 +27,7 @@ use super::{\n use fmt_macros::{Parser, Piece, Position};\n use hir::def_id::DefId;\n use infer::{self, InferCtxt};\n+use infer::type_variable::TypeVariableOrigin;\n use rustc::lint::builtin::EXTRA_REQUIREMENT_IN_IMPL;\n use ty::{self, AdtKind, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use ty::error::ExpectedFound;\n@@ -38,7 +39,7 @@ use util::nodemap::{FxHashMap, FxHashSet};\n use std::cmp;\n use std::fmt;\n use syntax::ast;\n-use syntax_pos::Span;\n+use syntax_pos::{DUMMY_SP, Span};\n use errors::DiagnosticBuilder;\n \n #[derive(Debug, PartialEq, Eq, Hash)]\n@@ -156,7 +157,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 ty::TyBox(..) | ty::TyRef(..) | ty::TyRawPtr(..) => Some(5),\n                 ty::TyArray(..) | ty::TySlice(..) => Some(6),\n                 ty::TyFnDef(..) | ty::TyFnPtr(..) => Some(7),\n-                ty::TyTrait(..) => Some(8),\n+                ty::TyDynamic(..) => Some(8),\n                 ty::TyClosure(..) => Some(9),\n                 ty::TyTuple(..) => Some(10),\n                 ty::TyProjection(..) => Some(11),\n@@ -244,11 +245,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         for item in self.tcx.get_attrs(def_id).iter() {\n             if item.check_name(\"rustc_on_unimplemented\") {\n                 let err_sp = item.meta().span.substitute_dummy(span);\n-                let def = self.tcx.lookup_trait_def(trait_ref.def_id);\n-                let trait_str = def.trait_ref.to_string();\n+                let trait_str = self.tcx.item_path_str(trait_ref.def_id);\n                 if let Some(istring) = item.value_str() {\n                     let istring = &*istring.as_str();\n-                    let generic_map = def.generics.types.iter().map(|param| {\n+                    let generics = self.tcx.item_generics(trait_ref.def_id);\n+                    let generic_map = generics.types.iter().map(|param| {\n                         (param.name.as_str().to_string(),\n                          trait_ref.substs.type_for_def(param).to_string())\n                     }).collect::<FxHashMap<String, String>>();\n@@ -790,9 +791,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'tcx> { self.infcx.tcx }\n \n             fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-                if let ty::TyParam(..) = ty.sty {\n+                if let ty::TyParam(ty::ParamTy {name, ..}) = ty.sty {\n                     let infcx = self.infcx;\n-                    self.var_map.entry(ty).or_insert_with(|| infcx.next_ty_var())\n+                    self.var_map.entry(ty).or_insert_with(||\n+                        infcx.next_ty_var(\n+                            TypeVariableOrigin::TypeParameterDefinition(DUMMY_SP, name)))\n                 } else {\n                     ty.super_fold_with(self)\n                 }\n@@ -824,12 +827,26 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n \n     fn need_type_info(&self, span: Span, ty: Ty<'tcx>) {\n+        let ty = self.resolve_type_vars_if_possible(&ty);\n+        let name = if let ty::TyInfer(ty::TyVar(ty_vid)) = ty.sty {\n+            let ty_vars = self.type_variables.borrow();\n+            if let TypeVariableOrigin::TypeParameterDefinition(_, name) =\n+                    *ty_vars.var_origin(ty_vid)\n+            {\n+                name.to_string()\n+            } else {\n+                ty.to_string()\n+            }\n+        } else {\n+            ty.to_string()\n+        };\n+\n         let mut err = struct_span_err!(self.tcx.sess, span, E0282,\n                                        \"unable to infer enough type information about `{}`\",\n-                                       ty);\n+                                       name);\n         err.note(\"type annotations or generic parameter binding required\");\n-        err.span_label(span, &format!(\"cannot infer type for `{}`\", ty));\n-        err.emit()\n+        err.span_label(span, &format!(\"cannot infer type for `{}`\", name));\n+        err.emit();\n     }\n \n     fn note_obligation_cause<T>(&self,\n@@ -905,16 +922,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             ObligationCauseCode::StructInitializerSized => {\n                 err.note(\"structs must have a statically known size to be initialized\");\n             }\n-            ObligationCauseCode::ClosureCapture(var_id, _, builtin_bound) => {\n-                let def_id = tcx.lang_items.from_builtin_kind(builtin_bound).unwrap();\n-                let trait_name = tcx.item_path_str(def_id);\n-                let name = tcx.local_var_name_str(var_id);\n-                err.note(\n-                    &format!(\"the closure that captures `{}` requires that all captured variables \\\n-                              implement the trait `{}`\",\n-                             name,\n-                             trait_name));\n-            }\n             ObligationCauseCode::FieldSized => {\n                 err.note(\"only the last field of a struct may have a dynamically sized type\");\n             }"}, {"sha": "23c28037a3c2d7b629f211c195446299032a6e0d", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -17,8 +17,8 @@ use rustc_data_structures::obligation_forest::{ForestObligation, ObligationProce\n use std::marker::PhantomData;\n use std::mem;\n use syntax::ast;\n-use util::common::ErrorReported;\n use util::nodemap::{FxHashSet, NodeMap};\n+use hir::def_id::DefId;\n \n use super::CodeAmbiguity;\n use super::CodeProjectionError;\n@@ -230,18 +230,21 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         normalized.value\n     }\n \n-    pub fn register_builtin_bound(&mut self,\n-                                  infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                  ty: Ty<'tcx>,\n-                                  builtin_bound: ty::BuiltinBound,\n-                                  cause: ObligationCause<'tcx>)\n+    pub fn register_bound(&mut self,\n+                          infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                          ty: Ty<'tcx>,\n+                          def_id: DefId,\n+                          cause: ObligationCause<'tcx>)\n     {\n-        match infcx.tcx.predicate_for_builtin_bound(cause, builtin_bound, 0, ty) {\n-            Ok(predicate) => {\n-                self.register_predicate_obligation(infcx, predicate);\n-            }\n-            Err(ErrorReported) => { }\n-        }\n+        let trait_ref = ty::TraitRef {\n+            def_id: def_id,\n+            substs: infcx.tcx.mk_substs_trait(ty, &[]),\n+        };\n+        self.register_predicate_obligation(infcx, Obligation {\n+            cause: cause,\n+            recursion_depth: 0,\n+            predicate: trait_ref.to_predicate()\n+        });\n     }\n \n     pub fn register_region_obligation(&mut self,"}, {"sha": "5c5bf130c3ba401ee28b00499fddca56a754429d", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -19,7 +19,7 @@ use hir;\n use hir::def_id::DefId;\n use middle::free_region::FreeRegionMap;\n use ty::subst::Substs;\n-use ty::{self, Ty, TyCtxt, TypeFoldable};\n+use ty::{self, Ty, TyCtxt, TypeFoldable, ToPredicate};\n use infer::InferCtxt;\n \n use std::rc::Rc;\n@@ -125,10 +125,6 @@ pub enum ObligationCauseCode<'tcx> {\n     ReturnType,                // Return type must be Sized\n     RepeatVec,                 // [T,..n] --> T must be Copy\n \n-    // Captures of variable the given id by a closure (span is the\n-    // span of the closure)\n-    ClosureCapture(ast::NodeId, Span, ty::BuiltinBound),\n-\n     // Types of fields (other than the last) in a struct must be sized.\n     FieldSized,\n \n@@ -369,27 +365,30 @@ pub fn predicates_for_generics<'tcx>(cause: ObligationCause<'tcx>,\n /// `bound` or is not known to meet bound (note that this is\n /// conservative towards *no impl*, which is the opposite of the\n /// `evaluate` methods).\n-pub fn type_known_to_meet_builtin_bound<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                                        ty: Ty<'tcx>,\n-                                                        bound: ty::BuiltinBound,\n-                                                        span: Span)\n-                                                        -> bool\n+pub fn type_known_to_meet_bound<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+                                                ty: Ty<'tcx>,\n+                                                def_id: DefId,\n+                                                span: Span)\n+-> bool\n {\n-    debug!(\"type_known_to_meet_builtin_bound(ty={:?}, bound={:?})\",\n+    debug!(\"type_known_to_meet_bound(ty={:?}, bound={:?})\",\n            ty,\n-           bound);\n-\n-    let cause = ObligationCause::misc(span, ast::DUMMY_NODE_ID);\n-    let obligation =\n-        infcx.tcx.predicate_for_builtin_bound(cause, bound, 0, ty);\n-    let obligation = match obligation {\n-        Ok(o) => o,\n-        Err(..) => return false\n+           infcx.tcx.item_path_str(def_id));\n+\n+    let trait_ref = ty::TraitRef {\n+        def_id: def_id,\n+        substs: infcx.tcx.mk_substs_trait(ty, &[]),\n     };\n+    let obligation = Obligation {\n+        cause: ObligationCause::misc(span, ast::DUMMY_NODE_ID),\n+        recursion_depth: 0,\n+        predicate: trait_ref.to_predicate(),\n+    };\n+\n     let result = SelectionContext::new(infcx)\n         .evaluate_obligation_conservatively(&obligation);\n-    debug!(\"type_known_to_meet_builtin_bound: ty={:?} bound={:?} => {:?}\",\n-           ty, bound, result);\n+    debug!(\"type_known_to_meet_ty={:?} bound={} => {:?}\",\n+           ty, infcx.tcx.item_path_str(def_id), result);\n \n     if result && (ty.has_infer_types() || ty.has_closure_types()) {\n         // Because of inference \"guessing\", selection can sometimes claim\n@@ -404,22 +403,22 @@ pub fn type_known_to_meet_builtin_bound<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'g\n         // anyhow).\n         let cause = ObligationCause::misc(span, ast::DUMMY_NODE_ID);\n \n-        fulfill_cx.register_builtin_bound(infcx, ty, bound, cause);\n+        fulfill_cx.register_bound(infcx, ty, def_id, cause);\n \n         // Note: we only assume something is `Copy` if we can\n         // *definitively* show that it implements `Copy`. Otherwise,\n         // assume it is move; linear is always ok.\n         match fulfill_cx.select_all_or_error(infcx) {\n             Ok(()) => {\n-                debug!(\"type_known_to_meet_builtin_bound: ty={:?} bound={:?} success\",\n+                debug!(\"type_known_to_meet_bound: ty={:?} bound={} success\",\n                        ty,\n-                       bound);\n+                       infcx.tcx.item_path_str(def_id));\n                 true\n             }\n             Err(e) => {\n-                debug!(\"type_known_to_meet_builtin_bound: ty={:?} bound={:?} errors={:?}\",\n+                debug!(\"type_known_to_meet_bound: ty={:?} bound={} errors={:?}\",\n                        ty,\n-                       bound,\n+                       infcx.tcx.item_path_str(def_id),\n                        e);\n                 false\n             }"}, {"sha": "0d5c9b98941dc086a78eee65d3cd55e87c597589", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -21,7 +21,8 @@ use super::elaborate_predicates;\n \n use hir::def_id::DefId;\n use traits;\n-use ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n+use ty::{self, Ty, TyCtxt, TypeFoldable};\n+use ty::subst::Substs;\n use syntax::ast;\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n@@ -126,9 +127,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn supertraits_reference_self(self, trait_def_id: DefId) -> bool {\n-        let trait_def = self.lookup_trait_def(trait_def_id);\n-        let trait_ref = trait_def.trait_ref.clone();\n-        let trait_ref = trait_ref.to_poly_trait_ref();\n+        let trait_ref = ty::Binder(ty::TraitRef {\n+            def_id: trait_def_id,\n+            substs: Substs::identity_for_item(self, trait_def_id)\n+        });\n         let predicates = self.item_super_predicates(trait_def_id);\n         predicates\n             .predicates\n@@ -239,12 +241,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         // The `Self` type is erased, so it should not appear in list of\n         // arguments or return type apart from the receiver.\n         let ref sig = self.item_type(method.def_id).fn_sig();\n-        for &input_ty in &sig.0.inputs[1..] {\n+        for input_ty in &sig.skip_binder().inputs()[1..] {\n             if self.contains_illegal_self_type_reference(trait_def_id, input_ty) {\n                 return Some(MethodViolationCode::ReferencesSelf);\n             }\n         }\n-        if self.contains_illegal_self_type_reference(trait_def_id, sig.0.output) {\n+        if self.contains_illegal_self_type_reference(trait_def_id, sig.output().skip_binder()) {\n             return Some(MethodViolationCode::ReferencesSelf);\n         }\n \n@@ -317,8 +319,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n                     // Compute supertraits of current trait lazily.\n                     if supertraits.is_none() {\n-                        let trait_def = self.lookup_trait_def(trait_def_id);\n-                        let trait_ref = ty::Binder(trait_def.trait_ref.clone());\n+                        let trait_ref = ty::Binder(ty::TraitRef {\n+                            def_id: trait_def_id,\n+                            substs: Substs::identity_for_item(self, trait_def_id)\n+                        });\n                         supertraits = Some(traits::supertraits(self, trait_ref).collect());\n                     }\n "}, {"sha": "6f645b5f94d0084fe305f4e0ee69fe365733c91a", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -25,6 +25,7 @@ use super::util;\n \n use hir::def_id::DefId;\n use infer::InferOk;\n+use infer::type_variable::TypeVariableOrigin;\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n use syntax::ast;\n use syntax::symbol::Symbol;\n@@ -382,7 +383,12 @@ pub fn normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             // and a deferred predicate to resolve this when more type\n             // information is available.\n \n-            let ty_var = selcx.infcx().next_ty_var();\n+            let tcx = selcx.infcx().tcx;\n+            let def_id = tcx.associated_items(projection_ty.trait_ref.def_id).find(|i|\n+                i.name == projection_ty.item_name && i.kind == ty::AssociatedKind::Type\n+            ).map(|i| i.def_id).unwrap();\n+            let ty_var = selcx.infcx().next_ty_var(\n+                TypeVariableOrigin::NormalizeProjectionType(tcx.def_span(def_id)));\n             let projection = ty::Binder(ty::ProjectionPredicate {\n                 projection_ty: projection_ty,\n                 ty: ty_var\n@@ -596,7 +602,12 @@ fn normalize_to_error<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tc\n     let trait_obligation = Obligation { cause: cause,\n                                         recursion_depth: depth,\n                                         predicate: trait_ref.to_predicate() };\n-    let new_value = selcx.infcx().next_ty_var();\n+    let tcx = selcx.infcx().tcx;\n+    let def_id = tcx.associated_items(projection_ty.trait_ref.def_id).find(|i|\n+        i.name == projection_ty.item_name && i.kind == ty::AssociatedKind::Type\n+    ).map(|i| i.def_id).unwrap();\n+    let new_value = selcx.infcx().next_ty_var(\n+        TypeVariableOrigin::NormalizeProjectionType(tcx.def_span(def_id)));\n     Normalized {\n         value: new_value,\n         obligations: vec![trait_obligation]\n@@ -1123,15 +1134,15 @@ fn confirm_object_candidate<'cx, 'gcx, 'tcx>(\n     debug!(\"confirm_object_candidate(object_ty={:?})\",\n            object_ty);\n     let data = match object_ty.sty {\n-        ty::TyTrait(ref data) => data,\n+        ty::TyDynamic(ref data, ..) => data,\n         _ => {\n             span_bug!(\n                 obligation.cause.span,\n                 \"confirm_object_candidate called with non-object: {:?}\",\n                 object_ty)\n         }\n     };\n-    let env_predicates = data.projection_bounds.iter().map(|p| {\n+    let env_predicates = data.projection_bounds().map(|p| {\n         p.with_self_ty(selcx.tcx(), object_ty).to_predicate()\n     }).collect();\n     let env_predicate = {\n@@ -1215,8 +1226,8 @@ fn confirm_closure_candidate<'cx, 'gcx, 'tcx>(\n                                obligation,\n                                &closure_type.sig,\n                                util::TupleArgumentsFlag::No)\n-        .with_addl_obligations(obligations)\n         .with_addl_obligations(vtable.nested)\n+        .with_addl_obligations(obligations)\n }\n \n fn confirm_callable_candidate<'cx, 'gcx, 'tcx>("}, {"sha": "23cfc2517590c1845b7a7f260dbc7a4a5a19d8c8", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 86, "deletions": 107, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -41,6 +41,7 @@ use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n use traits;\n use ty::fast_reject;\n use ty::relate::TypeRelation;\n+use middle::lang_items;\n \n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::snapshot_vec::{SnapshotVecDelegate, SnapshotVec};\n@@ -1091,40 +1092,31 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // Other bounds. Consider both in-scope bounds from fn decl\n         // and applicable impls. There is a certain set of precedence rules here.\n \n-        match self.tcx().lang_items.to_builtin_kind(obligation.predicate.def_id()) {\n-            Some(ty::BoundCopy) => {\n-                debug!(\"obligation self ty is {:?}\",\n-                       obligation.predicate.0.self_ty());\n-\n-                // User-defined copy impls are permitted, but only for\n-                // structs and enums.\n-                self.assemble_candidates_from_impls(obligation, &mut candidates)?;\n-\n-                // For other types, we'll use the builtin rules.\n-                let copy_conditions = self.copy_conditions(obligation);\n-                self.assemble_builtin_bound_candidates(copy_conditions, &mut candidates)?;\n-            }\n-            Some(ty::BoundSized) => {\n-                // Sized is never implementable by end-users, it is\n-                // always automatically computed.\n-                let sized_conditions = self.sized_conditions(obligation);\n-                self.assemble_builtin_bound_candidates(sized_conditions,\n-                                                       &mut candidates)?;\n-            }\n-\n-            None if self.tcx().lang_items.unsize_trait() ==\n-                    Some(obligation.predicate.def_id()) => {\n-                self.assemble_candidates_for_unsizing(obligation, &mut candidates);\n-            }\n-\n-            Some(ty::BoundSend) |\n-            Some(ty::BoundSync) |\n-            None => {\n-                self.assemble_closure_candidates(obligation, &mut candidates)?;\n-                self.assemble_fn_pointer_candidates(obligation, &mut candidates)?;\n-                self.assemble_candidates_from_impls(obligation, &mut candidates)?;\n-                self.assemble_candidates_from_object_ty(obligation, &mut candidates);\n-            }\n+        let def_id = obligation.predicate.def_id();\n+        if self.tcx().lang_items.copy_trait() == Some(def_id) {\n+            debug!(\"obligation self ty is {:?}\",\n+                   obligation.predicate.0.self_ty());\n+\n+            // User-defined copy impls are permitted, but only for\n+            // structs and enums.\n+            self.assemble_candidates_from_impls(obligation, &mut candidates)?;\n+\n+            // For other types, we'll use the builtin rules.\n+            let copy_conditions = self.copy_conditions(obligation);\n+            self.assemble_builtin_bound_candidates(copy_conditions, &mut candidates)?;\n+        } else if self.tcx().lang_items.sized_trait() == Some(def_id) {\n+            // Sized is never implementable by end-users, it is\n+            // always automatically computed.\n+            let sized_conditions = self.sized_conditions(obligation);\n+            self.assemble_builtin_bound_candidates(sized_conditions,\n+                                                   &mut candidates)?;\n+         } else if self.tcx().lang_items.unsize_trait() == Some(def_id) {\n+             self.assemble_candidates_for_unsizing(obligation, &mut candidates);\n+         } else {\n+             self.assemble_closure_candidates(obligation, &mut candidates)?;\n+             self.assemble_fn_pointer_candidates(obligation, &mut candidates)?;\n+             self.assemble_candidates_from_impls(obligation, &mut candidates)?;\n+             self.assemble_candidates_from_object_ty(obligation, &mut candidates);\n         }\n \n         self.assemble_candidates_from_projected_tys(obligation, &mut candidates);\n@@ -1376,21 +1368,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             ty::TyFnDef(.., &ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,\n                 abi: Abi::Rust,\n-                sig: ty::Binder(ty::FnSig {\n-                    inputs: _,\n-                    output: _,\n-                    variadic: false\n-                })\n+                ref sig,\n             }) |\n             ty::TyFnPtr(&ty::BareFnTy {\n                 unsafety: hir::Unsafety::Normal,\n                 abi: Abi::Rust,\n-                sig: ty::Binder(ty::FnSig {\n-                    inputs: _,\n-                    output: _,\n-                    variadic: false\n-                })\n-            }) => {\n+                ref sig\n+            }) if !sig.variadic() => {\n                 candidates.vec.push(FnPointerCandidate);\n             }\n \n@@ -1445,7 +1429,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         if self.tcx().trait_has_default_impl(def_id) {\n             match self_ty.sty {\n-                ty::TyTrait(..) => {\n+                ty::TyDynamic(..) => {\n                     // For object types, we don't know what the closed\n                     // over types are. For most traits, this means we\n                     // conservatively say nothing; a candidate may be\n@@ -1515,20 +1499,18 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // any LBR.\n             let self_ty = this.tcx().erase_late_bound_regions(&obligation.self_ty());\n             let poly_trait_ref = match self_ty.sty {\n-                ty::TyTrait(ref data) => {\n-                    match this.tcx().lang_items.to_builtin_kind(obligation.predicate.def_id()) {\n-                        Some(bound @ ty::BoundSend) | Some(bound @ ty::BoundSync) => {\n-                            if data.builtin_bounds.contains(&bound) {\n-                                debug!(\"assemble_candidates_from_object_ty: matched builtin bound, \\\n-                                        pushing candidate\");\n-                                candidates.vec.push(BuiltinObjectCandidate);\n-                                return;\n-                            }\n-                        }\n-                        _ => {}\n+                ty::TyDynamic(ref data, ..) => {\n+                    if data.auto_traits().any(|did| did == obligation.predicate.def_id()) {\n+                        debug!(\"assemble_candidates_from_object_ty: matched builtin bound, \\\n+                                    pushing candidate\");\n+                        candidates.vec.push(BuiltinObjectCandidate);\n+                        return;\n                     }\n \n-                    data.principal.with_self_ty(this.tcx(), self_ty)\n+                    match data.principal() {\n+                        Some(p) => p.with_self_ty(this.tcx(), self_ty),\n+                        None => return,\n+                    }\n                 }\n                 ty::TyInfer(ty::TyVar(_)) => {\n                     debug!(\"assemble_candidates_from_object_ty: ambiguous\");\n@@ -1599,7 +1581,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n \n         let may_apply = match (&source.sty, &target.sty) {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n-            (&ty::TyTrait(ref data_a), &ty::TyTrait(ref data_b)) => {\n+            (&ty::TyDynamic(ref data_a, ..), &ty::TyDynamic(ref data_b, ..)) => {\n                 // Upcasts permit two things:\n                 //\n                 // 1. Dropping builtin bounds, e.g. `Foo+Send` to `Foo`\n@@ -1611,12 +1593,17 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 //\n                 // We always upcast when we can because of reason\n                 // #2 (region bounds).\n-                data_a.principal.def_id() == data_b.principal.def_id() &&\n-                data_a.builtin_bounds.is_superset(&data_b.builtin_bounds)\n+                match (data_a.principal(), data_b.principal()) {\n+                    (Some(a), Some(b)) => a.def_id() == b.def_id() &&\n+                        data_b.auto_traits()\n+                            // All of a's auto traits need to be in b's auto traits.\n+                            .all(|b| data_a.auto_traits().any(|a| a == b)),\n+                    _ => false\n+                }\n             }\n \n             // T -> Trait.\n-            (_, &ty::TyTrait(_)) => true,\n+            (_, &ty::TyDynamic(..)) => true,\n \n             // Ambiguous handling is below T -> Trait, because inference\n             // variables can still implement Unsize<Trait> and nested\n@@ -1768,7 +1755,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 Where(ty::Binder(Vec::new()))\n             }\n \n-            ty::TyStr | ty::TySlice(_) | ty::TyTrait(..) => Never,\n+            ty::TyStr | ty::TySlice(_) | ty::TyDynamic(..) => Never,\n \n             ty::TyTuple(tys) => {\n                 Where(ty::Binder(tys.last().into_iter().cloned().collect()))\n@@ -1814,7 +1801,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 Where(ty::Binder(Vec::new()))\n             }\n \n-            ty::TyBox(_) | ty::TyTrait(..) | ty::TyStr | ty::TySlice(..) |\n+            ty::TyBox(_) | ty::TyDynamic(..) | ty::TyStr | ty::TySlice(..) |\n             ty::TyClosure(..) |\n             ty::TyRef(_, ty::TypeAndMut { ty: _, mutbl: hir::MutMutable }) => {\n                 Never\n@@ -1879,7 +1866,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 Vec::new()\n             }\n \n-            ty::TyTrait(..) |\n+            ty::TyDynamic(..) |\n             ty::TyParam(..) |\n             ty::TyProjection(..) |\n             ty::TyAnon(..) |\n@@ -2165,10 +2152,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // OK to skip binder, it is reintroduced below\n         let self_ty = self.infcx.shallow_resolve(obligation.predicate.skip_binder().self_ty());\n         match self_ty.sty {\n-            ty::TyTrait(ref data) => {\n+            ty::TyDynamic(ref data, ..) => {\n                 // OK to skip the binder, it is reintroduced below\n-                let input_types = data.principal.input_types();\n-                let assoc_types = data.projection_bounds.iter()\n+                let principal = data.principal().unwrap();\n+                let input_types = principal.input_types();\n+                let assoc_types = data.projection_bounds()\n                                       .map(|pb| pb.skip_binder().ty);\n                 let all_types: Vec<_> = input_types.chain(assoc_types)\n                                                    .collect();\n@@ -2300,8 +2288,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // case that results. -nmatsakis\n         let self_ty = self.infcx.shallow_resolve(*obligation.self_ty().skip_binder());\n         let poly_trait_ref = match self_ty.sty {\n-            ty::TyTrait(ref data) => {\n-                data.principal.with_self_ty(self.tcx(), self_ty)\n+            ty::TyDynamic(ref data, ..) => {\n+                data.principal().unwrap().with_self_ty(self.tcx(), self_ty)\n             }\n             _ => {\n                 span_bug!(obligation.cause.span,\n@@ -2469,14 +2457,16 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let mut nested = vec![];\n         match (&source.sty, &target.sty) {\n             // Trait+Kx+'a -> Trait+Ky+'b (upcasts).\n-            (&ty::TyTrait(ref data_a), &ty::TyTrait(ref data_b)) => {\n+            (&ty::TyDynamic(ref data_a, r_a), &ty::TyDynamic(ref data_b, r_b)) => {\n                 // See assemble_candidates_for_unsizing for more info.\n-                let new_trait = tcx.mk_trait(ty::TraitObject {\n-                    principal: data_a.principal,\n-                    region_bound: data_b.region_bound,\n-                    builtin_bounds: data_b.builtin_bounds,\n-                    projection_bounds: data_a.projection_bounds.clone(),\n-                });\n+                // Binders reintroduced below in call to mk_existential_predicates.\n+                let principal = data_a.skip_binder().principal();\n+                let iter = principal.into_iter().map(ty::ExistentialPredicate::Trait)\n+                    .chain(data_a.skip_binder().projection_bounds()\n+                           .map(|x| ty::ExistentialPredicate::Projection(x)))\n+                    .chain(data_b.auto_traits().map(ty::ExistentialPredicate::AutoTrait));\n+                let new_trait = tcx.mk_dynamic(\n+                    ty::Binder(tcx.mk_existential_predicates(iter)), r_b);\n                 let InferOk { obligations, .. } =\n                     self.infcx.sub_types(false, &obligation.cause, new_trait, target)\n                     .map_err(|_| Unimplemented)?;\n@@ -2486,20 +2476,16 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 let cause = ObligationCause::new(obligation.cause.span,\n                                                  obligation.cause.body_id,\n                                                  ObjectCastObligation(target));\n-                let outlives = ty::OutlivesPredicate(data_a.region_bound,\n-                                                     data_b.region_bound);\n+                let outlives = ty::OutlivesPredicate(r_a, r_b);\n                 nested.push(Obligation::with_depth(cause,\n                                                    obligation.recursion_depth + 1,\n                                                    ty::Binder(outlives).to_predicate()));\n             }\n \n             // T -> Trait.\n-            (_, &ty::TyTrait(ref data)) => {\n+            (_, &ty::TyDynamic(ref data, r)) => {\n                 let mut object_dids =\n-                    data.builtin_bounds.iter().flat_map(|bound| {\n-                        tcx.lang_items.from_builtin_kind(bound).ok()\n-                    })\n-                    .chain(Some(data.principal.def_id()));\n+                    data.auto_traits().chain(data.principal().map(|p| p.def_id()));\n                 if let Some(did) = object_dids.find(|did| {\n                     !tcx.is_object_safe(*did)\n                 }) {\n@@ -2515,33 +2501,26 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                                                        predicate));\n                 };\n \n-                // Create the obligation for casting from T to Trait.\n-                push(data.principal.with_self_ty(tcx, source).to_predicate());\n-\n-                // We can only make objects from sized types.\n-                let mut builtin_bounds = data.builtin_bounds;\n-                builtin_bounds.insert(ty::BoundSized);\n-\n-                // Create additional obligations for all the various builtin\n-                // bounds attached to the object cast. (In other words, if the\n-                // object type is Foo+Send, this would create an obligation\n-                // for the Send check.)\n-                for bound in &builtin_bounds {\n-                    if let Ok(tr) = tcx.trait_ref_for_builtin_bound(bound, source) {\n-                        push(tr.to_predicate());\n-                    } else {\n-                        return Err(Unimplemented);\n-                    }\n+                // Create obligations:\n+                //  - Casting T to Trait\n+                //  - For all the various builtin bounds attached to the object cast. (In other\n+                //  words, if the object type is Foo+Send, this would create an obligation for the\n+                //  Send check.)\n+                //  - Projection predicates\n+                for predicate in data.iter() {\n+                    push(predicate.with_self_ty(tcx, source));\n                 }\n \n-                // Create obligations for the projection predicates.\n-                for bound in &data.projection_bounds {\n-                    push(bound.with_self_ty(tcx, source).to_predicate());\n-                }\n+                // We can only make objects from sized types.\n+                let tr = ty::TraitRef {\n+                    def_id: tcx.require_lang_item(lang_items::SizedTraitLangItem),\n+                    substs: tcx.mk_substs_trait(source, &[]),\n+                };\n+                push(tr.to_predicate());\n \n                 // If the type is `Foo+'a`, ensures that the type\n                 // being cast to `Foo+'a` outlives `'a`:\n-                let outlives = ty::OutlivesPredicate(source, data.region_bound);\n+                let outlives = ty::OutlivesPredicate(source, r);\n                 push(ty::Binder(outlives).to_predicate());\n             }\n \n@@ -2557,7 +2536,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             (&ty::TyAdt(def, substs_a), &ty::TyAdt(_, substs_b)) => {\n                 let fields = def\n                     .all_fields()\n-                    .map(|f| f.unsubst_ty())\n+                    .map(|f| tcx.item_type(f.did))\n                     .collect::<Vec<_>>();\n \n                 // The last field of the structure has to exist and contain type parameters."}, {"sha": "59e3d398b2fd37ae502d863b3d1fe635458a7b2e", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -127,6 +127,7 @@ pub fn find_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 let substs = substs.rebase_onto(tcx, trait_def_id, impl_data.substs);\n                 let substs = translate_substs(&infcx, impl_data.impl_def_id,\n                                               substs, node_item.node);\n+                let substs = infcx.tcx.erase_regions(&substs);\n                 tcx.lift(&substs).unwrap_or_else(|| {\n                     bug!(\"find_method: translate_substs \\\n                           returned {:?} which contains inference types/regions\","}, {"sha": "a41523f2def76385d1cc323bf6ff103781ac4c6a", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -297,18 +297,18 @@ impl<'a, 'gcx, 'tcx> Node {\n     }\n }\n \n-pub struct Ancestors<'a, 'tcx: 'a> {\n-    trait_def: &'a TraitDef<'tcx>,\n+pub struct Ancestors<'a> {\n+    trait_def: &'a TraitDef,\n     current_source: Option<Node>,\n }\n \n-impl<'a, 'tcx> Iterator for Ancestors<'a, 'tcx> {\n+impl<'a> Iterator for Ancestors<'a> {\n     type Item = Node;\n     fn next(&mut self) -> Option<Node> {\n         let cur = self.current_source.take();\n         if let Some(Node::Impl(cur_impl)) = cur {\n             let parent = self.trait_def.specialization_graph.borrow().parent(cur_impl);\n-            if parent == self.trait_def.def_id() {\n+            if parent == self.trait_def.def_id {\n                 self.current_source = Some(Node::Trait(parent));\n             } else {\n                 self.current_source = Some(Node::Impl(parent));\n@@ -332,7 +332,7 @@ impl<T> NodeItem<T> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> Ancestors<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Ancestors<'a> {\n     /// Search the items from the given ancestors, returning each definition\n     /// with the given name and the given kind.\n     #[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n@@ -347,9 +347,7 @@ impl<'a, 'gcx, 'tcx> Ancestors<'a, 'tcx> {\n \n /// Walk up the specialization ancestors of a given impl, starting with that\n /// impl itself.\n-pub fn ancestors<'a, 'tcx>(trait_def: &'a TraitDef<'tcx>,\n-                           start_from_impl: DefId)\n-                           -> Ancestors<'a, 'tcx> {\n+pub fn ancestors<'a>(trait_def: &'a TraitDef, start_from_impl: DefId) -> Ancestors<'a> {\n     Ancestors {\n         trait_def: trait_def,\n         current_source: Some(Node::Impl(start_from_impl)),"}, {"sha": "dedb126d7ff6d6d40b5e304fa2385caed9fdf6b9", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -190,9 +190,6 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n             super::VariableType(id) => Some(super::VariableType(id)),\n             super::ReturnType => Some(super::ReturnType),\n             super::RepeatVec => Some(super::RepeatVec),\n-            super::ClosureCapture(node_id, span, bound) => {\n-                Some(super::ClosureCapture(node_id, span, bound))\n-            }\n             super::FieldSized => Some(super::FieldSized),\n             super::ConstSized => Some(super::ConstSized),\n             super::SharedStatic => Some(super::SharedStatic),\n@@ -507,7 +504,6 @@ impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCauseCode<'tcx> {\n             super::VariableType(_) |\n             super::ReturnType |\n             super::RepeatVec |\n-            super::ClosureCapture(..) |\n             super::FieldSized |\n             super::ConstSized |\n             super::SharedStatic |\n@@ -552,7 +548,6 @@ impl<'tcx> TypeFoldable<'tcx> for traits::ObligationCauseCode<'tcx> {\n             super::VariableType(_) |\n             super::ReturnType |\n             super::RepeatVec |\n-            super::ClosureCapture(..) |\n             super::FieldSized |\n             super::ConstSized |\n             super::SharedStatic |"}, {"sha": "cebd8bf87d736cca88ae75bcf5917a22d5193da3", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 4, "deletions": 34, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -12,7 +12,6 @@ use hir::def_id::DefId;\n use ty::subst::{Subst, Substs};\n use ty::{self, Ty, TyCtxt, ToPredicate, ToPolyTraitRef};\n use ty::outlives::Component;\n-use util::common::ErrorReported;\n use util::nodemap::FxHashSet;\n \n use super::{Obligation, ObligationCause, PredicateObligation, SelectionContext, Normalized};\n@@ -408,25 +407,6 @@ pub fn predicate_for_trait_ref<'tcx>(\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn trait_ref_for_builtin_bound(self,\n-        builtin_bound: ty::BuiltinBound,\n-        param_ty: Ty<'tcx>)\n-        -> Result<ty::TraitRef<'tcx>, ErrorReported>\n-    {\n-        match self.lang_items.from_builtin_kind(builtin_bound) {\n-            Ok(def_id) => {\n-                Ok(ty::TraitRef {\n-                    def_id: def_id,\n-                    substs: self.mk_substs_trait(param_ty, &[])\n-                })\n-            }\n-            Err(e) => {\n-                self.sess.err(&e);\n-                Err(ErrorReported)\n-            }\n-        }\n-    }\n-\n     pub fn predicate_for_trait_def(self,\n         cause: ObligationCause<'tcx>,\n         trait_def_id: DefId,\n@@ -442,17 +422,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         predicate_for_trait_ref(cause, trait_ref, recursion_depth)\n     }\n \n-    pub fn predicate_for_builtin_bound(self,\n-        cause: ObligationCause<'tcx>,\n-        builtin_bound: ty::BuiltinBound,\n-        recursion_depth: usize,\n-        param_ty: Ty<'tcx>)\n-        -> Result<PredicateObligation<'tcx>, ErrorReported>\n-    {\n-        let trait_ref = self.trait_ref_for_builtin_bound(builtin_bound, param_ty)?;\n-        Ok(predicate_for_trait_ref(cause, trait_ref, recursion_depth))\n-    }\n-\n     /// Cast a trait reference into a reference to one of its super\n     /// traits; returns `None` if `target_trait_def_id` is not a\n     /// supertrait.\n@@ -518,14 +487,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         -> ty::Binder<(ty::TraitRef<'tcx>, Ty<'tcx>)>\n     {\n         let arguments_tuple = match tuple_arguments {\n-            TupleArgumentsFlag::No => sig.0.inputs[0],\n-            TupleArgumentsFlag::Yes => self.intern_tup(&sig.0.inputs[..]),\n+            TupleArgumentsFlag::No => sig.skip_binder().inputs()[0],\n+            TupleArgumentsFlag::Yes =>\n+                self.intern_tup(sig.skip_binder().inputs()),\n         };\n         let trait_ref = ty::TraitRef {\n             def_id: fn_trait_def_id,\n             substs: self.mk_substs_trait(self_ty, &[arguments_tuple]),\n         };\n-        ty::Binder((trait_ref, sig.0.output))\n+        ty::Binder((trait_ref, sig.skip_binder().output()))\n     }\n }\n "}, {"sha": "8c3cb7929488064cb3982949452d352e121388bd", "filename": "src/librustc/ty/contents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Fcontents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Fcontents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontents.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -195,7 +195,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                     tc_ty(tcx, typ, cache).owned_pointer()\n                 }\n \n-                ty::TyTrait(_) => {\n+                ty::TyDynamic(..) => {\n                     TC::All - TC::InteriorParam\n                 }\n "}, {"sha": "4854a14f733f552c89e10e3252e1cbdb72a792ec", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 101, "deletions": 52, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -14,7 +14,7 @@ use dep_graph::{DepGraph, DepTrackingMap};\n use session::Session;\n use middle;\n use hir::TraitMap;\n-use hir::def::DefMap;\n+use hir::def::Def;\n use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use hir::map as ast_map;\n use hir::map::{DefKey, DefPathData, DisambiguatedDefPathData};\n@@ -29,7 +29,7 @@ use ty::{self, TraitRef, Ty, TypeAndMut};\n use ty::{TyS, TypeVariants, Slice};\n use ty::{AdtKind, AdtDef, ClosureSubsts, Region};\n use hir::FreevarMap;\n-use ty::{BareFnTy, InferTy, ParamTy, ProjectionTy, TraitObject};\n+use ty::{BareFnTy, InferTy, ParamTy, ProjectionTy, ExistentialPredicate};\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n use ty::TypeVariants::*;\n use ty::layout::{Layout, TargetDataLayout};\n@@ -47,6 +47,7 @@ use std::mem;\n use std::ops::Deref;\n use std::rc::Rc;\n use std::iter;\n+use std::cmp::Ordering;\n use syntax::ast::{self, Name, NodeId};\n use syntax::attr;\n use syntax::symbol::{Symbol, keywords};\n@@ -63,11 +64,12 @@ pub struct CtxtArenas<'tcx> {\n     region: TypedArena<Region>,\n     stability: TypedArena<attr::Stability>,\n     layout: TypedArena<Layout>,\n+    existential_predicates: TypedArena<ExistentialPredicate<'tcx>>,\n \n     // references\n     generics: TypedArena<ty::Generics<'tcx>>,\n-    trait_def: TypedArena<ty::TraitDef<'tcx>>,\n-    adt_def: TypedArena<ty::AdtDefData<'tcx, 'tcx>>,\n+    trait_def: TypedArena<ty::TraitDef>,\n+    adt_def: TypedArena<ty::AdtDef>,\n     mir: TypedArena<RefCell<Mir<'tcx>>>,\n }\n \n@@ -81,6 +83,7 @@ impl<'tcx> CtxtArenas<'tcx> {\n             region: TypedArena::new(),\n             stability: TypedArena::new(),\n             layout: TypedArena::new(),\n+            existential_predicates: TypedArena::new(),\n \n             generics: TypedArena::new(),\n             trait_def: TypedArena::new(),\n@@ -103,6 +106,7 @@ pub struct CtxtInterners<'tcx> {\n     region: RefCell<FxHashSet<Interned<'tcx, Region>>>,\n     stability: RefCell<FxHashSet<&'tcx attr::Stability>>,\n     layout: RefCell<FxHashSet<&'tcx Layout>>,\n+    existential_predicates: RefCell<FxHashSet<Interned<'tcx, Slice<ExistentialPredicate<'tcx>>>>>,\n }\n \n impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n@@ -115,7 +119,8 @@ impl<'gcx: 'tcx, 'tcx> CtxtInterners<'tcx> {\n             bare_fn: RefCell::new(FxHashSet()),\n             region: RefCell::new(FxHashSet()),\n             stability: RefCell::new(FxHashSet()),\n-            layout: RefCell::new(FxHashSet())\n+            layout: RefCell::new(FxHashSet()),\n+            existential_predicates: RefCell::new(FxHashSet()),\n         }\n     }\n \n@@ -201,6 +206,9 @@ pub struct CommonTypes<'tcx> {\n }\n \n pub struct Tables<'tcx> {\n+    /// Resolved definitions for `<T>::X` associated paths.\n+    pub type_relative_path_defs: NodeMap<Def>,\n+\n     /// Stores the types for various nodes in the AST.  Note that this table\n     /// is not guaranteed to be populated until after typeck.  See\n     /// typeck::check::fn_ctxt for details.\n@@ -244,6 +252,7 @@ pub struct Tables<'tcx> {\n impl<'a, 'gcx, 'tcx> Tables<'tcx> {\n     pub fn empty() -> Tables<'tcx> {\n         Tables {\n+            type_relative_path_defs: NodeMap(),\n             node_types: FxHashMap(),\n             item_substs: NodeMap(),\n             adjustments: NodeMap(),\n@@ -256,6 +265,16 @@ impl<'a, 'gcx, 'tcx> Tables<'tcx> {\n         }\n     }\n \n+    /// Returns the final resolution of a `QPath` in an `Expr` or `Pat` node.\n+    pub fn qpath_def(&self, qpath: &hir::QPath, id: NodeId) -> Def {\n+        match *qpath {\n+            hir::QPath::Resolved(_, ref path) => path.def,\n+            hir::QPath::TypeRelative(..) => {\n+                self.type_relative_path_defs.get(&id).cloned().unwrap_or(Def::Err)\n+            }\n+        }\n+    }\n+\n     pub fn node_id_to_type(&self, id: NodeId) -> Ty<'tcx> {\n         match self.node_id_to_type_opt(id) {\n             Some(ty) => ty,\n@@ -379,11 +398,6 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub sess: &'tcx Session,\n \n-    /// Map from path id to the results from resolve; generated\n-    /// initially by resolve and updated during typeck in some cases\n-    /// (e.g., UFCS paths)\n-    pub def_map: RefCell<DefMap>,\n-\n     /// Map indicating what traits are in scope for places where this\n     /// is relevant; generated by resolve.\n     pub trait_map: TraitMap,\n@@ -411,6 +425,7 @@ pub struct GlobalCtxt<'tcx> {\n     pub impl_trait_refs: RefCell<DepTrackingMap<maps::ImplTraitRefs<'tcx>>>,\n     pub trait_defs: RefCell<DepTrackingMap<maps::TraitDefs<'tcx>>>,\n     pub adt_defs: RefCell<DepTrackingMap<maps::AdtDefs<'tcx>>>,\n+    pub adt_sized_constraint: RefCell<DepTrackingMap<maps::AdtSizedConstraint<'tcx>>>,\n \n     /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n     /// associated generics and predicates.\n@@ -674,38 +689,17 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.global_interners.arenas.mir.alloc(RefCell::new(mir))\n     }\n \n-    pub fn intern_trait_def(self, def: ty::TraitDef<'gcx>)\n-                            -> &'gcx ty::TraitDef<'gcx> {\n-        let did = def.trait_ref.def_id;\n-        let interned = self.alloc_trait_def(def);\n-        if let Some(prev) = self.trait_defs.borrow_mut().insert(did, interned) {\n-            bug!(\"Tried to overwrite interned TraitDef: {:?}\", prev)\n-        }\n-        self.generics.borrow_mut().insert(did, interned.generics);\n-        interned\n-    }\n-\n-    pub fn alloc_trait_def(self, def: ty::TraitDef<'gcx>)\n-                           -> &'gcx ty::TraitDef<'gcx> {\n+    pub fn alloc_trait_def(self, def: ty::TraitDef) -> &'gcx ty::TraitDef {\n         self.global_interners.arenas.trait_def.alloc(def)\n     }\n \n-    pub fn insert_adt_def(self, did: DefId, adt_def: ty::AdtDefMaster<'gcx>) {\n-        // this will need a transmute when reverse-variance is removed\n-        if let Some(prev) = self.adt_defs.borrow_mut().insert(did, adt_def) {\n-            bug!(\"Tried to overwrite interned AdtDef: {:?}\", prev)\n-        }\n-    }\n-\n-    pub fn intern_adt_def(self,\n-                          did: DefId,\n-                          kind: AdtKind,\n-                          variants: Vec<ty::VariantDefData<'gcx, 'gcx>>)\n-                          -> ty::AdtDefMaster<'gcx> {\n-        let def = ty::AdtDefData::new(self, did, kind, variants);\n-        let interned = self.global_interners.arenas.adt_def.alloc(def);\n-        self.insert_adt_def(did, interned);\n-        interned\n+    pub fn alloc_adt_def(self,\n+                         did: DefId,\n+                         kind: AdtKind,\n+                         variants: Vec<ty::VariantDef>)\n+                         -> &'gcx ty::AdtDef {\n+        let def = ty::AdtDef::new(self, did, kind, variants);\n+        self.global_interners.arenas.adt_def.alloc(def)\n     }\n \n     pub fn intern_stability(self, stab: attr::Stability) -> &'gcx attr::Stability {\n@@ -768,7 +762,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// reference to the context, to allow formatting values that need it.\n     pub fn create_and_enter<F, R>(s: &'tcx Session,\n                                   arenas: &'tcx CtxtArenas<'tcx>,\n-                                  def_map: DefMap,\n                                   trait_map: TraitMap,\n                                   named_region_map: resolve_lifetime::NamedRegionMap,\n                                   map: ast_map::Map<'tcx>,\n@@ -797,12 +790,12 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             item_variance_map: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             variance_computed: Cell::new(false),\n             sess: s,\n-            def_map: RefCell::new(def_map),\n             trait_map: trait_map,\n             tables: RefCell::new(Tables::empty()),\n             impl_trait_refs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             trait_defs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             adt_defs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            adt_sized_constraint: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             generics: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             predicates: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             super_predicates: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n@@ -951,6 +944,27 @@ impl<'a, 'tcx> Lift<'tcx> for &'a Slice<Ty<'a>> {\n     }\n }\n \n+impl<'a, 'tcx> Lift<'tcx> for &'a Slice<ExistentialPredicate<'a>> {\n+    type Lifted = &'tcx Slice<ExistentialPredicate<'tcx>>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n+        -> Option<&'tcx Slice<ExistentialPredicate<'tcx>>> {\n+        if self.is_empty() {\n+            return Some(Slice::empty());\n+        }\n+        if let Some(&Interned(eps)) = tcx.interners.existential_predicates.borrow().get(&self[..]) {\n+            if *self as *const _ == eps as *const _ {\n+                return Some(eps);\n+            }\n+        }\n+        // Also try in the global tcx if we're not that.\n+        if !tcx.is_global() {\n+            self.lift_to_tcx(tcx.global_tcx())\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n impl<'a, 'tcx> Lift<'tcx> for &'a BareFnTy<'a> {\n     type Lifted = &'tcx BareFnTy<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>)\n@@ -1119,7 +1133,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n         sty_debug_print!(\n             self,\n             TyAdt, TyBox, TyArray, TySlice, TyRawPtr, TyRef, TyFnDef, TyFnPtr,\n-            TyTrait, TyClosure, TyTuple, TyParam, TyInfer, TyProjection, TyAnon);\n+            TyDynamic, TyClosure, TyTuple, TyParam, TyInfer, TyProjection, TyAnon);\n \n         println!(\"Substs interner: #{}\", self.interners.substs.borrow().len());\n         println!(\"BareFnTy interner: #{}\", self.interners.bare_fn.borrow().len());\n@@ -1193,6 +1207,13 @@ impl<'tcx> Borrow<Region> for Interned<'tcx, Region> {\n     }\n }\n \n+impl<'tcx: 'lcx, 'lcx> Borrow<[ExistentialPredicate<'lcx>]>\n+    for Interned<'tcx, Slice<ExistentialPredicate<'tcx>>> {\n+    fn borrow<'a>(&'a self) -> &'a [ExistentialPredicate<'lcx>] {\n+        &self.0[..]\n+    }\n+}\n+\n macro_rules! intern_method {\n     ($lt_tcx:tt, $name:ident: $method:ident($alloc:ty,\n                                             $alloc_method:ident,\n@@ -1290,6 +1311,7 @@ macro_rules! slice_interners {\n }\n \n slice_interners!(\n+    existential_predicates: _intern_existential_predicates(ExistentialPredicate),\n     type_list: _intern_type_list(Ty),\n     substs: _intern_substs(Kind)\n );\n@@ -1351,7 +1373,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_imm_ref(self.mk_region(ty::ReStatic), self.mk_str())\n     }\n \n-    pub fn mk_adt(self, def: AdtDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_adt(self, def: &'tcx AdtDef, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n         // take a copy of substs so that we own the vectors inside\n         self.mk_ty(TyAdt(def, substs))\n     }\n@@ -1430,24 +1452,27 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_ty(TyFnPtr(fty))\n     }\n \n-    pub fn mk_trait(self, mut obj: TraitObject<'tcx>) -> Ty<'tcx> {\n-        obj.projection_bounds.sort_by_key(|b| b.sort_key(self));\n-        self.mk_ty(TyTrait(box obj))\n+    pub fn mk_dynamic(\n+        self,\n+        obj: ty::Binder<&'tcx Slice<ExistentialPredicate<'tcx>>>,\n+        reg: &'tcx ty::Region\n+    ) -> Ty<'tcx> {\n+        self.mk_ty(TyDynamic(obj, reg))\n     }\n \n     pub fn mk_projection(self,\n                          trait_ref: TraitRef<'tcx>,\n                          item_name: Name)\n-                         -> Ty<'tcx> {\n-        // take a copy of substs so that we own the vectors inside\n-        let inner = ProjectionTy { trait_ref: trait_ref, item_name: item_name };\n-        self.mk_ty(TyProjection(inner))\n-    }\n+        -> Ty<'tcx> {\n+            // take a copy of substs so that we own the vectors inside\n+            let inner = ProjectionTy { trait_ref: trait_ref, item_name: item_name };\n+            self.mk_ty(TyProjection(inner))\n+        }\n \n     pub fn mk_closure(self,\n                       closure_id: DefId,\n                       substs: &'tcx Substs<'tcx>)\n-                      -> Ty<'tcx> {\n+        -> Ty<'tcx> {\n         self.mk_closure_from_closure_substs(closure_id, ClosureSubsts {\n             substs: substs\n         })\n@@ -1494,6 +1519,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_ty(TyAnon(def_id, substs))\n     }\n \n+    pub fn intern_existential_predicates(self, eps: &[ExistentialPredicate<'tcx>])\n+        -> &'tcx Slice<ExistentialPredicate<'tcx>> {\n+        assert!(!eps.is_empty());\n+        assert!(eps.windows(2).all(|w| w[0].cmp(self, &w[1]) != Ordering::Greater));\n+        self._intern_existential_predicates(eps)\n+    }\n+\n     pub fn intern_type_list(self, ts: &[Ty<'tcx>]) -> &'tcx Slice<Ty<'tcx>> {\n         if ts.len() == 0 {\n             Slice::empty()\n@@ -1510,6 +1542,23 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn mk_fn_sig<I>(self, inputs: I, output: I::Item, variadic: bool)\n+        -> <I::Item as InternIteratorElement<Ty<'tcx>, ty::FnSig<'tcx>>>::Output\n+        where I: Iterator,\n+              I::Item: InternIteratorElement<Ty<'tcx>, ty::FnSig<'tcx>>\n+    {\n+        inputs.chain(iter::once(output)).intern_with(|xs| ty::FnSig {\n+            inputs_and_output: self.intern_type_list(xs),\n+            variadic: variadic\n+        })\n+    }\n+\n+    pub fn mk_existential_predicates<I: InternAs<[ExistentialPredicate<'tcx>],\n+                                     &'tcx Slice<ExistentialPredicate<'tcx>>>>(self, iter: I)\n+                                     -> I::Output {\n+        iter.intern_with(|xs| self.intern_existential_predicates(xs))\n+    }\n+\n     pub fn mk_type_list<I: InternAs<[Ty<'tcx>],\n                         &'tcx Slice<Ty<'tcx>>>>(self, iter: I) -> I::Output {\n         iter.intern_with(|xs| self.intern_type_list(xs))"}, {"sha": "e95ce97e13577f19d36573988b739e2e0aa6ae85", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 11, "deletions": 25, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -45,12 +45,12 @@ pub enum TypeError<'tcx> {\n     IntMismatch(ExpectedFound<ty::IntVarValue>),\n     FloatMismatch(ExpectedFound<ast::FloatTy>),\n     Traits(ExpectedFound<DefId>),\n-    BuiltinBoundsMismatch(ExpectedFound<ty::BuiltinBounds>),\n     VariadicMismatch(ExpectedFound<bool>),\n     CyclicTy,\n     ProjectionNameMismatched(ExpectedFound<Name>),\n     ProjectionBoundsLength(ExpectedFound<usize>),\n-    TyParamDefaultMismatch(ExpectedFound<type_variable::Default<'tcx>>)\n+    TyParamDefaultMismatch(ExpectedFound<type_variable::Default<'tcx>>),\n+    ExistentialMismatch(ExpectedFound<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>),\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n@@ -135,19 +135,6 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n                                        format!(\"trait `{}`\",\n                                                tcx.item_path_str(values.found)))\n             }),\n-            BuiltinBoundsMismatch(values) => {\n-                if values.expected.is_empty() {\n-                    write!(f, \"expected no bounds, found `{}`\",\n-                           values.found)\n-                } else if values.found.is_empty() {\n-                    write!(f, \"expected bounds `{}`, found no bounds\",\n-                           values.expected)\n-                } else {\n-                    write!(f, \"expected bounds `{}`, found bounds `{}`\",\n-                           values.expected,\n-                           values.found)\n-                }\n-            }\n             IntMismatch(ref values) => {\n                 write!(f, \"expected `{:?}`, found `{:?}`\",\n                        values.expected,\n@@ -178,6 +165,10 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n                        values.expected.ty,\n                        values.found.ty)\n             }\n+            ExistentialMismatch(ref values) => {\n+                report_maybe_different(f, format!(\"trait `{}`\", values.expected),\n+                                       format!(\"trait `{}`\", values.found))\n+            }\n         }\n     }\n }\n@@ -214,8 +205,9 @@ impl<'a, 'gcx, 'lcx, 'tcx> ty::TyS<'tcx> {\n             }\n             ty::TyFnDef(..) => format!(\"fn item\"),\n             ty::TyFnPtr(_) => \"fn pointer\".to_string(),\n-            ty::TyTrait(ref inner) => {\n-                format!(\"trait {}\", tcx.item_path_str(inner.principal.def_id()))\n+            ty::TyDynamic(ref inner, ..) => {\n+                inner.principal().map_or_else(|| \"trait\".to_string(),\n+                    |p| format!(\"trait {}\", tcx.item_path_str(p.def_id())))\n             }\n             ty::TyClosure(..) => \"closure\".to_string(),\n             ty::TyTuple(_) => \"tuple\".to_string(),\n@@ -291,10 +283,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                                           expected.ty,\n                                           found.ty));\n \n-                match\n-                    self.map.as_local_node_id(expected.def_id)\n-                            .and_then(|node_id| self.map.opt_span(node_id))\n-                {\n+                match self.map.span_if_local(expected.def_id) {\n                     Some(span) => {\n                         db.span_note(span, \"a default was defined here...\");\n                     }\n@@ -308,10 +297,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                     expected.origin_span,\n                     \"...that was applied to an unconstrained type variable here\");\n \n-                match\n-                    self.map.as_local_node_id(found.def_id)\n-                            .and_then(|node_id| self.map.opt_span(node_id))\n-                {\n+                match self.map.span_if_local(found.def_id) {\n                     Some(span) => {\n                         db.span_note(span, \"a second default was defined here...\");\n                     }"}, {"sha": "7b4d76ad4973e0ce7e3c635916cf559d025b07fd", "filename": "src/librustc/ty/fast_reject.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Ffast_reject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Ffast_reject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffast_reject.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -11,6 +11,7 @@\n use hir::def_id::DefId;\n use ty::{self, Ty, TyCtxt};\n use syntax::ast;\n+use middle::lang_items::OwnedBoxLangItem;\n \n use self::SimplifiedType::*;\n \n@@ -59,8 +60,8 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ty::TyStr => Some(StrSimplifiedType),\n         ty::TyArray(..) | ty::TySlice(_) => Some(ArraySimplifiedType),\n         ty::TyRawPtr(_) => Some(PtrSimplifiedType),\n-        ty::TyTrait(ref trait_info) => {\n-            Some(TraitSimplifiedType(trait_info.principal.def_id()))\n+        ty::TyDynamic(ref trait_info, ..) => {\n+            trait_info.principal().map(|p| TraitSimplifiedType(p.def_id()))\n         }\n         ty::TyRef(_, mt) => {\n             // since we introduce auto-refs during method lookup, we\n@@ -70,10 +71,7 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         }\n         ty::TyBox(_) => {\n             // treat like we would treat `Box`\n-            match tcx.lang_items.require_owned_box() {\n-                Ok(def_id) => Some(AdtSimplifiedType(def_id)),\n-                Err(msg) => tcx.sess.fatal(&msg),\n-            }\n+            Some(AdtSimplifiedType(tcx.require_lang_item(OwnedBoxLangItem)))\n         }\n         ty::TyClosure(def_id, _) => {\n             Some(ClosureSimplifiedType(def_id))\n@@ -83,7 +81,7 @@ pub fn simplify_type<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n             Some(TupleSimplifiedType(tys.len()))\n         }\n         ty::TyFnDef(.., ref f) | ty::TyFnPtr(ref f) => {\n-            Some(FunctionSimplifiedType(f.sig.0.inputs.len()))\n+            Some(FunctionSimplifiedType(f.sig.skip_binder().inputs().len()))\n         }\n         ty::TyProjection(_) | ty::TyParam(_) => {\n             if can_simplify_params {"}, {"sha": "a06d3ed6cf4fb093b6352f18a1ccd94111021dd6", "filename": "src/librustc/ty/flags.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fflags.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -121,16 +121,21 @@ impl FlagComputation {\n                 self.add_substs(substs);\n             }\n \n-            &ty::TyTrait(ref obj) => {\n+            &ty::TyDynamic(ref obj, r) => {\n                 let mut computation = FlagComputation::new();\n-                computation.add_substs(obj.principal.skip_binder().substs);\n-                for projection_bound in &obj.projection_bounds {\n-                    let mut proj_computation = FlagComputation::new();\n-                    proj_computation.add_existential_projection(&projection_bound.0);\n-                    self.add_bound_computation(&proj_computation);\n+                for predicate in obj.skip_binder().iter() {\n+                    match *predicate {\n+                        ty::ExistentialPredicate::Trait(tr) => computation.add_substs(tr.substs),\n+                        ty::ExistentialPredicate::Projection(p) => {\n+                            let mut proj_computation = FlagComputation::new();\n+                            proj_computation.add_existential_projection(&p);\n+                            self.add_bound_computation(&proj_computation);\n+                        }\n+                        ty::ExistentialPredicate::AutoTrait(_) => {}\n+                    }\n                 }\n                 self.add_bound_computation(&computation);\n-                self.add_region(obj.region_bound);\n+                self.add_region(r);\n             }\n \n             &ty::TyBox(tt) | &ty::TyArray(tt, _) | &ty::TySlice(tt) => {\n@@ -175,8 +180,8 @@ impl FlagComputation {\n     fn add_fn_sig(&mut self, fn_sig: &ty::PolyFnSig) {\n         let mut computation = FlagComputation::new();\n \n-        computation.add_tys(&fn_sig.0.inputs);\n-        computation.add_ty(fn_sig.0.output);\n+        computation.add_tys(fn_sig.skip_binder().inputs());\n+        computation.add_ty(fn_sig.skip_binder().output());\n \n         self.add_bound_computation(&computation);\n     }"}, {"sha": "10754825a8c1873c9b7100ea262ee5643daf09b7", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -191,6 +191,10 @@ pub trait TypeVisitor<'tcx> : Sized {\n         t.super_visit_with(self)\n     }\n \n+    fn visit_trait_ref(&mut self, trait_ref: ty::TraitRef<'tcx>) -> bool {\n+        trait_ref.super_visit_with(self)\n+    }\n+\n     fn visit_region(&mut self, r: &'tcx ty::Region) -> bool {\n         r.super_visit_with(self)\n     }"}, {"sha": "440a3916786fa3224fb25ecf8bc6a002d6fa8c77", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -316,7 +316,7 @@ pub fn characteristic_def_id_of_type(ty: Ty) -> Option<DefId> {\n     match ty.sty {\n         ty::TyAdt(adt_def, _) => Some(adt_def.did),\n \n-        ty::TyTrait(ref data) => Some(data.principal.def_id()),\n+        ty::TyDynamic(data, ..) => data.principal().map(|p| p.def_id()),\n \n         ty::TyArray(subty, _) |\n         ty::TySlice(subty) |"}, {"sha": "634599406afb2fc49627a734559fccb5e0c4abc1", "filename": "src/librustc/ty/ivar.rs", "status": "removed", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/c61baa0fc7a85bd2bcce34aac05ed739261cf037/src%2Flibrustc%2Fty%2Fivar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c61baa0fc7a85bd2bcce34aac05ed739261cf037/src%2Flibrustc%2Fty%2Fivar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fivar.rs?ref=c61baa0fc7a85bd2bcce34aac05ed739261cf037", "patch": "@@ -1,90 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use dep_graph::DepNode;\n-use hir::def_id::DefId;\n-use ty::{Ty, TyS};\n-use ty::tls;\n-\n-use rustc_data_structures::ivar;\n-\n-use std::fmt;\n-use std::marker::PhantomData;\n-use core::nonzero::NonZero;\n-\n-/// An IVar that contains a Ty. 'lt is a (reverse-variant) upper bound\n-/// on the lifetime of the IVar. This is required because of variance\n-/// problems: the IVar needs to be variant with respect to 'tcx (so\n-/// it can be referred to from Ty) but can only be modified if its\n-/// lifetime is exactly 'tcx.\n-///\n-/// Safety invariants:\n-///     (A) self.0, if fulfilled, is a valid Ty<'tcx>\n-///     (B) no aliases to this value with a 'tcx longer than this\n-///         value's 'lt exist\n-///\n-/// Dependency tracking: each ivar does not know what node in the\n-/// dependency graph it is associated with, so when you get/fulfill\n-/// you must supply a `DepNode` id. This should always be the same id!\n-///\n-/// NonZero is used rather than Unique because Unique isn't Copy.\n-pub struct TyIVar<'tcx, 'lt: 'tcx>(ivar::Ivar<NonZero<*const TyS<'static>>>,\n-                                   PhantomData<fn(TyS<'lt>)->TyS<'tcx>>);\n-\n-impl<'tcx, 'lt> TyIVar<'tcx, 'lt> {\n-    #[inline]\n-    pub fn new() -> Self {\n-        // Invariant (A) satisfied because the IVar is unfulfilled\n-        // Invariant (B) because 'lt : 'tcx\n-        TyIVar(ivar::Ivar::new(), PhantomData)\n-    }\n-\n-    #[inline]\n-    pub fn get(&self, dep_node: DepNode<DefId>) -> Option<Ty<'tcx>> {\n-        tls::with(|tcx| tcx.dep_graph.read(dep_node));\n-        self.untracked_get()\n-    }\n-\n-    /// Reads the ivar without registered a dep-graph read. Use with\n-    /// caution.\n-    #[inline]\n-    pub fn untracked_get(&self) -> Option<Ty<'tcx>> {\n-        match self.0.get() {\n-            None => None,\n-            // valid because of invariant (A)\n-            Some(v) => Some(unsafe { &*(*v as *const TyS<'tcx>) })\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn unwrap(&self, dep_node: DepNode<DefId>) -> Ty<'tcx> {\n-        self.get(dep_node).unwrap()\n-    }\n-\n-    pub fn fulfill(&self, dep_node: DepNode<DefId>, value: Ty<'lt>) {\n-        tls::with(|tcx| tcx.dep_graph.write(dep_node));\n-\n-        // Invariant (A) is fulfilled, because by (B), every alias\n-        // of this has a 'tcx longer than 'lt.\n-        let value: *const TyS<'lt> = value;\n-        // FIXME(27214): unneeded [as *const ()]\n-        let value = value as *const () as *const TyS<'static>;\n-        self.0.fulfill(unsafe { NonZero::new(value) })\n-    }\n-}\n-\n-impl<'tcx, 'lt> fmt::Debug for TyIVar<'tcx, 'lt> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match self.untracked_get() {\n-            Some(val) => write!(f, \"TyIVar({:?})\", val),\n-            None => f.write_str(\"TyIVar(<unfulfilled>)\")\n-        }\n-    }\n-}"}, {"sha": "8646bccf1e9ed75d91856385a5d2b7e3865f0ffe", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -559,11 +559,14 @@ impl<'a, 'gcx, 'tcx> Struct {\n \n             self.offsets.push(offset);\n \n+            debug!(\"Struct::extend offset: {:?} field: {:?} {:?}\", offset, field, field.size(dl));\n \n             offset = offset.checked_add(field.size(dl), dl)\n                            .map_or(Err(LayoutError::SizeOverflow(scapegoat)), Ok)?;\n         }\n \n+        debug!(\"Struct::extend min_size: {:?}\", offset);\n+\n         self.min_size = offset;\n \n         Ok(())\n@@ -707,12 +710,16 @@ impl<'a, 'gcx, 'tcx> Union {\n                      index, scapegoat);\n             }\n \n+            debug!(\"Union::extend field: {:?} {:?}\", field, field.size(dl));\n+\n             if !self.packed {\n                 self.align = self.align.max(field.align(dl));\n             }\n             self.min_size = cmp::max(self.min_size, field.size(dl));\n         }\n \n+        debug!(\"Union::extend min-size: {:?}\", self.min_size);\n+\n         Ok(())\n     }\n \n@@ -917,7 +924,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         ty::TySlice(_) | ty::TyStr => {\n                             Int(dl.ptr_sized_integer())\n                         }\n-                        ty::TyTrait(_) => Pointer,\n+                        ty::TyDynamic(..) => Pointer,\n                         _ => return Err(LayoutError::Unknown(unsized_part))\n                     };\n                     FatPointer { metadata: meta, non_zero: non_zero }\n@@ -956,7 +963,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     non_zero: false\n                 }\n             }\n-            ty::TyTrait(_) => {\n+            ty::TyDynamic(..) => {\n                 let mut unit = Struct::new(dl, false);\n                 unit.sized = false;\n                 Univariant { variant: unit, non_zero: false }"}, {"sha": "42b3544421f8b01362b8efafff7104b6c5571fe2", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -39,8 +39,9 @@ dep_map_ty! { Predicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n dep_map_ty! { SuperPredicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n dep_map_ty! { AssociatedItemDefIds: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>> }\n dep_map_ty! { ImplTraitRefs: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>> }\n-dep_map_ty! { TraitDefs: ItemSignature(DefId) -> &'tcx ty::TraitDef<'tcx> }\n-dep_map_ty! { AdtDefs: ItemSignature(DefId) -> ty::AdtDefMaster<'tcx> }\n+dep_map_ty! { TraitDefs: ItemSignature(DefId) -> &'tcx ty::TraitDef }\n+dep_map_ty! { AdtDefs: ItemSignature(DefId) -> &'tcx ty::AdtDef }\n+dep_map_ty! { AdtSizedConstraint: SizedConstraint(DefId) -> Ty<'tcx> }\n dep_map_ty! { ItemVariances: ItemSignature(DefId) -> Rc<Vec<ty::Variance>> }\n dep_map_ty! { InherentImpls: InherentImpls(DefId) -> Vec<DefId> }\n dep_map_ty! { ReprHints: ReprHints(DefId) -> Rc<Vec<attr::ReprAttr>> }"}, {"sha": "df12c252907a5a5f319ef34f8e2d10c21b3514c5", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 134, "deletions": 198, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -19,7 +19,7 @@ pub use self::fold::TypeFoldable;\n use dep_graph::{self, DepNode};\n use hir::map as ast_map;\n use middle;\n-use hir::def::{Def, CtorKind, PathResolution, ExportMap};\n+use hir::def::{Def, CtorKind, ExportMap};\n use hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use middle::lang_items::{FnTraitLangItem, FnMutTraitLangItem, FnOnceTraitLangItem};\n use middle::region::{CodeExtent, ROOT_CODE_EXTENT};\n@@ -29,8 +29,7 @@ use ty;\n use ty::subst::{Subst, Substs};\n use ty::walk::TypeWalker;\n use util::common::MemoizationMap;\n-use util::nodemap::NodeSet;\n-use util::nodemap::FxHashMap;\n+use util::nodemap::{NodeSet, NodeMap, FxHashMap, FxHashSet};\n \n use serialize::{self, Encodable, Encoder};\n use std::borrow::Cow;\n@@ -48,14 +47,14 @@ use syntax::symbol::{Symbol, InternedString};\n use syntax_pos::{DUMMY_SP, Span};\n \n use rustc_const_math::ConstInt;\n+use rustc_data_structures::accumulate_vec::IntoIter as AccIntoIter;\n \n use hir;\n use hir::itemlikevisit::ItemLikeVisitor;\n \n pub use self::sty::{Binder, DebruijnIndex};\n-pub use self::sty::{BuiltinBound, BuiltinBounds};\n pub use self::sty::{BareFnTy, FnSig, PolyFnSig};\n-pub use self::sty::{ClosureTy, InferTy, ParamTy, ProjectionTy, TraitObject};\n+pub use self::sty::{ClosureTy, InferTy, ParamTy, ProjectionTy, ExistentialPredicate};\n pub use self::sty::{ClosureSubsts, TypeAndMut};\n pub use self::sty::{TraitRef, TypeVariants, PolyTraitRef};\n pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n@@ -68,11 +67,6 @@ pub use self::sty::InferTy::*;\n pub use self::sty::Region::*;\n pub use self::sty::TypeVariants::*;\n \n-pub use self::sty::BuiltinBound::Send as BoundSend;\n-pub use self::sty::BuiltinBound::Sized as BoundSized;\n-pub use self::sty::BuiltinBound::Copy as BoundCopy;\n-pub use self::sty::BuiltinBound::Sync as BoundSync;\n-\n pub use self::contents::TypeContents;\n pub use self::context::{TyCtxt, tls};\n pub use self::context::{CtxtArenas, Lift, Tables};\n@@ -99,7 +93,6 @@ pub mod util;\n mod contents;\n mod context;\n mod flags;\n-mod ivar;\n mod structural_impls;\n mod sty;\n \n@@ -110,12 +103,13 @@ pub type Disr = ConstInt;\n /// The complete set of all analyses described in this module. This is\n /// produced by the driver and fed to trans and later passes.\n #[derive(Clone)]\n-pub struct CrateAnalysis<'a> {\n+pub struct CrateAnalysis<'tcx> {\n     pub export_map: ExportMap,\n     pub access_levels: middle::privacy::AccessLevels,\n     pub reachable: NodeSet,\n-    pub name: &'a str,\n+    pub name: String,\n     pub glob_map: Option<hir::GlobMap>,\n+    pub hir_ty_to_ty: NodeMap<Ty<'tcx>>,\n }\n \n #[derive(Copy, Clone)]\n@@ -246,7 +240,7 @@ impl Visibility {\n         match *visibility {\n             hir::Public => Visibility::Public,\n             hir::Visibility::Crate => Visibility::Restricted(ast::CRATE_NODE_ID),\n-            hir::Visibility::Restricted { id, .. } => match tcx.expect_def(id) {\n+            hir::Visibility::Restricted { ref path, .. } => match path.def {\n                 // If there is no resolution, `resolve` will have already reported an error, so\n                 // assume that the visibility is public to avoid reporting more privacy errors.\n                 Def::Err => Visibility::Public,\n@@ -628,10 +622,6 @@ pub struct RegionParameterDef<'tcx> {\n }\n \n impl<'tcx> RegionParameterDef<'tcx> {\n-    pub fn to_early_bound_region(&self) -> ty::Region {\n-        ty::ReEarlyBound(self.to_early_bound_region_data())\n-    }\n-\n     pub fn to_early_bound_region_data(&self) -> ty::EarlyBoundRegion {\n         ty::EarlyBoundRegion {\n             index: self.index,\n@@ -1207,7 +1197,7 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         tcx.construct_parameter_environment(\n                             impl_item.span,\n                             tcx.map.local_def_id(id),\n-                            tcx.region_maps.call_site_extent(id, body.id))\n+                            tcx.region_maps.call_site_extent(id, body.node_id()))\n                     }\n                 }\n             }\n@@ -1226,9 +1216,9 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n                         // Use call-site for extent (unless this is a\n                         // trait method with no default; then fallback\n                         // to the method id).\n-                        let extent = if let Some(ref body) = *body {\n+                        let extent = if let Some(body_id) = *body {\n                             // default impl: use call_site extent as free_id_outlive bound.\n-                            tcx.region_maps.call_site_extent(id, body.id)\n+                            tcx.region_maps.call_site_extent(id, body_id.node_id())\n                         } else {\n                             // no default impl: use item extent as free_id_outlive bound.\n                             tcx.region_maps.item_extent(id)\n@@ -1242,14 +1232,14 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n             }\n             Some(ast_map::NodeItem(item)) => {\n                 match item.node {\n-                    hir::ItemFn(.., ref body) => {\n+                    hir::ItemFn(.., body_id) => {\n                         // We assume this is a function.\n                         let fn_def_id = tcx.map.local_def_id(id);\n \n                         tcx.construct_parameter_environment(\n                             item.span,\n                             fn_def_id,\n-                            tcx.region_maps.call_site_extent(id, body.id))\n+                            tcx.region_maps.call_site_extent(id, body_id.node_id()))\n                     }\n                     hir::ItemEnum(..) |\n                     hir::ItemStruct(..) |\n@@ -1279,8 +1269,13 @@ impl<'a, 'tcx> ParameterEnvironment<'tcx> {\n             }\n             Some(ast_map::NodeExpr(expr)) => {\n                 // This is a convenience to allow closures to work.\n-                if let hir::ExprClosure(..) = expr.node {\n-                    ParameterEnvironment::for_item(tcx, tcx.map.get_parent(id))\n+                if let hir::ExprClosure(.., body, _) = expr.node {\n+                    let def_id = tcx.map.local_def_id(id);\n+                    let base_def_id = tcx.closure_base_def_id(def_id);\n+                    tcx.construct_parameter_environment(\n+                        expr.span,\n+                        base_def_id,\n+                        tcx.region_maps.call_site_extent(id, body.node_id()))\n                 } else {\n                     tcx.empty_parameter_environment()\n                 }\n@@ -1313,90 +1308,64 @@ bitflags! {\n     }\n }\n \n-pub type AdtDef<'tcx> = &'tcx AdtDefData<'tcx, 'static>;\n-pub type VariantDef<'tcx> = &'tcx VariantDefData<'tcx, 'static>;\n-pub type FieldDef<'tcx> = &'tcx FieldDefData<'tcx, 'static>;\n-\n-// See comment on AdtDefData for explanation\n-pub type AdtDefMaster<'tcx> = &'tcx AdtDefData<'tcx, 'tcx>;\n-pub type VariantDefMaster<'tcx> = &'tcx VariantDefData<'tcx, 'tcx>;\n-pub type FieldDefMaster<'tcx> = &'tcx FieldDefData<'tcx, 'tcx>;\n-\n-pub struct VariantDefData<'tcx, 'container: 'tcx> {\n+pub struct VariantDef {\n     /// The variant's DefId. If this is a tuple-like struct,\n     /// this is the DefId of the struct's ctor.\n     pub did: DefId,\n     pub name: Name, // struct's name if this is a struct\n     pub disr_val: Disr,\n-    pub fields: Vec<FieldDefData<'tcx, 'container>>,\n+    pub fields: Vec<FieldDef>,\n     pub ctor_kind: CtorKind,\n }\n \n-pub struct FieldDefData<'tcx, 'container: 'tcx> {\n+pub struct FieldDef {\n     pub did: DefId,\n     pub name: Name,\n     pub vis: Visibility,\n-    /// TyIVar is used here to allow for variance (see the doc at\n-    /// AdtDefData).\n-    ///\n-    /// Note: direct accesses to `ty` must also add dep edges.\n-    ty: ivar::TyIVar<'tcx, 'container>\n }\n \n /// The definition of an abstract data type - a struct or enum.\n ///\n /// These are all interned (by intern_adt_def) into the adt_defs\n /// table.\n-///\n-/// Because of the possibility of nested tcx-s, this type\n-/// needs 2 lifetimes: the traditional variant lifetime ('tcx)\n-/// bounding the lifetime of the inner types is of course necessary.\n-/// However, it is not sufficient - types from a child tcx must\n-/// not be leaked into the master tcx by being stored in an AdtDefData.\n-///\n-/// The 'container lifetime ensures that by outliving the container\n-/// tcx and preventing shorter-lived types from being inserted. When\n-/// write access is not needed, the 'container lifetime can be\n-/// erased to 'static, which can be done by the AdtDef wrapper.\n-pub struct AdtDefData<'tcx, 'container: 'tcx> {\n+pub struct AdtDef {\n     pub did: DefId,\n-    pub variants: Vec<VariantDefData<'tcx, 'container>>,\n+    pub variants: Vec<VariantDef>,\n     destructor: Cell<Option<DefId>>,\n-    flags: Cell<AdtFlags>,\n-    sized_constraint: ivar::TyIVar<'tcx, 'container>,\n+    flags: Cell<AdtFlags>\n }\n \n-impl<'tcx, 'container> PartialEq for AdtDefData<'tcx, 'container> {\n-    // AdtDefData are always interned and this is part of TyS equality\n+impl PartialEq for AdtDef {\n+    // AdtDef are always interned and this is part of TyS equality\n     #[inline]\n     fn eq(&self, other: &Self) -> bool { self as *const _ == other as *const _ }\n }\n \n-impl<'tcx, 'container> Eq for AdtDefData<'tcx, 'container> {}\n+impl Eq for AdtDef {}\n \n-impl<'tcx, 'container> Hash for AdtDefData<'tcx, 'container> {\n+impl Hash for AdtDef {\n     #[inline]\n     fn hash<H: Hasher>(&self, s: &mut H) {\n-        (self as *const AdtDefData).hash(s)\n+        (self as *const AdtDef).hash(s)\n     }\n }\n \n-impl<'tcx> serialize::UseSpecializedEncodable for AdtDef<'tcx> {\n+impl<'tcx> serialize::UseSpecializedEncodable for &'tcx AdtDef {\n     fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         self.did.encode(s)\n     }\n }\n \n-impl<'tcx> serialize::UseSpecializedDecodable for AdtDef<'tcx> {}\n+impl<'tcx> serialize::UseSpecializedDecodable for &'tcx AdtDef {}\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum AdtKind { Struct, Union, Enum }\n \n-impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n+impl<'a, 'gcx, 'tcx> AdtDef {\n     fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n            did: DefId,\n            kind: AdtKind,\n-           variants: Vec<VariantDefData<'gcx, 'container>>) -> Self {\n+           variants: Vec<VariantDef>) -> Self {\n         let mut flags = AdtFlags::NO_ADT_FLAGS;\n         let attrs = tcx.get_attrs(did);\n         if attr::contains_name(&attrs, \"fundamental\") {\n@@ -1413,12 +1382,11 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n             AdtKind::Union => flags = flags | AdtFlags::IS_UNION,\n             AdtKind::Struct => {}\n         }\n-        AdtDefData {\n+        AdtDef {\n             did: did,\n             variants: variants,\n             flags: Cell::new(flags),\n             destructor: Cell::new(None),\n-            sized_constraint: ivar::TyIVar::new(),\n         }\n     }\n \n@@ -1429,6 +1397,20 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n         self.flags.set(self.flags.get() | AdtFlags::IS_DTORCK_VALID)\n     }\n \n+    #[inline]\n+    pub fn is_uninhabited_recurse(&self,\n+                                  visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n+                                  block: Option<NodeId>,\n+                                  tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                  substs: &'tcx Substs<'tcx>) -> bool {\n+        if !visited.insert((self.did, substs)) {\n+            return false;\n+        };\n+        self.variants.iter().all(|v| {\n+            v.is_uninhabited_recurse(visited, block, tcx, substs, self.is_union())\n+        })\n+    }\n+\n     #[inline]\n     pub fn is_struct(&self) -> bool {\n         !self.is_union() && !self.is_enum()\n@@ -1508,7 +1490,7 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n \n     /// Asserts this is a struct and returns the struct's unique\n     /// variant.\n-    pub fn struct_variant(&self) -> &VariantDefData<'gcx, 'container> {\n+    pub fn struct_variant(&self) -> &VariantDef {\n         assert!(!self.is_enum());\n         &self.variants[0]\n     }\n@@ -1521,19 +1503,8 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n     /// Returns an iterator over all fields contained\n     /// by this ADT.\n     #[inline]\n-    pub fn all_fields(&self) ->\n-            iter::FlatMap<\n-                slice::Iter<VariantDefData<'gcx, 'container>>,\n-                slice::Iter<FieldDefData<'gcx, 'container>>,\n-                for<'s> fn(&'s VariantDefData<'gcx, 'container>)\n-                    -> slice::Iter<'s, FieldDefData<'gcx, 'container>>\n-            > {\n-        self.variants.iter().flat_map(VariantDefData::fields_iter)\n-    }\n-\n-    #[inline]\n-    pub fn is_empty(&self) -> bool {\n-        self.variants.is_empty()\n+    pub fn all_fields<'s>(&'s self) -> impl Iterator<Item = &'s FieldDef> {\n+        self.variants.iter().flat_map(|v| v.fields.iter())\n     }\n \n     #[inline]\n@@ -1546,7 +1517,7 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n             self.variants.iter().all(|v| v.fields.is_empty())\n     }\n \n-    pub fn variant_with_id(&self, vid: DefId) -> &VariantDefData<'gcx, 'container> {\n+    pub fn variant_with_id(&self, vid: DefId) -> &VariantDef {\n         self.variants\n             .iter()\n             .find(|v| v.did == vid)\n@@ -1560,7 +1531,7 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n             .expect(\"variant_index_with_id: unknown variant\")\n     }\n \n-    pub fn variant_of_def(&self, def: Def) -> &VariantDefData<'gcx, 'container> {\n+    pub fn variant_of_def(&self, def: Def) -> &VariantDef {\n         match def {\n             Def::Variant(vid) | Def::VariantCtor(vid, ..) => self.variant_with_id(vid),\n             Def::Struct(..) | Def::StructCtor(..) | Def::Union(..) |\n@@ -1583,9 +1554,7 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n             None => NoDtor,\n         }\n     }\n-}\n \n-impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'tcx, 'container> {\n     /// Returns a simpler type such that `Self: Sized` if and only\n     /// if that type is Sized, or `TyErr` if this type is recursive.\n     ///\n@@ -1604,19 +1573,9 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'tcx, 'container> {\n     /// Due to normalization being eager, this applies even if\n     /// the associated type is behind a pointer, e.g. issue #31299.\n     pub fn sized_constraint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n-        match self.sized_constraint.get(DepNode::SizedConstraint(self.did)) {\n-            None => {\n-                let global_tcx = tcx.global_tcx();\n-                let this = global_tcx.lookup_adt_def_master(self.did);\n-                this.calculate_sized_constraint_inner(global_tcx, &mut Vec::new());\n-                self.sized_constraint(tcx)\n-            }\n-            Some(ty) => ty\n-        }\n+        self.calculate_sized_constraint_inner(tcx.global_tcx(), &mut Vec::new())\n     }\n-}\n \n-impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n     /// Calculates the Sized-constraint.\n     ///\n     /// As the Sized-constraint of enums can be a *set* of types,\n@@ -1632,42 +1591,41 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n     ///       such.\n     ///     - a TyError, if a type contained itself. The representability\n     ///       check should catch this case.\n-    fn calculate_sized_constraint_inner(&'tcx self,\n+    fn calculate_sized_constraint_inner(&self,\n                                         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                        stack: &mut Vec<AdtDefMaster<'tcx>>)\n+                                        stack: &mut Vec<DefId>)\n+                                        -> Ty<'tcx>\n     {\n-        let dep_node = || DepNode::SizedConstraint(self.did);\n+        if let Some(ty) = tcx.adt_sized_constraint.borrow().get(&self.did) {\n+            return ty;\n+        }\n \n         // Follow the memoization pattern: push the computation of\n         // DepNode::SizedConstraint as our current task.\n-        let _task = tcx.dep_graph.in_task(dep_node());\n-        if self.sized_constraint.untracked_get().is_some() {\n-            //                   ---------------\n-            // can skip the dep-graph read since we just pushed the task\n-            return;\n-        }\n+        let _task = tcx.dep_graph.in_task(DepNode::SizedConstraint(self.did));\n \n-        if stack.contains(&self) {\n+        if stack.contains(&self.did) {\n             debug!(\"calculate_sized_constraint: {:?} is recursive\", self);\n             // This should be reported as an error by `check_representable`.\n             //\n             // Consider the type as Sized in the meanwhile to avoid\n             // further errors.\n-            self.sized_constraint.fulfill(dep_node(), tcx.types.err);\n-            return;\n+            tcx.adt_sized_constraint.borrow_mut().insert(self.did, tcx.types.err);\n+            return tcx.types.err;\n         }\n \n-        stack.push(self);\n+        stack.push(self.did);\n \n         let tys : Vec<_> =\n             self.variants.iter().flat_map(|v| {\n                 v.fields.last()\n             }).flat_map(|f| {\n-                self.sized_constraint_for_ty(tcx, stack, f.unsubst_ty())\n+                let ty = tcx.item_type(f.did);\n+                self.sized_constraint_for_ty(tcx, stack, ty)\n             }).collect();\n \n         let self_ = stack.pop().unwrap();\n-        assert_eq!(self_, self);\n+        assert_eq!(self_, self.did);\n \n         let ty = match tys.len() {\n             _ if tys.references_error() => tcx.types.err,\n@@ -1676,32 +1634,34 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n             _ => tcx.intern_tup(&tys[..])\n         };\n \n-        match self.sized_constraint.get(dep_node()) {\n+        let old = tcx.adt_sized_constraint.borrow().get(&self.did).cloned();\n+        match old {\n             Some(old_ty) => {\n                 debug!(\"calculate_sized_constraint: {:?} recurred\", self);\n-                assert_eq!(old_ty, tcx.types.err)\n+                assert_eq!(old_ty, tcx.types.err);\n+                old_ty\n             }\n             None => {\n                 debug!(\"calculate_sized_constraint: {:?} => {:?}\", self, ty);\n-                self.sized_constraint.fulfill(dep_node(), ty)\n+                tcx.adt_sized_constraint.borrow_mut().insert(self.did, ty);\n+                ty\n             }\n         }\n     }\n \n-    fn sized_constraint_for_ty(\n-        &'tcx self,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        stack: &mut Vec<AdtDefMaster<'tcx>>,\n-        ty: Ty<'tcx>\n-    ) -> Vec<Ty<'tcx>> {\n+    fn sized_constraint_for_ty(&self,\n+                               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                               stack: &mut Vec<DefId>,\n+                               ty: Ty<'tcx>)\n+                               -> Vec<Ty<'tcx>> {\n         let result = match ty.sty {\n             TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n             TyBox(..) | TyRawPtr(..) | TyRef(..) | TyFnDef(..) | TyFnPtr(_) |\n             TyArray(..) | TyClosure(..) | TyNever => {\n                 vec![]\n             }\n \n-            TyStr | TyTrait(..) | TySlice(_) | TyError => {\n+            TyStr | TyDynamic(..) | TySlice(_) | TyError => {\n                 // these are never sized - return the target type\n                 vec![ty]\n             }\n@@ -1715,12 +1675,9 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n \n             TyAdt(adt, substs) => {\n                 // recursive case\n-                let adt = tcx.lookup_adt_def_master(adt.did);\n-                adt.calculate_sized_constraint_inner(tcx, stack);\n                 let adt_ty =\n-                    adt.sized_constraint\n-                    .unwrap(DepNode::SizedConstraint(adt.did))\n-                    .subst(tcx, substs);\n+                    adt.calculate_sized_constraint_inner(tcx, stack)\n+                       .subst(tcx, substs);\n                 debug!(\"sized_constraint_for_ty({:?}) intermediate = {:?}\",\n                        ty, adt_ty);\n                 if let ty::TyTuple(ref tys) = adt_ty.sty {\n@@ -1769,16 +1726,11 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n     }\n }\n \n-impl<'tcx, 'container> VariantDefData<'tcx, 'container> {\n-    #[inline]\n-    fn fields_iter(&self) -> slice::Iter<FieldDefData<'tcx, 'container>> {\n-        self.fields.iter()\n-    }\n-\n+impl<'a, 'gcx, 'tcx> VariantDef {\n     #[inline]\n     pub fn find_field_named(&self,\n                             name: ast::Name)\n-                            -> Option<&FieldDefData<'tcx, 'container>> {\n+                            -> Option<&FieldDef> {\n         self.fields.iter().find(|f| f.name == name)\n     }\n \n@@ -1790,33 +1742,38 @@ impl<'tcx, 'container> VariantDefData<'tcx, 'container> {\n     }\n \n     #[inline]\n-    pub fn field_named(&self, name: ast::Name) -> &FieldDefData<'tcx, 'container> {\n+    pub fn field_named(&self, name: ast::Name) -> &FieldDef {\n         self.find_field_named(name).unwrap()\n     }\n-}\n \n-impl<'a, 'gcx, 'tcx, 'container> FieldDefData<'tcx, 'container> {\n-    pub fn new(did: DefId,\n-               name: Name,\n-               vis: Visibility) -> Self {\n-        FieldDefData {\n-            did: did,\n-            name: name,\n-            vis: vis,\n-            ty: ivar::TyIVar::new()\n+    #[inline]\n+    pub fn is_uninhabited_recurse(&self,\n+                                  visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n+                                  block: Option<NodeId>,\n+                                  tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                  substs: &'tcx Substs<'tcx>,\n+                                  is_union: bool) -> bool {\n+        if is_union {\n+            self.fields.iter().all(|f| f.is_uninhabited_recurse(visited, block, tcx, substs))\n+        } else {\n+            self.fields.iter().any(|f| f.is_uninhabited_recurse(visited, block, tcx, substs))\n         }\n     }\n+}\n \n+impl<'a, 'gcx, 'tcx> FieldDef {\n     pub fn ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, subst: &Substs<'tcx>) -> Ty<'tcx> {\n-        self.unsubst_ty().subst(tcx, subst)\n-    }\n-\n-    pub fn unsubst_ty(&self) -> Ty<'tcx> {\n-        self.ty.unwrap(DepNode::FieldTy(self.did))\n+        tcx.item_type(self.did).subst(tcx, subst)\n     }\n \n-    pub fn fulfill_ty(&self, ty: Ty<'container>) {\n-        self.ty.fulfill(DepNode::FieldTy(self.did), ty);\n+    #[inline]\n+    pub fn is_uninhabited_recurse(&self,\n+                                  visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n+                                  block: Option<NodeId>,\n+                                  tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                  substs: &'tcx Substs<'tcx>) -> bool {\n+        block.map_or(true, |b| self.vis.is_accessible_from(b, &tcx.map)) &&\n+        self.ty(tcx, substs).is_uninhabited_recurse(visited, block, tcx)\n     }\n }\n \n@@ -1839,18 +1796,14 @@ pub enum ClosureKind {\n \n impl<'a, 'tcx> ClosureKind {\n     pub fn trait_did(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> DefId {\n-        let result = match *self {\n-            ClosureKind::Fn => tcx.lang_items.require(FnTraitLangItem),\n+        match *self {\n+            ClosureKind::Fn => tcx.require_lang_item(FnTraitLangItem),\n             ClosureKind::FnMut => {\n-                tcx.lang_items.require(FnMutTraitLangItem)\n+                tcx.require_lang_item(FnMutTraitLangItem)\n             }\n             ClosureKind::FnOnce => {\n-                tcx.lang_items.require(FnOnceTraitLangItem)\n+                tcx.require_lang_item(FnOnceTraitLangItem)\n             }\n-        };\n-        match result {\n-            Ok(trait_did) => trait_did,\n-            Err(err) => tcx.sess.fatal(&err[..]),\n         }\n     }\n \n@@ -1887,7 +1840,7 @@ impl<'tcx> TyS<'tcx> {\n     /// Iterator that walks the immediate children of `self`.  Hence\n     /// `Foo<Bar<i32>, u32>` yields the sequence `[Bar<i32>, u32]`\n     /// (but not `i32`, like `walk`).\n-    pub fn walk_shallow(&'tcx self) -> IntoIter<Ty<'tcx>> {\n+    pub fn walk_shallow(&'tcx self) -> AccIntoIter<walk::TypeWalkerArray<'tcx>> {\n         walk::walk_shallow(self)\n     }\n \n@@ -2007,7 +1960,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         match self.map.find(id) {\n             Some(ast_map::NodeLocal(pat)) => {\n                 match pat.node {\n-                    hir::PatKind::Binding(_, ref path1, _) => path1.node.as_str(),\n+                    hir::PatKind::Binding(_, _, ref path1, _) => path1.node.as_str(),\n                     _ => {\n                         bug!(\"Variable id {} maps to {:?}, not local\", id, pat);\n                     },\n@@ -2019,11 +1972,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn expr_is_lval(self, expr: &hir::Expr) -> bool {\n          match expr.node {\n-            hir::ExprPath(..) => {\n-                // This function can be used during type checking when not all paths are\n-                // fully resolved. Partially resolved paths in expressions can only legally\n-                // refer to associated items which are always rvalues.\n-                match self.expect_resolution(expr.id).base_def {\n+            hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+                match path.def {\n                     Def::Local(..) | Def::Upvar(..) | Def::Static(..) | Def::Err => true,\n                     _ => false,\n                 }\n@@ -2040,6 +1990,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 true\n             }\n \n+            // Partially qualified paths in expressions can only legally\n+            // refer to associated items which are always rvalues.\n+            hir::ExprPath(hir::QPath::TypeRelative(..)) |\n+\n             hir::ExprCall(..) |\n             hir::ExprMethodCall(..) |\n             hir::ExprStruct(..) |\n@@ -2257,25 +2211,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             || self.sess.cstore.impl_trait_ref(self.global_tcx(), id))\n     }\n \n-    /// Returns a path resolution for node id if it exists, panics otherwise.\n-    pub fn expect_resolution(self, id: NodeId) -> PathResolution {\n-        *self.def_map.borrow().get(&id).expect(\"no def-map entry for node id\")\n-    }\n-\n-    /// Returns a fully resolved definition for node id if it exists, panics otherwise.\n-    pub fn expect_def(self, id: NodeId) -> Def {\n-        self.expect_resolution(id).full_def()\n-    }\n-\n-    /// Returns a fully resolved definition for node id if it exists, or none if no\n-    /// definition exists, panics on partial resolutions to catch errors.\n-    pub fn expect_def_or_none(self, id: NodeId) -> Option<Def> {\n-        self.def_map.borrow().get(&id).map(|resolution| resolution.full_def())\n-    }\n-\n     // Returns `ty::VariantDef` if `def` refers to a struct,\n     // or variant or their constructors, panics otherwise.\n-    pub fn expect_variant_def(self, def: Def) -> VariantDef<'tcx> {\n+    pub fn expect_variant_def(self, def: Def) -> &'tcx VariantDef {\n         match def {\n             Def::Variant(did) | Def::VariantCtor(did, ..) => {\n                 let enum_did = self.parent_def_id(did).unwrap();\n@@ -2340,6 +2278,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    pub fn def_span(self, def_id: DefId) -> Span {\n+        if let Some(id) = self.map.as_local_node_id(def_id) {\n+            self.map.span(id)\n+        } else {\n+            self.sess.cstore.def_span(&self.sess, def_id)\n+        }\n+    }\n+\n     pub fn item_name(self, id: DefId) -> ast::Name {\n         if let Some(id) = self.map.as_local_node_id(id) {\n             self.map.name(id)\n@@ -2370,28 +2316,18 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Given the did of a trait, returns its canonical trait ref.\n-    pub fn lookup_trait_def(self, did: DefId) -> &'gcx TraitDef<'gcx> {\n+    pub fn lookup_trait_def(self, did: DefId) -> &'gcx TraitDef {\n         lookup_locally_or_in_crate_store(\n             \"trait_defs\", did, &self.trait_defs,\n             || self.alloc_trait_def(self.sess.cstore.trait_def(self.global_tcx(), did))\n         )\n     }\n \n-    /// Given the did of an ADT, return a master reference to its\n-    /// definition. Unless you are planning on fulfilling the ADT's fields,\n-    /// use lookup_adt_def instead.\n-    pub fn lookup_adt_def_master(self, did: DefId) -> AdtDefMaster<'gcx> {\n+    /// Given the did of an ADT, return a reference to its definition.\n+    pub fn lookup_adt_def(self, did: DefId) -> &'gcx AdtDef {\n         lookup_locally_or_in_crate_store(\n             \"adt_defs\", did, &self.adt_defs,\n-            || self.sess.cstore.adt_def(self.global_tcx(), did)\n-        )\n-    }\n-\n-    /// Given the did of an ADT, return a reference to its definition.\n-    pub fn lookup_adt_def(self, did: DefId) -> AdtDef<'gcx> {\n-        // when reverse-variance goes away, a transmute::<AdtDefMaster,AdtDef>\n-        // would be needed here.\n-        self.lookup_adt_def_master(did)\n+            || self.sess.cstore.adt_def(self.global_tcx(), did))\n     }\n \n     /// Given the did of an item, returns its generics."}, {"sha": "eb384eec6a6f1e3b583fcf5e0f355a023f0c6158", "filename": "src/librustc/ty/outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Foutlives.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -177,7 +177,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             ty::TyTuple(..) |       // ...\n             ty::TyFnDef(..) |       // OutlivesFunction (*)\n             ty::TyFnPtr(_) |        // OutlivesFunction (*)\n-            ty::TyTrait(..) |       // OutlivesObject, OutlivesFragment (*)\n+            ty::TyDynamic(..) |       // OutlivesObject, OutlivesFragment (*)\n             ty::TyError => {\n                 // (*) Bare functions and traits are both binders. In the\n                 // RFC, this means we would add the bound regions to the"}, {"sha": "76c26d01ac8e2051d1658fb21f06bb75806939c5", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 54, "deletions": 56, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -18,8 +18,10 @@ use ty::subst::{Kind, Substs};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::error::{ExpectedFound, TypeError};\n use std::rc::Rc;\n+use std::iter;\n use syntax::abi;\n use hir as ast;\n+use rustc_data_structures::accumulate_vec::AccumulateVec;\n \n pub type RelateResult<'tcx, T> = Result<T, TypeError<'tcx>>;\n \n@@ -185,32 +187,28 @@ impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n                 expected_found(relation, &a.variadic, &b.variadic)));\n         }\n \n-        let inputs = relate_arg_vecs(relation,\n-                                     &a.inputs,\n-                                     &b.inputs)?;\n-        let output = relation.relate(&a.output, &b.output)?;\n+        if a.inputs().len() != b.inputs().len() {\n+            return Err(TypeError::ArgCount);\n+        }\n \n-        Ok(ty::FnSig {inputs: inputs,\n-                      output: output,\n-                      variadic: a.variadic})\n+        let inputs_and_output = a.inputs().iter().cloned()\n+            .zip(b.inputs().iter().cloned())\n+            .map(|x| (x, false))\n+            .chain(iter::once(((a.output(), b.output()), true)))\n+            .map(|((a, b), is_output)| {\n+                if is_output {\n+                    relation.relate(&a, &b)\n+                } else {\n+                    relation.relate_with_variance(ty::Contravariant, &a, &b)\n+                }\n+            }).collect::<Result<AccumulateVec<[_; 8]>, _>>()?;\n+        Ok(ty::FnSig {\n+            inputs_and_output: relation.tcx().intern_type_list(&inputs_and_output),\n+            variadic: a.variadic\n+        })\n     }\n }\n \n-fn relate_arg_vecs<'a, 'gcx, 'tcx, R>(relation: &mut R,\n-                                      a_args: &[Ty<'tcx>],\n-                                      b_args: &[Ty<'tcx>])\n-                                      -> RelateResult<'tcx, Vec<Ty<'tcx>>>\n-    where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n-{\n-    if a_args.len() != b_args.len() {\n-        return Err(TypeError::ArgCount);\n-    }\n-\n-    a_args.iter().zip(b_args)\n-          .map(|(a, b)| relation.relate_with_variance(ty::Contravariant, a, b))\n-          .collect()\n-}\n-\n impl<'tcx> Relate<'tcx> for ast::Unsafety {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n                            a: &ast::Unsafety,\n@@ -302,23 +300,6 @@ impl<'tcx> Relate<'tcx> for Vec<ty::PolyExistentialProjection<'tcx>> {\n     }\n }\n \n-impl<'tcx> Relate<'tcx> for ty::BuiltinBounds {\n-    fn relate<'a, 'gcx, R>(relation: &mut R,\n-                           a: &ty::BuiltinBounds,\n-                           b: &ty::BuiltinBounds)\n-                           -> RelateResult<'tcx, ty::BuiltinBounds>\n-        where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a\n-    {\n-        // Two sets of builtin bounds are only relatable if they are\n-        // precisely the same (but see the coercion code).\n-        if a != b {\n-            Err(TypeError::BuiltinBoundsMismatch(expected_found(relation, a, b)))\n-        } else {\n-            Ok(*a)\n-        }\n-    }\n-}\n-\n impl<'tcx> Relate<'tcx> for ty::TraitRef<'tcx> {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n                            a: &ty::TraitRef<'tcx>,\n@@ -415,23 +396,15 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n             Ok(tcx.mk_adt(a_def, substs))\n         }\n \n-        (&ty::TyTrait(ref a_obj), &ty::TyTrait(ref b_obj)) =>\n-        {\n-            let principal = relation.relate(&a_obj.principal, &b_obj.principal)?;\n-            let r =\n-                relation.with_cause(\n-                    Cause::ExistentialRegionBound,\n-                    |relation| relation.relate_with_variance(ty::Contravariant,\n-                                                             &a_obj.region_bound,\n-                                                             &b_obj.region_bound))?;\n-            let nb = relation.relate(&a_obj.builtin_bounds, &b_obj.builtin_bounds)?;\n-            let pb = relation.relate(&a_obj.projection_bounds, &b_obj.projection_bounds)?;\n-            Ok(tcx.mk_trait(ty::TraitObject {\n-                principal: principal,\n-                region_bound: r,\n-                builtin_bounds: nb,\n-                projection_bounds: pb\n-            }))\n+        (&ty::TyDynamic(ref a_obj, ref a_region), &ty::TyDynamic(ref b_obj, ref b_region)) => {\n+            let region_bound = relation.with_cause(Cause::ExistentialRegionBound,\n+                                                       |relation| {\n+                                                           relation.relate_with_variance(\n+                                                               ty::Contravariant,\n+                                                               a_region,\n+                                                               b_region)\n+                                                       })?;\n+            Ok(tcx.mk_dynamic(relation.relate(a_obj, b_obj)?, region_bound))\n         }\n \n         (&ty::TyClosure(a_id, a_substs),\n@@ -527,6 +500,31 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n     }\n }\n \n+impl<'tcx> Relate<'tcx> for &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>> {\n+    fn relate<'a, 'gcx, R>(relation: &mut R,\n+                           a: &Self,\n+                           b: &Self)\n+        -> RelateResult<'tcx, Self>\n+            where R: TypeRelation<'a, 'gcx, 'tcx>, 'gcx: 'a+'tcx, 'tcx: 'a {\n+\n+        if a.len() != b.len() {\n+            return Err(TypeError::ExistentialMismatch(expected_found(relation, a, b)));\n+        }\n+\n+        let tcx = relation.tcx();\n+        let v = a.iter().zip(b.iter()).map(|(ep_a, ep_b)| {\n+            use ty::ExistentialPredicate::*;\n+            match (*ep_a, *ep_b) {\n+                (Trait(ref a), Trait(ref b)) => Ok(Trait(relation.relate(a, b)?)),\n+                (Projection(ref a), Projection(ref b)) => Ok(Projection(relation.relate(a, b)?)),\n+                (AutoTrait(ref a), AutoTrait(ref b)) if a == b => Ok(AutoTrait(*a)),\n+                _ => Err(TypeError::ExistentialMismatch(expected_found(relation, a, b)))\n+            }\n+        });\n+        Ok(tcx.mk_existential_predicates(v)?)\n+    }\n+}\n+\n impl<'tcx> Relate<'tcx> for ty::ClosureSubsts<'tcx> {\n     fn relate<'a, 'gcx, R>(relation: &mut R,\n                            a: &ty::ClosureSubsts<'tcx>,"}, {"sha": "0f0478bc8cdb0d8528f3402faa3b941635625522", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 79, "deletions": 35, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -232,14 +232,11 @@ impl<'a, 'tcx> Lift<'tcx> for ty::adjustment::AutoBorrow<'a> {\n impl<'a, 'tcx> Lift<'tcx> for ty::FnSig<'a> {\n     type Lifted = ty::FnSig<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.inputs[..]).and_then(|inputs| {\n-            tcx.lift(&self.output).map(|output| {\n-                ty::FnSig {\n-                    inputs: inputs,\n-                    output: output,\n-                    variadic: self.variadic\n-                }\n-            })\n+        tcx.lift(&self.inputs_and_output).map(|x| {\n+            ty::FnSig {\n+                inputs_and_output: x,\n+                variadic: self.variadic\n+            }\n         })\n     }\n }\n@@ -315,7 +312,6 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             IntMismatch(x) => IntMismatch(x),\n             FloatMismatch(x) => FloatMismatch(x),\n             Traits(x) => Traits(x),\n-            BuiltinBoundsMismatch(x) => BuiltinBoundsMismatch(x),\n             VariadicMismatch(x) => VariadicMismatch(x),\n             CyclicTy => CyclicTy,\n             ProjectionNameMismatched(x) => ProjectionNameMismatched(x),\n@@ -325,6 +321,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             TyParamDefaultMismatch(ref x) => {\n                 return tcx.lift(x).map(TyParamDefaultMismatch)\n             }\n+            ExistentialMismatch(ref x) => return tcx.lift(x).map(ExistentialMismatch)\n         })\n     }\n }\n@@ -427,20 +424,33 @@ impl<'tcx, T:TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::Binder<T> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::TraitObject<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::TraitObject {\n-            principal: self.principal.fold_with(folder),\n-            region_bound: self.region_bound.fold_with(folder),\n-            builtin_bounds: self.builtin_bounds,\n-            projection_bounds: self.projection_bounds.fold_with(folder),\n+        let v = self.iter().map(|p| p.fold_with(folder)).collect::<AccumulateVec<[_; 8]>>();\n+        folder.tcx().intern_existential_predicates(&v)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.iter().any(|p| p.visit_with(visitor))\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialPredicate<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self  {\n+        use ty::ExistentialPredicate::*;\n+        match *self {\n+            Trait(ref tr) => Trait(tr.fold_with(folder)),\n+            Projection(ref p) => Projection(p.fold_with(folder)),\n+            AutoTrait(did) => AutoTrait(did),\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.principal.visit_with(visitor) ||\n-        self.region_bound.visit_with(visitor) ||\n-        self.projection_bounds.visit_with(visitor)\n+        match *self {\n+            ty::ExistentialPredicate::Trait(ref tr) => tr.visit_with(visitor),\n+            ty::ExistentialPredicate::Projection(ref p) => p.visit_with(visitor),\n+            ty::ExistentialPredicate::AutoTrait(_) => false,\n+        }\n     }\n }\n \n@@ -463,7 +473,8 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyArray(typ, sz) => ty::TyArray(typ.fold_with(folder), sz),\n             ty::TySlice(typ) => ty::TySlice(typ.fold_with(folder)),\n             ty::TyAdt(tid, substs) => ty::TyAdt(tid, substs.fold_with(folder)),\n-            ty::TyTrait(ref trait_ty) => ty::TyTrait(trait_ty.fold_with(folder)),\n+            ty::TyDynamic(ref trait_ty, ref region) =>\n+                ty::TyDynamic(trait_ty.fold_with(folder), region.fold_with(folder)),\n             ty::TyTuple(ts) => ty::TyTuple(ts.fold_with(folder)),\n             ty::TyFnDef(def_id, substs, f) => {\n                 ty::TyFnDef(def_id,\n@@ -481,7 +492,12 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyUint(_) | ty::TyFloat(_) | ty::TyError | ty::TyInfer(_) |\n             ty::TyParam(..) | ty::TyNever => return self\n         };\n-        folder.tcx().mk_ty(sty)\n+\n+        if self.sty == sty {\n+            self\n+        } else {\n+            folder.tcx().mk_ty(sty)\n+        }\n     }\n \n     fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n@@ -495,7 +511,8 @@ impl<'tcx> TypeFoldable<'tcx> for Ty<'tcx> {\n             ty::TyArray(typ, _sz) => typ.visit_with(visitor),\n             ty::TySlice(typ) => typ.visit_with(visitor),\n             ty::TyAdt(_, substs) => substs.visit_with(visitor),\n-            ty::TyTrait(ref trait_ty) => trait_ty.visit_with(visitor),\n+            ty::TyDynamic(ref trait_ty, ref reg) =>\n+                trait_ty.visit_with(visitor) || reg.visit_with(visitor),\n             ty::TyTuple(ts) => ts.visit_with(visitor),\n             ty::TyFnDef(_, substs, ref f) => {\n                 substs.visit_with(visitor) || f.visit_with(visitor)\n@@ -569,17 +586,20 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TypeAndMut<'tcx> {\n \n impl<'tcx> TypeFoldable<'tcx> for ty::FnSig<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        ty::FnSig { inputs: self.inputs.fold_with(folder),\n-                    output: self.output.fold_with(folder),\n-                    variadic: self.variadic }\n+        let inputs_and_output = self.inputs_and_output.fold_with(folder);\n+        ty::FnSig {\n+            inputs_and_output: folder.tcx().intern_type_list(&inputs_and_output),\n+            variadic: self.variadic,\n+        }\n     }\n \n     fn fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         folder.fold_fn_sig(self)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.inputs.visit_with(visitor) || self.output.visit_with(visitor)\n+        self.inputs().iter().any(|i| i.visit_with(visitor)) ||\n+        self.output().visit_with(visitor)\n     }\n }\n \n@@ -594,6 +614,10 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TraitRef<'tcx> {\n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         self.substs.visit_with(visitor)\n     }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        visitor.visit_trait_ref(*self)\n+    }\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::ExistentialTraitRef<'tcx> {\n@@ -694,16 +718,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::adjustment::AutoBorrow<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::BuiltinBounds {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _folder: &mut F) -> Self {\n-        *self\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> bool {\n-        false\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ty::TypeParameterDef<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         ty::TypeParameterDef {\n@@ -761,6 +775,36 @@ impl<'tcx> TypeFoldable<'tcx> for ty::RegionParameterDef<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for ty::Generics<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::Generics {\n+            parent: self.parent,\n+            parent_regions: self.parent_regions,\n+            parent_types: self.parent_types,\n+            regions: self.regions.fold_with(folder),\n+            types: self.types.fold_with(folder),\n+            has_self: self.has_self,\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.regions.visit_with(visitor) || self.types.visit_with(visitor)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::GenericPredicates<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::GenericPredicates {\n+            parent: self.parent,\n+            predicates: self.predicates.fold_with(folder),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.predicates.visit_with(visitor)\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         match *self {"}, {"sha": "3b7c46ef7fe175c890b46700bcc3bff19cf12101", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 184, "deletions": 125, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -14,16 +14,17 @@ use hir::def_id::DefId;\n \n use middle::region;\n use ty::subst::Substs;\n-use ty::{self, AdtDef, ToPredicate, TypeFlags, Ty, TyCtxt, TypeFoldable};\n+use ty::{self, AdtDef, TypeFlags, Ty, TyCtxt, TypeFoldable};\n use ty::{Slice, TyS};\n-use util::common::ErrorReported;\n+use ty::subst::Kind;\n \n-use collections::enum_set::{self, EnumSet, CLike};\n use std::fmt;\n-use std::ops;\n+use std::iter;\n+use std::cmp::Ordering;\n use syntax::abi;\n-use syntax::ast::{self, Name};\n+use syntax::ast::{self, Name, NodeId};\n use syntax::symbol::{keywords, InternedString};\n+use util::nodemap::FxHashSet;\n \n use serialize;\n \n@@ -112,7 +113,7 @@ pub enum TypeVariants<'tcx> {\n     /// That is, even after substitution it is possible that there are type\n     /// variables. This happens when the `TyAdt` corresponds to an ADT\n     /// definition and not a concrete use of it.\n-    TyAdt(AdtDef<'tcx>, &'tcx Substs<'tcx>),\n+    TyAdt(&'tcx AdtDef, &'tcx Substs<'tcx>),\n \n     /// `Box<T>`; this is nominally a struct in the documentation, but is\n     /// special-cased internally. For example, it is possible to implicitly\n@@ -146,7 +147,7 @@ pub enum TypeVariants<'tcx> {\n     TyFnPtr(&'tcx BareFnTy<'tcx>),\n \n     /// A trait, defined with `trait`.\n-    TyTrait(Box<TraitObject<'tcx>>),\n+    TyDynamic(Binder<&'tcx Slice<ExistentialPredicate<'tcx>>>, &'tcx ty::Region),\n \n     /// The anonymous type of a closure. Used to represent the type of\n     /// `|a| a`.\n@@ -274,12 +275,104 @@ impl<'a, 'gcx, 'acx, 'tcx> ClosureSubsts<'tcx> {\n     }\n }\n \n-#[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n-pub struct TraitObject<'tcx> {\n-    pub principal: PolyExistentialTraitRef<'tcx>,\n-    pub region_bound: &'tcx ty::Region,\n-    pub builtin_bounds: BuiltinBounds,\n-    pub projection_bounds: Vec<PolyExistentialProjection<'tcx>>,\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub enum ExistentialPredicate<'tcx> {\n+    // e.g. Iterator\n+    Trait(ExistentialTraitRef<'tcx>),\n+    // e.g. Iterator::Item = T\n+    Projection(ExistentialProjection<'tcx>),\n+    // e.g. Send\n+    AutoTrait(DefId),\n+}\n+\n+impl<'a, 'gcx, 'tcx> ExistentialPredicate<'tcx> {\n+    pub fn cmp(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, other: &Self) -> Ordering {\n+        use self::ExistentialPredicate::*;\n+        match (*self, *other) {\n+            (Trait(_), Trait(_)) => Ordering::Equal,\n+            (Projection(ref a), Projection(ref b)) => a.sort_key(tcx).cmp(&b.sort_key(tcx)),\n+            (AutoTrait(ref a), AutoTrait(ref b)) =>\n+                tcx.lookup_trait_def(*a).def_path_hash.cmp(&tcx.lookup_trait_def(*b).def_path_hash),\n+            (Trait(_), _) => Ordering::Less,\n+            (Projection(_), Trait(_)) => Ordering::Greater,\n+            (Projection(_), _) => Ordering::Less,\n+            (AutoTrait(_), _) => Ordering::Greater,\n+        }\n+    }\n+\n+}\n+\n+impl<'a, 'gcx, 'tcx> Binder<ExistentialPredicate<'tcx>> {\n+    pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, self_ty: Ty<'tcx>)\n+        -> ty::Predicate<'tcx> {\n+        use ty::ToPredicate;\n+        match *self.skip_binder() {\n+            ExistentialPredicate::Trait(tr) => Binder(tr).with_self_ty(tcx, self_ty).to_predicate(),\n+            ExistentialPredicate::Projection(p) =>\n+                ty::Predicate::Projection(Binder(p.with_self_ty(tcx, self_ty))),\n+            ExistentialPredicate::AutoTrait(did) => {\n+                let trait_ref = Binder(ty::TraitRef {\n+                    def_id: did,\n+                    substs: tcx.mk_substs_trait(self_ty, &[]),\n+                });\n+                trait_ref.to_predicate()\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> serialize::UseSpecializedDecodable for &'tcx Slice<ExistentialPredicate<'tcx>> {}\n+\n+impl<'tcx> Slice<ExistentialPredicate<'tcx>> {\n+    pub fn principal(&self) -> Option<ExistentialTraitRef<'tcx>> {\n+        match self.get(0) {\n+            Some(&ExistentialPredicate::Trait(tr)) => Some(tr),\n+            _ => None\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn projection_bounds<'a>(&'a self) ->\n+        impl Iterator<Item=ExistentialProjection<'tcx>> + 'a {\n+        self.iter().filter_map(|predicate| {\n+            match *predicate {\n+                ExistentialPredicate::Projection(p) => Some(p),\n+                _ => None,\n+            }\n+        })\n+    }\n+\n+    #[inline]\n+    pub fn auto_traits<'a>(&'a self) -> impl Iterator<Item=DefId> + 'a {\n+        self.iter().filter_map(|predicate| {\n+            match *predicate {\n+                ExistentialPredicate::AutoTrait(d) => Some(d),\n+                _ => None\n+            }\n+        })\n+    }\n+}\n+\n+impl<'tcx> Binder<&'tcx Slice<ExistentialPredicate<'tcx>>> {\n+    pub fn principal(&self) -> Option<PolyExistentialTraitRef<'tcx>> {\n+        self.skip_binder().principal().map(Binder)\n+    }\n+\n+    #[inline]\n+    pub fn projection_bounds<'a>(&'a self) ->\n+        impl Iterator<Item=PolyExistentialProjection<'tcx>> + 'a {\n+        self.skip_binder().projection_bounds().map(Binder)\n+    }\n+\n+    #[inline]\n+    pub fn auto_traits<'a>(&'a self) -> impl Iterator<Item=DefId> + 'a {\n+        self.skip_binder().auto_traits()\n+    }\n+\n+    pub fn iter<'a>(&'a self)\n+        -> impl DoubleEndedIterator<Item=Binder<ExistentialPredicate<'tcx>>> + 'tcx {\n+        self.skip_binder().iter().cloned().map(Binder)\n+    }\n }\n \n /// A complete reference to a trait. These take numerous guises in syntax,\n@@ -343,14 +436,30 @@ pub struct ExistentialTraitRef<'tcx> {\n     pub substs: &'tcx Substs<'tcx>,\n }\n \n-impl<'tcx> ExistentialTraitRef<'tcx> {\n-    pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n+impl<'a, 'gcx, 'tcx> ExistentialTraitRef<'tcx> {\n+    pub fn input_types<'b>(&'b self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'b {\n         // Select only the \"input types\" from a trait-reference. For\n         // now this is all the types that appear in the\n         // trait-reference, but it should eventually exclude\n         // associated types.\n         self.substs.types()\n     }\n+\n+    /// Object types don't have a self-type specified. Therefore, when\n+    /// we convert the principal trait-ref into a normal trait-ref,\n+    /// you must give *some* self-type. A common choice is `mk_err()`\n+    /// or some skolemized type.\n+    pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, self_ty: Ty<'tcx>)\n+        -> ty::TraitRef<'tcx>  {\n+        // otherwise the escaping regions would be captured by the binder\n+        assert!(!self_ty.has_escaping_regions());\n+\n+        ty::TraitRef {\n+            def_id: self.def_id,\n+            substs: tcx.mk_substs(\n+                iter::once(Kind::from(self_ty)).chain(self.substs.iter().cloned()))\n+        }\n+    }\n }\n \n pub type PolyExistentialTraitRef<'tcx> = Binder<ExistentialTraitRef<'tcx>>;\n@@ -454,22 +563,31 @@ pub struct ClosureTy<'tcx> {\n /// - `variadic` indicates whether this is a variadic function. (only true for foreign fns)\n #[derive(Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct FnSig<'tcx> {\n-    pub inputs: Vec<Ty<'tcx>>,\n-    pub output: Ty<'tcx>,\n+    pub inputs_and_output: &'tcx Slice<Ty<'tcx>>,\n     pub variadic: bool\n }\n \n+impl<'tcx> FnSig<'tcx> {\n+    pub fn inputs(&self) -> &[Ty<'tcx>] {\n+        &self.inputs_and_output[..self.inputs_and_output.len() - 1]\n+    }\n+\n+    pub fn output(&self) -> Ty<'tcx> {\n+        self.inputs_and_output[self.inputs_and_output.len() - 1]\n+    }\n+}\n+\n pub type PolyFnSig<'tcx> = Binder<FnSig<'tcx>>;\n \n impl<'tcx> PolyFnSig<'tcx> {\n-    pub fn inputs(&self) -> ty::Binder<Vec<Ty<'tcx>>> {\n-        self.map_bound_ref(|fn_sig| fn_sig.inputs.clone())\n+    pub fn inputs(&self) -> Binder<&[Ty<'tcx>]> {\n+        Binder(self.skip_binder().inputs())\n     }\n     pub fn input(&self, index: usize) -> ty::Binder<Ty<'tcx>> {\n-        self.map_bound_ref(|fn_sig| fn_sig.inputs[index])\n+        self.map_bound_ref(|fn_sig| fn_sig.inputs()[index])\n     }\n     pub fn output(&self) -> ty::Binder<Ty<'tcx>> {\n-        self.map_bound_ref(|fn_sig| fn_sig.output.clone())\n+        self.map_bound_ref(|fn_sig| fn_sig.output().clone())\n     }\n     pub fn variadic(&self) -> bool {\n         self.skip_binder().variadic\n@@ -712,122 +830,53 @@ pub struct ExistentialProjection<'tcx> {\n \n pub type PolyExistentialProjection<'tcx> = Binder<ExistentialProjection<'tcx>>;\n \n-impl<'a, 'tcx, 'gcx> PolyExistentialProjection<'tcx> {\n+impl<'a, 'tcx, 'gcx> ExistentialProjection<'tcx> {\n     pub fn item_name(&self) -> Name {\n-        self.0.item_name // safe to skip the binder to access a name\n+        self.item_name // safe to skip the binder to access a name\n     }\n \n     pub fn sort_key(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> (u64, InternedString) {\n         // We want something here that is stable across crate boundaries.\n         // The DefId isn't but the `deterministic_hash` of the corresponding\n         // DefPath is.\n-        let trait_def = tcx.lookup_trait_def(self.0.trait_ref.def_id);\n+        let trait_def = tcx.lookup_trait_def(self.trait_ref.def_id);\n         let def_path_hash = trait_def.def_path_hash;\n \n         // An `ast::Name` is also not stable (it's just an index into an\n         // interning table), so map to the corresponding `InternedString`.\n-        let item_name = self.0.item_name.as_str();\n+        let item_name = self.item_name.as_str();\n         (def_path_hash, item_name)\n     }\n \n     pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                         self_ty: Ty<'tcx>)\n-                        -> ty::PolyProjectionPredicate<'tcx>\n+                        -> ty::ProjectionPredicate<'tcx>\n     {\n         // otherwise the escaping regions would be captured by the binders\n         assert!(!self_ty.has_escaping_regions());\n \n-        let trait_ref = self.map_bound(|proj| proj.trait_ref);\n-        self.map_bound(|proj| ty::ProjectionPredicate {\n+        ty::ProjectionPredicate {\n             projection_ty: ty::ProjectionTy {\n-                trait_ref: trait_ref.with_self_ty(tcx, self_ty).0,\n-                item_name: proj.item_name\n+                trait_ref: self.trait_ref.with_self_ty(tcx, self_ty),\n+                item_name: self.item_name\n             },\n-            ty: proj.ty\n-        })\n-    }\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub struct BuiltinBounds(EnumSet<BuiltinBound>);\n-\n-impl<'a, 'gcx, 'tcx> BuiltinBounds {\n-    pub fn empty() -> BuiltinBounds {\n-        BuiltinBounds(EnumSet::new())\n-    }\n-\n-    pub fn iter(&self) -> enum_set::Iter<BuiltinBound> {\n-        self.into_iter()\n-    }\n-\n-    pub fn to_predicates(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                         self_ty: Ty<'tcx>)\n-                         -> Vec<ty::Predicate<'tcx>> {\n-        self.iter().filter_map(|builtin_bound|\n-            match tcx.trait_ref_for_builtin_bound(builtin_bound, self_ty) {\n-                Ok(trait_ref) => Some(trait_ref.to_predicate()),\n-                Err(ErrorReported) => { None }\n-            }\n-        ).collect()\n+            ty: self.ty\n+        }\n     }\n }\n \n-impl ops::Deref for BuiltinBounds {\n-    type Target = EnumSet<BuiltinBound>;\n-    fn deref(&self) -> &Self::Target { &self.0 }\n-}\n-\n-impl ops::DerefMut for BuiltinBounds {\n-    fn deref_mut(&mut self) -> &mut Self::Target { &mut self.0 }\n-}\n-\n-impl<'a> IntoIterator for &'a BuiltinBounds {\n-    type Item = BuiltinBound;\n-    type IntoIter = enum_set::Iter<BuiltinBound>;\n-    fn into_iter(self) -> Self::IntoIter {\n-        (**self).into_iter()\n+impl<'a, 'tcx, 'gcx> PolyExistentialProjection<'tcx> {\n+    pub fn item_name(&self) -> Name {\n+        self.skip_binder().item_name()\n     }\n-}\n-\n-#[derive(Clone, RustcEncodable, PartialEq, Eq, RustcDecodable, Hash,\n-           Debug, Copy)]\n-pub enum BuiltinBound {\n-    Send = 0,\n-    Sized = 1,\n-    Copy = 2,\n-    Sync = 3,\n-}\n \n-impl CLike for BuiltinBound {\n-    fn to_usize(&self) -> usize {\n-        *self as usize\n-    }\n-    fn from_usize(v: usize) -> BuiltinBound {\n-        match v {\n-            0 => BuiltinBound::Send,\n-            1 => BuiltinBound::Sized,\n-            2 => BuiltinBound::Copy,\n-            3 => BuiltinBound::Sync,\n-            _ => bug!(\"{} is not a valid BuiltinBound\", v)\n-        }\n+    pub fn sort_key(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> (u64, InternedString) {\n+        self.skip_binder().sort_key(tcx)\n     }\n-}\n \n-impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn try_add_builtin_trait(self,\n-                                 trait_def_id: DefId,\n-                                 builtin_bounds: &mut EnumSet<BuiltinBound>)\n-                                 -> bool\n-    {\n-        //! Checks whether `trait_ref` refers to one of the builtin\n-        //! traits, like `Send`, and adds the corresponding\n-        //! bound to the set `builtin_bounds` if so. Returns true if `trait_ref`\n-        //! is a builtin trait.\n-\n-        match self.lang_items.to_builtin_kind(trait_def_id) {\n-            Some(bound) => { builtin_bounds.insert(bound); true }\n-            None => false\n-        }\n+    pub fn with_self_ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, self_ty: Ty<'tcx>)\n+        -> ty::PolyProjectionPredicate<'tcx> {\n+        self.map_bound(|p| p.with_self_ty(tcx, self_ty))\n     }\n }\n \n@@ -929,19 +978,27 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn is_uninhabited(&self, _cx: TyCtxt) -> bool {\n-        // FIXME(#24885): be smarter here, the AdtDefData::is_empty method could easily be made\n-        // more complete.\n+    /// Checks whether a type is uninhabited.\n+    /// If `block` is `Some(id)` it also checks that the uninhabited-ness is visible from `id`.\n+    pub fn is_uninhabited(&self, block: Option<NodeId>, cx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n+        let mut visited = FxHashSet::default();\n+        self.is_uninhabited_recurse(&mut visited, block, cx)\n+    }\n+\n+    pub fn is_uninhabited_recurse(&self,\n+                                  visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n+                                  block: Option<NodeId>,\n+                                  cx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n         match self.sty {\n-            TyAdt(def, _) => def.is_empty(),\n+            TyAdt(def, substs) => {\n+                def.is_uninhabited_recurse(visited, block, cx, substs)\n+            },\n \n-            // FIXME(canndrew): There's no reason why these can't be uncommented, they're tested\n-            // and they don't break anything. But I'm keeping my changes small for now.\n-            //TyNever => true,\n-            //TyTuple(ref tys) => tys.iter().any(|ty| ty.is_uninhabited(cx)),\n+            TyNever => true,\n+            TyTuple(ref tys) => tys.iter().any(|ty| ty.is_uninhabited_recurse(visited, block, cx)),\n+            TyArray(ty, len) => len > 0 && ty.is_uninhabited_recurse(visited, block, cx),\n+            TyRef(_, ref tm) => tm.ty.is_uninhabited_recurse(visited, block, cx),\n \n-            // FIXME(canndrew): this line breaks core::fmt\n-            //TyRef(_, ref tm) => tm.ty.is_uninhabited(cx),\n             _ => false,\n         }\n     }\n@@ -1079,7 +1136,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn is_trait(&self) -> bool {\n         match self.sty {\n-            TyTrait(..) => true,\n+            TyDynamic(..) => true,\n             _ => false\n         }\n     }\n@@ -1195,7 +1252,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     }\n \n     // Type accessors for substructures of types\n-    pub fn fn_args(&self) -> ty::Binder<Vec<Ty<'tcx>>> {\n+    pub fn fn_args(&self) -> ty::Binder<&[Ty<'tcx>]> {\n         self.fn_sig().inputs()\n     }\n \n@@ -1212,14 +1269,14 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n \n     pub fn ty_to_def_id(&self) -> Option<DefId> {\n         match self.sty {\n-            TyTrait(ref tt) => Some(tt.principal.def_id()),\n+            TyDynamic(ref tt, ..) => tt.principal().map(|p| p.def_id()),\n             TyAdt(def, _) => Some(def.did),\n             TyClosure(id, _) => Some(id),\n             _ => None\n         }\n     }\n \n-    pub fn ty_adt_def(&self) -> Option<AdtDef<'tcx>> {\n+    pub fn ty_adt_def(&self) -> Option<&'tcx AdtDef> {\n         match self.sty {\n             TyAdt(adt, _) => Some(adt),\n             _ => None\n@@ -1234,9 +1291,11 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n             TyRef(region, _) => {\n                 vec![region]\n             }\n-            TyTrait(ref obj) => {\n-                let mut v = vec![obj.region_bound];\n-                v.extend(obj.principal.skip_binder().substs.regions());\n+            TyDynamic(ref obj, region) => {\n+                let mut v = vec![region];\n+                if let Some(p) = obj.principal() {\n+                    v.extend(p.skip_binder().substs.regions());\n+                }\n                 v\n             }\n             TyAdt(_, substs) | TyAnon(_, substs) => {"}, {"sha": "d6f61a12a3c6eb2ca8ad84ab7f6ec6d0303e33aa", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -165,6 +165,14 @@ impl<'tcx> Decodable for Kind<'tcx> {\n pub type Substs<'tcx> = Slice<Kind<'tcx>>;\n \n impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n+    /// Creates a Substs that maps each generic parameter to itself.\n+    pub fn identity_for_item(tcx: TyCtxt<'a, 'gcx, 'tcx>, def_id: DefId)\n+                             -> &'tcx Substs<'tcx> {\n+        Substs::for_item(tcx, def_id, |def, _| {\n+            tcx.mk_region(ty::ReEarlyBound(def.to_early_bound_region_data()))\n+        }, |def, _| tcx.mk_param_from_def(def))\n+    }\n+\n     /// Creates a Substs for generic parameter definitions,\n     /// by calling closures to obtain each region and type.\n     /// The closures get to observe the Substs as they're"}, {"sha": "c6d862b23bd5e393fc2bc67da607d37c730e7e7d", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -19,7 +19,9 @@ use hir;\n use util::nodemap::FxHashMap;\n \n /// A trait's definition with type information.\n-pub struct TraitDef<'tcx> {\n+pub struct TraitDef {\n+    pub def_id: DefId,\n+\n     pub unsafety: hir::Unsafety,\n \n     /// If `true`, then this trait had the `#[rustc_paren_sugar]`\n@@ -28,15 +30,6 @@ pub struct TraitDef<'tcx> {\n     /// be usable with the sugar (or without it).\n     pub paren_sugar: bool,\n \n-    /// Generic type definitions. Note that `Self` is listed in here\n-    /// as having a single bound, the trait itself (e.g., in the trait\n-    /// `Eq`, there is a single bound `Self : Eq`). This is so that\n-    /// default methods get to assume that the `Self` parameters\n-    /// implements the trait.\n-    pub generics: &'tcx ty::Generics<'tcx>,\n-\n-    pub trait_ref: ty::TraitRef<'tcx>,\n-\n     // Impls of a trait. To allow for quicker lookup, the impls are indexed by a\n     // simplified version of their `Self` type: impls with a simplifiable `Self`\n     // are stored in `nonblanket_impls` keyed by it, while all other impls are\n@@ -72,18 +65,16 @@ pub struct TraitDef<'tcx> {\n     pub def_path_hash: u64,\n }\n \n-impl<'a, 'gcx, 'tcx> TraitDef<'tcx> {\n-    pub fn new(unsafety: hir::Unsafety,\n+impl<'a, 'gcx, 'tcx> TraitDef {\n+    pub fn new(def_id: DefId,\n+               unsafety: hir::Unsafety,\n                paren_sugar: bool,\n-               generics: &'tcx ty::Generics<'tcx>,\n-               trait_ref: ty::TraitRef<'tcx>,\n                def_path_hash: u64)\n-               -> TraitDef<'tcx> {\n+               -> TraitDef {\n         TraitDef {\n+            def_id: def_id,\n             paren_sugar: paren_sugar,\n             unsafety: unsafety,\n-            generics: generics,\n-            trait_ref: trait_ref,\n             nonblanket_impls: RefCell::new(FxHashMap()),\n             blanket_impls: RefCell::new(vec![]),\n             flags: Cell::new(ty::TraitFlags::NO_TRAIT_FLAGS),\n@@ -92,10 +83,6 @@ impl<'a, 'gcx, 'tcx> TraitDef<'tcx> {\n         }\n     }\n \n-    pub fn def_id(&self) -> DefId {\n-        self.trait_ref.def_id\n-    }\n-\n     // returns None if not yet calculated\n     pub fn object_safety(&self) -> Option<bool> {\n         if self.flags.get().intersects(TraitFlags::OBJECT_SAFETY_VALID) {\n@@ -117,11 +104,11 @@ impl<'a, 'gcx, 'tcx> TraitDef<'tcx> {\n     }\n \n     fn write_trait_impls(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) {\n-        tcx.dep_graph.write(DepNode::TraitImpls(self.trait_ref.def_id));\n+        tcx.dep_graph.write(DepNode::TraitImpls(self.def_id));\n     }\n \n     fn read_trait_impls(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) {\n-        tcx.dep_graph.read(DepNode::TraitImpls(self.trait_ref.def_id));\n+        tcx.dep_graph.read(DepNode::TraitImpls(self.def_id));\n     }\n \n     /// Records a basic trait-to-implementation mapping.\n@@ -203,13 +190,13 @@ impl<'a, 'gcx, 'tcx> TraitDef<'tcx> {\n             .insert(tcx, impl_def_id)\n     }\n \n-    pub fn ancestors(&'a self, of_impl: DefId) -> specialization_graph::Ancestors<'a, 'tcx> {\n+    pub fn ancestors(&'a self, of_impl: DefId) -> specialization_graph::Ancestors<'a> {\n         specialization_graph::ancestors(self, of_impl)\n     }\n \n     pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, mut f: F) {\n         self.read_trait_impls(tcx);\n-        tcx.populate_implementations_for_trait_if_necessary(self.trait_ref.def_id);\n+        tcx.populate_implementations_for_trait_if_necessary(self.def_id);\n \n         for &impl_def_id in self.blanket_impls.borrow().iter() {\n             f(impl_def_id);\n@@ -231,7 +218,7 @@ impl<'a, 'gcx, 'tcx> TraitDef<'tcx> {\n     {\n         self.read_trait_impls(tcx);\n \n-        tcx.populate_implementations_for_trait_if_necessary(self.trait_ref.def_id);\n+        tcx.populate_implementations_for_trait_if_necessary(self.def_id);\n \n         for &impl_def_id in self.blanket_impls.borrow().iter() {\n             f(impl_def_id);"}, {"sha": "e6db35cc3f5447b9f44c3f8306947b9fd4cccca2", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 20, "deletions": 23, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -14,14 +14,14 @@ use hir::def_id::DefId;\n use hir::map::DefPathData;\n use infer::InferCtxt;\n use hir::map as ast_map;\n-use hir::pat_util;\n use traits::{self, Reveal};\n use ty::{self, Ty, AdtKind, TyCtxt, TypeAndMut, TypeFlags, TypeFoldable};\n use ty::{Disr, ParameterEnvironment};\n use ty::fold::TypeVisitor;\n use ty::layout::{Layout, LayoutError};\n use ty::TypeVariants::*;\n use util::nodemap::FxHashMap;\n+use middle::lang_items;\n \n use rustc_const_math::{ConstInt, ConstIsize, ConstUsize};\n \n@@ -180,14 +180,6 @@ impl<'tcx> ParameterEnvironment<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn pat_contains_ref_binding(self, pat: &hir::Pat) -> Option<hir::Mutability> {\n-        pat_util::pat_contains_ref_binding(pat)\n-    }\n-\n-    pub fn arm_contains_ref_binding(self, arm: &hir::Arm) -> Option<hir::Mutability> {\n-        pat_util::arm_contains_ref_binding(arm)\n-    }\n-\n     pub fn has_error_field(self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n             ty::TyAdt(def, substs) => {\n@@ -374,7 +366,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// `adt` that do not strictly outlive the adt value itself.\n     /// (This allows programs to make cyclic structures without\n     /// resorting to unasfe means; see RFCs 769 and 1238).\n-    pub fn is_adt_dtorck(self, adt: ty::AdtDef) -> bool {\n+    pub fn is_adt_dtorck(self, adt: &ty::AdtDef) -> bool {\n         let dtor_method = match adt.destructor() {\n             Some(dtor) => dtor,\n             None => return false\n@@ -538,11 +530,15 @@ impl<'a, 'gcx, 'tcx, H: Hasher> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tc\n                 self.hash(f.unsafety);\n                 self.hash(f.abi);\n                 self.hash(f.sig.variadic());\n-                self.hash(f.sig.inputs().skip_binder().len());\n+                self.hash(f.sig.skip_binder().inputs().len());\n             }\n-            TyTrait(ref data) => {\n-                self.def_id(data.principal.def_id());\n-                self.hash(data.builtin_bounds);\n+            TyDynamic(ref data, ..) => {\n+                if let Some(p) = data.principal() {\n+                    self.def_id(p.def_id());\n+                }\n+                for d in data.auto_traits() {\n+                    self.def_id(d);\n+                }\n             }\n             TyTuple(tys) => {\n                 self.hash(tys.len());\n@@ -604,7 +600,7 @@ impl<'a, 'gcx, 'tcx, H: Hasher> TypeVisitor<'tcx> for TypeIdHasher<'a, 'gcx, 'tc\n impl<'a, 'tcx> ty::TyS<'tcx> {\n     fn impls_bound(&'tcx self, tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                    param_env: &ParameterEnvironment<'tcx>,\n-                   bound: ty::BuiltinBound,\n+                   def_id: DefId,\n                    cache: &RefCell<FxHashMap<Ty<'tcx>, bool>>,\n                    span: Span) -> bool\n     {\n@@ -616,7 +612,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n         let result =\n             tcx.infer_ctxt(None, Some(param_env.clone()), Reveal::ExactMatch)\n             .enter(|infcx| {\n-                traits::type_known_to_meet_builtin_bound(&infcx, self, bound, span)\n+                traits::type_known_to_meet_bound(&infcx, self, def_id, span)\n             });\n         if self.has_param_types() || self.has_self_ty() {\n             cache.borrow_mut().insert(self, result);\n@@ -645,12 +641,13 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n                 mutbl: hir::MutMutable, ..\n             }) => Some(true),\n \n-            TyArray(..) | TySlice(..) | TyTrait(..) | TyTuple(..) |\n+            TyArray(..) | TySlice(..) | TyDynamic(..) | TyTuple(..) |\n             TyClosure(..) | TyAdt(..) | TyAnon(..) |\n             TyProjection(..) | TyParam(..) | TyInfer(..) | TyError => None\n         }.unwrap_or_else(|| {\n-            !self.impls_bound(tcx, param_env, ty::BoundCopy, &param_env.is_copy_cache, span)\n-        });\n+            !self.impls_bound(tcx, param_env,\n+                              tcx.require_lang_item(lang_items::CopyTraitLangItem),\n+                              &param_env.is_copy_cache, span) });\n \n         if !self.has_param_types() && !self.has_self_ty() {\n             self.flags.set(self.flags.get() | if result {\n@@ -686,13 +683,13 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n             TyBox(..) | TyRawPtr(..) | TyRef(..) | TyFnDef(..) | TyFnPtr(_) |\n             TyArray(..) | TyTuple(..) | TyClosure(..) | TyNever => Some(true),\n \n-            TyStr | TyTrait(..) | TySlice(_) => Some(false),\n+            TyStr | TyDynamic(..) | TySlice(_) => Some(false),\n \n             TyAdt(..) | TyProjection(..) | TyParam(..) |\n             TyInfer(..) | TyAnon(..) | TyError => None\n         }.unwrap_or_else(|| {\n-            self.impls_bound(tcx, param_env, ty::BoundSized, &param_env.is_sized_cache, span)\n-        });\n+            self.impls_bound(tcx, param_env, tcx.require_lang_item(lang_items::SizedTraitLangItem),\n+                              &param_env.is_sized_cache, span) });\n \n         if !self.has_param_types() && !self.has_self_ty() {\n             self.flags.set(self.flags.get() | if result {\n@@ -776,7 +773,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n             }\n         }\n \n-        fn same_struct_or_enum<'tcx>(ty: Ty<'tcx>, def: ty::AdtDef<'tcx>) -> bool {\n+        fn same_struct_or_enum<'tcx>(ty: Ty<'tcx>, def: &'tcx ty::AdtDef) -> bool {\n             match ty.sty {\n                 TyAdt(ty_def, _) => {\n                      ty_def == def"}, {"sha": "3fa7a803141d1d51eafd5993f3d84aff4f42fa43", "filename": "src/librustc/ty/walk.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwalk.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -12,17 +12,22 @@\n //! WARNING: this does not keep track of the region depth.\n \n use ty::{self, Ty};\n-use std::iter::Iterator;\n-use std::vec::IntoIter;\n+use rustc_data_structures::small_vec::SmallVec;\n+use rustc_data_structures::accumulate_vec::IntoIter as AccIntoIter;\n+\n+// The TypeWalker's stack is hot enough that it's worth going to some effort to\n+// avoid heap allocations.\n+pub type TypeWalkerArray<'tcx> = [Ty<'tcx>; 8];\n+pub type TypeWalkerStack<'tcx> = SmallVec<TypeWalkerArray<'tcx>>;\n \n pub struct TypeWalker<'tcx> {\n-    stack: Vec<Ty<'tcx>>,\n+    stack: TypeWalkerStack<'tcx>,\n     last_subtree: usize,\n }\n \n impl<'tcx> TypeWalker<'tcx> {\n     pub fn new(ty: Ty<'tcx>) -> TypeWalker<'tcx> {\n-        TypeWalker { stack: vec![ty], last_subtree: 1, }\n+        TypeWalker { stack: SmallVec::one(ty), last_subtree: 1, }\n     }\n \n     /// Skips the subtree of types corresponding to the last type\n@@ -61,8 +66,8 @@ impl<'tcx> Iterator for TypeWalker<'tcx> {\n     }\n }\n \n-pub fn walk_shallow<'tcx>(ty: Ty<'tcx>) -> IntoIter<Ty<'tcx>> {\n-    let mut stack = vec![];\n+pub fn walk_shallow<'tcx>(ty: Ty<'tcx>) -> AccIntoIter<TypeWalkerArray<'tcx>> {\n+    let mut stack = SmallVec::new();\n     push_subtypes(&mut stack, ty);\n     stack.into_iter()\n }\n@@ -73,7 +78,7 @@ pub fn walk_shallow<'tcx>(ty: Ty<'tcx>) -> IntoIter<Ty<'tcx>> {\n // known to be significant to any code, but it seems like the\n // natural order one would expect (basically, the order of the\n // types as they are written).\n-fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n+fn push_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent_ty: Ty<'tcx>) {\n     match parent_ty.sty {\n         ty::TyBool | ty::TyChar | ty::TyInt(_) | ty::TyUint(_) | ty::TyFloat(_) |\n         ty::TyStr | ty::TyInfer(_) | ty::TyParam(_) | ty::TyNever | ty::TyError => {\n@@ -87,11 +92,19 @@ fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n         ty::TyProjection(ref data) => {\n             stack.extend(data.trait_ref.substs.types().rev());\n         }\n-        ty::TyTrait(ref obj) => {\n-            stack.extend(obj.principal.input_types().rev());\n-            stack.extend(obj.projection_bounds.iter().map(|pred| {\n-                pred.0.ty\n-            }).rev());\n+        ty::TyDynamic(ref obj, ..) => {\n+            stack.extend(obj.iter().rev().flat_map(|predicate| {\n+                let (substs, opt_ty) = match *predicate.skip_binder() {\n+                    ty::ExistentialPredicate::Trait(tr) => (tr.substs, None),\n+                    ty::ExistentialPredicate::Projection(p) =>\n+                        (p.trait_ref.substs, Some(p.ty)),\n+                    ty::ExistentialPredicate::AutoTrait(_) =>\n+                        // Empty iterator\n+                        (ty::Substs::empty(), None),\n+                };\n+\n+                substs.types().rev().chain(opt_ty)\n+            }));\n         }\n         ty::TyAdt(_, substs) | ty::TyAnon(_, substs) => {\n             stack.extend(substs.types().rev());\n@@ -112,7 +125,7 @@ fn push_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, parent_ty: Ty<'tcx>) {\n     }\n }\n \n-fn push_sig_subtypes<'tcx>(stack: &mut Vec<Ty<'tcx>>, sig: &ty::PolyFnSig<'tcx>) {\n-    stack.push(sig.0.output);\n-    stack.extend(sig.0.inputs.iter().cloned().rev());\n+fn push_sig_subtypes<'tcx>(stack: &mut TypeWalkerStack<'tcx>, sig: &ty::PolyFnSig<'tcx>) {\n+    stack.push(sig.skip_binder().output());\n+    stack.extend(sig.skip_binder().inputs().iter().cloned().rev());\n }"}, {"sha": "bab9964651dcacb4a1d48ff90e975542e9b5a26e", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -17,7 +17,7 @@ use ty::{self, ToPredicate, Ty, TyCtxt, TypeFoldable};\n use std::iter::once;\n use syntax::ast;\n use syntax_pos::Span;\n-use util::common::ErrorReported;\n+use middle::lang_items;\n \n /// Returns the set of obligations needed to make `ty` well-formed.\n /// If `ty` contains unresolved inference variables, this may include\n@@ -282,14 +282,11 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n     fn require_sized(&mut self, subty: Ty<'tcx>, cause: traits::ObligationCauseCode<'tcx>) {\n         if !subty.has_escaping_regions() {\n             let cause = self.cause(cause);\n-            match self.infcx.tcx.trait_ref_for_builtin_bound(ty::BoundSized, subty) {\n-                Ok(trait_ref) => {\n-                    self.out.push(\n-                        traits::Obligation::new(cause,\n-                                                trait_ref.to_predicate()));\n-                }\n-                Err(ErrorReported) => { }\n-            }\n+            let trait_ref = ty::TraitRef {\n+                def_id: self.infcx.tcx.require_lang_item(lang_items::SizedTraitLangItem),\n+                substs: self.infcx.tcx.mk_substs_trait(subty, &[]),\n+            };\n+            self.out.push(traits::Obligation::new(cause, trait_ref.to_predicate()));\n         }\n     }\n \n@@ -298,7 +295,6 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n     /// is WF. Returns false if `ty0` is an unresolved type variable,\n     /// in which case we are not able to simplify at all.\n     fn compute(&mut self, ty0: Ty<'tcx>) -> bool {\n-        let tcx = self.infcx.tcx;\n         let mut subtys = ty0.walk();\n         while let Some(ty) = subtys.next() {\n             match ty.sty {\n@@ -377,12 +373,12 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     // of whatever returned this exact `impl Trait`.\n                 }\n \n-                ty::TyTrait(ref data) => {\n+                ty::TyDynamic(data, r) => {\n                     // WfObject\n                     //\n                     // Here, we defer WF checking due to higher-ranked\n                     // regions. This is perhaps not ideal.\n-                    self.from_object_ty(ty, data);\n+                    self.from_object_ty(ty, data, r);\n \n                     // FIXME(#27579) RFC also considers adding trait\n                     // obligations that don't refer to Self and\n@@ -391,15 +387,12 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     let cause = self.cause(traits::MiscObligation);\n \n                     let component_traits =\n-                        data.builtin_bounds.iter().flat_map(|bound| {\n-                            tcx.lang_items.from_builtin_kind(bound).ok()\n-                        })\n-                        .chain(Some(data.principal.def_id()));\n+                        data.auto_traits().chain(data.principal().map(|p| p.def_id()));\n                     self.out.extend(\n-                        component_traits.map(|did| { traits::Obligation::new(\n+                        component_traits.map(|did| traits::Obligation::new(\n                             cause.clone(),\n                             ty::Predicate::ObjectSafe(did)\n-                        )})\n+                        ))\n                     );\n                 }\n \n@@ -456,7 +449,9 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                   .collect()\n     }\n \n-    fn from_object_ty(&mut self, ty: Ty<'tcx>, data: &ty::TraitObject<'tcx>) {\n+    fn from_object_ty(&mut self, ty: Ty<'tcx>,\n+                      data: ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>,\n+                      region: &'tcx ty::Region) {\n         // Imagine a type like this:\n         //\n         //     trait Foo { }\n@@ -491,11 +486,9 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n \n         if !data.has_escaping_regions() {\n             let implicit_bounds =\n-                object_region_bounds(self.infcx.tcx,\n-                                     data.principal,\n-                                     data.builtin_bounds);\n+                object_region_bounds(self.infcx.tcx, data);\n \n-            let explicit_bound = data.region_bound;\n+            let explicit_bound = region;\n \n             for implicit_bound in implicit_bounds {\n                 let cause = self.cause(traits::ObjectTypeBound(ty, explicit_bound));\n@@ -514,17 +507,21 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n /// `ty::required_region_bounds`, see that for more information.\n pub fn object_region_bounds<'a, 'gcx, 'tcx>(\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    principal: ty::PolyExistentialTraitRef<'tcx>,\n-    others: ty::BuiltinBounds)\n+    existential_predicates: ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>)\n     -> Vec<&'tcx ty::Region>\n {\n     // Since we don't actually *know* the self type for an object,\n     // this \"open(err)\" serves as a kind of dummy standin -- basically\n     // a skolemized type.\n     let open_ty = tcx.mk_infer(ty::FreshTy(0));\n \n-    let mut predicates = others.to_predicates(tcx, open_ty);\n-    predicates.push(principal.with_self_ty(tcx, open_ty).to_predicate());\n+    let predicates = existential_predicates.iter().filter_map(|predicate| {\n+        if let ty::ExistentialPredicate::Projection(_) = *predicate.skip_binder() {\n+            None\n+        } else {\n+            Some(predicate.with_self_ty(tcx, open_ty))\n+        }\n+    }).collect();\n \n     tcx.required_region_bounds(open_ty, predicates)\n }"}, {"sha": "38b38e5b49764b5bcf4c4d59b90b3bb089125d35", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 40, "deletions": 117, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -16,9 +16,8 @@ use ty::{TyBool, TyChar, TyAdt};\n use ty::{TyError, TyStr, TyArray, TySlice, TyFloat, TyFnDef, TyFnPtr};\n use ty::{TyParam, TyRawPtr, TyRef, TyNever, TyTuple};\n use ty::{TyClosure, TyProjection, TyAnon};\n-use ty::{TyBox, TyTrait, TyInt, TyUint, TyInfer};\n+use ty::{TyBox, TyDynamic, TyInt, TyUint, TyInfer};\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n-use ty::fold::{TypeFolder, TypeVisitor};\n \n use std::cell::Cell;\n use std::fmt;\n@@ -298,74 +297,31 @@ fn in_binder<'a, 'gcx, 'tcx, T, U>(f: &mut fmt::Formatter,\n     write!(f, \"{}\", new_value)\n }\n \n-/// This curious type is here to help pretty-print trait objects. In\n-/// a trait object, the projections are stored separately from the\n-/// main trait bound, but in fact we want to package them together\n-/// when printing out; they also have separate binders, but we want\n-/// them to share a binder when we print them out. (And the binder\n-/// pretty-printing logic is kind of clever and we don't want to\n-/// reproduce it.) So we just repackage up the structure somewhat.\n-///\n-/// Right now there is only one trait in an object that can have\n-/// projection bounds, so we just stuff them altogether. But in\n-/// reality we should eventually sort things out better.\n-#[derive(Clone, Debug)]\n-struct TraitAndProjections<'tcx>(ty::TraitRef<'tcx>,\n-                                 Vec<ty::ProjectionPredicate<'tcx>>);\n-\n-impl<'tcx> TypeFoldable<'tcx> for TraitAndProjections<'tcx> {\n-    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        TraitAndProjections(self.0.fold_with(folder), self.1.fold_with(folder))\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.0.visit_with(visitor) || self.1.visit_with(visitor)\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for TraitAndProjections<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let TraitAndProjections(ref trait_ref, ref projection_bounds) = *self;\n-        parameterized(f, trait_ref.substs,\n-                      trait_ref.def_id,\n-                      projection_bounds)\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::TraitObject<'tcx> {\n+impl<'tcx> fmt::Display for &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         // Generate the main trait ref, including associated types.\n         ty::tls::with(|tcx| {\n             // Use a type that can't appear in defaults of type parameters.\n             let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n \n-            let principal = tcx.lift(&self.principal)\n-                               .expect(\"could not lift TraitRef for printing\")\n-                               .with_self_ty(tcx, dummy_self).0;\n-            let projections = self.projection_bounds.iter().map(|p| {\n-                tcx.lift(p)\n-                    .expect(\"could not lift projection for printing\")\n-                    .with_self_ty(tcx, dummy_self).0\n-            }).collect();\n-\n-            let tap = ty::Binder(TraitAndProjections(principal, projections));\n-            in_binder(f, tcx, &ty::Binder(\"\"), Some(tap))\n-        })?;\n+            if let Some(p) = self.principal() {\n+                let principal = tcx.lift(&p).expect(\"could not lift TraitRef for printing\")\n+                    .with_self_ty(tcx, dummy_self);\n+                let projections = self.projection_bounds().map(|p| {\n+                    tcx.lift(&p)\n+                        .expect(\"could not lift projection for printing\")\n+                        .with_self_ty(tcx, dummy_self)\n+                }).collect::<Vec<_>>();\n+                parameterized(f, principal.substs, principal.def_id, &projections)?;\n+            }\n \n-        // Builtin bounds.\n-        for bound in &self.builtin_bounds {\n-            write!(f, \" + {:?}\", bound)?;\n-        }\n+            // Builtin bounds.\n+            for did in self.auto_traits() {\n+                write!(f, \" + {}\", tcx.item_path_str(did))?;\n+            }\n \n-        // FIXME: It'd be nice to compute from context when this bound\n-        // is implied, but that's non-trivial -- we'd perhaps have to\n-        // use thread-local data of some kind? There are also\n-        // advantages to just showing the region, since it makes\n-        // people aware that it's there.\n-        let bound = self.region_bound.to_string();\n-        if !bound.is_empty() {\n-            write!(f, \" + {}\", bound)?;\n-        }\n+            Ok(())\n+        })?;\n \n         Ok(())\n     }\n@@ -432,14 +388,15 @@ impl<'tcx> fmt::Debug for ty::ExistentialTraitRef<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::TraitDef<'tcx> {\n+impl fmt::Debug for ty::TraitDef {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"TraitDef(generics={:?}, trait_ref={:?})\",\n-               self.generics, self.trait_ref)\n+        ty::tls::with(|tcx| {\n+            write!(f, \"{}\", tcx.item_path_str(self.def_id))\n+        })\n     }\n }\n \n-impl<'tcx, 'container> fmt::Debug for ty::AdtDefData<'tcx, 'container> {\n+impl fmt::Debug for ty::AdtDef {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         ty::tls::with(|tcx| {\n             write!(f, \"{}\", tcx.item_path_str(self.did))\n@@ -453,41 +410,6 @@ impl<'tcx> fmt::Debug for ty::adjustment::Adjustment<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::TraitObject<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let mut empty = true;\n-        let mut maybe_continue = |f: &mut fmt::Formatter| {\n-            if empty {\n-                empty = false;\n-                Ok(())\n-            } else {\n-                write!(f, \" + \")\n-            }\n-        };\n-\n-        maybe_continue(f)?;\n-        write!(f, \"{:?}\", self.principal)?;\n-\n-        let region_str = format!(\"{:?}\", self.region_bound);\n-        if !region_str.is_empty() {\n-            maybe_continue(f)?;\n-            write!(f, \"{}\", region_str)?;\n-        }\n-\n-        for bound in &self.builtin_bounds {\n-            maybe_continue(f)?;\n-            write!(f, \"{:?}\", bound)?;\n-        }\n-\n-        for projection_bound in &self.projection_bounds {\n-            maybe_continue(f)?;\n-            write!(f, \"{:?}\", projection_bound)?;\n-        }\n-\n-        Ok(())\n-    }\n-}\n-\n impl<'tcx> fmt::Debug for ty::Predicate<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n@@ -673,20 +595,7 @@ impl<'tcx> fmt::Debug for ty::InstantiatedPredicates<'tcx> {\n impl<'tcx> fmt::Display for ty::FnSig<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"fn\")?;\n-        fn_sig(f, &self.inputs, self.variadic, self.output)\n-    }\n-}\n-\n-impl fmt::Display for ty::BuiltinBounds {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let mut bounds = self.iter();\n-        if let Some(bound) = bounds.next() {\n-            write!(f, \"{:?}\", bound)?;\n-            for bound in bounds {\n-                write!(f, \" + {:?}\", bound)?;\n-            }\n-        }\n-        Ok(())\n+        fn_sig(f, self.inputs(), self.variadic, self.output())\n     }\n }\n \n@@ -716,7 +625,7 @@ impl fmt::Debug for ty::RegionVid {\n \n impl<'tcx> fmt::Debug for ty::FnSig<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"({:?}; variadic: {})->{:?}\", self.inputs, self.variadic, self.output)\n+        write!(f, \"({:?}; variadic: {})->{:?}\", self.inputs(), self.variadic, self.output())\n     }\n }\n \n@@ -753,6 +662,12 @@ impl fmt::Debug for ty::IntVarValue {\n     }\n }*/\n \n+impl<'tcx> fmt::Display for ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n+    }\n+}\n+\n impl<'tcx> fmt::Display for ty::Binder<ty::TraitRef<'tcx>> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n@@ -872,7 +787,15 @@ impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n                     }\n                 })\n             }\n-            TyTrait(ref data) => write!(f, \"{}\", data),\n+            TyDynamic(data, r) => {\n+                write!(f, \"{}\", data)?;\n+                let r = r.to_string();\n+                if !r.is_empty() {\n+                    write!(f, \" + {}\", r)\n+                } else {\n+                    Ok(())\n+                }\n+            }\n             TyProjection(ref data) => write!(f, \"{}\", data),\n             TyAnon(def_id, substs) => {\n                 ty::tls::with(|tcx| {"}, {"sha": "3dc577b3c647acc3a4339ff672053580930a47a2", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -36,7 +36,6 @@\n #![feature(rand)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![cfg_attr(stage0, feature(question_mark))]\n #![cfg_attr(test, feature(rand))]\n \n extern crate syntax;"}, {"sha": "81efd37386a0f9232148e4d83c068526f3c634be", "filename": "src/librustc_back/target/i686_unknown_openbsd.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_openbsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_openbsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_openbsd.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use target::{Target, TargetResult};\n+\n+pub fn target() -> TargetResult {\n+    let mut base = super::openbsd_base::opts();\n+    base.cpu = \"pentium4\".to_string();\n+    base.max_atomic_width = Some(64);\n+    base.pre_link_args.push(\"-m32\".to_string());\n+\n+    Ok(Target {\n+        llvm_target: \"i686-unknown-openbsd\".to_string(),\n+        target_endian: \"little\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n+        data_layout: \"e-m:e-p:32:32-f64:32:64-f80:32-n8:16:32-S128\".to_string(),\n+        arch: \"x86\".to_string(),\n+        target_os: \"openbsd\".to_string(),\n+        target_env: \"\".to_string(),\n+        target_vendor: \"unknown\".to_string(),\n+        options: base,\n+    })\n+}"}, {"sha": "351d469ea2809c5914b837194fb3665344ad9301", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -168,7 +168,10 @@ supported_targets! {\n     (\"x86_64-unknown-dragonfly\", x86_64_unknown_dragonfly),\n \n     (\"x86_64-unknown-bitrig\", x86_64_unknown_bitrig),\n+\n+    (\"i686-unknown-openbsd\", i686_unknown_openbsd),\n     (\"x86_64-unknown-openbsd\", x86_64_unknown_openbsd),\n+\n     (\"x86_64-unknown-netbsd\", x86_64_unknown_netbsd),\n     (\"x86_64-rumprun-netbsd\", x86_64_rumprun_netbsd),\n \n@@ -299,6 +302,9 @@ pub struct TargetOptions {\n     pub staticlib_suffix: String,\n     /// OS family to use for conditional compilation. Valid options: \"unix\", \"windows\".\n     pub target_family: Option<String>,\n+    /// Whether the target toolchain is like OpenBSD's.\n+    /// Only useful for compiling against OpenBSD, for configuring abi when returning a struct.\n+    pub is_like_openbsd: bool,\n     /// Whether the target toolchain is like OSX's. Only useful for compiling against iOS/OS X, in\n     /// particular running dsymutil and some other stuff like `-dead_strip`. Defaults to false.\n     pub is_like_osx: bool,\n@@ -403,6 +409,7 @@ impl Default for TargetOptions {\n             staticlib_prefix: \"lib\".to_string(),\n             staticlib_suffix: \".a\".to_string(),\n             target_family: None,\n+            is_like_openbsd: false,\n             is_like_osx: false,\n             is_like_solaris: false,\n             is_like_windows: false,\n@@ -569,6 +576,7 @@ impl Target {\n         key!(staticlib_prefix);\n         key!(staticlib_suffix);\n         key!(target_family, optional);\n+        key!(is_like_openbsd, bool);\n         key!(is_like_osx, bool);\n         key!(is_like_solaris, bool);\n         key!(is_like_windows, bool);\n@@ -730,6 +738,7 @@ impl ToJson for Target {\n         target_option_val!(staticlib_prefix);\n         target_option_val!(staticlib_suffix);\n         target_option_val!(target_family);\n+        target_option_val!(is_like_openbsd);\n         target_option_val!(is_like_osx);\n         target_option_val!(is_like_solaris);\n         target_option_val!(is_like_windows);"}, {"sha": "1f74170e399893da9efba1030b1f731a000cb2fc", "filename": "src/librustc_back/target/openbsd_base.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fopenbsd_base.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -17,6 +17,7 @@ pub fn opts() -> TargetOptions {\n         executables: true,\n         linker_is_gnu: true,\n         has_rpath: true,\n+        is_like_openbsd: true,\n         pre_link_args: vec![\n             // GNU-style linkers will use this to omit linking to libraries\n             // which don't actually fulfill any relocations, but only for"}, {"sha": "b0a1b3498545fad7ba47b133cab54bdde9862c67", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -496,8 +496,8 @@ fn add_fragment_siblings_for_extension<'a, 'tcx>(this: &MoveData<'tcx>,\n         },\n \n         ref ty => {\n-            let opt_span = origin_id.and_then(|id|tcx.map.opt_span(id));\n-            span_bug!(opt_span.unwrap_or(DUMMY_SP),\n+            let span = origin_id.map_or(DUMMY_SP, |id| tcx.map.span(id));\n+            span_bug!(span,\n                       \"type {:?} ({:?}) is not fragmentable\",\n                       parent_ty, ty);\n         }"}, {"sha": "2c277c04a52e39568f7230e4c99876c64ec81468", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -98,7 +98,7 @@ pub fn gather_move_from_pat<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                       move_pat: &hir::Pat,\n                                       cmt: mc::cmt<'tcx>) {\n     let pat_span_path_opt = match move_pat.node {\n-        PatKind::Binding(_, ref path1, _) => {\n+        PatKind::Binding(_, _, ref path1, _) => {\n             Some(MoveSpanAndPath{span: move_pat.span,\n                                  name: path1.node})\n         },"}, {"sha": "5d59b58b847d9e0eabc99315c5352f0dd67c60d2", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -30,7 +30,7 @@ use syntax_pos::Span;\n use rustc::hir;\n use rustc::hir::Expr;\n use rustc::hir::intravisit;\n-use rustc::hir::intravisit::Visitor;\n+use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n \n use self::restrictions::RestrictionResult;\n \n@@ -520,8 +520,12 @@ struct StaticInitializerCtxt<'a, 'tcx: 'a> {\n     item_id: ast::NodeId\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n-    fn visit_expr(&mut self, ex: &Expr) {\n+impl<'a, 'tcx> Visitor<'tcx> for StaticInitializerCtxt<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.bccx.tcx.map)\n+    }\n+\n+    fn visit_expr(&mut self, ex: &'tcx Expr) {\n         if let hir::ExprAddrOf(mutbl, ref base) = ex.node {\n             let param_env = ty::ParameterEnvironment::for_item(self.bccx.tcx,\n                                                                self.item_id);\n@@ -542,9 +546,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for StaticInitializerCtxt<'a, 'tcx> {\n     }\n }\n \n-pub fn gather_loans_in_static_initializer(bccx: &mut BorrowckCtxt,\n-                                          item_id: ast::NodeId,\n-                                          expr: &hir::Expr) {\n+pub fn gather_loans_in_static_initializer<'a, 'tcx>(bccx: &mut BorrowckCtxt<'a, 'tcx>,\n+                                                    item_id: ast::NodeId,\n+                                                    expr: &'tcx hir::Expr) {\n \n     debug!(\"gather_loans_in_static_initializer(expr={:?})\", expr);\n "}, {"sha": "4f49bfc9725b345078da7699fe1b680b9a5cfd31", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -442,7 +442,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     fn move_paths_for_fields(&self,\n                              base_lv: &Lvalue<'tcx>,\n                              variant_path: MovePathIndex,\n-                             variant: ty::VariantDef<'tcx>,\n+                             variant: &'tcx ty::VariantDef,\n                              substs: &'tcx Substs<'tcx>)\n                              -> Vec<(Lvalue<'tcx>, Option<MovePathIndex>)>\n     {\n@@ -619,7 +619,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     fn open_drop_for_variant<'a>(&mut self,\n                                  c: &DropCtxt<'a, 'tcx>,\n                                  drop_block: &mut Option<BasicBlock>,\n-                                 adt: ty::AdtDef<'tcx>,\n+                                 adt: &'tcx ty::AdtDef,\n                                  substs: &'tcx Substs<'tcx>,\n                                  variant_index: usize)\n                                  -> BasicBlock\n@@ -652,7 +652,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     }\n \n     fn open_drop_for_adt<'a>(&mut self, c: &DropCtxt<'a, 'tcx>,\n-                             adt: ty::AdtDef<'tcx>, substs: &'tcx Substs<'tcx>)\n+                             adt: &'tcx ty::AdtDef, substs: &'tcx Substs<'tcx>)\n                              -> BasicBlock {\n         debug!(\"open_drop_for_adt({:?}, {:?}, {:?})\", c, adt, substs);\n \n@@ -857,8 +857,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n         let tcx = self.tcx;\n         let unit_temp = Lvalue::Local(self.patch.new_temp(tcx.mk_nil()));\n-        let free_func = tcx.lang_items.require(lang_items::BoxFreeFnLangItem)\n-            .unwrap_or_else(|e| tcx.sess.fatal(&e));\n+        let free_func = tcx.require_lang_item(lang_items::BoxFreeFnLangItem);\n         let substs = tcx.mk_substs(iter::once(Kind::from(ty)));\n         let fty = tcx.item_type(free_func).subst(tcx, substs);\n "}, {"sha": "ecf5c3ef176e566f59003cbf943eaa0cdd98cca5", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 115, "deletions": 70, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -24,7 +24,7 @@ use self::InteriorKind::*;\n \n use rustc::dep_graph::DepNode;\n use rustc::hir::map as hir_map;\n-use rustc::hir::map::blocks::FnParts;\n+use rustc::hir::map::blocks::{FnParts, FnLikeNode};\n use rustc::cfg;\n use rustc::middle::dataflow::DataFlowContext;\n use rustc::middle::dataflow::BitwiseOperator;\n@@ -47,7 +47,7 @@ use syntax_pos::{MultiSpan, Span};\n use errors::DiagnosticBuilder;\n \n use rustc::hir;\n-use rustc::hir::intravisit::{self, Visitor, FnKind};\n+use rustc::hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n \n pub mod check_loans;\n \n@@ -62,9 +62,13 @@ pub struct LoanDataFlowOperator;\n \n pub type LoanDataFlow<'a, 'tcx> = DataFlowContext<'a, 'tcx, LoanDataFlowOperator>;\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for BorrowckCtxt<'a, 'tcx> {\n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Expr, s: Span, id: ast::NodeId) {\n+impl<'a, 'tcx> Visitor<'tcx> for BorrowckCtxt<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+    }\n+\n+    fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n+                b: hir::ExprId, s: Span, id: ast::NodeId) {\n         match fk {\n             FnKind::ItemFn(..) |\n             FnKind::Method(..) => {\n@@ -79,18 +83,18 @@ impl<'a, 'tcx, 'v> Visitor<'v> for BorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_item(&mut self, item: &hir::Item) {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n         borrowck_item(self, item);\n     }\n \n-    fn visit_trait_item(&mut self, ti: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem) {\n         if let hir::ConstTraitItem(_, Some(ref expr)) = ti.node {\n             gather_loans::gather_loans_in_static_initializer(self, ti.id, &expr);\n         }\n         intravisit::walk_trait_item(self, ti);\n     }\n \n-    fn visit_impl_item(&mut self, ii: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem) {\n         if let hir::ImplItemKind::Const(_, ref expr) = ii.node {\n             gather_loans::gather_loans_in_static_initializer(self, ii.id, &expr);\n         }\n@@ -131,7 +135,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     }\n }\n \n-fn borrowck_item(this: &mut BorrowckCtxt, item: &hir::Item) {\n+fn borrowck_item<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>, item: &'tcx hir::Item) {\n     // Gather loans for items. Note that we don't need\n     // to check loans for single expressions. The check\n     // loan step is intended for things that have a data\n@@ -154,15 +158,17 @@ pub struct AnalysisData<'a, 'tcx: 'a> {\n     pub move_data: move_data::FlowedMoveData<'a, 'tcx>,\n }\n \n-fn borrowck_fn(this: &mut BorrowckCtxt,\n-               fk: FnKind,\n-               decl: &hir::FnDecl,\n-               body: &hir::Expr,\n-               sp: Span,\n-               id: ast::NodeId,\n-               attributes: &[ast::Attribute]) {\n+fn borrowck_fn<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n+                         fk: FnKind<'tcx>,\n+                         decl: &'tcx hir::FnDecl,\n+                         body_id: hir::ExprId,\n+                         sp: Span,\n+                         id: ast::NodeId,\n+                         attributes: &[ast::Attribute]) {\n     debug!(\"borrowck_fn(id={})\", id);\n \n+    let body = this.tcx.map.expr(body_id);\n+\n     if attributes.iter().any(|item| item.check_name(\"rustc_mir_borrowck\")) {\n         this.with_temp_region_map(id, |this| {\n             mir::borrowck_mir(this, fk, decl, body, sp, id, attributes)\n@@ -191,21 +197,21 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n                              decl,\n                              body);\n \n-    intravisit::walk_fn(this, fk, decl, body, sp, id);\n+    intravisit::walk_fn(this, fk, decl, body_id, sp, id);\n }\n \n fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n-                                          fk: FnKind,\n-                                          decl: &hir::FnDecl,\n+                                          fk: FnKind<'tcx>,\n+                                          decl: &'tcx hir::FnDecl,\n                                           cfg: &cfg::CFG,\n-                                          body: &hir::Expr,\n+                                          body: &'tcx hir::Expr,\n                                           sp: Span,\n                                           id: ast::NodeId)\n                                           -> AnalysisData<'a, 'tcx>\n {\n     // Check the body of fn items.\n     let tcx = this.tcx;\n-    let id_range = intravisit::compute_id_range_for_fn_body(fk, decl, body, sp, id);\n+    let id_range = intravisit::compute_id_range_for_fn_body(fk, decl, body, sp, id, &tcx.map);\n     let (all_loans, move_data) =\n         gather_loans::gather_loans_in_fn(this, id, decl, body);\n \n@@ -241,7 +247,7 @@ fn build_borrowck_dataflow_data<'a, 'tcx>(this: &mut BorrowckCtxt<'a, 'tcx>,\n /// the `BorrowckCtxt` itself , e.g. the flowgraph visualizer.\n pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    fn_parts: FnParts<'a>,\n+    fn_parts: FnParts<'tcx>,\n     cfg: &cfg::CFG)\n     -> (BorrowckCtxt<'a, 'tcx>, AnalysisData<'a, 'tcx>)\n {\n@@ -257,11 +263,13 @@ pub fn build_borrowck_dataflow_data_for_fn<'a, 'tcx>(\n         }\n     };\n \n+    let body = tcx.map.expr(fn_parts.body);\n+\n     let dataflow_data = build_borrowck_dataflow_data(&mut bccx,\n                                                      fn_parts.kind,\n                                                      &fn_parts.decl,\n                                                      cfg,\n-                                                     &fn_parts.body,\n+                                                     body,\n                                                      fn_parts.span,\n                                                      fn_parts.id);\n \n@@ -407,8 +415,8 @@ pub fn closure_to_block(closure_id: ast::NodeId,\n                         tcx: TyCtxt) -> ast::NodeId {\n     match tcx.map.get(closure_id) {\n         hir_map::NodeExpr(expr) => match expr.node {\n-            hir::ExprClosure(.., ref block, _) => {\n-                block.id\n+            hir::ExprClosure(.., body_id, _) => {\n+                body_id.node_id()\n             }\n             _ => {\n                 bug!(\"encountered non-closure id: {}\", closure_id)\n@@ -970,51 +978,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n     pub fn note_and_explain_bckerr(&self, db: &mut DiagnosticBuilder, err: BckError<'tcx>,\n         error_span: Span) {\n-        let code = err.code;\n-        match code {\n-            err_mutbl => {\n-                match err.cmt.note {\n-                    mc::NoteClosureEnv(upvar_id) | mc::NoteUpvarRef(upvar_id) => {\n-                        // If this is an `Fn` closure, it simply can't mutate upvars.\n-                        // If it's an `FnMut` closure, the original variable was declared immutable.\n-                        // We need to determine which is the case here.\n-                        let kind = match err.cmt.upvar().unwrap().cat {\n-                            Categorization::Upvar(mc::Upvar { kind, .. }) => kind,\n-                            _ => bug!()\n-                        };\n-                        if kind == ty::ClosureKind::Fn {\n-                            db.span_help(\n-                                self.tcx.map.span(upvar_id.closure_expr_id),\n-                                \"consider changing this closure to take \\\n-                                 self by mutable reference\");\n-                        }\n-                    }\n-                    _ => {\n-                        if let Categorization::Local(local_id) = err.cmt.cat {\n-                            let span = self.tcx.map.span(local_id);\n-                            if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n-                                if snippet.starts_with(\"ref mut \") || snippet.starts_with(\"&mut \") {\n-                                    db.span_label(error_span, &format!(\"cannot reborrow mutably\"));\n-                                    db.span_label(error_span, &format!(\"try removing `&mut` here\"));\n-                                } else {\n-                                    if snippet.starts_with(\"ref \") {\n-                                        db.span_label(span,\n-                                            &format!(\"use `{}` here to make mutable\",\n-                                                snippet.replace(\"ref \", \"ref mut \")));\n-                                    } else if snippet != \"self\" {\n-                                        db.span_label(span,\n-                                            &format!(\"use `mut {}` here to make mutable\", snippet));\n-                                    }\n-                                    db.span_label(error_span, &format!(\"cannot borrow mutably\"));\n-                                }\n-                            } else {\n-                                db.span_label(error_span, &format!(\"cannot borrow mutably\"));\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-\n+        match err.code {\n+            err_mutbl => self.note_and_explain_mutbl_error(db, &err, &error_span),\n             err_out_of_scope(super_scope, sub_scope, cause) => {\n                 let (value_kind, value_msg) = match err.cmt.cat {\n                     mc::Categorization::Rvalue(_) =>\n@@ -1135,6 +1100,86 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn note_and_explain_mutbl_error(&self, db: &mut DiagnosticBuilder, err: &BckError<'tcx>,\n+                                    error_span: &Span) {\n+        match err.cmt.note {\n+            mc::NoteClosureEnv(upvar_id) | mc::NoteUpvarRef(upvar_id) => {\n+                // If this is an `Fn` closure, it simply can't mutate upvars.\n+                // If it's an `FnMut` closure, the original variable was declared immutable.\n+                // We need to determine which is the case here.\n+                let kind = match err.cmt.upvar().unwrap().cat {\n+                    Categorization::Upvar(mc::Upvar { kind, .. }) => kind,\n+                    _ => bug!()\n+                };\n+                if kind == ty::ClosureKind::Fn {\n+                    db.span_help(self.tcx.map.span(upvar_id.closure_expr_id),\n+                                 \"consider changing this closure to take \\\n+                                 self by mutable reference\");\n+                }\n+            }\n+            _ => {\n+                if let Categorization::Deref(ref inner_cmt, ..) = err.cmt.cat {\n+                    if let Categorization::Local(local_id) = inner_cmt.cat {\n+                        let parent = self.tcx.map.get_parent_node(local_id);\n+                        let opt_fn_decl = FnLikeNode::from_node(self.tcx.map.get(parent))\n+                            .map(|fn_like| fn_like.decl());\n+\n+                        if let Some(fn_decl) = opt_fn_decl {\n+                            if let Some(ref arg) = fn_decl.inputs.iter()\n+                                .find(|ref arg| arg.pat.id == local_id) {\n+                                if let hir::TyRptr(\n+                                    opt_lifetime,\n+                                    hir::MutTy{mutbl: hir::Mutability::MutImmutable, ref ty}) =\n+                                    arg.ty.node {\n+                                    if let Some(lifetime) = opt_lifetime {\n+                                        if let Ok(snippet) = self.tcx.sess.codemap()\n+                                            .span_to_snippet(ty.span) {\n+                                            if let Ok(lifetime_snippet) = self.tcx.sess.codemap()\n+                                                .span_to_snippet(lifetime.span) {\n+                                                    db.span_label(arg.ty.span,\n+                                                                  &format!(\"use `&{} mut {}` \\\n+                                                                            here to make mutable\",\n+                                                                            lifetime_snippet,\n+                                                                            snippet));\n+                                            }\n+                                        }\n+                                    }\n+                                    else if let Ok(snippet) = self.tcx.sess.codemap()\n+                                        .span_to_snippet(arg.ty.span) {\n+                                        if snippet.starts_with(\"&\") {\n+                                            db.span_label(arg.ty.span,\n+                                                          &format!(\"use `{}` here to make mutable\",\n+                                                                   snippet.replace(\"&\", \"&mut \")));\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                } else if let Categorization::Local(local_id) = err.cmt.cat {\n+                    let span = self.tcx.map.span(local_id);\n+                    if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(span) {\n+                        if snippet.starts_with(\"ref mut \") || snippet.starts_with(\"&mut \") {\n+                            db.span_label(*error_span, &format!(\"cannot reborrow mutably\"));\n+                            db.span_label(*error_span, &format!(\"try removing `&mut` here\"));\n+                        } else {\n+                            if snippet.starts_with(\"ref \") {\n+                                db.span_label(span, &format!(\"use `{}` here to make mutable\",\n+                                                             snippet.replace(\"ref \", \"ref mut \")));\n+                            } else if snippet != \"self\" {\n+                                db.span_label(span,\n+                                              &format!(\"use `mut {}` here to make mutable\",\n+                                                       snippet));\n+                            }\n+                            db.span_label(*error_span, &format!(\"cannot borrow mutably\"));\n+                        }\n+                    } else {\n+                        db.span_label(*error_span, &format!(\"cannot borrow mutably\"));\n+                    }\n+                }\n+            }\n+        }\n+    }\n     pub fn append_loan_path_to_string(&self,\n                                       loan_path: &LoanPath<'tcx>,\n                                       out: &mut String) {"}, {"sha": "1ff232da427fcbfcc8b5ce3c056313d2f52d5922", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -19,14 +19,12 @@\n \n #![allow(non_camel_case_types)]\n \n-#![cfg_attr(stage0, feature(dotdot_in_tuple_patterns))]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(associated_consts)]\n #![feature(nonzero)]\n-#![cfg_attr(stage0, feature(question_mark))]\n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n extern crate syntax_pos;"}, {"sha": "23771f4bae3dc109cb81e6b0383443c421f344ba", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -23,8 +23,8 @@ use rustc_data_structures::indexed_vec::Idx;\n use pattern::{FieldPattern, Pattern, PatternKind};\n use pattern::{PatternFoldable, PatternFolder};\n \n-use rustc::hir::def_id::{DefId};\n-use rustc::hir::pat_util::def_to_path;\n+use rustc::hir::def::Def;\n+use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n \n use rustc::hir;\n@@ -223,10 +223,8 @@ pub enum Constructor {\n     Slice(usize),\n }\n \n-impl Constructor {\n-    fn variant_for_adt<'tcx, 'container, 'a>(&self,\n-                                             adt: &'a ty::AdtDefData<'tcx, 'container>)\n-                                             -> &'a ty::VariantDefData<'tcx, 'container> {\n+impl<'tcx> Constructor {\n+    fn variant_for_adt(&self, adt: &'tcx ty::AdtDef) -> &'tcx ty::VariantDef {\n         match self {\n             &Variant(vid) => adt.variant_with_id(vid),\n             &Single => {\n@@ -324,6 +322,12 @@ impl Witness {\n \n                 ty::TyAdt(adt, _) => {\n                     let v = ctor.variant_for_adt(adt);\n+                    let qpath = hir::QPath::Resolved(None, P(hir::Path {\n+                        span: DUMMY_SP,\n+                        global: false,\n+                        def: Def::Err,\n+                        segments: vec![hir::PathSegment::from_name(v.name)].into(),\n+                    }));\n                     match v.ctor_kind {\n                         CtorKind::Fictive => {\n                             let field_pats: hir::HirVec<_> = v.fields.iter()\n@@ -338,16 +342,12 @@ impl Witness {\n                                     }\n                                 }).collect();\n                             let has_more_fields = field_pats.len() < arity;\n-                            PatKind::Struct(\n-                                def_to_path(cx.tcx, v.did), field_pats, has_more_fields)\n+                            PatKind::Struct(qpath, field_pats, has_more_fields)\n                         }\n                         CtorKind::Fn => {\n-                            PatKind::TupleStruct(\n-                                def_to_path(cx.tcx, v.did), pats.collect(), None)\n-                        }\n-                        CtorKind::Const => {\n-                            PatKind::Path(None, def_to_path(cx.tcx, v.did))\n+                            PatKind::TupleStruct(qpath, pats.collect(), None)\n                         }\n+                        CtorKind::Const => PatKind::Path(qpath)\n                     }\n                 }\n "}, {"sha": "786b59e818da2052de8fc7f4e7e3c65523698cfe", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 47, "deletions": 41, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -19,8 +19,6 @@ use eval::report_const_eval_err;\n \n use rustc::dep_graph::DepNode;\n \n-use rustc::hir::pat_util::{pat_bindings, pat_contains_bindings};\n-\n use rustc::middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor};\n use rustc::middle::expr_use_visitor::{LoanCause, MutateMode};\n use rustc::middle::expr_use_visitor as euv;\n@@ -31,7 +29,7 @@ use rustc::ty::{self, TyCtxt};\n use rustc_errors::DiagnosticBuilder;\n \n use rustc::hir::def::*;\n-use rustc::hir::intravisit::{self, Visitor, FnKind};\n+use rustc::hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n use rustc::hir::print::pat_to_string;\n use rustc::hir::{self, Pat, PatKind};\n \n@@ -43,29 +41,33 @@ use syntax_pos::Span;\n \n struct OuterVisitor<'a, 'tcx: 'a> { tcx: TyCtxt<'a, 'tcx, 'tcx> }\n \n-impl<'a, 'v, 'tcx> Visitor<'v> for OuterVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, _expr: &hir::Expr) {\n+impl<'a, 'tcx> Visitor<'tcx> for OuterVisitor<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_expr(&mut self, _expr: &'tcx hir::Expr) {\n         return // const, static and N in [T; N] - shouldn't contain anything\n     }\n \n-    fn visit_trait_item(&mut self, item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem) {\n         if let hir::ConstTraitItem(..) = item.node {\n             return // nothing worth match checking in a constant\n         } else {\n             intravisit::walk_trait_item(self, item);\n         }\n     }\n \n-    fn visit_impl_item(&mut self, item: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem) {\n         if let hir::ImplItemKind::Const(..) = item.node {\n             return // nothing worth match checking in a constant\n         } else {\n             intravisit::walk_impl_item(self, item);\n         }\n     }\n \n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Expr, s: Span, id: ast::NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n+                b: hir::ExprId, s: Span, id: ast::NodeId) {\n         if let FnKind::Closure(..) = fk {\n             span_bug!(s, \"check_match: closure outside of function\")\n         }\n@@ -92,8 +94,12 @@ struct MatchVisitor<'a, 'tcx: 'a> {\n     param_env: &'a ty::ParameterEnvironment<'tcx>\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for MatchVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, ex: &hir::Expr) {\n+impl<'a, 'tcx> Visitor<'tcx> for MatchVisitor<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.tcx.map)\n+    }\n+\n+    fn visit_expr(&mut self, ex: &'tcx hir::Expr) {\n         intravisit::walk_expr(self, ex);\n \n         match ex.node {\n@@ -104,7 +110,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MatchVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_local(&mut self, loc: &hir::Local) {\n+    fn visit_local(&mut self, loc: &'tcx hir::Local) {\n         intravisit::walk_local(self, loc);\n \n         self.check_irrefutable(&loc.pat, false);\n@@ -113,8 +119,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MatchVisitor<'a, 'tcx> {\n         self.check_patterns(false, slice::ref_slice(&loc.pat));\n     }\n \n-    fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Expr, s: Span, n: ast::NodeId) {\n+    fn visit_fn(&mut self, fk: FnKind<'tcx>, fd: &'tcx hir::FnDecl,\n+                b: hir::ExprId, s: Span, n: ast::NodeId) {\n         intravisit::walk_fn(self, fk, fd, b, s, n);\n \n         for input in &fd.inputs {\n@@ -204,7 +210,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n             // Check for empty enum, because is_useful only works on inhabited types.\n             let pat_ty = self.tcx.tables().node_id_to_type(scrut.id);\n             if inlined_arms.is_empty() {\n-                if !pat_ty.is_uninhabited(self.tcx) {\n+                if !pat_ty.is_uninhabited(Some(scrut.id), self.tcx) {\n                     // We know the type is inhabited, so this must be wrong\n                     let mut err = create_e0004(self.tcx.sess, span,\n                                                format!(\"non-exhaustive patterns: type {} \\\n@@ -262,26 +268,22 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n \n fn check_for_bindings_named_the_same_as_variants(cx: &MatchVisitor, pat: &Pat) {\n     pat.walk(|p| {\n-        if let PatKind::Binding(hir::BindByValue(hir::MutImmutable), name, None) = p.node {\n+        if let PatKind::Binding(hir::BindByValue(hir::MutImmutable), _, name, None) = p.node {\n             let pat_ty = cx.tcx.tables().pat_ty(p);\n             if let ty::TyAdt(edef, _) = pat_ty.sty {\n-                if edef.is_enum() {\n-                    if let Def::Local(..) = cx.tcx.expect_def(p.id) {\n-                        if edef.variants.iter().any(|variant| {\n-                            variant.name == name.node && variant.ctor_kind == CtorKind::Const\n-                        }) {\n-                            let ty_path = cx.tcx.item_path_str(edef.did);\n-                            let mut err = struct_span_warn!(cx.tcx.sess, p.span, E0170,\n-                                \"pattern binding `{}` is named the same as one \\\n-                                of the variants of the type `{}`\",\n-                                name.node, ty_path);\n-                            help!(err,\n-                                \"if you meant to match on a variant, \\\n-                                consider making the path in the pattern qualified: `{}::{}`\",\n-                                ty_path, name.node);\n-                            err.emit();\n-                        }\n-                    }\n+                if edef.is_enum() && edef.variants.iter().any(|variant| {\n+                    variant.name == name.node && variant.ctor_kind == CtorKind::Const\n+                }) {\n+                    let ty_path = cx.tcx.item_path_str(edef.did);\n+                    let mut err = struct_span_warn!(cx.tcx.sess, p.span, E0170,\n+                        \"pattern binding `{}` is named the same as one \\\n+                         of the variants of the type `{}`\",\n+                        name.node, ty_path);\n+                    help!(err,\n+                        \"if you meant to match on a variant, \\\n+                        consider making the path in the pattern qualified: `{}::{}`\",\n+                        ty_path, name.node);\n+                    err.emit();\n                 }\n             }\n         }\n@@ -290,13 +292,13 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchVisitor, pat: &Pat) {\n }\n \n /// Checks for common cases of \"catchall\" patterns that may not be intended as such.\n-fn pat_is_catchall(dm: &DefMap, pat: &Pat) -> bool {\n+fn pat_is_catchall(pat: &Pat) -> bool {\n     match pat.node {\n         PatKind::Binding(.., None) => true,\n-        PatKind::Binding(.., Some(ref s)) => pat_is_catchall(dm, s),\n-        PatKind::Ref(ref s, _) => pat_is_catchall(dm, s),\n+        PatKind::Binding(.., Some(ref s)) => pat_is_catchall(s),\n+        PatKind::Ref(ref s, _) => pat_is_catchall(s),\n         PatKind::Tuple(ref v, _) => v.iter().all(|p| {\n-            pat_is_catchall(dm, &p)\n+            pat_is_catchall(&p)\n         }),\n         _ => false\n     }\n@@ -374,7 +376,7 @@ fn check_arms<'a, 'tcx>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n             }\n             if guard.is_none() {\n                 seen.push(v);\n-                if catchall.is_none() && pat_is_catchall(&cx.tcx.def_map.borrow(), hir_pat) {\n+                if catchall.is_none() && pat_is_catchall(hir_pat) {\n                     catchall = Some(pat.span);\n                 }\n             }\n@@ -454,7 +456,7 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n                                    pats: &[P<Pat>]) {\n     let mut by_ref_span = None;\n     for pat in pats {\n-        pat_bindings(&pat, |bm, _, span, _path| {\n+        pat.each_binding(|bm, _, span, _path| {\n             if let hir::BindByRef(..) = bm {\n                 by_ref_span = Some(span);\n             }\n@@ -465,7 +467,7 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n         // check legality of moving out of the enum\n \n         // x @ Foo(..) is legal, but x @ Foo(y) isn't.\n-        if sub.map_or(false, |p| pat_contains_bindings(&p)) {\n+        if sub.map_or(false, |p| p.contains_bindings()) {\n             struct_span_err!(cx.tcx.sess, p.span, E0007,\n                              \"cannot bind by-move with sub-bindings\")\n                 .span_label(p.span, &format!(\"binds an already bound by-move value by moving it\"))\n@@ -486,7 +488,7 @@ fn check_legality_of_move_bindings(cx: &MatchVisitor,\n \n     for pat in pats {\n         pat.walk(|p| {\n-            if let PatKind::Binding(hir::BindByValue(..), _, ref sub) = p.node {\n+            if let PatKind::Binding(hir::BindByValue(..), _, _, ref sub) = p.node {\n                 let pat_ty = cx.tcx.tables().node_id_to_type(p.id);\n                 if pat_ty.moves_by_default(cx.tcx, cx.param_env, pat.span) {\n                     check_move(p, sub.as_ref().map(|p| &**p));\n@@ -563,6 +565,10 @@ struct AtBindingPatternVisitor<'a, 'b:'a, 'tcx:'b> {\n }\n \n impl<'a, 'b, 'tcx, 'v> Visitor<'v> for AtBindingPatternVisitor<'a, 'b, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v> {\n+        NestedVisitorMap::None\n+    }\n+\n     fn visit_pat(&mut self, pat: &Pat) {\n         match pat.node {\n             PatKind::Binding(.., ref subpat) => {"}, {"sha": "9fcab1239899fed2b44055026b324cb5f3ee3c80", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 112, "deletions": 106, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -19,9 +19,8 @@ use rustc::hir::map as ast_map;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::middle::cstore::InlinedItem;\n use rustc::traits;\n-use rustc::hir::def::{Def, CtorKind, PathResolution};\n+use rustc::hir::def::{Def, CtorKind};\n use rustc::hir::def_id::DefId;\n-use rustc::hir::pat_util::def_to_path;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::util::IntTypeExt;\n use rustc::ty::subst::Substs;\n@@ -34,15 +33,13 @@ use graphviz::IntoCow;\n use syntax::ast;\n use rustc::hir::{Expr, PatKind};\n use rustc::hir;\n-use rustc::hir::intravisit::FnKind;\n use syntax::ptr::P;\n use syntax::codemap;\n use syntax::attr::IntType;\n use syntax_pos::{self, Span};\n \n use std::borrow::Cow;\n use std::cmp::Ordering;\n-use std::collections::hash_map::Entry::Vacant;\n \n use rustc_const_math::*;\n use rustc_errors::DiagnosticBuilder;\n@@ -105,14 +102,16 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 _ => None\n             },\n             Some(ast_map::NodeTraitItem(ti)) => match ti.node {\n-                hir::ConstTraitItem(..) => {\n+                hir::ConstTraitItem(ref ty, ref expr_option) => {\n                     if let Some(substs) = substs {\n                         // If we have a trait item and the substitutions for it,\n                         // `resolve_trait_associated_const` will select an impl\n                         // or the default.\n                         let trait_id = tcx.map.get_parent(node_id);\n                         let trait_id = tcx.map.local_def_id(trait_id);\n-                        resolve_trait_associated_const(tcx, ti, trait_id, substs)\n+                        let default_value = expr_option.as_ref()\n+                            .map(|expr| (&**expr, tcx.ast_ty_to_prim_ty(ty)));\n+                        resolve_trait_associated_const(tcx, def_id, default_value, trait_id, substs)\n                     } else {\n                         // Technically, without knowing anything about the\n                         // expression that generates the obligation, we could\n@@ -143,33 +142,31 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n         let mut used_substs = false;\n         let expr_ty = match tcx.sess.cstore.maybe_get_item_ast(tcx, def_id) {\n-            Some((&InlinedItem::Item(_, ref item), _)) => match item.node {\n-                hir::ItemConst(ref ty, ref const_expr) => {\n-                    Some((&**const_expr, tcx.ast_ty_to_prim_ty(ty)))\n-                },\n-                _ => None\n-            },\n-            Some((&InlinedItem::TraitItem(trait_id, ref ti), _)) => match ti.node {\n-                hir::ConstTraitItem(..) => {\n+            Some((&InlinedItem { body: ref const_expr, .. }, _)) => {\n+                Some((&**const_expr, Some(tcx.sess.cstore.item_type(tcx, def_id))))\n+            }\n+            _ => None\n+        };\n+        let expr_ty = match tcx.sess.cstore.describe_def(def_id) {\n+            Some(Def::AssociatedConst(_)) => {\n+                let trait_id = tcx.sess.cstore.trait_of_item(def_id);\n+                // As mentioned in the comments above for in-crate\n+                // constants, we only try to find the expression for a\n+                // trait-associated const if the caller gives us the\n+                // substitutions for the reference to it.\n+                if let Some(trait_id) = trait_id {\n                     used_substs = true;\n+\n                     if let Some(substs) = substs {\n-                        // As mentioned in the comments above for in-crate\n-                        // constants, we only try to find the expression for\n-                        // a trait-associated const if the caller gives us\n-                        // the substitutions for the reference to it.\n-                        resolve_trait_associated_const(tcx, ti, trait_id, substs)\n+                        resolve_trait_associated_const(tcx, def_id, expr_ty, trait_id, substs)\n                     } else {\n                         None\n                     }\n+                } else {\n+                    expr_ty\n                 }\n-                _ => None\n-            },\n-            Some((&InlinedItem::ImplItem(_, ref ii), _)) => match ii.node {\n-                hir::ImplItemKind::Const(ref ty, ref expr) => {\n-                    Some((&**expr, tcx.ast_ty_to_prim_ty(ty)))\n-                },\n-                _ => None\n             },\n+            Some(Def::Const(..)) => expr_ty,\n             _ => None\n         };\n         // If we used the substitutions, particularly to choose an impl\n@@ -198,24 +195,29 @@ fn inline_const_fn_from_external_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         return None;\n     }\n \n-    let fn_id = match tcx.sess.cstore.maybe_get_item_ast(tcx, def_id) {\n-        Some((&InlinedItem::Item(_, ref item), _)) => Some(item.id),\n-        Some((&InlinedItem::ImplItem(_, ref item), _)) => Some(item.id),\n-        _ => None\n-    };\n+    let fn_id = tcx.sess.cstore.maybe_get_item_ast(tcx, def_id).map(|t| t.1);\n     tcx.extern_const_fns.borrow_mut().insert(def_id,\n                                              fn_id.unwrap_or(ast::DUMMY_NODE_ID));\n     fn_id\n }\n \n+pub enum ConstFnNode<'tcx> {\n+    Local(FnLikeNode<'tcx>),\n+    Inlined(&'tcx InlinedItem)\n+}\n+\n pub fn lookup_const_fn_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n-                                       -> Option<FnLikeNode<'tcx>>\n+                                       -> Option<ConstFnNode<'tcx>>\n {\n     let fn_id = if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n         node_id\n     } else {\n         if let Some(fn_id) = inline_const_fn_from_external_crate(tcx, def_id) {\n-            fn_id\n+            if let ast_map::NodeInlinedItem(ii) = tcx.map.get(fn_id) {\n+                return Some(ConstFnNode::Inlined(ii));\n+            } else {\n+                bug!(\"Got const fn from external crate, but it's not inlined\")\n+            }\n         } else {\n             return None;\n         }\n@@ -226,18 +228,10 @@ pub fn lookup_const_fn_by_id<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefI\n         None => return None\n     };\n \n-    match fn_like.kind() {\n-        FnKind::ItemFn(_, _, _, hir::Constness::Const, ..) => {\n-            Some(fn_like)\n-        }\n-        FnKind::Method(_, m, ..) => {\n-            if m.constness == hir::Constness::Const {\n-                Some(fn_like)\n-            } else {\n-                None\n-            }\n-        }\n-        _ => None\n+    if fn_like.constness() == hir::Constness::Const {\n+        Some(ConstFnNode::Local(fn_like))\n+    } else {\n+        None\n     }\n }\n \n@@ -282,27 +276,37 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 .collect::<Result<_, _>>()?, None),\n \n         hir::ExprCall(ref callee, ref args) => {\n-            let def = tcx.expect_def(callee.id);\n-            if let Vacant(entry) = tcx.def_map.borrow_mut().entry(expr.id) {\n-               entry.insert(PathResolution::new(def));\n-            }\n-            let path = match def {\n-                Def::StructCtor(def_id, CtorKind::Fn) |\n-                Def::VariantCtor(def_id, CtorKind::Fn) => def_to_path(tcx, def_id),\n-                Def::Fn(..) | Def::Method(..) => return Ok(P(hir::Pat {\n-                    id: expr.id,\n-                    node: PatKind::Lit(P(expr.clone())),\n-                    span: span,\n-                })),\n+            let qpath = match callee.node {\n+                hir::ExprPath(ref qpath) => qpath,\n                 _ => bug!()\n             };\n-            let pats = args.iter()\n-                           .map(|expr| const_expr_to_pat(tcx, &*expr, pat_id, span))\n-                           .collect::<Result<_, _>>()?;\n-            PatKind::TupleStruct(path, pats, None)\n+            let def = tcx.tables().qpath_def(qpath, callee.id);\n+            let ctor_path = if let hir::QPath::Resolved(_, ref path) = *qpath {\n+                match def {\n+                    Def::StructCtor(_, CtorKind::Fn) |\n+                    Def::VariantCtor(_, CtorKind::Fn) => {\n+                        Some(path.clone())\n+                    }\n+                    _ => None\n+                }\n+            } else {\n+                None\n+            };\n+            match (def, ctor_path) {\n+                (Def::Fn(..), None) | (Def::Method(..), None) => {\n+                    PatKind::Lit(P(expr.clone()))\n+                }\n+                (_, Some(ctor_path)) => {\n+                    let pats = args.iter()\n+                                   .map(|expr| const_expr_to_pat(tcx, expr, pat_id, span))\n+                                   .collect::<Result<_, _>>()?;\n+                    PatKind::TupleStruct(hir::QPath::Resolved(None, ctor_path), pats, None)\n+                }\n+                _ => bug!()\n+            }\n         }\n \n-        hir::ExprStruct(ref path, ref fields, None) => {\n+        hir::ExprStruct(ref qpath, ref fields, None) => {\n             let field_pats =\n                 fields.iter()\n                       .map(|field| Ok(codemap::Spanned {\n@@ -314,7 +318,7 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           },\n                       }))\n                       .collect::<Result<_, _>>()?;\n-            PatKind::Struct((**path).clone(), field_pats, false)\n+            PatKind::Struct(qpath.clone(), field_pats, false)\n         }\n \n         hir::ExprArray(ref exprs) => {\n@@ -324,10 +328,18 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             PatKind::Slice(pats, None, hir::HirVec::new())\n         }\n \n-        hir::ExprPath(_, ref path) => {\n-            match tcx.expect_def(expr.id) {\n+        hir::ExprPath(ref qpath) => {\n+            let def = tcx.tables().qpath_def(qpath, expr.id);\n+            match def {\n                 Def::StructCtor(_, CtorKind::Const) |\n-                Def::VariantCtor(_, CtorKind::Const) => PatKind::Path(None, path.clone()),\n+                Def::VariantCtor(_, CtorKind::Const) => {\n+                    match expr.node {\n+                        hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+                            PatKind::Path(hir::QPath::Resolved(None, path.clone()))\n+                        }\n+                        _ => bug!()\n+                    }\n+                }\n                 Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                     let substs = Some(tcx.tables().node_id_item_substs(expr.id)\n                         .unwrap_or_else(|| tcx.intern_substs(&[])));\n@@ -788,14 +800,9 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             Err(kind) => return Err(ConstEvalErr { span: e.span, kind: kind }),\n         }\n       }\n-      hir::ExprPath(..) => {\n-          // This function can be used before type checking when not all paths are fully resolved.\n-          // FIXME: There's probably a better way to make sure we don't panic here.\n-          let resolution = tcx.expect_resolution(e.id);\n-          if resolution.depth != 0 {\n-              signal!(e, UnresolvedPath);\n-          }\n-          match resolution.base_def {\n+      hir::ExprPath(ref qpath) => {\n+          let def = tcx.tables().qpath_def(qpath, e.id);\n+          match def {\n               Def::Const(def_id) |\n               Def::AssociatedConst(def_id) => {\n                   let substs = if let ExprTypeChecked = ty_hint {\n@@ -845,6 +852,7 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                   }\n               },\n               Def::Method(id) | Def::Fn(id) => Function(id),\n+              Def::Err => signal!(e, UnresolvedPath),\n               _ => signal!(e, NonConstPath),\n           }\n       }\n@@ -856,15 +864,22 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n               Struct(_) => signal!(e, UnimplementedConstVal(\"tuple struct constructors\")),\n               callee => signal!(e, CallOn(callee)),\n           };\n-          let (decl, result) = if let Some(fn_like) = lookup_const_fn_by_id(tcx, did) {\n-              (fn_like.decl(), fn_like.body())\n-          } else {\n-              signal!(e, NonConstPath)\n+          let (arg_defs, body_id) = match lookup_const_fn_by_id(tcx, did) {\n+              Some(ConstFnNode::Inlined(ii)) => (ii.const_fn_args.clone(), ii.body.expr_id()),\n+              Some(ConstFnNode::Local(fn_like)) =>\n+                  (fn_like.decl().inputs.iter()\n+                   .map(|arg| match arg.pat.node {\n+                       hir::PatKind::Binding(_, def_id, _, _) => Some(def_id),\n+                       _ => None\n+                   }).collect(),\n+                   fn_like.body()),\n+              None => signal!(e, NonConstPath),\n           };\n-          assert_eq!(decl.inputs.len(), args.len());\n+          let result = tcx.map.expr(body_id);\n+          assert_eq!(arg_defs.len(), args.len());\n \n           let mut call_args = DefIdMap();\n-          for (arg, arg_expr) in decl.inputs.iter().zip(args.iter()) {\n+          for (arg, arg_expr) in arg_defs.into_iter().zip(args.iter()) {\n               let arg_hint = ty_hint.erase_hint();\n               let arg_val = eval_const_expr_partial(\n                   tcx,\n@@ -873,8 +888,9 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                   fn_args\n               )?;\n               debug!(\"const call arg: {:?}\", arg);\n-              let old = call_args.insert(tcx.expect_def(arg.pat.id).def_id(), arg_val);\n-              assert!(old.is_none());\n+              if let Some(def_id) = arg {\n+                assert!(call_args.insert(def_id, arg_val).is_none());\n+              }\n           }\n           debug!(\"const call({:?})\", call_args);\n           eval_const_expr_partial(tcx, &result, ty_hint, Some(&call_args))?\n@@ -1055,11 +1071,13 @@ fn infer<'a, 'tcx>(i: ConstInt,\n     }\n }\n \n-fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                                ti: &'tcx hir::TraitItem,\n-                                                trait_id: DefId,\n-                                                rcvr_substs: &'tcx Substs<'tcx>)\n-                                                -> Option<(&'tcx Expr, Option<ty::Ty<'tcx>>)>\n+fn resolve_trait_associated_const<'a, 'tcx: 'a>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    trait_item_id: DefId,\n+    default_value: Option<(&'tcx Expr, Option<ty::Ty<'tcx>>)>,\n+    trait_id: DefId,\n+    rcvr_substs: &'tcx Substs<'tcx>\n+) -> Option<(&'tcx Expr, Option<ty::Ty<'tcx>>)>\n {\n     let trait_ref = ty::Binder(ty::TraitRef::new(trait_id, rcvr_substs));\n     debug!(\"resolve_trait_associated_const: trait_ref={:?}\",\n@@ -1090,21 +1108,16 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         // when constructing the inference context above.\n         match selection {\n             traits::VtableImpl(ref impl_data) => {\n+                let name = tcx.associated_item(trait_item_id).name;\n                 let ac = tcx.associated_items(impl_data.impl_def_id)\n-                    .find(|item| item.kind == ty::AssociatedKind::Const && item.name == ti.name);\n+                    .find(|item| item.kind == ty::AssociatedKind::Const && item.name == name);\n                 match ac {\n                     Some(ic) => lookup_const_by_id(tcx, ic.def_id, None),\n-                    None => match ti.node {\n-                        hir::ConstTraitItem(ref ty, Some(ref expr)) => {\n-                            Some((&*expr, tcx.ast_ty_to_prim_ty(ty)))\n-                        },\n-                        _ => None,\n-                    },\n+                    None => default_value,\n                 }\n             }\n             _ => {\n-            span_bug!(ti.span,\n-                      \"resolve_trait_associated_const: unexpected vtable type\")\n+                bug!(\"resolve_trait_associated_const: unexpected vtable type\")\n             }\n         }\n     })\n@@ -1358,17 +1371,10 @@ pub fn eval_length<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             let mut diag = report_const_eval_err(\n                 tcx, &err, count_expr.span, reason);\n \n-            match count_expr.node {\n-                hir::ExprPath(None, hir::Path {\n-                    global: false,\n-                    ref segments,\n-                    ..\n-                }) if segments.len() == 1 => {\n-                    if let Some(Def::Local(..)) = tcx.expect_def_or_none(count_expr.id) {\n-                        diag.note(&format!(\"`{}` is a variable\", segments[0].name));\n-                    }\n+            if let hir::ExprPath(hir::QPath::Resolved(None, ref path)) = count_expr.node {\n+                if let Def::Local(..) = path.def {\n+                    diag.note(&format!(\"`{}` is a variable\", path));\n                 }\n-                _ => {}\n             }\n \n             diag.emit();"}, {"sha": "7a6cc4937232d9bc118b37df3e332bfc4d6f2e10", "filename": "src/librustc_const_eval/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -22,12 +22,10 @@\n       html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n-#![cfg_attr(stage0, feature(dotdot_in_tuple_patterns))]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(slice_patterns)]\n-#![cfg_attr(stage0, feature(question_mark))]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n "}, {"sha": "e93178c89c22b865b20cc054b73883b806c4ea19", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 26, "deletions": 36, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -66,7 +66,7 @@ pub enum PatternKind<'tcx> {\n \n     /// Foo(...) or Foo{...} or Foo, where `Foo` is a variant name from an adt with >1 variants\n     Variant {\n-        adt_def: AdtDef<'tcx>,\n+        adt_def: &'tcx AdtDef,\n         variant_index: usize,\n         subpatterns: Vec<FieldPattern<'tcx>>,\n     },\n@@ -163,8 +163,9 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            PatKind::Path(..) => {\n-                match self.tcx.expect_def(pat.id) {\n+            PatKind::Path(ref qpath) => {\n+                let def = self.tcx.tables().qpath_def(qpath, pat.id);\n+                match def {\n                     Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n                         let tcx = self.tcx.global_tcx();\n                         let substs = tcx.tables().node_id_item_substs(pat.id)\n@@ -188,7 +189,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                             }\n                         }\n                     }\n-                    _ => self.lower_variant_or_leaf(pat, vec![])\n+                    _ => self.lower_variant_or_leaf(def, vec![])\n                 }\n             }\n \n@@ -242,8 +243,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            PatKind::Binding(bm, ref ident, ref sub) => {\n-                let def_id = self.tcx.expect_def(pat.id).def_id();\n+            PatKind::Binding(bm, def_id, ref ident, ref sub) => {\n                 let id = self.tcx.map.as_local_node_id(def_id).unwrap();\n                 let var_ty = self.tcx.tables().node_id_to_type(pat.id);\n                 let region = match var_ty.sty {\n@@ -281,13 +281,14 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            PatKind::TupleStruct(_, ref subpatterns, ddpos) => {\n+            PatKind::TupleStruct(ref qpath, ref subpatterns, ddpos) => {\n+                let def = self.tcx.tables().qpath_def(qpath, pat.id);\n                 let pat_ty = self.tcx.tables().node_id_to_type(pat.id);\n                 let adt_def = match pat_ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n                     _ => span_bug!(pat.span, \"tuple struct pattern not applied to an ADT\"),\n                 };\n-                let variant_def = adt_def.variant_of_def(self.tcx.expect_def(pat.id));\n+                let variant_def = adt_def.variant_of_def(def);\n \n                 let subpatterns =\n                         subpatterns.iter()\n@@ -297,10 +298,11 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                                        pattern: self.lower_pattern(field),\n                                    })\n                                    .collect();\n-                self.lower_variant_or_leaf(pat, subpatterns)\n+                self.lower_variant_or_leaf(def, subpatterns)\n             }\n \n-            PatKind::Struct(_, ref fields, _) => {\n+            PatKind::Struct(ref qpath, ref fields, _) => {\n+                let def = self.tcx.tables().qpath_def(qpath, pat.id);\n                 let pat_ty = self.tcx.tables().node_id_to_type(pat.id);\n                 let adt_def = match pat_ty.sty {\n                     ty::TyAdt(adt_def, _) => adt_def,\n@@ -310,7 +312,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                             \"struct pattern not applied to an ADT\");\n                     }\n                 };\n-                let variant_def = adt_def.variant_of_def(self.tcx.expect_def(pat.id));\n+                let variant_def = adt_def.variant_of_def(def);\n \n                 let subpatterns =\n                     fields.iter()\n@@ -329,7 +331,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                           })\n                           .collect();\n \n-                self.lower_variant_or_leaf(pat, subpatterns)\n+                self.lower_variant_or_leaf(def, subpatterns)\n             }\n         };\n \n@@ -418,11 +420,11 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n \n     fn lower_variant_or_leaf(\n         &mut self,\n-        pat: &hir::Pat,\n+        def: Def,\n         subpatterns: Vec<FieldPattern<'tcx>>)\n         -> PatternKind<'tcx>\n     {\n-        match self.tcx.expect_def(pat.id) {\n+        match def {\n             Def::Variant(variant_id) | Def::VariantCtor(variant_id, ..) => {\n                 let enum_id = self.tcx.parent_def_id(variant_id).unwrap();\n                 let adt_def = self.tcx.lookup_adt_def(enum_id);\n@@ -442,9 +444,7 @@ impl<'a, 'gcx, 'tcx> PatternContext<'a, 'gcx, 'tcx> {\n                 PatternKind::Leaf { subpatterns: subpatterns }\n             }\n \n-            def => {\n-                span_bug!(pat.span, \"inappropriate def for pattern: {:?}\", def);\n-            }\n+            _ => bug!()\n         }\n     }\n }\n@@ -487,32 +487,22 @@ impl<'tcx, T: PatternFoldable<'tcx>> PatternFoldable<'tcx> for Option<T> {\n     }\n }\n \n-macro_rules! CopyImpls {\n-    ($($ty:ty),+) => {\n-        $(\n-            impl<'tcx> PatternFoldable<'tcx> for $ty {\n-                fn super_fold_with<F: PatternFolder<'tcx>>(&self, _: &mut F) -> Self {\n-                    self.clone()\n-                }\n-            }\n-            )+\n-    }\n-}\n-\n-macro_rules! TcxCopyImpls {\n-    ($($ty:ident),+) => {\n+macro_rules! CloneImpls {\n+    (<$lt_tcx:tt> $($ty:ty),+) => {\n         $(\n-            impl<'tcx> PatternFoldable<'tcx> for $ty<'tcx> {\n-                fn super_fold_with<F: PatternFolder<'tcx>>(&self, _: &mut F) -> Self {\n-                    *self\n+            impl<$lt_tcx> PatternFoldable<$lt_tcx> for $ty {\n+                fn super_fold_with<F: PatternFolder<$lt_tcx>>(&self, _: &mut F) -> Self {\n+                    Clone::clone(self)\n                 }\n             }\n         )+\n     }\n }\n \n-CopyImpls!{ Span, Field, Mutability, ast::Name, ast::NodeId, usize, ConstVal }\n-TcxCopyImpls!{ Ty, BindingMode, AdtDef }\n+CloneImpls!{ <'tcx>\n+    Span, Field, Mutability, ast::Name, ast::NodeId, usize, ConstVal,\n+    Ty<'tcx>, BindingMode<'tcx>, &'tcx AdtDef\n+}\n \n impl<'tcx> PatternFoldable<'tcx> for FieldPattern<'tcx> {\n     fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {"}, {"sha": "f667ff23b27a60ce35f04d46ca81de6d272cb50e", "filename": "src/librustc_const_math/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_const_math%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_const_math%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Flib.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -25,7 +25,6 @@\n \n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![cfg_attr(stage0, feature(question_mark))]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;"}, {"sha": "4e2b3786021026bf85b6821724ee0cfe3612201b", "filename": "src/librustc_data_structures/small_vec.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_data_structures%2Fsmall_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_data_structures%2Fsmall_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsmall_vec.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -130,6 +130,18 @@ impl<A: Array> SmallVec<A> {\n             self.set_len(len + 1);\n         }\n     }\n+\n+    pub fn truncate(&mut self, len: usize) {\n+        unsafe {\n+            while len < self.len() {\n+                // Decrement len before the drop_in_place(), so a panic on Drop\n+                // doesn't re-drop the just-failed value.\n+                let newlen = self.len() - 1;\n+                self.set_len(newlen);\n+                ::std::ptr::drop_in_place(self.get_unchecked_mut(newlen));\n+            }\n+        }\n+    }\n }\n \n impl<A: Array> Deref for SmallVec<A> {"}, {"sha": "8d995e97b95b35d9a23b143f7c6a6ba75b158ddf", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 74, "deletions": 65, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -10,7 +10,6 @@\n \n use rustc::hir;\n use rustc::hir::{map as hir_map, FreevarMap, TraitMap};\n-use rustc::hir::def::DefMap;\n use rustc::hir::lowering::lower_crate;\n use rustc_data_structures::blake2b::Blake2bHasher;\n use rustc_data_structures::fmt_wrap::FmtWrap;\n@@ -25,7 +24,7 @@ use rustc::middle::{self, dependency_format, stability, reachable};\n use rustc::middle::privacy::AccessLevels;\n use rustc::ty::{self, TyCtxt};\n use rustc::util::common::time;\n-use rustc::util::nodemap::NodeSet;\n+use rustc::util::nodemap::{NodeSet, NodeMap};\n use rustc_borrowck as borrowck;\n use rustc_incremental::{self, IncrementalHashesMap};\n use rustc_resolve::{MakeGlobMap, Resolver};\n@@ -38,7 +37,7 @@ use rustc_privacy;\n use rustc_plugin::registry::Registry;\n use rustc_plugin as plugin;\n use rustc_passes::{ast_validation, no_asm, loops, consts, rvalues,\n-                   static_recursion, hir_stats};\n+                   static_recursion, hir_stats, mir_stats};\n use rustc_const_eval::check_match;\n use super::Compilation;\n \n@@ -63,7 +62,6 @@ use derive_registrar;\n \n #[derive(Clone)]\n pub struct Resolutions {\n-    pub def_map: DefMap,\n     pub freevars: FreevarMap,\n     pub trait_map: TraitMap,\n     pub maybe_unused_trait_imports: NodeSet,\n@@ -215,6 +213,10 @@ pub fn compile_input(sess: &Session,\n         })??\n     };\n \n+    if sess.opts.debugging_opts.print_type_sizes {\n+        sess.code_stats.borrow().print_type_sizes();\n+    }\n+\n     let phase5_result = phase_5_run_llvm_passes(sess, &trans, &outputs);\n \n     controller_entry_point!(after_llvm,\n@@ -328,31 +330,31 @@ impl<'a> PhaseController<'a> {\n /// State that is passed to a callback. What state is available depends on when\n /// during compilation the callback is made. See the various constructor methods\n /// (`state_*`) in the impl to see which data is provided for any given entry point.\n-pub struct CompileState<'a, 'b, 'ast: 'a, 'tcx: 'b> where 'ast: 'tcx {\n+pub struct CompileState<'a, 'tcx: 'a> {\n     pub input: &'a Input,\n-    pub session: &'ast Session,\n+    pub session: &'tcx Session,\n     pub krate: Option<ast::Crate>,\n     pub registry: Option<Registry<'a>>,\n     pub cstore: Option<&'a CStore>,\n     pub crate_name: Option<&'a str>,\n     pub output_filenames: Option<&'a OutputFilenames>,\n     pub out_dir: Option<&'a Path>,\n     pub out_file: Option<&'a Path>,\n-    pub arenas: Option<&'ast ty::CtxtArenas<'ast>>,\n+    pub arenas: Option<&'tcx ty::CtxtArenas<'tcx>>,\n     pub expanded_crate: Option<&'a ast::Crate>,\n     pub hir_crate: Option<&'a hir::Crate>,\n-    pub ast_map: Option<&'a hir_map::Map<'ast>>,\n+    pub ast_map: Option<&'a hir_map::Map<'tcx>>,\n     pub resolutions: Option<&'a Resolutions>,\n-    pub analysis: Option<&'a ty::CrateAnalysis<'a>>,\n-    pub tcx: Option<TyCtxt<'b, 'tcx, 'tcx>>,\n+    pub analysis: Option<&'a ty::CrateAnalysis<'tcx>>,\n+    pub tcx: Option<TyCtxt<'a, 'tcx, 'tcx>>,\n     pub trans: Option<&'a trans::CrateTranslation>,\n }\n \n-impl<'a, 'b, 'ast, 'tcx> CompileState<'a, 'b, 'ast, 'tcx> {\n+impl<'a, 'tcx> CompileState<'a, 'tcx> {\n     fn empty(input: &'a Input,\n-             session: &'ast Session,\n+             session: &'tcx Session,\n              out_dir: &'a Option<PathBuf>)\n-             -> CompileState<'a, 'b, 'ast, 'tcx> {\n+             -> Self {\n         CompileState {\n             input: input,\n             session: session,\n@@ -375,12 +377,12 @@ impl<'a, 'b, 'ast, 'tcx> CompileState<'a, 'b, 'ast, 'tcx> {\n     }\n \n     fn state_after_parse(input: &'a Input,\n-                         session: &'ast Session,\n+                         session: &'tcx Session,\n                          out_dir: &'a Option<PathBuf>,\n                          out_file: &'a Option<PathBuf>,\n                          krate: ast::Crate,\n                          cstore: &'a CStore)\n-                         -> CompileState<'a, 'b, 'ast, 'tcx> {\n+                         -> Self {\n         CompileState {\n             // Initialize the registry before moving `krate`\n             registry: Some(Registry::new(&session, krate.span)),\n@@ -392,13 +394,13 @@ impl<'a, 'b, 'ast, 'tcx> CompileState<'a, 'b, 'ast, 'tcx> {\n     }\n \n     fn state_after_expand(input: &'a Input,\n-                          session: &'ast Session,\n+                          session: &'tcx Session,\n                           out_dir: &'a Option<PathBuf>,\n                           out_file: &'a Option<PathBuf>,\n                           cstore: &'a CStore,\n                           expanded_crate: &'a ast::Crate,\n                           crate_name: &'a str)\n-                          -> CompileState<'a, 'b, 'ast, 'tcx> {\n+                          -> Self {\n         CompileState {\n             crate_name: Some(crate_name),\n             cstore: Some(cstore),\n@@ -409,18 +411,18 @@ impl<'a, 'b, 'ast, 'tcx> CompileState<'a, 'b, 'ast, 'tcx> {\n     }\n \n     fn state_after_hir_lowering(input: &'a Input,\n-                                session: &'ast Session,\n+                                session: &'tcx Session,\n                                 out_dir: &'a Option<PathBuf>,\n                                 out_file: &'a Option<PathBuf>,\n-                                arenas: &'ast ty::CtxtArenas<'ast>,\n+                                arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                 cstore: &'a CStore,\n-                                hir_map: &'a hir_map::Map<'ast>,\n-                                analysis: &'a ty::CrateAnalysis,\n+                                hir_map: &'a hir_map::Map<'tcx>,\n+                                analysis: &'a ty::CrateAnalysis<'static>,\n                                 resolutions: &'a Resolutions,\n                                 krate: &'a ast::Crate,\n                                 hir_crate: &'a hir::Crate,\n                                 crate_name: &'a str)\n-                                -> CompileState<'a, 'b, 'ast, 'tcx> {\n+                                -> Self {\n         CompileState {\n             crate_name: Some(crate_name),\n             arenas: Some(arenas),\n@@ -436,15 +438,15 @@ impl<'a, 'b, 'ast, 'tcx> CompileState<'a, 'b, 'ast, 'tcx> {\n     }\n \n     fn state_after_analysis(input: &'a Input,\n-                            session: &'ast Session,\n+                            session: &'tcx Session,\n                             out_dir: &'a Option<PathBuf>,\n                             out_file: &'a Option<PathBuf>,\n                             krate: Option<&'a ast::Crate>,\n                             hir_crate: &'a hir::Crate,\n-                            analysis: &'a ty::CrateAnalysis<'a>,\n-                            tcx: TyCtxt<'b, 'tcx, 'tcx>,\n+                            analysis: &'a ty::CrateAnalysis<'tcx>,\n+                            tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             crate_name: &'a str)\n-                            -> CompileState<'a, 'b, 'ast, 'tcx> {\n+                            -> Self {\n         CompileState {\n             analysis: Some(analysis),\n             tcx: Some(tcx),\n@@ -458,11 +460,11 @@ impl<'a, 'b, 'ast, 'tcx> CompileState<'a, 'b, 'ast, 'tcx> {\n \n \n     fn state_after_llvm(input: &'a Input,\n-                        session: &'ast Session,\n+                        session: &'tcx Session,\n                         out_dir: &'a Option<PathBuf>,\n                         out_file: &'a Option<PathBuf>,\n                         trans: &'a trans::CrateTranslation)\n-                        -> CompileState<'a, 'b, 'ast, 'tcx> {\n+                        -> Self {\n         CompileState {\n             trans: Some(trans),\n             out_file: out_file.as_ref().map(|s| &**s),\n@@ -471,10 +473,10 @@ impl<'a, 'b, 'ast, 'tcx> CompileState<'a, 'b, 'ast, 'tcx> {\n     }\n \n     fn state_when_compilation_done(input: &'a Input,\n-                                    session: &'ast Session,\n+                                    session: &'tcx Session,\n                                     out_dir: &'a Option<PathBuf>,\n                                     out_file: &'a Option<PathBuf>)\n-                                    -> CompileState<'a, 'b, 'ast, 'tcx> {\n+                                    -> Self {\n         CompileState {\n             out_file: out_file.as_ref().map(|s| &**s),\n             ..CompileState::empty(input, session, out_dir)\n@@ -528,10 +530,10 @@ fn count_nodes(krate: &ast::Crate) -> usize {\n // For continuing compilation after a parsed crate has been\n // modified\n \n-pub struct ExpansionResult<'a> {\n+pub struct ExpansionResult {\n     pub expanded_crate: ast::Crate,\n     pub defs: hir_map::Definitions,\n-    pub analysis: ty::CrateAnalysis<'a>,\n+    pub analysis: ty::CrateAnalysis<'static>,\n     pub resolutions: Resolutions,\n     pub hir_forest: hir_map::Forest,\n }\n@@ -543,15 +545,15 @@ pub struct ExpansionResult<'a> {\n /// standard library and prelude, and name resolution.\n ///\n /// Returns `None` if we're aborting after handling -W help.\n-pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n-                                           cstore: &CStore,\n-                                           krate: ast::Crate,\n-                                           registry: Option<Registry>,\n-                                           crate_name: &'a str,\n-                                           addl_plugins: Option<Vec<String>>,\n-                                           make_glob_map: MakeGlobMap,\n-                                           after_expand: F)\n-                                           -> Result<ExpansionResult<'a>, usize>\n+pub fn phase_2_configure_and_expand<F>(sess: &Session,\n+                                       cstore: &CStore,\n+                                       krate: ast::Crate,\n+                                       registry: Option<Registry>,\n+                                       crate_name: &str,\n+                                       addl_plugins: Option<Vec<String>>,\n+                                       make_glob_map: MakeGlobMap,\n+                                       after_expand: F)\n+                                       -> Result<ExpansionResult, usize>\n     where F: FnOnce(&ast::Crate) -> CompileResult,\n {\n     let time_passes = sess.time_passes();\n@@ -564,7 +566,7 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n     *sess.crate_disambiguator.borrow_mut() = Symbol::intern(&compute_crate_disambiguator(sess));\n \n     time(time_passes, \"recursion limit\", || {\n-        middle::recursion_limit::update_recursion_limit(sess, &krate);\n+        middle::recursion_limit::update_limits(sess, &krate);\n     });\n \n     krate = time(time_passes, \"crate injection\", || {\n@@ -785,11 +787,11 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n             export_map: resolver.export_map,\n             access_levels: AccessLevels::default(),\n             reachable: NodeSet(),\n-            name: crate_name,\n+            name: crate_name.to_string(),\n             glob_map: if resolver.make_glob_map { Some(resolver.glob_map) } else { None },\n+            hir_ty_to_ty: NodeMap(),\n         },\n         resolutions: Resolutions {\n-            def_map: resolver.def_map,\n             freevars: resolver.freevars,\n             trait_map: resolver.trait_map,\n             maybe_unused_trait_imports: resolver.maybe_unused_trait_imports,\n@@ -803,14 +805,14 @@ pub fn phase_2_configure_and_expand<'a, F>(sess: &Session,\n /// structures carrying the results of the analysis.\n pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                                hir_map: hir_map::Map<'tcx>,\n-                                               mut analysis: ty::CrateAnalysis,\n+                                               mut analysis: ty::CrateAnalysis<'tcx>,\n                                                resolutions: Resolutions,\n                                                arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                                name: &str,\n                                                f: F)\n                                                -> Result<R, usize>\n     where F: for<'a> FnOnce(TyCtxt<'a, 'tcx, 'tcx>,\n-                            ty::CrateAnalysis,\n+                            ty::CrateAnalysis<'tcx>,\n                             IncrementalHashesMap,\n                             CompileResult) -> R\n {\n@@ -836,9 +838,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     let named_region_map = time(time_passes,\n                                 \"lifetime resolution\",\n-                                || middle::resolve_lifetime::krate(sess,\n-                                                                   &hir_map,\n-                                                                   &resolutions.def_map))?;\n+                                || middle::resolve_lifetime::krate(sess, &hir_map))?;\n \n     time(time_passes,\n          \"looking for entry point\",\n@@ -855,17 +855,16 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n     time(time_passes,\n          \"loop checking\",\n-         || loops::check_crate(sess, &resolutions.def_map, &hir_map));\n+         || loops::check_crate(sess, &hir_map));\n \n     time(time_passes,\n               \"static item recursion checking\",\n-              || static_recursion::check_crate(sess, &resolutions.def_map, &hir_map))?;\n+              || static_recursion::check_crate(sess, &hir_map))?;\n \n     let index = stability::Index::new(&hir_map);\n \n     TyCtxt::create_and_enter(sess,\n                              arenas,\n-                             resolutions.def_map,\n                              resolutions.trait_map,\n                              named_region_map,\n                              hir_map,\n@@ -884,8 +883,17 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              \"load_dep_graph\",\n              || rustc_incremental::load_dep_graph(tcx, &incremental_hashes_map));\n \n+        time(time_passes, \"stability index\", || {\n+            tcx.stability.borrow_mut().build(tcx)\n+        });\n+\n+        time(time_passes,\n+             \"stability checking\",\n+             || stability::check_unstable_api_usage(tcx));\n+\n         // passes are timed inside typeck\n-        try_with_f!(typeck::check_crate(tcx), (tcx, analysis, incremental_hashes_map));\n+        analysis.hir_ty_to_ty =\n+            try_with_f!(typeck::check_crate(tcx), (tcx, analysis, incremental_hashes_map));\n \n         time(time_passes,\n              \"const checking\",\n@@ -896,11 +904,6 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                 rustc_privacy::check_crate(tcx, &analysis.export_map)\n             });\n \n-        // Do not move this check past lint\n-        time(time_passes, \"stability index\", || {\n-            tcx.stability.borrow_mut().build(tcx, &analysis.access_levels)\n-        });\n-\n         time(time_passes,\n              \"intrinsic checking\",\n              || middle::intrinsicck::check_crate(tcx));\n@@ -929,6 +932,10 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n              \"MIR dump\",\n              || mir::mir_map::build_mir_for_crate(tcx));\n \n+        if sess.opts.debugging_opts.mir_stats {\n+            mir_stats::print_mir_stats(tcx, \"PRE CLEANUP MIR STATS\");\n+        }\n+\n         time(time_passes, \"MIR cleanup and validation\", || {\n             let mut passes = sess.mir_passes.borrow_mut();\n             // Push all the built-in validation passes.\n@@ -969,14 +976,8 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n             middle::dead::check_crate(tcx, &analysis.access_levels);\n         });\n \n-        let ref lib_features_used =\n-            time(time_passes,\n-                 \"stability checking\",\n-                 || stability::check_unstable_api_usage(tcx));\n-\n         time(time_passes, \"unused lib feature checking\", || {\n-            stability::check_unused_or_stable_features(&tcx.sess,\n-                                                       lib_features_used)\n+            stability::check_unused_or_stable_features(tcx, &analysis.access_levels)\n         });\n \n         time(time_passes,\n@@ -1003,6 +1004,10 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n          \"resolving dependency formats\",\n          || dependency_format::calculate(&tcx.sess));\n \n+    if tcx.sess.opts.debugging_opts.mir_stats {\n+        mir_stats::print_mir_stats(tcx, \"PRE OPTIMISATION MIR STATS\");\n+    }\n+\n     // Run the passes that transform the MIR into a more suitable form for translation to LLVM\n     // code.\n     time(time_passes, \"MIR optimisations\", || {\n@@ -1031,6 +1036,10 @@ pub fn phase_4_translate_to_llvm<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         passes.run_passes(tcx);\n     });\n \n+    if tcx.sess.opts.debugging_opts.mir_stats {\n+        mir_stats::print_mir_stats(tcx, \"POST OPTIMISATION MIR STATS\");\n+    }\n+\n     let translation =\n         time(time_passes,\n              \"translation\","}, {"sha": "f84622c2f028553a547113d7f0b2ef6a40c499b0", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -24,14 +24,12 @@\n #![cfg_attr(not(stage0), deny(warnings))]\n \n #![feature(box_syntax)]\n-#![cfg_attr(stage0, feature(dotdot_in_tuple_patterns))]\n #![feature(libc)]\n #![feature(quote)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(rustc_private)]\n #![feature(set_stdio)]\n #![feature(staged_api)]\n-#![cfg_attr(stage0, feature(question_mark))]\n \n extern crate arena;\n extern crate flate;\n@@ -82,6 +80,8 @@ use rustc_metadata::locator;\n use rustc_metadata::cstore::CStore;\n use rustc::util::common::time;\n \n+use serialize::json::ToJson;\n+\n use std::cmp::max;\n use std::cmp::Ordering::Equal;\n use std::default::Default;\n@@ -586,6 +586,7 @@ impl RustcDefaultCalls {\n                     println!(\"{}\", targets.join(\"\\n\"));\n                 },\n                 PrintRequest::Sysroot => println!(\"{}\", sess.sysroot().display()),\n+                PrintRequest::TargetSpec => println!(\"{}\", sess.target.target.to_json().pretty()),\n                 PrintRequest::FileNames |\n                 PrintRequest::CrateName => {\n                     let input = match input {"}, {"sha": "b055b043723e4ab769304d1a249fa2feff74cd38", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -200,7 +200,7 @@ impl PpSourceMode {\n     fn call_with_pp_support_hir<'tcx, A, B, F>(&self,\n                                                sess: &'tcx Session,\n                                                ast_map: &hir_map::Map<'tcx>,\n-                                               analysis: &ty::CrateAnalysis,\n+                                               analysis: &ty::CrateAnalysis<'tcx>,\n                                                resolutions: &Resolutions,\n                                                arenas: &'tcx ty::CtxtArenas<'tcx>,\n                                                id: &str,\n@@ -696,13 +696,16 @@ impl fold::Folder for ReplaceBodyWithLoop {\n \n fn print_flowgraph<'a, 'tcx, W: Write>(variants: Vec<borrowck_dot::Variant>,\n                                        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       code: blocks::Code,\n+                                       code: blocks::Code<'tcx>,\n                                        mode: PpFlowGraphMode,\n                                        mut out: W)\n                                        -> io::Result<()> {\n     let cfg = match code {\n         blocks::Code::Expr(expr) => cfg::CFG::new(tcx, expr),\n-        blocks::Code::FnLike(fn_like) => cfg::CFG::new(tcx, fn_like.body()),\n+        blocks::Code::FnLike(fn_like) => {\n+            let body = tcx.map.expr(fn_like.body());\n+            cfg::CFG::new(tcx, body)\n+        },\n     };\n     let labelled_edges = mode != PpFlowGraphMode::UnlabelledEdges;\n     let lcfg = LabelledCFG {\n@@ -817,7 +820,7 @@ pub fn print_after_parsing(sess: &Session,\n \n pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                                 ast_map: &hir_map::Map<'tcx>,\n-                                                analysis: &ty::CrateAnalysis,\n+                                                analysis: &ty::CrateAnalysis<'tcx>,\n                                                 resolutions: &Resolutions,\n                                                 input: &Input,\n                                                 krate: &ast::Crate,\n@@ -934,7 +937,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n // Instead, we call that function ourselves.\n fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                        ast_map: &hir_map::Map<'tcx>,\n-                                       analysis: &ty::CrateAnalysis,\n+                                       analysis: &ty::CrateAnalysis<'tcx>,\n                                        resolutions: &Resolutions,\n                                        crate_name: &str,\n                                        arenas: &'tcx ty::CtxtArenas<'tcx>,\n@@ -1003,11 +1006,7 @@ fn print_with_analysis<'tcx, 'a: 'tcx>(sess: &'a Session,\n                                                got {:?}\",\n                                               node);\n \n-                        // Point to what was found, if there's an accessible span.\n-                        match tcx.map.opt_span(nodeid) {\n-                            Some(sp) => tcx.sess.span_fatal(sp, &message),\n-                            None => tcx.sess.fatal(&message),\n-                        }\n+                        tcx.sess.span_fatal(tcx.map.span(nodeid), &message)\n                     }\n                 }\n             }"}, {"sha": "124e7aafcc5158b75b2fb4416f6f5a60d5199104", "filename": "src/librustc_driver/target_features.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_driver%2Ftarget_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_driver%2Ftarget_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftarget_features.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -24,7 +24,8 @@ const ARM_WHITELIST: &'static [&'static str] = &[\"neon\\0\", \"vfp2\\0\", \"vfp3\\0\", \"\n \n const X86_WHITELIST: &'static [&'static str] = &[\"avx\\0\", \"avx2\\0\", \"bmi\\0\", \"bmi2\\0\", \"sse\\0\",\n                                                  \"sse2\\0\", \"sse3\\0\", \"sse4.1\\0\", \"sse4.2\\0\",\n-                                                 \"ssse3\\0\", \"tbm\\0\"];\n+                                                 \"ssse3\\0\", \"tbm\\0\", \"lzcnt\\0\", \"popcnt\\0\",\n+                                                 \"sse4a\\0\"];\n \n /// Add `target_feature = \"...\"` cfgs for a variety of platform\n /// specific features (SSE, NEON etc.)."}, {"sha": "2f8550e5acda70dcca033d3dbdd07de56cd18fc2", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -24,6 +24,7 @@ use rustc::ty::subst::{Kind, Subst};\n use rustc::traits::{ObligationCause, Reveal};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::infer::{self, InferOk, InferResult};\n+use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc_metadata::cstore::CStore;\n use rustc::hir::map as hir_map;\n use rustc::session::{self, config};\n@@ -36,6 +37,7 @@ use errors::emitter::Emitter;\n use errors::{Level, DiagnosticBuilder};\n use syntax::feature_gate::UnstableFeatures;\n use syntax::symbol::Symbol;\n+use syntax_pos::DUMMY_SP;\n \n use rustc::hir;\n \n@@ -131,12 +133,11 @@ fn test_env<F>(source_string: &str,\n \n     // run just enough stuff to build a tcx:\n     let lang_items = lang_items::collect_language_items(&sess, &ast_map);\n-    let named_region_map = resolve_lifetime::krate(&sess, &ast_map, &resolutions.def_map);\n+    let named_region_map = resolve_lifetime::krate(&sess, &ast_map);\n     let region_map = region::resolve_crate(&sess, &ast_map);\n     let index = stability::Index::new(&ast_map);\n     TyCtxt::create_and_enter(&sess,\n                              &arenas,\n-                             resolutions.def_map,\n                              resolutions.trait_map,\n                              named_region_map.unwrap(),\n                              ast_map,\n@@ -266,15 +267,10 @@ impl<'a, 'gcx, 'tcx> Env<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn t_fn(&self, input_tys: &[Ty<'tcx>], output_ty: Ty<'tcx>) -> Ty<'tcx> {\n-        let input_args = input_tys.iter().cloned().collect();\n         self.infcx.tcx.mk_fn_ptr(self.infcx.tcx.mk_bare_fn(ty::BareFnTy {\n             unsafety: hir::Unsafety::Normal,\n             abi: Abi::Rust,\n-            sig: ty::Binder(ty::FnSig {\n-                inputs: input_args,\n-                output: output_ty,\n-                variadic: false,\n-            }),\n+            sig: ty::Binder(self.infcx.tcx.mk_fn_sig(input_tys.iter().cloned(), output_ty, false)),\n         }))\n     }\n \n@@ -495,7 +491,7 @@ fn sub_free_bound_false_infer() {\n     //! does NOT hold for any instantiation of `_#1`.\n \n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n-        let t_infer1 = env.infcx.next_ty_var();\n+        let t_infer1 = env.infcx.next_ty_var(TypeVariableOrigin::MiscVariable(DUMMY_SP));\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         env.check_not_sub(env.t_fn(&[t_infer1], env.tcx().types.isize),\n                           env.t_fn(&[t_rptr_bound1], env.tcx().types.isize));\n@@ -514,7 +510,7 @@ fn lub_free_bound_infer() {\n \n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         env.create_simple_region_hierarchy();\n-        let t_infer1 = env.infcx.next_ty_var();\n+        let t_infer1 = env.infcx.next_ty_var(TypeVariableOrigin::MiscVariable(DUMMY_SP));\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n         let t_rptr_free1 = env.t_rptr_free(1, 1);\n         env.check_lub(env.t_fn(&[t_infer1], env.tcx().types.isize),\n@@ -634,7 +630,7 @@ fn glb_bound_free() {\n fn glb_bound_free_infer() {\n     test_env(EMPTY_SOURCE_STR, errors(&[]), |env| {\n         let t_rptr_bound1 = env.t_rptr_late_bound(1);\n-        let t_infer1 = env.infcx.next_ty_var();\n+        let t_infer1 = env.infcx.next_ty_var(TypeVariableOrigin::MiscVariable(DUMMY_SP));\n \n         // compute GLB(fn(_) -> isize, for<'b> fn(&'b isize) -> isize),\n         // which should yield for<'b> fn(&'b isize) -> isize"}, {"sha": "808fe504b95cdc241f231604587e50d2125e8795", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 353, "deletions": 105, "changes": 458, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -14,7 +14,7 @@ use syntax_pos::{COMMAND_LINE_SP, DUMMY_SP, FileMap, Span, MultiSpan, CharPos};\n \n use {Level, CodeSuggestion, DiagnosticBuilder, SubDiagnostic, CodeMapper};\n use RenderSpan::*;\n-use snippet::{StyledString, Style, Annotation, Line};\n+use snippet::{Annotation, AnnotationType, Line, MultilineAnnotation, StyledString, Style};\n use styled_buffer::StyledBuffer;\n \n use std::io::prelude::*;\n@@ -65,6 +65,7 @@ pub struct EmitterWriter {\n struct FileWithAnnotatedLines {\n     file: Rc<FileMap>,\n     lines: Vec<Line>,\n+    multiline_depth: usize,\n }\n \n \n@@ -137,10 +138,12 @@ impl EmitterWriter {\n                                 line_index: line_index,\n                                 annotations: vec![ann],\n                             }],\n+                multiline_depth: 0,\n             });\n         }\n \n         let mut output = vec![];\n+        let mut multiline_annotations = vec![];\n \n         if let Some(ref cm) = self.cm {\n             for span_label in msp.span_labels() {\n@@ -151,8 +154,9 @@ impl EmitterWriter {\n                 let mut hi = cm.lookup_char_pos(span_label.span.hi);\n                 let mut is_minimized = false;\n \n-                // If the span is multi-line, simplify down to the span of one character\n-                if lo.line != hi.line {\n+                // If the span is long multi-line, simplify down to the span of one character\n+                let max_multiline_span_length = 8;\n+                if lo.line != hi.line && (hi.line - lo.line) > max_multiline_span_length {\n                     hi.line = lo.line;\n                     hi.col = CharPos(lo.col.0 + 1);\n                     is_minimized = true;\n@@ -163,52 +167,108 @@ impl EmitterWriter {\n                 // 6..7. This is degenerate input, but it's best to degrade\n                 // gracefully -- and the parser likes to supply a span like\n                 // that for EOF, in particular.\n-                if lo.col == hi.col {\n+                if lo.col == hi.col && lo.line == hi.line {\n                     hi.col = CharPos(lo.col.0 + 1);\n                 }\n \n-                add_annotation_to_file(&mut output,\n-                                       lo.file,\n-                                       lo.line,\n-                                       Annotation {\n-                                           start_col: lo.col.0,\n-                                           end_col: hi.col.0,\n-                                           is_primary: span_label.is_primary,\n-                                           is_minimized: is_minimized,\n-                                           label: span_label.label.clone(),\n-                                       });\n+                let mut ann = Annotation {\n+                    start_col: lo.col.0,\n+                    end_col: hi.col.0,\n+                    is_primary: span_label.is_primary,\n+                    label: span_label.label.clone(),\n+                    annotation_type: AnnotationType::Singleline,\n+                };\n+                if is_minimized {\n+                    ann.annotation_type = AnnotationType::Minimized;\n+                } else if lo.line != hi.line {\n+                    let ml = MultilineAnnotation {\n+                        depth: 1,\n+                        line_start: lo.line,\n+                        line_end: hi.line,\n+                        start_col: lo.col.0,\n+                        end_col: hi.col.0,\n+                        is_primary: span_label.is_primary,\n+                        label: span_label.label.clone(),\n+                    };\n+                    ann.annotation_type = AnnotationType::Multiline(ml.clone());\n+                    multiline_annotations.push((lo.file.clone(), ml));\n+                };\n+\n+                if !ann.is_multiline() {\n+                    add_annotation_to_file(&mut output,\n+                                           lo.file,\n+                                           lo.line,\n+                                           ann);\n+                }\n+            }\n+        }\n+\n+        // Find overlapping multiline annotations, put them at different depths\n+        multiline_annotations.sort_by(|a, b| {\n+            (a.1.line_start, a.1.line_end).cmp(&(b.1.line_start, b.1.line_end))\n+        });\n+        for item in multiline_annotations.clone() {\n+            let ann = item.1;\n+            for item in multiline_annotations.iter_mut() {\n+                let ref mut a = item.1;\n+                // Move all other multiline annotations overlapping with this one\n+                // one level to the right.\n+                if &ann != a &&\n+                    num_overlap(ann.line_start, ann.line_end, a.line_start, a.line_end, true)\n+                {\n+                    a.increase_depth();\n+                } else {\n+                    break;\n+                }\n             }\n         }\n+\n+        let mut max_depth = 0;  // max overlapping multiline spans\n+        for (file, ann) in multiline_annotations {\n+            if ann.depth > max_depth {\n+                max_depth = ann.depth;\n+            }\n+            add_annotation_to_file(&mut output, file.clone(), ann.line_start, ann.as_start());\n+            for line in ann.line_start + 1..ann.line_end {\n+                add_annotation_to_file(&mut output, file.clone(), line, ann.as_line());\n+            }\n+            add_annotation_to_file(&mut output, file, ann.line_end, ann.as_end());\n+        }\n+        for file_vec in output.iter_mut() {\n+            file_vec.multiline_depth = max_depth;\n+        }\n         output\n     }\n \n     fn render_source_line(&self,\n                           buffer: &mut StyledBuffer,\n                           file: Rc<FileMap>,\n                           line: &Line,\n-                          width_offset: usize) {\n+                          width_offset: usize,\n+                          multiline_depth: usize) {\n         let source_string = file.get_line(line.line_index - 1)\n             .unwrap_or(\"\");\n \n         let line_offset = buffer.num_lines();\n+        let code_offset = if multiline_depth == 0 {\n+            width_offset\n+        } else {\n+            width_offset + multiline_depth + 1\n+        };\n \n         // First create the source line we will highlight.\n-        buffer.puts(line_offset, width_offset, &source_string, Style::Quotation);\n+        buffer.puts(line_offset, code_offset, &source_string, Style::Quotation);\n         buffer.puts(line_offset,\n                     0,\n                     &(line.line_index.to_string()),\n                     Style::LineNumber);\n \n         draw_col_separator(buffer, line_offset, width_offset - 2);\n \n-        if line.annotations.is_empty() {\n-            return;\n-        }\n-\n         // We want to display like this:\n         //\n         //      vec.push(vec.pop().unwrap());\n-        //      ---      ^^^               _ previous borrow ends here\n+        //      ---      ^^^               - previous borrow ends here\n         //      |        |\n         //      |        error occurs here\n         //      previous borrow of `vec` occurs here\n@@ -227,42 +287,22 @@ impl EmitterWriter {\n         // Sort the annotations by (start, end col)\n         let mut annotations = line.annotations.clone();\n         annotations.sort();\n+        annotations.reverse();\n \n-        // Next, create the highlight line.\n-        for annotation in &annotations {\n-            for p in annotation.start_col..annotation.end_col {\n-                if annotation.is_primary {\n-                    buffer.putc(line_offset + 1,\n-                                width_offset + p,\n-                                '^',\n-                                Style::UnderlinePrimary);\n-                    if !annotation.is_minimized {\n-                        buffer.set_style(line_offset, width_offset + p, Style::UnderlinePrimary);\n-                    }\n-                } else {\n-                    buffer.putc(line_offset + 1,\n-                                width_offset + p,\n-                                '-',\n-                                Style::UnderlineSecondary);\n-                    if !annotation.is_minimized {\n-                        buffer.set_style(line_offset, width_offset + p, Style::UnderlineSecondary);\n-                    }\n-                }\n-            }\n-        }\n-        draw_col_separator(buffer, line_offset + 1, width_offset - 2);\n-\n-        // Now we are going to write labels in. To start, we'll exclude\n-        // the annotations with no labels.\n-        let (labeled_annotations, unlabeled_annotations): (Vec<_>, _) = annotations.into_iter()\n-            .partition(|a| a.label.is_some());\n-\n-        // If there are no annotations that need text, we're done.\n-        if labeled_annotations.is_empty() {\n-            return;\n-        }\n-        // Now add the text labels. We try, when possible, to stick the rightmost\n-        // annotation at the end of the highlight line:\n+        // First, figure out where each label will be positioned.\n+        //\n+        // In the case where you have the following annotations:\n+        //\n+        //      vec.push(vec.pop().unwrap());\n+        //      --------                    - previous borrow ends here [C]\n+        //      ||\n+        //      |this makes no sense [B]\n+        //      previous borrow of `vec` occurs here [A]\n+        //\n+        // `annotations_position` will hold [(2, A), (1, B), (0, C)].\n+        //\n+        // We try, when possible, to stick the rightmost annotation at the end\n+        // of the highlight line:\n         //\n         //      vec.push(vec.pop().unwrap());\n         //      ---      ---               - previous borrow ends here\n@@ -296,66 +336,251 @@ impl EmitterWriter {\n         // the rightmost span overlaps with any other span, we should\n         // use the \"hang below\" version, so we can at least make it\n         // clear where the span *starts*.\n-        let mut labeled_annotations = &labeled_annotations[..];\n-        match labeled_annotations.split_last().unwrap() {\n-            (last, previous) => {\n-                if previous.iter()\n-                    .chain(&unlabeled_annotations)\n-                    .all(|a| !overlaps(a, last)) {\n-                    // append the label afterwards; we keep it in a separate\n-                    // string\n-                    let highlight_label: String = format!(\" {}\", last.label.as_ref().unwrap());\n-                    if last.is_primary {\n-                        buffer.append(line_offset + 1, &highlight_label, Style::LabelPrimary);\n-                    } else {\n-                        buffer.append(line_offset + 1, &highlight_label, Style::LabelSecondary);\n-                    }\n-                    labeled_annotations = previous;\n+        let mut annotations_position = vec![];\n+        let mut line_len = 0;\n+        let mut p = 0;\n+        let mut ann_iter = annotations.iter().peekable();\n+        while let Some(annotation) = ann_iter.next() {\n+            let is_line = if let AnnotationType::MultilineLine(_) = annotation.annotation_type {\n+                true\n+            } else {\n+                false\n+            };\n+            let peek = ann_iter.peek();\n+            if let Some(next) = peek {\n+                let next_is_line = if let AnnotationType::MultilineLine(_) = next.annotation_type {\n+                    true\n+                } else {\n+                    false\n+                };\n+\n+                if overlaps(next, annotation) && !is_line && !next_is_line {\n+                    p += 1;\n+                }\n+            }\n+            annotations_position.push((p, annotation));\n+            if let Some(next) = peek {\n+                let next_is_line = if let AnnotationType::MultilineLine(_) = next.annotation_type {\n+                    true\n+                } else {\n+                    false\n+                };\n+                let l = if let Some(ref label) = next.label {\n+                    label.len() + 2\n+                } else {\n+                    0\n+                };\n+                if (overlaps(next, annotation) || next.end_col + l > annotation.start_col)\n+                    && !is_line && !next_is_line\n+                {\n+                    p += 1;\n                 }\n             }\n+            if line_len < p {\n+                line_len = p;\n+            }\n+        }\n+        if line_len != 0 {\n+            line_len += 1;\n         }\n \n-        // If that's the last annotation, we're done\n-        if labeled_annotations.is_empty() {\n+        // If there are no annotations or the only annotations on this line are\n+        // MultilineLine, then there's only code being shown, stop processing.\n+        if line.annotations.is_empty() || line.annotations.iter()\n+            .filter(|a| {\n+                // Set the multiline annotation vertical lines to the left of\n+                // the code in this line.\n+                if let AnnotationType::MultilineLine(depth) = a.annotation_type {\n+                    buffer.putc(line_offset,\n+                                width_offset + depth - 1,\n+                                '|',\n+                                if a.is_primary {\n+                                    Style::UnderlinePrimary\n+                                } else {\n+                                    Style::UnderlineSecondary\n+                                });\n+                    false\n+                } else {\n+                    true\n+                }\n+            }).collect::<Vec<_>>().len() == 0\n+        {\n             return;\n         }\n \n-        for (index, annotation) in labeled_annotations.iter().enumerate() {\n-            // Leave:\n-            // - 1 extra line\n-            // - One line for each thing that comes after\n-            let comes_after = labeled_annotations.len() - index - 1;\n-            let blank_lines = 3 + comes_after;\n+        for pos in 0..line_len + 1 {\n+            draw_col_separator(buffer, line_offset + pos + 1, width_offset - 2);\n+            buffer.putc(line_offset + pos + 1,\n+                        width_offset - 2,\n+                        '|',\n+                        Style::LineNumber);\n+        }\n+\n+        // Write the horizontal lines for multiline annotations\n+        // (only the first and last lines need this).\n+        //\n+        // After this we will have:\n+        //\n+        // 2 |   fn foo() {\n+        //   |  __________\n+        //   |\n+        //   |\n+        // 3 |\n+        // 4 |   }\n+        //   |  _\n+        for &(pos, annotation) in &annotations_position {\n+            let style = if annotation.is_primary {\n+                Style::UnderlinePrimary\n+            } else {\n+                Style::UnderlineSecondary\n+            };\n+            let pos = pos + 1;\n+            match annotation.annotation_type {\n+                AnnotationType::MultilineStart(depth) |\n+                AnnotationType::MultilineEnd(depth) => {\n+                    draw_range(buffer,\n+                               '_',\n+                               line_offset + pos,\n+                               width_offset + depth,\n+                               code_offset + annotation.start_col,\n+                               style);\n+                }\n+                _ => (),\n+            }\n+        }\n \n-            // For each blank line, draw a `|` at our column. The\n-            // text ought to be long enough for this.\n-            for index in 2..blank_lines {\n-                if annotation.is_primary {\n-                    buffer.putc(line_offset + index,\n-                                width_offset + annotation.start_col,\n+        // Write the vertical lines for multiline spans and for labels that are\n+        // on a different line as the underline.\n+        //\n+        // After this we will have:\n+        //\n+        // 2 |   fn foo() {\n+        //   |  __________\n+        //   | |    |\n+        //   | |\n+        // 3 | |\n+        // 4 | | }\n+        //   | |_\n+        for &(pos, annotation) in &annotations_position {\n+            let style = if annotation.is_primary {\n+                Style::UnderlinePrimary\n+            } else {\n+                Style::UnderlineSecondary\n+            };\n+            let pos = pos + 1;\n+            if pos > 1 {\n+                for p in line_offset + 1..line_offset + pos + 1 {\n+                    buffer.putc(p,\n+                                code_offset + annotation.start_col,\n                                 '|',\n-                                Style::UnderlinePrimary);\n+                                style);\n+                }\n+            }\n+            match annotation.annotation_type {\n+                AnnotationType::MultilineStart(depth) => {\n+                    for p in line_offset + pos + 1..line_offset + line_len + 2 {\n+                        buffer.putc(p,\n+                                    width_offset + depth - 1,\n+                                    '|',\n+                                    style);\n+                    }\n+                }\n+                AnnotationType::MultilineEnd(depth) => {\n+                    for p in line_offset..line_offset + pos + 1 {\n+                        buffer.putc(p,\n+                                    width_offset + depth - 1,\n+                                    '|',\n+                                    style);\n+                    }\n+                }\n+                AnnotationType::MultilineLine(depth) => {\n+                    // the first line will have already be filled when we checked\n+                    // wether there were any annotations for this line.\n+                    for p in line_offset + 1..line_offset + line_len + 2 {\n+                        buffer.putc(p,\n+                                    width_offset + depth - 1,\n+                                    '|',\n+                                    style);\n+                    }\n+                }\n+                _ => (),\n+            }\n+        }\n+\n+        // Write the labels on the annotations that actually have a label.\n+        //\n+        // After this we will have:\n+        //\n+        // 2 |   fn foo() {\n+        //   |  __________ starting here...\n+        //   | |    |\n+        //   | |    something about `foo`\n+        // 3 | |\n+        // 4 | | }\n+        //   | |_  ...ending here: test\n+        for &(pos, annotation) in &annotations_position {\n+            let style = if annotation.is_primary {\n+                Style::LabelPrimary\n+            } else {\n+                Style::LabelSecondary\n+            };\n+            let (pos, col) = if pos == 0 {\n+                (pos + 1, annotation.end_col + 1)\n+            } else {\n+                (pos + 2, annotation.start_col)\n+            };\n+            if let Some(ref label) = annotation.label {\n+                buffer.puts(line_offset + pos,\n+                            code_offset + col,\n+                            &label,\n+                            style);\n+            }\n+        }\n+\n+        // Sort from biggest span to smallest span so that smaller spans are\n+        // represented in the output:\n+        //\n+        // x | fn foo()\n+        //   | ^^^---^^\n+        //   | |  |\n+        //   | |  something about `foo`\n+        //   | something about `fn foo()`\n+        annotations_position.sort_by(|a, b| {\n+            fn len(a: &Annotation) -> usize {\n+                // Account for usize underflows\n+                if a.end_col > a.start_col {\n+                    a.end_col - a.start_col\n                 } else {\n-                    buffer.putc(line_offset + index,\n-                                width_offset + annotation.start_col,\n-                                '|',\n-                                Style::UnderlineSecondary);\n+                    a.start_col - a.end_col\n                 }\n-                draw_col_separator(buffer, line_offset + index, width_offset - 2);\n             }\n+            // Decreasing order\n+            len(a.1).cmp(&len(b.1)).reverse()\n+        });\n \n-            if annotation.is_primary {\n-                buffer.puts(line_offset + blank_lines,\n-                            width_offset + annotation.start_col,\n-                            annotation.label.as_ref().unwrap(),\n-                            Style::LabelPrimary);\n+        // Write the underlines.\n+        //\n+        // After this we will have:\n+        //\n+        // 2 |   fn foo() {\n+        //   |  ____-_____^ starting here...\n+        //   | |    |\n+        //   | |    something about `foo`\n+        // 3 | |\n+        // 4 | | }\n+        //   | |_^  ...ending here: test\n+        for &(_, annotation) in &annotations_position {\n+            let (underline, style) = if annotation.is_primary {\n+                ('^', Style::UnderlinePrimary)\n             } else {\n-                buffer.puts(line_offset + blank_lines,\n-                            width_offset + annotation.start_col,\n-                            annotation.label.as_ref().unwrap(),\n-                            Style::LabelSecondary);\n+                ('-', Style::UnderlineSecondary)\n+            };\n+            for p in annotation.start_col..annotation.end_col {\n+                buffer.putc(line_offset + 1,\n+                            code_offset + p,\n+                            underline,\n+                            style);\n             }\n-            draw_col_separator(buffer, line_offset + blank_lines, width_offset - 2);\n         }\n     }\n \n@@ -577,7 +802,8 @@ impl EmitterWriter {\n                 self.render_source_line(&mut buffer,\n                                         annotated_file.file.clone(),\n                                         &annotated_file.lines[line_idx],\n-                                        3 + max_line_num_len);\n+                                        3 + max_line_num_len,\n+                                        annotated_file.multiline_depth);\n \n                 // check to see if we need to print out or elide lines that come between\n                 // this annotated line and the next one\n@@ -729,16 +955,38 @@ fn draw_col_separator(buffer: &mut StyledBuffer, line: usize, col: usize) {\n }\n \n fn draw_col_separator_no_space(buffer: &mut StyledBuffer, line: usize, col: usize) {\n-    buffer.puts(line, col, \"|\", Style::LineNumber);\n+    draw_col_separator_no_space_with_style(buffer, line, col, Style::LineNumber);\n+}\n+\n+fn draw_col_separator_no_space_with_style(buffer: &mut StyledBuffer,\n+                                          line: usize,\n+                                          col: usize,\n+                                          style: Style) {\n+    buffer.putc(line, col, '|', style);\n+}\n+\n+fn draw_range(buffer: &mut StyledBuffer, symbol: char, line: usize,\n+              col_from: usize, col_to: usize, style: Style) {\n+    for col in col_from..col_to {\n+        buffer.putc(line, col, symbol, style);\n+    }\n }\n \n fn draw_note_separator(buffer: &mut StyledBuffer, line: usize, col: usize) {\n     buffer.puts(line, col, \"= \", Style::LineNumber);\n }\n \n+fn num_overlap(a_start: usize, a_end: usize, b_start: usize, b_end:usize, inclusive: bool) -> bool {\n+    let extra = if inclusive {\n+        1\n+    } else {\n+        0\n+    };\n+    (b_start..b_end + extra).contains(a_start) ||\n+    (a_start..a_end + extra).contains(b_start)\n+}\n fn overlaps(a1: &Annotation, a2: &Annotation) -> bool {\n-    (a2.start_col..a2.end_col).contains(a1.start_col) ||\n-    (a1.start_col..a1.end_col).contains(a2.start_col)\n+    num_overlap(a1.start_col, a1.end_col, a2.start_col, a2.end_col, false)\n }\n \n fn emit_to_destination(rendered_buffer: &Vec<Vec<StyledString>>,"}, {"sha": "09a0c7f9be4ea389f76e4abc337925c547994967", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -21,7 +21,6 @@\n #![allow(unused_attributes)]\n #![feature(rustc_private)]\n #![feature(staged_api)]\n-#![cfg_attr(stage0, feature(question_mark))]\n #![feature(range_contains)]\n #![feature(libc)]\n #![feature(unicode)]\n@@ -32,7 +31,7 @@ extern crate term;\n extern crate log;\n #[macro_use]\n extern crate libc;\n-extern crate rustc_unicode;\n+extern crate std_unicode;\n extern crate serialize as rustc_serialize; // used by deriving\n extern crate syntax_pos;\n "}, {"sha": "b8c1726443db350a84451f716577ae8217f82e0e", "filename": "src/librustc_errors/snippet.rs", "status": "modified", "additions": 104, "deletions": 3, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_errors%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_errors%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fsnippet.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -41,6 +41,86 @@ pub struct Line {\n     pub annotations: Vec<Annotation>,\n }\n \n+\n+#[derive(Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n+pub struct MultilineAnnotation {\n+    pub depth: usize,\n+    pub line_start: usize,\n+    pub line_end: usize,\n+    pub start_col: usize,\n+    pub end_col: usize,\n+    pub is_primary: bool,\n+    pub label: Option<String>,\n+}\n+\n+impl MultilineAnnotation {\n+    pub fn increase_depth(&mut self) {\n+        self.depth += 1;\n+    }\n+\n+    pub fn as_start(&self) -> Annotation {\n+        Annotation {\n+            start_col: self.start_col,\n+            end_col: self.start_col + 1,\n+            is_primary: self.is_primary,\n+            label: Some(\"starting here...\".to_owned()),\n+            annotation_type: AnnotationType::MultilineStart(self.depth)\n+        }\n+    }\n+\n+    pub fn as_end(&self) -> Annotation {\n+        Annotation {\n+            start_col: self.end_col - 1,\n+            end_col: self.end_col,\n+            is_primary: self.is_primary,\n+            label: match self.label {\n+                Some(ref label) => Some(format!(\"...ending here: {}\", label)),\n+                None => Some(\"...ending here\".to_owned()),\n+            },\n+            annotation_type: AnnotationType::MultilineEnd(self.depth)\n+        }\n+    }\n+\n+    pub fn as_line(&self) -> Annotation {\n+        Annotation {\n+            start_col: 0,\n+            end_col: 0,\n+            is_primary: self.is_primary,\n+            label: None,\n+            annotation_type: AnnotationType::MultilineLine(self.depth)\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n+pub enum AnnotationType {\n+    /// Annotation under a single line of code\n+    Singleline,\n+\n+    /// Annotation under the first character of a multiline span\n+    Minimized,\n+\n+    /// Annotation enclosing the first and last character of a multiline span\n+    Multiline(MultilineAnnotation),\n+\n+    // The Multiline type above is replaced with the following three in order\n+    // to reuse the current label drawing code.\n+    //\n+    // Each of these corresponds to one part of the following diagram:\n+    //\n+    //     x |   foo(1 + bar(x,\n+    //       |  _________^ starting here...           < MultilineStart\n+    //     x | |             y),                      < MultilineLine\n+    //       | |______________^ ...ending here: label < MultilineEnd\n+    //     x |       z);\n+    /// Annotation marking the first character of a fully shown multiline span\n+    MultilineStart(usize),\n+    /// Annotation marking the last character of a fully shown multiline span\n+    MultilineEnd(usize),\n+    /// Line at the left enclosing the lines of a fully shown multiline span\n+    MultilineLine(usize),\n+}\n+\n #[derive(Clone, Debug, PartialOrd, Ord, PartialEq, Eq)]\n pub struct Annotation {\n     /// Start column, 0-based indexing -- counting *characters*, not\n@@ -55,11 +135,32 @@ pub struct Annotation {\n     /// Is this annotation derived from primary span\n     pub is_primary: bool,\n \n-    /// Is this a large span minimized down to a smaller span\n-    pub is_minimized: bool,\n-\n     /// Optional label to display adjacent to the annotation.\n     pub label: Option<String>,\n+\n+    /// Is this a single line, multiline or multiline span minimized down to a\n+    /// smaller span.\n+    pub annotation_type: AnnotationType,\n+}\n+\n+impl Annotation {\n+    pub fn is_minimized(&self) -> bool {\n+        match self.annotation_type {\n+            AnnotationType::Minimized => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_multiline(&self) -> bool {\n+        match self.annotation_type {\n+            AnnotationType::Multiline(_) |\n+            AnnotationType::MultilineStart(_) |\n+            AnnotationType::MultilineLine(_) |\n+            AnnotationType::MultilineEnd(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n }\n \n #[derive(Debug)]"}, {"sha": "df65c4d27947b68b27dc60b0af8f51dad58c2e03", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627", "patch": "@@ -34,7 +34,7 @@ use rustc::dep_graph::DepNode;\n use rustc::hir;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::hir::intravisit as visit;\n-use rustc::hir::intravisit::Visitor;\n+use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n use rustc::ty::TyCtxt;\n use rustc_data_structures::fx::FxHashMap;\n use rustc::util::common::record_time;\n@@ -112,8 +112,9 @@ pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n         hash_spans: hash_spans,\n     };\n     record_time(&tcx.sess.perf_stats.incr_comp_hashes_time, || {\n-        visitor.calculate_def_id(DefId::local(CRATE_DEF_INDEX),\n-                                 |v| visit::walk_crate(v, krate));\n+        visitor.calculate_def_id(DefId::local(CRATE_DEF_INDEX), |v| {\n+            v.hash_crate_root_module(krate);\n+        });\n         krate.visit_all_item_likes(&mut visitor.as_deep_visitor());\n \n         for macro_def in krate.exported_macros.iter() {\n@@ -149,19 +150,30 @@ impl<'a, 'tcx> HashItemsVisitor<'a, 'tcx> {\n     {\n         assert!(def_id.is_local());\n         debug!(\"HashItemsVisitor::calculate(def_id={:?})\", def_id);\n+        self.calculate_def_hash(DepNode::Hir(def_id), false, &mut walk_op);\n+        self.calculate_def_hash(DepNode::HirBody(def_id), true, &mut walk_op);\n+    }\n+\n+    fn calculate_def_hash<W>(&mut self,\n+                             dep_node: DepNode<DefId>,\n+                             hash_bodies: bool,\n+                             walk_op: &mut W)\n+        where W: for<'v> FnMut(&mut StrictVersionHashVisitor<'v, 'a, 'tcx>)\n+    {\n         let mut state = IchHasher::new();\n         walk_op(&mut StrictVersionHashVisitor::new(&mut state,\n                                                    self.tcx,\n                                                    &mut self.def_path_hashes,\n                                                    &mut self.codemap,\n-                                                   self.hash_spans));\n+                                                   self.hash_spans,\n+                                                   hash_bodies));\n         let bytes_hashed = state.bytes_hashed();\n         let item_hash = state.finish();\n-        self.hashes.insert(DepNode::Hir(def_id), item_hash);\n-        debug!(\"calculate_item_hash: def_id={:?} hash={:?}\", def_id, item_hash);\n+        debug!(\"calculate_def_hash: dep_node={:?} hash={:?}\", dep_node, item_hash);\n+        self.hashes.insert(dep_node, item_hash);\n \n         let bytes_hashed = self.tcx.sess.perf_stats.incr_comp_bytes_hashed.get() +\n-                           bytes_hashed;\n+            bytes_hashed;\n         self.tcx.sess.perf_stats.incr_comp_bytes_hashed.set(bytes_hashed);\n     }\n \n@@ -200,7 +212,8 @@ impl<'a, 'tcx> HashItemsVisitor<'a, 'tcx> {\n                                                             self.tcx,\n                                                             &mut self.def_path_hashes,\n                                                             &mut self.codemap,\n-                                                            self.hash_spans);\n+                                                            self.hash_spans,\n+                                                            false);\n             visitor.hash_attributes(&krate.attrs);\n         }\n \n@@ -212,6 +225,10 @@ impl<'a, 'tcx> HashItemsVisitor<'a, 'tcx> {\n \n \n impl<'a, 'tcx> Visitor<'tcx> for HashItemsVisitor<'a, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n+\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         self.calculate_node_id(item.id, |v| v.visit_item(item));\n         visit::walk_item(self, item);"}, {"sha": "de52b70f1ec92d252f80a0f62d0fdb5c67ab93cf", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "3cb5244413bc0ea9cd8bb1d2df281dd3a47ec048", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "40873011a7b8d7fc73aaa76fa17fc9c75b91a8ac", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "b67caa6750a81b59de426b5923fb98199345a6e7", "filename": "src/librustc_incremental/persist/file_format.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "2ad37e98c708a1af3e797d98e4f38812d7533c7f", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "e5203ea02b45a8095ba4c1b14b3810d7660a4535", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "8ff04a565e96b6f437b5ec40da954c5b15ac8007", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 34, "deletions": 11, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "1ce4bf7f033417735a3fe09c160ee06a71177a8e", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "2aa74407afc5b087fe64c4804f1e0b279b4e3e1d", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "cd414846af4fb610f0f9dc56157218542daed3d6", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 40, "deletions": 170, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "6c9a3e99a0458029e11ff4ecd56adbbd65bbda5b", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "5e9fdbfa07314b9d9a88fd520a082cd2f0c601ae", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "429bfb8e3d60667bc683ee829c17d5ce76fb7b59", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "17678ef2bbd8fd85162c988f3386c0a78a5d5cc6", "filename": "src/librustc_llvm/Cargo.lock", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_llvm%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_llvm%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2FCargo.lock?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "f97daa22ff6624c26487dfe8b9a5e1d1a1c43fb0", "filename": "src/librustc_llvm/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2FCargo.toml?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "cef6199a74af6efa5833afffcc4d0ac732876942", "filename": "src/librustc_llvm/diagnostic.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_llvm%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_llvm%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fdiagnostic.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "a6b2fe471dfe517a0d761d39964c6243a28fb13e", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 46, "deletions": 269, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "a15edcd44be2a21083d98dd3d46de94f1fea0d5a", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "6598b7dcc527faff76d00f6bf3fc19020be69309", "filename": "src/librustc_metadata/astencode.rs", "status": "modified", "additions": 18, "deletions": 25, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_metadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_metadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fastencode.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "d36242537b8e54a255f9920796d4102f7bb97c54", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 124, "deletions": 66, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "7700ebde181333772a7fbda715e721ed85831e18", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "1a1bb1432eec1fc2b625178df786104cdda97ee0", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 51, "deletions": 36, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "54c195b1881622a2038e9d4563078934806ae133", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 103, "deletions": 62, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "6cf1a9e8a390d183e158012749bf6a8e393cfa8b", "filename": "src/librustc_metadata/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_metadata%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_metadata%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdiagnostics.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "443f3fbaa6e41df93d4ef12f7e03da34fb208621", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 68, "deletions": 40, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "56f3cfc12c97f8a3c2bf9bf78982119ecbc85768", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "de465ea92f6b81a3dbb2cc38bb718454e9c386d0", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "f92051cbf1943a03338f8b3e8b1d8bcc5f4464f0", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "ffd9525933b4e5d6f24f43ea414b2ed1db316f2f", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "e06d940de7e58238713e82d98a13846ae6ccb87f", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "cb449037aeba3eb9f610ec8ae32c8c095fd29b3c", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "0e4dbb0477716a246acaa97d24c15c02c4d2860d", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "c02a1822d736961e39f3b894db8a097664245f76", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "bd4724159b4cb9ac53a1e535c1a529bfb388bf90", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "e7a6b40c830bdf4fbaf8be7ac228692b68ff67c2", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "22c07f1903bacf4fbba9fef9c00ee6db88b4386e", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "617bd81d96a2c90f3f83fe1c86d1ca8651b9ac20", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "e2a516edbc8354ff69a7108d3ba416f03b98d832", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "d16b51adbafde996dfd61cc992da18ca0b00870a", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "771f05f7bccfe3223307d0001a85e8c2ae7b0231", "filename": "src/librustc_mir/transform/deaggregator.rs", "status": "modified", "additions": 62, "deletions": 66, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fdeaggregator.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "3f6abb31fe9d9c78e01e5e6afca46db00c3b3e38", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "893478a933182988d45c69552d0f65f412024290", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "4c86331a525766d5ca759642620a4fca7a94a861", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "2d0f0864752ab5739f064b3bc237301369c80cd0", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "86f56d003584155205fe623628809f055c4deefb", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 66, "deletions": 37, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "f7e026866e2df04d0bbc7820f0124b78fbf3216a", "filename": "src/librustc_passes/hir_stats.rs", "status": "modified", "additions": 35, "deletions": 38, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_passes%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_passes%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fhir_stats.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "670ef426c2dd5859fb6806b316665c0f4655cb29", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "10f464a9901d0beebb54f19fc72c9852f70447fe", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "cec1c20519bd6c62b4bfa8370332a5bfdc45dc77", "filename": "src/librustc_passes/mir_stats.rs", "status": "added", "additions": 319, "deletions": 0, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_passes%2Fmir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_passes%2Fmir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fmir_stats.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "4dbf57a99bcbe1395e060ecd59eb48bd863b8078", "filename": "src/librustc_passes/no_asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_passes%2Fno_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_passes%2Fno_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fno_asm.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "ddb5af1e80c345a00973628fb3cb1a4a97051034", "filename": "src/librustc_passes/rvalues.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_passes%2Frvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_passes%2Frvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalues.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "b5be4aa5e64e2ac25195bbf653f0220238cb6808", "filename": "src/librustc_passes/static_recursion.rs", "status": "modified", "additions": 69, "deletions": 71, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_passes%2Fstatic_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_passes%2Fstatic_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fstatic_recursion.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "145b9176f6b131cf5de102db4b118e05ef77ce6d", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 339, "deletions": 275, "changes": 614, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "25a37931ba31fd05cb870ca2aae423ab1221c045", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "41391c65a128d7396196ce9aaf2dfd2e12e45466", "filename": "src/librustc_resolve/check_unused.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_resolve%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_resolve%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fcheck_unused.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "f7aaf2475f65ef982a230b5f9d761084929aa2ec", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 428, "deletions": 737, "changes": 1165, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "6c02967672d84f48d0ffbadef20e2b9a18dcf888", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 97, "deletions": 71, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "b634d57a842f65626078581a10021f2e47c4075f", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 67, "deletions": 69, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "afa78a05a63a897c4a49ca447b4f326c3e22808c", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 101, "deletions": 81, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "f97272ad5440960a7d112fa3b4f8f4138ee89245", "filename": "src/librustc_save_analysis/json_dumper.rs", "status": "modified", "additions": 39, "deletions": 17, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_save_analysis%2Fjson_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_dumper.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "0c910240b60f0765b2349ab98ab999ceb80a43ea", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 62, "deletions": 15, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "0ac853e99eecdba47d0fc66dd9ca0fe2054a825c", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "8ee362bae355123765a6f127d78f1ceb87222564", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "efdd1b736f0e7ae77b8b14b69f1e5e89c53c414f", "filename": "src/librustc_trans/attributes.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fattributes.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "040a05b69a3a5045547be6f04e2daa260e0300e0", "filename": "src/librustc_trans/back/linker.rs", "status": "modified", "additions": 53, "deletions": 57, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flinker.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "f137bfff034d0e37c7cc9af7afd364a86d42064b", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 51, "deletions": 16, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "eef464eb7f4dc61098e64884dd9f9a70ae1ac756", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "ffab0bde7abde743cff20dce98787caeb0e4df62", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "f70c24c3ccb2d4b4bfceab9b1b1bebf9077c217f", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 316, "deletions": 139, "changes": 455, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "ce85234f2034af36cb720a14a387df6065a75544", "filename": "src/librustc_trans/cabi_x86.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "d7e9f1372e06d1af5a206f7243c1a5c84cc98345", "filename": "src/librustc_trans/callee.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcallee.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "3af3ada66b3e9c2ba3c8709f4c4438ae3de58f35", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 53, "deletions": 18, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "b1d61cea39ceceaaad7b2164e6c62dcfc1956633", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "730a4025a59a8ab3b0bd301302039080e0ae762d", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "8b98eb57814ace1e1c78375823b783a9e6f1bb29", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "cda9fa46f1754d91464fafddf61e493f834ba348", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 34, "deletions": 32, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "aab70ab252a7fb301980631f0b031970bede74bf", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "521dd7530beeabcbf79d1a663091a777235c966b", "filename": "src/librustc_trans/debuginfo/namespace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "788ce32937d847a8a9697ec9bd915eddc659aecc", "filename": "src/librustc_trans/debuginfo/type_names.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Ftype_names.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "3ee2497009f6513135438a7bb31ccd1bf75d683e", "filename": "src/librustc_trans/debuginfo/utils.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Futils.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "9bf023fc18936e4ca0517df93df0d92db8316408", "filename": "src/librustc_trans/declare.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdeclare.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "90bc29c39e9b50ed7fd60ed531330feccb72ab8a", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "577ffbad1348ba07673018c6958c0f04bdeeef32", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "e2da635b1592ae3ac1992f83e25fdbb95eb102a3", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "aa9b900fa465396573edae7f1f02801a0de67667", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "76f5f32b5dcff70b93c6bfface74d8d80b47803c", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "8f05cc793ef224f73b35f4eed64d3273b706874d", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "d93bbec7efa41153958ad5bd959ac8ef4fff16b3", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "9ed5a5d148cd62410cd608a546524d3c96db189b", "filename": "src/librustc_trans/symbol_names_test.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsymbol_names_test.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "214eaeb817f302b24011f9603d5899aa1bf022cc", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "22c405fe254a62c400d818d54e51de617f67c405", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "71270963f8057c4e9618031a0e3860e81e2e0a09", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 249, "deletions": 336, "changes": 585, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "624201eaab69660218509dcd676f949d34bb6f75", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 42, "deletions": 38, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "4fba29def226c6eb0a0ed0fa359962e245eac116", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 35, "deletions": 29, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "f2c8ef46a7e252db6a090ee80222797cec8d5fe1", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "1d81ed7d35956145de42a0d8d23ab3fb2bb67006", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "478de1673170f79ea03cb1836a421d3cccf88c19", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "e13c4ea314f06255634495d0d12ecaf5c28b456c", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "183a2a48ff523664a30cf9dd0d165bdefb64244c", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "ff9eaa012ba41e3c37f1ed4652134de01c00becb", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "b29eab780e0355df72e290dc5d79dfea719ac727", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "5cb0804b1bca19e1972fb953237cd821ac296b0b", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "86bfede87b333c6d6e7a7897c8d95d991fdf905c", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "58dff935a16b88388e3dce04cfca168b346058ba", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 286, "deletions": 264, "changes": 550, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "d1a9b8ef85ae48e5c990b55cec9d9825dc4c57ac", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "eb08e70d4c3e445d0a4da8ae9be41a0f98020fcc", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 38, "deletions": 37, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "63d20416bded57bddc768bd720962c6975df04b9", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "ffdb56753fdc1a028550ff20930843aca48e8334", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 27, "deletions": 38, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}, {"sha": "56de75995fd2e820bc4929c1a74eeb51ebbaa82f", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 37, "deletions": 18, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e7775ce7bfc916ce723bd1fdaf4ae54662c6627/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=7e7775ce7bfc916ce723bd1fdaf4ae54662c6627"}]}