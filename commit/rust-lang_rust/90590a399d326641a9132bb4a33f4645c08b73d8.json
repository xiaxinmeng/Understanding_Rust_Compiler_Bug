{"sha": "90590a399d326641a9132bb4a33f4645c08b73d8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwNTkwYTM5OWQzMjY2NDFhOTEzMmJiNGEzM2Y0NjQ1YzA4YjczZDg=", "commit": {"author": {"name": "Vytautas Astrauskas", "email": "vastrauskas@gmail.com", "date": "2020-05-24T18:29:56Z"}, "committer": {"name": "Vytautas Astrauskas", "email": "vastrauskas@gmail.com", "date": "2020-05-24T22:02:54Z"}, "message": "Small fixes.", "tree": {"sha": "3595ee527f2bd90a46221f3c9fcdaae2e9b0e24b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3595ee527f2bd90a46221f3c9fcdaae2e9b0e24b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90590a399d326641a9132bb4a33f4645c08b73d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90590a399d326641a9132bb4a33f4645c08b73d8", "html_url": "https://github.com/rust-lang/rust/commit/90590a399d326641a9132bb4a33f4645c08b73d8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90590a399d326641a9132bb4a33f4645c08b73d8/comments", "author": {"login": "vakaras", "id": 75347, "node_id": "MDQ6VXNlcjc1MzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/75347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vakaras", "html_url": "https://github.com/vakaras", "followers_url": "https://api.github.com/users/vakaras/followers", "following_url": "https://api.github.com/users/vakaras/following{/other_user}", "gists_url": "https://api.github.com/users/vakaras/gists{/gist_id}", "starred_url": "https://api.github.com/users/vakaras/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vakaras/subscriptions", "organizations_url": "https://api.github.com/users/vakaras/orgs", "repos_url": "https://api.github.com/users/vakaras/repos", "events_url": "https://api.github.com/users/vakaras/events{/privacy}", "received_events_url": "https://api.github.com/users/vakaras/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vakaras", "id": 75347, "node_id": "MDQ6VXNlcjc1MzQ3", "avatar_url": "https://avatars.githubusercontent.com/u/75347?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vakaras", "html_url": "https://github.com/vakaras", "followers_url": "https://api.github.com/users/vakaras/followers", "following_url": "https://api.github.com/users/vakaras/following{/other_user}", "gists_url": "https://api.github.com/users/vakaras/gists{/gist_id}", "starred_url": "https://api.github.com/users/vakaras/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vakaras/subscriptions", "organizations_url": "https://api.github.com/users/vakaras/orgs", "repos_url": "https://api.github.com/users/vakaras/repos", "events_url": "https://api.github.com/users/vakaras/events{/privacy}", "received_events_url": "https://api.github.com/users/vakaras/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ff0af3adf6aa9d1dac07d45cd40bdc8b123d229", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ff0af3adf6aa9d1dac07d45cd40bdc8b123d229", "html_url": "https://github.com/rust-lang/rust/commit/6ff0af3adf6aa9d1dac07d45cd40bdc8b123d229"}], "stats": {"total": 71, "additions": 60, "deletions": 11}, "files": [{"sha": "95092a042d34ac4c091c1b51cf1c729709f19919", "filename": "src/shims/sync.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/90590a399d326641a9132bb4a33f4645c08b73d8/src%2Fshims%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90590a399d326641a9132bb4a33f4645c08b73d8/src%2Fshims%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fsync.rs?ref=90590a399d326641a9132bb4a33f4645c08b73d8", "patch": "@@ -301,6 +301,8 @@ fn post_cond_signal<'mir, 'tcx: 'mir>(\n     mutex: MutexId,\n ) -> InterpResult<'tcx> {\n     reacquire_cond_mutex(ecx, thread, mutex)?;\n+    // Waiting for the mutex is not included in the waiting time because we need\n+    // to acquire the mutex always even if we get a timeout.\n     ecx.unregister_timeout_callback_if_exists(thread)\n }\n \n@@ -343,10 +345,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let kind = this.read_scalar(kind_op)?.not_undef()?;\n         if kind == this.eval_libc(\"PTHREAD_MUTEX_NORMAL\")? {\n             // In `glibc` implementation, the numeric values of\n-            // `PTHREAD_MUTEX_NORMAL` and `PTHREAD_MUTEX_DEFAULT` are equal, but\n-            // they have different behaviour in some cases. Therefore, we add\n-            // this flag to ensure that we can distinguish\n-            // `PTHREAD_MUTEX_NORMAL` from `PTHREAD_MUTEX_DEFAULT`.\n+            // `PTHREAD_MUTEX_NORMAL` and `PTHREAD_MUTEX_DEFAULT` are equal.\n+            // However, a mutex created by explicitly passing\n+            // `PTHREAD_MUTEX_NORMAL` type has in some cases different behaviour\n+            // from the default mutex for which the type was not explicitly\n+            // specified. For a more detailed discussion, please see\n+            // https://github.com/rust-lang/miri/issues/1419.\n+            //\n+            // To distinguish these two cases in already constructed mutexes, we\n+            // use the same trick as glibc: for the case when\n+            // `pthread_mutexattr_settype` is caled explicitly, we set the\n+            // `PTHREAD_MUTEX_NORMAL_FLAG` flag.\n             let normal_kind = kind.to_i32()? | PTHREAD_MUTEX_NORMAL_FLAG;\n             // Check that after setting the flag, the kind is distinguishable\n             // from all other kinds.\n@@ -414,7 +423,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             } else {\n                 // Trying to acquire the same mutex again.\n                 if is_mutex_kind_default(this, kind)? {\n-                    throw_ub_format!(\"trying to acquire already locked PTHREAD_MUTEX_DEFAULT\");\n+                    throw_ub_format!(\"trying to acquire already locked default mutex\");\n                 } else if is_mutex_kind_normal(this, kind)? {\n                     throw_machine_stop!(TerminationInfo::Deadlock);\n                 } else if kind == this.eval_libc(\"PTHREAD_MUTEX_ERRORCHECK\")? {\n@@ -484,7 +493,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_unlock.html.\n             if is_mutex_kind_default(this, kind)? {\n                 throw_ub_format!(\n-                    \"unlocked a PTHREAD_MUTEX_DEFAULT mutex that was not locked by the current thread\"\n+                    \"unlocked a default mutex that was not locked by the current thread\"\n                 );\n             } else if is_mutex_kind_normal(this, kind)? {\n                 throw_ub_format!("}, {"sha": "59f08eec1649b18d998dc28846640dcb4f02809b", "filename": "src/thread.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/90590a399d326641a9132bb4a33f4645c08b73d8/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90590a399d326641a9132bb4a33f4645c08b73d8/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=90590a399d326641a9132bb4a33f4645c08b73d8", "patch": "@@ -377,6 +377,9 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     }\n \n     /// Register the given `callback` to be called once the `call_time` passes.\n+    ///\n+    /// The callback will be called with `thread` being the active thread, and\n+    /// the callback may not change the active thread.\n     fn register_timeout_callback(\n         &mut self,\n         thread: ThreadId,\n@@ -452,10 +455,8 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         // https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_cond_timedwait.html#\n         let potential_sleep_time =\n             self.timeout_callbacks.values().map(|info| info.call_time.get_wait_time()).min();\n-        if let Some(sleep_time) = potential_sleep_time {\n-            if sleep_time == Duration::new(0, 0) {\n-                return Ok(SchedulingAction::ExecuteTimeoutCallback);\n-            }\n+        if potential_sleep_time == Some(Duration::new(0, 0)) {\n+            return Ok(SchedulingAction::ExecuteTimeoutCallback);\n         }\n         // No callbacks scheduled, pick a regular thread to execute.\n         if self.threads[self.active_thread].state == ThreadState::Enabled\n@@ -699,6 +700,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n         let (thread, callback) =\n             this.machine.threads.get_ready_callback().expect(\"no callback found\");\n+        // This back-and-forth with `set_active_thread` is here because of two\n+        // design decisions:\n+        // 1. Make the caller and not the callback responsible for changing\n+        //    thread.\n+        // 2. Make the scheduler the only place that can change the active\n+        //    thread.\n         let old_thread = this.set_active_thread(thread)?;\n         callback(this)?;\n         this.set_active_thread(old_thread)?;"}, {"sha": "3a737b2e3e155786f60a891da2cc6a1089383508", "filename": "tests/compile-fail/sync/libc_pthread_mutex_NULL_deadlock.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/90590a399d326641a9132bb4a33f4645c08b73d8/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_mutex_NULL_deadlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90590a399d326641a9132bb4a33f4645c08b73d8/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_mutex_NULL_deadlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_mutex_NULL_deadlock.rs?ref=90590a399d326641a9132bb4a33f4645c08b73d8", "patch": "@@ -0,0 +1,16 @@\n+// ignore-windows: No libc on Windows\n+//\n+// Check that if we pass NULL attribute, then we get the default mutex type.\n+\n+#![feature(rustc_private)]\n+\n+extern crate libc;\n+\n+fn main() {\n+    unsafe {\n+        let mut mutex: libc::pthread_mutex_t = std::mem::zeroed();\n+        assert_eq!(libc::pthread_mutex_init(&mut mutex as *mut _, std::ptr::null() as *const _), 0);\n+        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n+        libc::pthread_mutex_lock(&mut mutex as *mut _); //~ ERROR Undefined Behavior: trying to acquire already locked default mutex\n+    }\n+}"}, {"sha": "0f6f570d70b0241520c9f9d4d5fbfb290a68b3bc", "filename": "tests/compile-fail/sync/libc_pthread_mutex_default_deadlock.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/90590a399d326641a9132bb4a33f4645c08b73d8/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_mutex_default_deadlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90590a399d326641a9132bb4a33f4645c08b73d8/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_mutex_default_deadlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_mutex_default_deadlock.rs?ref=90590a399d326641a9132bb4a33f4645c08b73d8", "patch": "@@ -0,0 +1,17 @@\n+// ignore-windows: No libc on Windows\n+//\n+// Check that if we do not set the mutex type, it is the default.\n+\n+#![feature(rustc_private)]\n+\n+extern crate libc;\n+\n+fn main() {\n+    unsafe {\n+        let mutexattr: libc::pthread_mutexattr_t = std::mem::zeroed();\n+        let mut mutex: libc::pthread_mutex_t = std::mem::zeroed();\n+        assert_eq!(libc::pthread_mutex_init(&mut mutex as *mut _, &mutexattr as *const _), 0);\n+        assert_eq!(libc::pthread_mutex_lock(&mut mutex as *mut _), 0);\n+        libc::pthread_mutex_lock(&mut mutex as *mut _); //~ ERROR Undefined Behavior: trying to acquire already locked default mutex\n+    }\n+}"}, {"sha": "d69929d4ed465a7d3ca28ad7d863a9775d152588", "filename": "tests/compile-fail/sync/libc_pthread_mutex_wrong_owner.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90590a399d326641a9132bb4a33f4645c08b73d8/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_mutex_wrong_owner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90590a399d326641a9132bb4a33f4645c08b73d8/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_mutex_wrong_owner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fsync%2Flibc_pthread_mutex_wrong_owner.rs?ref=90590a399d326641a9132bb4a33f4645c08b73d8", "patch": "@@ -24,7 +24,7 @@ fn main() {\n \n         let lock_copy = lock.clone();\n         thread::spawn(move || {\n-            assert_eq!(libc::pthread_mutex_unlock(lock_copy.0.get() as *mut _), 0); //~ ERROR: Undefined Behavior: unlocked a PTHREAD_MUTEX_DEFAULT mutex that was not locked\n+            assert_eq!(libc::pthread_mutex_unlock(lock_copy.0.get() as *mut _), 0); //~ ERROR: Undefined Behavior: unlocked a default mutex that was not locked by the current thread\n         })\n         .join()\n         .unwrap();"}]}