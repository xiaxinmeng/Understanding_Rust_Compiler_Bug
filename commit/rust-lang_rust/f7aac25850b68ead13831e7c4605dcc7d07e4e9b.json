{"sha": "f7aac25850b68ead13831e7c4605dcc7d07e4e9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3YWFjMjU4NTBiNjhlYWQxMzgzMWU3YzQ2MDVkY2M3ZDA3ZTRlOWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-15T05:43:00Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-15T05:43:00Z"}, "message": "Auto merge of #75488 - ssomers:btree_revert_75257, r=Mark-Simulacrum\n\nRevert the fundamental changes in #74762 and #75257\n\nBefore possibly going over to #75487. Also contains some added and fixed comments.\n\nr? @Mark-Simulacrum", "tree": {"sha": "d4bc36a2011171aa47796b7622e623aabf44347f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4bc36a2011171aa47796b7622e623aabf44347f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7aac25850b68ead13831e7c4605dcc7d07e4e9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7aac25850b68ead13831e7c4605dcc7d07e4e9b", "html_url": "https://github.com/rust-lang/rust/commit/f7aac25850b68ead13831e7c4605dcc7d07e4e9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7aac25850b68ead13831e7c4605dcc7d07e4e9b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45060c2a66dfd667f88bd8b94261b28a58d85bd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/45060c2a66dfd667f88bd8b94261b28a58d85bd5", "html_url": "https://github.com/rust-lang/rust/commit/45060c2a66dfd667f88bd8b94261b28a58d85bd5"}, {"sha": "8668e5b29e78732cb4f4bb84e838fdace70fa3c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/8668e5b29e78732cb4f4bb84e838fdace70fa3c0", "html_url": "https://github.com/rust-lang/rust/commit/8668e5b29e78732cb4f4bb84e838fdace70fa3c0"}], "stats": {"total": 69, "additions": 20, "deletions": 49}, "files": [{"sha": "c6b55840db99369ffad7f0a28f054a13e6276a01", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 20, "deletions": 49, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/f7aac25850b68ead13831e7c4605dcc7d07e4e9b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7aac25850b68ead13831e7c4605dcc7d07e4e9b/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=f7aac25850b68ead13831e7c4605dcc7d07e4e9b", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-filelength\n-\n use core::borrow::Borrow;\n use core::cmp::Ordering;\n use core::fmt::{self, Debug};\n@@ -1288,11 +1286,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     pub(super) fn drain_filter_inner(&mut self) -> DrainFilterInner<'_, K, V> {\n         let root_node = self.root.as_mut().map(|r| r.node_as_mut());\n         let front = root_node.map(|rn| rn.first_leaf_edge());\n-        DrainFilterInner {\n-            length: &mut self.length,\n-            cur_leaf_edge: front,\n-            emptied_internal_root: false,\n-        }\n+        DrainFilterInner { length: &mut self.length, cur_leaf_edge: front }\n     }\n \n     /// Calculates the number of elements if it is incorrect.\n@@ -1708,7 +1702,6 @@ where\n pub(super) struct DrainFilterInner<'a, K: 'a, V: 'a> {\n     length: &'a mut usize,\n     cur_leaf_edge: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n-    emptied_internal_root: bool,\n }\n \n #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n@@ -1749,17 +1742,6 @@ where\n     }\n }\n \n-impl<K, V> Drop for DrainFilterInner<'_, K, V> {\n-    fn drop(&mut self) {\n-        if self.emptied_internal_root {\n-            if let Some(handle) = self.cur_leaf_edge.take() {\n-                let root = handle.into_node().into_root_mut();\n-                root.pop_internal_level();\n-            }\n-        }\n-    }\n-}\n-\n impl<'a, K: 'a, V: 'a> DrainFilterInner<'a, K, V> {\n     /// Allow Debug implementations to predict the next element.\n     pub(super) fn peek(&self) -> Option<(&K, &V)> {\n@@ -1776,7 +1758,7 @@ impl<'a, K: 'a, V: 'a> DrainFilterInner<'a, K, V> {\n             let (k, v) = kv.kv_mut();\n             if pred(k, v) {\n                 *self.length -= 1;\n-                let (kv, pos) = kv.remove_kv_tracking(|_| self.emptied_internal_root = true);\n+                let (kv, pos) = kv.remove_kv_tracking();\n                 self.cur_leaf_edge = Some(pos);\n                 return Some(kv);\n             }\n@@ -2799,39 +2781,32 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n     fn remove_kv(self) -> (K, V) {\n         *self.length -= 1;\n \n-        let (old_kv, _) =\n-            self.handle.remove_kv_tracking(|root| root.into_root_mut().pop_internal_level());\n+        let (old_kv, _) = self.handle.remove_kv_tracking();\n         old_kv\n     }\n }\n \n impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV> {\n-    /// Removes a key/value-pair from the tree, and returns that pair, as well as\n-    /// the leaf edge corresponding to that former pair. It's possible this leaves\n-    /// an empty internal root node, which the caller should subsequently pop from\n-    /// the map holding the tree. The caller should also decrement the map's length.\n-    fn remove_kv_tracking<F>(\n+    /// Removes a key/value-pair from the map, and returns that pair, as well as\n+    /// the leaf edge corresponding to that former pair.\n+    fn remove_kv_tracking(\n         self,\n-        handle_emptied_internal_root: F,\n-    ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>)\n-    where\n-        F: FnOnce(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n-    {\n+    ) -> ((K, V), Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>) {\n         let (old_kv, mut pos, was_internal) = match self.force() {\n             Leaf(leaf) => {\n                 let (old_kv, pos) = leaf.remove();\n                 (old_kv, pos, false)\n             }\n             Internal(mut internal) => {\n-                // Replace the location freed in the internal node with the next KV,\n-                // and remove that next KV from its leaf.\n+                // Replace the location freed in the internal node with an\n+                // adjacent KV, and remove that adjacent KV from its leaf.\n+                // Always choose the adjacent KV on the left side because\n+                // it is typically faster to pop an element from the end\n+                // of the KV arrays without needing to shift other elements.\n \n                 let key_loc = internal.kv_mut().0 as *mut K;\n                 let val_loc = internal.kv_mut().1 as *mut V;\n \n-                // Deleting from the left side is typically faster since we can\n-                // just pop an element from the end of the KV array without\n-                // needing to shift the other values.\n                 let to_remove = internal.left_edge().descend().last_leaf_edge().left_kv().ok();\n                 let to_remove = unsafe { unwrap_unchecked(to_remove) };\n \n@@ -2867,8 +2842,8 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInter\n                     if parent.len() == 0 {\n                         // The parent that was just emptied must be the root,\n                         // because nodes on a lower level would not have been\n-                        // left underfull. It has to be popped off the tree soon.\n-                        handle_emptied_internal_root(parent);\n+                        // left with a single child.\n+                        parent.into_root_mut().pop_internal_level();\n                         break;\n                     } else {\n                         cur_node = parent.forget_type();\n@@ -2972,19 +2947,15 @@ fn handle_underfull_node<K, V>(\n         Err(_) => return AtRoot,\n     };\n \n+    // Prefer the left KV if it exists. Merging with the left side is faster,\n+    // since merging happens towards the left and `node` has fewer elements.\n+    // Stealing from the left side is faster, since we can pop from the end of\n+    // the KV arrays.\n     let (is_left, mut handle) = match parent.left_kv() {\n         Ok(left) => (true, left),\n         Err(parent) => {\n-            match parent.right_kv() {\n-                Ok(right) => (false, right),\n-                Err(_) => {\n-                    // The underfull node has an empty parent, so it is the only child\n-                    // of an empty root. It is destined to become the new root, thus\n-                    // allowed to be underfull. The empty parent should be removed later\n-                    // by `pop_internal_level`.\n-                    return AtRoot;\n-                }\n-            }\n+            let right = unsafe { unwrap_unchecked(parent.right_kv().ok()) };\n+            (false, right)\n         }\n     };\n "}]}