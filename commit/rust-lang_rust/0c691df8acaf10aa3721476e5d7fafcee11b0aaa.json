{"sha": "0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBjNjkxZGY4YWNhZjEwYWEzNzIxNDc2ZTVkN2ZhZmNlZTExYjBhYWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-03T17:56:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-03T17:56:57Z"}, "message": "auto merge of #13773 : brson/rust/boxxy, r=alexcrichton\n\n`box` is the way you allocate in future-rust.", "tree": {"sha": "7aca9144c64039fea0aff444e13870b4be40fae7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7aca9144c64039fea0aff444e13870b4be40fae7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "html_url": "https://github.com/rust-lang/rust/commit/0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bca9647cd34c78a1c7c2409fbb2c31cb2c8194d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/bca9647cd34c78a1c7c2409fbb2c31cb2c8194d7", "html_url": "https://github.com/rust-lang/rust/commit/bca9647cd34c78a1c7c2409fbb2c31cb2c8194d7"}, {"sha": "a5be12ce7e88c1d28de1c98215991127d1e765f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5be12ce7e88c1d28de1c98215991127d1e765f0", "html_url": "https://github.com/rust-lang/rust/commit/a5be12ce7e88c1d28de1c98215991127d1e765f0"}], "stats": {"total": 1255, "additions": 631, "deletions": 624}, "files": [{"sha": "580e5f89cd4e0691aa3fa309300f0e2630705c38", "filename": "src/etc/emacs/rust-mode.el", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Fetc%2Femacs%2Frust-mode.el", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Fetc%2Femacs%2Frust-mode.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frust-mode.el?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -169,7 +169,7 @@\n ;; Font-locking definitions and helpers\n (defconst rust-mode-keywords\n   '(\"as\"\n-    \"break\"\n+    \"box\" \"break\"\n     \"continue\" \"crate\"\n     \"do\"\n     \"else\" \"enum\" \"extern\""}, {"sha": "95062d84e09859227a48254e89a495c994c27d5d", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -517,7 +517,7 @@ mod tests {\n     #[bench]\n     pub fn bench_copy_nonarena(b: &mut Bencher) {\n         b.iter(|| {\n-            ~Point {\n+            box Point {\n                 x: 1,\n                 y: 2,\n                 z: 3,\n@@ -569,7 +569,7 @@ mod tests {\n     #[bench]\n     pub fn bench_noncopy_nonarena(b: &mut Bencher) {\n         b.iter(|| {\n-            ~Noncopy {\n+            box Noncopy {\n                 string: \"hello world\".to_owned(),\n                 array: vec!( 1, 2, 3, 4, 5 ),\n             }"}, {"sha": "30add695646400e0704a46ce8e62169506edacf9", "filename": "src/libcollections/btree.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibcollections%2Fbtree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibcollections%2Fbtree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -377,8 +377,8 @@ impl<K: Clone + TotalOrd, V: Clone> Leaf<K, V> {\n                                                               == Less);\n             let branch_return = Node::new_branch(vec!(BranchElt::new(midpoint.key.clone(),\n                                                                   midpoint.value.clone(),\n-                                                             ~Node::new_leaf(left_leaf))),\n-                                            ~Node::new_leaf(right_leaf));\n+                                                             box Node::new_leaf(left_leaf))),\n+                                            box Node::new_leaf(right_leaf));\n             return (branch_return, true);\n         }\n         (Node::new_leaf(self.elts.clone()), true)\n@@ -540,10 +540,10 @@ impl<K: Clone + TotalOrd, V: Clone> Branch<K, V> {\n                     //so we can return false.\n                     LeafNode(..) => {\n                         if index.unwrap() == self.elts.len() {\n-                            self.rightmost_child = ~new_branch.clone();\n+                            self.rightmost_child = box new_branch.clone();\n                         }\n                         else {\n-                            self.elts.get_mut(index.unwrap()).left = ~new_branch.clone();\n+                            self.elts.get_mut(index.unwrap()).left = box new_branch.clone();\n                         }\n                         return (Node::new_branch(self.clone().elts,\n                                                  self.clone().rightmost_child),\n@@ -561,10 +561,10 @@ impl<K: Clone + TotalOrd, V: Clone> Branch<K, V> {\n                 //and return it, saying we have inserted a new element.\n                 LeafNode(..) => {\n                     if index.unwrap() == self.elts.len() {\n-                        self.rightmost_child = ~new_branch;\n+                        self.rightmost_child = box new_branch;\n                     }\n                     else {\n-                        self.elts.get_mut(index.unwrap()).left = ~new_branch;\n+                        self.elts.get_mut(index.unwrap()).left = box new_branch;\n                     }\n                     return (Node::new_branch(self.clone().elts,\n                                              self.clone().rightmost_child),\n@@ -604,9 +604,9 @@ impl<K: Clone + TotalOrd, V: Clone> Branch<K, V> {\n                 new_branch = Node::new_branch(\n                     vec!(BranchElt::new(midpoint.clone().key,\n                                      midpoint.clone().value,\n-                                     ~Node::new_branch(new_left,\n+                                     box Node::new_branch(new_left,\n                                                        midpoint.clone().left))),\n-                    ~Node::new_branch(new_right, self.clone().rightmost_child));\n+                    box Node::new_branch(new_right, self.clone().rightmost_child));\n                 return (new_branch, true);\n             }\n         }"}, {"sha": "0f82942d7e7882913b93010104ac5fdaa53d9ac7", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -238,7 +238,7 @@ impl<T> Deque<T> for DList<T> {\n     ///\n     /// O(1)\n     fn push_front(&mut self, elt: T) {\n-        self.push_front_node(~Node::new(elt))\n+        self.push_front_node(box Node::new(elt))\n     }\n \n     /// Remove the first element and return it, or None if the list is empty\n@@ -252,7 +252,7 @@ impl<T> Deque<T> for DList<T> {\n     ///\n     /// O(1)\n     fn push_back(&mut self, elt: T) {\n-        self.push_back_node(~Node::new(elt))\n+        self.push_back_node(box Node::new(elt))\n     }\n \n     /// Remove the last element and return it, or None if the list is empty\n@@ -555,7 +555,7 @@ impl<'a, A> MutItems<'a, A> {\n impl<'a, A> ListInsertion<A> for MutItems<'a, A> {\n     #[inline]\n     fn insert_next(&mut self, elt: A) {\n-        self.insert_next_node(~Node::new(elt))\n+        self.insert_next_node(box Node::new(elt))\n     }\n \n     #[inline]\n@@ -675,19 +675,19 @@ mod tests {\n         assert_eq!(m.pop_front(), None);\n         assert_eq!(m.pop_back(), None);\n         assert_eq!(m.pop_front(), None);\n-        m.push_front(~1);\n+        m.push_front(box 1);\n         assert_eq!(m.pop_front(), Some(~1));\n-        m.push_back(~2);\n-        m.push_back(~3);\n+        m.push_back(box 2);\n+        m.push_back(box 3);\n         assert_eq!(m.len(), 2);\n         assert_eq!(m.pop_front(), Some(~2));\n         assert_eq!(m.pop_front(), Some(~3));\n         assert_eq!(m.len(), 0);\n         assert_eq!(m.pop_front(), None);\n-        m.push_back(~1);\n-        m.push_back(~3);\n-        m.push_back(~5);\n-        m.push_back(~7);\n+        m.push_back(box 1);\n+        m.push_back(box 3);\n+        m.push_back(box 5);\n+        m.push_back(box 7);\n         assert_eq!(m.pop_front(), Some(~1));\n \n         let mut n = DList::new();"}, {"sha": "22876bf39752c9fee4527286580bdffbb4ad9625", "filename": "src/libcollections/lru_cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibcollections%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibcollections%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flru_cache.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -93,7 +93,7 @@ impl<K: Hash + TotalEq, V> LruCache<K, V> {\n         let cache = LruCache {\n             map: HashMap::new(),\n             max_size: capacity,\n-            head: unsafe{ cast::transmute(~mem::uninit::<LruEntry<K, V>>()) },\n+            head: unsafe{ cast::transmute(box mem::uninit::<LruEntry<K, V>>()) },\n         };\n         unsafe {\n             (*cache.head).next = cache.head;\n@@ -111,7 +111,7 @@ impl<K: Hash + TotalEq, V> LruCache<K, V> {\n                 (node_ptr, None)\n             }\n             None => {\n-                let mut node = ~LruEntry::new(k, v);\n+                let mut node = box LruEntry::new(k, v);\n                 let node_ptr: *mut LruEntry<K, V> = &mut *node;\n                 (node_ptr, Some(node))\n             }"}, {"sha": "e37e2a6f234b745daa797d69224cbc39a68c41e9", "filename": "src/libcollections/priority_queue.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibcollections%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibcollections%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fpriority_queue.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -273,19 +273,19 @@ mod tests {\n         let mut heap = PriorityQueue::from_vec(vec!(~2, ~4, ~9));\n         assert_eq!(heap.len(), 3);\n         assert!(*heap.top() == ~9);\n-        heap.push(~11);\n+        heap.push(box 11);\n         assert_eq!(heap.len(), 4);\n         assert!(*heap.top() == ~11);\n-        heap.push(~5);\n+        heap.push(box 5);\n         assert_eq!(heap.len(), 5);\n         assert!(*heap.top() == ~11);\n-        heap.push(~27);\n+        heap.push(box 27);\n         assert_eq!(heap.len(), 6);\n         assert!(*heap.top() == ~27);\n-        heap.push(~3);\n+        heap.push(box 3);\n         assert_eq!(heap.len(), 7);\n         assert!(*heap.top() == ~27);\n-        heap.push(~103);\n+        heap.push(box 103);\n         assert_eq!(heap.len(), 8);\n         assert!(*heap.top() == ~103);\n     }"}, {"sha": "e236e58b08d388e7c62d39b4edc681c24640205e", "filename": "src/libcollections/smallintmap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibcollections%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibcollections%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fsmallintmap.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -459,7 +459,7 @@ mod test_map {\n     #[test]\n     fn test_move_iter() {\n         let mut m = SmallIntMap::new();\n-        m.insert(1, ~2);\n+        m.insert(1, box 2);\n         let mut called = false;\n         for (k, v) in m.move_iter() {\n             assert!(!called);\n@@ -468,7 +468,7 @@ mod test_map {\n             assert_eq!(v, ~2);\n         }\n         assert!(called);\n-        m.insert(2, ~1);\n+        m.insert(2, box 1);\n     }\n }\n "}, {"sha": "3f993fc64a4af56ab2b24eec166156a25ce31b76", "filename": "src/libcollections/treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibcollections%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibcollections%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftreemap.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -834,7 +834,7 @@ fn insert<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n         }\n       }\n       None => {\n-       *node = Some(~TreeNode::new(key, value));\n+       *node = Some(box TreeNode::new(key, value));\n         None\n       }\n     }"}, {"sha": "1bff058d6f5b8bed6e542b156d0c58c86abcd558", "filename": "src/libcollections/trie.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibcollections%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibcollections%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Ftrie.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -448,7 +448,7 @@ fn insert<T>(count: &mut uint, child: &mut Child<T>, key: uint, value: T,\n     // have to move out of `child`.\n     match mem::replace(child, Nothing) {\n         External(stored_key, stored_value) => {\n-            let mut new = ~TrieNode::new();\n+            let mut new = box TrieNode::new();\n             insert(&mut new.count,\n                    &mut new.children[chunk(stored_key, idx)],\n                    stored_key, stored_value, idx + 1);"}, {"sha": "4da0214c27cf4c23fd5df89e24ba0406fb9afadd", "filename": "src/libgreen/basic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibgreen%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibgreen%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fbasic.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -23,7 +23,7 @@ use std::unstable::sync::Exclusive;\n \n /// This is the only exported function from this module.\n pub fn event_loop() -> ~EventLoop:Send {\n-    ~BasicLoop::new() as ~EventLoop:Send\n+    box BasicLoop::new() as ~EventLoop:Send\n }\n \n struct BasicLoop {\n@@ -143,7 +143,7 @@ impl EventLoop for BasicLoop {\n     fn pausable_idle_callback(&mut self, cb: ~Callback:Send)\n         -> ~PausableIdleCallback:Send\n     {\n-        let callback = ~BasicPausable::new(self, cb);\n+        let callback = box BasicPausable::new(self, cb);\n         rtassert!(self.idle.is_none());\n         unsafe {\n             let cb_ptr: &*mut BasicPausable = cast::transmute(&callback);\n@@ -156,7 +156,7 @@ impl EventLoop for BasicLoop {\n         let id = self.next_remote;\n         self.next_remote += 1;\n         self.remotes.push((id, f));\n-        ~BasicRemote::new(self.messages.clone(), id) as ~RemoteCallback:Send\n+        box BasicRemote::new(self.messages.clone(), id) as ~RemoteCallback:Send\n     }\n \n     fn io<'a>(&'a mut self) -> Option<&'a mut IoFactory> { None }"}, {"sha": "c30a93c23230f82162d824507173dc8f163f66c5", "filename": "src/libgreen/context.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibgreen%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibgreen%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fcontext.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -152,7 +152,7 @@ struct Registers {\n \n #[cfg(target_arch = \"x86\")]\n fn new_regs() -> ~Registers {\n-    ~Registers {\n+    box Registers {\n         eax: 0, ebx: 0, ecx: 0, edx: 0,\n         ebp: 0, esi: 0, edi: 0, esp: 0,\n         cs: 0, ds: 0, ss: 0, es: 0, fs: 0, gs: 0,\n@@ -190,9 +190,9 @@ type Registers = [uint, ..34];\n type Registers = [uint, ..22];\n \n #[cfg(windows, target_arch = \"x86_64\")]\n-fn new_regs() -> ~Registers { ~([0, .. 34]) }\n+fn new_regs() -> ~Registers { box [0, .. 34] }\n #[cfg(not(windows), target_arch = \"x86_64\")]\n-fn new_regs() -> ~Registers { ~([0, .. 22]) }\n+fn new_regs() -> ~Registers { box {let v = [0, .. 22]; v} }\n \n #[cfg(target_arch = \"x86_64\")]\n fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,\n@@ -241,7 +241,7 @@ fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,\n type Registers = [uint, ..32];\n \n #[cfg(target_arch = \"arm\")]\n-fn new_regs() -> ~Registers { ~([0, .. 32]) }\n+fn new_regs() -> ~Registers { box {[0, .. 32]} }\n \n #[cfg(target_arch = \"arm\")]\n fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,\n@@ -270,7 +270,7 @@ fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,\n type Registers = [uint, ..32];\n \n #[cfg(target_arch = \"mips\")]\n-fn new_regs() -> ~Registers { ~([0, .. 32]) }\n+fn new_regs() -> ~Registers { box [0, .. 32] }\n \n #[cfg(target_arch = \"mips\")]\n fn initialize_call_frame(regs: &mut Registers, fptr: InitFn, arg: uint,"}, {"sha": "f86743d10c7063cbeea1bcb60a2d54f4e500d79d", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -427,7 +427,7 @@ impl SchedPool {\n         for worker in workers.move_iter() {\n             rtdebug!(\"inserting a regular scheduler\");\n \n-            let mut sched = ~Scheduler::new(pool.id,\n+            let mut sched = box Scheduler::new(pool.id,\n                                             (pool.factory)(),\n                                             worker,\n                                             pool.stealers.clone(),\n@@ -488,7 +488,7 @@ impl SchedPool {\n         // Create the new scheduler, using the same sleeper list as all the\n         // other schedulers as well as having a stealer handle to all other\n         // schedulers.\n-        let mut sched = ~Scheduler::new(self.id,\n+        let mut sched = box Scheduler::new(self.id,\n                                         (self.factory)(),\n                                         worker,\n                                         self.stealers.clone(),"}, {"sha": "c323dbb92d742d29138c1012a0e30db4a74f12bb", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -183,7 +183,7 @@ impl Scheduler {\n     pub fn bootstrap(mut ~self) {\n \n         // Build an Idle callback.\n-        let cb = ~SchedRunner as ~Callback:Send;\n+        let cb = box SchedRunner as ~Callback:Send;\n         self.idle_callback = Some(self.event_loop.pausable_idle_callback(cb));\n \n         // Create a task for the scheduler with an empty context.\n@@ -869,7 +869,7 @@ impl Scheduler {\n     }\n \n     pub fn make_handle(&mut self) -> SchedHandle {\n-        let remote = self.event_loop.remote_callback(~SchedRunner);\n+        let remote = self.event_loop.remote_callback(box SchedRunner);\n \n         return SchedHandle {\n             remote: remote,\n@@ -1140,7 +1140,7 @@ mod test {\n             let (_p, state) = TaskState::new();\n \n             // Our normal scheduler\n-            let mut normal_sched = ~Scheduler::new(\n+            let mut normal_sched = box Scheduler::new(\n                 1,\n                 basic::event_loop(),\n                 normal_worker,\n@@ -1152,7 +1152,7 @@ mod test {\n             let friend_handle = normal_sched.make_handle();\n \n             // Our special scheduler\n-            let mut special_sched = ~Scheduler::new_special(\n+            let mut special_sched = box Scheduler::new_special(\n                 1,\n                 basic::event_loop(),\n                 special_worker,\n@@ -1403,7 +1403,7 @@ mod test {\n \n             impl Drop for S {\n                 fn drop(&mut self) {\n-                    let _foo = ~0;\n+                    let _foo = box 0;\n                 }\n             }\n "}, {"sha": "37b0aa4f611a7c95637e98e2d2653e5aece959a3", "filename": "src/libgreen/simple.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibgreen%2Fsimple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibgreen%2Fsimple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsimple.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -82,8 +82,8 @@ impl Runtime for SimpleTask {\n }\n \n pub fn task() -> ~Task {\n-    let mut task = ~Task::new();\n-    task.put_runtime(~SimpleTask {\n+    let mut task = box Task::new();\n+    task.put_runtime(box SimpleTask {\n         lock: unsafe {NativeMutex::new()},\n         awoken: false,\n     });"}, {"sha": "846fcdb1881d5db21aab58bb5e61d91e62beff14", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -159,14 +159,14 @@ impl GreenTask {\n     /// useful when creating scheduler tasks.\n     pub fn new_typed(coroutine: Option<Coroutine>,\n                      task_type: TaskType) -> ~GreenTask {\n-        ~GreenTask {\n+        box GreenTask {\n             pool_id: 0,\n             coroutine: coroutine,\n             task_type: task_type,\n             sched: None,\n             handle: None,\n             nasty_deschedule_lock: unsafe { NativeMutex::new() },\n-            task: Some(~Task::new()),\n+            task: Some(box Task::new()),\n         }\n     }\n "}, {"sha": "1571370d0331478e246b7b5b8cede939f16d49ba", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -203,7 +203,7 @@ pub fn log(level: u32, args: &fmt::Arguments) {\n     // frob the slot while we're doing the logging. This will destroy any logger\n     // set during logging.\n     let mut logger = local_data::pop(local_logger).unwrap_or_else(|| {\n-        ~DefaultLogger { handle: io::stderr() } as ~Logger:Send\n+        box DefaultLogger { handle: io::stderr() } as ~Logger:Send\n     });\n     logger.log(level, args);\n     local_data::set(local_logger, logger);\n@@ -286,7 +286,7 @@ fn init() {\n         LOG_LEVEL = max_level;\n \n         assert!(DIRECTIVES.is_null());\n-        DIRECTIVES = cast::transmute(~directives);\n+        DIRECTIVES = cast::transmute(box directives);\n \n         // Schedule the cleanup for this global for when the runtime exits.\n         rt::at_exit(proc() {"}, {"sha": "7c19eb54326245a7369d1aae8ff230576a04afa2", "filename": "src/libnative/io/file_unix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibnative%2Fio%2Ffile_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibnative%2Fio%2Ffile_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_unix.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -176,7 +176,7 @@ impl rtio::RtioPipe for FileDesc {\n         self.inner_write(buf)\n     }\n     fn clone(&self) -> ~rtio::RtioPipe:Send {\n-        ~FileDesc { inner: self.inner.clone() } as ~rtio::RtioPipe:Send\n+        box FileDesc { inner: self.inner.clone() } as ~rtio::RtioPipe:Send\n     }\n }\n "}, {"sha": "6a6fb31d3e3f728b763554b7da191cc642607f78", "filename": "src/libnative/io/file_win32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibnative%2Fio%2Ffile_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibnative%2Fio%2Ffile_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_win32.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -207,7 +207,7 @@ impl rtio::RtioPipe for FileDesc {\n         self.inner_write(buf)\n     }\n     fn clone(&self) -> ~rtio::RtioPipe:Send {\n-        ~FileDesc { inner: self.inner.clone() } as ~rtio::RtioPipe:Send\n+        box FileDesc { inner: self.inner.clone() } as ~rtio::RtioPipe:Send\n     }\n }\n "}, {"sha": "fb92d0d55cf396574a9a2b01af8c5ff04bd72b37", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -167,20 +167,20 @@ impl rtio::IoFactory for IoFactory {\n     // networking\n     fn tcp_connect(&mut self, addr: SocketAddr,\n                    timeout: Option<u64>) -> IoResult<~RtioTcpStream:Send> {\n-        net::TcpStream::connect(addr, timeout).map(|s| ~s as ~RtioTcpStream:Send)\n+        net::TcpStream::connect(addr, timeout).map(|s| box s as ~RtioTcpStream:Send)\n     }\n     fn tcp_bind(&mut self, addr: SocketAddr) -> IoResult<~RtioTcpListener:Send> {\n-        net::TcpListener::bind(addr).map(|s| ~s as ~RtioTcpListener:Send)\n+        net::TcpListener::bind(addr).map(|s| box s as ~RtioTcpListener:Send)\n     }\n     fn udp_bind(&mut self, addr: SocketAddr) -> IoResult<~RtioUdpSocket:Send> {\n-        net::UdpSocket::bind(addr).map(|u| ~u as ~RtioUdpSocket:Send)\n+        net::UdpSocket::bind(addr).map(|u| box u as ~RtioUdpSocket:Send)\n     }\n     fn unix_bind(&mut self, path: &CString) -> IoResult<~RtioUnixListener:Send> {\n-        pipe::UnixListener::bind(path).map(|s| ~s as ~RtioUnixListener:Send)\n+        pipe::UnixListener::bind(path).map(|s| box s as ~RtioUnixListener:Send)\n     }\n     fn unix_connect(&mut self, path: &CString,\n                     timeout: Option<u64>) -> IoResult<~RtioPipe:Send> {\n-        pipe::UnixStream::connect(path, timeout).map(|s| ~s as ~RtioPipe:Send)\n+        pipe::UnixStream::connect(path, timeout).map(|s| box s as ~RtioPipe:Send)\n     }\n     fn get_host_addresses(&mut self, host: Option<&str>, servname: Option<&str>,\n                           hint: Option<ai::Hint>) -> IoResult<~[ai::Info]> {\n@@ -194,11 +194,11 @@ impl rtio::IoFactory for IoFactory {\n             rtio::CloseSynchronously | rtio::CloseAsynchronously => true,\n             rtio::DontClose => false\n         };\n-        ~file::FileDesc::new(fd, close) as ~RtioFileStream:Send\n+        box file::FileDesc::new(fd, close) as ~RtioFileStream:Send\n     }\n     fn fs_open(&mut self, path: &CString, fm: io::FileMode, fa: io::FileAccess)\n         -> IoResult<~RtioFileStream:Send> {\n-        file::open(path, fm, fa).map(|fd| ~fd as ~RtioFileStream:Send)\n+        file::open(path, fm, fa).map(|fd| box fd as ~RtioFileStream:Send)\n     }\n     fn fs_unlink(&mut self, path: &CString) -> IoResult<()> {\n         file::unlink(path)\n@@ -245,26 +245,26 @@ impl rtio::IoFactory for IoFactory {\n \n     // misc\n     fn timer_init(&mut self) -> IoResult<~RtioTimer:Send> {\n-        timer::Timer::new().map(|t| ~t as ~RtioTimer:Send)\n+        timer::Timer::new().map(|t| box t as ~RtioTimer:Send)\n     }\n     fn spawn(&mut self, config: ProcessConfig)\n             -> IoResult<(~RtioProcess:Send, ~[Option<~RtioPipe:Send>])> {\n         process::Process::spawn(config).map(|(p, io)| {\n-            (~p as ~RtioProcess:Send,\n-             io.move_iter().map(|p| p.map(|p| ~p as ~RtioPipe:Send)).collect())\n+            (box p as ~RtioProcess:Send,\n+             io.move_iter().map(|p| p.map(|p| box p as ~RtioPipe:Send)).collect())\n         })\n     }\n     fn kill(&mut self, pid: libc::pid_t, signum: int) -> IoResult<()> {\n         process::Process::kill(pid, signum)\n     }\n     fn pipe_open(&mut self, fd: c_int) -> IoResult<~RtioPipe:Send> {\n-        Ok(~file::FileDesc::new(fd, true) as ~RtioPipe:Send)\n+        Ok(box file::FileDesc::new(fd, true) as ~RtioPipe:Send)\n     }\n     fn tty_open(&mut self, fd: c_int, _readable: bool)\n         -> IoResult<~RtioTTY:Send>\n     {\n         if unsafe { libc::isatty(fd) } != 0 {\n-            Ok(~file::FileDesc::new(fd, true) as ~RtioTTY:Send)\n+            Ok(box file::FileDesc::new(fd, true) as ~RtioTTY:Send)\n         } else {\n             Err(IoError {\n                 kind: io::MismatchedFileTypeForOperation,"}, {"sha": "c47e549b20acc86be49e3d97b7095fc6a3932e0b", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -352,7 +352,7 @@ impl rtio::RtioTcpStream for TcpStream {\n     }\n \n     fn clone(&self) -> ~rtio::RtioTcpStream:Send {\n-        ~TcpStream { inner: self.inner.clone() } as ~rtio::RtioTcpStream:Send\n+        box TcpStream { inner: self.inner.clone() } as ~rtio::RtioTcpStream:Send\n     }\n     fn close_write(&mut self) -> IoResult<()> {\n         super::mkerr_libc(unsafe {\n@@ -419,7 +419,7 @@ impl TcpListener {\n \n impl rtio::RtioTcpListener for TcpListener {\n     fn listen(~self) -> IoResult<~rtio::RtioTcpAcceptor:Send> {\n-        self.native_listen(128).map(|a| ~a as ~rtio::RtioTcpAcceptor:Send)\n+        self.native_listen(128).map(|a| box a as ~rtio::RtioTcpAcceptor:Send)\n     }\n }\n \n@@ -466,7 +466,7 @@ impl rtio::RtioSocket for TcpAcceptor {\n \n impl rtio::RtioTcpAcceptor for TcpAcceptor {\n     fn accept(&mut self) -> IoResult<~rtio::RtioTcpStream:Send> {\n-        self.native_accept().map(|s| ~s as ~rtio::RtioTcpStream:Send)\n+        self.native_accept().map(|s| box s as ~rtio::RtioTcpStream:Send)\n     }\n \n     fn accept_simultaneously(&mut self) -> IoResult<()> { Ok(()) }\n@@ -638,6 +638,6 @@ impl rtio::RtioUdpSocket for UdpSocket {\n     }\n \n     fn clone(&self) -> ~rtio::RtioUdpSocket:Send {\n-        ~UdpSocket { inner: self.inner.clone() } as ~rtio::RtioUdpSocket:Send\n+        box UdpSocket { inner: self.inner.clone() } as ~rtio::RtioUdpSocket:Send\n     }\n }"}, {"sha": "178247f3190f814dbdd0302d62f9d1ee81fe454f", "filename": "src/libnative/io/pipe_unix.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibnative%2Fio%2Fpipe_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibnative%2Fio%2Fpipe_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_unix.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -145,7 +145,7 @@ impl rtio::RtioPipe for UnixStream {\n     }\n \n     fn clone(&self) -> ~rtio::RtioPipe:Send {\n-        ~UnixStream { inner: self.inner.clone() } as ~rtio::RtioPipe:Send\n+        box UnixStream { inner: self.inner.clone() } as ~rtio::RtioPipe:Send\n     }\n }\n \n@@ -177,7 +177,7 @@ impl UnixListener {\n \n impl rtio::RtioUnixListener for UnixListener {\n     fn listen(~self) -> IoResult<~rtio::RtioUnixAcceptor:Send> {\n-        self.native_listen(128).map(|a| ~a as ~rtio::RtioUnixAcceptor:Send)\n+        self.native_listen(128).map(|a| box a as ~rtio::RtioUnixAcceptor:Send)\n     }\n }\n \n@@ -210,7 +210,7 @@ impl UnixAcceptor {\n \n impl rtio::RtioUnixAcceptor for UnixAcceptor {\n     fn accept(&mut self) -> IoResult<~rtio::RtioPipe:Send> {\n-        self.native_accept().map(|s| ~s as ~rtio::RtioPipe:Send)\n+        self.native_accept().map(|s| box s as ~rtio::RtioPipe:Send)\n     }\n     fn set_timeout(&mut self, timeout: Option<u64>) {\n         self.deadline = timeout.map(|a| ::io::timer::now() + a).unwrap_or(0);"}, {"sha": "bf7f82ef6622c22952ee5654aee476c83c31a2fa", "filename": "src/libnative/io/pipe_win32.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibnative%2Fio%2Fpipe_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibnative%2Fio%2Fpipe_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fpipe_win32.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -354,7 +354,7 @@ impl rtio::RtioPipe for UnixStream {\n     }\n \n     fn clone(&self) -> ~rtio::RtioPipe:Send {\n-        ~UnixStream {\n+        box UnixStream {\n             inner: self.inner.clone(),\n             read: None,\n             write: None,\n@@ -403,7 +403,7 @@ impl Drop for UnixListener {\n \n impl rtio::RtioUnixListener for UnixListener {\n     fn listen(~self) -> IoResult<~rtio::RtioUnixAcceptor:Send> {\n-        self.native_listen().map(|a| ~a as ~rtio::RtioUnixAcceptor:Send)\n+        self.native_listen().map(|a| box a as ~rtio::RtioUnixAcceptor:Send)\n     }\n }\n \n@@ -527,7 +527,7 @@ impl UnixAcceptor {\n \n impl rtio::RtioUnixAcceptor for UnixAcceptor {\n     fn accept(&mut self) -> IoResult<~rtio::RtioPipe:Send> {\n-        self.native_accept().map(|s| ~s as ~rtio::RtioPipe:Send)\n+        self.native_accept().map(|s| box s as ~rtio::RtioPipe:Send)\n     }\n     fn set_timeout(&mut self, timeout: Option<u64>) {\n         self.deadline = timeout.map(|i| i + ::io::timer::now()).unwrap_or(0);"}, {"sha": "298dd2f368df6297025376afcc6d1190a223c472", "filename": "src/libnative/io/timer_helper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibnative%2Fio%2Ftimer_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibnative%2Fio%2Ftimer_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_helper.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -48,7 +48,7 @@ pub fn boot(helper: fn(imp::signal, Receiver<Req>)) {\n             let (tx, rx) = channel();\n             // promote this to a shared channel\n             drop(tx.clone());\n-            HELPER_CHAN = cast::transmute(~tx);\n+            HELPER_CHAN = cast::transmute(box tx);\n             let (receive, send) = imp::new();\n             HELPER_SIGNAL = send;\n "}, {"sha": "8435c05c7716a8890246657937c1355f308b9929", "filename": "src/libnative/io/timer_unix.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibnative%2Fio%2Ftimer_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibnative%2Fio%2Ftimer_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_unix.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -207,7 +207,7 @@ impl Timer {\n         let id = unsafe { ID.fetch_add(1, atomics::Relaxed) };\n         Ok(Timer {\n             id: id,\n-            inner: Some(~Inner {\n+            inner: Some(box Inner {\n                 tx: None,\n                 interval: 0,\n                 target: 0,"}, {"sha": "512080e420480fe44f096c5ba0bfa1b1d085e959", "filename": "src/libnative/task.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -32,15 +32,15 @@ use task;\n \n /// Creates a new Task which is ready to execute as a 1:1 task.\n pub fn new(stack_bounds: (uint, uint)) -> ~Task {\n-    let mut task = ~Task::new();\n+    let mut task = box Task::new();\n     let mut ops = ops();\n     ops.stack_bounds = stack_bounds;\n     task.put_runtime(ops);\n     return task;\n }\n \n fn ops() -> ~Ops {\n-    ~Ops {\n+    box Ops {\n         lock: unsafe { NativeMutex::new() },\n         awoken: false,\n         io: io::IoFactory::new(),\n@@ -62,7 +62,7 @@ pub fn spawn_opts(opts: TaskOpts, f: proc():Send) {\n         stderr, stdout,\n     } = opts;\n \n-    let mut task = ~Task::new();\n+    let mut task = box Task::new();\n     task.name = name;\n     task.stderr = stderr;\n     task.stdout = stdout;"}, {"sha": "3393abc8b2615db74a27db70f3a904a517ef7a6e", "filename": "src/librand/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -602,7 +602,7 @@ pub fn task_rng() -> TaskRng {\n                 Ok(r) => r,\n                 Err(e) => fail!(\"could not initialize task_rng: {}\", e)\n             };\n-            let mut rng = ~reseeding::ReseedingRng::new(r,\n+            let mut rng = box reseeding::ReseedingRng::new(r,\n                                                         TASK_RNG_RESEED_THRESHOLD,\n                                                         TaskRngReseeder);\n             let ptr = &mut *rng as *mut TaskRngInner;"}, {"sha": "b4551fcc312df821ad51d9f5e9e056ad566b1eae", "filename": "src/librand/rand_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrand%2Frand_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrand%2Frand_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Frand_impls.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -216,7 +216,7 @@ impl<T:Rand> Rand for Option<T> {\n \n impl<T: Rand> Rand for ~T {\n     #[inline]\n-    fn rand<R: Rng>(rng: &mut R) -> ~T { ~rng.gen() }\n+    fn rand<R: Rng>(rng: &mut R) -> ~T { box rng.gen() }\n }\n \n impl<T: Rand + 'static> Rand for @T {"}, {"sha": "d098c2cf0c1440547e3e8fc2f4e0dc066ffab12f", "filename": "src/librand/reader.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freader.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -78,7 +78,7 @@ mod test {\n     #[test]\n     fn test_reader_rng_u64() {\n         // transmute from the target to avoid endianness concerns.\n-        let v = ~[1u64, 2u64, 3u64];\n+        let v = box [1u64, 2u64, 3u64];\n         let bytes: ~[u8] = unsafe {cast::transmute(v)};\n         let mut rng = ReaderRng::new(MemReader::new(bytes.move_iter().collect()));\n \n@@ -89,7 +89,7 @@ mod test {\n     #[test]\n     fn test_reader_rng_u32() {\n         // transmute from the target to avoid endianness concerns.\n-        let v = ~[1u32, 2u32, 3u32];\n+        let v = box [1u32, 2u32, 3u32];\n         let bytes: ~[u8] = unsafe {cast::transmute(v)};\n         let mut rng = ReaderRng::new(MemReader::new(bytes.move_iter().collect()));\n "}, {"sha": "a754c934a25d0507faabd87bc1a79bafdc970474", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -673,11 +673,11 @@ pub fn pretty_print_input(sess: Session,\n     let mut rdr = MemReader::new(src);\n \n     let out = match ofile {\n-        None => ~io::stdout() as ~Writer,\n+        None => box io::stdout() as ~Writer,\n         Some(p) => {\n             let r = io::File::create(&p);\n             match r {\n-                Ok(w) => ~w as ~Writer,\n+                Ok(w) => box w as ~Writer,\n                 Err(e) => fail!(\"print-print failed to open {} due to {}\",\n                                 p.display(), e),\n             }"}, {"sha": "a94715bdaa5055411886d46e3c576a8077e17a9a", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -387,7 +387,7 @@ pub fn monitor(f: proc():Send) {\n     let mut r = io::ChanReader::new(rx);\n \n     match task_builder.try(proc() {\n-        io::stdio::set_stderr(~w);\n+        io::stdio::set_stderr(box w);\n         f()\n     }) {\n         Ok(()) => { /* fallthrough */ }\n@@ -425,7 +425,7 @@ pub fn monitor(f: proc():Send) {\n             // Fail so the process returns a failure code, but don't pollute the\n             // output with some unnecessary failure messages, we've already\n             // printed everything that we needed to.\n-            io::stdio::set_stderr(~io::util::NullWriter);\n+            io::stdio::set_stderr(box io::util::NullWriter);\n             fail!();\n         }\n     }"}, {"sha": "edbc787fe5cec8d2fda8553041c902a20edd6d4f", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -316,7 +316,7 @@ impl<'a, O:DataFlowOperator+Clone+'static> DataFlowContext<'a, O> {\n \n         debug!(\"Dataflow result:\");\n         debug!(\"{}\", {\n-            self.pretty_print_to(~io::stderr(), blk).unwrap();\n+            self.pretty_print_to(box io::stderr(), blk).unwrap();\n             \"\"\n         });\n     }"}, {"sha": "0638fd5c4827ed85840428e540e0c97c878b6dd2", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -60,7 +60,7 @@ impl<'a> MarkSymbolVisitor<'a> {\n         MarkSymbolVisitor {\n             worklist: worklist,\n             tcx: tcx,\n-            live_symbols: ~HashSet::new(),\n+            live_symbols: box HashSet::new(),\n         }\n     }\n "}, {"sha": "a2dadc420669e3c9728fd4bde6323143248c5439", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -1922,7 +1922,7 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n         if ty::type_is_empty(tcx, t) {\n             // Special case for empty types\n             let fail_cx = Cell::new(None);\n-            let fail_handler = ~DynamicFailureHandler {\n+            let fail_handler = box DynamicFailureHandler {\n                 bcx: scope_cx,\n                 sp: discr_expr.span,\n                 msg: InternedString::new(\"scrutinizing value that can't \\"}, {"sha": "97c9dcce5ef64c10e787556ad046f579da6bc3a0", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -236,7 +236,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n          */\n \n         if !ty::type_needs_drop(self.ccx.tcx(), ty) { return; }\n-        let drop = ~DropValue {\n+        let drop = box DropValue {\n             is_immediate: false,\n             on_unwind: ty::type_needs_unwind_cleanup(self.ccx.tcx(), ty),\n             val: val,\n@@ -260,7 +260,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n          */\n \n         if !ty::type_needs_drop(self.ccx.tcx(), ty) { return; }\n-        let drop = ~DropValue {\n+        let drop = box DropValue {\n             is_immediate: true,\n             on_unwind: ty::type_needs_unwind_cleanup(self.ccx.tcx(), ty),\n             val: val,\n@@ -284,7 +284,7 @@ impl<'a> CleanupMethods<'a> for FunctionContext<'a> {\n          * operation.\n          */\n \n-        let drop = ~FreeValue { ptr: val, heap: heap };\n+        let drop = box FreeValue { ptr: val, heap: heap };\n \n         debug!(\"schedule_free_value({:?}, val={}, heap={:?})\",\n                cleanup_scope,"}, {"sha": "e8654da3457ee55809a34e890bd582131b36d79f", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -757,7 +757,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n     });\n \n     // Initialize fn debug context (including scope map and namespace map)\n-    let fn_debug_context = ~FunctionDebugContextData {\n+    let fn_debug_context = box FunctionDebugContextData {\n         scope_map: RefCell::new(HashMap::new()),\n         fn_metadata: fn_metadata,\n         argument_counter: Cell::new(1),"}, {"sha": "c114097fefa26fccc03b560570d1f82973edbb95", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -1231,7 +1231,7 @@ pub fn mk_t(cx: &ctxt, st: sty) -> t {\n       }\n     }\n \n-    let t = ~t_box_ {\n+    let t = box t_box_ {\n         sty: st,\n         id: cx.next_id.get(),\n         flags: flags,\n@@ -1400,7 +1400,7 @@ pub fn mk_slice(cx: &ctxt, r: Region, tm: mt) -> t {\n pub fn mk_tup(cx: &ctxt, ts: Vec<t>) -> t { mk_t(cx, ty_tup(ts)) }\n \n pub fn mk_closure(cx: &ctxt, fty: ClosureTy) -> t {\n-    mk_t(cx, ty_closure(~fty))\n+    mk_t(cx, ty_closure(box fty))\n }\n \n pub fn mk_bare_fn(cx: &ctxt, fty: BareFnTy) -> t {\n@@ -1433,7 +1433,7 @@ pub fn mk_trait(cx: &ctxt,\n                 bounds: BuiltinBounds)\n              -> t {\n     // take a copy of substs so that we own the vectors inside\n-    let inner = ~TyTrait {\n+    let inner = box TyTrait {\n         def_id: did,\n         substs: substs,\n         store: store,"}, {"sha": "f8f9ca30712d5b38705c138189554a924c76c666", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -150,7 +150,7 @@ pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n             ty::ty_enum(tid, this.fold_substs(substs))\n         }\n         ty::ty_trait(~ty::TyTrait { def_id, ref substs, store, bounds }) => {\n-            ty::ty_trait(~ty::TyTrait{\n+            ty::ty_trait(box ty::TyTrait{\n                 def_id: def_id,\n                 substs: this.fold_substs(substs),\n                 store: this.fold_trait_store(store),\n@@ -164,7 +164,7 @@ pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n             ty::ty_bare_fn(this.fold_bare_fn_ty(f))\n         }\n         ty::ty_closure(ref f) => {\n-            ty::ty_closure(~this.fold_closure_ty(*f))\n+            ty::ty_closure(box this.fold_closure_ty(*f))\n         }\n         ty::ty_rptr(r, ref tm) => {\n             ty::ty_rptr(this.fold_region(r),"}, {"sha": "16faccbc9c2e43a671ff27a7711790bd76784adf", "filename": "src/librustc/util/sha2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustc%2Futil%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustc%2Futil%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsha2.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -593,7 +593,7 @@ mod tests {\n \n         let tests = wikipedia_tests;\n \n-        let mut sh = ~Sha256::new();\n+        let mut sh = box Sha256::new();\n \n         test_hash(sh, tests.as_slice());\n     }"}, {"sha": "73812df252de534c8ec5f4092cdd891a2b72faab", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -724,24 +724,24 @@ impl Clean<Type> for ast::Ty {\n         debug!(\"span corresponds to `{}`\", codemap.span_to_str(self.span));\n         match self.node {\n             TyNil => Unit,\n-            TyPtr(ref m) => RawPointer(m.mutbl.clean(), ~m.ty.clean()),\n+            TyPtr(ref m) => RawPointer(m.mutbl.clean(), box m.ty.clean()),\n             TyRptr(ref l, ref m) =>\n                 BorrowedRef {lifetime: l.clean(), mutability: m.mutbl.clean(),\n-                             type_: ~m.ty.clean()},\n-            TyBox(ty) => Managed(~ty.clean()),\n-            TyUniq(ty) => Unique(~ty.clean()),\n-            TyVec(ty) => Vector(~ty.clean()),\n-            TyFixedLengthVec(ty, ref e) => FixedVector(~ty.clean(),\n+                             type_: box m.ty.clean()},\n+            TyBox(ty) => Managed(box ty.clean()),\n+            TyUniq(ty) => Unique(box ty.clean()),\n+            TyVec(ty) => Vector(box ty.clean()),\n+            TyFixedLengthVec(ty, ref e) => FixedVector(box ty.clean(),\n                                                        e.span.to_src()),\n             TyTup(ref tys) => Tuple(tys.iter().map(|x| x.clean()).collect()),\n             TyPath(ref p, ref tpbs, id) => {\n                 resolve_type(p.clean(),\n                              tpbs.clean().map(|x| x.move_iter().collect()),\n                              id)\n             }\n-            TyClosure(ref c, region) => Closure(~c.clean(), region.clean()),\n-            TyProc(ref c) => Proc(~c.clean()),\n-            TyBareFn(ref barefn) => BareFunction(~barefn.clean()),\n+            TyClosure(ref c, region) => Closure(box c.clean(), region.clean()),\n+            TyProc(ref c) => Proc(box c.clean()),\n+            TyBareFn(ref barefn) => BareFunction(box barefn.clean()),\n             TyBot => Bottom,\n             ref x => fail!(\"Unimplemented type {:?}\", x),\n         }"}, {"sha": "24b3e1128ea5fd328f35ee5e6189e39961d8fe52", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -379,9 +379,9 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n     //   \"crate\": { parsed crate ... },\n     //   \"plugins\": { output of plugins ... }\n     // }\n-    let mut json = ~collections::TreeMap::new();\n+    let mut json = box collections::TreeMap::new();\n     json.insert(\"schema\".to_owned(), json::String(SCHEMA_VERSION.to_owned()));\n-    let plugins_json = ~res.move_iter().filter_map(|opt| opt).collect();\n+    let plugins_json = box res.move_iter().filter_map(|opt| opt).collect();\n \n     // FIXME #8335: yuck, Rust -> str -> JSON round trip! No way to .encode\n     // straight to the Rust JSON representation."}, {"sha": "01cbd15be222a50d3bf38fd1f9134e3370edc82c", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -123,17 +123,17 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n     let (tx, rx) = channel();\n     let w1 = io::ChanWriter::new(tx);\n     let w2 = w1.clone();\n-    let old = io::stdio::set_stderr(~w1);\n+    let old = io::stdio::set_stderr(box w1);\n     spawn(proc() {\n         let mut p = io::ChanReader::new(rx);\n-        let mut err = old.unwrap_or(~io::stderr() as ~Writer:Send);\n+        let mut err = old.unwrap_or(box io::stderr() as ~Writer:Send);\n         io::util::copy(&mut p, &mut err).unwrap();\n     });\n-    let emitter = diagnostic::EmitterWriter::new(~w2);\n+    let emitter = diagnostic::EmitterWriter::new(box w2);\n \n     // Compile the code\n     let codemap = CodeMap::new();\n-    let diagnostic_handler = diagnostic::mk_handler(~emitter);\n+    let diagnostic_handler = diagnostic::mk_handler(box emitter);\n     let span_diagnostic_handler =\n         diagnostic::mk_span_handler(diagnostic_handler, codemap);\n "}, {"sha": "7b19be09bde5008ece35ed55674579e89f204f67", "filename": "src/librustuv/async.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fasync.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -37,7 +37,7 @@ impl AsyncWatcher {\n             uvll::uv_async_init(loop_.handle, handle, async_cb)\n         }, 0);\n         let flag = Exclusive::new(false);\n-        let payload = ~Payload { callback: cb, exit_flag: flag.clone() };\n+        let payload = box Payload { callback: cb, exit_flag: flag.clone() };\n         unsafe {\n             let payload: *u8 = cast::transmute(payload);\n             uvll::set_data_for_uv_handle(handle, payload);\n@@ -146,7 +146,7 @@ mod test_remote {\n         }\n \n         let (tx, rx) = channel();\n-        let cb = ~MyCallback(Some(tx));\n+        let cb = box MyCallback(Some(tx));\n         let watcher = AsyncWatcher::new(&mut local_loop().loop_, cb);\n \n         let thread = Thread::start(proc() {"}, {"sha": "9fb525bc260b171db433a30af65067ac81c42265", "filename": "src/librustuv/idle.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fidle.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -28,7 +28,7 @@ impl IdleWatcher {\n         assert_eq!(unsafe {\n             uvll::uv_idle_init(loop_.handle, handle)\n         }, 0);\n-        let me = ~IdleWatcher {\n+        let me = box IdleWatcher {\n             handle: handle,\n             idle_flag: false,\n             closed: false,\n@@ -41,7 +41,7 @@ impl IdleWatcher {\n         let handle = UvHandle::alloc(None::<IdleWatcher>, uvll::UV_IDLE);\n         unsafe {\n             assert_eq!(uvll::uv_idle_init(loop_.handle, handle), 0);\n-            let data: *c_void = cast::transmute(~f);\n+            let data: *c_void = cast::transmute(box f);\n             uvll::set_data_for_uv_handle(handle, data);\n             assert_eq!(uvll::uv_idle_start(handle, onetime_cb), 0)\n         }\n@@ -128,7 +128,7 @@ mod test {\n \n     fn mk(v: uint) -> (~IdleWatcher, Chan) {\n         let rc = Rc::new(RefCell::new((None, 0)));\n-        let cb = ~MyCallback(rc.clone(), v);\n+        let cb = box MyCallback(rc.clone(), v);\n         let cb = cb as ~Callback:;\n         let cb = unsafe { cast::transmute(cb) };\n         (IdleWatcher::new(&mut local_loop().loop_, cb), rc)\n@@ -173,7 +173,7 @@ mod test {\n         // never reschedule us, so we're guaranteed to stay on the same\n         // task/event loop.\n         use std::io;\n-        drop(io::stdio::set_stderr(~io::util::NullWriter));\n+        drop(io::stdio::set_stderr(box io::util::NullWriter));\n \n         let (mut idle, _chan) = mk(1);\n         idle.resume();"}, {"sha": "f7631f8e41dfa73ac6ad9a5ec1e45eaf92a5de19", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -125,7 +125,7 @@ pub mod stream;\n /// }\n /// ```\n pub fn event_loop() -> ~rtio::EventLoop:Send {\n-    ~uvio::UvEventLoop::new() as ~rtio::EventLoop:Send\n+    box uvio::UvEventLoop::new() as ~rtio::EventLoop:Send\n }\n \n /// A type that wraps a uv handle"}, {"sha": "e12276e8f5bb0742c652bcf7325b5fe18005f137", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -456,7 +456,7 @@ impl rtio::RtioTcpStream for TcpWatcher {\n     }\n \n     fn clone(&self) -> ~rtio::RtioTcpStream:Send {\n-        ~TcpWatcher {\n+        box TcpWatcher {\n             handle: self.handle,\n             stream: StreamWatcher::new(self.handle),\n             home: self.home.clone(),\n@@ -522,7 +522,7 @@ impl TcpListener {\n             uvll::uv_tcp_init(io.uv_loop(), handle)\n         }, 0);\n         let (tx, rx) = channel();\n-        let l = ~TcpListener {\n+        let l = box TcpListener {\n             home: io.make_handle(),\n             handle: handle,\n             closing_task: None,\n@@ -559,7 +559,7 @@ impl rtio::RtioSocket for TcpListener {\n impl rtio::RtioTcpListener for TcpListener {\n     fn listen(~self) -> Result<~rtio::RtioTcpAcceptor:Send, IoError> {\n         // create the acceptor object from ourselves\n-        let mut acceptor = ~TcpAcceptor {\n+        let mut acceptor = box TcpAcceptor {\n             listener: self,\n             timeout: AcceptTimeout::new(),\n         };\n@@ -583,7 +583,7 @@ extern fn listen_cb(server: *uvll::uv_stream_t, status: c_int) {\n             });\n             let client = TcpWatcher::new_home(&loop_, tcp.home().clone());\n             assert_eq!(unsafe { uvll::uv_accept(server, client.handle) }, 0);\n-            Ok(~client as ~rtio::RtioTcpStream:Send)\n+            Ok(box client as ~rtio::RtioTcpStream:Send)\n         }\n         n => Err(uv_error_to_io_error(UvError(n)))\n     };\n@@ -880,7 +880,7 @@ impl rtio::RtioUdpSocket for UdpWatcher {\n     }\n \n     fn clone(&self) -> ~rtio::RtioUdpSocket:Send {\n-        ~UdpWatcher {\n+        box UdpWatcher {\n             handle: self.handle,\n             home: self.home.clone(),\n             refcount: self.refcount.clone(),"}, {"sha": "99551e8f35ba1a990cef0ab02aa71f3cc7b80d0a", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -122,7 +122,7 @@ impl RtioPipe for PipeWatcher {\n     }\n \n     fn clone(&self) -> ~RtioPipe:Send {\n-        ~PipeWatcher {\n+        box PipeWatcher {\n             stream: StreamWatcher::new(self.stream.handle),\n             defused: false,\n             home: self.home.clone(),\n@@ -165,7 +165,7 @@ impl PipeListener {\n                 // we close the pipe differently. We can't rely on\n                 // StreamWatcher's default close method.\n                 let (tx, rx) = channel();\n-                let p = ~PipeListener {\n+                let p = box PipeListener {\n                     home: io.make_handle(),\n                     pipe: pipe.unwrap(),\n                     incoming: rx,\n@@ -181,7 +181,7 @@ impl PipeListener {\n impl RtioUnixListener for PipeListener {\n     fn listen(~self) -> Result<~RtioUnixAcceptor:Send, IoError> {\n         // create the acceptor object from ourselves\n-        let mut acceptor = ~PipeAcceptor {\n+        let mut acceptor = box PipeAcceptor {\n             listener: self,\n             timeout: net::AcceptTimeout::new(),\n         };\n@@ -214,7 +214,7 @@ extern fn listen_cb(server: *uvll::uv_stream_t, status: libc::c_int) {\n             });\n             let client = PipeWatcher::new_home(&loop_, pipe.home().clone(), false);\n             assert_eq!(unsafe { uvll::uv_accept(server, client.handle()) }, 0);\n-            Ok(~client as ~RtioPipe:Send)\n+            Ok(box client as ~RtioPipe:Send)\n         }\n         n => Err(uv_error_to_io_error(UvError(n)))\n     };"}, {"sha": "d6d1f754b232965467d1524d1cc2aefdcc00577c", "filename": "src/librustuv/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustuv%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustuv%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fprocess.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -87,7 +87,7 @@ impl Process {\n                 };\n \n                 let handle = UvHandle::alloc(None::<Process>, uvll::UV_PROCESS);\n-                let process = ~Process {\n+                let process = box Process {\n                     handle: handle,\n                     home: io_loop.make_handle(),\n                     to_wake: None,"}, {"sha": "58761045b97feff37dcfe94d6a7d9565d7185370", "filename": "src/librustuv/queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustuv%2Fqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustuv%2Fqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fqueue.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -114,7 +114,7 @@ impl QueuePool {\n             lock: unsafe {NativeMutex::new()},\n             queue: mpsc::Queue::new(),\n         });\n-        let q = ~QueuePool {\n+        let q = box QueuePool {\n             refcnt: 0,\n             queue: state,\n         };"}, {"sha": "3f56d3ad6863bd5652ca992b76da73a4d1d7ec21", "filename": "src/librustuv/signal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustuv%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustuv%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fsignal.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -28,7 +28,7 @@ pub struct SignalWatcher {\n impl SignalWatcher {\n     pub fn new(io: &mut UvIoFactory, signum: Signum,\n                channel: Sender<Signum>) -> Result<~SignalWatcher, UvError> {\n-        let s = ~SignalWatcher {\n+        let s = box SignalWatcher {\n             handle: UvHandle::alloc(None::<SignalWatcher>, uvll::UV_SIGNAL),\n             home: io.make_handle(),\n             channel: channel,"}, {"sha": "66c1a9039100a25c317f1cd04016cae1469349d2", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -34,7 +34,7 @@ pub enum NextAction {\n impl TimerWatcher {\n     pub fn new(io: &mut UvIoFactory) -> ~TimerWatcher {\n         let handle = io.make_handle();\n-        let me = ~TimerWatcher::new_home(&io.loop_, handle);\n+        let me = box TimerWatcher::new_home(&io.loop_, handle);\n         me.install()\n     }\n "}, {"sha": "80c09cc24d60c27db010d892d7b7dd626a56143b", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -103,7 +103,7 @@ impl EventLoop for UvEventLoop {\n     fn remote_callback(&mut self, f: ~rtio::Callback:Send)\n         -> ~rtio::RemoteCallback:Send\n     {\n-        ~AsyncWatcher::new(&mut self.uvio.loop_, f) as ~rtio::RemoteCallback:Send\n+        box AsyncWatcher::new(&mut self.uvio.loop_, f) as ~rtio::RemoteCallback:Send\n     }\n \n     fn io<'a>(&'a mut self) -> Option<&'a mut rtio::IoFactory> {\n@@ -154,7 +154,7 @@ impl IoFactory for UvIoFactory {\n         -> Result<~rtio::RtioTcpStream:Send, IoError>\n     {\n         match TcpWatcher::connect(self, addr, timeout) {\n-            Ok(t) => Ok(~t as ~rtio::RtioTcpStream:Send),\n+            Ok(t) => Ok(box t as ~rtio::RtioTcpStream:Send),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n@@ -168,7 +168,7 @@ impl IoFactory for UvIoFactory {\n \n     fn udp_bind(&mut self, addr: SocketAddr) -> Result<~rtio::RtioUdpSocket:Send, IoError> {\n         match UdpWatcher::bind(self, addr) {\n-            Ok(u) => Ok(~u as ~rtio::RtioUdpSocket:Send),\n+            Ok(u) => Ok(box u as ~rtio::RtioUdpSocket:Send),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n@@ -185,7 +185,7 @@ impl IoFactory for UvIoFactory {\n \n     fn fs_from_raw_fd(&mut self, fd: c_int,\n                       close: rtio::CloseBehavior) -> ~rtio::RtioFileStream:Send {\n-        ~FileWatcher::new(self, fd, close) as ~rtio::RtioFileStream:Send\n+        box FileWatcher::new(self, fd, close) as ~rtio::RtioFileStream:Send\n     }\n \n     fn fs_open(&mut self, path: &CString, fm: FileMode, fa: FileAccess)\n@@ -205,7 +205,7 @@ impl IoFactory for UvIoFactory {\n         };\n \n         match FsRequest::open(self, path, flags as int, mode as int) {\n-            Ok(fs) => Ok(~fs as ~rtio::RtioFileStream:Send),\n+            Ok(fs) => Ok(box fs as ~rtio::RtioFileStream:Send),\n             Err(e) => Err(uv_error_to_io_error(e))\n         }\n     }\n@@ -275,7 +275,7 @@ impl IoFactory for UvIoFactory {\n         match Process::spawn(self, config) {\n             Ok((p, io)) => {\n                 Ok((p as ~rtio::RtioProcess:Send,\n-                    io.move_iter().map(|i| i.map(|p| ~p as ~rtio::RtioPipe:Send)).collect()))\n+                    io.move_iter().map(|i| i.map(|p| box p as ~rtio::RtioPipe:Send)).collect()))\n             }\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n@@ -296,22 +296,22 @@ impl IoFactory for UvIoFactory {\n     fn unix_connect(&mut self, path: &CString,\n                     timeout: Option<u64>) -> Result<~rtio::RtioPipe:Send, IoError> {\n         match PipeWatcher::connect(self, path, timeout) {\n-            Ok(p) => Ok(~p as ~rtio::RtioPipe:Send),\n+            Ok(p) => Ok(box p as ~rtio::RtioPipe:Send),\n             Err(e) => Err(uv_error_to_io_error(e)),\n         }\n     }\n \n     fn tty_open(&mut self, fd: c_int, readable: bool)\n             -> Result<~rtio::RtioTTY:Send, IoError> {\n         match TtyWatcher::new(self, fd, readable) {\n-            Ok(tty) => Ok(~tty as ~rtio::RtioTTY:Send),\n+            Ok(tty) => Ok(box tty as ~rtio::RtioTTY:Send),\n             Err(e) => Err(uv_error_to_io_error(e))\n         }\n     }\n \n     fn pipe_open(&mut self, fd: c_int) -> Result<~rtio::RtioPipe:Send, IoError> {\n         match PipeWatcher::open(self, fd) {\n-            Ok(s) => Ok(~s as ~rtio::RtioPipe:Send),\n+            Ok(s) => Ok(box s as ~rtio::RtioPipe:Send),\n             Err(e) => Err(uv_error_to_io_error(e))\n         }\n     }"}, {"sha": "5c86566b2af78a56ce374d9cac393f9ea8b0bfe9", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 63, "deletions": 63, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -1772,7 +1772,7 @@ impl<T: Iterator<char>> Builder<T> {\n     fn build_object(&mut self) -> Result<Json, BuilderError> {\n         self.bump();\n \n-        let mut values = ~TreeMap::new();\n+        let mut values = box TreeMap::new();\n \n         while self.token != None {\n             match self.token {\n@@ -2213,7 +2213,7 @@ impl<A:ToJson,B:ToJson> ToJson for (A, B) {\n     fn to_json(&self) -> Json {\n         match *self {\n           (ref a, ref b) => {\n-            List(~[a.to_json(), b.to_json()])\n+            List(box [a.to_json(), b.to_json()])\n           }\n         }\n     }\n@@ -2223,7 +2223,7 @@ impl<A:ToJson,B:ToJson,C:ToJson> ToJson for (A, B, C) {\n     fn to_json(&self) -> Json {\n         match *self {\n           (ref a, ref b, ref c) => {\n-            List(~[a.to_json(), b.to_json(), c.to_json()])\n+            List(box [a.to_json(), b.to_json(), c.to_json()])\n           }\n         }\n     }\n@@ -2243,7 +2243,7 @@ impl<A:ToJson> ToJson for TreeMap<~str, A> {\n         for (key, value) in self.iter() {\n             d.insert((*key).clone(), value.to_json());\n         }\n-        Object(~d)\n+        Object(box d)\n     }\n }\n \n@@ -2253,7 +2253,7 @@ impl<A:ToJson> ToJson for HashMap<~str, A> {\n         for (key, value) in self.iter() {\n             d.insert((*key).clone(), value.to_json());\n         }\n-        Object(~d)\n+        Object(box d)\n     }\n }\n \n@@ -2309,7 +2309,7 @@ mod tests {\n     }\n \n     fn mk_object(items: &[(~str, Json)]) -> Json {\n-        let mut d = ~TreeMap::new();\n+        let mut d = box TreeMap::new();\n \n         for item in items.iter() {\n             match *item {\n@@ -2374,10 +2374,10 @@ mod tests {\n             ]\".to_owned()\n         );\n \n-        let long_test_list = List(~[\n+        let long_test_list = List(box [\n             Boolean(false),\n             Null,\n-            List(~[String(\"foo\\nbar\".to_owned()), Number(3.5)])]);\n+            List(box [String(\"foo\\nbar\".to_owned()), Number(3.5)])]);\n \n         assert_eq!(long_test_list.to_str(),\n             \"[false,null,[\\\"foo\\\\nbar\\\",3.5]]\".to_owned());\n@@ -2413,7 +2413,7 @@ mod tests {\n         );\n \n         let complex_obj = mk_object([\n-                (\"b\".to_owned(), List(~[\n+                (\"b\".to_owned(), List(box [\n                     mk_object([(\"c\".to_owned(), String(\"\\x0c\\r\".to_owned()))]),\n                     mk_object([(\"d\".to_owned(), String(\"\".to_owned()))])\n                 ]))\n@@ -2445,7 +2445,7 @@ mod tests {\n \n         let a = mk_object([\n             (\"a\".to_owned(), Boolean(true)),\n-            (\"b\".to_owned(), List(~[\n+            (\"b\".to_owned(), List(box [\n                 mk_object([(\"c\".to_owned(), String(\"\\x0c\\r\".to_owned()))]),\n                 mk_object([(\"d\".to_owned(), String(\"\".to_owned()))])\n             ]))\n@@ -3115,34 +3115,34 @@ mod tests {\n \n         assert_stream_equal(\n             \"{}\",\n-            ~[(ObjectStart, ~[]), (ObjectEnd, ~[])]\n+            box [(ObjectStart, box []), (ObjectEnd, box [])]\n         );\n         assert_stream_equal(\n             \"{\\\"a\\\": 3}\",\n-            ~[\n-                (ObjectStart,        ~[]),\n-                  (NumberValue(3.0), ~[Key(\"a\")]),\n-                (ObjectEnd,          ~[]),\n+            box [\n+                (ObjectStart,        box []),\n+                  (NumberValue(3.0), box [Key(\"a\")]),\n+                (ObjectEnd,          box []),\n             ]\n         );\n         assert_stream_equal(\n             \"{ \\\"a\\\": null, \\\"b\\\" : true }\",\n-            ~[\n-                (ObjectStart,           ~[]),\n-                  (NullValue,           ~[Key(\"a\")]),\n-                  (BooleanValue(true),  ~[Key(\"b\")]),\n-                (ObjectEnd,             ~[]),\n+            box [\n+                (ObjectStart,           box []),\n+                  (NullValue,           box [Key(\"a\")]),\n+                  (BooleanValue(true),  box [Key(\"b\")]),\n+                (ObjectEnd,             box []),\n             ]\n         );\n         assert_stream_equal(\n             \"{\\\"a\\\" : 1.0 ,\\\"b\\\": [ true ]}\",\n-            ~[\n-                (ObjectStart,           ~[]),\n-                  (NumberValue(1.0),    ~[Key(\"a\")]),\n-                  (ListStart,           ~[Key(\"b\")]),\n-                    (BooleanValue(true),~[Key(\"b\"), Index(0)]),\n-                  (ListEnd,             ~[Key(\"b\")]),\n-                (ObjectEnd,             ~[]),\n+            box [\n+                (ObjectStart,           box []),\n+                  (NumberValue(1.0),    box [Key(\"a\")]),\n+                  (ListStart,           box [Key(\"b\")]),\n+                    (BooleanValue(true),box [Key(\"b\"), Index(0)]),\n+                  (ListEnd,             box [Key(\"b\")]),\n+                (ObjectEnd,             box []),\n             ]\n         );\n         assert_stream_equal(\n@@ -3174,70 +3174,70 @@ mod tests {\n     fn test_read_list_streaming() {\n         assert_stream_equal(\n             \"[]\",\n-            ~[\n-                (ListStart, ~[]),\n-                (ListEnd,   ~[]),\n+            box [\n+                (ListStart, box []),\n+                (ListEnd,   box []),\n             ]\n         );\n         assert_stream_equal(\n             \"[ ]\",\n-            ~[\n-                (ListStart, ~[]),\n-                (ListEnd,   ~[]),\n+            box [\n+                (ListStart, box []),\n+                (ListEnd,   box []),\n             ]\n         );\n         assert_stream_equal(\n             \"[true]\",\n-            ~[\n-                (ListStart,              ~[]),\n-                    (BooleanValue(true), ~[Index(0)]),\n-                (ListEnd,                ~[]),\n+            box [\n+                (ListStart,              box []),\n+                    (BooleanValue(true), box [Index(0)]),\n+                (ListEnd,                box []),\n             ]\n         );\n         assert_stream_equal(\n             \"[ false ]\",\n-            ~[\n-                (ListStart,               ~[]),\n-                    (BooleanValue(false), ~[Index(0)]),\n-                (ListEnd,                 ~[]),\n+            box [\n+                (ListStart,               box []),\n+                    (BooleanValue(false), box [Index(0)]),\n+                (ListEnd,                 box []),\n             ]\n         );\n         assert_stream_equal(\n             \"[null]\",\n-            ~[\n-                (ListStart,     ~[]),\n-                    (NullValue, ~[Index(0)]),\n-                (ListEnd,       ~[]),\n+            box [\n+                (ListStart,     box []),\n+                    (NullValue, box [Index(0)]),\n+                (ListEnd,       box []),\n             ]\n         );\n         assert_stream_equal(\n             \"[3, 1]\",\n-            ~[\n-                (ListStart,     ~[]),\n-                    (NumberValue(3.0), ~[Index(0)]),\n-                    (NumberValue(1.0), ~[Index(1)]),\n-                (ListEnd,       ~[]),\n+            box [\n+                (ListStart,     box []),\n+                    (NumberValue(3.0), box [Index(0)]),\n+                    (NumberValue(1.0), box [Index(1)]),\n+                (ListEnd,       box []),\n             ]\n         );\n         assert_stream_equal(\n             \"\\n[3, 2]\\n\",\n-            ~[\n-                (ListStart,     ~[]),\n-                    (NumberValue(3.0), ~[Index(0)]),\n-                    (NumberValue(2.0), ~[Index(1)]),\n-                (ListEnd,       ~[]),\n+            box [\n+                (ListStart,     box []),\n+                    (NumberValue(3.0), box [Index(0)]),\n+                    (NumberValue(2.0), box [Index(1)]),\n+                (ListEnd,       box []),\n             ]\n         );\n         assert_stream_equal(\n             \"[2, [4, 1]]\",\n-            ~[\n-                (ListStart,                 ~[]),\n-                    (NumberValue(2.0),      ~[Index(0)]),\n-                    (ListStart,             ~[Index(1)]),\n-                        (NumberValue(4.0),  ~[Index(1), Index(0)]),\n-                        (NumberValue(1.0),  ~[Index(1), Index(1)]),\n-                    (ListEnd,               ~[Index(1)]),\n-                (ListEnd,                   ~[]),\n+            box [\n+                (ListStart,                 box []),\n+                    (NumberValue(2.0),      box [Index(0)]),\n+                    (ListStart,             box [Index(1)]),\n+                        (NumberValue(4.0),  box [Index(1), Index(0)]),\n+                        (NumberValue(1.0),  box [Index(1), Index(1)]),\n+                    (ListEnd,               box [Index(1)]),\n+                (ListEnd,                   box []),\n             ]\n         );\n "}, {"sha": "65f1016515fbe556e2e657e15cc04e52e6a3ddd0", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -399,7 +399,7 @@ impl<E, S:Encoder<E>,T:Encodable<S, E>> Encodable<S, E> for ~T {\n \n impl<E, D:Decoder<E>,T:Decodable<D, E>> Decodable<D, E> for ~T {\n     fn decode(d: &mut D) -> Result<~T, E> {\n-        Ok(~try!(Decodable::decode(d)))\n+        Ok(box try!(Decodable::decode(d)))\n     }\n }\n "}, {"sha": "e448b7b8e24220654849cef68862fa80bfbe340e", "filename": "src/libstd/any.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fany.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -190,7 +190,7 @@ mod tests {\n \n     #[test]\n     fn any_owning() {\n-        let (a, b, c) = (~5u as ~Any, ~TEST as ~Any, ~Test as ~Any);\n+        let (a, b, c) = (box 5u as ~Any, box TEST as ~Any, box Test as ~Any);\n \n         assert!(a.is::<uint>());\n         assert!(!b.is::<uint>());\n@@ -223,7 +223,7 @@ mod tests {\n     #[test]\n     fn any_as_mut() {\n         let mut a = 5u;\n-        let mut b = ~7u;\n+        let mut b = box 7u;\n \n         let a_r = &mut a as &mut Any;\n         let tmp: &mut uint = b;\n@@ -268,29 +268,29 @@ mod tests {\n \n     #[test]\n     fn any_move() {\n-        let a = ~8u as ~Any;\n-        let b = ~Test as ~Any;\n+        let a = box 8u as ~Any;\n+        let b = box Test as ~Any;\n \n         match a.move::<uint>() {\n-            Ok(a) => { assert_eq!(a, ~8u); }\n+            Ok(a) => { assert_eq!(a, box 8u); }\n             Err(..) => fail!()\n         }\n         match b.move::<Test>() {\n-            Ok(a) => { assert_eq!(a, ~Test); }\n+            Ok(a) => { assert_eq!(a, box Test); }\n             Err(..) => fail!()\n         }\n \n-        let a = ~8u as ~Any;\n-        let b = ~Test as ~Any;\n+        let a = box 8u as ~Any;\n+        let b = box Test as ~Any;\n \n         assert!(a.move::<~Test>().is_err());\n         assert!(b.move::<~uint>().is_err());\n     }\n \n     #[test]\n     fn test_show() {\n-        let a = ~8u as ~Any;\n-        let b = ~Test as ~Any;\n+        let a = box 8u as ~Any;\n+        let b = box Test as ~Any;\n         assert_eq!(format!(\"{}\", a), \"~Any\".to_owned());\n         assert_eq!(format!(\"{}\", b), \"~Any\".to_owned());\n "}, {"sha": "5b4400593b483af65a7b4864f0a700d5dcecef90", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -492,7 +492,7 @@ mod tests {\n     macro_rules! v2ascii (\n         ( [$($e:expr),*]) => (&[$(Ascii{chr:$e}),*]);\n         (&[$($e:expr),*]) => (&[$(Ascii{chr:$e}),*]);\n-        (~[$($e:expr),*]) => (~[$(Ascii{chr:$e}),*]);\n+        (~[$($e:expr),*]) => (box [$(Ascii{chr:$e}),*]);\n     )\n \n     macro_rules! vec2ascii (\n@@ -536,7 +536,7 @@ mod tests {\n         assert_eq!(\"( ;\".to_ascii(),                 v2ascii!([40, 32, 59]));\n         // FIXME: #5475 borrowchk error, owned vectors do not live long enough\n         // if chained-from directly\n-        let v = ~[40u8, 32u8, 59u8]; assert_eq!(v.to_ascii(), v2ascii!([40, 32, 59]));\n+        let v = box [40u8, 32u8, 59u8]; assert_eq!(v.to_ascii(), v2ascii!([40, 32, 59]));\n         let v = \"( ;\".to_owned();              assert_eq!(v.to_ascii(), v2ascii!([40, 32, 59]));\n \n         assert_eq!(\"abCDef&?#\".to_ascii().to_lower().into_str(), \"abcdef&?#\".to_owned());\n@@ -569,7 +569,7 @@ mod tests {\n     #[test]\n     fn test_owned_ascii_vec() {\n         assert_eq!((\"( ;\".to_owned()).into_ascii(), v2ascii!(~[40, 32, 59]));\n-        assert_eq!((~[40u8, 32u8, 59u8]).into_ascii(), v2ascii!(~[40, 32, 59]));\n+        assert_eq!((box [40u8, 32u8, 59u8]).into_ascii(), v2ascii!(~[40, 32, 59]));\n     }\n \n     #[test]\n@@ -586,7 +586,7 @@ mod tests {\n \n     #[test]\n     fn test_ascii_to_bytes() {\n-        assert_eq!(v2ascii!(~[40, 32, 59]).into_bytes(), ~[40u8, 32u8, 59u8]);\n+        assert_eq!(v2ascii!(~[40, 32, 59]).into_bytes(), box [40u8, 32u8, 59u8]);\n     }\n \n     #[test] #[should_fail]\n@@ -625,8 +625,8 @@ mod tests {\n         assert_eq!(v.to_ascii_opt(), Some(v2));\n         assert_eq!(\"zo\u00e4\u534e\".to_ascii_opt(), None);\n \n-        assert_eq!((~[40u8, 32u8, 59u8]).into_ascii_opt(), Some(v2ascii!(~[40, 32, 59])));\n-        assert_eq!((~[127u8, 128u8, 255u8]).into_ascii_opt(), None);\n+        assert_eq!((box [40u8, 32u8, 59u8]).into_ascii_opt(), Some(v2ascii!(~[40, 32, 59])));\n+        assert_eq!((box [127u8, 128u8, 255u8]).into_ascii_opt(), None);\n \n         assert_eq!((\"( ;\".to_owned()).into_ascii_opt(), Some(v2ascii!(~[40, 32, 59])));\n         assert_eq!((\"zo\u00e4\u534e\".to_owned()).into_ascii_opt(), None);"}, {"sha": "bcbf804d7b3084704c1045ab5eaea72410ba281f", "filename": "src/libstd/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcast.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -142,7 +142,7 @@ mod tests {\n     #[test]\n     fn test_transmute2() {\n         unsafe {\n-            assert_eq!(~[76u8], transmute(\"L\".to_owned()));\n+            assert_eq!(box [76u8], transmute(\"L\".to_owned()));\n         }\n     }\n }"}, {"sha": "e25f9c5ad4f7aa9f5a4b7660fa332ac8403957a2", "filename": "src/libstd/clone.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fclone.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -42,7 +42,7 @@ pub trait Clone {\n impl<T: Clone> Clone for ~T {\n     /// Return a copy of the owned box.\n     #[inline]\n-    fn clone(&self) -> ~T { ~(**self).clone() }\n+    fn clone(&self) -> ~T { box {(**self).clone()} }\n \n     /// Perform copy-assignment from `source` by reusing the existing allocation.\n     #[inline]\n@@ -126,7 +126,7 @@ extern_fn_clone!(A, B, C, D, E, F, G, H)\n \n #[test]\n fn test_owned_clone() {\n-    let a = ~5i;\n+    let a = box 5i;\n     let b: ~int = a.clone();\n     assert_eq!(a, b);\n }\n@@ -148,8 +148,8 @@ fn test_borrowed_clone() {\n \n #[test]\n fn test_clone_from() {\n-    let a = ~5;\n-    let mut b = ~10;\n+    let a = box 5;\n+    let mut b = box 10;\n     b.clone_from(&a);\n     assert_eq!(*b, 5);\n }"}, {"sha": "92e3e82c1c5a19f7cad10ab19b344a4265e757a9", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -976,14 +976,14 @@ mod test {\n \n     test!(fn drop_full() {\n         let (tx, _rx) = channel();\n-        tx.send(~1);\n+        tx.send(box 1);\n     })\n \n     test!(fn drop_full_shared() {\n         let (tx, _rx) = channel();\n         drop(tx.clone());\n         drop(tx.clone());\n-        tx.send(~1);\n+        tx.send(box 1);\n     })\n \n     test!(fn smoke_shared() {\n@@ -1179,7 +1179,7 @@ mod test {\n         // Testing that the sender cleans up the payload if receiver is closed\n         let (tx, rx) = channel::<~int>();\n         drop(rx);\n-        tx.send(~0);\n+        tx.send(box 0);\n     } #[should_fail])\n \n     test!(fn oneshot_single_thread_recv_chan_close() {\n@@ -1195,8 +1195,8 @@ mod test {\n \n     test!(fn oneshot_single_thread_send_then_recv() {\n         let (tx, rx) = channel::<~int>();\n-        tx.send(~10);\n-        assert!(rx.recv() == ~10);\n+        tx.send(box 10);\n+        assert!(rx.recv() == box 10);\n     })\n \n     test!(fn oneshot_single_thread_try_send_open() {\n@@ -1245,10 +1245,10 @@ mod test {\n     test!(fn oneshot_multi_task_recv_then_send() {\n         let (tx, rx) = channel::<~int>();\n         spawn(proc() {\n-            assert!(rx.recv() == ~10);\n+            assert!(rx.recv() == box 10);\n         });\n \n-        tx.send(~10);\n+        tx.send(box 10);\n     })\n \n     test!(fn oneshot_multi_task_recv_then_close() {\n@@ -1257,7 +1257,7 @@ mod test {\n             drop(tx);\n         });\n         let res = task::try(proc() {\n-            assert!(rx.recv() == ~10);\n+            assert!(rx.recv() == box 10);\n         });\n         assert!(res.is_err());\n     })\n@@ -1305,10 +1305,10 @@ mod test {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = channel();\n             spawn(proc() {\n-                tx.send(~10);\n+                tx.send(box 10);\n             });\n             spawn(proc() {\n-                assert!(rx.recv() == ~10);\n+                assert!(rx.recv() == box 10);\n             });\n         }\n     })\n@@ -1324,7 +1324,7 @@ mod test {\n                 if i == 10 { return }\n \n                 spawn(proc() {\n-                    tx.send(~i);\n+                    tx.send(box i);\n                     send(tx, i + 1);\n                 });\n             }\n@@ -1333,7 +1333,7 @@ mod test {\n                 if i == 10 { return }\n \n                 spawn(proc() {\n-                    assert!(rx.recv() == ~i);\n+                    assert!(rx.recv() == box i);\n                     recv(rx, i + 1);\n                 });\n             }\n@@ -1509,7 +1509,7 @@ mod sync_tests {\n \n     test!(fn drop_full() {\n         let (tx, _rx) = sync_channel(1);\n-        tx.send(~1);\n+        tx.send(box 1);\n     })\n \n     test!(fn smoke_shared() {\n@@ -1639,7 +1639,7 @@ mod sync_tests {\n         // Testing that the sender cleans up the payload if receiver is closed\n         let (tx, rx) = sync_channel::<~int>(0);\n         drop(rx);\n-        tx.send(~0);\n+        tx.send(box 0);\n     } #[should_fail])\n \n     test!(fn oneshot_single_thread_recv_chan_close() {\n@@ -1655,8 +1655,8 @@ mod sync_tests {\n \n     test!(fn oneshot_single_thread_send_then_recv() {\n         let (tx, rx) = sync_channel::<~int>(1);\n-        tx.send(~10);\n-        assert!(rx.recv() == ~10);\n+        tx.send(box 10);\n+        assert!(rx.recv() == box 10);\n     })\n \n     test!(fn oneshot_single_thread_try_send_open() {\n@@ -1710,10 +1710,10 @@ mod sync_tests {\n     test!(fn oneshot_multi_task_recv_then_send() {\n         let (tx, rx) = sync_channel::<~int>(0);\n         spawn(proc() {\n-            assert!(rx.recv() == ~10);\n+            assert!(rx.recv() == box 10);\n         });\n \n-        tx.send(~10);\n+        tx.send(box 10);\n     })\n \n     test!(fn oneshot_multi_task_recv_then_close() {\n@@ -1722,7 +1722,7 @@ mod sync_tests {\n             drop(tx);\n         });\n         let res = task::try(proc() {\n-            assert!(rx.recv() == ~10);\n+            assert!(rx.recv() == box 10);\n         });\n         assert!(res.is_err());\n     })\n@@ -1770,10 +1770,10 @@ mod sync_tests {\n         for _ in range(0, stress_factor()) {\n             let (tx, rx) = sync_channel(0);\n             spawn(proc() {\n-                tx.send(~10);\n+                tx.send(box 10);\n             });\n             spawn(proc() {\n-                assert!(rx.recv() == ~10);\n+                assert!(rx.recv() == box 10);\n             });\n         }\n     })\n@@ -1789,7 +1789,7 @@ mod sync_tests {\n                 if i == 10 { return }\n \n                 spawn(proc() {\n-                    tx.send(~i);\n+                    tx.send(box i);\n                     send(tx, i + 1);\n                 });\n             }\n@@ -1798,7 +1798,7 @@ mod sync_tests {\n                 if i == 10 { return }\n \n                 spawn(proc() {\n-                    assert!(rx.recv() == ~i);\n+                    assert!(rx.recv() == box i);\n                     recv(rx, i + 1);\n                 });\n             }"}, {"sha": "8dcce3fd146ee8c9f6d77efedb81dc98cde4cc9e", "filename": "src/libstd/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdefault.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -21,5 +21,5 @@ impl<T: Default + 'static> Default for @T {\n }\n \n impl<T: Default> Default for ~T {\n-    fn default() -> ~T { ~Default::default() }\n+    fn default() -> ~T { box Default::default() }\n }"}, {"sha": "0ba8cff742b4194c380cd168c008ec3e76526eea", "filename": "src/libstd/fmt/parse.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Ffmt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Ffmt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fparse.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -499,7 +499,7 @@ impl<'a> Parser<'a> {\n                 vec!()\n             }\n         };\n-        ~Select(arms, other)\n+        box Select(arms, other)\n     }\n \n     /// Parses a 'plural' statement (after the initial 'plural' word)\n@@ -597,7 +597,7 @@ impl<'a> Parser<'a> {\n                 vec!()\n             }\n         };\n-        ~Plural(offset, arms, other)\n+        box Plural(offset, arms, other)\n     }\n \n     /// Parses a Count parameter at the current position. This does not check\n@@ -912,25 +912,25 @@ mod tests {\n         same(\"{, select, other { haha } }\", [Argument(Argument{\n             position: ArgumentNext,\n             format: fmtdflt(),\n-            method: Some(~Select(vec![], vec![String(\" haha \")]))\n+            method: Some(box Select(vec![], vec![String(\" haha \")]))\n         })]);\n         same(\"{1, select, other { haha } }\", [Argument(Argument{\n             position: ArgumentIs(1),\n             format: fmtdflt(),\n-            method: Some(~Select(vec![], vec![String(\" haha \")]))\n+            method: Some(box Select(vec![], vec![String(\" haha \")]))\n         })]);\n         same(\"{1, select, other {#} }\", [Argument(Argument{\n             position: ArgumentIs(1),\n             format: fmtdflt(),\n-            method: Some(~Select(vec![], vec![CurrentArgument]))\n+            method: Some(box Select(vec![], vec![CurrentArgument]))\n         })]);\n         same(\"{1, select, other {{2, select, other {lol}}} }\", [Argument(Argument{\n             position: ArgumentIs(1),\n             format: fmtdflt(),\n-            method: Some(~Select(vec![], vec![Argument(Argument{\n+            method: Some(box Select(vec![], vec![Argument(Argument{\n                 position: ArgumentIs(2),\n                 format: fmtdflt(),\n-                method: Some(~Select(vec![], vec![String(\"lol\")]))\n+                method: Some(box Select(vec![], vec![String(\"lol\")]))\n             })])) // wat\n         })]);\n     }\n@@ -940,7 +940,7 @@ mod tests {\n         same(\"{1, select, a{1} b{2} c{3} other{4} }\", [Argument(Argument{\n             position: ArgumentIs(1),\n             format: fmtdflt(),\n-            method: Some(~Select(vec![\n+            method: Some(box Select(vec![\n                 SelectArm{ selector: \"a\", result: vec![String(\"1\")] },\n                 SelectArm{ selector: \"b\", result: vec![String(\"2\")] },\n                 SelectArm{ selector: \"c\", result: vec![String(\"3\")] },\n@@ -964,18 +964,18 @@ mod tests {\n         same(\"{, plural, other { haha } }\", [Argument(Argument{\n             position: ArgumentNext,\n             format: fmtdflt(),\n-            method: Some(~Plural(None, vec![], vec![String(\" haha \")]))\n+            method: Some(box Plural(None, vec![], vec![String(\" haha \")]))\n         })]);\n         same(\"{:, plural, other { haha } }\", [Argument(Argument{\n             position: ArgumentNext,\n             format: fmtdflt(),\n-            method: Some(~Plural(None, vec![], vec![String(\" haha \")]))\n+            method: Some(box Plural(None, vec![], vec![String(\" haha \")]))\n         })]);\n         same(\"{, plural, offset:1 =2{2} =3{3} many{yes} other{haha} }\",\n         [Argument(Argument{\n             position: ArgumentNext,\n             format: fmtdflt(),\n-            method: Some(~Plural(Some(1), vec![\n+            method: Some(box Plural(Some(1), vec![\n                 PluralArm{ selector: Literal(2), result: vec![String(\"2\")] },\n                 PluralArm{ selector: Literal(3), result: vec![String(\"3\")] },\n                 PluralArm{ selector: Keyword(Many), result: vec![String(\"yes\")] }"}, {"sha": "7387eff3dfc90d939a0ba0c2fe66fc1e9b893160", "filename": "src/libstd/gc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgc.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -117,7 +117,7 @@ mod tests {\n \n     #[test]\n     fn test_destructor() {\n-        let x = Gc::new(~5);\n+        let x = Gc::new(box 5);\n         assert_eq!(**x.borrow(), 5);\n     }\n }"}, {"sha": "3c1d5897e38e19ab66dd7c8f8e673aeb705f94ec", "filename": "src/libstd/hash/sip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash%2Fsip.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -467,7 +467,7 @@ mod tests {\n         }\n \n         fn result_bytes(h: u64) -> ~[u8] {\n-            ~[(h >> 0) as u8,\n+            box [(h >> 0) as u8,\n               (h >> 8) as u8,\n               (h >> 16) as u8,\n               (h >> 24) as u8,"}, {"sha": "45f783698cd3b9b2f3812ced16d1927b5ba07ecc", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -139,40 +139,40 @@ mod test {\n     fn test_rx_reader() {\n         let (tx, rx) = channel();\n         task::spawn(proc() {\n-          tx.send(~[1u8, 2u8]);\n-          tx.send(~[]);\n-          tx.send(~[3u8, 4u8]);\n-          tx.send(~[5u8, 6u8]);\n-          tx.send(~[7u8, 8u8]);\n+          tx.send(box [1u8, 2u8]);\n+          tx.send(box []);\n+          tx.send(box [3u8, 4u8]);\n+          tx.send(box [5u8, 6u8]);\n+          tx.send(box [7u8, 8u8]);\n         });\n \n         let mut reader = ChanReader::new(rx);\n-        let mut buf = ~[0u8, ..3];\n+        let mut buf = box [0u8, ..3];\n \n \n         assert_eq!(Ok(0), reader.read([]));\n \n         assert_eq!(Ok(3), reader.read(buf));\n-        assert_eq!(~[1,2,3], buf);\n+        assert_eq!(box [1,2,3], buf);\n \n         assert_eq!(Ok(3), reader.read(buf));\n-        assert_eq!(~[4,5,6], buf);\n+        assert_eq!(box [4,5,6], buf);\n \n         assert_eq!(Ok(2), reader.read(buf));\n-        assert_eq!(~[7,8,6], buf);\n+        assert_eq!(box [7,8,6], buf);\n \n         match reader.read(buf) {\n             Ok(..) => fail!(),\n             Err(e) => assert_eq!(e.kind, io::EndOfFile),\n         }\n-        assert_eq!(~[7,8,6], buf);\n+        assert_eq!(box [7,8,6], buf);\n \n         // Ensure it continues to fail in the same way.\n         match reader.read(buf) {\n             Ok(..) => fail!(),\n             Err(e) => assert_eq!(e.kind, io::EndOfFile),\n         }\n-        assert_eq!(~[7,8,6], buf);\n+        assert_eq!(box [7,8,6], buf);\n     }\n \n     #[test]\n@@ -181,7 +181,7 @@ mod test {\n         let mut writer = ChanWriter::new(tx);\n         writer.write_be_u32(42).unwrap();\n \n-        let wanted = ~[0u8, 0u8, 0u8, 42u8];\n+        let wanted = box [0u8, 0u8, 0u8, 42u8];\n         let got = task::try(proc() { rx.recv() }).unwrap();\n         assert_eq!(wanted, got);\n "}, {"sha": "c2e8fbeeb784ebceb9d6a2f93ceff3f67a870caf", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -447,7 +447,7 @@ mod test {\n     #[test]\n     fn test_read_f32() {\n         //big-endian floating-point 8.1250\n-        let buf = ~[0x41, 0x02, 0x00, 0x00];\n+        let buf = box [0x41, 0x02, 0x00, 0x00];\n \n         let mut writer = MemWriter::new();\n         writer.write(buf).unwrap();"}, {"sha": "9abe1bee9a32d8b60ecdcd6fb47af6e7ba64fac4", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -450,7 +450,7 @@ mod test {\n \n     #[test]\n     fn test_buf_reader() {\n-        let in_buf = ~[0, 1, 2, 3, 4, 5, 6, 7];\n+        let in_buf = box [0, 1, 2, 3, 4, 5, 6, 7];\n         let mut reader = BufReader::new(in_buf);\n         let mut buf = [];\n         assert_eq!(reader.read(buf), Ok(0));"}, {"sha": "184069bab33d3b28b6cceb3f2ef01f3f9df11661", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -243,7 +243,7 @@ mod test {\n         spawn(proc() {\n             match UdpSocket::bind(client_ip) {\n                 Ok(client) => {\n-                    let client = ~client;\n+                    let client = box client;\n                     let mut stream = client.connect(server_ip);\n                     rx1.recv();\n                     stream.write([99]).unwrap();\n@@ -255,7 +255,7 @@ mod test {\n \n         match UdpSocket::bind(server_ip) {\n             Ok(server) => {\n-                let server = ~server;\n+                let server = box server;\n                 let mut stream = server.connect(client_ip);\n                 tx1.send(());\n                 let mut buf = [0];\n@@ -281,7 +281,7 @@ mod test {\n         spawn(proc() {\n             match UdpSocket::bind(client_ip) {\n                 Ok(client) => {\n-                    let client = ~client;\n+                    let client = box client;\n                     let mut stream = client.connect(server_ip);\n                     rx1.recv();\n                     stream.write([99]).unwrap();\n@@ -293,7 +293,7 @@ mod test {\n \n         match UdpSocket::bind(server_ip) {\n             Ok(server) => {\n-                let server = ~server;\n+                let server = box server;\n                 let mut stream = server.connect(client_ip);\n                 tx1.send(());\n                 let mut buf = [0];"}, {"sha": "b89e3ec3c77bc527066deb11e8b705f4f1606b1f", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -417,7 +417,7 @@ impl Drop for Process {\n         drop(self.stdin.take());\n         drop(self.stdout.take());\n         drop(self.stderr.take());\n-        drop(mem::replace(&mut self.extra_io, ~[]));\n+        drop(mem::replace(&mut self.extra_io, box []));\n \n         self.wait();\n     }\n@@ -804,7 +804,7 @@ mod tests {\n     })\n \n     iotest!(fn test_add_to_env() {\n-        let new_env = ~[(\"RUN_TEST_NEW_ENV\".to_owned(), \"123\".to_owned())];\n+        let new_env = box [(\"RUN_TEST_NEW_ENV\".to_owned(), \"123\".to_owned())];\n \n         let mut prog = run_env(Some(new_env));\n         let result = prog.wait_with_output();"}, {"sha": "7cb58e1ea486cd5df9d6c9cfa71955123a12e1ae", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -216,7 +216,7 @@ fn with_task_stdout(f: |&mut Writer| -> IoResult<()> ) {\n             Local::put(task);\n \n             if my_stdout.is_none() {\n-                my_stdout = Some(~stdout() as ~Writer:Send);\n+                my_stdout = Some(box stdout() as ~Writer:Send);\n             }\n             let ret = f(*my_stdout.get_mut_ref());\n \n@@ -396,7 +396,7 @@ mod tests {\n         let (tx, rx) = channel();\n         let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));\n         spawn(proc() {\n-            set_stdout(~w);\n+            set_stdout(box w);\n             println!(\"hello!\");\n         });\n         assert_eq!(r.read_to_str().unwrap(), \"hello!\\n\".to_owned());\n@@ -408,7 +408,7 @@ mod tests {\n         let (tx, rx) = channel();\n         let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));\n         spawn(proc() {\n-            set_stderr(~w);\n+            set_stderr(box w);\n             fail!(\"my special message\");\n         });\n         let s = r.read_to_str().unwrap();"}, {"sha": "5cae79d371fdf3f909eb332e92f558d8838cd065", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -235,23 +235,23 @@ mod test {\n     #[test]\n     fn test_null_writer() {\n         let mut s = NullWriter;\n-        let buf = ~[0, 0, 0];\n+        let buf = box [0, 0, 0];\n         s.write(buf).unwrap();\n         s.flush().unwrap();\n     }\n \n     #[test]\n     fn test_zero_reader() {\n         let mut s = ZeroReader;\n-        let mut buf = ~[1, 2, 3];\n+        let mut buf = box [1, 2, 3];\n         assert_eq!(s.read(buf), Ok(3));\n-        assert_eq!(~[0, 0, 0], buf);\n+        assert_eq!(box [0, 0, 0], buf);\n     }\n \n     #[test]\n     fn test_null_reader() {\n         let mut r = NullReader;\n-        let mut buf = ~[0];\n+        let mut buf = box [0];\n         assert!(r.read(buf).is_err());\n     }\n \n@@ -273,8 +273,8 @@ mod test {\n             }\n         }\n \n-        let mut multi = MultiWriter::new(vec!(~TestWriter as ~Writer,\n-                                              ~TestWriter as ~Writer));\n+        let mut multi = MultiWriter::new(vec!(box TestWriter as ~Writer,\n+                                              box TestWriter as ~Writer));\n         multi.write([1, 2, 3]).unwrap();\n         assert_eq!(2, unsafe { writes });\n         assert_eq!(0, unsafe { flushes });"}, {"sha": "daeba2365e6ec5e9029d55677942271b31fcde62", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -2340,7 +2340,7 @@ mod tests {\n     fn test_counter_from_iter() {\n         let it = count(0, 5).take(10);\n         let xs: ~[int] = FromIterator::from_iter(it);\n-        assert_eq!(xs, ~[0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n+        assert_eq!(xs, box [0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n     }\n \n     #[test]\n@@ -2370,7 +2370,7 @@ mod tests {\n     fn test_filter_map() {\n         let mut it = count(0u, 1u).take(10)\n             .filter_map(|x| if x % 2 == 0 { Some(x*x) } else { None });\n-        assert_eq!(it.collect::<~[uint]>(), ~[0*0, 2*2, 4*4, 6*6, 8*8]);\n+        assert_eq!(it.collect::<~[uint]>(), box [0*0, 2*2, 4*4, 6*6, 8*8]);\n     }\n \n     #[test]\n@@ -2384,7 +2384,7 @@ mod tests {\n \n     #[test]\n     fn test_iterator_peekable() {\n-        let xs = ~[0u, 1, 2, 3, 4, 5];\n+        let xs = box [0u, 1, 2, 3, 4, 5];\n         let mut it = xs.iter().map(|&x|x).peekable();\n         assert_eq!(it.peek().unwrap(), &0);\n         assert_eq!(it.next().unwrap(), 0);\n@@ -2627,14 +2627,14 @@ mod tests {\n \n     #[test]\n     fn test_collect() {\n-        let a = ~[1, 2, 3, 4, 5];\n+        let a = box [1, 2, 3, 4, 5];\n         let b: ~[int] = a.iter().map(|&x| x).collect();\n         assert_eq!(a, b);\n     }\n \n     #[test]\n     fn test_all() {\n-        let v: ~&[int] = ~&[1, 2, 3, 4, 5];\n+        let v: ~&[int] = box &[1, 2, 3, 4, 5];\n         assert!(v.iter().all(|&x| x < 10));\n         assert!(!v.iter().all(|&x| x % 2 == 0));\n         assert!(!v.iter().all(|&x| x > 100));\n@@ -2643,7 +2643,7 @@ mod tests {\n \n     #[test]\n     fn test_any() {\n-        let v: ~&[int] = ~&[1, 2, 3, 4, 5];\n+        let v: ~&[int] = box &[1, 2, 3, 4, 5];\n         assert!(v.iter().any(|&x| x < 10));\n         assert!(v.iter().any(|&x| x % 2 == 0));\n         assert!(!v.iter().any(|&x| x > 100));\n@@ -2701,7 +2701,7 @@ mod tests {\n         let mut it = xs.iter();\n         it.next();\n         it.next();\n-        assert_eq!(it.rev().map(|&x| x).collect::<~[int]>(), ~[16, 14, 12, 10, 8, 6]);\n+        assert_eq!(it.rev().map(|&x| x).collect::<~[int]>(), box [16, 14, 12, 10, 8, 6]);\n     }\n \n     #[test]\n@@ -2767,7 +2767,7 @@ mod tests {\n     #[test]\n     fn test_double_ended_chain() {\n         let xs = [1, 2, 3, 4, 5];\n-        let ys = ~[7, 9, 11];\n+        let ys = box [7, 9, 11];\n         let mut it = xs.iter().chain(ys.iter()).rev();\n         assert_eq!(it.next().unwrap(), &11)\n         assert_eq!(it.next().unwrap(), &9)\n@@ -2784,7 +2784,7 @@ mod tests {\n     fn test_rposition() {\n         fn f(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'b' }\n         fn g(xy: &(int, char)) -> bool { let (_x, y) = *xy; y == 'd' }\n-        let v = ~[(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n+        let v = box [(0, 'a'), (1, 'b'), (2, 'c'), (3, 'b')];\n \n         assert_eq!(v.iter().rposition(f), Some(3u));\n         assert!(v.iter().rposition(g).is_none());\n@@ -2793,7 +2793,7 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_rposition_fail() {\n-        let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n+        let v = [(box 0, @0), (box 0, @0), (box 0, @0), (box 0, @0)];\n         let mut i = 0;\n         v.iter().rposition(|_elt| {\n             if i == 2 {\n@@ -2845,7 +2845,7 @@ mod tests {\n     #[test]\n     fn test_random_access_chain() {\n         let xs = [1, 2, 3, 4, 5];\n-        let ys = ~[7, 9, 11];\n+        let ys = box [7, 9, 11];\n         let mut it = xs.iter().chain(ys.iter());\n         assert_eq!(it.idx(0).unwrap(), &1);\n         assert_eq!(it.idx(5).unwrap(), &7);\n@@ -2939,12 +2939,12 @@ mod tests {\n \n     #[test]\n     fn test_double_ended_range() {\n-        assert_eq!(range(11i, 14).rev().collect::<~[int]>(), ~[13i, 12, 11]);\n+        assert_eq!(range(11i, 14).rev().collect::<~[int]>(), box [13i, 12, 11]);\n         for _ in range(10i, 0).rev() {\n             fail!(\"unreachable\");\n         }\n \n-        assert_eq!(range(11u, 14).rev().collect::<~[uint]>(), ~[13u, 12, 11]);\n+        assert_eq!(range(11u, 14).rev().collect::<~[uint]>(), box [13u, 12, 11]);\n         for _ in range(10u, 0).rev() {\n             fail!(\"unreachable\");\n         }\n@@ -2996,13 +2996,13 @@ mod tests {\n             }\n         }\n \n-        assert_eq!(range(0i, 5).collect::<~[int]>(), ~[0i, 1, 2, 3, 4]);\n-        assert_eq!(range(-10i, -1).collect::<~[int]>(), ~[-10, -9, -8, -7, -6, -5, -4, -3, -2]);\n-        assert_eq!(range(0i, 5).rev().collect::<~[int]>(), ~[4, 3, 2, 1, 0]);\n-        assert_eq!(range(200, -5).collect::<~[int]>(), ~[]);\n-        assert_eq!(range(200, -5).rev().collect::<~[int]>(), ~[]);\n-        assert_eq!(range(200, 200).collect::<~[int]>(), ~[]);\n-        assert_eq!(range(200, 200).rev().collect::<~[int]>(), ~[]);\n+        assert_eq!(range(0i, 5).collect::<~[int]>(), box [0i, 1, 2, 3, 4]);\n+        assert_eq!(range(-10i, -1).collect::<~[int]>(), box [-10, -9, -8, -7, -6, -5, -4, -3, -2]);\n+        assert_eq!(range(0i, 5).rev().collect::<~[int]>(), box [4, 3, 2, 1, 0]);\n+        assert_eq!(range(200, -5).collect::<~[int]>(), box []);\n+        assert_eq!(range(200, -5).rev().collect::<~[int]>(), box []);\n+        assert_eq!(range(200, 200).collect::<~[int]>(), box []);\n+        assert_eq!(range(200, 200).rev().collect::<~[int]>(), box []);\n \n         assert_eq!(range(0i, 100).size_hint(), (100, Some(100)));\n         // this test is only meaningful when sizeof uint < sizeof u64\n@@ -3013,32 +3013,32 @@ mod tests {\n \n     #[test]\n     fn test_range_inclusive() {\n-        assert_eq!(range_inclusive(0i, 5).collect::<~[int]>(), ~[0i, 1, 2, 3, 4, 5]);\n-        assert_eq!(range_inclusive(0i, 5).rev().collect::<~[int]>(), ~[5i, 4, 3, 2, 1, 0]);\n-        assert_eq!(range_inclusive(200, -5).collect::<~[int]>(), ~[]);\n-        assert_eq!(range_inclusive(200, -5).rev().collect::<~[int]>(), ~[]);\n-        assert_eq!(range_inclusive(200, 200).collect::<~[int]>(), ~[200]);\n-        assert_eq!(range_inclusive(200, 200).rev().collect::<~[int]>(), ~[200]);\n+        assert_eq!(range_inclusive(0i, 5).collect::<~[int]>(), box [0i, 1, 2, 3, 4, 5]);\n+        assert_eq!(range_inclusive(0i, 5).rev().collect::<~[int]>(), box [5i, 4, 3, 2, 1, 0]);\n+        assert_eq!(range_inclusive(200, -5).collect::<~[int]>(), box []);\n+        assert_eq!(range_inclusive(200, -5).rev().collect::<~[int]>(), box []);\n+        assert_eq!(range_inclusive(200, 200).collect::<~[int]>(), box [200]);\n+        assert_eq!(range_inclusive(200, 200).rev().collect::<~[int]>(), box [200]);\n     }\n \n     #[test]\n     fn test_range_step() {\n-        assert_eq!(range_step(0i, 20, 5).collect::<~[int]>(), ~[0, 5, 10, 15]);\n-        assert_eq!(range_step(20i, 0, -5).collect::<~[int]>(), ~[20, 15, 10, 5]);\n-        assert_eq!(range_step(20i, 0, -6).collect::<~[int]>(), ~[20, 14, 8, 2]);\n-        assert_eq!(range_step(200u8, 255, 50).collect::<~[u8]>(), ~[200u8, 250]);\n-        assert_eq!(range_step(200, -5, 1).collect::<~[int]>(), ~[]);\n-        assert_eq!(range_step(200, 200, 1).collect::<~[int]>(), ~[]);\n+        assert_eq!(range_step(0i, 20, 5).collect::<~[int]>(), box [0, 5, 10, 15]);\n+        assert_eq!(range_step(20i, 0, -5).collect::<~[int]>(), box [20, 15, 10, 5]);\n+        assert_eq!(range_step(20i, 0, -6).collect::<~[int]>(), box [20, 14, 8, 2]);\n+        assert_eq!(range_step(200u8, 255, 50).collect::<~[u8]>(), box [200u8, 250]);\n+        assert_eq!(range_step(200, -5, 1).collect::<~[int]>(), box []);\n+        assert_eq!(range_step(200, 200, 1).collect::<~[int]>(), box []);\n     }\n \n     #[test]\n     fn test_range_step_inclusive() {\n-        assert_eq!(range_step_inclusive(0i, 20, 5).collect::<~[int]>(), ~[0, 5, 10, 15, 20]);\n-        assert_eq!(range_step_inclusive(20i, 0, -5).collect::<~[int]>(), ~[20, 15, 10, 5, 0]);\n-        assert_eq!(range_step_inclusive(20i, 0, -6).collect::<~[int]>(), ~[20, 14, 8, 2]);\n-        assert_eq!(range_step_inclusive(200u8, 255, 50).collect::<~[u8]>(), ~[200u8, 250]);\n-        assert_eq!(range_step_inclusive(200, -5, 1).collect::<~[int]>(), ~[]);\n-        assert_eq!(range_step_inclusive(200, 200, 1).collect::<~[int]>(), ~[200]);\n+        assert_eq!(range_step_inclusive(0i, 20, 5).collect::<~[int]>(), box [0, 5, 10, 15, 20]);\n+        assert_eq!(range_step_inclusive(20i, 0, -5).collect::<~[int]>(), box [20, 15, 10, 5, 0]);\n+        assert_eq!(range_step_inclusive(20i, 0, -6).collect::<~[int]>(), box [20, 14, 8, 2]);\n+        assert_eq!(range_step_inclusive(200u8, 255, 50).collect::<~[u8]>(), box [200u8, 250]);\n+        assert_eq!(range_step_inclusive(200, -5, 1).collect::<~[int]>(), box []);\n+        assert_eq!(range_step_inclusive(200, 200, 1).collect::<~[int]>(), box [200]);\n     }\n \n     #[test]"}, {"sha": "bc6e324a5f7b06aa492c12727605b9c6cd3ffb57", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -302,7 +302,7 @@ pub fn set<T: 'static>(key: Key<T>, data: T) {\n     // everything to a trait (LocalData) which is then stored inside the map.\n     // Upon destruction of the map, all the objects will be destroyed and the\n     // traits have enough information about them to destroy themselves.\n-    let data = ~data as ~LocalData:;\n+    let data = box data as ~LocalData:;\n \n     fn insertion_position(map: &mut Map,\n                           key: *u8) -> Option<uint> {\n@@ -486,7 +486,7 @@ mod tests {\n     #[test]\n     fn test_owned() {\n         static key: Key<~int> = &Key;\n-        set(key, ~1);\n+        set(key, box 1);\n \n         get(key, |v| {\n             get(key, |v| {\n@@ -497,7 +497,7 @@ mod tests {\n             });\n             assert_eq!(**v.unwrap(), 1);\n         });\n-        set(key, ~2);\n+        set(key, box 2);\n         get(key, |v| {\n             assert_eq!(**v.unwrap(), 2);\n         })"}, {"sha": "eabaf4f2f9a14b02ee024a254db95dcb066ccf7a", "filename": "src/libstd/option.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -619,7 +619,7 @@ mod tests {\n     #[test]\n     fn test_get_ptr() {\n         unsafe {\n-            let x = ~0;\n+            let x = box 0;\n             let addr_x: *int = ::cast::transmute(&*x);\n             let opt = Some(x);\n             let y = opt.unwrap();\n@@ -862,11 +862,11 @@ mod tests {\n     fn test_collect() {\n         let v: Option<~[int]> = collect(range(0, 0)\n                                         .map(|_| Some(0)));\n-        assert_eq!(v, Some(~[]));\n+        assert_eq!(v, Some(box []));\n \n         let v: Option<~[int]> = collect(range(0, 3)\n                                         .map(|x| Some(x)));\n-        assert_eq!(v, Some(~[0, 1, 2]));\n+        assert_eq!(v, Some(box [0, 1, 2]));\n \n         let v: Option<~[int]> = collect(range(0, 3)\n                                         .map(|x| if x > 1 { None } else { Some(x) }));"}, {"sha": "071aae974db1ed98d500e5682483567a0186c375", "filename": "src/libstd/os.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -225,7 +225,7 @@ pub fn env_as_bytes() -> ~[(~[u8],~[u8])] {\n             for p in input.iter() {\n                 let vs: ~[&[u8]] = p.splitn(1, |b| *b == '=' as u8).collect();\n                 let key = vs[0].to_owned();\n-                let val = if vs.len() < 2 { ~[] } else { vs[1].to_owned() };\n+                let val = if vs.len() < 2 { box [] } else { vs[1].to_owned() };\n                 pairs.push((key, val));\n             }\n             pairs\n@@ -419,7 +419,7 @@ pub fn self_exe_name() -> Option<Path> {\n         unsafe {\n             use libc::funcs::bsd44::*;\n             use libc::consts::os::extra::*;\n-            let mib = ~[CTL_KERN as c_int,\n+            let mib = box [CTL_KERN as c_int,\n                         KERN_PROC as c_int,\n                         KERN_PROC_PATHNAME as c_int, -1 as c_int];\n             let mut sz: libc::size_t = 0;"}, {"sha": "b4b5185c2216a2ba9b14a549fb7919f978d7fe47", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -544,8 +544,8 @@ pub mod ptr_tests {\n             assert_eq!(p.fst, 50);\n             assert_eq!(p.snd, 60);\n \n-            let v0 = ~[32000u16, 32001u16, 32002u16];\n-            let mut v1 = ~[0u16, 0u16, 0u16];\n+            let v0 = box [32000u16, 32001u16, 32002u16];\n+            let mut v1 = box [0u16, 0u16, 0u16];\n \n             copy_memory(v1.as_mut_ptr().offset(1),\n                         v0.as_ptr().offset(1), 1);\n@@ -579,7 +579,7 @@ pub mod ptr_tests {\n         \"hello\".with_c_str(|p0| {\n             \"there\".with_c_str(|p1| {\n                 \"thing\".with_c_str(|p2| {\n-                    let v = ~[p0, p1, p2, null()];\n+                    let v = box [p0, p1, p2, null()];\n                     unsafe {\n                         assert_eq!(buf_len(v.as_ptr()), 3u);\n                     }\n@@ -627,7 +627,7 @@ pub mod ptr_tests {\n     #[test]\n     fn test_ptr_addition() {\n         unsafe {\n-            let xs = ~[5, ..16];\n+            let xs = box [5, ..16];\n             let mut ptr = xs.as_ptr();\n             let end = ptr.offset(16);\n \n@@ -645,14 +645,14 @@ pub mod ptr_tests {\n                 m_ptr = m_ptr.offset(1);\n             }\n \n-            assert_eq!(xs_mut, ~[10, ..16]);\n+            assert_eq!(xs_mut, box [10, ..16]);\n         }\n     }\n \n     #[test]\n     fn test_ptr_subtraction() {\n         unsafe {\n-            let xs = ~[0,1,2,3,4,5,6,7,8,9];\n+            let xs = box [0,1,2,3,4,5,6,7,8,9];\n             let mut idx = 9i8;\n             let ptr = xs.as_ptr();\n \n@@ -670,7 +670,7 @@ pub mod ptr_tests {\n                 m_ptr = m_ptr.offset(-1);\n             }\n \n-            assert_eq!(xs_mut, ~[0,2,4,6,8,10,12,14,16,18]);\n+            assert_eq!(xs_mut, box [0,2,4,6,8,10,12,14,16,18]);\n         }\n     }\n \n@@ -680,7 +680,7 @@ pub mod ptr_tests {\n             let one = \"oneOne\".to_c_str();\n             let two = \"twoTwo\".to_c_str();\n             let three = \"threeThree\".to_c_str();\n-            let arr = ~[\n+            let arr = box [\n                 one.with_ref(|buf| buf),\n                 two.with_ref(|buf| buf),\n                 three.with_ref(|buf| buf),\n@@ -713,7 +713,7 @@ pub mod ptr_tests {\n             let one = \"oneOne\".to_c_str();\n             let two = \"twoTwo\".to_c_str();\n             let three = \"threeThree\".to_c_str();\n-            let arr = ~[\n+            let arr = box [\n                 one.with_ref(|buf| buf),\n                 two.with_ref(|buf| buf),\n                 three.with_ref(|buf| buf),"}, {"sha": "51ab885a85f61f2b8187a5c3d5b45141ae7856f2", "filename": "src/libstd/rc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frc.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -58,7 +58,7 @@ impl<T> Rc<T> {\n                 // destructor never frees the allocation while the\n                 // strong destructor is running, even if the weak\n                 // pointer is stored inside the strong one.\n-                ptr: transmute(~RcBox {\n+                ptr: transmute(box RcBox {\n                     value: value,\n                     strong: Cell::new(1),\n                     weak: Cell::new(1)\n@@ -255,7 +255,7 @@ mod tests {\n \n     #[test]\n     fn test_destructor() {\n-        let x = Rc::new(~5);\n+        let x = Rc::new(box 5);\n         assert_eq!(**x, 5);\n     }\n "}, {"sha": "29d4f9e36d2e03183d62c1a9cb64d08927880fbc", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -642,7 +642,7 @@ fn test_repr() {\n     exact_test(&(\"he\\u10f3llo\".to_owned()), \"~\\\"he\\\\u10f3llo\\\"\");\n \n     exact_test(&(@10), \"@10\");\n-    exact_test(&(~10), \"~10\");\n+    exact_test(&(box 10), \"~10\");\n     exact_test(&(&10), \"&10\");\n     let mut x = 10;\n     exact_test(&(&mut x), \"&mut 10\");\n@@ -651,15 +651,15 @@ fn test_repr() {\n     exact_test(&(0 as *mut ()), \"(0x0 as *mut ())\");\n \n     exact_test(&(1,), \"(1,)\");\n-    exact_test(&(~[\"hi\", \"there\"]),\n+    exact_test(&(box [\"hi\", \"there\"]),\n                \"~[\\\"hi\\\", \\\"there\\\"]\");\n     exact_test(&(&[\"hi\", \"there\"]),\n                \"&[\\\"hi\\\", \\\"there\\\"]\");\n     exact_test(&(P{a:10, b:1.234}),\n                \"repr::P{a: 10, b: 1.234f64}\");\n     exact_test(&(@P{a:10, b:1.234}),\n                \"@repr::P{a: 10, b: 1.234f64}\");\n-    exact_test(&(~P{a:10, b:1.234}),\n+    exact_test(&(box P{a:10, b:1.234}),\n                \"~repr::P{a: 10, b: 1.234f64}\");\n     exact_test(&(10u8, \"hello\".to_owned()),\n                \"(10u8, ~\\\"hello\\\")\");\n@@ -681,10 +681,10 @@ fn test_repr() {\n     exact_test(&println, \"fn(&str)\");\n     exact_test(&swap::<int>, \"fn(&mut int, &mut int)\");\n     exact_test(&is_alphabetic, \"fn(char) -> bool\");\n-    exact_test(&(~5 as ~ToStr), \"~to_str::ToStr<no-bounds>\");\n+    exact_test(&(box 5 as ~ToStr), \"~to_str::ToStr<no-bounds>\");\n \n     struct Foo;\n-    exact_test(&(~[Foo, Foo]), \"~[repr::test_repr::Foo, repr::test_repr::Foo]\");\n+    exact_test(&(box [Foo, Foo]), \"~[repr::test_repr::Foo, repr::test_repr::Foo]\");\n \n     struct Bar(int, int);\n     exact_test(&(Bar(2, 2)), \"repr::test_repr::Bar(2, 2)\");"}, {"sha": "922d2cf3d3247efbec38f5d6becf68908f35875e", "filename": "src/libstd/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -685,10 +685,10 @@ mod tests {\n     #[test]\n     fn test_collect() {\n         let v: Result<~[int], ()> = collect(range(0, 0).map(|_| Ok::<int, ()>(0)));\n-        assert_eq!(v, Ok(~[]));\n+        assert_eq!(v, Ok(box []));\n \n         let v: Result<~[int], ()> = collect(range(0, 3).map(|x| Ok::<int, ()>(x)));\n-        assert_eq!(v, Ok(~[0, 1, 2]));\n+        assert_eq!(v, Ok(box [0, 1, 2]));\n \n         let v: Result<~[int], int> = collect(range(0, 3)\n                                              .map(|x| if x > 1 { Err(x) } else { Ok(x) }));"}, {"sha": "092efcad831545cc3d4358419521dbf6b4c2c3f0", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -99,7 +99,7 @@ mod imp {\n         with_lock(|| unsafe {\n             let ptr = get_global_ptr();\n             rtassert!((*ptr).is_none());\n-            (*ptr) = Some(~args.clone());\n+            (*ptr) = Some(box args.clone());\n         })\n     }\n \n@@ -147,7 +147,7 @@ mod imp {\n             // Preserve the actual global state.\n             let saved_value = take();\n \n-            let expected = ~[bytes!(\"happy\").to_owned(), bytes!(\"today?\").to_owned()];\n+            let expected = box [bytes!(\"happy\").to_owned(), bytes!(\"today?\").to_owned()];\n \n             put(expected.clone());\n             assert!(clone() == Some(expected.clone()));"}, {"sha": "2c8e159aeb9629de5f150dbc7384994bb706cf4d", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -36,7 +36,7 @@ pub fn init() {\n     unsafe {\n         rtassert!(!RUNNING);\n         rtassert!(QUEUE.is_null());\n-        let state: ~Queue = ~Exclusive::new(vec!());\n+        let state: ~Queue = box Exclusive::new(vec!());\n         QUEUE = cast::transmute(state);\n     }\n }"}, {"sha": "094bbd13889a09c86d5b876654e52028a208a81a", "filename": "src/libstd/rt/global_heap.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fglobal_heap.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -125,14 +125,14 @@ mod bench {\n     #[bench]\n     fn alloc_owned_small(b: &mut Bencher) {\n         b.iter(|| {\n-            ~10\n+            box 10\n         })\n     }\n \n     #[bench]\n     fn alloc_owned_big(b: &mut Bencher) {\n         b.iter(|| {\n-            ~[10, ..1000]\n+            box [10, ..1000]\n         })\n     }\n }"}, {"sha": "828bbc118c10a59025c26100c8d04a9a75c14d3b", "filename": "src/libstd/rt/local.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -59,7 +59,7 @@ mod test {\n     #[test]\n     fn thread_local_task_smoke_test() {\n         run_in_bare_thread(proc() {\n-            let task = ~Task::new();\n+            let task = box Task::new();\n             Local::put(task);\n             let task: ~Task = Local::take();\n             cleanup_task(task);\n@@ -69,11 +69,11 @@ mod test {\n     #[test]\n     fn thread_local_task_two_instances() {\n         run_in_bare_thread(proc() {\n-            let task = ~Task::new();\n+            let task = box Task::new();\n             Local::put(task);\n             let task: ~Task = Local::take();\n             cleanup_task(task);\n-            let task = ~Task::new();\n+            let task = box Task::new();\n             Local::put(task);\n             let task: ~Task = Local::take();\n             cleanup_task(task);\n@@ -83,7 +83,7 @@ mod test {\n     #[test]\n     fn borrow_smoke_test() {\n         run_in_bare_thread(proc() {\n-            let task = ~Task::new();\n+            let task = box Task::new();\n             Local::put(task);\n \n             unsafe {\n@@ -97,7 +97,7 @@ mod test {\n     #[test]\n     fn borrow_with_return() {\n         run_in_bare_thread(proc() {\n-            let task = ~Task::new();\n+            let task = box Task::new();\n             Local::put(task);\n \n             {\n@@ -112,7 +112,7 @@ mod test {\n     #[test]\n     fn try_take() {\n         run_in_bare_thread(proc() {\n-            let task = ~Task::new();\n+            let task = box Task::new();\n             Local::put(task);\n \n             let t: ~Task = Local::try_take().unwrap();"}, {"sha": "ae5786604c7a15efdb074bdcd7d4caee814957e7", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -353,7 +353,7 @@ impl BlockedTask {\n                 blocked_task_ptr\n             }\n             Shared(arc) => {\n-                let blocked_task_ptr: uint = cast::transmute(~arc);\n+                let blocked_task_ptr: uint = cast::transmute(box arc);\n                 rtassert!(blocked_task_ptr & 0x1 == 0);\n                 blocked_task_ptr | 0x1\n             }\n@@ -485,7 +485,7 @@ mod test {\n \n     #[test]\n     fn block_and_wake() {\n-        let task = ~Task::new();\n+        let task = box Task::new();\n         let mut task = BlockedTask::block(task).wake().unwrap();\n         task.destroyed = true;\n     }"}, {"sha": "a836958279b8e650c8307ee8de5ce354957982d8", "filename": "src/libstd/rt/thread.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -80,12 +80,12 @@ impl Thread<()> {\n         // We need the address of the packet to fill in to be stable so when\n         // `main` fills it in it's still valid, so allocate an extra ~ box to do\n         // so.\n-        let packet = ~None;\n+        let packet = box None;\n         let packet2: *mut Option<T> = unsafe {\n             *cast::transmute::<&~Option<T>, **mut Option<T>>(&packet)\n         };\n         let main = proc() unsafe { *packet2 = Some(main()); };\n-        let native = unsafe { imp::create(stack, ~main) };\n+        let native = unsafe { imp::create(stack, box main) };\n \n         Thread {\n             native: native,\n@@ -108,7 +108,7 @@ impl Thread<()> {\n     /// stack size for the new thread.\n     pub fn spawn_stack(stack: uint, main: proc():Send) {\n         unsafe {\n-            let handle = imp::create(stack, ~main);\n+            let handle = imp::create(stack, box main);\n             imp::detach(handle);\n         }\n     }"}, {"sha": "fceff80e792aac34a9843b3913d09e7072d2f2d0", "filename": "src/libstd/rt/thread_local_storage.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Frt%2Fthread_local_storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Frt%2Fthread_local_storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread_local_storage.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -96,14 +96,14 @@ fn tls_smoke_test() {\n     use cast::transmute;\n     unsafe {\n         let mut key = 0;\n-        let value = ~20;\n+        let value = box 20;\n         create(&mut key);\n         set(key, transmute(value));\n         let value: ~int = transmute(get(key));\n-        assert_eq!(value, ~20);\n-        let value = ~30;\n+        assert_eq!(value, box 20);\n+        let value = box 30;\n         set(key, transmute(value));\n         let value: ~int = transmute(get(key));\n-        assert_eq!(value, ~30);\n+        assert_eq!(value, box 30);\n     }\n }"}, {"sha": "98623c35b78996e9ef000cc0aac88e5068089401", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -141,7 +141,7 @@ impl Unwinder {\n         #[no_mangle]\n         fn rust_fail() -> ! {\n             unsafe {\n-                let exception = ~uw::_Unwind_Exception {\n+                let exception = box uw::_Unwind_Exception {\n                     exception_class: rust_exception_class(),\n                     exception_cleanup: exception_cleanup,\n                     private: [0, ..uw::unwinder_private_data_size],\n@@ -346,7 +346,7 @@ pub fn begin_unwind_fmt(msg: &fmt::Arguments, file: &'static str, line: uint) ->\n     // required with the current scheme, and (b) we don't handle\n     // failure + OOM properly anyway (see comment in begin_unwind\n     // below).\n-    begin_unwind_inner(~fmt::format(msg), file, line)\n+    begin_unwind_inner(box fmt::format(msg), file, line)\n }\n \n /// This is the entry point of unwinding for fail!() and assert!().\n@@ -360,7 +360,7 @@ pub fn begin_unwind<M: Any + Send>(msg: M, file: &'static str, line: uint) -> !\n     // failing.\n \n     // see below for why we do the `Any` coercion here.\n-    begin_unwind_inner(~msg, file, line)\n+    begin_unwind_inner(box msg, file, line)\n }\n \n "}, {"sha": "cb8550d248eabf17fbe9b784c8a44e0be7969139", "filename": "src/libstd/slice.rs", "status": "modified", "additions": 100, "deletions": 99, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fslice.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -2042,7 +2042,7 @@ impl<'a, A> Default for &'a [A] {\n }\n \n impl<A> Default for ~[A] {\n-    fn default() -> ~[A] { ~[] }\n+    fn default() -> ~[A] { box [] }\n }\n \n /// Immutable slice iterator\n@@ -2361,7 +2361,7 @@ mod tests {\n     fn test_unsafe_ptrs() {\n         unsafe {\n             // Test on-stack copy-from-buf.\n-            let a = ~[1, 2, 3];\n+            let a = box [1, 2, 3];\n             let mut ptr = a.as_ptr();\n             let b = from_buf(ptr, 3u);\n             assert_eq!(b.len(), 3u);\n@@ -2370,7 +2370,7 @@ mod tests {\n             assert_eq!(b[2], 3);\n \n             // Test on-heap copy-from-buf.\n-            let c = ~[1, 2, 3, 4, 5];\n+            let c = box [1, 2, 3, 4, 5];\n             ptr = c.as_ptr();\n             let d = from_buf(ptr, 5u);\n             assert_eq!(d.len(), 5u);\n@@ -2452,91 +2452,91 @@ mod tests {\n \n     #[test]\n     fn test_get() {\n-        let mut a = ~[11];\n+        let mut a = box [11];\n         assert_eq!(a.get(1), None);\n-        a = ~[11, 12];\n+        a = box [11, 12];\n         assert_eq!(a.get(1).unwrap(), &12);\n-        a = ~[11, 12, 13];\n+        a = box [11, 12, 13];\n         assert_eq!(a.get(1).unwrap(), &12);\n     }\n \n     #[test]\n     fn test_head() {\n-        let mut a = ~[];\n+        let mut a = box [];\n         assert_eq!(a.head(), None);\n-        a = ~[11];\n+        a = box [11];\n         assert_eq!(a.head().unwrap(), &11);\n-        a = ~[11, 12];\n+        a = box [11, 12];\n         assert_eq!(a.head().unwrap(), &11);\n     }\n \n     #[test]\n     fn test_tail() {\n-        let mut a = ~[11];\n+        let mut a = box [11];\n         assert_eq!(a.tail(), &[]);\n-        a = ~[11, 12];\n+        a = box [11, 12];\n         assert_eq!(a.tail(), &[12]);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_tail_empty() {\n-        let a: ~[int] = ~[];\n+        let a: ~[int] = box [];\n         a.tail();\n     }\n \n     #[test]\n     fn test_tailn() {\n-        let mut a = ~[11, 12, 13];\n+        let mut a = box [11, 12, 13];\n         assert_eq!(a.tailn(0), &[11, 12, 13]);\n-        a = ~[11, 12, 13];\n+        a = box [11, 12, 13];\n         assert_eq!(a.tailn(2), &[13]);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_tailn_empty() {\n-        let a: ~[int] = ~[];\n+        let a: ~[int] = box [];\n         a.tailn(2);\n     }\n \n     #[test]\n     fn test_init() {\n-        let mut a = ~[11];\n+        let mut a = box [11];\n         assert_eq!(a.init(), &[]);\n-        a = ~[11, 12];\n+        a = box [11, 12];\n         assert_eq!(a.init(), &[11]);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_init_empty() {\n-        let a: ~[int] = ~[];\n+        let a: ~[int] = box [];\n         a.init();\n     }\n \n     #[test]\n     fn test_initn() {\n-        let mut a = ~[11, 12, 13];\n+        let mut a = box [11, 12, 13];\n         assert_eq!(a.initn(0), &[11, 12, 13]);\n-        a = ~[11, 12, 13];\n+        a = box [11, 12, 13];\n         assert_eq!(a.initn(2), &[11]);\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_initn_empty() {\n-        let a: ~[int] = ~[];\n+        let a: ~[int] = box [];\n         a.initn(2);\n     }\n \n     #[test]\n     fn test_last() {\n-        let mut a = ~[];\n+        let mut a = box [];\n         assert_eq!(a.last(), None);\n-        a = ~[11];\n+        a = box [11];\n         assert_eq!(a.last().unwrap(), &11);\n-        a = ~[11, 12];\n+        a = box [11, 12];\n         assert_eq!(a.last().unwrap(), &12);\n     }\n \n@@ -2558,7 +2558,7 @@ mod tests {\n         assert_eq!(v_b[1], 3);\n \n         // Test on exchange heap.\n-        let vec_unique = ~[1, 2, 3, 4, 5, 6];\n+        let vec_unique = box [1, 2, 3, 4, 5, 6];\n         let v_d = vec_unique.slice(1u, 6u).to_owned();\n         assert_eq!(v_d.len(), 5u);\n         assert_eq!(v_d[0], 2);\n@@ -2692,7 +2692,7 @@ mod tests {\n \n     #[test]\n     fn test_truncate() {\n-        let mut v = vec![~6,~5,~4];\n+        let mut v = vec![box 6,box 5,box 4];\n         v.truncate(1);\n         let v = v.as_slice();\n         assert_eq!(v.len(), 1);\n@@ -2702,7 +2702,7 @@ mod tests {\n \n     #[test]\n     fn test_clear() {\n-        let mut v = vec![~6,~5,~4];\n+        let mut v = vec![box 6,box 5,box 4];\n         v.clear();\n         assert_eq!(v.len(), 0);\n         // If the unsafe block didn't drop things properly, we blow up here.\n@@ -2727,11 +2727,11 @@ mod tests {\n \n     #[test]\n     fn test_dedup_unique() {\n-        let mut v0 = vec![~1, ~1, ~2, ~3];\n+        let mut v0 = vec![box 1, box 1, box 2, box 3];\n         v0.dedup();\n-        let mut v1 = vec![~1, ~2, ~2, ~3];\n+        let mut v1 = vec![box 1, box 2, box 2, box 3];\n         v1.dedup();\n-        let mut v2 = vec![~1, ~2, ~3, ~3];\n+        let mut v2 = vec![box 1, box 2, box 3, box 3];\n         v2.dedup();\n         /*\n          * If the ~pointers were leaked or otherwise misused, valgrind and/or\n@@ -2741,11 +2741,11 @@ mod tests {\n \n     #[test]\n     fn test_dedup_shared() {\n-        let mut v0 = vec![~1, ~1, ~2, ~3];\n+        let mut v0 = vec![box 1, box 1, box 2, box 3];\n         v0.dedup();\n-        let mut v1 = vec![~1, ~2, ~2, ~3];\n+        let mut v1 = vec![box 1, box 2, box 2, box 3];\n         v1.dedup();\n-        let mut v2 = vec![~1, ~2, ~3, ~3];\n+        let mut v2 = vec![box 1, box 2, box 3, box 3];\n         v2.dedup();\n         /*\n          * If the pointers were leaked or otherwise misused, valgrind and/or\n@@ -2814,15 +2814,15 @@ mod tests {\n             let (min_size, max_opt) = it.size_hint();\n             assert_eq!(min_size, 3*2);\n             assert_eq!(max_opt.unwrap(), 3*2);\n-            assert_eq!(it.next(), Some(~[1,2,3]));\n-            assert_eq!(it.next(), Some(~[1,3,2]));\n-            assert_eq!(it.next(), Some(~[3,1,2]));\n+            assert_eq!(it.next(), Some(box [1,2,3]));\n+            assert_eq!(it.next(), Some(box [1,3,2]));\n+            assert_eq!(it.next(), Some(box [3,1,2]));\n             let (min_size, max_opt) = it.size_hint();\n             assert_eq!(min_size, 3);\n             assert_eq!(max_opt.unwrap(), 3);\n-            assert_eq!(it.next(), Some(~[3,2,1]));\n-            assert_eq!(it.next(), Some(~[2,3,1]));\n-            assert_eq!(it.next(), Some(~[2,1,3]));\n+            assert_eq!(it.next(), Some(box [3,2,1]));\n+            assert_eq!(it.next(), Some(box [2,3,1]));\n+            assert_eq!(it.next(), Some(box [2,1,3]));\n             assert_eq!(it.next(), None);\n         }\n         {\n@@ -2845,7 +2845,7 @@ mod tests {\n     fn test_position_elem() {\n         assert!([].position_elem(&1).is_none());\n \n-        let v1 = ~[1, 2, 3, 3, 2, 5];\n+        let v1 = box [1, 2, 3, 3, 2, 5];\n         assert_eq!(v1.position_elem(&1), Some(0u));\n         assert_eq!(v1.position_elem(&2), Some(1u));\n         assert_eq!(v1.position_elem(&5), Some(5u));\n@@ -2899,14 +2899,14 @@ mod tests {\n \n     #[test]\n     fn test_reverse() {\n-        let mut v: ~[int] = ~[10, 20];\n+        let mut v: ~[int] = box [10, 20];\n         assert_eq!(v[0], 10);\n         assert_eq!(v[1], 20);\n         v.reverse();\n         assert_eq!(v[0], 20);\n         assert_eq!(v[1], 10);\n \n-        let mut v3: ~[int] = ~[];\n+        let mut v3: ~[int] = box [];\n         v3.reverse();\n         assert!(v3.is_empty());\n     }\n@@ -2973,39 +2973,39 @@ mod tests {\n \n     #[test]\n     fn test_partition() {\n-        assert_eq!((~[]).partition(|x: &int| *x < 3), (~[], ~[]));\n-        assert_eq!((~[1, 2, 3]).partition(|x: &int| *x < 4), (~[1, 2, 3], ~[]));\n-        assert_eq!((~[1, 2, 3]).partition(|x: &int| *x < 2), (~[1], ~[2, 3]));\n-        assert_eq!((~[1, 2, 3]).partition(|x: &int| *x < 0), (~[], ~[1, 2, 3]));\n+        assert_eq!((box []).partition(|x: &int| *x < 3), (box [], box []));\n+        assert_eq!((box [1, 2, 3]).partition(|x: &int| *x < 4), (box [1, 2, 3], box []));\n+        assert_eq!((box [1, 2, 3]).partition(|x: &int| *x < 2), (box [1], box [2, 3]));\n+        assert_eq!((box [1, 2, 3]).partition(|x: &int| *x < 0), (box [], box [1, 2, 3]));\n     }\n \n     #[test]\n     fn test_partitioned() {\n-        assert_eq!(([]).partitioned(|x: &int| *x < 3), (~[], ~[]))\n-        assert_eq!(([1, 2, 3]).partitioned(|x: &int| *x < 4), (~[1, 2, 3], ~[]));\n-        assert_eq!(([1, 2, 3]).partitioned(|x: &int| *x < 2), (~[1], ~[2, 3]));\n-        assert_eq!(([1, 2, 3]).partitioned(|x: &int| *x < 0), (~[], ~[1, 2, 3]));\n+        assert_eq!(([]).partitioned(|x: &int| *x < 3), (box [], box []))\n+        assert_eq!(([1, 2, 3]).partitioned(|x: &int| *x < 4), (box [1, 2, 3], box []));\n+        assert_eq!(([1, 2, 3]).partitioned(|x: &int| *x < 2), (box [1], box [2, 3]));\n+        assert_eq!(([1, 2, 3]).partitioned(|x: &int| *x < 0), (box [], box [1, 2, 3]));\n     }\n \n     #[test]\n     fn test_concat() {\n         let v: [~[int], ..0] = [];\n-        assert_eq!(v.concat_vec(), ~[]);\n-        assert_eq!([~[1], ~[2,3]].concat_vec(), ~[1, 2, 3]);\n+        assert_eq!(v.concat_vec(), box []);\n+        assert_eq!([box [1], box [2,3]].concat_vec(), box [1, 2, 3]);\n \n-        assert_eq!([&[1], &[2,3]].concat_vec(), ~[1, 2, 3]);\n+        assert_eq!([&[1], &[2,3]].concat_vec(), box [1, 2, 3]);\n     }\n \n     #[test]\n     fn test_connect() {\n         let v: [~[int], ..0] = [];\n-        assert_eq!(v.connect_vec(&0), ~[]);\n-        assert_eq!([~[1], ~[2, 3]].connect_vec(&0), ~[1, 0, 2, 3]);\n-        assert_eq!([~[1], ~[2], ~[3]].connect_vec(&0), ~[1, 0, 2, 0, 3]);\n+        assert_eq!(v.connect_vec(&0), box []);\n+        assert_eq!([box [1], box [2, 3]].connect_vec(&0), box [1, 0, 2, 3]);\n+        assert_eq!([box [1], box [2], box [3]].connect_vec(&0), box [1, 0, 2, 0, 3]);\n \n-        assert_eq!(v.connect_vec(&0), ~[]);\n-        assert_eq!([&[1], &[2, 3]].connect_vec(&0), ~[1, 0, 2, 3]);\n-        assert_eq!([&[1], &[2], &[3]].connect_vec(&0), ~[1, 0, 2, 0, 3]);\n+        assert_eq!(v.connect_vec(&0), box []);\n+        assert_eq!([&[1], &[2, 3]].connect_vec(&0), box [1, 0, 2, 3]);\n+        assert_eq!([&[1], &[2], &[3]].connect_vec(&0), box [1, 0, 2, 0, 3]);\n     }\n \n     #[test]\n@@ -3100,7 +3100,7 @@ mod tests {\n     fn test_from_fn_fail() {\n         Vec::from_fn(100, |v| {\n             if v == 50 { fail!() }\n-            ~0\n+            box 0\n         });\n     }\n \n@@ -3124,7 +3124,7 @@ mod tests {\n             }\n         }\n \n-        let s = S { f: 0, boxes: (~0, Rc::new(0)) };\n+        let s = S { f: 0, boxes: (box 0, Rc::new(0)) };\n         let _ = Vec::from_elem(100, s);\n     }\n \n@@ -3137,15 +3137,16 @@ mod tests {\n             if i == 50 {\n                 fail!()\n             }\n-            (~0, Rc::new(0))\n+            (box 0, Rc::new(0))\n         })\n     }\n \n     #[test]\n     #[should_fail]\n     fn test_permute_fail() {\n         use rc::Rc;\n-        let v = [(~0, Rc::new(0)), (~0, Rc::new(0)), (~0, Rc::new(0)), (~0, Rc::new(0))];\n+        let v = [(box 0, Rc::new(0)), (box 0, Rc::new(0)),\n+                 (box 0, Rc::new(0)), (box 0, Rc::new(0))];\n         let mut i = 0;\n         for _ in v.permutations() {\n             if i == 2 {\n@@ -3288,14 +3289,14 @@ mod tests {\n     #[test]\n     fn test_move_iterator() {\n         use iter::*;\n-        let xs = ~[1u,2,3,4,5];\n+        let xs = box [1u,2,3,4,5];\n         assert_eq!(xs.move_iter().fold(0, |a: uint, b: uint| 10*a + b), 12345);\n     }\n \n     #[test]\n     fn test_move_rev_iterator() {\n         use iter::*;\n-        let xs = ~[1u,2,3,4,5];\n+        let xs = box [1u,2,3,4,5];\n         assert_eq!(xs.move_iter().rev().fold(0, |a: uint, b: uint| 10*a + b), 54321);\n     }\n \n@@ -3304,73 +3305,73 @@ mod tests {\n         let xs = &[1i,2,3,4,5];\n \n         assert_eq!(xs.split(|x| *x % 2 == 0).collect::<~[&[int]]>(),\n-                   ~[&[1], &[3], &[5]]);\n+                   box [&[1], &[3], &[5]]);\n         assert_eq!(xs.split(|x| *x == 1).collect::<~[&[int]]>(),\n-                   ~[&[], &[2,3,4,5]]);\n+                   box [&[], &[2,3,4,5]]);\n         assert_eq!(xs.split(|x| *x == 5).collect::<~[&[int]]>(),\n-                   ~[&[1,2,3,4], &[]]);\n+                   box [&[1,2,3,4], &[]]);\n         assert_eq!(xs.split(|x| *x == 10).collect::<~[&[int]]>(),\n-                   ~[&[1,2,3,4,5]]);\n+                   box [&[1,2,3,4,5]]);\n         assert_eq!(xs.split(|_| true).collect::<~[&[int]]>(),\n-                   ~[&[], &[], &[], &[], &[], &[]]);\n+                   box [&[], &[], &[], &[], &[], &[]]);\n \n         let xs: &[int] = &[];\n-        assert_eq!(xs.split(|x| *x == 5).collect::<~[&[int]]>(), ~[&[]]);\n+        assert_eq!(xs.split(|x| *x == 5).collect::<~[&[int]]>(), box [&[]]);\n     }\n \n     #[test]\n     fn test_splitnator() {\n         let xs = &[1i,2,3,4,5];\n \n         assert_eq!(xs.splitn(0, |x| *x % 2 == 0).collect::<~[&[int]]>(),\n-                   ~[&[1,2,3,4,5]]);\n+                   box [&[1,2,3,4,5]]);\n         assert_eq!(xs.splitn(1, |x| *x % 2 == 0).collect::<~[&[int]]>(),\n-                   ~[&[1], &[3,4,5]]);\n+                   box [&[1], &[3,4,5]]);\n         assert_eq!(xs.splitn(3, |_| true).collect::<~[&[int]]>(),\n-                   ~[&[], &[], &[], &[4,5]]);\n+                   box [&[], &[], &[], &[4,5]]);\n \n         let xs: &[int] = &[];\n-        assert_eq!(xs.splitn(1, |x| *x == 5).collect::<~[&[int]]>(), ~[&[]]);\n+        assert_eq!(xs.splitn(1, |x| *x == 5).collect::<~[&[int]]>(), box [&[]]);\n     }\n \n     #[test]\n     fn test_rsplitator() {\n         let xs = &[1i,2,3,4,5];\n \n         assert_eq!(xs.split(|x| *x % 2 == 0).rev().collect::<~[&[int]]>(),\n-                   ~[&[5], &[3], &[1]]);\n+                   box [&[5], &[3], &[1]]);\n         assert_eq!(xs.split(|x| *x == 1).rev().collect::<~[&[int]]>(),\n-                   ~[&[2,3,4,5], &[]]);\n+                   box [&[2,3,4,5], &[]]);\n         assert_eq!(xs.split(|x| *x == 5).rev().collect::<~[&[int]]>(),\n-                   ~[&[], &[1,2,3,4]]);\n+                   box [&[], &[1,2,3,4]]);\n         assert_eq!(xs.split(|x| *x == 10).rev().collect::<~[&[int]]>(),\n-                   ~[&[1,2,3,4,5]]);\n+                   box [&[1,2,3,4,5]]);\n \n         let xs: &[int] = &[];\n-        assert_eq!(xs.split(|x| *x == 5).rev().collect::<~[&[int]]>(), ~[&[]]);\n+        assert_eq!(xs.split(|x| *x == 5).rev().collect::<~[&[int]]>(), box [&[]]);\n     }\n \n     #[test]\n     fn test_rsplitnator() {\n         let xs = &[1,2,3,4,5];\n \n         assert_eq!(xs.rsplitn(0, |x| *x % 2 == 0).collect::<~[&[int]]>(),\n-                   ~[&[1,2,3,4,5]]);\n+                   box [&[1,2,3,4,5]]);\n         assert_eq!(xs.rsplitn(1, |x| *x % 2 == 0).collect::<~[&[int]]>(),\n-                   ~[&[5], &[1,2,3]]);\n+                   box [&[5], &[1,2,3]]);\n         assert_eq!(xs.rsplitn(3, |_| true).collect::<~[&[int]]>(),\n-                   ~[&[], &[], &[], &[1,2]]);\n+                   box [&[], &[], &[], &[1,2]]);\n \n         let xs: &[int] = &[];\n-        assert_eq!(xs.rsplitn(1, |x| *x == 5).collect::<~[&[int]]>(), ~[&[]]);\n+        assert_eq!(xs.rsplitn(1, |x| *x == 5).collect::<~[&[int]]>(), box [&[]]);\n     }\n \n     #[test]\n     fn test_windowsator() {\n         let v = &[1i,2,3,4];\n \n-        assert_eq!(v.windows(2).collect::<~[&[int]]>(), ~[&[1,2], &[2,3], &[3,4]]);\n-        assert_eq!(v.windows(3).collect::<~[&[int]]>(), ~[&[1i,2,3], &[2,3,4]]);\n+        assert_eq!(v.windows(2).collect::<~[&[int]]>(), box [&[1,2], &[2,3], &[3,4]]);\n+        assert_eq!(v.windows(3).collect::<~[&[int]]>(), box [&[1i,2,3], &[2,3,4]]);\n         assert!(v.windows(6).next().is_none());\n     }\n \n@@ -3385,11 +3386,11 @@ mod tests {\n     fn test_chunksator() {\n         let v = &[1i,2,3,4,5];\n \n-        assert_eq!(v.chunks(2).collect::<~[&[int]]>(), ~[&[1i,2], &[3,4], &[5]]);\n-        assert_eq!(v.chunks(3).collect::<~[&[int]]>(), ~[&[1i,2,3], &[4,5]]);\n-        assert_eq!(v.chunks(6).collect::<~[&[int]]>(), ~[&[1i,2,3,4,5]]);\n+        assert_eq!(v.chunks(2).collect::<~[&[int]]>(), box [&[1i,2], &[3,4], &[5]]);\n+        assert_eq!(v.chunks(3).collect::<~[&[int]]>(), box [&[1i,2,3], &[4,5]]);\n+        assert_eq!(v.chunks(6).collect::<~[&[int]]>(), box [&[1i,2,3,4,5]]);\n \n-        assert_eq!(v.chunks(2).rev().collect::<~[&[int]]>(), ~[&[5i], &[3,4], &[1,2]]);\n+        assert_eq!(v.chunks(2).rev().collect::<~[&[int]]>(), box [&[5i], &[3,4], &[1,2]]);\n         let mut it = v.chunks(2);\n         assert_eq!(it.indexable(), 3);\n         assert_eq!(it.idx(0).unwrap(), &[1,2]);\n@@ -3408,19 +3409,19 @@ mod tests {\n     #[test]\n     fn test_move_from() {\n         let mut a = [1,2,3,4,5];\n-        let b = ~[6,7,8];\n+        let b = box [6,7,8];\n         assert_eq!(a.move_from(b, 0, 3), 3);\n         assert!(a == [6,7,8,4,5]);\n         let mut a = [7,2,8,1];\n-        let b = ~[3,1,4,1,5,9];\n+        let b = box [3,1,4,1,5,9];\n         assert_eq!(a.move_from(b, 0, 6), 4);\n         assert!(a == [3,1,4,1]);\n         let mut a = [1,2,3,4];\n-        let b = ~[5,6,7,8,9,0];\n+        let b = box [5,6,7,8,9,0];\n         assert_eq!(a.move_from(b, 2, 3), 1);\n         assert!(a == [7,2,3,4]);\n         let mut a = [1,2,3,4,5];\n-        let b = ~[5,6,7,8,9,0];\n+        let b = box [5,6,7,8,9,0];\n         assert_eq!(a.mut_slice(2,4).move_from(b,1,6), 2);\n         assert!(a == [1,2,6,7,5]);\n     }\n@@ -3453,11 +3454,11 @@ mod tests {\n                 assert_eq!(format!(\"{}\", x.as_slice()), x_str);\n             })\n         )\n-        let empty: ~[int] = ~[];\n+        let empty: ~[int] = box [];\n         test_show_vec!(empty, \"[]\".to_owned());\n-        test_show_vec!(~[1], \"[1]\".to_owned());\n-        test_show_vec!(~[1, 2, 3], \"[1, 2, 3]\".to_owned());\n-        test_show_vec!(~[~[], ~[1u], ~[1u, 1u]], \"[[], [1], [1, 1]]\".to_owned());\n+        test_show_vec!(box [1], \"[1]\".to_owned());\n+        test_show_vec!(box [1, 2, 3], \"[1, 2, 3]\".to_owned());\n+        test_show_vec!(box [box [], box [1u], box [1u, 1u]], \"[[], [1], [1, 1]]\".to_owned());\n \n         let empty_mut: &mut [int] = &mut[];\n         test_show_vec!(empty_mut, \"[]\".to_owned());\n@@ -3890,7 +3891,7 @@ mod bench {\n     #[bench]\n     fn zero_1kb_fixed_repeat(b: &mut Bencher) {\n         b.iter(|| {\n-            ~[0u8, ..1024]\n+            box [0u8, ..1024]\n         });\n     }\n "}, {"sha": "430f63263271ce7589e3aeb145990801bfb6bb67", "filename": "src/libstd/str.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -137,7 +137,7 @@ impl FromStr for ~str {\n /// Fails if invalid UTF-8\n pub fn from_byte(b: u8) -> ~str {\n     assert!(b < 128u8);\n-    unsafe { ::cast::transmute(~[b]) }\n+    unsafe { ::cast::transmute(box [b]) }\n }\n \n /// Convert a char to a string\n@@ -1387,7 +1387,7 @@ pub mod raw {\n     }\n \n     /// Converts a byte to a string.\n-    pub unsafe fn from_byte(u: u8) -> ~str { from_utf8_owned(~[u]) }\n+    pub unsafe fn from_byte(u: u8) -> ~str { from_utf8_owned(box [u]) }\n \n     /// Form a slice from a C string. Unsafe because the caller must ensure the\n     /// C string has the static lifetime, or else the return value may be\n@@ -1448,7 +1448,7 @@ pub mod raw {\n     #[test]\n     fn test_from_buf_len() {\n         unsafe {\n-            let a = ~[65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n+            let a = box [65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 65u8, 0u8];\n             let b = a.as_ptr();\n             let c = from_buf_len(b, 3u);\n             assert_eq!(c, \"AAA\".to_owned());\n@@ -3342,7 +3342,7 @@ mod tests {\n     #[test]\n     fn test_raw_from_c_str() {\n         unsafe {\n-            let a = ~[65, 65, 65, 65, 65, 65, 65, 0];\n+            let a = box [65, 65, 65, 65, 65, 65, 65, 0];\n             let b = a.as_ptr();\n             let c = raw::from_c_str(b);\n             assert_eq!(c, \"AAAAAAA\".to_owned());\n@@ -3456,21 +3456,21 @@ mod tests {\n     fn test_utf16() {\n         let pairs =\n             [(\"\ud800\udf45\ud800\udf3f\ud800\udf3b\ud800\udf46\ud800\udf39\ud800\udf3b\ud800\udf30\\n\".to_owned(),\n-              ~[0xd800_u16, 0xdf45_u16, 0xd800_u16, 0xdf3f_u16,\n+              box [0xd800_u16, 0xdf45_u16, 0xd800_u16, 0xdf3f_u16,\n                 0xd800_u16, 0xdf3b_u16, 0xd800_u16, 0xdf46_u16,\n                 0xd800_u16, 0xdf39_u16, 0xd800_u16, 0xdf3b_u16,\n                 0xd800_u16, 0xdf30_u16, 0x000a_u16]),\n \n              (\"\ud801\udc12\ud801\udc49\ud801\udc2e\ud801\udc40\ud801\udc32\ud801\udc4b \ud801\udc0f\ud801\udc32\ud801\udc4d\\n\".to_owned(),\n-              ~[0xd801_u16, 0xdc12_u16, 0xd801_u16,\n+              box [0xd801_u16, 0xdc12_u16, 0xd801_u16,\n                 0xdc49_u16, 0xd801_u16, 0xdc2e_u16, 0xd801_u16,\n                 0xdc40_u16, 0xd801_u16, 0xdc32_u16, 0xd801_u16,\n                 0xdc4b_u16, 0x0020_u16, 0xd801_u16, 0xdc0f_u16,\n                 0xd801_u16, 0xdc32_u16, 0xd801_u16, 0xdc4d_u16,\n                 0x000a_u16]),\n \n              (\"\ud800\udf00\ud800\udf16\ud800\udf0b\ud800\udf04\ud800\udf11\ud800\udf09\u00b7\ud800\udf0c\ud800\udf04\ud800\udf15\ud800\udf04\ud800\udf0b\ud800\udf09\ud800\udf11\\n\".to_owned(),\n-              ~[0xd800_u16, 0xdf00_u16, 0xd800_u16, 0xdf16_u16,\n+              box [0xd800_u16, 0xdf00_u16, 0xd800_u16, 0xdf16_u16,\n                 0xd800_u16, 0xdf0b_u16, 0xd800_u16, 0xdf04_u16,\n                 0xd800_u16, 0xdf11_u16, 0xd800_u16, 0xdf09_u16,\n                 0x00b7_u16, 0xd800_u16, 0xdf0c_u16, 0xd800_u16,\n@@ -3479,7 +3479,7 @@ mod tests {\n                 0xdf09_u16, 0xd800_u16, 0xdf11_u16, 0x000a_u16 ]),\n \n              (\"\ud801\udc8b\ud801\udc98\ud801\udc88\ud801\udc91\ud801\udc9b\ud801\udc92 \ud801\udc95\ud801\udc93 \ud801\udc88\ud801\udc9a\ud801\udc8d \ud801\udc8f\ud801\udc9c\ud801\udc92\ud801\udc96\ud801\udc86 \ud801\udc95\ud801\udc86\\n\".to_owned(),\n-              ~[0xd801_u16, 0xdc8b_u16, 0xd801_u16, 0xdc98_u16,\n+              box [0xd801_u16, 0xdc8b_u16, 0xd801_u16, 0xdc98_u16,\n                 0xd801_u16, 0xdc88_u16, 0xd801_u16, 0xdc91_u16,\n                 0xd801_u16, 0xdc9b_u16, 0xd801_u16, 0xdc92_u16,\n                 0x0020_u16, 0xd801_u16, 0xdc95_u16, 0xd801_u16,\n@@ -3492,7 +3492,7 @@ mod tests {\n                 0x000a_u16 ]),\n              // Issue #12318, even-numbered non-BMP planes\n              (\"\\U00020000\".to_owned(),\n-              ~[0xD840, 0xDC00])];\n+              box [0xD840, 0xDC00])];\n \n         for p in pairs.iter() {\n             let (s, u) = (*p).clone();\n@@ -3558,7 +3558,7 @@ mod tests {\n     #[test]\n     fn test_char_at() {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_owned();\n-        let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n+        let v = box ['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n         let mut pos = 0;\n         for ch in v.iter() {\n             assert!(s.char_at(pos) == *ch);\n@@ -3569,7 +3569,7 @@ mod tests {\n     #[test]\n     fn test_char_at_reverse() {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_owned();\n-        let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n+        let v = box ['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n         let mut pos = s.len();\n         for ch in v.iter().rev() {\n             assert!(s.char_at_reverse(pos) == *ch);\n@@ -3652,7 +3652,7 @@ mod tests {\n     fn test_iterator() {\n         use iter::*;\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_owned();\n-        let v = ~['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n+        let v = box ['\u0e28','\u0e44','\u0e17','\u0e22','\u4e2d','\u534e','V','i','\u1ec7','t',' ','N','a','m'];\n \n         let mut pos = 0;\n         let mut it = s.chars();\n@@ -3668,7 +3668,7 @@ mod tests {\n     fn test_rev_iterator() {\n         use iter::*;\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".to_owned();\n-        let v = ~['m', 'a', 'N', ' ', 't', '\u1ec7','i','V','\u534e','\u4e2d','\u0e22','\u0e17','\u0e44','\u0e28'];\n+        let v = box ['m', 'a', 'N', ' ', 't', '\u1ec7','i','V','\u534e','\u4e2d','\u0e22','\u0e17','\u0e44','\u0e28'];\n \n         let mut pos = 0;\n         let mut it = s.chars().rev();\n@@ -3761,51 +3761,51 @@ mod tests {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n         let split: ~[&str] = data.split(' ').collect();\n-        assert_eq!( split, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+        assert_eq!( split, box [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n         let mut rsplit: ~[&str] = data.split(' ').rev().collect();\n         rsplit.reverse();\n-        assert_eq!(rsplit, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+        assert_eq!(rsplit, box [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n         let split: ~[&str] = data.split(|c: char| c == ' ').collect();\n-        assert_eq!( split, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+        assert_eq!( split, box [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n         let mut rsplit: ~[&str] = data.split(|c: char| c == ' ').rev().collect();\n         rsplit.reverse();\n-        assert_eq!(rsplit, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+        assert_eq!(rsplit, box [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n         // Unicode\n         let split: ~[&str] = data.split('\u00e4').collect();\n-        assert_eq!( split, ~[\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+        assert_eq!( split, box [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n         let mut rsplit: ~[&str] = data.split('\u00e4').rev().collect();\n         rsplit.reverse();\n-        assert_eq!(rsplit, ~[\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+        assert_eq!(rsplit, box [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n         let split: ~[&str] = data.split(|c: char| c == '\u00e4').collect();\n-        assert_eq!( split, ~[\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+        assert_eq!( split, box [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n         let mut rsplit: ~[&str] = data.split(|c: char| c == '\u00e4').rev().collect();\n         rsplit.reverse();\n-        assert_eq!(rsplit, ~[\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+        assert_eq!(rsplit, box [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n     }\n \n     #[test]\n     fn test_splitn_char_iterator() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n         let split: ~[&str] = data.splitn(' ', 3).collect();\n-        assert_eq!(split, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n+        assert_eq!(split, box [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n \n         let split: ~[&str] = data.splitn(|c: char| c == ' ', 3).collect();\n-        assert_eq!(split, ~[\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n+        assert_eq!(split, box [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n \n         // Unicode\n         let split: ~[&str] = data.splitn('\u00e4', 3).collect();\n-        assert_eq!(split, ~[\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n+        assert_eq!(split, box [\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n \n         let split: ~[&str] = data.splitn(|c: char| c == '\u00e4', 3).collect();\n-        assert_eq!(split, ~[\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n+        assert_eq!(split, box [\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n     }\n \n     #[test]\n@@ -3814,31 +3814,31 @@ mod tests {\n \n         let mut split: ~[&str] = data.rsplitn(' ', 3).collect();\n         split.reverse();\n-        assert_eq!(split, ~[\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+        assert_eq!(split, box [\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n         let mut split: ~[&str] = data.rsplitn(|c: char| c == ' ', 3).collect();\n         split.reverse();\n-        assert_eq!(split, ~[\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+        assert_eq!(split, box [\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n         // Unicode\n         let mut split: ~[&str] = data.rsplitn('\u00e4', 3).collect();\n         split.reverse();\n-        assert_eq!(split, ~[\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+        assert_eq!(split, box [\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n         let mut split: ~[&str] = data.rsplitn(|c: char| c == '\u00e4', 3).collect();\n         split.reverse();\n-        assert_eq!(split, ~[\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+        assert_eq!(split, box [\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n     }\n \n     #[test]\n     fn test_split_char_iterator_no_trailing() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n         let split: ~[&str] = data.split('\\n').collect();\n-        assert_eq!(split, ~[\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n+        assert_eq!(split, box [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n \n         let split: ~[&str] = data.split_terminator('\\n').collect();\n-        assert_eq!(split, ~[\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n+        assert_eq!(split, box [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n     }\n \n     #[test]\n@@ -3847,18 +3847,18 @@ mod tests {\n \n         let mut split: ~[&str] = data.split('\\n').rev().collect();\n         split.reverse();\n-        assert_eq!(split, ~[\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n+        assert_eq!(split, box [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n \n         let mut split: ~[&str] = data.split_terminator('\\n').rev().collect();\n         split.reverse();\n-        assert_eq!(split, ~[\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n+        assert_eq!(split, box [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n     }\n \n     #[test]\n     fn test_words() {\n         let data = \"\\n \\tM\u00e4ry   h\u00e4d\\t\u00e4  little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n         let words: ~[&str] = data.words().collect();\n-        assert_eq!(words, ~[\"M\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\", \"Little\", \"l\u00e4mb\"])\n+        assert_eq!(words, box [\"M\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\", \"Little\", \"l\u00e4mb\"])\n     }\n \n     #[test]\n@@ -3893,11 +3893,11 @@ mod tests {\n     fn test_lines() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n         let lines: ~[&str] = data.lines().collect();\n-        assert_eq!(lines, ~[\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n+        assert_eq!(lines, box [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n \n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\"; // no trailing \\n\n         let lines: ~[&str] = data.lines().collect();\n-        assert_eq!(lines, ~[\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n+        assert_eq!(lines, box [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n     }\n \n     #[test]\n@@ -3906,20 +3906,20 @@ mod tests {\n             let v: ~[&str] = s.split_str(sep).collect();\n             assert_eq!(v, u);\n         }\n-        t(\"--1233345--\", \"12345\", ~[\"--1233345--\"]);\n-        t(\"abc::hello::there\", \"::\", ~[\"abc\", \"hello\", \"there\"]);\n-        t(\"::hello::there\", \"::\", ~[\"\", \"hello\", \"there\"]);\n-        t(\"hello::there::\", \"::\", ~[\"hello\", \"there\", \"\"]);\n-        t(\"::hello::there::\", \"::\", ~[\"\", \"hello\", \"there\", \"\"]);\n-        t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", \"\u4e2d\u534e\", ~[\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\", \"Vi\u1ec7t Nam\"]);\n-        t(\"zzXXXzzYYYzz\", \"zz\", ~[\"\", \"XXX\", \"YYY\", \"\"]);\n-        t(\"zzXXXzYYYz\", \"XXX\", ~[\"zz\", \"zYYYz\"]);\n-        t(\".XXX.YYY.\", \".\", ~[\"\", \"XXX\", \"YYY\", \"\"]);\n-        t(\"\", \".\", ~[\"\"]);\n-        t(\"zz\", \"zz\", ~[\"\",\"\"]);\n-        t(\"ok\", \"z\", ~[\"ok\"]);\n-        t(\"zzz\", \"zz\", ~[\"\",\"z\"]);\n-        t(\"zzzzz\", \"zz\", ~[\"\",\"\",\"z\"]);\n+        t(\"--1233345--\", \"12345\", box [\"--1233345--\"]);\n+        t(\"abc::hello::there\", \"::\", box [\"abc\", \"hello\", \"there\"]);\n+        t(\"::hello::there\", \"::\", box [\"\", \"hello\", \"there\"]);\n+        t(\"hello::there::\", \"::\", box [\"hello\", \"there\", \"\"]);\n+        t(\"::hello::there::\", \"::\", box [\"\", \"hello\", \"there\", \"\"]);\n+        t(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\", \"\u4e2d\u534e\", box [\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\", \"Vi\u1ec7t Nam\"]);\n+        t(\"zzXXXzzYYYzz\", \"zz\", box [\"\", \"XXX\", \"YYY\", \"\"]);\n+        t(\"zzXXXzYYYz\", \"XXX\", box [\"zz\", \"zYYYz\"]);\n+        t(\".XXX.YYY.\", \".\", box [\"\", \"XXX\", \"YYY\", \"\"]);\n+        t(\"\", \".\", box [\"\"]);\n+        t(\"zz\", \"zz\", box [\"\",\"\"]);\n+        t(\"ok\", \"z\", box [\"ok\"]);\n+        t(\"zzz\", \"zz\", box [\"\",\"z\"]);\n+        t(\"zzzzz\", \"zz\", box [\"\",\"\",\"z\"]);\n     }\n \n     #[test]"}, {"sha": "0cf975a4c1c96feef2173b91f7fa104643dae623", "filename": "src/libstd/sync/arc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Farc.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -45,7 +45,7 @@ struct ArcData<T> {\n }\n \n unsafe fn new_inner<T: Send>(data: T, refcount: uint) -> *mut ArcData<T> {\n-    let data = ~ArcData {\n+    let data = box ArcData {\n                     count: AtomicUint::new(refcount),\n                     data: Unsafe::new(data)\n                  };\n@@ -71,7 +71,7 @@ impl<T: Send> UnsafeArc<T> {\n     pub fn newN(data: T, num_handles: uint) -> ~[UnsafeArc<T>] {\n         unsafe {\n             if num_handles == 0 {\n-                ~[] // need to free data here\n+                box [] // need to free data here\n             } else {\n                 let ptr = new_inner(data, num_handles);\n                 let v = Vec::from_fn(num_handles, |_| UnsafeArc { data: ptr });"}, {"sha": "a3c1c33f77c539490db6e21c608dcf5b2a60f367", "filename": "src/libstd/sync/atomics.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fsync%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fsync%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fatomics.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -894,36 +894,36 @@ mod test {\n \n     #[test]\n     fn option_swap() {\n-        let p = AtomicOption::new(~1);\n-        let a = ~2;\n+        let p = AtomicOption::new(box 1);\n+        let a = box 2;\n \n         let b = p.swap(a, SeqCst);\n \n-        assert_eq!(b, Some(~1));\n-        assert_eq!(p.take(SeqCst), Some(~2));\n+        assert_eq!(b, Some(box 1));\n+        assert_eq!(p.take(SeqCst), Some(box 2));\n     }\n \n     #[test]\n     fn option_take() {\n-        let p = AtomicOption::new(~1);\n+        let p = AtomicOption::new(box 1);\n \n-        assert_eq!(p.take(SeqCst), Some(~1));\n+        assert_eq!(p.take(SeqCst), Some(box 1));\n         assert_eq!(p.take(SeqCst), None);\n \n-        let p2 = ~2;\n+        let p2 = box 2;\n         p.swap(p2, SeqCst);\n \n-        assert_eq!(p.take(SeqCst), Some(~2));\n+        assert_eq!(p.take(SeqCst), Some(box 2));\n     }\n \n     #[test]\n     fn option_fill() {\n-        let p = AtomicOption::new(~1);\n-        assert!(p.fill(~2, SeqCst).is_some()); // should fail; shouldn't leak!\n-        assert_eq!(p.take(SeqCst), Some(~1));\n+        let p = AtomicOption::new(box 1);\n+        assert!(p.fill(box 2, SeqCst).is_some()); // should fail; shouldn't leak!\n+        assert_eq!(p.take(SeqCst), Some(box 1));\n \n-        assert!(p.fill(~2, SeqCst).is_none()); // shouldn't fail\n-        assert_eq!(p.take(SeqCst), Some(~2));\n+        assert!(p.fill(box 2, SeqCst).is_none()); // shouldn't fail\n+        assert_eq!(p.take(SeqCst), Some(box 2));\n     }\n \n     #[test]"}, {"sha": "22ed66b708b7e340cfc8391186be75e2d45467f9", "filename": "src/libstd/sync/deque.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fsync%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fsync%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fdeque.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -159,7 +159,7 @@ impl<T: Send> BufferPool<T> {\n             self.pool.with(|pool| {\n                 match pool.iter().position(|x| x.size() >= (1 << bits)) {\n                     Some(i) => pool.remove(i).unwrap(),\n-                    None => ~Buffer::new(bits)\n+                    None => box Buffer::new(bits)\n                 }\n             })\n         }\n@@ -314,7 +314,7 @@ impl<T: Send> Deque<T> {\n     // continue to be read after we flag this buffer for reclamation.\n     unsafe fn swap_buffer(&mut self, b: int, old: *mut Buffer<T>,\n                           buf: Buffer<T>) -> *mut Buffer<T> {\n-        let newbuf: *mut Buffer<T> = cast::transmute(~buf);\n+        let newbuf: *mut Buffer<T> = cast::transmute(box buf);\n         self.array.store(newbuf, SeqCst);\n         let ss = (*newbuf).size();\n         self.bottom.store(b + ss, SeqCst);\n@@ -474,7 +474,7 @@ mod tests {\n     fn stampede(mut w: Worker<~int>, s: Stealer<~int>,\n                 nthreads: int, amt: uint) {\n         for _ in range(0, amt) {\n-            w.push(~20);\n+            w.push(box 20);\n         }\n         let mut remaining = AtomicUint::new(amt);\n         let unsafe_remaining: *mut AtomicUint = &mut remaining;\n@@ -603,7 +603,7 @@ mod tests {\n \n         let (threads, hits) = slice::unzip(range(0, NTHREADS).map(|_| {\n             let s = s.clone();\n-            let unique_box = ~AtomicUint::new(0);\n+            let unique_box = box AtomicUint::new(0);\n             let thread_box = unsafe {\n                 *cast::transmute::<&~AtomicUint,**mut AtomicUint>(&unique_box)\n             };"}, {"sha": "315e412446d6b329348e7af3df92b7eea6e8e3cd", "filename": "src/libstd/sync/mpsc_queue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fsync%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fsync%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc_queue.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -73,7 +73,7 @@ pub struct Queue<T> {\n \n impl<T> Node<T> {\n     unsafe fn new(v: Option<T>) -> *mut Node<T> {\n-        cast::transmute(~Node {\n+        cast::transmute(box Node {\n             next: AtomicPtr::new(0 as *mut Node<T>),\n             value: v,\n         })\n@@ -163,8 +163,8 @@ mod tests {\n     #[test]\n     fn test_full() {\n         let mut q = Queue::new();\n-        q.push(~1);\n-        q.push(~2);\n+        q.push(box 1);\n+        q.push(box 2);\n     }\n \n     #[test]"}, {"sha": "f155bdca446464b6fb1d7cbc64e6a7518e4ca790", "filename": "src/libstd/sync/spsc_queue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fsync%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fsync%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fspsc_queue.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -73,7 +73,7 @@ pub struct Queue<T> {\n impl<T: Send> Node<T> {\n     fn new() -> *mut Node<T> {\n         unsafe {\n-            cast::transmute(~Node {\n+            cast::transmute(box Node {\n                 value: None,\n                 next: AtomicPtr::new(0 as *mut Node<T>),\n             })\n@@ -247,8 +247,8 @@ mod test {\n     #[test]\n     fn drop_full() {\n         let mut q = Queue::new(0);\n-        q.push(~1);\n-        q.push(~2);\n+        q.push(box 1);\n+        q.push(box 2);\n     }\n \n     #[test]"}, {"sha": "e9b01063f94c1739009e9b390bc6f3565ac7fd4b", "filename": "src/libstd/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -418,7 +418,7 @@ fn test_spawn_sched_childs_on_default_sched() {\n fn avoid_copying_the_body(spawnfn: |v: proc():Send|) {\n     let (tx, rx) = channel::<uint>();\n \n-    let x = ~1;\n+    let x = box 1;\n     let x_in_parent = (&*x) as *int as uint;\n \n     spawnfn(proc() {\n@@ -507,7 +507,7 @@ fn test_try_fail_message_owned_str() {\n #[test]\n fn test_try_fail_message_any() {\n     match try(proc() {\n-        fail!(~413u16 as ~Any:Send);\n+        fail!(box 413u16 as ~Any:Send);\n     }) {\n         Err(e) => {\n             type T = ~Any:Send;"}, {"sha": "bdeae0340e29ea387f4d0ce4669e9e6ec88a6394", "filename": "src/libstd/to_str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_str.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -51,11 +51,11 @@ mod tests {\n \n     #[test]\n     fn test_vectors() {\n-        let x: ~[int] = ~[];\n+        let x: ~[int] = box [];\n         assert_eq!(x.to_str(), \"[]\".to_owned());\n-        assert_eq!((~[1]).to_str(), \"[1]\".to_owned());\n-        assert_eq!((~[1, 2, 3]).to_str(), \"[1, 2, 3]\".to_owned());\n-        assert!((~[~[], ~[1], ~[1, 1]]).to_str() ==\n+        assert_eq!((box [1]).to_str(), \"[1]\".to_owned());\n+        assert_eq!((box [1, 2, 3]).to_str(), \"[1, 2, 3]\".to_owned());\n+        assert!((box [box [], box [1], box [1, 1]]).to_str() ==\n                \"[[], [1], [1, 1]]\".to_owned());\n     }\n }"}, {"sha": "68f0aaab05b1b034075d23b691fb6911632ea318", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -72,7 +72,7 @@ impl DynamicLibrary {\n         } else {\n             (\"LD_LIBRARY_PATH\", ':' as u8)\n         };\n-        let newenv = os::getenv_as_bytes(envvar).unwrap_or(~[]);\n+        let newenv = os::getenv_as_bytes(envvar).unwrap_or(box []);\n         let newenv = newenv + &[sep] + path.as_vec();\n         os::setenv(envvar, str::from_utf8(newenv).unwrap());\n     }"}, {"sha": "372fcc396b13a4e9374f2c405adfc1f135df5fce", "filename": "src/libstd/unstable/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Funstable%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Funstable%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmod.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -44,9 +44,9 @@ fn test_run_in_bare_thread() {\n #[test]\n fn test_run_in_bare_thread_exchange() {\n     // Does the exchange heap work without the runtime?\n-    let i = ~100;\n+    let i = box 100;\n     run_in_bare_thread(proc() {\n-        assert!(i == ~100);\n+        assert!(i == box 100);\n     });\n }\n "}, {"sha": "5be10fc27dfe551af129b0f9ab46d66a31c51720", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -120,7 +120,7 @@ mod tests {\n             let num_tasks = 10;\n             let count = 10;\n \n-            let total = Exclusive::new(~0);\n+            let total = Exclusive::new(box 0);\n \n             for _ in range(0u, num_tasks) {\n                 let total = total.clone();"}, {"sha": "e264615578e42a70ac6502078a2817a71ff9a385", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -1585,8 +1585,8 @@ mod tests {\n     #[test]\n     fn test_clone_from() {\n         let mut v = vec!();\n-        let three = vec!(~1, ~2, ~3);\n-        let two = vec!(~4, ~5);\n+        let three = vec!(box 1, box 2, box 3);\n+        let two = vec!(box 4, box 5);\n         // zero, long\n         v.clone_from(&three);\n         assert_eq!(v, three);"}, {"sha": "b5c660759522eab96d0407fa8c5a953ca0a73f3f", "filename": "src/libsync/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Farc.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -70,7 +70,7 @@ impl<T: Share + Send> Arc<T> {\n     pub fn new(data: T) -> Arc<T> {\n         // Start the weak pointer count as 1 which is the weak pointer that's\n         // held by all the strong pointers (kinda), see std/rc.rs for more info\n-        let x = ~ArcInner {\n+        let x = box ArcInner {\n             strong: atomics::AtomicUint::new(1),\n             weak: atomics::AtomicUint::new(1),\n             data: data,"}, {"sha": "6ab833a19efbd7d2e41537d82eb2bb1fa080a71b", "filename": "src/libsync/raw.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsync%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsync%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fraw.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -109,7 +109,7 @@ struct SemGuard<'a, Q> {\n impl<Q: Send> Sem<Q> {\n     fn new(count: int, q: Q) -> Sem<Q> {\n         let inner = unsafe {\n-            cast::transmute(~SemInner {\n+            cast::transmute(box SemInner {\n                 waiters: WaitQueue::new(),\n                 count: count,\n                 blocked: q,\n@@ -726,7 +726,7 @@ mod tests {\n         let (tx, rx) = channel();\n         let m = Arc::new(Mutex::new());\n         let m2 = m.clone();\n-        let mut sharedstate = ~0;\n+        let mut sharedstate = box 0;\n         {\n             let ptr: *mut int = &mut *sharedstate;\n             task::spawn(proc() {\n@@ -895,7 +895,7 @@ mod tests {\n         // mutex mutual exclusion test, a ways above.\n         let (tx, rx) = channel();\n         let x2 = x.clone();\n-        let mut sharedstate = ~0;\n+        let mut sharedstate = box 0;\n         {\n             let ptr: *int = &*sharedstate;\n             task::spawn(proc() {"}, {"sha": "f09072e0bc605aa374bd1f0e359d6009d2d68ae7", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -177,7 +177,7 @@ pub fn mk_span_handler(handler: Handler, cm: codemap::CodeMap) -> SpanHandler {\n }\n \n pub fn default_handler() -> Handler {\n-    mk_handler(~EmitterWriter::stderr())\n+    mk_handler(box EmitterWriter::stderr())\n }\n \n pub fn mk_handler(e: ~Emitter:Send) -> Handler {\n@@ -262,11 +262,11 @@ impl EmitterWriter {\n         if stderr.get_ref().isatty() {\n             let dst = match term::Terminal::new(stderr.unwrap()) {\n                 Ok(t) => Terminal(t),\n-                Err(..) => Raw(~io::stderr()),\n+                Err(..) => Raw(box io::stderr()),\n             };\n             EmitterWriter { dst: dst }\n         } else {\n-            EmitterWriter { dst: Raw(~stderr) }\n+            EmitterWriter { dst: Raw(box stderr) }\n         }\n     }\n "}, {"sha": "cee6216b23fdd52047b50fea716e4ee65d3ded3c", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -131,7 +131,7 @@ pub struct MacExpr {\n }\n impl MacExpr {\n     pub fn new(e: @ast::Expr) -> ~MacResult {\n-        ~MacExpr { e: e } as ~MacResult\n+        box MacExpr { e: e } as ~MacResult\n     }\n }\n impl MacResult for MacExpr {\n@@ -145,7 +145,7 @@ pub struct MacItem {\n }\n impl MacItem {\n     pub fn new(i: @ast::Item) -> ~MacResult {\n-        ~MacItem { i: i } as ~MacResult\n+        box MacItem { i: i } as ~MacResult\n     }\n }\n impl MacResult for MacItem {\n@@ -174,7 +174,7 @@ impl DummyResult {\n     /// Use this as a return value after hitting any errors and\n     /// calling `span_err`.\n     pub fn any(sp: Span) -> ~MacResult {\n-        ~DummyResult { expr_only: false, span: sp } as ~MacResult\n+        box DummyResult { expr_only: false, span: sp } as ~MacResult\n     }\n \n     /// Create a default MacResult that can only be an expression.\n@@ -183,7 +183,7 @@ impl DummyResult {\n     /// if an error is encountered internally, the user will recieve\n     /// an error that they also used it in the wrong place.\n     pub fn expr(sp: Span) -> ~MacResult {\n-        ~DummyResult { expr_only: true, span: sp } as ~MacResult\n+        box DummyResult { expr_only: true, span: sp } as ~MacResult\n     }\n \n     /// A plain dummy expression.\n@@ -262,7 +262,7 @@ pub type RenameList = Vec<(ast::Ident, Name)>;\n pub fn syntax_expander_table() -> SyntaxEnv {\n     // utility function to simplify creating NormalTT syntax extensions\n     fn builtin_normal_expander(f: MacroExpanderFn) -> SyntaxExtension {\n-        NormalTT(~BasicMacroExpander {\n+        NormalTT(box BasicMacroExpander {\n                 expander: f,\n                 span: None,\n             },\n@@ -271,7 +271,7 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n \n     let mut syntax_expanders = SyntaxEnv::new();\n     syntax_expanders.insert(intern(\"macro_rules\"),\n-                            IdentTT(~BasicIdentMacroExpander {\n+                            IdentTT(box BasicIdentMacroExpander {\n                                 expander: ext::tt::macro_rules::add_new_extension,\n                                 span: None,\n                             },"}, {"sha": "2447535f1f3d88fbd5de91c4f98321652a223d09", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -31,25 +31,26 @@ pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n         span: span,\n         attributes: Vec::new(),\n         path: Path::new_(vec!(\"serialize\", \"Decodable\"), None,\n-                         vec!(~Literal(Path::new_local(\"__D\")),\n-                              ~Literal(Path::new_local(\"__E\"))), true),\n+                         vec!(box Literal(Path::new_local(\"__D\")),\n+                              box Literal(Path::new_local(\"__E\"))), true),\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds {\n             lifetimes: Vec::new(),\n             bounds: vec!((\"__D\", ast::StaticSize, vec!(Path::new_(\n                             vec!(\"serialize\", \"Decoder\"), None,\n-                            vec!(~Literal(Path::new_local(\"__E\"))), true))),\n+                            vec!(box Literal(Path::new_local(\"__E\"))), true))),\n                          (\"__E\", ast::StaticSize, vec!()))\n         },\n         methods: vec!(\n             MethodDef {\n                 name: \"decode\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: None,\n-                args: vec!(Ptr(~Literal(Path::new_local(\"__D\")),\n+                args: vec!(Ptr(box Literal(Path::new_local(\"__D\")),\n                             Borrowed(None, MutMutable))),\n                 ret_ty: Literal(Path::new_(vec!(\"std\", \"result\", \"Result\"), None,\n-                                          vec!(~Self, ~Literal(Path::new_local(\"__E\"))), true)),\n+                                          vec!(box Self,\n+                                               box Literal(Path::new_local(\"__E\"))), true)),\n                 attributes: Vec::new(),\n                 const_nonmatching: true,\n                 combine_substructure: combine_substructure(|a, b, c| {"}, {"sha": "75b051b2f1086b109f60960feb797d01905d0142", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -99,27 +99,27 @@ pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n         span: span,\n         attributes: Vec::new(),\n         path: Path::new_(vec!(\"serialize\", \"Encodable\"), None,\n-                         vec!(~Literal(Path::new_local(\"__S\")),\n-                              ~Literal(Path::new_local(\"__E\"))), true),\n+                         vec!(box Literal(Path::new_local(\"__S\")),\n+                              box Literal(Path::new_local(\"__E\"))), true),\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds {\n             lifetimes: Vec::new(),\n             bounds: vec!((\"__S\", ast::StaticSize, vec!(Path::new_(\n                             vec!(\"serialize\", \"Encoder\"), None,\n-                            vec!(~Literal(Path::new_local(\"__E\"))), true))),\n+                            vec!(box Literal(Path::new_local(\"__E\"))), true))),\n                          (\"__E\", ast::StaticSize, vec!()))\n         },\n         methods: vec!(\n             MethodDef {\n                 name: \"encode\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: vec!(Ptr(~Literal(Path::new_local(\"__S\")),\n+                args: vec!(Ptr(box Literal(Path::new_local(\"__S\")),\n                             Borrowed(None, MutMutable))),\n                 ret_ty: Literal(Path::new_(vec!(\"std\", \"result\", \"Result\"),\n                                            None,\n-                                           vec!(~Tuple(Vec::new()),\n-                                                ~Literal(Path::new_local(\"__E\"))),\n+                                           vec!(box Tuple(Vec::new()),\n+                                                box Literal(Path::new_local(\"__E\"))),\n                                            true)),\n                 attributes: Vec::new(),\n                 const_nonmatching: true,"}, {"sha": "8ce98a04e287af6eb2d3fa00456a3270c12a658b", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -24,7 +24,7 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n \n     let (path, generics, args) = if cx.ecfg.deriving_hash_type_parameter {\n         (Path::new_(vec!(\"std\", \"hash\", \"Hash\"), None,\n-                    vec!(~Literal(Path::new_local(\"__S\"))), true),\n+                    vec!(box Literal(Path::new_local(\"__S\"))), true),\n          LifetimeBounds {\n              lifetimes: Vec::new(),\n              bounds: vec!((\"__S\", ast::StaticSize, vec!(Path::new(vec!(\"std\", \"io\", \"Writer\"))))),\n@@ -48,7 +48,7 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n                 name: \"hash\",\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n-                args: vec!(Ptr(~Literal(args), Borrowed(None, MutMutable))),\n+                args: vec!(Ptr(box Literal(args), Borrowed(None, MutMutable))),\n                 ret_ty: nil_ty(),\n                 attributes: attrs,\n                 const_nonmatching: false,"}, {"sha": "5066a395b415f073e0eba0478a918174d0b448a9", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -38,7 +38,7 @@ pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n                     Literal(Path::new(vec!(\"i64\")))),\n                 ret_ty: Literal(Path::new_(vec!(\"std\", \"option\", \"Option\"),\n                                            None,\n-                                           vec!(~Self),\n+                                           vec!(box Self),\n                                            true)),\n                 // #[inline] liable to cause code-bloat\n                 attributes: attrs.clone(),\n@@ -55,7 +55,7 @@ pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n                     Literal(Path::new(vec!(\"u64\")))),\n                 ret_ty: Literal(Path::new_(vec!(\"std\", \"option\", \"Option\"),\n                                            None,\n-                                           vec!(~Self),\n+                                           vec!(box Self),\n                                            true)),\n                 // #[inline] liable to cause code-bloat\n                 attributes: attrs,"}, {"sha": "397b99925c8ec6a33e57e350f7d1dd3c65bddc3f", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -37,7 +37,7 @@ pub fn expand_deriving_rand(cx: &mut ExtCtxt,\n                 },\n                 explicit_self: None,\n                 args: vec!(\n-                    Ptr(~Literal(Path::new_local(\"R\")),\n+                    Ptr(box Literal(Path::new_local(\"R\")),\n                         Borrowed(None, ast::MutMutable))\n                 ),\n                 ret_ty: Self,"}, {"sha": "aeaf53a193904b7e1f5330db0b73b5fd47c0d33a", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -26,7 +26,7 @@ pub fn expand_deriving_show(cx: &mut ExtCtxt,\n                             item: @Item,\n                             push: |@Item|) {\n     // &mut ::std::fmt::Formatter\n-    let fmtr = Ptr(~Literal(Path::new(vec!(\"std\", \"fmt\", \"Formatter\"))),\n+    let fmtr = Ptr(box Literal(Path::new(vec!(\"std\", \"fmt\", \"Formatter\"))),\n                    Borrowed(None, ast::MutMutable));\n \n     let trait_def = TraitDef {"}, {"sha": "769bbe2fc4e2f457a6ab275ccca6f5f039363a4e", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -101,7 +101,7 @@ pub fn borrowed_explicit_self<'r>() -> Option<Option<PtrTy<'r>>> {\n }\n \n pub fn borrowed_self<'r>() -> Ty<'r> {\n-    borrowed(~Self)\n+    borrowed(box Self)\n }\n \n pub fn nil_ty() -> Ty<'static> {"}, {"sha": "4c426bef12e5ba3bd20c86cef1a377bf3b628173", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -134,7 +134,7 @@ pub fn initial_matcher_pos(ms: Vec<Matcher> , sep: Option<Token>, lo: BytePos)\n         }\n     }\n     let matches = Vec::from_fn(count_names(ms.as_slice()), |_i| Vec::new());\n-    ~MatcherPos {\n+    box MatcherPos {\n         elts: ms,\n         sep: sep,\n         idx: 0u,\n@@ -334,7 +334,7 @@ pub fn parse(sess: &ParseSess,\n \n                     let matches = Vec::from_elem(ei.matches.len(), Vec::new());\n                     let ei_t = ei;\n-                    cur_eis.push(~MatcherPos {\n+                    cur_eis.push(box MatcherPos {\n                         elts: (*matchers).clone(),\n                         sep: (*sep).clone(),\n                         idx: 0u,\n@@ -396,7 +396,7 @@ pub fn parse(sess: &ParseSess,\n                 }\n                 rdr.next_token();\n             } else /* bb_eis.len() == 1 */ {\n-                let mut rust_parser = Parser(sess, cfg.clone(), ~rdr.clone());\n+                let mut rust_parser = Parser(sess, cfg.clone(), box rdr.clone());\n \n                 let mut ei = bb_eis.pop().unwrap();\n                 match ei.elts.get(ei.idx).node {\n@@ -433,14 +433,14 @@ pub fn parse_nt(p: &mut Parser, name: &str) -> Nonterminal {\n       \"ty\" => token::NtTy(p.parse_ty(false /* no need to disambiguate*/)),\n       // this could be handled like a token, since it is one\n       \"ident\" => match p.token {\n-        token::IDENT(sn,b) => { p.bump(); token::NtIdent(~sn,b) }\n+        token::IDENT(sn,b) => { p.bump(); token::NtIdent(box sn,b) }\n         _ => {\n             let token_str = token::to_str(&p.token);\n             p.fatal(\"expected ident, found \".to_owned() + token_str)\n         }\n       },\n       \"path\" => {\n-        token::NtPath(~p.parse_path(LifetimeAndTypesWithoutColons).path)\n+        token::NtPath(box p.parse_path(LifetimeAndTypesWithoutColons).path)\n       }\n       \"meta\" => token::NtMeta(p.parse_meta_item()),\n       \"tt\" => {"}, {"sha": "ab0266cedaae986ab44ca7848745139537da81d3", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -166,10 +166,10 @@ fn generic_extension(cx: &ExtCtxt,\n                 let trncbr = new_tt_reader(&cx.parse_sess().span_diagnostic,\n                                            Some(named_matches),\n                                            rhs);\n-                let p = Parser(cx.parse_sess(), cx.cfg(), ~trncbr);\n+                let p = Parser(cx.parse_sess(), cx.cfg(), box trncbr);\n                 // Let the context choose how to interpret the result.\n                 // Weird, but useful for X-macros.\n-                return ~ParserAnyMacro {\n+                return box ParserAnyMacro {\n                     parser: RefCell::new(p),\n                 } as ~MacResult\n               }\n@@ -239,13 +239,13 @@ pub fn add_new_extension(cx: &mut ExtCtxt,\n         _ => cx.span_bug(sp, \"wrong-structured rhs\")\n     };\n \n-    let exp = ~MacroRulesMacroExpander {\n+    let exp = box MacroRulesMacroExpander {\n         name: name,\n         lhses: lhses,\n         rhses: rhses,\n     };\n \n-    ~MacroRulesDefiner {\n+    box MacroRulesDefiner {\n         def: RefCell::new(Some(MacroDef {\n             name: token::get_ident(name).to_str(),\n             ext: NormalTT(exp, Some(sp))"}, {"sha": "43535205601f17ee7dde1cde0231f41adb6f2727", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -1020,8 +1020,8 @@ mod test {\n     use std::io::util;\n \n     fn mk_sh() -> diagnostic::SpanHandler {\n-        let emitter = diagnostic::EmitterWriter::new(~util::NullWriter);\n-        let handler = diagnostic::mk_handler(~emitter);\n+        let emitter = diagnostic::EmitterWriter::new(box util::NullWriter);\n+        let handler = diagnostic::mk_handler(box emitter);\n         diagnostic::mk_span_handler(handler, CodeMap::new())\n     }\n "}, {"sha": "dec6e6dd3747b9fe388e862c81976d3c45cc0012", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -247,7 +247,7 @@ pub fn filemap_to_tts(sess: &ParseSess, filemap: Rc<FileMap>)\n     // parsing tt's probably shouldn't require a parser at all.\n     let cfg = Vec::new();\n     let srdr = lexer::new_string_reader(&sess.span_diagnostic, filemap);\n-    let mut p1 = Parser(sess, cfg, ~srdr);\n+    let mut p1 = Parser(sess, cfg, box srdr);\n     p1.parse_all_token_trees()\n }\n \n@@ -256,7 +256,7 @@ pub fn tts_to_parser<'a>(sess: &'a ParseSess,\n                          tts: Vec<ast::TokenTree>,\n                          cfg: ast::CrateConfig) -> Parser<'a> {\n     let trdr = lexer::new_tt_reader(&sess.span_diagnostic, None, tts);\n-    Parser(sess, cfg, ~trdr)\n+    Parser(sess, cfg, box trdr)\n }\n \n // abort if necessary"}, {"sha": "6989ceb0d7992aa3df4c3daa0f24fe8d9305312b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -751,7 +751,7 @@ impl<'a> Parser<'a> {\n         self.last_span = self.span;\n         // Stash token for error recovery (sometimes; clone is not necessarily cheap).\n         self.last_token = if is_ident_or_path(&self.token) {\n-            Some(~self.token.clone())\n+            Some(box self.token.clone())\n         } else {\n             None\n         };"}, {"sha": "f5fe92c3e6791e53fd7be8e3e962405a560061db", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -132,7 +132,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n }\n \n pub fn to_str(f: |&mut State| -> IoResult<()>) -> ~str {\n-    let mut s = rust_printer(~MemWriter::new());\n+    let mut s = rust_printer(box MemWriter::new());\n     f(&mut s).unwrap();\n     eof(&mut s.s).unwrap();\n     unsafe {"}, {"sha": "538a1513d65a710e3775fc6d663746848784ca46", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -294,7 +294,12 @@ pub fn parse(file: &mut io::Reader,\n     }\n \n     // And that's all there is to it\n-    Ok(~TermInfo {names: term_names, bools: bools_map, numbers: numbers_map, strings: string_map })\n+    Ok(box TermInfo {\n+        names: term_names,\n+        bools: bools_map,\n+        numbers: numbers_map,\n+        strings: string_map\n+    })\n }\n \n /// Create a dummy TermInfo struct for msys terminals\n@@ -304,7 +309,7 @@ pub fn msys_terminfo() -> ~TermInfo {\n     strings.insert(\"bold\".to_owned(), Vec::from_slice(bytes!(\"\\x1b[1m\")));\n     strings.insert(\"setaf\".to_owned(), Vec::from_slice(bytes!(\"\\x1b[3%p1%dm\")));\n     strings.insert(\"setab\".to_owned(), Vec::from_slice(bytes!(\"\\x1b[4%p1%dm\")));\n-    ~TermInfo {\n+    box TermInfo {\n         names: vec!(\"cygwin\".to_owned()), // msys is a fork of an older cygwin version\n         bools: HashMap::new(),\n         numbers: HashMap::new(),"}, {"sha": "a491f7e863e96c1fa5b52673d36588a6a0b5a787", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -62,13 +62,13 @@ pub fn get_dbpath_for_term(term: &str) -> Option<~Path> {\n             let f = str::from_char(first_char);\n             let newp = p.join_many([f.as_slice(), term]);\n             if newp.exists() {\n-                return Some(~newp);\n+                return Some(box newp);\n             }\n             // on some installations the dir is named after the hex of the char (e.g. OS X)\n             let f = format!(\"{:x}\", first_char as uint);\n             let newp = p.join_many([f.as_slice(), term]);\n             if newp.exists() {\n-                return Some(~newp);\n+                return Some(box newp);\n             }\n         }\n     }"}, {"sha": "8c0abe32e3cb8fe7f5bc85c58e759f41ac080374", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0c691df8acaf10aa3721476e5d7fafcee11b0aaa/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=0c691df8acaf10aa3721476e5d7fafcee11b0aaa", "patch": "@@ -1001,8 +1001,8 @@ pub fn run_test(opts: &TestOpts,\n             if nocapture {\n                 drop((stdout, stderr));\n             } else {\n-                task.opts.stdout = Some(~stdout as ~Writer:Send);\n-                task.opts.stderr = Some(~stderr as ~Writer:Send);\n+                task.opts.stdout = Some(box stdout as ~Writer:Send);\n+                task.opts.stderr = Some(box stderr as ~Writer:Send);\n             }\n             let result_future = task.future_result();\n             task.spawn(testfn);\n@@ -1056,7 +1056,7 @@ fn calc_result(desc: &TestDesc, task_succeeded: bool) -> TestResult {\n \n impl ToJson for Metric {\n     fn to_json(&self) -> json::Json {\n-        let mut map = ~TreeMap::new();\n+        let mut map = box TreeMap::new();\n         map.insert(\"value\".to_owned(), json::Number(self.value));\n         map.insert(\"noise\".to_owned(), json::Number(self.noise));\n         json::Object(map)"}]}