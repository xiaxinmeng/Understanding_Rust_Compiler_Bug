{"sha": "593db005d4dbce2ff72009c1ba03477b031b2c0f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5M2RiMDA1ZDRkYmNlMmZmNzIwMDljMWJhMDM0NzdiMDMxYjJjMGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-25T01:42:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-03-25T01:42:42Z"}, "message": "Auto merge of #23681 - alexcrichton:rollup, r=alexcrichton", "tree": {"sha": "b585f5625dde7ab0af35fb3dd41a67ba0507f525", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b585f5625dde7ab0af35fb3dd41a67ba0507f525"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/593db005d4dbce2ff72009c1ba03477b031b2c0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/593db005d4dbce2ff72009c1ba03477b031b2c0f", "html_url": "https://github.com/rust-lang/rust/commit/593db005d4dbce2ff72009c1ba03477b031b2c0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/593db005d4dbce2ff72009c1ba03477b031b2c0f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "123a754cb8356d0e78837dd4e58103ad801309ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/123a754cb8356d0e78837dd4e58103ad801309ff", "html_url": "https://github.com/rust-lang/rust/commit/123a754cb8356d0e78837dd4e58103ad801309ff"}, {"sha": "3021d4c56422e15331e38f4b7b04c7229e024fda", "url": "https://api.github.com/repos/rust-lang/rust/commits/3021d4c56422e15331e38f4b7b04c7229e024fda", "html_url": "https://github.com/rust-lang/rust/commit/3021d4c56422e15331e38f4b7b04c7229e024fda"}], "stats": {"total": 3246, "additions": 2212, "deletions": 1034}, "files": [{"sha": "32088b2ab67bf9dbed624557bd0e12ad30eb23e6", "filename": "src/doc/reference.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -1265,7 +1265,7 @@ be undesired.\n * Sending signals\n * Accessing/modifying the file system\n * Unsigned integer overflow (well-defined as wrapping)\n-* Signed integer overflow (well-defined as two's complement representation\n+* Signed integer overflow (well-defined as two\u2019s complement representation\n   wrapping)\n \n #### Diverging functions\n@@ -2961,10 +2961,10 @@ meaning of the operators on standard types is given here.\n   : Exclusive or.\n     Calls the `bitxor` method of the `std::ops::BitXor` trait.\n * `<<`\n-  : Logical left shift.\n+  : Left shift.\n     Calls the `shl` method of the `std::ops::Shl` trait.\n * `>>`\n-  : Logical right shift.\n+  : Right shift.\n     Calls the `shr` method of the `std::ops::Shr` trait.\n \n #### Lazy boolean operators"}, {"sha": "70c74825a072cd7fac01e1b772f70ad659d7dba1", "filename": "src/doc/trpl/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Fdoc%2Ftrpl%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FSUMMARY.md?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -22,6 +22,7 @@\n     * [More Strings](more-strings.md)\n     * [Patterns](patterns.md)\n     * [Method Syntax](method-syntax.md)\n+    * [Associated Types](associated-types.md)\n     * [Closures](closures.md)\n     * [Iterators](iterators.md)\n     * [Generics](generics.md)"}, {"sha": "f36c2c56b6a76d06ff21500a4495fb01c059e102", "filename": "src/doc/trpl/associated-types.md", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Fdoc%2Ftrpl%2Fassociated-types.md", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Fdoc%2Ftrpl%2Fassociated-types.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fassociated-types.md?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -0,0 +1,202 @@\n+% Associated Types\n+\n+Associated types are a powerful part of Rust's type system. They're related to\n+the idea of a 'type family', in other words, grouping multiple types together. That\n+description is a bit abstract, so let's dive right into an example. If you want\n+to write a `Graph` trait, you have two types to be generic over: the node type\n+and the edge type. So you might write a trait, `Graph<N, E>`, that looks like\n+this:\n+\n+```rust\n+trait Graph<N, E> {\n+    fn has_edge(&self, &N, &N) -> bool;\n+    fn edges(&self, &N) -> Vec<E>;\n+    // etc\n+}\n+```\n+\n+While this sort of works, it ends up being awkward. For example, any function\n+that wants to take a `Graph` as a parameter now _also_ needs to be generic over\n+the `N`ode and `E`dge types too:\n+\n+```rust,ignore\n+fn distance<N, E, G: Graph<N, E>>(graph: &G, start: &N, end: &N) -> u32 { ... }\n+```\n+\n+Our distance calculation works regardless of our `Edge` type, so the `E` stuff in\n+this signature is just a distraction.\n+\n+What we really want to say is that a certain `E`dge and `N`ode type come together\n+to form each kind of `Graph`. We can do that with associated types:\n+\n+```rust\n+trait Graph {\n+    type N;\n+    type E;\n+\n+    fn has_edge(&self, &Self::N, &Self::N) -> bool;\n+    fn edges(&self, &Self::N) -> Vec<Self::E>;\n+    // etc\n+}\n+```\n+\n+Now, our clients can be abstract over a given `Graph`:\n+\n+```rust,ignore\n+fn distance<G: Graph>(graph: &G, start: &G::N, end: &G::N) -> uint { ... }\n+```\n+\n+No need to deal with the `E`dge type here!\n+\n+Let's go over all this in more detail.\n+\n+## Defining associated types\n+\n+Let's build that `Graph` trait. Here's the definition:\n+\n+```rust\n+trait Graph {\n+    type N;\n+    type E;\n+\n+    fn has_edge(&self, &Self::N, &Self::N) -> bool;\n+    fn edges(&self, &Self::N) -> Vec<Self::E>;\n+}\n+```\n+\n+Simple enough. Associated types use the `type` keyword, and go inside the body\n+of the trait, with the functions.\n+\n+These `type` declarations can have all the same thing as functions do. For example,\n+if we wanted our `N` type to implement `Display`, so we can print the nodes out,\n+we could do this:\n+\n+```rust\n+use std::fmt;\n+\n+trait Graph {\n+    type N: fmt::Display;\n+    type E;\n+\n+    fn has_edge(&self, &Self::N, &Self::N) -> bool;\n+    fn edges(&self, &Self::N) -> Vec<Self::E>;\n+}\n+```\n+\n+## Implementing associated types\n+\n+Just like any trait, traits that use associated types use the `impl` keyword to\n+provide implementations. Here's a simple implementation of Graph:\n+\n+```rust\n+# trait Graph {\n+#     type N;\n+#     type E;\n+#     fn has_edge(&self, &Self::N, &Self::N) -> bool;\n+#     fn edges(&self, &Self::N) -> Vec<Self::E>;\n+# }\n+struct Node;\n+\n+struct Edge;\n+\n+struct MyGraph;\n+\n+impl Graph for MyGraph {\n+    type N = Node;\n+    type E = Edge;\n+\n+    fn has_edge(&self, n1: &Node, n2: &Node) -> bool {\n+        true\n+    }\n+\n+    fn edges(&self, n: &Node) -> Vec<Edge> {\n+        Vec::new()\n+    }\n+}\n+```\n+\n+This silly implementation always returns `true` and an empty `Vec<Edge>`, but it\n+gives you an idea of how to implement this kind of thing. We first need three\n+`struct`s, one for the graph, one for the node, and one for the edge. If it made\n+more sense to use a different type, that would work as well, we're just going to\n+use `struct`s for all three here.\n+\n+Next is the `impl` line, which is just like implementing any other trait.\n+\n+From here, we use `=` to define our associated types. The name the trait uses\n+goes on the left of the `=`, and the concrete type we're `impl`ementing this\n+for goes on the right. Finally, we use the concrete types in our function\n+declarations.\n+\n+## Trait objects with associated types\n+\n+There\u2019s one more bit of syntax we should talk about: trait objects. If you\n+try to create a trait object from an associated type, like this:\n+\n+```rust,ignore\n+# trait Graph {\n+#     type N;\n+#     type E;\n+#     fn has_edge(&self, &Self::N, &Self::N) -> bool;\n+#     fn edges(&self, &Self::N) -> Vec<Self::E>;\n+# }\n+# struct Node;\n+# struct Edge;\n+# struct MyGraph;\n+# impl Graph for MyGraph {\n+#     type N = Node;\n+#     type E = Edge;\n+#     fn has_edge(&self, n1: &Node, n2: &Node) -> bool {\n+#         true\n+#     }\n+#     fn edges(&self, n: &Node) -> Vec<Edge> {\n+#         Vec::new()\n+#     }\n+# }\n+let graph = MyGraph;\n+let obj = Box::new(graph) as Box<Graph>;\n+```\n+\n+You\u2019ll get two errors:\n+\n+```text\n+error: the value of the associated type `E` (from the trait `main::Graph`) must\n+be specified [E0191]\n+let obj = Box::new(graph) as Box<Graph>;\n+          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+24:44 error: the value of the associated type `N` (from the trait\n+`main::Graph`) must be specified [E0191]\n+let obj = Box::new(graph) as Box<Graph>;\n+          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+```\n+\n+We can\u2019t create a trait object like this, becuase we don\u2019t know the associated\n+types. Instead, we can write this:\n+\n+```rust\n+# trait Graph {\n+#     type N;\n+#     type E;\n+#     fn has_edge(&self, &Self::N, &Self::N) -> bool;\n+#     fn edges(&self, &Self::N) -> Vec<Self::E>;\n+# }\n+# struct Node;\n+# struct Edge;\n+# struct MyGraph;\n+# impl Graph for MyGraph {\n+#     type N = Node;\n+#     type E = Edge;\n+#     fn has_edge(&self, n1: &Node, n2: &Node) -> bool {\n+#         true\n+#     }\n+#     fn edges(&self, n: &Node) -> Vec<Edge> {\n+#         Vec::new()\n+#     }\n+# }\n+let graph = MyGraph;\n+let obj = Box::new(graph) as Box<Graph<N=Node, E=Edge>>;\n+```\n+\n+The `N=Node` syntax allows us to provide a concrete type, `Node`, for the `N`\n+type parameter. Same with `E=Edge`. If we didn\u2019t proide this constraint, we\n+couldn\u2019t be sure which `impl` to match this trait object to."}, {"sha": "b851f19d22dc39327da7ad296619121c8e5faa7c", "filename": "src/doc/trpl/ownership.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Fdoc%2Ftrpl%2Fownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Fdoc%2Ftrpl%2Fownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fownership.md?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -513,8 +513,8 @@ Otherwise, it is an error to elide an output lifetime.\n \n ### Examples\n \n-Here are some examples of functions with elided lifetimes, and the version of\n-what the elided lifetimes are expand to:\n+Here are some examples of functions with elided lifetimes.  We've paired each\n+example of an elided lifetime with its expanded form.\n \n ```{rust,ignore}\n fn print(s: &str); // elided"}, {"sha": "dbf0cae6f4ba84b852e771e978b94ae84bbb99c5", "filename": "src/doc/trpl/unsafe.md", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Fdoc%2Ftrpl%2Funsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Fdoc%2Ftrpl%2Funsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Funsafe.md?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -197,15 +197,16 @@ use std::ptr;\n \n // Define a wrapper around the handle returned by the foreign code.\n // Unique<T> has the same semantics as Box<T>\n-pub struct Unique<T> {\n+//\n+// NB: For simplicity and correctness, we require that T has kind Send\n+// (owned boxes relax this restriction).\n+pub struct Unique<T: Send> {\n     // It contains a single raw, mutable pointer to the object in question.\n     ptr: *mut T\n }\n \n // Implement methods for creating and using the values in the box.\n \n-// NB: For simplicity and correctness, we require that T has kind Send\n-// (owned boxes relax this restriction).\n impl<T: Send> Unique<T> {\n     pub fn new(value: T) -> Unique<T> {\n         unsafe {\n@@ -239,11 +240,11 @@ impl<T: Send> Unique<T> {\n // Unique<T>, making the struct manage the raw pointer: when the\n // struct goes out of scope, it will automatically free the raw pointer.\n //\n-// NB: This is an unsafe destructor, because rustc will not normally\n-// allow destructors to be associated with parameterized types, due to\n-// bad interaction with managed boxes. (With the Send restriction,\n-// we don't have this problem.) Note that the `#[unsafe_destructor]`\n-// feature gate is required to use unsafe destructors.\n+// NB: This is an unsafe destructor; rustc will not normally allow\n+// destructors to be associated with parameterized types (due to\n+// historically failing to check them soundly).  Note that the\n+// `#[unsafe_destructor]` feature gate is currently required to use\n+// unsafe destructors.\n #[unsafe_destructor]\n impl<T: Send> Drop for Unique<T> {\n     fn drop(&mut self) {"}, {"sha": "249b5d22b6b23ad763df4d8a586abb33ae82cc79", "filename": "src/etc/libc.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Fetc%2Flibc.c", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Fetc%2Flibc.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flibc.c?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -165,6 +165,16 @@ void posix88_consts() {\n   put_const(S_IWUSR, int);\n   put_const(S_IRUSR, int);\n \n+  put_const(S_IRWXG, int);\n+  put_const(S_IXGRP, int);\n+  put_const(S_IWGRP, int);\n+  put_const(S_IRGRP, int);\n+\n+  put_const(S_IRWXO, int);\n+  put_const(S_IXOTH, int);\n+  put_const(S_IWOTH, int);\n+  put_const(S_IROTH, int);\n+\n #ifdef F_OK\n   put_const(F_OK, int);\n #endif"}, {"sha": "b5d16d29272850843e9204749c68e6be9165d56d", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -321,7 +321,7 @@ impl<T: Send + Sync + Clone> Arc<T> {\n \n #[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Sync + Send> Drop for Arc<T> {\n+impl<T> Drop for Arc<T> {\n     /// Drops the `Arc<T>`.\n     ///\n     /// This will decrement the strong reference count. If the strong reference\n@@ -388,7 +388,7 @@ impl<T: Sync + Send> Drop for Arc<T> {\n \n #[unstable(feature = \"alloc\",\n            reason = \"Weak pointers may not belong in this module.\")]\n-impl<T: Sync + Send> Weak<T> {\n+impl<T> Weak<T> {\n     /// Upgrades a weak reference to a strong reference.\n     ///\n     /// Upgrades the `Weak<T>` reference to an `Arc<T>`, if possible.\n@@ -454,7 +454,7 @@ impl<T: Sync + Send> Clone for Weak<T> {\n \n #[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Sync + Send> Drop for Weak<T> {\n+impl<T> Drop for Weak<T> {\n     /// Drops the `Weak<T>`.\n     ///\n     /// This will decrement the weak reference count."}, {"sha": "7843be0b483ebd8750e7eab20e73ae1014ea04b7", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -429,7 +429,8 @@ impl<T> TypedArenaChunk<T> {\n         // Destroy the next chunk.\n         let next = self.next;\n         let size = calculate_size::<T>(self.capacity);\n-        deallocate(self as *mut TypedArenaChunk<T> as *mut u8, size,\n+        let self_ptr: *mut TypedArenaChunk<T> = self;\n+        deallocate(self_ptr as *mut u8, size,\n                    mem::min_align_of::<TypedArenaChunk<T>>());\n         if !next.is_null() {\n             let capacity = (*next).capacity;"}, {"sha": "6a65c991c95037b5d45be79dd7c191277a74960a", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -24,6 +24,8 @@\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![doc(test(no_crate_inject))]\n \n+#![allow(trivial_casts)]\n+#![allow(trivial_numeric_casts)]\n #![feature(alloc)]\n #![feature(box_syntax)]\n #![feature(box_patterns)]"}, {"sha": "af2daabc2d02ca080d5756c0bb9f12aa89d2826a", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -1199,8 +1199,8 @@ impl<T: PartialEq> Vec<T> {\n \n             // Avoid bounds checks by using unsafe pointers.\n             let p = self.as_mut_ptr();\n-            let mut r = 1;\n-            let mut w = 1;\n+            let mut r: usize = 1;\n+            let mut w: usize = 1;\n \n             while r < ln {\n                 let p_r = p.offset(r as isize);"}, {"sha": "234cd6e0fd21ec23994810de197661005891dc0a", "filename": "src/libcollectionstest/btree/set.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcollectionstest%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcollectionstest%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbtree%2Fset.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -43,15 +43,21 @@ struct Counter<'a, 'b> {\n }\n \n impl<'a, 'b, 'c> FnMut<(&'c i32,)> for Counter<'a, 'b> {\n-    type Output = bool;\n-\n     extern \"rust-call\" fn call_mut(&mut self, (&x,): (&'c i32,)) -> bool {\n         assert_eq!(x, self.expected[*self.i]);\n         *self.i += 1;\n         true\n     }\n }\n \n+impl<'a, 'b, 'c> FnOnce<(&'c i32,)> for Counter<'a, 'b> {\n+    type Output = bool;\n+\n+    extern \"rust-call\" fn call_once(mut self, args: (&'c i32,)) -> bool {\n+        self.call_mut(args)\n+    }\n+}\n+\n fn check<F>(a: &[i32], b: &[i32], expected: &[i32], f: F) where\n     // FIXME Replace Counter with `Box<FnMut(_) -> _>`\n     F: FnOnce(&BTreeSet<i32>, &BTreeSet<i32>, Counter) -> bool,"}, {"sha": "c94d8e2ed0c8d8d5ee79f0743ff6a826c30968cd", "filename": "src/libcore/any.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -82,11 +82,11 @@ use marker::Sized;\n // Any trait\n ///////////////////////////////////////////////////////////////////////////////\n \n-/// The `Any` trait is implemented by all `'static` types, and can be used for\n-/// dynamic typing\n+/// A type to emulate dynamic typing. See the [module-level documentation][mod] for more details.\n ///\n-/// Every type with no non-`'static` references implements `Any`, so `Any` can\n-/// be used as a trait object to emulate the effects dynamic typing.\n+/// Every type with no non-`'static` references implements `Any`.\n+///\n+/// [mod]: ../index.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Any: 'static {\n     /// Get the `TypeId` of `self`"}, {"sha": "9e6dbce0325935da3737fe1c10cbf511c7afaa68", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -713,7 +713,11 @@ impl<T> UnsafeCell<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get(&self) -> *mut T { &self.value as *const T as *mut T }\n+    pub fn get(&self) -> *mut T {\n+        // FIXME(#23542) Replace with type ascription.\n+        #![allow(trivial_casts)]\n+        &self.value as *const T as *mut T\n+    }\n \n     /// Unwraps the value\n     ///"}, {"sha": "85e5bde48598eee8bde8ee706fc365e60f19104c", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -27,6 +27,14 @@ use marker::Sized;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Clone : Sized {\n     /// Returns a copy of the value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let hello = \"Hello\"; // &str implements Clone\n+    ///\n+    /// assert_eq!(\"Hello\", hello.clone());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn clone(&self) -> Self;\n "}, {"sha": "aa0d0a1539a30e045ba424a52b1f4861da689629", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -833,20 +833,26 @@ impl<T> Pointer for *const T {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Pointer for *mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n+        // FIXME(#23542) Replace with type ascription.\n+        #![allow(trivial_casts)]\n         Pointer::fmt(&(*self as *const T), f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Pointer for &'a T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n+        // FIXME(#23542) Replace with type ascription.\n+        #![allow(trivial_casts)]\n         Pointer::fmt(&(*self as *const T), f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Pointer for &'a mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n+        // FIXME(#23542) Replace with type ascription.\n+        #![allow(trivial_casts)]\n         Pointer::fmt(&(&**self as *const T), f)\n     }\n }"}, {"sha": "56d2eabc095a3f0f4aa538481a590fe12504df55", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -13,6 +13,7 @@\n // FIXME: #6220 Implement floating point formatting\n \n #![allow(unsigned_negation)]\n+#![allow(trivial_numeric_casts)]\n \n use fmt;\n use iter::IteratorExt;"}, {"sha": "2feb2f8b1e36372d8121b54f2167b631c2d04879", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -182,6 +182,8 @@ mod impls {\n                 }\n \n                 fn hash_slice<H: Hasher>(data: &[$ty], state: &mut H) {\n+                    // FIXME(#23542) Replace with type ascription.\n+                    #![allow(trivial_casts)]\n                     let newlen = data.len() * ::$ty::BYTES as usize;\n                     let ptr = data.as_ptr() as *const u8;\n                     state.write(unsafe { slice::from_raw_parts(ptr, newlen) })"}, {"sha": "1e6fb51a8a528e9d75bac0d6fa36da598104f057", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -313,6 +313,8 @@ pub fn drop<T>(_x: T) { }\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn transmute_copy<T, U>(src: &T) -> U {\n+    // FIXME(#23542) Replace with type ascription.\n+    #![allow(trivial_casts)]\n     ptr::read(src as *const T as *const U)\n }\n "}, {"sha": "efafce3fdefb04537a4b455af99ee20941e00ed9", "filename": "src/libcore/num/i16.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi16.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -12,5 +12,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"i16\")]\n+#![allow(trivial_numeric_casts)]\n \n int_module! { i16, 16 }"}, {"sha": "72b0236a8d2a4c12814ab55febe6f2cda730bbbe", "filename": "src/libcore/num/i32.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi32.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -12,5 +12,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"i32\")]\n+#![allow(trivial_numeric_casts)]\n \n int_module! { i32, 32 }"}, {"sha": "a64a4febd5a963448fab5c413646509871a896a6", "filename": "src/libcore/num/i64.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi64.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -12,5 +12,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"i64\")]\n+#![allow(trivial_numeric_casts)]\n \n int_module! { i64, 64 }"}, {"sha": "459814875ee0ee1686bfe88b502784a9139ce70a", "filename": "src/libcore/num/i8.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi8.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -12,5 +12,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"i8\")]\n+#![allow(trivial_numeric_casts)]\n \n int_module! { i8, 8 }"}, {"sha": "675f568a96099e7c8728f498d5168845c64d5292", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![doc(hidden)]\n+#![allow(trivial_numeric_casts)]\n \n macro_rules! int_module { ($T:ty, $bits:expr) => (\n "}, {"sha": "9af51a36748263a2474b26e4c9fc5f7878afe3c8", "filename": "src/libcore/num/isize.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fnum%2Fisize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fnum%2Fisize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fisize.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -16,6 +16,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"isize\")]\n+#![allow(trivial_numeric_casts)]\n \n #[cfg(target_pointer_width = \"32\")]\n int_module! { isize, 32 }"}, {"sha": "0eec875afc3bb15a47e1734bb62468f2bc6d8479", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -14,6 +14,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![allow(missing_docs)]\n+#![allow(trivial_numeric_casts)]\n \n use self::wrapping::{OverflowingOps, WrappingOps};\n "}, {"sha": "289c5dbd08ea0eb02bf6c028ff2ec62e79ca4e80", "filename": "src/libcore/num/u16.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu16.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -12,5 +12,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"u16\")]\n+#![allow(trivial_numeric_casts)]\n \n uint_module! { u16, i16, 16 }"}, {"sha": "6d0b6b0e5eaf9799a4f472bbc2efbbff8c8ea2c5", "filename": "src/libcore/num/u32.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu32.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -12,5 +12,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"u32\")]\n+#![allow(trivial_numeric_casts)]\n \n uint_module! { u32, i32, 32 }"}, {"sha": "bf8747fdb6e2f45461a50eeea9795a97e85ecb33", "filename": "src/libcore/num/u64.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu64.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -12,5 +12,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"u64\")]\n+#![allow(trivial_numeric_casts)]\n \n uint_module! { u64, i64, 64 }"}, {"sha": "05199735d4acb3f6aee6963963896308dab95ebd", "filename": "src/libcore/num/u8.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu8.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -12,5 +12,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"u8\")]\n+#![allow(trivial_numeric_casts)]\n \n uint_module! { u8, i8, 8 }"}, {"sha": "c22f31cc57ea84efba5238460fee13f32afd64ee", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n #![doc(hidden)]\n+#![allow(trivial_numeric_casts)]\n \n macro_rules! uint_module { ($T:ty, $T_SIGNED:ty, $bits:expr) => (\n "}, {"sha": "82dd3312782c554fdebaadb100d1d1c7df08d90f", "filename": "src/libcore/num/usize.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fnum%2Fusize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fnum%2Fusize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fusize.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -16,5 +16,6 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n #![doc(primitive = \"usize\")]\n+#![allow(trivial_numeric_casts)]\n \n uint_module! { usize, isize, ::isize::BITS }"}, {"sha": "fee40115f39525bcca9651cce1cfc47cb3cc3ae6", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -1148,6 +1148,7 @@ impl<'a, T: ?Sized> DerefMut for &'a mut T {\n #[lang=\"fn\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n+#[cfg(stage0)]\n pub trait Fn<Args> {\n     /// The returned type after the call operator is used.\n     type Output;\n@@ -1156,10 +1157,21 @@ pub trait Fn<Args> {\n     extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n }\n \n+/// A version of the call operator that takes an immutable receiver.\n+#[lang=\"fn\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_paren_sugar]\n+#[cfg(not(stage0))]\n+pub trait Fn<Args> : FnMut<Args> {\n+    /// This is called when the call operator is used.\n+    extern \"rust-call\" fn call(&self, args: Args) -> Self::Output;\n+}\n+\n /// A version of the call operator that takes a mutable receiver.\n #[lang=\"fn_mut\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_paren_sugar]\n+#[cfg(stage0)]\n pub trait FnMut<Args> {\n     /// The returned type after the call operator is used.\n     type Output;\n@@ -1168,6 +1180,16 @@ pub trait FnMut<Args> {\n     extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n }\n \n+/// A version of the call operator that takes a mutable receiver.\n+#[lang=\"fn_mut\"]\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_paren_sugar]\n+#[cfg(not(stage0))]\n+pub trait FnMut<Args> : FnOnce<Args> {\n+    /// This is called when the call operator is used.\n+    extern \"rust-call\" fn call_mut(&mut self, args: Args) -> Self::Output;\n+}\n+\n /// A version of the call operator that takes a by-value receiver.\n #[lang=\"fn_once\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1180,6 +1202,7 @@ pub trait FnOnce<Args> {\n     extern \"rust-call\" fn call_once(self, args: Args) -> Self::Output;\n }\n \n+#[cfg(stage0)]\n impl<F: ?Sized, A> FnMut<A> for F\n     where F : Fn<A>\n {\n@@ -1190,6 +1213,7 @@ impl<F: ?Sized, A> FnMut<A> for F\n     }\n }\n \n+#[cfg(stage0)]\n impl<F,A> FnOnce<A> for F\n     where F : FnMut<A>\n {"}, {"sha": "9b3ee3ef5e0c28fb1a402d0b6100bf1af5ad2288", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -529,7 +529,7 @@ impl<T: ?Sized> Unique<T> {\n     /// Create a new `Unique`.\n     #[unstable(feature = \"unique\")]\n     pub unsafe fn new(ptr: *mut T) -> Unique<T> {\n-        Unique { pointer: NonZero::new(ptr as *const T), _marker: PhantomData }\n+        Unique { pointer: NonZero::new(ptr), _marker: PhantomData }\n     }\n \n     /// Dereference the content."}, {"sha": "ea98f6f5f24616afd809055aba4ace834b2f5afc", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 30, "deletions": 2, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -28,8 +28,9 @@ use iter::ExactSizeIterator;\n use iter::{Map, Iterator, IteratorExt, DoubleEndedIterator};\n use marker::Sized;\n use mem;\n+#[allow(deprecated)]\n use num::Int;\n-use ops::{Fn, FnMut};\n+use ops::{Fn, FnMut, FnOnce};\n use option::Option::{self, None, Some};\n use raw::{Repr, Slice};\n use result::Result::{self, Ok, Err};\n@@ -261,7 +262,7 @@ pub unsafe fn from_utf8_unchecked<'a>(v: &'a [u8]) -> &'a str {\n              reason = \"use std::ffi::c_str_to_bytes + str::from_utf8\")]\n pub unsafe fn from_c_str(s: *const i8) -> &'static str {\n     let s = s as *const u8;\n-    let mut len = 0;\n+    let mut len: usize = 0;\n     while *s.offset(len as isize) != 0 {\n         len += 1;\n     }\n@@ -541,6 +542,7 @@ delegate_iter!{exact u8 : Bytes<'a>}\n #[derive(Copy, Clone)]\n struct BytesDeref;\n \n+#[cfg(stage0)]\n impl<'a> Fn<(&'a u8,)> for BytesDeref {\n     type Output = u8;\n \n@@ -550,6 +552,32 @@ impl<'a> Fn<(&'a u8,)> for BytesDeref {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl<'a> Fn<(&'a u8,)> for BytesDeref {\n+    #[inline]\n+    extern \"rust-call\" fn call(&self, (ptr,): (&'a u8,)) -> u8 {\n+        *ptr\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl<'a> FnMut<(&'a u8,)> for BytesDeref {\n+    #[inline]\n+    extern \"rust-call\" fn call_mut(&mut self, (ptr,): (&'a u8,)) -> u8 {\n+        Fn::call(&*self, (ptr,))\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl<'a> FnOnce<(&'a u8,)> for BytesDeref {\n+    type Output = u8;\n+\n+    #[inline]\n+    extern \"rust-call\" fn call_once(self, (ptr,): (&'a u8,)) -> u8 {\n+        Fn::call(&self, (ptr,))\n+    }\n+}\n+\n /// An iterator over the substrings of a string, separated by `sep`.\n struct CharSplits<'a, P: Pattern<'a>> {\n     /// The slice remaining to be iterated"}, {"sha": "17d6b684c50e80a1111ee80cc5e47a1b329f347d", "filename": "src/libcoretest/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcoretest%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcoretest%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fmem.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -95,7 +95,7 @@ fn test_transmute() {\n     trait Foo { fn dummy(&self) { } }\n     impl Foo for int {}\n \n-    let a = box 100 as Box<Foo>;\n+    let a = box 100isize as Box<Foo>;\n     unsafe {\n         let x: ::core::raw::TraitObject = transmute(a);\n         assert!(*(x.data as *const int) == 100);"}, {"sha": "4f5f269d4375d0c0a6e2ec2c24ad3f19b476a065", "filename": "src/libcoretest/ptr.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcoretest%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibcoretest%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fptr.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -84,9 +84,9 @@ fn test_as_ref() {\n         assert_eq!(q.as_ref().unwrap(), &2);\n \n         // Lifetime inference\n-        let u = 2;\n+        let u = 2isize;\n         {\n-            let p: *const int = &u as *const _;\n+            let p = &u as *const int;\n             assert_eq!(p.as_ref().unwrap(), &2);\n         }\n     }\n@@ -102,9 +102,9 @@ fn test_as_mut() {\n         assert!(q.as_mut().unwrap() == &mut 2);\n \n         // Lifetime inference\n-        let mut u = 2;\n+        let mut u = 2isize;\n         {\n-            let p: *mut int = &mut u as *mut _;\n+            let p = &mut u as *mut int;\n             assert!(p.as_mut().unwrap() == &mut 2);\n         }\n     }\n@@ -170,9 +170,9 @@ fn test_set_memory() {\n \n #[test]\n fn test_unsized_unique() {\n-    let xs: &mut [_] = &mut [1, 2, 3];\n-    let ptr = unsafe { Unique::new(xs as *mut [_]) };\n+    let xs: &mut [i32] = &mut [1, 2, 3];\n+    let ptr = unsafe { Unique::new(xs as *mut [i32]) };\n     let ys = unsafe { &mut **ptr };\n-    let zs: &mut [_] = &mut [1, 2, 3];\n+    let zs: &mut [i32] = &mut [1, 2, 3];\n     assert!(ys == zs);\n }"}, {"sha": "89843979cd01583346aef92808b3edafe843d9b0", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -2439,6 +2439,7 @@ pub mod consts {\n         }\n         pub mod posix88 {\n             use types::os::arch::c95::c_int;\n+            use types::os::arch::posix88::mode_t;\n \n             pub const O_RDONLY : c_int = 0;\n             pub const O_WRONLY : c_int = 1;\n@@ -2461,6 +2462,14 @@ pub mod consts {\n             pub const S_IXUSR : c_int = 64;\n             pub const S_IWUSR : c_int = 128;\n             pub const S_IRUSR : c_int = 256;\n+            pub const S_IRWXG : mode_t = 56;\n+            pub const S_IXGRP : mode_t = 8;\n+            pub const S_IWGRP : mode_t = 16;\n+            pub const S_IRGRP : mode_t = 32;\n+            pub const S_IRWXO : mode_t = 7;\n+            pub const S_IXOTH : mode_t = 1;\n+            pub const S_IWOTH : mode_t = 2;\n+            pub const S_IROTH : mode_t = 4;\n             pub const F_OK : c_int = 0;\n             pub const R_OK : c_int = 4;\n             pub const W_OK : c_int = 2;\n@@ -2811,6 +2820,14 @@ pub mod consts {\n             pub const S_IXUSR : mode_t = 64;\n             pub const S_IWUSR : mode_t = 128;\n             pub const S_IRUSR : mode_t = 256;\n+            pub const S_IRWXG : mode_t = 56;\n+            pub const S_IXGRP : mode_t = 8;\n+            pub const S_IWGRP : mode_t = 16;\n+            pub const S_IRGRP : mode_t = 32;\n+            pub const S_IRWXO : mode_t = 7;\n+            pub const S_IXOTH : mode_t = 1;\n+            pub const S_IWOTH : mode_t = 2;\n+            pub const S_IROTH : mode_t = 4;\n             pub const F_OK : c_int = 0;\n             pub const R_OK : c_int = 4;\n             pub const W_OK : c_int = 2;\n@@ -3024,6 +3041,14 @@ pub mod consts {\n             pub const S_IXUSR : mode_t = 64;\n             pub const S_IWUSR : mode_t = 128;\n             pub const S_IRUSR : mode_t = 256;\n+            pub const S_IRWXG : mode_t = 56;\n+            pub const S_IXGRP : mode_t = 8;\n+            pub const S_IWGRP : mode_t = 16;\n+            pub const S_IRGRP : mode_t = 32;\n+            pub const S_IRWXO : mode_t = 7;\n+            pub const S_IXOTH : mode_t = 1;\n+            pub const S_IWOTH : mode_t = 2;\n+            pub const S_IROTH : mode_t = 4;\n             pub const F_OK : c_int = 0;\n             pub const R_OK : c_int = 4;\n             pub const W_OK : c_int = 2;\n@@ -3752,6 +3777,14 @@ pub mod consts {\n             pub const S_IXUSR : mode_t = 64;\n             pub const S_IWUSR : mode_t = 128;\n             pub const S_IRUSR : mode_t = 256;\n+            pub const S_IRWXG : mode_t = 56;\n+            pub const S_IXGRP : mode_t = 8;\n+            pub const S_IWGRP : mode_t = 16;\n+            pub const S_IRGRP : mode_t = 32;\n+            pub const S_IRWXO : mode_t = 7;\n+            pub const S_IXOTH : mode_t = 1;\n+            pub const S_IWOTH : mode_t = 2;\n+            pub const S_IROTH : mode_t = 4;\n             pub const F_OK : c_int = 0;\n             pub const R_OK : c_int = 4;\n             pub const W_OK : c_int = 2;\n@@ -4198,6 +4231,14 @@ pub mod consts {\n             pub const S_IXUSR : mode_t = 64;\n             pub const S_IWUSR : mode_t = 128;\n             pub const S_IRUSR : mode_t = 256;\n+            pub const S_IRWXG : mode_t = 56;\n+            pub const S_IXGRP : mode_t = 8;\n+            pub const S_IWGRP : mode_t = 16;\n+            pub const S_IRGRP : mode_t = 32;\n+            pub const S_IRWXO : mode_t = 7;\n+            pub const S_IXOTH : mode_t = 1;\n+            pub const S_IWOTH : mode_t = 2;\n+            pub const S_IROTH : mode_t = 4;\n             pub const F_OK : c_int = 0;\n             pub const R_OK : c_int = 4;\n             pub const W_OK : c_int = 2;\n@@ -4610,6 +4651,14 @@ pub mod consts {\n             pub const S_IXUSR : mode_t = 64;\n             pub const S_IWUSR : mode_t = 128;\n             pub const S_IRUSR : mode_t = 256;\n+            pub const S_IRWXG : mode_t = 56;\n+            pub const S_IXGRP : mode_t = 8;\n+            pub const S_IWGRP : mode_t = 16;\n+            pub const S_IRGRP : mode_t = 32;\n+            pub const S_IRWXO : mode_t = 7;\n+            pub const S_IXOTH : mode_t = 1;\n+            pub const S_IWOTH : mode_t = 2;\n+            pub const S_IROTH : mode_t = 4;\n             pub const F_OK : c_int = 0;\n             pub const R_OK : c_int = 4;\n             pub const W_OK : c_int = 2;"}, {"sha": "7ccd5401fdea47b58419244621a473b813d7e7e1", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -304,10 +304,10 @@ pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n     // Completely remove the local logger from TLS in case anyone attempts to\n     // frob the slot while we're doing the logging. This will destroy any logger\n     // set during logging.\n-    let mut logger = LOCAL_LOGGER.with(|s| {\n+    let mut logger: Box<Logger + Send> = LOCAL_LOGGER.with(|s| {\n         s.borrow_mut().take()\n     }).unwrap_or_else(|| {\n-        box DefaultLogger { handle: io::stderr() } as Box<Logger + Send>\n+        box DefaultLogger { handle: io::stderr() }\n     });\n     logger.log(&LogRecord {\n         level: LogLevel(level),\n@@ -443,7 +443,7 @@ fn init() {\n         DIRECTIVES = boxed::into_raw(box directives);\n \n         // Schedule the cleanup for the globals for when the runtime exits.\n-        rt::at_exit(move || {\n+        let _ = rt::at_exit(move || {\n             let _g = LOCK.lock();\n             assert!(!DIRECTIVES.is_null());\n             let _directives = Box::from_raw(DIRECTIVES);"}, {"sha": "a682fa8584176977d02ccb2b942fd91b4e62e2ab", "filename": "src/librand/distributions/range.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fdistributions%2Frange.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -10,6 +10,8 @@\n \n //! Generating numbers between two others.\n \n+#![allow(trivial_numeric_casts)]\n+\n // this is surprisingly complicated to be both generic & correct\n \n use core::prelude::{PartialOrd};"}, {"sha": "14bebe0cd915cf167803a01a40d41227e389c387", "filename": "src/librand/isaac.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fisaac.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -447,6 +447,7 @@ impl Rng for Isaac64Rng {\n \n     #[inline]\n     fn next_u64(&mut self) -> u64 {\n+        #![allow(trivial_numeric_casts)]\n         if self.cnt == 0 {\n             // make some more numbers\n             self.isaac64();"}, {"sha": "1ffc6001af5721b3163bac4e575a7c3dc21df67f", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -352,8 +352,8 @@ pub mod reader {\n             let i = (val >> 28) as uint;\n             let (shift, mask) = SHIFT_MASK_TABLE[i];\n             Ok(Res {\n-                val: ((val >> shift) & mask) as uint,\n-                next: start + (((32 - shift) >> 3) as uint)\n+                val: ((val >> shift) & mask) as usize,\n+                next: start + ((32 - shift) >> 3),\n             })\n         }\n     }\n@@ -573,7 +573,7 @@ pub mod reader {\n                     0 => doc_as_u8(r_doc) as u64,\n                     1 => doc_as_u16(r_doc) as u64,\n                     2 => doc_as_u32(r_doc) as u64,\n-                    3 => doc_as_u64(r_doc) as u64,\n+                    3 => doc_as_u64(r_doc),\n                     _ => unreachable!(),\n                 }\n             } else {"}, {"sha": "e8af07e43815919ef4a23410a662770d90047409", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -47,6 +47,9 @@\n #![feature(into_cow)]\n #![cfg_attr(test, feature(test))]\n \n+#![allow(trivial_casts)]\n+#![allow(trivial_numeric_casts)]\n+\n extern crate arena;\n extern crate flate;\n extern crate fmt_macros;"}, {"sha": "2cc47f258f0764db771e1a7dd1feb00b51e9f092", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -100,6 +100,17 @@ declare_lint! {\n     \"detects transmutes of fat pointers\"\n }\n \n+declare_lint! {\n+    pub TRIVIAL_CASTS,\n+    Warn,\n+    \"detects trivial casts which could be removed\"\n+}\n+\n+declare_lint! {\n+    pub TRIVIAL_NUMERIC_CASTS,\n+    Warn,\n+    \"detects trivial casts of numeric types which could be removed\"\n+}\n /// Does nothing as a lint pass, but registers some `Lint`s\n /// which are used by other parts of the compiler.\n #[derive(Copy)]\n@@ -121,7 +132,9 @@ impl LintPass for HardwiredLints {\n             STABLE_FEATURES,\n             UNKNOWN_CRATE_TYPES,\n             VARIANT_SIZE_DIFFERENCES,\n-            FAT_PTR_TRANSMUTES\n+            FAT_PTR_TRANSMUTES,\n+            TRIVIAL_CASTS,\n+            TRIVIAL_NUMERIC_CASTS\n         )\n     }\n }"}, {"sha": "16b387330b9efea402867d39e78c64e76cbeefeb", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -14,6 +14,7 @@\n use super::{CombinedSnapshot, cres, InferCtxt, HigherRankedType, SkolemizationMap};\n use super::combine::{Combine, Combineable};\n \n+use middle::subst;\n use middle::ty::{self, Binder};\n use middle::ty_fold::{self, TypeFoldable};\n use syntax::codemap::Span;\n@@ -455,6 +456,63 @@ impl<'a,'tcx> InferCtxtExt for InferCtxt<'a,'tcx> {\n     }\n }\n \n+/// Constructs and returns a substitution that, for a given type\n+/// scheme parameterized by `generics`, will replace every generic\n+/// parmeter in the type with a skolemized type/region (which one can\n+/// think of as a \"fresh constant\", except at the type/region level of\n+/// reasoning).\n+///\n+/// Since we currently represent bound/free type parameters in the\n+/// same way, this only has an effect on regions.\n+///\n+/// (Note that unlike a substitution from `ty::construct_free_substs`,\n+/// this inserts skolemized regions rather than free regions; this\n+/// allows one to use `fn leak_check` to catch attmepts to unify the\n+/// skolemized regions with e.g. the `'static` lifetime)\n+pub fn construct_skolemized_substs<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                                            generics: &ty::Generics<'tcx>,\n+                                            snapshot: &CombinedSnapshot)\n+                                            -> (subst::Substs<'tcx>, SkolemizationMap)\n+{\n+    let mut map = FnvHashMap();\n+\n+    // map T => T\n+    let mut types = subst::VecPerParamSpace::empty();\n+    push_types_from_defs(infcx.tcx, &mut types, generics.types.as_slice());\n+\n+    // map early- or late-bound 'a => fresh 'a\n+    let mut regions = subst::VecPerParamSpace::empty();\n+    push_region_params(infcx, &mut map, &mut regions, generics.regions.as_slice(), snapshot);\n+\n+    let substs = subst::Substs { types: types,\n+                                 regions: subst::NonerasedRegions(regions) };\n+    return (substs, map);\n+\n+    fn push_region_params<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                                   map: &mut SkolemizationMap,\n+                                   regions: &mut subst::VecPerParamSpace<ty::Region>,\n+                                   region_params: &[ty::RegionParameterDef],\n+                                   snapshot: &CombinedSnapshot)\n+    {\n+        for r in region_params {\n+            let br = r.to_bound_region();\n+            let skol_var = infcx.region_vars.new_skolemized(br, &snapshot.region_vars_snapshot);\n+            let sanity_check = map.insert(br, skol_var);\n+            assert!(sanity_check.is_none());\n+            regions.push(r.space, skol_var);\n+        }\n+    }\n+\n+    fn push_types_from_defs<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                  types: &mut subst::VecPerParamSpace<ty::Ty<'tcx>>,\n+                                  defs: &[ty::TypeParameterDef<'tcx>]) {\n+        for def in defs {\n+            let ty = ty::mk_param_from_def(tcx, def);\n+            types.push(def.space, ty);\n+        }\n+    }\n+}\n+\n pub fn skolemize_late_bound_regions<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n                                                binder: &ty::Binder<T>,\n                                                snapshot: &CombinedSnapshot)"}, {"sha": "a38adabee915b318b0abe2fcc50fb341743ef0d8", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -726,6 +726,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         })\n     }\n \n+    pub fn construct_skolemized_subst(&self,\n+                                      generics: &ty::Generics<'tcx>,\n+                                      snapshot: &CombinedSnapshot)\n+                                      -> (subst::Substs<'tcx>, SkolemizationMap) {\n+        /*! See `higher_ranked::construct_skolemized_subst` */\n+\n+        higher_ranked::construct_skolemized_substs(self, generics, snapshot)\n+    }\n+\n     pub fn skolemize_late_bound_regions<T>(&self,\n                                            value: &ty::Binder<T>,\n                                            snapshot: &CombinedSnapshot)"}, {"sha": "2232bb7bcdbf3698510c56e4f40808c205664dc0", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -789,10 +789,13 @@ fn confirm_callable_candidate<'cx,'tcx>(\n            obligation.repr(tcx),\n            fn_sig.repr(tcx));\n \n+    // the `Output` associated type is declared on `FnOnce`\n+    let fn_once_def_id = tcx.lang_items.fn_once_trait().unwrap();\n+\n     // Note: we unwrap the binder here but re-create it below (1)\n     let ty::Binder((trait_ref, ret_type)) =\n         util::closure_trait_ref_and_return_type(tcx,\n-                                                obligation.predicate.trait_ref.def_id,\n+                                                fn_once_def_id,\n                                                 obligation.predicate.trait_ref.self_ty(),\n                                                 fn_sig,\n                                                 flag);"}, {"sha": "0d6a1f7df5e564cd8d26bf8d7beebec1ba9f4201", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -1069,7 +1069,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match self.closure_typer.closure_kind(closure_def_id) {\n             Some(closure_kind) => {\n                 debug!(\"assemble_unboxed_candidates: closure_kind = {:?}\", closure_kind);\n-                if closure_kind == kind {\n+                if closure_kind.extends(kind) {\n                     candidates.vec.push(ClosureCandidate(closure_def_id, substs.clone()));\n                 }\n             }\n@@ -1088,10 +1088,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                       candidates: &mut SelectionCandidateSet<'tcx>)\n                                       -> Result<(),SelectionError<'tcx>>\n     {\n-        // We provide a `Fn` impl for fn pointers. There is no need to provide\n-        // the other traits (e.g. `FnMut`) since those are provided by blanket\n-        // impls.\n-        if Some(obligation.predicate.def_id()) != self.tcx().lang_items.fn_trait() {\n+        // We provide impl of all fn traits for fn pointers.\n+        if self.tcx().lang_items.fn_trait_kind(obligation.predicate.def_id()).is_none() {\n             return Ok(());\n         }\n "}, {"sha": "92b444e85d8c3f5fa713bfc632c1272b50acf01f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 25, "deletions": 30, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -968,7 +968,7 @@ impl<'tcx> Eq for TyS<'tcx> {}\n \n impl<'tcx> Hash for TyS<'tcx> {\n     fn hash<H: Hasher>(&self, s: &mut H) {\n-        (self as *const _).hash(s)\n+        (self as *const TyS).hash(s)\n     }\n }\n \n@@ -1793,6 +1793,9 @@ impl RegionParameterDef {\n     pub fn to_early_bound_region(&self) -> ty::Region {\n         ty::ReEarlyBound(self.def_id.node, self.space, self.index, self.name)\n     }\n+    pub fn to_bound_region(&self) -> ty::BoundRegion {\n+        ty::BoundRegion::BrNamed(self.def_id, self.name)\n+    }\n }\n \n /// Information about the formal type/lifetime parameters associated\n@@ -2462,8 +2465,11 @@ pub struct ItemSubsts<'tcx> {\n     pub substs: Substs<'tcx>,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Debug, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Debug, RustcEncodable, RustcDecodable)]\n pub enum ClosureKind {\n+    // Warning: Ordering is significant here! The ordering is chosen\n+    // because the trait Fn is a subtrait of FnMut and so in turn, and\n+    // hence we order it so that Fn < FnMut < FnOnce.\n     FnClosureKind,\n     FnMutClosureKind,\n     FnOnceClosureKind,\n@@ -2485,6 +2491,20 @@ impl ClosureKind {\n             Err(err) => cx.sess.fatal(&err[..]),\n         }\n     }\n+\n+    /// True if this a type that impls this closure kind\n+    /// must also implement `other`.\n+    pub fn extends(self, other: ty::ClosureKind) -> bool {\n+        match (self, other) {\n+            (FnClosureKind, FnClosureKind) => true,\n+            (FnClosureKind, FnMutClosureKind) => true,\n+            (FnClosureKind, FnOnceClosureKind) => true,\n+            (FnMutClosureKind, FnMutClosureKind) => true,\n+            (FnMutClosureKind, FnOnceClosureKind) => true,\n+            (FnOnceClosureKind, FnOnceClosureKind) => true,\n+            _ => false,\n+        }\n+    }\n }\n \n pub trait ClosureTyper<'tcx> {\n@@ -2721,7 +2741,7 @@ fn intern_ty<'tcx>(type_arena: &'tcx TypedArena<TyS<'tcx>>,\n     };\n \n     debug!(\"Interned type: {:?} Pointer: {:?}\",\n-           ty, ty as *const _);\n+           ty, ty as *const TyS);\n \n     interner.insert(InternedTy { ty: ty }, ty);\n \n@@ -4806,32 +4826,6 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n             RvalueDpsExpr\n         }\n \n-        ast::ExprCast(..) => {\n-            match tcx.node_types.borrow().get(&expr.id) {\n-                Some(&ty) => {\n-                    if type_is_trait(ty) {\n-                        RvalueDpsExpr\n-                    } else {\n-                        RvalueDatumExpr\n-                    }\n-                }\n-                None => {\n-                    // Technically, it should not happen that the expr is not\n-                    // present within the table.  However, it DOES happen\n-                    // during type check, because the final types from the\n-                    // expressions are not yet recorded in the tcx.  At that\n-                    // time, though, we are only interested in knowing lvalue\n-                    // vs rvalue.  It would be better to base this decision on\n-                    // the AST type in cast node---but (at the time of this\n-                    // writing) it's not easy to distinguish casts to traits\n-                    // from other casts based on the AST.  This should be\n-                    // easier in the future, when casts to traits\n-                    // would like @Foo, Box<Foo>, or &Foo.\n-                    RvalueDatumExpr\n-                }\n-            }\n-        }\n-\n         ast::ExprBreak(..) |\n         ast::ExprAgain(..) |\n         ast::ExprRet(..) |\n@@ -4847,7 +4841,8 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n         ast::ExprUnary(..) |\n         ast::ExprBox(None, _) |\n         ast::ExprAddrOf(..) |\n-        ast::ExprBinary(..) => {\n+        ast::ExprBinary(..) |\n+        ast::ExprCast(..) => {\n             RvalueDatumExpr\n         }\n "}, {"sha": "8b57a48f3ce728355e345cb4b3415009ab00e885", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 24, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -84,30 +84,6 @@ impl LintPass for WhileTrue {\n     }\n }\n \n-declare_lint! {\n-    UNUSED_TYPECASTS,\n-    Allow,\n-    \"detects unnecessary type casts that can be removed\"\n-}\n-\n-#[derive(Copy)]\n-pub struct UnusedCasts;\n-\n-impl LintPass for UnusedCasts {\n-    fn get_lints(&self) -> LintArray {\n-        lint_array!(UNUSED_TYPECASTS)\n-    }\n-\n-    fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n-        if let ast::ExprCast(ref expr, ref ty) = e.node {\n-            let t_t = ty::expr_ty(cx.tcx, e);\n-            if ty::expr_ty(cx.tcx, &**expr) == t_t {\n-                cx.span_lint(UNUSED_TYPECASTS, ty.span, \"unnecessary type cast\");\n-            }\n-        }\n-    }\n-}\n-\n declare_lint! {\n     UNSIGNED_NEGATION,\n     Warn,\n@@ -1804,6 +1780,9 @@ impl LintPass for UnconditionalRecursion {\n \n     fn check_fn(&mut self, cx: &Context, fn_kind: visit::FnKind, _: &ast::FnDecl,\n                 blk: &ast::Block, sp: Span, id: ast::NodeId) {\n+        // FIXME(#23542) Replace with type ascription.\n+        #![allow(trivial_casts)]\n+\n         type F = for<'tcx> fn(&ty::ctxt<'tcx>,\n                               ast::NodeId, ast::NodeId, ast::Ident, ast::NodeId) -> bool;\n "}, {"sha": "e158541cd1cfffe8471fc3a9662070de078949c1", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -56,7 +56,7 @@ pub use rustc::session as session;\n pub use rustc::util as util;\n \n use session::Session;\n-use lint::{LintPassObject, LintId};\n+use lint::LintId;\n \n mod builtin;\n \n@@ -67,15 +67,15 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n     macro_rules! add_builtin {\n         ($sess:ident, $($name:ident),*,) => (\n             {$(\n-                store.register_pass($sess, false, box builtin::$name as LintPassObject);\n+                store.register_pass($sess, false, box builtin::$name);\n                 )*}\n             )\n     }\n \n     macro_rules! add_builtin_with_new {\n         ($sess:ident, $($name:ident),*,) => (\n             {$(\n-                store.register_pass($sess, false, box builtin::$name::new() as LintPassObject);\n+                store.register_pass($sess, false, box builtin::$name::new());\n                 )*}\n             )\n     }\n@@ -89,7 +89,6 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n     add_builtin!(sess,\n                  HardwiredLints,\n                  WhileTrue,\n-                 UnusedCasts,\n                  ImproperCTypes,\n                  BoxPointers,\n                  UnusedAttributes,\n@@ -129,7 +128,7 @@ pub fn register_builtins(store: &mut lint::LintStore, sess: Option<&Session>) {\n                     UNUSED_UNSAFE, PATH_STATEMENTS);\n \n     // We have one lint pass defined specially\n-    store.register_pass(sess, false, box lint::GatherNodeLevels as LintPassObject);\n+    store.register_pass(sess, false, box lint::GatherNodeLevels);\n \n     // Insert temporary renamings for a one-time deprecation\n     store.register_renamed(\"raw_pointer_deriving\", \"raw_pointer_derive\");"}, {"sha": "9d564fa56f54d88391f62a02fbe7690870f38d93", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -14,6 +14,8 @@\n #![allow(non_camel_case_types)]\n #![allow(non_snake_case)]\n #![allow(dead_code)]\n+#![allow(trivial_casts)]\n+#![allow(trivial_numeric_casts)]\n \n #![crate_name = \"rustc_llvm\"]\n #![unstable(feature = \"rustc_private\")]"}, {"sha": "99a64156d667b96d89a3cef297d4500ed0f6c33c", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -43,6 +43,9 @@\n #![feature(convert)]\n #![feature(path_relative_from)]\n \n+#![allow(trivial_casts)]\n+#![allow(trivial_numeric_casts)]\n+\n extern crate arena;\n extern crate flate;\n extern crate getopts;"}, {"sha": "e7911d5cc197006942987d85575ad302488b5037", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -264,24 +264,36 @@ fn trans_fn_ref_with_substs_to_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n /// but for the bare function type given.\n pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     ccx: &'a CrateContext<'a, 'tcx>,\n+    closure_kind: ty::ClosureKind,\n     bare_fn_ty: Ty<'tcx>)\n     -> ValueRef\n {\n     let _icx = push_ctxt(\"trans_fn_pointer_shim\");\n     let tcx = ccx.tcx();\n \n+    // Normalize the type for better caching.\n     let bare_fn_ty = common::erase_regions(tcx, &bare_fn_ty);\n-    match ccx.fn_pointer_shims().borrow().get(&bare_fn_ty) {\n+\n+    // If this is an impl of `Fn` or `FnMut` trait, the receiver is `&self`.\n+    let is_by_ref = match closure_kind {\n+        ty::FnClosureKind | ty::FnMutClosureKind => true,\n+        ty::FnOnceClosureKind => false,\n+    };\n+    let bare_fn_ty_maybe_ref = if is_by_ref {\n+        ty::mk_imm_rptr(tcx, tcx.mk_region(ty::ReStatic), bare_fn_ty)\n+    } else {\n+        bare_fn_ty\n+    };\n+\n+    // Check if we already trans'd this shim.\n+    match ccx.fn_pointer_shims().borrow().get(&bare_fn_ty_maybe_ref) {\n         Some(&llval) => { return llval; }\n         None => { }\n     }\n \n     debug!(\"trans_fn_pointer_shim(bare_fn_ty={})\",\n            bare_fn_ty.repr(tcx));\n \n-    // This is an impl of `Fn` trait, so receiver is `&self`.\n-    let bare_fn_ty_ref = ty::mk_imm_rptr(tcx, tcx.mk_region(ty::ReStatic), bare_fn_ty);\n-\n     // Construct the \"tuply\" version of `bare_fn_ty`. It takes two arguments: `self`,\n     // which is the fn pointer, and `args`, which is the arguments tuple.\n     let (opt_def_id, sig) =\n@@ -306,7 +318,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                                          unsafety: ast::Unsafety::Normal,\n                                          abi: synabi::RustCall,\n                                          sig: ty::Binder(ty::FnSig {\n-                                             inputs: vec![bare_fn_ty_ref,\n+                                             inputs: vec![bare_fn_ty_maybe_ref,\n                                                           tuple_input_ty],\n                                              output: sig.output,\n                                              variadic: false\n@@ -337,8 +349,11 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let mut bcx = init_function(&fcx, false, sig.output);\n \n     // the first argument (`self`) will be ptr to the the fn pointer\n-    let llfnpointer =\n-        Load(bcx, get_param(fcx.llfn, fcx.arg_pos(0) as u32));\n+    let llfnpointer = if is_by_ref {\n+        Load(bcx, get_param(fcx.llfn, fcx.arg_pos(0) as u32))\n+    } else {\n+        get_param(fcx.llfn, fcx.arg_pos(0) as u32)\n+    };\n \n     // the remaining arguments will be the untupled values\n     let llargs: Vec<_> =\n@@ -361,7 +376,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n \n     finish_fn(&fcx, bcx, sig.output, DebugLoc::None);\n \n-    ccx.fn_pointer_shims().borrow_mut().insert(bare_fn_ty, llfn);\n+    ccx.fn_pointer_shims().borrow_mut().insert(bare_fn_ty_maybe_ref, llfn);\n \n     llfn\n }"}, {"sha": "5a48b8e4bce1d37acb4ae77844ff80a2e674c864", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 193, "deletions": 11, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -8,24 +8,27 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use back::link::mangle_internal_name_by_path_and_seq;\n-use llvm::ValueRef;\n+use arena::TypedArena;\n+use back::link::{self, mangle_internal_name_by_path_and_seq};\n+use llvm::{ValueRef, get_param};\n use middle::mem_categorization::Typer;\n use trans::adt;\n use trans::base::*;\n use trans::build::*;\n-use trans::cleanup::{CleanupMethods, ScopeId};\n+use trans::callee::{self, ArgVals, Callee, TraitItem, MethodData};\n+use trans::cleanup::{CleanupMethods, CustomScope, ScopeId};\n use trans::common::*;\n-use trans::datum::{Datum, rvalue_scratch_datum};\n-use trans::datum::{Rvalue, ByValue};\n-use trans::debuginfo;\n+use trans::datum::{self, Datum, rvalue_scratch_datum, Rvalue, ByValue};\n+use trans::debuginfo::{self, DebugLoc};\n use trans::expr;\n use trans::monomorphize::{self, MonoId};\n use trans::type_of::*;\n use middle::ty::{self, ClosureTyper};\n use middle::subst::{Substs};\n use session::config::FullDebugInfo;\n+use util::ppaux::Repr;\n \n+use syntax::abi::RustCall;\n use syntax::ast;\n use syntax::ast_util;\n \n@@ -239,11 +242,7 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n     // Create the closure.\n     for (i, freevar) in freevars.iter().enumerate() {\n         let datum = expr::trans_local_var(bcx, freevar.def);\n-        let upvar_slot_dest = adt::trans_field_ptr(bcx,\n-                                                   &*repr,\n-                                                   dest_addr,\n-                                                   0,\n-                                                   i);\n+        let upvar_slot_dest = adt::trans_field_ptr(bcx, &*repr, dest_addr, 0, i);\n         let upvar_id = ty::UpvarId { var_id: freevar.def.local_node_id(),\n                                      closure_expr_id: id };\n         match tcx.upvar_capture(upvar_id).unwrap() {\n@@ -259,3 +258,186 @@ pub fn trans_closure_expr<'a, 'tcx>(dest: Dest<'a, 'tcx>,\n \n     Some(bcx)\n }\n+\n+pub fn trans_closure_method<'a, 'tcx>(ccx: &'a CrateContext<'a, 'tcx>,\n+                                      closure_def_id: ast::DefId,\n+                                      substs: Substs<'tcx>,\n+                                      node: ExprOrMethodCall,\n+                                      param_substs: &'tcx Substs<'tcx>,\n+                                      trait_closure_kind: ty::ClosureKind)\n+                                      -> ValueRef\n+{\n+    // The substitutions should have no type parameters remaining\n+    // after passing through fulfill_obligation\n+    let llfn = callee::trans_fn_ref_with_substs(ccx,\n+                                                closure_def_id,\n+                                                node,\n+                                                param_substs,\n+                                                substs.clone()).val;\n+\n+    // If the closure is a Fn closure, but a FnOnce is needed (etc),\n+    // then adapt the self type\n+    let closure_kind = ccx.tcx().closure_kind(closure_def_id);\n+    trans_closure_adapter_shim(ccx,\n+                               closure_def_id,\n+                               substs,\n+                               closure_kind,\n+                               trait_closure_kind,\n+                               llfn)\n+}\n+\n+fn trans_closure_adapter_shim<'a, 'tcx>(\n+    ccx: &'a CrateContext<'a, 'tcx>,\n+    closure_def_id: ast::DefId,\n+    substs: Substs<'tcx>,\n+    llfn_closure_kind: ty::ClosureKind,\n+    trait_closure_kind: ty::ClosureKind,\n+    llfn: ValueRef)\n+    -> ValueRef\n+{\n+    let _icx = push_ctxt(\"trans_closure_adapter_shim\");\n+    let tcx = ccx.tcx();\n+\n+    debug!(\"trans_closure_adapter_shim(llfn_closure_kind={:?}, \\\n+           trait_closure_kind={:?}, \\\n+           llfn={})\",\n+           llfn_closure_kind,\n+           trait_closure_kind,\n+           ccx.tn().val_to_string(llfn));\n+\n+    match (llfn_closure_kind, trait_closure_kind) {\n+        (ty::FnClosureKind, ty::FnClosureKind) |\n+        (ty::FnMutClosureKind, ty::FnMutClosureKind) |\n+        (ty::FnOnceClosureKind, ty::FnOnceClosureKind) => {\n+            // No adapter needed.\n+            llfn\n+        }\n+        (ty::FnClosureKind, ty::FnMutClosureKind) => {\n+            // The closure fn `llfn` is a `fn(&self, ...)`.  We want a\n+            // `fn(&mut self, ...)`. In fact, at trans time, these are\n+            // basically the same thing, so we can just return llfn.\n+            llfn\n+        }\n+        (ty::FnClosureKind, ty::FnOnceClosureKind) |\n+        (ty::FnMutClosureKind, ty::FnOnceClosureKind) => {\n+            // The closure fn `llfn` is a `fn(&self, ...)` or `fn(&mut\n+            // self, ...)`.  We want a `fn(self, ...)`. We can produce\n+            // this by doing something like:\n+            //\n+            //     fn call_once(self, ...) { call_mut(&self, ...) }\n+            //     fn call_once(mut self, ...) { call_mut(&mut self, ...) }\n+            //\n+            // These are both the same at trans time.\n+            trans_fn_once_adapter_shim(ccx, closure_def_id, substs, llfn)\n+        }\n+        _ => {\n+            tcx.sess.bug(&format!(\"trans_closure_adapter_shim: cannot convert {:?} to {:?}\",\n+                                  llfn_closure_kind,\n+                                  trait_closure_kind));\n+        }\n+    }\n+}\n+\n+fn trans_fn_once_adapter_shim<'a, 'tcx>(\n+    ccx: &'a CrateContext<'a, 'tcx>,\n+    closure_def_id: ast::DefId,\n+    substs: Substs<'tcx>,\n+    llreffn: ValueRef)\n+    -> ValueRef\n+{\n+    debug!(\"trans_fn_once_adapter_shim(closure_def_id={}, substs={}, llreffn={})\",\n+           closure_def_id.repr(ccx.tcx()),\n+           substs.repr(ccx.tcx()),\n+           ccx.tn().val_to_string(llreffn));\n+\n+    let tcx = ccx.tcx();\n+    let typer = NormalizingClosureTyper::new(tcx);\n+\n+    // Find a version of the closure type. Substitute static for the\n+    // region since it doesn't really matter.\n+    let substs = tcx.mk_substs(substs);\n+    let closure_ty = ty::mk_closure(tcx, closure_def_id, substs);\n+    let ref_closure_ty = ty::mk_imm_rptr(tcx, tcx.mk_region(ty::ReStatic), closure_ty);\n+\n+    // Make a version with the type of by-ref closure.\n+    let ty::ClosureTy { unsafety, abi, mut sig } = typer.closure_type(closure_def_id, substs);\n+    sig.0.inputs.insert(0, ref_closure_ty); // sig has no self type as of yet\n+    let llref_bare_fn_ty = tcx.mk_bare_fn(ty::BareFnTy { unsafety: unsafety,\n+                                                               abi: abi,\n+                                                               sig: sig.clone() });\n+    let llref_fn_ty = ty::mk_bare_fn(tcx, None, llref_bare_fn_ty);\n+    debug!(\"trans_fn_once_adapter_shim: llref_fn_ty={}\",\n+           llref_fn_ty.repr(tcx));\n+\n+    // Make a version of the closure type with the same arguments, but\n+    // with argument #0 being by value.\n+    assert_eq!(abi, RustCall);\n+    sig.0.inputs[0] = closure_ty;\n+    let llonce_bare_fn_ty = tcx.mk_bare_fn(ty::BareFnTy { unsafety: unsafety,\n+                                                                abi: abi,\n+                                                                sig: sig });\n+    let llonce_fn_ty = ty::mk_bare_fn(tcx, None, llonce_bare_fn_ty);\n+\n+    // Create the by-value helper.\n+    let function_name = link::mangle_internal_name_by_type_and_seq(ccx, llonce_fn_ty, \"once_shim\");\n+    let lloncefn = decl_internal_rust_fn(ccx, llonce_fn_ty, &function_name);\n+\n+    let sig = ty::erase_late_bound_regions(tcx, &llonce_bare_fn_ty.sig);\n+    let (block_arena, fcx): (TypedArena<_>, FunctionContext);\n+    block_arena = TypedArena::new();\n+    fcx = new_fn_ctxt(ccx,\n+                      lloncefn,\n+                      ast::DUMMY_NODE_ID,\n+                      false,\n+                      sig.output,\n+                      substs,\n+                      None,\n+                      &block_arena);\n+    let mut bcx = init_function(&fcx, false, sig.output);\n+\n+    // the first argument (`self`) will be the (by value) closure env.\n+    let self_scope = fcx.push_custom_cleanup_scope();\n+    let self_scope_id = CustomScope(self_scope);\n+    let rvalue_mode = datum::appropriate_rvalue_mode(ccx, closure_ty);\n+    let llself = get_param(lloncefn, fcx.arg_pos(0) as u32);\n+    let env_datum = Datum::new(llself, closure_ty, Rvalue::new(rvalue_mode));\n+    let env_datum = unpack_datum!(bcx,\n+                                  env_datum.to_lvalue_datum_in_scope(bcx, \"self\",\n+                                                                     self_scope_id));\n+\n+    debug!(\"trans_fn_once_adapter_shim: env_datum={}\",\n+           bcx.val_to_string(env_datum.val));\n+\n+    // the remaining arguments will be packed up in a tuple.\n+    let input_tys = match sig.inputs[1].sty {\n+        ty::ty_tup(ref tys) => &**tys,\n+        _ => bcx.sess().bug(&format!(\"trans_fn_once_adapter_shim: not rust-call! \\\n+                                      closure_def_id={}\",\n+                                     closure_def_id.repr(tcx)))\n+    };\n+    let llargs: Vec<_> =\n+        input_tys.iter()\n+                 .enumerate()\n+                 .map(|(i, _)| get_param(lloncefn, fcx.arg_pos(i+1) as u32))\n+                 .collect();\n+\n+    let dest =\n+        fcx.llretslotptr.get().map(\n+            |_| expr::SaveIn(fcx.get_ret_slot(bcx, sig.output, \"ret_slot\")));\n+\n+    let callee_data = TraitItem(MethodData { llfn: llreffn,\n+                                             llself: env_datum.val });\n+\n+    bcx = callee::trans_call_inner(bcx,\n+                                   DebugLoc::None,\n+                                   llref_fn_ty,\n+                                   |bcx, _| Callee { bcx: bcx, data: callee_data },\n+                                   ArgVals(&llargs),\n+                                   dest).bcx;\n+\n+    fcx.pop_custom_cleanup_scope(self_scope);\n+\n+    finish_fn(&fcx, bcx, sig.output, DebugLoc::None);\n+\n+    lloncefn\n+}"}, {"sha": "15738d1e61ac14122f0161df205f0d536ebca146", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -471,15 +471,6 @@ impl<'tcx> Datum<'tcx, Expr> {\n             })\n     }\n \n-    /// Ensures that `self` will get cleaned up, if it is not an lvalue already.\n-    pub fn clean<'blk>(self,\n-                       bcx: Block<'blk, 'tcx>,\n-                       name: &'static str,\n-                       expr_id: ast::NodeId)\n-                       -> Block<'blk, 'tcx> {\n-        self.to_lvalue_datum(bcx, name, expr_id).bcx\n-    }\n-\n     pub fn to_lvalue_datum<'blk>(self,\n                                  bcx: Block<'blk, 'tcx>,\n                                  name: &str,"}, {"sha": "4d7431a20b707e098f3ef6ea54f03b7853ea2763", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -1227,22 +1227,9 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             trans_overloaded_op(bcx, expr, MethodCall::expr(expr.id), base,\n                                 vec![(idx_datum, idx.id)], Some(dest), true).bcx\n         }\n-        ast::ExprCast(ref val, _) => {\n-            // DPS output mode means this is a trait cast:\n-            if ty::type_is_trait(node_id_type(bcx, expr.id)) {\n-                let trait_ref =\n-                    bcx.tcx().object_cast_map.borrow()\n-                                             .get(&expr.id)\n-                                             .cloned()\n-                                             .unwrap();\n-                let trait_ref = bcx.monomorphize(&trait_ref);\n-                let datum = unpack_datum!(bcx, trans(bcx, &**val));\n-                meth::trans_trait_cast(bcx, datum, expr.id,\n-                                       trait_ref, dest)\n-            } else {\n-                bcx.tcx().sess.span_bug(expr.span,\n-                                        \"expr_cast of non-trait\");\n-            }\n+        ast::ExprCast(..) => {\n+            // Trait casts used to come this way, now they should be coercions.\n+            bcx.tcx().sess.span_bug(expr.span, \"DPS expr_cast (residual trait cast?)\")\n         }\n         ast::ExprAssignOp(op, ref dst, ref src) => {\n             trans_assign_op(bcx, expr, op, &**dst, &**src)\n@@ -2091,7 +2078,7 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let mut bcx = bcx;\n     let ccx = bcx.ccx();\n \n-    let t_in = expr_ty(bcx, expr);\n+    let t_in = expr_ty_adjusted(bcx, expr);\n     let t_out = node_id_type(bcx, id);\n     let k_in = cast_type_kind(bcx.tcx(), t_in);\n     let k_out = cast_type_kind(bcx.tcx(), t_out);\n@@ -2103,7 +2090,8 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // by-value as appropriate given its type:\n     let mut datum = unpack_datum!(bcx, trans(bcx, expr));\n \n-    if cast_is_noop(datum.ty, t_out) {\n+    let datum_ty = monomorphize_type(bcx, datum.ty);\n+    if cast_is_noop(datum_ty, t_out) {\n         datum.ty = t_out;\n         return DatumBlock::new(bcx, datum);\n     }"}, {"sha": "1a38b3d142676f1a717c395a702d4a6a5302e0fe", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 21, "deletions": 57, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -17,16 +17,18 @@ use middle::subst::Substs;\n use middle::subst::VecPerParamSpace;\n use middle::subst;\n use middle::traits;\n+use middle::ty::ClosureTyper;\n use trans::base::*;\n use trans::build::*;\n use trans::callee::*;\n use trans::callee;\n use trans::cleanup;\n+use trans::closure;\n use trans::common::*;\n use trans::consts;\n use trans::datum::*;\n use trans::debuginfo::DebugLoc;\n-use trans::expr::{SaveIn, Ignore};\n+use trans::expr::SaveIn;\n use trans::expr;\n use trans::glue;\n use trans::machine;\n@@ -358,19 +360,21 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         traits::VtableClosure(closure_def_id, substs) => {\n             // The substitutions should have no type parameters remaining\n             // after passing through fulfill_obligation\n-            let llfn = trans_fn_ref_with_substs(bcx.ccx(),\n-                                                closure_def_id,\n-                                                MethodCallKey(method_call),\n-                                                bcx.fcx.param_substs,\n-                                                substs).val;\n-\n+            let trait_closure_kind = bcx.tcx().lang_items.fn_trait_kind(trait_id).unwrap();\n+            let llfn = closure::trans_closure_method(bcx.ccx(),\n+                                                     closure_def_id,\n+                                                     substs,\n+                                                     MethodCallKey(method_call),\n+                                                     bcx.fcx.param_substs,\n+                                                     trait_closure_kind);\n             Callee {\n                 bcx: bcx,\n                 data: Fn(llfn),\n             }\n         }\n         traits::VtableFnPointer(fn_ty) => {\n-            let llfn = trans_fn_pointer_shim(bcx.ccx(), fn_ty);\n+            let trait_closure_kind = bcx.tcx().lang_items.fn_trait_kind(trait_id).unwrap();\n+            let llfn = trans_fn_pointer_shim(bcx.ccx(), trait_closure_kind, fn_ty);\n             Callee { bcx: bcx, data: Fn(llfn) }\n         }\n         traits::VtableObject(ref data) => {\n@@ -645,9 +649,6 @@ pub fn trans_object_shim<'a, 'tcx>(\n \n     assert!(!fcx.needs_ret_allocas);\n \n-    let sig =\n-        ty::erase_late_bound_regions(bcx.tcx(), &fty.sig);\n-\n     let dest =\n         fcx.llretslotptr.get().map(\n             |_| expr::SaveIn(fcx.get_ret_slot(bcx, sig.output, \"ret_slot\")));\n@@ -714,17 +715,18 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 emit_vtable_methods(ccx, id, substs, param_substs).into_iter()\n             }\n             traits::VtableClosure(closure_def_id, substs) => {\n-                let llfn = trans_fn_ref_with_substs(\n-                    ccx,\n-                    closure_def_id,\n-                    ExprId(0),\n-                    param_substs,\n-                    substs).val;\n-\n+                let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_ref.def_id()).unwrap();\n+                let llfn = closure::trans_closure_method(ccx,\n+                                                         closure_def_id,\n+                                                         substs,\n+                                                         ExprId(0),\n+                                                         param_substs,\n+                                                         trait_closure_kind);\n                 vec![llfn].into_iter()\n             }\n             traits::VtableFnPointer(bare_fn_ty) => {\n-                vec![trans_fn_pointer_shim(ccx, bare_fn_ty)].into_iter()\n+                let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_ref.def_id()).unwrap();\n+                vec![trans_fn_pointer_shim(ccx, trait_closure_kind, bare_fn_ty)].into_iter()\n             }\n             traits::VtableObject(ref data) => {\n                 // this would imply that the Self type being erased is\n@@ -861,44 +863,6 @@ fn emit_vtable_methods<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         .collect()\n }\n \n-/// Generates the code to convert from a pointer (`Box<T>`, `&T`, etc) into an object\n-/// (`Box<Trait>`, `&Trait`, etc). This means creating a pair where the first word is the vtable\n-/// and the second word is the pointer.\n-pub fn trans_trait_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                    datum: Datum<'tcx, Expr>,\n-                                    id: ast::NodeId,\n-                                    trait_ref: ty::PolyTraitRef<'tcx>,\n-                                    dest: expr::Dest)\n-                                    -> Block<'blk, 'tcx> {\n-    let mut bcx = bcx;\n-    let _icx = push_ctxt(\"meth::trans_trait_cast\");\n-\n-    let lldest = match dest {\n-        Ignore => {\n-            return datum.clean(bcx, \"trait_trait_cast\", id);\n-        }\n-        SaveIn(dest) => dest\n-    };\n-\n-    debug!(\"trans_trait_cast: trait_ref={}\",\n-           trait_ref.repr(bcx.tcx()));\n-\n-    let llty = type_of(bcx.ccx(), datum.ty);\n-\n-    // Store the pointer into the first half of pair.\n-    let llboxdest = GEPi(bcx, lldest, &[0, abi::FAT_PTR_ADDR]);\n-    let llboxdest = PointerCast(bcx, llboxdest, llty.ptr_to());\n-    bcx = datum.store_to(bcx, llboxdest);\n-\n-    // Store the vtable into the second half of pair.\n-    let vtable = get_vtable(bcx.ccx(), trait_ref, bcx.fcx.param_substs);\n-    let llvtabledest = GEPi(bcx, lldest, &[0, abi::FAT_PTR_EXTRA]);\n-    let llvtabledest = PointerCast(bcx, llvtabledest, val_ty(vtable).ptr_to());\n-    Store(bcx, vtable, llvtabledest);\n-\n-    bcx\n-}\n-\n /// Replace the self type (&Self or Box<Self>) with an opaque pointer.\n pub fn opaque_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>, method_ty: &ty::BareFnTy<'tcx>)\n         -> &'tcx ty::BareFnTy<'tcx> {"}, {"sha": "e9de8bd879e202342cbe00df6e0d61ec3adf812c", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 133, "deletions": 110, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -55,7 +55,7 @@ use middle::resolve_lifetime as rl;\n use middle::privacy::{AllPublic, LastMod};\n use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs};\n use middle::traits;\n-use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty};\n+use middle::ty::{self, RegionEscape, Ty};\n use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope,\n              ObjectLifetimeDefaultRscope, ShiftedRscope, BindingRscope};\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n@@ -608,24 +608,16 @@ pub fn instantiate_poly_trait_ref<'tcx>(\n     poly_projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n     -> ty::PolyTraitRef<'tcx>\n {\n-    let mut projections = Vec::new();\n-\n-    // The trait reference introduces a binding level here, so\n-    // we need to shift the `rscope`. It'd be nice if we could\n-    // do away with this rscope stuff and work this knowledge\n-    // into resolve_lifetimes, as we do with non-omitted\n-    // lifetimes. Oh well, not there yet.\n-    let shifted_rscope = ShiftedRscope::new(rscope);\n-\n-    let trait_ref = instantiate_trait_ref(this, &shifted_rscope,\n-                                          &ast_trait_ref.trait_ref,\n-                                          None, self_ty, Some(&mut projections));\n-\n-    for projection in projections {\n-        poly_projections.push(ty::Binder(projection));\n-    }\n-\n-    ty::Binder(trait_ref)\n+    let trait_ref = &ast_trait_ref.trait_ref;\n+    let trait_def_id = trait_def_id(this, trait_ref);\n+    ast_path_to_poly_trait_ref(this,\n+                               rscope,\n+                               trait_ref.path.span,\n+                               PathParamMode::Explicit,\n+                               trait_def_id,\n+                               self_ty,\n+                               trait_ref.path.segments.last().unwrap(),\n+                               poly_projections)\n }\n \n /// Instantiates the path for the given trait reference, assuming that it's\n@@ -634,31 +626,27 @@ pub fn instantiate_poly_trait_ref<'tcx>(\n ///\n /// If the `projections` argument is `None`, then assoc type bindings like `Foo<T=X>`\n /// are disallowed. Otherwise, they are pushed onto the vector given.\n-pub fn instantiate_trait_ref<'tcx>(\n+pub fn instantiate_mono_trait_ref<'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n     trait_ref: &ast::TraitRef,\n-    impl_id: Option<ast::NodeId>,\n-    self_ty: Option<Ty<'tcx>>,\n-    projections: Option<&mut Vec<ty::ProjectionPredicate<'tcx>>>)\n+    self_ty: Option<Ty<'tcx>>)\n     -> Rc<ty::TraitRef<'tcx>>\n {\n+    let trait_def_id = trait_def_id(this, trait_ref);\n+    ast_path_to_mono_trait_ref(this,\n+                               rscope,\n+                               trait_ref.path.span,\n+                               PathParamMode::Explicit,\n+                               trait_def_id,\n+                               self_ty,\n+                               trait_ref.path.segments.last().unwrap())\n+}\n+\n+fn trait_def_id<'tcx>(this: &AstConv<'tcx>, trait_ref: &ast::TraitRef) -> ast::DefId {\n     let path = &trait_ref.path;\n     match ::lookup_full_def(this.tcx(), path.span, trait_ref.ref_id) {\n-        def::DefTrait(trait_def_id) => {\n-            let trait_ref = ast_path_to_trait_ref(this,\n-                                                  rscope,\n-                                                  path.span,\n-                                                  PathParamMode::Explicit,\n-                                                  trait_def_id,\n-                                                  self_ty,\n-                                                  path.segments.last().unwrap(),\n-                                                  projections);\n-            if let Some(id) = impl_id {\n-                this.tcx().impl_trait_refs.borrow_mut().insert(id, trait_ref.clone());\n-            }\n-            trait_ref\n-        }\n+        def::DefTrait(trait_def_id) => trait_def_id,\n         _ => {\n             span_fatal!(this.tcx().sess, path.span, E0245, \"`{}` is not a trait\",\n                         path.user_string(this.tcx()));\n@@ -676,35 +664,96 @@ fn object_path_to_poly_trait_ref<'a,'tcx>(\n     mut projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n     -> ty::PolyTraitRef<'tcx>\n {\n-    // we are introducing a binder here, so shift the\n-    // anonymous regions depth to account for that\n-    let shifted_rscope = ShiftedRscope::new(rscope);\n-\n-    let mut tmp = Vec::new();\n-    let trait_ref = ty::Binder(ast_path_to_trait_ref(this,\n-                                                     &shifted_rscope,\n-                                                     span,\n-                                                     param_mode,\n-                                                     trait_def_id,\n-                                                     None,\n-                                                     trait_segment,\n-                                                     Some(&mut tmp)));\n-    projections.extend(tmp.into_iter().map(ty::Binder));\n-    trait_ref\n+    ast_path_to_poly_trait_ref(this,\n+                               rscope,\n+                               span,\n+                               param_mode,\n+                               trait_def_id,\n+                               None,\n+                               trait_segment,\n+                               projections)\n }\n \n-fn ast_path_to_trait_ref<'a,'tcx>(\n+fn ast_path_to_poly_trait_ref<'a,'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n     span: Span,\n     param_mode: PathParamMode,\n     trait_def_id: ast::DefId,\n     self_ty: Option<Ty<'tcx>>,\n     trait_segment: &ast::PathSegment,\n-    mut projections: Option<&mut Vec<ty::ProjectionPredicate<'tcx>>>)\n-    -> Rc<ty::TraitRef<'tcx>>\n+    poly_projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n+    -> ty::PolyTraitRef<'tcx>\n+{\n+    // The trait reference introduces a binding level here, so\n+    // we need to shift the `rscope`. It'd be nice if we could\n+    // do away with this rscope stuff and work this knowledge\n+    // into resolve_lifetimes, as we do with non-omitted\n+    // lifetimes. Oh well, not there yet.\n+    let shifted_rscope = &ShiftedRscope::new(rscope);\n+\n+    let (substs, assoc_bindings) =\n+        create_substs_for_ast_trait_ref(this,\n+                                        shifted_rscope,\n+                                        span,\n+                                        param_mode,\n+                                        trait_def_id,\n+                                        self_ty,\n+                                        trait_segment);\n+    let poly_trait_ref = ty::Binder(Rc::new(ty::TraitRef::new(trait_def_id, substs)));\n+\n+    {\n+        let converted_bindings =\n+            assoc_bindings\n+            .iter()\n+            .filter_map(|binding| {\n+                // specify type to assert that error was already reported in Err case:\n+                let predicate: Result<_, ErrorReported> =\n+                    ast_type_binding_to_poly_projection_predicate(this,\n+                                                                  poly_trait_ref.clone(),\n+                                                                  self_ty,\n+                                                                  binding);\n+                predicate.ok() // ok to ignore Err() because ErrorReported (see above)\n+            });\n+        poly_projections.extend(converted_bindings);\n+    }\n+\n+    poly_trait_ref\n+}\n+\n+fn ast_path_to_mono_trait_ref<'a,'tcx>(this: &AstConv<'tcx>,\n+                                       rscope: &RegionScope,\n+                                       span: Span,\n+                                       param_mode: PathParamMode,\n+                                       trait_def_id: ast::DefId,\n+                                       self_ty: Option<Ty<'tcx>>,\n+                                       trait_segment: &ast::PathSegment)\n+                                       -> Rc<ty::TraitRef<'tcx>>\n {\n-    debug!(\"ast_path_to_trait_ref {:?}\", trait_segment);\n+    let (substs, assoc_bindings) =\n+        create_substs_for_ast_trait_ref(this,\n+                                        rscope,\n+                                        span,\n+                                        param_mode,\n+                                        trait_def_id,\n+                                        self_ty,\n+                                        trait_segment);\n+    prohibit_projections(this.tcx(), &assoc_bindings);\n+    Rc::new(ty::TraitRef::new(trait_def_id, substs))\n+}\n+\n+fn create_substs_for_ast_trait_ref<'a,'tcx>(this: &AstConv<'tcx>,\n+                                            rscope: &RegionScope,\n+                                            span: Span,\n+                                            param_mode: PathParamMode,\n+                                            trait_def_id: ast::DefId,\n+                                            self_ty: Option<Ty<'tcx>>,\n+                                            trait_segment: &ast::PathSegment)\n+                                            -> (&'tcx Substs<'tcx>, Vec<ConvertedBinding<'tcx>>)\n+{\n+    debug!(\"create_substs_for_ast_trait_ref(trait_segment={:?})\",\n+           trait_segment);\n+\n     let trait_def = match this.get_trait_def(span, trait_def_id) {\n         Ok(trait_def) => trait_def,\n         Err(ErrorReported) => {\n@@ -752,34 +801,16 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n                                             self_ty,\n                                             types,\n                                             regions);\n-    let substs = this.tcx().mk_substs(substs);\n \n-    let trait_ref = Rc::new(ty::TraitRef::new(trait_def_id, substs));\n-\n-    match projections {\n-        None => {\n-            prohibit_projections(this.tcx(), &assoc_bindings);\n-        }\n-        Some(ref mut v) => {\n-            for binding in &assoc_bindings {\n-                match ast_type_binding_to_projection_predicate(this, trait_ref.clone(),\n-                                                               self_ty, binding) {\n-                    Ok(pp) => { v.push(pp); }\n-                    Err(ErrorReported) => { }\n-                }\n-            }\n-        }\n-    }\n-\n-    trait_ref\n+    (this.tcx().mk_substs(substs), assoc_bindings)\n }\n \n-fn ast_type_binding_to_projection_predicate<'tcx>(\n+fn ast_type_binding_to_poly_projection_predicate<'tcx>(\n     this: &AstConv<'tcx>,\n-    mut trait_ref: Rc<ty::TraitRef<'tcx>>,\n+    mut trait_ref: ty::PolyTraitRef<'tcx>,\n     self_ty: Option<Ty<'tcx>>,\n     binding: &ConvertedBinding<'tcx>)\n-    -> Result<ty::ProjectionPredicate<'tcx>, ErrorReported>\n+    -> Result<ty::PolyProjectionPredicate<'tcx>, ErrorReported>\n {\n     let tcx = this.tcx();\n \n@@ -800,14 +831,14 @@ fn ast_type_binding_to_projection_predicate<'tcx>(\n     // We want to produce `<B as SuperTrait<int>>::T == foo`.\n \n     // Simple case: X is defined in the current trait.\n-    if this.trait_defines_associated_type_named(trait_ref.def_id, binding.item_name) {\n-        return Ok(ty::ProjectionPredicate {\n-            projection_ty: ty::ProjectionTy {\n-                trait_ref: trait_ref,\n+    if this.trait_defines_associated_type_named(trait_ref.def_id(), binding.item_name) {\n+        return Ok(ty::Binder(ty::ProjectionPredicate {      // <-------------------+\n+            projection_ty: ty::ProjectionTy {               //                     |\n+                trait_ref: trait_ref.skip_binder().clone(), // Binder moved here --+\n                 item_name: binding.item_name,\n             },\n             ty: binding.ty,\n-        });\n+        }));\n     }\n \n     // Otherwise, we have to walk through the supertraits to find\n@@ -820,17 +851,17 @@ fn ast_type_binding_to_projection_predicate<'tcx>(\n \n     let dummy_self_ty = ty::mk_infer(tcx, ty::FreshTy(0));\n     if self_ty.is_none() { // if converting for an object type\n-        let mut dummy_substs = trait_ref.substs.clone();\n-        assert!(dummy_substs.self_ty().is_none());\n-        dummy_substs.types.push(SelfSpace, dummy_self_ty);\n-        trait_ref = Rc::new(ty::TraitRef::new(trait_ref.def_id,\n-                                              tcx.mk_substs(dummy_substs)));\n+        let mut dummy_substs = trait_ref.skip_binder().substs.clone(); // binder moved here -+\n+        assert!(dummy_substs.self_ty().is_none());                     //                    |\n+        dummy_substs.types.push(SelfSpace, dummy_self_ty);             //                    |\n+        trait_ref = ty::Binder(Rc::new(ty::TraitRef::new(trait_ref.def_id(), // <------------+\n+                                                         tcx.mk_substs(dummy_substs))));\n     }\n \n-    try!(this.ensure_super_predicates(binding.span, trait_ref.def_id));\n+    try!(this.ensure_super_predicates(binding.span, trait_ref.def_id()));\n \n     let mut candidates: Vec<ty::PolyTraitRef> =\n-        traits::supertraits(tcx, trait_ref.to_poly_trait_ref())\n+        traits::supertraits(tcx, trait_ref.clone())\n         .filter(|r| this.trait_defines_associated_type_named(r.def_id(), binding.item_name))\n         .collect();\n \n@@ -865,21 +896,13 @@ fn ast_type_binding_to_projection_predicate<'tcx>(\n         }\n     };\n \n-    if ty::binds_late_bound_regions(tcx, &candidate) {\n-        span_err!(tcx.sess, binding.span, E0219,\n-            \"associated type `{}` defined in higher-ranked supertrait `{}`\",\n-                    token::get_name(binding.item_name),\n-                    candidate.user_string(tcx));\n-        return Err(ErrorReported);\n-    }\n-\n-    Ok(ty::ProjectionPredicate {\n-        projection_ty: ty::ProjectionTy {\n-            trait_ref: candidate.0,\n+    Ok(ty::Binder(ty::ProjectionPredicate {             // <-------------------------+\n+        projection_ty: ty::ProjectionTy {               //                           |\n+            trait_ref: candidate.skip_binder().clone(), // binder is moved up here --+\n             item_name: binding.item_name,\n         },\n         ty: binding.ty,\n-    })\n+    }))\n }\n \n fn ast_path_to_ty<'tcx>(\n@@ -1134,14 +1157,14 @@ fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n \n     debug!(\"qpath_to_ty: self_type={}\", self_ty.repr(tcx));\n \n-    let trait_ref = ast_path_to_trait_ref(this,\n-                                          rscope,\n-                                          span,\n-                                          param_mode,\n-                                          trait_def_id,\n-                                          Some(self_ty),\n-                                          trait_segment,\n-                                          None);\n+    let trait_ref =\n+        ast_path_to_mono_trait_ref(this,\n+                                   rscope,\n+                                   span,\n+                                   param_mode,\n+                                   trait_def_id,\n+                                   Some(self_ty),\n+                                   trait_segment);\n \n     debug!(\"qpath_to_ty: trait_ref={}\", trait_ref.repr(tcx));\n "}, {"sha": "d2a06fcf9909138d1a1b354350c9dc1ea903b5ce", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -16,6 +16,7 @@ use astconv;\n use middle::region;\n use middle::subst;\n use middle::ty::{self, ToPolyTraitRef, Ty};\n+use std::cmp;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast_util;\n@@ -109,15 +110,11 @@ fn deduce_expectations_from_expected_type<'a,'tcx>(\n         ty::ty_trait(ref object_type) => {\n             let proj_bounds = object_type.projection_bounds_with_self_ty(fcx.tcx(),\n                                                                          fcx.tcx().types.err);\n-            let expectations =\n-                proj_bounds.iter()\n-                           .filter_map(|pb| deduce_expectations_from_projection(fcx, pb))\n-                           .next();\n-\n-            match expectations {\n-                Some((sig, kind)) => (Some(sig), Some(kind)),\n-                None => (None, None)\n-            }\n+            let sig = proj_bounds.iter()\n+                                 .filter_map(|pb| deduce_sig_from_projection(fcx, pb))\n+                                 .next();\n+            let kind = fcx.tcx().lang_items.fn_trait_kind(object_type.principal_def_id());\n+            (sig, kind)\n         }\n         ty::ty_infer(ty::TyVar(vid)) => {\n             deduce_expectations_from_obligations(fcx, vid)\n@@ -136,7 +133,7 @@ fn deduce_expectations_from_obligations<'a,'tcx>(\n     let fulfillment_cx = fcx.inh.fulfillment_cx.borrow();\n     // Here `expected_ty` is known to be a type inference variable.\n \n-    let expected_sig_and_kind =\n+    let expected_sig =\n         fulfillment_cx\n         .pending_obligations()\n         .iter()\n@@ -150,7 +147,7 @@ fn deduce_expectations_from_obligations<'a,'tcx>(\n                 ty::Predicate::Projection(ref proj_predicate) => {\n                     let trait_ref = proj_predicate.to_poly_trait_ref();\n                     self_type_matches_expected_vid(fcx, trait_ref, expected_vid)\n-                        .and_then(|_| deduce_expectations_from_projection(fcx, proj_predicate))\n+                        .and_then(|_| deduce_sig_from_projection(fcx, proj_predicate))\n                 }\n                 _ => {\n                     None\n@@ -159,14 +156,10 @@ fn deduce_expectations_from_obligations<'a,'tcx>(\n         })\n         .next();\n \n-    match expected_sig_and_kind {\n-        Some((sig, kind)) => { return (Some(sig), Some(kind)); }\n-        None => { }\n-    }\n-\n     // Even if we can't infer the full signature, we may be able to\n     // infer the kind. This can occur if there is a trait-reference\n-    // like `F : Fn<A>`.\n+    // like `F : Fn<A>`. Note that due to subtyping we could encounter\n+    // many viable options, so pick the most restrictive.\n     let expected_kind =\n         fulfillment_cx\n         .pending_obligations()\n@@ -183,54 +176,61 @@ fn deduce_expectations_from_obligations<'a,'tcx>(\n                 .and_then(|trait_ref| self_type_matches_expected_vid(fcx, trait_ref, expected_vid))\n                 .and_then(|trait_ref| fcx.tcx().lang_items.fn_trait_kind(trait_ref.def_id()))\n         })\n-        .next();\n+        .fold(None, pick_most_restrictive_closure_kind);\n+\n+    (expected_sig, expected_kind)\n+}\n \n-    (None, expected_kind)\n+fn pick_most_restrictive_closure_kind(best: Option<ty::ClosureKind>,\n+                                      cur: ty::ClosureKind)\n+                                      -> Option<ty::ClosureKind>\n+{\n+    match best {\n+        None => Some(cur),\n+        Some(best) => Some(cmp::min(best, cur))\n+    }\n }\n \n /// Given a projection like \"<F as Fn(X)>::Result == Y\", we can deduce\n /// everything we need to know about a closure.\n-fn deduce_expectations_from_projection<'a,'tcx>(\n+fn deduce_sig_from_projection<'a,'tcx>(\n     fcx: &FnCtxt<'a,'tcx>,\n     projection: &ty::PolyProjectionPredicate<'tcx>)\n-    -> Option<(ty::FnSig<'tcx>, ty::ClosureKind)>\n+    -> Option<ty::FnSig<'tcx>>\n {\n     let tcx = fcx.tcx();\n \n-    debug!(\"deduce_expectations_from_projection({})\",\n+    debug!(\"deduce_sig_from_projection({})\",\n            projection.repr(tcx));\n \n     let trait_ref = projection.to_poly_trait_ref();\n \n-    let kind = match tcx.lang_items.fn_trait_kind(trait_ref.def_id()) {\n-        Some(k) => k,\n-        None => { return None; }\n-    };\n-\n-    debug!(\"found object type {:?}\", kind);\n+    if tcx.lang_items.fn_trait_kind(trait_ref.def_id()).is_none() {\n+        return None;\n+    }\n \n     let arg_param_ty = *trait_ref.substs().types.get(subst::TypeSpace, 0);\n     let arg_param_ty = fcx.infcx().resolve_type_vars_if_possible(&arg_param_ty);\n-    debug!(\"arg_param_ty {}\", arg_param_ty.repr(tcx));\n+    debug!(\"deduce_sig_from_projection: arg_param_ty {}\", arg_param_ty.repr(tcx));\n \n     let input_tys = match arg_param_ty.sty {\n         ty::ty_tup(ref tys) => { (*tys).clone() }\n         _ => { return None; }\n     };\n-    debug!(\"input_tys {}\", input_tys.repr(tcx));\n+    debug!(\"deduce_sig_from_projection: input_tys {}\", input_tys.repr(tcx));\n \n     let ret_param_ty = projection.0.ty;\n     let ret_param_ty = fcx.infcx().resolve_type_vars_if_possible(&ret_param_ty);\n-    debug!(\"ret_param_ty {}\", ret_param_ty.repr(tcx));\n+    debug!(\"deduce_sig_from_projection: ret_param_ty {}\", ret_param_ty.repr(tcx));\n \n     let fn_sig = ty::FnSig {\n         inputs: input_tys,\n         output: ty::FnConverging(ret_param_ty),\n         variadic: false\n     };\n-    debug!(\"fn_sig {}\", fn_sig.repr(tcx));\n+    debug!(\"deduce_sig_from_projection: fn_sig {}\", fn_sig.repr(tcx));\n \n-    return Some((fn_sig, kind));\n+    Some(fn_sig)\n }\n \n fn self_type_matches_expected_vid<'a,'tcx>("}, {"sha": "ae1dbbb1b00ad2ca0dc0d619344fc5aaea99e8e5", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 144, "deletions": 151, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -258,70 +258,64 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         match (&a.sty, &b.sty) {\n             (&ty::ty_rptr(_, ty::mt{ty: t_a, mutbl: mutbl_a}), &ty::ty_rptr(_, mt_b)) => {\n-                self.unpack_actual_value(t_a, |a| {\n-                    match self.unsize_ty(t_a, a, mt_b.ty) {\n-                        Some((ty, kind)) => {\n-                            if !can_coerce_mutbls(mutbl_a, mt_b.mutbl) {\n-                                return Err(ty::terr_mutability);\n-                            }\n-\n-                            let coercion = Coercion(self.trace.clone());\n-                            let r_borrow = self.fcx.infcx().next_region_var(coercion);\n-                            let ty = ty::mk_rptr(self.tcx(),\n-                                                 self.tcx().mk_region(r_borrow),\n-                                                 ty::mt{ty: ty, mutbl: mt_b.mutbl});\n-                            try!(self.fcx.infcx().try(|_| self.subtype(ty, b)));\n-                            debug!(\"Success, coerced with AutoDerefRef(1, \\\n-                                    AutoPtr(AutoUnsize({:?})))\", kind);\n-                            Ok(Some(AdjustDerefRef(AutoDerefRef {\n-                                autoderefs: 1,\n-                                autoref: Some(ty::AutoPtr(r_borrow, mt_b.mutbl,\n-                                                          Some(box AutoUnsize(kind))))\n-                            })))\n+                match self.unsize_ty(t_a, mt_b.ty) {\n+                    Some((ty, kind)) => {\n+                        if !can_coerce_mutbls(mutbl_a, mt_b.mutbl) {\n+                            return Err(ty::terr_mutability);\n                         }\n-                        _ => Err(ty::terr_mismatch)\n+\n+                        let coercion = Coercion(self.trace.clone());\n+                        let r_borrow = self.fcx.infcx().next_region_var(coercion);\n+                        let ty = ty::mk_rptr(self.tcx(),\n+                                             self.tcx().mk_region(r_borrow),\n+                                             ty::mt{ty: ty, mutbl: mt_b.mutbl});\n+                        try!(self.fcx.infcx().try(|_| self.subtype(ty, b)));\n+                        debug!(\"Success, coerced with AutoDerefRef(1, \\\n+                                AutoPtr(AutoUnsize({:?})))\", kind);\n+                        Ok(Some(AdjustDerefRef(AutoDerefRef {\n+                            autoderefs: 1,\n+                            autoref: Some(ty::AutoPtr(r_borrow, mt_b.mutbl,\n+                                                      Some(box AutoUnsize(kind))))\n+                        })))\n                     }\n-                })\n+                    _ => Err(ty::terr_mismatch)\n+                }\n             }\n             (&ty::ty_rptr(_, ty::mt{ty: t_a, mutbl: mutbl_a}), &ty::ty_ptr(mt_b)) => {\n-                self.unpack_actual_value(t_a, |a| {\n-                    match self.unsize_ty(t_a, a, mt_b.ty) {\n-                        Some((ty, kind)) => {\n-                            if !can_coerce_mutbls(mutbl_a, mt_b.mutbl) {\n-                                return Err(ty::terr_mutability);\n-                            }\n-\n-                            let ty = ty::mk_ptr(self.tcx(),\n-                                                 ty::mt{ty: ty, mutbl: mt_b.mutbl});\n-                            try!(self.fcx.infcx().try(|_| self.subtype(ty, b)));\n-                            debug!(\"Success, coerced with AutoDerefRef(1, \\\n-                                    AutoPtr(AutoUnsize({:?})))\", kind);\n-                            Ok(Some(AdjustDerefRef(AutoDerefRef {\n-                                autoderefs: 1,\n-                                autoref: Some(ty::AutoUnsafe(mt_b.mutbl,\n-                                                             Some(box AutoUnsize(kind))))\n-                            })))\n+                match self.unsize_ty(t_a, mt_b.ty) {\n+                    Some((ty, kind)) => {\n+                        if !can_coerce_mutbls(mutbl_a, mt_b.mutbl) {\n+                            return Err(ty::terr_mutability);\n                         }\n-                        _ => Err(ty::terr_mismatch)\n+\n+                        let ty = ty::mk_ptr(self.tcx(),\n+                                             ty::mt{ty: ty, mutbl: mt_b.mutbl});\n+                        try!(self.fcx.infcx().try(|_| self.subtype(ty, b)));\n+                        debug!(\"Success, coerced with AutoDerefRef(1, \\\n+                                AutoPtr(AutoUnsize({:?})))\", kind);\n+                        Ok(Some(AdjustDerefRef(AutoDerefRef {\n+                            autoderefs: 1,\n+                            autoref: Some(ty::AutoUnsafe(mt_b.mutbl,\n+                                                         Some(box AutoUnsize(kind))))\n+                        })))\n                     }\n-                })\n+                    _ => Err(ty::terr_mismatch)\n+                }\n             }\n             (&ty::ty_uniq(t_a), &ty::ty_uniq(t_b)) => {\n-                self.unpack_actual_value(t_a, |a| {\n-                    match self.unsize_ty(t_a, a, t_b) {\n-                        Some((ty, kind)) => {\n-                            let ty = ty::mk_uniq(self.tcx(), ty);\n-                            try!(self.fcx.infcx().try(|_| self.subtype(ty, b)));\n-                            debug!(\"Success, coerced with AutoDerefRef(1, \\\n-                                    AutoUnsizeUniq({:?}))\", kind);\n-                            Ok(Some(AdjustDerefRef(AutoDerefRef {\n-                                autoderefs: 1,\n-                                autoref: Some(ty::AutoUnsizeUniq(kind))\n-                            })))\n-                        }\n-                        _ => Err(ty::terr_mismatch)\n+                match self.unsize_ty(t_a, t_b) {\n+                    Some((ty, kind)) => {\n+                        let ty = ty::mk_uniq(self.tcx(), ty);\n+                        try!(self.fcx.infcx().try(|_| self.subtype(ty, b)));\n+                        debug!(\"Success, coerced with AutoDerefRef(1, \\\n+                                AutoUnsizeUniq({:?}))\", kind);\n+                        Ok(Some(AdjustDerefRef(AutoDerefRef {\n+                            autoderefs: 1,\n+                            autoref: Some(ty::AutoUnsizeUniq(kind))\n+                        })))\n                     }\n-                })\n+                    _ => Err(ty::terr_mismatch)\n+                }\n             }\n             _ => Err(ty::terr_mismatch)\n         }\n@@ -332,113 +326,112 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     // E.g., `[T, ..n]` -> `([T], UnsizeLength(n))`\n     fn unsize_ty(&self,\n                  ty_a: Ty<'tcx>,\n-                 a: Ty<'tcx>,\n                  ty_b: Ty<'tcx>)\n-                 -> Option<(Ty<'tcx>, ty::UnsizeKind<'tcx>)> {\n-        debug!(\"unsize_ty(a={:?}, ty_b={})\", a, ty_b.repr(self.tcx()));\n-\n+                 -> Option<(Ty<'tcx>, ty::UnsizeKind<'tcx>)>\n+    {\n         let tcx = self.tcx();\n \n-        self.unpack_actual_value(ty_b, |b|\n-            match (&a.sty, &b.sty) {\n-                (&ty::ty_vec(t_a, Some(len)), &ty::ty_vec(_, None)) => {\n-                    let ty = ty::mk_vec(tcx, t_a, None);\n-                    Some((ty, ty::UnsizeLength(len)))\n-                }\n-                (&ty::ty_trait(ref data_a), &ty::ty_trait(ref data_b)) => {\n-                    // Upcasts permit two things:\n-                    //\n-                    // 1. Dropping builtin bounds, e.g. `Foo+Send` to `Foo`\n-                    // 2. Tightening the region bound, e.g. `Foo+'a` to `Foo+'b` if `'a : 'b`\n-                    //\n-                    // Note that neither of these changes requires any\n-                    // change at runtime.  Eventually this will be\n-                    // generalized.\n-                    //\n-                    // We always upcast when we can because of reason\n-                    // #2 (region bounds).\n-                    if data_a.bounds.builtin_bounds.is_superset(&data_b.bounds.builtin_bounds) {\n-                        // construct a type `a1` which is a version of\n-                        // `a` using the upcast bounds from `b`\n-                        let bounds_a1 = ty::ExistentialBounds {\n-                            // From type b\n-                            region_bound: data_b.bounds.region_bound,\n-                            builtin_bounds: data_b.bounds.builtin_bounds,\n-\n-                            // From type a\n-                            projection_bounds: data_a.bounds.projection_bounds.clone(),\n-                        };\n-                        let ty_a1 = ty::mk_trait(tcx, data_a.principal.clone(), bounds_a1);\n-\n-                        // relate `a1` to `b`\n-                        let result = self.fcx.infcx().try(|_| {\n-                            // it's ok to upcast from Foo+'a to Foo+'b so long as 'a : 'b\n-                            try!(self.outlives(data_a.bounds.region_bound,\n-                                               data_b.bounds.region_bound));\n-                            self.subtype(ty_a1, ty_b)\n-                        });\n-\n-                        // if that was successful, we have a coercion\n-                        match result {\n-                            Ok(_) => Some((ty_b, ty::UnsizeUpcast(ty_b))),\n-                            Err(_) => None,\n-                        }\n-                    } else {\n-                        None\n+        self.unpack_actual_value(ty_a, |a| {\n+            self.unpack_actual_value(ty_b, |b| {\n+                debug!(\"unsize_ty(a={}, b={})\", a.repr(self.tcx()), b.repr(self.tcx()));\n+                match (&a.sty, &b.sty) {\n+                    (&ty::ty_vec(t_a, Some(len)), &ty::ty_vec(_, None)) => {\n+                        let ty = ty::mk_vec(tcx, t_a, None);\n+                        Some((ty, ty::UnsizeLength(len)))\n                     }\n-                }\n-                (_, &ty::ty_trait(ref data)) => {\n-                    Some((ty_b, ty::UnsizeVtable(ty::TyTrait { principal: data.principal.clone(),\n-                                                               bounds: data.bounds.clone() },\n-                                                 ty_a)))\n-                }\n-                (&ty::ty_struct(did_a, substs_a), &ty::ty_struct(did_b, substs_b))\n-                  if did_a == did_b => {\n-                    debug!(\"unsizing a struct\");\n-                    // Try unsizing each type param in turn to see if we end up with ty_b.\n-                    let ty_substs_a = substs_a.types.get_slice(subst::TypeSpace);\n-                    let ty_substs_b = substs_b.types.get_slice(subst::TypeSpace);\n-                    assert!(ty_substs_a.len() == ty_substs_b.len());\n-\n-                    let mut result = None;\n-                    let tps = ty_substs_a.iter().zip(ty_substs_b.iter()).enumerate();\n-                    for (i, (tp_a, tp_b)) in tps {\n-                        if self.fcx.infcx().try(|_| self.subtype(*tp_a, *tp_b)).is_ok() {\n-                            continue;\n+                    (&ty::ty_trait(ref data_a), &ty::ty_trait(ref data_b)) => {\n+                        // Upcasts permit two things:\n+                        //\n+                        // 1. Dropping builtin bounds, e.g. `Foo+Send` to `Foo`\n+                        // 2. Tightening the region bound, e.g. `Foo+'a` to `Foo+'b` if `'a : 'b`\n+                        //\n+                        // Note that neither of these changes requires any\n+                        // change at runtime.  Eventually this will be\n+                        // generalized.\n+                        //\n+                        // We always upcast when we can because of reason\n+                        // #2 (region bounds).\n+                        if data_a.bounds.builtin_bounds.is_superset(&data_b.bounds.builtin_bounds) {\n+                            // construct a type `a1` which is a version of\n+                            // `a` using the upcast bounds from `b`\n+                            let bounds_a1 = ty::ExistentialBounds {\n+                                // From type b\n+                                region_bound: data_b.bounds.region_bound,\n+                                builtin_bounds: data_b.bounds.builtin_bounds,\n+\n+                                // From type a\n+                                projection_bounds: data_a.bounds.projection_bounds.clone(),\n+                            };\n+                            let ty_a1 = ty::mk_trait(tcx, data_a.principal.clone(), bounds_a1);\n+\n+                            // relate `a1` to `b`\n+                            let result = self.fcx.infcx().try(|_| {\n+                                // it's ok to upcast from Foo+'a to Foo+'b so long as 'a : 'b\n+                                try!(self.outlives(data_a.bounds.region_bound,\n+                                                   data_b.bounds.region_bound));\n+                                self.subtype(ty_a1, ty_b)\n+                            });\n+\n+                            // if that was successful, we have a coercion\n+                            match result {\n+                                Ok(_) => Some((ty_b, ty::UnsizeUpcast(ty_b))),\n+                                Err(_) => None,\n+                            }\n+                        } else {\n+                            None\n                         }\n-                        match\n-                            self.unpack_actual_value(\n-                                *tp_a,\n-                                |tp| self.unsize_ty(*tp_a, tp, *tp_b))\n-                        {\n-                            Some((new_tp, k)) => {\n-                                // Check that the whole types match.\n-                                let mut new_substs = substs_a.clone();\n-                                new_substs.types.get_mut_slice(subst::TypeSpace)[i] = new_tp;\n-                                let ty = ty::mk_struct(tcx, did_a, tcx.mk_substs(new_substs));\n-                                if self.fcx.infcx().try(|_| self.subtype(ty, ty_b)).is_err() {\n-                                    debug!(\"Unsized type parameter '{}', but still \\\n-                                            could not match types {} and {}\",\n-                                           ppaux::ty_to_string(tcx, *tp_a),\n-                                           ppaux::ty_to_string(tcx, ty),\n-                                           ppaux::ty_to_string(tcx, ty_b));\n-                                    // We can only unsize a single type parameter, so\n-                                    // if we unsize one and it doesn't give us the\n-                                    // type we want, then we won't succeed later.\n+                    }\n+                    (_, &ty::ty_trait(ref data)) => {\n+                        Some((ty_b, ty::UnsizeVtable(ty::TyTrait {\n+                                                         principal: data.principal.clone(),\n+                                                         bounds: data.bounds.clone()\n+                                                     },\n+                                                     ty_a)))\n+                    }\n+                    (&ty::ty_struct(did_a, substs_a), &ty::ty_struct(did_b, substs_b))\n+                      if did_a == did_b => {\n+                        debug!(\"unsizing a struct\");\n+                        // Try unsizing each type param in turn to see if we end up with ty_b.\n+                        let ty_substs_a = substs_a.types.get_slice(subst::TypeSpace);\n+                        let ty_substs_b = substs_b.types.get_slice(subst::TypeSpace);\n+                        assert!(ty_substs_a.len() == ty_substs_b.len());\n+\n+                        let mut result = None;\n+                        let tps = ty_substs_a.iter().zip(ty_substs_b.iter()).enumerate();\n+                        for (i, (tp_a, tp_b)) in tps {\n+                            if self.fcx.infcx().try(|_| self.subtype(*tp_a, *tp_b)).is_ok() {\n+                                continue;\n+                            }\n+                            match self.unsize_ty(*tp_a, *tp_b) {\n+                                Some((new_tp, k)) => {\n+                                    // Check that the whole types match.\n+                                    let mut new_substs = substs_a.clone();\n+                                    new_substs.types.get_mut_slice(subst::TypeSpace)[i] = new_tp;\n+                                    let ty = ty::mk_struct(tcx, did_a, tcx.mk_substs(new_substs));\n+                                    if self.fcx.infcx().try(|_| self.subtype(ty, ty_b)).is_err() {\n+                                        debug!(\"Unsized type parameter '{}', but still \\\n+                                                could not match types {} and {}\",\n+                                               ppaux::ty_to_string(tcx, *tp_a),\n+                                               ppaux::ty_to_string(tcx, ty),\n+                                               ppaux::ty_to_string(tcx, ty_b));\n+                                        // We can only unsize a single type parameter, so\n+                                        // if we unsize one and it doesn't give us the\n+                                        // type we want, then we won't succeed later.\n+                                        break;\n+                                    }\n+\n+                                    result = Some((ty, ty::UnsizeStruct(box k, i)));\n                                     break;\n                                 }\n-\n-                                result = Some((ty, ty::UnsizeStruct(box k, i)));\n-                                break;\n+                                None => {}\n                             }\n-                            None => {}\n                         }\n+                        result\n                     }\n-                    result\n+                    _ => None\n                 }\n-                _ => None\n-            }\n-        )\n+            })\n+        })\n     }\n \n     fn coerce_from_fn_pointer(&self,"}, {"sha": "cd6a1226e00c9d639d8c83d38891caaf13122e85", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -53,9 +53,11 @@ pub fn eqtype<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n     }\n }\n \n-// Checks that the type `actual` can be coerced to `expected`.\n-pub fn coerce<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n-                        expected: Ty<'tcx>, expr: &ast::Expr) {\n+// Checks that the type of `expr` can be coerced to `expected`.\n+pub fn coerce<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                        sp: Span,\n+                        expected: Ty<'tcx>,\n+                        expr: &ast::Expr) {\n     let expr_ty = fcx.expr_ty(expr);\n     debug!(\"demand::coerce(expected = {}, expr_ty = {})\",\n            expected.repr(fcx.ccx.tcx),"}, {"sha": "c48033cab897f612c1a371d365340655c634dcda", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 238, "deletions": 2, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -12,13 +12,249 @@ use check::regionck::{self, Rcx};\n \n use middle::infer;\n use middle::region;\n-use middle::subst;\n+use middle::subst::{self, Subst};\n use middle::ty::{self, Ty};\n use util::ppaux::{Repr, UserString};\n \n use syntax::ast;\n-use syntax::codemap::Span;\n+use syntax::codemap::{self, Span};\n+\n+/// check_drop_impl confirms that the Drop implementation identfied by\n+/// `drop_impl_did` is not any more specialized than the type it is\n+/// attached to (Issue #8142).\n+///\n+/// This means:\n+///\n+/// 1. The self type must be nominal (this is already checked during\n+///    coherence),\n+///\n+/// 2. The generic region/type parameters of the impl's self-type must\n+///    all be parameters of the Drop impl itself (i.e. no\n+///    specialization like `impl Drop for Foo<i32>`), and,\n+///\n+/// 3. Any bounds on the generic parameters must be reflected in the\n+///    struct/enum definition for the nominal type itself (i.e.\n+///    cannot do `struct S<T>; impl<T:Clone> Drop for S<T> { ... }`).\n+///\n+pub fn check_drop_impl(tcx: &ty::ctxt, drop_impl_did: ast::DefId) -> Result<(), ()> {\n+    let ty::TypeScheme { generics: ref dtor_generics,\n+                         ty: ref dtor_self_type } = ty::lookup_item_type(tcx, drop_impl_did);\n+    let dtor_predicates = ty::lookup_predicates(tcx, drop_impl_did);\n+    match dtor_self_type.sty {\n+        ty::ty_enum(self_type_did, self_to_impl_substs) |\n+        ty::ty_struct(self_type_did, self_to_impl_substs) |\n+        ty::ty_closure(self_type_did, self_to_impl_substs) => {\n+            try!(ensure_drop_params_and_item_params_correspond(tcx,\n+                                                               drop_impl_did,\n+                                                               dtor_generics,\n+                                                               dtor_self_type,\n+                                                               self_type_did));\n+\n+            ensure_drop_predicates_are_implied_by_item_defn(tcx,\n+                                                            drop_impl_did,\n+                                                            &dtor_predicates,\n+                                                            self_type_did,\n+                                                            self_to_impl_substs)\n+        }\n+        _ => {\n+            // Destructors only work on nominal types.  This was\n+            // already checked by coherence, so we can panic here.\n+            let span = tcx.map.def_id_span(drop_impl_did, codemap::DUMMY_SP);\n+            tcx.sess.span_bug(\n+                span, &format!(\"should have been rejected by coherence check: {}\",\n+                               dtor_self_type.repr(tcx)));\n+        }\n+    }\n+}\n+\n+fn ensure_drop_params_and_item_params_correspond<'tcx>(\n+    tcx: &ty::ctxt<'tcx>,\n+    drop_impl_did: ast::DefId,\n+    drop_impl_generics: &ty::Generics<'tcx>,\n+    drop_impl_ty: &ty::Ty<'tcx>,\n+    self_type_did: ast::DefId) -> Result<(), ()>\n+{\n+    // New strategy based on review suggestion from nikomatsakis.\n+    //\n+    // (In the text and code below, \"named\" denotes \"struct/enum\", and\n+    // \"generic params\" denotes \"type and region params\")\n+    //\n+    // 1. Create fresh skolemized type/region \"constants\" for each of\n+    //    the named type's generic params.  Instantiate the named type\n+    //    with the fresh constants, yielding `named_skolem`.\n+    //\n+    // 2. Create unification variables for each of the Drop impl's\n+    //    generic params.  Instantiate the impl's Self's type with the\n+    //    unification-vars, yielding `drop_unifier`.\n+    //\n+    // 3. Attempt to unify Self_unif with Type_skolem.  If unification\n+    //    succeeds, continue (i.e. with the predicate checks).\n+\n+    let ty::TypeScheme { generics: ref named_type_generics,\n+                         ty: named_type } =\n+        ty::lookup_item_type(tcx, self_type_did);\n+\n+    let infcx = infer::new_infer_ctxt(tcx);\n+    infcx.try(|snapshot| {\n+        let (named_type_to_skolem, skol_map) =\n+            infcx.construct_skolemized_subst(named_type_generics, snapshot);\n+        let named_type_skolem = named_type.subst(tcx, &named_type_to_skolem);\n+\n+        let drop_impl_span = tcx.map.def_id_span(drop_impl_did, codemap::DUMMY_SP);\n+        let drop_to_unifier =\n+            infcx.fresh_substs_for_generics(drop_impl_span, drop_impl_generics);\n+        let drop_unifier = drop_impl_ty.subst(tcx, &drop_to_unifier);\n+\n+        if let Ok(()) = infer::mk_eqty(&infcx, true, infer::TypeOrigin::Misc(drop_impl_span),\n+                                       named_type_skolem, drop_unifier) {\n+            // Even if we did manage to equate the types, the process\n+            // may have just gathered unsolvable region constraints\n+            // like `R == 'static` (represented as a pair of subregion\n+            // constraints) for some skolemization constant R.\n+            //\n+            // However, the leak_check method allows us to confirm\n+            // that no skolemized regions escaped (i.e. were related\n+            // to other regions in the constraint graph).\n+            if let Ok(()) = infcx.leak_check(&skol_map, snapshot) {\n+                return Ok(())\n+            }\n+        }\n+\n+        span_err!(tcx.sess, drop_impl_span, E0366,\n+                  \"Implementations of Drop cannot be specialized\");\n+        let item_span = tcx.map.span(self_type_did.node);\n+        tcx.sess.span_note(item_span,\n+                           \"Use same sequence of generic type and region \\\n+                            parameters that is on the struct/enum definition\");\n+        return Err(());\n+    })\n+}\n+\n+/// Confirms that every predicate imposed by dtor_predicates is\n+/// implied by assuming the predicates attached to self_type_did.\n+fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n+    tcx: &ty::ctxt<'tcx>,\n+    drop_impl_did: ast::DefId,\n+    dtor_predicates: &ty::GenericPredicates<'tcx>,\n+    self_type_did: ast::DefId,\n+    self_to_impl_substs: &subst::Substs<'tcx>) -> Result<(), ()> {\n+\n+    // Here is an example, analogous to that from\n+    // `compare_impl_method`.\n+    //\n+    // Consider a struct type:\n+    //\n+    //     struct Type<'c, 'b:'c, 'a> {\n+    //         x: &'a Contents            // (contents are irrelevant;\n+    //         y: &'c Cell<&'b Contents>, //  only the bounds matter for our purposes.)\n+    //     }\n+    //\n+    // and a Drop impl:\n+    //\n+    //     impl<'z, 'y:'z, 'x:'y> Drop for P<'z, 'y, 'x> {\n+    //         fn drop(&mut self) { self.y.set(self.x); } // (only legal if 'x: 'y)\n+    //     }\n+    //\n+    // We start out with self_to_impl_substs, that maps the generic\n+    // parameters of Type to that of the Drop impl.\n+    //\n+    //     self_to_impl_substs = {'c => 'z, 'b => 'y, 'a => 'x}\n+    //\n+    // Applying this to the predicates (i.e. assumptions) provided by the item\n+    // definition yields the instantiated assumptions:\n+    //\n+    //     ['y : 'z]\n+    //\n+    // We then check all of the predicates of the Drop impl:\n+    //\n+    //     ['y:'z, 'x:'y]\n+    //\n+    // and ensure each is in the list of instantiated\n+    // assumptions. Here, `'y:'z` is present, but `'x:'y` is\n+    // absent. So we report an error that the Drop impl injected a\n+    // predicate that is not present on the struct definition.\n+\n+    assert_eq!(self_type_did.krate, ast::LOCAL_CRATE);\n+\n+    let drop_impl_span = tcx.map.def_id_span(drop_impl_did, codemap::DUMMY_SP);\n+\n+    // We can assume the predicates attached to struct/enum definition\n+    // hold.\n+    let generic_assumptions = ty::lookup_predicates(tcx, self_type_did);\n+\n+    let assumptions_in_impl_context = generic_assumptions.instantiate(tcx, &self_to_impl_substs);\n+    assert!(assumptions_in_impl_context.predicates.is_empty_in(subst::SelfSpace));\n+    assert!(assumptions_in_impl_context.predicates.is_empty_in(subst::FnSpace));\n+    let assumptions_in_impl_context =\n+        assumptions_in_impl_context.predicates.get_slice(subst::TypeSpace);\n+\n+    // An earlier version of this code attempted to do this checking\n+    // via the traits::fulfill machinery. However, it ran into trouble\n+    // since the fulfill machinery merely turns outlives-predicates\n+    // 'a:'b and T:'b into region inference constraints. It is simpler\n+    // just to look for all the predicates directly.\n+\n+    assert!(dtor_predicates.predicates.is_empty_in(subst::SelfSpace));\n+    assert!(dtor_predicates.predicates.is_empty_in(subst::FnSpace));\n+    let predicates = dtor_predicates.predicates.get_slice(subst::TypeSpace);\n+    for predicate in predicates {\n+        // (We do not need to worry about deep analysis of type\n+        // expressions etc because the Drop impls are already forced\n+        // to take on a structure that is roughly a alpha-renaming of\n+        // the generic parameters of the item definition.)\n+\n+        // This path now just checks *all* predicates via the direct\n+        // lookup, rather than using fulfill machinery.\n+        //\n+        // However, it may be more efficient in the future to batch\n+        // the analysis together via the fulfill , rather than the\n+        // repeated `contains` calls.\n+\n+        if !assumptions_in_impl_context.contains(&predicate) {\n+            let item_span = tcx.map.span(self_type_did.node);\n+            let req = predicate.user_string(tcx);\n+            span_err!(tcx.sess, drop_impl_span, E0367,\n+                      \"The requirement `{}` is added only by the Drop impl.\", req);\n+            tcx.sess.span_note(item_span,\n+                               \"The same requirement must be part of \\\n+                                the struct/enum definition\");\n+        }\n+    }\n+\n+    if tcx.sess.has_errors() {\n+        return Err(());\n+    }\n+    Ok(())\n+}\n \n+/// check_safety_of_destructor_if_necessary confirms that the type\n+/// expression `typ` conforms to the \"Drop Check Rule\" from the Sound\n+/// Generic Drop (RFC 769).\n+///\n+/// ----\n+///\n+/// The Drop Check Rule is the following:\n+///\n+/// Let `v` be some value (either temporary or named) and 'a be some\n+/// lifetime (scope). If the type of `v` owns data of type `D`, where\n+///\n+///   (1.) `D` has a lifetime- or type-parametric Drop implementation, and\n+///   (2.) the structure of `D` can reach a reference of type `&'a _`, and\n+///   (3.) either:\n+///\n+///     (A.) the Drop impl for `D` instantiates `D` at 'a directly,\n+///          i.e. `D<'a>`, or,\n+///\n+///     (B.) the Drop impl for `D` has some type parameter with a\n+///          trait bound `T` where `T` is a trait that has at least\n+///          one method,\n+///\n+/// then 'a must strictly outlive the scope of v.\n+///\n+/// ----\n+///\n+/// This function is meant to by applied to the type for every\n+/// expression in the program.\n pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                                                      typ: ty::Ty<'tcx>,\n                                                      span: Span,"}, {"sha": "b95e0ce8cb3c59e512d65101884e5fbd1d9b1697", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -725,7 +725,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             };\n \n             // this closure doesn't implement the right kind of `Fn` trait\n-            if closure_kind != kind {\n+            if !closure_kind.extends(kind) {\n                 continue;\n             }\n "}, {"sha": "1e38a7d2d9f944222403095c82f24ddf733b20d1", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 101, "deletions": 63, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -184,6 +184,8 @@ pub struct Inherited<'a, 'tcx: 'a> {\n     // def-id of the closure, so that once we decide, we can easily go\n     // back and process them.\n     deferred_call_resolutions: RefCell<DefIdMap<Vec<DeferredCallResolutionHandler<'tcx>>>>,\n+\n+    deferred_cast_checks: RefCell<Vec<CastCheck<'tcx>>>,\n }\n \n trait DeferredCallResolution<'tcx> {\n@@ -192,6 +194,15 @@ trait DeferredCallResolution<'tcx> {\n \n type DeferredCallResolutionHandler<'tcx> = Box<DeferredCallResolution<'tcx>+'tcx>;\n \n+/// Reifies a cast check to be checked once we have full type information for\n+/// a function context.\n+struct CastCheck<'tcx> {\n+    expr: ast::Expr,\n+    expr_ty: Ty<'tcx>,\n+    cast_ty: Ty<'tcx>,\n+    span: Span,\n+}\n+\n /// When type-checking an expression, we propagate downward\n /// whatever type hint we are able in the form of an `Expectation`.\n #[derive(Copy)]\n@@ -399,6 +410,7 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n             fn_sig_map: RefCell::new(NodeMap()),\n             fulfillment_cx: RefCell::new(traits::FulfillmentContext::new()),\n             deferred_call_resolutions: RefCell::new(DefIdMap()),\n+            deferred_cast_checks: RefCell::new(Vec::new()),\n         }\n     }\n \n@@ -478,6 +490,20 @@ pub fn check_item_types(ccx: &CrateCtxt) {\n     visit::walk_crate(&mut visit, krate);\n \n     ccx.tcx.sess.abort_if_errors();\n+\n+    for drop_method_did in ccx.tcx.destructors.borrow().iter() {\n+        if drop_method_did.krate == ast::LOCAL_CRATE {\n+            let drop_impl_did = ccx.tcx.map.get_parent_did(drop_method_did.node);\n+            match dropck::check_drop_impl(ccx.tcx, drop_impl_did) {\n+                Ok(()) => {}\n+                Err(()) => {\n+                    assert!(ccx.tcx.sess.has_errors());\n+                }\n+            }\n+        }\n+    }\n+\n+    ccx.tcx.sess.abort_if_errors();\n }\n \n fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n@@ -508,6 +534,7 @@ fn check_bare_fn<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             vtable::select_all_fcx_obligations_and_apply_defaults(&fcx);\n             upvar::closure_analyze_fn(&fcx, fn_id, decl, body);\n             vtable::select_all_fcx_obligations_or_error(&fcx);\n+            fcx.check_casts();\n             regionck::regionck_fn(&fcx, fn_id, fn_span, decl, body);\n             writeback::resolve_type_vars_in_fn(&fcx, decl, body);\n         }\n@@ -1053,11 +1080,7 @@ fn report_cast_to_unsized_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n }\n \n \n-fn check_cast_inner<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                              span: Span,\n-                              t_1: Ty<'tcx>,\n-                              t_e: Ty<'tcx>,\n-                              e: &ast::Expr) {\n+fn check_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, cast: &CastCheck<'tcx>) {\n     fn cast_through_integer_err<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                           span: Span,\n                                           t_1: Ty<'tcx>,\n@@ -1070,6 +1093,33 @@ fn check_cast_inner<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }, t_e, None);\n     }\n \n+    let span = cast.span;\n+    let e = &cast.expr;\n+    let t_e = structurally_resolved_type(fcx, span, cast.expr_ty);\n+    let t_1 = structurally_resolved_type(fcx, span, cast.cast_ty);\n+\n+    // Check for trivial casts.\n+    if !ty::type_has_ty_infer(t_1) {\n+        if let Ok(()) = coercion::mk_assignty(fcx, e, t_e, t_1) {\n+            if ty::type_is_numeric(t_1) && ty::type_is_numeric(t_e) {\n+                fcx.tcx().sess.add_lint(lint::builtin::TRIVIAL_NUMERIC_CASTS,\n+                                        e.id,\n+                                        span,\n+                                        format!(\"trivial numeric cast: `{}` as `{}`\",\n+                                                fcx.infcx().ty_to_string(t_e),\n+                                                fcx.infcx().ty_to_string(t_1)));\n+            } else {\n+                fcx.tcx().sess.add_lint(lint::builtin::TRIVIAL_CASTS,\n+                                        e.id,\n+                                        span,\n+                                        format!(\"trivial cast: `{}` as `{}`\",\n+                                                fcx.infcx().ty_to_string(t_e),\n+                                                fcx.infcx().ty_to_string(t_1)));\n+            }\n+            return;\n+        }\n+    }\n+\n     let t_e_is_bare_fn_item = ty::type_is_bare_fn_item(t_e);\n     let t_e_is_scalar = ty::type_is_scalar(t_e);\n     let t_e_is_integral = ty::type_is_integral(t_e);\n@@ -1085,18 +1135,17 @@ fn check_cast_inner<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let t_1_is_trivial = t_1_is_scalar && !t_1_is_char && !t_1_is_bare_fn;\n \n     if t_e_is_bare_fn_item && t_1_is_bare_fn {\n-        demand::coerce(fcx, e.span, t_1, &*e);\n+        demand::coerce(fcx, e.span, t_1, &e);\n     } else if t_1_is_char {\n         let t_e = fcx.infcx().shallow_resolve(t_e);\n         if t_e.sty != ty::ty_uint(ast::TyU8) {\n             fcx.type_error_message(span, |actual| {\n-                format!(\"only `u8` can be cast as \\\n-                         `char`, not `{}`\", actual)\n+                format!(\"only `u8` can be cast as `char`, not `{}`\", actual)\n             }, t_e, None);\n         }\n     } else if t_1.sty == ty::ty_bool {\n         span_err!(fcx.tcx().sess, span, E0054,\n-            \"cannot cast as `bool`, compare with zero instead\");\n+                  \"cannot cast as `bool`, compare with zero instead\");\n     } else if t_1_is_float && (t_e_is_scalar || t_e_is_c_enum) && !(\n         t_e_is_integral || t_e_is_float || t_e.sty == ty::ty_bool) {\n         // Casts to float must go through an integer or boolean\n@@ -1145,7 +1194,7 @@ fn check_cast_inner<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 /* this case is allowed */\n             }\n             _ => {\n-                demand::coerce(fcx, e.span, t_1, &*e);\n+                demand::coerce(fcx, e.span, t_1, &e);\n             }\n         }\n     } else if !(t_e_is_scalar && t_1_is_trivial) {\n@@ -1162,49 +1211,6 @@ fn check_cast_inner<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n }\n \n-fn check_cast<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n-                       cast_expr: &ast::Expr,\n-                       e: &'tcx ast::Expr,\n-                       t: &ast::Ty) {\n-    let id = cast_expr.id;\n-    let span = cast_expr.span;\n-\n-    // Find the type of `e`. Supply hints based on the type we are casting to,\n-    // if appropriate.\n-    let t_1 = fcx.to_ty(t);\n-    let t_1 = structurally_resolved_type(fcx, span, t_1);\n-\n-    check_expr_with_expectation(fcx, e, ExpectCastableToType(t_1));\n-\n-    let t_e = fcx.expr_ty(e);\n-\n-    debug!(\"t_1={}\", fcx.infcx().ty_to_string(t_1));\n-    debug!(\"t_e={}\", fcx.infcx().ty_to_string(t_e));\n-\n-    if ty::type_is_error(t_e) {\n-        fcx.write_error(id);\n-        return\n-    }\n-\n-    if !fcx.type_is_known_to_be_sized(t_1, cast_expr.span) {\n-        report_cast_to_unsized_type(fcx, span, t.span, e.span, t_1, t_e, id);\n-        return\n-    }\n-\n-    if ty::type_is_trait(t_1) {\n-        // This will be looked up later on.\n-        vtable::check_object_cast(fcx, cast_expr, e, t_1);\n-        fcx.write_ty(id, t_1);\n-        return\n-    }\n-\n-    let t_1 = structurally_resolved_type(fcx, span, t_1);\n-    let t_e = structurally_resolved_type(fcx, span, t_e);\n-\n-    check_cast_inner(fcx, span, t_1, t_e, e);\n-    fcx.write_ty(id, t_1);\n-}\n-\n impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> { self.ccx.tcx }\n \n@@ -1372,7 +1378,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub fn tag(&self) -> String {\n-        format!(\"{:?}\", self as *const FnCtxt)\n+        let self_ptr: *const FnCtxt = self;\n+        format!(\"{:?}\", self_ptr)\n     }\n \n     pub fn local_ty(&self, span: Span, nid: ast::NodeId) -> Ty<'tcx> {\n@@ -1416,14 +1423,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.inh.node_types.borrow_mut().insert(node_id, ty);\n     }\n \n-    pub fn write_object_cast(&self,\n-                             key: ast::NodeId,\n-                             trait_ref: ty::PolyTraitRef<'tcx>) {\n-        debug!(\"write_object_cast key={} trait_ref={}\",\n-               key, trait_ref.repr(self.tcx()));\n-        self.inh.object_cast_map.borrow_mut().insert(key, trait_ref);\n-    }\n-\n     pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::ItemSubsts<'tcx>) {\n         if !substs.substs.is_noop() {\n             debug!(\"write_substs({}, {}) in fcx {}\",\n@@ -1923,6 +1922,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         o_field.map(|f| ty::lookup_field_type(self.tcx(), class_id, f.id, substs))\n                .map(|t| self.normalize_associated_types_in(span, &t))\n     }\n+\n+    fn check_casts(&self) {\n+        let mut deferred_cast_checks = self.inh.deferred_cast_checks.borrow_mut();\n+        for check in deferred_cast_checks.iter() {\n+            check_cast(self, check);\n+        }\n+\n+        deferred_cast_checks.clear();\n+    }\n }\n \n impl<'a, 'tcx> RegionScope for FnCtxt<'a, 'tcx> {\n@@ -3828,7 +3836,33 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         if let ast::TyFixedLengthVec(_, ref count_expr) = t.node {\n             check_expr_with_hint(fcx, &**count_expr, tcx.types.uint);\n         }\n-        check_cast(fcx, expr, &**e, &**t);\n+\n+        // Find the type of `e`. Supply hints based on the type we are casting to,\n+        // if appropriate.\n+        let t_1 = fcx.to_ty(t);\n+        let t_1 = structurally_resolved_type(fcx, expr.span, t_1);\n+        check_expr_with_expectation(fcx, e, ExpectCastableToType(t_1));\n+        let t_e = fcx.expr_ty(e);\n+\n+        // Eagerly check for some obvious errors.\n+        if ty::type_is_error(t_e) {\n+            fcx.write_error(id);\n+        } else if !fcx.type_is_known_to_be_sized(t_1, expr.span) {\n+            report_cast_to_unsized_type(fcx, expr.span, t.span, e.span, t_1, t_e, id);\n+        } else {\n+            // Write a type for the whole expression, assuming everything is going\n+            // to work out Ok.\n+            fcx.write_ty(id, t_1);\n+\n+            // Defer other checks until we're done type checking.\n+            let mut deferred_cast_checks = fcx.inh.deferred_cast_checks.borrow_mut();\n+            deferred_cast_checks.push(CastCheck {\n+                expr: (**e).clone(),\n+                expr_ty: t_e,\n+                cast_ty: t_1,\n+                span: expr.span,\n+            });\n+        }\n       }\n       ast::ExprVec(ref args) => {\n         let uty = expected.to_option(fcx).and_then(|uty| {\n@@ -4461,6 +4495,7 @@ fn check_const_with_ty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     check_expr_with_hint(fcx, e, declty);\n     demand::coerce(fcx, e.span, declty, e);\n     vtable::select_all_fcx_obligations_or_error(fcx);\n+    fcx.check_casts();\n     regionck::regionck_expr(fcx, e);\n     writeback::resolve_type_vars_in_expr(fcx, e);\n }\n@@ -4560,6 +4595,8 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                      ty: attr::IntType,\n                      disr: ty::Disr) -> bool {\n         fn uint_in_range(ccx: &CrateCtxt, ty: ast::UintTy, disr: ty::Disr) -> bool {\n+            #![allow(trivial_numeric_casts)]\n+\n             match ty {\n                 ast::TyU8 => disr as u8 as Disr == disr,\n                 ast::TyU16 => disr as u16 as Disr == disr,\n@@ -4588,6 +4625,7 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                           id: ast::NodeId,\n                           hint: attr::ReprAttr)\n                           -> Vec<Rc<ty::VariantInfo<'tcx>>> {\n+        #![allow(trivial_numeric_casts)]\n         use std::num::Int;\n \n         let rty = ty::node_id_to_type(ccx.tcx, id);"}, {"sha": "2858dc9b569fe1adaa22ffb7cde199e4e375404a", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use check::{FnCtxt};\n-use check::demand;\n use middle::traits::{self, ObjectSafetyViolation, MethodViolationCode};\n use middle::traits::{Obligation, ObligationCause};\n use middle::traits::report_fulfillment_errors;\n@@ -19,83 +18,6 @@ use syntax::codemap::Span;\n use util::nodemap::FnvHashSet;\n use util::ppaux::{Repr, UserString};\n \n-pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                   cast_expr: &ast::Expr,\n-                                   source_expr: &ast::Expr,\n-                                   target_object_ty: Ty<'tcx>)\n-{\n-    let tcx = fcx.tcx();\n-    debug!(\"check_object_cast(cast_expr={}, target_object_ty={})\",\n-           cast_expr.repr(tcx),\n-           target_object_ty.repr(tcx));\n-\n-    // Look up vtables for the type we're casting to,\n-    // passing in the source and target type.  The source\n-    // must be a pointer type suitable to the object sigil,\n-    // e.g.: `&x as &Trait` or `box x as Box<Trait>`\n-\n-    // First, construct a fresh type that we can feed into `<expr>`\n-    // within `<expr> as <type>` to inform type inference (e.g. to\n-    // tell it that we are expecting a `Box<_>` or an `&_`).\n-    let fresh_ty = fcx.infcx().next_ty_var();\n-    let (object_trait_ty, source_expected_ty) = match target_object_ty.sty {\n-        ty::ty_uniq(object_trait_ty) => {\n-            (object_trait_ty, ty::mk_uniq(fcx.tcx(), fresh_ty))\n-        }\n-        ty::ty_rptr(target_region, ty::mt { ty: object_trait_ty,\n-                                            mutbl: target_mutbl }) => {\n-            (object_trait_ty,\n-             ty::mk_rptr(fcx.tcx(),\n-                         target_region, ty::mt { ty: fresh_ty,\n-                                                 mutbl: target_mutbl }))\n-        }\n-        _ => {\n-            fcx.tcx().sess.span_bug(source_expr.span, \"expected object type\");\n-        }\n-    };\n-\n-    let source_ty = fcx.expr_ty(source_expr);\n-    debug!(\"check_object_cast pre unify source_ty={}\", source_ty.repr(tcx));\n-\n-    // This ensures that the source_ty <: source_expected_ty, which\n-    // will ensure e.g. that &'a T <: &'b T when doing `&'a T as &'b Trait`\n-    //\n-    // FIXME (pnkfelix): do we need to use suptype_with_fn in order to\n-    // override the error message emitted when the types do not work\n-    // out in the manner desired?\n-    demand::suptype(fcx, source_expr.span, source_expected_ty, source_ty);\n-\n-    debug!(\"check_object_cast postunify source_ty={}\", source_ty.repr(tcx));\n-\n-    let object_trait = object_trait(&object_trait_ty);\n-\n-    // Ensure that if Ptr<T> is cast to Ptr<Trait>, then T : Trait.\n-    push_cast_obligation(fcx, cast_expr, object_trait, fresh_ty);\n-    check_object_safety(tcx, object_trait, source_expr.span);\n-\n-    fn object_trait<'a, 'tcx>(t: &'a Ty<'tcx>) -> &'a ty::TyTrait<'tcx> {\n-        match t.sty {\n-            ty::ty_trait(ref ty_trait) => &**ty_trait,\n-            _ => panic!(\"expected ty_trait\")\n-        }\n-    }\n-\n-    fn push_cast_obligation<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                      cast_expr: &ast::Expr,\n-                                      object_trait: &ty::TyTrait<'tcx>,\n-                                      referent_ty: Ty<'tcx>) {\n-        let object_trait_ref =\n-            register_object_cast_obligations(fcx,\n-                                             cast_expr.span,\n-                                             object_trait,\n-                                             referent_ty);\n-\n-        // Finally record the object_trait_ref for use during trans\n-        // (it would prob be better not to do this, but it's just kind\n-        // of a pain to have to reconstruct it).\n-        fcx.write_object_cast(cast_expr.id, object_trait_ref);\n-    }\n-}\n \n // Check that a trait is 'object-safe'. This should be checked whenever a trait object\n // is created (by casting or coercion, etc.). A trait is object-safe if all its"}, {"sha": "5816fe58bc9b1b25948ae56670bb2032fb94470e", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -784,14 +784,15 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                                    &enum_definition.variants);\n         },\n         ast::ItemDefaultImpl(_, ref ast_trait_ref) => {\n-            let trait_ref = astconv::instantiate_trait_ref(&ccx.icx(&()),\n-                                                           &ExplicitRscope,\n-                                                           ast_trait_ref,\n-                                                           Some(it.id),\n-                                                           None,\n-                                                           None);\n+            let trait_ref =\n+                astconv::instantiate_mono_trait_ref(&ccx.icx(&()),\n+                                                    &ExplicitRscope,\n+                                                    ast_trait_ref,\n+                                                    None);\n \n             ty::record_trait_has_default_impl(tcx, trait_ref.def_id);\n+\n+            tcx.impl_trait_refs.borrow_mut().insert(it.id, trait_ref);\n         }\n         ast::ItemImpl(_, _,\n                       ref generics,\n@@ -890,13 +891,14 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                 }\n             }\n \n-            if let Some(ref trait_ref) = *opt_trait_ref {\n-                astconv::instantiate_trait_ref(&ccx.icx(&ty_predicates),\n-                                               &ExplicitRscope,\n-                                               trait_ref,\n-                                               Some(it.id),\n-                                               Some(selfty),\n-                                               None);\n+            if let Some(ref ast_trait_ref) = *opt_trait_ref {\n+                let trait_ref =\n+                    astconv::instantiate_mono_trait_ref(&ccx.icx(&ty_predicates),\n+                                                        &ExplicitRscope,\n+                                                        ast_trait_ref,\n+                                                        Some(selfty));\n+\n+                tcx.impl_trait_refs.borrow_mut().insert(it.id, trait_ref);\n             }\n \n             enforce_impl_ty_params_are_constrained(tcx,"}, {"sha": "95e06879fb2235a066c2aa83104fe7ec9ca643b0", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -177,7 +177,9 @@ register_diagnostics! {\n     E0319, // trait impls for defaulted traits allowed just for structs/enums\n     E0320, // recursive overflow during dropck\n     E0321, // extended coherence rules for defaulted traits violated\n-    E0322  // cannot implement Sized explicitly\n+    E0322, // cannot implement Sized explicitly\n+    E0366, // dropck forbid specialization to concrete type or region\n+    E0367  // dropck forbid specialization to predicate not in struct/enum\n }\n \n __build_diagnostic_array! { DIAGNOSTICS }"}, {"sha": "cfa84de5ca7c9f37577877f1bc6f38ea347300ca", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -308,8 +308,8 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n         };\n         (*((*renderer).opaque as *mut hoedown_html_renderer_state)).opaque\n                 = &mut opaque as *mut _ as *mut libc::c_void;\n-        (*renderer).blockcode = Some(block as blockcodefn);\n-        (*renderer).header = Some(header as headerfn);\n+        (*renderer).blockcode = Some(block);\n+        (*renderer).header = Some(header);\n \n         let document = hoedown_document_new(renderer, HOEDOWN_EXTENSIONS, 16);\n         hoedown_document_render(document, ob, s.as_ptr(),\n@@ -380,8 +380,8 @@ pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n     unsafe {\n         let ob = hoedown_buffer_new(DEF_OUNIT);\n         let renderer = hoedown_html_renderer_new(0, 0);\n-        (*renderer).blockcode = Some(block as blockcodefn);\n-        (*renderer).header = Some(header as headerfn);\n+        (*renderer).blockcode = Some(block);\n+        (*renderer).header = Some(header);\n         (*((*renderer).opaque as *mut hoedown_html_renderer_state)).opaque\n                 = tests as *mut _ as *mut libc::c_void;\n \n@@ -501,10 +501,10 @@ pub fn plain_summary_line(md: &str) -> String {\n     unsafe {\n         let ob = hoedown_buffer_new(DEF_OUNIT);\n         let mut plain_renderer: hoedown_renderer = ::std::mem::zeroed();\n-        let renderer = &mut plain_renderer as *mut hoedown_renderer;\n+        let renderer: *mut hoedown_renderer = &mut plain_renderer;\n         (*renderer).opaque = ob as *mut libc::c_void;\n-        (*renderer).link = Some(link as linkfn);\n-        (*renderer).normal_text = Some(normal_text as normaltextfn);\n+        (*renderer).link = Some(link);\n+        (*renderer).normal_text = Some(normal_text);\n \n         let document = hoedown_document_new(renderer, HOEDOWN_EXTENSIONS, 16);\n         hoedown_document_render(document, ob, md.as_ptr(),"}, {"sha": "0d6ed91d5298139b1cdf5800d3e6ac20c08aaab4", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -2429,7 +2429,10 @@ pub trait ToJson {\n macro_rules! to_json_impl_i64 {\n     ($($t:ty), +) => (\n         $(impl ToJson for $t {\n-            fn to_json(&self) -> Json { Json::I64(*self as i64) }\n+            fn to_json(&self) -> Json {\n+                #![allow(trivial_numeric_casts)]\n+                Json::I64(*self as i64)\n+            }\n         })+\n     )\n }\n@@ -2439,7 +2442,10 @@ to_json_impl_i64! { int, i8, i16, i32, i64 }\n macro_rules! to_json_impl_u64 {\n     ($($t:ty), +) => (\n         $(impl ToJson for $t {\n-            fn to_json(&self) -> Json { Json::U64(*self as u64) }\n+            fn to_json(&self) -> Json {\n+                #![allow(trivial_numeric_casts)]\n+                Json::U64(*self as u64)\n+            }\n         })+\n     )\n }"}, {"sha": "c1253706832df6e87667aeafbc1901b17962e5aa", "filename": "src/libstd/fs/mod.rs", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Ffs%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Ffs%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs%2Fmod.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -128,6 +128,17 @@ impl File {\n     ///\n     /// This function will return an error if `path` does not already exist.\n     /// Other errors may also be returned according to `OpenOptions::open`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// let mut f = try!(File::open(\"foo.txt\"));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn open<P: AsRef<Path>>(path: P) -> io::Result<File> {\n         OpenOptions::new().read(true).open(path)\n@@ -139,6 +150,17 @@ impl File {\n     /// and will truncate it if it does.\n     ///\n     /// See the `OpenOptions::open` function for more details.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// let mut f = try!(File::create(\"foo.txt\"));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn create<P: AsRef<Path>>(path: P) -> io::Result<File> {\n         OpenOptions::new().write(true).create(true).truncate(true).open(path)\n@@ -156,6 +178,21 @@ impl File {\n     ///\n     /// This function will attempt to ensure that all in-core data reaches the\n     /// filesystem before returning.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::File;\n+    /// use std::io::prelude::*;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// let mut f = try!(File::create(\"foo.txt\"));\n+    /// try!(f.write_all(b\"Hello, world!\"));\n+    ///\n+    /// try!(f.sync_all());\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn sync_all(&self) -> io::Result<()> {\n         self.inner.fsync()\n@@ -170,6 +207,21 @@ impl File {\n     ///\n     /// Note that some platforms may simply implement this in terms of\n     /// `sync_all`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::File;\n+    /// use std::io::prelude::*;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// let mut f = try!(File::create(\"foo.txt\"));\n+    /// try!(f.write_all(b\"Hello, world!\"));\n+    ///\n+    /// try!(f.sync_data());\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn sync_data(&self) -> io::Result<()> {\n         self.inner.datasync()\n@@ -182,12 +234,36 @@ impl File {\n     /// be shrunk. If it is greater than the current file's size, then the file\n     /// will be extended to `size` and have all of the intermediate data filled\n     /// in with 0s.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// let mut f = try!(File::open(\"foo.txt\"));\n+    /// try!(f.set_len(0));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn set_len(&self, size: u64) -> io::Result<()> {\n         self.inner.truncate(size)\n     }\n \n     /// Queries metadata about the underlying file.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// let mut f = try!(File::open(\"foo.txt\"));\n+    /// let metadata = try!(f.metadata());\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn metadata(&self) -> io::Result<Metadata> {\n         self.inner.file_attr().map(Metadata)"}, {"sha": "2a1294f23b20e9a33384abf6d83f14b5ab548a12", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -120,7 +120,7 @@ impl<R> fmt::Debug for BufReader<R> where R: fmt::Debug {\n ///\n /// The buffer will be written out when the writer is dropped.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct BufWriter<W> {\n+pub struct BufWriter<W: Write> {\n     inner: Option<W>,\n     buf: Vec<u8>,\n }\n@@ -220,7 +220,7 @@ impl<W: Write> Write for BufWriter<W> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W> fmt::Debug for BufWriter<W> where W: fmt::Debug {\n+impl<W: Write> fmt::Debug for BufWriter<W> where W: fmt::Debug {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"BufWriter {{ writer: {:?}, buffer: {}/{} }}\",\n                self.inner.as_ref().unwrap(), self.buf.len(), self.buf.capacity())\n@@ -276,7 +276,7 @@ impl<W> fmt::Display for IntoInnerError<W> {\n ///\n /// The buffer will be written out when the writer is dropped.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct LineWriter<W> {\n+pub struct LineWriter<W: Write> {\n     inner: BufWriter<W>,\n }\n \n@@ -335,24 +335,24 @@ impl<W: Write> Write for LineWriter<W> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W> fmt::Debug for LineWriter<W> where W: fmt::Debug {\n+impl<W: Write> fmt::Debug for LineWriter<W> where W: fmt::Debug {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"LineWriter {{ writer: {:?}, buffer: {}/{} }}\",\n                self.inner.inner, self.inner.buf.len(),\n                self.inner.buf.capacity())\n     }\n }\n \n-struct InternalBufWriter<W>(BufWriter<W>);\n+struct InternalBufWriter<W: Write>(BufWriter<W>);\n \n-impl<W> InternalBufWriter<W> {\n+impl<W: Read + Write> InternalBufWriter<W> {\n     fn get_mut(&mut self) -> &mut BufWriter<W> {\n         let InternalBufWriter(ref mut w) = *self;\n         return w;\n     }\n }\n \n-impl<W: Read> Read for InternalBufWriter<W> {\n+impl<W: Read + Write> Read for InternalBufWriter<W> {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         self.get_mut().inner.as_mut().unwrap().read(buf)\n     }\n@@ -367,7 +367,7 @@ impl<W: Read> Read for InternalBufWriter<W> {\n ///\n /// The output buffer will be written out when this stream is dropped.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct BufStream<S> {\n+pub struct BufStream<S: Write> {\n     inner: BufReader<InternalBufWriter<S>>\n }\n \n@@ -448,7 +448,7 @@ impl<S: Read + Write> Write for BufStream<S> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<S> fmt::Debug for BufStream<S> where S: fmt::Debug {\n+impl<S: Write> fmt::Debug for BufStream<S> where S: fmt::Debug {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let reader = &self.inner;\n         let writer = &self.inner.inner.0;"}, {"sha": "df280dab37d467221afff885df9cdd78004e01ba", "filename": "src/libstd/io/lazy.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fio%2Flazy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fio%2Flazy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Flazy.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -35,25 +35,33 @@ impl<T: Send + Sync + 'static> Lazy<T> {\n     pub fn get(&'static self) -> Option<Arc<T>> {\n         let _g = self.lock.lock();\n         unsafe {\n-            let mut ptr = *self.ptr.get();\n+            let ptr = *self.ptr.get();\n             if ptr.is_null() {\n-                ptr = boxed::into_raw(self.init());\n-                *self.ptr.get() = ptr;\n+                Some(self.init())\n             } else if ptr as usize == 1 {\n-                return None\n+                None\n+            } else {\n+                Some((*ptr).clone())\n             }\n-            Some((*ptr).clone())\n         }\n     }\n \n-    fn init(&'static self) -> Box<Arc<T>> {\n-        rt::at_exit(move || unsafe {\n+    unsafe fn init(&'static self) -> Arc<T> {\n+        // If we successfully register an at exit handler, then we cache the\n+        // `Arc` allocation in our own internal box (it will get deallocated by\n+        // the at exit handler). Otherwise we just return the freshly allocated\n+        // `Arc`.\n+        let registered = rt::at_exit(move || {\n             let g = self.lock.lock();\n             let ptr = *self.ptr.get();\n             *self.ptr.get() = 1 as *mut _;\n             drop(g);\n             drop(Box::from_raw(ptr))\n         });\n-        Box::new((self.init)())\n+        let ret = (self.init)();\n+        if registered.is_ok() {\n+            *self.ptr.get() = boxed::into_raw(Box::new(ret.clone()));\n+        }\n+        return ret\n     }\n }"}, {"sha": "c6ae4d0dbec7d87d0ce650569fadfd8467cd91f0", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 14, "deletions": 30, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -16,13 +16,12 @@ use cmp;\n use unicode::str as core_str;\n use error as std_error;\n use fmt;\n-use iter::Iterator;\n+use iter::{self, Iterator, IteratorExt, Extend};\n use marker::Sized;\n use ops::{Drop, FnOnce};\n use option::Option::{self, Some, None};\n use result::Result::{Ok, Err};\n use result;\n-use slice;\n use string::String;\n use str;\n use vec::Vec;\n@@ -50,41 +49,26 @@ mod stdio;\n const DEFAULT_BUF_SIZE: usize = 64 * 1024;\n \n // Acquires a slice of the vector `v` from its length to its capacity\n-// (uninitialized data), reads into it, and then updates the length.\n+// (after initializing the data), reads into it, and then updates the length.\n //\n // This function is leveraged to efficiently read some bytes into a destination\n // vector without extra copying and taking advantage of the space that's already\n // in `v`.\n-//\n-// The buffer we're passing down, however, is pointing at uninitialized data\n-// (the end of a `Vec`), and many operations will be *much* faster if we don't\n-// have to zero it out. In order to prevent LLVM from generating an `undef`\n-// value when reads happen from this uninitialized memory, we force LLVM to\n-// think it's initialized by sending it through a black box. This should prevent\n-// actual undefined behavior after optimizations.\n fn with_end_to_cap<F>(v: &mut Vec<u8>, f: F) -> Result<usize>\n     where F: FnOnce(&mut [u8]) -> Result<usize>\n {\n-    unsafe {\n-        let n = try!(f({\n-            let base = v.as_mut_ptr().offset(v.len() as isize);\n-            black_box(slice::from_raw_parts_mut(base,\n-                                                v.capacity() - v.len()))\n-        }));\n-\n-        // If the closure (typically a `read` implementation) reported that it\n-        // read a larger number of bytes than the vector actually has, we need\n-        // to be sure to clamp the vector to at most its capacity.\n-        let new_len = cmp::min(v.capacity(), v.len() + n);\n-        v.set_len(new_len);\n-        return Ok(n);\n-    }\n-\n-    // Semi-hack used to prevent LLVM from retaining any assumptions about\n-    // `dummy` over this function call\n-    unsafe fn black_box<T>(mut dummy: T) -> T {\n-        asm!(\"\" :: \"r\"(&mut dummy) : \"memory\");\n-        dummy\n+    let len = v.len();\n+    let new_area = v.capacity() - len;\n+    v.extend(iter::repeat(0).take(new_area));\n+    match f(&mut v[len..]) {\n+        Ok(n) => {\n+            v.truncate(len + n);\n+            Ok(n)\n+        }\n+        Err(e) => {\n+            v.truncate(len);\n+            Err(e)\n+        }\n     }\n }\n "}, {"sha": "cca6bb747d43c5f2e66f0f43dcd2883fbc18345b", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -135,6 +135,8 @@\n #![feature(no_std)]\n #![no_std]\n \n+#![allow(trivial_casts)]\n+#![allow(trivial_numeric_casts)]\n #![deny(missing_docs)]\n \n #[cfg(test)] extern crate test;"}, {"sha": "9a9d421dfe1f02700d12a855837c7d1370e19699", "filename": "src/libstd/old_io/buffered.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fold_io%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fold_io%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fbuffered.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -148,14 +148,14 @@ impl<R: Reader> Reader for BufferedReader<R> {\n /// writer.write_str(\"hello, world\").unwrap();\n /// writer.flush().unwrap();\n /// ```\n-pub struct BufferedWriter<W> {\n+pub struct BufferedWriter<W: Writer> {\n     inner: Option<W>,\n     buf: Vec<u8>,\n     pos: uint\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W> fmt::Debug for BufferedWriter<W> where W: fmt::Debug {\n+impl<W: Writer> fmt::Debug for BufferedWriter<W> where W: fmt::Debug {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"BufferedWriter {{ writer: {:?}, buffer: {}/{} }}\",\n                self.inner.as_ref().unwrap(), self.pos, self.buf.len())\n@@ -250,12 +250,12 @@ impl<W: Writer> Drop for BufferedWriter<W> {\n /// `'\\n'`) is detected.\n ///\n /// This writer will be flushed when it is dropped.\n-pub struct LineBufferedWriter<W> {\n+pub struct LineBufferedWriter<W: Writer> {\n     inner: BufferedWriter<W>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<W> fmt::Debug for LineBufferedWriter<W> where W: fmt::Debug {\n+impl<W: Writer> fmt::Debug for LineBufferedWriter<W> where W: fmt::Debug {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         write!(fmt, \"LineBufferedWriter {{ writer: {:?}, buffer: {}/{} }}\",\n                self.inner.inner, self.inner.pos, self.inner.buf.len())\n@@ -299,16 +299,16 @@ impl<W: Writer> Writer for LineBufferedWriter<W> {\n     fn flush(&mut self) -> IoResult<()> { self.inner.flush() }\n }\n \n-struct InternalBufferedWriter<W>(BufferedWriter<W>);\n+struct InternalBufferedWriter<W: Writer>(BufferedWriter<W>);\n \n-impl<W> InternalBufferedWriter<W> {\n+impl<W: Writer> InternalBufferedWriter<W> {\n     fn get_mut<'a>(&'a mut self) -> &'a mut BufferedWriter<W> {\n         let InternalBufferedWriter(ref mut w) = *self;\n         return w;\n     }\n }\n \n-impl<W: Reader> Reader for InternalBufferedWriter<W> {\n+impl<W: Reader + Writer> Reader for InternalBufferedWriter<W> {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         self.get_mut().inner.as_mut().unwrap().read(buf)\n     }\n@@ -343,12 +343,12 @@ impl<W: Reader> Reader for InternalBufferedWriter<W> {\n ///     Err(e) => println!(\"error reading: {}\", e)\n /// }\n /// ```\n-pub struct BufferedStream<S> {\n+pub struct BufferedStream<S: Writer> {\n     inner: BufferedReader<InternalBufferedWriter<S>>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<S> fmt::Debug for BufferedStream<S> where S: fmt::Debug {\n+impl<S: Writer> fmt::Debug for BufferedStream<S> where S: fmt::Debug {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let reader = &self.inner;\n         let writer = &self.inner.inner.0;"}, {"sha": "90d270849114186f57d96fed9290e4c50b124feb", "filename": "src/libstd/old_io/stdio.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fold_io%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fold_io%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fstdio.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -240,7 +240,7 @@ pub fn stdin() -> StdinReader {\n             STDIN = boxed::into_raw(box stdin);\n \n             // Make sure to free it at exit\n-            rt::at_exit(|| {\n+            let _ = rt::at_exit(|| {\n                 Box::from_raw(STDIN);\n                 STDIN = ptr::null_mut();\n             });\n@@ -337,10 +337,10 @@ pub fn set_stderr(_stderr: Box<Writer + Send>) -> Option<Box<Writer + Send>> {\n //      })\n //  })\n fn with_task_stdout<F>(f: F) where F: FnOnce(&mut Writer) -> IoResult<()> {\n-    let mut my_stdout = LOCAL_STDOUT.with(|slot| {\n+    let mut my_stdout: Box<Writer + Send> = LOCAL_STDOUT.with(|slot| {\n         slot.borrow_mut().take()\n     }).unwrap_or_else(|| {\n-        box stdout() as Box<Writer + Send>\n+        box stdout()\n     });\n     let result = f(&mut *my_stdout);\n     let mut var = Some(my_stdout);"}, {"sha": "9079c0aaffb7d3669e6bd57ecce4dde8d7b8c6c2", "filename": "src/libstd/rt/at_exit_imp.rs", "status": "modified", "additions": 36, "deletions": 23, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Frt%2Fat_exit_imp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fat_exit_imp.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -12,6 +12,10 @@\n //!\n //! Documentation can be found on the `rt::at_exit` function.\n \n+// FIXME: switch this to use atexit. Currently this\n+// segfaults (the queue's memory is mysteriously gone), so\n+// instead the cleanup is tied to the `std::rt` entry point.\n+\n use boxed;\n use boxed::Box;\n use vec::Vec;\n@@ -27,47 +31,56 @@ type Queue = Vec<Thunk<'static>>;\n static LOCK: Mutex = MUTEX_INIT;\n static mut QUEUE: *mut Queue = 0 as *mut Queue;\n \n-unsafe fn init() {\n+// The maximum number of times the cleanup routines will be run. While running\n+// the at_exit closures new ones may be registered, and this count is the number\n+// of times the new closures will be allowed to register successfully. After\n+// this number of iterations all new registrations will return `false`.\n+const ITERS: usize = 10;\n+\n+unsafe fn init() -> bool {\n     if QUEUE.is_null() {\n         let state: Box<Queue> = box Vec::new();\n         QUEUE = boxed::into_raw(state);\n-    } else {\n+    } else if QUEUE as usize == 1 {\n         // can't re-init after a cleanup\n-        rtassert!(QUEUE as uint != 1);\n+        return false\n     }\n \n-    // FIXME: switch this to use atexit as below. Currently this\n-    // segfaults (the queue's memory is mysteriously gone), so\n-    // instead the cleanup is tied to the `std::rt` entry point.\n-    //\n-    // ::libc::atexit(cleanup);\n+    return true\n }\n \n pub fn cleanup() {\n-    unsafe {\n-        LOCK.lock();\n-        let queue = QUEUE;\n-        QUEUE = 1 as *mut _;\n-        LOCK.unlock();\n+    for i in 0..ITERS {\n+        unsafe {\n+            LOCK.lock();\n+            let queue = QUEUE;\n+            QUEUE = if i == ITERS - 1 {1} else {0} as *mut _;\n+            LOCK.unlock();\n \n-        // make sure we're not recursively cleaning up\n-        rtassert!(queue as uint != 1);\n+            // make sure we're not recursively cleaning up\n+            rtassert!(queue as usize != 1);\n \n-        // If we never called init, not need to cleanup!\n-        if queue as uint != 0 {\n-            let queue: Box<Queue> = Box::from_raw(queue);\n-            for to_run in *queue {\n-                to_run.invoke(());\n+            // If we never called init, not need to cleanup!\n+            if queue as usize != 0 {\n+                let queue: Box<Queue> = Box::from_raw(queue);\n+                for to_run in *queue {\n+                    to_run.invoke(());\n+                }\n             }\n         }\n     }\n }\n \n-pub fn push(f: Thunk<'static>) {\n+pub fn push(f: Thunk<'static>) -> bool {\n+    let mut ret = true;\n     unsafe {\n         LOCK.lock();\n-        init();\n-        (*QUEUE).push(f);\n+        if init() {\n+            (*QUEUE).push(f);\n+        } else {\n+            ret = false;\n+        }\n         LOCK.unlock();\n     }\n+    return ret\n }"}, {"sha": "497076cc6ac34795e763897cdee911c6f9fba400", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -17,14 +17,9 @@\n //! time being.\n \n #![unstable(feature = \"std_misc\")]\n-\n-// FIXME: this should not be here.\n #![allow(missing_docs)]\n \n-#![allow(dead_code)]\n-\n-use marker::Send;\n-use ops::FnOnce;\n+use prelude::v1::*;\n use sys;\n use thunk::Thunk;\n use usize;\n@@ -73,7 +68,7 @@ fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n     use thread::Thread;\n \n     let something_around_the_top_of_the_stack = 1;\n-    let addr = &something_around_the_top_of_the_stack as *const int;\n+    let addr = &something_around_the_top_of_the_stack as *const _ as *const int;\n     let my_stack_top = addr as uint;\n \n     // FIXME #11359 we just assume that this thread has a stack of a\n@@ -149,13 +144,16 @@ fn lang_start(main: *const u8, argc: int, argv: *const *const u8) -> int {\n \n /// Enqueues a procedure to run when the main thread exits.\n ///\n-/// It is forbidden for procedures to register more `at_exit` handlers when they\n-/// are running, and doing so will lead to a process abort.\n+/// Currently these closures are only run once the main *Rust* thread exits.\n+/// Once the `at_exit` handlers begin running, more may be enqueued, but not\n+/// infinitely so. Eventually a handler registration will be forced to fail.\n ///\n-/// Note that other threads may still be running when `at_exit` routines start\n-/// running.\n-pub fn at_exit<F: FnOnce() + Send + 'static>(f: F) {\n-    at_exit_imp::push(Thunk::new(f));\n+/// Returns `Ok` if the handler was successfully registered, meaning that the\n+/// closure will be run once the main thread exits. Returns `Err` to indicate\n+/// that the closure could not be registered, meaning that it is not scheduled\n+/// to be rune.\n+pub fn at_exit<F: FnOnce() + Send + 'static>(f: F) -> Result<(), ()> {\n+    if at_exit_imp::push(Thunk::new(f)) {Ok(())} else {Err(())}\n }\n \n /// One-time runtime cleanup."}, {"sha": "eb421fe55a4d093ad80337808a5b61333232bd11", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -342,7 +342,7 @@ mod spsc_queue;\n /// The receiving-half of Rust's channel type. This half can only be owned by\n /// one task\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Receiver<T> {\n+pub struct Receiver<T:Send> {\n     inner: UnsafeCell<Flavor<T>>,\n }\n \n@@ -354,14 +354,14 @@ unsafe impl<T: Send> Send for Receiver<T> { }\n /// whenever `next` is called, waiting for a new message, and `None` will be\n /// returned when the corresponding channel has hung up.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Iter<'a, T:'a> {\n+pub struct Iter<'a, T:Send+'a> {\n     rx: &'a Receiver<T>\n }\n \n /// The sending-half of Rust's asynchronous channel type. This half can only be\n /// owned by one task, but it can be cloned to send to other tasks.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Sender<T> {\n+pub struct Sender<T:Send> {\n     inner: UnsafeCell<Flavor<T>>,\n }\n \n@@ -372,7 +372,7 @@ unsafe impl<T: Send> Send for Sender<T> { }\n /// The sending-half of Rust's synchronous channel type. This half can only be\n /// owned by one task, but it can be cloned to send to other tasks.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SyncSender<T> {\n+pub struct SyncSender<T: Send> {\n     inner: Arc<UnsafeCell<sync::Packet<T>>>,\n }\n \n@@ -433,15 +433,15 @@ pub enum TrySendError<T> {\n     Disconnected(T),\n }\n \n-enum Flavor<T> {\n+enum Flavor<T:Send> {\n     Oneshot(Arc<UnsafeCell<oneshot::Packet<T>>>),\n     Stream(Arc<UnsafeCell<stream::Packet<T>>>),\n     Shared(Arc<UnsafeCell<shared::Packet<T>>>),\n     Sync(Arc<UnsafeCell<sync::Packet<T>>>),\n }\n \n #[doc(hidden)]\n-trait UnsafeFlavor<T> {\n+trait UnsafeFlavor<T:Send> {\n     fn inner_unsafe<'a>(&'a self) -> &'a UnsafeCell<Flavor<T>>;\n     unsafe fn inner_mut<'a>(&'a self) -> &'a mut Flavor<T> {\n         &mut *self.inner_unsafe().get()\n@@ -450,12 +450,12 @@ trait UnsafeFlavor<T> {\n         &*self.inner_unsafe().get()\n     }\n }\n-impl<T> UnsafeFlavor<T> for Sender<T> {\n+impl<T:Send> UnsafeFlavor<T> for Sender<T> {\n     fn inner_unsafe<'a>(&'a self) -> &'a UnsafeCell<Flavor<T>> {\n         &self.inner\n     }\n }\n-impl<T> UnsafeFlavor<T> for Receiver<T> {\n+impl<T:Send> UnsafeFlavor<T> for Receiver<T> {\n     fn inner_unsafe<'a>(&'a self) -> &'a UnsafeCell<Flavor<T>> {\n         &self.inner\n     }"}, {"sha": "1be8b0dd8628a217e57fdcaaaeb48c0c65cdc9e9", "filename": "src/libstd/sync/mpsc/mpsc_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -72,7 +72,7 @@ struct Node<T> {\n /// The multi-producer single-consumer structure. This is not cloneable, but it\n /// may be safely shared so long as it is guaranteed that there is only one\n /// popper at a time (many pushers are allowed).\n-pub struct Queue<T> {\n+pub struct Queue<T: Send> {\n     head: AtomicPtr<Node<T>>,\n     tail: UnsafeCell<*mut Node<T>>,\n }"}, {"sha": "13578ce0517911393e106c941ea30e73ce6845a8", "filename": "src/libstd/sync/mpsc/oneshot.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -54,7 +54,7 @@ const DISCONNECTED: usize = 2;   // channel is disconnected OR upgraded\n // moves *from* a pointer, ownership of the token is transferred to\n // whoever changed the state.\n \n-pub struct Packet<T> {\n+pub struct Packet<T:Send> {\n     // Internal state of the chan/port pair (stores the blocked task as well)\n     state: AtomicUsize,\n     // One-shot data slot location\n@@ -64,7 +64,7 @@ pub struct Packet<T> {\n     upgrade: MyUpgrade<T>,\n }\n \n-pub enum Failure<T> {\n+pub enum Failure<T:Send> {\n     Empty,\n     Disconnected,\n     Upgraded(Receiver<T>),\n@@ -76,13 +76,13 @@ pub enum UpgradeResult {\n     UpWoke(SignalToken),\n }\n \n-pub enum SelectionResult<T> {\n+pub enum SelectionResult<T:Send> {\n     SelCanceled,\n     SelUpgraded(SignalToken, Receiver<T>),\n     SelSuccess,\n }\n \n-enum MyUpgrade<T> {\n+enum MyUpgrade<T:Send> {\n     NothingSent,\n     SendUsed,\n     GoUp(Receiver<T>),"}, {"sha": "b509b3472ee413276ecf52c78c64da05e97f4e2b", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -80,7 +80,7 @@ impl !marker::Send for Select {}\n /// A handle to a receiver which is currently a member of a `Select` set of\n /// receivers.  This handle is used to keep the receiver in the set as well as\n /// interact with the underlying receiver.\n-pub struct Handle<'rx, T:'rx> {\n+pub struct Handle<'rx, T:Send+'rx> {\n     /// The ID of this handle, used to compare against the return value of\n     /// `Select::wait()`\n     id: usize,"}, {"sha": "f3930a8a5d632756f52f93d61a1e7b91a47a1939", "filename": "src/libstd/sync/mpsc/shared.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -40,7 +40,7 @@ const MAX_STEALS: isize = 5;\n #[cfg(not(test))]\n const MAX_STEALS: isize = 1 << 20;\n \n-pub struct Packet<T> {\n+pub struct Packet<T: Send> {\n     queue: mpsc::Queue<T>,\n     cnt: AtomicIsize, // How many items are on this channel\n     steals: isize, // How many times has a port received without blocking?"}, {"sha": "cd6d1ee05c788bb453b6ceba4f5112c03f9aef42", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -57,7 +57,7 @@ struct Node<T> {\n /// but it can be safely shared in an Arc if it is guaranteed that there\n /// is only one popper and one pusher touching the queue at any one point in\n /// time.\n-pub struct Queue<T> {\n+pub struct Queue<T: Send> {\n     // consumer fields\n     tail: UnsafeCell<*mut Node<T>>, // where to pop from\n     tail_prev: AtomicPtr<Node<T>>, // where to pop from"}, {"sha": "a5a73314a6db3d36e29cd08540744954ee986c1e", "filename": "src/libstd/sync/mpsc/stream.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -39,7 +39,7 @@ const MAX_STEALS: isize = 5;\n #[cfg(not(test))]\n const MAX_STEALS: isize = 1 << 20;\n \n-pub struct Packet<T> {\n+pub struct Packet<T:Send> {\n     queue: spsc::Queue<Message<T>>, // internal queue for all message\n \n     cnt: AtomicIsize, // How many items are on this channel\n@@ -49,7 +49,7 @@ pub struct Packet<T> {\n     port_dropped: AtomicBool, // flag if the channel has been destroyed.\n }\n \n-pub enum Failure<T> {\n+pub enum Failure<T:Send> {\n     Empty,\n     Disconnected,\n     Upgraded(Receiver<T>),\n@@ -61,15 +61,15 @@ pub enum UpgradeResult {\n     UpWoke(SignalToken),\n }\n \n-pub enum SelectionResult<T> {\n+pub enum SelectionResult<T:Send> {\n     SelSuccess,\n     SelCanceled,\n     SelUpgraded(SignalToken, Receiver<T>),\n }\n \n // Any message could contain an \"upgrade request\" to a new shared port, so the\n // internal queue it's a queue of T, but rather Message<T>\n-enum Message<T> {\n+enum Message<T:Send> {\n     Data(T),\n     GoUp(Receiver<T>),\n }"}, {"sha": "71236269487ef8c803ce2fc1af7d01572cb025a9", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -47,7 +47,7 @@ use sync::mpsc::blocking::{self, WaitToken, SignalToken};\n use sync::mpsc::select::StartResult::{self, Installed, Abort};\n use sync::{Mutex, MutexGuard};\n \n-pub struct Packet<T> {\n+pub struct Packet<T: Send> {\n     /// Only field outside of the mutex. Just done for kicks, but mainly because\n     /// the other shared channel already had the code implemented\n     channels: AtomicUsize,"}, {"sha": "b24cfbb6899a9c655d794958259477a7f8217e11", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -112,7 +112,7 @@ use fmt;\n /// *guard += 1;\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Mutex<T> {\n+pub struct Mutex<T: Send> {\n     // Note that this static mutex is in a *box*, not inlined into the struct\n     // itself. Once a native mutex has been used once, its address can never\n     // change (it can't be moved). This mutex type can be safely moved at any\n@@ -366,7 +366,7 @@ mod test {\n     use sync::{Arc, Mutex, StaticMutex, MUTEX_INIT, Condvar};\n     use thread;\n \n-    struct Packet<T>(Arc<(Mutex<T>, Condvar)>);\n+    struct Packet<T: Send>(Arc<(Mutex<T>, Condvar)>);\n \n     unsafe impl<T: Send> Send for Packet<T> {}\n     unsafe impl<T> Sync for Packet<T> {}"}, {"sha": "10077dfd1b86517f5bcf64ddb37c5bf6eef73178", "filename": "src/libstd/sys/common/helper_thread.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fhelper_thread.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -38,7 +38,7 @@ use thread;\n ///\n /// The fields of this helper are all public, but they should not be used, this\n /// is for static initialization.\n-pub struct Helper<M> {\n+pub struct Helper<M:Send> {\n     /// Internal lock which protects the remaining fields\n     pub lock: StaticMutex,\n     pub cond: StaticCondvar,\n@@ -112,7 +112,7 @@ impl<M: Send> Helper<M> {\n                     self.cond.notify_one()\n                 });\n \n-                rt::at_exit(move || { self.shutdown() });\n+                let _ = rt::at_exit(move || { self.shutdown() });\n                 *self.initialized.get() = true;\n             } else if *self.chan.get() as uint == 1 {\n                 panic!(\"cannot continue usage after shutdown\");"}, {"sha": "734268c70ac9ccd1c0e906d77df44aee4708d370", "filename": "src/libstd/sys/windows/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -36,7 +36,7 @@ pub fn init() {\n                                 &mut data);\n         assert_eq!(ret, 0);\n \n-        rt::at_exit(|| { c::WSACleanup(); })\n+        let _ = rt::at_exit(|| { c::WSACleanup(); });\n     });\n }\n "}, {"sha": "167db1e8ac2d790b056c05af6bd78b8bdb8cdb86", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -109,7 +109,7 @@ impl Iterator for Env {\n             if *self.cur == 0 { return None }\n             let p = &*self.cur;\n             let mut len = 0;\n-            while *(p as *const _).offset(len) != 0 {\n+            while *(p as *const u16).offset(len) != 0 {\n                 len += 1;\n             }\n             let p = p as *const u16;"}, {"sha": "c908c791247d1b3bc47b8379778b380926078fb7", "filename": "src/libstd/sys/windows/thread_local.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread_local.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -133,16 +133,20 @@ unsafe fn init_dtors() {\n     if !DTORS.is_null() { return }\n \n     let dtors = box Vec::<(Key, Dtor)>::new();\n-    DTORS = boxed::into_raw(dtors);\n \n-    rt::at_exit(move|| {\n+    let res = rt::at_exit(move|| {\n         DTOR_LOCK.lock();\n         let dtors = DTORS;\n         DTORS = 1 as *mut _;\n         Box::from_raw(dtors);\n         assert!(DTORS as uint == 1); // can't re-init after destructing\n         DTOR_LOCK.unlock();\n     });\n+    if res.is_ok() {\n+        DTORS = boxed::into_raw(dtors);\n+    } else {\n+        DTORS = 1 as *mut _;\n+    }\n }\n \n unsafe fn register_dtor(key: Key, dtor: Dtor) {"}, {"sha": "a2b824bb016ffa401255a488249e480e0d56eaf8", "filename": "src/libstd/thread/local.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Flocal.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -176,6 +176,7 @@ macro_rules! __thread_local_inner {\n             }\n         };\n \n+        #[allow(trivial_casts)]\n         #[cfg(any(not(any(target_os = \"macos\", target_os = \"linux\")), target_arch = \"aarch64\"))]\n         const _INIT: ::std::thread::__local::__impl::KeyInner<$t> = {\n             ::std::thread::__local::__impl::KeyInner {"}, {"sha": "27b50fc9aaa60ca0312245161eb46c48b8a8f61e", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -698,7 +698,7 @@ impl Drop for JoinHandle {\n /// permission.\n #[must_use = \"thread will be immediately joined if `JoinGuard` is not used\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct JoinGuard<'a, T: 'a> {\n+pub struct JoinGuard<'a, T: Send + 'a> {\n     inner: JoinInner<T>,\n     _marker: PhantomData<&'a T>,\n }"}, {"sha": "6a00fff186002f4383ec2b0e24da9556d3b25dcd", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -284,7 +284,7 @@ pub const COMMAND_LINE_EXPN: ExpnId = ExpnId(-2);\n \n impl ExpnId {\n     pub fn from_llvm_cookie(cookie: c_uint) -> ExpnId {\n-        ExpnId(cookie as u32)\n+        ExpnId(cookie)\n     }\n \n     pub fn to_llvm_cookie(self) -> i32 {\n@@ -376,7 +376,7 @@ impl Encodable for FileMap {\n                         match bytes_per_diff {\n                             1 => for diff in diff_iter { try! { (diff.0 as u8).encode(s) } },\n                             2 => for diff in diff_iter { try! { (diff.0 as u16).encode(s) } },\n-                            4 => for diff in diff_iter { try! { (diff.0 as u32).encode(s) } },\n+                            4 => for diff in diff_iter { try! { diff.0.encode(s) } },\n                             _ => unreachable!()\n                         }\n                     }\n@@ -650,7 +650,7 @@ impl CodeMap {\n         let lo = self.lookup_char_pos(sp.lo);\n         let hi = self.lookup_char_pos(sp.hi);\n         let mut lines = Vec::new();\n-        for i in lo.line - 1..hi.line as usize {\n+        for i in lo.line - 1..hi.line {\n             lines.push(i);\n         };\n         FileLines {file: lo.file, lines: lines}"}, {"sha": "b679456b3537ba00ea448ec2ca0706e7da07bbd3", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -264,7 +264,7 @@ macro_rules! make_MacEager {\n                     box MacEager {\n                         $fld: Some(v),\n                         ..Default::default()\n-                    } as Box<MacResult>\n+                    }\n                 }\n             )*\n         }\n@@ -330,7 +330,7 @@ impl DummyResult {\n     /// Use this as a return value after hitting any errors and\n     /// calling `span_err`.\n     pub fn any(sp: Span) -> Box<MacResult+'static> {\n-        box DummyResult { expr_only: false, span: sp } as Box<MacResult+'static>\n+        box DummyResult { expr_only: false, span: sp }\n     }\n \n     /// Create a default MacResult that can only be an expression.\n@@ -339,7 +339,7 @@ impl DummyResult {\n     /// if an error is encountered internally, the user will receive\n     /// an error that they also used it in the wrong place.\n     pub fn expr(sp: Span) -> Box<MacResult+'static> {\n-        box DummyResult { expr_only: true, span: sp } as Box<MacResult+'static>\n+        box DummyResult { expr_only: true, span: sp }\n     }\n \n     /// A plain dummy expression."}, {"sha": "a25a6451918d72e671784b951fab29d2a3b4c75b", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -262,6 +262,7 @@ pub mod rt {\n         (unsigned, $t:ty, $tag:expr) => (\n             impl ToSource for $t {\n                 fn to_source(&self) -> String {\n+                    #![allow(trivial_numeric_casts)]\n                     let lit = ast::LitInt(*self as u64, ast::UnsignedIntLit($tag));\n                     pprust::lit_to_string(&dummy_spanned(lit))\n                 }"}, {"sha": "1e53db6030143bbcad443e12b866da8fa706c273", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -169,7 +169,7 @@ fn generic_extension<'cx>(cx: &'cx ExtCtxt,\n                 // Weird, but useful for X-macros.\n                 return box ParserAnyMacro {\n                     parser: RefCell::new(p),\n-                } as Box<MacResult+'cx>\n+                }\n               }\n               Failure(sp, ref msg) => if sp.lo >= best_fail_spot.lo {\n                 best_fail_spot = sp;"}, {"sha": "0843713681bbdaad8b27502a7b8c34956ba151de", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -758,7 +758,7 @@ impl<'a> StringReader<'a> {\n                 self.err_span_char(self.last_pos, self.pos,\n                               \"illegal character in numeric character escape\", c);\n                 0\n-            }) as u32;\n+            });\n             self.bump();\n         }\n \n@@ -887,7 +887,7 @@ impl<'a> StringReader<'a> {\n                     self.fatal_span_char(self.last_pos, self.pos,\n                                    \"illegal character in unicode escape\", c);\n                 }\n-            }) as u32;\n+            });\n             self.bump();\n             count += 1;\n         }"}, {"sha": "220ea30256e03cba2014e41a1bdb663671b95e49", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -865,7 +865,7 @@ impl<'a> Parser<'a> {\n         } else {\n             // Avoid token copies with `replace`.\n             let buffer_start = self.buffer_start as usize;\n-            let next_index = (buffer_start + 1) & 3 as usize;\n+            let next_index = (buffer_start + 1) & 3;\n             self.buffer_start = next_index as isize;\n \n             let placeholder = TokenAndSpan {"}, {"sha": "2bc3fc1017ae6808e7940d2e7b75822fe8f8408d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -2836,7 +2836,7 @@ impl<'a> State<'a> {\n             ast::LitBinary(ref v) => {\n                 let mut escaped: String = String::new();\n                 for &ch in &**v {\n-                    escaped.extend(ascii::escape_default(ch as u8)\n+                    escaped.extend(ascii::escape_default(ch)\n                                          .map(|c| c as char));\n                 }\n                 word(&mut self.s, &format!(\"b\\\"{}\\\"\", escaped))"}, {"sha": "41e066cc94a92b2aab65ea336f0c2b16639bffe6", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -103,7 +103,7 @@ impl Write for WriterWrapper {\n /// opened.\n pub fn stdout() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n     TerminfoTerminal::new(WriterWrapper {\n-        wrapped: box std::io::stdout() as Box<Write + Send>,\n+        wrapped: box std::io::stdout(),\n     })\n }\n \n@@ -112,14 +112,14 @@ pub fn stdout() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n /// opened.\n pub fn stdout() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n     let ti = TerminfoTerminal::new(WriterWrapper {\n-        wrapped: box std::io::stdout() as Box<Write + Send>,\n+        wrapped: box std::io::stdout(),\n     });\n \n     match ti {\n         Some(t) => Some(t),\n         None => {\n             WinConsole::new(WriterWrapper {\n-                wrapped: box std::io::stdout() as Box<Write + Send>,\n+                wrapped: box std::io::stdout(),\n             })\n         }\n     }\n@@ -130,7 +130,7 @@ pub fn stdout() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n /// opened.\n pub fn stderr() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n     TerminfoTerminal::new(WriterWrapper {\n-        wrapped: box std::io::stderr() as Box<Write + Send>,\n+        wrapped: box std::io::stderr(),\n     })\n }\n \n@@ -139,14 +139,14 @@ pub fn stderr() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n /// opened.\n pub fn stderr() -> Option<Box<Terminal<WriterWrapper> + Send>> {\n     let ti = TerminfoTerminal::new(WriterWrapper {\n-        wrapped: box std::io::stderr() as Box<Write + Send>,\n+        wrapped: box std::io::stderr(),\n     });\n \n     match ti {\n         Some(t) => Some(t),\n         None => {\n             WinConsole::new(WriterWrapper {\n-                wrapped: box std::io::stderr() as Box<Write + Send>,\n+                wrapped: box std::io::stderr(),\n             })\n         }\n     }"}, {"sha": "1d6657d5932c0d5a410282254e8a7056571dc148", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -190,7 +190,7 @@ impl<T: Write+Send+'static> TerminfoTerminal<T> {\n                         out: out,\n                         ti: msys_terminfo(),\n                         num_colors: 8,\n-                    } as Box<Terminal<T>+Send>)\n+                    })\n                 },\n                 _ => {\n                     debug!(\"error finding terminfo entry: {:?}\", err);\n@@ -213,7 +213,7 @@ impl<T: Write+Send+'static> TerminfoTerminal<T> {\n \n         return Some(box TerminfoTerminal {out: out,\n                                           ti: inf,\n-                                          num_colors: nc} as Box<Terminal<T>+Send>);\n+                                          num_colors: nc});\n     }\n \n     fn dim_if_necessary(&self, color: color::Color) -> color::Color {"}, {"sha": "8d0a9e6e9717d502d2e7b17fa1dd34dceddc90e4", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -186,7 +186,7 @@ pub fn parse(file: &mut Read, longnames: bool)\n     let magic = try!(read_le_u16(file));\n     if magic != 0x011A {\n         return Err(format!(\"invalid magic number: expected {:x}, found {:x}\",\n-                           0x011A as usize, magic as usize));\n+                           0x011A_usize, magic as usize));\n     }\n \n     let names_bytes          = try!(read_le_u16(file)) as int;"}, {"sha": "001313db6769f133b8f8166b16c61428ead730a4", "filename": "src/libterm/win.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibterm%2Fwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibterm%2Fwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fwin.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -126,7 +126,7 @@ impl<T: Write+Send+'static> WinConsole<T> {\n         }\n         Some(box WinConsole { buf: out,\n                               def_foreground: fg, def_background: bg,\n-                              foreground: fg, background: bg } as Box<Terminal<T>+Send>)\n+                              foreground: fg, background: bg })\n     }\n }\n "}, {"sha": "c48c7e413d03baa961ec62c60a07b19e82da678c", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -1021,7 +1021,7 @@ impl MetricMap {\n         let MetricMap(ref mm) = *self;\n         let v : Vec<String> = mm.iter()\n             .map(|(k,v)| format!(\"{}: {} (+/- {})\", *k,\n-                                 v.value as f64, v.noise as f64))\n+                                 v.value, v.noise))\n             .collect();\n         v.connect(\", \")\n     }"}, {"sha": "44af43be7877344cfd878700984662adb9f60058", "filename": "src/rustbook/subcommand.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Frustbook%2Fsubcommand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Frustbook%2Fsubcommand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fsubcommand.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -32,11 +32,11 @@ pub trait Subcommand {\n \n /// Create a Subcommand object based on its name.\n pub fn parse_name(name: &str) -> Option<Box<Subcommand>> {\n-    for parser in [\n-        help::parse_cmd as fn(&str) -> Option<Box<Subcommand>>,\n-        build::parse_cmd as fn(&str) -> Option<Box<Subcommand>>,\n-        serve::parse_cmd as fn(&str) -> Option<Box<Subcommand>>,\n-        test::parse_cmd as fn(&str) -> Option<Box<Subcommand>>].iter() {\n+    let cmds: [fn(&str) -> Option<Box<Subcommand>>; 4] = [help::parse_cmd,\n+                                                          build::parse_cmd,\n+                                                          serve::parse_cmd,\n+                                                          test::parse_cmd];\n+    for parser in cmds.iter() {\n         let parsed = (*parser)(name);\n         if parsed.is_some() { return parsed }\n     }"}, {"sha": "d66cfe9bf636b716867370a728bd5f52091142c6", "filename": "src/test/auxiliary/issue-11224.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fauxiliary%2Fissue-11224.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fauxiliary%2Fissue-11224.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-11224.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -21,6 +21,6 @@ mod inner {\n }\n \n pub fn foo() {\n-    let a = &1 as &inner::Trait;\n+    let a = &1i as &inner::Trait;\n     a.f();\n }"}, {"sha": "832665abdc2d762ab48ac265c3a54e3a674eea43", "filename": "src/test/auxiliary/issue-2526.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2526.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -15,7 +15,7 @@\n \n use std::marker;\n \n-struct arc_destruct<T> {\n+struct arc_destruct<T: Sync> {\n     _data: int,\n     _marker: marker::PhantomData<T>\n }"}, {"sha": "93c37524bf565294dd07c4fba3c4ec794c49bd7a", "filename": "src/test/compile-fail/borrowck-overloaded-call.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-overloaded-call.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -18,26 +18,36 @@ struct SFn {\n }\n \n impl Fn<(isize,)> for SFn {\n-    type Output = isize;\n-\n     extern \"rust-call\" fn call(&self, (z,): (isize,)) -> isize {\n         self.x * self.y * z\n     }\n }\n \n+impl FnMut<(isize,)> for SFn {\n+    extern \"rust-call\" fn call_mut(&mut self, args: (isize,)) -> isize { self.call(args) }\n+}\n+\n+impl FnOnce<(isize,)> for SFn {\n+    type Output = isize;\n+    extern \"rust-call\" fn call_once(self, args: (isize,)) -> isize { self.call(args) }\n+}\n+\n struct SFnMut {\n     x: isize,\n     y: isize,\n }\n \n impl FnMut<(isize,)> for SFnMut {\n-    type Output = isize;\n-\n     extern \"rust-call\" fn call_mut(&mut self, (z,): (isize,)) -> isize {\n         self.x * self.y * z\n     }\n }\n \n+impl FnOnce<(isize,)> for SFnMut {\n+    type Output = isize;\n+    extern \"rust-call\" fn call_once(mut self, args: (isize,)) -> isize { self.call_mut(args) }\n+}\n+\n struct SFnOnce {\n     x: String,\n }"}, {"sha": "27b4a04054f073f203503b5ef9a01298e864a622", "filename": "src/test/compile-fail/coerce-unsafe-to-closure.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Fcoerce-unsafe-to-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Fcoerce-unsafe-to-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoerce-unsafe-to-closure.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -10,5 +10,6 @@\n \n fn main() {\n     let x: Option<&[u8]> = Some(\"foo\").map(std::mem::transmute);\n-    //~^ ERROR: is not implemented for the type\n+    //~^ ERROR E0277\n+    //~| ERROR E0277\n }"}, {"sha": "d1abed9b2627c0a636bd9f1eb96ceb6ce7c3f008", "filename": "src/test/compile-fail/extern-wrong-value-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Fextern-wrong-value-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Fextern-wrong-value-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fextern-wrong-value-type.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -18,5 +18,5 @@ fn main() {\n     let _x: extern \"C\" fn() = f; // OK\n     is_fn(f);\n     //~^ ERROR the trait `core::ops::Fn<()>` is not implemented for the type `extern \"C\" fn()\n-    //~| ERROR the trait `core::ops::Fn<()>` is not implemented for the type `extern \"C\" fn()\n+    //~| ERROR the trait `core::ops::FnOnce<()>` is not implemented for the type `extern \"C\" fn()\n }"}, {"sha": "d86c5d211dc5fa2e339d1fa06582655ee0b44d3f", "filename": "src/test/compile-fail/feature-gate-unboxed-closures-manual-impls.rs", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unboxed-closures-manual-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unboxed-closures-manual-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unboxed-closures-manual-impls.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -18,28 +18,21 @@\n struct Foo;\n impl Fn<()> for Foo {\n     //~^ ERROR angle-bracket notation is not stable when used with the `Fn` family of traits\n-    type Output = ();\n-\n-    extern \"rust-call\" fn call(&self, args: ()) -> () {}\n+    extern \"rust-call\" fn call(self, args: ()) -> () {}\n }\n struct Foo1;\n-impl Fn() for Foo1 {\n+impl FnOnce() for Foo1 {\n     //~^ ERROR associated type bindings are not allowed here\n-\n-    extern \"rust-call\" fn call(&self, args: ()) -> () {}\n+    extern \"rust-call\" fn call_once(self, args: ()) -> () {}\n }\n struct Bar;\n impl FnMut<()> for Bar {\n     //~^ ERROR angle-bracket notation is not stable when used with the `Fn` family of traits\n-    type Output = ();\n-\n     extern \"rust-call\" fn call_mut(&self, args: ()) -> () {}\n }\n struct Baz;\n impl FnOnce<()> for Baz {\n     //~^ ERROR angle-bracket notation is not stable when used with the `Fn` family of traits\n-    type Output = ();\n-\n     extern \"rust-call\" fn call_once(&self, args: ()) -> () {}\n }\n "}, {"sha": "6433255bd4d2fcb7e3dd05894e669f8a38b0b945", "filename": "src/test/compile-fail/fn-trait-formatting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Ffn-trait-formatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Ffn-trait-formatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-trait-formatting.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -35,5 +35,5 @@ fn main() {\n \n     needs_fn(1);\n     //~^ ERROR `core::ops::Fn<(isize,)>`\n-    //~| ERROR `core::ops::Fn<(isize,)>`\n+    //~| ERROR `core::ops::FnOnce<(isize,)>`\n }"}, {"sha": "8e1e88a92e452c09d0200806c4bfe2cdc7386394", "filename": "src/test/compile-fail/fn-variance-1.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Ffn-variance-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Ffn-variance-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-variance-1.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -17,9 +17,13 @@ fn apply<T, F>(t: T, f: F) where F: FnOnce(T) {\n }\n \n fn main() {\n-    apply(&3, takes_mut); //~ ERROR (values differ in mutability)\n     apply(&3, takes_imm);\n+    apply(&3, takes_mut);\n+    //~^ ERROR (values differ in mutability)\n+    //~| ERROR (values differ in mutability)\n \n     apply(&mut 3, takes_mut);\n-    apply(&mut 3, takes_imm); //~ ERROR (values differ in mutability)\n+    apply(&mut 3, takes_imm);\n+    //~^ ERROR (values differ in mutability)\n+    //~| ERROR (values differ in mutability)\n }"}, {"sha": "3f994102a173e0853f052c0b7ba9f3d65e0864bc", "filename": "src/test/compile-fail/issue-14845.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Fissue-14845.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Fissue-14845.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14845.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -22,11 +22,11 @@ fn main() {\n     //~| expected u8\n     //~| found array of 1 elements\n \n-    let local = [0];\n+    let local: [u8; 1] = [0];\n     let _v = &local as *mut u8;\n     //~^ ERROR mismatched types\n     //~| expected `*mut u8`\n-    //~| found `&[_; 1]`\n+    //~| found `&[u8; 1]`\n     //~| expected u8,\n     //~| found array of 1 elements\n }"}, {"sha": "3853434e128ebd0b9465747277150ddf0c9fc41b", "filename": "src/test/compile-fail/issue-15094.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Fissue-15094.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Fissue-15094.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15094.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -16,11 +16,10 @@ struct Debuger<T> {\n     x: T\n }\n \n-impl<T: fmt::Debug> ops::Fn<(),> for Debuger<T> {\n+impl<T: fmt::Debug> ops::FnOnce<(),> for Debuger<T> {\n     type Output = ();\n-\n-    fn call(&self, _args: ()) {\n-//~^ ERROR `call` has an incompatible type for trait: expected \"rust-call\" fn, found \"Rust\" fn\n+    fn call_once(self, _args: ()) {\n+//~^ ERROR `call_once` has an incompatible type for trait: expected \"rust-call\" fn, found \"Rust\" fn\n         println!(\"{:?}\", self.x);\n     }\n }"}, {"sha": "a4e0f69b63b39e0b55c2353ca65c1d95221c6180", "filename": "src/test/compile-fail/issue-16538.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Fissue-16538.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Fissue-16538.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16538.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -19,8 +19,7 @@ mod Y {\n }\n \n static foo: *const Y::X = Y::foo(Y::x as *const Y::X);\n-//~^ ERROR cannot refer to other statics by value\n-//~| ERROR the trait `core::marker::Sync` is not implemented for the type\n+//~^ ERROR the trait `core::marker::Sync` is not implemented for the type\n //~| ERROR function calls in statics are limited to struct and enum constructors\n \n fn main() {}"}, {"sha": "fe427e02451af6a0587f2c7ae49cfc2f98dfa75e", "filename": "src/test/compile-fail/issue-20225.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Fissue-20225.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Fissue-20225.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-20225.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -13,9 +13,19 @@\n struct Foo;\n \n impl<'a, T> Fn<(&'a T,)> for Foo {\n+  extern \"rust-call\" fn call(&self, (_,): (T,)) {}\n+  //~^ ERROR: has an incompatible type for trait: expected &-ptr\n+}\n+\n+impl<'a, T> FnMut<(&'a T,)> for Foo {\n+  extern \"rust-call\" fn call_mut(&mut self, (_,): (T,)) {}\n+  //~^ ERROR: has an incompatible type for trait: expected &-ptr\n+}\n+\n+impl<'a, T> FnOnce<(&'a T,)> for Foo {\n   type Output = ();\n \n-  extern \"rust-call\" fn call(&self, (_,): (T,)) {}\n+  extern \"rust-call\" fn call_once(self, (_,): (T,)) {}\n   //~^ ERROR: has an incompatible type for trait: expected &-ptr\n }\n "}, {"sha": "c27362eea3e3c6cea897f9fe8ac073de693fc3d6", "filename": "src/test/compile-fail/issue-5543.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/123a754cb8356d0e78837dd4e58103ad801309ff/src%2Ftest%2Fcompile-fail%2Fissue-5543.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123a754cb8356d0e78837dd4e58103ad801309ff/src%2Ftest%2Fcompile-fail%2Fissue-5543.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5543.rs?ref=123a754cb8356d0e78837dd4e58103ad801309ff", "patch": "@@ -1,19 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-trait Foo { fn foo(&self) {} }\n-impl Foo for u8 {}\n-\n-fn main() {\n-    // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n-    let r: Box<Foo> = Box::new(5);\n-    let _m: Box<Foo> = r as Box<Foo>;\n-    //~^ ERROR `core::marker::Sized` is not implemented for the type `Foo`\n-}"}, {"sha": "71494fd5f38dcef2116756b89e57a7c6edabdb7f", "filename": "src/test/compile-fail/kindck-impl-type-params.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -28,6 +28,7 @@ fn f<T>(val: T) {\n     let a = &t as &Gettable<T>;\n     //~^ ERROR the trait `core::marker::Send` is not implemented\n     //~^^ ERROR the trait `core::marker::Copy` is not implemented\n+    //~^^^ ERROR the parameter type `T` may not live long enough\n }\n \n fn g<T>(val: T) {"}, {"sha": "ba1b7f03b0f419b2fe15570b7594b77bf4a93f7d", "filename": "src/test/compile-fail/lint-dead-code-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-3.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -86,6 +86,6 @@ mod inner {\n }\n \n pub fn foo() {\n-    let a = &1 as &inner::Trait;\n+    let a: &inner::Trait = &1_isize;\n     a.f();\n }"}, {"sha": "b3cf8257b8f6efa42e6a2f0538e98d0b8a10f554", "filename": "src/test/compile-fail/lint-unnecessary-casts.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/123a754cb8356d0e78837dd4e58103ad801309ff/src%2Ftest%2Fcompile-fail%2Flint-unnecessary-casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123a754cb8356d0e78837dd4e58103ad801309ff/src%2Ftest%2Fcompile-fail%2Flint-unnecessary-casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unnecessary-casts.rs?ref=123a754cb8356d0e78837dd4e58103ad801309ff", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![forbid(unused_typecasts)]\n-\n-fn foo_i32(_: i32) {}\n-\n-fn foo_u64(a: u64) {\n-    let b: i32 = a as i32;\n-    foo_i32(b as i32); //~ ERROR: unnecessary type cast\n-}\n-\n-fn main() {\n-    let x: u64 = 1;\n-    let y: u64 = x as u64; //~ ERROR: unnecessary type cast\n-    foo_u64(y as u64); //~ ERROR: unnecessary type cast\n-}"}, {"sha": "0fee48a8c6c662ddeda75093ea52daf124096aae", "filename": "src/test/compile-fail/liveness-unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -10,7 +10,7 @@\n \n #![deny(unused_variables)]\n #![deny(unused_assignments)]\n-#![allow(dead_code, non_camel_case_types)]\n+#![allow(dead_code, non_camel_case_types, trivial_numeric_casts)]\n \n fn f1(x: isize) {\n     //~^ ERROR unused variable: `x`"}, {"sha": "5a8772d61425fcb9176c7c69abe6368a900c34c1", "filename": "src/test/compile-fail/object-safety-by-value-self.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Fobject-safety-by-value-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Fobject-safety-by-value-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-safety-by-value-self.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -12,6 +12,7 @@\n \n #![feature(rustc_attrs)]\n #![allow(dead_code)]\n+#![allow(trivial_casts)]\n \n trait Bar {\n     fn bar(self);"}, {"sha": "77ac97bc8b89951427bf7aaa9d69d0e45675f55a", "filename": "src/test/compile-fail/overloaded-calls-bad.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-bad.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -18,13 +18,18 @@ struct S {\n }\n \n impl FnMut<(isize,)> for S {\n-    type Output = isize;\n-\n     extern \"rust-call\" fn call_mut(&mut self, (z,): (isize,)) -> isize {\n         self.x * self.y * z\n     }\n }\n \n+impl FnOnce<(isize,)> for S {\n+    type Output = isize;\n+    extern \"rust-call\" fn call_once(mut self, (z,): (isize,)) -> isize {\n+        self.call_mut((z,))\n+    }\n+}\n+\n fn main() {\n     let mut s = S {\n         x: 3,"}, {"sha": "ea47d676412098c04e54399afc0a05d7187a7be7", "filename": "src/test/compile-fail/overloaded-calls-nontuple.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-nontuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-nontuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foverloaded-calls-nontuple.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -18,12 +18,16 @@ struct S {\n }\n \n impl FnMut<isize> for S {\n-    type Output = isize;\n     extern \"rust-call\" fn call_mut(&mut self, z: isize) -> isize {\n         self.x + self.y + z\n     }\n }\n \n+impl FnOnce<isize> for S {\n+    type Output = isize;\n+    extern \"rust-call\" fn call_once(mut self, z: isize) -> isize { self.call_mut(z) }\n+}\n+\n fn main() {\n     let mut s = S {\n         x: 1,"}, {"sha": "253132e5f07d02ed93ea98fcb613cb440934a750", "filename": "src/test/compile-fail/regions-close-object-into-object-5.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-object-into-object-5.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -24,6 +24,7 @@ impl<'a, T> X for B<'a, T> {}\n \n fn f<'a, T, U>(v: Box<A<T>+'static>) -> Box<X+'static> {\n     box B(&*v) as Box<X> //~ ERROR the parameter type `T` may not live long enough\n+        //~^ ERROR the parameter type `T` may not live long enough\n }\n \n fn main() {}"}, {"sha": "924044647d84a08473c547d8da2366d2bb8b34b6", "filename": "src/test/compile-fail/regions-close-over-type-parameter-1.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-close-over-type-parameter-1.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -19,6 +19,7 @@ trait SomeTrait { fn get(&self) -> isize; }\n fn make_object1<A:SomeTrait>(v: A) -> Box<SomeTrait+'static> {\n     box v as Box<SomeTrait+'static>\n         //~^ ERROR the parameter type `A` may not live long enough\n+        //~^^ ERROR the parameter type `A` may not live long enough\n }\n \n fn make_object2<'a,A:SomeTrait+'a>(v: A) -> Box<SomeTrait+'a> {\n@@ -28,6 +29,7 @@ fn make_object2<'a,A:SomeTrait+'a>(v: A) -> Box<SomeTrait+'a> {\n fn make_object3<'a,'b,A:SomeTrait+'a>(v: A) -> Box<SomeTrait+'b> {\n     box v as Box<SomeTrait+'b>\n         //~^ ERROR the parameter type `A` may not live long enough\n+        //~^^ ERROR the parameter type `A` may not live long enough\n }\n \n fn main() { }"}, {"sha": "30264c9f218a18aed7e7665e46da61df077ab37c", "filename": "src/test/compile-fail/reject-specialized-drops-8142.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Freject-specialized-drops-8142.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Freject-specialized-drops-8142.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Freject-specialized-drops-8142.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -0,0 +1,79 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue 8142: Test that Drop impls cannot be specialized beyond the\n+// predicates attached to the struct/enum definition itself.\n+\n+#![feature(unsafe_destructor)]\n+\n+trait Bound { fn foo(&self) { } }\n+struct K<'l1,'l2> { x: &'l1 i8, y: &'l2 u8 }\n+struct L<'l1,'l2> { x: &'l1 i8, y: &'l2 u8 }\n+struct M<'m> { x: &'m i8 }\n+struct N<'n> { x: &'n i8 }\n+struct O<To> { x: *const To }\n+struct P<Tp> { x: *const Tp }\n+struct Q<Tq> { x: *const Tq }\n+struct R<Tr> { x: *const Tr }\n+struct S<Ts:Bound> { x: *const Ts }\n+struct T<'t,Ts:'t> { x: &'t Ts }\n+struct U;\n+struct V<Tva, Tvb> { x: *const Tva, y: *const Tvb }\n+struct W<'l1, 'l2> { x: &'l1 i8, y: &'l2 u8 }\n+\n+#[unsafe_destructor]\n+impl<'al,'adds_bnd:'al> Drop for K<'al,'adds_bnd> {                        // REJECT\n+    //~^ ERROR The requirement `'adds_bnd : 'al` is added only by the Drop impl.\n+    fn drop(&mut self) { } }\n+\n+#[unsafe_destructor]\n+impl<'al,'adds_bnd>     Drop for L<'al,'adds_bnd> where 'adds_bnd:'al {    // REJECT\n+    //~^ ERROR The requirement `'adds_bnd : 'al` is added only by the Drop impl.\n+    fn drop(&mut self) { } }\n+\n+#[unsafe_destructor]\n+impl<'ml>               Drop for M<'ml>         { fn drop(&mut self) { } } // ACCEPT\n+\n+#[unsafe_destructor]\n+impl                    Drop for N<'static>     { fn drop(&mut self) { } } // REJECT\n+//~^ ERROR Implementations of Drop cannot be specialized\n+\n+#[unsafe_destructor]\n+impl<Cok_nobound> Drop for O<Cok_nobound> { fn drop(&mut self) { } } // ACCEPT\n+\n+#[unsafe_destructor]\n+impl              Drop for P<i8>          { fn drop(&mut self) { } } // REJECT\n+//~^ ERROR Implementations of Drop cannot be specialized\n+\n+#[unsafe_destructor]\n+impl<Adds_bnd:Bound> Drop for Q<Adds_bnd> { fn drop(&mut self) { } } // REJECT\n+//~^ ERROR The requirement `Adds_bnd : Bound` is added only by the Drop impl.\n+\n+#[unsafe_destructor]\n+impl<'rbnd,Adds_rbnd:'rbnd> Drop for R<Adds_rbnd> { fn drop(&mut self) { } } // REJECT\n+//~^ ERROR The requirement `Adds_rbnd : 'rbnd` is added only by the Drop impl.\n+\n+#[unsafe_destructor]\n+impl<Bs:Bound>    Drop for S<Bs>          { fn drop(&mut self) { } } // ACCEPT\n+\n+#[unsafe_destructor]\n+impl<'t,Bt:'t>    Drop for T<'t,Bt>       { fn drop(&mut self) { } } // ACCEPT\n+\n+impl              Drop for U              { fn drop(&mut self) { } } // ACCEPT\n+\n+#[unsafe_destructor]\n+impl<One>         Drop for V<One,One>     { fn drop(&mut self) { } } // REJECT\n+//~^ERROR Implementations of Drop cannot be specialized\n+\n+#[unsafe_destructor]\n+impl<'lw>         Drop for W<'lw,'lw>     { fn drop(&mut self) { } } // REJECT\n+//~^ERROR Implementations of Drop cannot be specialized\n+\n+pub fn main() { }"}, {"sha": "3119b865488e896b1a5cba0c195c2532778d72fa", "filename": "src/test/compile-fail/trivial_casts.rs", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Ftrivial_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Ftrivial_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrivial_casts.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -0,0 +1,94 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test the trivial_casts and trivial_numeric_casts lints. For each error we also\n+// check that the cast can be done using just coercion.\n+\n+#![deny(trivial_casts, trivial_numeric_casts)]\n+\n+trait Foo {\n+    fn foo(&self) {}\n+}\n+\n+pub struct Bar;\n+\n+impl Foo for Bar {}\n+\n+pub fn main() {\n+    // Numeric\n+    let _ = 42_i32 as i32; //~ ERROR trivial numeric cast: `i32` as `i32`\n+    let _: i32 = 42_i32;\n+\n+    let _ = 42_u8 as u8; //~ ERROR trivial numeric cast: `u8` as `u8`\n+    let _: u8 = 42_u8;\n+\n+    // & to * pointers\n+    let x: &u32 = &42;\n+    let _ = x as *const u32; //~ERROR trivial cast: `&u32` as `*const u32`\n+    let _: *const u32 = x;\n+\n+    let x: &mut u32 = &mut 42;\n+    let _ = x as *mut u32; //~ERROR trivial cast: `&mut u32` as `*mut u32`\n+    let _: *mut u32 = x;\n+\n+    // unsize array\n+    let x: &[u32; 3] = &[42, 43, 44];\n+    let _ = x as &[u32]; //~ERROR trivial cast: `&[u32; 3]` as `&[u32]`\n+    let _ = x as *const [u32]; //~ERROR trivial cast: `&[u32; 3]` as `*const [u32]`\n+    let _: &[u32] = x;\n+    let _: *const [u32] = x;\n+\n+    let x: &mut [u32; 3] = &mut [42, 43, 44];\n+    let _ = x as &mut [u32]; //~ERROR trivial cast: `&mut [u32; 3]` as `&mut [u32]`\n+    let _ = x as *mut [u32]; //~ERROR trivial cast: `&mut [u32; 3]` as `*mut [u32]`\n+    let _: &mut [u32] = x;\n+    let _: *mut [u32] = x;\n+\n+    let x: Box<[u32; 3]> = Box::new([42, 43, 44]);\n+    let _ = x as Box<[u32]>; //~ERROR trivial cast: `Box<[u32; 3]>` as `Box<[u32]>`\n+    let x: Box<[u32; 3]> = Box::new([42, 43, 44]);\n+    let _: Box<[u32]> = x;\n+\n+    // unsize trait\n+    let x: &Bar = &Bar;\n+    let _ = x as &Foo; //~ERROR trivial cast: `&Bar` as `&Foo`\n+    let _ = x as *const Foo; //~ERROR trivial cast: `&Bar` as `*const Foo`\n+    let _: &Foo = x;\n+    let _: *const Foo = x;\n+\n+    let x: &mut Bar = &mut Bar;\n+    let _ = x as &mut Foo; //~ERROR trivial cast: `&mut Bar` as `&mut Foo`\n+    let _ = x as *mut Foo; //~ERROR trivial cast: `&mut Bar` as `*mut Foo`\n+    let _: &mut Foo = x;\n+    let _: *mut Foo = x;\n+\n+    let x: Box<Bar> = Box::new(Bar);\n+    let _ = x as Box<Foo>; //~ERROR trivial cast: `Box<Bar>` as `Box<Foo>`\n+    let x: Box<Bar> = Box::new(Bar);\n+    let _: Box<Foo> = x;\n+\n+    // functions\n+    fn baz(_x: i32) {}\n+    let _ = &baz as &Fn(i32); //~ERROR trivial cast: `&fn(i32) {main::baz}` as `&core::ops::Fn(i32)`\n+    let _: &Fn(i32) = &baz;\n+    let x = |_x: i32| {};\n+    let _ = &x as &Fn(i32); //~ERROR trivial cast\n+    let _: &Fn(i32) = &x;\n+}\n+\n+// subtyping\n+pub fn test_subtyping<'a, 'b: 'a>(a: &'a Bar, b: &'b Bar) {\n+    let _ = a as &'a Bar; //~ERROR trivial cast\n+    let _: &'a Bar = a;\n+    let _ = b as &'a Bar; //~ERROR trivial cast\n+    let _: &'a Bar = b;\n+    let _ = b as &'b Bar; //~ERROR trivial cast\n+    let _: &'b Bar = b;\n+}"}, {"sha": "8cc531625d17956c0d01223736884c2601774dc1", "filename": "src/test/compile-fail/type-parameter-defaults-referencing-Self-ppaux.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Ftype-parameter-defaults-referencing-Self-ppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Ftype-parameter-defaults-referencing-Self-ppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-parameter-defaults-referencing-Self-ppaux.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -20,7 +20,7 @@ impl MyAdd for i32 {\n }\n \n fn main() {\n-    let x = 5;\n+    let x: i32 = 5;\n     let y = x as MyAdd<i32>;\n     //~^ ERROR as `MyAdd<i32>`\n }"}, {"sha": "93498ac7f83514c1768d1babc95dcd640c3435e2", "filename": "src/test/compile-fail/unboxed-closures-fnmut-as-fn.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Funboxed-closures-fnmut-as-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Funboxed-closures-fnmut-as-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-fnmut-as-fn.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -19,19 +19,22 @@ use std::ops::{Fn,FnMut,FnOnce};\n struct S;\n \n impl FnMut<(isize,)> for S {\n-    type Output = isize;\n-\n     extern \"rust-call\" fn call_mut(&mut self, (x,): (isize,)) -> isize {\n         x * x\n     }\n }\n \n+impl FnOnce<(isize,)> for S {\n+    type Output = isize;\n+\n+    extern \"rust-call\" fn call_once(mut self, args: (isize,)) -> isize { self.call_mut(args) }\n+}\n+\n fn call_it<F:Fn(isize)->isize>(f: &F, x: isize) -> isize {\n     f.call((x,))\n }\n \n fn main() {\n     let x = call_it(&S, 22);\n     //~^ ERROR not implemented\n-    //~| ERROR not implemented\n }"}, {"sha": "2dcd7a97d8977eec83fc37a53c8dd016bc3b31fa", "filename": "src/test/compile-fail/unboxed-closures-recursive-fn-using-fn-mut.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Funboxed-closures-recursive-fn-using-fn-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Funboxed-closures-recursive-fn-using-fn-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-recursive-fn-using-fn-mut.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -28,14 +28,19 @@ impl<F,A,R> YCombinator<F,A,R> {\n }\n \n impl<A,R,F : FnMut(&mut FnMut(A) -> R, A) -> R> FnMut<(A,)> for YCombinator<F,A,R> {\n-    type Output = R;\n-\n     extern \"rust-call\" fn call_mut(&mut self, (arg,): (A,)) -> R {\n         (self.func)(self, arg)\n             //~^ ERROR cannot borrow `*self` as mutable more than once at a time\n     }\n }\n \n+impl<A,R,F : FnMut(&mut FnMut(A) -> R, A) -> R> FnOnce<(A,)> for YCombinator<F,A,R> {\n+    type Output = R;\n+    extern \"rust-call\" fn call_once(mut self, args: (A,)) -> R {\n+        self.call_mut(args)\n+    }\n+}\n+\n fn main() {\n     let mut counter = 0;\n     let factorial = |recur: &mut FnMut(u32) -> u32, arg: u32| -> u32 {"}, {"sha": "dc7c70ba649d8b0524766893a060679a1714c511", "filename": "src/test/compile-fail/unboxed-closures-unsafe-extern-fn.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Funboxed-closures-unsafe-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Funboxed-closures-unsafe-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-unsafe-extern-fn.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -27,11 +27,15 @@ fn a() {\n }\n \n fn b() {\n-    let y = call_it_mut(&mut square, 22); //~ ERROR not implemented\n+    let y = call_it_mut(&mut square, 22);\n+    //~^ ERROR not implemented\n+    //~| ERROR not implemented\n }\n \n fn c() {\n-    let z = call_it_once(square, 22); //~ ERROR not implemented\n+    let z = call_it_once(square, 22);\n+    //~^ ERROR not implemented\n+    //~| ERROR not implemented\n }\n \n fn main() { }"}, {"sha": "cdcb435b65a6acfcc8cdc3700d420022234385bb", "filename": "src/test/compile-fail/unboxed-closures-wrong-abi.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-abi.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -27,11 +27,15 @@ fn a() {\n }\n \n fn b() {\n-    let y = call_it_mut(&mut square, 22); //~ ERROR not implemented\n+    let y = call_it_mut(&mut square, 22);\n+    //~^ ERROR not implemented\n+    //~| ERROR not implemented\n }\n \n fn c() {\n-    let z = call_it_once(square, 22); //~ ERROR not implemented\n+    let z = call_it_once(square, 22);\n+    //~^ ERROR not implemented\n+    //~| ERROR not implemented\n }\n \n fn main() { }"}, {"sha": "150bf36dcc286db2befd582b8dd6fa055495e1b8", "filename": "src/test/compile-fail/unboxed-closures-wrong-arg-type-extern-fn.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-arg-type-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-arg-type-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-wrong-arg-type-extern-fn.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -28,11 +28,15 @@ fn a() {\n }\n \n fn b() {\n-    let y = call_it_mut(&mut square, 22); //~ ERROR not implemented\n+    let y = call_it_mut(&mut square, 22);\n+    //~^ ERROR not implemented\n+    //~| ERROR not implemented\n }\n \n fn c() {\n-    let z = call_it_once(square, 22); //~ ERROR not implemented\n+    let z = call_it_once(square, 22);\n+    //~^ ERROR not implemented\n+    //~| ERROR not implemented\n }\n \n fn main() { }"}, {"sha": "cac52306d6ae0e1a4d08dfd13763c4552f6099a7", "filename": "src/test/compile-fail/vector-cast-weirdness.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Fvector-cast-weirdness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fcompile-fail%2Fvector-cast-weirdness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvector-cast-weirdness.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -10,6 +10,8 @@\n \n // Issue #14893. Tests that casts from vectors don't behave strangely in the\n // presence of the `_` type shorthand notation.\n+// Update: after a change to the way casts are done, we have more type information\n+// around and so the errors here are no longer exactly the same.\n \n struct X {\n     y: [u8; 2],\n@@ -18,12 +20,14 @@ struct X {\n fn main() {\n     let x1 = X { y: [0, 0] };\n \n-    let p1: *const u8 = &x1.y as *const _;  //~ ERROR mismatched types\n+    // No longer a type mismatch - the `_` can be fully resolved by type inference.\n+    let p1: *const u8 = &x1.y as *const _;\n     let t1: *const [u8; 2] = &x1.y as *const _;\n     let h1: *const [u8; 2] = &x1.y as *const [u8; 2];\n \n     let mut x1 = X { y: [0, 0] };\n \n+    // This is still an error since we don't allow casts from &mut [T; n] to *mut T.\n     let p1: *mut u8 = &mut x1.y as *mut _;  //~ ERROR mismatched types\n     let t1: *mut [u8; 2] = &mut x1.y as *mut _;\n     let h1: *mut [u8; 2] = &mut x1.y as *mut [u8; 2];"}, {"sha": "d4cbd255e34c2861bcc35fee75c15dc6134a9038", "filename": "src/test/debuginfo/type-names.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftype-names.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -291,15 +291,15 @@ fn main() {\n     let slice2 = &*vec2;\n \n     // Trait Objects\n-    let box_trait = (box 0) as Box<Trait1>;\n-    let ref_trait = &0 as &Trait1;\n-    let mut mut_int1 = 0;\n+    let box_trait = (box 0_isize) as Box<Trait1>;\n+    let ref_trait = &0_isize as &Trait1;\n+    let mut mut_int1 = 0_isize;\n     let mut_ref_trait = (&mut mut_int1) as &mut Trait1;\n \n-    let generic_box_trait = (box 0) as Box<Trait2<i32, Mod1::Struct2>>;\n-    let generic_ref_trait  = (&0) as &Trait2<Struct1, Struct1>;\n+    let generic_box_trait = (box 0_isize) as Box<Trait2<i32, Mod1::Struct2>>;\n+    let generic_ref_trait  = (&0_isize) as &Trait2<Struct1, Struct1>;\n \n-    let mut generic_mut_ref_trait_impl = 0;\n+    let mut generic_mut_ref_trait_impl = 0_isize;\n     let generic_mut_ref_trait = (&mut generic_mut_ref_trait_impl) as\n         &mut Trait2<Mod1::Mod2::Struct3, GenericStruct<usize, isize>>;\n "}, {"sha": "42b2fe806e95f605bbd91febc4a4737d8fa117e4", "filename": "src/test/pretty/path-type-bounds.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fpretty%2Fpath-type-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Fpretty%2Fpath-type-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fpath-type-bounds.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -21,5 +21,5 @@ fn foo<'a>(x: Box<Tr+ Sync + 'a>) -> Box<Tr+ Sync + 'a> { x }\n fn main() {\n     let x: Box<Tr+ Sync>;\n \n-    Box::new(1) as Box<Tr+ Sync>;\n+    Box::new(1isize) as Box<Tr+ Sync>;\n }"}, {"sha": "474a6782b616b3af1ea845be56b948c662cda0b6", "filename": "src/test/run-make/symbols-are-reasonable/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-make%2Fsymbols-are-reasonable%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-make%2Fsymbols-are-reasonable%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsymbols-are-reasonable%2Flib.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -16,5 +16,5 @@ impl Foo for uint {}\n \n pub fn dummy() {\n     // force the vtable to be created\n-    let _x = &1 as &Foo;\n+    let _x = &1u as &Foo;\n }"}, {"sha": "0bec3af4273afad2819f79523f6bba194425dae8", "filename": "src/test/run-pass/autoderef-method-on-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fautoderef-method-on-trait.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -22,6 +22,6 @@ impl double for uint {\n }\n \n pub fn main() {\n-    let x: Box<_> = box() (box 3 as Box<double>);\n+    let x: Box<_> = box() (box 3u as Box<double>);\n     assert_eq!(x.double(), 6);\n }"}, {"sha": "deb0c0d0dc0df884c4c0c2ba01d3df22e309b47e", "filename": "src/test/run-pass/cast-region-to-uint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fcast-region-to-uint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fcast-region-to-uint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcast-region-to-uint.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -9,6 +9,6 @@\n // except according to those terms.\n \n pub fn main() {\n-    let x = 3;\n+    let x: int = 3;\n     println!(\"&x={:x}\", (&x as *const int as uint));\n }"}, {"sha": "7347ded99e7c4e10ed96ce895b6a1147f36369b2", "filename": "src/test/run-pass/infer-container-across-object-cast.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/123a754cb8356d0e78837dd4e58103ad801309ff/src%2Ftest%2Frun-pass%2Finfer-container-across-object-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123a754cb8356d0e78837dd4e58103ad801309ff/src%2Ftest%2Frun-pass%2Finfer-container-across-object-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finfer-container-across-object-cast.rs?ref=123a754cb8356d0e78837dd4e58103ad801309ff", "patch": "@@ -1,61 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Given `<expr> as Box<Trait>`, we should be able to infer that a\n-// `Box<_>` is the expected type.\n-\n-// pretty-expanded FIXME #23616\n-\n-trait Foo { fn foo(&self) -> u32; }\n-impl Foo for u32 { fn foo(&self) -> u32 { *self } }\n-\n-// (another impl to ensure trait-matching cannot just choose from a singleton set)\n-impl Foo for  () { fn foo(&self) -> u32 { -176 } }\n-\n-trait Boxed { fn make() -> Self; }\n-impl Boxed for Box<u32> { fn make() -> Self { Box::new(7) } }\n-\n-// (another impl to ensure trait-matching cannot just choose from a singleton set)\n-impl Boxed for () { fn make() -> Self { () } }\n-\n-fn boxed_foo() {\n-    let b7 = Boxed::make() as Box<Foo>;\n-    assert_eq!(b7.foo(), 7);\n-}\n-\n-trait Refed<'a,T> { fn make(&'a T) -> Self; }\n-impl<'a> Refed<'a, u32> for &'a u32 { fn make(x: &'a u32) -> Self { x } }\n-\n-// (another impl to ensure trait-matching cannot just choose from a singleton set)\n-impl<'a,'b> Refed<'a, ()> for &'b () { fn make(_: &'a ()) -> Self { static U: () = (); &U } }\n-\n-fn refed_foo() {\n-    let a = 8;\n-    let b7 = Refed::make(&a) as &Foo;\n-    assert_eq!(b7.foo(), 8);\n-}\n-\n-fn check_subtyping_works() {\n-    fn inner<'short, 'long:'short>(_s: &'short u32,\n-                                   l: &'long u32) -> &'short (Foo+'short) {\n-        Refed::make(l) as &Foo\n-    }\n-\n-    let a = 9;\n-    let b = 10;\n-    let r = inner(&b, &a);\n-    assert_eq!(r.foo(), 9);\n-}\n-\n-pub fn main() {\n-    boxed_foo();\n-    refed_foo();\n-    check_subtyping_works();\n-}"}, {"sha": "11219b04f2b97003e55434f34b4f1312af2fe1c2", "filename": "src/test/run-pass/issue-13655.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fissue-13655.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fissue-13655.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-13655.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -14,14 +14,27 @@ use std::ops::Fn;\n struct Foo<T>(T);\n \n impl<T: Copy> Fn<()> for Foo<T> {\n-    type Output = T;\n     extern \"rust-call\" fn call(&self, _: ()) -> T {\n       match *self {\n         Foo(t) => t\n       }\n     }\n }\n \n+impl<T: Copy> FnMut<()> for Foo<T> {\n+    extern \"rust-call\" fn call_mut(&mut self, _: ()) -> T {\n+        self.call(())\n+    }\n+}\n+\n+impl<T: Copy> FnOnce<()> for Foo<T> {\n+    type Output = T;\n+\n+    extern \"rust-call\" fn call_once(self, _: ()) -> T {\n+        self.call(())\n+    }\n+}\n+\n fn main() {\n   let t: u8 = 1;\n   println!(\"{}\", Foo(t)());"}, {"sha": "ec482a776def32f4e3bf940b0a09272130179b91", "filename": "src/test/run-pass/issue-14958.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fissue-14958.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fissue-14958.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14958.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -17,10 +17,18 @@ trait Foo { fn dummy(&self) { }}\n struct Bar;\n \n impl<'a> std::ops::Fn<(&'a (Foo+'a),)> for Bar {\n-    type Output = ();\n     extern \"rust-call\" fn call(&self, _: (&'a Foo,)) {}\n }\n \n+impl<'a> std::ops::FnMut<(&'a (Foo+'a),)> for Bar {\n+    extern \"rust-call\" fn call_mut(&mut self, a: (&'a Foo,)) { self.call(a) }\n+}\n+\n+impl<'a> std::ops::FnOnce<(&'a (Foo+'a),)> for Bar {\n+    type Output = ();\n+    extern \"rust-call\" fn call_once(self, a: (&'a Foo,)) { self.call(a) }\n+}\n+\n struct Baz;\n \n impl Foo for Baz {}"}, {"sha": "5accaf363490fae2b1e45692d78e2e9156ef7941", "filename": "src/test/run-pass/issue-14959.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fissue-14959.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fissue-14959.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-14959.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -36,9 +36,21 @@ impl Alloy {\n }\n \n impl<'b> Fn<(&'b mut (Response+'b),)> for SendFile {\n+    extern \"rust-call\" fn call(&self, (_res,): (&'b mut (Response+'b),)) {}\n+}\n+\n+impl<'b> FnMut<(&'b mut (Response+'b),)> for SendFile {\n+    extern \"rust-call\" fn call_mut(&mut self, (_res,): (&'b mut (Response+'b),)) {\n+        self.call((_res,))\n+    }\n+}\n+\n+impl<'b> FnOnce<(&'b mut (Response+'b),)> for SendFile {\n     type Output = ();\n \n-    extern \"rust-call\" fn call(&self, (_res,): (&'b mut (Response+'b),)) {}\n+    extern \"rust-call\" fn call_once(self, (_res,): (&'b mut (Response+'b),)) {\n+        self.call((_res,))\n+    }\n }\n \n impl<Rq: Request, Rs: Response> Ingot<Rq, Rs> for HelloWorld {"}, {"sha": "f30991a19635251797a88dc08e06e72980789f41", "filename": "src/test/run-pass/issue-15763.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fissue-15763.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fissue-15763.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15763.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -87,12 +87,12 @@ fn main() {\n     assert_eq!(cc().unwrap(), 3);\n     assert_eq!(dd().unwrap(), 3);\n \n-    let i = box 32 as Box<A>;\n+    let i = box 32i as Box<A>;\n     assert_eq!(i.aaa(), 3);\n-    let i = box 32 as Box<A>;\n+    let i = box 32i as Box<A>;\n     assert_eq!(i.bbb(), 3);\n-    let i = box 32 as Box<A>;\n+    let i = box 32i as Box<A>;\n     assert_eq!(i.ccc().unwrap(), 3);\n-    let i = box 32 as Box<A>;\n+    let i = box 32i as Box<A>;\n     assert_eq!(i.ddd().unwrap(), 3);\n }"}, {"sha": "265db3fe1336a6520a4d92dfd0e63e3c96c3f014", "filename": "src/test/run-pass/issue-15858.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fissue-15858.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fissue-15858.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15858.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -25,7 +25,7 @@ impl Bar for BarImpl {\n }\n \n \n-struct Foo<B>(B);\n+struct Foo<B: Bar>(B);\n \n #[unsafe_destructor]\n impl<B: Bar> Drop for Foo<B> {"}, {"sha": "e544585745de3dfc21839f252614879bc2e19d44", "filename": "src/test/run-pass/issue-15924.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fissue-15924.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fissue-15924.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15924.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -18,7 +18,7 @@ use std::fmt;\n use serialize::{Encoder, Encodable};\n use serialize::json;\n \n-struct Foo<T> {\n+struct Foo<T: Encodable> {\n     v: T,\n }\n "}, {"sha": "99ddaba4e5514513291796aa2d90198757bf776d", "filename": "src/test/run-pass/issue-16739.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fissue-16739.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fissue-16739.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16739.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -20,20 +20,36 @@\n struct Foo { foo: u32 }\n \n impl FnMut<()> for Foo {\n-    type Output = u32;\n     extern \"rust-call\" fn call_mut(&mut self, _: ()) -> u32 { self.foo }\n }\n \n-impl FnMut<(u32,)> for Foo {\n+impl FnOnce<()> for Foo {\n     type Output = u32;\n+    extern \"rust-call\" fn call_once(mut self, _: ()) -> u32 { self.call_mut(()) }\n+}\n+\n+/////////////////////////////////////////////////////////////////////////\n+\n+impl FnMut<(u32,)> for Foo {\n     extern \"rust-call\" fn call_mut(&mut self, (x,): (u32,)) -> u32 { self.foo + x }\n }\n \n-impl FnMut<(u32,u32)> for Foo {\n+impl FnOnce<(u32,)> for Foo {\n     type Output = u32;\n+    extern \"rust-call\" fn call_once(mut self, args: (u32,)) -> u32 { self.call_mut(args) }\n+}\n+\n+/////////////////////////////////////////////////////////////////////////\n+\n+impl FnMut<(u32,u32)> for Foo {\n     extern \"rust-call\" fn call_mut(&mut self, (x, y): (u32, u32)) -> u32 { self.foo + x + y }\n }\n \n+impl FnOnce<(u32,u32)> for Foo {\n+    type Output = u32;\n+    extern \"rust-call\" fn call_once(mut self, args: (u32,u32)) -> u32 { self.call_mut(args) }\n+}\n+\n fn main() {\n     let mut f = box Foo { foo: 42 } as Box<FnMut() -> u32>;\n     assert_eq!(f.call_mut(()), 42);"}, {"sha": "9442b039bc6cbecd1bc3573123e38f156c09d2a0", "filename": "src/test/run-pass/issue-19982.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fissue-19982.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fissue-19982.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-19982.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -16,9 +16,17 @@\n struct Foo;\n \n impl<'a> Fn<(&'a (),)> for Foo {\n+    extern \"rust-call\" fn call(&self, (_,): (&(),)) {}\n+}\n+\n+impl<'a> FnMut<(&'a (),)> for Foo {\n+    extern \"rust-call\" fn call_mut(&mut self, (_,): (&(),)) {}\n+}\n+\n+impl<'a> FnOnce<(&'a (),)> for Foo {\n     type Output = ();\n \n-    extern \"rust-call\" fn call(&self, (_,): (&(),)) {}\n+    extern \"rust-call\" fn call_once(self, (_,): (&(),)) {}\n }\n \n fn main() {}"}, {"sha": "7ca0ee01015b89f2c0db75779ff2ee1bd6afe691", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -162,7 +162,7 @@ pub mod pipes {\n         }\n     }\n \n-    pub struct send_packet<T> {\n+    pub struct send_packet<T:Send> {\n         p: Option<*const packet<T>>,\n     }\n \n@@ -192,7 +192,7 @@ pub mod pipes {\n         }\n     }\n \n-    pub struct recv_packet<T> {\n+    pub struct recv_packet<T:Send> {\n         p: Option<*const packet<T>>,\n     }\n "}, {"sha": "08ee955cabbacd65e29a8300f9901f6f29f60b6b", "filename": "src/test/run-pass/issue-4252.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fissue-4252.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fissue-4252.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4252.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -21,7 +21,7 @@ trait X {\n struct Y(int);\n \n #[derive(Debug)]\n-struct Z<T> {\n+struct Z<T: X+std::fmt::Debug> {\n     x: T\n }\n "}, {"sha": "54773d71cbec0464575cabb24c2ea131181cadab", "filename": "src/test/run-pass/issue-5708.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fissue-5708.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fissue-5708.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-5708.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -41,7 +41,7 @@ impl<'a> Outer<'a> {\n }\n \n pub fn main() {\n-    let inner = 5;\n+    let inner: int = 5;\n     let outer = Outer::new(&inner as &Inner);\n     outer.inner.print();\n }"}, {"sha": "6e88379f9a41b2676b33eb65002d535cb57376a5", "filename": "src/test/run-pass/issue-9719.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fissue-9719.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fissue-9719.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9719.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -21,7 +21,7 @@ mod a {\n     impl X for int {}\n \n     pub struct Z<'a>(Enum<&'a (X+'a)>);\n-    fn foo() { let x = 42; let z = Z(Enum::A(&x as &X)); let _ = z; }\n+    fn foo() { let x: int = 42; let z = Z(Enum::A(&x as &X)); let _ = z; }\n }\n \n mod b {\n@@ -34,7 +34,7 @@ mod b {\n     }\n \n     fn bar() {\n-        let x = 42;\n+        let x: int = 42;\n         let _y = Y { x: Some(&x as &X) };\n     }\n }\n@@ -43,7 +43,7 @@ mod c {\n     pub trait X { fn f(&self); }\n     impl X for int { fn f(&self) {} }\n     pub struct Z<'a>(Option<&'a (X+'a)>);\n-    fn main() { let x = 42; let z = Z(Some(&x as &X)); let _ = z; }\n+    fn main() { let x: int = 42; let z = Z(Some(&x as &X)); let _ = z; }\n }\n \n pub fn main() {}"}, {"sha": "de8d116255ba227a2ae18f36f8a9103871d2bca3", "filename": "src/test/run-pass/method-two-traits-distinguished-via-where-clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fmethod-two-traits-distinguished-via-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fmethod-two-traits-distinguished-via-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-two-traits-distinguished-via-where-clause.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -33,6 +33,6 @@ impl<T> B for *const [T] {\n \n fn main() {\n     let x: [int; 4] = [1,2,3,4];\n-    let xptr = x.as_slice() as *const _;\n+    let xptr = x.as_slice() as *const [int];\n     xptr.foo();\n }"}, {"sha": "baf8c6e4c97913e459911e0940be8e47220833d3", "filename": "src/test/run-pass/object-one-type-two-traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fobject-one-type-two-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fobject-one-type-two-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobject-one-type-two-traits.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -35,7 +35,7 @@ fn is<T:'static>(x: &Any) -> bool {\n }\n \n fn main() {\n-    let x = box 22 as Box<Wrap>;\n+    let x = box 22isize as Box<Wrap>;\n     println!(\"x={}\", x.get());\n     let y = x.wrap();\n }"}, {"sha": "368842ed1b0304244841ae3d233670baf9351281", "filename": "src/test/run-pass/objects-coerce-freeze-borrored.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fobjects-coerce-freeze-borrored.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fobjects-coerce-freeze-borrored.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobjects-coerce-freeze-borrored.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -42,7 +42,7 @@ fn do_it_imm(obj: &Foo, v: uint) {\n }\n \n pub fn main() {\n-    let mut x = 22;\n+    let mut x: uint = 22;\n     let obj = &mut x as &mut Foo;\n     do_it_mut(obj);\n     do_it_imm(obj, 23);"}, {"sha": "597075c550051bc8664e3b0e63853468757f8932", "filename": "src/test/run-pass/overloaded-calls-param-vtables.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Foverloaded-calls-param-vtables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Foverloaded-calls-param-vtables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-calls-param-vtables.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -21,13 +21,20 @@ use std::ops::Add;\n struct G<A>(PhantomData<A>);\n \n impl<'a, A: Add<i32, Output=i32>> Fn<(A,)> for G<A> {\n-    type Output = i32;\n-\n     extern \"rust-call\" fn call(&self, (arg,): (A,)) -> i32 {\n         arg.add(1)\n     }\n }\n \n+impl<'a, A: Add<i32, Output=i32>> FnMut<(A,)> for G<A> {\n+    extern \"rust-call\" fn call_mut(&mut self, args: (A,)) -> i32 { self.call(args) }\n+}\n+\n+impl<'a, A: Add<i32, Output=i32>> FnOnce<(A,)> for G<A> {\n+    type Output = i32;\n+    extern \"rust-call\" fn call_once(self, args: (A,)) -> i32 { self.call(args) }\n+}\n+\n fn main() {\n     // ICE trigger\n     (G(PhantomData))(1);"}, {"sha": "eeb705a2e3c99b5db12af2de0530c1a98b1c1399", "filename": "src/test/run-pass/overloaded-calls-simple.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Foverloaded-calls-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Foverloaded-calls-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-calls-simple.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -20,24 +20,38 @@ struct S1 {\n }\n \n impl FnMut<(i32,)> for S1 {\n-    type Output = i32;\n     extern \"rust-call\" fn call_mut(&mut self, (z,): (i32,)) -> i32 {\n         self.x * self.y * z\n     }\n }\n \n+impl FnOnce<(i32,)> for S1 {\n+    type Output = i32;\n+    extern \"rust-call\" fn call_once(mut self, args: (i32,)) -> i32 {\n+        self.call_mut(args)\n+    }\n+}\n+\n struct S2 {\n     x: i32,\n     y: i32,\n }\n \n impl Fn<(i32,)> for S2 {\n-    type Output = i32;\n     extern \"rust-call\" fn call(&self, (z,): (i32,)) -> i32 {\n         self.x * self.y * z\n     }\n }\n \n+impl FnMut<(i32,)> for S2 {\n+    extern \"rust-call\" fn call_mut(&mut self, args: (i32,)) -> i32 { self.call(args) }\n+}\n+\n+impl FnOnce<(i32,)> for S2 {\n+    type Output = i32;\n+    extern \"rust-call\" fn call_once(self, args: (i32,)) -> i32 { self.call(args) }\n+}\n+\n struct S3 {\n     x: i32,\n     y: i32,"}, {"sha": "110109018db59d672476ca3f9e9deea720b69b59", "filename": "src/test/run-pass/overloaded-calls-zero-args.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Foverloaded-calls-zero-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Foverloaded-calls-zero-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-calls-zero-args.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -20,12 +20,16 @@ struct S {\n }\n \n impl FnMut<()> for S {\n-    type Output = i32;\n     extern \"rust-call\" fn call_mut(&mut self, (): ()) -> i32 {\n         self.x * self.y\n     }\n }\n \n+impl FnOnce<()> for S {\n+    type Output = i32;\n+    extern \"rust-call\" fn call_once(mut self, args: ()) -> i32 { self.call_mut(args) }\n+}\n+\n fn main() {\n     let mut s = S {\n         x: 3,"}, {"sha": "c87c79ca24edaab83cd7ac4aba3063342ff95493", "filename": "src/test/run-pass/regions-early-bound-trait-param.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fregions-early-bound-trait-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fregions-early-bound-trait-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-early-bound-trait-param.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -83,7 +83,10 @@ impl<'s> Trait<'s> for (int,int) {\n }\n \n impl<'t> MakerTrait for Box<Trait<'t>+'static> {\n-    fn mk() -> Box<Trait<'t>+'static> { box() (4,5) as Box<Trait> }\n+    fn mk() -> Box<Trait<'t>+'static> {\n+        let tup: Box<(int, int)> = box() (4,5);\n+        tup as Box<Trait>\n+    }\n }\n \n enum List<'l> {"}, {"sha": "920cd9e03ab6b4ee97fd876a94e5c60bbfa44d92", "filename": "src/test/run-pass/stable-addr-of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fstable-addr-of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fstable-addr-of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstable-addr-of.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -13,6 +13,6 @@\n // pretty-expanded FIXME #23616\n \n pub fn main() {\n-    let foo = 1;\n+    let foo: int = 1;\n     assert_eq!(&foo as *const int, &foo as *const int);\n }"}, {"sha": "5c0d0fe9a63d8ed74b4ff05042e1562a6debf52c", "filename": "src/test/run-pass/task-spawn-move-and-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -19,7 +19,7 @@ use std::sync::mpsc::channel;\n pub fn main() {\n     let (tx, rx) = channel::<uint>();\n \n-    let x: Box<_> = box 1;\n+    let x: Box<int> = box 1;\n     let x_in_parent = &(*x) as *const int as uint;\n \n     let _t = Thread::spawn(move || {"}, {"sha": "3da1ba0f0451f0b047faa1b495496390bab50f62", "filename": "src/test/run-pass/trivial_casts.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Ftrivial_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Ftrivial_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrivial_casts.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -0,0 +1,71 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that all coercions can actually be done using casts (modulo the lints).\n+\n+#![allow(trivial_casts, trivial_numeric_casts)]\n+\n+trait Foo {\n+    fn foo(&self) {}\n+}\n+\n+pub struct Bar;\n+\n+impl Foo for Bar {}\n+\n+pub fn main() {\n+    // Numeric\n+    let _ = 42_i32 as i32;\n+    let _ = 42_u8 as u8;\n+\n+    // & to * pointers\n+    let x: &u32 = &42;\n+    let _ = x as *const u32;\n+\n+    let x: &mut u32 = &mut 42;\n+    let _ = x as *mut u32;\n+\n+    // unsize array\n+    let x: &[u32; 3] = &[42, 43, 44];\n+    let _ = x as &[u32];\n+    let _ = x as *const [u32];\n+\n+    let x: &mut [u32; 3] = &mut [42, 43, 44];\n+    let _ = x as &mut [u32];\n+    let _ = x as *mut [u32];\n+\n+    let x: Box<[u32; 3]> = Box::new([42, 43, 44]);\n+    let _ = x as Box<[u32]>;\n+\n+    // unsize trait\n+    let x: &Bar = &Bar;\n+    let _ = x as &Foo;\n+    let _ = x as *const Foo;\n+\n+    let x: &mut Bar = &mut Bar;\n+    let _ = x as &mut Foo;\n+    let _ = x as *mut Foo;\n+\n+    let x: Box<Bar> = Box::new(Bar);\n+    let _ = x as Box<Foo>;\n+\n+    // functions\n+    fn baz(_x: i32) {}\n+    let _ = &baz as &Fn(i32);\n+    let x = |_x: i32| {};\n+    let _ = &x as &Fn(i32);\n+}\n+\n+// subtyping\n+pub fn test_subtyping<'a, 'b: 'a>(a: &'a Bar, b: &'b Bar) {\n+    let _ = a as &'a Bar;\n+    let _ = b as &'a Bar;\n+    let _ = b as &'b Bar;\n+}"}, {"sha": "53e78db68b19d485d7a4b81abc9fd4cfb0cd6c08", "filename": "src/test/run-pass/typeck_type_placeholder_1.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Ftypeck_type_placeholder_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Ftypeck_type_placeholder_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypeck_type_placeholder_1.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -14,17 +14,17 @@\n // pretty-expanded FIXME #23616\n \n struct TestStruct {\n-    x: *const int\n+    x: *const isize\n }\n \n unsafe impl Sync for TestStruct {}\n \n-static CONSTEXPR: TestStruct = TestStruct{x: &413 as *const _};\n+static CONSTEXPR: TestStruct = TestStruct{ x: &413 };\n \n \n pub fn main() {\n     let x: Vec<_> = (0..5).collect();\n-    let expected: &[uint] = &[0,1,2,3,4];\n+    let expected: &[usize] = &[0,1,2,3,4];\n     assert_eq!(x, expected);\n \n     let x = (0..5).collect::<Vec<_>>();\n@@ -33,8 +33,8 @@ pub fn main() {\n     let y: _ = \"hello\";\n     assert_eq!(y.len(), 5);\n \n-    let ptr = &5;\n+    let ptr: &usize = &5;\n     let ptr2 = ptr as *const _;\n \n-    assert_eq!(ptr as *const uint as uint, ptr2 as uint);\n+    assert_eq!(ptr as *const usize as usize, ptr2 as usize);\n }"}, {"sha": "9b71abf3653318c21fbc558cdb07822bba9845a5", "filename": "src/test/run-pass/unboxed-closures-fn-as-fnmut-and-fnonce.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Funboxed-closures-fn-as-fnmut-and-fnonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Funboxed-closures-fn-as-fnmut-and-fnonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-fn-as-fnmut-and-fnonce.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -20,12 +20,20 @@ use std::ops::{Fn,FnMut,FnOnce};\n struct S;\n \n impl Fn<(i32,)> for S {\n-    type Output = i32;\n     extern \"rust-call\" fn call(&self, (x,): (i32,)) -> i32 {\n         x * x\n     }\n }\n \n+impl FnMut<(i32,)> for S {\n+    extern \"rust-call\" fn call_mut(&mut self, args: (i32,)) -> i32 { self.call(args) }\n+}\n+\n+impl FnOnce<(i32,)> for S {\n+    type Output = i32;\n+    extern \"rust-call\" fn call_once(self, args: (i32,)) -> i32 { self.call(args) }\n+}\n+\n fn call_it<F:Fn(i32)->i32>(f: &F, x: i32) -> i32 {\n     f(x)\n }"}, {"sha": "6261058b86742a2f9d4edc91597ab03ef65e2638", "filename": "src/test/run-pass/unboxed-closures-fnmut-as-fnonce.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Funboxed-closures-fnmut-as-fnonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Funboxed-closures-fnmut-as-fnonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-fnmut-as-fnonce.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -20,13 +20,17 @@ use std::ops::{FnMut,FnOnce};\n struct S;\n \n impl FnMut<(i32,)> for S {\n-    type Output = i32;\n-\n     extern \"rust-call\" fn call_mut(&mut self, (x,): (i32,)) -> i32 {\n         x * x\n     }\n }\n \n+impl FnOnce<(i32,)> for S {\n+    type Output = i32;\n+\n+    extern \"rust-call\" fn call_once(mut self, args: (i32,)) -> i32 { self.call_mut(args) }\n+}\n+\n fn call_it_mut<F:FnMut(i32)->i32>(f: &mut F, x: i32) -> i32 {\n     f(x)\n }"}, {"sha": "e02784f917a97e71ca134242bfd9013ac55f188c", "filename": "src/test/run-pass/unboxed-closures-infer-recursive-fn.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-recursive-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-recursive-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-recursive-fn.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -32,13 +32,20 @@ impl<F,A,R> YCombinator<F,A,R> {\n }\n \n impl<A,R,F : Fn(&Fn(A) -> R, A) -> R> Fn<(A,)> for YCombinator<F,A,R> {\n-    type Output = R;\n-\n     extern \"rust-call\" fn call(&self, (arg,): (A,)) -> R {\n         (self.func)(self, arg)\n     }\n }\n \n+impl<A,R,F : Fn(&Fn(A) -> R, A) -> R> FnMut<(A,)> for YCombinator<F,A,R> {\n+    extern \"rust-call\" fn call_mut(&mut self, args: (A,)) -> R { self.call(args) }\n+}\n+\n+impl<A,R,F : Fn(&Fn(A) -> R, A) -> R> FnOnce<(A,)> for YCombinator<F,A,R> {\n+    type Output = R;\n+    extern \"rust-call\" fn call_once(self, args: (A,)) -> R { self.call(args) }\n+}\n+\n fn main() {\n     let factorial = |recur: &Fn(u32) -> u32, arg: u32| -> u32 {\n         if arg == 0 {1} else {arg * recur(arg-1)}"}, {"sha": "38f15d6e4499b30c7f970eb83ebb482bbf025b45", "filename": "src/test/run-pass/unboxed-closures-manual-impl.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Funboxed-closures-manual-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Funboxed-closures-manual-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-manual-impl.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -17,13 +17,17 @@ use std::ops::FnMut;\n struct S;\n \n impl FnMut<(i32,)> for S {\n-    type Output = i32;\n-\n     extern \"rust-call\" fn call_mut(&mut self, (x,): (i32,)) -> i32 {\n         x * x\n     }\n }\n \n+impl FnOnce<(i32,)> for S {\n+    type Output = i32;\n+\n+    extern \"rust-call\" fn call_once(mut self, args: (i32,)) -> i32 { self.call_mut(args) }\n+}\n+\n fn call_it<F:FnMut(i32)->i32>(mut f: F, x: i32) -> i32 {\n     f(x) + 3\n }"}, {"sha": "ba12599747068ac7666d0655578f3181456dcc4d", "filename": "src/test/run-pass/zero_sized_subslice_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fzero_sized_subslice_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/593db005d4dbce2ff72009c1ba03477b031b2c0f/src%2Ftest%2Frun-pass%2Fzero_sized_subslice_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fzero_sized_subslice_match.rs?ref=593db005d4dbce2ff72009c1ba03477b031b2c0f", "patch": "@@ -16,6 +16,6 @@ fn main() {\n     // The subslice used to go out of bounds for zero-sized array items, check that this doesn't\n     // happen anymore\n     match x {\n-        [_, y..] => assert_eq!(&x[1] as *const _, &y[0] as *const _)\n+        [_, y..] => assert_eq!(&x[1] as *const (), &y[0] as *const ())\n     }\n }"}]}