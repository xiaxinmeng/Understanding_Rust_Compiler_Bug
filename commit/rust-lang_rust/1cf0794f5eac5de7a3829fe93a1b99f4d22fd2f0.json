{"sha": "1cf0794f5eac5de7a3829fe93a1b99f4d22fd2f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjZjA3OTRmNWVhYzVkZTdhMzgyOWZlOTNhMWI5OWY0ZDIyZmQyZjA=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-05-19T17:06:49Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-19T17:06:49Z"}, "message": "Merge #8882\n\n8882: internal: resolve attributes in name resolution (minimal version) r=jonas-schievink a=jonas-schievink\n\nCloses https://github.com/rust-analyzer/rust-analyzer/pull/7049\r\n\r\nThis should not have any observable effect, since we don't attempt to expand attribute macros yet, and I have implemented a fallback that treats items with unresolved attributes as if the attribute wasn't there.\r\n\r\nDerive helpers are not yet resolved. `#![register_{attr,tool}]` are not yet supported.\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "00b6bd0173f586a44fc84573cc9d867fcf162940", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00b6bd0173f586a44fc84573cc9d867fcf162940"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1cf0794f5eac5de7a3829fe93a1b99f4d22fd2f0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgpUWpCRBK7hj4Ov3rIwAAa2YIACY78Ri6QaFmu7wnAGL3uJsa\nGjluUCN4t3iBcNa9C8bTJXWWO9w9nG400NkMXwIf/H9KMNtWuTcvgxmQ2sUQk36l\nGsDtdPV9hHjGL39krGvh08EBpR2IBoOmF3++iBBtUhXLqxTDtbtQbOFWJ8PB6KFl\ng1/tUz8UAv6u8jGZ2+WQD080vC2BtfuHeJ5p3RteIaaidlMBpWTBqduxXkdWwMsv\n2fKfoQnYBwAsPKh+J8IKtssnHOJGF+jZXv086DRxQFDKyisXS5oFWjRvyFpu0YYm\n/b9cm1jpW7KEsTTb8jE4+8XVpWektqdOvV3i0XFgzTNaWmBtmL0D10h7Z+yGfC4=\n=y++J\n-----END PGP SIGNATURE-----\n", "payload": "tree 00b6bd0173f586a44fc84573cc9d867fcf162940\nparent f4afffc7e9fbcfe4981ee3d89206e37940b27008\nparent 383635a13e336c35c2c41d412e4452ecd86e5cf2\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1621444009 +0000\ncommitter GitHub <noreply@github.com> 1621444009 +0000\n\nMerge #8882\n\n8882: internal: resolve attributes in name resolution (minimal version) r=jonas-schievink a=jonas-schievink\n\nCloses https://github.com/rust-analyzer/rust-analyzer/pull/7049\r\n\r\nThis should not have any observable effect, since we don't attempt to expand attribute macros yet, and I have implemented a fallback that treats items with unresolved attributes as if the attribute wasn't there.\r\n\r\nDerive helpers are not yet resolved. `#![register_{attr,tool}]` are not yet supported.\n\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1cf0794f5eac5de7a3829fe93a1b99f4d22fd2f0", "html_url": "https://github.com/rust-lang/rust/commit/1cf0794f5eac5de7a3829fe93a1b99f4d22fd2f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1cf0794f5eac5de7a3829fe93a1b99f4d22fd2f0/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4afffc7e9fbcfe4981ee3d89206e37940b27008", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4afffc7e9fbcfe4981ee3d89206e37940b27008", "html_url": "https://github.com/rust-lang/rust/commit/f4afffc7e9fbcfe4981ee3d89206e37940b27008"}, {"sha": "383635a13e336c35c2c41d412e4452ecd86e5cf2", "url": "https://api.github.com/repos/rust-lang/rust/commits/383635a13e336c35c2c41d412e4452ecd86e5cf2", "html_url": "https://github.com/rust-lang/rust/commit/383635a13e336c35c2c41d412e4452ecd86e5cf2"}], "stats": {"total": 188, "additions": 160, "deletions": 28}, "files": [{"sha": "5cc7f2df659393381ef99c5c192d387fe4a57287", "filename": "crates/hir_def/src/intern.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1cf0794f5eac5de7a3829fe93a1b99f4d22fd2f0/crates%2Fhir_def%2Fsrc%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf0794f5eac5de7a3829fe93a1b99f4d22fd2f0/crates%2Fhir_def%2Fsrc%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fintern.rs?ref=1cf0794f5eac5de7a3829fe93a1b99f4d22fd2f0", "patch": "@@ -4,7 +4,7 @@\n \n use std::{\n     collections::HashMap,\n-    fmt::{self, Debug},\n+    fmt::{self, Debug, Display},\n     hash::{BuildHasherDefault, Hash, Hasher},\n     ops::Deref,\n     sync::Arc,\n@@ -171,6 +171,12 @@ impl<T: Debug + Internable + ?Sized> Debug for Interned<T> {\n     }\n }\n \n+impl<T: Display + Internable + ?Sized> Display for Interned<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        (*self.arc).fmt(f)\n+    }\n+}\n+\n pub struct InternStorage<T: ?Sized> {\n     map: OnceCell<InternMap<T>>,\n }"}, {"sha": "221a5a5567a1d64dd3684c4f4a7036bb4d7ac8d9", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 153, "deletions": 27, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/1cf0794f5eac5de7a3829fe93a1b99f4d22fd2f0/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf0794f5eac5de7a3829fe93a1b99f4d22fd2f0/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=1cf0794f5eac5de7a3829fe93a1b99f4d22fd2f0", "patch": "@@ -21,6 +21,7 @@ use syntax::ast;\n \n use crate::{\n     attr::{AttrId, Attrs},\n+    builtin_attr,\n     db::DefDatabase,\n     derive_macro_as_call_id,\n     intern::Interned,\n@@ -99,6 +100,7 @@ pub(super) fn collect_defs(\n         proc_macros,\n         exports_proc_macros: false,\n         from_glob_import: Default::default(),\n+        ignore_attrs_on: FxHashSet::default(),\n     };\n     match block {\n         Some(block) => {\n@@ -217,6 +219,7 @@ struct MacroDirective {\n enum MacroDirectiveKind {\n     FnLike { ast_id: AstIdWithPath<ast::MacroCall>, fragment: FragmentKind },\n     Derive { ast_id: AstIdWithPath<ast::Item>, derive_attr: AttrId },\n+    Attr { ast_id: AstIdWithPath<ast::Item>, attr: AttrId, mod_item: ModItem },\n }\n \n struct DefData<'a> {\n@@ -243,6 +246,7 @@ struct DefCollector<'a> {\n     proc_macros: Vec<(Name, ProcMacroExpander)>,\n     exports_proc_macros: bool,\n     from_glob_import: PerNsGlobImports,\n+    ignore_attrs_on: FxHashSet<ModItem>,\n }\n \n impl DefCollector<'_> {\n@@ -292,16 +296,26 @@ impl DefCollector<'_> {\n     fn collect(&mut self) {\n         // main name resolution fixed-point loop.\n         let mut i = 0;\n-        loop {\n-            self.db.check_canceled();\n-            self.resolve_imports();\n+        'outer: loop {\n+            loop {\n+                self.db.check_canceled();\n+                loop {\n+                    if self.resolve_imports() == ReachedFixedPoint::Yes {\n+                        break;\n+                    }\n+                }\n+                if self.resolve_macros() == ReachedFixedPoint::Yes {\n+                    break;\n+                }\n \n-            match self.resolve_macros() {\n-                ReachedFixedPoint::Yes => break,\n-                ReachedFixedPoint::No => i += 1,\n+                i += 1;\n+                if i == FIXED_POINT_LIMIT {\n+                    log::error!(\"name resolution is stuck\");\n+                    break 'outer;\n+                }\n             }\n-            if i == FIXED_POINT_LIMIT {\n-                log::error!(\"name resolution is stuck\");\n+\n+            if self.reseed_with_unresolved_attributes() == ReachedFixedPoint::Yes {\n                 break;\n             }\n         }\n@@ -343,6 +357,50 @@ impl DefCollector<'_> {\n         }\n     }\n \n+    /// When the fixed-point loop reaches a stable state, we might still have some unresolved\n+    /// attributes (or unexpanded attribute proc macros) left over. This takes them, and feeds the\n+    /// item they're applied to back into name resolution.\n+    ///\n+    /// This effectively ignores the fact that the macro is there and just treats the items as\n+    /// normal code.\n+    ///\n+    /// This improves UX when proc macros are turned off or don't work, and replicates the behavior\n+    /// before we supported proc. attribute macros.\n+    fn reseed_with_unresolved_attributes(&mut self) -> ReachedFixedPoint {\n+        let mut added_items = false;\n+        let unexpanded_macros = std::mem::replace(&mut self.unexpanded_macros, Vec::new());\n+        for directive in &unexpanded_macros {\n+            if let MacroDirectiveKind::Attr { mod_item, .. } = &directive.kind {\n+                // Make sure to only add such items once.\n+                if !self.ignore_attrs_on.insert(*mod_item) {\n+                    continue;\n+                }\n+\n+                let file_id = self.def_map[directive.module_id].definition_source(self.db).file_id;\n+                let item_tree = self.db.file_item_tree(file_id);\n+                let mod_dir = self.mod_dirs[&directive.module_id].clone();\n+                ModCollector {\n+                    def_collector: &mut *self,\n+                    macro_depth: directive.depth,\n+                    module_id: directive.module_id,\n+                    file_id,\n+                    item_tree: &item_tree,\n+                    mod_dir,\n+                }\n+                .collect(&[*mod_item]);\n+                added_items = true;\n+            }\n+        }\n+        self.unexpanded_macros = unexpanded_macros;\n+\n+        if added_items {\n+            // Continue name resolution with the new data.\n+            ReachedFixedPoint::No\n+        } else {\n+            ReachedFixedPoint::Yes\n+        }\n+    }\n+\n     /// Adds a definition of procedural macro `name` to the root module.\n     ///\n     /// # Notes on procedural macro resolution\n@@ -504,35 +562,35 @@ impl DefCollector<'_> {\n         }\n     }\n \n-    /// Import resolution\n-    ///\n-    /// This is a fix point algorithm. We resolve imports until no forward\n-    /// progress in resolving imports is made\n-    fn resolve_imports(&mut self) {\n-        let mut n_previous_unresolved = self.unresolved_imports.len() + 1;\n-\n-        while self.unresolved_imports.len() < n_previous_unresolved {\n-            n_previous_unresolved = self.unresolved_imports.len();\n-            let imports = std::mem::replace(&mut self.unresolved_imports, Vec::new());\n-            for mut directive in imports {\n+    /// Tries to resolve every currently unresolved import.\n+    fn resolve_imports(&mut self) -> ReachedFixedPoint {\n+        let mut res = ReachedFixedPoint::Yes;\n+        let imports = std::mem::replace(&mut self.unresolved_imports, Vec::new());\n+        let imports = imports\n+            .into_iter()\n+            .filter_map(|mut directive| {\n                 directive.status = self.resolve_import(directive.module_id, &directive.import);\n                 match directive.status {\n                     PartialResolvedImport::Indeterminate(_) => {\n                         self.record_resolved_import(&directive);\n                         // FIXME: For avoid performance regression,\n                         // we consider an imported resolved if it is indeterminate (i.e not all namespace resolved)\n-                        self.resolved_imports.push(directive)\n+                        self.resolved_imports.push(directive);\n+                        res = ReachedFixedPoint::No;\n+                        None\n                     }\n                     PartialResolvedImport::Resolved(_) => {\n                         self.record_resolved_import(&directive);\n-                        self.resolved_imports.push(directive)\n-                    }\n-                    PartialResolvedImport::Unresolved => {\n-                        self.unresolved_imports.push(directive);\n+                        self.resolved_imports.push(directive);\n+                        res = ReachedFixedPoint::No;\n+                        None\n                     }\n+                    PartialResolvedImport::Unresolved => Some(directive),\n                 }\n-            }\n-        }\n+            })\n+            .collect();\n+        self.unresolved_imports = imports;\n+        res\n     }\n \n     fn resolve_import(&self, module_id: LocalModuleId, import: &Import) -> PartialResolvedImport {\n@@ -856,6 +914,9 @@ impl DefCollector<'_> {\n                         Err(UnresolvedMacro { .. }) => (),\n                     }\n                 }\n+                MacroDirectiveKind::Attr { .. } => {\n+                    // not yet :)\n+                }\n             }\n \n             true\n@@ -948,7 +1009,7 @@ impl DefCollector<'_> {\n                         ));\n                     }\n                 },\n-                MacroDirectiveKind::Derive { .. } => {\n+                MacroDirectiveKind::Derive { .. } | MacroDirectiveKind::Attr { .. } => {\n                     // FIXME: we might want to diagnose this too\n                 }\n             }\n@@ -1056,6 +1117,14 @@ impl ModCollector<'_, '_> {\n                     continue;\n                 }\n             }\n+\n+            if let Err(()) = self.resolve_attributes(&attrs, item) {\n+                // Do not process the item. It has at least one non-builtin attribute, which *must*\n+                // resolve to a proc macro (or fail to resolve), so we'll never see this item during\n+                // normal name resolution.\n+                continue;\n+            }\n+\n             let module = self.def_collector.def_map.module_id(self.module_id);\n \n             let mut def = None;\n@@ -1362,6 +1431,62 @@ impl ModCollector<'_, '_> {\n         res\n     }\n \n+    /// Resolves attributes on an item.\n+    ///\n+    /// Returns `Err` when some attributes could not be resolved to builtins and have been\n+    /// registered as unresolved.\n+    fn resolve_attributes(&mut self, attrs: &Attrs, mod_item: ModItem) -> Result<(), ()> {\n+        fn is_builtin_attr(path: &ModPath) -> bool {\n+            if path.kind == PathKind::Plain {\n+                if let Some(tool_module) = path.segments().first() {\n+                    let tool_module = tool_module.to_string();\n+                    if builtin_attr::TOOL_MODULES.iter().any(|m| tool_module == *m) {\n+                        return true;\n+                    }\n+                }\n+\n+                if let Some(name) = path.as_ident() {\n+                    let name = name.to_string();\n+                    if builtin_attr::INERT_ATTRIBUTES\n+                        .iter()\n+                        .chain(builtin_attr::EXTRA_ATTRIBUTES)\n+                        .any(|attr| name == *attr)\n+                    {\n+                        return true;\n+                    }\n+                }\n+            }\n+\n+            false\n+        }\n+\n+        // We failed to resolve an attribute on this item earlier, and are falling back to treating\n+        // the item as-is.\n+        if self.def_collector.ignore_attrs_on.contains(&mod_item) {\n+            return Ok(());\n+        }\n+\n+        match attrs.iter().find(|attr| !is_builtin_attr(&attr.path)) {\n+            Some(non_builtin_attr) => {\n+                log::debug!(\"non-builtin attribute {}\", non_builtin_attr.path);\n+\n+                let ast_id = AstIdWithPath::new(\n+                    self.file_id,\n+                    mod_item.ast_id(self.item_tree),\n+                    non_builtin_attr.path.as_ref().clone(),\n+                );\n+                self.def_collector.unexpanded_macros.push(MacroDirective {\n+                    module_id: self.module_id,\n+                    depth: self.macro_depth + 1,\n+                    kind: MacroDirectiveKind::Attr { ast_id, attr: non_builtin_attr.id, mod_item },\n+                });\n+\n+                Err(())\n+            }\n+            None => Ok(()),\n+        }\n+    }\n+\n     fn collect_derives(&mut self, attrs: &Attrs, ast_id: FileAstId<ast::Item>) {\n         for derive in attrs.by_key(\"derive\").attrs() {\n             match derive.parse_derive() {\n@@ -1594,6 +1719,7 @@ mod tests {\n             proc_macros: Default::default(),\n             exports_proc_macros: false,\n             from_glob_import: Default::default(),\n+            ignore_attrs_on: FxHashSet::default(),\n         };\n         collector.seed_with_top_level();\n         collector.collect();"}]}