{"sha": "25d3e14da77f755ef858b976a25c7e856b62b42a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1ZDNlMTRkYTc3Zjc1NWVmODU4Yjk3NmEyNWM3ZTg1NmI2MmI0MmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-12T01:16:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-12T01:16:22Z"}, "message": "Auto merge of #87843 - kornelski:try_reserve, r=m-ou-se\n\nTryReserveErrorKind tests and inline\n\nA small follow-up to #87408", "tree": {"sha": "51f4f7edc7121c4f27da72f40a5d047bae926782", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51f4f7edc7121c4f27da72f40a5d047bae926782"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25d3e14da77f755ef858b976a25c7e856b62b42a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25d3e14da77f755ef858b976a25c7e856b62b42a", "html_url": "https://github.com/rust-lang/rust/commit/25d3e14da77f755ef858b976a25c7e856b62b42a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25d3e14da77f755ef858b976a25c7e856b62b42a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ccffcafd55e58f769d4b0efc0064bf65e76998e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/ccffcafd55e58f769d4b0efc0064bf65e76998e4", "html_url": "https://github.com/rust-lang/rust/commit/ccffcafd55e58f769d4b0efc0064bf65e76998e4"}, {"sha": "7dca8eb5653fb7ae5efbea2b80941997fead5ce3", "url": "https://api.github.com/repos/rust-lang/rust/commits/7dca8eb5653fb7ae5efbea2b80941997fead5ce3", "html_url": "https://github.com/rust-lang/rust/commit/7dca8eb5653fb7ae5efbea2b80941997fead5ce3"}], "stats": {"total": 583, "additions": 282, "deletions": 301}, "files": [{"sha": "0d442011921ba7bb5516058d21f6facbb76a31a6", "filename": "library/alloc/src/collections/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25d3e14da77f755ef858b976a25c7e856b62b42a/library%2Falloc%2Fsrc%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d3e14da77f755ef858b976a25c7e856b62b42a/library%2Falloc%2Fsrc%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fmod.rs?ref=25d3e14da77f755ef858b976a25c7e856b62b42a", "patch": "@@ -111,6 +111,7 @@ pub enum TryReserveErrorKind {\n     issue = \"48043\"\n )]\n impl From<TryReserveErrorKind> for TryReserveError {\n+    #[inline]\n     fn from(kind: TryReserveErrorKind) -> Self {\n         Self { kind }\n     }"}, {"sha": "8fca2662fc3047d7c50d0e3a627122b15d2df322", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/25d3e14da77f755ef858b976a25c7e856b62b42a/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d3e14da77f755ef858b976a25c7e856b62b42a/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=25d3e14da77f755ef858b976a25c7e856b62b42a", "patch": "@@ -1,4 +1,5 @@\n #![feature(allocator_api)]\n+#![feature(assert_matches)]\n #![feature(box_syntax)]\n #![feature(cow_is_borrowed)]\n #![feature(const_cow_is_borrowed)]"}, {"sha": "7be137131ff0100d4feac67e7203c6e8edd1a53d", "filename": "library/alloc/tests/string.rs", "status": "modified", "additions": 73, "deletions": 80, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/25d3e14da77f755ef858b976a25c7e856b62b42a/library%2Falloc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d3e14da77f755ef858b976a25c7e856b62b42a/library%2Falloc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fstring.rs?ref=25d3e14da77f755ef858b976a25c7e856b62b42a", "patch": "@@ -1,3 +1,4 @@\n+use std::assert_matches::assert_matches;\n use std::borrow::Cow;\n use std::cell::Cell;\n use std::collections::TryReserveErrorKind::*;\n@@ -713,35 +714,32 @@ fn test_try_reserve() {\n \n         if guards_against_isize {\n             // Check isize::MAX + 1 does count as overflow\n-            if let Err(CapacityOverflow) =\n-                empty_string.try_reserve(MAX_CAP + 1).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\")\n-            }\n+            assert_matches!(\n+                empty_string.try_reserve(MAX_CAP + 1).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n \n             // Check usize::MAX does count as overflow\n-            if let Err(CapacityOverflow) = empty_string.try_reserve(MAX_USIZE).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"usize::MAX should trigger an overflow!\")\n-            }\n+            assert_matches!(\n+                empty_string.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"usize::MAX should trigger an overflow!\"\n+            );\n         } else {\n             // Check isize::MAX + 1 is an OOM\n-            if let Err(AllocError { .. }) =\n-                empty_string.try_reserve(MAX_CAP + 1).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n+            assert_matches!(\n+                empty_string.try_reserve(MAX_CAP + 1).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n \n             // Check usize::MAX is an OOM\n-            if let Err(AllocError { .. }) =\n-                empty_string.try_reserve(MAX_USIZE).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"usize::MAX should trigger an OOM!\")\n-            }\n+            assert_matches!(\n+                empty_string.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"usize::MAX should trigger an OOM!\"\n+            );\n         }\n     }\n \n@@ -756,23 +754,24 @@ fn test_try_reserve() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n-            }\n+            assert_matches!(\n+                ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n         } else {\n-            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n+            assert_matches!(\n+                ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n         }\n         // Should always overflow in the add-to-len\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()) {\n-        } else {\n-            panic!(\"usize::MAX should trigger an overflow!\")\n-        }\n+        assert_matches!(\n+            ten_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n }\n \n@@ -801,33 +800,29 @@ fn test_try_reserve_exact() {\n         }\n \n         if guards_against_isize {\n-            if let Err(CapacityOverflow) =\n-                empty_string.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\")\n-            }\n-\n-            if let Err(CapacityOverflow) =\n-                empty_string.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"usize::MAX should trigger an overflow!\")\n-            }\n+            assert_matches!(\n+                empty_string.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n+\n+            assert_matches!(\n+                empty_string.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"usize::MAX should trigger an overflow!\"\n+            );\n         } else {\n-            if let Err(AllocError { .. }) =\n-                empty_string.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n-\n-            if let Err(AllocError { .. }) =\n-                empty_string.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"usize::MAX should trigger an OOM!\")\n-            }\n+            assert_matches!(\n+                empty_string.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n+\n+            assert_matches!(\n+                empty_string.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"usize::MAX should trigger an OOM!\"\n+            );\n         }\n     }\n \n@@ -845,25 +840,23 @@ fn test_try_reserve_exact() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) =\n-                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n-            }\n-        } else {\n-            if let Err(AllocError { .. }) =\n-                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n-        }\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n-        {\n+            assert_matches!(\n+                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n         } else {\n-            panic!(\"usize::MAX should trigger an overflow!\")\n+            assert_matches!(\n+                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n         }\n+        assert_matches!(\n+            ten_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n }\n "}, {"sha": "c2df50b48f55d9c2176d35890554875e77daa9a6", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 103, "deletions": 113, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/25d3e14da77f755ef858b976a25c7e856b62b42a/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d3e14da77f755ef858b976a25c7e856b62b42a/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=25d3e14da77f755ef858b976a25c7e856b62b42a", "patch": "@@ -1,3 +1,4 @@\n+use std::assert_matches::assert_matches;\n use std::borrow::Cow;\n use std::cell::Cell;\n use std::collections::TryReserveErrorKind::*;\n@@ -1488,34 +1489,32 @@ fn test_try_reserve() {\n \n         if guards_against_isize {\n             // Check isize::MAX + 1 does count as overflow\n-            if let Err(CapacityOverflow) =\n-                empty_bytes.try_reserve(MAX_CAP + 1).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\")\n-            }\n+            assert_matches!(\n+                empty_bytes.try_reserve(MAX_CAP + 1).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n \n             // Check usize::MAX does count as overflow\n-            if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"usize::MAX should trigger an overflow!\")\n-            }\n+            assert_matches!(\n+                empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"usize::MAX should trigger an overflow!\"\n+            );\n         } else {\n             // Check isize::MAX + 1 is an OOM\n-            if let Err(AllocError { .. }) =\n-                empty_bytes.try_reserve(MAX_CAP + 1).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n+            assert_matches!(\n+                empty_bytes.try_reserve(MAX_CAP + 1).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n \n             // Check usize::MAX is an OOM\n-            if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"usize::MAX should trigger an OOM!\")\n-            }\n+            assert_matches!(\n+                empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"usize::MAX should trigger an OOM!\"\n+            );\n         }\n     }\n \n@@ -1530,23 +1529,24 @@ fn test_try_reserve() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n-            }\n+            assert_matches!(\n+                ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n         } else {\n-            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n+            assert_matches!(\n+                ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n         }\n         // Should always overflow in the add-to-len\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()) {\n-        } else {\n-            panic!(\"usize::MAX should trigger an overflow!\")\n-        }\n+        assert_matches!(\n+            ten_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n \n     {\n@@ -1562,25 +1562,24 @@ fn test_try_reserve() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) =\n-                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n-            }\n+            assert_matches!(\n+                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n         } else {\n-            if let Err(AllocError { .. }) =\n-                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n+            assert_matches!(\n+                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n         }\n         // Should fail in the mul-by-size\n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_USIZE - 20).map_err(|e| e.kind()) {\n-        } else {\n-            panic!(\"usize::MAX should trigger an overflow!\");\n-        }\n+        assert_matches!(\n+            ten_u32s.try_reserve(MAX_USIZE - 20).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n }\n \n@@ -1609,33 +1608,29 @@ fn test_try_reserve_exact() {\n         }\n \n         if guards_against_isize {\n-            if let Err(CapacityOverflow) =\n-                empty_bytes.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\")\n-            }\n-\n-            if let Err(CapacityOverflow) =\n-                empty_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"usize::MAX should trigger an overflow!\")\n-            }\n+            assert_matches!(\n+                empty_bytes.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n+\n+            assert_matches!(\n+                empty_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"usize::MAX should trigger an overflow!\"\n+            );\n         } else {\n-            if let Err(AllocError { .. }) =\n-                empty_bytes.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n+            assert_matches!(\n+                empty_bytes.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n \n-            if let Err(AllocError { .. }) =\n-                empty_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"usize::MAX should trigger an OOM!\")\n-            }\n+            assert_matches!(\n+                empty_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"usize::MAX should trigger an OOM!\"\n+            );\n         }\n     }\n \n@@ -1653,25 +1648,23 @@ fn test_try_reserve_exact() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) =\n-                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n-            }\n-        } else {\n-            if let Err(AllocError { .. }) =\n-                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n-        }\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n-        {\n+            assert_matches!(\n+                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n         } else {\n-            panic!(\"usize::MAX should trigger an overflow!\")\n+            assert_matches!(\n+                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n         }\n+        assert_matches!(\n+            ten_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n \n     {\n@@ -1688,26 +1681,23 @@ fn test_try_reserve_exact() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) =\n-                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n-            }\n+            assert_matches!(\n+                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n         } else {\n-            if let Err(AllocError { .. }) =\n-                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n-        }\n-        if let Err(CapacityOverflow) =\n-            ten_u32s.try_reserve_exact(MAX_USIZE - 20).map_err(|e| e.kind())\n-        {\n-        } else {\n-            panic!(\"usize::MAX should trigger an overflow!\")\n-        }\n+            assert_matches!(\n+                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n+        }\n+        assert_matches!(\n+            ten_u32s.try_reserve_exact(MAX_USIZE - 20).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n }\n "}, {"sha": "ddfb4c00c2698fdc635219a2be033073264007a6", "filename": "library/alloc/tests/vec_deque.rs", "status": "modified", "additions": 92, "deletions": 99, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/25d3e14da77f755ef858b976a25c7e856b62b42a/library%2Falloc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d3e14da77f755ef858b976a25c7e856b62b42a/library%2Falloc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec_deque.rs?ref=25d3e14da77f755ef858b976a25c7e856b62b42a", "patch": "@@ -1,3 +1,4 @@\n+use std::assert_matches::assert_matches;\n use std::collections::TryReserveErrorKind::*;\n use std::collections::{vec_deque::Drain, VecDeque};\n use std::fmt::Debug;\n@@ -1181,28 +1182,28 @@ fn test_try_reserve() {\n \n         if guards_against_isize {\n             // Check isize::MAX + 1 does count as overflow\n-            if let Err(CapacityOverflow) =\n-                empty_bytes.try_reserve(MAX_CAP + 1).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\")\n-            }\n+            assert_matches!(\n+                empty_bytes.try_reserve(MAX_CAP + 1).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n \n             // Check usize::MAX does count as overflow\n-            if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"usize::MAX should trigger an overflow!\")\n-            }\n+            assert_matches!(\n+                empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"usize::MAX should trigger an overflow!\"\n+            );\n         } else {\n             // Check isize::MAX is an OOM\n             // VecDeque starts with capacity 7, always adds 1 to the capacity\n             // and also rounds the number to next power of 2 so this is the\n             // furthest we can go without triggering CapacityOverflow\n-            if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_CAP).map_err(|e| e.kind()) {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n+            assert_matches!(\n+                empty_bytes.try_reserve(MAX_CAP).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n         }\n     }\n \n@@ -1217,23 +1218,24 @@ fn test_try_reserve() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n-            }\n+            assert_matches!(\n+                ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n         } else {\n-            if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n+            assert_matches!(\n+                ten_bytes.try_reserve(MAX_CAP - 9).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n         }\n         // Should always overflow in the add-to-len\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()) {\n-        } else {\n-            panic!(\"usize::MAX should trigger an overflow!\")\n-        }\n+        assert_matches!(\n+            ten_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n \n     {\n@@ -1249,25 +1251,24 @@ fn test_try_reserve() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) =\n-                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n-            }\n+            assert_matches!(\n+                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n         } else {\n-            if let Err(AllocError { .. }) =\n-                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n+            assert_matches!(\n+                ten_u32s.try_reserve(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n         }\n         // Should fail in the mul-by-size\n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_USIZE - 20).map_err(|e| e.kind()) {\n-        } else {\n-            panic!(\"usize::MAX should trigger an overflow!\");\n-        }\n+        assert_matches!(\n+            ten_u32s.try_reserve(MAX_USIZE - 20).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n }\n \n@@ -1296,30 +1297,27 @@ fn test_try_reserve_exact() {\n         }\n \n         if guards_against_isize {\n-            if let Err(CapacityOverflow) =\n-                empty_bytes.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\")\n-            }\n-\n-            if let Err(CapacityOverflow) =\n-                empty_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"usize::MAX should trigger an overflow!\")\n-            }\n+            assert_matches!(\n+                empty_bytes.try_reserve_exact(MAX_CAP + 1).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n+\n+            assert_matches!(\n+                empty_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"usize::MAX should trigger an overflow!\"\n+            );\n         } else {\n             // Check isize::MAX is an OOM\n             // VecDeque starts with capacity 7, always adds 1 to the capacity\n             // and also rounds the number to next power of 2 so this is the\n             // furthest we can go without triggering CapacityOverflow\n-            if let Err(AllocError { .. }) =\n-                empty_bytes.try_reserve_exact(MAX_CAP).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n+            assert_matches!(\n+                empty_bytes.try_reserve_exact(MAX_CAP).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n         }\n     }\n \n@@ -1337,25 +1335,23 @@ fn test_try_reserve_exact() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) =\n-                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n-            }\n-        } else {\n-            if let Err(AllocError { .. }) =\n-                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n-        }\n-        if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind())\n-        {\n+            assert_matches!(\n+                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n         } else {\n-            panic!(\"usize::MAX should trigger an overflow!\")\n+            assert_matches!(\n+                ten_bytes.try_reserve_exact(MAX_CAP - 9).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n         }\n+        assert_matches!(\n+            ten_bytes.try_reserve_exact(MAX_USIZE).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n \n     {\n@@ -1372,26 +1368,23 @@ fn test_try_reserve_exact() {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) =\n-                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n-            }\n-        } else {\n-            if let Err(AllocError { .. }) =\n-                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind())\n-            {\n-            } else {\n-                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n-            }\n-        }\n-        if let Err(CapacityOverflow) =\n-            ten_u32s.try_reserve_exact(MAX_USIZE - 20).map_err(|e| e.kind())\n-        {\n+            assert_matches!(\n+                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n+                Err(CapacityOverflow),\n+                \"isize::MAX + 1 should trigger an overflow!\"\n+            );\n         } else {\n-            panic!(\"usize::MAX should trigger an overflow!\")\n+            assert_matches!(\n+                ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9).map_err(|e| e.kind()),\n+                Err(AllocError { .. }),\n+                \"isize::MAX + 1 should trigger an OOM!\"\n+            );\n         }\n+        assert_matches!(\n+            ten_u32s.try_reserve_exact(MAX_USIZE - 20).map_err(|e| e.kind()),\n+            Err(CapacityOverflow),\n+            \"usize::MAX should trigger an overflow!\"\n+        );\n     }\n }\n "}, {"sha": "d9b20aee2d27f1e1b6fd7951976766db317ac6bc", "filename": "library/std/src/collections/hash/map/tests.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/25d3e14da77f755ef858b976a25c7e856b62b42a/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25d3e14da77f755ef858b976a25c7e856b62b42a/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap%2Ftests.rs?ref=25d3e14da77f755ef858b976a25c7e856b62b42a", "patch": "@@ -1,6 +1,7 @@\n use super::Entry::{Occupied, Vacant};\n use super::HashMap;\n use super::RandomState;\n+use crate::assert_matches::assert_matches;\n use crate::cell::RefCell;\n use rand::{thread_rng, Rng};\n use realstd::collections::TryReserveErrorKind::*;\n@@ -821,15 +822,17 @@ fn test_try_reserve() {\n \n     const MAX_USIZE: usize = usize::MAX;\n \n-    if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()) {\n-    } else {\n-        panic!(\"usize::MAX should trigger an overflow!\");\n-    }\n-\n-    if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_USIZE / 8).map_err(|e| e.kind()) {\n-    } else {\n-        panic!(\"usize::MAX / 8 should trigger an OOM!\")\n-    }\n+    assert_matches!(\n+        empty_bytes.try_reserve(MAX_USIZE).map_err(|e| e.kind()),\n+        Err(CapacityOverflow),\n+        \"usize::MAX should trigger an overflow!\"\n+    );\n+\n+    assert_matches!(\n+        empty_bytes.try_reserve(MAX_USIZE / 8).map_err(|e| e.kind()),\n+        Err(AllocError { .. }),\n+        \"usize::MAX / 8 should trigger an OOM!\"\n+    );\n }\n \n #[test]"}]}