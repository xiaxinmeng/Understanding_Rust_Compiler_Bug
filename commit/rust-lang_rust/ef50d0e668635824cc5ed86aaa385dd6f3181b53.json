{"sha": "ef50d0e668635824cc5ed86aaa385dd6f3181b53", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmNTBkMGU2Njg2MzU4MjRjYzVlZDg2YWFhMzg1ZGQ2ZjMxODFiNTM=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-02-01T02:06:35Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-02-01T02:06:35Z"}, "message": "More work on derived tydescs. Can compile simple tests with generic objects.", "tree": {"sha": "e022aef8cd9614e87ee47f82836f0f8fd2042125", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e022aef8cd9614e87ee47f82836f0f8fd2042125"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef50d0e668635824cc5ed86aaa385dd6f3181b53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef50d0e668635824cc5ed86aaa385dd6f3181b53", "html_url": "https://github.com/rust-lang/rust/commit/ef50d0e668635824cc5ed86aaa385dd6f3181b53", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef50d0e668635824cc5ed86aaa385dd6f3181b53/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "784b2decf2ce4233a022cf221b1ec744b755c3ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/784b2decf2ce4233a022cf221b1ec744b755c3ed", "html_url": "https://github.com/rust-lang/rust/commit/784b2decf2ce4233a022cf221b1ec744b755c3ed"}], "stats": {"total": 86, "additions": 53, "deletions": 33}, "files": [{"sha": "7755ed93ca6d41fdb964379a424d3b6473375746", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 49, "deletions": 29, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/ef50d0e668635824cc5ed86aaa385dd6f3181b53/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef50d0e668635824cc5ed86aaa385dd6f3181b53/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=ef50d0e668635824cc5ed86aaa385dd6f3181b53", "patch": "@@ -997,7 +997,7 @@ fn get_tydesc(&@block_ctxt cx, @ty.t t) -> result {\n                               vec(p2i(bcx.fcx.ccx.crate_ptr),\n                                   sz.val,\n                                   align.val,\n-                                  C_int(n_params as int),\n+                                  C_int((1u + n_params) as int),\n                                   bcx.build.PtrToInt(tydescs, T_int())));\n \n         ret res(v.bcx, v.bcx.build.IntToPtr(v.val, T_ptr(T_tydesc())));\n@@ -2193,6 +2193,34 @@ fn lval_val(@block_ctxt cx, ValueRef val) -> lval_result {\n             llobj=none[ValueRef]);\n }\n \n+fn lval_generic_fn(@block_ctxt cx,\n+                   ty.ty_params_and_ty tpt,\n+                   ast.def_id fn_id,\n+                   &ast.ann ann)\n+    -> lval_result {\n+\n+    check (cx.fcx.ccx.fn_pairs.contains_key(fn_id));\n+    auto lv = lval_val(cx, cx.fcx.ccx.fn_pairs.get(fn_id));\n+    auto monoty = node_ann_type(cx.fcx.ccx, ann);\n+    auto tys = ty.resolve_ty_params(tpt, monoty);\n+\n+    if (_vec.len[@ty.t](tys) != 0u) {\n+        auto bcx = cx;\n+        let vec[ValueRef] tydescs = vec();\n+        for (@ty.t t in tys) {\n+            auto td = get_tydesc(bcx, t);\n+            bcx = td.bcx;\n+            append[ValueRef](tydescs, td.val);\n+        }\n+        auto gen = rec( item_type = tpt._1,\n+                        tydescs = tydescs );\n+        lv = rec(res = res(bcx, lv.res.val),\n+                 generic = some[generic_info](gen)\n+                 with lv);\n+    }\n+    ret lv;\n+}\n+\n fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n               &ast.ann ann) -> lval_result {\n     alt (dopt) {\n@@ -2215,39 +2243,33 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n                     ret lval_mem(cx, cx.fcx.llobjfields.get(did));\n                 }\n                 case (ast.def_fn(?did)) {\n-                    check (cx.fcx.ccx.fn_pairs.contains_key(did));\n-                    check (cx.fcx.ccx.item_ids.contains_key(did));\n-\n+                    check (cx.fcx.ccx.items.contains_key(did));\n                     auto fn_item = cx.fcx.ccx.items.get(did);\n-                    auto lv = lval_val(cx, cx.fcx.ccx.fn_pairs.get(did));\n-                    auto monoty = node_ann_type(cx.fcx.ccx, ann);\n-                    auto tys = ty.resolve_ty_params(fn_item, monoty);\n-\n-                    if (_vec.len[@ty.t](tys) != 0u) {\n-                        auto bcx = cx;\n-                        let vec[ValueRef] tydescs = vec();\n-                        for (@ty.t t in tys) {\n-                            auto td = get_tydesc(bcx, t);\n-                            bcx = td.bcx;\n-                            append[ValueRef](tydescs, td.val);\n-                        }\n-                        auto gen = rec( item_type = ty.item_ty(fn_item)._1,\n-                                        tydescs = tydescs );\n-                        lv = rec(res = res(bcx, lv.res.val),\n-                                 generic = some[generic_info](gen)\n-                                 with lv);\n-                    }\n-\n-                    ret lv;\n+                    ret lval_generic_fn(cx, ty.item_ty(fn_item), did, ann);\n                 }\n                 case (ast.def_obj(?did)) {\n-                    check (cx.fcx.ccx.fn_pairs.contains_key(did));\n-                    ret lval_val(cx, cx.fcx.ccx.fn_pairs.get(did));\n+                    check (cx.fcx.ccx.items.contains_key(did));\n+                    auto fn_item = cx.fcx.ccx.items.get(did);\n+                    ret lval_generic_fn(cx, ty.item_ty(fn_item), did, ann);\n                 }\n                 case (ast.def_variant(?tid, ?vid)) {\n                     check (cx.fcx.ccx.tags.contains_key(tid));\n                     if (cx.fcx.ccx.fn_pairs.contains_key(vid)) {\n-                        ret lval_val(cx, cx.fcx.ccx.fn_pairs.get(vid));\n+                        check (cx.fcx.ccx.items.contains_key(tid));\n+                        auto tag_item = cx.fcx.ccx.items.get(tid);\n+                        auto params = ty.item_ty(tag_item)._0;\n+                        auto fty = ty.plain_ty(ty.ty_nil);\n+                        alt (tag_item.node) {\n+                            case (ast.item_tag(_, ?variants, _, _)) {\n+                                for (ast.variant v in variants) {\n+                                    if (v.id == vid) {\n+                                        fty = node_ann_type(cx.fcx.ccx,\n+                                                            v.ann);\n+                                    }\n+                                }\n+                            }\n+                        }\n+                        ret lval_generic_fn(cx, tup(params, fty), vid, ann);\n                     } else {\n                         // Nullary variants are just scalar constants.\n                         check (cx.fcx.ccx.item_ids.contains_key(vid));\n@@ -3798,15 +3820,13 @@ fn collect_item(&@crate_ctxt cx, @ast.item i) -> @crate_ctxt {\n \n     alt (i.node) {\n         case (ast.item_fn(?name, ?f, _, ?fid, ?ann)) {\n-            // TODO: type-params\n             cx.items.insert(fid, i);\n             if (! cx.obj_methods.contains_key(fid)) {\n                 decl_fn_and_pair(cx, \"fn\", name, ann, fid);\n             }\n         }\n \n         case (ast.item_obj(?name, ?ob, _, ?oid, ?ann)) {\n-            // TODO: type-params\n             cx.items.insert(oid, i);\n             decl_fn_and_pair(cx, \"obj_ctor\", name, ann, oid);\n             for (@ast.method m in ob.methods) {"}, {"sha": "7a184bc6dfb2e14a038fb4c89b5ebd264cba8e24", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ef50d0e668635824cc5ed86aaa385dd6f3181b53/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef50d0e668635824cc5ed86aaa385dd6f3181b53/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=ef50d0e668635824cc5ed86aaa385dd6f3181b53", "patch": "@@ -571,7 +571,8 @@ fn is_fn_ty(@t fty) -> bool {\n \n // Given an item, returns the associated type as well as a list of the IDs of\n // its type parameters.\n-fn item_ty(@ast.item it) -> tup(vec[ast.def_id], @t) {\n+type ty_params_and_ty = tup(vec[ast.def_id], @t);\n+fn item_ty(@ast.item it) -> ty_params_and_ty {\n     let vec[ast.ty_param] ty_params;\n     auto result_ty;\n     alt (it.node) {\n@@ -1233,7 +1234,8 @@ fn type_err_to_str(&ty.type_err err) -> str {\n \n // Type parameter resolution, used in translation\n \n-fn resolve_ty_params(@ast.item item, @t monoty) -> vec[@t] {\n+fn resolve_ty_params(ty_params_and_ty ty_params_and_polyty,\n+                     @t monoty) -> vec[@t] {\n     obj resolve_ty_params_handler(@hashmap[ast.def_id,@t] bindings) {\n         fn resolve_local(ast.def_id id) -> @t { log \"resolve local\"; fail; }\n         fn record_local(ast.def_id id, @t ty) { log \"record local\"; fail; }\n@@ -1249,8 +1251,6 @@ fn resolve_ty_params(@ast.item item, @t monoty) -> vec[@t] {\n         }\n     }\n \n-    auto ty_params_and_polyty = item_ty(item);\n-\n     auto bindings = @new_def_hash[@t]();\n     auto handler = resolve_ty_params_handler(bindings);\n "}]}