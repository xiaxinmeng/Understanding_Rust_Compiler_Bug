{"sha": "bf352cd2511775a331d77dee261b64bd8359dacb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmMzUyY2QyNTExNzc1YTMzMWQ3N2RlZTI2MWI2NGJkODM1OWRhY2I=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-14T17:43:45Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-14T18:11:07Z"}, "message": "automatically wait for worker threads\n\ncloses #817", "tree": {"sha": "ba7d988ebef437d5a9d7beac048b5ac0dbd2fe9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba7d988ebef437d5a9d7beac048b5ac0dbd2fe9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf352cd2511775a331d77dee261b64bd8359dacb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf352cd2511775a331d77dee261b64bd8359dacb", "html_url": "https://github.com/rust-lang/rust/commit/bf352cd2511775a331d77dee261b64bd8359dacb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf352cd2511775a331d77dee261b64bd8359dacb/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10bf61b83b2600ed3cb7e7825f1cd0ee83e9b7e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/10bf61b83b2600ed3cb7e7825f1cd0ee83e9b7e7", "html_url": "https://github.com/rust-lang/rust/commit/10bf61b83b2600ed3cb7e7825f1cd0ee83e9b7e7"}], "stats": {"total": 285, "additions": 133, "deletions": 152}, "files": [{"sha": "266b88f197e0b0135853faf9a625ea14940913d0", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bf352cd2511775a331d77dee261b64bd8359dacb/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/bf352cd2511775a331d77dee261b64bd8359dacb/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=bf352cd2511775a331d77dee261b64bd8359dacb", "patch": "@@ -1651,7 +1651,6 @@ name = \"thread_worker\"\n version = \"0.1.0\"\n dependencies = [\n  \"crossbeam-channel 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"drop_bomb 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n "}, {"sha": "69d66113e97d5360adff719ec8334c69169109fc", "filename": "crates/ra_batch/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bf352cd2511775a331d77dee261b64bd8359dacb/crates%2Fra_batch%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf352cd2511775a331d77dee261b64bd8359dacb/crates%2Fra_batch%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_batch%2Fsrc%2Flib.rs?ref=bf352cd2511775a331d77dee261b64bd8359dacb", "patch": "@@ -121,7 +121,6 @@ impl BatchDatabase {\n             .collect();\n \n         let db = BatchDatabase::load(crate_graph, &mut vfs);\n-        let _ = vfs.shutdown();\n         Ok((db, local_roots))\n     }\n }"}, {"sha": "06443bb76111c3f9f932e3bd8785de8cca285fa9", "filename": "crates/ra_lsp_server/src/main_loop.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bf352cd2511775a331d77dee261b64bd8359dacb/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf352cd2511775a331d77dee261b64bd8359dacb/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop.rs?ref=bf352cd2511775a331d77dee261b64bd8359dacb", "patch": "@@ -54,19 +54,20 @@ pub fn main_loop(\n ) -> Result<()> {\n     let pool = ThreadPool::new(THREADPOOL_SIZE);\n     let (task_sender, task_receiver) = unbounded::<Task>();\n-    let (ws_worker, ws_watcher) = workspace_loader();\n \n-    ws_worker.send(ws_root.clone()).unwrap();\n     // FIXME: support dynamic workspace loading.\n-    let workspaces = match ws_worker.recv().unwrap() {\n-        Ok(ws) => vec![ws],\n-        Err(e) => {\n-            log::error!(\"loading workspace failed: {}\", e);\n-            Vec::new()\n+    let workspaces = {\n+        let ws_worker = workspace_loader();\n+        ws_worker.sender().send(ws_root.clone()).unwrap();\n+        match ws_worker.receiver().recv().unwrap() {\n+            Ok(ws) => vec![ws],\n+            Err(e) => {\n+                log::error!(\"loading workspace failed: {}\", e);\n+                Vec::new()\n+            }\n         }\n     };\n-    ws_worker.shutdown();\n-    ws_watcher.shutdown().map_err(|_| format_err!(\"ws watcher died\"))?;\n+\n     let mut state = ServerWorldState::new(ws_root.clone(), workspaces);\n \n     log::info!(\"server initialized, serving requests\");\n@@ -94,12 +95,9 @@ pub fn main_loop(\n     log::info!(\"...threadpool has finished\");\n \n     let vfs = Arc::try_unwrap(state.vfs).expect(\"all snapshots should be dead\");\n-    let vfs_res = vfs.into_inner().shutdown();\n+    drop(vfs);\n \n-    main_res?;\n-    vfs_res.map_err(|_| format_err!(\"fs watcher died\"))?;\n-\n-    Ok(())\n+    main_res\n }\n \n enum Event {"}, {"sha": "7d6440fadcc5b0f3f28415d7d3f25859b87cafd0", "filename": "crates/ra_lsp_server/src/project_model.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf352cd2511775a331d77dee261b64bd8359dacb/crates%2Fra_lsp_server%2Fsrc%2Fproject_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf352cd2511775a331d77dee261b64bd8359dacb/crates%2Fra_lsp_server%2Fsrc%2Fproject_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fproject_model.rs?ref=bf352cd2511775a331d77dee261b64bd8359dacb", "patch": "@@ -1,15 +1,15 @@\n use std::path::PathBuf;\n \n-use thread_worker::{WorkerHandle, Worker};\n+use thread_worker::Worker;\n \n use crate::Result;\n \n pub use ra_project_model::{\n     ProjectWorkspace, CargoWorkspace, Package, Target, TargetKind, Sysroot,\n };\n \n-pub fn workspace_loader() -> (Worker<PathBuf, Result<ProjectWorkspace>>, WorkerHandle) {\n-    thread_worker::spawn::<PathBuf, Result<ProjectWorkspace>, _>(\n+pub fn workspace_loader() -> Worker<PathBuf, Result<ProjectWorkspace>> {\n+    Worker::<PathBuf, Result<ProjectWorkspace>>::spawn(\n         \"workspace loader\",\n         1,\n         |input_receiver, output_sender| {"}, {"sha": "11f94b4abaa8ed950c60417dd4e8ef8a9a5cbac7", "filename": "crates/ra_lsp_server/tests/heavy_tests/support.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bf352cd2511775a331d77dee261b64bd8359dacb/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf352cd2511775a331d77dee261b64bd8359dacb/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fsupport.rs?ref=bf352cd2511775a331d77dee261b64bd8359dacb", "patch": "@@ -17,7 +17,7 @@ use lsp_types::{\n use serde::Serialize;\n use serde_json::{to_string_pretty, Value};\n use tempfile::TempDir;\n-use thread_worker::{WorkerHandle, Worker};\n+use thread_worker::Worker;\n use test_utils::{parse_fixture, find_mismatch};\n \n use ra_lsp_server::{\n@@ -45,13 +45,12 @@ pub struct Server {\n     messages: RefCell<Vec<RawMessage>>,\n     dir: TempDir,\n     worker: Option<Worker<RawMessage, RawMessage>>,\n-    watcher: Option<WorkerHandle>,\n }\n \n impl Server {\n     fn new(dir: TempDir, files: Vec<(PathBuf, String)>) -> Server {\n         let path = dir.path().to_path_buf();\n-        let (worker, watcher) = thread_worker::spawn::<RawMessage, RawMessage, _>(\n+        let worker = Worker::<RawMessage, RawMessage>::spawn(\n             \"test server\",\n             128,\n             move |mut msg_receiver, mut msg_sender| {\n@@ -63,7 +62,6 @@ impl Server {\n             dir,\n             messages: Default::default(),\n             worker: Some(worker),\n-            watcher: Some(watcher),\n         };\n \n         for (path, text) in files {\n@@ -117,7 +115,7 @@ impl Server {\n     }\n     fn send_request_(&self, r: RawRequest) -> Value {\n         let id = r.id;\n-        self.worker.as_ref().unwrap().send(RawMessage::Request(r)).unwrap();\n+        self.worker.as_ref().unwrap().sender().send(RawMessage::Request(r)).unwrap();\n         while let Some(msg) = self.recv() {\n             match msg {\n                 RawMessage::Request(req) => panic!(\"unexpected request: {:?}\", req),\n@@ -157,24 +155,19 @@ impl Server {\n         }\n     }\n     fn recv(&self) -> Option<RawMessage> {\n-        recv_timeout(&self.worker.as_ref().unwrap().out).map(|msg| {\n+        recv_timeout(&self.worker.as_ref().unwrap().receiver()).map(|msg| {\n             self.messages.borrow_mut().push(msg.clone());\n             msg\n         })\n     }\n     fn send_notification(&self, not: RawNotification) {\n-        self.worker.as_ref().unwrap().send(RawMessage::Notification(not)).unwrap();\n+        self.worker.as_ref().unwrap().sender().send(RawMessage::Notification(not)).unwrap();\n     }\n }\n \n impl Drop for Server {\n     fn drop(&mut self) {\n         self.send_request::<Shutdown>(());\n-        let receiver = self.worker.take().unwrap().shutdown();\n-        while let Some(msg) = recv_timeout(&receiver) {\n-            drop(msg);\n-        }\n-        self.watcher.take().unwrap().shutdown().unwrap();\n     }\n }\n "}, {"sha": "1b70cd8df38772d250f2bf898a1aa2fb116dac0d", "filename": "crates/ra_vfs/src/io.rs", "status": "modified", "additions": 50, "deletions": 56, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/bf352cd2511775a331d77dee261b64bd8359dacb/crates%2Fra_vfs%2Fsrc%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf352cd2511775a331d77dee261b64bd8359dacb/crates%2Fra_vfs%2Fsrc%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fio.rs?ref=bf352cd2511775a331d77dee261b64bd8359dacb", "patch": "@@ -1,13 +1,11 @@\n use std::{\n     fs,\n-    thread,\n     path::{Path, PathBuf},\n     sync::{mpsc, Arc},\n     time::Duration,\n };\n use crossbeam_channel::{Receiver, Sender, unbounded, RecvError, select};\n use relative_path::RelativePathBuf;\n-use thread_worker::WorkerHandle;\n use walkdir::WalkDir;\n use notify::{DebouncedEvent, RecommendedWatcher, RecursiveMode, Watcher as _Watcher};\n \n@@ -49,8 +47,7 @@ enum ChangeKind {\n const WATCHER_DELAY: Duration = Duration::from_millis(250);\n \n pub(crate) struct Worker {\n-    worker: thread_worker::Worker<Task, TaskResult>,\n-    worker_handle: WorkerHandle,\n+    thread_worker: thread_worker::Worker<Task, TaskResult>,\n }\n \n impl Worker {\n@@ -62,82 +59,79 @@ impl Worker {\n         //    * we want to read all files from a single thread, to guarantee that\n         //      we always get fresher versions and never go back in time.\n         //    * we want to tear down everything neatly during shutdown.\n-        let (worker, worker_handle) = thread_worker::spawn(\n+        let thread_worker = thread_worker::Worker::spawn(\n             \"vfs\",\n             128,\n             // This are the channels we use to communicate with outside world.\n             // If `input_receiver` is closed we need to tear ourselves down.\n             // `output_sender` should not be closed unless the parent died.\n             move |input_receiver, output_sender| {\n-                // These are `std` channels notify will send events to\n-                let (notify_sender, notify_receiver) = mpsc::channel();\n+                // Make sure that the destruction order is\n+                //\n+                // * notify_sender\n+                // * _thread\n+                // * watcher_sender\n+                //\n+                // this is required to avoid deadlocks.\n+\n                 // These are the corresponding crossbeam channels\n                 let (watcher_sender, watcher_receiver) = unbounded();\n+                let _thread;\n+                {\n+                    // These are `std` channels notify will send events to\n+                    let (notify_sender, notify_receiver) = mpsc::channel();\n \n-                let mut watcher = notify::watcher(notify_sender, WATCHER_DELAY)\n-                    .map_err(|e| log::error!(\"failed to spawn notify {}\", e))\n-                    .ok();\n-                // Start a silly thread to transform between two channels\n-                let thread = thread::spawn(move || {\n-                    notify_receiver\n-                        .into_iter()\n-                        .for_each(|event| convert_notify_event(event, &watcher_sender))\n-                });\n+                    let mut watcher = notify::watcher(notify_sender, WATCHER_DELAY)\n+                        .map_err(|e| log::error!(\"failed to spawn notify {}\", e))\n+                        .ok();\n+                    // Start a silly thread to transform between two channels\n+                    _thread = thread_worker::ScopedThread::spawn(\"notify-convertor\", move || {\n+                        notify_receiver\n+                            .into_iter()\n+                            .for_each(|event| convert_notify_event(event, &watcher_sender))\n+                    });\n \n-                // Process requests from the called or notifications from\n-                // watcher until the caller says stop.\n-                loop {\n-                    select! {\n-                        // Received request from the caller. If this channel is\n-                        // closed, we should shutdown everything.\n-                        recv(input_receiver) -> t => match t {\n-                            Err(RecvError) => {\n-                                drop(input_receiver);\n-                                break\n+                    // Process requests from the called or notifications from\n+                    // watcher until the caller says stop.\n+                    loop {\n+                        select! {\n+                            // Received request from the caller. If this channel is\n+                            // closed, we should shutdown everything.\n+                            recv(input_receiver) -> t => match t {\n+                                Err(RecvError) => {\n+                                    drop(input_receiver);\n+                                    break\n+                                },\n+                                Ok(Task::AddRoot { root, config }) => {\n+                                    watch_root(watcher.as_mut(), &output_sender, root, Arc::clone(&config));\n+                                }\n+                            },\n+                            // Watcher send us changes. If **this** channel is\n+                            // closed, the watcher has died, which indicates a bug\n+                            // -- escalate!\n+                            recv(watcher_receiver) -> event => match event {\n+                                Err(RecvError) => panic!(\"watcher is dead\"),\n+                                Ok((path, change)) => {\n+                                    handle_change(watcher.as_mut(), &output_sender, &*roots, path, change);\n+                                }\n                             },\n-                            Ok(Task::AddRoot { root, config }) => {\n-                                watch_root(watcher.as_mut(), &output_sender, root, Arc::clone(&config));\n-                            }\n-                        },\n-                        // Watcher send us changes. If **this** channel is\n-                        // closed, the watcher has died, which indicates a bug\n-                        // -- escalate!\n-                        recv(watcher_receiver) -> event => match event {\n-                            Err(RecvError) => panic!(\"watcher is dead\"),\n-                            Ok((path, change)) => {\n-                                handle_change(watcher.as_mut(), &output_sender, &*roots, path, change);\n-                            }\n-                        },\n+                        }\n                     }\n                 }\n-                // Stopped the watcher\n-                drop(watcher.take());\n                 // Drain pending events: we are not interested in them anyways!\n                 watcher_receiver.into_iter().for_each(|_| ());\n-\n-                let res = thread.join();\n-                match &res {\n-                    Ok(()) => log::info!(\"... Watcher terminated with ok\"),\n-                    Err(_) => log::error!(\"... Watcher terminated with err\"),\n-                }\n-                res.unwrap();\n             },\n         );\n \n-        Worker { worker, worker_handle }\n+        Worker { thread_worker }\n     }\n \n     pub(crate) fn sender(&self) -> &Sender<Task> {\n-        &self.worker.inp\n+        &self.thread_worker.sender()\n     }\n \n     pub(crate) fn receiver(&self) -> &Receiver<TaskResult> {\n-        &self.worker.out\n-    }\n-\n-    pub(crate) fn shutdown(self) -> thread::Result<()> {\n-        let _ = self.worker.shutdown();\n-        self.worker_handle.shutdown()\n+        &self.thread_worker.receiver()\n     }\n }\n "}, {"sha": "1fb255365c80cba8adc0ac08a456ea2c01c46a7a", "filename": "crates/ra_vfs/src/lib.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bf352cd2511775a331d77dee261b64bd8359dacb/crates%2Fra_vfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf352cd2511775a331d77dee261b64bd8359dacb/crates%2Fra_vfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Flib.rs?ref=bf352cd2511775a331d77dee261b64bd8359dacb", "patch": "@@ -22,7 +22,6 @@ use std::{\n     fmt, fs, mem,\n     path::{Path, PathBuf},\n     sync::Arc,\n-    thread,\n };\n \n use crossbeam_channel::Receiver;\n@@ -337,11 +336,6 @@ impl Vfs {\n         mem::replace(&mut self.pending_changes, Vec::new())\n     }\n \n-    /// Shutdown the VFS and terminate the background watching thread.\n-    pub fn shutdown(self) -> thread::Result<()> {\n-        self.worker.shutdown()\n-    }\n-\n     fn add_file(\n         &mut self,\n         root: VfsRoot,"}, {"sha": "c76e6ea26444c954e9fa717549261c0c0eb044b8", "filename": "crates/ra_vfs/tests/vfs.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bf352cd2511775a331d77dee261b64bd8359dacb/crates%2Fra_vfs%2Ftests%2Fvfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf352cd2511775a331d77dee261b64bd8359dacb/crates%2Fra_vfs%2Ftests%2Fvfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Ftests%2Fvfs.rs?ref=bf352cd2511775a331d77dee261b64bd8359dacb", "patch": "@@ -158,6 +158,5 @@ fn test_vfs_works() -> std::io::Result<()> {\n         Err(RecvTimeoutError::Timeout)\n     );\n \n-    vfs.shutdown().unwrap();\n     Ok(())\n }"}, {"sha": "a9857d59d1f89a659c37f8e32f9f1f0520dd4a34", "filename": "crates/thread_worker/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bf352cd2511775a331d77dee261b64bd8359dacb/crates%2Fthread_worker%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bf352cd2511775a331d77dee261b64bd8359dacb/crates%2Fthread_worker%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fthread_worker%2FCargo.toml?ref=bf352cd2511775a331d77dee261b64bd8359dacb", "patch": "@@ -5,7 +5,6 @@ version = \"0.1.0\"\n authors = [\"rust-analyzer developers\"]\n \n [dependencies]\n-drop_bomb = \"0.1.0\"\n crossbeam-channel = \"0.3.5\"\n log = \"0.4.3\"\n "}, {"sha": "d67e44e38000696a5ab491fef6d4752e18596880", "filename": "crates/thread_worker/src/lib.rs", "status": "modified", "additions": 63, "deletions": 57, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/bf352cd2511775a331d77dee261b64bd8359dacb/crates%2Fthread_worker%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf352cd2511775a331d77dee261b64bd8359dacb/crates%2Fthread_worker%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fthread_worker%2Fsrc%2Flib.rs?ref=bf352cd2511775a331d77dee261b64bd8359dacb", "patch": "@@ -2,74 +2,80 @@\n \n use std::thread;\n \n-use crossbeam_channel::{bounded, unbounded, Receiver, Sender, RecvError, SendError};\n-use drop_bomb::DropBomb;\n+use crossbeam_channel::{bounded, unbounded, Receiver, Sender};\n \n-pub struct Worker<I, O> {\n-    pub inp: Sender<I>,\n-    pub out: Receiver<O>,\n+/// Like `std::thread::JoinHandle<()>`, but joins thread in drop automatically.\n+pub struct ScopedThread {\n+    // Option for drop\n+    inner: Option<thread::JoinHandle<()>>,\n }\n \n-pub struct WorkerHandle {\n-    name: &'static str,\n-    thread: thread::JoinHandle<()>,\n-    bomb: DropBomb,\n-}\n+impl Drop for ScopedThread {\n+    fn drop(&mut self) {\n+        let inner = self.inner.take().unwrap();\n+        let name = inner.thread().name().unwrap().to_string();\n+        log::info!(\"waiting for {} to finish...\", name);\n+        let res = inner.join();\n+        log::info!(\".. {} terminated with {}\", name, if res.is_ok() { \"ok\" } else { \"err\" });\n \n-pub fn spawn<I, O, F>(name: &'static str, buf: usize, f: F) -> (Worker<I, O>, WorkerHandle)\n-where\n-    F: FnOnce(Receiver<I>, Sender<O>) + Send + 'static,\n-    I: Send + 'static,\n-    O: Send + 'static,\n-{\n-    let (worker, inp_r, out_s) = worker_chan(buf);\n-    let watcher = WorkerHandle::spawn(name, move || f(inp_r, out_s));\n-    (worker, watcher)\n-}\n-\n-impl<I, O> Worker<I, O> {\n-    /// Stops the worker. Returns the message receiver to fetch results which\n-    /// have become ready before the worker is stopped.\n-    pub fn shutdown(self) -> Receiver<O> {\n-        self.out\n+        // escalate panic, but avoid aborting the process\n+        match res {\n+            Err(e) => {\n+                if !thread::panicking() {\n+                    panic!(e)\n+                }\n+            }\n+            _ => (),\n+        }\n     }\n+}\n \n-    pub fn send(&self, item: I) -> Result<(), SendError<I>> {\n-        self.inp.send(item)\n-    }\n-    pub fn recv(&self) -> Result<O, RecvError> {\n-        self.out.recv()\n+impl ScopedThread {\n+    pub fn spawn(name: &'static str, f: impl FnOnce() + Send + 'static) -> ScopedThread {\n+        let inner = thread::Builder::new().name(name.into()).spawn(f).unwrap();\n+        ScopedThread { inner: Some(inner) }\n     }\n }\n \n-impl WorkerHandle {\n-    fn spawn(name: &'static str, f: impl FnOnce() + Send + 'static) -> WorkerHandle {\n-        let thread = thread::spawn(f);\n-        WorkerHandle {\n-            name,\n-            thread,\n-            bomb: DropBomb::new(format!(\"WorkerHandle {} was not shutdown\", name)),\n-        }\n-    }\n+/// A wrapper around event-processing thread with automatic shutdown semantics.\n+pub struct Worker<I, O> {\n+    // XXX: field order is significant here.\n+    //\n+    // In Rust, fields are dropped in the declaration order, and we rely on this\n+    // here. We must close input first, so that the  `thread` (who holds the\n+    // opposite side of the channel) noticed shutdown. Then, we must join the\n+    // thread, but we must keep out alive so that the thread does not panic.\n+    //\n+    // Note that a potential problem here is that we might drop some messages\n+    // from receiver on the floor. This is ok for rust-analyzer: we have only a\n+    // single client, so, if we are shutting down, nobody is interested in the\n+    // unfinished work anyway!\n+    sender: Sender<I>,\n+    _thread: ScopedThread,\n+    receiver: Receiver<O>,\n+}\n \n-    pub fn shutdown(mut self) -> thread::Result<()> {\n-        log::info!(\"waiting for {} to finish ...\", self.name);\n-        let name = self.name;\n-        self.bomb.defuse();\n-        let res = self.thread.join();\n-        match &res {\n-            Ok(()) => log::info!(\"... {} terminated with ok\", name),\n-            Err(_) => log::error!(\"... {} terminated with err\", name),\n-        }\n-        res\n+impl<I, O> Worker<I, O> {\n+    pub fn spawn<F>(name: &'static str, buf: usize, f: F) -> Worker<I, O>\n+    where\n+        F: FnOnce(Receiver<I>, Sender<O>) + Send + 'static,\n+        I: Send + 'static,\n+        O: Send + 'static,\n+    {\n+        // Set up worker channels in a deadlock-avoiding way. If one sets both input\n+        // and output buffers to a fixed size, a worker might get stuck.\n+        let (sender, input_receiver) = bounded::<I>(buf);\n+        let (output_sender, receiver) = unbounded::<O>();\n+        let _thread = ScopedThread::spawn(name, move || f(input_receiver, output_sender));\n+        Worker { sender, _thread, receiver }\n     }\n }\n \n-/// Sets up worker channels in a deadlock-avoiding way.\n-/// If one sets both input and output buffers to a fixed size,\n-/// a worker might get stuck.\n-fn worker_chan<I, O>(buf: usize) -> (Worker<I, O>, Receiver<I>, Sender<O>) {\n-    let (input_sender, input_receiver) = bounded::<I>(buf);\n-    let (output_sender, output_receiver) = unbounded::<O>();\n-    (Worker { inp: input_sender, out: output_receiver }, input_receiver, output_sender)\n+impl<I, O> Worker<I, O> {\n+    pub fn sender(&self) -> &Sender<I> {\n+        &self.sender\n+    }\n+    pub fn receiver(&self) -> &Receiver<O> {\n+        &self.receiver\n+    }\n }"}]}