{"sha": "4463b08652110e96700f65bb584004e67da497e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0NjNiMDg2NTIxMTBlOTY3MDBmNjViYjU4NDAwNGU2N2RhNDk3ZTY=", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2021-06-21T22:37:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-21T22:37:46Z"}, "message": "Rollup merge of #86037 - soerenmeier:cursor_remaining, r=yaahc\n\nAdd `io::Cursor::{remaining, remaining_slice, is_empty}`\n\nTracking issue: #86369\n\nI came across an inconvenience when answering the following [Stack Overflow](https://stackoverflow.com/questions/67831170) question.\nTo get the remaining slice you have to call `buff.fill_buf().unwrap()`. Which in my opinion doesn't really tell you what is returned (in the context of Cursor). To improve readability and convenience when using Cursor i propose adding the method `remaining`.\n\nThe next thing i found inconvenient (unnecessary long) was detecting if the cursor reached the end. There are a few ways this can be achieved right now:\n- `buff.fill_buf().unwrap().is_empty()`\n- `buff.position() >= buff.get_ref().len()`\n- `buff.bytes().next().is_none()`\n\nWhich all seem a bit unintuitive, hidden in trait documentations or just a bit long for such a simple task.\nTherefor i propose another method called `is_empty`, maybe with another name, since this one may leave room for interpretation on what really is empty (the underlying slice, the remaining slice or maybe the position).\n\nSince it seemed easier to create this PR instead of an RFC i did that, if an RFC is wanted, i can close this PR and write an RFC first.", "tree": {"sha": "a94bcb5879806134172952bb4a7f006b3d57878b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a94bcb5879806134172952bb4a7f006b3d57878b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4463b08652110e96700f65bb584004e67da497e6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg0RS7CRBK7hj4Ov3rIwAAXYUIAAHUgrS1Lv/DOjeF/coES3zD\nxZnq0ICfZ7FXmPZ8E4pBBGMVym3+ITpWgx0WE6hln1np0sef8hNeniWd3C6BYIOZ\n6bEAbaGOVP5K/wd1Pv91i2i4OdlVtt56BC0RhC3q/B6meeXCBr7K4+Lj+TDe4o3c\nEjeRAL2YOI6Z8KmzjwIm7FaAVcl86q2icTKy4DuT9e0Av0y9jmDBWklA5NtrWK+Q\nnXR8QPEVYrST7NV0LqqUW6x6BdYkJ6F6CsVY1c1Bkqd9A6Ib73G5Ka4l7Vn6Ua7p\n5MbOmKxvwI9xrznKOBTVVS48Wr3kTs0eykaGIFDU3xUig9qTrvJSufX2uyHUnxQ=\n=fgji\n-----END PGP SIGNATURE-----\n", "payload": "tree a94bcb5879806134172952bb4a7f006b3d57878b\nparent 7f1a4a287f4aa39500aa4c45f60ad805047ad725\nparent 664bde0770fcd898a6da97a117996de1366098dd\nauthor Yuki Okushi <jtitor@2k36.org> 1624315066 +0900\ncommitter GitHub <noreply@github.com> 1624315066 +0900\n\nRollup merge of #86037 - soerenmeier:cursor_remaining, r=yaahc\n\nAdd `io::Cursor::{remaining, remaining_slice, is_empty}`\n\nTracking issue: #86369\n\nI came across an inconvenience when answering the following [Stack Overflow](https://stackoverflow.com/questions/67831170) question.\nTo get the remaining slice you have to call `buff.fill_buf().unwrap()`. Which in my opinion doesn't really tell you what is returned (in the context of Cursor). To improve readability and convenience when using Cursor i propose adding the method `remaining`.\n\nThe next thing i found inconvenient (unnecessary long) was detecting if the cursor reached the end. There are a few ways this can be achieved right now:\n- `buff.fill_buf().unwrap().is_empty()`\n- `buff.position() >= buff.get_ref().len()`\n- `buff.bytes().next().is_none()`\n\nWhich all seem a bit unintuitive, hidden in trait documentations or just a bit long for such a simple task.\nTherefor i propose another method called `is_empty`, maybe with another name, since this one may leave room for interpretation on what really is empty (the underlying slice, the remaining slice or maybe the position).\n\nSince it seemed easier to create this PR instead of an RFC i did that, if an RFC is wanted, i can close this PR and write an RFC first.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4463b08652110e96700f65bb584004e67da497e6", "html_url": "https://github.com/rust-lang/rust/commit/4463b08652110e96700f65bb584004e67da497e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4463b08652110e96700f65bb584004e67da497e6/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f1a4a287f4aa39500aa4c45f60ad805047ad725", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f1a4a287f4aa39500aa4c45f60ad805047ad725", "html_url": "https://github.com/rust-lang/rust/commit/7f1a4a287f4aa39500aa4c45f60ad805047ad725"}, {"sha": "664bde0770fcd898a6da97a117996de1366098dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/664bde0770fcd898a6da97a117996de1366098dd", "html_url": "https://github.com/rust-lang/rust/commit/664bde0770fcd898a6da97a117996de1366098dd"}], "stats": {"total": 89, "additions": 85, "deletions": 4}, "files": [{"sha": "04f13cdeb88e353f629c282ddf8bc904bf3d684b", "filename": "library/std/src/io/cursor.rs", "status": "modified", "additions": 85, "deletions": 4, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/4463b08652110e96700f65bb584004e67da497e6/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4463b08652110e96700f65bb584004e67da497e6/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs?ref=4463b08652110e96700f65bb584004e67da497e6", "patch": "@@ -205,6 +205,88 @@ impl<T> Cursor<T> {\n     }\n }\n \n+impl<T> Cursor<T>\n+where\n+    T: AsRef<[u8]>,\n+{\n+    /// Returns the remaining length.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(cursor_remaining)]\n+    /// use std::io::Cursor;\n+    ///\n+    /// let mut buff = Cursor::new(vec![1, 2, 3, 4, 5]);\n+    ///\n+    /// assert_eq!(buff.remaining(), 5);\n+    ///\n+    /// buff.set_position(2);\n+    /// assert_eq!(buff.remaining(), 3);\n+    ///\n+    /// buff.set_position(4);\n+    /// assert_eq!(buff.remaining(), 1);\n+    ///\n+    /// buff.set_position(6);\n+    /// assert_eq!(buff.remaining(), 0);\n+    /// ```\n+    #[unstable(feature = \"cursor_remaining\", issue = \"86369\")]\n+    pub fn remaining(&self) -> u64 {\n+        (self.inner.as_ref().len() as u64).checked_sub(self.pos).unwrap_or(0)\n+    }\n+\n+    /// Returns the remaining slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(cursor_remaining)]\n+    /// use std::io::Cursor;\n+    ///\n+    /// let mut buff = Cursor::new(vec![1, 2, 3, 4, 5]);\n+    ///\n+    /// assert_eq!(buff.remaining_slice(), &[1, 2, 3, 4, 5]);\n+    ///\n+    /// buff.set_position(2);\n+    /// assert_eq!(buff.remaining_slice(), &[3, 4, 5]);\n+    ///\n+    /// buff.set_position(4);\n+    /// assert_eq!(buff.remaining_slice(), &[5]);\n+    ///\n+    /// buff.set_position(6);\n+    /// assert_eq!(buff.remaining_slice(), &[]);\n+    /// ```\n+    #[unstable(feature = \"cursor_remaining\", issue = \"86369\")]\n+    pub fn remaining_slice(&self) -> &[u8] {\n+        let len = self.pos.min(self.inner.as_ref().len() as u64);\n+        &self.inner.as_ref()[(len as usize)..]\n+    }\n+\n+    /// Returns `true` if the remaining slice is empty.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(cursor_remaining)]\n+    /// use std::io::Cursor;\n+    ///\n+    /// let mut buff = Cursor::new(vec![1, 2, 3, 4, 5]);\n+    ///\n+    /// buff.set_position(2);\n+    /// assert!(!buff.is_empty());\n+    ///\n+    /// buff.set_position(5);\n+    /// assert!(buff.is_empty());\n+    ///\n+    /// buff.set_position(10);\n+    /// assert!(buff.is_empty());\n+    /// ```\n+    #[unstable(feature = \"cursor_remaining\", issue = \"86369\")]\n+    pub fn is_empty(&self) -> bool {\n+        self.pos >= self.inner.as_ref().len() as u64\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Clone for Cursor<T>\n where\n@@ -268,7 +350,7 @@ where\n     T: AsRef<[u8]>,\n {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        let n = Read::read(&mut self.fill_buf()?, buf)?;\n+        let n = Read::read(&mut self.remaining_slice(), buf)?;\n         self.pos += n as u64;\n         Ok(n)\n     }\n@@ -291,7 +373,7 @@ where\n \n     fn read_exact(&mut self, buf: &mut [u8]) -> io::Result<()> {\n         let n = buf.len();\n-        Read::read_exact(&mut self.fill_buf()?, buf)?;\n+        Read::read_exact(&mut self.remaining_slice(), buf)?;\n         self.pos += n as u64;\n         Ok(())\n     }\n@@ -308,8 +390,7 @@ where\n     T: AsRef<[u8]>,\n {\n     fn fill_buf(&mut self) -> io::Result<&[u8]> {\n-        let amt = cmp::min(self.pos, self.inner.as_ref().len() as u64);\n-        Ok(&self.inner.as_ref()[(amt as usize)..])\n+        Ok(self.remaining_slice())\n     }\n     fn consume(&mut self, amt: usize) {\n         self.pos += amt as u64;"}]}