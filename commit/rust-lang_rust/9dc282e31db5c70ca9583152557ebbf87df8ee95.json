{"sha": "9dc282e31db5c70ca9583152557ebbf87df8ee95", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkYzI4MmUzMWRiNWM3MGNhOTU4MzE1MjU1N2ViYmY4N2RmOGVlOTU=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-03-14T15:41:41Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-03-18T13:06:39Z"}, "message": "improve needless_bool to catch odd construct in non_expressive_names", "tree": {"sha": "587f8161fc6ba0949664720b4138570e3fb467bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/587f8161fc6ba0949664720b4138570e3fb467bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9dc282e31db5c70ca9583152557ebbf87df8ee95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9dc282e31db5c70ca9583152557ebbf87df8ee95", "html_url": "https://github.com/rust-lang/rust/commit/9dc282e31db5c70ca9583152557ebbf87df8ee95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9dc282e31db5c70ca9583152557ebbf87df8ee95/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea1c2406cc2711ac19bc651b665ab081cfac987f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea1c2406cc2711ac19bc651b665ab081cfac987f", "html_url": "https://github.com/rust-lang/rust/commit/ea1c2406cc2711ac19bc651b665ab081cfac987f"}], "stats": {"total": 128, "additions": 82, "deletions": 46}, "files": [{"sha": "f6179f4f99324a9c5be5e977574a5bb2563ae2d0", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9dc282e31db5c70ca9583152557ebbf87df8ee95/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dc282e31db5c70ca9583152557ebbf87df8ee95/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=9dc282e31db5c70ca9583152557ebbf87df8ee95", "patch": "@@ -3,6 +3,7 @@\n #![feature(rustc_private, collections)]\n #![feature(iter_arith)]\n #![feature(custom_attribute)]\n+#![feature(slice_patterns)]\n #![allow(indexing_slicing, shadow_reuse, unknown_lints)]\n \n // this only exists to allow the \"dogfood\" integration test to work"}, {"sha": "58afc86b82c5f33858cb28ff7242aa64bd504a7e", "filename": "src/needless_bool.rs", "status": "modified", "additions": 54, "deletions": 40, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/9dc282e31db5c70ca9583152557ebbf87df8ee95/src%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dc282e31db5c70ca9583152557ebbf87df8ee95/src%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fneedless_bool.rs?ref=9dc282e31db5c70ca9583152557ebbf87df8ee95", "patch": "@@ -47,44 +47,39 @@ impl LintPass for NeedlessBool {\n \n impl LateLintPass for NeedlessBool {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+        use self::Expression::*;\n         if let ExprIf(ref pred, ref then_block, Some(ref else_expr)) = e.node {\n+            let reduce = |hint: &str, not| {\n+                let pred_snip = snippet(cx, pred.span, \"..\");\n+                let hint = if pred_snip == \"..\" {\n+                    hint.into()\n+                } else {\n+                    format!(\"`{}{}`\", not, pred_snip)\n+                };\n+                span_lint(cx,\n+                          NEEDLESS_BOOL,\n+                          e.span,\n+                          &format!(\"you can reduce this if-then-else expression to just {}\", hint));\n+            };\n             match (fetch_bool_block(then_block), fetch_bool_expr(else_expr)) {\n-                (Some(true), Some(true)) => {\n+                (RetBool(true), RetBool(true)) |\n+                (Bool(true), Bool(true)) => {\n                     span_lint(cx,\n                               NEEDLESS_BOOL,\n                               e.span,\n                               \"this if-then-else expression will always return true\");\n                 }\n-                (Some(false), Some(false)) => {\n+                (RetBool(false), RetBool(false)) |\n+                (Bool(false), Bool(false)) => {\n                     span_lint(cx,\n                               NEEDLESS_BOOL,\n                               e.span,\n                               \"this if-then-else expression will always return false\");\n                 }\n-                (Some(true), Some(false)) => {\n-                    let pred_snip = snippet(cx, pred.span, \"..\");\n-                    let hint = if pred_snip == \"..\" {\n-                        \"its predicate\".into()\n-                    } else {\n-                        format!(\"`{}`\", pred_snip)\n-                    };\n-                    span_lint(cx,\n-                              NEEDLESS_BOOL,\n-                              e.span,\n-                              &format!(\"you can reduce this if-then-else expression to just {}\", hint));\n-                }\n-                (Some(false), Some(true)) => {\n-                    let pred_snip = snippet(cx, pred.span, \"..\");\n-                    let hint = if pred_snip == \"..\" {\n-                        \"`!` and its predicate\".into()\n-                    } else {\n-                        format!(\"`!{}`\", pred_snip)\n-                    };\n-                    span_lint(cx,\n-                              NEEDLESS_BOOL,\n-                              e.span,\n-                              &format!(\"you can reduce this if-then-else expression to just {}\", hint));\n-                }\n+                (RetBool(true), RetBool(false)) => reduce(\"its predicate\", \"return \"),\n+                (Bool(true), Bool(false)) => reduce(\"its predicate\", \"\"),\n+                (RetBool(false), RetBool(true)) => reduce(\"`!` and its predicate\", \"return !\"),\n+                (Bool(false), Bool(true)) => reduce(\"`!` and its predicate\", \"!\"),\n                 _ => (),\n             }\n         }\n@@ -102,9 +97,10 @@ impl LintPass for BoolComparison {\n \n impl LateLintPass for BoolComparison {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+        use self::Expression::*;\n         if let ExprBinary(Spanned{ node: BiEq, .. }, ref left_side, ref right_side) = e.node {\n             match (fetch_bool_expr(left_side), fetch_bool_expr(right_side)) {\n-                (Some(true), None) => {\n+                (Bool(true), Other) => {\n                     let hint = snippet(cx, right_side.span, \"..\").into_owned();\n                     span_lint_and_then(cx,\n                                        BOOL_COMPARISON,\n@@ -114,7 +110,7 @@ impl LateLintPass for BoolComparison {\n                                            db.span_suggestion(e.span, \"try simplifying it as shown:\", hint);\n                                        });\n                 }\n-                (None, Some(true)) => {\n+                (Other, Bool(true)) => {\n                     let hint = snippet(cx, left_side.span, \"..\").into_owned();\n                     span_lint_and_then(cx,\n                                        BOOL_COMPARISON,\n@@ -124,7 +120,7 @@ impl LateLintPass for BoolComparison {\n                                            db.span_suggestion(e.span, \"try simplifying it as shown:\", hint);\n                                        });\n                 }\n-                (Some(false), None) => {\n+                (Bool(false), Other) => {\n                     let hint = format!(\"!{}\", snippet(cx, right_side.span, \"..\"));\n                     span_lint_and_then(cx,\n                                        BOOL_COMPARISON,\n@@ -134,7 +130,7 @@ impl LateLintPass for BoolComparison {\n                                            db.span_suggestion(e.span, \"try simplifying it as shown:\", hint);\n                                        });\n                 }\n-                (None, Some(false)) => {\n+                (Other, Bool(false)) => {\n                     let hint = format!(\"!{}\", snippet(cx, left_side.span, \"..\"));\n                     span_lint_and_then(cx,\n                                        BOOL_COMPARISON,\n@@ -150,24 +146,42 @@ impl LateLintPass for BoolComparison {\n     }\n }\n \n-fn fetch_bool_block(block: &Block) -> Option<bool> {\n-    if block.stmts.is_empty() {\n-        block.expr.as_ref().and_then(|e| fetch_bool_expr(e))\n-    } else {\n-        None\n+enum Expression {\n+    Bool(bool),\n+    RetBool(bool),\n+    Other,\n+}\n+\n+fn fetch_bool_block(block: &Block) -> Expression {\n+    match (&*block.stmts, block.expr.as_ref()) {\n+        ([], Some(e)) => fetch_bool_expr(&**e),\n+        ([ref e], None) => if let StmtSemi(ref e, _) = e.node {\n+            if let ExprRet(_) = e.node {\n+                fetch_bool_expr(&**e)\n+            } else {\n+                Expression::Other\n+            }\n+        } else {\n+            Expression::Other\n+        },\n+        _ => Expression::Other,\n     }\n }\n \n-fn fetch_bool_expr(expr: &Expr) -> Option<bool> {\n+fn fetch_bool_expr(expr: &Expr) -> Expression {\n     match expr.node {\n         ExprBlock(ref block) => fetch_bool_block(block),\n         ExprLit(ref lit_ptr) => {\n             if let LitKind::Bool(value) = lit_ptr.node {\n-                Some(value)\n+                Expression::Bool(value)\n             } else {\n-                None\n+                Expression::Other\n             }\n-        }\n-        _ => None,\n+        },\n+        ExprRet(Some(ref expr)) => match fetch_bool_expr(expr) {\n+            Expression::Bool(value) => Expression::RetBool(value),\n+            _ => Expression::Other,\n+        },\n+        _ => Expression::Other,\n     }\n }"}, {"sha": "b7d2ac80a10f7094636ce5945c34a04d47329d84", "filename": "src/non_expressive_names.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9dc282e31db5c70ca9583152557ebbf87df8ee95/src%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dc282e31db5c70ca9583152557ebbf87df8ee95/src%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnon_expressive_names.rs?ref=9dc282e31db5c70ca9583152557ebbf87df8ee95", "patch": "@@ -262,12 +262,7 @@ fn levenstein_not_1(a_name: &str, b_name: &str) -> bool {\n         }\n         if let Some(b2) = b_chars.next() {\n             // check if there's just one character inserted\n-            if a == b2 && a_chars.eq(b_chars) {\n-                return false;\n-            } else {\n-                // two charaters don't match\n-                return true;\n-            }\n+            return !(a == b2 && a_chars.eq(b_chars));\n         } else {\n             // tuple\n             // ntuple"}, {"sha": "eff2bdc9b285c4cc54e3b831cd2bf107d41a4d40", "filename": "tests/compile-fail/needless_bool.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9dc282e31db5c70ca9583152557ebbf87df8ee95/tests%2Fcompile-fail%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9dc282e31db5c70ca9583152557ebbf87df8ee95/tests%2Fcompile-fail%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fneedless_bool.rs?ref=9dc282e31db5c70ca9583152557ebbf87df8ee95", "patch": "@@ -10,4 +10,30 @@ fn main() {\n     if x { true } else { false }; //~ERROR you can reduce this if-then-else expression to just `x`\n     if x { false } else { true }; //~ERROR you can reduce this if-then-else expression to just `!x`\n     if x { x } else { false }; // would also be questionable, but we don't catch this yet\n+    bool_ret(x);\n+    bool_ret2(x);\n+    bool_ret3(x);\n+    bool_ret4(x);\n+}\n+\n+#[deny(needless_bool)]\n+#[allow(if_same_then_else)]\n+fn bool_ret(x: bool) -> bool {\n+    if x { return true } else { return true }; //~ERROR this if-then-else expression will always return true\n+}\n+\n+#[deny(needless_bool)]\n+#[allow(if_same_then_else)]\n+fn bool_ret2(x: bool) -> bool {\n+    if x { return false } else { return false }; //~ERROR this if-then-else expression will always return false\n+}\n+\n+#[deny(needless_bool)]\n+fn bool_ret3(x: bool) -> bool {\n+    if x { return true } else { return false }; //~ERROR you can reduce this if-then-else expression to just `return x`\n+}\n+\n+#[deny(needless_bool)]\n+fn bool_ret4(x: bool) -> bool {\n+    if x { return false } else { return true }; //~ERROR you can reduce this if-then-else expression to just `return !x`\n }"}]}