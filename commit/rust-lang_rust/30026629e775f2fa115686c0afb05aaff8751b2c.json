{"sha": "30026629e775f2fa115686c0afb05aaff8751b2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwMDI2NjI5ZTc3NWYyZmExMTU2ODZjMGFmYjA1YWFmZjg3NTFiMmM=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-10-14T04:23:40Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-10-14T07:20:56Z"}, "message": "Rollup merge of #29024 - mseri:patch-1, r=nrc\n\nr? @nrc", "tree": {"sha": "2eac51f14f1ad50b3010f34f511e4eb1243f16e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2eac51f14f1ad50b3010f34f511e4eb1243f16e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30026629e775f2fa115686c0afb05aaff8751b2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30026629e775f2fa115686c0afb05aaff8751b2c", "html_url": "https://github.com/rust-lang/rust/commit/30026629e775f2fa115686c0afb05aaff8751b2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30026629e775f2fa115686c0afb05aaff8751b2c/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3636c8bb3ebb5c65a0c3a0b53bd47a2f1760b4f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/3636c8bb3ebb5c65a0c3a0b53bd47a2f1760b4f4", "html_url": "https://github.com/rust-lang/rust/commit/3636c8bb3ebb5c65a0c3a0b53bd47a2f1760b4f4"}, {"sha": "1454b426f04f78b9c6a3de0ee7b1d47e355abdb0", "url": "https://api.github.com/repos/rust-lang/rust/commits/1454b426f04f78b9c6a3de0ee7b1d47e355abdb0", "html_url": "https://github.com/rust-lang/rust/commit/1454b426f04f78b9c6a3de0ee7b1d47e355abdb0"}], "stats": {"total": 380, "additions": 220, "deletions": 160}, "files": [{"sha": "41571366af5d41cf82985e20c10034c58cf6d2c8", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 220, "deletions": 160, "changes": 380, "blob_url": "https://github.com/rust-lang/rust/blob/30026629e775f2fa115686c0afb05aaff8751b2c/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30026629e775f2fa115686c0afb05aaff8751b2c/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=30026629e775f2fa115686c0afb05aaff8751b2c", "patch": "@@ -75,7 +75,7 @@ pub struct FormatSpec<'a> {\n     /// The descriptor string representing the name of the format desired for\n     /// this argument, this can be empty or any number of characters, although\n     /// it is required to be one word.\n-    pub ty: &'a str\n+    pub ty: &'a str,\n }\n \n /// Enum describing where an argument for a format can be located.\n@@ -202,7 +202,12 @@ impl<'a> Parser<'a> {\n     /// returned, otherwise the character is consumed and true is returned.\n     fn consume(&mut self, c: char) -> bool {\n         if let Some(&(_, maybe)) = self.cur.peek() {\n-            if c == maybe { self.cur.next(); true } else { false }\n+            if c == maybe {\n+                self.cur.next();\n+                true\n+            } else {\n+                false\n+            }\n         } else {\n             false\n         }\n@@ -227,7 +232,11 @@ impl<'a> Parser<'a> {\n     /// character\n     fn ws(&mut self) {\n         while let Some(&(_, c)) = self.cur.peek() {\n-            if c.is_whitespace() { self.cur.next(); } else { break }\n+            if c.is_whitespace() {\n+                self.cur.next();\n+            } else {\n+                break\n+            }\n         }\n     }\n \n@@ -237,8 +246,12 @@ impl<'a> Parser<'a> {\n         // we may not consume the character, peek the iterator\n         while let Some(&(pos, c)) = self.cur.peek() {\n             match c {\n-                '{' | '}' => { return &self.input[start..pos]; }\n-                _ => { self.cur.next(); }\n+                '{' | '}' => {\n+                    return &self.input[start..pos];\n+                }\n+                _ => {\n+                    self.cur.next();\n+                }\n             }\n         }\n         &self.input[start..self.input.len()]\n@@ -263,7 +276,7 @@ impl<'a> Parser<'a> {\n                 Some(&(_, c)) if c.is_alphabetic() => {\n                     ArgumentNamed(self.word())\n                 }\n-                _ => ArgumentNext\n+                _ => ArgumentNext,\n             }\n         }\n     }\n@@ -279,7 +292,9 @@ impl<'a> Parser<'a> {\n             width: CountImplied,\n             ty: &self.input[..0],\n         };\n-        if !self.consume(':') { return spec }\n+        if !self.consume(':') {\n+            return spec\n+        }\n \n         // fill character\n         if let Some(&(_, c)) = self.cur.peek() {\n@@ -347,7 +362,11 @@ impl<'a> Parser<'a> {\n     /// width.\n     fn count(&mut self) -> Count<'a> {\n         if let Some(i) = self.integer() {\n-            if self.consume('$') { CountIsParam(i) } else { CountIs(i) }\n+            if self.consume('$') {\n+                CountIsParam(i)\n+            } else {\n+                CountIs(i)\n+            }\n         } else {\n             let tmp = self.cur.clone();\n             let word = self.word();\n@@ -370,8 +389,13 @@ impl<'a> Parser<'a> {\n     /// characters.\n     fn word(&mut self) -> &'a str {\n         let start = match self.cur.peek() {\n-            Some(&(pos, c)) if c.is_xid_start() => { self.cur.next(); pos }\n-            _ => { return &self.input[..0]; }\n+            Some(&(pos, c)) if c.is_xid_start() => {\n+                self.cur.next();\n+                pos\n+            }\n+            _ => {\n+                return &self.input[..0];\n+            }\n         };\n         while let Some(&(pos, c)) = self.cur.peek() {\n             if c.is_xid_continue() {\n@@ -397,7 +421,11 @@ impl<'a> Parser<'a> {\n                 break\n             }\n         }\n-        if found { Some(cur) } else { None }\n+        if found {\n+            Some(cur)\n+        } else {\n+            None\n+        }\n     }\n }\n \n@@ -437,178 +465,210 @@ mod tests {\n         same(\"\\\\}}\", &[String(\"\\\\\"), String(\"}\")]);\n     }\n \n-    #[test] fn invalid01() { musterr(\"{\") }\n-    #[test] fn invalid02() { musterr(\"}\") }\n-    #[test] fn invalid04() { musterr(\"{3a}\") }\n-    #[test] fn invalid05() { musterr(\"{:|}\") }\n-    #[test] fn invalid06() { musterr(\"{:>>>}\") }\n+    #[test]\n+    fn invalid01() {\n+        musterr(\"{\")\n+    }\n+    #[test]\n+    fn invalid02() {\n+        musterr(\"}\")\n+    }\n+    #[test]\n+    fn invalid04() {\n+        musterr(\"{3a}\")\n+    }\n+    #[test]\n+    fn invalid05() {\n+        musterr(\"{:|}\")\n+    }\n+    #[test]\n+    fn invalid06() {\n+        musterr(\"{:>>>}\")\n+    }\n \n     #[test]\n     fn format_nothing() {\n-        same(\"{}\", &[NextArgument(Argument {\n-            position: ArgumentNext,\n-            format: fmtdflt(),\n-        })]);\n+        same(\"{}\",\n+             &[NextArgument(Argument {\n+                   position: ArgumentNext,\n+                   format: fmtdflt(),\n+               })]);\n     }\n     #[test]\n     fn format_position() {\n-        same(\"{3}\", &[NextArgument(Argument {\n-            position: ArgumentIs(3),\n-            format: fmtdflt(),\n-        })]);\n+        same(\"{3}\",\n+             &[NextArgument(Argument {\n+                   position: ArgumentIs(3),\n+                   format: fmtdflt(),\n+               })]);\n     }\n     #[test]\n     fn format_position_nothing_else() {\n-        same(\"{3:}\", &[NextArgument(Argument {\n-            position: ArgumentIs(3),\n-            format: fmtdflt(),\n-        })]);\n+        same(\"{3:}\",\n+             &[NextArgument(Argument {\n+                   position: ArgumentIs(3),\n+                   format: fmtdflt(),\n+               })]);\n     }\n     #[test]\n     fn format_type() {\n-        same(\"{3:a}\", &[NextArgument(Argument {\n-            position: ArgumentIs(3),\n-            format: FormatSpec {\n-                fill: None,\n-                align: AlignUnknown,\n-                flags: 0,\n-                precision: CountImplied,\n-                width: CountImplied,\n-                ty: \"a\",\n-            },\n-        })]);\n+        same(\"{3:a}\",\n+             &[NextArgument(Argument {\n+                   position: ArgumentIs(3),\n+                   format: FormatSpec {\n+                       fill: None,\n+                       align: AlignUnknown,\n+                       flags: 0,\n+                       precision: CountImplied,\n+                       width: CountImplied,\n+                       ty: \"a\",\n+                   },\n+               })]);\n     }\n     #[test]\n     fn format_align_fill() {\n-        same(\"{3:>}\", &[NextArgument(Argument {\n-            position: ArgumentIs(3),\n-            format: FormatSpec {\n-                fill: None,\n-                align: AlignRight,\n-                flags: 0,\n-                precision: CountImplied,\n-                width: CountImplied,\n-                ty: \"\",\n-            },\n-        })]);\n-        same(\"{3:0<}\", &[NextArgument(Argument {\n-            position: ArgumentIs(3),\n-            format: FormatSpec {\n-                fill: Some('0'),\n-                align: AlignLeft,\n-                flags: 0,\n-                precision: CountImplied,\n-                width: CountImplied,\n-                ty: \"\",\n-            },\n-        })]);\n-        same(\"{3:*<abcd}\", &[NextArgument(Argument {\n-            position: ArgumentIs(3),\n-            format: FormatSpec {\n-                fill: Some('*'),\n-                align: AlignLeft,\n-                flags: 0,\n-                precision: CountImplied,\n-                width: CountImplied,\n-                ty: \"abcd\",\n-            },\n-        })]);\n+        same(\"{3:>}\",\n+             &[NextArgument(Argument {\n+                   position: ArgumentIs(3),\n+                   format: FormatSpec {\n+                       fill: None,\n+                       align: AlignRight,\n+                       flags: 0,\n+                       precision: CountImplied,\n+                       width: CountImplied,\n+                       ty: \"\",\n+                   },\n+               })]);\n+        same(\"{3:0<}\",\n+             &[NextArgument(Argument {\n+                   position: ArgumentIs(3),\n+                   format: FormatSpec {\n+                       fill: Some('0'),\n+                       align: AlignLeft,\n+                       flags: 0,\n+                       precision: CountImplied,\n+                       width: CountImplied,\n+                       ty: \"\",\n+                   },\n+               })]);\n+        same(\"{3:*<abcd}\",\n+             &[NextArgument(Argument {\n+                   position: ArgumentIs(3),\n+                   format: FormatSpec {\n+                       fill: Some('*'),\n+                       align: AlignLeft,\n+                       flags: 0,\n+                       precision: CountImplied,\n+                       width: CountImplied,\n+                       ty: \"abcd\",\n+                   },\n+               })]);\n     }\n     #[test]\n     fn format_counts() {\n-        same(\"{:10s}\", &[NextArgument(Argument {\n-            position: ArgumentNext,\n-            format: FormatSpec {\n-                fill: None,\n-                align: AlignUnknown,\n-                flags: 0,\n-                precision: CountImplied,\n-                width: CountIs(10),\n-                ty: \"s\",\n-            },\n-        })]);\n-        same(\"{:10$.10s}\", &[NextArgument(Argument {\n-            position: ArgumentNext,\n-            format: FormatSpec {\n-                fill: None,\n-                align: AlignUnknown,\n-                flags: 0,\n-                precision: CountIs(10),\n-                width: CountIsParam(10),\n-                ty: \"s\",\n-            },\n-        })]);\n-        same(\"{:.*s}\", &[NextArgument(Argument {\n-            position: ArgumentNext,\n-            format: FormatSpec {\n-                fill: None,\n-                align: AlignUnknown,\n-                flags: 0,\n-                precision: CountIsNextParam,\n-                width: CountImplied,\n-                ty: \"s\",\n-            },\n-        })]);\n-        same(\"{:.10$s}\", &[NextArgument(Argument {\n-            position: ArgumentNext,\n-            format: FormatSpec {\n-                fill: None,\n-                align: AlignUnknown,\n-                flags: 0,\n-                precision: CountIsParam(10),\n-                width: CountImplied,\n-                ty: \"s\",\n-            },\n-        })]);\n-        same(\"{:a$.b$s}\", &[NextArgument(Argument {\n-            position: ArgumentNext,\n-            format: FormatSpec {\n-                fill: None,\n-                align: AlignUnknown,\n-                flags: 0,\n-                precision: CountIsName(\"b\"),\n-                width: CountIsName(\"a\"),\n-                ty: \"s\",\n-            },\n-        })]);\n+        same(\"{:10s}\",\n+             &[NextArgument(Argument {\n+                   position: ArgumentNext,\n+                   format: FormatSpec {\n+                       fill: None,\n+                       align: AlignUnknown,\n+                       flags: 0,\n+                       precision: CountImplied,\n+                       width: CountIs(10),\n+                       ty: \"s\",\n+                   },\n+               })]);\n+        same(\"{:10$.10s}\",\n+             &[NextArgument(Argument {\n+                   position: ArgumentNext,\n+                   format: FormatSpec {\n+                       fill: None,\n+                       align: AlignUnknown,\n+                       flags: 0,\n+                       precision: CountIs(10),\n+                       width: CountIsParam(10),\n+                       ty: \"s\",\n+                   },\n+               })]);\n+        same(\"{:.*s}\",\n+             &[NextArgument(Argument {\n+                   position: ArgumentNext,\n+                   format: FormatSpec {\n+                       fill: None,\n+                       align: AlignUnknown,\n+                       flags: 0,\n+                       precision: CountIsNextParam,\n+                       width: CountImplied,\n+                       ty: \"s\",\n+                   },\n+               })]);\n+        same(\"{:.10$s}\",\n+             &[NextArgument(Argument {\n+                   position: ArgumentNext,\n+                   format: FormatSpec {\n+                       fill: None,\n+                       align: AlignUnknown,\n+                       flags: 0,\n+                       precision: CountIsParam(10),\n+                       width: CountImplied,\n+                       ty: \"s\",\n+                   },\n+               })]);\n+        same(\"{:a$.b$s}\",\n+             &[NextArgument(Argument {\n+                   position: ArgumentNext,\n+                   format: FormatSpec {\n+                       fill: None,\n+                       align: AlignUnknown,\n+                       flags: 0,\n+                       precision: CountIsName(\"b\"),\n+                       width: CountIsName(\"a\"),\n+                       ty: \"s\",\n+                   },\n+               })]);\n     }\n     #[test]\n     fn format_flags() {\n-        same(\"{:-}\", &[NextArgument(Argument {\n-            position: ArgumentNext,\n-            format: FormatSpec {\n-                fill: None,\n-                align: AlignUnknown,\n-                flags: (1 << FlagSignMinus as u32),\n-                precision: CountImplied,\n-                width: CountImplied,\n-                ty: \"\",\n-            },\n-        })]);\n-        same(\"{:+#}\", &[NextArgument(Argument {\n-            position: ArgumentNext,\n-            format: FormatSpec {\n-                fill: None,\n-                align: AlignUnknown,\n-                flags: (1 << FlagSignPlus as u32) | (1 << FlagAlternate as u32),\n-                precision: CountImplied,\n-                width: CountImplied,\n-                ty: \"\",\n-            },\n-        })]);\n+        same(\"{:-}\",\n+             &[NextArgument(Argument {\n+                   position: ArgumentNext,\n+                   format: FormatSpec {\n+                       fill: None,\n+                       align: AlignUnknown,\n+                       flags: (1 << FlagSignMinus as u32),\n+                       precision: CountImplied,\n+                       width: CountImplied,\n+                       ty: \"\",\n+                   },\n+               })]);\n+        same(\"{:+#}\",\n+             &[NextArgument(Argument {\n+                   position: ArgumentNext,\n+                   format: FormatSpec {\n+                       fill: None,\n+                       align: AlignUnknown,\n+                       flags: (1 << FlagSignPlus as u32) | (1 << FlagAlternate as u32),\n+                       precision: CountImplied,\n+                       width: CountImplied,\n+                       ty: \"\",\n+                   },\n+               })]);\n     }\n     #[test]\n     fn format_mixture() {\n-        same(\"abcd {3:a} efg\", &[String(\"abcd \"), NextArgument(Argument {\n-            position: ArgumentIs(3),\n-            format: FormatSpec {\n-                fill: None,\n-                align: AlignUnknown,\n-                flags: 0,\n-                precision: CountImplied,\n-                width: CountImplied,\n-                ty: \"a\",\n-            },\n-        }), String(\" efg\")]);\n+        same(\"abcd {3:a} efg\",\n+             &[String(\"abcd \"),\n+               NextArgument(Argument {\n+                   position: ArgumentIs(3),\n+                   format: FormatSpec {\n+                       fill: None,\n+                       align: AlignUnknown,\n+                       flags: 0,\n+                       precision: CountImplied,\n+                       width: CountImplied,\n+                       ty: \"a\",\n+                   },\n+               }),\n+               String(\" efg\")]);\n     }\n }"}]}