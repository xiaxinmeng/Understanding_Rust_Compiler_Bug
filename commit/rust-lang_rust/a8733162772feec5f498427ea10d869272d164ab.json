{"sha": "a8733162772feec5f498427ea10d869272d164ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4NzMzMTYyNzcyZmVlYzVmNDk4NDI3ZWExMGQ4NjkyNzJkMTY0YWI=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-01-22T21:59:23Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2015-01-30T15:37:44Z"}, "message": "remove dead code", "tree": {"sha": "27299ee0b731bae872417ca1c8de63c9ce2fa80b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27299ee0b731bae872417ca1c8de63c9ce2fa80b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8733162772feec5f498427ea10d869272d164ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8733162772feec5f498427ea10d869272d164ab", "html_url": "https://github.com/rust-lang/rust/commit/a8733162772feec5f498427ea10d869272d164ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8733162772feec5f498427ea10d869272d164ab/comments", "author": null, "committer": null, "parents": [{"sha": "acb8c1aaa6f3aa46cc3abf9ccc77b4882d778f9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/acb8c1aaa6f3aa46cc3abf9ccc77b4882d778f9c", "html_url": "https://github.com/rust-lang/rust/commit/acb8c1aaa6f3aa46cc3abf9ccc77b4882d778f9c"}], "stats": {"total": 307, "additions": 5, "deletions": 302}, "files": [{"sha": "0a575a31eadc0841f940a40e29ea139f66f8f68e", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8733162772feec5f498427ea10d869272d164ab/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8733162772feec5f498427ea10d869272d164ab/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=a8733162772feec5f498427ea10d869272d164ab", "patch": "@@ -263,7 +263,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 self.tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n             }\n \n-            ast::ExprForLoop(ref pat, ref head, ref body, _) => {\n+            ast::ExprForLoop(..) => {\n                 self.tcx.sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n             }\n "}, {"sha": "a79e6fac0cc260d3ea33df4821649c7f15fae13c", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8733162772feec5f498427ea10d869272d164ab/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8733162772feec5f498427ea10d869272d164ab/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=a8733162772feec5f498427ea10d869272d164ab", "patch": "@@ -537,7 +537,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                 self.tcx().sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n             }\n \n-            ast::ExprForLoop(ref pat, ref head, ref blk, _) => {\n+            ast::ExprForLoop(..) => {\n                 self.tcx().sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n             }\n "}, {"sha": "982bc41f06a849cf38034487a7a8303b19ff5163", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a8733162772feec5f498427ea10d869272d164ab/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8733162772feec5f498427ea10d869272d164ab/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=a8733162772feec5f498427ea10d869272d164ab", "patch": "@@ -135,8 +135,6 @@ enum LoopKind<'a> {\n     LoopLoop,\n     /// A `while` loop, with the given expression as condition.\n     WhileLoop(&'a Expr),\n-    /// A `for` loop, with the given pattern to bind.\n-    ForLoop(&'a ast::Pat),\n }\n \n #[derive(Copy, PartialEq)]\n@@ -490,7 +488,7 @@ fn visit_expr(ir: &mut IrMaps, expr: &Expr) {\n       ast::ExprWhileLet(..) => {\n           ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n       }\n-      ast::ExprForLoop(ref pat, _, _, _) => {\n+      ast::ExprForLoop(..) => {\n           ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n       }\n       ast::ExprBinary(op, _, _) if ast_util::lazy_binop(op.node) => {\n@@ -1023,7 +1021,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n               self.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprWhileLet\");\n           }\n \n-          ast::ExprForLoop(ref pat, ref head, ref blk, _) => {\n+          ast::ExprForLoop(..) => {\n               self.ir.tcx.sess.span_bug(expr.span, \"non-desugared ExprForLoop\");\n           }\n \n@@ -1361,7 +1359,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n         let cond_ln = match kind {\n             LoopLoop => ln,\n-            ForLoop(ref pat) => self.define_bindings_in_pat(*pat, ln),\n             WhileLoop(ref cond) => self.propagate_through_expr(&**cond, ln),\n         };\n         let body_ln = self.with_loop_nodes(expr.id, succ, ln, |this| {\n@@ -1374,9 +1371,6 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n             let new_cond_ln = match kind {\n                 LoopLoop => ln,\n-                ForLoop(ref pat) => {\n-                    self.define_bindings_in_pat(*pat, ln)\n-                }\n                 WhileLoop(ref cond) => {\n                     self.propagate_through_expr(&**cond, ln)\n                 }"}, {"sha": "3d7adc9934fb55f488b19556b9fcff71ac0775bb", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a8733162772feec5f498427ea10d869272d164ab/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8733162772feec5f498427ea10d869272d164ab/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=a8733162772feec5f498427ea10d869272d164ab", "patch": "@@ -252,7 +252,6 @@ mod svh_visitor {\n         SawExprStruct,\n         SawExprRepeat,\n         SawExprParen,\n-        SawExprForLoop,\n     }\n \n     fn saw_expr<'a>(node: &'a Expr_) -> SawExprComponent<'a> {"}, {"sha": "89d36ef5801013fe8e53e3e74ebf59c0d0cfb305", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a8733162772feec5f498427ea10d869272d164ab/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8733162772feec5f498427ea10d869272d164ab/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=a8733162772feec5f498427ea10d869272d164ab", "patch": "@@ -68,7 +68,7 @@ use rustc::util::lev_distance::lev_distance;\n \n use syntax::ast::{Arm, BindByRef, BindByValue, BindingMode, Block, Crate, CrateNum};\n use syntax::ast::{DefId, Expr, ExprAgain, ExprBreak, ExprField};\n-use syntax::ast::{ExprClosure, ExprForLoop, ExprLoop, ExprWhile, ExprMethodCall};\n+use syntax::ast::{ExprClosure, ExprLoop, ExprWhile, ExprMethodCall};\n use syntax::ast::{ExprPath, ExprQPath, ExprStruct, FnDecl};\n use syntax::ast::{ForeignItemFn, ForeignItemStatic, Generics};\n use syntax::ast::{Ident, ImplItem, Item, ItemConst, ItemEnum, ItemExternCrate};"}, {"sha": "7074a970ba91ccda454e0e87c1c0e040adee5350", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a8733162772feec5f498427ea10d869272d164ab/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8733162772feec5f498427ea10d869272d164ab/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=a8733162772feec5f498427ea10d869272d164ab", "patch": "@@ -1537,31 +1537,6 @@ pub fn store_arg<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-/// Generates code for the pattern binding in a `for` loop like\n-/// `for <pat> in <expr> { ... }`.\n-pub fn store_for_loop_binding<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                          pat: &ast::Pat,\n-                                          llvalue: ValueRef,\n-                                          body_scope: cleanup::ScopeId)\n-                                          -> Block<'blk, 'tcx> {\n-    let _icx = push_ctxt(\"match::store_for_loop_binding\");\n-\n-    if simple_identifier(&*pat).is_some() &&\n-       bcx.sess().opts.debuginfo != FullDebugInfo {\n-        // Generate nicer LLVM for the common case of a `for` loop pattern\n-        // like `for x in blahblah { ... }`.\n-        let binding_type = node_id_type(bcx, pat.id);\n-        bcx.fcx.lllocals.borrow_mut().insert(pat.id,\n-                                             Datum::new(llvalue,\n-                                                        binding_type,\n-                                                        Lvalue));\n-        return bcx\n-    }\n-\n-    // General path. Copy out the values that are used in the pattern.\n-    bind_irrefutable_pat(bcx, pat, llvalue, body_scope)\n-}\n-\n fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n                                        p_id: ast::NodeId,\n                                        ident: &ast::Ident,"}, {"sha": "c4388603145fe2796b46a0926ef3d7e57c135cb2", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/a8733162772feec5f498427ea10d869272d164ab/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8733162772feec5f498427ea10d869272d164ab/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=a8733162772feec5f498427ea10d869272d164ab", "patch": "@@ -11,26 +11,19 @@\n use llvm::ValueRef;\n use middle::def;\n use middle::lang_items::{PanicFnLangItem, PanicBoundsCheckFnLangItem};\n-use trans::_match;\n-use trans::adt;\n use trans::base::*;\n use trans::build::*;\n use trans::callee;\n use trans::cleanup::CleanupMethods;\n use trans::cleanup;\n use trans::common::*;\n use trans::consts;\n-use trans::datum;\n use trans::debuginfo;\n use trans::debuginfo::{DebugLoc, ToDebugLoc};\n use trans::expr;\n-use trans::meth;\n-use trans::type_::Type;\n use trans;\n use middle::ty;\n-use middle::ty::MethodCall;\n use util::ppaux::Repr;\n-use util::ppaux;\n \n use syntax::ast;\n use syntax::ast::Ident;\n@@ -259,135 +252,6 @@ pub fn trans_while<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     return next_bcx_in;\n }\n \n-/// Translates a `for` loop.\n-pub fn trans_for<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n-                             loop_info: NodeIdAndSpan,\n-                             pat: &ast::Pat,\n-                             head: &ast::Expr,\n-                             body: &ast::Block)\n-                             -> Block<'blk, 'tcx>\n-{\n-    let _icx = push_ctxt(\"trans_for\");\n-\n-    //            bcx\n-    //             |\n-    //      loopback_bcx_in  <-------+\n-    //             |                 |\n-    //      loopback_bcx_out         |\n-    //           |      |            |\n-    //           |    body_bcx_in    |\n-    // cleanup_blk      |            |\n-    //    |           body_bcx_out --+\n-    // next_bcx_in\n-\n-    // Codegen the head to create the iterator value.\n-    let iterator_datum =\n-        unpack_datum!(bcx, expr::trans_to_lvalue(bcx, head, \"for_head\"));\n-    let iterator_type = node_id_type(bcx, head.id);\n-    debug!(\"iterator type is {}, datum type is {}\",\n-           ppaux::ty_to_string(bcx.tcx(), iterator_type),\n-           ppaux::ty_to_string(bcx.tcx(), iterator_datum.ty));\n-\n-    let lliterator = load_ty(bcx, iterator_datum.val, iterator_datum.ty);\n-\n-    // Create our basic blocks and set up our loop cleanups.\n-    let next_bcx_in = bcx.fcx.new_id_block(\"for_exit\", loop_info.id);\n-    let loopback_bcx_in = bcx.fcx.new_id_block(\"for_loopback\", head.id);\n-    let body_bcx_in = bcx.fcx.new_id_block(\"for_body\", body.id);\n-    bcx.fcx.push_loop_cleanup_scope(loop_info.id,\n-                                    [next_bcx_in, loopback_bcx_in]);\n-    Br(bcx, loopback_bcx_in.llbb, DebugLoc::None);\n-    let cleanup_llbb = bcx.fcx.normal_exit_block(loop_info.id,\n-                                                 cleanup::EXIT_BREAK);\n-\n-    // Set up the method call (to `.next()`).\n-    let method_call = MethodCall::expr(loop_info.id);\n-    let method_type = (*loopback_bcx_in.tcx()\n-                                     .method_map\n-                                     .borrow())[method_call]\n-                                     .ty;\n-    let method_type = monomorphize_type(loopback_bcx_in, method_type);\n-    let method_result_type =\n-        ty::assert_no_late_bound_regions( // LB regions are instantiated in invoked methods\n-            loopback_bcx_in.tcx(), &ty::ty_fn_ret(method_type)).unwrap();\n-    let option_cleanup_scope = body_bcx_in.fcx.push_custom_cleanup_scope();\n-    let option_cleanup_scope_id = cleanup::CustomScope(option_cleanup_scope);\n-\n-    // Compile the method call (to `.next()`).\n-    let mut loopback_bcx_out = loopback_bcx_in;\n-    let option_datum =\n-        unpack_datum!(loopback_bcx_out,\n-                      datum::lvalue_scratch_datum(loopback_bcx_out,\n-                                                  method_result_type,\n-                                                  \"loop_option\",\n-                                                  false,\n-                                                  option_cleanup_scope_id,\n-                                                  (),\n-                                                  |(), bcx, lloption| {\n-        let Result {\n-            bcx,\n-            val: _\n-        } = callee::trans_call_inner(bcx,\n-                                     Some(loop_info),\n-                                     method_type,\n-                                     |bcx, arg_cleanup_scope| {\n-                                         meth::trans_method_callee(\n-                                             bcx,\n-                                             method_call,\n-                                             None,\n-                                             arg_cleanup_scope)\n-                                     },\n-                                     callee::ArgVals(&[lliterator]),\n-                                     Some(expr::SaveIn(lloption)));\n-        bcx\n-    }));\n-\n-    // Check the discriminant; if the `None` case, exit the loop.\n-    let option_representation = adt::represent_type(loopback_bcx_out.ccx(),\n-                                                    method_result_type);\n-    let lldiscriminant = adt::trans_get_discr(loopback_bcx_out,\n-                                              &*option_representation,\n-                                              option_datum.val,\n-                                              None);\n-    let i1_type = Type::i1(loopback_bcx_out.ccx());\n-    let llcondition = Trunc(loopback_bcx_out, lldiscriminant, i1_type);\n-    CondBr(loopback_bcx_out, llcondition, body_bcx_in.llbb, cleanup_llbb, DebugLoc::None);\n-\n-    // Now we're in the body. Unpack the `Option` value into the programmer-\n-    // supplied pattern.\n-    let llpayload = adt::trans_field_ptr(body_bcx_in,\n-                                         &*option_representation,\n-                                         option_datum.val,\n-                                         1,\n-                                         0);\n-    let binding_cleanup_scope = body_bcx_in.fcx.push_custom_cleanup_scope();\n-    let binding_cleanup_scope_id =\n-        cleanup::CustomScope(binding_cleanup_scope);\n-    let mut body_bcx_out =\n-        _match::store_for_loop_binding(body_bcx_in,\n-                                       pat,\n-                                       llpayload,\n-                                       binding_cleanup_scope_id);\n-\n-    debuginfo::create_for_loop_var_metadata(body_bcx_in, pat);\n-\n-    // Codegen the body.\n-    body_bcx_out = trans_block(body_bcx_out, body, expr::Ignore);\n-    body_bcx_out =\n-        body_bcx_out.fcx\n-                    .pop_and_trans_custom_cleanup_scope(body_bcx_out,\n-                                                        binding_cleanup_scope);\n-    body_bcx_out =\n-        body_bcx_out.fcx\n-                    .pop_and_trans_custom_cleanup_scope(body_bcx_out,\n-                                                        option_cleanup_scope);\n-    Br(body_bcx_out, loopback_bcx_in.llbb, DebugLoc::None);\n-\n-    // Codegen cleanups and leave.\n-    next_bcx_in.fcx.pop_loop_cleanup_scope(loop_info.id);\n-    next_bcx_in\n-}\n-\n pub fn trans_loop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                               loop_expr: &ast::Expr,\n                               body: &ast::Block)"}, {"sha": "4f9c97795e1987428575ae03b5ae03237bf7d272", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/a8733162772feec5f498427ea10d869272d164ab/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8733162772feec5f498427ea10d869272d164ab/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=a8733162772feec5f498427ea10d869272d164ab", "patch": "@@ -1053,48 +1053,6 @@ pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n     })\n }\n \n-/// Creates debug information for the given for-loop variable.\n-///\n-/// This function assumes that there's a datum for each pattern component of the\n-/// loop variable in `bcx.fcx.lllocals`.\n-/// Adds the created metadata nodes directly to the crate's IR.\n-pub fn create_for_loop_var_metadata(bcx: Block, pat: &ast::Pat) {\n-    if bcx.unreachable.get() ||\n-       fn_should_be_ignored(bcx.fcx) ||\n-       bcx.sess().opts.debuginfo != FullDebugInfo {\n-        return;\n-    }\n-\n-    let def_map = &bcx.tcx().def_map;\n-    let locals = bcx.fcx.lllocals.borrow();\n-\n-    pat_util::pat_bindings(def_map, pat, |_, node_id, span, var_ident| {\n-        let datum = match locals.get(&node_id) {\n-            Some(datum) => datum,\n-            None => {\n-                bcx.sess().span_bug(span,\n-                    format!(\"no entry in lllocals table for {}\",\n-                            node_id).as_slice());\n-            }\n-        };\n-\n-        if unsafe { llvm::LLVMIsAAllocaInst(datum.val) } == ptr::null_mut() {\n-            bcx.sess().span_bug(span, \"debuginfo::create_for_loop_var_metadata() - \\\n-                                       Referenced variable location is not an alloca!\");\n-        }\n-\n-        let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n-\n-        declare_local(bcx,\n-                      var_ident.node,\n-                      datum.ty,\n-                      scope_metadata,\n-                      DirectVariable { alloca: datum.val },\n-                      LocalVariable,\n-                      span);\n-    })\n-}\n-\n pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                     node_id: ast::NodeId,\n                                                     node_span: Span,"}, {"sha": "12bf507c05735fc47940ba6061f1b43b3d98585e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/a8733162772feec5f498427ea10d869272d164ab/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8733162772feec5f498427ea10d869272d164ab/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a8733162772feec5f498427ea10d869272d164ab", "patch": "@@ -87,7 +87,6 @@ use check::_match::pat_ctxt;\n use fmt_macros::{Parser, Piece, Position};\n use middle::{const_eval, def};\n use middle::infer;\n-use middle::lang_items::IteratorItem;\n use middle::mem_categorization as mc;\n use middle::mem_categorization::McResult;\n use middle::pat_util::{self, pat_id_map};\n@@ -2140,92 +2139,6 @@ fn try_index_step<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     })\n }\n \n-/// Given the head of a `for` expression, looks up the `next` method in the\n-/// `Iterator` trait. Panics if the expression does not implement `next`.\n-///\n-/// The return type of this function represents the concrete element type\n-/// `A` in the type `Iterator<A>` that the method returns.\n-fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                        iterator_expr: &ast::Expr,\n-                                        loop_id: ast::NodeId)\n-                                        -> Ty<'tcx> {\n-    let trait_did = match fcx.tcx().lang_items.require(IteratorItem) {\n-        Ok(trait_did) => trait_did,\n-        Err(ref err_string) => {\n-            span_err!(fcx.tcx().sess, iterator_expr.span, E0233,\n-                                    \"{}\", &err_string[]);\n-            return fcx.tcx().types.err\n-        }\n-    };\n-\n-    let expr_type = fcx.expr_ty(&*iterator_expr);\n-    let method = method::lookup_in_trait(fcx,\n-                                         iterator_expr.span,\n-                                         Some(&*iterator_expr),\n-                                         token::intern(\"next\"),\n-                                         trait_did,\n-                                         expr_type,\n-                                         None);\n-\n-    // Regardless of whether the lookup succeeds, check the method arguments\n-    // so that we have *some* type for each argument.\n-    let method_type = match method {\n-        Some(ref method) => method.ty,\n-        None => {\n-            let true_expr_type = fcx.infcx().resolve_type_vars_if_possible(&expr_type);\n-\n-            if !ty::type_is_error(true_expr_type) {\n-                let ty_string = fcx.infcx().ty_to_string(true_expr_type);\n-                span_err!(fcx.tcx().sess, iterator_expr.span, E0234,\n-                                        \"`for` loop expression has type `{}` which does \\\n-                                                not implement the `Iterator` trait; \\\n-                                                maybe try .iter()\", ty_string);\n-            }\n-            fcx.tcx().types.err\n-        }\n-    };\n-    let return_type = check_method_argument_types(fcx,\n-                                                  iterator_expr.span,\n-                                                  method_type,\n-                                                  iterator_expr,\n-                                                  &[],\n-                                                  AutorefArgs::No,\n-                                                  DontTupleArguments,\n-                                                  NoExpectation);\n-\n-    match method {\n-        Some(method) => {\n-            fcx.inh.method_map.borrow_mut().insert(MethodCall::expr(loop_id),\n-                                                   method);\n-\n-            // We expect the return type to be `Option` or something like it.\n-            // Grab the first parameter of its type substitution.\n-            let return_type = match return_type {\n-                ty::FnConverging(return_type) =>\n-                    structurally_resolved_type(fcx, iterator_expr.span, return_type),\n-                ty::FnDiverging => fcx.tcx().types.err\n-            };\n-            match return_type.sty {\n-                ty::ty_enum(_, ref substs)\n-                        if !substs.types.is_empty_in(subst::TypeSpace) => {\n-                    *substs.types.get(subst::TypeSpace, 0)\n-                }\n-                ty::ty_err => {\n-                    fcx.tcx().types.err\n-                }\n-                _ => {\n-                    span_err!(fcx.tcx().sess, iterator_expr.span, E0239,\n-                                            \"`next` method of the `Iterator` \\\n-                                                    trait has an unexpected type `{}`\",\n-                                                    fcx.infcx().ty_to_string(return_type));\n-                    fcx.tcx().types.err\n-                }\n-            }\n-        }\n-        None => fcx.tcx().types.err\n-    }\n-}\n-\n fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                          sp: Span,\n                                          method_fn_ty: Ty<'tcx>,"}]}