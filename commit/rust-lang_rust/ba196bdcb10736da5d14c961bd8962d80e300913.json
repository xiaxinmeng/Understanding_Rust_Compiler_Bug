{"sha": "ba196bdcb10736da5d14c961bd8962d80e300913", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhMTk2YmRjYjEwNzM2ZGE1ZDE0Yzk2MWJkODk2MmQ4MGUzMDA5MTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-28T03:57:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-28T03:57:28Z"}, "message": "Auto merge of #51444 - estebank:impl-static, r=nikomatsakis\n\nSuggestion for 'static impl Trait return\n\nWhen encountering a named or anonymous sup requirement (for example,\n`&'a self`) and a `'static` impl Trait return type, suggest adding the\n`'_` lifetime constraing to the return type.\n\nFix #43719, #51282.\n\n```\nerror: cannot infer an appropriate lifetime\n  --> $DIR/static-return-lifetime-infered.rs:17:16\n   |\nLL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n   |                                   ----------------------- this return type evaluates to the `'static` lifetime...\nLL |         self.x.iter().map(|a| a.0)\n   |         ------ ^^^^\n   |         |\n   |         ...but this borrow...\n   |\nnote: ...can't outlive the anonymous lifetime #1 defined on the method body at 16:5\n  --> $DIR/static-return-lifetime-infered.rs:16:5\n   |\nLL | /     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\nLL | |         self.x.iter().map(|a| a.0)\nLL | |     }\n   | |_____^\nhelp: you can add a constraint to the return type to make it last less than `'static` and match the anonymous lifetime #1 defined on the method body at 16:5\n   |\nLL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> + '_ {\n   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n```", "tree": {"sha": "bf3b38bcf15b9d776031b961e7640cb9d751925e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf3b38bcf15b9d776031b961e7640cb9d751925e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba196bdcb10736da5d14c961bd8962d80e300913", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba196bdcb10736da5d14c961bd8962d80e300913", "html_url": "https://github.com/rust-lang/rust/commit/ba196bdcb10736da5d14c961bd8962d80e300913", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba196bdcb10736da5d14c961bd8962d80e300913/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99a9d6806d355b69fa66621df5208342de823aea", "url": "https://api.github.com/repos/rust-lang/rust/commits/99a9d6806d355b69fa66621df5208342de823aea", "html_url": "https://github.com/rust-lang/rust/commit/99a9d6806d355b69fa66621df5208342de823aea"}, {"sha": "612657d9f0b158f0b78e85e3f0a694ddcbf83268", "url": "https://api.github.com/repos/rust-lang/rust/commits/612657d9f0b158f0b78e85e3f0a694ddcbf83268", "html_url": "https://github.com/rust-lang/rust/commit/612657d9f0b158f0b78e85e3f0a694ddcbf83268"}], "stats": {"total": 207, "additions": 206, "deletions": 1}, "files": [{"sha": "f50c23b0aa75209e498c70f3d2df5ddb2d546a9b", "filename": "src/librustc/infer/error_reporting/nice_region_error/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba196bdcb10736da5d14c961bd8962d80e300913/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba196bdcb10736da5d14c961bd8962d80e300913/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmod.rs?ref=ba196bdcb10736da5d14c961bd8962d80e300913", "patch": "@@ -19,6 +19,7 @@ mod different_lifetimes;\n mod find_anon_type;\n mod named_anon_conflict;\n mod outlives_closure;\n+mod static_impl_trait;\n mod util;\n \n impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n@@ -67,6 +68,7 @@ impl<'cx, 'gcx, 'tcx> NiceRegionError<'cx, 'gcx, 'tcx> {\n         self.try_report_named_anon_conflict()\n             .or_else(|| self.try_report_anon_anon_conflict())\n             .or_else(|| self.try_report_outlives_closure())\n+            .or_else(|| self.try_report_static_impl_trait())\n     }\n \n     pub fn get_regions(&self) -> (Span, ty::Region<'tcx>, ty::Region<'tcx>) {"}, {"sha": "f9ec5fa13c960a2896d4e7e20ff988219eac7fa8", "filename": "src/librustc/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/ba196bdcb10736da5d14c961bd8962d80e300913/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba196bdcb10736da5d14c961bd8962d80e300913/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=ba196bdcb10736da5d14c961bd8962d80e300913", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Error Reporting for static impl Traits.\n+\n+use infer::error_reporting::nice_region_error::NiceRegionError;\n+use infer::lexical_region_resolve::RegionResolutionError;\n+use ty::{BoundRegion, FreeRegion, RegionKind};\n+use util::common::ErrorReported;\n+\n+impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n+    /// Print the error message for lifetime errors when the return type is a static impl Trait.\n+    pub(super) fn try_report_static_impl_trait(&self) -> Option<ErrorReported> {\n+        if let Some(ref error) = self.error {\n+            match error.clone() {\n+                RegionResolutionError::SubSupConflict(\n+                    var_origin,\n+                    sub_origin,\n+                    sub_r,\n+                    sup_origin,\n+                    sup_r,\n+                ) => {\n+                    let anon_reg_sup = self.is_suitable_region(sup_r)?;\n+                    if sub_r == &RegionKind::ReStatic &&\n+                        self.is_return_type_impl_trait(anon_reg_sup.def_id)\n+                    {\n+                        let sp = var_origin.span();\n+                        let return_sp = sub_origin.span();\n+                        let mut err = self.tcx.sess.struct_span_err(\n+                            sp,\n+                            \"cannot infer an appropriate lifetime\",\n+                        );\n+                        err.span_label(\n+                            return_sp,\n+                            \"this return type evaluates to the `'static` lifetime...\",\n+                        );\n+                        err.span_label(\n+                            sup_origin.span(),\n+                            \"...but this borrow...\",\n+                        );\n+\n+                        let (lifetime, lt_sp_opt) = self.tcx.msg_span_from_free_region(sup_r);\n+                        if let Some(lifetime_sp) = lt_sp_opt {\n+                            err.span_note(\n+                                lifetime_sp,\n+                                &format!(\"...can't outlive {}\", lifetime),\n+                            );\n+                        }\n+\n+                        let lifetime_name = match sup_r {\n+                            RegionKind::ReFree(FreeRegion {\n+                                bound_region: BoundRegion::BrNamed(_, ref name), ..\n+                            }) => format!(\"{}\", name),\n+                            _ => \"'_\".to_owned(),\n+                        };\n+                        if let Ok(snippet) = self.tcx.sess.codemap().span_to_snippet(return_sp) {\n+                            err.span_suggestion(\n+                                return_sp,\n+                                &format!(\n+                                    \"you can add a constraint to the return type to make it last \\\n+                                     less than `'static` and match {}\",\n+                                    lifetime,\n+                                ),\n+                                format!(\"{} + {}\", snippet, lifetime_name),\n+                            );\n+                        }\n+                        err.emit();\n+                        return Some(ErrorReported);\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+        None\n+    }\n+}"}, {"sha": "1cc2b9d50b99ba1eb57de1f4bd1526558be7c1eb", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ba196bdcb10736da5d14c961bd8962d80e300913/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba196bdcb10736da5d14c961bd8962d80e300913/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=ba196bdcb10736da5d14c961bd8962d80e300913", "patch": "@@ -167,6 +167,23 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n         }\n         None\n     }\n+\n+    pub(super) fn is_return_type_impl_trait(\n+        &self,\n+        scope_def_id: DefId,\n+    ) -> bool {\n+        let ret_ty = self.tcx.type_of(scope_def_id);\n+        match ret_ty.sty {\n+            ty::TyFnDef(_, _) => {\n+                let sig = ret_ty.fn_sig(self.tcx);\n+                let output = self.tcx.erase_late_bound_regions(&sig.output());\n+                return output.is_impl_trait();\n+            }\n+            _ => {}\n+        }\n+        false\n+    }\n+\n     // Here we check for the case where anonymous region\n     // corresponds to self and if yes, we display E0312.\n     // FIXME(#42700) - Need to format self properly to"}, {"sha": "6d4e9a1b767a9524e29b771c40d4d0d0a70e349e", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba196bdcb10736da5d14c961bd8962d80e300913/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba196bdcb10736da5d14c961bd8962d80e300913/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=ba196bdcb10736da5d14c961bd8962d80e300913", "patch": "@@ -179,7 +179,7 @@ pub enum Note {\n // and how it is located, as well as the mutability of the memory in\n // which the value is stored.\n //\n-// *WARNING* The field `cmt.type` is NOT necessarily the same as the\n+// *WARNING* The field `cmt.ty` is NOT necessarily the same as the\n // result of `node_id_to_type(cmt.id)`. This is because the `id` is\n // always the `id` of the node producing the type; in an expression\n // like `*x`, the type of this deref node is the deref'd type (`T`),"}, {"sha": "412dc7dc7e715c8fb7ef21394fccba56e5d2577d", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ba196bdcb10736da5d14c961bd8962d80e300913/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba196bdcb10736da5d14c961bd8962d80e300913/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=ba196bdcb10736da5d14c961bd8962d80e300913", "patch": "@@ -1751,6 +1751,13 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n+    pub fn is_impl_trait(&self) -> bool {\n+        match self.sty {\n+            TyAnon(..) => true,\n+            _ => false,\n+        }\n+    }\n+\n     pub fn ty_to_def_id(&self) -> Option<DefId> {\n         match self.sty {\n             TyDynamic(ref tt, ..) => tt.principal().map(|p| p.def_id()),"}, {"sha": "7099316d694a2d4921bab1ce0c8887d6f2b232c9", "filename": "src/test/ui/impl-trait/static-return-lifetime-infered.nll.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ba196bdcb10736da5d14c961bd8962d80e300913/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ba196bdcb10736da5d14c961bd8962d80e300913/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.nll.stderr?ref=ba196bdcb10736da5d14c961bd8962d80e300913", "patch": "@@ -0,0 +1,26 @@\n+warning: not reporting region error due to nll\n+  --> $DIR/static-return-lifetime-infered.rs:17:16\n+   |\n+LL |         self.x.iter().map(|a| a.0)\n+   |                ^^^^\n+\n+warning: not reporting region error due to nll\n+  --> $DIR/static-return-lifetime-infered.rs:21:16\n+   |\n+LL |         self.x.iter().map(|a| a.0)\n+   |                ^^^^\n+\n+error: free region `` does not outlive free region `'static`\n+  --> $DIR/static-return-lifetime-infered.rs:17:9\n+   |\n+LL |         self.x.iter().map(|a| a.0)\n+   |         ^^^^^^^^^^^^^\n+\n+error: free region `'a` does not outlive free region `'static`\n+  --> $DIR/static-return-lifetime-infered.rs:21:9\n+   |\n+LL |         self.x.iter().map(|a| a.0)\n+   |         ^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "a05c88952828020582ed3eea00bc4ddacc2d5f54", "filename": "src/test/ui/impl-trait/static-return-lifetime-infered.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ba196bdcb10736da5d14c961bd8962d80e300913/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba196bdcb10736da5d14c961bd8962d80e300913/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.rs?ref=ba196bdcb10736da5d14c961bd8962d80e300913", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct A {\n+    x: [(u32, u32); 10]\n+}\n+\n+impl A {\n+    fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n+        self.x.iter().map(|a| a.0)\n+    }\n+    //~^^ ERROR cannot infer an appropriate lifetime\n+    fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n+        self.x.iter().map(|a| a.0)\n+    }\n+    //~^^ ERROR cannot infer an appropriate lifetime\n+}\n+\n+fn main() {}"}, {"sha": "2795bb92ed56f46aba0101fa5e9408d3ca97e9b2", "filename": "src/test/ui/impl-trait/static-return-lifetime-infered.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ba196bdcb10736da5d14c961bd8962d80e300913/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ba196bdcb10736da5d14c961bd8962d80e300913/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fstatic-return-lifetime-infered.stderr?ref=ba196bdcb10736da5d14c961bd8962d80e300913", "patch": "@@ -0,0 +1,44 @@\n+error: cannot infer an appropriate lifetime\n+  --> $DIR/static-return-lifetime-infered.rs:17:16\n+   |\n+LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n+   |                                   ----------------------- this return type evaluates to the `'static` lifetime...\n+LL |         self.x.iter().map(|a| a.0)\n+   |         ------ ^^^^\n+   |         |\n+   |         ...but this borrow...\n+   |\n+note: ...can't outlive the anonymous lifetime #1 defined on the method body at 16:5\n+  --> $DIR/static-return-lifetime-infered.rs:16:5\n+   |\n+LL | /     fn iter_values_anon(&self) -> impl Iterator<Item=u32> {\n+LL | |         self.x.iter().map(|a| a.0)\n+LL | |     }\n+   | |_____^\n+help: you can add a constraint to the return type to make it last less than `'static` and match the anonymous lifetime #1 defined on the method body at 16:5\n+   |\n+LL |     fn iter_values_anon(&self) -> impl Iterator<Item=u32> + '_ {\n+   |                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: cannot infer an appropriate lifetime\n+  --> $DIR/static-return-lifetime-infered.rs:21:16\n+   |\n+LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n+   |                                     ----------------------- this return type evaluates to the `'static` lifetime...\n+LL |         self.x.iter().map(|a| a.0)\n+   |         ------ ^^^^\n+   |         |\n+   |         ...but this borrow...\n+   |\n+note: ...can't outlive the lifetime 'a as defined on the method body at 20:5\n+  --> $DIR/static-return-lifetime-infered.rs:20:5\n+   |\n+LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: you can add a constraint to the return type to make it last less than `'static` and match the lifetime 'a as defined on the method body at 20:5\n+   |\n+LL |     fn iter_values<'a>(&'a self) -> impl Iterator<Item=u32> + 'a {\n+   |                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}]}