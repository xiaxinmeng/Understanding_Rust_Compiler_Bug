{"sha": "8e863eb59a10fb0900d7377524a0dc7bf44b9ae3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlODYzZWI1OWExMGZiMDkwMGQ3Mzc3NTI0YTBkYzdiZjQ0YjlhZTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-27T07:52:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-27T07:52:11Z"}, "message": "Auto merge of #82448 - Aaron1011:merge-hastokens-hasattrs, r=petrochenkov\n\nCombine HasAttrs and HasTokens into AstLike\n\nWhen token-based attribute handling is implemeneted in #80689,\nwe will need to access tokens from `HasAttrs` (to perform\ncfg-stripping), and we will to access attributes from `HasTokens` (to\nconstruct a `PreexpTokenStream`).\n\nThis PR merges the `HasAttrs` and `HasTokens` traits into a new\n`AstLike` trait. The previous `HasAttrs` impls from `Vec<Attribute>` and `AttrVec`\nare removed - they aren't attribute targets, so the impls never really\nmade sense.", "tree": {"sha": "3e21f786845776476c5960608e53edec8efbe82a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e21f786845776476c5960608e53edec8efbe82a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e863eb59a10fb0900d7377524a0dc7bf44b9ae3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e863eb59a10fb0900d7377524a0dc7bf44b9ae3", "html_url": "https://github.com/rust-lang/rust/commit/8e863eb59a10fb0900d7377524a0dc7bf44b9ae3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e863eb59a10fb0900d7377524a0dc7bf44b9ae3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0846043440b480e4bbf36ac19db3948f0c835bb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/0846043440b480e4bbf36ac19db3948f0c835bb1", "html_url": "https://github.com/rust-lang/rust/commit/0846043440b480e4bbf36ac19db3948f0c835bb1"}, {"sha": "fb5fec017b2f24b88c1f51980f7d81a02e7468d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb5fec017b2f24b88c1f51980f7d81a02e7468d9", "html_url": "https://github.com/rust-lang/rust/commit/fb5fec017b2f24b88c1f51980f7d81a02e7468d9"}], "stats": {"total": 470, "additions": 264, "deletions": 206}, "files": [{"sha": "de44a2031ab82df999663aae00502d5d074979d4", "filename": "compiler/rustc_ast/src/ast.rs", "status": "modified", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/8e863eb59a10fb0900d7377524a0dc7bf44b9ae3/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e863eb59a10fb0900d7377524a0dc7bf44b9ae3/compiler%2Frustc_ast%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast.rs?ref=8e863eb59a10fb0900d7377524a0dc7bf44b9ae3", "patch": "@@ -2912,84 +2912,3 @@ impl TryFrom<ItemKind> for ForeignItemKind {\n }\n \n pub type ForeignItem = Item<ForeignItemKind>;\n-\n-pub trait HasTokens {\n-    /// Called by `Parser::collect_tokens` to store the collected\n-    /// tokens inside an AST node\n-    fn finalize_tokens(&mut self, tokens: LazyTokenStream);\n-}\n-\n-impl<T: HasTokens + 'static> HasTokens for P<T> {\n-    fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-        (**self).finalize_tokens(tokens);\n-    }\n-}\n-\n-impl<T: HasTokens> HasTokens for Option<T> {\n-    fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-        if let Some(inner) = self {\n-            inner.finalize_tokens(tokens);\n-        }\n-    }\n-}\n-\n-impl HasTokens for Attribute {\n-    fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-        match &mut self.kind {\n-            AttrKind::Normal(_, attr_tokens) => {\n-                if attr_tokens.is_none() {\n-                    *attr_tokens = Some(tokens);\n-                }\n-            }\n-            AttrKind::DocComment(..) => {\n-                panic!(\"Called finalize_tokens on doc comment attr {:?}\", self)\n-            }\n-        }\n-    }\n-}\n-\n-impl HasTokens for Stmt {\n-    fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-        let stmt_tokens = match self.kind {\n-            StmtKind::Local(ref mut local) => &mut local.tokens,\n-            StmtKind::Item(ref mut item) => &mut item.tokens,\n-            StmtKind::Expr(ref mut expr) | StmtKind::Semi(ref mut expr) => &mut expr.tokens,\n-            StmtKind::Empty => return,\n-            StmtKind::MacCall(ref mut mac) => &mut mac.tokens,\n-        };\n-        if stmt_tokens.is_none() {\n-            *stmt_tokens = Some(tokens);\n-        }\n-    }\n-}\n-\n-macro_rules! derive_has_tokens {\n-    ($($ty:path),*) => { $(\n-        impl HasTokens for $ty {\n-            fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n-                if self.tokens.is_none() {\n-                    self.tokens = Some(tokens);\n-                }\n-            }\n-        }\n-    )* }\n-}\n-\n-derive_has_tokens! {\n-    Item, Expr, Ty, AttrItem, Visibility, Path, Block, Pat\n-}\n-\n-macro_rules! derive_has_attrs_no_tokens {\n-    ($($ty:path),*) => { $(\n-        impl HasTokens for $ty {\n-            fn finalize_tokens(&mut self, _tokens: LazyTokenStream) {}\n-        }\n-    )* }\n-}\n-\n-// These ast nodes only support inert attributes, so they don't\n-// store tokens (since nothing can observe them)\n-derive_has_attrs_no_tokens! {\n-    StructField, Arm,\n-    Field, FieldPat, Variant, Param, GenericParam\n-}"}, {"sha": "6649cda69a0b0f9aafe69b31a27b3052218bf5a3", "filename": "compiler/rustc_ast/src/ast_like.rs", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/8e863eb59a10fb0900d7377524a0dc7bf44b9ae3/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e863eb59a10fb0900d7377524a0dc7bf44b9ae3/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fast_like.rs?ref=8e863eb59a10fb0900d7377524a0dc7bf44b9ae3", "patch": "@@ -0,0 +1,219 @@\n+use super::ptr::P;\n+use super::tokenstream::LazyTokenStream;\n+use super::{Arm, Field, FieldPat, GenericParam, Param, StructField, Variant};\n+use super::{AssocItem, Expr, ForeignItem, Item, Local};\n+use super::{AttrItem, AttrKind, Block, Pat, Path, Ty, Visibility};\n+use super::{AttrVec, Attribute, Stmt, StmtKind};\n+\n+/// An `AstLike` represents an AST node (or some wrapper around\n+/// and AST node) which stores some combination of attributes\n+/// and tokens.\n+pub trait AstLike: Sized {\n+    fn attrs(&self) -> &[Attribute];\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>));\n+    /// Called by `Parser::collect_tokens` to store the collected\n+    /// tokens inside an AST node\n+    fn finalize_tokens(&mut self, _tokens: LazyTokenStream) {\n+        // This default impl makes this trait easier to implement\n+        // in tools like `rust-analyzer`\n+        panic!(\"`finalize_tokens` is not supported!\")\n+    }\n+}\n+\n+impl<T: AstLike + 'static> AstLike for P<T> {\n+    fn attrs(&self) -> &[Attribute] {\n+        (**self).attrs()\n+    }\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+        (**self).visit_attrs(f);\n+    }\n+    fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n+        (**self).finalize_tokens(tokens)\n+    }\n+}\n+\n+fn visit_attrvec(attrs: &mut AttrVec, f: impl FnOnce(&mut Vec<Attribute>)) {\n+    crate::mut_visit::visit_clobber(attrs, |attrs| {\n+        let mut vec = attrs.into();\n+        f(&mut vec);\n+        vec.into()\n+    });\n+}\n+\n+impl AstLike for StmtKind {\n+    fn attrs(&self) -> &[Attribute] {\n+        match *self {\n+            StmtKind::Local(ref local) => local.attrs(),\n+            StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => expr.attrs(),\n+            StmtKind::Item(ref item) => item.attrs(),\n+            StmtKind::Empty => &[],\n+            StmtKind::MacCall(ref mac) => &*mac.attrs,\n+        }\n+    }\n+\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+        match self {\n+            StmtKind::Local(local) => local.visit_attrs(f),\n+            StmtKind::Expr(expr) | StmtKind::Semi(expr) => expr.visit_attrs(f),\n+            StmtKind::Item(item) => item.visit_attrs(f),\n+            StmtKind::Empty => {}\n+            StmtKind::MacCall(mac) => visit_attrvec(&mut mac.attrs, f),\n+        }\n+    }\n+    fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n+        let stmt_tokens = match self {\n+            StmtKind::Local(ref mut local) => &mut local.tokens,\n+            StmtKind::Item(ref mut item) => &mut item.tokens,\n+            StmtKind::Expr(ref mut expr) | StmtKind::Semi(ref mut expr) => &mut expr.tokens,\n+            StmtKind::Empty => return,\n+            StmtKind::MacCall(ref mut mac) => &mut mac.tokens,\n+        };\n+        if stmt_tokens.is_none() {\n+            *stmt_tokens = Some(tokens);\n+        }\n+    }\n+}\n+\n+impl AstLike for Stmt {\n+    fn attrs(&self) -> &[Attribute] {\n+        self.kind.attrs()\n+    }\n+\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+        self.kind.visit_attrs(f);\n+    }\n+    fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n+        self.kind.finalize_tokens(tokens)\n+    }\n+}\n+\n+impl AstLike for Attribute {\n+    fn attrs(&self) -> &[Attribute] {\n+        &[]\n+    }\n+    fn visit_attrs(&mut self, _f: impl FnOnce(&mut Vec<Attribute>)) {}\n+    fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n+        match &mut self.kind {\n+            AttrKind::Normal(_, attr_tokens) => {\n+                if attr_tokens.is_none() {\n+                    *attr_tokens = Some(tokens);\n+                }\n+            }\n+            AttrKind::DocComment(..) => {\n+                panic!(\"Called finalize_tokens on doc comment attr {:?}\", self)\n+            }\n+        }\n+    }\n+}\n+\n+impl<T: AstLike> AstLike for Option<T> {\n+    fn attrs(&self) -> &[Attribute] {\n+        self.as_ref().map(|inner| inner.attrs()).unwrap_or(&[])\n+    }\n+    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+        if let Some(inner) = self.as_mut() {\n+            inner.visit_attrs(f);\n+        }\n+    }\n+    fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n+        if let Some(inner) = self {\n+            inner.finalize_tokens(tokens);\n+        }\n+    }\n+}\n+\n+/// Helper trait for the macros below. Abstracts over\n+/// the two types of attribute fields that AST nodes\n+/// may have (`Vec<Attribute>` or `AttrVec`)\n+trait VecOrAttrVec {\n+    fn visit(&mut self, f: impl FnOnce(&mut Vec<Attribute>));\n+}\n+\n+impl VecOrAttrVec for Vec<Attribute> {\n+    fn visit(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+        f(self)\n+    }\n+}\n+\n+impl VecOrAttrVec for AttrVec {\n+    fn visit(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+        visit_attrvec(self, f)\n+    }\n+}\n+\n+macro_rules! derive_has_tokens_and_attrs {\n+    ($($ty:path),*) => { $(\n+        impl AstLike for $ty {\n+            fn attrs(&self) -> &[Attribute] {\n+                &self.attrs\n+            }\n+\n+            fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+                VecOrAttrVec::visit(&mut self.attrs, f)\n+            }\n+\n+            fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n+                if self.tokens.is_none() {\n+                    self.tokens = Some(tokens);\n+                }\n+\n+            }\n+        }\n+    )* }\n+}\n+\n+macro_rules! derive_has_attrs_no_tokens {\n+    ($($ty:path),*) => { $(\n+        impl AstLike for $ty {\n+            fn attrs(&self) -> &[Attribute] {\n+                &self.attrs\n+            }\n+\n+            fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n+                VecOrAttrVec::visit(&mut self.attrs, f)\n+            }\n+\n+            fn finalize_tokens(&mut self, _tokens: LazyTokenStream) {}\n+        }\n+    )* }\n+}\n+\n+macro_rules! derive_has_tokens_no_attrs {\n+    ($($ty:path),*) => { $(\n+        impl AstLike for $ty {\n+            fn attrs(&self) -> &[Attribute] {\n+                &[]\n+            }\n+\n+            fn visit_attrs(&mut self, _f: impl FnOnce(&mut Vec<Attribute>)) {\n+            }\n+\n+            fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n+                if self.tokens.is_none() {\n+                    self.tokens = Some(tokens);\n+                }\n+\n+            }\n+        }\n+    )* }\n+}\n+\n+// These AST nodes support both inert and active\n+// attributes, so they also have tokens.\n+derive_has_tokens_and_attrs! {\n+    Item, Expr, Local, AssocItem, ForeignItem\n+}\n+\n+// These ast nodes only support inert attributes, so they don't\n+// store tokens (since nothing can observe them)\n+derive_has_attrs_no_tokens! {\n+    StructField, Arm,\n+    Field, FieldPat, Variant, Param, GenericParam\n+}\n+\n+// These AST nodes don't support attributes, but can\n+// be captured by a `macro_rules!` matcher. Therefore,\n+// they need to store tokens.\n+derive_has_tokens_no_attrs! {\n+    Ty, Block, AttrItem, Pat, Path, Visibility\n+}"}, {"sha": "52ac7540f6943c120530e81bb12e5207bddec1b6", "filename": "compiler/rustc_ast/src/attr/mod.rs", "status": "modified", "additions": 3, "deletions": 103, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/8e863eb59a10fb0900d7377524a0dc7bf44b9ae3/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e863eb59a10fb0900d7377524a0dc7bf44b9ae3/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fattr%2Fmod.rs?ref=8e863eb59a10fb0900d7377524a0dc7bf44b9ae3", "patch": "@@ -1,17 +1,15 @@\n //! Functions dealing with attributes and meta items.\n \n use crate::ast;\n-use crate::ast::{AttrId, AttrItem, AttrKind, AttrStyle, AttrVec, Attribute};\n-use crate::ast::{Expr, GenericParam, Item, Lit, LitKind, Local, Stmt, StmtKind};\n+use crate::ast::{AttrId, AttrItem, AttrKind, AttrStyle, Attribute};\n+use crate::ast::{Lit, LitKind};\n use crate::ast::{MacArgs, MacDelimiter, MetaItem, MetaItemKind, NestedMetaItem};\n use crate::ast::{Path, PathSegment};\n-use crate::mut_visit::visit_clobber;\n-use crate::ptr::P;\n use crate::token::{self, CommentKind, Token};\n use crate::tokenstream::{DelimSpan, LazyTokenStream, TokenStream, TokenTree, TreeAndSpacing};\n \n use rustc_index::bit_set::GrowableBitSet;\n-use rustc_span::source_map::{BytePos, Spanned};\n+use rustc_span::source_map::BytePos;\n use rustc_span::symbol::{sym, Ident, Symbol};\n use rustc_span::Span;\n \n@@ -617,101 +615,3 @@ impl NestedMetaItem {\n         MetaItem::from_tokens(tokens).map(NestedMetaItem::MetaItem)\n     }\n }\n-\n-pub trait HasAttrs: Sized {\n-    fn attrs(&self) -> &[Attribute];\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>));\n-}\n-\n-impl<T: HasAttrs> HasAttrs for Spanned<T> {\n-    fn attrs(&self) -> &[Attribute] {\n-        self.node.attrs()\n-    }\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-        self.node.visit_attrs(f);\n-    }\n-}\n-\n-impl HasAttrs for Vec<Attribute> {\n-    fn attrs(&self) -> &[Attribute] {\n-        self\n-    }\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-        f(self)\n-    }\n-}\n-\n-impl HasAttrs for AttrVec {\n-    fn attrs(&self) -> &[Attribute] {\n-        self\n-    }\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-        visit_clobber(self, |this| {\n-            let mut vec = this.into();\n-            f(&mut vec);\n-            vec.into()\n-        });\n-    }\n-}\n-\n-impl<T: HasAttrs + 'static> HasAttrs for P<T> {\n-    fn attrs(&self) -> &[Attribute] {\n-        (**self).attrs()\n-    }\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-        (**self).visit_attrs(f);\n-    }\n-}\n-\n-impl HasAttrs for StmtKind {\n-    fn attrs(&self) -> &[Attribute] {\n-        match *self {\n-            StmtKind::Local(ref local) => local.attrs(),\n-            StmtKind::Expr(ref expr) | StmtKind::Semi(ref expr) => expr.attrs(),\n-            StmtKind::Item(ref item) => item.attrs(),\n-            StmtKind::Empty => &[],\n-            StmtKind::MacCall(ref mac) => mac.attrs.attrs(),\n-        }\n-    }\n-\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-        match self {\n-            StmtKind::Local(local) => local.visit_attrs(f),\n-            StmtKind::Expr(expr) | StmtKind::Semi(expr) => expr.visit_attrs(f),\n-            StmtKind::Item(item) => item.visit_attrs(f),\n-            StmtKind::Empty => {}\n-            StmtKind::MacCall(mac) => {\n-                mac.attrs.visit_attrs(f);\n-            }\n-        }\n-    }\n-}\n-\n-impl HasAttrs for Stmt {\n-    fn attrs(&self) -> &[ast::Attribute] {\n-        self.kind.attrs()\n-    }\n-\n-    fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-        self.kind.visit_attrs(f);\n-    }\n-}\n-\n-macro_rules! derive_has_attrs {\n-    ($($ty:path),*) => { $(\n-        impl HasAttrs for $ty {\n-            fn attrs(&self) -> &[Attribute] {\n-                &self.attrs\n-            }\n-\n-            fn visit_attrs(&mut self, f: impl FnOnce(&mut Vec<Attribute>)) {\n-                self.attrs.visit_attrs(f);\n-            }\n-        }\n-    )* }\n-}\n-\n-derive_has_attrs! {\n-    Item, Expr, Local, ast::AssocItem, ast::ForeignItem, ast::StructField, ast::Arm,\n-    ast::Field, ast::FieldPat, ast::Variant, ast::Param, GenericParam\n-}"}, {"sha": "4eaef85043ccde3009f95fe5a737a0cb8cf1a20c", "filename": "compiler/rustc_ast/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e863eb59a10fb0900d7377524a0dc7bf44b9ae3/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e863eb59a10fb0900d7377524a0dc7bf44b9ae3/compiler%2Frustc_ast%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Flib.rs?ref=8e863eb59a10fb0900d7377524a0dc7bf44b9ae3", "patch": "@@ -40,6 +40,7 @@ pub mod util {\n }\n \n pub mod ast;\n+pub mod ast_like;\n pub mod attr;\n pub mod crate_disambiguator;\n pub mod entry;\n@@ -52,6 +53,7 @@ pub mod tokenstream;\n pub mod visit;\n \n pub use self::ast::*;\n+pub use self::ast_like::AstLike;\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n "}, {"sha": "ce8103c0f850dc4ebaf6f329a52b73532405aab2", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8e863eb59a10fb0900d7377524a0dc7bf44b9ae3/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e863eb59a10fb0900d7377524a0dc7bf44b9ae3/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=8e863eb59a10fb0900d7377524a0dc7bf44b9ae3", "patch": "@@ -3,10 +3,10 @@ use crate::module::DirectoryOwnership;\n \n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, Nonterminal};\n-use rustc_ast::tokenstream::{CanSynthesizeMissingTokens, TokenStream};\n+use rustc_ast::tokenstream::{CanSynthesizeMissingTokens, LazyTokenStream, TokenStream};\n use rustc_ast::visit::{AssocCtxt, Visitor};\n-use rustc_ast::{self as ast, Attribute, NodeId, PatKind};\n-use rustc_attr::{self as attr, Deprecation, HasAttrs, Stability};\n+use rustc_ast::{self as ast, AstLike, Attribute, NodeId, PatKind};\n+use rustc_attr::{self as attr, Deprecation, Stability};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{self, Lrc};\n use rustc_errors::{DiagnosticBuilder, ErrorReported};\n@@ -44,7 +44,7 @@ pub enum Annotatable {\n     Variant(ast::Variant),\n }\n \n-impl HasAttrs for Annotatable {\n+impl AstLike for Annotatable {\n     fn attrs(&self) -> &[Attribute] {\n         match *self {\n             Annotatable::Item(ref item) => &item.attrs,\n@@ -80,6 +80,10 @@ impl HasAttrs for Annotatable {\n             Annotatable::Variant(v) => v.visit_attrs(f),\n         }\n     }\n+\n+    fn finalize_tokens(&mut self, tokens: LazyTokenStream) {\n+        panic!(\"Called finalize_tokens on an Annotatable: {:?}\", tokens);\n+    }\n }\n \n impl Annotatable {"}, {"sha": "7d0becf1f5d85d658825b99885841325d68f9577", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8e863eb59a10fb0900d7377524a0dc7bf44b9ae3/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e863eb59a10fb0900d7377524a0dc7bf44b9ae3/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=8e863eb59a10fb0900d7377524a0dc7bf44b9ae3", "patch": "@@ -2,12 +2,11 @@\n \n use crate::base::Annotatable;\n \n-use rustc_ast::attr::HasAttrs;\n use rustc_ast::mut_visit::*;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{DelimToken, Token, TokenKind};\n use rustc_ast::tokenstream::{DelimSpan, LazyTokenStream, Spacing, TokenStream, TokenTree};\n-use rustc_ast::{self as ast, AttrItem, Attribute, MetaItem};\n+use rustc_ast::{self as ast, AstLike, AttrItem, Attribute, MetaItem};\n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::map_in_place::MapInPlace;\n@@ -205,7 +204,7 @@ pub fn features(sess: &Session, mut krate: ast::Crate) -> (ast::Crate, Features)\n     let unconfigured_attrs = krate.attrs.clone();\n     let diag = &sess.parse_sess.span_diagnostic;\n     let err_count = diag.err_count();\n-    let features = match strip_unconfigured.configure(krate.attrs) {\n+    let features = match strip_unconfigured.configure_krate_attrs(krate.attrs) {\n         None => {\n             // The entire crate is unconfigured.\n             krate.attrs = Vec::new();\n@@ -218,7 +217,9 @@ pub fn features(sess: &Session, mut krate: ast::Crate) -> (ast::Crate, Features)\n             if err_count == diag.err_count() {\n                 // Avoid reconfiguring malformed `cfg_attr`s.\n                 strip_unconfigured.features = Some(&features);\n-                strip_unconfigured.configure(unconfigured_attrs);\n+                // Run configuration again, this time with features available\n+                // so that we can perform feature-gating.\n+                strip_unconfigured.configure_krate_attrs(unconfigured_attrs);\n             }\n             features\n         }\n@@ -242,7 +243,7 @@ const CFG_ATTR_NOTE_REF: &str = \"for more information, visit \\\n     #the-cfg_attr-attribute>\";\n \n impl<'a> StripUnconfigured<'a> {\n-    pub fn configure<T: HasAttrs>(&mut self, mut node: T) -> Option<T> {\n+    pub fn configure<T: AstLike>(&mut self, mut node: T) -> Option<T> {\n         self.process_cfg_attrs(&mut node);\n         if self.in_cfg(node.attrs()) {\n             Some(node)\n@@ -252,13 +253,26 @@ impl<'a> StripUnconfigured<'a> {\n         }\n     }\n \n+    fn configure_krate_attrs(\n+        &mut self,\n+        mut attrs: Vec<ast::Attribute>,\n+    ) -> Option<Vec<ast::Attribute>> {\n+        attrs.flat_map_in_place(|attr| self.process_cfg_attr(attr));\n+        if self.in_cfg(&attrs) {\n+            Some(attrs)\n+        } else {\n+            self.modified = true;\n+            None\n+        }\n+    }\n+\n     /// Parse and expand all `cfg_attr` attributes into a list of attributes\n     /// that are within each `cfg_attr` that has a true configuration predicate.\n     ///\n     /// Gives compiler warnings if any `cfg_attr` does not contain any\n     /// attributes and is in the original source code. Gives compiler errors if\n     /// the syntax of any `cfg_attr` is incorrect.\n-    pub fn process_cfg_attrs<T: HasAttrs>(&mut self, node: &mut T) {\n+    pub fn process_cfg_attrs<T: AstLike>(&mut self, node: &mut T) {\n         node.visit_attrs(|attrs| {\n             attrs.flat_map_in_place(|attr| self.process_cfg_attr(attr));\n         });"}, {"sha": "b474cad1242e8f3767906ca3c9e54f190d44477d", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e863eb59a10fb0900d7377524a0dc7bf44b9ae3/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e863eb59a10fb0900d7377524a0dc7bf44b9ae3/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=8e863eb59a10fb0900d7377524a0dc7bf44b9ae3", "patch": "@@ -12,11 +12,11 @@ use rustc_ast::ptr::P;\n use rustc_ast::token;\n use rustc_ast::tokenstream::TokenStream;\n use rustc_ast::visit::{self, AssocCtxt, Visitor};\n-use rustc_ast::{AttrItem, AttrStyle, Block, Inline, ItemKind, LitKind, MacArgs};\n+use rustc_ast::{AstLike, AttrItem, AttrStyle, Block, Inline, ItemKind, LitKind, MacArgs};\n use rustc_ast::{MacCallStmt, MacStmtStyle, MetaItemKind, ModKind, NestedMetaItem};\n use rustc_ast::{NodeId, PatKind, Path, StmtKind, Unsafe};\n use rustc_ast_pretty::pprust;\n-use rustc_attr::{self as attr, is_builtin_attr, HasAttrs};\n+use rustc_attr::{self as attr, is_builtin_attr};\n use rustc_data_structures::map_in_place::MapInPlace;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_data_structures::sync::Lrc;\n@@ -1014,7 +1014,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     /// legacy derive helpers (helpers written before derives that introduce them).\n     fn take_first_attr(\n         &mut self,\n-        item: &mut impl HasAttrs,\n+        item: &mut impl AstLike,\n     ) -> Option<(ast::Attribute, usize, Vec<Path>)> {\n         let mut attr = None;\n \n@@ -1045,7 +1045,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n         attr\n     }\n \n-    fn configure<T: HasAttrs>(&mut self, node: T) -> Option<T> {\n+    fn configure<T: AstLike>(&mut self, node: T) -> Option<T> {\n         self.cfg.configure(node)\n     }\n "}, {"sha": "4258a4b4237a8c9b3b92f05e728f7d8d5590fac4", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e863eb59a10fb0900d7377524a0dc7bf44b9ae3/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e863eb59a10fb0900d7377524a0dc7bf44b9ae3/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=8e863eb59a10fb0900d7377524a0dc7bf44b9ae3", "patch": "@@ -24,7 +24,7 @@ use crate::{\n     types::{transparent_newtype_field, CItemKind},\n     EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext,\n };\n-use rustc_ast::attr::{self, HasAttrs};\n+use rustc_ast::attr;\n use rustc_ast::tokenstream::{TokenStream, TokenTree};\n use rustc_ast::visit::{FnCtxt, FnKind};\n use rustc_ast::{self as ast, *};"}, {"sha": "0c7b843831ababeff8dee6fa54610af56b8ef0c8", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e863eb59a10fb0900d7377524a0dc7bf44b9ae3/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e863eb59a10fb0900d7377524a0dc7bf44b9ae3/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=8e863eb59a10fb0900d7377524a0dc7bf44b9ae3", "patch": "@@ -18,7 +18,7 @@ use crate::context::{EarlyContext, LintContext, LintStore};\n use crate::passes::{EarlyLintPass, EarlyLintPassObject};\n use rustc_ast as ast;\n use rustc_ast::visit as ast_visit;\n-use rustc_attr::HasAttrs;\n+use rustc_ast::AstLike;\n use rustc_session::lint::{BufferedEarlyLint, LintBuffer, LintPass};\n use rustc_session::Session;\n use rustc_span::symbol::Ident;"}, {"sha": "cea4de72df5491282c9bb06d10d2ab7493f59b2c", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e863eb59a10fb0900d7377524a0dc7bf44b9ae3/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e863eb59a10fb0900d7377524a0dc7bf44b9ae3/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=8e863eb59a10fb0900d7377524a0dc7bf44b9ae3", "patch": "@@ -8,9 +8,9 @@\n #![feature(box_patterns)]\n \n use rustc_ast as ast;\n-use rustc_ast::attr::HasAttrs;\n use rustc_ast::token::{self, Nonterminal};\n use rustc_ast::tokenstream::{self, CanSynthesizeMissingTokens, LazyTokenStream, TokenStream};\n+use rustc_ast::AstLike;\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{Diagnostic, FatalError, Level, PResult};"}, {"sha": "f45d8d6c7a00eaff9db4d7d6b68aa0d997306af9", "filename": "compiler/rustc_parse/src/parser/attr_wrapper.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e863eb59a10fb0900d7377524a0dc7bf44b9ae3/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e863eb59a10fb0900d7377524a0dc7bf44b9ae3/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs?ref=8e863eb59a10fb0900d7377524a0dc7bf44b9ae3", "patch": "@@ -3,7 +3,7 @@ use super::{ForceCollect, Parser, TokenCursor, TrailingToken};\n use rustc_ast::token::{self, Token, TokenKind};\n use rustc_ast::tokenstream::{CreateTokenStream, TokenStream, TokenTree, TreeAndSpacing};\n use rustc_ast::tokenstream::{DelimSpan, LazyTokenStream, Spacing};\n-use rustc_ast::HasTokens;\n+use rustc_ast::AstLike;\n use rustc_ast::{self as ast};\n use rustc_errors::PResult;\n use rustc_span::{Span, DUMMY_SP};\n@@ -59,7 +59,7 @@ impl<'a> Parser<'a> {\n     /// This restriction shouldn't be an issue in practice,\n     /// since this function is used to record the tokens for\n     /// a parsed AST item, which always has matching delimiters.\n-    pub fn collect_tokens_trailing_token<R: HasTokens>(\n+    pub fn collect_tokens_trailing_token<R: AstLike>(\n         &mut self,\n         attrs: AttrWrapper,\n         force_collect: ForceCollect,"}, {"sha": "4cc2224d27e427df2682e5eac65c6ab7e7e1a1d0", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e863eb59a10fb0900d7377524a0dc7bf44b9ae3/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e863eb59a10fb0900d7377524a0dc7bf44b9ae3/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=8e863eb59a10fb0900d7377524a0dc7bf44b9ae3", "patch": "@@ -22,7 +22,7 @@ use rustc_ast::token::{self, DelimToken, Token, TokenKind};\n use rustc_ast::tokenstream::{self, DelimSpan, Spacing};\n use rustc_ast::tokenstream::{TokenStream, TokenTree, TreeAndSpacing};\n use rustc_ast::DUMMY_NODE_ID;\n-use rustc_ast::{self as ast, AnonConst, AttrStyle, AttrVec, Const, CrateSugar, Extern, HasTokens};\n+use rustc_ast::{self as ast, AnonConst, AstLike, AttrStyle, AttrVec, Const, CrateSugar, Extern};\n use rustc_ast::{Async, Expr, ExprKind, MacArgs, MacDelimiter, Mutability, StrLit, Unsafe};\n use rustc_ast::{Visibility, VisibilityKind};\n use rustc_ast_pretty::pprust;\n@@ -1228,7 +1228,7 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    pub fn collect_tokens_no_attrs<R: HasTokens>(\n+    pub fn collect_tokens_no_attrs<R: AstLike>(\n         &mut self,\n         f: impl FnOnce(&mut Self) -> PResult<'a, R>,\n     ) -> PResult<'a, R> {"}, {"sha": "07746f2390dd94f2fa6c81d8146ec121c0ce0877", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e863eb59a10fb0900d7377524a0dc7bf44b9ae3/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e863eb59a10fb0900d7377524a0dc7bf44b9ae3/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=8e863eb59a10fb0900d7377524a0dc7bf44b9ae3", "patch": "@@ -8,10 +8,10 @@ use super::{AttrWrapper, BlockMode, ForceCollect, Parser, Restrictions, SemiColo\n use crate::maybe_whole;\n \n use rustc_ast as ast;\n-use rustc_ast::attr::HasAttrs;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, TokenKind};\n use rustc_ast::util::classify;\n+use rustc_ast::AstLike;\n use rustc_ast::{AttrStyle, AttrVec, Attribute, MacCall, MacCallStmt, MacStmtStyle};\n use rustc_ast::{Block, BlockCheckMode, Expr, ExprKind, Local, Stmt, StmtKind, DUMMY_NODE_ID};\n use rustc_errors::{Applicability, PResult};"}]}