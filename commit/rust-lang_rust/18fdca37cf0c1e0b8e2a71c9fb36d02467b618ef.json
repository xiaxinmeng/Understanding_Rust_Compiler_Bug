{"sha": "18fdca37cf0c1e0b8e2a71c9fb36d02467b618ef", "node_id": "C_kwDOAAsO6NoAKDE4ZmRjYTM3Y2YwYzFlMGI4ZTJhNzFjOWZiMzZkMDI0NjdiNjE4ZWY", "commit": {"author": {"name": "Esme Yi", "email": "onelirong@gmail.com", "date": "2023-05-23T08:23:59Z"}, "committer": {"name": "Esme Yi", "email": "onelirong@gmail.com", "date": "2023-05-23T08:23:59Z"}, "message": "Support rust metadata for AIX.", "tree": {"sha": "6e9f74d089a881c9ecc125a647b1f7530e18a9a0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e9f74d089a881c9ecc125a647b1f7530e18a9a0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18fdca37cf0c1e0b8e2a71c9fb36d02467b618ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18fdca37cf0c1e0b8e2a71c9fb36d02467b618ef", "html_url": "https://github.com/rust-lang/rust/commit/18fdca37cf0c1e0b8e2a71c9fb36d02467b618ef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18fdca37cf0c1e0b8e2a71c9fb36d02467b618ef/comments", "author": {"login": "EsmeYi", "id": 33888773, "node_id": "MDQ6VXNlcjMzODg4Nzcz", "avatar_url": "https://avatars.githubusercontent.com/u/33888773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/EsmeYi", "html_url": "https://github.com/EsmeYi", "followers_url": "https://api.github.com/users/EsmeYi/followers", "following_url": "https://api.github.com/users/EsmeYi/following{/other_user}", "gists_url": "https://api.github.com/users/EsmeYi/gists{/gist_id}", "starred_url": "https://api.github.com/users/EsmeYi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/EsmeYi/subscriptions", "organizations_url": "https://api.github.com/users/EsmeYi/orgs", "repos_url": "https://api.github.com/users/EsmeYi/repos", "events_url": "https://api.github.com/users/EsmeYi/events{/privacy}", "received_events_url": "https://api.github.com/users/EsmeYi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "EsmeYi", "id": 33888773, "node_id": "MDQ6VXNlcjMzODg4Nzcz", "avatar_url": "https://avatars.githubusercontent.com/u/33888773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/EsmeYi", "html_url": "https://github.com/EsmeYi", "followers_url": "https://api.github.com/users/EsmeYi/followers", "following_url": "https://api.github.com/users/EsmeYi/following{/other_user}", "gists_url": "https://api.github.com/users/EsmeYi/gists{/gist_id}", "starred_url": "https://api.github.com/users/EsmeYi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/EsmeYi/subscriptions", "organizations_url": "https://api.github.com/users/EsmeYi/orgs", "repos_url": "https://api.github.com/users/EsmeYi/repos", "events_url": "https://api.github.com/users/EsmeYi/events{/privacy}", "received_events_url": "https://api.github.com/users/EsmeYi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4400d8fce79ab2a610f05479413397464052e9c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4400d8fce79ab2a610f05479413397464052e9c0", "html_url": "https://github.com/rust-lang/rust/commit/4400d8fce79ab2a610f05479413397464052e9c0"}], "stats": {"total": 151, "additions": 139, "deletions": 12}, "files": [{"sha": "984efa21044469bc932fdba929161e0a49bc6b19", "filename": "compiler/rustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/18fdca37cf0c1e0b8e2a71c9fb36d02467b618ef/compiler%2Frustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/18fdca37cf0c1e0b8e2a71c9fb36d02467b618ef/compiler%2Frustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2FCargo.toml?ref=18fdca37cf0c1e0b8e2a71c9fb36d02467b618ef", "patch": "@@ -48,7 +48,7 @@ libc = \"0.2.50\"\n [dependencies.object]\n version = \"0.31.1\"\n default-features = false\n-features = [\"read_core\", \"elf\", \"macho\", \"pe\", \"unaligned\", \"archive\", \"write\"]\n+features = [\"read_core\", \"elf\", \"macho\", \"pe\", \"xcoff\", \"unaligned\", \"archive\", \"write\"]\n \n [target.'cfg(windows)'.dependencies.windows]\n version = \"0.48.0\""}, {"sha": "9f0ca3863bb609adf9c4e6456ccb6e73424534cb", "filename": "compiler/rustc_codegen_ssa/src/back/metadata.rs", "status": "modified", "additions": 138, "deletions": 11, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/18fdca37cf0c1e0b8e2a71c9fb36d02467b618ef/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18fdca37cf0c1e0b8e2a71c9fb36d02467b618ef/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fmetadata.rs?ref=18fdca37cf0c1e0b8e2a71c9fb36d02467b618ef", "patch": "@@ -6,8 +6,8 @@ use std::path::Path;\n \n use object::write::{self, StandardSegment, Symbol, SymbolSection};\n use object::{\n-    elf, pe, Architecture, BinaryFormat, Endianness, FileFlags, Object, ObjectSection,\n-    SectionFlags, SectionKind, SymbolFlags, SymbolKind, SymbolScope,\n+    elf, pe, xcoff, Architecture, BinaryFormat, Endianness, FileFlags, Object, ObjectSection,\n+    ObjectSymbol, SectionFlags, SectionKind, SymbolFlags, SymbolKind, SymbolScope,\n };\n \n use snap::write::FrameEncoder;\n@@ -35,6 +35,8 @@ use rustc_target::spec::{RelocModel, Target};\n #[derive(Debug)]\n pub struct DefaultMetadataLoader;\n \n+static AIX_METADATA_SYMBOL_NAME: &'static str = \"__aix_rust_metadata\";\n+\n fn load_metadata_with(\n     path: &Path,\n     f: impl for<'a> FnOnce(&'a [u8]) -> Result<&'a [u8], String>,\n@@ -48,7 +50,7 @@ fn load_metadata_with(\n }\n \n impl MetadataLoader for DefaultMetadataLoader {\n-    fn get_rlib_metadata(&self, _target: &Target, path: &Path) -> Result<OwnedSlice, String> {\n+    fn get_rlib_metadata(&self, target: &Target, path: &Path) -> Result<OwnedSlice, String> {\n         load_metadata_with(path, |data| {\n             let archive = object::read::archive::ArchiveFile::parse(&*data)\n                 .map_err(|e| format!(\"failed to parse rlib '{}': {}\", path.display(), e))?;\n@@ -60,16 +62,24 @@ impl MetadataLoader for DefaultMetadataLoader {\n                     let data = entry\n                         .data(data)\n                         .map_err(|e| format!(\"failed to parse rlib '{}': {}\", path.display(), e))?;\n-                    return search_for_section(path, data, \".rmeta\");\n+                    if target.is_like_aix {\n+                        return get_metadata_xcoff(path, data);\n+                    } else {\n+                        return search_for_section(path, data, \".rmeta\");\n+                    }\n                 }\n             }\n \n             Err(format!(\"metadata not found in rlib '{}'\", path.display()))\n         })\n     }\n \n-    fn get_dylib_metadata(&self, _target: &Target, path: &Path) -> Result<OwnedSlice, String> {\n-        load_metadata_with(path, |data| search_for_section(path, data, \".rustc\"))\n+    fn get_dylib_metadata(&self, target: &Target, path: &Path) -> Result<OwnedSlice, String> {\n+        if target.is_like_aix {\n+            load_metadata_with(path, |data| get_metadata_xcoff(path, data))\n+        } else {\n+            load_metadata_with(path, |data| search_for_section(path, data, \".rustc\"))\n+        }\n     }\n }\n \n@@ -141,6 +151,33 @@ fn add_gnu_property_note(\n     file.append_section_data(section, &data, 8);\n }\n \n+pub(super) fn get_metadata_xcoff<'a>(path: &Path, data: &'a [u8]) -> Result<&'a [u8], String> {\n+    let Ok(file) = object::File::parse(data) else {\n+        return Ok(data);\n+    };\n+    let info_data = search_for_section(path, data, \".info\")?;\n+    if let Some(metadata_symbol) =\n+        file.symbols().find(|sym| sym.name() == Ok(AIX_METADATA_SYMBOL_NAME))\n+    {\n+        let offset = metadata_symbol.address() as usize;\n+        if offset < 4 {\n+            return Err(format!(\"Invalid metadata symbol offset: {}\", offset));\n+        }\n+        // The offset specifies the location of rustc metadata in the comment section.\n+        // The metadata is preceded by a 4-byte length field.\n+        let len = u32::from_be_bytes(info_data[(offset - 4)..offset].try_into().unwrap()) as usize;\n+        if offset + len > (info_data.len() as usize) {\n+            return Err(format!(\n+                \"Metadata at offset {} with size {} is beyond .info section\",\n+                offset, len\n+            ));\n+        }\n+        return Ok(&info_data[offset..(offset + len)]);\n+    } else {\n+        return Err(format!(\"Unable to find symbol {}\", AIX_METADATA_SYMBOL_NAME));\n+    };\n+}\n+\n pub(crate) fn create_object_file(sess: &Session) -> Option<write::Object<'static>> {\n     let endianness = match sess.target.options.endian {\n         Endian::Little => Endianness::Little,\n@@ -183,6 +220,8 @@ pub(crate) fn create_object_file(sess: &Session) -> Option<write::Object<'static\n         BinaryFormat::MachO\n     } else if sess.target.is_like_windows {\n         BinaryFormat::Coff\n+    } else if sess.target.is_like_aix {\n+        BinaryFormat::Xcoff\n     } else {\n         BinaryFormat::Elf\n     };\n@@ -319,11 +358,15 @@ pub fn create_wrapper_file(\n         // to add a case above.\n         return (data.to_vec(), MetadataPosition::Last);\n     };\n-    let section = file.add_section(\n-        file.segment_name(StandardSegment::Debug).to_vec(),\n-        section_name,\n-        SectionKind::Debug,\n-    );\n+    let section = if file.format() == BinaryFormat::Xcoff {\n+        file.add_section(Vec::new(), b\".info\".to_vec(), SectionKind::Debug)\n+    } else {\n+        file.add_section(\n+            file.segment_name(StandardSegment::Debug).to_vec(),\n+            section_name,\n+            SectionKind::Debug,\n+        )\n+    };\n     match file.format() {\n         BinaryFormat::Coff => {\n             file.section_mut(section).flags =\n@@ -333,6 +376,30 @@ pub fn create_wrapper_file(\n             file.section_mut(section).flags =\n                 SectionFlags::Elf { sh_flags: elf::SHF_EXCLUDE as u64 };\n         }\n+        BinaryFormat::Xcoff => {\n+            file.add_section(Vec::new(), b\".text\".to_vec(), SectionKind::Text);\n+            file.section_mut(section).flags =\n+                SectionFlags::Xcoff { s_flags: xcoff::STYP_INFO as u32 };\n+\n+            let len = data.len() as u32;\n+            let offset = file.append_section_data(section, &len.to_be_bytes(), 1);\n+            // Add a symbol referring to the data in .info section.\n+            file.add_symbol(Symbol {\n+                name: AIX_METADATA_SYMBOL_NAME.into(),\n+                value: offset + 4,\n+                size: 0,\n+                kind: SymbolKind::Unknown,\n+                scope: SymbolScope::Dynamic,\n+                weak: false,\n+                section: SymbolSection::Section(section),\n+                flags: SymbolFlags::Xcoff {\n+                    n_sclass: xcoff::C_INFO,\n+                    x_smtyp: xcoff::C_HIDEXT,\n+                    x_smclas: xcoff::C_HIDEXT,\n+                    containing_csect: None,\n+                },\n+            });\n+        }\n         _ => {}\n     };\n     file.append_section_data(section, data, 1);\n@@ -369,6 +436,9 @@ pub fn create_compressed_metadata_file(\n     let Some(mut file) = create_object_file(sess) else {\n         return compressed.to_vec();\n     };\n+    if file.format() == BinaryFormat::Xcoff {\n+        return create_compressed_metadata_file_for_xcoff(file, &compressed, symbol_name);\n+    }\n     let section = file.add_section(\n         file.segment_name(StandardSegment::Data).to_vec(),\n         b\".rustc\".to_vec(),\n@@ -398,3 +468,60 @@ pub fn create_compressed_metadata_file(\n \n     file.write().unwrap()\n }\n+\n+/// * Xcoff - On AIX, custom sections are merged into predefined sections,\n+///   so custom .rustc section is not preserved during linking.\n+///   For this reason, we store metadata in predefined .info section, and\n+///   define a symbol to reference the metadata. To preserve metadata during\n+///   linking on AIX, we have to\n+///   1. Create an empty .text section, a empty .data section.\n+///   2. Define an empty symbol named `symbol_name` inside .data section.\n+///   3. Define an symbol named `AIX_METADATA_SYMBOL_NAME` referencing\n+///      data inside .info section.\n+///   From XCOFF's view, (2) creates a csect entry in the symbol table, the\n+///   symbol created by (3) is a info symbol for the preceding csect. Thus\n+///   two symbols are preserved during linking and we can use the second symbol\n+///   to reference the metadata.\n+pub fn create_compressed_metadata_file_for_xcoff(\n+    mut file: write::Object<'_>,\n+    data: &[u8],\n+    symbol_name: &str,\n+) -> Vec<u8> {\n+    assert!(file.format() == BinaryFormat::Xcoff);\n+    file.add_section(Vec::new(), b\".text\".to_vec(), SectionKind::Text);\n+    let data_section = file.add_section(Vec::new(), b\".data\".to_vec(), SectionKind::Data);\n+    let section = file.add_section(Vec::new(), b\".info\".to_vec(), SectionKind::Debug);\n+    file.add_file_symbol(\"lib.rmeta\".into());\n+    file.section_mut(section).flags = SectionFlags::Xcoff { s_flags: xcoff::STYP_INFO as u32 };\n+    // Add a global symbol to data_section.\n+    file.add_symbol(Symbol {\n+        name: symbol_name.as_bytes().into(),\n+        value: 0,\n+        size: 0,\n+        kind: SymbolKind::Data,\n+        scope: SymbolScope::Dynamic,\n+        weak: true,\n+        section: SymbolSection::Section(data_section),\n+        flags: SymbolFlags::None,\n+    });\n+    let len = data.len() as u32;\n+    let offset = file.append_section_data(section, &len.to_be_bytes(), 1);\n+    // Add a symbol referring to the rustc metadata.\n+    file.add_symbol(Symbol {\n+        name: AIX_METADATA_SYMBOL_NAME.into(),\n+        value: offset + 4, // The metadata is preceded by a 4-byte length field.\n+        size: 0,\n+        kind: SymbolKind::Unknown,\n+        scope: SymbolScope::Dynamic,\n+        weak: false,\n+        section: SymbolSection::Section(section),\n+        flags: SymbolFlags::Xcoff {\n+            n_sclass: xcoff::C_INFO,\n+            x_smtyp: xcoff::C_HIDEXT,\n+            x_smclas: xcoff::C_HIDEXT,\n+            containing_csect: None,\n+        },\n+    });\n+    file.append_section_data(section, data, 1);\n+    file.write().unwrap()\n+}"}]}