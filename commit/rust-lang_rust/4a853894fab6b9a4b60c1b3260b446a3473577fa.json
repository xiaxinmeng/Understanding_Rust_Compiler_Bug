{"sha": "4a853894fab6b9a4b60c1b3260b446a3473577fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhODUzODk0ZmFiNmI5YTRiNjBjMWIzMjYwYjQ0NmEzNDczNTc3ZmE=", "commit": {"author": {"name": "Ben Striegel", "email": "ben.striegel@gmail.com", "date": "2013-02-22T06:41:37Z"}, "committer": {"name": "Ben Striegel", "email": "ben.striegel@gmail.com", "date": "2013-02-22T06:42:03Z"}, "message": "De-implicit-self librustc", "tree": {"sha": "eb3fb03bd4f82c2d882c21da84ea749583b295df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb3fb03bd4f82c2d882c21da84ea749583b295df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a853894fab6b9a4b60c1b3260b446a3473577fa", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a853894fab6b9a4b60c1b3260b446a3473577fa", "html_url": "https://github.com/rust-lang/rust/commit/4a853894fab6b9a4b60c1b3260b446a3473577fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a853894fab6b9a4b60c1b3260b446a3473577fa/comments", "author": {"login": "bstrie", "id": 865233, "node_id": "MDQ6VXNlcjg2NTIzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/865233?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bstrie", "html_url": "https://github.com/bstrie", "followers_url": "https://api.github.com/users/bstrie/followers", "following_url": "https://api.github.com/users/bstrie/following{/other_user}", "gists_url": "https://api.github.com/users/bstrie/gists{/gist_id}", "starred_url": "https://api.github.com/users/bstrie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bstrie/subscriptions", "organizations_url": "https://api.github.com/users/bstrie/orgs", "repos_url": "https://api.github.com/users/bstrie/repos", "events_url": "https://api.github.com/users/bstrie/events{/privacy}", "received_events_url": "https://api.github.com/users/bstrie/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bstrie", "id": 865233, "node_id": "MDQ6VXNlcjg2NTIzMw==", "avatar_url": "https://avatars.githubusercontent.com/u/865233?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bstrie", "html_url": "https://github.com/bstrie", "followers_url": "https://api.github.com/users/bstrie/followers", "following_url": "https://api.github.com/users/bstrie/following{/other_user}", "gists_url": "https://api.github.com/users/bstrie/gists{/gist_id}", "starred_url": "https://api.github.com/users/bstrie/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bstrie/subscriptions", "organizations_url": "https://api.github.com/users/bstrie/orgs", "repos_url": "https://api.github.com/users/bstrie/repos", "events_url": "https://api.github.com/users/bstrie/events{/privacy}", "received_events_url": "https://api.github.com/users/bstrie/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cec1f38c309b743b29a386ce71db1b1035ccd89d", "url": "https://api.github.com/repos/rust-lang/rust/commits/cec1f38c309b743b29a386ce71db1b1035ccd89d", "html_url": "https://github.com/rust-lang/rust/commit/cec1f38c309b743b29a386ce71db1b1035ccd89d"}], "stats": {"total": 1195, "additions": 626, "deletions": 569}, "files": [{"sha": "bd35bf50cefc09f230675c9301f5f72201159832", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 48, "deletions": 38, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=4a853894fab6b9a4b60c1b3260b446a3473577fa", "patch": "@@ -165,49 +165,49 @@ pub struct Session_ {\n pub type Session = @Session_;\n \n pub impl Session {\n-    fn span_fatal(sp: span, msg: ~str) -> ! {\n+    fn span_fatal(&self, sp: span, msg: ~str) -> ! {\n         self.span_diagnostic.span_fatal(sp, msg)\n     }\n-    fn fatal(msg: ~str) -> ! {\n+    fn fatal(&self, msg: ~str) -> ! {\n         self.span_diagnostic.handler().fatal(msg)\n     }\n-    fn span_err(sp: span, msg: ~str) {\n+    fn span_err(&self, sp: span, msg: ~str) {\n         self.span_diagnostic.span_err(sp, msg)\n     }\n-    fn err(msg: ~str) {\n+    fn err(&self, msg: ~str) {\n         self.span_diagnostic.handler().err(msg)\n     }\n-    fn has_errors() -> bool {\n+    fn has_errors(&self) -> bool {\n         self.span_diagnostic.handler().has_errors()\n     }\n-    fn abort_if_errors() {\n+    fn abort_if_errors(&self) {\n         self.span_diagnostic.handler().abort_if_errors()\n     }\n-    fn span_warn(sp: span, msg: ~str) {\n+    fn span_warn(&self, sp: span, msg: ~str) {\n         self.span_diagnostic.span_warn(sp, msg)\n     }\n-    fn warn(msg: ~str) {\n+    fn warn(&self, msg: ~str) {\n         self.span_diagnostic.handler().warn(msg)\n     }\n-    fn span_note(sp: span, msg: ~str) {\n+    fn span_note(&self, sp: span, msg: ~str) {\n         self.span_diagnostic.span_note(sp, msg)\n     }\n-    fn note(msg: ~str) {\n+    fn note(&self, msg: ~str) {\n         self.span_diagnostic.handler().note(msg)\n     }\n-    fn span_bug(sp: span, msg: ~str) -> ! {\n+    fn span_bug(&self, sp: span, msg: ~str) -> ! {\n         self.span_diagnostic.span_bug(sp, msg)\n     }\n-    fn bug(msg: ~str) -> ! {\n+    fn bug(&self, msg: ~str) -> ! {\n         self.span_diagnostic.handler().bug(msg)\n     }\n-    fn span_unimpl(sp: span, msg: ~str) -> ! {\n+    fn span_unimpl(&self, sp: span, msg: ~str) -> ! {\n         self.span_diagnostic.span_unimpl(sp, msg)\n     }\n-    fn unimpl(msg: ~str) -> ! {\n+    fn unimpl(&self, msg: ~str) -> ! {\n         self.span_diagnostic.handler().unimpl(msg)\n     }\n-    fn span_lint_level(level: lint::level, sp: span, +msg: ~str) {\n+    fn span_lint_level(&self, level: lint::level, sp: span, +msg: ~str) {\n         match level {\n           lint::allow => { },\n           lint::warn => self.span_warn(sp, msg),\n@@ -216,7 +216,7 @@ pub impl Session {\n           }\n         }\n     }\n-    fn span_lint(lint_mode: lint::lint,\n+    fn span_lint(&self, lint_mode: lint::lint,\n                  expr_id: ast::node_id,\n                  item_id: ast::node_id,\n                  span: span,\n@@ -225,45 +225,55 @@ pub impl Session {\n             self.lint_settings, lint_mode, expr_id, item_id);\n         self.span_lint_level(level, span, msg);\n     }\n-    fn next_node_id() -> ast::node_id {\n+    fn next_node_id(&self) -> ast::node_id {\n         return syntax::parse::next_node_id(self.parse_sess);\n     }\n-    fn diagnostic() -> diagnostic::span_handler {\n+    fn diagnostic(&self) -> diagnostic::span_handler {\n         self.span_diagnostic\n     }\n-    fn debugging_opt(opt: uint) -> bool {\n+    fn debugging_opt(&self, opt: uint) -> bool {\n         (self.opts.debugging_opts & opt) != 0u\n     }\n     // This exists to help with refactoring to eliminate impossible\n     // cases later on\n-    fn impossible_case(sp: span, msg: &str) -> ! {\n+    fn impossible_case(&self, sp: span, msg: &str) -> ! {\n         self.span_bug(sp, fmt!(\"Impossible case reached: %s\", msg));\n     }\n-    fn verbose() -> bool { self.debugging_opt(verbose) }\n-    fn time_passes() -> bool { self.debugging_opt(time_passes) }\n-    fn count_llvm_insns() -> bool { self.debugging_opt(count_llvm_insns) }\n-    fn count_type_sizes() -> bool { self.debugging_opt(count_type_sizes) }\n-    fn time_llvm_passes() -> bool { self.debugging_opt(time_llvm_passes) }\n-    fn trans_stats() -> bool { self.debugging_opt(trans_stats) }\n-    fn meta_stats() -> bool { self.debugging_opt(meta_stats) }\n-    fn no_asm_comments() -> bool { self.debugging_opt(no_asm_comments) }\n-    fn no_verify() -> bool { self.debugging_opt(no_verify) }\n-    fn trace() -> bool { self.debugging_opt(trace) }\n-    fn coherence() -> bool { self.debugging_opt(coherence) }\n-    fn borrowck_stats() -> bool { self.debugging_opt(borrowck_stats) }\n-    fn borrowck_note_pure() -> bool { self.debugging_opt(borrowck_note_pure) }\n-    fn borrowck_note_loan() -> bool { self.debugging_opt(borrowck_note_loan) }\n-    fn no_monomorphic_collapse() -> bool {\n+    fn verbose(&self) -> bool { self.debugging_opt(verbose) }\n+    fn time_passes(&self) -> bool { self.debugging_opt(time_passes) }\n+    fn count_llvm_insns(&self) -> bool {\n+        self.debugging_opt(count_llvm_insns)\n+    }\n+    fn count_type_sizes(&self) -> bool {\n+        self.debugging_opt(count_type_sizes)\n+    }\n+    fn time_llvm_passes(&self) -> bool {\n+        self.debugging_opt(time_llvm_passes)\n+    }\n+    fn trans_stats(&self) -> bool { self.debugging_opt(trans_stats) }\n+    fn meta_stats(&self) -> bool { self.debugging_opt(meta_stats) }\n+    fn no_asm_comments(&self) -> bool { self.debugging_opt(no_asm_comments) }\n+    fn no_verify(&self) -> bool { self.debugging_opt(no_verify) }\n+    fn trace(&self) -> bool { self.debugging_opt(trace) }\n+    fn coherence(&self) -> bool { self.debugging_opt(coherence) }\n+    fn borrowck_stats(&self) -> bool { self.debugging_opt(borrowck_stats) }\n+    fn borrowck_note_pure(&self) -> bool {\n+        self.debugging_opt(borrowck_note_pure)\n+    }\n+    fn borrowck_note_loan(&self) -> bool {\n+        self.debugging_opt(borrowck_note_loan)\n+    }\n+    fn no_monomorphic_collapse(&self) -> bool {\n         self.debugging_opt(no_monomorphic_collapse)\n     }\n \n-    fn str_of(id: ast::ident) -> @~str {\n+    fn str_of(&self, id: ast::ident) -> @~str {\n         self.parse_sess.interner.get(id)\n     }\n-    fn ident_of(+st: ~str) -> ast::ident {\n+    fn ident_of(&self, +st: ~str) -> ast::ident {\n         self.parse_sess.interner.intern(@st)\n     }\n-    fn intr() -> @syntax::parse::token::ident_interner {\n+    fn intr(&self) -> @syntax::parse::token::ident_interner {\n         self.parse_sess.interner\n     }\n }"}, {"sha": "82ea0b6d6f1866fa5283ed1dee37b71f1f7e5ee4", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=4a853894fab6b9a4b60c1b3260b446a3473577fa", "patch": "@@ -29,10 +29,10 @@ pub fn pick_file(file: Path, path: &Path) -> Option<Path> {\n }\n \n pub trait FileSearch {\n-    fn sysroot() -> Path;\n-    fn lib_search_paths() -> ~[Path];\n-    fn get_target_lib_path() -> Path;\n-    fn get_target_lib_file_path(file: &Path) -> Path;\n+    fn sysroot(&self) -> Path;\n+    fn lib_search_paths(&self) -> ~[Path];\n+    fn get_target_lib_path(&self) -> Path;\n+    fn get_target_lib_file_path(&self, file: &Path) -> Path;\n }\n \n pub fn mk_filesearch(maybe_sysroot: Option<Path>,\n@@ -44,8 +44,8 @@ pub fn mk_filesearch(maybe_sysroot: Option<Path>,\n         target_triple: ~str\n     }\n     impl FileSearch for FileSearchImpl {\n-        fn sysroot() -> Path { /*bad*/copy self.sysroot }\n-        fn lib_search_paths() -> ~[Path] {\n+        fn sysroot(&self) -> Path { /*bad*/copy self.sysroot }\n+        fn lib_search_paths(&self) -> ~[Path] {\n             let mut paths = /*bad*/copy self.addl_lib_search_paths;\n \n             paths.push(\n@@ -61,10 +61,10 @@ pub fn mk_filesearch(maybe_sysroot: Option<Path>,\n             }\n             paths\n         }\n-        fn get_target_lib_path() -> Path {\n+        fn get_target_lib_path(&self) -> Path {\n             make_target_lib_path(&self.sysroot, self.target_triple)\n         }\n-        fn get_target_lib_file_path(file: &Path) -> Path {\n+        fn get_target_lib_file_path(&self, file: &Path) -> Path {\n             self.get_target_lib_path().push_rel(file)\n         }\n     }"}, {"sha": "0b1abd683b122892061b30db519a91585756f5b7", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 98, "deletions": 87, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=4a853894fab6b9a4b60c1b3260b446a3473577fa", "patch": "@@ -75,11 +75,11 @@ struct ExtendedDecodeContext {\n }\n \n trait tr {\n-    fn tr(xcx: @ExtendedDecodeContext) -> Self;\n+    fn tr(&self, xcx: @ExtendedDecodeContext) -> Self;\n }\n \n trait tr_intern {\n-    fn tr_intern(xcx: @ExtendedDecodeContext) -> ast::def_id;\n+    fn tr_intern(&self, xcx: @ExtendedDecodeContext) -> ast::def_id;\n }\n \n // ______________________________________________________________________\n@@ -227,41 +227,41 @@ impl ExtendedDecodeContext {\n }\n \n impl tr_intern for ast::def_id {\n-    fn tr_intern(xcx: @ExtendedDecodeContext) -> ast::def_id {\n-        xcx.tr_intern_def_id(self)\n+    fn tr_intern(&self, xcx: @ExtendedDecodeContext) -> ast::def_id {\n+        xcx.tr_intern_def_id(*self)\n     }\n }\n \n impl tr for ast::def_id {\n-    fn tr(xcx: @ExtendedDecodeContext) -> ast::def_id {\n-        xcx.tr_def_id(self)\n+    fn tr(&self, xcx: @ExtendedDecodeContext) -> ast::def_id {\n+        xcx.tr_def_id(*self)\n     }\n }\n \n impl tr for span {\n-    fn tr(xcx: @ExtendedDecodeContext) -> span {\n-        xcx.tr_span(self)\n+    fn tr(&self, xcx: @ExtendedDecodeContext) -> span {\n+        xcx.tr_span(*self)\n     }\n }\n \n trait def_id_encoder_helpers {\n-    fn emit_def_id(did: ast::def_id);\n+    fn emit_def_id(&self, did: ast::def_id);\n }\n \n impl<S:serialize::Encoder> def_id_encoder_helpers for S {\n-    fn emit_def_id(did: ast::def_id) {\n-        did.encode(&self)\n+    fn emit_def_id(&self, did: ast::def_id) {\n+        did.encode(self)\n     }\n }\n \n trait def_id_decoder_helpers {\n-    fn read_def_id(xcx: @ExtendedDecodeContext) -> ast::def_id;\n+    fn read_def_id(&self, xcx: @ExtendedDecodeContext) -> ast::def_id;\n }\n \n impl<D:serialize::Decoder> def_id_decoder_helpers for D {\n \n-    fn read_def_id(xcx: @ExtendedDecodeContext) -> ast::def_id {\n-        let did: ast::def_id = Decodable::decode(&self);\n+    fn read_def_id(&self, xcx: @ExtendedDecodeContext) -> ast::def_id {\n+        let did: ast::def_id = Decodable::decode(self);\n         did.tr(xcx)\n     }\n }\n@@ -405,8 +405,8 @@ fn decode_def(xcx: @ExtendedDecodeContext, doc: ebml::Doc) -> ast::def {\n }\n \n impl tr for ast::def {\n-    fn tr(xcx: @ExtendedDecodeContext) -> ast::def {\n-        match self {\n+    fn tr(&self, xcx: @ExtendedDecodeContext) -> ast::def {\n+        match *self {\n           ast::def_fn(did, p) => { ast::def_fn(did.tr(xcx), p) }\n           ast::def_static_method(did, did2_opt, p) => {\n             ast::def_static_method(did.tr(xcx),\n@@ -450,7 +450,7 @@ impl tr for ast::def {\n // Encoding and decoding of adjustment information\n \n impl tr for ty::AutoAdjustment {\n-    fn tr(xcx: @ExtendedDecodeContext) -> ty::AutoAdjustment {\n+    fn tr(&self, xcx: @ExtendedDecodeContext) -> ty::AutoAdjustment {\n         ty::AutoAdjustment {\n             autoderefs: self.autoderefs,\n             autoref: self.autoref.map(|ar| ar.tr(xcx)),\n@@ -459,7 +459,7 @@ impl tr for ty::AutoAdjustment {\n }\n \n impl tr for ty::AutoRef {\n-    fn tr(xcx: @ExtendedDecodeContext) -> ty::AutoRef {\n+    fn tr(&self, xcx: @ExtendedDecodeContext) -> ty::AutoRef {\n         ty::AutoRef {\n             kind: self.kind,\n             region: self.region.tr(xcx),\n@@ -469,21 +469,21 @@ impl tr for ty::AutoRef {\n }\n \n impl tr for ty::Region {\n-    fn tr(xcx: @ExtendedDecodeContext) -> ty::Region {\n-        match self {\n+    fn tr(&self, xcx: @ExtendedDecodeContext) -> ty::Region {\n+        match *self {\n             ty::re_bound(br) => ty::re_bound(br.tr(xcx)),\n             ty::re_free(id, br) => ty::re_free(xcx.tr_id(id), br.tr(xcx)),\n             ty::re_scope(id) => ty::re_scope(xcx.tr_id(id)),\n-            ty::re_static | ty::re_infer(*) => self,\n+            ty::re_static | ty::re_infer(*) => *self,\n         }\n     }\n }\n \n impl tr for ty::bound_region {\n-    fn tr(xcx: @ExtendedDecodeContext) -> ty::bound_region {\n-        match self {\n+    fn tr(&self, xcx: @ExtendedDecodeContext) -> ty::bound_region {\n+        match *self {\n             ty::br_anon(_) | ty::br_named(_) | ty::br_self |\n-            ty::br_fresh(_) => self,\n+            ty::br_fresh(_) => *self,\n             ty::br_cap_avoid(id, br) => ty::br_cap_avoid(xcx.tr_id(id),\n                                                          @br.tr(xcx))\n         }\n@@ -498,18 +498,20 @@ fn encode_freevar_entry(ebml_w: writer::Encoder, fv: @freevar_entry) {\n }\n \n trait ebml_decoder_helper {\n-    fn read_freevar_entry(xcx: @ExtendedDecodeContext) -> freevar_entry;\n+    fn read_freevar_entry(&self, xcx: @ExtendedDecodeContext)\n+                         -> freevar_entry;\n }\n \n impl ebml_decoder_helper for reader::Decoder {\n-    fn read_freevar_entry(xcx: @ExtendedDecodeContext) -> freevar_entry {\n-        let fv: freevar_entry = Decodable::decode(&self);\n+    fn read_freevar_entry(&self, xcx: @ExtendedDecodeContext)\n+                         -> freevar_entry {\n+        let fv: freevar_entry = Decodable::decode(self);\n         fv.tr(xcx)\n     }\n }\n \n impl tr for freevar_entry {\n-    fn tr(xcx: @ExtendedDecodeContext) -> freevar_entry {\n+    fn tr(&self, xcx: @ExtendedDecodeContext) -> freevar_entry {\n         freevar_entry {\n             def: self.def.tr(xcx),\n             span: self.span.tr(xcx),\n@@ -521,18 +523,20 @@ impl tr for freevar_entry {\n // Encoding and decoding of CaptureVar information\n \n trait capture_var_helper {\n-    fn read_capture_var(xcx: @ExtendedDecodeContext) -> moves::CaptureVar;\n+    fn read_capture_var(&self, xcx: @ExtendedDecodeContext)\n+                       -> moves::CaptureVar;\n }\n \n impl capture_var_helper for reader::Decoder {\n-    fn read_capture_var(xcx: @ExtendedDecodeContext) -> moves::CaptureVar {\n-        let cvar: moves::CaptureVar = Decodable::decode(&self);\n+    fn read_capture_var(&self, xcx: @ExtendedDecodeContext)\n+                       -> moves::CaptureVar {\n+        let cvar: moves::CaptureVar = Decodable::decode(self);\n         cvar.tr(xcx)\n     }\n }\n \n impl tr for moves::CaptureVar {\n-    fn tr(xcx: @ExtendedDecodeContext) -> moves::CaptureVar {\n+    fn tr(&self, xcx: @ExtendedDecodeContext) -> moves::CaptureVar {\n         moves::CaptureVar {\n             def: self.def.tr(xcx),\n             span: self.span.tr(xcx),\n@@ -545,7 +549,8 @@ impl tr for moves::CaptureVar {\n // Encoding and decoding of method_map_entry\n \n trait read_method_map_entry_helper {\n-    fn read_method_map_entry(xcx: @ExtendedDecodeContext) -> method_map_entry;\n+    fn read_method_map_entry(&self, xcx: @ExtendedDecodeContext)\n+                            -> method_map_entry;\n }\n \n fn encode_method_map_entry(ecx: @e::EncodeContext,\n@@ -565,20 +570,20 @@ fn encode_method_map_entry(ecx: @e::EncodeContext,\n }\n \n impl read_method_map_entry_helper for reader::Decoder {\n-    fn read_method_map_entry(xcx: @ExtendedDecodeContext)\n+    fn read_method_map_entry(&self, xcx: @ExtendedDecodeContext)\n         -> method_map_entry {\n         do self.read_rec {\n             method_map_entry {\n                 self_arg: self.read_field(~\"self_arg\", 0u, || {\n                     self.read_arg(xcx)\n                 }),\n                 explicit_self: self.read_field(~\"explicit_self\", 2u, || {\n-                    let self_type: ast::self_ty_ = Decodable::decode(&self);\n+                    let self_type: ast::self_ty_ = Decodable::decode(self);\n                     self_type\n                 }),\n                 origin: self.read_field(~\"origin\", 1u, || {\n                     let method_origin: method_origin =\n-                        Decodable::decode(&self);\n+                        Decodable::decode(self);\n                     method_origin.tr(xcx)\n                 }),\n             }\n@@ -587,8 +592,8 @@ impl read_method_map_entry_helper for reader::Decoder {\n }\n \n impl tr for method_origin {\n-    fn tr(xcx: @ExtendedDecodeContext) -> method_origin {\n-        match self {\n+    fn tr(&self, xcx: @ExtendedDecodeContext) -> method_origin {\n+        match *self {\n           typeck::method_static(did) => {\n               typeck::method_static(did.tr(xcx))\n           }\n@@ -672,17 +677,19 @@ fn encode_vtable_origin(ecx: @e::EncodeContext,\n }\n \n trait vtable_decoder_helpers {\n-    fn read_vtable_res(xcx: @ExtendedDecodeContext) -> typeck::vtable_res;\n-    fn read_vtable_origin(xcx: @ExtendedDecodeContext)\n+    fn read_vtable_res(&self, xcx: @ExtendedDecodeContext)\n+                      -> typeck::vtable_res;\n+    fn read_vtable_origin(&self, xcx: @ExtendedDecodeContext)\n         -> typeck::vtable_origin;\n }\n \n impl vtable_decoder_helpers for reader::Decoder {\n-    fn read_vtable_res(xcx: @ExtendedDecodeContext) -> typeck::vtable_res {\n+    fn read_vtable_res(&self, xcx: @ExtendedDecodeContext)\n+                      -> typeck::vtable_res {\n         @self.read_to_vec(|| self.read_vtable_origin(xcx) )\n     }\n \n-    fn read_vtable_origin(xcx: @ExtendedDecodeContext)\n+    fn read_vtable_origin(&self, xcx: @ExtendedDecodeContext)\n         -> typeck::vtable_origin {\n         do self.read_enum(~\"vtable_origin\") {\n             do self.read_enum_variant |i| {\n@@ -736,6 +743,7 @@ trait get_ty_str_ctxt {\n }\n \n impl get_ty_str_ctxt for @e::EncodeContext {\n+    // IMPLICIT SELF WARNING: fix this!\n     fn ty_str_ctxt() -> @tyencode::ctxt {\n         @tyencode::ctxt {diag: self.tcx.sess.diagnostic(),\n                         ds: e::def_to_str,\n@@ -746,54 +754,56 @@ impl get_ty_str_ctxt for @e::EncodeContext {\n }\n \n trait ebml_writer_helpers {\n-    fn emit_arg(ecx: @e::EncodeContext, arg: ty::arg);\n-    fn emit_ty(ecx: @e::EncodeContext, ty: ty::t);\n-    fn emit_vstore(ecx: @e::EncodeContext, vstore: ty::vstore);\n-    fn emit_tys(ecx: @e::EncodeContext, tys: ~[ty::t]);\n-    fn emit_bounds(ecx: @e::EncodeContext, bs: ty::param_bounds);\n-    fn emit_tpbt(ecx: @e::EncodeContext, tpbt: ty::ty_param_bounds_and_ty);\n+    fn emit_arg(&self, ecx: @e::EncodeContext, arg: ty::arg);\n+    fn emit_ty(&self, ecx: @e::EncodeContext, ty: ty::t);\n+    fn emit_vstore(&self, ecx: @e::EncodeContext, vstore: ty::vstore);\n+    fn emit_tys(&self, ecx: @e::EncodeContext, tys: ~[ty::t]);\n+    fn emit_bounds(&self, ecx: @e::EncodeContext, bs: ty::param_bounds);\n+    fn emit_tpbt(&self, ecx: @e::EncodeContext,\n+                 tpbt: ty::ty_param_bounds_and_ty);\n }\n \n impl ebml_writer_helpers for writer::Encoder {\n-    fn emit_ty(ecx: @e::EncodeContext, ty: ty::t) {\n+    fn emit_ty(&self, ecx: @e::EncodeContext, ty: ty::t) {\n         do self.emit_opaque {\n-            e::write_type(ecx, self, ty)\n+            e::write_type(ecx, *self, ty)\n         }\n     }\n \n-    fn emit_vstore(ecx: @e::EncodeContext, vstore: ty::vstore) {\n+    fn emit_vstore(&self, ecx: @e::EncodeContext, vstore: ty::vstore) {\n         do self.emit_opaque {\n-            e::write_vstore(ecx, self, vstore)\n+            e::write_vstore(ecx, *self, vstore)\n         }\n     }\n \n-    fn emit_arg(ecx: @e::EncodeContext, arg: ty::arg) {\n+    fn emit_arg(&self, ecx: @e::EncodeContext, arg: ty::arg) {\n         do self.emit_opaque {\n             tyencode::enc_arg(self.writer, ecx.ty_str_ctxt(), arg);\n         }\n     }\n \n-    fn emit_tys(ecx: @e::EncodeContext, tys: ~[ty::t]) {\n+    fn emit_tys(&self, ecx: @e::EncodeContext, tys: ~[ty::t]) {\n         do self.emit_from_vec(tys) |ty| {\n             self.emit_ty(ecx, *ty)\n         }\n     }\n \n-    fn emit_bounds(ecx: @e::EncodeContext, bs: ty::param_bounds) {\n+    fn emit_bounds(&self, ecx: @e::EncodeContext, bs: ty::param_bounds) {\n         do self.emit_opaque {\n             tyencode::enc_bounds(self.writer, ecx.ty_str_ctxt(), bs)\n         }\n     }\n \n-    fn emit_tpbt(ecx: @e::EncodeContext, tpbt: ty::ty_param_bounds_and_ty) {\n+    fn emit_tpbt(&self, ecx: @e::EncodeContext,\n+                 tpbt: ty::ty_param_bounds_and_ty) {\n         do self.emit_rec {\n             do self.emit_field(~\"bounds\", 0) {\n                 do self.emit_from_vec(*tpbt.bounds) |bs| {\n                     self.emit_bounds(ecx, *bs);\n                 }\n             }\n             do self.emit_field(~\"region_param\", 1u) {\n-                tpbt.region_param.encode(&self);\n+                tpbt.region_param.encode(self);\n             }\n             do self.emit_field(~\"ty\", 2u) {\n                 self.emit_ty(ecx, tpbt.ty);\n@@ -803,16 +813,16 @@ impl ebml_writer_helpers for writer::Encoder {\n }\n \n trait write_tag_and_id {\n-    fn tag(tag_id: c::astencode_tag, f: fn());\n-    fn id(id: ast::node_id);\n+    fn tag(&self, tag_id: c::astencode_tag, f: fn());\n+    fn id(&self, id: ast::node_id);\n }\n \n impl write_tag_and_id for writer::Encoder {\n-    fn tag(tag_id: c::astencode_tag, f: fn()) {\n+    fn tag(&self, tag_id: c::astencode_tag, f: fn()) {\n         do self.wr_tag(tag_id as uint) { f() }\n     }\n \n-    fn id(id: ast::node_id) {\n+    fn id(&self, id: ast::node_id) {\n         self.wr_tagged_u64(c::tag_table_id as uint, id as u64)\n     }\n }\n@@ -981,39 +991,39 @@ fn encode_side_tables_for_id(ecx: @e::EncodeContext,\n }\n \n trait doc_decoder_helpers {\n-    fn as_int() -> int;\n-    fn opt_child(tag: c::astencode_tag) -> Option<ebml::Doc>;\n+    fn as_int(&self) -> int;\n+    fn opt_child(&self, tag: c::astencode_tag) -> Option<ebml::Doc>;\n }\n \n impl doc_decoder_helpers for ebml::Doc {\n-    fn as_int() -> int { reader::doc_as_u64(self) as int }\n-    fn opt_child(tag: c::astencode_tag) -> Option<ebml::Doc> {\n-        reader::maybe_get_doc(self, tag as uint)\n+    fn as_int(&self) -> int { reader::doc_as_u64(*self) as int }\n+    fn opt_child(&self, tag: c::astencode_tag) -> Option<ebml::Doc> {\n+        reader::maybe_get_doc(*self, tag as uint)\n     }\n }\n \n trait ebml_decoder_decoder_helpers {\n-    fn read_arg(xcx: @ExtendedDecodeContext) -> ty::arg;\n-    fn read_ty(xcx: @ExtendedDecodeContext) -> ty::t;\n-    fn read_tys(xcx: @ExtendedDecodeContext) -> ~[ty::t];\n-    fn read_bounds(xcx: @ExtendedDecodeContext) -> @~[ty::param_bound];\n-    fn read_ty_param_bounds_and_ty(xcx: @ExtendedDecodeContext)\n+    fn read_arg(&self, xcx: @ExtendedDecodeContext) -> ty::arg;\n+    fn read_ty(&self, xcx: @ExtendedDecodeContext) -> ty::t;\n+    fn read_tys(&self, xcx: @ExtendedDecodeContext) -> ~[ty::t];\n+    fn read_bounds(&self, xcx: @ExtendedDecodeContext) -> @~[ty::param_bound];\n+    fn read_ty_param_bounds_and_ty(&self, xcx: @ExtendedDecodeContext)\n                                 -> ty::ty_param_bounds_and_ty;\n-    fn convert_def_id(xcx: @ExtendedDecodeContext,\n+    fn convert_def_id(&self, xcx: @ExtendedDecodeContext,\n                       source: DefIdSource,\n                       did: ast::def_id) -> ast::def_id;\n }\n \n impl ebml_decoder_decoder_helpers for reader::Decoder {\n-    fn read_arg(xcx: @ExtendedDecodeContext) -> ty::arg {\n+    fn read_arg(&self, xcx: @ExtendedDecodeContext) -> ty::arg {\n         do self.read_opaque |doc| {\n             tydecode::parse_arg_data(\n                 doc.data, xcx.dcx.cdata.cnum, doc.start, xcx.dcx.tcx,\n                 |s, a| self.convert_def_id(xcx, s, a))\n         }\n     }\n \n-    fn read_ty(xcx: @ExtendedDecodeContext) -> ty::t {\n+    fn read_ty(&self, xcx: @ExtendedDecodeContext) -> ty::t {\n         // Note: regions types embed local node ids.  In principle, we\n         // should translate these node ids into the new decode\n         // context.  However, we do not bother, because region types\n@@ -1040,19 +1050,20 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n         }\n     }\n \n-    fn read_tys(xcx: @ExtendedDecodeContext) -> ~[ty::t] {\n+    fn read_tys(&self, xcx: @ExtendedDecodeContext) -> ~[ty::t] {\n         self.read_to_vec(|| self.read_ty(xcx) )\n     }\n \n-    fn read_bounds(xcx: @ExtendedDecodeContext) -> @~[ty::param_bound] {\n+    fn read_bounds(&self, xcx: @ExtendedDecodeContext)\n+                  -> @~[ty::param_bound] {\n         do self.read_opaque |doc| {\n             tydecode::parse_bounds_data(\n                 doc.data, doc.start, xcx.dcx.cdata.cnum, xcx.dcx.tcx,\n                 |s, a| self.convert_def_id(xcx, s, a))\n         }\n     }\n \n-    fn read_ty_param_bounds_and_ty(xcx: @ExtendedDecodeContext)\n+    fn read_ty_param_bounds_and_ty(&self, xcx: @ExtendedDecodeContext)\n         -> ty::ty_param_bounds_and_ty\n     {\n         do self.read_rec {\n@@ -1061,7 +1072,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n                     @self.read_to_vec(|| self.read_bounds(xcx) )\n                 }),\n                 region_param: self.read_field(~\"region_param\", 1u, || {\n-                    Decodable::decode(&self)\n+                    Decodable::decode(self)\n                 }),\n                 ty: self.read_field(~\"ty\", 2u, || {\n                     self.read_ty(xcx)\n@@ -1070,7 +1081,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n         }\n     }\n \n-    fn convert_def_id(xcx: @ExtendedDecodeContext,\n+    fn convert_def_id(&self, xcx: @ExtendedDecodeContext,\n                       source: tydecode::DefIdSource,\n                       did: ast::def_id) -> ast::def_id {\n         /*!\n@@ -1192,27 +1203,27 @@ fn decode_item_ast(par_doc: ebml::Doc) -> @ast::item {\n \n #[cfg(test)]\n trait fake_ext_ctxt {\n-    fn cfg() -> ast::crate_cfg;\n-    fn parse_sess() -> @mut parse::ParseSess;\n-    fn call_site() -> span;\n-    fn ident_of(+st: ~str) -> ast::ident;\n+    fn cfg(&self) -> ast::crate_cfg;\n+    fn parse_sess(&self) -> @mut parse::ParseSess;\n+    fn call_site(&self) -> span;\n+    fn ident_of(&self, +st: ~str) -> ast::ident;\n }\n \n #[cfg(test)]\n type fake_session = @mut parse::ParseSess;\n \n #[cfg(test)]\n impl fake_ext_ctxt for fake_session {\n-    fn cfg() -> ast::crate_cfg { ~[] }\n-    fn parse_sess() -> @mut parse::ParseSess { self }\n-    fn call_site() -> span {\n+    fn cfg(&self) -> ast::crate_cfg { ~[] }\n+    fn parse_sess(&self) -> @mut parse::ParseSess { *self }\n+    fn call_site(&self) -> span {\n         codemap::span {\n             lo: codemap::BytePos(0),\n             hi: codemap::BytePos(0),\n             expn_info: None\n         }\n     }\n-    fn ident_of(+st: ~str) -> ast::ident {\n+    fn ident_of(&self, +st: ~str) -> ast::ident {\n         self.interner.intern(@st)\n     }\n }"}, {"sha": "afefec00c5040a1ad81a3533302f08b21f57eb48", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=4a853894fab6b9a4b60c1b3260b446a3473577fa", "patch": "@@ -90,16 +90,16 @@ enum assignment_type {\n }\n \n impl assignment_type {\n-    fn checked_by_liveness() -> bool {\n+    fn checked_by_liveness(&self) -> bool {\n         // the liveness pass guarantees that immutable local variables\n         // are only assigned once; but it doesn't consider &mut\n-        match self {\n+        match *self {\n           at_straight_up => true,\n           at_swap => true\n         }\n     }\n-    fn ing_form(desc: ~str) -> ~str {\n-        match self {\n+    fn ing_form(&self, desc: ~str) -> ~str {\n+        match *self {\n           at_straight_up => ~\"assigning to \" + desc,\n           at_swap => ~\"swapping to and from \" + desc\n         }"}, {"sha": "b997c94a71b4de2581c9f90cbc647df2d5d6fd43", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=4a853894fab6b9a4b60c1b3260b446a3473577fa", "patch": "@@ -82,7 +82,7 @@ pub struct LanguageItems {\n }\n \n pub impl LanguageItems {\n-    static pub fn new() -> LanguageItems {\n+    static pub fn new(&self) -> LanguageItems {\n         LanguageItems {\n             items: [ None, ..34 ]\n         }\n@@ -96,7 +96,7 @@ pub impl LanguageItems {\n         }\n     }\n \n-    static pub fn item_name(index: uint) -> &static/str {\n+    static pub fn item_name(&self, index: uint) -> &static/str {\n         match index {\n             0  => \"const\",\n             1  => \"copy\",\n@@ -315,7 +315,7 @@ struct LanguageItemCollector {\n }\n \n impl LanguageItemCollector {\n-    fn match_and_collect_meta_item(item_def_id: def_id,\n+    fn match_and_collect_meta_item(&self, item_def_id: def_id,\n                                    meta_item: meta_item) {\n         match meta_item.node {\n             meta_name_value(key, literal) => {\n@@ -330,7 +330,7 @@ impl LanguageItemCollector {\n         }\n     }\n \n-    fn collect_item(item_index: uint, item_def_id: def_id) {\n+    fn collect_item(&self, item_index: uint, item_def_id: def_id) {\n         // Check for duplicates.\n         match self.items.items[item_index] {\n             Some(original_def_id) if original_def_id != item_def_id => {\n@@ -346,7 +346,8 @@ impl LanguageItemCollector {\n         self.items.items[item_index] = Some(item_def_id);\n     }\n \n-    fn match_and_collect_item(item_def_id: def_id, key: @~str, value: @~str) {\n+    fn match_and_collect_item(&self,\n+                              item_def_id: def_id, key: @~str, value: @~str) {\n         if *key != ~\"lang\" {\n             return;    // Didn't match.\n         }\n@@ -361,7 +362,7 @@ impl LanguageItemCollector {\n         }\n     }\n \n-    fn collect_local_language_items() {\n+    fn collect_local_language_items(&self) {\n         let this = unsafe { ptr::addr_of(&self) };\n         visit_crate(*self.crate, (), mk_simple_visitor(@SimpleVisitor {\n             visit_item: |item| {\n@@ -378,7 +379,7 @@ impl LanguageItemCollector {\n         }));\n     }\n \n-    fn collect_external_language_items() {\n+    fn collect_external_language_items(&self) {\n         let crate_store = self.session.cstore;\n         do iter_crate_data(crate_store) |crate_number, _crate_metadata| {\n             for each_lang_item(crate_store, crate_number)\n@@ -389,7 +390,7 @@ impl LanguageItemCollector {\n         }\n     }\n \n-    fn check_completeness() {\n+    fn check_completeness(&self) {\n         for self.item_refs.each |&key, &item_ref| {\n             match self.items.items[item_ref] {\n                 None => {\n@@ -402,7 +403,7 @@ impl LanguageItemCollector {\n         }\n     }\n \n-    fn collect() {\n+    fn collect(&self) {\n         self.collect_local_language_items();\n         self.collect_external_language_items();\n         self.check_completeness();"}, {"sha": "75bf7cf26091c0d4e739d2fd945618deb214c401", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 61, "deletions": 53, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=4a853894fab6b9a4b60c1b3260b446a3473577fa", "patch": "@@ -255,7 +255,7 @@ impl to_str::ToStr for Variable {\n // assignment.  And so forth.\n \n impl LiveNode {\n-    pure fn is_valid() -> bool { *self != uint::max_value }\n+    pure fn is_valid(&self) -> bool { **self != uint::max_value }\n }\n \n fn invalid_node() -> LiveNode { LiveNode(uint::max_value) }\n@@ -699,7 +699,7 @@ fn Liveness(ir: @mut IrMaps, specials: Specials) -> Liveness {\n }\n \n impl Liveness {\n-    fn live_node(node_id: node_id, span: span) -> LiveNode {\n+    fn live_node(&self, node_id: node_id, span: span) -> LiveNode {\n         match self.ir.live_node_map.find(&node_id) {\n           Some(ln) => ln,\n           None => {\n@@ -714,7 +714,7 @@ impl Liveness {\n         }\n     }\n \n-    fn variable_from_path(expr: @expr) -> Option<Variable> {\n+    fn variable_from_path(&self, expr: @expr) -> Option<Variable> {\n         match expr.node {\n           expr_path(_) => {\n             let def = self.tcx.def_map.get(&expr.id);\n@@ -726,11 +726,11 @@ impl Liveness {\n         }\n     }\n \n-    fn variable(node_id: node_id, span: span) -> Variable {\n+    fn variable(&self, node_id: node_id, span: span) -> Variable {\n         self.ir.variable(node_id, span)\n     }\n \n-    fn variable_from_def_map(node_id: node_id,\n+    fn variable_from_def_map(&self, node_id: node_id,\n                              span: span) -> Option<Variable> {\n         match self.tcx.def_map.find(&node_id) {\n           Some(def) => {\n@@ -745,7 +745,7 @@ impl Liveness {\n         }\n     }\n \n-    fn pat_bindings(pat: @pat, f: fn(LiveNode, Variable, span)) {\n+    fn pat_bindings(&self, pat: @pat, f: fn(LiveNode, Variable, span)) {\n         let def_map = self.tcx.def_map;\n         do pat_util::pat_bindings(def_map, pat) |_bm, p_id, sp, _n| {\n             let ln = self.live_node(p_id, sp);\n@@ -754,7 +754,8 @@ impl Liveness {\n         }\n     }\n \n-    fn arm_pats_bindings(pats: &[@pat], f: fn(LiveNode, Variable, span)) {\n+    fn arm_pats_bindings(&self,\n+                         pats: &[@pat], f: fn(LiveNode, Variable, span)) {\n         // only consider the first pattern; any later patterns must have\n         // the same bindings, and we also consider the first pattern to be\n         // the \"authoratative\" set of ids\n@@ -763,11 +764,11 @@ impl Liveness {\n         }\n     }\n \n-    fn define_bindings_in_pat(pat: @pat, succ: LiveNode) -> LiveNode {\n+    fn define_bindings_in_pat(&self, pat: @pat, succ: LiveNode) -> LiveNode {\n         self.define_bindings_in_arm_pats([pat], succ)\n     }\n \n-    fn define_bindings_in_arm_pats(pats: &[@pat],\n+    fn define_bindings_in_arm_pats(&self, pats: &[@pat],\n                                    succ: LiveNode) -> LiveNode {\n         let mut succ = succ;\n         do self.arm_pats_bindings(pats) |ln, var, _sp| {\n@@ -778,11 +779,11 @@ impl Liveness {\n         succ\n     }\n \n-    fn idx(ln: LiveNode, var: Variable) -> uint {\n+    fn idx(&self, ln: LiveNode, var: Variable) -> uint {\n         *ln * self.ir.num_vars + *var\n     }\n \n-    fn live_on_entry(ln: LiveNode, var: Variable)\n+    fn live_on_entry(&self, ln: LiveNode, var: Variable)\n         -> Option<LiveNodeKind> {\n \n         assert ln.is_valid();\n@@ -793,32 +794,32 @@ impl Liveness {\n     /*\n     Is this variable live on entry to any of its successor nodes?\n     */\n-    fn live_on_exit(ln: LiveNode, var: Variable)\n+    fn live_on_exit(&self, ln: LiveNode, var: Variable)\n         -> Option<LiveNodeKind> {\n \n         self.live_on_entry(copy self.successors[*ln], var)\n     }\n \n-    fn used_on_entry(ln: LiveNode, var: Variable) -> bool {\n+    fn used_on_entry(&self, ln: LiveNode, var: Variable) -> bool {\n         assert ln.is_valid();\n         self.users[self.idx(ln, var)].used\n     }\n \n-    fn assigned_on_entry(ln: LiveNode, var: Variable)\n+    fn assigned_on_entry(&self, ln: LiveNode, var: Variable)\n         -> Option<LiveNodeKind> {\n \n         assert ln.is_valid();\n         let writer = self.users[self.idx(ln, var)].writer;\n         if writer.is_valid() {Some(self.ir.lnk(writer))} else {None}\n     }\n \n-    fn assigned_on_exit(ln: LiveNode, var: Variable)\n+    fn assigned_on_exit(&self, ln: LiveNode, var: Variable)\n         -> Option<LiveNodeKind> {\n \n         self.assigned_on_entry(copy self.successors[*ln], var)\n     }\n \n-    fn indices(ln: LiveNode, op: fn(uint)) {\n+    fn indices(&self, ln: LiveNode, op: fn(uint)) {\n         let node_base_idx = self.idx(ln, Variable(0));\n         for uint::range(0, self.ir.num_vars) |var_idx| {\n             op(node_base_idx + var_idx)\n@@ -834,7 +835,7 @@ impl Liveness {\n         }\n     }\n \n-    fn write_vars(wr: io::Writer,\n+    fn write_vars(&self, wr: io::Writer,\n                   ln: LiveNode,\n                   test: fn(uint) -> LiveNode) {\n         let node_base_idx = self.idx(ln, Variable(0));\n@@ -847,7 +848,7 @@ impl Liveness {\n         }\n     }\n \n-    fn find_loop_scope(opt_label: Option<ident>, id: node_id, sp: span)\n+    fn find_loop_scope(&self, opt_label: Option<ident>, id: node_id, sp: span)\n         -> node_id {\n         match opt_label {\n             Some(_) => // Refers to a labeled loop. Use the results of resolve\n@@ -869,7 +870,7 @@ impl Liveness {\n         }\n     }\n \n-    fn ln_str(ln: LiveNode) -> ~str {\n+    fn ln_str(&self, ln: LiveNode) -> ~str {\n         do io::with_str_writer |wr| {\n             wr.write_str(~\"[ln(\");\n             wr.write_uint(*ln);\n@@ -886,7 +887,7 @@ impl Liveness {\n         }\n     }\n \n-    fn init_empty(ln: LiveNode, succ_ln: LiveNode) {\n+    fn init_empty(&self, ln: LiveNode, succ_ln: LiveNode) {\n         self.successors[*ln] = succ_ln;\n \n         // It is not necessary to initialize the\n@@ -899,7 +900,7 @@ impl Liveness {\n         // }\n     }\n \n-    fn init_from_succ(ln: LiveNode, succ_ln: LiveNode) {\n+    fn init_from_succ(&self, ln: LiveNode, succ_ln: LiveNode) {\n         // more efficient version of init_empty() / merge_from_succ()\n         self.successors[*ln] = succ_ln;\n         self.indices2(ln, succ_ln, |idx, succ_idx| {\n@@ -909,7 +910,7 @@ impl Liveness {\n                self.ln_str(ln), self.ln_str(succ_ln));\n     }\n \n-    fn merge_from_succ(ln: LiveNode, succ_ln: LiveNode,\n+    fn merge_from_succ(&self, ln: LiveNode, succ_ln: LiveNode,\n                        first_merge: bool) -> bool {\n         if ln == succ_ln { return false; }\n \n@@ -943,7 +944,7 @@ impl Liveness {\n     // Indicates that a local variable was *defined*; we know that no\n     // uses of the variable can precede the definition (resolve checks\n     // this) so we just clear out all the data.\n-    fn define(writer: LiveNode, var: Variable) {\n+    fn define(&self, writer: LiveNode, var: Variable) {\n         let idx = self.idx(writer, var);\n         self.users[idx].reader = invalid_node();\n         self.users[idx].writer = invalid_node();\n@@ -953,7 +954,7 @@ impl Liveness {\n     }\n \n     // Either read, write, or both depending on the acc bitset\n-    fn acc(ln: LiveNode, var: Variable, acc: uint) {\n+    fn acc(&self, ln: LiveNode, var: Variable, acc: uint) {\n         let idx = self.idx(ln, var);\n         let user = &mut self.users[idx];\n \n@@ -978,7 +979,7 @@ impl Liveness {\n \n     // _______________________________________________________________________\n \n-    fn compute(decl: fn_decl, body: blk) -> LiveNode {\n+    fn compute(&self, decl: fn_decl, body: blk) -> LiveNode {\n         // if there is a `break` or `again` at the top level, then it's\n         // effectively a return---this only occurs in `for` loops,\n         // where the body is really a closure.\n@@ -1003,7 +1004,8 @@ impl Liveness {\n         entry_ln\n     }\n \n-    fn propagate_through_fn_block(decl: fn_decl, blk: blk) -> LiveNode {\n+    fn propagate_through_fn_block(&self, decl: fn_decl, blk: blk)\n+                                 -> LiveNode {\n         // inputs passed by & mode should be considered live on exit:\n         for decl.inputs.each |arg| {\n             match ty::resolved_mode(self.tcx, arg.mode) {\n@@ -1036,14 +1038,15 @@ impl Liveness {\n         self.propagate_through_block(blk, self.s.fallthrough_ln)\n     }\n \n-    fn propagate_through_block(blk: blk, succ: LiveNode) -> LiveNode {\n+    fn propagate_through_block(&self, blk: blk, succ: LiveNode) -> LiveNode {\n         let succ = self.propagate_through_opt_expr(blk.node.expr, succ);\n         do blk.node.stmts.foldr(succ) |stmt, succ| {\n             self.propagate_through_stmt(*stmt, succ)\n         }\n     }\n \n-    fn propagate_through_stmt(stmt: @stmt, succ: LiveNode) -> LiveNode {\n+    fn propagate_through_stmt(&self, stmt: @stmt, succ: LiveNode)\n+                             -> LiveNode {\n         match stmt.node {\n           stmt_decl(decl, _) => {\n             return self.propagate_through_decl(decl, succ);\n@@ -1059,7 +1062,8 @@ impl Liveness {\n         }\n     }\n \n-    fn propagate_through_decl(decl: @decl, succ: LiveNode) -> LiveNode {\n+    fn propagate_through_decl(&self, decl: @decl, succ: LiveNode)\n+                             -> LiveNode {\n         match /*bad*/copy decl.node {\n           decl_local(locals) => {\n             do locals.foldr(succ) |local, succ| {\n@@ -1072,7 +1076,8 @@ impl Liveness {\n         }\n     }\n \n-    fn propagate_through_local(local: @local, succ: LiveNode) -> LiveNode {\n+    fn propagate_through_local(&self, local: @local, succ: LiveNode)\n+                              -> LiveNode {\n         // Note: we mark the variable as defined regardless of whether\n         // there is an initializer.  Initially I had thought to only mark\n         // the live variable as defined if it was initialized, and then we\n@@ -1091,21 +1096,22 @@ impl Liveness {\n         self.define_bindings_in_pat(local.node.pat, succ)\n     }\n \n-    fn propagate_through_exprs(exprs: ~[@expr],\n+    fn propagate_through_exprs(&self, exprs: ~[@expr],\n                                succ: LiveNode) -> LiveNode {\n         do exprs.foldr(succ) |expr, succ| {\n             self.propagate_through_expr(*expr, succ)\n         }\n     }\n \n-    fn propagate_through_opt_expr(opt_expr: Option<@expr>,\n+    fn propagate_through_opt_expr(&self, opt_expr: Option<@expr>,\n                                   succ: LiveNode) -> LiveNode {\n         do opt_expr.foldl(succ) |succ, expr| {\n             self.propagate_through_expr(*expr, *succ)\n         }\n     }\n \n-    fn propagate_through_expr(expr: @expr, succ: LiveNode) -> LiveNode {\n+    fn propagate_through_expr(&self, expr: @expr, succ: LiveNode)\n+                             -> LiveNode {\n         debug!(\"propagate_through_expr: %s\",\n              expr_to_str(expr, self.tcx.sess.intr()));\n \n@@ -1365,7 +1371,7 @@ impl Liveness {\n         }\n     }\n \n-    fn propagate_through_lvalue_components(expr: @expr,\n+    fn propagate_through_lvalue_components(&self, expr: @expr,\n                                            succ: LiveNode) -> LiveNode {\n         // # Lvalues\n         //\n@@ -1424,7 +1430,7 @@ impl Liveness {\n     }\n \n     // see comment on propagate_through_lvalue()\n-    fn write_lvalue(expr: @expr,\n+    fn write_lvalue(&self, expr: @expr,\n                     succ: LiveNode,\n                     acc: uint) -> LiveNode {\n         match expr.node {\n@@ -1438,7 +1444,8 @@ impl Liveness {\n         }\n     }\n \n-    fn access_path(expr: @expr, succ: LiveNode, acc: uint) -> LiveNode {\n+    fn access_path(&self, expr: @expr, succ: LiveNode, acc: uint)\n+                  -> LiveNode {\n         let def = self.tcx.def_map.get(&expr.id);\n         match relevant_def(def) {\n           Some(nid) => {\n@@ -1454,7 +1461,7 @@ impl Liveness {\n         }\n     }\n \n-    fn propagate_through_loop(expr: @expr,\n+    fn propagate_through_loop(&self, expr: @expr,\n                               cond: Option<@expr>,\n                               body: blk,\n                               succ: LiveNode) -> LiveNode {\n@@ -1510,7 +1517,7 @@ impl Liveness {\n         cond_ln\n     }\n \n-    fn with_loop_nodes<R>(loop_node_id: node_id,\n+    fn with_loop_nodes<R>(&self, loop_node_id: node_id,\n                           break_ln: LiveNode,\n                           cont_ln: LiveNode,\n                           f: fn() -> R) -> R {\n@@ -1646,7 +1653,7 @@ enum ReadKind {\n }\n \n impl @Liveness {\n-    fn check_ret(id: node_id, sp: span, _fk: visit::fn_kind,\n+    fn check_ret(&self, id: node_id, sp: span, _fk: visit::fn_kind,\n                  entry_ln: LiveNode) {\n         if self.live_on_entry(entry_ln, self.s.no_ret_var).is_some() {\n             // if no_ret_var is live, then we fall off the end of the\n@@ -1666,7 +1673,7 @@ impl @Liveness {\n         }\n     }\n \n-    fn check_move_from_var(ln: LiveNode,\n+    fn check_move_from_var(&self, ln: LiveNode,\n                            var: Variable,\n                            move_expr: @expr)\n     {\n@@ -1691,7 +1698,7 @@ impl @Liveness {\n         }\n     }\n \n-    fn consider_last_use(expr: @expr, ln: LiveNode, var: Variable) {\n+    fn consider_last_use(&self, expr: @expr, ln: LiveNode, var: Variable) {\n         debug!(\"consider_last_use(expr.id=%?, ln=%s, var=%s)\",\n                expr.id, ln.to_str(), var.to_str());\n \n@@ -1701,7 +1708,7 @@ impl @Liveness {\n        }\n     }\n \n-    fn check_lvalue(expr: @expr, vt: vt<@Liveness>) {\n+    fn check_lvalue(&self, expr: @expr, vt: vt<@Liveness>) {\n         match expr.node {\n           expr_path(_) => {\n             match self.tcx.def_map.get(&expr.id) {\n@@ -1729,18 +1736,18 @@ impl @Liveness {\n           _ => {\n             // For other kinds of lvalues, no checks are required,\n             // and any embedded expressions are actually rvalues\n-            visit::visit_expr(expr, self, vt);\n+            visit::visit_expr(expr, *self, vt);\n           }\n        }\n     }\n \n-    fn check_for_reassignments_in_pat(pat: @pat) {\n+    fn check_for_reassignments_in_pat(&self, pat: @pat) {\n         do self.pat_bindings(pat) |ln, var, sp| {\n             self.check_for_reassignment(ln, var, sp);\n         }\n     }\n \n-    fn check_for_reassignment(ln: LiveNode, var: Variable,\n+    fn check_for_reassignment(&self, ln: LiveNode, var: Variable,\n                               orig_span: span) {\n         match self.assigned_on_exit(ln, var) {\n           Some(ExprNode(span)) => {\n@@ -1761,7 +1768,7 @@ impl @Liveness {\n         }\n     }\n \n-    fn report_illegal_move(lnk: LiveNodeKind,\n+    fn report_illegal_move(&self, lnk: LiveNodeKind,\n                            var: Variable,\n                            move_expr: @expr)\n     {\n@@ -1827,7 +1834,7 @@ impl @Liveness {\n         };\n     }\n \n-    fn report_move_location(move_expr: @expr,\n+    fn report_move_location(&self, move_expr: @expr,\n                             var: Variable,\n                             expr_descr: &str,\n                             pronoun: &str)\n@@ -1842,7 +1849,7 @@ impl @Liveness {\n                  ty_to_str(self.tcx, move_expr_ty)));\n     }\n \n-    fn report_illegal_read(chk_span: span,\n+    fn report_illegal_read(&self, chk_span: span,\n                            lnk: LiveNodeKind,\n                            var: Variable,\n                            rk: ReadKind) {\n@@ -1873,12 +1880,12 @@ impl @Liveness {\n         }\n     }\n \n-    fn should_warn(var: Variable) -> Option<@~str> {\n+    fn should_warn(&self, var: Variable) -> Option<@~str> {\n         let name = self.ir.variable_name(var);\n         if name[0] == ('_' as u8) { None } else { Some(name) }\n     }\n \n-    fn warn_about_unused_args(decl: fn_decl, entry_ln: LiveNode) {\n+    fn warn_about_unused_args(&self, decl: fn_decl, entry_ln: LiveNode) {\n         for decl.inputs.each |arg| {\n             do pat_util::pat_bindings(self.tcx.def_map, arg.pat)\n                     |_bm, p_id, sp, _n| {\n@@ -1888,15 +1895,16 @@ impl @Liveness {\n         }\n     }\n \n-    fn warn_about_unused_or_dead_vars_in_pat(pat: @pat) {\n+    fn warn_about_unused_or_dead_vars_in_pat(&self, pat: @pat) {\n         do self.pat_bindings(pat) |ln, var, sp| {\n             if !self.warn_about_unused(sp, ln, var) {\n                 self.warn_about_dead_assign(sp, ln, var);\n             }\n         }\n     }\n \n-    fn warn_about_unused(sp: span, ln: LiveNode, var: Variable) -> bool {\n+    fn warn_about_unused(&self, sp: span, ln: LiveNode, var: Variable)\n+                        -> bool {\n         if !self.used_on_entry(ln, var) {\n             for self.should_warn(var).each |name| {\n \n@@ -1925,7 +1933,7 @@ impl @Liveness {\n         return false;\n     }\n \n-    fn warn_about_dead_assign(sp: span, ln: LiveNode, var: Variable) {\n+    fn warn_about_dead_assign(&self, sp: span, ln: LiveNode, var: Variable) {\n         if self.live_on_exit(ln, var).is_none() {\n             for self.should_warn(var).each |name| {\n                 // FIXME(#3266)--make liveness warnings lintable"}, {"sha": "f027ca99d514f84b0085d74b522abe2c8400f272", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=4a853894fab6b9a4b60c1b3260b446a3473577fa", "patch": "@@ -277,27 +277,27 @@ pub fn cat_variant<N:ast_node>(\n }\n \n pub trait ast_node {\n-    fn id() -> ast::node_id;\n-    fn span() -> span;\n+    fn id(&self) -> ast::node_id;\n+    fn span(&self) -> span;\n }\n \n pub impl ast_node for @ast::expr {\n-    fn id() -> ast::node_id { self.id }\n-    fn span() -> span { self.span }\n+    fn id(&self) -> ast::node_id { self.id }\n+    fn span(&self) -> span { self.span }\n }\n \n pub impl ast_node for @ast::pat {\n-    fn id() -> ast::node_id { self.id }\n-    fn span() -> span { self.span }\n+    fn id(&self) -> ast::node_id { self.id }\n+    fn span(&self) -> span { self.span }\n }\n \n pub trait get_type_for_node {\n-    fn ty<N:ast_node>(node: N) -> ty::t;\n+    fn ty<N:ast_node>(&self, node: N) -> ty::t;\n }\n \n pub impl get_type_for_node for ty::ctxt {\n-    fn ty<N:ast_node>(node: N) -> ty::t {\n-        ty::node_id_to_type(self, node.id())\n+    fn ty<N:ast_node>(&self, node: N) -> ty::t {\n+        ty::node_id_to_type(*self, node.id())\n     }\n }\n \n@@ -313,7 +313,7 @@ impl ToStr for MutabilityCategory {\n }\n \n impl MutabilityCategory {\n-    static fn from_mutbl(m: ast::mutability) -> MutabilityCategory {\n+    static fn from_mutbl(&self, m: ast::mutability) -> MutabilityCategory {\n         match m {\n             m_imm => McImmutable,\n             m_const => McReadOnly,"}, {"sha": "689d6ca40eefe8e36f3adbd5a37268f3c6ce1924", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=4a853894fab6b9a4b60c1b3260b446a3473577fa", "patch": "@@ -154,8 +154,8 @@ pub enum NamespaceResult {\n }\n \n pub impl NamespaceResult {\n-    pure fn is_unknown() -> bool {\n-        match self {\n+    pure fn is_unknown(&self) -> bool {\n+        match *self {\n             UnknownResult => true,\n             _ => false\n         }\n@@ -206,11 +206,11 @@ pub enum ResolveResult<T> {\n }\n \n pub impl<T> ResolveResult<T> {\n-    fn failed() -> bool {\n-        match self { Failed => true, _ => false }\n+    fn failed(&self) -> bool {\n+        match *self { Failed => true, _ => false }\n     }\n-    fn indeterminate() -> bool {\n-        match self { Indeterminate => true, _ => false }\n+    fn indeterminate(&self) -> bool {\n+        match *self { Indeterminate => true, _ => false }\n     }\n }\n \n@@ -417,7 +417,7 @@ pub fn ImportResolution(privacy: Privacy,\n }\n \n pub impl ImportResolution {\n-    fn target_for_namespace(namespace: Namespace) -> Option<Target> {\n+    fn target_for_namespace(&self, namespace: Namespace) -> Option<Target> {\n         match namespace {\n             TypeNS      => return copy self.type_target,\n             ValueNS     => return copy self.value_target\n@@ -503,7 +503,7 @@ pub fn Module(parent_link: ParentLink,\n }\n \n pub impl Module {\n-    fn all_imports_resolved() -> bool {\n+    fn all_imports_resolved(&self) -> bool {\n         return self.imports.len() == self.resolved_import_count;\n     }\n }\n@@ -706,7 +706,7 @@ pub struct PrimitiveTypeTable {\n }\n \n pub impl PrimitiveTypeTable {\n-    fn intern(intr: @ident_interner, string: @~str,\n+    fn intern(&self, intr: @ident_interner, string: @~str,\n               primitive_type: prim_ty) {\n         let ident = intr.intern(string);\n         self.primitive_types.insert(ident, primitive_type);"}, {"sha": "130370cdc02ae4c68880490c376854e655f3acc8", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=4a853894fab6b9a4b60c1b3260b446a3473577fa", "patch": "@@ -105,27 +105,27 @@ pub fn icx_popper(ccx: @CrateContext) -> icx_popper {\n }\n \n pub trait get_insn_ctxt {\n-    fn insn_ctxt(s: &str) -> icx_popper;\n+    fn insn_ctxt(&self, s: &str) -> icx_popper;\n }\n \n pub impl get_insn_ctxt for @CrateContext {\n-    fn insn_ctxt(s: &str) -> icx_popper {\n+    fn insn_ctxt(&self, s: &str) -> icx_popper {\n         debug!(\"new insn_ctxt: %s\", s);\n         if self.sess.count_llvm_insns() {\n             self.stats.llvm_insn_ctxt.push(str::from_slice(s));\n         }\n-        icx_popper(self)\n+        icx_popper(*self)\n     }\n }\n \n pub impl get_insn_ctxt for block {\n-    fn insn_ctxt(s: &str) -> icx_popper {\n+    fn insn_ctxt(&self, s: &str) -> icx_popper {\n         self.ccx().insn_ctxt(s)\n     }\n }\n \n pub impl get_insn_ctxt for fn_ctxt {\n-    fn insn_ctxt(s: &str) -> icx_popper {\n+    fn insn_ctxt(&self, s: &str) -> icx_popper {\n         self.ccx.insn_ctxt(s)\n     }\n }"}, {"sha": "0b8283dbf2cc5ee796a0c5193d396046e9761892", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=4a853894fab6b9a4b60c1b3260b446a3473577fa", "patch": "@@ -131,7 +131,7 @@ pub impl EnvAction {\n }\n \n pub impl EnvValue {\n-    fn to_str(ccx: @CrateContext) -> ~str {\n+    fn to_str(&self, ccx: @CrateContext) -> ~str {\n         fmt!(\"%s(%s)\", self.action.to_str(), self.datum.to_str(ccx))\n     }\n }"}, {"sha": "50ca6e90e22856b15b6a095e72f3ccea24bd0efa", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=4a853894fab6b9a4b60c1b3260b446a3473577fa", "patch": "@@ -533,17 +533,17 @@ pub struct scope_info {\n }\n \n pub trait get_node_info {\n-    fn info() -> Option<NodeInfo>;\n+    fn info(&self) -> Option<NodeInfo>;\n }\n \n pub impl get_node_info for @ast::expr {\n-    fn info() -> Option<NodeInfo> {\n+    fn info(&self) -> Option<NodeInfo> {\n         Some(NodeInfo { id: self.id, span: self.span })\n     }\n }\n \n pub impl get_node_info for ast::blk {\n-    fn info() -> Option<NodeInfo> {\n+    fn info(&self) -> Option<NodeInfo> {\n         Some(NodeInfo { id: self.node.id, span: self.span })\n     }\n }\n@@ -552,7 +552,7 @@ pub impl get_node_info for ast::blk {\n pub type optional_boxed_ast_expr = Option<@ast::expr>;\n \n pub impl get_node_info for optional_boxed_ast_expr {\n-    fn info() -> Option<NodeInfo> {\n+    fn info(&self) -> Option<NodeInfo> {\n         self.chain_ref(|s| s.info())\n     }\n }\n@@ -625,7 +625,7 @@ pub fn rslt(bcx: block, val: ValueRef) -> Result {\n }\n \n pub impl Result {\n-    fn unpack(bcx: &mut block) -> ValueRef {\n+    fn unpack(&self, bcx: &mut block) -> ValueRef {\n         *bcx = self.bcx;\n         return self.val;\n     }\n@@ -689,27 +689,27 @@ pub fn block_parent(cx: block) -> block {\n // Accessors\n \n pub impl block {\n-    pure fn ccx() -> @CrateContext { *self.fcx.ccx }\n-    pure fn tcx() -> ty::ctxt { self.fcx.ccx.tcx }\n-    pure fn sess() -> Session { self.fcx.ccx.sess }\n+    pure fn ccx(&self) -> @CrateContext { *self.fcx.ccx }\n+    pure fn tcx(&self) -> ty::ctxt { self.fcx.ccx.tcx }\n+    pure fn sess(&self) -> Session { self.fcx.ccx.sess }\n \n-    fn node_id_to_str(id: ast::node_id) -> ~str {\n+    fn node_id_to_str(&self, id: ast::node_id) -> ~str {\n         ast_map::node_id_to_str(self.tcx().items, id, self.sess().intr())\n     }\n \n-    fn expr_to_str(e: @ast::expr) -> ~str {\n+    fn expr_to_str(&self, e: @ast::expr) -> ~str {\n         expr_repr(self.tcx(), e)\n     }\n \n-    fn expr_is_lval(e: @ast::expr) -> bool {\n+    fn expr_is_lval(&self, e: @ast::expr) -> bool {\n         ty::expr_is_lval(self.tcx(), self.ccx().maps.method_map, e)\n     }\n \n-    fn expr_kind(e: @ast::expr) -> ty::ExprKind {\n+    fn expr_kind(&self, e: @ast::expr) -> ty::ExprKind {\n         ty::expr_kind(self.tcx(), self.ccx().maps.method_map, e)\n     }\n \n-    fn def(nid: ast::node_id) -> ast::def {\n+    fn def(&self, nid: ast::node_id) -> ast::def {\n         match self.tcx().def_map.find(&nid) {\n             Some(v) => v,\n             None => {\n@@ -719,15 +719,15 @@ pub impl block {\n         }\n     }\n \n-    fn val_str(val: ValueRef) -> @str {\n+    fn val_str(&self, val: ValueRef) -> @str {\n         val_str(self.ccx().tn, val)\n     }\n \n-    fn llty_str(llty: TypeRef) -> @str {\n+    fn llty_str(&self, llty: TypeRef) -> @str {\n         ty_str(self.ccx().tn, llty)\n     }\n \n-    fn ty_to_str(t: ty::t) -> ~str {\n+    fn ty_to_str(&self, t: ty::t) -> ~str {\n         ty_to_str(self.tcx(), t)\n     }\n     fn to_str(&self) -> ~str {"}, {"sha": "ba56eb56c0a9de0b770899eef1bbca0b74182e16", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 55, "deletions": 51, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=4a853894fab6b9a4b60c1b3260b446a3473577fa", "patch": "@@ -142,12 +142,12 @@ pub enum DatumMode {\n }\n \n pub impl DatumMode {\n-    fn is_by_ref() -> bool {\n-        match self { ByRef => true, ByValue => false }\n+    fn is_by_ref(&self) -> bool {\n+        match *self { ByRef => true, ByValue => false }\n     }\n \n-    fn is_by_value() -> bool {\n-        match self { ByRef => false, ByValue => true }\n+    fn is_by_value(&self) -> bool {\n+        match *self { ByRef => false, ByValue => true }\n     }\n }\n \n@@ -216,7 +216,7 @@ pub fn appropriate_mode(ty: ty::t) -> DatumMode {\n }\n \n pub impl Datum {\n-    fn store_to(bcx: block, id: ast::node_id,\n+    fn store_to(&self, bcx: block, id: ast::node_id,\n                 action: CopyAction, dst: ValueRef) -> block {\n         /*!\n          *\n@@ -231,7 +231,7 @@ pub impl Datum {\n         }\n     }\n \n-    fn store_to_dest(bcx: block, id: ast::node_id,\n+    fn store_to_dest(&self, bcx: block, id: ast::node_id,\n                      dest: expr::Dest) -> block {\n         match dest {\n             expr::Ignore => {\n@@ -243,25 +243,28 @@ pub impl Datum {\n         }\n     }\n \n-    fn store_to_datum(bcx: block, id: ast::node_id,\n+    fn store_to_datum(&self, bcx: block, id: ast::node_id,\n                       action: CopyAction, datum: Datum) -> block {\n         debug!(\"store_to_datum(self=%s, action=%?, datum=%s)\",\n                self.to_str(bcx.ccx()), action, datum.to_str(bcx.ccx()));\n         assert datum.mode.is_by_ref();\n         self.store_to(bcx, id, action, datum.val)\n     }\n \n-    fn move_to_datum(bcx: block, action: CopyAction, datum: Datum) -> block {\n+    fn move_to_datum(&self, bcx: block, action: CopyAction, datum: Datum)\n+                    -> block {\n         assert datum.mode.is_by_ref();\n         self.move_to(bcx, action, datum.val)\n     }\n \n-    fn copy_to_datum(bcx: block, action: CopyAction, datum: Datum) -> block {\n+    fn copy_to_datum(&self, bcx: block, action: CopyAction, datum: Datum)\n+                    -> block {\n         assert datum.mode.is_by_ref();\n         self.copy_to(bcx, action, datum.val)\n     }\n \n-    fn copy_to(bcx: block, action: CopyAction, dst: ValueRef) -> block {\n+    fn copy_to(&self, bcx: block, action: CopyAction, dst: ValueRef)\n+              -> block {\n         /*!\n          *\n          * Copies the value into `dst`, which should be a pointer to a\n@@ -303,7 +306,7 @@ pub impl Datum {\n         }\n     }\n \n-    fn copy_to_no_check(bcx: block, action: CopyAction,\n+    fn copy_to_no_check(&self, bcx: block, action: CopyAction,\n                         dst: ValueRef) -> block\n     {\n         /*!\n@@ -333,7 +336,8 @@ pub impl Datum {\n     // This works like copy_val, except that it deinitializes the source.\n     // Since it needs to zero out the source, src also needs to be an lval.\n     //\n-    fn move_to(bcx: block, action: CopyAction, dst: ValueRef) -> block {\n+    fn move_to(&self, bcx: block, action: CopyAction, dst: ValueRef)\n+              -> block {\n         let _icx = bcx.insn_ctxt(\"move_to\");\n         let mut bcx = bcx;\n \n@@ -362,7 +366,7 @@ pub impl Datum {\n         return bcx;\n     }\n \n-    fn add_clean(bcx: block) {\n+    fn add_clean(&self, bcx: block) {\n         /*!\n          *\n          * Schedules this datum for cleanup in `bcx`.  The datum\n@@ -379,7 +383,7 @@ pub impl Datum {\n         }\n     }\n \n-    fn cancel_clean(bcx: block) {\n+    fn cancel_clean(&self, bcx: block) {\n         if ty::type_needs_drop(bcx.tcx(), self.ty) {\n             match self.source {\n                 RevokeClean => {\n@@ -396,15 +400,15 @@ pub impl Datum {\n         }\n     }\n \n-    fn to_str(ccx: &CrateContext) -> ~str {\n+    fn to_str(&self, ccx: &CrateContext) -> ~str {\n         fmt!(\"Datum { val=%s, ty=%s, mode=%?, source=%? }\",\n              val_str(ccx.tn, self.val),\n              ty_to_str(ccx.tcx, self.ty),\n              self.mode,\n              self.source)\n     }\n \n-    fn to_value_datum(bcx: block) -> Datum {\n+    fn to_value_datum(&self, bcx: block) -> Datum {\n         /*!\n          *\n          * Yields a by-ref form of this datum.  This may involve\n@@ -413,15 +417,15 @@ pub impl Datum {\n          * it will not live longer than the current datum. */\n \n         match self.mode {\n-            ByValue => self,\n+            ByValue => *self,\n             ByRef => {\n                 Datum {val: self.to_value_llval(bcx), mode: ByValue,\n                        ty: self.ty, source: RevokeClean}\n             }\n         }\n     }\n \n-    fn to_value_llval(bcx: block) -> ValueRef {\n+    fn to_value_llval(&self, bcx: block) -> ValueRef {\n         /*!\n          *\n          * Yields the value itself. */\n@@ -442,7 +446,7 @@ pub impl Datum {\n         }\n     }\n \n-    fn to_ref_datum(bcx: block) -> Datum {\n+    fn to_ref_datum(&self, bcx: block) -> Datum {\n         /*!\n          *\n          * Yields a by-ref form of this datum.  This may involve\n@@ -451,15 +455,15 @@ pub impl Datum {\n          * it will not live longer than the current datum. */\n \n         match self.mode {\n-            ByRef => self,\n+            ByRef => *self,\n             ByValue => {\n                 Datum {val: self.to_ref_llval(bcx), mode: ByRef,\n                        ty: self.ty, source: RevokeClean}\n             }\n         }\n     }\n \n-    fn to_ref_llval(bcx: block) -> ValueRef {\n+    fn to_ref_llval(&self, bcx: block) -> ValueRef {\n         match self.mode {\n             ByRef => self.val,\n             ByValue => {\n@@ -474,13 +478,13 @@ pub impl Datum {\n         }\n     }\n \n-    fn appropriate_mode() -> DatumMode {\n+    fn appropriate_mode(&self) -> DatumMode {\n         /*! See the `appropriate_mode()` function */\n \n         appropriate_mode(self.ty)\n     }\n \n-    fn to_appropriate_llval(bcx: block) -> ValueRef {\n+    fn to_appropriate_llval(&self, bcx: block) -> ValueRef {\n         /*!\n          *\n          * Yields an llvalue with the `appropriate_mode()`. */\n@@ -491,7 +495,7 @@ pub impl Datum {\n         }\n     }\n \n-    fn to_appropriate_datum(bcx: block) -> Datum {\n+    fn to_appropriate_datum(&self, bcx: block) -> Datum {\n         /*!\n          *\n          * Yields a datum with the `appropriate_mode()`. */\n@@ -502,7 +506,7 @@ pub impl Datum {\n         }\n     }\n \n-    fn GEPi(bcx: block,\n+    fn GEPi(&self, bcx: block,\n             ixs: &[uint],\n             ty: ty::t,\n             source: DatumCleanup)\n@@ -516,7 +520,7 @@ pub impl Datum {\n         }\n     }\n \n-    fn root(bcx: block, root_info: RootInfo) -> block {\n+    fn root(&self, bcx: block, root_info: RootInfo) -> block {\n         /*!\n          *\n          * In some cases, borrowck will decide that an @T/@[]/@str\n@@ -555,7 +559,7 @@ pub impl Datum {\n         }\n     }\n \n-    fn perform_write_guard(bcx: block) -> block {\n+    fn perform_write_guard(&self, bcx: block) -> block {\n         // Create scratch space, but do not root it.\n         let llval = match self.mode {\n             ByValue => self.val,\n@@ -569,7 +573,7 @@ pub impl Datum {\n             expr::Ignore)\n     }\n \n-    fn drop_val(bcx: block) -> block {\n+    fn drop_val(&self, bcx: block) -> block {\n         if !ty::type_needs_drop(bcx.tcx(), self.ty) {\n             return bcx;\n         }\n@@ -580,7 +584,7 @@ pub impl Datum {\n         };\n     }\n \n-    fn box_body(bcx: block) -> Datum {\n+    fn box_body(&self, bcx: block) -> Datum {\n         /*!\n          *\n          * This datum must represent an @T or ~T box.  Returns a new\n@@ -600,7 +604,7 @@ pub impl Datum {\n         Datum {val: body, ty: content_ty, mode: ByRef, source: ZeroMem}\n     }\n \n-    fn to_rptr(bcx: block) -> Datum {\n+    fn to_rptr(&self, bcx: block) -> Datum {\n         //!\n         //\n         // Returns a new datum of region-pointer type containing the\n@@ -618,7 +622,7 @@ pub impl Datum {\n                mode: ByValue, source: RevokeClean}\n     }\n \n-    fn try_deref(\n+    fn try_deref(&self,\n         bcx: block,            // block wherein to generate insn's\n         expr_id: ast::node_id, // id of expr being deref'd\n         derefs: uint,          // number of times deref'd already\n@@ -656,11 +660,11 @@ pub impl Datum {\n                 if is_auto { // unsafe ptrs are not AUTO-derefable\n                     return (None, bcx);\n                 } else {\n-                    return (Some(deref_ptr(bcx, &self, mt.ty)), bcx);\n+                    return (Some(deref_ptr(bcx, self, mt.ty)), bcx);\n                 }\n             }\n             ty::ty_rptr(_, mt) => {\n-                return (Some(deref_ptr(bcx, &self, mt.ty)), bcx);\n+                return (Some(deref_ptr(bcx, self, mt.ty)), bcx);\n             }\n             ty::ty_enum(did, ref substs) => {\n                 // Check whether this enum is a newtype enum:\n@@ -695,7 +699,7 @@ pub impl Datum {\n                         // code in place here to do the right\n                         // thing if this change ever goes through.\n                         assert ty::type_is_immediate(ty);\n-                        (Some(Datum {ty: ty, ..self}), bcx)\n+                        (Some(Datum {ty: ty, ..*self}), bcx)\n                     }\n                 };\n             }\n@@ -733,7 +737,7 @@ pub impl Datum {\n                         // code in place here to do the right thing if this\n                         // change ever goes through.\n                         assert ty::type_is_immediate(ty);\n-                        (Some(Datum {ty: ty, ..self}), bcx)\n+                        (Some(Datum {ty: ty, ..*self}), bcx)\n                     }\n                 }\n             }\n@@ -752,7 +756,7 @@ pub impl Datum {\n         }\n     }\n \n-    fn deref(bcx: block,\n+    fn deref(&self, bcx: block,\n              expr: @ast::expr,  // the expression whose value is being deref'd\n              derefs: uint)\n           -> DatumBlock {\n@@ -765,7 +769,7 @@ pub impl Datum {\n         }\n     }\n \n-    fn autoderef(bcx: block,\n+    fn autoderef(&self, bcx: block,\n                  expr_id: ast::node_id,\n                  max: uint)\n               -> DatumBlock {\n@@ -775,7 +779,7 @@ pub impl Datum {\n                expr_id, max, self.to_str(bcx.ccx()));\n         let _indenter = indenter();\n \n-        let mut datum = self;\n+        let mut datum = *self;\n         let mut derefs = 0u;\n         let mut bcx = bcx;\n         while derefs < max {\n@@ -796,56 +800,56 @@ pub impl Datum {\n         DatumBlock { bcx: bcx, datum: datum }\n     }\n \n-    fn get_base_and_len(bcx: block) -> (ValueRef, ValueRef) {\n+    fn get_base_and_len(&self, bcx: block) -> (ValueRef, ValueRef) {\n         tvec::get_base_and_len(bcx, self.to_appropriate_llval(bcx), self.ty)\n     }\n \n-    fn to_result(bcx: block) -> common::Result {\n+    fn to_result(&self, bcx: block) -> common::Result {\n         rslt(bcx, self.to_appropriate_llval(bcx))\n     }\n }\n \n pub impl DatumBlock {\n-    fn unpack(bcx: &mut block) -> Datum {\n+    fn unpack(&self, bcx: &mut block) -> Datum {\n         *bcx = self.bcx;\n         return self.datum;\n     }\n \n-    fn assert_by_ref() -> DatumBlock {\n+    fn assert_by_ref(&self) -> DatumBlock {\n         assert self.datum.mode.is_by_ref();\n-        self\n+        *self\n     }\n \n-    fn drop_val() -> block {\n+    fn drop_val(&self) -> block {\n         self.datum.drop_val(self.bcx)\n     }\n \n-    fn store_to(id: ast::node_id, action: CopyAction,\n+    fn store_to(&self, id: ast::node_id, action: CopyAction,\n                 dst: ValueRef) -> block {\n         self.datum.store_to(self.bcx, id, action, dst)\n     }\n \n-    fn copy_to(action: CopyAction, dst: ValueRef) -> block {\n+    fn copy_to(&self, action: CopyAction, dst: ValueRef) -> block {\n         self.datum.copy_to(self.bcx, action, dst)\n     }\n \n-    fn move_to(action: CopyAction, dst: ValueRef) -> block {\n+    fn move_to(&self, action: CopyAction, dst: ValueRef) -> block {\n         self.datum.move_to(self.bcx, action, dst)\n     }\n \n-    fn to_value_llval() -> ValueRef {\n+    fn to_value_llval(&self) -> ValueRef {\n         self.datum.to_value_llval(self.bcx)\n     }\n \n-    fn to_result() -> common::Result {\n+    fn to_result(&self) -> common::Result {\n         rslt(self.bcx, self.datum.to_appropriate_llval(self.bcx))\n     }\n \n-    fn ccx() -> @CrateContext {\n+    fn ccx(&self) -> @CrateContext {\n         self.bcx.ccx()\n     }\n \n-    fn tcx() -> ty::ctxt {\n+    fn tcx(&self) -> ty::ctxt {\n         self.bcx.tcx()\n     }\n "}, {"sha": "4adc0cf0e395962ce345d498aeca13292734c10b", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=4a853894fab6b9a4b60c1b3260b446a3473577fa", "patch": "@@ -157,8 +157,8 @@ pub enum Dest {\n }\n \n impl Dest {\n-    fn to_str(ccx: @CrateContext) -> ~str {\n-        match self {\n+    fn to_str(&self, ccx: @CrateContext) -> ~str {\n+        match *self {\n             SaveIn(v) => fmt!(\"SaveIn(%s)\", val_str(ccx.tn, v)),\n             Ignore => ~\"Ignore\"\n         }"}, {"sha": "a943b2bed6d0a53da48d13b10e5dde98f1c2ee8c", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=4a853894fab6b9a4b60c1b3260b446a3473577fa", "patch": "@@ -144,7 +144,7 @@ pub struct VecTypes {\n }\n \n pub impl VecTypes {\n-    fn to_str(ccx: @CrateContext) -> ~str {\n+    fn to_str(&self, ccx: @CrateContext) -> ~str {\n         fmt!(\"VecTypes {vec_ty=%s, unit_ty=%s, llunit_ty=%s, llunit_size=%s}\",\n              ty_to_str(ccx.tcx, self.vec_ty),\n              ty_to_str(ccx.tcx, self.unit_ty),"}, {"sha": "faa6d3992c0712c9419046fcec9d750d8da21a68", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=4a853894fab6b9a4b60c1b3260b446a3473577fa", "patch": "@@ -657,35 +657,35 @@ impl to_bytes::IterBytes for param_bound {\n }\n \n pub trait Vid {\n-    pure fn to_uint() -> uint;\n+    pure fn to_uint(&self) -> uint;\n }\n \n pub impl Vid for TyVid {\n-    pure fn to_uint() -> uint { *self }\n+    pure fn to_uint(&self) -> uint { **self }\n }\n \n pub impl ToStr for TyVid {\n     pure fn to_str(&self) -> ~str { fmt!(\"<V%u>\", self.to_uint()) }\n }\n \n pub impl Vid for IntVid {\n-    pure fn to_uint() -> uint { *self }\n+    pure fn to_uint(&self) -> uint { **self }\n }\n \n pub impl ToStr for IntVid {\n     pure fn to_str(&self) -> ~str { fmt!(\"<VI%u>\", self.to_uint()) }\n }\n \n pub impl Vid for FloatVid {\n-    pure fn to_uint() -> uint { *self }\n+    pure fn to_uint(&self) -> uint { **self }\n }\n \n pub impl ToStr for FloatVid {\n     pure fn to_str(&self) -> ~str { fmt!(\"<VF%u>\", self.to_uint()) }\n }\n \n pub impl Vid for RegionVid {\n-    pure fn to_uint() -> uint { *self }\n+    pure fn to_uint(&self) -> uint { **self }\n }\n \n pub impl ToStr for RegionVid {"}, {"sha": "e63e46ace3d05abb3ef3bde820b9a158e716c970", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=4a853894fab6b9a4b60c1b3260b446a3473577fa", "patch": "@@ -660,19 +660,19 @@ pub impl FnCtxt {\n }\n \n pub impl region_scope for @mut FnCtxt {\n-    pure fn anon_region(span: span) -> Result<ty::Region, ~str> {\n+    pure fn anon_region(&self, span: span) -> Result<ty::Region, ~str> {\n         // XXX: Unsafe to work around purity\n         unsafe {\n             result::Ok(self.infcx().next_region_var_nb(span))\n         }\n     }\n-    pure fn self_region(_span: span) -> Result<ty::Region, ~str> {\n+    pure fn self_region(&self, _span: span) -> Result<ty::Region, ~str> {\n         // XXX: Unsafe to work around purity\n         unsafe {\n             self.search_in_scope_regions(ty::br_self)\n         }\n     }\n-    pure fn named_region(_span: span, id: ast::ident)\n+    pure fn named_region(&self, _span: span, id: ast::ident)\n                       -> Result<ty::Region, ~str> {\n         // XXX: Unsafe to work around purity\n         unsafe {"}, {"sha": "29738f28266610bfd6e400f42d6c27f6d207728a", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 32, "deletions": 23, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=4a853894fab6b9a4b60c1b3260b446a3473577fa", "patch": "@@ -197,6 +197,7 @@ pub struct CoherenceChecker {\n }\n \n pub impl CoherenceChecker {\n+    // IMPLICIT SELF WARNING: fix this!\n     fn check_coherence(crate: @crate) {\n         // Check implementations and traits. This populates the tables\n         // containing the inherent methods and extension methods. It also\n@@ -235,7 +236,8 @@ pub impl CoherenceChecker {\n         self.populate_destructor_table();\n     }\n \n-    fn check_implementation(item: @item, associated_traits: ~[@trait_ref]) {\n+    fn check_implementation(&self,\n+                            item: @item, associated_traits: ~[@trait_ref]) {\n         let self_type = self.crate_context.tcx.tcache.get(\n             &local_def(item.id));\n \n@@ -302,7 +304,8 @@ pub impl CoherenceChecker {\n                     let implementation;\n                     match implementation_opt {\n                         None => {\n-                            implementation = self.create_impl_from_item(item);\n+                            implementation =\n+                                self.create_impl_from_item(item);\n                         }\n                         Some(copy existing_implementation) => {\n                             implementation = existing_implementation;\n@@ -321,7 +324,7 @@ pub impl CoherenceChecker {\n     // Creates default method IDs and performs type substitutions for an impl\n     // and trait pair. Then, for each provided method in the trait, inserts a\n     // `ProvidedMethodInfo` instance into the `provided_method_sources` map.\n-    fn instantiate_default_methods(impl_id: ast::node_id,\n+    fn instantiate_default_methods(&self, impl_id: ast::node_id,\n                                    trait_did: ast::def_id) {\n         for self.each_provided_trait_method(trait_did) |trait_method| {\n             // Synthesize an ID.\n@@ -330,7 +333,8 @@ pub impl CoherenceChecker {\n             let new_did = local_def(new_id);\n \n             // XXX: Perform substitutions.\n-            let new_polytype = ty::lookup_item_type(tcx, trait_method.def_id);\n+            let new_polytype = ty::lookup_item_type(tcx,\n+                                                    trait_method.def_id);\n             tcx.tcache.insert(new_did, new_polytype);\n \n             // Pair the new synthesized ID up with the\n@@ -380,7 +384,8 @@ pub impl CoherenceChecker {\n         }\n     }\n \n-    fn add_inherent_method(base_def_id: def_id, implementation: @Impl) {\n+    fn add_inherent_method(&self,\n+                           base_def_id: def_id, implementation: @Impl) {\n         let implementation_list;\n         match self.crate_context.coherence_info.inherent_methods\n                   .find(&base_def_id) {\n@@ -397,7 +402,7 @@ pub impl CoherenceChecker {\n         implementation_list.push(implementation);\n     }\n \n-    fn add_trait_method(trait_id: def_id, implementation: @Impl) {\n+    fn add_trait_method(&self, trait_id: def_id, implementation: @Impl) {\n         let implementation_list;\n         match self.crate_context.coherence_info.extension_methods\n                   .find(&trait_id) {\n@@ -414,7 +419,7 @@ pub impl CoherenceChecker {\n         implementation_list.push(implementation);\n     }\n \n-    fn check_implementation_coherence() {\n+    fn check_implementation_coherence(&self) {\n         let coherence_info = &mut self.crate_context.coherence_info;\n         let extension_methods = &coherence_info.extension_methods;\n \n@@ -423,7 +428,7 @@ pub impl CoherenceChecker {\n         }\n     }\n \n-    fn check_implementation_coherence_of(trait_def_id: def_id) {\n+    fn check_implementation_coherence_of(&self, trait_def_id: def_id) {\n \n         // Unify pairs of polytypes.\n         do self.iter_impls_of_trait(trait_def_id) |a| {\n@@ -459,7 +464,8 @@ pub impl CoherenceChecker {\n \n     // Adds an impl of trait trait_t for self type self_t; that impl\n     // is the_impl\n-    fn add_impl_for_trait(trait_t: def_id, self_t: t, the_impl: @Impl) {\n+    fn add_impl_for_trait(&self,\n+                          trait_t: def_id, self_t: t, the_impl: @Impl) {\n         debug!(\"Adding impl %? of %? for %s\",\n                the_impl.did, trait_t,\n                ty_to_str(self.crate_context.tcx, self_t));\n@@ -475,7 +481,7 @@ pub impl CoherenceChecker {\n         }\n     }\n \n-    fn iter_impls_of_trait(trait_def_id: def_id,\n+    fn iter_impls_of_trait(&self, trait_def_id: def_id,\n                            f: &fn(@Impl)) {\n \n         let coherence_info = &mut self.crate_context.coherence_info;\n@@ -491,7 +497,7 @@ pub impl CoherenceChecker {\n         }\n     }\n \n-    fn each_provided_trait_method(\n+    fn each_provided_trait_method(&self,\n             trait_did: ast::def_id,\n             f: &fn(x: &ty::method) -> bool) {\n         // Make a list of all the names of the provided methods.\n@@ -511,7 +517,7 @@ pub impl CoherenceChecker {\n         }\n     }\n \n-    fn polytypes_unify(polytype_a: ty_param_bounds_and_ty,\n+    fn polytypes_unify(&self, polytype_a: ty_param_bounds_and_ty,\n                        polytype_b: ty_param_bounds_and_ty)\n                     -> bool {\n         let universally_quantified_a =\n@@ -527,7 +533,7 @@ pub impl CoherenceChecker {\n \n     // Converts a polytype to a monotype by replacing all parameters with\n     // type variables. Returns the monotype and the type variables created.\n-    fn universally_quantify_polytype(polytype: ty_param_bounds_and_ty)\n+    fn universally_quantify_polytype(&self, polytype: ty_param_bounds_and_ty)\n                                   -> UniversalQuantificationResult {\n         // NDM--this span is bogus.\n         let self_region =\n@@ -558,7 +564,8 @@ pub impl CoherenceChecker {\n         }\n     }\n \n-    fn can_unify_universally_quantified(a: &a/UniversalQuantificationResult,\n+    fn can_unify_universally_quantified(&self,\n+                                        a: &a/UniversalQuantificationResult,\n                                         b: &a/UniversalQuantificationResult)\n                                      -> bool {\n         let mut might_unify = true;\n@@ -610,12 +617,13 @@ pub impl CoherenceChecker {\n         might_unify\n     }\n \n-    fn get_self_type_for_implementation(implementation: @Impl)\n+    fn get_self_type_for_implementation(&self, implementation: @Impl)\n                                      -> ty_param_bounds_and_ty {\n         return self.crate_context.tcx.tcache.get(&implementation.did);\n     }\n \n     // Privileged scope checking\n+    // IMPLICIT SELF WARNING: fix this!\n     fn check_privileged_scopes(crate: @crate) {\n         visit_crate(*crate, (), mk_vt(@Visitor {\n             visit_item: |item, _context, visitor| {\n@@ -699,7 +707,7 @@ pub impl CoherenceChecker {\n         }));\n     }\n \n-    fn trait_ref_to_trait_def_id(trait_ref: @trait_ref) -> def_id {\n+    fn trait_ref_to_trait_def_id(&self, trait_ref: @trait_ref) -> def_id {\n         let def_map = self.crate_context.tcx.def_map;\n         let trait_def = def_map.get(&trait_ref.ref_id);\n         let trait_id = def_id_of_def(trait_def);\n@@ -708,7 +716,7 @@ pub impl CoherenceChecker {\n \n     // This check doesn't really have anything to do with coherence. It's\n     // here for historical reasons\n-    fn please_check_that_trait_methods_are_implemented(\n+    fn please_check_that_trait_methods_are_implemented(&self,\n         all_methods: &mut ~[@MethodInfo],\n         trait_did: def_id,\n         trait_ref_span: span) {\n@@ -735,7 +743,7 @@ pub impl CoherenceChecker {\n     }\n \n     // Converts an implementation in the AST to an Impl structure.\n-    fn create_impl_from_item(item: @item) -> @Impl {\n+    fn create_impl_from_item(&self, item: @item) -> @Impl {\n         fn add_provided_methods(all_methods: &mut ~[@MethodInfo],\n                                 all_provided_methods: ~[@ProvidedMethodInfo],\n                                 sess: driver::session::Session) {\n@@ -806,7 +814,7 @@ pub impl CoherenceChecker {\n         }\n     }\n \n-    fn span_of_impl(implementation: @Impl) -> span {\n+    fn span_of_impl(&self, implementation: @Impl) -> span {\n         assert implementation.did.crate == local_crate;\n         match self.crate_context.tcx.items.find(&implementation.did.node) {\n             Some(node_item(item, _)) => {\n@@ -822,7 +830,7 @@ pub impl CoherenceChecker {\n \n     // External crate handling\n \n-    fn add_impls_for_module(impls_seen: HashMap<def_id,()>,\n+    fn add_impls_for_module(&self, impls_seen: HashMap<def_id,()>,\n                             crate_store: @mut CStore,\n                             module_def_id: def_id) {\n         let implementations = get_impls_for_mod(crate_store,\n@@ -907,7 +915,8 @@ pub impl CoherenceChecker {\n         }\n     }\n \n-    fn add_default_methods_for_external_trait(trait_def_id: ast::def_id) {\n+    fn add_default_methods_for_external_trait(&self,\n+                                              trait_def_id: ast::def_id) {\n         let tcx = self.crate_context.tcx;\n         let pmm = tcx.provided_methods;\n \n@@ -942,7 +951,7 @@ pub impl CoherenceChecker {\n \n     // Adds implementations and traits from external crates to the coherence\n     // info.\n-    fn add_external_crates() {\n+    fn add_external_crates(&self) {\n         let impls_seen = HashMap();\n \n         let crate_store = self.crate_context.tcx.sess.cstore;\n@@ -983,7 +992,7 @@ pub impl CoherenceChecker {\n     // Destructors\n     //\n \n-    fn populate_destructor_table() {\n+    fn populate_destructor_table(&self) {\n         let coherence_info = &mut self.crate_context.coherence_info;\n         let tcx = self.crate_context.tcx;\n         let drop_trait = tcx.lang_items.drop_trait();"}, {"sha": "1c6b1507629c5da9df49e5bf8474333d432a4ec7", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=4a853894fab6b9a4b60c1b3260b446a3473577fa", "patch": "@@ -78,37 +78,38 @@ pub fn macros() {\n }\n \n pub trait Combine {\n-    fn infcx() -> @mut InferCtxt;\n-    fn tag() -> ~str;\n-    fn a_is_expected() -> bool;\n-    fn span() -> span;\n-\n-    fn sub() -> Sub;\n-    fn lub() -> Lub;\n-    fn glb() -> Glb;\n-\n-    fn mts(a: ty::mt, b: ty::mt) -> cres<ty::mt>;\n-    fn contratys(a: ty::t, b: ty::t) -> cres<ty::t>;\n-    fn tys(a: ty::t, b: ty::t) -> cres<ty::t>;\n-    fn tps(as_: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]>;\n-    fn self_tys(a: Option<ty::t>, b: Option<ty::t>) -> cres<Option<ty::t>>;\n-    fn substs(did: ast::def_id, as_: &ty::substs,\n+    fn infcx(&self) -> @mut InferCtxt;\n+    fn tag(&self) -> ~str;\n+    fn a_is_expected(&self) -> bool;\n+    fn span(&self) -> span;\n+\n+    fn sub(&self) -> Sub;\n+    fn lub(&self) -> Lub;\n+    fn glb(&self) -> Glb;\n+\n+    fn mts(&self, a: ty::mt, b: ty::mt) -> cres<ty::mt>;\n+    fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t>;\n+    fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t>;\n+    fn tps(&self, as_: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]>;\n+    fn self_tys(&self, a: Option<ty::t>, b: Option<ty::t>)\n+               -> cres<Option<ty::t>>;\n+    fn substs(&self, did: ast::def_id, as_: &ty::substs,\n               bs: &ty::substs) -> cres<ty::substs>;\n-    fn bare_fn_tys(a: &ty::BareFnTy,\n+    fn bare_fn_tys(&self, a: &ty::BareFnTy,\n                    b: &ty::BareFnTy) -> cres<ty::BareFnTy>;\n-    fn closure_tys(a: &ty::ClosureTy,\n+    fn closure_tys(&self, a: &ty::ClosureTy,\n                    b: &ty::ClosureTy) -> cres<ty::ClosureTy>;\n-    fn fn_sigs(a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig>;\n-    fn flds(a: ty::field, b: ty::field) -> cres<ty::field>;\n-    fn modes(a: ast::mode, b: ast::mode) -> cres<ast::mode>;\n-    fn args(a: ty::arg, b: ty::arg) -> cres<ty::arg>;\n-    fn sigils(p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil>;\n-    fn purities(a: purity, b: purity) -> cres<purity>;\n-    fn abis(a: ast::Abi, b: ast::Abi) -> cres<ast::Abi>;\n-    fn oncenesses(a: Onceness, b: Onceness) -> cres<Onceness>;\n-    fn contraregions(a: ty::Region, b: ty::Region) -> cres<ty::Region>;\n-    fn regions(a: ty::Region, b: ty::Region) -> cres<ty::Region>;\n-    fn vstores(vk: ty::terr_vstore_kind,\n+    fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig>;\n+    fn flds(&self, a: ty::field, b: ty::field) -> cres<ty::field>;\n+    fn modes(&self, a: ast::mode, b: ast::mode) -> cres<ast::mode>;\n+    fn args(&self, a: ty::arg, b: ty::arg) -> cres<ty::arg>;\n+    fn sigils(&self, p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil>;\n+    fn purities(&self, a: purity, b: purity) -> cres<purity>;\n+    fn abis(&self, a: ast::Abi, b: ast::Abi) -> cres<ast::Abi>;\n+    fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<Onceness>;\n+    fn contraregions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region>;\n+    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region>;\n+    fn vstores(&self, vk: ty::terr_vstore_kind,\n                a: ty::vstore, b: ty::vstore) -> cres<ty::vstore>;\n }\n "}, {"sha": "5008791723eeedcabc6ab133ae429b2680ca87ab", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 49, "deletions": 47, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=4a853894fab6b9a4b60c1b3260b446a3473577fa", "patch": "@@ -28,16 +28,16 @@ use std::list;\n pub enum Glb = CombineFields;  // \"greatest lower bound\" (common subtype)\n \n pub impl Combine for Glb {\n-    fn infcx() -> @mut InferCtxt { self.infcx }\n-    fn tag() -> ~str { ~\"glb\" }\n-    fn a_is_expected() -> bool { self.a_is_expected }\n-    fn span() -> span { self.span }\n+    fn infcx(&self) -> @mut InferCtxt { self.infcx }\n+    fn tag(&self) -> ~str { ~\"glb\" }\n+    fn a_is_expected(&self) -> bool { self.a_is_expected }\n+    fn span(&self) -> span { self.span }\n \n-    fn sub() -> Sub { Sub(*self) }\n-    fn lub() -> Lub { Lub(*self) }\n-    fn glb() -> Glb { Glb(*self) }\n+    fn sub(&self) -> Sub { Sub(**self) }\n+    fn lub(&self) -> Lub { Lub(**self) }\n+    fn glb(&self) -> Glb { Glb(**self) }\n \n-    fn mts(a: ty::mt, b: ty::mt) -> cres<ty::mt> {\n+    fn mts(&self, a: ty::mt, b: ty::mt) -> cres<ty::mt> {\n         let tcx = self.infcx.tcx;\n \n         debug!(\"%s.mts(%s, %s)\",\n@@ -49,17 +49,17 @@ pub impl Combine for Glb {\n           // If one side or both is mut, then the GLB must use\n           // the precise type from the mut side.\n           (m_mutbl, m_const) => {\n-            Sub(*self).tys(a.ty, b.ty).chain(|_t| {\n+            Sub(**self).tys(a.ty, b.ty).chain(|_t| {\n                 Ok(ty::mt {ty: a.ty, mutbl: m_mutbl})\n             })\n           }\n           (m_const, m_mutbl) => {\n-            Sub(*self).tys(b.ty, a.ty).chain(|_t| {\n+            Sub(**self).tys(b.ty, a.ty).chain(|_t| {\n                 Ok(ty::mt {ty: b.ty, mutbl: m_mutbl})\n             })\n           }\n           (m_mutbl, m_mutbl) => {\n-            eq_tys(&self, a.ty, b.ty).then(|| {\n+            eq_tys(self, a.ty, b.ty).then(|| {\n                 Ok(ty::mt {ty: a.ty, mutbl: m_mutbl})\n             })\n           }\n@@ -90,11 +90,11 @@ pub impl Combine for Glb {\n         }\n     }\n \n-    fn contratys(a: ty::t, b: ty::t) -> cres<ty::t> {\n-        Lub(*self).tys(a, b)\n+    fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n+        Lub(**self).tys(a, b)\n     }\n \n-    fn purities(a: purity, b: purity) -> cres<purity> {\n+    fn purities(&self, a: purity, b: purity) -> cres<purity> {\n         match (a, b) {\n           (pure_fn, _) | (_, pure_fn) => Ok(pure_fn),\n           (extern_fn, _) | (_, extern_fn) => Ok(extern_fn),\n@@ -103,14 +103,14 @@ pub impl Combine for Glb {\n         }\n     }\n \n-    fn oncenesses(a: Onceness, b: Onceness) -> cres<Onceness> {\n+    fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<Onceness> {\n         match (a, b) {\n             (Many, _) | (_, Many) => Ok(Many),\n             (Once, Once) => Ok(Once)\n         }\n     }\n \n-    fn regions(a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n+    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n         debug!(\"%s.regions(%?, %?)\",\n                self.tag(),\n                a.inf_str(self.infcx),\n@@ -121,34 +121,35 @@ pub impl Combine for Glb {\n         }\n     }\n \n-    fn contraregions(a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n-        Lub(*self).regions(a, b)\n+    fn contraregions(&self, a: ty::Region, b: ty::Region)\n+                    -> cres<ty::Region> {\n+        Lub(**self).regions(a, b)\n     }\n \n-    fn tys(a: ty::t, b: ty::t) -> cres<ty::t> {\n-        super_lattice_tys(&self, a, b)\n+    fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n+        super_lattice_tys(self, a, b)\n     }\n \n     // Traits please (FIXME: #2794):\n \n-    fn flds(a: ty::field, b: ty::field) -> cres<ty::field> {\n-        super_flds(&self, a, b)\n+    fn flds(&self, a: ty::field, b: ty::field) -> cres<ty::field> {\n+        super_flds(self, a, b)\n     }\n \n-    fn vstores(vk: ty::terr_vstore_kind,\n+    fn vstores(&self, vk: ty::terr_vstore_kind,\n                a: ty::vstore, b: ty::vstore) -> cres<ty::vstore> {\n-        super_vstores(&self, vk, a, b)\n+        super_vstores(self, vk, a, b)\n     }\n \n-    fn modes(a: ast::mode, b: ast::mode) -> cres<ast::mode> {\n-        super_modes(&self, a, b)\n+    fn modes(&self, a: ast::mode, b: ast::mode) -> cres<ast::mode> {\n+        super_modes(self, a, b)\n     }\n \n-    fn args(a: ty::arg, b: ty::arg) -> cres<ty::arg> {\n-        super_args(&self, a, b)\n+    fn args(&self, a: ty::arg, b: ty::arg) -> cres<ty::arg> {\n+        super_args(self, a, b)\n     }\n \n-    fn fn_sigs(a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n+    fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n         // Note: this is a subtle algorithm.  For a full explanation,\n         // please see the large comment in `region_inference.rs`.\n \n@@ -166,14 +167,14 @@ pub impl Combine for Glb {\n         let (a_with_fresh, a_isr) =\n             self.infcx.replace_bound_regions_with_fresh_regions(\n                 self.span, a);\n-        let a_vars = var_ids(&self, a_isr);\n+        let a_vars = var_ids(self, a_isr);\n         let (b_with_fresh, b_isr) =\n             self.infcx.replace_bound_regions_with_fresh_regions(\n                 self.span, b);\n-        let b_vars = var_ids(&self, b_isr);\n+        let b_vars = var_ids(self, b_isr);\n \n         // Collect constraints.\n-        let sig0 = if_ok!(super_fn_sigs(&self, &a_with_fresh, &b_with_fresh));\n+        let sig0 = if_ok!(super_fn_sigs(self, &a_with_fresh, &b_with_fresh));\n         debug!(\"sig0 = %s\", sig0.inf_str(self.infcx));\n \n         // Generalize the regions appearing in fn_ty0 if possible\n@@ -182,7 +183,7 @@ pub impl Combine for Glb {\n         let sig1 =\n             self.infcx.fold_regions_in_sig(\n                 &sig0,\n-                |r, _in_fn| generalize_region(&self, snapshot,\n+                |r, _in_fn| generalize_region(self, snapshot,\n                                               new_vars, a_isr, a_vars, b_vars,\n                                               r));\n         debug!(\"sig1 = %s\", sig1.inf_str(self.infcx));\n@@ -267,36 +268,37 @@ pub impl Combine for Glb {\n         }\n     }\n \n-    fn sigils(p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil> {\n-        super_sigils(&self, p1, p2)\n+    fn sigils(&self, p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil> {\n+        super_sigils(self, p1, p2)\n     }\n \n-    fn abis(p1: ast::Abi, p2: ast::Abi) -> cres<ast::Abi> {\n-        super_abis(&self, p1, p2)\n+    fn abis(&self, p1: ast::Abi, p2: ast::Abi) -> cres<ast::Abi> {\n+        super_abis(self, p1, p2)\n     }\n \n-    fn bare_fn_tys(a: &ty::BareFnTy,\n+    fn bare_fn_tys(&self, a: &ty::BareFnTy,\n                    b: &ty::BareFnTy) -> cres<ty::BareFnTy> {\n-        super_bare_fn_tys(&self, a, b)\n+        super_bare_fn_tys(self, a, b)\n     }\n \n-    fn closure_tys(a: &ty::ClosureTy,\n+    fn closure_tys(&self, a: &ty::ClosureTy,\n                    b: &ty::ClosureTy) -> cres<ty::ClosureTy> {\n-        super_closure_tys(&self, a, b)\n+        super_closure_tys(self, a, b)\n     }\n \n-    fn substs(did: ast::def_id,\n+    fn substs(&self, did: ast::def_id,\n               as_: &ty::substs,\n               bs: &ty::substs) -> cres<ty::substs> {\n-        super_substs(&self, did, as_, bs)\n+        super_substs(self, did, as_, bs)\n     }\n \n-    fn tps(as_: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]> {\n-        super_tps(&self, as_, bs)\n+    fn tps(&self, as_: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]> {\n+        super_tps(self, as_, bs)\n     }\n \n-    fn self_tys(a: Option<ty::t>, b: Option<ty::t>) -> cres<Option<ty::t>> {\n-        super_self_tys(&self, a, b)\n+    fn self_tys(&self, a: Option<ty::t>, b: Option<ty::t>)\n+               -> cres<Option<ty::t>> {\n+        super_self_tys(self, a, b)\n     }\n }\n "}, {"sha": "1a919ac0f3b0b8850820bfbfe8b2e9848f195582", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=4a853894fab6b9a4b60c1b3260b446a3473577fa", "patch": "@@ -50,23 +50,27 @@ use middle::typeck::infer::to_str::InferStr;\n use std::list;\n \n pub trait LatticeValue {\n-    static fn sub(cf: &CombineFields, a: &Self, b: &Self) -> ures;\n-    static fn lub(cf: &CombineFields, a: &Self, b: &Self) -> cres<Self>;\n-    static fn glb(cf: &CombineFields, a: &Self, b: &Self) -> cres<Self>;\n+    static fn sub(&self, cf: &CombineFields, a: &Self, b: &Self) -> ures;\n+    static fn lub(&self, cf: &CombineFields, a: &Self, b: &Self)\n+                 -> cres<Self>;\n+    static fn glb(&self, cf: &CombineFields, a: &Self, b: &Self)\n+                 -> cres<Self>;\n }\n \n pub type LatticeOp<T> = &fn(cf: &CombineFields, a: &T, b: &T) -> cres<T>;\n \n pub impl LatticeValue for ty::t {\n-    static fn sub(cf: &CombineFields, a: &ty::t, b: &ty::t) -> ures {\n+    static fn sub(&self, cf: &CombineFields, a: &ty::t, b: &ty::t) -> ures {\n         Sub(*cf).tys(*a, *b).to_ures()\n     }\n \n-    static fn lub(cf: &CombineFields, a: &ty::t, b: &ty::t) -> cres<ty::t> {\n+    static fn lub(&self, cf: &CombineFields, a: &ty::t, b: &ty::t)\n+                 -> cres<ty::t> {\n         Lub(*cf).tys(*a, *b)\n     }\n \n-    static fn glb(cf: &CombineFields, a: &ty::t, b: &ty::t) -> cres<ty::t> {\n+    static fn glb(&self, cf: &CombineFields, a: &ty::t, b: &ty::t)\n+                 -> cres<ty::t> {\n         Glb(*cf).tys(*a, *b)\n     }\n }\n@@ -292,39 +296,39 @@ pub impl CombineFields {\n // for pairs of variables or for variables and values.\n \n pub trait LatticeDir {\n-    fn combine_fields() -> CombineFields;\n-    fn bnd<T:Copy>(b: &Bounds<T>) -> Option<T>;\n-    fn with_bnd<T:Copy>(b: &Bounds<T>, +t: T) -> Bounds<T>;\n+    fn combine_fields(&self) -> CombineFields;\n+    fn bnd<T:Copy>(&self, b: &Bounds<T>) -> Option<T>;\n+    fn with_bnd<T:Copy>(&self, b: &Bounds<T>, +t: T) -> Bounds<T>;\n }\n \n pub trait TyLatticeDir {\n-    fn ty_bot(t: ty::t) -> cres<ty::t>;\n+    fn ty_bot(&self, t: ty::t) -> cres<ty::t>;\n }\n \n pub impl LatticeDir for Lub {\n-    fn combine_fields() -> CombineFields { *self }\n-    fn bnd<T:Copy>(b: &Bounds<T>) -> Option<T> { b.ub }\n-    fn with_bnd<T:Copy>(b: &Bounds<T>, +t: T) -> Bounds<T> {\n+    fn combine_fields(&self) -> CombineFields { **self }\n+    fn bnd<T:Copy>(&self, b: &Bounds<T>) -> Option<T> { b.ub }\n+    fn with_bnd<T:Copy>(&self, b: &Bounds<T>, +t: T) -> Bounds<T> {\n         Bounds { ub: Some(t), ..*b }\n     }\n }\n \n pub impl TyLatticeDir for Lub {\n-    fn ty_bot(t: ty::t) -> cres<ty::t> {\n+    fn ty_bot(&self, t: ty::t) -> cres<ty::t> {\n         Ok(t)\n     }\n }\n \n pub impl LatticeDir for Glb {\n-    fn combine_fields() -> CombineFields { *self }\n-    fn bnd<T:Copy>(b: &Bounds<T>) -> Option<T> { b.lb }\n-    fn with_bnd<T:Copy>(b: &Bounds<T>, +t: T) -> Bounds<T> {\n+    fn combine_fields(&self) -> CombineFields { **self }\n+    fn bnd<T:Copy>(&self, b: &Bounds<T>) -> Option<T> { b.lb }\n+    fn with_bnd<T:Copy>(&self, b: &Bounds<T>, +t: T) -> Bounds<T> {\n         Bounds { lb: Some(t), ..*b }\n     }\n }\n \n pub impl TyLatticeDir for Glb {\n-    fn ty_bot(_t: ty::t) -> cres<ty::t> {\n+    fn ty_bot(&self, _t: ty::t) -> cres<ty::t> {\n         Ok(ty::mk_bot(self.infcx.tcx))\n     }\n }"}, {"sha": "df4b8c0be09b51fcf53c34b3a8802861077724e9", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 49, "deletions": 45, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=4a853894fab6b9a4b60c1b3260b446a3473577fa", "patch": "@@ -32,21 +32,22 @@ pub fn macros() {\n pub enum Lub = CombineFields;  // least-upper-bound: common supertype\n \n pub impl Lub {\n-    fn bot_ty(b: ty::t) -> cres<ty::t> { Ok(b) }\n-    fn ty_bot(b: ty::t) -> cres<ty::t> { self.bot_ty(b) } // commutative\n+    fn bot_ty(&self, b: ty::t) -> cres<ty::t> { Ok(b) }\n+    fn ty_bot(&self, b: ty::t)\n+             -> cres<ty::t> { self.bot_ty(b) } // commutative\n }\n \n pub impl Combine for Lub {\n-    fn infcx() -> @mut InferCtxt { self.infcx }\n-    fn tag() -> ~str { ~\"lub\" }\n-    fn a_is_expected() -> bool { self.a_is_expected }\n-    fn span() -> span { self.span }\n+    fn infcx(&self) -> @mut InferCtxt { self.infcx }\n+    fn tag(&self) -> ~str { ~\"lub\" }\n+    fn a_is_expected(&self) -> bool { self.a_is_expected }\n+    fn span(&self) -> span { self.span }\n \n-    fn sub() -> Sub { Sub(*self) }\n-    fn lub() -> Lub { Lub(*self) }\n-    fn glb() -> Glb { Glb(*self) }\n+    fn sub(&self) -> Sub { Sub(**self) }\n+    fn lub(&self) -> Lub { Lub(**self) }\n+    fn glb(&self) -> Glb { Glb(**self) }\n \n-    fn mts(a: ty::mt, b: ty::mt) -> cres<ty::mt> {\n+    fn mts(&self, a: ty::mt, b: ty::mt) -> cres<ty::mt> {\n         let tcx = self.infcx.tcx;\n \n         debug!(\"%s.mts(%s, %s)\",\n@@ -67,7 +68,7 @@ pub impl Combine for Lub {\n \n           m_mutbl => {\n             self.infcx.try(|| {\n-                eq_tys(&self, a.ty, b.ty).then(|| {\n+                eq_tys(self, a.ty, b.ty).then(|| {\n                     Ok(ty::mt {ty: a.ty, mutbl: m})\n                 })\n             }).chain_err(|_e| {\n@@ -79,11 +80,11 @@ pub impl Combine for Lub {\n         }\n     }\n \n-    fn contratys(a: ty::t, b: ty::t) -> cres<ty::t> {\n-        Glb(*self).tys(a, b)\n+    fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n+        Glb(**self).tys(a, b)\n     }\n \n-    fn purities(a: purity, b: purity) -> cres<purity> {\n+    fn purities(&self, a: purity, b: purity) -> cres<purity> {\n         match (a, b) {\n           (unsafe_fn, _) | (_, unsafe_fn) => Ok(unsafe_fn),\n           (impure_fn, _) | (_, impure_fn) => Ok(impure_fn),\n@@ -92,18 +93,19 @@ pub impl Combine for Lub {\n         }\n     }\n \n-    fn oncenesses(a: Onceness, b: Onceness) -> cres<Onceness> {\n+    fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<Onceness> {\n         match (a, b) {\n             (Once, _) | (_, Once) => Ok(Once),\n             (Many, Many) => Ok(Many)\n         }\n     }\n \n-    fn contraregions(a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n-        return Glb(*self).regions(a, b);\n+    fn contraregions(&self, a: ty::Region, b: ty::Region)\n+                    -> cres<ty::Region> {\n+        return Glb(**self).regions(a, b);\n     }\n \n-    fn regions(a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n+    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n         debug!(\"%s.regions(%?, %?)\",\n                self.tag(),\n                a.inf_str(self.infcx),\n@@ -114,7 +116,7 @@ pub impl Combine for Lub {\n         }\n     }\n \n-    fn fn_sigs(a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n+    fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n         // Note: this is a subtle algorithm.  For a full explanation,\n         // please see the large comment in `region_inference.rs`.\n \n@@ -133,7 +135,7 @@ pub impl Combine for Lub {\n                 self.span, b);\n \n         // Collect constraints.\n-        let sig0 = if_ok!(super_fn_sigs(&self, &a_with_fresh, &b_with_fresh));\n+        let sig0 = if_ok!(super_fn_sigs(self, &a_with_fresh, &b_with_fresh));\n         debug!(\"sig0 = %s\", sig0.inf_str(self.infcx));\n \n         // Generalize the regions appearing in sig0 if possible\n@@ -142,7 +144,7 @@ pub impl Combine for Lub {\n         let sig1 =\n             self.infcx.fold_regions_in_sig(\n                 &sig0,\n-                |r, _in_fn| generalize_region(&self, snapshot, new_vars,\n+                |r, _in_fn| generalize_region(self, snapshot, new_vars,\n                                               a_isr, r));\n         return Ok(sig1);\n \n@@ -191,58 +193,60 @@ pub impl Combine for Lub {\n         }\n     }\n \n-    fn bare_fn_tys(a: &ty::BareFnTy,\n+    fn bare_fn_tys(&self, a: &ty::BareFnTy,\n                    b: &ty::BareFnTy) -> cres<ty::BareFnTy> {\n-        super_bare_fn_tys(&self, a, b)\n+        super_bare_fn_tys(self, a, b)\n     }\n \n-    fn closure_tys(a: &ty::ClosureTy,\n+    fn closure_tys(&self, a: &ty::ClosureTy,\n                    b: &ty::ClosureTy) -> cres<ty::ClosureTy> {\n-        super_closure_tys(&self, a, b)\n+        super_closure_tys(self, a, b)\n     }\n \n     // Traits please (FIXME: #2794):\n \n-    fn sigils(p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil> {\n-        super_sigils(&self, p1, p2)\n+    fn sigils(&self, p1: ast::Sigil, p2: ast::Sigil)\n+             -> cres<ast::Sigil> {\n+        super_sigils(self, p1, p2)\n     }\n \n-    fn abis(p1: ast::Abi, p2: ast::Abi) -> cres<ast::Abi> {\n-        super_abis(&self, p1, p2)\n+    fn abis(&self, p1: ast::Abi, p2: ast::Abi) -> cres<ast::Abi> {\n+        super_abis(self, p1, p2)\n     }\n \n-    fn tys(a: ty::t, b: ty::t) -> cres<ty::t> {\n-        super_lattice_tys(&self, a, b)\n+    fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n+        super_lattice_tys(self, a, b)\n     }\n \n-    fn flds(a: ty::field, b: ty::field) -> cres<ty::field> {\n-        super_flds(&self, a, b)\n+    fn flds(&self, a: ty::field, b: ty::field) -> cres<ty::field> {\n+        super_flds(self, a, b)\n     }\n \n-    fn vstores(vk: ty::terr_vstore_kind,\n+    fn vstores(&self, vk: ty::terr_vstore_kind,\n                a: ty::vstore, b: ty::vstore) -> cres<ty::vstore> {\n-        super_vstores(&self, vk, a, b)\n+        super_vstores(self, vk, a, b)\n     }\n \n-    fn modes(a: ast::mode, b: ast::mode) -> cres<ast::mode> {\n-        super_modes(&self, a, b)\n+    fn modes(&self, a: ast::mode, b: ast::mode) -> cres<ast::mode> {\n+        super_modes(self, a, b)\n     }\n \n-    fn args(a: ty::arg, b: ty::arg) -> cres<ty::arg> {\n-        super_args(&self, a, b)\n+    fn args(&self, a: ty::arg, b: ty::arg) -> cres<ty::arg> {\n+        super_args(self, a, b)\n     }\n \n-    fn substs(did: ast::def_id,\n+    fn substs(&self, did: ast::def_id,\n               as_: &ty::substs,\n               bs: &ty::substs) -> cres<ty::substs> {\n-        super_substs(&self, did, as_, bs)\n+        super_substs(self, did, as_, bs)\n     }\n \n-    fn tps(as_: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]> {\n-        super_tps(&self, as_, bs)\n+    fn tps(&self, as_: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]> {\n+        super_tps(self, as_, bs)\n     }\n \n-    fn self_tys(a: Option<ty::t>, b: Option<ty::t>) -> cres<Option<ty::t>> {\n-        super_self_tys(&self, a, b)\n+    fn self_tys(&self, a: Option<ty::t>, b: Option<ty::t>)\n+               -> cres<Option<ty::t>> {\n+        super_self_tys(self, a, b)\n     }\n }"}, {"sha": "f013712595281d39c85ea8cd76e2104478637674", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=4a853894fab6b9a4b60c1b3260b446a3473577fa", "patch": "@@ -489,39 +489,39 @@ fn resolve_borrowings(cx: @mut InferCtxt) {\n */\n \n trait then {\n-    fn then<T:Copy>(f: fn() -> Result<T,ty::type_err>)\n+    fn then<T:Copy>(&self, f: fn() -> Result<T,ty::type_err>)\n         -> Result<T,ty::type_err>;\n }\n \n impl then for ures {\n-    fn then<T:Copy>(f: fn() -> Result<T,ty::type_err>)\n+    fn then<T:Copy>(&self, f: fn() -> Result<T,ty::type_err>)\n         -> Result<T,ty::type_err> {\n         self.chain(|_i| f())\n     }\n }\n \n trait ToUres {\n-    fn to_ures() -> ures;\n+    fn to_ures(&self) -> ures;\n }\n \n impl<T> ToUres for cres<T> {\n-    fn to_ures() -> ures {\n-        match self {\n+    fn to_ures(&self) -> ures {\n+        match *self {\n           Ok(ref _v) => Ok(()),\n           Err(ref e) => Err((*e))\n         }\n     }\n }\n \n trait CresCompare<T> {\n-    fn compare(t: T, f: fn() -> ty::type_err) -> cres<T>;\n+    fn compare(&self, t: T, f: fn() -> ty::type_err) -> cres<T>;\n }\n \n impl<T:Copy + Eq> CresCompare<T> for cres<T> {\n-    fn compare(t: T, f: fn() -> ty::type_err) -> cres<T> {\n+    fn compare(&self, t: T, f: fn() -> ty::type_err) -> cres<T> {\n         do self.chain |s| {\n             if s == t {\n-                self\n+                *self\n             } else {\n                 Err(f())\n             }\n@@ -551,22 +551,22 @@ struct Snapshot {\n }\n \n impl @mut InferCtxt {\n-    fn combine_fields(a_is_expected: bool,\n+    fn combine_fields(&self, a_is_expected: bool,\n                       span: span) -> CombineFields {\n-        CombineFields {infcx: self,\n+        CombineFields {infcx: *self,\n                        a_is_expected: a_is_expected,\n                        span: span}\n     }\n \n-    fn sub(a_is_expected: bool, span: span) -> Sub {\n+    fn sub(&self, a_is_expected: bool, span: span) -> Sub {\n         Sub(self.combine_fields(a_is_expected, span))\n     }\n \n-    fn in_snapshot() -> bool {\n+    fn in_snapshot(&self) -> bool {\n         self.region_vars.in_snapshot()\n     }\n \n-    fn start_snapshot() -> Snapshot {\n+    fn start_snapshot(&self) -> Snapshot {\n         Snapshot {\n             ty_var_bindings_len:\n                 self.ty_var_bindings.bindings.len(),\n@@ -579,7 +579,7 @@ impl @mut InferCtxt {\n         }\n     }\n \n-    fn rollback_to(snapshot: &Snapshot) {\n+    fn rollback_to(&self, snapshot: &Snapshot) {\n         debug!(\"rollback!\");\n         rollback_to(&mut self.ty_var_bindings, snapshot.ty_var_bindings_len);\n \n@@ -643,45 +643,45 @@ fn next_simple_var<V:Copy,T:Copy>(\n }\n \n impl @mut InferCtxt {\n-    fn next_ty_var_id() -> TyVid {\n+    fn next_ty_var_id(&self) -> TyVid {\n         let id = self.ty_var_counter;\n         self.ty_var_counter += 1;\n         let vals = self.ty_var_bindings.vals;\n         vals.insert(id, Root(Bounds { lb: None, ub: None }, 0u));\n         return TyVid(id);\n     }\n \n-    fn next_ty_var() -> ty::t {\n+    fn next_ty_var(&self) -> ty::t {\n         ty::mk_var(self.tcx, self.next_ty_var_id())\n     }\n \n-    fn next_ty_vars(n: uint) -> ~[ty::t] {\n+    fn next_ty_vars(&self, n: uint) -> ~[ty::t] {\n         vec::from_fn(n, |_i| self.next_ty_var())\n     }\n \n-    fn next_int_var_id() -> IntVid {\n+    fn next_int_var_id(&self) -> IntVid {\n         IntVid(next_simple_var(&mut self.int_var_counter,\n                                &mut self.int_var_bindings))\n     }\n \n-    fn next_int_var() -> ty::t {\n+    fn next_int_var(&self) -> ty::t {\n         ty::mk_int_var(self.tcx, self.next_int_var_id())\n     }\n \n-    fn next_float_var_id() -> FloatVid {\n+    fn next_float_var_id(&self) -> FloatVid {\n         FloatVid(next_simple_var(&mut self.float_var_counter,\n                                  &mut self.float_var_bindings))\n     }\n \n-    fn next_float_var() -> ty::t {\n+    fn next_float_var(&self) -> ty::t {\n         ty::mk_float_var(self.tcx, self.next_float_var_id())\n     }\n \n-    fn next_region_var_nb(span: span) -> ty::Region {\n+    fn next_region_var_nb(&self, span: span) -> ty::Region {\n         ty::re_infer(ty::ReVar(self.region_vars.new_region_var(span)))\n     }\n \n-    fn next_region_var_with_lb(span: span,\n+    fn next_region_var_with_lb(&self, span: span,\n                                lb_region: ty::Region) -> ty::Region {\n         let region_var = self.next_region_var_nb(span);\n \n@@ -693,27 +693,28 @@ impl @mut InferCtxt {\n         return region_var;\n     }\n \n-    fn next_region_var(span: span, scope_id: ast::node_id) -> ty::Region {\n+    fn next_region_var(&self, span: span, scope_id: ast::node_id)\n+                      -> ty::Region {\n         self.next_region_var_with_lb(span, ty::re_scope(scope_id))\n     }\n \n-    fn resolve_regions() {\n+    fn resolve_regions(&self) {\n         self.region_vars.resolve_regions();\n     }\n \n-    fn ty_to_str(t: ty::t) -> ~str {\n+    fn ty_to_str(&self, t: ty::t) -> ~str {\n         ty_to_str(self.tcx,\n                   self.resolve_type_vars_if_possible(t))\n     }\n \n-    fn resolve_type_vars_if_possible(typ: ty::t) -> ty::t {\n-        match resolve_type(self, typ, resolve_nested_tvar | resolve_ivar) {\n+    fn resolve_type_vars_if_possible(&self, typ: ty::t) -> ty::t {\n+        match resolve_type(*self, typ, resolve_nested_tvar | resolve_ivar) {\n           result::Ok(new_type) => new_type,\n           result::Err(_) => typ\n         }\n     }\n \n-    fn type_error_message(sp: span, mk_msg: fn(~str) -> ~str,\n+    fn type_error_message(&self, sp: span, mk_msg: fn(~str) -> ~str,\n                           actual_ty: ty::t, err: Option<&ty::type_err>) {\n         let actual_ty = self.resolve_type_vars_if_possible(actual_ty);\n \n@@ -731,7 +732,7 @@ impl @mut InferCtxt {\n              ty::note_and_explain_type_err(self.tcx, *err));\n     }\n \n-    fn report_mismatched_types(sp: span, e: ty::t, a: ty::t,\n+    fn report_mismatched_types(&self, sp: span, e: ty::t, a: ty::t,\n                                err: &ty::type_err) {\n         // Don't report an error if expected is ty_err\n         let resolved_expected =\n@@ -749,7 +750,7 @@ impl @mut InferCtxt {\n         self.type_error_message(sp, mk_msg, a, Some(err));\n     }\n \n-    fn replace_bound_regions_with_fresh_regions(\n+    fn replace_bound_regions_with_fresh_regions(&self,\n             span: span,\n             fsig: &ty::FnSig)\n          -> (ty::FnSig, isr_alist) {"}, {"sha": "661c67dbefc6251ddbeea42d021fb0285d735672", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 47, "deletions": 45, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=4a853894fab6b9a4b60c1b3260b446a3473577fa", "patch": "@@ -33,30 +33,31 @@ pub fn macros() {\n pub enum Sub = CombineFields;  // \"subtype\", \"subregion\" etc\n \n pub impl Combine for Sub {\n-    fn infcx() -> @mut InferCtxt { self.infcx }\n-    fn tag() -> ~str { ~\"sub\" }\n-    fn a_is_expected() -> bool { self.a_is_expected }\n-    fn span() -> span { self.span }\n+    fn infcx(&self) -> @mut InferCtxt { self.infcx }\n+    fn tag(&self) -> ~str { ~\"sub\" }\n+    fn a_is_expected(&self) -> bool { self.a_is_expected }\n+    fn span(&self) -> span { self.span }\n \n-    fn sub() -> Sub { Sub(*self) }\n-    fn lub() -> Lub { Lub(*self) }\n-    fn glb() -> Glb { Glb(*self) }\n+    fn sub(&self) -> Sub { Sub(**self) }\n+    fn lub(&self) -> Lub { Lub(**self) }\n+    fn glb(&self) -> Glb { Glb(**self) }\n \n-    fn contratys(a: ty::t, b: ty::t) -> cres<ty::t> {\n+    fn contratys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n         let opp = CombineFields {\n-            a_is_expected: !self.a_is_expected,.. *self\n+            a_is_expected: !self.a_is_expected,.. **self\n         };\n         Sub(opp).tys(b, a)\n     }\n \n-    fn contraregions(a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n+    fn contraregions(&self, a: ty::Region, b: ty::Region)\n+                    -> cres<ty::Region> {\n         let opp = CombineFields {\n-            a_is_expected: !self.a_is_expected,.. *self\n+            a_is_expected: !self.a_is_expected,.. **self\n         };\n         Sub(opp).regions(b, a)\n     }\n \n-    fn regions(a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n+    fn regions(&self, a: ty::Region, b: ty::Region) -> cres<ty::Region> {\n         debug!(\"%s.regions(%s, %s)\",\n                self.tag(),\n                a.inf_str(self.infcx),\n@@ -69,7 +70,7 @@ pub impl Combine for Sub {\n         }\n     }\n \n-    fn mts(a: ty::mt, b: ty::mt) -> cres<ty::mt> {\n+    fn mts(&self, a: ty::mt, b: ty::mt) -> cres<ty::mt> {\n         debug!(\"mts(%s <: %s)\", a.inf_str(self.infcx), b.inf_str(self.infcx));\n \n         if a.mutbl != b.mutbl && b.mutbl != m_const {\n@@ -80,7 +81,7 @@ pub impl Combine for Sub {\n           m_mutbl => {\n             // If supertype is mut, subtype must match exactly\n             // (i.e., invariant if mut):\n-            eq_tys(&self, a.ty, b.ty).then(|| Ok(a) )\n+            eq_tys(self, a.ty, b.ty).then(|| Ok(a) )\n           }\n           m_imm | m_const => {\n             // Otherwise we can be covariant:\n@@ -89,19 +90,19 @@ pub impl Combine for Sub {\n         }\n     }\n \n-    fn purities(a: purity, b: purity) -> cres<purity> {\n+    fn purities(&self, a: purity, b: purity) -> cres<purity> {\n         self.lub().purities(a, b).compare(b, || {\n-            ty::terr_purity_mismatch(expected_found(&self, a, b))\n+            ty::terr_purity_mismatch(expected_found(self, a, b))\n         })\n     }\n \n-    fn oncenesses(a: Onceness, b: Onceness) -> cres<Onceness> {\n+    fn oncenesses(&self, a: Onceness, b: Onceness) -> cres<Onceness> {\n         self.lub().oncenesses(a, b).compare(b, || {\n-            ty::terr_onceness_mismatch(expected_found(&self, a, b))\n+            ty::terr_onceness_mismatch(expected_found(self, a, b))\n         })\n     }\n \n-    fn tys(a: ty::t, b: ty::t) -> cres<ty::t> {\n+    fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {\n         debug!(\"%s.tys(%s, %s)\", self.tag(),\n                a.inf_str(self.infcx), b.inf_str(self.infcx));\n         if a == b { return Ok(a); }\n@@ -125,16 +126,16 @@ pub impl Combine for Sub {\n             }\n \n             (_, &ty::ty_bot) => {\n-                Err(ty::terr_sorts(expected_found(&self, a, b)))\n+                Err(ty::terr_sorts(expected_found(self, a, b)))\n             }\n \n             _ => {\n-                super_tys(&self, a, b)\n+                super_tys(self, a, b)\n             }\n         }\n     }\n \n-    fn fn_sigs(a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n+    fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n         debug!(\"fn_sigs(a=%s, b=%s)\",\n                a.inf_str(self.infcx), b.inf_str(self.infcx));\n         let _indenter = indenter();\n@@ -175,7 +176,7 @@ pub impl Combine for Sub {\n         debug!(\"b_sig=%s\", b_sig.inf_str(self.infcx));\n \n         // Compare types now that bound regions have been replaced.\n-        let sig = if_ok!(super_fn_sigs(&self, &a_sig, &b_sig));\n+        let sig = if_ok!(super_fn_sigs(self, &a_sig, &b_sig));\n \n         // Presuming type comparison succeeds, we need to check\n         // that the skolemized regions do not \"leak\".\n@@ -212,53 +213,54 @@ pub impl Combine for Sub {\n \n     // Traits please (FIXME: #2794):\n \n-    fn sigils(p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil> {\n-        super_sigils(&self, p1, p2)\n+    fn sigils(&self, p1: ast::Sigil, p2: ast::Sigil) -> cres<ast::Sigil> {\n+        super_sigils(self, p1, p2)\n     }\n \n-    fn abis(p1: ast::Abi, p2: ast::Abi) -> cres<ast::Abi> {\n-        super_abis(&self, p1, p2)\n+    fn abis(&self, p1: ast::Abi, p2: ast::Abi) -> cres<ast::Abi> {\n+        super_abis(self, p1, p2)\n     }\n \n-    fn flds(a: ty::field, b: ty::field) -> cres<ty::field> {\n-        super_flds(&self, a, b)\n+    fn flds(&self, a: ty::field, b: ty::field) -> cres<ty::field> {\n+        super_flds(self, a, b)\n     }\n \n-    fn bare_fn_tys(a: &ty::BareFnTy,\n+    fn bare_fn_tys(&self, a: &ty::BareFnTy,\n                    b: &ty::BareFnTy) -> cres<ty::BareFnTy> {\n-        super_bare_fn_tys(&self, a, b)\n+        super_bare_fn_tys(self, a, b)\n     }\n \n-    fn closure_tys(a: &ty::ClosureTy,\n+    fn closure_tys(&self, a: &ty::ClosureTy,\n                    b: &ty::ClosureTy) -> cres<ty::ClosureTy> {\n-        super_closure_tys(&self, a, b)\n+        super_closure_tys(self, a, b)\n     }\n \n-    fn vstores(vk: ty::terr_vstore_kind,\n+    fn vstores(&self, vk: ty::terr_vstore_kind,\n                a: ty::vstore, b: ty::vstore) -> cres<ty::vstore> {\n-        super_vstores(&self, vk, a, b)\n+        super_vstores(self, vk, a, b)\n     }\n \n-    fn modes(a: ast::mode, b: ast::mode) -> cres<ast::mode> {\n-        super_modes(&self, a, b)\n+    fn modes(&self, a: ast::mode, b: ast::mode) -> cres<ast::mode> {\n+        super_modes(self, a, b)\n     }\n \n-    fn args(a: ty::arg, b: ty::arg) -> cres<ty::arg> {\n-        super_args(&self, a, b)\n+    fn args(&self, a: ty::arg, b: ty::arg) -> cres<ty::arg> {\n+        super_args(self, a, b)\n     }\n \n-    fn substs(did: ast::def_id,\n+    fn substs(&self, did: ast::def_id,\n               as_: &ty::substs,\n               bs: &ty::substs) -> cres<ty::substs> {\n-        super_substs(&self, did, as_, bs)\n+        super_substs(self, did, as_, bs)\n     }\n \n-    fn tps(as_: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]> {\n-        super_tps(&self, as_, bs)\n+    fn tps(&self, as_: &[ty::t], bs: &[ty::t]) -> cres<~[ty::t]> {\n+        super_tps(self, as_, bs)\n     }\n \n-    fn self_tys(a: Option<ty::t>, b: Option<ty::t>) -> cres<Option<ty::t>> {\n-        super_self_tys(&self, a, b)\n+    fn self_tys(&self, a: Option<ty::t>, b: Option<ty::t>)\n+               -> cres<Option<ty::t>> {\n+        super_self_tys(self, a, b)\n     }\n }\n "}, {"sha": "d9b2b73890d42d3cf84d85646d819d0544c002ec", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=4a853894fab6b9a4b60c1b3260b446a3473577fa", "patch": "@@ -38,7 +38,7 @@ pub struct Node<V, T> {\n }\n \n pub trait UnifyVid<T> {\n-    static fn appropriate_vals_and_bindings(infcx: &v/mut InferCtxt)\n+    static fn appropriate_vals_and_bindings(&self, infcx: &v/mut InferCtxt)\n         -> &v/mut ValsAndBindings<Self, T>;\n }\n \n@@ -147,7 +147,7 @@ pub impl InferCtxt {\n // doesn't have a subtyping relationship we need to worry about.\n \n pub trait SimplyUnifiable {\n-    static fn to_type_err(expected_found<Self>) -> ty::type_err;\n+    static fn to_type_err(&self, expected_found<Self>) -> ty::type_err;\n }\n \n pub fn mk_err<T:SimplyUnifiable>(+a_is_expected: bool,\n@@ -238,35 +238,35 @@ pub impl InferCtxt {\n // ______________________________________________________________________\n \n pub impl UnifyVid<Bounds<ty::t>> for ty::TyVid {\n-    static fn appropriate_vals_and_bindings(infcx: &v/mut InferCtxt)\n+    static fn appropriate_vals_and_bindings(&self, infcx: &v/mut InferCtxt)\n         -> &v/mut ValsAndBindings<ty::TyVid, Bounds<ty::t>> {\n         return &mut infcx.ty_var_bindings;\n     }\n }\n \n pub impl UnifyVid<Option<IntVarValue>> for ty::IntVid {\n-    static fn appropriate_vals_and_bindings(infcx: &v/mut InferCtxt)\n+    static fn appropriate_vals_and_bindings(&self, infcx: &v/mut InferCtxt)\n         -> &v/mut ValsAndBindings<ty::IntVid, Option<IntVarValue>> {\n         return &mut infcx.int_var_bindings;\n     }\n }\n \n pub impl SimplyUnifiable for IntVarValue {\n-    static fn to_type_err(err: expected_found<IntVarValue>)\n+    static fn to_type_err(&self, err: expected_found<IntVarValue>)\n         -> ty::type_err {\n         return ty::terr_int_mismatch(err);\n     }\n }\n \n pub impl UnifyVid<Option<ast::float_ty>> for ty::FloatVid {\n-    static fn appropriate_vals_and_bindings(infcx: &v/mut InferCtxt)\n+    static fn appropriate_vals_and_bindings(&self, infcx: &v/mut InferCtxt)\n         -> &v/mut ValsAndBindings<ty::FloatVid, Option<ast::float_ty>> {\n         return &mut infcx.float_var_bindings;\n     }\n }\n \n pub impl SimplyUnifiable for ast::float_ty {\n-    static fn to_type_err(err: expected_found<ast::float_ty>)\n+    static fn to_type_err(&self, err: expected_found<ast::float_ty>)\n         -> ty::type_err {\n         return ty::terr_float_mismatch(err);\n     }"}, {"sha": "49b818328be068ff41335b660ec9678b2cb5235f", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=4a853894fab6b9a4b60c1b3260b446a3473577fa", "patch": "@@ -172,8 +172,8 @@ pub enum vtable_origin {\n }\n \n pub impl vtable_origin {\n-    fn to_str(tcx: ty::ctxt) -> ~str {\n-        match self {\n+    fn to_str(&self, tcx: ty::ctxt) -> ~str {\n+        match *self {\n             vtable_static(def_id, ref tys, ref vtable_res) => {\n                 fmt!(\"vtable_static(%?:%s, %?, %?)\",\n                      def_id, ty::item_path_str(tcx, def_id),\n@@ -279,17 +279,17 @@ pub fn require_same_types(\n pub type isr_alist = @List<(ty::bound_region, ty::Region)>;\n \n trait get_and_find_region {\n-    fn get(br: ty::bound_region) -> ty::Region;\n-    fn find(br: ty::bound_region) -> Option<ty::Region>;\n+    fn get(&self, br: ty::bound_region) -> ty::Region;\n+    fn find(&self, br: ty::bound_region) -> Option<ty::Region>;\n }\n \n impl get_and_find_region for isr_alist {\n-    fn get(br: ty::bound_region) -> ty::Region {\n+    fn get(&self, br: ty::bound_region) -> ty::Region {\n         self.find(br).get()\n     }\n \n-    fn find(br: ty::bound_region) -> Option<ty::Region> {\n-        for list::each(self) |isr| {\n+    fn find(&self, br: ty::bound_region) -> Option<ty::Region> {\n+        for list::each(*self) |isr| {\n             let (isr_br, isr_r) = *isr;\n             if isr_br == br { return Some(isr_r); }\n         }"}, {"sha": "141a730ca8d34f024d1d9a46b07617210c6c0dd9", "filename": "src/librustc/middle/typeck/rscope.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a853894fab6b9a4b60c1b3260b446a3473577fa/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Frscope.rs?ref=4a853894fab6b9a4b60c1b3260b446a3473577fa", "patch": "@@ -19,39 +19,39 @@ use syntax::codemap::span;\n use syntax::parse::token::special_idents;\n \n pub trait region_scope {\n-    pure fn anon_region(span: span) -> Result<ty::Region, ~str>;\n-    pure fn self_region(span: span) -> Result<ty::Region, ~str>;\n-    pure fn named_region(span: span, id: ast::ident)\n+    pure fn anon_region(&self, span: span) -> Result<ty::Region, ~str>;\n+    pure fn self_region(&self, span: span) -> Result<ty::Region, ~str>;\n+    pure fn named_region(&self, span: span, id: ast::ident)\n                       -> Result<ty::Region, ~str>;\n }\n \n pub enum empty_rscope { empty_rscope }\n pub impl region_scope for empty_rscope {\n-    pure fn anon_region(_span: span) -> Result<ty::Region, ~str> {\n+    pure fn anon_region(&self, _span: span) -> Result<ty::Region, ~str> {\n         result::Ok(ty::re_static)\n     }\n-    pure fn self_region(_span: span) -> Result<ty::Region, ~str> {\n+    pure fn self_region(&self, _span: span) -> Result<ty::Region, ~str> {\n         result::Err(~\"only the static region is allowed here\")\n     }\n-    pure fn named_region(_span: span, _id: ast::ident)\n+    pure fn named_region(&self, _span: span, _id: ast::ident)\n         -> Result<ty::Region, ~str> {\n         result::Err(~\"only the static region is allowed here\")\n     }\n }\n \n pub enum type_rscope = Option<ty::region_variance>;\n pub impl region_scope for type_rscope {\n-    pure fn anon_region(_span: span) -> Result<ty::Region, ~str> {\n-        match *self {\n+    pure fn anon_region(&self, _span: span) -> Result<ty::Region, ~str> {\n+        match **self {\n           Some(_) => result::Ok(ty::re_bound(ty::br_self)),\n           None => result::Err(~\"to use region types here, the containing \\\n                                 type must be declared with a region bound\")\n         }\n     }\n-    pure fn self_region(span: span) -> Result<ty::Region, ~str> {\n+    pure fn self_region(&self, span: span) -> Result<ty::Region, ~str> {\n         self.anon_region(span)\n     }\n-    pure fn named_region(span: span, id: ast::ident)\n+    pure fn named_region(&self, span: span, id: ast::ident)\n                       -> Result<ty::Region, ~str> {\n         do empty_rscope.named_region(span, id).chain_err |_e| {\n             result::Err(~\"named regions other than `self` are not \\\n@@ -75,13 +75,13 @@ pub fn in_anon_rscope<RS:region_scope + Copy + Durable>(self: RS,\n     @anon_rscope {anon: r, base: self as region_scope}\n }\n pub impl region_scope for @anon_rscope {\n-    pure fn anon_region(_span: span) -> Result<ty::Region, ~str> {\n+    pure fn anon_region(&self, _span: span) -> Result<ty::Region, ~str> {\n         result::Ok(self.anon)\n     }\n-    pure fn self_region(span: span) -> Result<ty::Region, ~str> {\n+    pure fn self_region(&self, span: span) -> Result<ty::Region, ~str> {\n         self.base.self_region(span)\n     }\n-    pure fn named_region(span: span, id: ast::ident)\n+    pure fn named_region(&self, span: span, id: ast::ident)\n                       -> Result<ty::Region, ~str> {\n         self.base.named_region(span, id)\n     }\n@@ -98,18 +98,18 @@ pub fn in_binding_rscope<RS:region_scope + Copy + Durable>(self: RS)\n     @mut binding_rscope { base: base, anon_bindings: 0 }\n }\n pub impl region_scope for @mut binding_rscope {\n-    pure fn anon_region(_span: span) -> Result<ty::Region, ~str> {\n+    pure fn anon_region(&self, _span: span) -> Result<ty::Region, ~str> {\n         // XXX: Unsafe to work around purity\n         unsafe {\n             let idx = self.anon_bindings;\n             self.anon_bindings += 1;\n             result::Ok(ty::re_bound(ty::br_anon(idx)))\n         }\n     }\n-    pure fn self_region(span: span) -> Result<ty::Region, ~str> {\n+    pure fn self_region(&self, span: span) -> Result<ty::Region, ~str> {\n         self.base.self_region(span)\n     }\n-    pure fn named_region(span: span, id: ast::ident)\n+    pure fn named_region(&self, span: span, id: ast::ident)\n                       -> Result<ty::Region, ~str> {\n         do self.base.named_region(span, id).chain_err |_e| {\n             result::Ok(ty::re_bound(ty::br_named(id)))"}]}