{"sha": "e75b2c8543ee08abed6f3d072447afc514af13bb", "node_id": "C_kwDOAAsO6NoAKGU3NWIyYzg1NDNlZTA4YWJlZDZmM2QwNzI0NDdhZmM1MTRhZjEzYmI", "commit": {"author": {"name": "5225225", "email": "5225225@mailbox.org", "date": "2022-08-13T12:20:56Z"}, "committer": {"name": "5225225", "email": "5225225@mailbox.org", "date": "2022-08-13T12:20:56Z"}, "message": "Breaking posix_memalign precondition is not UB", "tree": {"sha": "b702b0d1fd9fe0e54f6b62497853e7d119ee61ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b702b0d1fd9fe0e54f6b62497853e7d119ee61ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e75b2c8543ee08abed6f3d072447afc514af13bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e75b2c8543ee08abed6f3d072447afc514af13bb", "html_url": "https://github.com/rust-lang/rust/commit/e75b2c8543ee08abed6f3d072447afc514af13bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e75b2c8543ee08abed6f3d072447afc514af13bb/comments", "author": {"login": "5225225", "id": 8584210, "node_id": "MDQ6VXNlcjg1ODQyMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/8584210?v=4", "gravatar_id": "", "url": "https://api.github.com/users/5225225", "html_url": "https://github.com/5225225", "followers_url": "https://api.github.com/users/5225225/followers", "following_url": "https://api.github.com/users/5225225/following{/other_user}", "gists_url": "https://api.github.com/users/5225225/gists{/gist_id}", "starred_url": "https://api.github.com/users/5225225/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/5225225/subscriptions", "organizations_url": "https://api.github.com/users/5225225/orgs", "repos_url": "https://api.github.com/users/5225225/repos", "events_url": "https://api.github.com/users/5225225/events{/privacy}", "received_events_url": "https://api.github.com/users/5225225/received_events", "type": "User", "site_admin": false}, "committer": {"login": "5225225", "id": 8584210, "node_id": "MDQ6VXNlcjg1ODQyMTA=", "avatar_url": "https://avatars.githubusercontent.com/u/8584210?v=4", "gravatar_id": "", "url": "https://api.github.com/users/5225225", "html_url": "https://github.com/5225225", "followers_url": "https://api.github.com/users/5225225/followers", "following_url": "https://api.github.com/users/5225225/following{/other_user}", "gists_url": "https://api.github.com/users/5225225/gists{/gist_id}", "starred_url": "https://api.github.com/users/5225225/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/5225225/subscriptions", "organizations_url": "https://api.github.com/users/5225225/orgs", "repos_url": "https://api.github.com/users/5225225/repos", "events_url": "https://api.github.com/users/5225225/events{/privacy}", "received_events_url": "https://api.github.com/users/5225225/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e1bc7e695cb412fa77fe17b5380b0244e9a70b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e1bc7e695cb412fa77fe17b5380b0244e9a70b9", "html_url": "https://github.com/rust-lang/rust/commit/4e1bc7e695cb412fa77fe17b5380b0244e9a70b9"}], "stats": {"total": 117, "additions": 98, "deletions": 19}, "files": [{"sha": "877a144963a2a40af628ac1b01ab337dc388a97b", "filename": "src/shims/unix/foreign_items.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e75b2c8543ee08abed6f3d072447afc514af13bb/src%2Fshims%2Funix%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e75b2c8543ee08abed6f3d072447afc514af13bb/src%2Fshims%2Funix%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fforeign_items.rs?ref=e75b2c8543ee08abed6f3d072447afc514af13bb", "patch": "@@ -186,27 +186,23 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let align = this.read_scalar(align)?.to_machine_usize(this)?;\n                 let size = this.read_scalar(size)?.to_machine_usize(this)?;\n                 // Align must be power of 2, and also at least ptr-sized (POSIX rules).\n-                if !align.is_power_of_two() {\n-                    throw_ub_format!(\"posix_memalign: alignment must be a power of two, but is {}\", align);\n-                }\n-                if align < this.pointer_size().bytes() {\n-                    throw_ub_format!(\n-                        \"posix_memalign: alignment must be at least the size of a pointer, but is {}\",\n-                        align,\n-                    );\n-                }\n-\n-                if size == 0 {\n-                    this.write_null(&ret.into())?;\n+                // But failure to adhere to this is not UB, it's an error condition.\n+                if !align.is_power_of_two() || align < this.pointer_size().bytes() {\n+                    let einval = this.eval_libc_i32(\"EINVAL\")?;\n+                    this.write_int(einval, dest)?;\n                 } else {\n-                    let ptr = this.allocate_ptr(\n-                        Size::from_bytes(size),\n-                        Align::from_bytes(align).unwrap(),\n-                        MiriMemoryKind::C.into(),\n-                    )?;\n-                    this.write_pointer(ptr, &ret.into())?;\n+                    if size == 0 {\n+                        this.write_null(&ret.into())?;\n+                    } else {\n+                        let ptr = this.allocate_ptr(\n+                            Size::from_bytes(size),\n+                            Align::from_bytes(align).unwrap(),\n+                            MiriMemoryKind::C.into(),\n+                        )?;\n+                        this.write_pointer(ptr, &ret.into())?;\n+                    }\n+                    this.write_null(dest)?;\n                 }\n-                this.write_null(dest)?;\n             }\n \n             // Dynamic symbol loading"}, {"sha": "5dadb62436d646d706a027e7fbd280efc7758bbd", "filename": "tests/pass/posix_memalign.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/e75b2c8543ee08abed6f3d072447afc514af13bb/tests%2Fpass%2Fposix_memalign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e75b2c8543ee08abed6f3d072447afc514af13bb/tests%2Fpass%2Fposix_memalign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fpass%2Fposix_memalign.rs?ref=e75b2c8543ee08abed6f3d072447afc514af13bb", "patch": "@@ -0,0 +1,83 @@\n+//@ignore-target-windows: No libc on Windows\n+\n+#![feature(rustc_private)]\n+#![feature(pointer_is_aligned)]\n+#![feature(strict_provenance)]\n+\n+use core::ptr;\n+\n+fn main() {\n+    // A normal allocation.\n+    unsafe {\n+        let mut ptr: *mut libc::c_void = ptr::null_mut();\n+        let align = 8;\n+        let size = 64;\n+        assert_eq!(libc::posix_memalign(&mut ptr, align, size), 0);\n+        assert!(!ptr.is_null());\n+        assert!(ptr.is_aligned_to(align));\n+        ptr.cast::<u8>().write_bytes(1, size);\n+        libc::free(ptr);\n+    }\n+\n+    // Align > size.\n+    unsafe {\n+        let mut ptr: *mut libc::c_void = ptr::null_mut();\n+        let align = 64;\n+        let size = 8;\n+        assert_eq!(libc::posix_memalign(&mut ptr, align, size), 0);\n+        assert!(!ptr.is_null());\n+        assert!(ptr.is_aligned_to(align));\n+        ptr.cast::<u8>().write_bytes(1, size);\n+        libc::free(ptr);\n+    }\n+\n+    // Size not multiple of align\n+    unsafe {\n+        let mut ptr: *mut libc::c_void = ptr::null_mut();\n+        let align = 16;\n+        let size = 31;\n+        assert_eq!(libc::posix_memalign(&mut ptr, align, size), 0);\n+        assert!(!ptr.is_null());\n+        assert!(ptr.is_aligned_to(align));\n+        ptr.cast::<u8>().write_bytes(1, size);\n+        libc::free(ptr);\n+    }\n+\n+    // Size == 0\n+    unsafe {\n+        let mut ptr: *mut libc::c_void = ptr::null_mut();\n+        let align = 64;\n+        let size = 0;\n+        assert_eq!(libc::posix_memalign(&mut ptr, align, size), 0);\n+        // We are not required to return null if size == 0, but we currently do.\n+        // It's fine to remove this assert if we start returning non-null pointers.\n+        assert!(ptr.is_null());\n+        assert!(ptr.is_aligned_to(align));\n+        // Regardless of what we return, it must be `free`able.\n+        libc::free(ptr);\n+    }\n+\n+    // Non-power of 2 align\n+    unsafe {\n+        let mut ptr: *mut libc::c_void = ptr::invalid_mut(0x1234567);\n+        let align = 15;\n+        let size = 8;\n+        assert_eq!(libc::posix_memalign(&mut ptr, align, size), libc::EINVAL);\n+        // The pointer is not modified on failure, posix_memalign(3) says:\n+        // > On Linux (and other systems), posix_memalign() does  not  modify  memptr  on failure.\n+        // > A requirement standardizing this behavior was added in POSIX.1-2008 TC2.\n+        assert_eq!(ptr.addr(), 0x1234567);\n+    }\n+\n+    // Too small align (smaller than ptr)\n+    unsafe {\n+        let mut ptr: *mut libc::c_void = ptr::invalid_mut(0x1234567);\n+        let align = std::mem::size_of::<usize>() / 2;\n+        let size = 8;\n+        assert_eq!(libc::posix_memalign(&mut ptr, align, size), libc::EINVAL);\n+        // The pointer is not modified on failure, posix_memalign(3) says:\n+        // > On Linux (and other systems), posix_memalign() does  not  modify  memptr  on failure.\n+        // > A requirement standardizing this behavior was added in POSIX.1-2008 TC2.\n+        assert_eq!(ptr.addr(), 0x1234567);\n+    }\n+}"}]}