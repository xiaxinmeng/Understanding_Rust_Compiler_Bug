{"sha": "eec84b31fb6cbac72043017ef81eba0ced658be7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlYzg0YjMxZmI2Y2JhYzcyMDQzMDE3ZWY4MWViYTBjZWQ2NThiZTc=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "eddyb@lyken.rs", "date": "2021-07-16T12:34:29Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "eddyb@lyken.rs", "date": "2021-08-24T16:07:50Z"}, "message": "rustc_symbol_mangling: never cache placeholders in print_const.", "tree": {"sha": "8d84d692a0bc3a9b13ce0838c29a726dcfdc2e12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d84d692a0bc3a9b13ce0838c29a726dcfdc2e12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eec84b31fb6cbac72043017ef81eba0ced658be7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eec84b31fb6cbac72043017ef81eba0ced658be7", "html_url": "https://github.com/rust-lang/rust/commit/eec84b31fb6cbac72043017ef81eba0ced658be7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eec84b31fb6cbac72043017ef81eba0ced658be7/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e291234f59523f57106a233d3115958ded7d3b04", "url": "https://api.github.com/repos/rust-lang/rust/commits/e291234f59523f57106a233d3115958ded7d3b04", "html_url": "https://github.com/rust-lang/rust/commit/e291234f59523f57106a233d3115958ded7d3b04"}], "stats": {"total": 58, "additions": 36, "deletions": 22}, "files": [{"sha": "aa670fc644690b10ad1457cb105518edb5a2b3d0", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 36, "deletions": 22, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/eec84b31fb6cbac72043017ef81eba0ced658be7/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec84b31fb6cbac72043017ef81eba0ced658be7/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=eec84b31fb6cbac72043017ef81eba0ced658be7", "patch": "@@ -534,39 +534,53 @@ impl Printer<'tcx> for &mut SymbolMangler<'tcx> {\n     }\n \n     fn print_const(mut self, ct: &'tcx ty::Const<'tcx>) -> Result<Self::Const, Self::Error> {\n+        // We only mangle a typed value if the const can be evaluated.\n+        let ct = ct.eval(self.tcx, ty::ParamEnv::reveal_all());\n+        match ct.val {\n+            ty::ConstKind::Value(_) => {}\n+\n+            // Placeholders (should be demangled as `_`).\n+            // NOTE(eddyb) despite `Unevaluated` having a `DefId` (and therefore\n+            // a path), even for it we still need to encode a placeholder, as\n+            // the path could refer back to e.g. an `impl` using the constant.\n+            ty::ConstKind::Unevaluated(_)\n+            | ty::ConstKind::Param(_)\n+            | ty::ConstKind::Infer(_)\n+            | ty::ConstKind::Bound(..)\n+            | ty::ConstKind::Placeholder(_)\n+            | ty::ConstKind::Error(_) => {\n+                // Never cached (single-character).\n+                self.push(\"p\");\n+                return Ok(self);\n+            }\n+        }\n+\n         if let Some(&i) = self.consts.get(&ct) {\n             return self.print_backref(i);\n         }\n         let start = self.out.len();\n \n-        let mut neg = false;\n-        let val = match ct.ty.kind() {\n-            ty::Uint(_) | ty::Bool | ty::Char => {\n-                ct.try_eval_bits(self.tcx, ty::ParamEnv::reveal_all(), ct.ty)\n-            }\n-            ty::Int(ity) => {\n-                ct.try_eval_bits(self.tcx, ty::ParamEnv::reveal_all(), ct.ty).and_then(|b| {\n-                    let val = Integer::from_int_ty(&self.tcx, *ity).size().sign_extend(b) as i128;\n+        match ct.ty.kind() {\n+            ty::Uint(_) | ty::Int(_) | ty::Bool | ty::Char => {\n+                self = ct.ty.print(self)?;\n+\n+                let mut bits = ct.eval_bits(self.tcx, ty::ParamEnv::reveal_all(), ct.ty);\n+\n+                // Negative integer values are mangled using `n` as a \"sign prefix\".\n+                if let ty::Int(ity) = ct.ty.kind() {\n+                    let val =\n+                        Integer::from_int_ty(&self.tcx, *ity).size().sign_extend(bits) as i128;\n                     if val < 0 {\n-                        neg = true;\n+                        self.push(\"n\");\n                     }\n-                    Some(val.unsigned_abs())\n-                })\n+                    bits = val.unsigned_abs();\n+                }\n+\n+                let _ = write!(self.out, \"{:x}_\", bits);\n             }\n             _ => {\n                 bug!(\"symbol_names: unsupported constant of type `{}` ({:?})\", ct.ty, ct);\n             }\n-        };\n-\n-        if let Some(bits) = val {\n-            // We only print the type if the const can be evaluated.\n-            self = ct.ty.print(self)?;\n-            let _ = write!(self.out, \"{}{:x}_\", if neg { \"n\" } else { \"\" }, bits);\n-        } else {\n-            // NOTE(eddyb) despite having the path, we need to\n-            // encode a placeholder, as the path could refer\n-            // back to e.g. an `impl` using the constant.\n-            self.push(\"p\");\n         }\n \n         // Only cache consts that do not refer to an enclosing"}]}