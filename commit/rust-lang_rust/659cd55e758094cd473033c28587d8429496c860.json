{"sha": "659cd55e758094cd473033c28587d8429496c860", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1OWNkNTVlNzU4MDk0Y2Q0NzMwMzNjMjg1ODdkODQyOTQ5NmM4NjA=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-06-27T22:48:12Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-06-28T04:24:09Z"}, "message": "add a tutorial on containers and iterators", "tree": {"sha": "87613b06c47824311339371d7e167df6dd130f88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87613b06c47824311339371d7e167df6dd130f88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/659cd55e758094cd473033c28587d8429496c860", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/659cd55e758094cd473033c28587d8429496c860", "html_url": "https://github.com/rust-lang/rust/commit/659cd55e758094cd473033c28587d8429496c860", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/659cd55e758094cd473033c28587d8429496c860/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c45af013517148b8fe6e6234ecad729baf135c23", "url": "https://api.github.com/repos/rust-lang/rust/commits/c45af013517148b8fe6e6234ecad729baf135c23", "html_url": "https://github.com/rust-lang/rust/commit/c45af013517148b8fe6e6234ecad729baf135c23"}], "stats": {"total": 344, "additions": 218, "deletions": 126}, "files": [{"sha": "66bd0b9c1319f4cda407a9c42cdd08a9488adab1", "filename": "doc/tutorial-container.md", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/659cd55e758094cd473033c28587d8429496c860/doc%2Ftutorial-container.md", "raw_url": "https://github.com/rust-lang/rust/raw/659cd55e758094cd473033c28587d8429496c860/doc%2Ftutorial-container.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-container.md?ref=659cd55e758094cd473033c28587d8429496c860", "patch": "@@ -0,0 +1,207 @@\n+% Containers and iterators\n+\n+# Containers\n+\n+The container traits are defined in the `std::container` module.\n+\n+## Unique and managed vectors\n+\n+Vectors have `O(1)` indexing and removal from the end, along with `O(1)`\n+amortized insertion. Vectors are the most common container in Rust, and are\n+flexible enough to fit many use cases.\n+\n+Vectors can also be sorted and used as efficient lookup tables with the\n+`std::vec::bsearch` function, if all the elements are inserted at one time and\n+deletions are unnecessary.\n+\n+## Maps and sets\n+\n+Maps are collections of unique keys with corresponding values, and sets are\n+just unique keys without a corresponding value. The `Map` and `Set` traits in\n+`std::container` define the basic interface.\n+\n+The standard library provides three owned map/set types:\n+\n+* `std::hashmap::HashMap` and `std::hashmap::HashSet`, requiring the keys to\n+  implement `Eq` and `Hash`\n+* `std::trie::TrieMap` and `std::trie::TrieSet`, requiring the keys to be `uint`\n+* `extra::treemap::TreeMap` and `extra::treemap::TreeSet`, requiring the keys\n+  to implement `TotalOrd`\n+\n+These maps do not use managed pointers so they can be sent between tasks as\n+long as the key and value types are sendable. Neither the key or value type has\n+to be copyable.\n+\n+The `TrieMap` and `TreeMap` maps are ordered, while `HashMap` uses an arbitrary\n+order.\n+\n+Each `HashMap` instance has a random 128-bit key to use with a keyed hash,\n+making the order of a set of keys in a given hash table randomized. Rust\n+provides a [SipHash](https://131002.net/siphash/) implementation for any type\n+implementing the `IterBytes` trait.\n+\n+## Double-ended queues\n+\n+The `extra::deque` module implements a double-ended queue with `O(1)` amortized\n+inserts and removals from both ends of the container. It also has `O(1)`\n+indexing like a vector. The contained elements are not required to be copyable,\n+and the queue will be sendable if the contained type is sendable.\n+\n+## Priority queues\n+\n+The `extra::priority_queue` module implements a queue ordered by a key.  The\n+contained elements are not required to be copyable, and the queue will be\n+sendable if the contained type is sendable.\n+\n+Insertions have `O(log n)` time complexity and checking or popping the largest\n+element is `O(1)`. Converting a vector to a priority queue can be done\n+in-place, and has `O(n)` complexity. A priority queue can also be converted to\n+a sorted vector in-place, allowing it to be used for an `O(n log n)` in-place\n+heapsort.\n+\n+# Iterators\n+\n+## Iteration protocol\n+\n+The iteration protocol is defined by the `Iterator` trait in the\n+`std::iterator` module. The minimal implementation of the trait is a `next`\n+method, yielding the next element from an iterator object:\n+\n+~~~\n+/// An infinite stream of zeroes\n+struct ZeroStream;\n+\n+impl Iterator<int> for ZeroStream {\n+    fn next(&mut self) -> Option<int> {\n+        Some(0)\n+    }\n+}\n+~~~~\n+\n+Reaching the end of the iterator is signalled by returning `None` instead of\n+`Some(item)`:\n+\n+~~~\n+/// A stream of N zeroes\n+struct ZeroStream {\n+    priv remaining: uint\n+}\n+\n+impl ZeroStream {\n+    fn new(n: uint) -> ZeroStream {\n+        ZeroStream { remaining: n }\n+    }\n+}\n+\n+impl Iterator<int> for ZeroStream {\n+    fn next(&mut self) -> Option<int> {\n+        if self.remaining == 0 {\n+            None\n+        } else {\n+            self.remaining -= 1;\n+            Some(0)\n+        }\n+    }\n+}\n+~~~\n+\n+## Container iterators\n+\n+Containers implement iteration over the contained elements by returning an\n+iterator object. For example, vectors have four iterators available:\n+\n+* `vector.iter()`, for immutable references to the elements\n+* `vector.mut_iter()`, for mutable references to the elements\n+* `vector.rev_iter()`, for immutable references to the elements in reverse order\n+* `vector.mut_rev_iter()`, for mutable references to the elements in reverse order\n+\n+### Freezing\n+\n+Unlike most other languages with external iterators, Rust has no *iterator\n+invalidation*. As long an iterator is still in scope, the compiler will prevent\n+modification of the container through another handle.\n+\n+~~~\n+let mut xs = [1, 2, 3];\n+{\n+    let _it = xs.iter();\n+\n+    // the vector is frozen for this scope, the compiler will statically\n+    // prevent modification\n+}\n+// the vector becomes unfrozen again at the end of the scope\n+~~~\n+\n+These semantics are due to most container iterators being implemented with `&`\n+and `&mut`.\n+\n+## Iterator adaptors\n+\n+The `IteratorUtil` trait implements common algorithms as methods extending\n+every `Iterator` implementation. For example, the `fold` method will accumulate\n+the items yielded by an `Iterator` into a single value:\n+\n+~~~\n+let xs = [1, 9, 2, 3, 14, 12];\n+let result = xs.iter().fold(0, |accumulator, item| accumulator - *item);\n+assert_eq!(result, -41);\n+~~~\n+\n+Some adaptors return an adaptor object implementing the `Iterator` trait itself:\n+\n+~~~\n+let xs = [1, 9, 2, 3, 14, 12];\n+let ys = [5, 2, 1, 8];\n+let sum = xs.iter().chain_(ys.iter()).fold(0, |a, b| a + *b);\n+assert_eq!(sum, 57);\n+~~~\n+\n+Note that some adaptors like the `chain_` method above use a trailing\n+underscore to work around an issue with method resolve. The underscores will be\n+dropped when they become unnecessary.\n+\n+## For loops\n+\n+The `for` loop syntax is currently in transition, and will switch from the old\n+closure-based iteration protocol to iterator objects. For now, the `advance`\n+adaptor is required as a compatibility shim to use iterators with for loops.\n+\n+~~~\n+let xs = [2, 3, 5, 7, 11, 13, 17];\n+\n+// print out all the elements in the vector\n+for xs.iter().advance |x| {\n+    println(x.to_str())\n+}\n+\n+// print out all but the first 3 elements in the vector\n+for xs.iter().skip(3).advance |x| {\n+    println(x.to_str())\n+}\n+~~~\n+\n+For loops are *often* used with a temporary iterator object, as above. They can\n+also advance the state of an iterator in a mutable location:\n+\n+~~~\n+let xs = [1, 2, 3, 4, 5];\n+let ys = [\"foo\", \"bar\", \"baz\", \"foobar\"];\n+\n+// create an iterator yielding tuples of elements from both vectors\n+let mut it = xs.iter().zip(ys.iter());\n+\n+// print out the pairs of elements up to (&3, &\"baz\")\n+for it.advance |(x, y)| {\n+    println(fmt!(\"%d %s\", *x, *y));\n+\n+    if *x == 3 {\n+        break;\n+    }\n+}\n+\n+// yield and print the last pair from the iterator\n+println(fmt!(\"last: %?\", it.next()));\n+\n+// the iterator is now fully consumed\n+assert!(it.next().is_none());\n+~~~"}, {"sha": "fc0f7b74a7af87e44b23020de53bada9fb3da741", "filename": "doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 126, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/659cd55e758094cd473033c28587d8429496c860/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/659cd55e758094cd473033c28587d8429496c860/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=659cd55e758094cd473033c28587d8429496c860", "patch": "@@ -1607,132 +1607,6 @@ do spawn {\n If you want to see the output of `debug!` statements, you will need to turn on `debug!` logging.\n To enable `debug!` logging, set the RUST_LOG environment variable to the name of your crate, which, for a file named `foo.rs`, will be `foo` (e.g., with bash, `export RUST_LOG=foo`).\n \n-## For loops\n-\n-> ***Note:*** The closure-based protocol used `for` loop is on the way out. The `for` loop will\n-> use iterator objects in the future instead.\n-\n-The most common way to express iteration in Rust is with a `for`\n-loop. Like `do`, `for` is a nice syntax for describing control flow\n-with closures.  Additionally, within a `for` loop, `break`, `loop`,\n-and `return` work just as they do with `while` and `loop`.\n-\n-Consider again our `each` function, this time improved to return\n-immediately when the iteratee returns `false`:\n-\n-~~~~\n-fn each(v: &[int], op: &fn(v: &int) -> bool) -> bool {\n-   let mut n = 0;\n-   while n < v.len() {\n-       if !op(&v[n]) {\n-           return false;\n-       }\n-       n += 1;\n-   }\n-   return true;\n-}\n-~~~~\n-\n-And using this function to iterate over a vector:\n-\n-~~~~\n-# fn each(v: &[int], op: &fn(v: &int) -> bool) -> bool {\n-#    let mut n = 0;\n-#    while n < v.len() {\n-#        if !op(&v[n]) {\n-#            return false;\n-#        }\n-#        n += 1;\n-#    }\n-#    return true;\n-# }\n-each([2, 4, 8, 5, 16], |n| {\n-    if *n % 2 != 0 {\n-        println(\"found odd number!\");\n-        false\n-    } else { true }\n-});\n-~~~~\n-\n-With `for`, functions like `each` can be treated more\n-like built-in looping structures. When calling `each`\n-in a `for` loop, instead of returning `false` to break\n-out of the loop, you just write `break`. To skip ahead\n-to the next iteration, write `loop`.\n-\n-~~~~\n-# fn each(v: &[int], op: &fn(v: &int) -> bool) -> bool {\n-#    let mut n = 0;\n-#    while n < v.len() {\n-#        if !op(&v[n]) {\n-#            return false;\n-#        }\n-#        n += 1;\n-#    }\n-#    return true;\n-# }\n-for each([2, 4, 8, 5, 16]) |n| {\n-    if *n % 2 != 0 {\n-        println(\"found odd number!\");\n-        break;\n-    }\n-}\n-~~~~\n-\n-As an added bonus, you can use the `return` keyword, which is not\n-normally allowed in closures, in a block that appears as the body of a\n-`for` loop: the meaning of `return` in such a block is to return from\n-the enclosing function, not just the loop body.\n-\n-~~~~\n-# fn each(v: &[int], op: &fn(v: &int) -> bool) -> bool {\n-#    let mut n = 0;\n-#    while n < v.len() {\n-#        if !op(&v[n]) {\n-#            return false;\n-#        }\n-#        n += 1;\n-#    }\n-#    return true;\n-# }\n-fn contains(v: &[int], elt: int) -> bool {\n-    for each(v) |x| {\n-        if (*x == elt) { return true; }\n-    }\n-    false\n-}\n-~~~~\n-\n-Notice that, because `each` passes each value by borrowed pointer,\n-the iteratee needs to dereference it before using it.\n-In these situations it can be convenient to lean on Rust's\n-argument patterns to bind `x` to the actual value, not the pointer.\n-\n-~~~~\n-# fn each(v: &[int], op: &fn(v: &int) -> bool) -> bool {\n-#    let mut n = 0;\n-#    while n < v.len() {\n-#        if !op(&v[n]) {\n-#            return false;\n-#        }\n-#        n += 1;\n-#    }\n-#    return true;\n-# }\n-# fn contains(v: &[int], elt: int) -> bool {\n-    for each(v) |&x| {\n-        if (x == elt) { return true; }\n-    }\n-#    false\n-# }\n-~~~~\n-\n-`for` syntax only works with stack closures.\n-\n-> ***Note:*** This is, essentially, a special loop protocol:\n-> the keywords `break`, `loop`, and `return` work, in varying degree,\n-> with `while`, `loop`, `do`, and `for` constructs.\n-\n # Methods\n \n Methods are like functions except that they always begin with a special argument,\n@@ -2653,6 +2527,7 @@ tutorials on individual topics.\n * [Tasks and communication][tasks]\n * [Macros][macros]\n * [The foreign function interface][ffi]\n+* [Containers and iterators](tutorial-container.html)\n \n There is further documentation on the [wiki].\n "}, {"sha": "f11a3d24b8d2559f0e3dba340e0a888c7c96ef41", "filename": "mk/docs.mk", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/659cd55e758094cd473033c28587d8429496c860/mk%2Fdocs.mk", "raw_url": "https://github.com/rust-lang/rust/raw/659cd55e758094cd473033c28587d8429496c860/mk%2Fdocs.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdocs.mk?ref=659cd55e758094cd473033c28587d8429496c860", "patch": "@@ -99,6 +99,16 @@ doc/tutorial-macros.html: tutorial-macros.md doc/version_info.html \\\n \t   --include-before-body=doc/version_info.html \\\n            --output=$@\n \n+DOCS += doc/tutorial-container.html\n+doc/tutorial-container.html: tutorial-container.md doc/version_info.html doc/rust.css\n+\t@$(call E, pandoc: $@)\n+\t$(Q)$(CFG_NODE) $(S)doc/prep.js --highlight $< | \\\n+          $(CFG_PANDOC) --standalone --toc \\\n+           --section-divs --number-sections \\\n+           --from=markdown --to=html --css=rust.css \\\n+\t   --include-before-body=doc/version_info.html \\\n+           --output=$@\n+\n DOCS += doc/tutorial-ffi.html\n doc/tutorial-ffi.html: tutorial-ffi.md doc/version_info.html doc/rust.css\n \t@$(call E, pandoc: $@)"}]}