{"sha": "3c4d157c8419d73574587a22a8095ad32d860af5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjNGQxNTdjODQxOWQ3MzU3NDU4N2EyMmE4MDk1YWQzMmQ4NjBhZjU=", "commit": {"author": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2019-08-31T03:35:27Z"}, "committer": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2019-08-31T03:35:27Z"}, "message": "Fix unlock ordering in SGX synchronization primitives", "tree": {"sha": "c0c3b8fe3e36056f1f237c71cd2485808c30fb3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0c3b8fe3e36056f1f237c71cd2485808c30fb3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c4d157c8419d73574587a22a8095ad32d860af5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c4d157c8419d73574587a22a8095ad32d860af5", "html_url": "https://github.com/rust-lang/rust/commit/3c4d157c8419d73574587a22a8095ad32d860af5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c4d157c8419d73574587a22a8095ad32d860af5/comments", "author": null, "committer": null, "parents": [{"sha": "72b2abfd65ba024e12d7fe51852a309419f494d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/72b2abfd65ba024e12d7fe51852a309419f494d8", "html_url": "https://github.com/rust-lang/rust/commit/72b2abfd65ba024e12d7fe51852a309419f494d8"}], "stats": {"total": 52, "additions": 32, "deletions": 20}, "files": [{"sha": "cc1c04a83e752859343e4afcf8c6ebb281ac84c0", "filename": "src/libstd/sys/sgx/condvar.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3c4d157c8419d73574587a22a8095ad32d860af5/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c4d157c8419d73574587a22a8095ad32d860af5/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fcondvar.rs?ref=3c4d157c8419d73574587a22a8095ad32d860af5", "patch": "@@ -27,8 +27,7 @@ impl Condvar {\n \n     pub unsafe fn wait(&self, mutex: &Mutex) {\n         let guard = self.inner.lock();\n-        mutex.unlock();\n-        WaitQueue::wait(guard);\n+        WaitQueue::wait(guard, || mutex.unlock());\n         mutex.lock()\n     }\n "}, {"sha": "662da8b3f66850f1a72add0674ad5006e0c84e57", "filename": "src/libstd/sys/sgx/mutex.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c4d157c8419d73574587a22a8095ad32d860af5/src%2Flibstd%2Fsys%2Fsgx%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c4d157c8419d73574587a22a8095ad32d860af5/src%2Flibstd%2Fsys%2Fsgx%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fmutex.rs?ref=3c4d157c8419d73574587a22a8095ad32d860af5", "patch": "@@ -22,7 +22,7 @@ impl Mutex {\n         let mut guard = self.inner.lock();\n         if *guard.lock_var() {\n             // Another thread has the lock, wait\n-            WaitQueue::wait(guard)\n+            WaitQueue::wait(guard, ||{})\n             // Another thread has passed the lock to us\n         } else {\n             // We are just now obtaining the lock\n@@ -83,7 +83,7 @@ impl ReentrantMutex {\n         match guard.lock_var().owner {\n             Some(tcs) if tcs != thread::current() => {\n                 // Another thread has the lock, wait\n-                WaitQueue::wait(guard);\n+                WaitQueue::wait(guard, ||{});\n                 // Another thread has passed the lock to us\n             },\n             _ => {"}, {"sha": "e2f94b1d928e10db38416f8c874fd88fb08c652d", "filename": "src/libstd/sys/sgx/rwlock.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3c4d157c8419d73574587a22a8095ad32d860af5/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c4d157c8419d73574587a22a8095ad32d860af5/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Frwlock.rs?ref=3c4d157c8419d73574587a22a8095ad32d860af5", "patch": "@@ -31,7 +31,7 @@ impl RWLock {\n         if *wguard.lock_var() || !wguard.queue_empty() {\n             // Another thread has or is waiting for the write lock, wait\n             drop(wguard);\n-            WaitQueue::wait(rguard);\n+            WaitQueue::wait(rguard, ||{});\n             // Another thread has passed the lock to us\n         } else {\n             // No waiting writers, acquire the read lock\n@@ -62,7 +62,7 @@ impl RWLock {\n         if *wguard.lock_var() || rguard.lock_var().is_some() {\n             // Another thread has the lock, wait\n             drop(rguard);\n-            WaitQueue::wait(wguard);\n+            WaitQueue::wait(wguard, ||{});\n             // Another thread has passed the lock to us\n         } else {\n             // We are just now obtaining the lock\n@@ -97,6 +97,7 @@ impl RWLock {\n             if let Ok(mut wguard) = WaitQueue::notify_one(wguard) {\n                 // A writer was waiting, pass the lock\n                 *wguard.lock_var_mut() = true;\n+                wguard.drop_after(rguard);\n             } else {\n                 // No writers were waiting, the lock is released\n                 rtassert!(rguard.queue_empty());\n@@ -117,21 +118,26 @@ impl RWLock {\n         rguard: SpinMutexGuard<'_, WaitVariable<Option<NonZeroUsize>>>,\n         wguard: SpinMutexGuard<'_, WaitVariable<bool>>,\n     ) {\n-        if let Err(mut wguard) = WaitQueue::notify_one(wguard) {\n-            // No writers waiting, release the write lock\n-            *wguard.lock_var_mut() = false;\n-            if let Ok(mut rguard) = WaitQueue::notify_all(rguard) {\n-                // One or more readers were waiting, pass the lock to them\n-                if let NotifiedTcs::All { count } = rguard.notified_tcs() {\n-                    *rguard.lock_var_mut() = Some(count)\n+        match WaitQueue::notify_one(wguard) {\n+            Err(mut wguard) => {\n+                // No writers waiting, release the write lock\n+                *wguard.lock_var_mut() = false;\n+                if let Ok(mut rguard) = WaitQueue::notify_all(rguard) {\n+                    // One or more readers were waiting, pass the lock to them\n+                    if let NotifiedTcs::All { count } = rguard.notified_tcs() {\n+                        *rguard.lock_var_mut() = Some(count)\n+                    } else {\n+                        unreachable!() // called notify_all\n+                    }\n+                    rguard.drop_after(wguard);\n                 } else {\n-                    unreachable!() // called notify_all\n+                    // No readers waiting, the lock is released\n                 }\n-            } else {\n-                // No readers waiting, the lock is released\n+            },\n+            Ok(wguard) => {\n+                // There was a thread waiting for write, just pass the lock\n+                wguard.drop_after(rguard);\n             }\n-        } else {\n-            // There was a thread waiting for write, just pass the lock\n         }\n     }\n "}, {"sha": "3cb40e509b6b2973b93d0a8c1fa0a08df3b6f8a1", "filename": "src/libstd/sys/sgx/waitqueue.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3c4d157c8419d73574587a22a8095ad32d860af5/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c4d157c8419d73574587a22a8095ad32d860af5/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fwaitqueue.rs?ref=3c4d157c8419d73574587a22a8095ad32d860af5", "patch": "@@ -98,6 +98,12 @@ impl<'a, T> WaitGuard<'a, T> {\n     pub fn notified_tcs(&self) -> NotifiedTcs {\n         self.notified_tcs\n     }\n+\n+    /// Drop this `WaitGuard`, after dropping another `guard`.\n+    pub fn drop_after<U>(self, guard: U) {\n+        drop(guard);\n+        drop(self);\n+    }\n }\n \n impl<'a, T> Deref for WaitGuard<'a, T> {\n@@ -140,7 +146,7 @@ impl WaitQueue {\n     /// until a wakeup event.\n     ///\n     /// This function does not return until this thread has been awoken.\n-    pub fn wait<T>(mut guard: SpinMutexGuard<'_, WaitVariable<T>>) {\n+    pub fn wait<T, F: FnOnce()>(mut guard: SpinMutexGuard<'_, WaitVariable<T>>, before_wait: F) {\n         // very unsafe: check requirements of UnsafeList::push\n         unsafe {\n             let mut entry = UnsafeListEntry::new(SpinMutex::new(WaitEntry {\n@@ -149,6 +155,7 @@ impl WaitQueue {\n             }));\n             let entry = guard.queue.inner.push(&mut entry);\n             drop(guard);\n+            before_wait();\n             while !entry.lock().wake {\n                 // don't panic, this would invalidate `entry` during unwinding\n                 let eventset = rtunwrap!(Ok, usercalls::wait(EV_UNPARK, WAIT_INDEFINITE));\n@@ -545,7 +552,7 @@ mod tests {\n             assert!(WaitQueue::notify_one(wq2.lock()).is_ok());\n         });\n \n-        WaitQueue::wait(locked);\n+        WaitQueue::wait(locked, ||{});\n \n         t1.join().unwrap();\n     }"}]}