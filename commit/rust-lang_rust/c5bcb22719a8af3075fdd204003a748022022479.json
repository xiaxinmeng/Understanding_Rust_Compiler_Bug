{"sha": "c5bcb22719a8af3075fdd204003a748022022479", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1YmNiMjI3MTlhOGFmMzA3NWZkZDIwNDAwM2E3NDgwMjIwMjI0Nzk=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-01-07T19:45:13Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-01-09T21:02:17Z"}, "message": "rename Strong -> Rc, replacing `rc` with `weak`", "tree": {"sha": "814f651d245148c9bd5dcd0fb40c8252eb33487f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/814f651d245148c9bd5dcd0fb40c8252eb33487f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5bcb22719a8af3075fdd204003a748022022479", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5bcb22719a8af3075fdd204003a748022022479", "html_url": "https://github.com/rust-lang/rust/commit/c5bcb22719a8af3075fdd204003a748022022479", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5bcb22719a8af3075fdd204003a748022022479/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77cc1c5107ced596b694265d898194f33ace361e", "url": "https://api.github.com/repos/rust-lang/rust/commits/77cc1c5107ced596b694265d898194f33ace361e", "html_url": "https://github.com/rust-lang/rust/commit/77cc1c5107ced596b694265d898194f33ace361e"}], "stats": {"total": 391, "additions": 103, "deletions": 288}, "files": [{"sha": "020404057fb1ff514d9a3b23cfc27c39c1fc1835", "filename": "src/libextra/serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5bcb22719a8af3075fdd204003a748022022479/src%2Flibextra%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5bcb22719a8af3075fdd204003a748022022479/src%2Flibextra%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fserialize.rs?ref=c5bcb22719a8af3075fdd204003a748022022479", "patch": "@@ -413,7 +413,7 @@ impl<S:Encoder,T:Encodable<S>> Encodable<S> for Rc<T> {\n     }\n }\n \n-impl<D:Decoder,T:Decodable<D> + NonManaged> Decodable<D> for Rc<T> {\n+impl<D:Decoder,T:Decodable<D>> Decodable<D> for Rc<T> {\n     #[inline]\n     fn decode(d: &mut D) -> Rc<T> {\n         Rc::new(Decodable::decode(d))"}, {"sha": "8a4d102e7bee9e742445c083b8a67116d7ff5618", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5bcb22719a8af3075fdd204003a748022022479/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5bcb22719a8af3075fdd204003a748022022479/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=c5bcb22719a8af3075fdd204003a748022022479", "patch": "@@ -121,7 +121,6 @@ pub mod owned;\n pub mod managed;\n pub mod borrow;\n pub mod rc;\n-pub mod weak;\n pub mod gc;\n \n "}, {"sha": "a5b909008bfaee38bcc1ae77c4b39c88bc3a7ad9", "filename": "src/libstd/rc.rs", "status": "modified", "additions": 102, "deletions": 96, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/c5bcb22719a8af3075fdd204003a748022022479/src%2Flibstd%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5bcb22719a8af3075fdd204003a748022022479/src%2Flibstd%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frc.rs?ref=c5bcb22719a8af3075fdd204003a748022022479", "patch": "@@ -14,18 +14,27 @@ The `Rc` type provides shared ownership of an immutable value. Destruction is de\n will occur as soon as the last owner is gone. It is marked as non-sendable because it avoids the\n overhead of atomic reference counting.\n \n+The `downgrade` method can be used to create a non-owning `Weak` pointer to the box. A `Weak`\n+pointer can be upgraded to an `Rc` pointer, but will return `None` if the value has already been\n+freed.\n+\n+For example, a tree with parent pointers can be represented by putting the nodes behind `Strong`\n+pointers, and then storing the parent pointers as `Weak` pointers.\n+\n */\n \n-use ptr::RawPtr;\n-use unstable::intrinsics::transmute;\n+use cast::transmute;\n use ops::Drop;\n-use kinds::NonManaged;\n+use cmp::{Eq, Ord};\n use clone::{Clone, DeepClone};\n-use cmp::{Eq, TotalEq, Ord, TotalOrd, Ordering};\n+use rt::global_heap::exchange_free;\n+use ptr::read_ptr;\n+use option::{Option, Some, None};\n \n struct RcBox<T> {\n     value: T,\n-    count: uint\n+    strong: uint,\n+    weak: uint\n }\n \n /// Immutable reference counted pointer type\n@@ -35,152 +44,149 @@ pub struct Rc<T> {\n     priv ptr: *mut RcBox<T>\n }\n \n-impl<T: NonManaged> Rc<T> {\n+impl<T> Rc<T> {\n     /// Construct a new reference-counted box\n-    #[inline]\n     pub fn new(value: T) -> Rc<T> {\n         unsafe {\n-            Rc { ptr: transmute(~RcBox { value: value, count: 1 }) }\n+            Rc { ptr: transmute(~RcBox { value: value, strong: 1, weak: 0 }) }\n         }\n     }\n }\n \n impl<T> Rc<T> {\n     /// Borrow the value contained in the reference-counted box\n-    #[inline]\n-    pub fn borrow<'r>(&'r self) -> &'r T {\n+    #[inline(always)]\n+    pub fn borrow<'a>(&'a self) -> &'a T {\n         unsafe { &(*self.ptr).value }\n     }\n \n-    /// Determine if two reference-counted pointers point to the same object\n-    #[inline]\n-    pub fn ptr_eq(&self, other: &Rc<T>) -> bool {\n-        self.ptr == other.ptr\n+    /// Downgrade the reference-counted pointer to a weak reference\n+    pub fn downgrade(&self) -> Weak<T> {\n+        unsafe {\n+            (*self.ptr).weak += 1;\n+            Weak { ptr: self.ptr }\n+        }\n     }\n }\n \n-impl<T: Eq> Eq for Rc<T> {\n-    #[inline]\n-    fn eq(&self, other: &Rc<T>) -> bool {\n-        unsafe { (*self.ptr).value == (*other.ptr).value }\n+#[unsafe_destructor]\n+impl<T> Drop for Rc<T> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            if self.ptr != 0 as *mut RcBox<T> {\n+                (*self.ptr).strong -= 1;\n+                if (*self.ptr).strong == 0 {\n+                    read_ptr(self.borrow()); // destroy the contained object\n+                    if (*self.ptr).weak == 0 {\n+                        exchange_free(self.ptr as *mut u8 as *i8)\n+                    }\n+                }\n+            }\n+        }\n     }\n+}\n \n+impl<T> Clone for Rc<T> {\n     #[inline]\n-    fn ne(&self, other: &Rc<T>) -> bool {\n-        unsafe { (*self.ptr).value != (*other.ptr).value }\n+    fn clone(&self) -> Rc<T> {\n+        unsafe {\n+            (*self.ptr).strong += 1;\n+            Rc { ptr: self.ptr }\n+        }\n     }\n }\n \n-impl<T: TotalEq> TotalEq for Rc<T> {\n+impl<T: DeepClone> DeepClone for Rc<T> {\n     #[inline]\n-    fn equals(&self, other: &Rc<T>) -> bool {\n-        unsafe { (*self.ptr).value.equals(&(*other.ptr).value) }\n+    fn deep_clone(&self) -> Rc<T> {\n+        Rc::new(self.borrow().deep_clone())\n     }\n }\n \n+impl<T: Eq> Eq for Rc<T> {\n+    #[inline(always)]\n+    fn eq(&self, other: &Rc<T>) -> bool { *self.borrow() == *other.borrow() }\n+\n+    #[inline(always)]\n+    fn ne(&self, other: &Rc<T>) -> bool { *self.borrow() != *other.borrow() }\n+}\n+\n impl<T: Ord> Ord for Rc<T> {\n-    #[inline]\n-    fn lt(&self, other: &Rc<T>) -> bool {\n-        unsafe { (*self.ptr).value < (*other.ptr).value }\n-    }\n+    #[inline(always)]\n+    fn lt(&self, other: &Rc<T>) -> bool { *self.borrow() < *other.borrow() }\n \n-    #[inline]\n-    fn le(&self, other: &Rc<T>) -> bool {\n-        unsafe { (*self.ptr).value <= (*other.ptr).value }\n-    }\n+    #[inline(always)]\n+    fn le(&self, other: &Rc<T>) -> bool { *self.borrow() <= *other.borrow() }\n \n-    #[inline]\n-    fn ge(&self, other: &Rc<T>) -> bool {\n-        unsafe { (*self.ptr).value >= (*other.ptr).value }\n-    }\n+    #[inline(always)]\n+    fn gt(&self, other: &Rc<T>) -> bool { *self.borrow() > *other.borrow() }\n \n-    #[inline]\n-    fn gt(&self, other: &Rc<T>) -> bool {\n-        unsafe { (*self.ptr).value > (*other.ptr).value }\n-    }\n+    #[inline(always)]\n+    fn ge(&self, other: &Rc<T>) -> bool { *self.borrow() >= *other.borrow() }\n }\n \n-impl<T: TotalOrd> TotalOrd for Rc<T> {\n-    #[inline]\n-    fn cmp(&self, other: &Rc<T>) -> Ordering {\n-        unsafe { (*self.ptr).value.cmp(&(*other.ptr).value) }\n-    }\n+/// Weak reference to a reference-counted box\n+#[unsafe_no_drop_flag]\n+#[no_send]\n+pub struct Weak<T> {\n+    priv ptr: *mut RcBox<T>\n }\n \n-impl<T> Clone for Rc<T> {\n-    #[inline]\n-    fn clone(&self) -> Rc<T> {\n+impl<T> Weak<T> {\n+    /// Upgrade a weak reference to a strong reference\n+    pub fn upgrade(&self) -> Option<Rc<T>> {\n         unsafe {\n-            (*self.ptr).count += 1;\n-            Rc{ptr: self.ptr}\n+            if (*self.ptr).strong == 0 {\n+                None\n+            } else {\n+                (*self.ptr).strong += 1;\n+                Some(Rc { ptr: self.ptr })\n+            }\n         }\n     }\n }\n \n-impl<T: NonManaged + DeepClone> DeepClone for Rc<T> {\n-    #[inline]\n-    fn deep_clone(&self) -> Rc<T> {\n-        Rc::new(self.borrow().deep_clone())\n-    }\n-}\n-\n #[unsafe_destructor]\n-impl<T> Drop for Rc<T> {\n+impl<T> Drop for Weak<T> {\n     fn drop(&mut self) {\n         unsafe {\n-            if self.ptr.is_not_null() {\n-                (*self.ptr).count -= 1;\n-                if (*self.ptr).count == 0 {\n-                    let _: ~RcBox<T> = transmute(self.ptr);\n+            if self.ptr != 0 as *mut RcBox<T> {\n+                (*self.ptr).weak -= 1;\n+                if (*self.ptr).weak == 0 && (*self.ptr).strong == 0 {\n+                    exchange_free(self.ptr as *mut u8 as *i8)\n                 }\n             }\n         }\n     }\n }\n \n-#[cfg(test)]\n-mod test_rc {\n-    use prelude::*;\n-    use super::*;\n-    use cell::RefCell;\n-\n-    #[test]\n-    fn test_clone() {\n-        let x = Rc::new(RefCell::new(5));\n-        let y = x.clone();\n-        x.borrow().with_mut(|inner| {\n-            *inner = 20;\n-        });\n-        assert_eq!(y.borrow().with(|v| *v), 20);\n+impl<T> Clone for Weak<T> {\n+    #[inline]\n+    fn clone(&self) -> Weak<T> {\n+        unsafe {\n+            (*self.ptr).weak += 1;\n+            Weak { ptr: self.ptr }\n+        }\n     }\n+}\n \n-    #[test]\n-    fn test_deep_clone() {\n-        let x = Rc::new(RefCell::new(5));\n-        let y = x.deep_clone();\n-        x.borrow().with_mut(|inner| {\n-            *inner = 20;\n-        });\n-        assert_eq!(y.borrow().with(|v| *v), 5);\n-    }\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use prelude::drop;\n \n     #[test]\n-    fn test_simple() {\n+    fn test_live() {\n         let x = Rc::new(5);\n-        assert_eq!(*x.borrow(), 5);\n+        let y = x.downgrade();\n+        assert!(y.upgrade().is_some());\n     }\n \n     #[test]\n-    fn test_simple_clone() {\n+    fn test_dead() {\n         let x = Rc::new(5);\n-        let y = x.clone();\n-        assert_eq!(*x.borrow(), 5);\n-        assert_eq!(*y.borrow(), 5);\n-    }\n-\n-    #[test]\n-    fn test_destructor() {\n-        let x = Rc::new(~5);\n-        assert_eq!(**x.borrow(), 5);\n+        let y = x.downgrade();\n+        drop(x);\n+        assert!(y.upgrade().is_none());\n     }\n }"}, {"sha": "54176a1dc434f19fdf752e37bf23df579c6e0985", "filename": "src/libstd/weak.rs", "status": "removed", "additions": 0, "deletions": 190, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/77cc1c5107ced596b694265d898194f33ace361e/src%2Flibstd%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77cc1c5107ced596b694265d898194f33ace361e/src%2Flibstd%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fweak.rs?ref=77cc1c5107ced596b694265d898194f33ace361e", "patch": "@@ -1,190 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*! Task-local reference counted boxes with weak pointer support\n-\n-The `Strong` type is an extension of `std::rc::Rc` with a `downgrade` method returning a `Weak`\n-pointer type. Ownership of the contained value is shared amongst the `Strong` pointers, and the\n-value will be destroyed as soon as the last one is gone. A `Weak` pointer can be upgraded to a\n-`Strong` pointer, but will return `None` if the value has already been freed. It can be used to\n-avoid creating reference cycles.\n-\n-For example, a tree with parent pointers can be represented by putting the nodes behind `Strong`\n-pointers, and then storing the parent pointers as `Weak` pointers.\n-\n-*/\n-\n-use cast::transmute;\n-use ops::Drop;\n-use cmp::{Eq, Ord};\n-use clone::{Clone, DeepClone};\n-use rt::global_heap::exchange_free;\n-use ptr::read_ptr;\n-use option::{Option, Some, None};\n-\n-struct RcBox<T> {\n-    value: T,\n-    strong: uint,\n-    weak: uint\n-}\n-\n-/// Immutable reference counted pointer type\n-#[unsafe_no_drop_flag]\n-#[no_send]\n-pub struct Strong<T> {\n-    priv ptr: *mut RcBox<T>\n-}\n-\n-impl<T> Strong<T> {\n-    /// Construct a new reference-counted box\n-    pub fn new(value: T) -> Strong<T> {\n-        unsafe {\n-            Strong { ptr: transmute(~RcBox { value: value, strong: 1, weak: 0 }) }\n-        }\n-    }\n-}\n-\n-impl<T> Strong<T> {\n-    /// Borrow the value contained in the reference-counted box\n-    #[inline(always)]\n-    pub fn borrow<'a>(&'a self) -> &'a T {\n-        unsafe { &(*self.ptr).value }\n-    }\n-\n-    /// Downgrade the reference-counted pointer to a weak reference\n-    pub fn downgrade(&self) -> Weak<T> {\n-        unsafe {\n-            (*self.ptr).weak += 1;\n-            Weak { ptr: self.ptr }\n-        }\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<T> Drop for Strong<T> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            if self.ptr != 0 as *mut RcBox<T> {\n-                (*self.ptr).strong -= 1;\n-                if (*self.ptr).strong == 0 {\n-                    read_ptr(self.borrow()); // destroy the contained object\n-                    if (*self.ptr).weak == 0 {\n-                        exchange_free(self.ptr as *mut u8 as *i8)\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<T> Clone for Strong<T> {\n-    #[inline]\n-    fn clone(&self) -> Strong<T> {\n-        unsafe {\n-            (*self.ptr).strong += 1;\n-            Strong { ptr: self.ptr }\n-        }\n-    }\n-}\n-\n-impl<T: DeepClone> DeepClone for Strong<T> {\n-    #[inline]\n-    fn deep_clone(&self) -> Strong<T> {\n-        Strong::new(self.borrow().deep_clone())\n-    }\n-}\n-\n-impl<T: Eq> Eq for Strong<T> {\n-    #[inline(always)]\n-    fn eq(&self, other: &Strong<T>) -> bool { *self.borrow() == *other.borrow() }\n-\n-    #[inline(always)]\n-    fn ne(&self, other: &Strong<T>) -> bool { *self.borrow() != *other.borrow() }\n-}\n-\n-impl<T: Ord> Ord for Strong<T> {\n-    #[inline(always)]\n-    fn lt(&self, other: &Strong<T>) -> bool { *self.borrow() < *other.borrow() }\n-\n-    #[inline(always)]\n-    fn le(&self, other: &Strong<T>) -> bool { *self.borrow() <= *other.borrow() }\n-\n-    #[inline(always)]\n-    fn gt(&self, other: &Strong<T>) -> bool { *self.borrow() > *other.borrow() }\n-\n-    #[inline(always)]\n-    fn ge(&self, other: &Strong<T>) -> bool { *self.borrow() >= *other.borrow() }\n-}\n-\n-/// Weak reference to a reference-counted box\n-#[unsafe_no_drop_flag]\n-#[no_send]\n-pub struct Weak<T> {\n-    priv ptr: *mut RcBox<T>\n-}\n-\n-impl<T> Weak<T> {\n-    /// Upgrade a weak reference to a strong reference\n-    pub fn upgrade(&self) -> Option<Strong<T>> {\n-        unsafe {\n-            if (*self.ptr).strong == 0 {\n-                None\n-            } else {\n-                (*self.ptr).strong += 1;\n-                Some(Strong { ptr: self.ptr })\n-            }\n-        }\n-    }\n-}\n-\n-#[unsafe_destructor]\n-impl<T> Drop for Weak<T> {\n-    fn drop(&mut self) {\n-        unsafe {\n-            if self.ptr != 0 as *mut RcBox<T> {\n-                (*self.ptr).weak -= 1;\n-                if (*self.ptr).weak == 0 && (*self.ptr).strong == 0 {\n-                    exchange_free(self.ptr as *mut u8 as *i8)\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<T> Clone for Weak<T> {\n-    #[inline]\n-    fn clone(&self) -> Weak<T> {\n-        unsafe {\n-            (*self.ptr).weak += 1;\n-            Weak { ptr: self.ptr }\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-    use prelude::drop;\n-\n-    #[test]\n-    fn test_live() {\n-        let x = Strong::new(5);\n-        let y = x.downgrade();\n-        assert!(y.upgrade().is_some());\n-    }\n-\n-    #[test]\n-    fn test_dead() {\n-        let x = Strong::new(5);\n-        let y = x.downgrade();\n-        drop(x);\n-        assert!(y.upgrade().is_none());\n-    }\n-}"}]}