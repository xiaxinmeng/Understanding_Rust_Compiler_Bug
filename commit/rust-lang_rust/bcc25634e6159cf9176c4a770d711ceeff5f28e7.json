{"sha": "bcc25634e6159cf9176c4a770d711ceeff5f28e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjYzI1NjM0ZTYxNTljZjkxNzZjNGE3NzBkNzExY2VlZmY1ZjI4ZTc=", "commit": {"author": {"name": "Grahame Bowland", "email": "grahame@angrygoats.net", "date": "2012-01-08T16:37:03Z"}, "committer": {"name": "Grahame Bowland", "email": "grahame@angrygoats.net", "date": "2012-01-08T16:37:03Z"}, "message": "add new read_chars method, fix bug in read_char\n\nhaving a read_chars method is convenient and more efficient.\n\nthe old read_char method had a bug due to re-use of the 'w' width\nvariable as a loop counter and so was broken for wide characters,\nthis patch fixes that.", "tree": {"sha": "f0932e871482379b68b6dd3f49112cddef5d3d88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0932e871482379b68b6dd3f49112cddef5d3d88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bcc25634e6159cf9176c4a770d711ceeff5f28e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bcc25634e6159cf9176c4a770d711ceeff5f28e7", "html_url": "https://github.com/rust-lang/rust/commit/bcc25634e6159cf9176c4a770d711ceeff5f28e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bcc25634e6159cf9176c4a770d711ceeff5f28e7/comments", "author": null, "committer": null, "parents": [{"sha": "e3afc78fde5c614995dd4f2c76da160a321c8f5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3afc78fde5c614995dd4f2c76da160a321c8f5d", "html_url": "https://github.com/rust-lang/rust/commit/e3afc78fde5c614995dd4f2c76da160a321c8f5d"}], "stats": {"total": 80, "additions": 60, "deletions": 20}, "files": [{"sha": "f424b8c3a5e0e2b8ce536b85b6ee44ffeb457e3a", "filename": "src/libstd/io.rs", "status": "modified", "additions": 60, "deletions": 20, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/bcc25634e6159cf9176c4a770d711ceeff5f28e7/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcc25634e6159cf9176c4a770d711ceeff5f28e7/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=bcc25634e6159cf9176c4a770d711ceeff5f28e7", "patch": "@@ -50,6 +50,7 @@ type reader =\n         fn unread_byte(int);\n         fn read_bytes(uint) -> [u8];\n         fn read_char() -> char;\n+        fn read_chars(uint) -> [char];\n         fn eof() -> bool;\n         fn read_line() -> str;\n         fn read_c_str() -> str;\n@@ -101,29 +102,68 @@ obj new_reader(rdr: buf_reader) {\n     fn read_byte() -> int { ret rdr.read_byte(); }\n     fn unread_byte(byte: int) { ret rdr.unread_byte(byte); }\n     fn read_bytes(len: uint) -> [u8] { ret rdr.read(len); }\n+    fn read_chars(n: uint) -> [char] {\n+        // returns the (consumed offset, n_req), appends characters to &chars\n+        fn chars_from_buf(buf: [u8], &chars: [char]) -> (uint, uint) {\n+            let i = 0u;\n+            while i < vec::len(buf) {\n+                let b0 = buf[i];\n+                let w = str::utf8_char_width(b0);\n+                let end = i + w;\n+                i += 1u;\n+                assert (w > 0u);\n+                if w == 1u {\n+                    chars += [ b0 as char ];\n+                    cont;\n+                }\n+                // can't satisfy this char with the existing data\n+                if end > vec::len(buf) {\n+                    ret (i - 1u, end - vec::len(buf));\n+                }\n+                let val = 0u;\n+                while i < end {\n+                    let next = buf[i] as int;\n+                    i += 1u;\n+                    assert (next > -1);\n+                    assert (next & 192 == 128);\n+                    val <<= 6u;\n+                    val += next & 63 as uint;\n+                }\n+                // See str::char_at\n+                val += (b0 << (w + 1u as u8) as uint) << (w - 1u) * 6u - w - 1u;\n+                chars += [ val as char ];\n+            }\n+            ret (i, 0u);\n+        }\n+        let buf: [u8] = [];\n+        let chars: [char] = [];\n+        let nbread = n; // might need more bytes, but reading n will never over-read\n+        while nbread > 0u {\n+            let data = self.read_bytes(nbread); \n+            if vec::len(data) == 0u {\n+                // eof - FIXME should we do something if we're split in a unicode char?\n+                break;\n+            }\n+            buf += data;\n+            let (offset, nbreq) = chars_from_buf(buf, chars);\n+            let ncreq = n - vec::len(chars);\n+            // again we either know we need a certain number of bytes to complete a\n+            // character, or we make sure we don't over-read by reading 1-byte per char\n+            // needed\n+            nbread = if ncreq > nbreq { ncreq } else { nbreq };\n+            if nbread > 0u {\n+                buf = vec::slice(buf, offset, vec::len(buf));\n+            }\n+        }\n+        ret chars;\n+    }\n     fn read_char() -> char {\n-        let c0 = rdr.read_byte();\n-        if c0 == -1 {\n+        let c = self.read_chars(1u);\n+        if vec::len(c) == 0u {\n             ret -1 as char; // FIXME will this stay valid?\n-\n         }\n-        let b0 = c0 as u8;\n-        let w = str::utf8_char_width(b0);\n-        assert (w > 0u);\n-        if w == 1u { ret b0 as char; }\n-        let val = 0u;\n-        while w > 1u {\n-            w -= 1u;\n-            let next = rdr.read_byte();\n-            assert (next > -1);\n-            assert (next & 192 == 128);\n-            val <<= 6u;\n-            val += next & 63 as uint;\n-        }\n-        // See str::char_at\n-\n-        val += (b0 << (w + 1u as u8) as uint) << (w - 1u) * 6u - w - 1u;\n-        ret val as char;\n+        assert(vec::len(c) == 1u);\n+        ret c[0];\n     }\n     fn eof() -> bool { ret rdr.eof(); }\n     fn read_line() -> str {"}]}