{"sha": "9d9c7ad323f95612d933106d65e3057ca9a0434f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkOWM3YWQzMjNmOTU2MTJkOTMzMTA2ZDY1ZTMwNTdjYTlhMDQzNGY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-11T05:24:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-11T05:24:41Z"}, "message": "Auto merge of #61492 - RalfJung:const-qualif-comments, r=eddyb\n\nConst qualification comments\n\nI extracted some const-qualif knowledge from @eddyb. This is my attempt to turn that into comments.\n\nCc @oli-obk \t@eddyb", "tree": {"sha": "4d736547165512baaf2cc86c9310a187f57674fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d736547165512baaf2cc86c9310a187f57674fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d9c7ad323f95612d933106d65e3057ca9a0434f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d9c7ad323f95612d933106d65e3057ca9a0434f", "html_url": "https://github.com/rust-lang/rust/commit/9d9c7ad323f95612d933106d65e3057ca9a0434f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d9c7ad323f95612d933106d65e3057ca9a0434f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "efc30d0cda9002029cdda254a50c82ea82e670da", "url": "https://api.github.com/repos/rust-lang/rust/commits/efc30d0cda9002029cdda254a50c82ea82e670da", "html_url": "https://github.com/rust-lang/rust/commit/efc30d0cda9002029cdda254a50c82ea82e670da"}, {"sha": "0edf46f7d1db0f09dc07bf93ed466ea067d50054", "url": "https://api.github.com/repos/rust-lang/rust/commits/0edf46f7d1db0f09dc07bf93ed466ea067d50054", "html_url": "https://github.com/rust-lang/rust/commit/0edf46f7d1db0f09dc07bf93ed466ea067d50054"}], "stats": {"total": 124, "additions": 81, "deletions": 43}, "files": [{"sha": "19bd812ec80c0106ab784b3dc4ab24321ac0eec8", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 81, "deletions": 43, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/9d9c7ad323f95612d933106d65e3057ca9a0434f/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d9c7ad323f95612d933106d65e3057ca9a0434f/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=9d9c7ad323f95612d933106d65e3057ca9a0434f", "patch": "@@ -35,11 +35,25 @@ use super::promote_consts::{self, Candidate, TempState};\n /// What kind of item we are in.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n enum Mode {\n-    Const,\n+    /// A `static` item.\n     Static,\n+    /// A `static mut` item.\n     StaticMut,\n+    /// A `const fn` item.\n     ConstFn,\n-    Fn\n+    /// A `const` item or an anonymous constant (e.g. in array lengths).\n+    Const,\n+    /// Other type of `fn`.\n+    NonConstFn,\n+}\n+\n+impl Mode {\n+    /// Determine whether we have to do full const-checking because syntactically, we\n+    /// are required to be \"const\".\n+    #[inline]\n+    fn requires_const_checking(self) -> bool {\n+        self != Mode::NonConstFn\n+    }\n }\n \n impl fmt::Display for Mode {\n@@ -48,7 +62,7 @@ impl fmt::Display for Mode {\n             Mode::Const => write!(f, \"constant\"),\n             Mode::Static | Mode::StaticMut => write!(f, \"static\"),\n             Mode::ConstFn => write!(f, \"constant function\"),\n-            Mode::Fn => write!(f, \"function\")\n+            Mode::NonConstFn => write!(f, \"function\")\n         }\n     }\n }\n@@ -135,6 +149,12 @@ enum ValueSource<'a, 'tcx> {\n     },\n }\n \n+/// A \"qualif\"(-ication) is a way to look for something \"bad\" in the MIR that would disqualify some\n+/// code for promotion or prevent it from evaluating at compile time. So `return true` means\n+/// \"I found something bad, no reason to go on searching\". `false` is only returned if we\n+/// definitely cannot find anything bad anywhere.\n+///\n+/// The default implementations proceed structurally.\n trait Qualif {\n     const IDX: usize;\n \n@@ -285,7 +305,11 @@ trait Qualif {\n     }\n }\n \n-// Constant containing interior mutability (UnsafeCell).\n+/// Constant containing interior mutability (`UnsafeCell<T>`).\n+/// This must be ruled out to make sure that evaluating the constant at compile-time\n+/// and at *any point* during the run-time would produce the same result. In particular,\n+/// promotion of temporaries must not change program behavior; if the promoted could be\n+/// written to, that would be a problem.\n struct HasMutInterior;\n \n impl Qualif for HasMutInterior {\n@@ -314,10 +338,10 @@ impl Qualif for HasMutInterior {\n                             _ => return true,\n                         }\n                     } else if let ty::Array(_, len) = ty.sty {\n-                        // FIXME(eddyb) the `cx.mode == Mode::Fn` condition\n+                        // FIXME(eddyb) the `cx.mode == Mode::NonConstFn` condition\n                         // seems unnecessary, given that this is merely a ZST.\n                         match len.assert_usize(cx.tcx) {\n-                            Some(0) if cx.mode == Mode::Fn => {},\n+                            Some(0) if cx.mode == Mode::NonConstFn => {},\n                             _ => return true,\n                         }\n                     } else {\n@@ -343,7 +367,10 @@ impl Qualif for HasMutInterior {\n     }\n }\n \n-// Constant containing an ADT that implements Drop.\n+/// Constant containing an ADT that implements `Drop`.\n+/// This must be ruled out (a) because we cannot run `Drop` during compile-time\n+/// as that might not be a `const fn`, and (b) because implicit promotion would\n+/// remove side-effects that occur as part of dropping that value.\n struct NeedsDrop;\n \n impl Qualif for NeedsDrop {\n@@ -366,8 +393,12 @@ impl Qualif for NeedsDrop {\n     }\n }\n \n-// Not promotable at all - non-`const fn` calls, asm!,\n-// pointer comparisons, ptr-to-int casts, etc.\n+/// Not promotable at all - non-`const fn` calls, `asm!`,\n+/// pointer comparisons, ptr-to-int casts, etc.\n+/// Inside a const context all constness rules apply, so promotion simply has to follow the regular\n+/// constant rules (modulo interior mutability or `Drop` rules which are handled `HasMutInterior`\n+/// and `NeedsDrop` respectively). Basically this duplicates the checks that the const-checking\n+/// visitor enforces by emitting errors when working in const context.\n struct IsNotPromotable;\n \n impl Qualif for IsNotPromotable {\n@@ -398,9 +429,10 @@ impl Qualif for IsNotPromotable {\n             ProjectionElem::Index(_) => {}\n \n             ProjectionElem::Field(..) => {\n-                if cx.mode == Mode::Fn {\n+                if cx.mode == Mode::NonConstFn {\n                     let base_ty = proj.base.ty(cx.body, cx.tcx).ty;\n                     if let Some(def) = base_ty.ty_adt_def() {\n+                        // No promotion of union field accesses.\n                         if def.is_union() {\n                             return true;\n                         }\n@@ -414,7 +446,7 @@ impl Qualif for IsNotPromotable {\n \n     fn in_rvalue(cx: &ConstCx<'_, 'tcx>, rvalue: &Rvalue<'tcx>) -> bool {\n         match *rvalue {\n-            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) if cx.mode == Mode::Fn => {\n+            Rvalue::Cast(CastKind::Misc, ref operand, cast_ty) if cx.mode == Mode::NonConstFn => {\n                 let operand_ty = operand.ty(cx.body, cx.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n@@ -428,7 +460,7 @@ impl Qualif for IsNotPromotable {\n                 }\n             }\n \n-            Rvalue::BinaryOp(op, ref lhs, _) if cx.mode == Mode::Fn => {\n+            Rvalue::BinaryOp(op, ref lhs, _) if cx.mode == Mode::NonConstFn => {\n                 if let ty::RawPtr(_) | ty::FnPtr(..) = lhs.ty(cx.body, cx.tcx).sty {\n                     assert!(op == BinOp::Eq || op == BinOp::Ne ||\n                             op == BinOp::Le || op == BinOp::Lt ||\n@@ -511,12 +543,9 @@ impl Qualif for IsNotPromotable {\n \n /// Refers to temporaries which cannot be promoted *implicitly*.\n /// Explicit promotion happens e.g. for constant arguments declared via `rustc_args_required_const`.\n-/// Inside a const context all constness rules\n-/// apply, so implicit promotion simply has to follow the regular constant rules (modulo interior\n-/// mutability or `Drop` rules which are handled `HasMutInterior` and `NeedsDrop` respectively).\n-/// Implicit promotion inside regular functions does not happen if `const fn` calls are involved,\n-/// as the call may be perfectly alright at runtime, but fail at compile time e.g. due to addresses\n-/// being compared inside the function.\n+/// Implicit promotion has almost the same rules, except that disallows `const fn` except for\n+/// those marked `#[rustc_promotable]`. This is to avoid changing a legitimate run-time operation\n+/// into a failing compile-time operation e.g. due to addresses being compared inside the function.\n struct IsNotImplicitlyPromotable;\n \n impl Qualif for IsNotImplicitlyPromotable {\n@@ -528,7 +557,7 @@ impl Qualif for IsNotImplicitlyPromotable {\n         args: &[Operand<'tcx>],\n         _return_ty: Ty<'tcx>,\n     ) -> bool {\n-        if cx.mode == Mode::Fn {\n+        if cx.mode == Mode::NonConstFn {\n             if let ty::FnDef(def_id, _) = callee.ty(cx.body, cx.tcx).sty {\n                 // Never promote runtime `const fn` calls of\n                 // functions without `#[rustc_promotable]`.\n@@ -589,6 +618,11 @@ impl ConstCx<'_, 'tcx> {\n     }\n }\n \n+/// Checks MIR for being admissible as a compile-time constant, using `ConstCx`\n+/// for value qualifications, and accumulates writes of\n+/// rvalue/call results to locals, in `local_qualif`.\n+/// It also records candidates for promotion in `promotion_candidates`,\n+/// both in functions and const/static items.\n struct Checker<'a, 'tcx> {\n     cx: ConstCx<'a, 'tcx>,\n \n@@ -672,7 +706,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n     // slightly pointless (even with feature-gating).\n     fn not_const(&mut self) {\n         unleash_miri!(self);\n-        if self.mode != Mode::Fn {\n+        if self.mode.requires_const_checking() {\n             let mut err = struct_span_err!(\n                 self.tcx.sess,\n                 self.span,\n@@ -707,7 +741,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                 qualifs[HasMutInterior] = false;\n                 qualifs[IsNotPromotable] = true;\n \n-                if self.mode != Mode::Fn {\n+                if self.mode.requires_const_checking() {\n                     if let BorrowKind::Mut { .. } = kind {\n                         let mut err = struct_span_err!(self.tcx.sess,  self.span, E0017,\n                                                        \"references in {}s may only refer \\\n@@ -737,7 +771,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n \n                 // We might have a candidate for promotion.\n                 let candidate = Candidate::Ref(location);\n-                // We can only promote interior borrows of promotable temps.\n+                // Start by traversing to the \"base\", with non-deref projections removed.\n                 let mut place = place;\n                 while let Place::Projection(ref proj) = *place {\n                     if proj.elem == ProjectionElem::Deref {\n@@ -746,6 +780,10 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                     place = &proj.base;\n                 }\n                 debug!(\"qualify_consts: promotion candidate: place={:?}\", place);\n+                // We can only promote interior borrows of promotable temps (non-temps\n+                // don't get promoted anyway).\n+                // (If we bailed out of the loop due to a `Deref` above, we will definitely\n+                // not enter the conditional here.)\n                 if let Place::Base(PlaceBase::Local(local)) = *place {\n                     if self.body.local_kind(local) == LocalKind::Temp {\n                         debug!(\"qualify_consts: promotion candidate: local={:?}\", local);\n@@ -756,6 +794,10 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                         // `HasMutInterior`, from a type that does, e.g.:\n                         // `let _: &'static _ = &(Cell::new(1), 2).1;`\n                         let mut local_qualifs = self.qualifs_in_local(local);\n+                        // Any qualifications, except HasMutInterior (see above), disqualify\n+                        // from promotion.\n+                        // This is, in particular, the \"implicit promotion\" version of\n+                        // the check making sure that we don't run drop glue during const-eval.\n                         local_qualifs[HasMutInterior] = false;\n                         if !local_qualifs.0.iter().any(|&qualif| qualif) {\n                             debug!(\"qualify_consts: promotion candidate: {:?}\", candidate);\n@@ -803,7 +845,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n         debug!(\"store to {:?} {:?}\", kind, index);\n \n         // Only handle promotable temps in non-const functions.\n-        if self.mode == Mode::Fn {\n+        if self.mode == Mode::NonConstFn {\n             if kind != LocalKind::Temp ||\n                !self.temp_promotion_state[index].is_promotable() {\n                 return;\n@@ -920,11 +962,6 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n     }\n }\n \n-/// Checks MIR for const-correctness, using `ConstCx`\n-/// for value qualifications, and accumulates writes of\n-/// rvalue/call results to locals, in `local_qualif`.\n-/// For functions (constant or not), it also records\n-/// candidates for promotion in `promotion_candidates`.\n impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n     fn visit_place_base(\n         &mut self,\n@@ -943,7 +980,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                         .get_attrs(*def_id)\n                         .iter()\n                         .any(|attr| attr.check_name(sym::thread_local)) {\n-                    if self.mode != Mode::Fn {\n+                    if self.mode.requires_const_checking() {\n                         span_err!(self.tcx.sess, self.span, E0625,\n                                     \"thread-local statics cannot be \\\n                                     accessed at compile-time\");\n@@ -967,7 +1004,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 }\n                 unleash_miri!(self);\n \n-                if self.mode != Mode::Fn {\n+                if self.mode.requires_const_checking() {\n                     let mut err = struct_span_err!(self.tcx.sess, self.span, E0013,\n                                                     \"{}s cannot refer to statics, use \\\n                                                     a constant instead\", self.mode);\n@@ -1005,7 +1042,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 }\n                 let base_ty = proj.base.ty(self.body, self.tcx).ty;\n                 match self.mode {\n-                    Mode::Fn => {},\n+                    Mode::NonConstFn => {},\n                     _ => {\n                         if let ty::RawPtr(_) = base_ty.sty {\n                             if !self.tcx.features().const_raw_ptr_deref {\n@@ -1041,7 +1078,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                 }\n                             },\n \n-                            | Mode::Fn\n+                            | Mode::NonConstFn\n                             | Mode::Static\n                             | Mode::StaticMut\n                             | Mode::Const\n@@ -1131,7 +1168,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n                 match (cast_in, cast_out) {\n                     (CastTy::Ptr(_), CastTy::Int(_)) |\n-                    (CastTy::FnPtr, CastTy::Int(_)) if self.mode != Mode::Fn => {\n+                    (CastTy::FnPtr, CastTy::Int(_)) if self.mode != Mode::NonConstFn => {\n                         unleash_miri!(self);\n                         if !self.tcx.features().const_raw_ptr_to_usize_cast {\n                             // in const fn and constants require the feature gate\n@@ -1158,7 +1195,9 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                             op == BinOp::Offset);\n \n                     unleash_miri!(self);\n-                    if self.mode != Mode::Fn && !self.tcx.features().const_compare_raw_pointers {\n+                    if self.mode.requires_const_checking() &&\n+                        !self.tcx.features().const_compare_raw_pointers\n+                    {\n                         // require the feature gate inside constants and const fn\n                         // FIXME: make it unsafe to use these operations\n                         emit_feature_err(\n@@ -1174,7 +1213,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n \n             Rvalue::NullaryOp(NullOp::Box, _) => {\n                 unleash_miri!(self);\n-                if self.mode != Mode::Fn {\n+                if self.mode.requires_const_checking() {\n                     let mut err = struct_span_err!(self.tcx.sess, self.span, E0010,\n                                                    \"allocations are not allowed in {}s\", self.mode);\n                     err.span_label(self.span, format!(\"allocation not allowed in {}s\", self.mode));\n@@ -1219,8 +1258,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                 // special intrinsic that can be called diretly without an intrinsic\n                                 // feature gate needs a language feature gate\n                                 \"transmute\" => {\n-                                    // never promote transmute calls\n-                                    if self.mode != Mode::Fn {\n+                                    if self.mode.requires_const_checking() {\n                                         // const eval transmute calls only with the feature gate\n                                         if !self.tcx.features().const_transmute {\n                                             emit_feature_err(\n@@ -1243,7 +1281,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                         }\n                         _ => {\n                             // In normal functions no calls are feature-gated.\n-                            if self.mode != Mode::Fn {\n+                            if self.mode.requires_const_checking() {\n                                 let unleash_miri = self\n                                     .tcx\n                                     .sess\n@@ -1302,7 +1340,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                     }\n                 }\n                 ty::FnPtr(_) => {\n-                    if self.mode != Mode::Fn {\n+                    if self.mode.requires_const_checking() {\n                         let mut err = self.tcx.sess.struct_span_err(\n                             self.span,\n                             &format!(\"function pointers are not allowed in const fn\"));\n@@ -1361,7 +1399,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             self.super_terminator_kind(kind, location);\n \n             // Deny *any* live drops anywhere other than functions.\n-            if self.mode != Mode::Fn {\n+            if self.mode.requires_const_checking() {\n                 unleash_miri!(self);\n                 // HACK(eddyb): emulate a bit of dataflow analysis,\n                 // conservatively, that drop elaboration will do.\n@@ -1472,12 +1510,12 @@ impl MirPass for QualifyAndPromoteConstants {\n         let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n         let mut const_promoted_temps = None;\n         let mode = match tcx.hir().body_owner_kind_by_hir_id(id) {\n-            hir::BodyOwnerKind::Closure => Mode::Fn,\n+            hir::BodyOwnerKind::Closure => Mode::NonConstFn,\n             hir::BodyOwnerKind::Fn => {\n                 if tcx.is_const_fn(def_id) {\n                     Mode::ConstFn\n                 } else {\n-                    Mode::Fn\n+                    Mode::NonConstFn\n                 }\n             }\n             hir::BodyOwnerKind::Const => {\n@@ -1489,7 +1527,7 @@ impl MirPass for QualifyAndPromoteConstants {\n         };\n \n         debug!(\"run_pass: mode={:?}\", mode);\n-        if mode == Mode::Fn || mode == Mode::ConstFn {\n+        if mode == Mode::NonConstFn || mode == Mode::ConstFn {\n             // This is ugly because Checker holds onto mir,\n             // which can't be mutated until its scope ends.\n             let (temps, candidates) = {"}]}