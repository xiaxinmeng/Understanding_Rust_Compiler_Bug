{"sha": "7e4ed72d64eb7a6bd6a05d4f3222aa43975898e1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlNGVkNzJkNjRlYjdhNmJkNmEwNWQ0ZjMyMjJhYTQzOTc1ODk4ZTE=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-04-05T11:13:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-05T11:13:08Z"}, "message": "Rollup merge of #70558 - RalfJung:vec-extend-aliasing, r=Amanieu\n\nFix some aliasing issues in Vec\n\n`Vec::extend` and `Vec::truncate` invalidated references into the vector even without reallocation, because they (implicitly) created a mutable reference covering the *entire* initialized part of the vector.\n\nFixes https://github.com/rust-lang/rust/issues/70301\nI verified the fix by adding some new tests here that I ran in Miri.", "tree": {"sha": "f41410f4fc699afc25c019cecbf8c78233a4234b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f41410f4fc699afc25c019cecbf8c78233a4234b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7e4ed72d64eb7a6bd6a05d4f3222aa43975898e1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeib1ECRBK7hj4Ov3rIwAAdHIIADzgdZ40dXKvJ+Mir7swgcVo\nUHUjs0QKjDjQOuzmSymnqDBE1/sjS0fBl+fihJj2cbcq3OcGnsP5RxwunGu/Mnqs\nlGAoa/6349M/uaNVPPGgFPS+J1PiehXr6Nxy6aOXC9wFdaGPbpekTvSB4URBVFaP\nttOiWZuRsQgNBY26Frd1tzydQMCJfcnZ0TPYzyNKfxraX1hiVY9+ReeqAIiVUWKo\nehUjI11XQmsOYiN6Ro5fRL9nCvgdwGcNtlTET2SHAXL0D1c5KgoZhSg73yux1j1S\nnhX1SUWEP1KypZgthxX/p86UKt8ejHAH5CLNzCPdBq2QjlJ2jy3rPWm3xhW3SCo=\n=TCGw\n-----END PGP SIGNATURE-----\n", "payload": "tree f41410f4fc699afc25c019cecbf8c78233a4234b\nparent 7b657d340d715f48449189fea9d032350323a13f\nparent 7e81c11aa8ddcebf64c01579754b44930ecf4d04\nauthor Dylan DPC <dylan.dpc@gmail.com> 1586085188 +0200\ncommitter GitHub <noreply@github.com> 1586085188 +0200\n\nRollup merge of #70558 - RalfJung:vec-extend-aliasing, r=Amanieu\n\nFix some aliasing issues in Vec\n\n`Vec::extend` and `Vec::truncate` invalidated references into the vector even without reallocation, because they (implicitly) created a mutable reference covering the *entire* initialized part of the vector.\n\nFixes https://github.com/rust-lang/rust/issues/70301\nI verified the fix by adding some new tests here that I ran in Miri.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7e4ed72d64eb7a6bd6a05d4f3222aa43975898e1", "html_url": "https://github.com/rust-lang/rust/commit/7e4ed72d64eb7a6bd6a05d4f3222aa43975898e1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7e4ed72d64eb7a6bd6a05d4f3222aa43975898e1/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b657d340d715f48449189fea9d032350323a13f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b657d340d715f48449189fea9d032350323a13f", "html_url": "https://github.com/rust-lang/rust/commit/7b657d340d715f48449189fea9d032350323a13f"}, {"sha": "7e81c11aa8ddcebf64c01579754b44930ecf4d04", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e81c11aa8ddcebf64c01579754b44930ecf4d04", "html_url": "https://github.com/rust-lang/rust/commit/7e81c11aa8ddcebf64c01579754b44930ecf4d04"}], "stats": {"total": 93, "additions": 79, "deletions": 14}, "files": [{"sha": "6321e7154e7d091e7617a6007e79522185f84876", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 66, "deletions": 5, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/7e4ed72d64eb7a6bd6a05d4f3222aa43975898e1/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e4ed72d64eb7a6bd6a05d4f3222aa43975898e1/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=7e4ed72d64eb7a6bd6a05d4f3222aa43975898e1", "patch": "@@ -1351,24 +1351,85 @@ fn test_try_reserve_exact() {\n }\n \n #[test]\n-fn test_stable_push_pop() {\n+fn test_stable_pointers() {\n+    /// Pull an element from the iterator, then drop it.\n+    /// Useful to cover both the `next` and `drop` paths of an iterator.\n+    fn next_then_drop<I: Iterator>(mut i: I) {\n+        i.next().unwrap();\n+        drop(i);\n+    }\n+\n     // Test that, if we reserved enough space, adding and removing elements does not\n     // invalidate references into the vector (such as `v0`).  This test also\n     // runs in Miri, which would detect such problems.\n-    let mut v = Vec::with_capacity(10);\n+    let mut v = Vec::with_capacity(128);\n     v.push(13);\n \n-    // laundering the lifetime -- we take care that `v` does not reallocate, so that's okay.\n-    let v0 = unsafe { &*(&v[0] as *const _) };\n-\n+    // Laundering the lifetime -- we take care that `v` does not reallocate, so that's okay.\n+    let v0 = &mut v[0];\n+    let v0 = unsafe { &mut *(v0 as *mut _) };\n     // Now do a bunch of things and occasionally use `v0` again to assert it is still valid.\n+\n+    // Pushing/inserting and popping/removing\n     v.push(1);\n     v.push(2);\n     v.insert(1, 1);\n     assert_eq!(*v0, 13);\n     v.remove(1);\n     v.pop().unwrap();\n     assert_eq!(*v0, 13);\n+    v.push(1);\n+    v.swap_remove(1);\n+    assert_eq!(v.len(), 2);\n+    v.swap_remove(1); // swap_remove the last element\n+    assert_eq!(*v0, 13);\n+\n+    // Appending\n+    v.append(&mut vec![27, 19]);\n+    assert_eq!(*v0, 13);\n+\n+    // Extending\n+    v.extend_from_slice(&[1, 2]);\n+    v.extend(&[1, 2]); // `slice::Iter` (with `T: Copy`) specialization\n+    v.extend(vec![2, 3]); // `vec::IntoIter` specialization\n+    v.extend(std::iter::once(3)); // `TrustedLen` specialization\n+    v.extend(std::iter::empty::<i32>()); // `TrustedLen` specialization with empty iterator\n+    v.extend(std::iter::once(3).filter(|_| true)); // base case\n+    v.extend(std::iter::once(&3)); // `cloned` specialization\n+    assert_eq!(*v0, 13);\n+\n+    // Truncation\n+    v.truncate(2);\n+    assert_eq!(*v0, 13);\n+\n+    // Resizing\n+    v.resize_with(v.len() + 10, || 42);\n+    assert_eq!(*v0, 13);\n+    v.resize_with(2, || panic!());\n+    assert_eq!(*v0, 13);\n+\n+    // No-op reservation\n+    v.reserve(32);\n+    v.reserve_exact(32);\n+    assert_eq!(*v0, 13);\n+\n+    // Partial draining\n+    v.resize_with(10, || 42);\n+    next_then_drop(v.drain(5..));\n+    assert_eq!(*v0, 13);\n+\n+    // Splicing\n+    v.resize_with(10, || 42);\n+    next_then_drop(v.splice(5.., vec![1, 2, 3, 4, 5])); // empty tail after range\n+    assert_eq!(*v0, 13);\n+    next_then_drop(v.splice(5..8, vec![1])); // replacement is smaller than original range\n+    assert_eq!(*v0, 13);\n+    next_then_drop(v.splice(5..6, vec![1; 10].into_iter().filter(|_| true))); // lower bound not exact\n+    assert_eq!(*v0, 13);\n+\n+    // Smoke test that would fire even outside Miri if an actual relocation happened.\n+    *v0 -= 13;\n+    assert_eq!(v[0], 0);\n }\n \n // https://github.com/rust-lang/rust/pull/49496 introduced specialization based on:"}, {"sha": "a48e48d7da31e6d6748ec6d925e4f2c36f6c7aae", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7e4ed72d64eb7a6bd6a05d4f3222aa43975898e1/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7e4ed72d64eb7a6bd6a05d4f3222aa43975898e1/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=7e4ed72d64eb7a6bd6a05d4f3222aa43975898e1", "patch": "@@ -740,7 +740,8 @@ impl<T> Vec<T> {\n             if len > self.len {\n                 return;\n             }\n-            let s = self.get_unchecked_mut(len..) as *mut _;\n+            let remaining_len = self.len - len;\n+            let s = slice::from_raw_parts_mut(self.as_mut_ptr().add(len), remaining_len);\n             self.len = len;\n             ptr::drop_in_place(s);\n         }\n@@ -963,13 +964,15 @@ impl<T> Vec<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn swap_remove(&mut self, index: usize) -> T {\n+        let len = self.len();\n+        assert!(index < len);\n         unsafe {\n             // We replace self[index] with the last element. Note that if the\n-            // bounds check on hole succeeds there must be a last element (which\n+            // bounds check above succeeds there must be a last element (which\n             // can be self[index] itself).\n-            let hole: *mut T = &mut self[index];\n-            let last = ptr::read(self.get_unchecked(self.len - 1));\n-            self.len -= 1;\n+            let last = ptr::read(self.as_ptr().add(len - 1));\n+            let hole: *mut T = self.as_mut_ptr().add(index);\n+            self.set_len(len - 1);\n             ptr::replace(hole, last)\n         }\n     }\n@@ -1200,7 +1203,7 @@ impl<T> Vec<T> {\n         } else {\n             unsafe {\n                 self.len -= 1;\n-                Some(ptr::read(self.get_unchecked(self.len())))\n+                Some(ptr::read(self.as_ptr().add(self.len())))\n             }\n         }\n     }\n@@ -2020,7 +2023,7 @@ where\n                 let (lower, _) = iterator.size_hint();\n                 let mut vector = Vec::with_capacity(lower.saturating_add(1));\n                 unsafe {\n-                    ptr::write(vector.get_unchecked_mut(0), element);\n+                    ptr::write(vector.as_mut_ptr(), element);\n                     vector.set_len(1);\n                 }\n                 vector\n@@ -2122,8 +2125,9 @@ where\n         self.reserve(slice.len());\n         unsafe {\n             let len = self.len();\n+            let dst_slice = slice::from_raw_parts_mut(self.as_mut_ptr().add(len), slice.len());\n+            dst_slice.copy_from_slice(slice);\n             self.set_len(len + slice.len());\n-            self.get_unchecked_mut(len..).copy_from_slice(slice);\n         }\n     }\n }\n@@ -2144,7 +2148,7 @@ impl<T> Vec<T> {\n                 self.reserve(lower.saturating_add(1));\n             }\n             unsafe {\n-                ptr::write(self.get_unchecked_mut(len), element);\n+                ptr::write(self.as_mut_ptr().add(len), element);\n                 // NB can't overflow since we would have had to alloc the address space\n                 self.set_len(len + 1);\n             }"}]}