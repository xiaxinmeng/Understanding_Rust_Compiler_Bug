{"sha": "1a97ab34dbe21a528f9109c74c4b3404543c5d2b", "node_id": "C_kwDOAAsO6NoAKDFhOTdhYjM0ZGJlMjFhNTI4ZjkxMDljNzRjNGIzNDA0NTQzYzVkMmI", "commit": {"author": {"name": "bitgaoshu", "email": "bitgaoshu@gmail.com", "date": "2022-06-03T02:28:01Z"}, "committer": {"name": "bitgaoshu", "email": "bitgaoshu@gmail.com", "date": "2022-06-03T02:47:41Z"}, "message": "fix: #12441 False-positive type-mismatch error with generic future", "tree": {"sha": "6c47fb10db8f1f706f7a9be226792abf7a56fcf9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c47fb10db8f1f706f7a9be226792abf7a56fcf9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a97ab34dbe21a528f9109c74c4b3404543c5d2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a97ab34dbe21a528f9109c74c4b3404543c5d2b", "html_url": "https://github.com/rust-lang/rust/commit/1a97ab34dbe21a528f9109c74c4b3404543c5d2b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a97ab34dbe21a528f9109c74c4b3404543c5d2b/comments", "author": {"login": "bitgaoshu", "id": 7943146, "node_id": "MDQ6VXNlcjc5NDMxNDY=", "avatar_url": "https://avatars.githubusercontent.com/u/7943146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bitgaoshu", "html_url": "https://github.com/bitgaoshu", "followers_url": "https://api.github.com/users/bitgaoshu/followers", "following_url": "https://api.github.com/users/bitgaoshu/following{/other_user}", "gists_url": "https://api.github.com/users/bitgaoshu/gists{/gist_id}", "starred_url": "https://api.github.com/users/bitgaoshu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bitgaoshu/subscriptions", "organizations_url": "https://api.github.com/users/bitgaoshu/orgs", "repos_url": "https://api.github.com/users/bitgaoshu/repos", "events_url": "https://api.github.com/users/bitgaoshu/events{/privacy}", "received_events_url": "https://api.github.com/users/bitgaoshu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bitgaoshu", "id": 7943146, "node_id": "MDQ6VXNlcjc5NDMxNDY=", "avatar_url": "https://avatars.githubusercontent.com/u/7943146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bitgaoshu", "html_url": "https://github.com/bitgaoshu", "followers_url": "https://api.github.com/users/bitgaoshu/followers", "following_url": "https://api.github.com/users/bitgaoshu/following{/other_user}", "gists_url": "https://api.github.com/users/bitgaoshu/gists{/gist_id}", "starred_url": "https://api.github.com/users/bitgaoshu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bitgaoshu/subscriptions", "organizations_url": "https://api.github.com/users/bitgaoshu/orgs", "repos_url": "https://api.github.com/users/bitgaoshu/repos", "events_url": "https://api.github.com/users/bitgaoshu/events{/privacy}", "received_events_url": "https://api.github.com/users/bitgaoshu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e10799536a22a777891f5a971626e79c17097f9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e10799536a22a777891f5a971626e79c17097f9e", "html_url": "https://github.com/rust-lang/rust/commit/e10799536a22a777891f5a971626e79c17097f9e"}], "stats": {"total": 82, "additions": 78, "deletions": 4}, "files": [{"sha": "faec99c7d33c1f2d7d1b183e3b7a19d478e35e82", "filename": "crates/hir-ty/src/chalk_db.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1a97ab34dbe21a528f9109c74c4b3404543c5d2b/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a97ab34dbe21a528f9109c74c4b3404543c5d2b/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs?ref=1a97ab34dbe21a528f9109c74c4b3404543c5d2b", "patch": "@@ -241,6 +241,27 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n                             .intern(Interner),\n                         ),\n                     });\n+                    let mut binder = vec![];\n+                    binder.push(crate::wrap_empty_binders(impl_bound));\n+                    let sized_trait = self\n+                        .db\n+                        .lang_item(self.krate, SmolStr::new_inline(\"sized\"))\n+                        .and_then(|item| item.as_trait());\n+                    if let Some(sized_trait_) = sized_trait {\n+                        let sized_bound = WhereClause::Implemented(TraitRef {\n+                            trait_id: to_chalk_trait_id(sized_trait_),\n+                            // Self type as the first parameter.\n+                            substitution: Substitution::from1(\n+                                Interner,\n+                                TyKind::BoundVar(BoundVar {\n+                                    debruijn: DebruijnIndex::INNERMOST,\n+                                    index: 0,\n+                                })\n+                                .intern(Interner),\n+                            ),\n+                        });\n+                        binder.push(crate::wrap_empty_binders(sized_bound));\n+                    }\n                     let proj_bound = WhereClause::AliasEq(AliasEq {\n                         alias: AliasTy::Projection(ProjectionTy {\n                             associated_ty_id: to_assoc_type_id(future_output),\n@@ -255,11 +276,9 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n                         ty: TyKind::BoundVar(BoundVar { debruijn: DebruijnIndex::ONE, index: 0 })\n                             .intern(Interner),\n                     });\n+                    binder.push(crate::wrap_empty_binders(proj_bound));\n                     let bound = OpaqueTyDatumBound {\n-                        bounds: make_single_type_binders(vec![\n-                            crate::wrap_empty_binders(impl_bound),\n-                            crate::wrap_empty_binders(proj_bound),\n-                        ]),\n+                        bounds: make_single_type_binders(binder),\n                         where_clauses: chalk_ir::Binders::empty(Interner, vec![]),\n                     };\n                     // The opaque type has 1 parameter."}, {"sha": "30c67d41b7175d7ddda8412b7e4ad7585220625b", "filename": "crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/1a97ab34dbe21a528f9109c74c4b3404543c5d2b/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a97ab34dbe21a528f9109c74c4b3404543c5d2b/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=1a97ab34dbe21a528f9109c74c4b3404543c5d2b", "patch": "@@ -82,6 +82,61 @@ async fn test() {\n     );\n }\n \n+#[test]\n+fn auto_sized_async_block() {\n+    check_no_mismatches(\n+        r#\"\n+//- minicore: future, sized\n+\n+use core::future::Future;\n+struct MyFut<Fut>(Fut);\n+\n+impl<Fut> Future for MyFut<Fut>\n+where Fut: Future\n+{\n+    type Output = Fut::Output;\n+}\n+async fn reproduction() -> usize {\n+    let f = async {999usize};\n+    MyFut(f).await\n+}\n+    \"#,\n+    );\n+    check_no_mismatches(\n+        r#\"\n+//- minicore: future\n+//#11815\n+#[lang = \"sized\"]\n+pub trait Sized {}\n+\n+#[lang = \"unsize\"]\n+pub trait Unsize<T: ?Sized> {}\n+\n+#[lang = \"coerce_unsized\"]\n+pub trait CoerceUnsized<T> {}\n+\n+pub unsafe trait Allocator {}\n+\n+pub struct Global;\n+unsafe impl Allocator for Global {}\n+\n+#[lang = \"owned_box\"]\n+#[fundamental]\n+pub struct Box<T: ?Sized, A: Allocator = Global>;\n+\n+impl<T: ?Sized + Unsize<U>, U: ?Sized, A: Allocator> CoerceUnsized<Box<U, A>> for Box<T, A> {}\n+\n+fn send() ->  Box<dyn Future<Output = ()> + Send + 'static>{\n+    box async move {}\n+}\n+\n+fn not_send() -> Box<dyn Future<Output = ()> + 'static> {\n+    box async move {}\n+}\n+    \"#,\n+    );\n+}\n+\n #[test]\n fn infer_try() {\n     check_types("}]}