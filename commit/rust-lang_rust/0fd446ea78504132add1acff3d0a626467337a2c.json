{"sha": "0fd446ea78504132add1acff3d0a626467337a2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmZDQ0NmVhNzg1MDQxMzJhZGQxYWNmZjNkMGE2MjY0NjczMzdhMmM=", "commit": {"author": {"name": "Edward Barnard", "email": "eabarnard@gmail.com", "date": "2019-04-11T15:02:13Z"}, "committer": {"name": "Edward Barnard", "email": "eabarnard@gmail.com", "date": "2019-05-02T08:41:37Z"}, "message": "Make `std::fs::copy` attempt to create copy-on-write clones of files on MacOS.", "tree": {"sha": "ecb6a4fd1fd158903b12375a8095c1063b615635", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ecb6a4fd1fd158903b12375a8095c1063b615635"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0fd446ea78504132add1acff3d0a626467337a2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0fd446ea78504132add1acff3d0a626467337a2c", "html_url": "https://github.com/rust-lang/rust/commit/0fd446ea78504132add1acff3d0a626467337a2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0fd446ea78504132add1acff3d0a626467337a2c/comments", "author": {"login": "ebarnard", "id": 1059683, "node_id": "MDQ6VXNlcjEwNTk2ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1059683?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebarnard", "html_url": "https://github.com/ebarnard", "followers_url": "https://api.github.com/users/ebarnard/followers", "following_url": "https://api.github.com/users/ebarnard/following{/other_user}", "gists_url": "https://api.github.com/users/ebarnard/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebarnard/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebarnard/subscriptions", "organizations_url": "https://api.github.com/users/ebarnard/orgs", "repos_url": "https://api.github.com/users/ebarnard/repos", "events_url": "https://api.github.com/users/ebarnard/events{/privacy}", "received_events_url": "https://api.github.com/users/ebarnard/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ebarnard", "id": 1059683, "node_id": "MDQ6VXNlcjEwNTk2ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1059683?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebarnard", "html_url": "https://github.com/ebarnard", "followers_url": "https://api.github.com/users/ebarnard/followers", "following_url": "https://api.github.com/users/ebarnard/following{/other_user}", "gists_url": "https://api.github.com/users/ebarnard/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebarnard/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebarnard/subscriptions", "organizations_url": "https://api.github.com/users/ebarnard/orgs", "repos_url": "https://api.github.com/users/ebarnard/repos", "events_url": "https://api.github.com/users/ebarnard/events{/privacy}", "received_events_url": "https://api.github.com/users/ebarnard/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b7baa53c91d7c33b925fc8aec553e3521548a07", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b7baa53c91d7c33b925fc8aec553e3521548a07", "html_url": "https://github.com/rust-lang/rust/commit/5b7baa53c91d7c33b925fc8aec553e3521548a07"}], "stats": {"total": 92, "additions": 71, "deletions": 21}, "files": [{"sha": "991b45fd4a2ec2caf03b10b4d49237967226c7f2", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0fd446ea78504132add1acff3d0a626467337a2c/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fd446ea78504132add1acff3d0a626467337a2c/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=0fd446ea78504132add1acff3d0a626467337a2c", "patch": "@@ -1615,8 +1615,8 @@ pub fn rename<P: AsRef<Path>, Q: AsRef<Path>>(from: P, to: Q) -> io::Result<()>\n /// `O_CLOEXEC` is set for returned file descriptors.\n /// On Windows, this function currently corresponds to `CopyFileEx`. Alternate\n /// NTFS streams are copied but only the size of the main stream is returned by\n-/// this function. On MacOS, this function corresponds to `copyfile` with\n-/// `COPYFILE_ALL`.\n+/// this function. On MacOS, this function corresponds to `fclonefileat` and\n+/// `fcopyfile`.\n /// Note that, this [may change in the future][changes].\n ///\n /// [changes]: ../io/index.html#platform-specific-behavior"}, {"sha": "22c05a72a91c04289865bc57a72ef215d94a605c", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 69, "deletions": 19, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/0fd446ea78504132add1acff3d0a626467337a2c/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fd446ea78504132add1acff3d0a626467337a2c/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=0fd446ea78504132add1acff3d0a626467337a2c", "patch": "@@ -823,24 +823,28 @@ pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n     Ok(PathBuf::from(OsString::from_vec(buf)))\n }\n \n-fn open_and_set_permissions(\n-    from: &Path,\n+fn open_from(from: &Path) -> io::Result<(crate::fs::File, crate::fs::Metadata)> {\n+    use crate::fs::File;\n+\n+    let reader = File::open(from)?;\n+    let metadata = reader.metadata()?;\n+    if !metadata.is_file() {\n+        return Err(Error::new(\n+            ErrorKind::InvalidInput,\n+            \"the source path is not an existing regular file\",\n+        ));\n+    }\n+    Ok((reader, metadata))\n+}\n+\n+fn open_to_and_set_permissions(\n     to: &Path,\n-) -> io::Result<(crate::fs::File, crate::fs::File, u64, crate::fs::Metadata)> {\n-    use crate::fs::{File, OpenOptions};\n+    reader_metadata: crate::fs::Metadata,\n+) -> io::Result<(crate::fs::File, crate::fs::Metadata)> {\n+    use crate::fs::OpenOptions;\n     use crate::os::unix::fs::{OpenOptionsExt, PermissionsExt};\n \n-    let reader = File::open(from)?;\n-    let (perm, len) = {\n-        let metadata = reader.metadata()?;\n-        if !metadata.is_file() {\n-            return Err(Error::new(\n-                ErrorKind::InvalidInput,\n-                \"the source path is not an existing regular file\",\n-            ));\n-        }\n-        (metadata.permissions(), metadata.len())\n-    };\n+    let perm = reader_metadata.permissions();\n     let writer = OpenOptions::new()\n         // create the file with the correct mode right away\n         .mode(perm.mode())\n@@ -855,15 +859,16 @@ fn open_and_set_permissions(\n         // pipes/FIFOs or device nodes.\n         writer.set_permissions(perm)?;\n     }\n-    Ok((reader, writer, len, writer_metadata))\n+    Ok((writer, writer_metadata))\n }\n \n #[cfg(not(any(target_os = \"linux\",\n               target_os = \"android\",\n               target_os = \"macos\",\n               target_os = \"ios\")))]\n pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n-    let (mut reader, mut writer, _, _) = open_and_set_permissions(from, to)?;\n+    let (mut reader, reader_metadata) = open_from(from)?;\n+    let (mut writer, _) = open_to_and_set_permissions(to, reader_metadata)?;\n \n     io::copy(&mut reader, &mut writer)\n }\n@@ -896,7 +901,9 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n         )\n     }\n \n-    let (mut reader, mut writer, len, _) = open_and_set_permissions(from, to)?;\n+    let (mut reader, reader_metadata) = open_from(from)?;\n+    let len = reader_metadata.len();\n+    let (mut writer, _) = open_to_and_set_permissions(to, reader_metadata)?;\n \n     let has_copy_file_range = HAS_COPY_FILE_RANGE.load(Ordering::Relaxed);\n     let mut written = 0u64;\n@@ -955,6 +962,8 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n \n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n+    use crate::sync::atomic::{AtomicBool, Ordering};\n+\n     const COPYFILE_ACL: u32 = 1 << 0;\n     const COPYFILE_STAT: u32 = 1 << 1;\n     const COPYFILE_XATTR: u32 = 1 << 2;\n@@ -1000,7 +1009,48 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n         }\n     }\n \n-    let (reader, writer, _, writer_metadata) = open_and_set_permissions(from, to)?;\n+    // MacOS prior to 10.12 don't support `fclonefileat`\n+    // We store the availability in a global to avoid unnecessary syscalls\n+    static HAS_FCLONEFILEAT: AtomicBool = AtomicBool::new(true);\n+    syscall! {\n+        fn fclonefileat(\n+            srcfd: libc::c_int,\n+            dst_dirfd: libc::c_int,\n+            dst: *const libc::c_char,\n+            flags: libc::c_int\n+        ) -> libc::c_int\n+    }\n+\n+    let (reader, reader_metadata) = open_from(from)?;\n+\n+    // Opportunistically attempt to create a copy-on-write clone of `from`\n+    // using `fclonefileat`.\n+    if HAS_FCLONEFILEAT.load(Ordering::Relaxed) {\n+        let to = cstr(to)?;\n+        let clonefile_result = cvt(unsafe {\n+            fclonefileat(\n+                reader.as_raw_fd(),\n+                libc::AT_FDCWD,\n+                to.as_ptr(),\n+                0,\n+            )\n+        });\n+        match clonefile_result {\n+            Ok(_) => return Ok(reader_metadata.len()),\n+            Err(err) => match err.raw_os_error() {\n+                // `fclonefileat` will fail on non-APFS volumes, if the\n+                // destination already exists, or if the source and destination\n+                // are on different devices. In all these cases `fcopyfile`\n+                // should succeed.\n+                Some(libc::ENOTSUP) | Some(libc::EEXIST) | Some(libc::EXDEV) => (),\n+                Some(libc::ENOSYS) => HAS_FCLONEFILEAT.store(false, Ordering::Relaxed),\n+                _ => return Err(err),\n+            }\n+        }\n+    }\n+\n+    // Fall back to using `fcopyfile` if `fclonefileat` does not succeed.\n+    let (writer, writer_metadata) = open_to_and_set_permissions(to, reader_metadata)?;\n \n     // We ensure that `FreeOnDrop` never contains a null pointer so it is\n     // always safe to call `copyfile_state_free`"}]}