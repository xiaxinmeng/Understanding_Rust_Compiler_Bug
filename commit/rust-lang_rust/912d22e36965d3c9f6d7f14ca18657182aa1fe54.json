{"sha": "912d22e36965d3c9f6d7f14ca18657182aa1fe54", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxMmQyMmUzNjk2NWQzYzlmNmQ3ZjE0Y2ExODY1NzE4MmFhMWZlNTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-11T08:15:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-06-11T08:15:12Z"}, "message": "Auto merge of #61673 - RalfJung:miri-no-hard-float, r=eddyb,oli-obk\n\nMiri: convert to/from apfloat instead of host floats\n\nCc @oli-obk @eddyb", "tree": {"sha": "3f434240e7a09d49bcd6b88b084ddea93b71da6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f434240e7a09d49bcd6b88b084ddea93b71da6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/912d22e36965d3c9f6d7f14ca18657182aa1fe54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/912d22e36965d3c9f6d7f14ca18657182aa1fe54", "html_url": "https://github.com/rust-lang/rust/commit/912d22e36965d3c9f6d7f14ca18657182aa1fe54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/912d22e36965d3c9f6d7f14ca18657182aa1fe54/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d9c7ad323f95612d933106d65e3057ca9a0434f", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d9c7ad323f95612d933106d65e3057ca9a0434f", "html_url": "https://github.com/rust-lang/rust/commit/9d9c7ad323f95612d933106d65e3057ca9a0434f"}, {"sha": "8dfc8db235e205c60b56e0753996399a6f66f3e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/8dfc8db235e205c60b56e0753996399a6f66f3e1", "html_url": "https://github.com/rust-lang/rust/commit/8dfc8db235e205c60b56e0753996399a6f66f3e1"}], "stats": {"total": 278, "additions": 154, "deletions": 124}, "files": [{"sha": "23c37676f3659e57a2b684a404ab22eb5700a9ec", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 49, "deletions": 10, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/912d22e36965d3c9f6d7f14ca18657182aa1fe54/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/912d22e36965d3c9f6d7f14ca18657182aa1fe54/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=912d22e36965d3c9f6d7f14ca18657182aa1fe54", "patch": "@@ -1,5 +1,6 @@\n use std::fmt;\n use rustc_macros::HashStable;\n+use rustc_apfloat::{Float, ieee::{Double, Single}};\n \n use crate::ty::{Ty, InferConst, ParamConst, layout::{HasDataLayout, Size}, subst::SubstsRef};\n use crate::ty::PlaceholderConst;\n@@ -131,6 +132,20 @@ impl<Tag> fmt::Display for Scalar<Tag> {\n     }\n }\n \n+impl<Tag> From<Single> for Scalar<Tag> {\n+    #[inline(always)]\n+    fn from(f: Single) -> Self {\n+        Scalar::from_f32(f)\n+    }\n+}\n+\n+impl<Tag> From<Double> for Scalar<Tag> {\n+    #[inline(always)]\n+    fn from(f: Double) -> Self {\n+        Scalar::from_f64(f)\n+    }\n+}\n+\n impl<'tcx> Scalar<()> {\n     #[inline(always)]\n     fn check_data(data: u128, size: u8) {\n@@ -279,6 +294,26 @@ impl<'tcx, Tag> Scalar<Tag> {\n         Scalar::Raw { data: i, size: size.bytes() as u8 }\n     }\n \n+    #[inline]\n+    pub fn from_u8(i: u8) -> Self {\n+        Scalar::Raw { data: i as u128, size: 1 }\n+    }\n+\n+    #[inline]\n+    pub fn from_u16(i: u16) -> Self {\n+        Scalar::Raw { data: i as u128, size: 2 }\n+    }\n+\n+    #[inline]\n+    pub fn from_u32(i: u32) -> Self {\n+        Scalar::Raw { data: i as u128, size: 4 }\n+    }\n+\n+    #[inline]\n+    pub fn from_u64(i: u64) -> Self {\n+        Scalar::Raw { data: i as u128, size: 8 }\n+    }\n+\n     #[inline]\n     pub fn from_int(i: impl Into<i128>, size: Size) -> Self {\n         let i = i.into();\n@@ -292,13 +327,15 @@ impl<'tcx, Tag> Scalar<Tag> {\n     }\n \n     #[inline]\n-    pub fn from_f32(f: f32) -> Self {\n-        Scalar::Raw { data: f.to_bits() as u128, size: 4 }\n+    pub fn from_f32(f: Single) -> Self {\n+        // We trust apfloat to give us properly truncated data.\n+        Scalar::Raw { data: f.to_bits(), size: 4 }\n     }\n \n     #[inline]\n-    pub fn from_f64(f: f64) -> Self {\n-        Scalar::Raw { data: f.to_bits() as u128, size: 8 }\n+    pub fn from_f64(f: Double) -> Self {\n+        // We trust apfloat to give us properly truncated data.\n+        Scalar::Raw { data: f.to_bits(), size: 8 }\n     }\n \n     #[inline]\n@@ -427,13 +464,15 @@ impl<'tcx, Tag> Scalar<Tag> {\n     }\n \n     #[inline]\n-    pub fn to_f32(self) -> InterpResult<'static, f32> {\n-        Ok(f32::from_bits(self.to_u32()?))\n+    pub fn to_f32(self) -> InterpResult<'static, Single> {\n+        // Going through `u32` to check size and truncation.\n+        Ok(Single::from_bits(self.to_u32()? as u128))\n     }\n \n     #[inline]\n-    pub fn to_f64(self) -> InterpResult<'static, f64> {\n-        Ok(f64::from_bits(self.to_u64()?))\n+    pub fn to_f64(self) -> InterpResult<'static, Double> {\n+        // Going through `u64` to check size and truncation.\n+        Ok(Double::from_bits(self.to_u64()? as u128))\n     }\n }\n \n@@ -517,12 +556,12 @@ impl<'tcx, Tag> ScalarMaybeUndef<Tag> {\n     }\n \n     #[inline(always)]\n-    pub fn to_f32(self) -> InterpResult<'tcx, f32> {\n+    pub fn to_f32(self) -> InterpResult<'tcx, Single> {\n         self.not_undef()?.to_f32()\n     }\n \n     #[inline(always)]\n-    pub fn to_f64(self) -> InterpResult<'tcx, f64> {\n+    pub fn to_f64(self) -> InterpResult<'tcx, Double> {\n         self.not_undef()?.to_f64()\n     }\n "}, {"sha": "5cc46b21fca1f1bf27de4e57f469d89b0ee6709b", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/912d22e36965d3c9f6d7f14ca18657182aa1fe54/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/912d22e36965d3c9f6d7f14ca18657182aa1fe54/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=912d22e36965d3c9f6d7f14ca18657182aa1fe54", "patch": "@@ -2035,6 +2035,14 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n+    #[inline]\n+    pub fn is_fn_ptr(&self) -> bool {\n+        match self.sty {\n+            FnPtr(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n     pub fn is_impl_trait(&self) -> bool {\n         match self.sty {\n             Opaque(..) => true,"}, {"sha": "37a2e79dae91ff62d89ff94efebcf2648d1c266c", "filename": "src/librustc_mir/hair/constant.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/912d22e36965d3c9f6d7f14ca18657182aa1fe54/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/912d22e36965d3c9f6d7f14ca18657182aa1fe54/src%2Flibrustc_mir%2Fhair%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fconstant.rs?ref=912d22e36965d3c9f6d7f14ca18657182aa1fe54", "patch": "@@ -69,8 +69,7 @@ fn parse_float<'tcx>(\n ) -> Result<ConstValue<'tcx>, ()> {\n     let num = num.as_str();\n     use rustc_apfloat::ieee::{Single, Double};\n-    use rustc_apfloat::Float;\n-    let (data, size) = match fty {\n+    let scalar = match fty {\n         ast::FloatTy::F32 => {\n             num.parse::<f32>().map_err(|_| ())?;\n             let mut f = num.parse::<Single>().unwrap_or_else(|e| {\n@@ -79,19 +78,19 @@ fn parse_float<'tcx>(\n             if neg {\n                 f = -f;\n             }\n-            (f.to_bits(), 4)\n+            Scalar::from_f32(f)\n         }\n         ast::FloatTy::F64 => {\n             num.parse::<f64>().map_err(|_| ())?;\n             let mut f = num.parse::<Double>().unwrap_or_else(|e| {\n-                panic!(\"apfloat::ieee::Single failed to parse `{}`: {:?}\", num, e)\n+                panic!(\"apfloat::ieee::Double failed to parse `{}`: {:?}\", num, e)\n             });\n             if neg {\n                 f = -f;\n             }\n-            (f.to_bits(), 8)\n+            Scalar::from_f64(f)\n         }\n     };\n \n-    Ok(ConstValue::Scalar(Scalar::from_uint(data, Size::from_bytes(size))))\n+    Ok(ConstValue::Scalar(scalar))\n }"}, {"sha": "6392e0996aec233eaec48a8a645df8fe2de22cb8", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 45, "deletions": 52, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/912d22e36965d3c9f6d7f14ca18657182aa1fe54/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/912d22e36965d3c9f6d7f14ca18657182aa1fe54/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=912d22e36965d3c9f6d7f14ca18657182aa1fe54", "patch": "@@ -5,11 +5,11 @@ use syntax::ast::{FloatTy, IntTy, UintTy};\n use syntax::symbol::sym;\n \n use rustc_apfloat::ieee::{Single, Double};\n+use rustc_apfloat::{Float, FloatConvert};\n use rustc::mir::interpret::{\n     Scalar, InterpResult, Pointer, PointerArithmetic, InterpError,\n };\n use rustc::mir::CastKind;\n-use rustc_apfloat::Float;\n \n use super::{InterpretCx, Machine, PlaceTy, OpTy, Immediate};\n \n@@ -126,7 +126,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         Ok(())\n     }\n \n-    pub(super) fn cast_scalar(\n+    fn cast_scalar(\n         &self,\n         val: Scalar<M::PointerTag>,\n         src_layout: TyLayout<'tcx>,\n@@ -135,23 +135,36 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         use rustc::ty::TyKind::*;\n         trace!(\"Casting {:?}: {:?} to {:?}\", val, src_layout.ty, dest_layout.ty);\n \n-        match val.to_bits_or_ptr(src_layout.size, self) {\n-            Err(ptr) => self.cast_from_ptr(ptr, dest_layout.ty),\n-            Ok(data) => {\n-                match src_layout.ty.sty {\n-                    Float(fty) => self.cast_from_float(data, fty, dest_layout.ty),\n-                    _ => self.cast_from_int(data, src_layout, dest_layout),\n+        match src_layout.ty.sty {\n+            // Floating point\n+            Float(FloatTy::F32) => self.cast_from_float(val.to_f32()?, dest_layout.ty),\n+            Float(FloatTy::F64) => self.cast_from_float(val.to_f64()?, dest_layout.ty),\n+            // Integer(-like), including fn ptr casts and casts from enums that\n+            // are represented as integers (this excludes univariant enums, which\n+            // are handled in `cast` directly).\n+            _ => {\n+                assert!(\n+                    src_layout.ty.is_bool()       || src_layout.ty.is_char()     ||\n+                    src_layout.ty.is_enum()       || src_layout.ty.is_integral() ||\n+                    src_layout.ty.is_unsafe_ptr() || src_layout.ty.is_fn_ptr()   ||\n+                    src_layout.ty.is_region_ptr(),\n+                    \"Unexpected cast from type {:?}\", src_layout.ty\n+                );\n+                match val.to_bits_or_ptr(src_layout.size, self) {\n+                    Err(ptr) => self.cast_from_ptr(ptr, dest_layout.ty),\n+                    Ok(data) => self.cast_from_int(data, src_layout, dest_layout),\n                 }\n             }\n         }\n     }\n \n     fn cast_from_int(\n         &self,\n-        v: u128,\n+        v: u128, // raw bits\n         src_layout: TyLayout<'tcx>,\n         dest_layout: TyLayout<'tcx>,\n     ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n+        // Let's make sure v is sign-extended *if* it has a signed type.\n         let signed = src_layout.abi.is_signed();\n         let v = if signed {\n             self.sign_extend(v, src_layout)\n@@ -166,21 +179,17 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                 Ok(Scalar::from_uint(v, dest_layout.size))\n             }\n \n-            Float(FloatTy::F32) if signed => Ok(Scalar::from_uint(\n-                Single::from_i128(v as i128).value.to_bits(),\n-                Size::from_bits(32)\n+            Float(FloatTy::F32) if signed => Ok(Scalar::from_f32(\n+                Single::from_i128(v as i128).value\n             )),\n-            Float(FloatTy::F64) if signed => Ok(Scalar::from_uint(\n-                Double::from_i128(v as i128).value.to_bits(),\n-                Size::from_bits(64)\n+            Float(FloatTy::F64) if signed => Ok(Scalar::from_f64(\n+                Double::from_i128(v as i128).value\n             )),\n-            Float(FloatTy::F32) => Ok(Scalar::from_uint(\n-                Single::from_u128(v).value.to_bits(),\n-                Size::from_bits(32)\n+            Float(FloatTy::F32) => Ok(Scalar::from_f32(\n+                Single::from_u128(v).value\n             )),\n-            Float(FloatTy::F64) => Ok(Scalar::from_uint(\n-                Double::from_u128(v).value.to_bits(),\n-                Size::from_bits(64)\n+            Float(FloatTy::F64) => Ok(Scalar::from_f64(\n+                Double::from_u128(v).value\n             )),\n \n             Char => {\n@@ -194,52 +203,36 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         }\n     }\n \n-    fn cast_from_float(\n+    fn cast_from_float<F>(\n         &self,\n-        bits: u128,\n-        fty: FloatTy,\n+        f: F,\n         dest_ty: Ty<'tcx>\n-    ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n+    ) -> InterpResult<'tcx, Scalar<M::PointerTag>>\n+    where F: Float + Into<Scalar<M::PointerTag>> + FloatConvert<Single> + FloatConvert<Double>\n+    {\n         use rustc::ty::TyKind::*;\n-        use rustc_apfloat::FloatConvert;\n         match dest_ty.sty {\n             // float -> uint\n             Uint(t) => {\n                 let width = t.bit_width().unwrap_or_else(|| self.pointer_size().bits() as usize);\n-                let v = match fty {\n-                    FloatTy::F32 => Single::from_bits(bits).to_u128(width).value,\n-                    FloatTy::F64 => Double::from_bits(bits).to_u128(width).value,\n-                };\n+                let v = f.to_u128(width).value;\n                 // This should already fit the bit width\n                 Ok(Scalar::from_uint(v, Size::from_bits(width as u64)))\n             },\n             // float -> int\n             Int(t) => {\n                 let width = t.bit_width().unwrap_or_else(|| self.pointer_size().bits() as usize);\n-                let v = match fty {\n-                    FloatTy::F32 => Single::from_bits(bits).to_i128(width).value,\n-                    FloatTy::F64 => Double::from_bits(bits).to_i128(width).value,\n-                };\n+                let v = f.to_i128(width).value;\n                 Ok(Scalar::from_int(v, Size::from_bits(width as u64)))\n             },\n-            // f64 -> f32\n-            Float(FloatTy::F32) if fty == FloatTy::F64 => {\n-                Ok(Scalar::from_uint(\n-                    Single::to_bits(Double::from_bits(bits).convert(&mut false).value),\n-                    Size::from_bits(32),\n-                ))\n-            },\n-            // f32 -> f64\n-            Float(FloatTy::F64) if fty == FloatTy::F32 => {\n-                Ok(Scalar::from_uint(\n-                    Double::to_bits(Single::from_bits(bits).convert(&mut false).value),\n-                    Size::from_bits(64),\n-                ))\n-            },\n-            // identity cast\n-            Float(FloatTy:: F64) => Ok(Scalar::from_uint(bits, Size::from_bits(64))),\n-            Float(FloatTy:: F32) => Ok(Scalar::from_uint(bits, Size::from_bits(32))),\n-            _ => err!(Unimplemented(format!(\"float to {:?} cast\", dest_ty))),\n+            // float -> f32\n+            Float(FloatTy::F32) =>\n+                Ok(Scalar::from_f32(f.convert(&mut false).value)),\n+            // float -> f64\n+            Float(FloatTy::F64) =>\n+                Ok(Scalar::from_f64(f.convert(&mut false).value)),\n+            // That's it.\n+            _ => bug!(\"invalid float to {:?} cast\", dest_ty),\n         }\n     }\n "}, {"sha": "db7da9359de7b7762bfc153120bdce4bd56dc699", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 47, "deletions": 56, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/912d22e36965d3c9f6d7f14ca18657182aa1fe54/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/912d22e36965d3c9f6d7f14ca18657182aa1fe54/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=912d22e36965d3c9f6d7f14ca18657182aa1fe54", "patch": "@@ -1,7 +1,6 @@\n use rustc::mir;\n-use rustc::ty::{self, layout::{Size, TyLayout}};\n+use rustc::ty::{self, layout::TyLayout};\n use syntax::ast::FloatTy;\n-use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n use rustc::mir::interpret::{InterpResult, Scalar};\n \n@@ -43,7 +42,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         bin_op: mir::BinOp,\n         l: char,\n         r: char,\n-    ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n+    ) -> (Scalar<M::PointerTag>, bool) {\n         use rustc::mir::BinOp::*;\n \n         let res = match bin_op {\n@@ -55,15 +54,15 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n             Ge => l >= r,\n             _ => bug!(\"Invalid operation on char: {:?}\", bin_op),\n         };\n-        return Ok((Scalar::from_bool(res), false));\n+        return (Scalar::from_bool(res), false);\n     }\n \n     fn binary_bool_op(\n         &self,\n         bin_op: mir::BinOp,\n         l: bool,\n         r: bool,\n-    ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n+    ) -> (Scalar<M::PointerTag>, bool) {\n         use rustc::mir::BinOp::*;\n \n         let res = match bin_op {\n@@ -78,46 +77,32 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n             BitXor => l ^ r,\n             _ => bug!(\"Invalid operation on bool: {:?}\", bin_op),\n         };\n-        return Ok((Scalar::from_bool(res), false));\n+        return (Scalar::from_bool(res), false);\n     }\n \n-    fn binary_float_op(\n+    fn binary_float_op<F: Float + Into<Scalar<M::PointerTag>>>(\n         &self,\n         bin_op: mir::BinOp,\n-        fty: FloatTy,\n-        // passing in raw bits\n-        l: u128,\n-        r: u128,\n-    ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n+        l: F,\n+        r: F,\n+    ) -> (Scalar<M::PointerTag>, bool) {\n         use rustc::mir::BinOp::*;\n \n-        macro_rules! float_math {\n-            ($ty:path, $size:expr) => {{\n-                let l = <$ty>::from_bits(l);\n-                let r = <$ty>::from_bits(r);\n-                let bitify = |res: ::rustc_apfloat::StatusAnd<$ty>|\n-                    Scalar::from_uint(res.value.to_bits(), Size::from_bytes($size));\n-                let val = match bin_op {\n-                    Eq => Scalar::from_bool(l == r),\n-                    Ne => Scalar::from_bool(l != r),\n-                    Lt => Scalar::from_bool(l < r),\n-                    Le => Scalar::from_bool(l <= r),\n-                    Gt => Scalar::from_bool(l > r),\n-                    Ge => Scalar::from_bool(l >= r),\n-                    Add => bitify(l + r),\n-                    Sub => bitify(l - r),\n-                    Mul => bitify(l * r),\n-                    Div => bitify(l / r),\n-                    Rem => bitify(l % r),\n-                    _ => bug!(\"invalid float op: `{:?}`\", bin_op),\n-                };\n-                return Ok((val, false));\n-            }};\n-        }\n-        match fty {\n-            FloatTy::F32 => float_math!(Single, 4),\n-            FloatTy::F64 => float_math!(Double, 8),\n-        }\n+        let val = match bin_op {\n+            Eq => Scalar::from_bool(l == r),\n+            Ne => Scalar::from_bool(l != r),\n+            Lt => Scalar::from_bool(l < r),\n+            Le => Scalar::from_bool(l <= r),\n+            Gt => Scalar::from_bool(l > r),\n+            Ge => Scalar::from_bool(l >= r),\n+            Add => (l + r).value.into(),\n+            Sub => (l - r).value.into(),\n+            Mul => (l * r).value.into(),\n+            Div => (l / r).value.into(),\n+            Rem => (l % r).value.into(),\n+            _ => bug!(\"invalid float op: `{:?}`\", bin_op),\n+        };\n+        return (val, false);\n     }\n \n     fn binary_int_op(\n@@ -286,28 +271,35 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n         match left.layout.ty.sty {\n             ty::Char => {\n                 assert_eq!(left.layout.ty, right.layout.ty);\n-                let left = left.to_scalar()?.to_char()?;\n-                let right = right.to_scalar()?.to_char()?;\n-                self.binary_char_op(bin_op, left, right)\n+                let left = left.to_scalar()?;\n+                let right = right.to_scalar()?;\n+                Ok(self.binary_char_op(bin_op, left.to_char()?, right.to_char()?))\n             }\n             ty::Bool => {\n                 assert_eq!(left.layout.ty, right.layout.ty);\n-                let left = left.to_scalar()?.to_bool()?;\n-                let right = right.to_scalar()?.to_bool()?;\n-                self.binary_bool_op(bin_op, left, right)\n+                let left = left.to_scalar()?;\n+                let right = right.to_scalar()?;\n+                Ok(self.binary_bool_op(bin_op, left.to_bool()?, right.to_bool()?))\n             }\n             ty::Float(fty) => {\n                 assert_eq!(left.layout.ty, right.layout.ty);\n-                let left = left.to_bits()?;\n-                let right = right.to_bits()?;\n-                self.binary_float_op(bin_op, fty, left, right)\n+                let left = left.to_scalar()?;\n+                let right = right.to_scalar()?;\n+                Ok(match fty {\n+                    FloatTy::F32 => self.binary_float_op(bin_op, left.to_f32()?, right.to_f32()?),\n+                    FloatTy::F64 => self.binary_float_op(bin_op, left.to_f64()?, right.to_f64()?),\n+                })\n             }\n             _ => {\n                 // Must be integer(-like) types.  Don't forget about == on fn pointers.\n-                assert!(left.layout.ty.is_integral() || left.layout.ty.is_unsafe_ptr() ||\n-                    left.layout.ty.is_fn());\n-                assert!(right.layout.ty.is_integral() || right.layout.ty.is_unsafe_ptr() ||\n-                    right.layout.ty.is_fn());\n+                assert!(\n+                    left.layout.ty.is_integral()   ||\n+                    left.layout.ty.is_unsafe_ptr() || left.layout.ty.is_fn_ptr(),\n+                    \"Unexpected LHS type {:?} for BinOp {:?}\", left.layout.ty, bin_op);\n+                assert!(\n+                    right.layout.ty.is_integral()   ||\n+                    right.layout.ty.is_unsafe_ptr() || right.layout.ty.is_fn_ptr(),\n+                    \"Unexpected RHS type {:?} for BinOp {:?}\", right.layout.ty, bin_op);\n \n                 // Handle operations that support pointer values\n                 if left.to_scalar_ptr()?.is_ptr() ||\n@@ -346,13 +338,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M>\n                 Ok(Scalar::from_bool(res))\n             }\n             ty::Float(fty) => {\n-                let val = val.to_bits(layout.size)?;\n                 let res = match (un_op, fty) {\n-                    (Neg, FloatTy::F32) => Single::to_bits(-Single::from_bits(val)),\n-                    (Neg, FloatTy::F64) => Double::to_bits(-Double::from_bits(val)),\n+                    (Neg, FloatTy::F32) => Scalar::from_f32(-val.to_f32()?),\n+                    (Neg, FloatTy::F64) => Scalar::from_f64(-val.to_f64()?),\n                     _ => bug!(\"Invalid float op {:?}\", un_op)\n                 };\n-                Ok(Scalar::from_uint(res, layout.size))\n+                Ok(res)\n             }\n             _ => {\n                 assert!(layout.ty.is_integral());"}]}