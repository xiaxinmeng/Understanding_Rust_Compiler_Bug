{"sha": "4820a9e790c4c41c7ffe1892ec576f7fd321e788", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4MjBhOWU3OTBjNGM0MWM3ZmZlMTg5MmVjNTc2ZjdmZDMyMWU3ODg=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-01-14T10:30:24Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-14T10:30:24Z"}, "message": "Merge #2836\n\n2836: Move utility functions down r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "ef22688ef7d1486ac4f084ead6bcb7e69d520b65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef22688ef7d1486ac4f084ead6bcb7e69d520b65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4820a9e790c4c41c7ffe1892ec576f7fd321e788", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeHZhACRBK7hj4Ov3rIwAAdHIIAED3Pwc8DQZKHMke6Ld1W+JT\n262fKi55DnYQNBptCnNdqBp3cStWzh0Wwyn9LrBvD27bvscPrVBh8DhH1t6/Rx7o\nKCkBjtezwBNaVG/RyP76Im5NkD5Q73FaeBp9wYykrS2Tubxw95zjwKnzvWzY4WEK\n8oQvhDjlBOC6HagbYe4NAK4JjA/ZtXHdqxpVenEMLD367/d+NV91Ks3sTHHeQ/kx\n+GjOCfo1/UVPHK3rmC6ACjWbpr8FoOkGwk9aGx2ENEzeZeTrMtt0fZoM+VgJvmy7\ndvd5Ua1ZcLx/k7Z0khYsV88P+rLCfsBxYstIkS9hxc2zPecls33kGT+z5vBTllg=\n=Eo2V\n-----END PGP SIGNATURE-----\n", "payload": "tree ef22688ef7d1486ac4f084ead6bcb7e69d520b65\nparent 254650ff82d2e592e992cade4c9183c326fcf974\nparent 52e7f67128fdaf604e4563eb6445fdd69d42c91e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1578997824 +0000\ncommitter GitHub <noreply@github.com> 1578997824 +0000\n\nMerge #2836\n\n2836: Move utility functions down r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4820a9e790c4c41c7ffe1892ec576f7fd321e788", "html_url": "https://github.com/rust-lang/rust/commit/4820a9e790c4c41c7ffe1892ec576f7fd321e788", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4820a9e790c4c41c7ffe1892ec576f7fd321e788/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "254650ff82d2e592e992cade4c9183c326fcf974", "url": "https://api.github.com/repos/rust-lang/rust/commits/254650ff82d2e592e992cade4c9183c326fcf974", "html_url": "https://github.com/rust-lang/rust/commit/254650ff82d2e592e992cade4c9183c326fcf974"}, {"sha": "52e7f67128fdaf604e4563eb6445fdd69d42c91e", "url": "https://api.github.com/repos/rust-lang/rust/commits/52e7f67128fdaf604e4563eb6445fdd69d42c91e", "html_url": "https://github.com/rust-lang/rust/commit/52e7f67128fdaf604e4563eb6445fdd69d42c91e"}], "stats": {"total": 171, "additions": 82, "deletions": 89}, "files": [{"sha": "3461183506584d1fda3d951142ac35b0d8e97c0e", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4820a9e790c4c41c7ffe1892ec576f7fd321e788/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4820a9e790c4c41c7ffe1892ec576f7fd321e788/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=4820a9e790c4c41c7ffe1892ec576f7fd321e788", "patch": "@@ -21,8 +21,8 @@ use hir_expand::{\n     MacroDefId,\n };\n use hir_ty::{\n-    autoderef, display::HirFormatter, expr::ExprValidator, ApplicationTy, Canonical, InEnvironment,\n-    TraitEnvironment, Ty, TyDefId, TypeCtor, TypeWalk,\n+    autoderef, display::HirFormatter, expr::ExprValidator, method_resolution::implements_trait,\n+    ApplicationTy, Canonical, InEnvironment, TraitEnvironment, Ty, TyDefId, TypeCtor, TypeWalk,\n };\n use ra_db::{CrateId, Edition, FileId};\n use ra_prof::profile;\n@@ -878,6 +878,22 @@ impl Type {\n         }\n     }\n \n+    /// Checks that particular type `ty` implements `std::future::Future`.\n+    /// This function is used in `.await` syntax completion.\n+    pub fn impls_future(&self, db: &impl HirDatabase) -> bool {\n+        let krate = self.krate;\n+\n+        let std_future_trait =\n+            db.lang_item(krate, \"future_trait\".into()).and_then(|it| it.as_trait());\n+        let std_future_trait = match std_future_trait {\n+            Some(it) => it,\n+            None => return false,\n+        };\n+\n+        let canonical_ty = Canonical { value: self.ty.value.clone(), num_vars: 0 };\n+        implements_trait(&canonical_ty, db, self.ty.environment.clone(), krate, std_future_trait)\n+    }\n+\n     // FIXME: this method is broken, as it doesn't take closures into account.\n     pub fn as_callable(&self) -> Option<CallableDef> {\n         Some(self.ty.value.as_callable()?.0)"}, {"sha": "a1cf89010fda4eb89c6958b823264d8d470409e3", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4820a9e790c4c41c7ffe1892ec576f7fd321e788/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4820a9e790c4c41c7ffe1892ec576f7fd321e788/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=4820a9e790c4c41c7ffe1892ec576f7fd321e788", "patch": "@@ -27,7 +27,7 @@ macro_rules! impl_froms {\n }\n \n pub mod db;\n-pub mod source_binder;\n+pub mod source_analyzer;\n \n pub mod diagnostics;\n \n@@ -46,7 +46,7 @@ pub use crate::{\n     },\n     from_source::FromSource,\n     has_source::HasSource,\n-    source_binder::{PathResolution, ScopeEntryWithSyntax, SourceAnalyzer},\n+    source_analyzer::{PathResolution, ScopeEntryWithSyntax, SourceAnalyzer},\n };\n \n pub use hir_def::{"}, {"sha": "3df48842d3b121b75df45b634d571913b0dadf67", "filename": "crates/ra_hir/src/source_analyzer.rs", "status": "renamed", "additions": 59, "deletions": 82, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/4820a9e790c4c41c7ffe1892ec576f7fd321e788/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4820a9e790c4c41c7ffe1892ec576f7fd321e788/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs?ref=4820a9e790c4c41c7ffe1892ec576f7fd321e788", "patch": "@@ -15,17 +15,13 @@ use hir_def::{\n     },\n     expr::{ExprId, PatId},\n     nameres::ModuleSource,\n-    path::path,\n     resolver::{self, resolver_for_scope, HasResolver, Resolver, TypeNs, ValueNs},\n     AssocItemId, DefWithBodyId,\n };\n use hir_expand::{\n     hygiene::Hygiene, name::AsName, AstId, HirFileId, InFile, MacroCallId, MacroCallKind,\n };\n-use hir_ty::{\n-    method_resolution::{self, implements_trait},\n-    Canonical, InEnvironment, InferenceResult, TraitEnvironment, Ty,\n-};\n+use hir_ty::{method_resolution, Canonical, InEnvironment, InferenceResult, TraitEnvironment, Ty};\n use ra_prof::profile;\n use ra_syntax::{\n     ast::{self, AstNode},\n@@ -40,64 +36,6 @@ use crate::{\n     TypeParam,\n };\n \n-fn try_get_resolver_for_node(db: &impl HirDatabase, node: InFile<&SyntaxNode>) -> Option<Resolver> {\n-    match_ast! {\n-        match (node.value) {\n-            ast::Module(it) => {\n-                let src = node.with_value(it);\n-                Some(crate::Module::from_declaration(db, src)?.id.resolver(db))\n-            },\n-             ast::SourceFile(it) => {\n-                let src = node.with_value(ModuleSource::SourceFile(it));\n-                Some(crate::Module::from_definition(db, src)?.id.resolver(db))\n-            },\n-            ast::StructDef(it) => {\n-                let src = node.with_value(it);\n-                Some(Struct::from_source(db, src)?.id.resolver(db))\n-            },\n-            ast::EnumDef(it) => {\n-                let src = node.with_value(it);\n-                Some(Enum::from_source(db, src)?.id.resolver(db))\n-            },\n-            ast::ImplBlock(it) => {\n-                let src = node.with_value(it);\n-                Some(ImplBlock::from_source(db, src)?.id.resolver(db))\n-            },\n-            ast::TraitDef(it) => {\n-                let src = node.with_value(it);\n-                Some(Trait::from_source(db, src)?.id.resolver(db))\n-            },\n-            _ => match node.value.kind() {\n-                FN_DEF | CONST_DEF | STATIC_DEF => {\n-                    let def = def_with_body_from_child_node(db, node)?;\n-                    let def = DefWithBodyId::from(def);\n-                    Some(def.resolver(db))\n-                }\n-                // FIXME add missing cases\n-                _ => None\n-            }\n-        }\n-    }\n-}\n-\n-fn def_with_body_from_child_node(\n-    db: &impl HirDatabase,\n-    child: InFile<&SyntaxNode>,\n-) -> Option<DefWithBody> {\n-    let _p = profile(\"def_with_body_from_child_node\");\n-    child.cloned().ancestors_with_macros(db).find_map(|node| {\n-        let n = &node.value;\n-        match_ast! {\n-            match n {\n-                ast::FnDef(def)  => { return Function::from_source(db, node.with_value(def)).map(DefWithBody::from); },\n-                ast::ConstDef(def) => { return Const::from_source(db, node.with_value(def)).map(DefWithBody::from); },\n-                ast::StaticDef(def) => { return Static::from_source(db, node.with_value(def)).map(DefWithBody::from); },\n-                _ => { None },\n-            }\n-        }\n-    })\n-}\n-\n /// `SourceAnalyzer` is a convenience wrapper which exposes HIR API in terms of\n /// original source files. It should not be used inside the HIR itself.\n #[derive(Debug)]\n@@ -454,25 +392,6 @@ impl SourceAnalyzer {\n         )\n     }\n \n-    /// Checks that particular type `ty` implements `std::future::Future`.\n-    /// This function is used in `.await` syntax completion.\n-    pub fn impls_future(&self, db: &impl HirDatabase, ty: Type) -> bool {\n-        let std_future_path = path![std::future::Future];\n-\n-        let std_future_trait = match self.resolver.resolve_known_trait(db, &std_future_path) {\n-            Some(it) => it.into(),\n-            _ => return false,\n-        };\n-\n-        let krate = match self.resolver.krate() {\n-            Some(krate) => krate,\n-            _ => return false,\n-        };\n-\n-        let canonical_ty = Canonical { value: ty.ty.value, num_vars: 0 };\n-        implements_trait(&canonical_ty, db, &self.resolver, krate.into(), std_future_trait)\n-    }\n-\n     pub fn expand(\n         &self,\n         db: &impl HirDatabase,\n@@ -487,6 +406,64 @@ impl SourceAnalyzer {\n     }\n }\n \n+fn try_get_resolver_for_node(db: &impl HirDatabase, node: InFile<&SyntaxNode>) -> Option<Resolver> {\n+    match_ast! {\n+        match (node.value) {\n+            ast::Module(it) => {\n+                let src = node.with_value(it);\n+                Some(crate::Module::from_declaration(db, src)?.id.resolver(db))\n+            },\n+             ast::SourceFile(it) => {\n+                let src = node.with_value(ModuleSource::SourceFile(it));\n+                Some(crate::Module::from_definition(db, src)?.id.resolver(db))\n+            },\n+            ast::StructDef(it) => {\n+                let src = node.with_value(it);\n+                Some(Struct::from_source(db, src)?.id.resolver(db))\n+            },\n+            ast::EnumDef(it) => {\n+                let src = node.with_value(it);\n+                Some(Enum::from_source(db, src)?.id.resolver(db))\n+            },\n+            ast::ImplBlock(it) => {\n+                let src = node.with_value(it);\n+                Some(ImplBlock::from_source(db, src)?.id.resolver(db))\n+            },\n+            ast::TraitDef(it) => {\n+                let src = node.with_value(it);\n+                Some(Trait::from_source(db, src)?.id.resolver(db))\n+            },\n+            _ => match node.value.kind() {\n+                FN_DEF | CONST_DEF | STATIC_DEF => {\n+                    let def = def_with_body_from_child_node(db, node)?;\n+                    let def = DefWithBodyId::from(def);\n+                    Some(def.resolver(db))\n+                }\n+                // FIXME add missing cases\n+                _ => None\n+            }\n+        }\n+    }\n+}\n+\n+fn def_with_body_from_child_node(\n+    db: &impl HirDatabase,\n+    child: InFile<&SyntaxNode>,\n+) -> Option<DefWithBody> {\n+    let _p = profile(\"def_with_body_from_child_node\");\n+    child.cloned().ancestors_with_macros(db).find_map(|node| {\n+        let n = &node.value;\n+        match_ast! {\n+            match n {\n+                ast::FnDef(def)  => { return Function::from_source(db, node.with_value(def)).map(DefWithBody::from); },\n+                ast::ConstDef(def) => { return Const::from_source(db, node.with_value(def)).map(DefWithBody::from); },\n+                ast::StaticDef(def) => { return Static::from_source(db, node.with_value(def)).map(DefWithBody::from); },\n+                _ => { None },\n+            }\n+        }\n+    })\n+}\n+\n fn scope_for(\n     scopes: &ExprScopes,\n     source_map: &BodySourceMap,", "previous_filename": "crates/ra_hir/src/source_binder.rs"}, {"sha": "55435e6eafe0d786c61cd2b576cdee29a2d56f0a", "filename": "crates/ra_hir_ty/src/method_resolution.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4820a9e790c4c41c7ffe1892ec576f7fd321e788/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4820a9e790c4c41c7ffe1892ec576f7fd321e788/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Fmethod_resolution.rs?ref=4820a9e790c4c41c7ffe1892ec576f7fd321e788", "patch": "@@ -465,7 +465,7 @@ fn transform_receiver_ty(\n pub fn implements_trait(\n     ty: &Canonical<Ty>,\n     db: &impl HirDatabase,\n-    resolver: &Resolver,\n+    env: Arc<TraitEnvironment>,\n     krate: CrateId,\n     trait_: TraitId,\n ) -> bool {\n@@ -474,7 +474,6 @@ pub fn implements_trait(\n         // anyway, but currently Chalk doesn't implement `dyn/impl Trait` yet\n         return true;\n     }\n-    let env = TraitEnvironment::lower(db, resolver);\n     let goal = generic_implements_goal(db, env, trait_, ty.clone());\n     let solution = db.trait_solve(krate.into(), goal);\n "}, {"sha": "9ab43644e1c98c1ac024cef7a8a4b8daa6c08aa1", "filename": "crates/ra_ide/src/completion/complete_dot.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4820a9e790c4c41c7ffe1892ec576f7fd321e788/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4820a9e790c4c41c7ffe1892ec576f7fd321e788/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=4820a9e790c4c41c7ffe1892ec576f7fd321e788", "patch": "@@ -27,7 +27,7 @@ pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n     complete_methods(acc, ctx, &receiver_ty);\n \n     // Suggest .await syntax for types that implement Future trait\n-    if ctx.analyzer.impls_future(ctx.db, receiver_ty) {\n+    if receiver_ty.impls_future(ctx.db) {\n         CompletionItem::new(CompletionKind::Keyword, ctx.source_range(), \"await\")\n             .detail(\"expr.await\")\n             .insert_text(\"await\")\n@@ -525,6 +525,7 @@ mod tests {\n \n             //- /std/lib.rs\n             pub mod future {\n+                #[lang = \"future_trait\"]\n                 pub trait Future {}\n             }\n             \"###, CompletionKind::Keyword),"}]}