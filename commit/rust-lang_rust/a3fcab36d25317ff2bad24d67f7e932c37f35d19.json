{"sha": "a3fcab36d25317ff2bad24d67f7e932c37f35d19", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzZmNhYjM2ZDI1MzE3ZmYyYmFkMjRkNjdmN2U5MzJjMzdmMzVkMTk=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-04-20T15:26:26Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-05-03T19:48:27Z"}, "message": "rustc: factor most DefId-containing variants out of Def and into DefKind.", "tree": {"sha": "3f24997e9d0e1d57bfb7912ec33f9be3743fafda", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f24997e9d0e1d57bfb7912ec33f9be3743fafda"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a3fcab36d25317ff2bad24d67f7e932c37f35d19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a3fcab36d25317ff2bad24d67f7e932c37f35d19", "html_url": "https://github.com/rust-lang/rust/commit/a3fcab36d25317ff2bad24d67f7e932c37f35d19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a3fcab36d25317ff2bad24d67f7e932c37f35d19/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "url": "https://api.github.com/repos/rust-lang/rust/commits/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd", "html_url": "https://github.com/rust-lang/rust/commit/3af1bdc4bcc502d576b1e836f99bae1eb29dbafd"}], "stats": {"total": 1348, "additions": 737, "deletions": 611}, "files": [{"sha": "d4ad4225b9914d74a5338f4f927858a2a657e0c7", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 76, "deletions": 90, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -11,12 +11,12 @@ use std::fmt::Debug;\n \n use self::Namespace::*;\n \n-/// Encodes if a `Def::Ctor` is the constructor of an enum variant or a struct.\n+/// Encodes if a `DefKind::Ctor` is the constructor of an enum variant or a struct.\n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n pub enum CtorOf {\n-    /// This `Def::Ctor` is a synthesized constructor of a tuple or unit struct.\n+    /// This `DefKind::Ctor` is a synthesized constructor of a tuple or unit struct.\n     Struct,\n-    /// This `Def::Ctor` is a synthesized constructor of a tuple or unit variant.\n+    /// This `DefKind::Ctor` is a synthesized constructor of a tuple or unit variant.\n     Variant,\n }\n \n@@ -45,52 +45,62 @@ pub enum NonMacroAttrKind {\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n-pub enum Def<Id = hir::HirId> {\n+pub enum DefKind {\n     // Type namespace\n-    Mod(DefId),\n-    /// `DefId` refers to the struct itself, `Def::Ctor` refers to its constructor if it exists.\n-    Struct(DefId),\n-    Union(DefId),\n-    Enum(DefId),\n-    /// `DefId` refers to the variant itself, `Def::Ctor` refers to its constructor if it exists.\n-    Variant(DefId),\n-    Trait(DefId),\n+    Mod,\n+    /// Refers to the struct itself, `DefKind::Ctor` refers to its constructor if it exists.\n+    Struct,\n+    Union,\n+    Enum,\n+    /// Refers to the variant itself, `DefKind::Ctor` refers to its constructor if it exists.\n+    Variant,\n+    Trait,\n     /// `existential type Foo: Bar;`\n-    Existential(DefId),\n+    Existential,\n     /// `type Foo = Bar;`\n-    TyAlias(DefId),\n-    ForeignTy(DefId),\n-    TraitAlias(DefId),\n-    AssociatedTy(DefId),\n+    TyAlias,\n+    ForeignTy,\n+    TraitAlias,\n+    AssociatedTy,\n     /// `existential type Foo: Bar;`\n-    AssociatedExistential(DefId),\n+    AssociatedExistential,\n+    TyParam,\n+\n+    // Value namespace\n+    Fn,\n+    Const,\n+    ConstParam,\n+    Static,\n+    /// Refers to the struct or enum variant's constructor.\n+    Ctor(CtorOf, CtorKind),\n+    Method,\n+    AssociatedConst,\n+\n+    // Macro namespace\n+    Macro(MacroKind),\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n+pub enum Def<Id = hir::HirId> {\n+    Def(DefKind, DefId),\n+\n+    // Type namespace\n     PrimTy(hir::PrimTy),\n-    TyParam(DefId),\n     SelfTy(Option<DefId> /* trait */, Option<DefId> /* impl */),\n     ToolMod, // e.g., `rustfmt` in `#[rustfmt::skip]`\n \n     // Value namespace\n-    Fn(DefId),\n-    Const(DefId),\n-    ConstParam(DefId),\n-    Static(DefId),\n-    /// `DefId` refers to the struct or enum variant's constructor.\n-    Ctor(DefId, CtorOf, CtorKind),\n     SelfCtor(DefId /* impl */),  // `DefId` refers to the impl\n-    Method(DefId),\n-    AssociatedConst(DefId),\n-\n     Local(Id),\n     Upvar(Id,           // `HirId` of closed over local\n           usize,        // index in the `freevars` list of the closure\n           ast::NodeId), // expr node that creates the closure\n     Label(ast::NodeId),\n \n     // Macro namespace\n-    Macro(DefId, MacroKind),\n     NonMacroAttr(NonMacroAttrKind), // e.g., `#[inline]` or `#[rustfmt::skip]`\n \n-    // Both namespaces\n+    // All namespaces\n     Err,\n }\n \n@@ -291,15 +301,7 @@ impl<Id> Def<Id> {\n     /// Return `Some(..)` with the `DefId` of this `Def` if it has a id, else `None`.\n     pub fn opt_def_id(&self) -> Option<DefId> {\n         match *self {\n-            Def::Fn(id) | Def::Mod(id) | Def::Static(id) |\n-            Def::Variant(id) | Def::Ctor(id, ..) | Def::Enum(id) |\n-            Def::TyAlias(id) | Def::TraitAlias(id) |\n-            Def::AssociatedTy(id) | Def::TyParam(id) | Def::ConstParam(id) | Def::Struct(id) |\n-            Def::Union(id) | Def::Trait(id) | Def::Method(id) | Def::Const(id) |\n-            Def::AssociatedConst(id) | Def::Macro(id, ..) |\n-            Def::Existential(id) | Def::AssociatedExistential(id) | Def::ForeignTy(id) => {\n-                Some(id)\n-            }\n+            Def::Def(_, id) => Some(id),\n \n             Def::Local(..) |\n             Def::Upvar(..) |\n@@ -318,47 +320,47 @@ impl<Id> Def<Id> {\n     /// Return the `DefId` of this `Def` if it represents a module.\n     pub fn mod_def_id(&self) -> Option<DefId> {\n         match *self {\n-            Def::Mod(id) => Some(id),\n+            Def::Def(DefKind::Mod, id) => Some(id),\n             _ => None,\n         }\n     }\n \n     /// A human readable name for the def kind (\"function\", \"module\", etc.).\n     pub fn kind_name(&self) -> &'static str {\n         match *self {\n-            Def::Fn(..) => \"function\",\n-            Def::Mod(..) => \"module\",\n-            Def::Static(..) => \"static\",\n-            Def::Enum(..) => \"enum\",\n-            Def::Variant(..) => \"variant\",\n-            Def::Ctor(_, CtorOf::Variant, CtorKind::Fn) => \"tuple variant\",\n-            Def::Ctor(_, CtorOf::Variant, CtorKind::Const) => \"unit variant\",\n-            Def::Ctor(_, CtorOf::Variant, CtorKind::Fictive) => \"struct variant\",\n-            Def::Struct(..) => \"struct\",\n-            Def::Ctor(_, CtorOf::Struct, CtorKind::Fn) => \"tuple struct\",\n-            Def::Ctor(_, CtorOf::Struct, CtorKind::Const) => \"unit struct\",\n-            Def::Ctor(_, CtorOf::Struct, CtorKind::Fictive) =>\n+            Def::Def(DefKind::Fn, _) => \"function\",\n+            Def::Def(DefKind::Mod, _) => \"module\",\n+            Def::Def(DefKind::Static, _) => \"static\",\n+            Def::Def(DefKind::Enum, _) => \"enum\",\n+            Def::Def(DefKind::Variant, _) => \"variant\",\n+            Def::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), _) => \"tuple variant\",\n+            Def::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Const), _) => \"unit variant\",\n+            Def::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fictive), _) => \"struct variant\",\n+            Def::Def(DefKind::Struct, _) => \"struct\",\n+            Def::Def(DefKind::Ctor(CtorOf::Struct, CtorKind::Fn), _) => \"tuple struct\",\n+            Def::Def(DefKind::Ctor(CtorOf::Struct, CtorKind::Const), _) => \"unit struct\",\n+            Def::Def(DefKind::Ctor(CtorOf::Struct, CtorKind::Fictive), _) =>\n                 bug!(\"impossible struct constructor\"),\n-            Def::Existential(..) => \"existential type\",\n-            Def::TyAlias(..) => \"type alias\",\n-            Def::TraitAlias(..) => \"trait alias\",\n-            Def::AssociatedTy(..) => \"associated type\",\n-            Def::AssociatedExistential(..) => \"associated existential type\",\n+            Def::Def(DefKind::Existential, _) => \"existential type\",\n+            Def::Def(DefKind::TyAlias, _) => \"type alias\",\n+            Def::Def(DefKind::TraitAlias, _) => \"trait alias\",\n+            Def::Def(DefKind::AssociatedTy, _) => \"associated type\",\n+            Def::Def(DefKind::AssociatedExistential, _) => \"associated existential type\",\n             Def::SelfCtor(..) => \"self constructor\",\n-            Def::Union(..) => \"union\",\n-            Def::Trait(..) => \"trait\",\n-            Def::ForeignTy(..) => \"foreign type\",\n-            Def::Method(..) => \"method\",\n-            Def::Const(..) => \"constant\",\n-            Def::AssociatedConst(..) => \"associated constant\",\n-            Def::TyParam(..) => \"type parameter\",\n-            Def::ConstParam(..) => \"const parameter\",\n+            Def::Def(DefKind::Union, _) => \"union\",\n+            Def::Def(DefKind::Trait, _) => \"trait\",\n+            Def::Def(DefKind::ForeignTy, _) => \"foreign type\",\n+            Def::Def(DefKind::Method, _) => \"method\",\n+            Def::Def(DefKind::Const, _) => \"constant\",\n+            Def::Def(DefKind::AssociatedConst, _) => \"associated constant\",\n+            Def::Def(DefKind::TyParam, _) => \"type parameter\",\n+            Def::Def(DefKind::ConstParam, _) => \"const parameter\",\n             Def::PrimTy(..) => \"builtin type\",\n             Def::Local(..) => \"local variable\",\n             Def::Upvar(..) => \"closure capture\",\n             Def::Label(..) => \"label\",\n             Def::SelfTy(..) => \"self type\",\n-            Def::Macro(.., macro_kind) => macro_kind.descr(),\n+            Def::Def(DefKind::Macro(macro_kind), _) => macro_kind.descr(),\n             Def::ToolMod => \"tool module\",\n             Def::NonMacroAttr(attr_kind) => attr_kind.descr(),\n             Def::Err => \"unresolved item\",\n@@ -368,36 +370,21 @@ impl<Id> Def<Id> {\n     /// An English article for the def.\n     pub fn article(&self) -> &'static str {\n         match *self {\n-            Def::AssociatedTy(..) | Def::AssociatedConst(..) | Def::AssociatedExistential(..) |\n-            Def::Enum(..) | Def::Existential(..) | Def::Err => \"an\",\n-            Def::Macro(.., macro_kind) => macro_kind.article(),\n+            Def::Def(DefKind::AssociatedTy, _)\n+            | Def::Def(DefKind::AssociatedConst, _)\n+            | Def::Def(DefKind::AssociatedExistential, _)\n+            | Def::Def(DefKind::Enum, _)\n+            | Def::Def(DefKind::Existential, _)\n+            | Def::Err => \"an\",\n+            Def::Def(DefKind::Macro(macro_kind), _) => macro_kind.article(),\n             _ => \"a\",\n         }\n     }\n \n     pub fn map_id<R>(self, mut map: impl FnMut(Id) -> R) -> Def<R> {\n         match self {\n-            Def::Fn(id) => Def::Fn(id),\n-            Def::Mod(id) => Def::Mod(id),\n-            Def::Static(id) => Def::Static(id),\n-            Def::Enum(id) => Def::Enum(id),\n-            Def::Variant(id) => Def::Variant(id),\n-            Def::Ctor(a, b, c) => Def::Ctor(a, b, c),\n-            Def::Struct(id) => Def::Struct(id),\n-            Def::Existential(id) => Def::Existential(id),\n-            Def::TyAlias(id) => Def::TyAlias(id),\n-            Def::TraitAlias(id) => Def::TraitAlias(id),\n-            Def::AssociatedTy(id) => Def::AssociatedTy(id),\n-            Def::AssociatedExistential(id) => Def::AssociatedExistential(id),\n+            Def::Def(kind, id) => Def::Def(kind, id),\n             Def::SelfCtor(id) => Def::SelfCtor(id),\n-            Def::Union(id) => Def::Union(id),\n-            Def::Trait(id) => Def::Trait(id),\n-            Def::ForeignTy(id) => Def::ForeignTy(id),\n-            Def::Method(id) => Def::Method(id),\n-            Def::Const(id) => Def::Const(id),\n-            Def::AssociatedConst(id) => Def::AssociatedConst(id),\n-            Def::TyParam(id) => Def::TyParam(id),\n-            Def::ConstParam(id) => Def::ConstParam(id),\n             Def::PrimTy(id) => Def::PrimTy(id),\n             Def::Local(id) => Def::Local(map(id)),\n             Def::Upvar(id, index, closure) => Def::Upvar(\n@@ -407,7 +394,6 @@ impl<Id> Def<Id> {\n             ),\n             Def::Label(id) => Def::Label(id),\n             Def::SelfTy(a, b) => Def::SelfTy(a, b),\n-            Def::Macro(id, macro_kind) => Def::Macro(id, macro_kind),\n             Def::ToolMod => Def::ToolMod,\n             Def::NonMacroAttr(attr_kind) => Def::NonMacroAttr(attr_kind),\n             Def::Err => Def::Err,"}, {"sha": "583508bfb7ee5eba36f2160dcc9fd92ad4acf141", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -37,7 +37,7 @@ use crate::hir::{self, ParamName};\n use crate::hir::HirVec;\n use crate::hir::map::{DefKey, DefPathData, Definitions};\n use crate::hir::def_id::{DefId, DefIndex, DefIndexAddressSpace, CRATE_DEF_INDEX};\n-use crate::hir::def::{Def, PathResolution, PerNS};\n+use crate::hir::def::{Def, DefKind, PathResolution, PerNS};\n use crate::hir::{GenericArg, ConstArg};\n use crate::lint::builtin::{self, PARENTHESIZED_PARAMS_IN_TYPES_AND_MODULES,\n                     ELIDED_LIFETIMES_IN_PATHS};\n@@ -1500,7 +1500,7 @@ impl<'a> LoweringContext<'a> {\n                             None,\n                             P(hir::Path {\n                                 span,\n-                                def: Def::TyParam(DefId::local(def_index)),\n+                                def: Def::Def(DefKind::TyParam, DefId::local(def_index)),\n                                 segments: hir_vec![hir::PathSegment::from_ident(ident)],\n                             }),\n                         ))\n@@ -1870,39 +1870,42 @@ impl<'a> LoweringContext<'a> {\n                         index: this.def_key(def_id).parent.expect(\"missing parent\"),\n                     };\n                     let type_def_id = match resolution.base_def() {\n-                        Def::AssociatedTy(def_id) if i + 2 == proj_start => {\n+                        Def::Def(DefKind::AssociatedTy, def_id) if i + 2 == proj_start => {\n                             Some(parent_def_id(self, def_id))\n                         }\n-                        Def::Variant(def_id) if i + 1 == proj_start => {\n+                        Def::Def(DefKind::Variant, def_id) if i + 1 == proj_start => {\n                             Some(parent_def_id(self, def_id))\n                         }\n-                        Def::Struct(def_id)\n-                        | Def::Union(def_id)\n-                        | Def::Enum(def_id)\n-                        | Def::TyAlias(def_id)\n-                        | Def::Trait(def_id) if i + 1 == proj_start =>\n+                        Def::Def(DefKind::Struct, def_id)\n+                        | Def::Def(DefKind::Union, def_id)\n+                        | Def::Def(DefKind::Enum, def_id)\n+                        | Def::Def(DefKind::TyAlias, def_id)\n+                        | Def::Def(DefKind::Trait, def_id) if i + 1 == proj_start =>\n                         {\n                             Some(def_id)\n                         }\n                         _ => None,\n                     };\n                     let parenthesized_generic_args = match resolution.base_def() {\n                         // `a::b::Trait(Args)`\n-                        Def::Trait(..) if i + 1 == proj_start => ParenthesizedGenericArgs::Ok,\n+                        Def::Def(DefKind::Trait, _)\n+                            if i + 1 == proj_start => ParenthesizedGenericArgs::Ok,\n                         // `a::b::Trait(Args)::TraitItem`\n-                        Def::Method(..) | Def::AssociatedConst(..) | Def::AssociatedTy(..)\n+                        Def::Def(DefKind::Method, _)\n+                        | Def::Def(DefKind::AssociatedConst, _)\n+                        | Def::Def(DefKind::AssociatedTy, _)\n                             if i + 2 == proj_start =>\n                         {\n                             ParenthesizedGenericArgs::Ok\n                         }\n                         // Avoid duplicated errors.\n                         Def::Err => ParenthesizedGenericArgs::Ok,\n                         // An error\n-                        Def::Struct(..)\n-                        | Def::Enum(..)\n-                        | Def::Union(..)\n-                        | Def::TyAlias(..)\n-                        | Def::Variant(..) if i + 1 == proj_start =>\n+                        Def::Def(DefKind::Struct, _)\n+                        | Def::Def(DefKind::Enum, _)\n+                        | Def::Def(DefKind::Union, _)\n+                        | Def::Def(DefKind::TyAlias, _)\n+                        | Def::Def(DefKind::Variant, _) if i + 1 == proj_start =>\n                         {\n                             ParenthesizedGenericArgs::Err\n                         }\n@@ -2788,7 +2791,7 @@ impl<'a> LoweringContext<'a> {\n                                 if path.segments.len() == 1\n                                     && bound_pred.bound_generic_params.is_empty() =>\n                             {\n-                                if let Some(Def::TyParam(def_id)) = self.resolver\n+                                if let Some(Def::Def(DefKind::TyParam, def_id)) = self.resolver\n                                     .get_resolution(bound_pred.bounded_ty.id)\n                                     .map(|d| d.base_def())\n                                 {\n@@ -3242,7 +3245,7 @@ impl<'a> LoweringContext<'a> {\n                         });\n \n                         if let Some(ref trait_ref) = trait_ref {\n-                            if let Def::Trait(def_id) = trait_ref.path.def {\n+                            if let Def::Def(DefKind::Trait, def_id) = trait_ref.path.def {\n                                 this.trait_impls.entry(def_id).or_default().push(\n                                     lowered_trait_impl_id);\n                             }\n@@ -5277,7 +5280,7 @@ impl<'a> LoweringContext<'a> {\n             hir::QPath::Resolved(None, path) => {\n                 // Turn trait object paths into `TyKind::TraitObject` instead.\n                 match path.def {\n-                    Def::Trait(_) | Def::TraitAlias(_) => {\n+                    Def::Def(DefKind::Trait, _) | Def::Def(DefKind::TraitAlias, _) => {\n                         let principal = hir::PolyTraitRef {\n                             bound_generic_params: hir::HirVec::new(),\n                             trait_ref: hir::TraitRef {"}, {"sha": "9251f8e797baa3939f5ede9cb688234d2f4b1a59", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 42, "deletions": 51, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -17,6 +17,7 @@ use syntax::ext::base::MacroKind;\n use syntax_pos::{Span, DUMMY_SP};\n \n use crate::hir::*;\n+use crate::hir::{Def, DefKind};\n use crate::hir::itemlikevisit::ItemLikeVisitor;\n use crate::hir::print::Nested;\n use crate::util::nodemap::FxHashMap;\n@@ -316,67 +317,61 @@ impl<'hir> Map<'hir> {\n             return None\n         };\n \n-        match node {\n+        let kind = match node {\n             Node::Item(item) => {\n-                let def_id = || self.local_def_id_from_hir_id(item.hir_id);\n-\n                 match item.node {\n-                    ItemKind::Static(..) => Some(Def::Static(def_id())),\n-                    ItemKind::Const(..) => Some(Def::Const(def_id())),\n-                    ItemKind::Fn(..) => Some(Def::Fn(def_id())),\n-                    ItemKind::Mod(..) => Some(Def::Mod(def_id())),\n-                    ItemKind::Existential(..) => Some(Def::Existential(def_id())),\n-                    ItemKind::Ty(..) => Some(Def::TyAlias(def_id())),\n-                    ItemKind::Enum(..) => Some(Def::Enum(def_id())),\n-                    ItemKind::Struct(..) => Some(Def::Struct(def_id())),\n-                    ItemKind::Union(..) => Some(Def::Union(def_id())),\n-                    ItemKind::Trait(..) => Some(Def::Trait(def_id())),\n-                    ItemKind::TraitAlias(..) => Some(Def::TraitAlias(def_id())),\n+                    ItemKind::Static(..) => DefKind::Static,\n+                    ItemKind::Const(..) => DefKind::Const,\n+                    ItemKind::Fn(..) => DefKind::Fn,\n+                    ItemKind::Mod(..) => DefKind::Mod,\n+                    ItemKind::Existential(..) => DefKind::Existential,\n+                    ItemKind::Ty(..) => DefKind::TyAlias,\n+                    ItemKind::Enum(..) => DefKind::Enum,\n+                    ItemKind::Struct(..) => DefKind::Struct,\n+                    ItemKind::Union(..) => DefKind::Union,\n+                    ItemKind::Trait(..) => DefKind::Trait,\n+                    ItemKind::TraitAlias(..) => DefKind::TraitAlias,\n                     ItemKind::ExternCrate(_) |\n                     ItemKind::Use(..) |\n                     ItemKind::ForeignMod(..) |\n                     ItemKind::GlobalAsm(..) |\n-                    ItemKind::Impl(..) => None,\n+                    ItemKind::Impl(..) => return None,\n                 }\n             }\n             Node::ForeignItem(item) => {\n-                let def_id = self.local_def_id_from_hir_id(item.hir_id);\n                 match item.node {\n-                    ForeignItemKind::Fn(..) => Some(Def::Fn(def_id)),\n-                    ForeignItemKind::Static(..) => Some(Def::Static(def_id)),\n-                    ForeignItemKind::Type => Some(Def::ForeignTy(def_id)),\n+                    ForeignItemKind::Fn(..) => DefKind::Fn,\n+                    ForeignItemKind::Static(..) => DefKind::Static,\n+                    ForeignItemKind::Type => DefKind::ForeignTy,\n                 }\n             }\n             Node::TraitItem(item) => {\n-                let def_id = self.local_def_id_from_hir_id(item.hir_id);\n                 match item.node {\n-                    TraitItemKind::Const(..) => Some(Def::AssociatedConst(def_id)),\n-                    TraitItemKind::Method(..) => Some(Def::Method(def_id)),\n-                    TraitItemKind::Type(..) => Some(Def::AssociatedTy(def_id)),\n+                    TraitItemKind::Const(..) => DefKind::AssociatedConst,\n+                    TraitItemKind::Method(..) => DefKind::Method,\n+                    TraitItemKind::Type(..) => DefKind::AssociatedTy,\n                 }\n             }\n             Node::ImplItem(item) => {\n-                let def_id = self.local_def_id_from_hir_id(item.hir_id);\n                 match item.node {\n-                    ImplItemKind::Const(..) => Some(Def::AssociatedConst(def_id)),\n-                    ImplItemKind::Method(..) => Some(Def::Method(def_id)),\n-                    ImplItemKind::Type(..) => Some(Def::AssociatedTy(def_id)),\n-                    ImplItemKind::Existential(..) => Some(Def::AssociatedExistential(def_id)),\n+                    ImplItemKind::Const(..) => DefKind::AssociatedConst,\n+                    ImplItemKind::Method(..) => DefKind::Method,\n+                    ImplItemKind::Type(..) => DefKind::AssociatedTy,\n+                    ImplItemKind::Existential(..) => DefKind::AssociatedExistential,\n                 }\n             }\n-            Node::Variant(variant) => {\n-                let def_id = self.local_def_id_from_hir_id(variant.node.id);\n-                Some(Def::Variant(def_id))\n-            }\n+            Node::Variant(_) => DefKind::Variant,\n             Node::Ctor(variant_data) => {\n+                // FIXME(eddyb) is this even possible, if we have a `Node::Ctor`?\n+                if variant_data.ctor_hir_id().is_none() {\n+                    return None;\n+                }\n                 let ctor_of = match self.find(self.get_parent_node(node_id)) {\n                     Some(Node::Item(..)) => def::CtorOf::Struct,\n                     Some(Node::Variant(..)) => def::CtorOf::Variant,\n                     _ => unreachable!(),\n                 };\n-                variant_data.ctor_hir_id()\n-                    .map(|hir_id| self.local_def_id_from_hir_id(hir_id))\n-                    .map(|def_id| Def::Ctor(def_id, ctor_of, def::CtorKind::from_hir(variant_data)))\n+                DefKind::Ctor(ctor_of, def::CtorKind::from_hir(variant_data))\n             }\n             Node::AnonConst(_) |\n             Node::Field(_) |\n@@ -390,26 +385,22 @@ impl<'hir> Map<'hir> {\n             Node::Lifetime(_) |\n             Node::Visibility(_) |\n             Node::Block(_) |\n-            Node::Crate => None,\n+            Node::Crate => return None,\n+            // FIXME(eddyb) this is the only non-`DefKind` case here,\n+            // investigate whether it's actually used, and ideally remove it.\n             Node::Local(local) => {\n-                Some(Def::Local(local.hir_id))\n-            }\n-            Node::MacroDef(macro_def) => {\n-                Some(Def::Macro(self.local_def_id_from_hir_id(macro_def.hir_id),\n-                                MacroKind::Bang))\n+                return Some(Def::Local(local.hir_id));\n             }\n+            Node::MacroDef(_) => DefKind::Macro(MacroKind::Bang),\n             Node::GenericParam(param) => {\n-                Some(match param.kind {\n-                    GenericParamKind::Lifetime { .. } => {\n-                        Def::Local(param.hir_id)\n-                    },\n-                    GenericParamKind::Type { .. } => Def::TyParam(\n-                        self.local_def_id_from_hir_id(param.hir_id)),\n-                    GenericParamKind::Const { .. } => Def::ConstParam(\n-                        self.local_def_id_from_hir_id(param.hir_id)),\n-                })\n+                match param.kind {\n+                    GenericParamKind::Lifetime { .. } => return None,\n+                    GenericParamKind::Type { .. } => DefKind::TyParam,\n+                    GenericParamKind::Const { .. } => DefKind::ConstParam,\n+                }\n             }\n-        }\n+        };\n+        Some(Def::Def(kind, self.local_def_id(node_id)))\n     }\n \n     // FIXME(@ljedrz): replace the NodeId variant"}, {"sha": "f474ab1a1a5bc52009ae853dfa33726d2367491e", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -10,7 +10,7 @@ pub use self::PrimTy::*;\n pub use self::UnOp::*;\n pub use self::UnsafeSource::*;\n \n-use crate::hir::def::Def;\n+use crate::hir::def::{Def, DefKind};\n use crate::hir::def_id::{DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX};\n use crate::util::nodemap::{NodeMap, FxHashSet};\n use crate::mir::mono::Linkage;\n@@ -1394,7 +1394,10 @@ impl Expr {\n          match self.node {\n             ExprKind::Path(QPath::Resolved(_, ref path)) => {\n                 match path.def {\n-                    Def::Local(..) | Def::Upvar(..) | Def::Static(..) | Def::Err => true,\n+                    Def::Local(..)\n+                    | Def::Upvar(..)\n+                    | Def::Def(DefKind::Static, _)\n+                    | Def::Err => true,\n                     _ => false,\n                 }\n             }\n@@ -2152,8 +2155,8 @@ impl TraitRef {\n     /// Gets the `DefId` of the referenced trait. It _must_ actually be a trait or trait alias.\n     pub fn trait_def_id(&self) -> DefId {\n         match self.path.def {\n-            Def::Trait(did) => did,\n-            Def::TraitAlias(did) => did,\n+            Def::Def(DefKind::Trait, did) => did,\n+            Def::Def(DefKind::TraitAlias, did) => did,\n             Def::Err => {\n                 FatalError.raise();\n             }"}, {"sha": "a1ff3dcda2d4ca5dc6f5b47341970bf6206b920b", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -1,4 +1,4 @@\n-use crate::hir::def::{CtorOf, Def};\n+use crate::hir::def::{CtorOf, Def, DefKind};\n use crate::hir::def_id::DefId;\n use crate::hir::{self, HirId, PatKind};\n use syntax::ast;\n@@ -55,7 +55,7 @@ impl hir::Pat {\n             PatKind::TupleStruct(hir::QPath::Resolved(_, ref path), ..) |\n             PatKind::Struct(hir::QPath::Resolved(_, ref path), ..) => {\n                 match path.def {\n-                    Def::Variant(..) => true,\n+                    Def::Def(DefKind::Variant, _) => true,\n                     _ => false\n                 }\n             }\n@@ -125,8 +125,8 @@ impl hir::Pat {\n                 PatKind::TupleStruct(hir::QPath::Resolved(_, ref path), ..) |\n                 PatKind::Struct(hir::QPath::Resolved(_, ref path), ..) => {\n                     match path.def {\n-                        Def::Variant(id) => variants.push(id),\n-                        Def::Ctor(id, CtorOf::Variant, ..) => variants.push(id),\n+                        Def::Def(DefKind::Variant, id) => variants.push(id),\n+                        Def::Def(DefKind::Ctor(CtorOf::Variant, ..), id) => variants.push(id),\n                         _ => ()\n                     }\n                 }"}, {"sha": "a58fb1a933ed306997018b6711f52fb87d005040", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -7,7 +7,7 @@ use crate::hir::{self, PatKind, TyKind};\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use crate::hir::itemlikevisit::ItemLikeVisitor;\n \n-use crate::hir::def::{CtorOf, Def};\n+use crate::hir::def::{CtorOf, Def, DefKind};\n use crate::hir::CodegenFnAttrFlags;\n use crate::hir::def_id::{DefId, LOCAL_CRATE};\n use crate::lint;\n@@ -70,21 +70,23 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n \n     fn handle_definition(&mut self, def: Def) {\n         match def {\n-            Def::Const(_) | Def::AssociatedConst(..) | Def::TyAlias(_) => {\n+            Def::Def(DefKind::Const, _)\n+            | Def::Def(DefKind::AssociatedConst, _)\n+            | Def::Def(DefKind::TyAlias, _) => {\n                 self.check_def_id(def.def_id());\n             }\n             _ if self.in_pat => {},\n             Def::PrimTy(..) | Def::SelfTy(..) | Def::SelfCtor(..) |\n             Def::Local(..) | Def::Upvar(..) => {}\n-            Def::Ctor(ctor_def_id, CtorOf::Variant, ..) => {\n+            Def::Def(DefKind::Ctor(CtorOf::Variant, ..), ctor_def_id) => {\n                 let variant_id = self.tcx.parent(ctor_def_id).unwrap();\n                 let enum_id = self.tcx.parent(variant_id).unwrap();\n                 self.check_def_id(enum_id);\n                 if !self.ignore_variant_stack.contains(&ctor_def_id) {\n                     self.check_def_id(variant_id);\n                 }\n             }\n-            Def::Variant(variant_id) => {\n+            Def::Def(DefKind::Variant, variant_id) => {\n                 let enum_id = self.tcx.parent(variant_id).unwrap();\n                 self.check_def_id(enum_id);\n                 if !self.ignore_variant_stack.contains(&variant_id) {"}, {"sha": "149f9fe96f6970a8a4a6260b1382c1daf1a0d864", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -9,7 +9,7 @@ pub use self::MatchMode::*;\n use self::TrackMatchMode::*;\n use self::OverloadedCallType::*;\n \n-use crate::hir::def::{CtorOf, Def};\n+use crate::hir::def::{CtorOf, Def, DefKind};\n use crate::hir::def_id::DefId;\n use crate::infer::InferCtxt;\n use crate::middle::mem_categorization as mc;\n@@ -900,21 +900,25 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n             };\n             let def = mc.tables.qpath_def(qpath, pat.hir_id);\n             match def {\n-                Def::Ctor(variant_ctor_did, CtorOf::Variant, ..) => {\n+                Def::Def(DefKind::Ctor(CtorOf::Variant, ..), variant_ctor_did) => {\n                     let variant_did = mc.tcx.parent(variant_ctor_did).unwrap();\n                     let downcast_cmt = mc.cat_downcast_if_needed(pat, cmt_pat, variant_did);\n \n                     debug!(\"variantctor downcast_cmt={:?} pat={:?}\", downcast_cmt, pat);\n                     delegate.matched_pat(pat, &downcast_cmt, match_mode);\n                 }\n-                Def::Variant(variant_did) => {\n+                Def::Def(DefKind::Variant, variant_did) => {\n                     let downcast_cmt = mc.cat_downcast_if_needed(pat, cmt_pat, variant_did);\n \n                     debug!(\"variant downcast_cmt={:?} pat={:?}\", downcast_cmt, pat);\n                     delegate.matched_pat(pat, &downcast_cmt, match_mode);\n                 }\n-                Def::Struct(..) | Def::Ctor(..) | Def::Union(..) |\n-                Def::TyAlias(..) | Def::AssociatedTy(..) | Def::SelfTy(..) => {\n+                Def::Def(DefKind::Struct, _)\n+                | Def::Def(DefKind::Ctor(..), _)\n+                | Def::Def(DefKind::Union, _)\n+                | Def::Def(DefKind::TyAlias, _)\n+                | Def::Def(DefKind::AssociatedTy, _)\n+                | Def::SelfTy(..) => {\n                     debug!(\"struct cmt_pat={:?} pat={:?}\", cmt_pat, pat);\n                     delegate.matched_pat(pat, &cmt_pat, match_mode);\n                 }"}, {"sha": "507aff69005100e9d0db64e356c721698f5171fb", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -1,4 +1,4 @@\n-use crate::hir::def::Def;\n+use crate::hir::def::{Def, DefKind};\n use crate::hir::def_id::DefId;\n use crate::ty::{self, Ty, TyCtxt};\n use crate::ty::layout::{LayoutError, Pointer, SizeSkeleton, VariantIdx};\n@@ -157,7 +157,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ExprVisitor<'a, 'tcx> {\n         } else {\n             Def::Err\n         };\n-        if let Def::Fn(did) = def {\n+        if let Def::Def(DefKind::Fn, did) = def {\n             if self.def_id_is_transmute(did) {\n                 let typ = self.tables.node_type(expr.hir_id);\n                 let sig = typ.fn_sig(self.tcx);"}, {"sha": "21c7152ed7d7018ef791f0b3ec90ae82948521ca", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -62,7 +62,7 @@ use crate::middle::region;\n use crate::hir::def_id::{DefId, LocalDefId};\n use crate::hir::Node;\n use crate::infer::InferCtxt;\n-use crate::hir::def::{CtorOf, Def, CtorKind};\n+use crate::hir::def::{CtorOf, Def, DefKind, CtorKind};\n use crate::ty::adjustment;\n use crate::ty::{self, DefIdTree, Ty, TyCtxt};\n use crate::ty::fold::TypeFoldable;\n@@ -699,12 +699,17 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                hir_id, expr_ty, def);\n \n         match def {\n-            Def::Ctor(..) | Def::Const(..) | Def::ConstParam(..) |\n-            Def::AssociatedConst(..) | Def::Fn(..) | Def::Method(..) | Def::SelfCtor(..) => {\n+            Def::Def(DefKind::Ctor(..), _)\n+            | Def::Def(DefKind::Const, _)\n+            | Def::Def(DefKind::ConstParam, _)\n+            | Def::Def(DefKind::AssociatedConst, _)\n+            | Def::Def(DefKind::Fn, _)\n+            | Def::Def(DefKind::Method, _)\n+            | Def::SelfCtor(..) => {\n                 Ok(self.cat_rvalue_node(hir_id, span, expr_ty))\n             }\n \n-            Def::Static(def_id) => {\n+            Def::Def(DefKind::Static, def_id) => {\n                 // `#[thread_local]` statics may not outlive the current function, but\n                 // they also cannot be moved out of.\n                 let is_thread_local = self.tcx.get_attrs(def_id)[..]\n@@ -1274,14 +1279,15 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                         debug!(\"access to unresolvable pattern {:?}\", pat);\n                         return Err(())\n                     }\n-                    Def::Ctor(variant_ctor_did, CtorOf::Variant, CtorKind::Fn) => {\n+                    Def::Def(DefKind::Ctor(CtorOf::Variant, CtorKind::Fn), variant_ctor_did) => {\n                         let variant_did = self.tcx.parent(variant_ctor_did).unwrap();\n                         let enum_did = self.tcx.parent(variant_did).unwrap();\n                         (self.cat_downcast_if_needed(pat, cmt, variant_did),\n                          self.tcx.adt_def(enum_did)\n                              .variant_with_ctor_id(variant_ctor_did).fields.len())\n                     }\n-                    Def::Ctor(_, CtorOf::Struct, CtorKind::Fn) | Def::SelfCtor(..) => {\n+                    Def::Def(DefKind::Ctor(CtorOf::Struct, CtorKind::Fn), _)\n+                    | Def::SelfCtor(..) => {\n                         let ty = self.pat_ty_unadjusted(&pat)?;\n                         match ty.sty {\n                             ty::Adt(adt_def, _) => {\n@@ -1316,11 +1322,11 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                         debug!(\"access to unresolvable pattern {:?}\", pat);\n                         return Err(())\n                     }\n-                    Def::Ctor(variant_ctor_did, CtorOf::Variant, _) => {\n+                    Def::Def(DefKind::Ctor(CtorOf::Variant, _), variant_ctor_did) => {\n                         let variant_did = self.tcx.parent(variant_ctor_did).unwrap();\n                         self.cat_downcast_if_needed(pat, cmt, variant_did)\n                     }\n-                    Def::Variant(variant_did) => {\n+                    Def::Def(DefKind::Variant, variant_did) => {\n                         self.cat_downcast_if_needed(pat, cmt, variant_did)\n                     }\n                     _ => cmt,"}, {"sha": "8647820d574bfa81847537b5eec7fb3a5036cf11", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -7,7 +7,7 @@\n \n use crate::hir::{CodegenFnAttrs, CodegenFnAttrFlags};\n use crate::hir::Node;\n-use crate::hir::def::Def;\n+use crate::hir::def::{Def, DefKind};\n use crate::hir::def_id::{DefId, CrateNum};\n use rustc_data_structures::sync::Lrc;\n use crate::ty::{self, TyCtxt};\n@@ -117,7 +117,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ReachableContext<'a, 'tcx> {\n                             // If this path leads to a constant, then we need to\n                             // recurse into the constant to continue finding\n                             // items that are reachable.\n-                            Def::Const(..) | Def::AssociatedConst(..) => {\n+                            Def::Def(DefKind::Const, _) | Def::Def(DefKind::AssociatedConst, _) => {\n                                 self.worklist.push(hir_id);\n                             }\n \n@@ -357,7 +357,7 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a,\n                 self.worklist.extend(impl_item_refs.iter().map(|ii_ref| ii_ref.id.hir_id));\n \n                 let trait_def_id = match trait_ref.path.def {\n-                    Def::Trait(def_id) => def_id,\n+                    Def::Def(DefKind::Trait, def_id) => def_id,\n                     _ => unreachable!()\n                 };\n "}, {"sha": "1e886c08d41d76c6d90712f9064d286588647c9a", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -5,7 +5,7 @@\n //! used between functions, and they operate in a purely top-down\n //! way. Therefore, we break lifetime name resolution into a separate pass.\n \n-use crate::hir::def::Def;\n+use crate::hir::def::{Def, DefKind};\n use crate::hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use crate::hir::map::Map;\n use crate::hir::{GenericArg, GenericParam, ItemLocalId, LifetimeName, Node, ParamName};\n@@ -1365,7 +1365,7 @@ fn object_lifetime_defaults_for_item(\n                         _ => continue,\n                     };\n \n-                    if def == Def::TyParam(param_def_id) {\n+                    if def == Def::Def(DefKind::TyParam, param_def_id) {\n                         add_bounds(&mut set, &data.bounds);\n                     }\n                 }\n@@ -1929,13 +1929,15 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         };\n         let type_def_id = match def {\n-            Def::AssociatedTy(def_id) if depth == 1 => Some(parent_def_id(self, def_id)),\n-            Def::Variant(def_id) if depth == 0 => Some(parent_def_id(self, def_id)),\n-            Def::Struct(def_id)\n-            | Def::Union(def_id)\n-            | Def::Enum(def_id)\n-            | Def::TyAlias(def_id)\n-            | Def::Trait(def_id) if depth == 0 =>\n+            Def::Def(DefKind::AssociatedTy, def_id)\n+                if depth == 1 => Some(parent_def_id(self, def_id)),\n+            Def::Def(DefKind::Variant, def_id)\n+                if depth == 0 => Some(parent_def_id(self, def_id)),\n+            Def::Def(DefKind::Struct, def_id)\n+            | Def::Def(DefKind::Union, def_id)\n+            | Def::Def(DefKind::Enum, def_id)\n+            | Def::Def(DefKind::TyAlias, def_id)\n+            | Def::Def(DefKind::Trait, def_id) if depth == 0 =>\n             {\n                 Some(def_id)\n             }\n@@ -2139,7 +2141,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         // Whitelist the types that unambiguously always\n                         // result in the same type constructor being used\n                         // (it can't differ between `Self` and `self`).\n-                        Def::Struct(_) | Def::Union(_) | Def::Enum(_) | Def::PrimTy(_) => {\n+                        Def::Def(DefKind::Struct, _)\n+                        | Def::Def(DefKind::Union, _)\n+                        | Def::Def(DefKind::Enum, _)\n+                        | Def::PrimTy(_) => {\n                             return def == path.def\n                         }\n                         _ => {}"}, {"sha": "e651e82d30499d40afe8bb794e6150def25c353d", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -5,7 +5,7 @@ pub use self::StabilityLevel::*;\n \n use crate::lint::{self, Lint, in_derive_expansion};\n use crate::hir::{self, Item, Generics, StructField, Variant, HirId};\n-use crate::hir::def::Def;\n+use crate::hir::def::{Def, DefKind};\n use crate::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId, LOCAL_CRATE};\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use crate::ty::query::Providers;\n@@ -526,9 +526,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     fn skip_stability_check_due_to_privacy(self, mut def_id: DefId) -> bool {\n         // Check if `def_id` is a trait method.\n         match self.describe_def(def_id) {\n-            Some(Def::Method(_)) |\n-            Some(Def::AssociatedTy(_)) |\n-            Some(Def::AssociatedConst(_)) => {\n+            Some(Def::Def(DefKind::Method, _)) |\n+            Some(Def::Def(DefKind::AssociatedTy, _)) |\n+            Some(Def::Def(DefKind::AssociatedConst, _)) => {\n                 if let ty::TraitContainer(trait_def_id) = self.associated_item(def_id).container {\n                     // Trait methods do not declare visibility (even\n                     // for visibility info in cstore). Use containing\n@@ -779,7 +779,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             // individually as it's possible to have a stable trait with unstable\n             // items.\n             hir::ItemKind::Impl(.., Some(ref t), _, ref impl_item_refs) => {\n-                if let Def::Trait(trait_did) = t.path.def {\n+                if let Def::Def(DefKind::Trait, trait_did) = t.path.def {\n                     for impl_item_ref in impl_item_refs {\n                         let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                         let trait_item_def_id = self.tcx.associated_items(trait_did)"}, {"sha": "48c3400c597c2b19487a258fb7934729c6357905", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -10,7 +10,7 @@ use crate::session::config::{BorrowckMode, OutputFilenames};\n use crate::session::config::CrateType;\n use crate::middle;\n use crate::hir::{TraitCandidate, HirId, ItemKind, ItemLocalId, Node};\n-use crate::hir::def::{Def, Export};\n+use crate::hir::def::{Def, DefKind, Export};\n use crate::hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use crate::hir::map as hir_map;\n use crate::hir::map::DefPathHash;\n@@ -658,7 +658,7 @@ impl<'tcx> TypeckTables<'tcx> {\n         }\n \n         match self.type_dependent_defs().get(expr.hir_id) {\n-            Some(&Def::Method(_)) => true,\n+            Some(&Def::Def(DefKind::Method, _)) => true,\n             _ => false\n         }\n     }"}, {"sha": "3871b465cabdbb03b136f59eabda4cfd6623f628", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -10,7 +10,7 @@ pub use self::fold::TypeFoldable;\n \n use crate::hir::{map as hir_map, FreevarMap, GlobMap, TraitMap};\n use crate::hir::{HirId, Node};\n-use crate::hir::def::{Def, CtorOf, CtorKind, ExportMap};\n+use crate::hir::def::{Def, DefKind, CtorOf, CtorKind, ExportMap};\n use crate::hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_data_structures::svh::Svh;\n use rustc_macros::HashStable;\n@@ -193,10 +193,10 @@ pub enum AssociatedKind {\n impl AssociatedItem {\n     pub fn def(&self) -> Def {\n         match self.kind {\n-            AssociatedKind::Const => Def::AssociatedConst(self.def_id),\n-            AssociatedKind::Method => Def::Method(self.def_id),\n-            AssociatedKind::Type => Def::AssociatedTy(self.def_id),\n-            AssociatedKind::Existential => Def::AssociatedExistential(self.def_id),\n+            AssociatedKind::Const => Def::Def(DefKind::AssociatedConst, self.def_id),\n+            AssociatedKind::Method => Def::Def(DefKind::Method, self.def_id),\n+            AssociatedKind::Type => Def::Def(DefKind::AssociatedTy, self.def_id),\n+            AssociatedKind::Existential => Def::Def(DefKind::AssociatedExistential, self.def_id),\n         }\n     }\n \n@@ -2339,10 +2339,10 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n \n     pub fn variant_of_def(&self, def: Def) -> &VariantDef {\n         match def {\n-            Def::Variant(vid) => self.variant_with_id(vid),\n-            Def::Ctor(cid, ..) => self.variant_with_ctor_id(cid),\n-            Def::Struct(..) | Def::Union(..) |\n-            Def::TyAlias(..) | Def::AssociatedTy(..) | Def::SelfTy(..) |\n+            Def::Def(DefKind::Variant, vid) => self.variant_with_id(vid),\n+            Def::Def(DefKind::Ctor(..), cid) => self.variant_with_ctor_id(cid),\n+            Def::Def(DefKind::Struct, _) | Def::Def(DefKind::Union, _) |\n+            Def::Def(DefKind::TyAlias, _) | Def::Def(DefKind::AssociatedTy, _) | Def::SelfTy(..) |\n             Def::SelfCtor(..) => self.non_enum_variant(),\n             _ => bug!(\"unexpected def {:?} in variant_of_def\", def)\n         }\n@@ -2806,7 +2806,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             }\n         } else {\n             match self.describe_def(def_id).expect(\"no def for def-id\") {\n-                Def::AssociatedConst(_) | Def::Method(_) | Def::AssociatedTy(_) => true,\n+                Def::Def(DefKind::AssociatedConst, _)\n+                | Def::Def(DefKind::Method, _)\n+                | Def::Def(DefKind::AssociatedTy, _) => true,\n                 _ => false,\n             }\n         };\n@@ -2952,19 +2954,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// or variant or their constructors, panics otherwise.\n     pub fn expect_variant_def(self, def: Def) -> &'tcx VariantDef {\n         match def {\n-            Def::Variant(did) => {\n+            Def::Def(DefKind::Variant, did) => {\n                 let enum_did = self.parent(did).unwrap();\n                 self.adt_def(enum_did).variant_with_id(did)\n             }\n-            Def::Struct(did) | Def::Union(did) => {\n+            Def::Def(DefKind::Struct, did) | Def::Def(DefKind::Union, did) => {\n                 self.adt_def(did).non_enum_variant()\n             }\n-            Def::Ctor(variant_ctor_did, CtorOf::Variant, ..) => {\n+            Def::Def(DefKind::Ctor(CtorOf::Variant, ..), variant_ctor_did) => {\n                 let variant_did = self.parent(variant_ctor_did).unwrap();\n                 let enum_did = self.parent(variant_did).unwrap();\n                 self.adt_def(enum_did).variant_with_ctor_id(variant_ctor_did)\n             }\n-            Def::Ctor(ctor_did, CtorOf::Struct, ..) => {\n+            Def::Def(DefKind::Ctor(CtorOf::Struct, ..), ctor_did) => {\n                 let struct_did = self.parent(ctor_did).expect(\"struct ctor has no parent\");\n                 self.adt_def(struct_did).non_enum_variant()\n             }\n@@ -3044,7 +3046,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// `DefId` of the impl that the method belongs to; otherwise, returns `None`.\n     pub fn impl_of_method(self, def_id: DefId) -> Option<DefId> {\n         let item = if def_id.krate != LOCAL_CRATE {\n-            if let Some(Def::Method(_)) = self.describe_def(def_id) {\n+            if let Some(Def::Def(DefKind::Method, _)) = self.describe_def(def_id) {\n                 Some(self.associated_item(def_id))\n             } else {\n                 None"}, {"sha": "8f583f3546be4da49d785e549c961760b901aa85", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -21,7 +21,7 @@\n //! If you define a new `LateLintPass`, you will also need to add it to the\n //! `late_lint_methods!` invocation in `lib.rs`.\n \n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Def, DefKind};\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::ty::{self, Ty};\n use rustc::{lint, util};\n@@ -916,7 +916,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n             } else {\n                 return None;\n             };\n-            if let Def::Fn(did) = def {\n+            if let Def::Def(DefKind::Fn, did) = def {\n                 if !def_id_is_transmute(cx, did) {\n                     return None;\n                 }\n@@ -1072,7 +1072,7 @@ impl TypeAliasBounds {\n                 match ty.node {\n                     hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n                         match path.def {\n-                            Def::TyParam(_) => true,\n+                            Def::Def(DefKind::TyParam, _) => true,\n                             _ => false\n                         }\n                     }"}, {"sha": "7e6af43c5003ffa3155261a5595105efe24b464c", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -1,5 +1,5 @@\n use rustc::hir::{self, GenericParamKind, PatKind};\n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Def, DefKind};\n use rustc::hir::intravisit::FnKind;\n use rustc::lint;\n use rustc::ty;\n@@ -415,7 +415,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n     fn check_pat(&mut self, cx: &LateContext<'_, '_>, p: &hir::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n         if let PatKind::Path(hir::QPath::Resolved(None, ref path)) = p.node {\n-            if let Def::Const(..) = path.def {\n+            if let Def::Def(DefKind::Const, _) = path.def {\n                 if path.segments.len() == 1 {\n                     NonUpperCaseGlobals::check_upper_case(\n                         cx,"}, {"sha": "9962caf0731739435c78e646c07281be2ad6b501", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -1,4 +1,4 @@\n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Def, DefKind};\n use rustc::hir::def_id::DefId;\n use rustc::lint;\n use rustc::ty;\n@@ -93,7 +93,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n                     hir::ExprKind::Path(ref qpath) => {\n                         let def = cx.tables.qpath_def(qpath, callee.hir_id);\n                         match def {\n-                            Def::Fn(_) | Def::Method(_) => Some(def),\n+                            Def::Def(DefKind::Fn, _) | Def::Def(DefKind::Method, _) => Some(def),\n                             // `Def::Local` if it was a closure, for which we\n                             // do not currently support must-use linting\n                             _ => None"}, {"sha": "cc7a72c75935501ee6085e9e64d0fd2864823930", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 35, "deletions": 29, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -8,7 +8,7 @@ use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash, Definitions};\n use rustc::hir;\n use rustc::middle::cstore::LinkagePreference;\n use rustc::middle::exported_symbols::{ExportedSymbol, SymbolExportLevel};\n-use rustc::hir::def::{self, Def, CtorOf, CtorKind};\n+use rustc::hir::def::{self, Def, DefKind, CtorOf, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, DefIndex, DefIndexAddressSpace,\n                          CRATE_DEF_INDEX, LOCAL_CRATE, LocalDefId};\n use rustc::hir::map::definitions::DefPathTable;\n@@ -401,30 +401,30 @@ impl<'a, 'tcx> MetadataBlob {\n impl<'tcx> EntryKind<'tcx> {\n     fn to_def(&self, did: DefId) -> Option<Def> {\n         Some(match *self {\n-            EntryKind::Const(..) => Def::Const(did),\n-            EntryKind::AssociatedConst(..) => Def::AssociatedConst(did),\n+            EntryKind::Const(..) => Def::Def(DefKind::Const, did),\n+            EntryKind::AssociatedConst(..) => Def::Def(DefKind::AssociatedConst, did),\n             EntryKind::ImmStatic |\n             EntryKind::MutStatic |\n             EntryKind::ForeignImmStatic |\n-            EntryKind::ForeignMutStatic => Def::Static(did),\n-            EntryKind::Struct(_, _) => Def::Struct(did),\n-            EntryKind::Union(_, _) => Def::Union(did),\n+            EntryKind::ForeignMutStatic => Def::Def(DefKind::Static, did),\n+            EntryKind::Struct(_, _) => Def::Def(DefKind::Struct, did),\n+            EntryKind::Union(_, _) => Def::Def(DefKind::Union, did),\n             EntryKind::Fn(_) |\n-            EntryKind::ForeignFn(_) => Def::Fn(did),\n-            EntryKind::Method(_) => Def::Method(did),\n-            EntryKind::Type => Def::TyAlias(did),\n-            EntryKind::TypeParam => Def::TyParam(did),\n-            EntryKind::ConstParam => Def::ConstParam(did),\n-            EntryKind::Existential => Def::Existential(did),\n-            EntryKind::AssociatedType(_) => Def::AssociatedTy(did),\n-            EntryKind::AssociatedExistential(_) => Def::AssociatedExistential(did),\n-            EntryKind::Mod(_) => Def::Mod(did),\n-            EntryKind::Variant(_) => Def::Variant(did),\n-            EntryKind::Trait(_) => Def::Trait(did),\n-            EntryKind::TraitAlias(_) => Def::TraitAlias(did),\n-            EntryKind::Enum(..) => Def::Enum(did),\n-            EntryKind::MacroDef(_) => Def::Macro(did, MacroKind::Bang),\n-            EntryKind::ForeignType => Def::ForeignTy(did),\n+            EntryKind::ForeignFn(_) => Def::Def(DefKind::Fn, did),\n+            EntryKind::Method(_) => Def::Def(DefKind::Method, did),\n+            EntryKind::Type => Def::Def(DefKind::TyAlias, did),\n+            EntryKind::TypeParam => Def::Def(DefKind::TyParam, did),\n+            EntryKind::ConstParam => Def::Def(DefKind::ConstParam, did),\n+            EntryKind::Existential => Def::Def(DefKind::Existential, did),\n+            EntryKind::AssociatedType(_) => Def::Def(DefKind::AssociatedTy, did),\n+            EntryKind::AssociatedExistential(_) => Def::Def(DefKind::AssociatedExistential, did),\n+            EntryKind::Mod(_) => Def::Def(DefKind::Mod, did),\n+            EntryKind::Variant(_) => Def::Def(DefKind::Variant, did),\n+            EntryKind::Trait(_) => Def::Def(DefKind::Trait, did),\n+            EntryKind::TraitAlias(_) => Def::Def(DefKind::TraitAlias, did),\n+            EntryKind::Enum(..) => Def::Def(DefKind::Enum, did),\n+            EntryKind::MacroDef(_) => Def::Def(DefKind::Macro(MacroKind::Bang), did),\n+            EntryKind::ForeignType => Def::Def(DefKind::ForeignTy, did),\n \n             EntryKind::ForeignMod |\n             EntryKind::GlobalAsm |\n@@ -512,7 +512,7 @@ impl<'a, 'tcx> CrateMetadata {\n             self.entry(index).kind.to_def(self.local_def_id(index))\n         } else {\n             let kind = self.proc_macros.as_ref().unwrap()[index.to_proc_macro_index()].1.kind();\n-            Some(Def::Macro(self.local_def_id(index), kind))\n+            Some(Def::Def(DefKind::Macro(kind), self.local_def_id(index)))\n         }\n     }\n \n@@ -743,12 +743,12 @@ impl<'a, 'tcx> CrateMetadata {\n              */\n             if id == CRATE_DEF_INDEX {\n                 for (id, &(name, ref ext)) in proc_macros.iter().enumerate() {\n-                    let def = Def::Macro(\n+                    let def = Def::Def(\n+                        DefKind::Macro(ext.kind()),\n                         DefId {\n                             krate: self.cnum,\n                             index: DefIndex::from_proc_macro_index(id),\n                         },\n-                        ext.kind()\n                     );\n                     let ident = Ident::with_empty_ctxt(name);\n                     callback(def::Export {\n@@ -815,22 +815,28 @@ impl<'a, 'tcx> CrateMetadata {\n                     // For non-re-export structs and variants add their constructors to children.\n                     // Re-export lists automatically contain constructors when necessary.\n                     match def {\n-                        Def::Struct(..) => {\n+                        Def::Def(DefKind::Struct, _) => {\n                             if let Some(ctor_def_id) = self.get_ctor_def_id(child_index) {\n                                 let ctor_kind = self.get_ctor_kind(child_index);\n-                                let ctor_def = Def::Ctor(ctor_def_id, CtorOf::Struct, ctor_kind);\n+                                let ctor_def = Def::Def(\n+                                    DefKind::Ctor(CtorOf::Struct, ctor_kind),\n+                                    ctor_def_id,\n+                                );\n                                 let vis = self.get_visibility(ctor_def_id.index);\n                                 callback(def::Export { def: ctor_def, vis, ident, span });\n                             }\n                         }\n-                        Def::Variant(def_id) => {\n+                        Def::Def(DefKind::Variant, def_id) => {\n                             // Braced variants, unlike structs, generate unusable names in\n                             // value namespace, they are reserved for possible future use.\n                             // It's ok to use the variant's id as a ctor id since an\n                             // error will be reported on any use of such resolution anyway.\n                             let ctor_def_id = self.get_ctor_def_id(child_index).unwrap_or(def_id);\n                             let ctor_kind = self.get_ctor_kind(child_index);\n-                            let ctor_def = Def::Ctor(ctor_def_id, CtorOf::Variant, ctor_kind);\n+                            let ctor_def = Def::Def(\n+                                DefKind::Ctor(CtorOf::Variant, ctor_kind),\n+                                ctor_def_id,\n+                            );\n                             let mut vis = self.get_visibility(ctor_def_id.index);\n                             if ctor_def_id == def_id && vis == ty::Visibility::Public {\n                                 // For non-exhaustive variants lower the constructor visibility to\n@@ -854,7 +860,7 @@ impl<'a, 'tcx> CrateMetadata {\n         if let EntryKind::Mod(data) = item.kind {\n             for exp in data.decode((self, sess)).reexports.decode((self, sess)) {\n                 match exp.def {\n-                    Def::Macro(..) => {}\n+                    Def::Def(DefKind::Macro(..), _) => {}\n                     _ if macros_only => continue,\n                     _ => {}\n                 }"}, {"sha": "4a636fa87c6ddd705f024034ca5aa5daa2b5daff", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/region_name.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fregion_name.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -4,6 +4,7 @@ use crate::borrow_check::nll::universal_regions::DefiningTy;\n use crate::borrow_check::nll::ToRegionVid;\n use crate::borrow_check::Upvar;\n use rustc::hir;\n+use rustc::hir::def::{Def, DefKind};\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n use rustc::mir::Mir;\n@@ -496,7 +497,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                         // be the same as those of the ADT.\n                         // FIXME: We should be able to do something similar to\n                         // match_adt_and_segment in this case.\n-                        hir::def::Def::TyAlias(_) => (),\n+                        Def::Def(DefKind::TyAlias, _) => (),\n                         _ => if let Some(last_segment) = path.segments.last() {\n                             if let Some(name) = self.match_adt_and_segment(\n                                 substs,"}, {"sha": "f4c7b40647c7bbdb70166104aac63d6d9eb45964", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -6,7 +6,7 @@ use std::borrow::{Borrow, Cow};\n use std::hash::Hash;\n use std::collections::hash_map::Entry;\n \n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Def, DefKind};\n use rustc::hir::def_id::DefId;\n use rustc::mir::interpret::{ConstEvalErr, ErrorHandled};\n use rustc::mir;\n@@ -641,7 +641,7 @@ pub fn const_eval_raw_provider<'a, 'tcx>(\n                 // note that validation may still cause a hard error on this very same constant,\n                 // because any code that existed before validation could not have failed validation\n                 // thus preventing such a hard error from being a backwards compatibility hazard\n-                Some(Def::Const(_)) | Some(Def::AssociatedConst(_)) => {\n+                Some(Def::Def(DefKind::Const, _)) | Some(Def::Def(DefKind::AssociatedConst, _)) => {\n                     let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n                     err.report_as_lint(\n                         tcx.at(tcx.def_span(def_id)),"}, {"sha": "b1c3cdc9dc852eb831148448762eac92b16feed8", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -4,7 +4,7 @@ use crate::hair::cx::block;\n use crate::hair::cx::to_ref::ToRef;\n use crate::hair::util::UserAnnotatedTyHelpers;\n use rustc_data_structures::indexed_vec::Idx;\n-use rustc::hir::def::{CtorOf, Def, CtorKind};\n+use rustc::hir::def::{CtorOf, Def, DefKind, CtorKind};\n use rustc::mir::interpret::{GlobalId, ErrorHandled, ConstValue};\n use rustc::ty::{self, AdtKind, Ty};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability, PointerCast};\n@@ -250,7 +250,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     // Tuple-like ADTs are represented as ExprKind::Call. We convert them here.\n                     expr_ty.ty_adt_def().and_then(|adt_def| {\n                         match path.def {\n-                            Def::Ctor(ctor_id, _, CtorKind::Fn) =>\n+                            Def::Def(DefKind::Ctor(_, CtorKind::Fn), ctor_id) =>\n                                 Some((adt_def, adt_def.variant_index_with_ctor_id(ctor_id))),\n                             Def::SelfCtor(..) => Some((adt_def, VariantIdx::new(0))),\n                             _ => None,\n@@ -470,7 +470,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         AdtKind::Enum => {\n                             let def = cx.tables().qpath_def(qpath, expr.hir_id);\n                             match def {\n-                                Def::Variant(variant_id) => {\n+                                Def::Def(DefKind::Variant, variant_id) => {\n                                     assert!(base.is_none());\n \n                                     let index = adt.variant_index_with_id(variant_id);\n@@ -664,7 +664,10 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         .ty_adt_def()\n                         .and_then(|adt_def| {\n                         match def {\n-                            Def::Ctor(variant_ctor_id, CtorOf::Variant, CtorKind::Const) => {\n+                            Def::Def(\n+                                DefKind::Ctor(CtorOf::Variant, CtorKind::Const),\n+                                variant_ctor_id,\n+                            ) => {\n                                 let idx = adt_def.variant_index_with_ctor_id(variant_ctor_id);\n                                 let (d, o) = adt_def.discriminant_def_for_variant(idx);\n                                 use rustc::ty::util::IntTypeExt;\n@@ -792,17 +795,18 @@ fn user_substs_applied_to_def(\n         // A reference to something callable -- e.g., a fn, method, or\n         // a tuple-struct or tuple-variant. This has the type of a\n         // `Fn` but with the user-given substitutions.\n-        Def::Fn(_) |\n-        Def::Method(_) |\n-        Def::Ctor(_, _, CtorKind::Fn) |\n-        Def::Const(_) |\n-        Def::AssociatedConst(_) => cx.tables().user_provided_types().get(hir_id).map(|u_ty| *u_ty),\n+        Def::Def(DefKind::Fn, _) |\n+        Def::Def(DefKind::Method, _) |\n+        Def::Def(DefKind::Ctor(_, CtorKind::Fn), _) |\n+        Def::Def(DefKind::Const, _) |\n+        Def::Def(DefKind::AssociatedConst, _) =>\n+            cx.tables().user_provided_types().get(hir_id).map(|u_ty| *u_ty),\n \n         // A unit struct/variant which is used as a value (e.g.,\n         // `None`). This has the type of the enum/struct that defines\n         // this variant -- but with the substitutions given by the\n         // user.\n-        Def::Ctor(_, _, CtorKind::Const) =>\n+        Def::Def(DefKind::Ctor(_, CtorKind::Const), _) =>\n             cx.user_substs_applied_to_ty_of_hir_id(hir_id),\n \n         // `Self` is used in expression as a tuple struct constructor or an unit struct constructor\n@@ -895,9 +899,9 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     let substs = cx.tables().node_substs(expr.hir_id);\n     match def {\n         // A regular function, constructor function or a constant.\n-        Def::Fn(_) |\n-        Def::Method(_) |\n-        Def::Ctor(_, _, CtorKind::Fn) |\n+        Def::Def(DefKind::Fn, _) |\n+        Def::Def(DefKind::Method, _) |\n+        Def::Def(DefKind::Ctor(_, CtorKind::Fn), _) |\n         Def::SelfCtor(..) => {\n             let user_ty = user_substs_applied_to_def(cx, expr.hir_id, &def);\n             debug!(\"convert_path_expr: user_ty={:?}\", user_ty);\n@@ -909,7 +913,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        Def::ConstParam(def_id) => {\n+        Def::Def(DefKind::ConstParam, def_id) => {\n             let node_id = cx.tcx.hir().as_local_node_id(def_id).unwrap();\n             let item_id = cx.tcx.hir().get_parent_node(node_id);\n             let item_def_id = cx.tcx.hir().local_def_id(item_id);\n@@ -928,8 +932,8 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        Def::Const(def_id) |\n-        Def::AssociatedConst(def_id) => {\n+        Def::Def(DefKind::Const, def_id) |\n+        Def::Def(DefKind::AssociatedConst, def_id) => {\n             let user_ty = user_substs_applied_to_def(cx, expr.hir_id, &def);\n             debug!(\"convert_path_expr: (const) user_ty={:?}\", user_ty);\n             ExprKind::Literal {\n@@ -941,7 +945,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         },\n \n-        Def::Ctor(def_id, _, CtorKind::Const) => {\n+        Def::Def(DefKind::Ctor(_, CtorKind::Const), def_id) => {\n             let user_provided_types = cx.tables.user_provided_types();\n             let user_provided_type = user_provided_types.get(expr.hir_id).map(|u_ty| *u_ty);\n             debug!(\"convert_path_expr: user_provided_type={:?}\", user_provided_type);\n@@ -963,7 +967,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             }\n         }\n \n-        Def::Static(id) => ExprKind::StaticRef { id },\n+        Def::Def(DefKind::Static, id) => ExprKind::StaticRef { id },\n \n         Def::Local(..) | Def::Upvar(..) => convert_var(cx, expr, def),\n "}, {"sha": "90551d8d167c4c59981c008b7aaae9fa3efa3d3b", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -18,7 +18,7 @@ use rustc::ty::{CanonicalUserType, CanonicalUserTypeAnnotation, CanonicalUserTyp\n use rustc::ty::subst::{SubstsRef, Kind};\n use rustc::ty::layout::VariantIdx;\n use rustc::hir::{self, PatKind, RangeEnd};\n-use rustc::hir::def::{CtorOf, Def, CtorKind};\n+use rustc::hir::def::{CtorOf, Def, DefKind, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n \n use rustc_data_structures::indexed_vec::Idx;\n@@ -733,15 +733,15 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         subpatterns: Vec<FieldPattern<'tcx>>,\n     ) -> PatternKind<'tcx> {\n         let def = match def {\n-            Def::Ctor(variant_ctor_id, CtorOf::Variant, ..) => {\n+            Def::Def(DefKind::Ctor(CtorOf::Variant, ..), variant_ctor_id) => {\n                 let variant_id = self.tcx.parent(variant_ctor_id).unwrap();\n-                Def::Variant(variant_id)\n+                Def::Def(DefKind::Variant, variant_id)\n             },\n             def => def,\n         };\n \n         let mut kind = match def {\n-            Def::Variant(variant_id) => {\n+            Def::Def(DefKind::Variant, variant_id) => {\n                 let enum_id = self.tcx.parent(variant_id).unwrap();\n                 let adt_def = self.tcx.adt_def(enum_id);\n                 if adt_def.is_enum() {\n@@ -764,8 +764,13 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 }\n             }\n \n-            Def::Struct(..) | Def::Ctor(_, CtorOf::Struct, ..) | Def::Union(..) |\n-            Def::TyAlias(..) | Def::AssociatedTy(..) | Def::SelfTy(..) | Def::SelfCtor(..) => {\n+            Def::Def(DefKind::Struct, _)\n+            | Def::Def(DefKind::Ctor(CtorOf::Struct, ..), _)\n+            | Def::Def(DefKind::Union, _)\n+            | Def::Def(DefKind::TyAlias, _)\n+            | Def::Def(DefKind::AssociatedTy, _)\n+            | Def::SelfTy(..)\n+            | Def::SelfCtor(..) => {\n                 PatternKind::Leaf { subpatterns }\n             }\n \n@@ -805,11 +810,11 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         let ty = self.tables.node_type(id);\n         let def = self.tables.qpath_def(qpath, id);\n         let is_associated_const = match def {\n-            Def::AssociatedConst(_) => true,\n+            Def::Def(DefKind::AssociatedConst, _) => true,\n             _ => false,\n         };\n         let kind = match def {\n-            Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n+            Def::Def(DefKind::Const, def_id) | Def::Def(DefKind::AssociatedConst, def_id) => {\n                 let substs = self.tables.node_substs(id);\n                 match ty::Instance::resolve(\n                     self.tcx,"}, {"sha": "7a8530b31ce3d142fe7ff48107c134942788fc81", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -4,7 +4,7 @@ use std::mem;\n \n use syntax::source_map::{self, Span, DUMMY_SP};\n use rustc::hir::def_id::DefId;\n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Def, DefKind};\n use rustc::mir;\n use rustc::ty::layout::{\n     self, Size, Align, HasDataLayout, LayoutOf, TyLayout\n@@ -503,7 +503,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tc\n             // Now mark those locals as dead that we do not want to initialize\n             match self.tcx.describe_def(instance.def_id()) {\n                 // statics and constants don't have `Storage*` statements, no need to look for them\n-                Some(Def::Static(..)) | Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => {},\n+                Some(Def::Def(DefKind::Static, _))\n+                | Some(Def::Def(DefKind::Const, _))\n+                | Some(Def::Def(DefKind::AssociatedConst, _)) => {},\n                 _ => {\n                     trace!(\"push_stack_frame: {:?}: num_bbs: {}\", span, mir.basic_blocks().len());\n                     for block in mir.basic_blocks() {"}, {"sha": "a114c18ace8b6f0287930eca57666ab3d8611df2", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -1,7 +1,7 @@\n //! Propagates constants for early reporting of statically known\n //! assertion failures\n \n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Def, DefKind};\n use rustc::mir::{\n     Constant, Location, Place, PlaceBase, Mir, Operand, Rvalue, Local,\n     NullOp, UnOp, StatementKind, Statement, LocalKind, Static, StaticKind,\n@@ -43,7 +43,7 @@ impl MirPass for ConstProp {\n \n         let is_fn_like = FnLikeNode::from_node(tcx.hir().get_by_hir_id(hir_id)).is_some();\n         let is_assoc_const = match tcx.describe_def(source.def_id()) {\n-            Some(Def::AssociatedConst(_)) => true,\n+            Some(Def::Def(DefKind::AssociatedConst, _)) => true,\n             _ => false,\n         };\n "}, {"sha": "790d3c6624a38f39a9023eec545336ef836881e8", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -575,19 +575,22 @@ fn write_mir_sig(\n     mir: &Mir<'_>,\n     w: &mut dyn Write,\n ) -> io::Result<()> {\n-    use rustc::hir::def::Def;\n+    use rustc::hir::def::{Def, DefKind};\n \n     trace!(\"write_mir_sig: {:?}\", src.instance);\n     let descr = tcx.describe_def(src.def_id());\n     let is_function = match descr {\n-        Some(Def::Fn(_)) | Some(Def::Method(_)) | Some(Def::Ctor(..)) => true,\n+        Some(Def::Def(DefKind::Fn, _))\n+        | Some(Def::Def(DefKind::Method, _))\n+        | Some(Def::Def(DefKind::Ctor(..), _)) => true,\n         _ => tcx.is_closure(src.def_id()),\n     };\n     match (descr, src.promoted) {\n         (_, Some(i)) => write!(w, \"{:?} in \", i)?,\n-        (Some(Def::Const(_)), _) | (Some(Def::AssociatedConst(_)), _) => write!(w, \"const \")?,\n-        (Some(Def::Static(def_id)), _) =>\n-            write!(w, \"static {}\", if tcx.is_mutable_static(def_id) { \"mut \" } else { \"\" })?,\n+        (Some(Def::Def(DefKind::Const, _)), _)\n+        | (Some(Def::Def(DefKind::AssociatedConst, _)), _) => write!(w, \"const \")?,\n+        (Some(Def::Def(DefKind::Static, _)), _) =>\n+            write!(w, \"static {}\", if tcx.is_mutable_static(src.def_id()) { \"mut \" } else { \"\" })?,\n         (_, _) if is_function => write!(w, \"fn \")?,\n         (None, _) => {}, // things like anon const, not an item\n         _ => bug!(\"Unexpected def description {:?}\", descr),"}, {"sha": "57cea198c729803c1471d16c9e66a95859baa984", "filename": "src/librustc_passes/rvalue_promotion.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_passes%2Frvalue_promotion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_passes%2Frvalue_promotion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Frvalue_promotion.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -15,7 +15,7 @@\n // by borrowck::gather_loans\n \n use rustc::ty::cast::CastTy;\n-use rustc::hir::def::{Def, CtorKind};\n+use rustc::hir::def::{Def, DefKind, CtorKind};\n use rustc::hir::def_id::DefId;\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n@@ -321,14 +321,17 @@ fn check_expr_kind<'a, 'tcx>(\n         hir::ExprKind::Path(ref qpath) => {\n             let def = v.tables.qpath_def(qpath, e.hir_id);\n             match def {\n-                Def::Ctor(..) | Def::Fn(..) | Def::Method(..) | Def::SelfCtor(..) =>\n+                Def::Def(DefKind::Ctor(..), _)\n+                | Def::Def(DefKind::Fn, _)\n+                | Def::Def(DefKind::Method, _)\n+                | Def::SelfCtor(..) =>\n                     Promotable,\n \n                 // References to a static that are themselves within a static\n                 // are inherently promotable with the exception\n                 //  of \"#[thread_local]\" statics, which may not\n                 // outlive the current function\n-                Def::Static(did) => {\n+                Def::Def(DefKind::Static, did) => {\n \n                     if v.in_static {\n                         for attr in &v.tcx.get_attrs(did)[..] {\n@@ -346,8 +349,8 @@ fn check_expr_kind<'a, 'tcx>(\n                     }\n                 }\n \n-                Def::Const(did) |\n-                Def::AssociatedConst(did) => {\n+                Def::Def(DefKind::Const, did) |\n+                Def::Def(DefKind::AssociatedConst, did) => {\n                     let promotable = if v.tcx.trait_of_item(did).is_some() {\n                         // Don't peek inside trait associated constants.\n                         NotPromotable\n@@ -386,10 +389,10 @@ fn check_expr_kind<'a, 'tcx>(\n                 Def::Err\n             };\n             let def_result = match def {\n-                Def::Ctor(_, _, CtorKind::Fn) |\n+                Def::Def(DefKind::Ctor(_, CtorKind::Fn), _) |\n                 Def::SelfCtor(..) => Promotable,\n-                Def::Fn(did) => v.handle_const_fn_call(did),\n-                Def::Method(did) => {\n+                Def::Def(DefKind::Fn, did) => v.handle_const_fn_call(did),\n+                Def::Def(DefKind::Method, did) => {\n                     match v.tcx.associated_item(did).container {\n                         ty::ImplContainer(_) => v.handle_const_fn_call(did),\n                         ty::TraitContainer(_) => NotPromotable,"}, {"sha": "b971de06bbf3db9e5c2be72c148f2aabb6532f14", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -12,7 +12,7 @@\n \n use rustc::bug;\n use rustc::hir::{self, Node, PatKind, AssociatedItemKind};\n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Def, DefKind};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefId};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::DeepVisitor;\n@@ -1107,9 +1107,9 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n     fn visit_qpath(&mut self, qpath: &'tcx hir::QPath, id: hir::HirId, span: Span) {\n         let def = match *qpath {\n             hir::QPath::Resolved(_, ref path) => match path.def {\n-                Def::Method(..) | Def::AssociatedConst(..) |\n-                Def::AssociatedTy(..) | Def::AssociatedExistential(..) |\n-                Def::Static(..) => Some(path.def),\n+                Def::Def(DefKind::Method, _) | Def::Def(DefKind::AssociatedConst, _) |\n+                Def::Def(DefKind::AssociatedTy, _) | Def::Def(DefKind::AssociatedExistential, _) |\n+                Def::Def(DefKind::Static, _) => Some(path.def),\n                 _ => None,\n             }\n             hir::QPath::TypeRelative(..) => {\n@@ -1118,7 +1118,9 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         };\n         if let Some(def) = def {\n             let def_id = def.def_id();\n-            let is_local_static = if let Def::Static(..) = def { def_id.is_local() } else { false };\n+            let is_local_static = if let Def::Def(DefKind::Static, _) = def {\n+                def_id.is_local()\n+            } else { false };\n             if !self.item_is_accessible(def_id) && !is_local_static {\n                 let name = match *qpath {\n                     hir::QPath::Resolved(_, ref path) => path.to_string(),"}, {"sha": "5c7e51d4057f0bbf3a4c0d2c6d7e2eaea1ff6b5e", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 50, "deletions": 37, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -424,7 +424,7 @@ impl<'a> Resolver<'a> {\n \n             ItemKind::Mod(..) => {\n                 let def_id = self.definitions.local_def_id(item.id);\n-                let module_kind = ModuleKind::Def(Def::Mod(def_id), ident.name);\n+                let module_kind = ModuleKind::Def(Def::Def(DefKind::Mod, def_id), ident.name);\n                 let module = self.arenas.alloc_module(ModuleData {\n                     no_implicit_prelude: parent.no_implicit_prelude || {\n                         attr::contains_name(&item.attrs, \"no_implicit_prelude\")\n@@ -443,29 +443,32 @@ impl<'a> Resolver<'a> {\n \n             // These items live in the value namespace.\n             ItemKind::Static(..) => {\n-                let def = Def::Static(self.definitions.local_def_id(item.id));\n+                let def = Def::Def(DefKind::Static, self.definitions.local_def_id(item.id));\n                 self.define(parent, ident, ValueNS, (def, vis, sp, expansion));\n             }\n             ItemKind::Const(..) => {\n-                let def = Def::Const(self.definitions.local_def_id(item.id));\n+                let def = Def::Def(DefKind::Const, self.definitions.local_def_id(item.id));\n                 self.define(parent, ident, ValueNS, (def, vis, sp, expansion));\n             }\n             ItemKind::Fn(..) => {\n-                let def = Def::Fn(self.definitions.local_def_id(item.id));\n+                let def = Def::Def(DefKind::Fn, self.definitions.local_def_id(item.id));\n                 self.define(parent, ident, ValueNS, (def, vis, sp, expansion));\n \n                 // Functions introducing procedural macros reserve a slot\n                 // in the macro namespace as well (see #52225).\n                 if attr::contains_name(&item.attrs, \"proc_macro\") ||\n                    attr::contains_name(&item.attrs, \"proc_macro_attribute\") {\n-                    let def = Def::Macro(def.def_id(), MacroKind::ProcMacroStub);\n+                    let def = Def::Def(DefKind::Macro(MacroKind::ProcMacroStub), def.def_id());\n                     self.define(parent, ident, MacroNS, (def, vis, sp, expansion));\n                 }\n                 if let Some(attr) = attr::find_by_name(&item.attrs, \"proc_macro_derive\") {\n                     if let Some(trait_attr) =\n                             attr.meta_item_list().and_then(|list| list.get(0).cloned()) {\n                         if let Some(ident) = trait_attr.ident() {\n-                            let def = Def::Macro(def.def_id(), MacroKind::ProcMacroStub);\n+                            let def = Def::Def(\n+                                DefKind::Macro(MacroKind::ProcMacroStub),\n+                                def.def_id(),\n+                            );\n                             self.define(parent, ident, MacroNS, (def, vis, ident.span, expansion));\n                         }\n                     }\n@@ -474,17 +477,17 @@ impl<'a> Resolver<'a> {\n \n             // These items live in the type namespace.\n             ItemKind::Ty(..) => {\n-                let def = Def::TyAlias(self.definitions.local_def_id(item.id));\n+                let def = Def::Def(DefKind::TyAlias, self.definitions.local_def_id(item.id));\n                 self.define(parent, ident, TypeNS, (def, vis, sp, expansion));\n             }\n \n             ItemKind::Existential(_, _) => {\n-                let def = Def::Existential(self.definitions.local_def_id(item.id));\n+                let def = Def::Def(DefKind::Existential, self.definitions.local_def_id(item.id));\n                 self.define(parent, ident, TypeNS, (def, vis, sp, expansion));\n             }\n \n             ItemKind::Enum(ref enum_definition, _) => {\n-                let def = Def::Enum(self.definitions.local_def_id(item.id));\n+                let def = Def::Def(DefKind::Enum, self.definitions.local_def_id(item.id));\n                 let module_kind = ModuleKind::Def(def, ident.name);\n                 let module = self.new_module(parent,\n                                              module_kind,\n@@ -499,15 +502,15 @@ impl<'a> Resolver<'a> {\n             }\n \n             ItemKind::TraitAlias(..) => {\n-                let def = Def::TraitAlias(self.definitions.local_def_id(item.id));\n+                let def = Def::Def(DefKind::TraitAlias, self.definitions.local_def_id(item.id));\n                 self.define(parent, ident, TypeNS, (def, vis, sp, expansion));\n             }\n \n             // These items live in both the type and value namespaces.\n             ItemKind::Struct(ref struct_def, _) => {\n                 // Define a name in the type namespace.\n                 let def_id = self.definitions.local_def_id(item.id);\n-                let def = Def::Struct(def_id);\n+                let def = Def::Def(DefKind::Struct, def_id);\n                 self.define(parent, ident, TypeNS, (def, vis, sp, expansion));\n \n                 let mut ctor_vis = vis;\n@@ -534,16 +537,17 @@ impl<'a> Resolver<'a> {\n                 // If this is a tuple or unit struct, define a name\n                 // in the value namespace as well.\n                 if let Some(ctor_node_id) = struct_def.ctor_id() {\n-                    let ctor_def = Def::Ctor(self.definitions.local_def_id(ctor_node_id),\n-                                             CtorOf::Struct,\n-                                             CtorKind::from_ast(struct_def));\n+                    let ctor_def = Def::Def(\n+                        DefKind::Ctor(CtorOf::Struct, CtorKind::from_ast(struct_def)),\n+                        self.definitions.local_def_id(ctor_node_id),\n+                    );\n                     self.define(parent, ident, ValueNS, (ctor_def, ctor_vis, sp, expansion));\n                     self.struct_constructors.insert(def.def_id(), (ctor_def, ctor_vis));\n                 }\n             }\n \n             ItemKind::Union(ref vdata, _) => {\n-                let def = Def::Union(self.definitions.local_def_id(item.id));\n+                let def = Def::Def(DefKind::Union, self.definitions.local_def_id(item.id));\n                 self.define(parent, ident, TypeNS, (def, vis, sp, expansion));\n \n                 // Record field names for error reporting.\n@@ -561,7 +565,7 @@ impl<'a> Resolver<'a> {\n                 let def_id = self.definitions.local_def_id(item.id);\n \n                 // Add all the items within to a new module.\n-                let module_kind = ModuleKind::Def(Def::Trait(def_id), ident.name);\n+                let module_kind = ModuleKind::Def(Def::Def(DefKind::Trait, def_id), ident.name);\n                 let module = self.new_module(parent,\n                                              module_kind,\n                                              parent.normal_ancestor_id,\n@@ -586,7 +590,7 @@ impl<'a> Resolver<'a> {\n \n         // Define a name in the type namespace.\n         let def_id = self.definitions.local_def_id(variant.node.id);\n-        let def = Def::Variant(def_id);\n+        let def = Def::Def(DefKind::Variant, def_id);\n         self.define(parent, ident, TypeNS, (def, vis, variant.span, expansion));\n \n         // If the variant is marked as non_exhaustive then lower the visibility to within the\n@@ -605,21 +609,21 @@ impl<'a> Resolver<'a> {\n         let ctor_node_id = variant.node.data.ctor_id().unwrap_or(variant.node.id);\n         let ctor_def_id = self.definitions.local_def_id(ctor_node_id);\n         let ctor_kind = CtorKind::from_ast(&variant.node.data);\n-        let ctor_def = Def::Ctor(ctor_def_id, CtorOf::Variant, ctor_kind);\n+        let ctor_def = Def::Def(DefKind::Ctor(CtorOf::Variant, ctor_kind), ctor_def_id);\n         self.define(parent, ident, ValueNS, (ctor_def, ctor_vis, variant.span, expansion));\n     }\n \n     /// Constructs the reduced graph for one foreign item.\n     fn build_reduced_graph_for_foreign_item(&mut self, item: &ForeignItem, expansion: Mark) {\n         let (def, ns) = match item.node {\n             ForeignItemKind::Fn(..) => {\n-                (Def::Fn(self.definitions.local_def_id(item.id)), ValueNS)\n+                (Def::Def(DefKind::Fn, self.definitions.local_def_id(item.id)), ValueNS)\n             }\n             ForeignItemKind::Static(..) => {\n-                (Def::Static(self.definitions.local_def_id(item.id)), ValueNS)\n+                (Def::Def(DefKind::Static, self.definitions.local_def_id(item.id)), ValueNS)\n             }\n             ForeignItemKind::Ty => {\n-                (Def::ForeignTy(self.definitions.local_def_id(item.id)), TypeNS)\n+                (Def::Def(DefKind::ForeignTy, self.definitions.local_def_id(item.id)), TypeNS)\n             }\n             ForeignItemKind::Macro(_) => unreachable!(),\n         };\n@@ -654,23 +658,30 @@ impl<'a> Resolver<'a> {\n         let ident = ident.gensym_if_underscore();\n         let expansion = Mark::root(); // FIXME(jseyfried) intercrate hygiene\n         match def {\n-            Def::Mod(def_id) | Def::Enum(def_id) => {\n+            Def::Def(DefKind::Mod, def_id) | Def::Def(DefKind::Enum, def_id) => {\n                 let module = self.new_module(parent,\n                                              ModuleKind::Def(def, ident.name),\n                                              def_id,\n                                              expansion,\n                                              span);\n                 self.define(parent, ident, TypeNS, (module, vis, DUMMY_SP, expansion));\n             }\n-            Def::Variant(..) | Def::TyAlias(..) | Def::ForeignTy(..) | Def::Existential(..) |\n-            Def::TraitAlias(..) | Def::PrimTy(..) | Def::ToolMod => {\n+            Def::Def(DefKind::Variant, _)\n+            | Def::Def(DefKind::TyAlias, _)\n+            | Def::Def(DefKind::ForeignTy, _)\n+            | Def::Def(DefKind::Existential, _)\n+            | Def::Def(DefKind::TraitAlias, _)\n+            | Def::PrimTy(..)\n+            | Def::ToolMod => {\n                 self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, expansion));\n             }\n-            Def::Fn(..) | Def::Static(..) | Def::Const(..) |\n-            Def::Ctor(_, CtorOf::Variant, ..) => {\n+            Def::Def(DefKind::Fn, _)\n+            | Def::Def(DefKind::Static, _)\n+            | Def::Def(DefKind::Const, _)\n+            | Def::Def(DefKind::Ctor(CtorOf::Variant, ..), _) => {\n                 self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, expansion));\n             }\n-            Def::Ctor(def_id, CtorOf::Struct, ..) => {\n+            Def::Def(DefKind::Ctor(CtorOf::Struct, ..), def_id) => {\n                 self.define(parent, ident, ValueNS, (def, vis, DUMMY_SP, expansion));\n \n                 if let Some(struct_def_id) =\n@@ -679,7 +690,7 @@ impl<'a> Resolver<'a> {\n                     self.struct_constructors.insert(struct_def_id, (def, vis));\n                 }\n             }\n-            Def::Trait(def_id) => {\n+            Def::Def(DefKind::Trait, def_id) => {\n                 let module_kind = ModuleKind::Def(def, ident.name);\n                 let module = self.new_module(parent,\n                                              module_kind,\n@@ -690,7 +701,9 @@ impl<'a> Resolver<'a> {\n \n                 for child in self.cstore.item_children_untracked(def_id, self.session) {\n                     let def = child.def.map_id(|_| panic!(\"unexpected id\"));\n-                    let ns = if let Def::AssociatedTy(..) = def { TypeNS } else { ValueNS };\n+                    let ns = if let Def::Def(DefKind::AssociatedTy, _) = def {\n+                        TypeNS\n+                    } else { ValueNS };\n                     self.define(module, child.ident, ns,\n                                 (def, ty::Visibility::Public, DUMMY_SP, expansion));\n \n@@ -701,14 +714,14 @@ impl<'a> Resolver<'a> {\n                 }\n                 module.populated.set(true);\n             }\n-            Def::Struct(def_id) | Def::Union(def_id) => {\n+            Def::Def(DefKind::Struct, def_id) | Def::Def(DefKind::Union, def_id) => {\n                 self.define(parent, ident, TypeNS, (def, vis, DUMMY_SP, expansion));\n \n                 // Record field names for error reporting.\n                 let field_names = self.cstore.struct_field_names_untracked(def_id);\n                 self.insert_field_names(def_id, field_names);\n             }\n-            Def::Macro(..) | Def::NonMacroAttr(..) => {\n+            Def::Def(DefKind::Macro(..), _) | Def::NonMacroAttr(..) => {\n                 self.define(parent, ident, MacroNS, (def, vis, DUMMY_SP, expansion));\n             }\n             _ => bug!(\"unexpected definition: {:?}\", def)\n@@ -733,7 +746,7 @@ impl<'a> Resolver<'a> {\n              Some(self.get_module(DefId { index: def_key.parent.unwrap(), ..def_id })))\n         };\n \n-        let kind = ModuleKind::Def(Def::Mod(def_id), name.as_symbol());\n+        let kind = ModuleKind::Def(Def::Def(DefKind::Mod, def_id), name.as_symbol());\n         let module =\n             self.arenas.alloc_module(ModuleData::new(parent, kind, def_id, Mark::root(), DUMMY_SP));\n         self.extern_module_map.insert((def_id, macros_only), module);\n@@ -754,11 +767,11 @@ impl<'a> Resolver<'a> {\n \n     pub fn get_macro(&mut self, def: Def) -> Lrc<SyntaxExtension> {\n         let def_id = match def {\n-            Def::Macro(def_id, ..) => def_id,\n+            Def::Def(DefKind::Macro(..), def_id) => def_id,\n             Def::NonMacroAttr(attr_kind) => return Lrc::new(SyntaxExtension::NonMacroAttr {\n                 mark_used: attr_kind == NonMacroAttrKind::Tool,\n             }),\n-            _ => panic!(\"expected `Def::Macro` or `Def::NonMacroAttr`\"),\n+            _ => panic!(\"expected `DefKind::Macro` or `Def::NonMacroAttr`\"),\n         };\n         if let Some(ext) = self.macro_map.get(&def_id) {\n             return ext.clone();\n@@ -1016,14 +1029,14 @@ impl<'a, 'b> Visitor<'a> for BuildReducedGraphVisitor<'a, 'b> {\n         // Add the item to the trait info.\n         let item_def_id = self.resolver.definitions.local_def_id(item.id);\n         let (def, ns) = match item.node {\n-            TraitItemKind::Const(..) => (Def::AssociatedConst(item_def_id), ValueNS),\n+            TraitItemKind::Const(..) => (Def::Def(DefKind::AssociatedConst, item_def_id), ValueNS),\n             TraitItemKind::Method(ref sig, _) => {\n                 if sig.decl.has_self() {\n                     self.resolver.has_self.insert(item_def_id);\n                 }\n-                (Def::Method(item_def_id), ValueNS)\n+                (Def::Def(DefKind::Method, item_def_id), ValueNS)\n             }\n-            TraitItemKind::Type(..) => (Def::AssociatedTy(item_def_id), TypeNS),\n+            TraitItemKind::Type(..) => (Def::Def(DefKind::AssociatedTy, item_def_id), TypeNS),\n             TraitItemKind::Macro(_) => bug!(),  // handled above\n         };\n "}, {"sha": "a86319801dcb853ea10c35ab77e30ad7a3f4f00b", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -2,7 +2,7 @@ use std::cmp::Reverse;\n \n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n use log::debug;\n-use rustc::hir::def::{self, CtorKind, Namespace::*};\n+use rustc::hir::def::{self, DefKind, CtorKind, Namespace::*};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n use rustc::session::{Session, config::nightly_options};\n use syntax::ast::{self, Expr, ExprKind, Ident};\n@@ -31,7 +31,9 @@ impl<'a> Resolver<'a> {\n         let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n         let ns = source.namespace();\n         let is_expected = &|def| source.is_expected(def);\n-        let is_enum_variant = &|def| if let Def::Variant(..) = def { true } else { false };\n+        let is_enum_variant = &|def| {\n+            if let Def::Def(DefKind::Variant, _) = def { true } else { false }\n+        };\n \n         // Make the base error.\n         let expected = source.descr_expected();\n@@ -117,7 +119,8 @@ impl<'a> Resolver<'a> {\n                 }\n             })\n             .collect::<Vec<_>>();\n-        if candidates.is_empty() && is_expected(Def::Enum(DefId::local(CRATE_DEF_INDEX))) {\n+        let crate_def_id = DefId::local(CRATE_DEF_INDEX);\n+        if candidates.is_empty() && is_expected(Def::Def(DefKind::Enum, crate_def_id)) {\n             let enum_candidates =\n                 self.lookup_import_candidates(ident, ns, is_enum_variant);\n             let mut enum_candidates = enum_candidates.iter()\n@@ -362,7 +365,7 @@ impl<'a> Resolver<'a> {\n         };\n \n         match (def, source) {\n-            (Def::Macro(..), _) => {\n+            (Def::Def(DefKind::Macro(..), _), _) => {\n                 err.span_suggestion(\n                     span,\n                     \"use `!` to invoke the macro\",\n@@ -373,17 +376,19 @@ impl<'a> Resolver<'a> {\n                     err.note(\"if you want the `try` keyword, you need to be in the 2018 edition\");\n                 }\n             }\n-            (Def::TyAlias(..), PathSource::Trait(_)) => {\n+            (Def::Def(DefKind::TyAlias, _), PathSource::Trait(_)) => {\n                 err.span_label(span, \"type aliases cannot be used as traits\");\n                 if nightly_options::is_nightly_build() {\n                     err.note(\"did you mean to use a trait alias?\");\n                 }\n             }\n-            (Def::Mod(..), PathSource::Expr(Some(parent))) => if !path_sep(err, &parent) {\n-                return false;\n-            },\n-            (Def::Enum(..), PathSource::TupleStruct)\n-                | (Def::Enum(..), PathSource::Expr(..))  => {\n+            (Def::Def(DefKind::Mod, _), PathSource::Expr(Some(parent))) => {\n+                if !path_sep(err, &parent) {\n+                    return false;\n+                }\n+            }\n+            (Def::Def(DefKind::Enum, _), PathSource::TupleStruct)\n+                | (Def::Def(DefKind::Enum, _), PathSource::Expr(..))  => {\n                 if let Some(variants) = self.collect_enum_variants(def) {\n                     if !variants.is_empty() {\n                         let msg = if variants.len() == 1 {\n@@ -403,7 +408,7 @@ impl<'a> Resolver<'a> {\n                     err.note(\"did you mean to use one of the enum's variants?\");\n                 }\n             },\n-            (Def::Struct(def_id), _) if ns == ValueNS => {\n+            (Def::Def(DefKind::Struct, def_id), _) if ns == ValueNS => {\n                 if let Some((ctor_def, ctor_vis))\n                         = self.struct_constructors.get(&def_id).cloned() {\n                     let accessible_ctor = self.is_accessible(ctor_vis);\n@@ -417,16 +422,17 @@ impl<'a> Resolver<'a> {\n                     bad_struct_syntax_suggestion();\n                 }\n             }\n-            (Def::Union(..), _) |\n-            (Def::Variant(..), _) |\n-            (Def::Ctor(_, _, CtorKind::Fictive), _) if ns == ValueNS => {\n+            (Def::Def(DefKind::Union, _), _) |\n+            (Def::Def(DefKind::Variant, _), _) |\n+            (Def::Def(DefKind::Ctor(_, CtorKind::Fictive), _), _) if ns == ValueNS => {\n                 bad_struct_syntax_suggestion();\n             }\n             (Def::SelfTy(..), _) if ns == ValueNS => {\n                 err.span_label(span, fallback_label);\n                 err.note(\"can't use `Self` as a constructor, you must use the implemented struct\");\n             }\n-            (Def::TyAlias(_), _) | (Def::AssociatedTy(..), _) if ns == ValueNS => {\n+            (Def::Def(DefKind::TyAlias, _), _)\n+            | (Def::Def(DefKind::AssociatedTy, _), _) if ns == ValueNS => {\n                 err.note(\"can't use a type alias as a constructor\");\n             }\n             _ => return false,\n@@ -622,7 +628,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         let resolutions = crate_module.resolutions.borrow();\n         let resolution = resolutions.get(&(ident, MacroNS))?;\n         let binding = resolution.borrow().binding()?;\n-        if let Def::Macro(_, MacroKind::Bang) = binding.def() {\n+        if let Def::Def(DefKind::Macro(MacroKind::Bang), _) = binding.def() {\n             let module_name = crate_module.kind.name().unwrap();\n             let import = match directive.subclass {\n                 ImportDirectiveSubclass::SingleImport { source, target, .. } if source != target =>"}, {"sha": "f7b8103a5210f773060b68b17e0aa56b84a71372", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 100, "deletions": 61, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -24,7 +24,7 @@ use rustc::middle::cstore::CrateStore;\n use rustc::session::Session;\n use rustc::lint;\n use rustc::hir::def::{\n-    self, PathResolution, CtorKind, CtorOf, NonMacroAttrKind, DefMap, ImportMap, ExportMap\n+    self, DefKind, PathResolution, CtorKind, CtorOf, NonMacroAttrKind, DefMap, ImportMap, ExportMap\n };\n use rustc::hir::def::Namespace::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n@@ -236,19 +236,19 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver<'_>,\n                     }\n                     return err;\n                 },\n-                Def::TyParam(def_id) => {\n+                Def::Def(DefKind::TyParam, def_id) => {\n                     if let Some(span) = resolver.definitions.opt_span(def_id) {\n                         err.span_label(span, \"type parameter from outer function\");\n                     }\n                 }\n-                Def::ConstParam(def_id) => {\n+                Def::Def(DefKind::ConstParam, def_id) => {\n                     if let Some(span) = resolver.definitions.opt_span(def_id) {\n                         err.span_label(span, \"const parameter from outer function\");\n                     }\n                 }\n                 _ => {\n                     bug!(\"GenericParamsFromOuterFunction should only be used with Def::SelfTy, \\\n-                         Def::TyParam\");\n+                         DefKind::TyParam\");\n                 }\n             }\n \n@@ -570,7 +570,7 @@ impl<'a> PathSource<'a> {\n                 MacroNS => bug!(\"associated macro\"),\n             },\n             PathSource::Expr(parent) => match parent.map(|p| &p.node) {\n-                // \"function\" here means \"anything callable\" rather than `Def::Fn`,\n+                // \"function\" here means \"anything callable\" rather than `DefKind::Fn`,\n                 // this is not precise but usually more helpful than just \"value\".\n                 Some(&ExprKind::Call(..)) => \"function\",\n                 _ => \"value\",\n@@ -581,50 +581,70 @@ impl<'a> PathSource<'a> {\n     fn is_expected(self, def: Def) -> bool {\n         match self {\n             PathSource::Type => match def {\n-                Def::Struct(..) | Def::Union(..) | Def::Enum(..) |\n-                Def::Trait(..) | Def::TraitAlias(..) | Def::TyAlias(..) |\n-                Def::AssociatedTy(..) | Def::PrimTy(..) | Def::TyParam(..) |\n-                Def::SelfTy(..) | Def::Existential(..) | Def::ForeignTy(..) => true,\n+                Def::Def(DefKind::Struct, _)\n+                | Def::Def(DefKind::Union, _)\n+                | Def::Def(DefKind::Enum, _)\n+                | Def::Def(DefKind::Trait, _)\n+                | Def::Def(DefKind::TraitAlias, _)\n+                | Def::Def(DefKind::TyAlias, _)\n+                | Def::Def(DefKind::AssociatedTy, _)\n+                | Def::PrimTy(..)\n+                | Def::Def(DefKind::TyParam, _)\n+                | Def::SelfTy(..)\n+                | Def::Def(DefKind::Existential, _)\n+                | Def::Def(DefKind::ForeignTy, _) => true,\n                 _ => false,\n             },\n             PathSource::Trait(AliasPossibility::No) => match def {\n-                Def::Trait(..) => true,\n+                Def::Def(DefKind::Trait, _) => true,\n                 _ => false,\n             },\n             PathSource::Trait(AliasPossibility::Maybe) => match def {\n-                Def::Trait(..) => true,\n-                Def::TraitAlias(..) => true,\n+                Def::Def(DefKind::Trait, _) => true,\n+                Def::Def(DefKind::TraitAlias, _) => true,\n                 _ => false,\n             },\n             PathSource::Expr(..) => match def {\n-                Def::Ctor(_, _, CtorKind::Const) | Def::Ctor(_, _, CtorKind::Fn) |\n-                Def::Const(..) | Def::Static(..) | Def::Local(..) | Def::Upvar(..) |\n-                Def::Fn(..) | Def::Method(..) | Def::AssociatedConst(..) |\n-                Def::SelfCtor(..) | Def::ConstParam(..) => true,\n+                Def::Def(DefKind::Ctor(_, CtorKind::Const), _)\n+                | Def::Def(DefKind::Ctor(_, CtorKind::Fn), _)\n+                | Def::Def(DefKind::Const, _)\n+                | Def::Def(DefKind::Static, _)\n+                | Def::Local(..)\n+                | Def::Upvar(..)\n+                | Def::Def(DefKind::Fn, _)\n+                | Def::Def(DefKind::Method, _)\n+                | Def::Def(DefKind::AssociatedConst, _)\n+                | Def::SelfCtor(..)\n+                | Def::Def(DefKind::ConstParam, _) => true,\n                 _ => false,\n             },\n             PathSource::Pat => match def {\n-                Def::Ctor(_, _, CtorKind::Const) |\n-                Def::Const(..) | Def::AssociatedConst(..) |\n+                Def::Def(DefKind::Ctor(_, CtorKind::Const), _) |\n+                Def::Def(DefKind::Const, _) | Def::Def(DefKind::AssociatedConst, _) |\n                 Def::SelfCtor(..) => true,\n                 _ => false,\n             },\n             PathSource::TupleStruct => match def {\n-                Def::Ctor(_, _, CtorKind::Fn) | Def::SelfCtor(..) => true,\n+                Def::Def(DefKind::Ctor(_, CtorKind::Fn), _) | Def::SelfCtor(..) => true,\n                 _ => false,\n             },\n             PathSource::Struct => match def {\n-                Def::Struct(..) | Def::Union(..) | Def::Variant(..) |\n-                Def::TyAlias(..) | Def::AssociatedTy(..) | Def::SelfTy(..) => true,\n+                Def::Def(DefKind::Struct, _)\n+                | Def::Def(DefKind::Union, _)\n+                | Def::Def(DefKind::Variant, _)\n+                | Def::Def(DefKind::TyAlias, _)\n+                | Def::Def(DefKind::AssociatedTy, _)\n+                | Def::SelfTy(..) => true,\n                 _ => false,\n             },\n             PathSource::TraitItem(ns) => match def {\n-                Def::AssociatedConst(..) | Def::Method(..) if ns == ValueNS => true,\n-                Def::AssociatedTy(..) if ns == TypeNS => true,\n+                Def::Def(DefKind::AssociatedConst, _)\n+                | Def::Def(DefKind::Method, _) if ns == ValueNS => true,\n+                Def::Def(DefKind::AssociatedTy, _) if ns == TypeNS => true,\n                 _ => false,\n             },\n             PathSource::Visibility => match def {\n-                Def::Mod(..) => true,\n+                Def::Def(DefKind::Mod, _) => true,\n                 _ => false,\n             },\n         }\n@@ -1263,14 +1283,14 @@ impl<'a> ModuleData<'a> {\n     // `self` resolves to the first module ancestor that `is_normal`.\n     fn is_normal(&self) -> bool {\n         match self.kind {\n-            ModuleKind::Def(Def::Mod(_), _) => true,\n+            ModuleKind::Def(Def::Def(DefKind::Mod, _), _) => true,\n             _ => false,\n         }\n     }\n \n     fn is_trait(&self) -> bool {\n         match self.kind {\n-            ModuleKind::Def(Def::Trait(_), _) => true,\n+            ModuleKind::Def(Def::Def(DefKind::Trait, _), _) => true,\n             _ => false,\n         }\n     }\n@@ -1443,8 +1463,8 @@ impl<'a> NameBinding<'a> {\n \n     fn is_variant(&self) -> bool {\n         match self.kind {\n-            NameBindingKind::Def(Def::Variant(..), _) |\n-            NameBindingKind::Def(Def::Ctor(_, CtorOf::Variant, ..), _) => true,\n+            NameBindingKind::Def(Def::Def(DefKind::Variant, _), _) |\n+            NameBindingKind::Def(Def::Def(DefKind::Ctor(CtorOf::Variant, ..), _), _) => true,\n             _ => false,\n         }\n     }\n@@ -1457,7 +1477,7 @@ impl<'a> NameBinding<'a> {\n                 }, ..\n             } => true,\n             NameBindingKind::Module(\n-                &ModuleData { kind: ModuleKind::Def(Def::Mod(def_id), _), .. }\n+                &ModuleData { kind: ModuleKind::Def(Def::Def(DefKind::Mod, def_id), _), .. }\n             ) => def_id.index == CRATE_DEF_INDEX,\n             _ => false,\n         }\n@@ -1479,21 +1499,23 @@ impl<'a> NameBinding<'a> {\n \n     fn is_importable(&self) -> bool {\n         match self.def() {\n-            Def::AssociatedConst(..) | Def::Method(..) | Def::AssociatedTy(..) => false,\n+            Def::Def(DefKind::AssociatedConst, _)\n+            | Def::Def(DefKind::Method, _)\n+            | Def::Def(DefKind::AssociatedTy, _) => false,\n             _ => true,\n         }\n     }\n \n     fn is_macro_def(&self) -> bool {\n         match self.kind {\n-            NameBindingKind::Def(Def::Macro(..), _) => true,\n+            NameBindingKind::Def(Def::Def(DefKind::Macro(..), _), _) => true,\n             _ => false,\n         }\n     }\n \n     fn macro_kind(&self) -> Option<MacroKind> {\n         match self.def() {\n-            Def::Macro(_, kind) => Some(kind),\n+            Def::Def(DefKind::Macro(kind), _) => Some(kind),\n             Def::NonMacroAttr(..) => Some(MacroKind::Attr),\n             _ => None,\n         }\n@@ -1915,7 +1937,10 @@ impl<'a> Resolver<'a> {\n                arenas: &'a ResolverArenas<'a>)\n                -> Resolver<'a> {\n         let root_def_id = DefId::local(CRATE_DEF_INDEX);\n-        let root_module_kind = ModuleKind::Def(Def::Mod(root_def_id), keywords::Invalid.name());\n+        let root_module_kind = ModuleKind::Def(\n+            Def::Def(DefKind::Mod, root_def_id),\n+            keywords::Invalid.name(),\n+        );\n         let graph_root = arenas.alloc_module(ModuleData {\n             no_implicit_prelude: attr::contains_name(&krate.attrs, \"no_implicit_prelude\"),\n             ..ModuleData::new(None, root_module_kind, root_def_id, Mark::root(), krate.span)\n@@ -2663,8 +2688,11 @@ impl<'a> Resolver<'a> {\n                             }\n                             seen_bindings.entry(ident).or_insert(param.ident.span);\n \n-                        // Plain insert (no renaming).\n-                        let def = Def::TyParam(self.definitions.local_def_id(param.id));\n+                            // Plain insert (no renaming).\n+                            let def = Def::Def(\n+                                DefKind::TyParam,\n+                                self.definitions.local_def_id(param.id),\n+                            );\n                             function_type_rib.bindings.insert(ident, def);\n                             self.record_def(param.id, PathResolution::new(def));\n                         }\n@@ -2682,7 +2710,10 @@ impl<'a> Resolver<'a> {\n                             }\n                             seen_bindings.entry(ident).or_insert(param.ident.span);\n \n-                            let def = Def::ConstParam(self.definitions.local_def_id(param.id));\n+                            let def = Def::Def(\n+                                DefKind::ConstParam,\n+                                self.definitions.local_def_id(param.id),\n+                            );\n                             function_value_rib.bindings.insert(ident, def);\n                             self.record_def(param.id, PathResolution::new(def));\n                         }\n@@ -3175,14 +3206,16 @@ impl<'a> Resolver<'a> {\n                         let is_syntactic_ambiguity = opt_pat.is_none() &&\n                             bmode == BindingMode::ByValue(Mutability::Immutable);\n                         match def {\n-                            Def::Ctor(_, _, CtorKind::Const) |\n-                            Def::Const(..) if is_syntactic_ambiguity => {\n+                            Def::Def(DefKind::Ctor(_, CtorKind::Const), _) |\n+                            Def::Def(DefKind::Const, _) if is_syntactic_ambiguity => {\n                                 // Disambiguate in favor of a unit struct/variant\n                                 // or constant pattern.\n                                 self.record_use(ident, ValueNS, binding.unwrap(), false);\n                                 Some(PathResolution::new(def))\n                             }\n-                            Def::Ctor(..) | Def::Const(..) | Def::Static(..) => {\n+                            Def::Def(DefKind::Ctor(..), _)\n+                            | Def::Def(DefKind::Const, _)\n+                            | Def::Def(DefKind::Static, _) => {\n                                 // This is unambiguously a fresh binding, either syntactically\n                                 // (e.g., `IDENT @ PAT` or `ref IDENT`) or because `IDENT` resolves\n                                 // to something unusable as a pattern (e.g., constructor function),\n@@ -3196,7 +3229,7 @@ impl<'a> Resolver<'a> {\n                                 );\n                                 None\n                             }\n-                            Def::Fn(..) | Def::Err => {\n+                            Def::Def(DefKind::Fn, _) | Def::Err => {\n                                 // These entities are explicitly allowed\n                                 // to be shadowed by fresh bindings.\n                                 None\n@@ -3310,7 +3343,7 @@ impl<'a> Resolver<'a> {\n                     // Add a temporary hack to smooth the transition to new struct ctor\n                     // visibility rules. See #38932 for more details.\n                     let mut res = None;\n-                    if let Def::Struct(def_id) = resolution.base_def() {\n+                    if let Def::Def(DefKind::Struct, def_id) = resolution.base_def() {\n                         if let Some((ctor_def, ctor_vis))\n                                 = self.struct_constructors.get(&def_id).cloned() {\n                             if is_expected(ctor_def) && self.is_accessible(ctor_vis) {\n@@ -3501,9 +3534,10 @@ impl<'a> Resolver<'a> {\n             self.macro_use_prelude.get(&path[0].ident.name).cloned()\n                                   .and_then(NameBinding::macro_kind) == Some(MacroKind::Bang)) {\n             // Return some dummy definition, it's enough for error reporting.\n-            return Some(\n-                PathResolution::new(Def::Macro(DefId::local(CRATE_DEF_INDEX), MacroKind::Bang))\n-            );\n+            return Some(PathResolution::new(Def::Def(\n+                DefKind::Macro(MacroKind::Bang),\n+                DefId::local(CRATE_DEF_INDEX),\n+            )));\n         }\n         fin_res\n     }\n@@ -3536,7 +3570,7 @@ impl<'a> Resolver<'a> {\n                 // trait to resolve.  In that case, we leave the `B`\n                 // segment to be resolved by type-check.\n                 return Some(PathResolution::with_unresolved_segments(\n-                    Def::Mod(DefId::local(CRATE_DEF_INDEX)), path.len()\n+                    Def::Def(DefKind::Mod, DefId::local(CRATE_DEF_INDEX)), path.len()\n                 ));\n             }\n \n@@ -3862,7 +3896,9 @@ impl<'a> Resolver<'a> {\n                         _ => None,\n                     };\n                     let (label, suggestion) = if module_def == self.graph_root.def() {\n-                        let is_mod = |def| match def { Def::Mod(..) => true, _ => false };\n+                        let is_mod = |def| {\n+                            match def { Def::Def(DefKind::Mod, _) => true, _ => false }\n+                        };\n                         let mut candidates =\n                             self.lookup_import_candidates(ident, TypeNS, is_mod);\n                         candidates.sort_by_cached_key(|c| {\n@@ -4059,7 +4095,7 @@ impl<'a> Resolver<'a> {\n                      return Def::Err;\n                 }\n             }\n-            Def::TyParam(..) | Def::SelfTy(..) => {\n+            Def::Def(DefKind::TyParam, _) | Def::SelfTy(..) => {\n                 for rib in ribs {\n                     match rib.kind {\n                         NormalRibKind | TraitOrImplItemRibKind | ClosureRibKind(..) |\n@@ -4081,7 +4117,7 @@ impl<'a> Resolver<'a> {\n                     }\n                 }\n             }\n-            Def::ConstParam(..) => {\n+            Def::Def(DefKind::ConstParam, _) => {\n                 let mut ribs = ribs.iter().peekable();\n                 if let Some(Rib { kind: FnItemRibKind, .. }) = ribs.peek() {\n                     // When declaring const parameters inside function signatures, the first rib\n@@ -4132,7 +4168,7 @@ impl<'a> Resolver<'a> {\n                 // Look for a field with the same name in the current self_type.\n                 if let Some(resolution) = self.def_map.get(&node_id) {\n                     match resolution.base_def() {\n-                        Def::Struct(did) | Def::Union(did)\n+                        Def::Def(DefKind::Struct, did) | Def::Def(DefKind::Union, did)\n                                 if resolution.unresolved_segments() == 0 => {\n                             if let Some(field_names) = self.field_names.get(&did) {\n                                 if field_names.iter().any(|&field_name| ident.name == field_name) {\n@@ -4223,10 +4259,13 @@ impl<'a> Resolver<'a> {\n                                 self.crate_loader\n                                     .maybe_process_path_extern(ident.name, ident.span)\n                                     .and_then(|crate_id| {\n-                                        let crate_mod = Def::Mod(DefId {\n-                                            krate: crate_id,\n-                                            index: CRATE_DEF_INDEX,\n-                                        });\n+                                        let crate_mod = Def::Def(\n+                                            DefKind::Mod,\n+                                            DefId {\n+                                                krate: crate_id,\n+                                                index: CRATE_DEF_INDEX,\n+                                            },\n+                                        );\n \n                                         if !ident.name.is_gensymed() && filter_fn(crate_mod) {\n                                             Some(TypoSuggestion {\n@@ -4566,8 +4605,8 @@ impl<'a> Resolver<'a> {\n             module.for_each_child(|name, ns, binding| {\n                 if ns != TypeNS { return }\n                 match binding.def() {\n-                    Def::Trait(_) |\n-                    Def::TraitAlias(_) => collected_traits.push((name, binding)),\n+                    Def::Def(DefKind::Trait, _) |\n+                    Def::Def(DefKind::TraitAlias, _) => collected_traits.push((name, binding)),\n                     _ => (),\n                 }\n             });\n@@ -4602,7 +4641,7 @@ impl<'a> Resolver<'a> {\n                     let trait_def_id = module.def_id().unwrap();\n                     found_traits.push(TraitCandidate { def_id: trait_def_id, import_id });\n                 }\n-            } else if let Def::TraitAlias(_) = binding.def() {\n+            } else if let Def::Def(DefKind::TraitAlias, _) = binding.def() {\n                 // For now, just treat all trait aliases as possible candidates, since we don't\n                 // know if the ident is somewhere in the transitive bounds.\n \n@@ -4677,7 +4716,7 @@ impl<'a> Resolver<'a> {\n                         // outside crate private modules => no need to check this)\n                         if !in_module_is_extern || name_binding.vis == ty::Visibility::Public {\n                             let did = match def {\n-                                Def::Ctor(did, ..) => self.parent(did),\n+                                Def::Def(DefKind::Ctor(..), did) => self.parent(did),\n                                 _ => def.opt_def_id(),\n                             };\n                             candidates.push(ImportSuggestion { did, path });\n@@ -4793,7 +4832,7 @@ impl<'a> Resolver<'a> {\n     }\n \n     fn collect_enum_variants(&mut self, enum_def: Def) -> Option<Vec<Path>> {\n-        if let Def::Enum(..) = enum_def {} else {\n+        if let Def::Def(DefKind::Enum, _) = enum_def {} else {\n             panic!(\"Non-enum def passed to collect_enum_variants: {:?}\", enum_def)\n         }\n \n@@ -4802,7 +4841,7 @@ impl<'a> Resolver<'a> {\n \n             let mut variants = Vec::new();\n             enum_module.for_each_child_stable(|ident, _, name_binding| {\n-                if let Def::Variant(..) = name_binding.def() {\n+                if let Def::Def(DefKind::Variant, _) = name_binding.def() {\n                     let mut segms = enum_import_suggestion.path.segments.clone();\n                     segms.push(ast::PathSegment::from_ident(ident));\n                     variants.push(Path {\n@@ -5050,8 +5089,8 @@ impl<'a> Resolver<'a> {\n         }\n \n         let container = match parent.kind {\n-            ModuleKind::Def(Def::Mod(_), _) => \"module\",\n-            ModuleKind::Def(Def::Trait(_), _) => \"trait\",\n+            ModuleKind::Def(Def::Def(DefKind::Mod, _), _) => \"module\",\n+            ModuleKind::Def(Def::Def(DefKind::Trait, _), _) => \"trait\",\n             ModuleKind::Block(..) => \"block\",\n             _ => \"enum\",\n         };"}, {"sha": "eea48f0711f23ff966e24a7dbee92b58af470911", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -8,7 +8,7 @@ use crate::build_reduced_graph::{BuildReducedGraphVisitor, IsMacroExport};\n use crate::resolve_imports::ImportResolver;\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX, DefIndex,\n                          CrateNum, DefIndexAddressSpace};\n-use rustc::hir::def::{self, NonMacroAttrKind};\n+use rustc::hir::def::{self, DefKind, NonMacroAttrKind};\n use rustc::hir::map::{self, DefCollector};\n use rustc::{ty, lint};\n use rustc::{bug, span_bug};\n@@ -179,7 +179,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n         let kind = ext.kind();\n         self.macro_map.insert(def_id, ext);\n         let binding = self.arenas.alloc_name_binding(NameBinding {\n-            kind: NameBindingKind::Def(Def::Macro(def_id, kind), false),\n+            kind: NameBindingKind::Def(Def::Def(DefKind::Macro(kind), def_id), false),\n             ambiguity: None,\n             span: DUMMY_SP,\n             vis: ty::Visibility::Public,\n@@ -218,7 +218,7 @@ impl<'a> base::Resolver for Resolver<'a> {\n             Err(determinacy) => return Err(determinacy),\n         };\n \n-        if let Def::Macro(def_id, _) = def {\n+        if let Def::Def(DefKind::Macro(_), def_id) = def {\n             if after_derive {\n                 self.session.span_err(invoc.span(),\n                                       \"macro attributes must be placed before `#[derive]`\");\n@@ -297,7 +297,7 @@ impl<'a> Resolver<'a> {\n         let def = def?;\n \n         match def {\n-            Def::Macro(def_id, macro_kind) => {\n+            Def::Def(DefKind::Macro(macro_kind), def_id) => {\n                 self.unused_macros.remove(&def_id);\n                 if macro_kind == MacroKind::ProcMacroStub {\n                     let msg = \"can't use a procedural macro from the same crate that defines it\";\n@@ -341,7 +341,7 @@ impl<'a> Resolver<'a> {\n             Def::Err => {\n                 return Err(Determinacy::Determined);\n             }\n-            _ => panic!(\"expected `Def::Macro` or `Def::NonMacroAttr`\"),\n+            _ => panic!(\"expected `DefKind::Macro` or `Def::NonMacroAttr`\"),\n         }\n \n         Ok((def, self.get_macro(def)))\n@@ -1028,7 +1028,7 @@ impl<'a> Resolver<'a> {\n         // Then check modules.\n         }).or_else(|| {\n             let is_macro = |def| {\n-                if let Def::Macro(_, def_kind) = def {\n+                if let Def::Def(DefKind::Macro(def_kind), _) = def {\n                     def_kind == kind\n                 } else {\n                     false\n@@ -1107,7 +1107,7 @@ impl<'a> Resolver<'a> {\n         if def.legacy {\n             let ident = ident.modern();\n             self.macro_names.insert(ident);\n-            let def = Def::Macro(def_id, MacroKind::Bang);\n+            let def = Def::Def(DefKind::Macro(MacroKind::Bang), def_id);\n             let is_macro_export = attr::contains_name(&item.attrs, \"macro_export\");\n             let vis = if is_macro_export {\n                 ty::Visibility::Public\n@@ -1133,7 +1133,7 @@ impl<'a> Resolver<'a> {\n             }\n         } else {\n             let module = self.current_module;\n-            let def = Def::Macro(def_id, MacroKind::Bang);\n+            let def = Def::Def(DefKind::Macro(MacroKind::Bang), def_id);\n             let vis = self.resolve_visibility(&item.vis);\n             if vis != ty::Visibility::Public {\n                 self.unused_macros.insert(def_id);"}, {"sha": "6ad09b2f7e7f6d1dcdd65314c70a772b0409757a", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -21,7 +21,7 @@ use rustc::lint::builtin::{\n     UNUSED_IMPORTS,\n };\n use rustc::hir::def_id::{CrateNum, DefId};\n-use rustc::hir::def::{self, PathResolution, Export};\n+use rustc::hir::def::{self, DefKind, PathResolution, Export};\n use rustc::session::DiagnosticMessageId;\n use rustc::util::nodemap::FxHashSet;\n use rustc::{bug, span_bug};\n@@ -1224,7 +1224,7 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         // purposes it's good enough to just favor one over the other.\n         self.per_ns(|this, ns| if let Some(binding) = source_bindings[ns].get().ok() {\n             let mut def = binding.def();\n-            if let Def::Macro(def_id, _) = def {\n+            if let Def::Def(DefKind::Macro(_), def_id) = def {\n                 // `DefId`s from the \"built-in macro crate\" should not leak from resolve because\n                 // later stages are not ready to deal with them and produce lots of ICEs. Replace\n                 // them with `Def::Err` until some saner scheme is implemented for built-in macros."}, {"sha": "36413e76a1e2c27cea951a5f17df442695d61018", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -13,7 +13,7 @@\n //! DumpVisitor walks the AST and processes it, and JsonDumper is used for\n //! recording the output.\n \n-use rustc::hir::def::Def as HirDef;\n+use rustc::hir::def::{Def as HirDef, DefKind as HirDefKind};\n use rustc::hir::def_id::DefId;\n use rustc::session::config::Input;\n use rustc::span_bug;\n@@ -957,13 +957,13 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                         );\n                     }\n                 }\n-                HirDef::Ctor(_, _, _) |\n-                HirDef::Const(..) |\n-                HirDef::AssociatedConst(..) |\n-                HirDef::Struct(..) |\n-                HirDef::Variant(..) |\n-                HirDef::TyAlias(..) |\n-                HirDef::AssociatedTy(..) |\n+                HirDef::Def(HirDefKind::Ctor(..), _) |\n+                HirDef::Def(HirDefKind::Const, _) |\n+                HirDef::Def(HirDefKind::AssociatedConst, _) |\n+                HirDef::Def(HirDefKind::Struct, _) |\n+                HirDef::Def(HirDefKind::Variant, _) |\n+                HirDef::Def(HirDefKind::TyAlias, _) |\n+                HirDef::Def(HirDefKind::AssociatedTy, _) |\n                 HirDef::SelfTy(..) => {\n                     self.dump_path_ref(id, &ast::Path::from_ident(ident));\n                 }"}, {"sha": "47d0b5055ea5d6f31b599617bfa4f3822a2d3240", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -15,7 +15,7 @@ mod span_utils;\n mod sig;\n \n use rustc::hir;\n-use rustc::hir::def::{CtorOf, Def as HirDef};\n+use rustc::hir::def::{CtorOf, Def as HirDef, DefKind as HirDefKind};\n use rustc::hir::Node;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::middle::privacy::AccessLevels;\n@@ -710,39 +710,39 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     ref_id: id_from_node_id(self.tcx.hir().hir_to_node_id(id), self),\n                 })\n             }\n-            HirDef::Trait(def_id) if fn_type(path_seg) => {\n+            HirDef::Def(HirDefKind::Trait, def_id) if fn_type(path_seg) => {\n                 Some(Ref {\n                     kind: RefKind::Type,\n                     span,\n                     ref_id: id_from_def_id(def_id),\n                 })\n             }\n-            HirDef::Struct(def_id) |\n-            HirDef::Variant(def_id, ..) |\n-            HirDef::Union(def_id) |\n-            HirDef::Enum(def_id) |\n-            HirDef::TyAlias(def_id) |\n-            HirDef::ForeignTy(def_id) |\n-            HirDef::TraitAlias(def_id) |\n-            HirDef::AssociatedExistential(def_id) |\n-            HirDef::AssociatedTy(def_id) |\n-            HirDef::Trait(def_id) |\n-            HirDef::Existential(def_id) |\n-            HirDef::TyParam(def_id) => {\n+            HirDef::Def(HirDefKind::Struct, def_id) |\n+            HirDef::Def(HirDefKind::Variant, def_id) |\n+            HirDef::Def(HirDefKind::Union, def_id) |\n+            HirDef::Def(HirDefKind::Enum, def_id) |\n+            HirDef::Def(HirDefKind::TyAlias, def_id) |\n+            HirDef::Def(HirDefKind::ForeignTy, def_id) |\n+            HirDef::Def(HirDefKind::TraitAlias, def_id) |\n+            HirDef::Def(HirDefKind::AssociatedExistential, def_id) |\n+            HirDef::Def(HirDefKind::AssociatedTy, def_id) |\n+            HirDef::Def(HirDefKind::Trait, def_id) |\n+            HirDef::Def(HirDefKind::Existential, def_id) |\n+            HirDef::Def(HirDefKind::TyParam, def_id) => {\n                 Some(Ref {\n                     kind: RefKind::Type,\n                     span,\n                     ref_id: id_from_def_id(def_id),\n                 })\n             }\n-            HirDef::ConstParam(def_id) => {\n+            HirDef::Def(HirDefKind::ConstParam, def_id) => {\n                 Some(Ref {\n                     kind: RefKind::Variable,\n                     span,\n                     ref_id: id_from_def_id(def_id),\n                 })\n             }\n-            HirDef::Ctor(def_id, CtorOf::Struct, ..) => {\n+            HirDef::Def(HirDefKind::Ctor(CtorOf::Struct, ..), def_id) => {\n                 // This is a reference to a tuple struct where the def_id points\n                 // to an invisible constructor function. That is not a very useful\n                 // def, so adjust to point to the tuple struct itself.\n@@ -753,17 +753,17 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     ref_id: id_from_def_id(parent_def_id),\n                 })\n             }\n-            HirDef::Static(..) |\n-            HirDef::Const(..) |\n-            HirDef::AssociatedConst(..) |\n-            HirDef::Ctor(..) => {\n+            HirDef::Def(HirDefKind::Static, _) |\n+            HirDef::Def(HirDefKind::Const, _) |\n+            HirDef::Def(HirDefKind::AssociatedConst, _) |\n+            HirDef::Def(HirDefKind::Ctor(..), _) => {\n                 Some(Ref {\n                     kind: RefKind::Variable,\n                     span,\n                     ref_id: id_from_def_id(def.def_id()),\n                 })\n             }\n-            HirDef::Method(decl_id) => {\n+            HirDef::Def(HirDefKind::Method, decl_id) => {\n                 let def_id = if decl_id.is_local() {\n                     let ti = self.tcx.associated_item(decl_id);\n                     self.tcx\n@@ -780,14 +780,14 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     ref_id: id_from_def_id(def_id.unwrap_or(decl_id)),\n                 })\n             }\n-            HirDef::Fn(def_id) => {\n+            HirDef::Def(HirDefKind::Fn, def_id) => {\n                 Some(Ref {\n                     kind: RefKind::Function,\n                     span,\n                     ref_id: id_from_def_id(def_id),\n                 })\n             }\n-            HirDef::Mod(def_id) => {\n+            HirDef::Def(HirDefKind::Mod, def_id) => {\n                 Some(Ref {\n                     kind: RefKind::Mod,\n                     span,\n@@ -797,7 +797,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             HirDef::PrimTy(..) |\n             HirDef::SelfTy(..) |\n             HirDef::Label(..) |\n-            HirDef::Macro(..) |\n+            HirDef::Def(HirDefKind::Macro(..), _) |\n             HirDef::ToolMod |\n             HirDef::NonMacroAttr(..) |\n             HirDef::SelfCtor(..) |"}, {"sha": "bcdb6be0ebdfd83be1d359af3ae310418122dd76", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -29,7 +29,7 @@ use crate::{id_from_def_id, id_from_node_id, SaveContext};\n \n use rls_data::{SigElement, Signature};\n \n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Def, DefKind};\n use syntax::ast::{self, NodeId};\n use syntax::print::pprust;\n \n@@ -586,7 +586,9 @@ impl Sig for ast::Path {\n                     refs: vec![],\n                 })\n             }\n-            Def::AssociatedConst(..) | Def::Variant(..) | Def::Ctor(..) => {\n+            Def::Def(DefKind::AssociatedConst, _)\n+            | Def::Def(DefKind::Variant, _)\n+            | Def::Def(DefKind::Ctor(..), _) => {\n                 let len = self.segments.len();\n                 if len < 2 {\n                     return Err(\"Bad path\");"}, {"sha": "8807e1aa62a8fbda3b35067048aaf98dcb1458b6", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -4,7 +4,7 @@\n \n use errors::{Applicability, DiagnosticId};\n use crate::hir::{self, GenericArg, GenericArgs, ExprKind};\n-use crate::hir::def::{CtorOf, Def};\n+use crate::hir::def::{CtorOf, Def, DefKind};\n use crate::hir::def_id::DefId;\n use crate::hir::HirVec;\n use crate::lint;\n@@ -1330,7 +1330,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     tcx.hygienic_eq(assoc_ident, vd.ident, adt_def.did)\n                 });\n                 if let Some(variant_def) = variant_def {\n-                    let def = Def::Variant(variant_def.def_id);\n+                    let def = Def::Def(DefKind::Variant, variant_def.def_id);\n                     if permit_variants {\n                         check_type_alias_enum_variants_enabled(tcx, span);\n                         tcx.check_stability(variant_def.def_id, Some(hir_ref_id), span);\n@@ -1365,7 +1365,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 }\n             }\n             (&ty::Param(_), Def::SelfTy(Some(param_did), None)) |\n-            (&ty::Param(_), Def::TyParam(param_did)) => {\n+            (&ty::Param(_), Def::Def(DefKind::TyParam, param_did)) => {\n                 match self.find_bound_for_assoc_item(param_did, assoc_ident, span) {\n                     Ok(bound) => bound,\n                     Err(ErrorReported) => return (tcx.types.err, Def::Err),\n@@ -1427,7 +1427,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         let ty = self.projected_ty_from_poly_trait_ref(span, item.def_id, bound);\n         let ty = self.normalize_ty(span, ty);\n \n-        let def = Def::AssociatedTy(item.def_id);\n+        let def = Def::Def(DefKind::AssociatedTy, item.def_id);\n         if !item.vis.is_accessible_from(def_scope, tcx) {\n             let msg = format!(\"{} `{}` is private\", def.kind_name(), assoc_ident);\n             tcx.sess.span_err(span, &msg);\n@@ -1617,7 +1617,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n \n         match def {\n             // Case 1. Reference to a struct constructor.\n-            Def::Ctor(def_id, CtorOf::Struct, ..) |\n+            Def::Def(DefKind::Ctor(CtorOf::Struct, ..), def_id) |\n             Def::SelfCtor(.., def_id) => {\n                 // Everything but the final segment should have no\n                 // parameters at all.\n@@ -1629,7 +1629,8 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             }\n \n             // Case 2. Reference to a variant constructor.\n-            Def::Ctor(def_id, CtorOf::Variant, ..) | Def::Variant(def_id, ..) => {\n+            Def::Def(DefKind::Ctor(CtorOf::Variant, ..), def_id)\n+            | Def::Def(DefKind::Variant, def_id) => {\n                 let adt_def = self_ty.map(|t| t.ty_adt_def().unwrap());\n                 let (generics_def_id, index) = if let Some(adt_def) = adt_def {\n                     debug_assert!(adt_def.is_enum());\n@@ -1639,12 +1640,12 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     // parameters at all.\n                     let mut def_id = def_id;\n \n-                    // `Def::Ctor` -> `Def::Variant`\n-                    if let Def::Ctor(..) = def {\n+                    // `DefKind::Ctor` -> `DefKind::Variant`\n+                    if let Def::Def(DefKind::Ctor(..), _) = def {\n                         def_id = tcx.parent(def_id).unwrap()\n                     }\n \n-                    // `Def::Variant` -> `Def::Item` (enum)\n+                    // `DefKind::Variant` -> `DefKind::Item` (enum)\n                     let enum_def_id = tcx.parent(def_id).unwrap();\n                     (enum_def_id, last - 1)\n                 } else {\n@@ -1662,16 +1663,16 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             }\n \n             // Case 3. Reference to a top-level value.\n-            Def::Fn(def_id) |\n-            Def::Const(def_id) |\n-            Def::ConstParam(def_id) |\n-            Def::Static(def_id) => {\n+            Def::Def(DefKind::Fn, def_id) |\n+            Def::Def(DefKind::Const, def_id) |\n+            Def::Def(DefKind::ConstParam, def_id) |\n+            Def::Def(DefKind::Static, def_id) => {\n                 path_segs.push(PathSeg(def_id, last));\n             }\n \n             // Case 4. Reference to a method or associated const.\n-            Def::Method(def_id) |\n-            Def::AssociatedConst(def_id) => {\n+            Def::Def(DefKind::Method, def_id) |\n+            Def::Def(DefKind::AssociatedConst, def_id) => {\n                 if segments.len() >= 2 {\n                     let generics = tcx.generics_of(def_id);\n                     path_segs.push(PathSeg(generics.parent.unwrap(), last - 1));\n@@ -1703,7 +1704,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n \n         let span = path.span;\n         match path.def {\n-            Def::Existential(did) => {\n+            Def::Def(DefKind::Existential, did) => {\n                 // Check for desugared impl trait.\n                 assert!(ty::is_impl_trait_defn(tcx, did).is_none());\n                 let item_segment = path.segments.split_last().unwrap();\n@@ -1714,13 +1715,16 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     tcx.mk_opaque(did, substs),\n                 )\n             }\n-            Def::Enum(did) | Def::TyAlias(did) | Def::Struct(did) |\n-            Def::Union(did) | Def::ForeignTy(did) => {\n+            Def::Def(DefKind::Enum, did)\n+            | Def::Def(DefKind::TyAlias, did)\n+            | Def::Def(DefKind::Struct, did)\n+            | Def::Def(DefKind::Union, did)\n+            | Def::Def(DefKind::ForeignTy, did) => {\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(path.segments.split_last().unwrap().1);\n                 self.ast_path_to_ty(span, did, path.segments.last().unwrap())\n             }\n-            Def::Variant(_) if permit_variants => {\n+            Def::Def(DefKind::Variant, _) if permit_variants => {\n                 // Convert \"variant type\" as if it were a real type.\n                 // The resulting `Ty` is type of the variant's enum for now.\n                 assert_eq!(opt_self_ty, None);\n@@ -1739,7 +1743,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 let PathSeg(def_id, index) = path_segs.last().unwrap();\n                 self.ast_path_to_ty(span, *def_id, &path.segments[*index])\n             }\n-            Def::TyParam(did) => {\n+            Def::Def(DefKind::TyParam, did) => {\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(&path.segments);\n \n@@ -1764,7 +1768,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 self.prohibit_generics(&path.segments);\n                 tcx.mk_self_type()\n             }\n-            Def::AssociatedTy(def_id) => {\n+            Def::Def(DefKind::AssociatedTy, def_id) => {\n                 debug_assert!(path.segments.len() >= 2);\n                 self.prohibit_generics(&path.segments[..path.segments.len() - 2]);\n                 self.qpath_to_ty(span,\n@@ -1911,7 +1915,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n         let expr = &tcx.hir().body(ast_const.body).value;\n         if let ExprKind::Path(ref qpath) = expr.node {\n             if let hir::QPath::Resolved(_, ref path) = qpath {\n-                if let Def::ConstParam(def_id) = path.def {\n+                if let Def::Def(DefKind::ConstParam, def_id) = path.def {\n                     let node_id = tcx.hir().as_local_node_id(def_id).unwrap();\n                     let item_id = tcx.hir().get_parent_node(node_id);\n                     let item_def_id = tcx.hir().local_def_id(item_id);\n@@ -2098,15 +2102,15 @@ fn split_auto_traits<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     let (auto_traits, trait_bounds): (Vec<_>, _) = trait_bounds.iter().partition(|bound| {\n         // Checks whether `trait_did` is an auto trait and adds it to `auto_traits` if so.\n         match bound.trait_ref.path.def {\n-            Def::Trait(trait_did) if tcx.trait_is_auto(trait_did) => {\n+            Def::Def(DefKind::Trait, trait_did) if tcx.trait_is_auto(trait_did) => {\n                 true\n             }\n             _ => false\n         }\n     });\n \n     let auto_traits = auto_traits.into_iter().map(|tr| {\n-        if let Def::Trait(trait_did) = tr.trait_ref.path.def {\n+        if let Def::Def(DefKind::Trait, trait_did) = tr.trait_ref.path.def {\n             trait_did\n         } else {\n             unreachable!()"}, {"sha": "bd04e12eb2485cca599df410621f1b960b9f10eb", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -3,7 +3,7 @@ use crate::check::coercion::CoerceMany;\n use crate::util::nodemap::FxHashMap;\n use errors::{Applicability, DiagnosticBuilder};\n use rustc::hir::{self, PatKind, Pat};\n-use rustc::hir::def::{Def, CtorKind};\n+use rustc::hir::def::{Def, DefKind, CtorKind};\n use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::infer;\n use rustc::infer::type_variable::TypeVariableOrigin;\n@@ -67,7 +67,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             PatKind::Path(ref qpath) => {\n                 let (def, _, _) = self.resolve_ty_and_def_ufcs(qpath, pat.hir_id, pat.span);\n                 match def {\n-                    Def::Const(..) | Def::AssociatedConst(..) => false,\n+                    Def::Def(DefKind::Const, _) | Def::Def(DefKind::AssociatedConst, _) => false,\n                     _ => true,\n                 }\n             }\n@@ -846,17 +846,17 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 self.set_tainted_by_errors();\n                 return tcx.types.err;\n             }\n-            Def::Method(..) => {\n+            Def::Def(DefKind::Method, _) => {\n                 report_unexpected_variant_def(tcx, &def, pat.span, qpath);\n                 return tcx.types.err;\n             }\n-            Def::Ctor(_, _, CtorKind::Fictive) |\n-            Def::Ctor(_, _, CtorKind::Fn) => {\n+            Def::Def(DefKind::Ctor(_, CtorKind::Fictive), _) |\n+            Def::Def(DefKind::Ctor(_, CtorKind::Fn), _) => {\n                 report_unexpected_variant_def(tcx, &def, pat.span, qpath);\n                 return tcx.types.err;\n             }\n-            Def::Ctor(_, _, CtorKind::Const) | Def::SelfCtor(..) |\n-            Def::Const(..) | Def::AssociatedConst(..) => {} // OK\n+            Def::Def(DefKind::Ctor(_, CtorKind::Const), _) | Def::SelfCtor(..) |\n+            Def::Def(DefKind::Const, _) | Def::Def(DefKind::AssociatedConst, _) => {} // OK\n             _ => bug!(\"unexpected pattern definition: {:?}\", def)\n         }\n \n@@ -913,11 +913,11 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                 on_error();\n                 return tcx.types.err;\n             }\n-            Def::AssociatedConst(..) | Def::Method(..) => {\n+            Def::Def(DefKind::AssociatedConst, _) | Def::Def(DefKind::Method, _) => {\n                 report_unexpected_def(def);\n                 return tcx.types.err;\n             }\n-            Def::Ctor(_, _, CtorKind::Fn) => {\n+            Def::Def(DefKind::Ctor(_, CtorKind::Fn), _) => {\n                 tcx.expect_variant_def(def)\n             }\n             _ => bug!(\"unexpected pattern definition: {:?}\", def)"}, {"sha": "a3ee6ffe8da84aa1a23577812d9e30f1c2be92ad", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -1,4 +1,5 @@\n use rustc::hir::{self, GenericParamKind, ImplItemKind, TraitItemKind};\n+use rustc::hir::def::{Def, DefKind};\n use rustc::infer::{self, InferOk};\n use rustc::ty::{self, TyCtxt, GenericParamDefKind};\n use rustc::ty::util::ExplicitSelf;\n@@ -844,7 +845,7 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 if let hir::TyKind::Path(\n                                     hir::QPath::Resolved(None, ref path)) = ty.node\n                                 {\n-                                    if let hir::def::Def::TyParam(def_id) = path.def {\n+                                    if let Def::Def(DefKind::TyParam, def_id) = path.def {\n                                         if def_id == self.1 {\n                                             self.0 = Some(ty.span);\n                                         }"}, {"sha": "537ea9a4b446834ab39fff2601027abe602087c4", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -5,7 +5,7 @@ use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n use syntax::util::parser::PREC_POSTFIX;\n use syntax_pos::Span;\n use rustc::hir;\n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Def, DefKind};\n use rustc::hir::Node;\n use rustc::hir::{print, lowering::is_range_literal};\n use rustc::ty::{self, Ty, AssociatedItem};\n@@ -207,7 +207,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // This function checks if the method isn't static and takes other arguments than `self`.\n     fn has_no_input_arg(&self, method: &AssociatedItem) -> bool {\n         match method.def() {\n-            Def::Method(def_id) => {\n+            Def::Def(DefKind::Method, def_id) => {\n                 self.tcx.fn_sig(def_id).inputs().skip_binder().len() == 1\n             }\n             _ => false,"}, {"sha": "b0f0856615d422c5bc71b4bac0d52e2dcdccec23", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -15,7 +15,7 @@ use crate::namespace::Namespace;\n use errors::{Applicability, DiagnosticBuilder};\n use rustc_data_structures::sync::Lrc;\n use rustc::hir;\n-use rustc::hir::def::{CtorOf, Def};\n+use rustc::hir::def::{CtorOf, Def, DefKind};\n use rustc::hir::def_id::DefId;\n use rustc::traits;\n use rustc::ty::subst::{InternalSubsts, SubstsRef};\n@@ -422,7 +422,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     // them as well. It's ok to use the variant's id as a ctor id since an\n                     // error will be reported on any use of such resolution anyway.\n                     let ctor_def_id = variant_def.ctor_def_id.unwrap_or(variant_def.def_id);\n-                    let def = Def::Ctor(ctor_def_id, CtorOf::Variant, variant_def.ctor_kind);\n+                    let def = Def::Def(\n+                        DefKind::Ctor(CtorOf::Variant, variant_def.ctor_kind),\n+                        ctor_def_id,\n+                    );\n                     tcx.check_stability(def.def_id(), Some(expr_id), span);\n                     return Ok(def);\n                 }"}, {"sha": "54260f196ce8b6573b50e1025942fbe4f111b8d1", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -6,7 +6,7 @@ use super::suggest;\n use crate::check::autoderef::{self, Autoderef};\n use crate::check::FnCtxt;\n use crate::hir::def_id::DefId;\n-use crate::hir::def::Def;\n+use crate::hir::def::{Def, DefKind};\n use crate::namespace::Namespace;\n \n use rustc_data_structures::sync::Lrc;\n@@ -862,7 +862,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                                self_ty: Option<Ty<'tcx>>,\n                                expected: Ty<'tcx>) -> bool {\n         match method.def() {\n-            Def::Method(def_id) => {\n+            Def::Def(DefKind::Method, def_id) => {\n                 let fty = self.tcx.fn_sig(def_id);\n                 self.probe(|_| {\n                     let substs = self.fresh_substs_for_item(self.span, method.def_id);"}, {"sha": "2c567a869916fa5fc10aa8b38cff122388c95354", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -8,7 +8,7 @@ use crate::util::nodemap::FxHashSet;\n use errors::{Applicability, DiagnosticBuilder};\n use rustc_data_structures::sync::Lrc;\n use rustc::hir::{self, ExprKind, Node, QPath};\n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Def, DefKind};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n use rustc::hir::map as hir_map;\n use rustc::hir::print;\n@@ -804,11 +804,11 @@ fn compute_all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Vec<DefId>\n                            external_mods: &mut FxHashSet<DefId>,\n                            def: Def) {\n         match def {\n-            Def::Trait(def_id) |\n-            Def::TraitAlias(def_id) => {\n+            Def::Def(DefKind::Trait, def_id) |\n+            Def::Def(DefKind::TraitAlias, def_id) => {\n                 traits.push(def_id);\n             }\n-            Def::Mod(def_id) => {\n+            Def::Def(DefKind::Mod, def_id) => {\n                 if !external_mods.insert(def_id) {\n                     return;\n                 }\n@@ -824,7 +824,7 @@ fn compute_all_traits<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Vec<DefId>\n             krate: cnum,\n             index: CRATE_DEF_INDEX,\n         };\n-        handle_external_def(tcx, &mut traits, &mut external_mods, Def::Mod(def_id));\n+        handle_external_def(tcx, &mut traits, &mut external_mods, Def::Def(DefKind::Mod, def_id));\n     }\n \n     traits"}, {"sha": "47974bc5564ce7a604a5f7cd6fd019a0807169fc", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 16, "deletions": 10, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -88,7 +88,7 @@ mod op;\n use crate::astconv::{AstConv, PathSeg};\n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n use rustc::hir::{self, ExprKind, GenericArg, ItemKind, Node, PatKind, QPath};\n-use rustc::hir::def::{CtorOf, CtorKind, Def};\n+use rustc::hir::def::{CtorOf, CtorKind, Def, DefKind};\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -2149,7 +2149,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.tables\n             .borrow_mut()\n             .type_dependent_defs_mut()\n-            .insert(hir_id, Def::Method(method.def_id));\n+            .insert(hir_id, Def::Def(DefKind::Method, method.def_id));\n \n         self.write_substs(hir_id, method.substs);\n \n@@ -3926,16 +3926,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.set_tainted_by_errors();\n                 return None;\n             }\n-            Def::Variant(..) => {\n+            Def::Def(DefKind::Variant, _) => {\n                 match ty.sty {\n                     ty::Adt(adt, substs) => {\n                         Some((adt.variant_of_def(def), adt.did, substs))\n                     }\n                     _ => bug!(\"unexpected type: {:?}\", ty)\n                 }\n             }\n-            Def::Struct(..) | Def::Union(..) | Def::TyAlias(..) |\n-            Def::AssociatedTy(..) | Def::SelfTy(..) => {\n+            Def::Def(DefKind::Struct, _)\n+            | Def::Def(DefKind::Union, _)\n+            | Def::Def(DefKind::TyAlias, _)\n+            | Def::Def(DefKind::AssociatedTy, _)\n+            | Def::SelfTy(..) => {\n                 match ty.sty {\n                     ty::Adt(adt, substs) if !adt.is_enum() => {\n                         Some((adt.non_enum_variant(), adt.did, substs))\n@@ -4237,7 +4240,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         self.set_tainted_by_errors();\n                         tcx.types.err\n                     }\n-                    Def::Ctor(_, _, CtorKind::Fictive) => {\n+                    Def::Def(DefKind::Ctor(_, CtorKind::Fictive), _) => {\n                         report_unexpected_variant_def(tcx, &def, expr.span, qpath);\n                         tcx.types.err\n                     }\n@@ -5362,7 +5365,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 Some(adt_def) if adt_def.has_ctor() => {\n                     let variant = adt_def.non_enum_variant();\n                     let ctor_def_id = variant.ctor_def_id.unwrap();\n-                    let def = Def::Ctor(ctor_def_id, CtorOf::Struct, variant.ctor_kind);\n+                    let def = Def::Def(\n+                        DefKind::Ctor(CtorOf::Struct, variant.ctor_kind),\n+                        ctor_def_id,\n+                    );\n                     (def, ctor_def_id, tcx.type_of(ctor_def_id))\n                 }\n                 _ => {\n@@ -5434,7 +5440,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let mut user_self_ty = None;\n         let mut is_alias_variant_ctor = false;\n         match def {\n-            Def::Ctor(_, CtorOf::Variant, _) => {\n+            Def::Def(DefKind::Ctor(CtorOf::Variant, _), _) => {\n                 if let Some(self_ty) = self_ty {\n                     let adt_def = self_ty.ty_adt_def().unwrap();\n                     user_self_ty = Some(UserSelfTy {\n@@ -5444,8 +5450,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     is_alias_variant_ctor = true;\n                 }\n             }\n-            Def::Method(def_id) |\n-            Def::AssociatedConst(def_id) => {\n+            Def::Def(DefKind::Method, def_id) |\n+            Def::Def(DefKind::AssociatedConst, def_id) => {\n                 let container = tcx.associated_item(def_id).container;\n                 debug!(\"instantiate_value_path: def={:?} container={:?}\", def, container);\n                 match container {"}, {"sha": "89409deb145943357d8a6c2a55b89d4dfcf38aec", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -42,7 +42,7 @@ use syntax::feature_gate;\n use syntax::symbol::{keywords, Symbol};\n use syntax_pos::{Span, DUMMY_SP};\n \n-use rustc::hir::def::{CtorKind, Def};\n+use rustc::hir::def::{CtorKind, Def, DefKind};\n use rustc::hir::Node;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n@@ -381,7 +381,7 @@ fn is_param<'a, 'tcx>(\n ) -> bool {\n     if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) = ast_ty.node {\n         match path.def {\n-            Def::SelfTy(Some(def_id), None) | Def::TyParam(def_id) => {\n+            Def::SelfTy(Some(def_id), None) | Def::Def(DefKind::TyParam, def_id) => {\n                 def_id == tcx.hir().local_def_id_from_hir_id(param_id)\n             }\n             _ => false,\n@@ -1381,10 +1381,10 @@ pub fn checked_type_of<'a, 'tcx>(\n                                 // We've encountered an `AnonConst` in some path, so we need to\n                                 // figure out which generic parameter it corresponds to and return\n                                 // the relevant type.\n-                                Def::Struct(def_id)\n-                                | Def::Union(def_id)\n-                                | Def::Enum(def_id)\n-                                | Def::Fn(def_id) => {\n+                                Def::Def(DefKind::Struct, def_id)\n+                                | Def::Def(DefKind::Union, def_id)\n+                                | Def::Def(DefKind::Enum, def_id)\n+                                | Def::Def(DefKind::Fn, def_id) => {\n                                     let generics = tcx.generics_of(def_id);\n                                     let mut param_index = 0;\n                                     for param in &generics.params {\n@@ -1778,7 +1778,7 @@ fn is_unsized<'gcx: 'tcx, 'tcx>(\n         Some(ref tpb) => {\n             // FIXME(#8559) currently requires the unbound to be built-in.\n             if let Ok(kind_id) = kind_id {\n-                if tpb.path.def != Def::Trait(kind_id) {\n+                if tpb.path.def != Def::Def(DefKind::Trait, kind_id) {\n                     tcx.sess.span_warn(\n                         span,\n                         \"default bound relaxed for a type parameter, but \\"}, {"sha": "365af15e006f751ceef97b872211f18704bd9a24", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -7,7 +7,7 @@ use syntax::ext::base::{MacroKind, SyntaxExtension};\n use syntax_pos::Span;\n \n use rustc::hir;\n-use rustc::hir::def::{Def, CtorKind};\n+use rustc::hir::def::{Def, DefKind, CtorKind};\n use rustc::hir::def_id::DefId;\n use rustc_metadata::cstore::LoadedMacro;\n use rustc::ty;\n@@ -50,59 +50,59 @@ pub fn try_inline(\n     if did.is_local() { return None }\n     let mut ret = Vec::new();\n     let inner = match def {\n-        Def::Trait(did) => {\n+        Def::Def(DefKind::Trait, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Trait);\n             ret.extend(build_impls(cx, did));\n             clean::TraitItem(build_external_trait(cx, did))\n         }\n-        Def::Fn(did) => {\n+        Def::Def(DefKind::Fn, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Function);\n             clean::FunctionItem(build_external_function(cx, did))\n         }\n-        Def::Struct(did) => {\n+        Def::Def(DefKind::Struct, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Struct);\n             ret.extend(build_impls(cx, did));\n             clean::StructItem(build_struct(cx, did))\n         }\n-        Def::Union(did) => {\n+        Def::Def(DefKind::Union, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Union);\n             ret.extend(build_impls(cx, did));\n             clean::UnionItem(build_union(cx, did))\n         }\n-        Def::TyAlias(did) => {\n+        Def::Def(DefKind::TyAlias, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Typedef);\n             ret.extend(build_impls(cx, did));\n             clean::TypedefItem(build_type_alias(cx, did), false)\n         }\n-        Def::Enum(did) => {\n+        Def::Def(DefKind::Enum, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Enum);\n             ret.extend(build_impls(cx, did));\n             clean::EnumItem(build_enum(cx, did))\n         }\n-        Def::ForeignTy(did) => {\n+        Def::Def(DefKind::ForeignTy, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Foreign);\n             ret.extend(build_impls(cx, did));\n             clean::ForeignTypeItem\n         }\n         // Never inline enum variants but leave them shown as re-exports.\n-        Def::Variant(..) => return None,\n+        Def::Def(DefKind::Variant, _) => return None,\n         // Assume that enum variants and struct types are re-exported next to\n         // their constructors.\n-        Def::Ctor(..) | Def::SelfCtor(..) => return Some(Vec::new()),\n-        Def::Mod(did) => {\n+        Def::Def(DefKind::Ctor(..), _) | Def::SelfCtor(..) => return Some(Vec::new()),\n+        Def::Def(DefKind::Mod, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Module);\n             clean::ModuleItem(build_module(cx, did, visited))\n         }\n-        Def::Static(did) => {\n+        Def::Def(DefKind::Static, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Static);\n             clean::StaticItem(build_static(cx, did, cx.tcx.is_mutable_static(did)))\n         }\n-        Def::Const(did) => {\n+        Def::Def(DefKind::Const, did) => {\n             record_extern_fqn(cx, did, clean::TypeKind::Const);\n             clean::ConstantItem(build_const(cx, did))\n         }\n         // FIXME: proc-macros don't propagate attributes or spans across crates, so they look empty\n-        Def::Macro(did, MacroKind::Bang) => {\n+        Def::Def(DefKind::Macro(MacroKind::Bang), did) => {\n             let mac = build_macro(cx, did, name);\n             if let clean::MacroItem(..) = mac {\n                 record_extern_fqn(cx, did, clean::TypeKind::Macro);\n@@ -135,7 +135,7 @@ pub fn try_inline_glob(cx: &DocContext<'_>, def: Def, visited: &mut FxHashSet<De\n     if did.is_local() { return None }\n \n     match def {\n-        Def::Mod(did) => {\n+        Def::Def(DefKind::Mod, did) => {\n             let m = build_module(cx, did, visited);\n             Some(m.items)\n         }"}, {"sha": "95a2664954da9e47150bedbe578da8b84d2e739a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 57, "deletions": 37, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -19,7 +19,7 @@ use rustc::middle::lang_items;\n use rustc::middle::stability;\n use rustc::mir::interpret::{GlobalId, ConstValue};\n use rustc::hir::{self, HirVec};\n-use rustc::hir::def::{self, Def, CtorKind};\n+use rustc::hir::def::{self, Def, DefKind, CtorKind};\n use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::ty::subst::{InternalSubsts, SubstsRef, UnpackedKind};\n use rustc::ty::{self, DefIdTree, TyCtxt, Region, RegionVid, Ty, AdtKind};\n@@ -258,7 +258,7 @@ impl Clean<ExternalCrate> for CrateNum {\n         // duplicately for the same primitive. This is handled later on when\n         // rendering by delegating everything to a hash map.\n         let as_primitive = |def: Def| {\n-            if let Def::Mod(def_id) = def {\n+            if let Def::Def(DefKind::Mod, def_id) = def {\n                 let attrs = cx.tcx.get_attrs(def_id).clean(cx);\n                 let mut prim = None;\n                 for attr in attrs.lists(\"doc\") {\n@@ -281,7 +281,10 @@ impl Clean<ExternalCrate> for CrateNum {\n                 let item = cx.tcx.hir().expect_item_by_hir_id(id.id);\n                 match item.node {\n                     hir::ItemKind::Mod(_) => {\n-                        as_primitive(Def::Mod(cx.tcx.hir().local_def_id_from_hir_id(id.id)))\n+                        as_primitive(Def::Def(\n+                            DefKind::Mod,\n+                            cx.tcx.hir().local_def_id_from_hir_id(id.id),\n+                        ))\n                     }\n                     hir::ItemKind::Use(ref path, hir::UseKind::Single)\n                     if item.vis.node.is_pub() => {\n@@ -299,7 +302,7 @@ impl Clean<ExternalCrate> for CrateNum {\n         };\n \n         let as_keyword = |def: Def| {\n-            if let Def::Mod(def_id) = def {\n+            if let Def::Def(DefKind::Mod, def_id) = def {\n                 let attrs = cx.tcx.get_attrs(def_id).clean(cx);\n                 let mut keyword = None;\n                 for attr in attrs.lists(\"doc\") {\n@@ -323,7 +326,10 @@ impl Clean<ExternalCrate> for CrateNum {\n                 let item = cx.tcx.hir().expect_item_by_hir_id(id.id);\n                 match item.node {\n                     hir::ItemKind::Mod(_) => {\n-                        as_keyword(Def::Mod(cx.tcx.hir().local_def_id_from_hir_id(id.id)))\n+                        as_keyword(Def::Def(\n+                            DefKind::Mod,\n+                            cx.tcx.hir().local_def_id_from_hir_id(id.id),\n+                        ))\n                     }\n                     hir::ItemKind::Use(ref path, hir::UseKind::Single)\n                     if item.vis.node.is_pub() => {\n@@ -2785,14 +2791,14 @@ impl Clean<Type> for hir::Ty {\n                     return new_ty;\n                 }\n \n-                if let Def::TyParam(did) = path.def {\n+                if let Def::Def(DefKind::TyParam, did) = path.def {\n                     if let Some(bounds) = cx.impl_trait_bounds.borrow_mut().remove(&did) {\n                         return ImplTrait(bounds);\n                     }\n                 }\n \n                 let mut alias = None;\n-                if let Def::TyAlias(def_id) = path.def {\n+                if let Def::Def(DefKind::TyAlias, def_id) = path.def {\n                     // Substitute private type aliases\n                     if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(def_id) {\n                         if !cx.renderinfo.borrow().access_levels.is_exported(def_id) {\n@@ -2835,8 +2841,10 @@ impl Clean<Type> for hir::Ty {\n                                 }\n                                 hir::GenericParamKind::Type { ref default, .. } => {\n                                     let ty_param_def =\n-                                        Def::TyParam(\n-                                            cx.tcx.hir().local_def_id_from_hir_id(param.hir_id));\n+                                        Def::Def(\n+                                            DefKind::TyParam,\n+                                            cx.tcx.hir().local_def_id_from_hir_id(param.hir_id),\n+                                        );\n                                     let mut j = 0;\n                                     let type_ = generic_args.args.iter().find_map(|arg| {\n                                         match arg {\n@@ -2860,8 +2868,10 @@ impl Clean<Type> for hir::Ty {\n                                 }\n                                 hir::GenericParamKind::Const { .. } => {\n                                     let const_param_def =\n-                                        Def::ConstParam(\n-                                            cx.tcx.hir().local_def_id_from_hir_id(param.hir_id));\n+                                        Def::Def(\n+                                            DefKind::ConstParam,\n+                                            cx.tcx.hir().local_def_id_from_hir_id(param.hir_id),\n+                                        );\n                                     let mut j = 0;\n                                     let const_ = generic_args.args.iter().find_map(|arg| {\n                                         match arg {\n@@ -2893,7 +2903,10 @@ impl Clean<Type> for hir::Ty {\n                 segments.pop();\n                 let trait_path = hir::Path {\n                     span: p.span,\n-                    def: Def::Trait(cx.tcx.associated_item(p.def.def_id()).container.id()),\n+                    def: Def::Def(\n+                        DefKind::Trait,\n+                        cx.tcx.associated_item(p.def.def_id()).container.id(),\n+                    ),\n                     segments: segments.into(),\n                 };\n                 Type::QPath {\n@@ -2906,7 +2919,7 @@ impl Clean<Type> for hir::Ty {\n                 let mut def = Def::Err;\n                 let ty = hir_ty_to_ty(cx.tcx, self);\n                 if let ty::Projection(proj) = ty.sty {\n-                    def = Def::Trait(proj.trait_ref(cx.tcx).def_id);\n+                    def = Def::Def(DefKind::Trait, proj.trait_ref(cx.tcx).def_id);\n                 }\n                 let trait_path = hir::Path {\n                     span: self.span,\n@@ -3898,10 +3911,13 @@ impl Clean<Vec<Item>> for doctree::ExternCrate {\n         if please_inline {\n             let mut visited = FxHashSet::default();\n \n-            let def = Def::Mod(DefId {\n-                krate: self.cnum,\n-                index: CRATE_DEF_INDEX,\n-            });\n+            let def = Def::Def(\n+                DefKind::Mod,\n+                DefId {\n+                    krate: self.cnum,\n+                    index: CRATE_DEF_INDEX,\n+                },\n+            );\n \n             if let Some(items) = inline::try_inline(cx, def, self.name, &mut visited) {\n                 return items;\n@@ -3951,10 +3967,12 @@ impl Clean<Vec<Item>> for doctree::Import {\n             let name = self.name;\n             if !please_inline {\n                 match path.def {\n-                    Def::Mod(did) => if !did.is_local() && did.index == CRATE_DEF_INDEX {\n-                        // if we're `pub use`ing an extern crate root, don't inline it unless we\n-                        // were specifically asked for it\n-                        denied = true;\n+                    Def::Def(DefKind::Mod, did) => {\n+                        if !did.is_local() && did.index == CRATE_DEF_INDEX {\n+                            // if we're `pub use`ing an extern crate root, don't inline it unless we\n+                            // were specifically asked for it\n+                            denied = true;\n+                        }\n                     }\n                     _ => {}\n                 }\n@@ -4157,10 +4175,12 @@ fn resolve_type(cx: &DocContext<'_>,\n         Def::SelfTy(..) if path.segments.len() == 1 => {\n             return Generic(keywords::SelfUpper.name().to_string());\n         }\n-        Def::TyParam(..) if path.segments.len() == 1 => {\n+        Def::Def(DefKind::TyParam, _) if path.segments.len() == 1 => {\n             return Generic(format!(\"{:#}\", path));\n         }\n-        Def::SelfTy(..) | Def::TyParam(..) | Def::AssociatedTy(..) => true,\n+        Def::SelfTy(..)\n+        | Def::Def(DefKind::TyParam, _)\n+        | Def::Def(DefKind::AssociatedTy, _) => true,\n         _ => false,\n     };\n     let did = register_def(&*cx, path.def);\n@@ -4171,25 +4191,25 @@ pub fn register_def(cx: &DocContext<'_>, def: Def) -> DefId {\n     debug!(\"register_def({:?})\", def);\n \n     let (did, kind) = match def {\n-        Def::Fn(i) => (i, TypeKind::Function),\n-        Def::TyAlias(i) => (i, TypeKind::Typedef),\n-        Def::Enum(i) => (i, TypeKind::Enum),\n-        Def::Trait(i) => (i, TypeKind::Trait),\n-        Def::Struct(i) => (i, TypeKind::Struct),\n-        Def::Union(i) => (i, TypeKind::Union),\n-        Def::Mod(i) => (i, TypeKind::Module),\n-        Def::ForeignTy(i) => (i, TypeKind::Foreign),\n-        Def::Const(i) => (i, TypeKind::Const),\n-        Def::Static(i) => (i, TypeKind::Static),\n-        Def::Variant(i) => (cx.tcx.parent(i).expect(\"cannot get parent def id\"),\n+        Def::Def(DefKind::Fn, i) => (i, TypeKind::Function),\n+        Def::Def(DefKind::TyAlias, i) => (i, TypeKind::Typedef),\n+        Def::Def(DefKind::Enum, i) => (i, TypeKind::Enum),\n+        Def::Def(DefKind::Trait, i) => (i, TypeKind::Trait),\n+        Def::Def(DefKind::Struct, i) => (i, TypeKind::Struct),\n+        Def::Def(DefKind::Union, i) => (i, TypeKind::Union),\n+        Def::Def(DefKind::Mod, i) => (i, TypeKind::Module),\n+        Def::Def(DefKind::ForeignTy, i) => (i, TypeKind::Foreign),\n+        Def::Def(DefKind::Const, i) => (i, TypeKind::Const),\n+        Def::Def(DefKind::Static, i) => (i, TypeKind::Static),\n+        Def::Def(DefKind::Variant, i) => (cx.tcx.parent(i).expect(\"cannot get parent def id\"),\n                             TypeKind::Enum),\n-        Def::Macro(i, mac_kind) => match mac_kind {\n+        Def::Def(DefKind::Macro(mac_kind), i) => match mac_kind {\n             MacroKind::Bang => (i, TypeKind::Macro),\n             MacroKind::Attr => (i, TypeKind::Attr),\n             MacroKind::Derive => (i, TypeKind::Derive),\n             MacroKind::ProcMacroStub => unreachable!(),\n         },\n-        Def::TraitAlias(i) => (i, TypeKind::TraitAlias),\n+        Def::Def(DefKind::TraitAlias, i) => (i, TypeKind::TraitAlias),\n         Def::SelfTy(Some(def_id), _) => (def_id, TypeKind::Trait),\n         Def::SelfTy(_, Some(impl_def_id)) => return impl_def_id,\n         _ => return def.def_id()\n@@ -4418,7 +4438,7 @@ pub fn path_to_def(tcx: TyCtxt<'_, '_, '_>, path: &[&str]) -> Option<DefId> {\n                 if item.ident.name == *segment {\n                     if path_it.peek().is_none() {\n                         return match item.def {\n-                            def::Def::Trait(did) => Some(did),\n+                            def::Def::Def(DefKind::Trait, did) => Some(did),\n                             _ => None,\n                         }\n                     }"}, {"sha": "f5b97797897bad4ccc748242199ac70cdebf58e2", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -1,5 +1,5 @@\n use errors::Applicability;\n-use rustc::hir::def::{Def, Namespace::{self, *}, PerNS};\n+use rustc::hir::def::{Def, DefKind, Namespace::{self, *}, PerNS};\n use rustc::hir::def_id::DefId;\n use rustc::hir;\n use rustc::lint as lint;\n@@ -75,9 +75,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 // In case this is a trait item, skip the\n                 // early return and try looking for the trait.\n                 let value = match result.def {\n-                    Def::Method(_) | Def::AssociatedConst(_) => true,\n-                    Def::AssociatedTy(_) => false,\n-                    Def::Variant(_) => return handle_variant(cx, result.def),\n+                    Def::Def(DefKind::Method, _) | Def::Def(DefKind::AssociatedConst, _) => true,\n+                    Def::Def(DefKind::AssociatedTy, _) => false,\n+                    Def::Def(DefKind::Variant, _) => return handle_variant(cx, result.def),\n                     // Not a trait item; just return what we found.\n                     _ => return Ok((result.def, None))\n                 };\n@@ -133,7 +133,10 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     resolver.resolve_str_path_error(DUMMY_SP, &path, false)\n             }))?;\n             match ty.def {\n-                Def::Struct(did) | Def::Union(did) | Def::Enum(did) | Def::TyAlias(did) => {\n+                Def::Def(DefKind::Struct, did)\n+                | Def::Def(DefKind::Union, did)\n+                | Def::Def(DefKind::Enum, did)\n+                | Def::Def(DefKind::TyAlias, did) => {\n                     let item = cx.tcx.inherent_impls(did)\n                                      .iter()\n                                      .flat_map(|imp| cx.tcx.associated_items(*imp))\n@@ -172,7 +175,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                         }\n                     }\n                 }\n-                Def::Trait(did) => {\n+                Def::Def(DefKind::Trait, did) => {\n                     let item = cx.tcx.associated_item_def_ids(did).iter()\n                                  .map(|item| cx.tcx.associated_item(*item))\n                                  .find(|item| item.ident.name == item_name);\n@@ -347,7 +350,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                                 .and_then(|(def, fragment)| {\n                                     // Constructors are picked up in the type namespace.\n                                     match def {\n-                                        Def::Ctor(..) | Def::SelfCtor(..) => None,\n+                                        Def::Def(DefKind::Ctor(..), _) | Def::SelfCtor(..) => None,\n                                         _ => Some((def, fragment))\n                                     }\n                                 }),\n@@ -427,7 +430,7 @@ fn macro_resolve(cx: &DocContext<'_>, path_str: &str) -> Option<Def> {\n         let parent_scope = resolver.dummy_parent_scope();\n         if let Ok(def) = resolver.resolve_macro_to_def_inner(&path, MacroKind::Bang,\n                                                             &parent_scope, false, false) {\n-            if let Def::Macro(_, MacroKind::ProcMacroStub) = def {\n+            if let Def::Def(DefKind::Macro(MacroKind::ProcMacroStub), _) = def {\n                 // skip proc-macro stubs, they'll cause `get_macro` to crash\n             } else {\n                 if let SyntaxExtension::DeclMacro { .. } = *resolver.get_macro(def) {\n@@ -541,21 +544,21 @@ fn ambiguity_error(\n \n             for (def, ns) in candidates {\n                 let (action, mut suggestion) = match def {\n-                    Def::Method(..) | Def::Fn(..) => {\n+                    Def::Def(DefKind::Method, _) | Def::Def(DefKind::Fn, _) => {\n                         (\"add parentheses\", format!(\"{}()\", path_str))\n                     }\n-                    Def::Macro(..) => {\n+                    Def::Def(DefKind::Macro(..), _) => {\n                         (\"add an exclamation mark\", format!(\"{}!\", path_str))\n                     }\n                     _ => {\n                         let type_ = match (def, ns) {\n-                            (Def::Const(..), _) => \"const\",\n-                            (Def::Static(..), _) => \"static\",\n-                            (Def::Struct(..), _) => \"struct\",\n-                            (Def::Enum(..), _) => \"enum\",\n-                            (Def::Union(..), _) => \"union\",\n-                            (Def::Trait(..), _) => \"trait\",\n-                            (Def::Mod(..), _) => \"module\",\n+                            (Def::Def(DefKind::Const, _), _) => \"const\",\n+                            (Def::Def(DefKind::Static, _), _) => \"static\",\n+                            (Def::Def(DefKind::Struct, _), _) => \"struct\",\n+                            (Def::Def(DefKind::Enum, _), _) => \"enum\",\n+                            (Def::Def(DefKind::Union, _), _) => \"union\",\n+                            (Def::Def(DefKind::Trait, _), _) => \"trait\",\n+                            (Def::Def(DefKind::Mod, _), _) => \"module\",\n                             (_, TypeNS) => \"type\",\n                             (_, ValueNS) => \"value\",\n                             (_, MacroNS) => \"macro\",\n@@ -609,7 +612,7 @@ fn handle_variant(cx: &DocContext<'_>, def: Def) -> Result<(Def, Option<String>)\n     } else {\n         return Err(())\n     };\n-    let parent_def = Def::Enum(parent);\n+    let parent_def = Def::Def(DefKind::Enum, parent);\n     let variant = cx.tcx.expect_variant_def(def);\n     Ok((parent_def, Some(format!(\"{}.v\", variant.ident.name))))\n }"}, {"sha": "b7a617cdbd9f7caf40b499e74685b4c1f275386e", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -2,7 +2,7 @@\n //! usable for `clean`.\n \n use rustc::hir::{self, Node};\n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Def, DefKind};\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::middle::privacy::AccessLevel;\n use rustc::util::nodemap::{FxHashSet, FxHashMap};\n@@ -306,18 +306,18 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             let attrs = clean::inline::load_attrs(self.cx, def_did);\n             let self_is_hidden = attrs.lists(\"doc\").has_word(\"hidden\");\n             match def {\n-                Def::Trait(did) |\n-                Def::Struct(did) |\n-                Def::Union(did) |\n-                Def::Enum(did) |\n-                Def::ForeignTy(did) |\n-                Def::TyAlias(did) if !self_is_hidden => {\n+                Def::Def(DefKind::Trait, did) |\n+                Def::Def(DefKind::Struct, did) |\n+                Def::Def(DefKind::Union, did) |\n+                Def::Def(DefKind::Enum, did) |\n+                Def::Def(DefKind::ForeignTy, did) |\n+                Def::Def(DefKind::TyAlias, did) if !self_is_hidden => {\n                     self.cx.renderinfo\n                         .borrow_mut()\n                         .access_levels.map\n                         .insert(did, AccessLevel::Public);\n                 },\n-                Def::Mod(did) => if !self_is_hidden {\n+                Def::Def(DefKind::Mod, did) => if !self_is_hidden {\n                     crate::visit_lib::LibEmbargoVisitor::new(self.cx).visit_mod(did);\n                 },\n                 _ => {},\n@@ -421,8 +421,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 // Struct and variant constructors and proc macro stubs always show up alongside\n                 // their definitions, we've already processed them so just discard these.\n                 match path.def {\n-                    Def::Ctor(..) | Def::SelfCtor(..) | Def::Macro(_, MacroKind::ProcMacroStub) =>\n-                        return,\n+                    Def::Def(DefKind::Ctor(..), _)\n+                    | Def::SelfCtor(..)\n+                    | Def::Def(DefKind::Macro(MacroKind::ProcMacroStub), _) => return,\n                     _ => {}\n                 }\n "}, {"sha": "22c750011d9907fc26cd5a6285e67e3b2e76ed73", "filename": "src/librustdoc/visit_lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustdoc%2Fvisit_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a3fcab36d25317ff2bad24d67f7e932c37f35d19/src%2Flibrustdoc%2Fvisit_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_lib.rs?ref=a3fcab36d25317ff2bad24d67f7e932c37f35d19", "patch": "@@ -1,5 +1,5 @@\n use rustc::middle::privacy::{AccessLevels, AccessLevel};\n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Def, DefKind};\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n use rustc::ty::Visibility;\n use rustc::util::nodemap::FxHashSet;\n@@ -80,7 +80,7 @@ impl<'a, 'tcx> LibEmbargoVisitor<'a, 'tcx> {\n \n         let item_level = self.update(def_id, inherited_item_level);\n \n-        if let Def::Mod(..) = def {\n+        if let Def::Def(DefKind::Mod, _) = def {\n             let orig_level = self.prev_level;\n \n             self.prev_level = item_level;"}]}