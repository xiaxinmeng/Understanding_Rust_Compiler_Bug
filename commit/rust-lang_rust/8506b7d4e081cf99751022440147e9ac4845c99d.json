{"sha": "8506b7d4e081cf99751022440147e9ac4845c99d", "node_id": "C_kwDOAAsO6NoAKDg1MDZiN2Q0ZTA4MWNmOTk3NTEwMjI0NDAxNDdlOWFjNDg0NWM5OWQ", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-06-05T20:06:37Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-06-11T23:27:01Z"}, "message": "Make Ty::is_suggestable use a visitor", "tree": {"sha": "304dd7ba98118558c76b69ec36a2538d165e7081", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/304dd7ba98118558c76b69ec36a2538d165e7081"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8506b7d4e081cf99751022440147e9ac4845c99d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8506b7d4e081cf99751022440147e9ac4845c99d", "html_url": "https://github.com/rust-lang/rust/commit/8506b7d4e081cf99751022440147e9ac4845c99d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8506b7d4e081cf99751022440147e9ac4845c99d/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99930ac7f8cbb5d9b319b2e2e92794fd6f24f556", "url": "https://api.github.com/repos/rust-lang/rust/commits/99930ac7f8cbb5d9b319b2e2e92794fd6f24f556", "html_url": "https://github.com/rust-lang/rust/commit/99930ac7f8cbb5d9b319b2e2e92794fd6f24f556"}], "stats": {"total": 138, "additions": 69, "deletions": 69}, "files": [{"sha": "e4e575542c2e581a31beaf757f7b3430cb31bb7c", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 69, "deletions": 69, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/8506b7d4e081cf99751022440147e9ac4845c99d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8506b7d4e081cf99751022440147e9ac4845c99d/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=8506b7d4e081cf99751022440147e9ac4845c99d", "patch": "@@ -1,9 +1,10 @@\n //! Diagnostics related methods for `Ty`.\n \n-use crate::ty::subst::{GenericArg, GenericArgKind};\n+use std::ops::ControlFlow;\n+\n use crate::ty::{\n-    ConstKind, DefIdTree, ExistentialPredicate, ExistentialProjection, ExistentialTraitRef,\n-    InferTy, ProjectionTy, Term, Ty, TyCtxt, TypeAndMut,\n+    fold::TypeFoldable, Const, ConstKind, DefIdTree, ExistentialPredicate, InferTy, Ty, TyCtxt,\n+    TypeVisitor,\n };\n \n use rustc_data_structures::fx::FxHashMap;\n@@ -75,72 +76,7 @@ impl<'tcx> Ty<'tcx> {\n \n     /// Whether the type can be safely suggested during error recovery.\n     pub fn is_suggestable(self, tcx: TyCtxt<'tcx>) -> bool {\n-        fn generic_arg_is_suggestible<'tcx>(arg: GenericArg<'tcx>, tcx: TyCtxt<'tcx>) -> bool {\n-            match arg.unpack() {\n-                GenericArgKind::Type(ty) => ty.is_suggestable(tcx),\n-                GenericArgKind::Const(c) => const_is_suggestable(c.val()),\n-                _ => true,\n-            }\n-        }\n-\n-        fn const_is_suggestable(kind: ConstKind<'_>) -> bool {\n-            match kind {\n-                ConstKind::Infer(..)\n-                | ConstKind::Bound(..)\n-                | ConstKind::Placeholder(..)\n-                | ConstKind::Error(..) => false,\n-                _ => true,\n-            }\n-        }\n-\n-        // FIXME(compiler-errors): Some types are still not good to suggest,\n-        // specifically references with lifetimes within the function. Not\n-        //sure we have enough information to resolve whether a region is\n-        // temporary, so I'll leave this as a fixme.\n-\n-        match self.kind() {\n-            FnDef(..)\n-            | Closure(..)\n-            | Infer(..)\n-            | Generator(..)\n-            | GeneratorWitness(..)\n-            | Bound(_, _)\n-            | Placeholder(_)\n-            | Error(_) => false,\n-            Opaque(did, substs) => {\n-                let parent = tcx.parent(*did);\n-                if let hir::def::DefKind::TyAlias | hir::def::DefKind::AssocTy = tcx.def_kind(parent)\n-                    && let Opaque(parent_did, _) = tcx.type_of(parent).kind()\n-                    && parent_did == did\n-                {\n-                    substs.iter().all(|a| generic_arg_is_suggestible(a, tcx))\n-                } else {\n-                    false\n-                }\n-            }\n-            Dynamic(dty, _) => dty.iter().all(|pred| match pred.skip_binder() {\n-                ExistentialPredicate::Trait(ExistentialTraitRef { substs, .. }) => {\n-                    substs.iter().all(|a| generic_arg_is_suggestible(a, tcx))\n-                }\n-                ExistentialPredicate::Projection(ExistentialProjection {\n-                    substs, term, ..\n-                }) => {\n-                    let term_is_suggestable = match term {\n-                        Term::Ty(ty) => ty.is_suggestable(tcx),\n-                        Term::Const(c) => const_is_suggestable(c.val()),\n-                    };\n-                    term_is_suggestable && substs.iter().all(|a| generic_arg_is_suggestible(a, tcx))\n-                }\n-                _ => true,\n-            }),\n-            Projection(ProjectionTy { substs: args, .. }) | Adt(_, args) => {\n-                args.iter().all(|a| generic_arg_is_suggestible(a, tcx))\n-            }\n-            Tuple(args) => args.iter().all(|ty| ty.is_suggestable(tcx)),\n-            Slice(ty) | RawPtr(TypeAndMut { ty, .. }) | Ref(_, ty, _) => ty.is_suggestable(tcx),\n-            Array(ty, c) => ty.is_suggestable(tcx) && const_is_suggestable(c.val()),\n-            _ => true,\n-        }\n+        self.visit_with(&mut IsSuggestableVisitor { tcx }).is_continue()\n     }\n }\n \n@@ -463,3 +399,67 @@ impl<'v> hir::intravisit::Visitor<'v> for StaticLifetimeVisitor<'v> {\n         }\n     }\n }\n+\n+pub struct IsSuggestableVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+}\n+\n+impl<'tcx> TypeVisitor<'tcx> for IsSuggestableVisitor<'tcx> {\n+    type BreakTy = ();\n+\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        match t.kind() {\n+            FnDef(..)\n+            | Closure(..)\n+            | Infer(..)\n+            | Generator(..)\n+            | GeneratorWitness(..)\n+            | Bound(_, _)\n+            | Placeholder(_)\n+            | Error(_) => {\n+                return ControlFlow::Break(());\n+            }\n+\n+            Opaque(did, _) => {\n+                let parent = self.tcx.parent(*did);\n+                if let hir::def::DefKind::TyAlias | hir::def::DefKind::AssocTy = self.tcx.def_kind(parent)\n+                    && let Opaque(parent_did, _) = self.tcx.type_of(parent).kind()\n+                    && parent_did == did\n+                {\n+                    // Okay\n+                } else {\n+                    return ControlFlow::Break(());\n+                }\n+            }\n+\n+            Dynamic(dty, _) => {\n+                for pred in *dty {\n+                    match pred.skip_binder() {\n+                        ExistentialPredicate::Trait(_) | ExistentialPredicate::Projection(_) => {\n+                            // Okay\n+                        }\n+                        _ => return ControlFlow::Break(()),\n+                    }\n+                }\n+            }\n+\n+            _ => {}\n+        }\n+\n+        t.super_visit_with(self)\n+    }\n+\n+    fn visit_const(&mut self, c: Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        match c.val() {\n+            ConstKind::Infer(..)\n+            | ConstKind::Bound(..)\n+            | ConstKind::Placeholder(..)\n+            | ConstKind::Error(..) => {\n+                return ControlFlow::Break(());\n+            }\n+            _ => {}\n+        }\n+\n+        c.super_visit_with(self)\n+    }\n+}"}]}