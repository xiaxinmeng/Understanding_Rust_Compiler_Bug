{"sha": "ee1e6529bddc4ea262e6453589a8042e0128594e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlMWU2NTI5YmRkYzRlYTI2MmU2NDUzNTg5YTgwNDJlMDEyODU5NGU=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-06T22:39:42Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-10-10T10:38:51Z"}, "message": "Implement BufferedReader.{read_until, read_line}\n\nThese two functions will be useful when replacing various other counterparts\nused by std::io consumers.", "tree": {"sha": "ef21691dab3dade61813b2cc579534f73cc519d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef21691dab3dade61813b2cc579534f73cc519d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee1e6529bddc4ea262e6453589a8042e0128594e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee1e6529bddc4ea262e6453589a8042e0128594e", "html_url": "https://github.com/rust-lang/rust/commit/ee1e6529bddc4ea262e6453589a8042e0128594e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee1e6529bddc4ea262e6453589a8042e0128594e/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "facefa7c8d1adf6c851dca88fcf4f5d26f72caa9", "url": "https://api.github.com/repos/rust-lang/rust/commits/facefa7c8d1adf6c851dca88fcf4f5d26f72caa9", "html_url": "https://github.com/rust-lang/rust/commit/facefa7c8d1adf6c851dca88fcf4f5d26f72caa9"}], "stats": {"total": 72, "additions": 65, "deletions": 7}, "files": [{"sha": "725477bec41ccded9259c7a9c41425b44359ba7f", "filename": "src/libstd/rt/io/buffered.rs", "status": "modified", "additions": 65, "deletions": 7, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/ee1e6529bddc4ea262e6453589a8042e0128594e/src%2Flibstd%2Frt%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee1e6529bddc4ea262e6453589a8042e0128594e/src%2Flibstd%2Frt%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fbuffered.rs?ref=ee1e6529bddc4ea262e6453589a8042e0128594e", "patch": "@@ -55,6 +55,7 @@ use prelude::*;\n \n use num;\n use vec;\n+use str;\n use super::{Reader, Writer, Stream, Decorator};\n \n // libuv recommends 64k buffers to maximize throughput\n@@ -84,23 +85,69 @@ impl<R: Reader> BufferedReader<R> {\n     pub fn new(inner: R) -> BufferedReader<R> {\n         BufferedReader::with_capacity(DEFAULT_CAPACITY, inner)\n     }\n-}\n \n-impl<R: Reader> Reader for BufferedReader<R> {\n-    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+    /// Reads the next line of input, interpreted as a sequence of utf-8\n+    /// encoded unicode codepoints. If a newline is encountered, then the\n+    /// newline is contained in the returned string.\n+    pub fn read_line(&mut self) -> ~str {\n+        str::from_utf8_owned(self.read_until('\\n' as u8))\n+    }\n+\n+    /// Reads a sequence of bytes leading up to a specified delimeter. Once the\n+    /// specified byte is encountered, reading ceases and the bytes up to and\n+    /// including the delimiter are returned.\n+    pub fn read_until(&mut self, byte: u8) -> ~[u8] {\n+        let mut res = ~[];\n+        let mut used;\n+        loop {\n+            {\n+                let available = self.fill_buffer();\n+                match available.iter().position(|&b| b == byte) {\n+                    Some(i) => {\n+                        res.push_all(available.slice_to(i + 1));\n+                        used = i + 1;\n+                        break\n+                    }\n+                    None => {\n+                        res.push_all(available);\n+                        used = available.len();\n+                    }\n+                }\n+            }\n+            if used == 0 {\n+                break\n+            }\n+            self.pos += used;\n+        }\n+        self.pos += used;\n+        return res;\n+    }\n+\n+    fn fill_buffer<'a>(&'a mut self) -> &'a [u8] {\n         if self.pos == self.cap {\n             match self.inner.read(self.buf) {\n                 Some(cap) => {\n                     self.pos = 0;\n                     self.cap = cap;\n                 }\n-                None => return None\n+                None => {}\n             }\n         }\n+        return self.buf.slice(self.pos, self.cap);\n+    }\n+}\n \n-        let src = self.buf.slice(self.pos, self.cap);\n-        let nread = num::min(src.len(), buf.len());\n-        vec::bytes::copy_memory(buf, src, nread);\n+impl<R: Reader> Reader for BufferedReader<R> {\n+    fn read(&mut self, buf: &mut [u8]) -> Option<uint> {\n+        let nread = {\n+            let available = self.fill_buffer();\n+            if available.len() == 0 {\n+                return None;\n+            }\n+            let nread = num::min(available.len(), buf.len());\n+            vec::bytes::copy_memory(buf, available, nread);\n+            nread\n+        };\n         self.pos += nread;\n         Some(nread)\n     }\n@@ -355,4 +402,15 @@ mod test {\n         stream.write(buf);\n         stream.flush();\n     }\n+\n+    #[test]\n+    fn test_read_until() {\n+        let inner = MemReader::new(~[0, 1, 2, 1, 0]);\n+        let mut reader = BufferedReader::with_capacity(2, inner);\n+        assert_eq!(reader.read_until(0), Some(~[0]));\n+        assert_eq!(reader.read_until(2), Some(~[1, 2]));\n+        assert_eq!(reader.read_until(1), Some(~[1]));\n+        assert_eq!(reader.read_until(8), Some(~[0]));\n+        assert_eq!(reader.read_until(9), None);\n+    }\n }"}]}