{"sha": "76e0129a21661029dc6cdbea2412ab53efe33aa1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2ZTAxMjlhMjE2NjEwMjlkYzZjZGJlYTI0MTJhYjUzZWZlMzNhYTE=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-22T09:39:20Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-22T09:39:20Z"}, "message": "Merge #1192\n\n1192: Add mbe expand limit and poision macro set r=maklad a=edwin0cheng\n\nAs discussed in Zulip, this PR add a token expansion limit in `parse_macro` and a \"poison\" macro set in `CrateDefMap` to prevent stack over flow and limit a mbe macro size.\r\n\r\nNote:\r\nRight now it only handle a poison macro in a single crate, such that if other crate try to call that macro, the whole process will do again until it became poisoned in that crate.\r\n\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "8da626b89a277722edd445798679339234596956", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8da626b89a277722edd445798679339234596956"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76e0129a21661029dc6cdbea2412ab53efe33aa1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76e0129a21661029dc6cdbea2412ab53efe33aa1", "html_url": "https://github.com/rust-lang/rust/commit/76e0129a21661029dc6cdbea2412ab53efe33aa1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76e0129a21661029dc6cdbea2412ab53efe33aa1/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "bbc5c1d24e1a641b134f634516828301e8cfc320", "url": "https://api.github.com/repos/rust-lang/rust/commits/bbc5c1d24e1a641b134f634516828301e8cfc320", "html_url": "https://github.com/rust-lang/rust/commit/bbc5c1d24e1a641b134f634516828301e8cfc320"}, {"sha": "ad1c3b5bd605942c85e4488b0483a0f50dc60942", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad1c3b5bd605942c85e4488b0483a0f50dc60942", "html_url": "https://github.com/rust-lang/rust/commit/ad1c3b5bd605942c85e4488b0483a0f50dc60942"}], "stats": {"total": 217, "additions": 202, "deletions": 15}, "files": [{"sha": "c7849c995b009ccf839cef94a1b7fea8b1070eba", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/76e0129a21661029dc6cdbea2412ab53efe33aa1/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e0129a21661029dc6cdbea2412ab53efe33aa1/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=76e0129a21661029dc6cdbea2412ab53efe33aa1", "patch": "@@ -94,6 +94,13 @@ fn parse_macro(\n \n     let macro_rules = db.macro_def(loc.def).ok_or(\"Fail to find macro definition\")?;\n     let tt = macro_rules.expand(&macro_arg).map_err(|err| format!(\"{:?}\", err))?;\n+\n+    // Set a hard limit for the expanded tt\n+    let count = tt.count();\n+    if count > 65536 {\n+        return Err(format!(\"Total tokens count exceed limit : count = {}\", count));\n+    }\n+\n     Ok(mbe::token_tree_to_ast_item_list(&tt))\n }\n "}, {"sha": "fbfff4fd785f0bbbbc78cf3cc9a120d8e3654e70", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/76e0129a21661029dc6cdbea2412ab53efe33aa1/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e0129a21661029dc6cdbea2412ab53efe33aa1/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=76e0129a21661029dc6cdbea2412ab53efe33aa1", "patch": "@@ -55,7 +55,7 @@ mod tests;\n \n use std::sync::Arc;\n \n-use rustc_hash::FxHashMap;\n+use rustc_hash::{FxHashMap, FxHashSet};\n use ra_arena::{Arena, RawId, impl_arena_id};\n use ra_db::{FileId, Edition};\n use test_utils::tested_by;\n@@ -91,6 +91,19 @@ pub struct CrateDefMap {\n     root: CrateModuleId,\n     modules: Arena<CrateModuleId, ModuleData>,\n     public_macros: FxHashMap<Name, MacroDefId>,\n+\n+    /// Some macros are not well-behavior, which leads to infinite loop\n+    /// e.g. macro_rules! foo { ($ty:ty) => { foo!($ty); } }\n+    /// We mark it down and skip it in collector\n+    ///\n+    /// FIXME:\n+    /// Right now it only handle a poison macro in a single crate,\n+    /// such that if other crate try to call that macro,\n+    /// the whole process will do again until it became poisoned in that crate.\n+    /// We should handle this macro set globally\n+    /// However, do we want to put it as a global variable?\n+    poison_macros: FxHashSet<MacroDefId>,\n+\n     diagnostics: Vec<DefDiagnostic>,\n }\n \n@@ -195,6 +208,7 @@ impl CrateDefMap {\n                 root,\n                 modules,\n                 public_macros: FxHashMap::default(),\n+                poison_macros: FxHashSet::default(),\n                 diagnostics: Vec::new(),\n             }\n         };"}, {"sha": "4590a5184b176730be5b73b468810a96c78a4963", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 154, "deletions": 11, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/76e0129a21661029dc6cdbea2412ab53efe33aa1/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e0129a21661029dc6cdbea2412ab53efe33aa1/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=76e0129a21661029dc6cdbea2412ab53efe33aa1", "patch": "@@ -42,12 +42,40 @@ pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> C\n         unresolved_imports: Vec::new(),\n         unexpanded_macros: Vec::new(),\n         global_macro_scope: FxHashMap::default(),\n-        marco_stack_count: 0,\n+        macro_stack_monitor: MacroStackMonitor::default(),\n     };\n     collector.collect();\n     collector.finish()\n }\n \n+#[derive(Default)]\n+struct MacroStackMonitor {\n+    counts: FxHashMap<MacroDefId, u32>,\n+\n+    /// Mainly use for test\n+    validator: Option<Box<dyn Fn(u32) -> bool>>,\n+}\n+\n+impl MacroStackMonitor {\n+    fn increase(&mut self, macro_def_id: MacroDefId) {\n+        *self.counts.entry(macro_def_id).or_default() += 1;\n+    }\n+\n+    fn decrease(&mut self, macro_def_id: MacroDefId) {\n+        *self.counts.entry(macro_def_id).or_default() -= 1;\n+    }\n+\n+    fn is_poison(&self, macro_def_id: MacroDefId) -> bool {\n+        let cur = *self.counts.get(&macro_def_id).unwrap_or(&0);\n+\n+        if let Some(validator) = &self.validator {\n+            validator(cur)\n+        } else {\n+            cur > 100\n+        }\n+    }\n+}\n+\n /// Walks the tree of module recursively\n struct DefCollector<DB> {\n     db: DB,\n@@ -59,7 +87,7 @@ struct DefCollector<DB> {\n \n     /// Some macro use `$tt:tt which mean we have to handle the macro perfectly\n     /// To prevent stackoverflow, we add a deep counter here for prevent that.\n-    marco_stack_count: u32,\n+    macro_stack_monitor: MacroStackMonitor,\n }\n \n impl<'a, DB> DefCollector<&'a DB>\n@@ -317,30 +345,40 @@ where\n             let def_map = self.db.crate_def_map(krate);\n             if let Some(macro_id) = def_map.public_macros.get(&path.segments[1].name).cloned() {\n                 let call_id = MacroCallLoc { def: macro_id, ast_id: *ast_id }.id(self.db);\n-                resolved.push((*module_id, call_id));\n+                resolved.push((*module_id, call_id, macro_id));\n             }\n             false\n         });\n \n-        for (module_id, macro_call_id) in resolved {\n-            self.collect_macro_expansion(module_id, macro_call_id);\n+        for (module_id, macro_call_id, macro_def_id) in resolved {\n+            self.collect_macro_expansion(module_id, macro_call_id, macro_def_id);\n         }\n         res\n     }\n \n-    fn collect_macro_expansion(&mut self, module_id: CrateModuleId, macro_call_id: MacroCallId) {\n-        self.marco_stack_count += 1;\n+    fn collect_macro_expansion(\n+        &mut self,\n+        module_id: CrateModuleId,\n+        macro_call_id: MacroCallId,\n+        macro_def_id: MacroDefId,\n+    ) {\n+        if self.def_map.poison_macros.contains(&macro_def_id) {\n+            return;\n+        }\n+\n+        self.macro_stack_monitor.increase(macro_def_id);\n \n-        if self.marco_stack_count < 300 {\n+        if !self.macro_stack_monitor.is_poison(macro_def_id) {\n             let file_id: HirFileId = macro_call_id.into();\n             let raw_items = self.db.raw_items(file_id);\n             ModCollector { def_collector: &mut *self, file_id, module_id, raw_items: &raw_items }\n-                .collect(raw_items.items())\n+                .collect(raw_items.items());\n         } else {\n             log::error!(\"Too deep macro expansion: {}\", macro_call_id.debug_dump(self.db));\n+            self.def_map.poison_macros.insert(macro_def_id);\n         }\n \n-        self.marco_stack_count -= 1;\n+        self.macro_stack_monitor.decrease(macro_def_id);\n     }\n \n     fn finish(self) -> CrateDefMap {\n@@ -484,7 +522,7 @@ where\n         {\n             let macro_call_id = MacroCallLoc { def: macro_id, ast_id }.id(self.def_collector.db);\n \n-            self.def_collector.collect_macro_expansion(self.module_id, macro_call_id);\n+            self.def_collector.collect_macro_expansion(self.module_id, macro_call_id, macro_id);\n             return;\n         }\n \n@@ -530,3 +568,108 @@ fn resolve_submodule(\n         None => Err(if is_dir_owner { file_mod } else { file_dir_mod }),\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    use ra_db::SourceDatabase;\n+\n+    use crate::{Crate, mock::MockDatabase, DefDatabase};\n+    use ra_arena::{Arena};\n+    use super::*;\n+    use rustc_hash::FxHashSet;\n+\n+    fn do_collect_defs(\n+        db: &impl DefDatabase,\n+        def_map: CrateDefMap,\n+        monitor: MacroStackMonitor,\n+    ) -> CrateDefMap {\n+        let mut collector = DefCollector {\n+            db,\n+            def_map,\n+            glob_imports: FxHashMap::default(),\n+            unresolved_imports: Vec::new(),\n+            unexpanded_macros: Vec::new(),\n+            global_macro_scope: FxHashMap::default(),\n+            macro_stack_monitor: monitor,\n+        };\n+        collector.collect();\n+        collector.finish()\n+    }\n+\n+    fn do_limited_resolve(code: &str, limit: u32, poison_limit: u32) -> CrateDefMap {\n+        let (db, _source_root, _) = MockDatabase::with_single_file(&code);\n+        let crate_id = db.crate_graph().iter().next().unwrap();\n+        let krate = Crate { crate_id };\n+\n+        let def_map = {\n+            let edition = krate.edition(&db);\n+            let mut modules: Arena<CrateModuleId, ModuleData> = Arena::default();\n+            let root = modules.alloc(ModuleData::default());\n+            CrateDefMap {\n+                krate,\n+                edition,\n+                extern_prelude: FxHashMap::default(),\n+                prelude: None,\n+                root,\n+                modules,\n+                public_macros: FxHashMap::default(),\n+                poison_macros: FxHashSet::default(),\n+                diagnostics: Vec::new(),\n+            }\n+        };\n+\n+        let mut monitor = MacroStackMonitor::default();\n+        monitor.validator = Some(Box::new(move |count| {\n+            assert!(count < limit);\n+            count >= poison_limit\n+        }));\n+\n+        do_collect_defs(&db, def_map, monitor)\n+    }\n+\n+    #[test]\n+    fn test_macro_expand_limit_width() {\n+        do_limited_resolve(\n+            r#\"\n+        macro_rules! foo {\n+            ($($ty:ty)*) => { foo!($($ty)*, $($ty)*); }\n+        }\n+foo!(KABOOM);\n+        \"#,\n+            16,\n+            1000,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_macro_expand_poisoned() {\n+        let def = do_limited_resolve(\n+            r#\"\n+        macro_rules! foo {\n+            ($ty:ty) => { foo!($ty); }\n+        }\n+foo!(KABOOM);\n+        \"#,\n+            100,\n+            16,\n+        );\n+\n+        assert_eq!(def.poison_macros.len(), 1);\n+    }\n+\n+    #[test]\n+    fn test_macro_expand_normal() {\n+        let def = do_limited_resolve(\n+            r#\"\n+        macro_rules! foo {\n+            ($ident:ident) => { struct $ident {} }\n+        }\n+foo!(Bar);\n+        \"#,\n+            16,\n+            16,\n+        );\n+\n+        assert_eq!(def.poison_macros.len(), 0);\n+    }\n+}"}, {"sha": "f07107414b89b9cdd7828d20321dbacfafdf489d", "filename": "crates/ra_mbe/src/subtree_parser.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/76e0129a21661029dc6cdbea2412ab53efe33aa1/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e0129a21661029dc6cdbea2412ab53efe33aa1/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs?ref=76e0129a21661029dc6cdbea2412ab53efe33aa1", "patch": "@@ -5,6 +5,7 @@ use ra_syntax::{SyntaxKind};\n \n struct OffsetTokenSink {\n     token_pos: usize,\n+    error: bool,\n }\n \n impl TreeSink for OffsetTokenSink {\n@@ -13,7 +14,9 @@ impl TreeSink for OffsetTokenSink {\n     }\n     fn start_node(&mut self, _kind: SyntaxKind) {}\n     fn finish_node(&mut self) {}\n-    fn error(&mut self, _error: ra_parser::ParseError) {}\n+    fn error(&mut self, _error: ra_parser::ParseError) {\n+        self.error = true;\n+    }\n }\n \n pub(crate) struct Parser<'a> {\n@@ -67,11 +70,15 @@ impl<'a> Parser<'a> {\n         F: FnOnce(&dyn TokenSource, &mut dyn TreeSink),\n     {\n         let mut src = SubtreeTokenSource::new(&self.subtree.token_trees[*self.cur_pos..]);\n-        let mut sink = OffsetTokenSink { token_pos: 0 };\n+        let mut sink = OffsetTokenSink { token_pos: 0, error: false };\n \n         f(&src, &mut sink);\n \n-        self.finish(sink.token_pos, &mut src)\n+        let r = self.finish(sink.token_pos, &mut src);\n+        if sink.error {\n+            return None;\n+        }\n+        r\n     }\n \n     fn finish(self, parsed_token: usize, src: &mut SubtreeTokenSource) -> Option<tt::TokenTree> {"}, {"sha": "62c5ac52a4e126410092a2083ef6fbb4cb52cc75", "filename": "crates/ra_tt/src/lib.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/76e0129a21661029dc6cdbea2412ab53efe33aa1/crates%2Fra_tt%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e0129a21661029dc6cdbea2412ab53efe33aa1/crates%2Fra_tt%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_tt%2Fsrc%2Flib.rs?ref=76e0129a21661029dc6cdbea2412ab53efe33aa1", "patch": "@@ -149,3 +149,19 @@ impl fmt::Display for Punct {\n         fmt::Display::fmt(&self.char, f)\n     }\n }\n+\n+impl Subtree {\n+    /// Count the number of tokens recursively\n+    pub fn count(&self) -> usize {\n+        let children_count = self\n+            .token_trees\n+            .iter()\n+            .map(|c| match c {\n+                TokenTree::Subtree(c) => c.count(),\n+                _ => 0,\n+            })\n+            .sum::<usize>();\n+\n+        self.token_trees.len() + children_count\n+    }\n+}"}]}