{"sha": "3cb1811e459d1cf30dcb553ab99ce090cd5c76f1", "node_id": "C_kwDOAAsO6NoAKDNjYjE4MTFlNDU5ZDFjZjMwZGNiNTUzYWI5OWNlMDkwY2Q1Yzc2ZjE", "commit": {"author": {"name": "Deadbeef", "email": "ent3rm4n@gmail.com", "date": "2022-07-22T16:48:36Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-10-01T14:12:50Z"}, "message": "Compute `lint_levels` by definition", "tree": {"sha": "ba405b86869d065cae3b192f5197f452bf38c1ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba405b86869d065cae3b192f5197f452bf38c1ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3cb1811e459d1cf30dcb553ab99ce090cd5c76f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3cb1811e459d1cf30dcb553ab99ce090cd5c76f1", "html_url": "https://github.com/rust-lang/rust/commit/3cb1811e459d1cf30dcb553ab99ce090cd5c76f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3cb1811e459d1cf30dcb553ab99ce090cd5c76f1/comments", "author": {"login": "fee1-dead", "id": 43851243, "node_id": "MDQ6VXNlcjQzODUxMjQz", "avatar_url": "https://avatars.githubusercontent.com/u/43851243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fee1-dead", "html_url": "https://github.com/fee1-dead", "followers_url": "https://api.github.com/users/fee1-dead/followers", "following_url": "https://api.github.com/users/fee1-dead/following{/other_user}", "gists_url": "https://api.github.com/users/fee1-dead/gists{/gist_id}", "starred_url": "https://api.github.com/users/fee1-dead/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fee1-dead/subscriptions", "organizations_url": "https://api.github.com/users/fee1-dead/orgs", "repos_url": "https://api.github.com/users/fee1-dead/repos", "events_url": "https://api.github.com/users/fee1-dead/events{/privacy}", "received_events_url": "https://api.github.com/users/fee1-dead/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6019cbbfd3121d294c4705528ee66642e31ccf79", "url": "https://api.github.com/repos/rust-lang/rust/commits/6019cbbfd3121d294c4705528ee66642e31ccf79", "html_url": "https://github.com/rust-lang/rust/commit/6019cbbfd3121d294c4705528ee66642e31ccf79"}], "stats": {"total": 816, "additions": 482, "deletions": 334}, "files": [{"sha": "31e410aaaf082fc1c7a32c364439cf097e2ba531", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3cb1811e459d1cf30dcb553ab99ce090cd5c76f1/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb1811e459d1cf30dcb553ab99ce090cd5c76f1/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=3cb1811e459d1cf30dcb553ab99ce090cd5c76f1", "patch": "@@ -364,9 +364,10 @@ impl Diagnostic {\n             // The lint index inside the attribute is manually transferred here.\n             let lint_index = expectation_id.get_lint_index();\n             expectation_id.set_lint_index(None);\n-            let mut stable_id = *unstable_to_stable\n+            let mut stable_id = unstable_to_stable\n                 .get(&expectation_id)\n-                .expect(\"each unstable `LintExpectationId` must have a matching stable id\");\n+                .expect(\"each unstable `LintExpectationId` must have a matching stable id\")\n+                .normalize();\n \n             stable_id.set_lint_index(lint_index);\n             *expectation_id = stable_id;"}, {"sha": "7c312da62793f03ff0acfbd4835dade4e6a7dc6b", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cb1811e459d1cf30dcb553ab99ce090cd5c76f1/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb1811e459d1cf30dcb553ab99ce090cd5c76f1/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=3cb1811e459d1cf30dcb553ab99ce090cd5c76f1", "patch": "@@ -1211,7 +1211,7 @@ impl HandlerInner {\n \n         if let Some(expectation_id) = diagnostic.level.get_expectation_id() {\n             self.suppressed_expected_diag = true;\n-            self.fulfilled_expectations.insert(expectation_id);\n+            self.fulfilled_expectations.insert(expectation_id.normalize());\n         }\n \n         if matches!(diagnostic.level, Warning(_))"}, {"sha": "74e35afc87d7bac343e7a389ae1accafb2a9dc74", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3cb1811e459d1cf30dcb553ab99ce090cd5c76f1/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb1811e459d1cf30dcb553ab99ce090cd5c76f1/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=3cb1811e459d1cf30dcb553ab99ce090cd5c76f1", "patch": "@@ -558,7 +558,7 @@ pub struct LateContext<'tcx> {\n \n /// Context for lint checking of the AST, after expansion, before lowering to HIR.\n pub struct EarlyContext<'a> {\n-    pub builder: LintLevelsBuilder<'a>,\n+    pub builder: LintLevelsBuilder<'a, crate::levels::TopDown>,\n     pub buffered: LintBuffer,\n }\n "}, {"sha": "f7759bec908b40682bb455a0ffb66229a56eb388", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3cb1811e459d1cf30dcb553ab99ce090cd5c76f1/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb1811e459d1cf30dcb553ab99ce090cd5c76f1/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=3cb1811e459d1cf30dcb553ab99ce090cd5c76f1", "patch": "@@ -58,6 +58,7 @@ impl<'a, T: EarlyLintPass> EarlyContextAndPass<'a, T> {\n         F: FnOnce(&mut Self),\n     {\n         let is_crate_node = id == ast::CRATE_NODE_ID;\n+        debug!(?id);\n         let push = self.context.builder.push(attrs, is_crate_node, None);\n \n         self.check_id(id);"}, {"sha": "4c3c39734dd6fcb9f7a039b56c64bc86237c0eaa", "filename": "compiler/rustc_lint/src/expect.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3cb1811e459d1cf30dcb553ab99ce090cd5c76f1/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb1811e459d1cf30dcb553ab99ce090cd5c76f1/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs?ref=3cb1811e459d1cf30dcb553ab99ce090cd5c76f1", "patch": "@@ -16,8 +16,10 @@ fn check_expectations(tcx: TyCtxt<'_>, tool_filter: Option<Symbol>) {\n         return;\n     }\n \n+    let lint_expectations = tcx.lint_expectations(());\n     let fulfilled_expectations = tcx.sess.diagnostic().steal_fulfilled_expectation_ids();\n-    let lint_expectations = &tcx.lint_levels(()).lint_expectations;\n+\n+    tracing::debug!(?lint_expectations, ?fulfilled_expectations);\n \n     for (id, expectation) in lint_expectations {\n         // This check will always be true, since `lint_expectations` only"}, {"sha": "ab4ee6e3f06780238d33adfabad99f6afee575e0", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 310, "deletions": 278, "changes": 588, "blob_url": "https://github.com/rust-lang/rust/blob/3cb1811e459d1cf30dcb553ab99ce090cd5c76f1/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb1811e459d1cf30dcb553ab99ce090cd5c76f1/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=3cb1811e459d1cf30dcb553ab99ce090cd5c76f1", "patch": "@@ -8,7 +8,7 @@ use rustc_hir as hir;\n use rustc_hir::{intravisit, HirId};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::lint::{\n-    struct_lint_level, LevelAndSource, LintExpectation, LintLevelMap, LintLevelSets,\n+    struct_lint_level, LevelAndSource, LintExpectation, LintLevelQueryMap, LintLevelSets,\n     LintLevelSource, LintSet, LintStackIndex, COMMAND_LINE,\n };\n use rustc_middle::ty::query::Providers;\n@@ -27,35 +27,199 @@ use crate::errors::{\n     UnknownToolInScopedLint,\n };\n \n-fn lint_levels(tcx: TyCtxt<'_>, (): ()) -> LintLevelMap {\n+fn lint_expectations(tcx: TyCtxt<'_>, (): ()) -> Vec<(LintExpectationId, LintExpectation)> {\n     let store = unerased_lint_store(tcx);\n-    let levels =\n-        LintLevelsBuilder::new(tcx.sess, false, &store, &tcx.resolutions(()).registered_tools);\n-    let mut builder = LintLevelMapBuilder { levels, tcx };\n-    let krate = tcx.hir().krate();\n \n-    builder.levels.id_to_set.reserve(krate.owners.len() + 1);\n+    let mut builder = LintLevelsBuilder {\n+        sess: tcx.sess,\n+        provider: QueryMapExpectationsWrapper {\n+            map: LintLevelQueryMap { tcx, cur: hir::CRATE_HIR_ID, specs: FxHashMap::default() },\n+            expectations: Vec::new(),\n+            unstable_to_stable_ids: FxHashMap::default(),\n+        },\n+        warn_about_weird_lints: false,\n+        store,\n+        registered_tools: &tcx.resolutions(()).registered_tools,\n+    };\n+\n+    builder.add_command_line();\n+    builder.add_id(hir::CRATE_HIR_ID);\n+    tcx.hir().walk_toplevel_module(&mut builder);\n \n-    let push =\n-        builder.levels.push(tcx.hir().attrs(hir::CRATE_HIR_ID), true, Some(hir::CRATE_HIR_ID));\n+    tcx.sess.diagnostic().update_unstable_expectation_id(&builder.provider.unstable_to_stable_ids);\n \n-    builder.levels.register_id(hir::CRATE_HIR_ID);\n-    tcx.hir().walk_toplevel_module(&mut builder);\n-    builder.levels.pop(push);\n+    builder.provider.expectations\n+}\n+\n+fn lint_levels_on(tcx: TyCtxt<'_>, hir_id: HirId) -> FxHashMap<LintId, LevelAndSource> {\n+    let store = unerased_lint_store(tcx);\n+\n+    let mut levels = LintLevelsBuilder {\n+        sess: tcx.sess,\n+        provider: LintLevelQueryMap { tcx, cur: hir_id, specs: FxHashMap::default() },\n+        warn_about_weird_lints: false,\n+        store,\n+        registered_tools: &tcx.resolutions(()).registered_tools,\n+    };\n+\n+    let is_crate = hir::CRATE_HIR_ID == hir_id;\n+    if is_crate {\n+        levels.add_command_line();\n+    }\n+    debug!(?hir_id);\n+    levels.add(tcx.hir().attrs(hir_id), is_crate, Some(hir_id));\n \n-    builder.levels.update_unstable_expectation_ids();\n-    builder.levels.build_map()\n+    levels.provider.specs\n }\n \n-pub struct LintLevelsBuilder<'s> {\n-    sess: &'s Session,\n-    lint_expectations: Vec<(LintExpectationId, LintExpectation)>,\n-    /// Each expectation has a stable and an unstable identifier. This map\n-    /// is used to map from unstable to stable [`LintExpectationId`]s.\n-    expectation_id_map: FxHashMap<LintExpectationId, LintExpectationId>,\n+pub struct TopDown {\n     sets: LintLevelSets,\n-    id_to_set: FxHashMap<HirId, LintStackIndex>,\n     cur: LintStackIndex,\n+}\n+\n+pub struct QueryMapExpectationsWrapper<'tcx> {\n+    map: LintLevelQueryMap<'tcx>,\n+    expectations: Vec<(LintExpectationId, LintExpectation)>,\n+    unstable_to_stable_ids: FxHashMap<LintExpectationId, LintExpectationId>,\n+}\n+\n+pub trait LintLevelsProvider {\n+    fn current_specs(&self) -> &FxHashMap<LintId, LevelAndSource>;\n+    fn current_specs_mut(&mut self) -> &mut FxHashMap<LintId, LevelAndSource>;\n+    fn get_lint_level(&self, lint: &'static Lint, sess: &Session) -> LevelAndSource;\n+    fn push_expectation(&mut self, _id: LintExpectationId, _expectation: LintExpectation) {}\n+}\n+\n+impl LintLevelsProvider for TopDown {\n+    fn current_specs(&self) -> &FxHashMap<LintId, LevelAndSource> {\n+        &self.sets.list[self.cur].specs\n+    }\n+\n+    fn current_specs_mut(&mut self) -> &mut FxHashMap<LintId, LevelAndSource> {\n+        &mut self.sets.list[self.cur].specs\n+    }\n+\n+    fn get_lint_level(&self, lint: &'static Lint, sess: &Session) -> LevelAndSource {\n+        self.sets.get_lint_level(lint, self.cur, Some(self.current_specs()), sess)\n+    }\n+}\n+\n+impl LintLevelsProvider for LintLevelQueryMap<'_> {\n+    fn current_specs(&self) -> &FxHashMap<LintId, LevelAndSource> {\n+        &self.specs\n+    }\n+    fn current_specs_mut(&mut self) -> &mut FxHashMap<LintId, LevelAndSource> {\n+        &mut self.specs\n+    }\n+    fn get_lint_level(&self, lint: &'static Lint, _: &Session) -> LevelAndSource {\n+        self.lint_level(lint)\n+    }\n+}\n+\n+impl LintLevelsProvider for QueryMapExpectationsWrapper<'_> {\n+    fn current_specs(&self) -> &FxHashMap<LintId, LevelAndSource> {\n+        &self.map.specs\n+    }\n+    fn current_specs_mut(&mut self) -> &mut FxHashMap<LintId, LevelAndSource> {\n+        self.map.specs.clear();\n+        &mut self.map.specs\n+    }\n+    fn get_lint_level(&self, lint: &'static Lint, _: &Session) -> LevelAndSource {\n+        self.map.lint_level(lint)\n+    }\n+    fn push_expectation(&mut self, id: LintExpectationId, expectation: LintExpectation) {\n+        let LintExpectationId::Stable { attr_id: Some(attr_id), hir_id, attr_index, .. } = id else { bug!(\"unstable expectation id should already be mapped\") };\n+        let key = LintExpectationId::Unstable { attr_id, lint_index: None };\n+\n+        if !self.unstable_to_stable_ids.contains_key(&key) {\n+            self.unstable_to_stable_ids.insert(\n+                key,\n+                LintExpectationId::Stable { hir_id, attr_index, lint_index: None, attr_id: None },\n+            );\n+        }\n+\n+        self.expectations.push((id.normalize(), expectation));\n+    }\n+}\n+\n+impl<'tcx> LintLevelsBuilder<'_, QueryMapExpectationsWrapper<'tcx>> {\n+    fn add_id(&mut self, hir_id: HirId) {\n+        self.add(\n+            self.provider.map.tcx.hir().attrs(hir_id),\n+            hir_id == hir::CRATE_HIR_ID,\n+            Some(hir_id),\n+        );\n+    }\n+}\n+\n+impl<'tcx> intravisit::Visitor<'tcx> for LintLevelsBuilder<'_, QueryMapExpectationsWrapper<'tcx>> {\n+    type NestedFilter = nested_filter::All;\n+\n+    fn nested_visit_map(&mut self) -> Self::Map {\n+        self.provider.map.tcx.hir()\n+    }\n+\n+    fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n+        self.add_id(param.hir_id);\n+        intravisit::walk_param(self, param);\n+    }\n+\n+    fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n+        self.add_id(it.hir_id());\n+        intravisit::walk_item(self, it);\n+    }\n+\n+    fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem<'tcx>) {\n+        self.add_id(it.hir_id());\n+        intravisit::walk_foreign_item(self, it);\n+    }\n+\n+    fn visit_stmt(&mut self, e: &'tcx hir::Stmt<'tcx>) {\n+        // We will call `add_id` when we walk\n+        // the `StmtKind`. The outer statement itself doesn't\n+        // define the lint levels.\n+        intravisit::walk_stmt(self, e);\n+    }\n+\n+    fn visit_expr(&mut self, e: &'tcx hir::Expr<'tcx>) {\n+        self.add_id(e.hir_id);\n+        intravisit::walk_expr(self, e);\n+    }\n+\n+    fn visit_field_def(&mut self, s: &'tcx hir::FieldDef<'tcx>) {\n+        self.add_id(s.hir_id);\n+        intravisit::walk_field_def(self, s);\n+    }\n+\n+    fn visit_variant(&mut self, v: &'tcx hir::Variant<'tcx>) {\n+        self.add_id(v.id);\n+        intravisit::walk_variant(self, v);\n+    }\n+\n+    fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n+        self.add_id(l.hir_id);\n+        intravisit::walk_local(self, l);\n+    }\n+\n+    fn visit_arm(&mut self, a: &'tcx hir::Arm<'tcx>) {\n+        self.add_id(a.hir_id);\n+        intravisit::walk_arm(self, a);\n+    }\n+\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n+        self.add_id(trait_item.hir_id());\n+        intravisit::walk_trait_item(self, trait_item);\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n+        self.add_id(impl_item.hir_id());\n+        intravisit::walk_impl_item(self, impl_item);\n+    }\n+}\n+\n+pub struct LintLevelsBuilder<'s, P> {\n+    sess: &'s Session,\n+    provider: P,\n     warn_about_weird_lints: bool,\n     store: &'s LintStore,\n     registered_tools: &'s RegisteredTools,\n@@ -66,7 +230,7 @@ pub struct BuilderPush {\n     pub changed: bool,\n }\n \n-impl<'s> LintLevelsBuilder<'s> {\n+impl<'s> LintLevelsBuilder<'s, TopDown> {\n     pub fn new(\n         sess: &'s Session,\n         warn_about_weird_lints: bool,\n@@ -75,20 +239,66 @@ impl<'s> LintLevelsBuilder<'s> {\n     ) -> Self {\n         let mut builder = LintLevelsBuilder {\n             sess,\n-            lint_expectations: Default::default(),\n-            expectation_id_map: Default::default(),\n-            sets: LintLevelSets::new(),\n-            cur: COMMAND_LINE,\n-            id_to_set: Default::default(),\n+            provider: TopDown { sets: LintLevelSets::new(), cur: COMMAND_LINE },\n             warn_about_weird_lints,\n             store,\n             registered_tools,\n         };\n-        builder.process_command_line(sess, store);\n-        assert_eq!(builder.sets.list.len(), 1);\n+        builder.process_command_line();\n+        assert_eq!(builder.provider.sets.list.len(), 1);\n         builder\n     }\n \n+    fn process_command_line(&mut self) {\n+        self.provider.cur = self\n+            .provider\n+            .sets\n+            .list\n+            .push(LintSet { specs: FxHashMap::default(), parent: COMMAND_LINE });\n+        self.add_command_line();\n+    }\n+\n+    /// Pushes a list of AST lint attributes onto this context.\n+    ///\n+    /// This function will return a `BuilderPush` object which should be passed\n+    /// to `pop` when this scope for the attributes provided is exited.\n+    ///\n+    /// This function will perform a number of tasks:\n+    ///\n+    /// * It'll validate all lint-related attributes in `attrs`\n+    /// * It'll mark all lint-related attributes as used\n+    /// * Lint levels will be updated based on the attributes provided\n+    /// * Lint attributes are validated, e.g., a `#[forbid]` can't be switched to\n+    ///   `#[allow]`\n+    ///\n+    /// Don't forget to call `pop`!\n+    pub(crate) fn push(\n+        &mut self,\n+        attrs: &[ast::Attribute],\n+        is_crate_node: bool,\n+        source_hir_id: Option<HirId>,\n+    ) -> BuilderPush {\n+        let prev = self.provider.cur;\n+        self.provider.cur =\n+            self.provider.sets.list.push(LintSet { specs: FxHashMap::default(), parent: prev });\n+\n+        self.add(attrs, is_crate_node, source_hir_id);\n+\n+        if self.provider.current_specs().is_empty() {\n+            self.provider.sets.list.pop();\n+            self.provider.cur = prev;\n+        }\n+\n+        BuilderPush { prev, changed: prev != self.provider.cur }\n+    }\n+\n+    /// Called after `push` when the scope of a set of attributes are exited.\n+    pub fn pop(&mut self, push: BuilderPush) {\n+        self.provider.cur = push.prev;\n+    }\n+}\n+\n+impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n     pub(crate) fn sess(&self) -> &Session {\n         self.sess\n     }\n@@ -98,24 +308,20 @@ impl<'s> LintLevelsBuilder<'s> {\n     }\n \n     fn current_specs(&self) -> &FxHashMap<LintId, LevelAndSource> {\n-        &self.sets.list[self.cur].specs\n+        self.provider.current_specs()\n     }\n \n     fn current_specs_mut(&mut self) -> &mut FxHashMap<LintId, LevelAndSource> {\n-        &mut self.sets.list[self.cur].specs\n+        self.provider.current_specs_mut()\n     }\n \n-    fn process_command_line(&mut self, sess: &Session, store: &LintStore) {\n-        self.sets.lint_cap = sess.opts.lint_cap.unwrap_or(Level::Forbid);\n-\n-        self.cur =\n-            self.sets.list.push(LintSet { specs: FxHashMap::default(), parent: COMMAND_LINE });\n-        for &(ref lint_name, level) in &sess.opts.lint_opts {\n-            store.check_lint_name_cmdline(sess, &lint_name, level, self.registered_tools);\n+    fn add_command_line(&mut self) {\n+        for &(ref lint_name, level) in &self.sess.opts.lint_opts {\n+            self.store.check_lint_name_cmdline(self.sess, &lint_name, level, self.registered_tools);\n             let orig_level = level;\n             let lint_flag_val = Symbol::intern(lint_name);\n \n-            let Ok(ids) = store.find_lints(&lint_name) else {\n+            let Ok(ids) = self.store.find_lints(&lint_name) else {\n                 // errors handled in check_lint_name_cmdline above\n                 continue\n             };\n@@ -138,9 +344,11 @@ impl<'s> LintLevelsBuilder<'s> {\n     /// Attempts to insert the `id` to `level_src` map entry. If unsuccessful\n     /// (e.g. if a forbid was already inserted on the same scope), then emits a\n     /// diagnostic with no change to `specs`.\n-    fn insert_spec(&mut self, id: LintId, (level, src): LevelAndSource) {\n-        let (old_level, old_src) =\n-            self.sets.get_lint_level(id.lint, self.cur, Some(self.current_specs()), &self.sess);\n+    fn insert_spec(&mut self, id: LintId, (mut level, src): LevelAndSource) {\n+        let (old_level, old_src) = self.provider.get_lint_level(id.lint, &self.sess);\n+        if let Level::Expect(id) = &mut level && let LintExpectationId::Stable { .. } = id {\n+            *id = id.normalize();\n+        }\n         // Setting to a non-forbid level is an error if the lint previously had\n         // a forbid level. Note that this is not necessarily true even with a\n         // `#[forbid(..)]` attribute present, as that is overridden by `--cap-lints`.\n@@ -158,7 +366,7 @@ impl<'s> LintLevelsBuilder<'s> {\n                 let id_name = id.lint.name_lower();\n                 let fcw_warning = match old_src {\n                     LintLevelSource::Default => false,\n-                    LintLevelSource::Node(symbol, _, _) => self.store.is_lint_group(symbol),\n+                    LintLevelSource::Node { name, .. } => self.store.is_lint_group(name),\n                     LintLevelSource::CommandLine(symbol, _) => self.store.is_lint_group(symbol),\n                 };\n                 debug!(\n@@ -178,8 +386,8 @@ impl<'s> LintLevelsBuilder<'s> {\n                                 id.to_string()\n                             ));\n                         }\n-                        LintLevelSource::Node(_, forbid_source_span, reason) => {\n-                            diag.span_label(forbid_source_span, \"`forbid` level set here\");\n+                        LintLevelSource::Node { span, reason, .. } => {\n+                            diag.span_label(span, \"`forbid` level set here\");\n                             if let Some(rationale) = reason {\n                                 diag.note(rationale.as_str());\n                             }\n@@ -199,11 +407,8 @@ impl<'s> LintLevelsBuilder<'s> {\n                             LintLevelSource::Default => {\n                                 OverruledAttributeSub::DefaultSource { id: id.to_string() }\n                             }\n-                            LintLevelSource::Node(_, forbid_source_span, reason) => {\n-                                OverruledAttributeSub::NodeSource {\n-                                    span: forbid_source_span,\n-                                    reason,\n-                                }\n+                            LintLevelSource::Node { span, reason, .. } => {\n+                                OverruledAttributeSub::NodeSource { span, reason }\n                             }\n                             LintLevelSource::CommandLine(_, _) => {\n                                 OverruledAttributeSub::CommandLineSource\n@@ -256,29 +461,7 @@ impl<'s> LintLevelsBuilder<'s> {\n         };\n     }\n \n-    /// Pushes a list of AST lint attributes onto this context.\n-    ///\n-    /// This function will return a `BuilderPush` object which should be passed\n-    /// to `pop` when this scope for the attributes provided is exited.\n-    ///\n-    /// This function will perform a number of tasks:\n-    ///\n-    /// * It'll validate all lint-related attributes in `attrs`\n-    /// * It'll mark all lint-related attributes as used\n-    /// * Lint levels will be updated based on the attributes provided\n-    /// * Lint attributes are validated, e.g., a `#[forbid]` can't be switched to\n-    ///   `#[allow]`\n-    ///\n-    /// Don't forget to call `pop`!\n-    pub(crate) fn push(\n-        &mut self,\n-        attrs: &[ast::Attribute],\n-        is_crate_node: bool,\n-        source_hir_id: Option<HirId>,\n-    ) -> BuilderPush {\n-        let prev = self.cur;\n-        self.cur = self.sets.list.push(LintSet { specs: FxHashMap::default(), parent: prev });\n-\n+    fn add(&mut self, attrs: &[ast::Attribute], is_crate_node: bool, source_hir_id: Option<HirId>) {\n         let sess = self.sess;\n         for (attr_index, attr) in attrs.iter().enumerate() {\n             if attr.has_name(sym::automatically_derived) {\n@@ -293,7 +476,17 @@ impl<'s> LintLevelsBuilder<'s> {\n                 None => continue,\n                 // This is the only lint level with a `LintExpectationId` that can be created from an attribute\n                 Some(Level::Expect(unstable_id)) if let Some(hir_id) = source_hir_id => {\n-                    let stable_id = self.create_stable_id(unstable_id, hir_id, attr_index);\n+                    let LintExpectationId::Unstable { attr_id, lint_index } = unstable_id\n+                        else { bug!(\"stable id Level::from_attr\") };\n+\n+                    let stable_id = LintExpectationId::Stable {\n+                        hir_id,\n+                        attr_index: attr_index.try_into().unwrap(),\n+                        lint_index,\n+                        // we pass the previous unstable attr_id such that we can trace the ast id when building a map\n+                        // to go from unstable to stable id.\n+                        attr_id: Some(attr_id),\n+                    };\n \n                     Level::Expect(stable_id)\n                 }\n@@ -408,21 +601,28 @@ impl<'s> LintLevelsBuilder<'s> {\n                                 [lint] => *lint == LintId::of(UNFULFILLED_LINT_EXPECTATIONS),\n                                 _ => false,\n                             };\n-                            self.lint_expectations.push((\n+                            self.provider.push_expectation(\n                                 expect_id,\n                                 LintExpectation::new(\n                                     reason,\n                                     sp,\n                                     is_unfulfilled_lint_expectations,\n                                     tool_name,\n                                 ),\n-                            ));\n+                            );\n                         }\n-                        let src = LintLevelSource::Node(\n-                            meta_item.path.segments.last().expect(\"empty lint name\").ident.name,\n-                            sp,\n+                        let src = LintLevelSource::Node {\n+                            name: meta_item\n+                                .path\n+                                .segments\n+                                .last()\n+                                .expect(\"empty lint name\")\n+                                .ident\n+                                .name,\n+                            span: sp,\n                             reason,\n-                        );\n+                            tool: tool_name,\n+                        };\n                         for &id in *ids {\n                             if self.check_gated_lint(id, attr.span) {\n                                 self.insert_spec(id, (level, src));\n@@ -435,31 +635,27 @@ impl<'s> LintLevelsBuilder<'s> {\n                             Ok(ids) => {\n                                 let complete_name =\n                                     &format!(\"{}::{}\", tool_ident.unwrap().name, name);\n-                                let src = LintLevelSource::Node(\n-                                    Symbol::intern(complete_name),\n-                                    sp,\n+                                let src = LintLevelSource::Node {\n+                                    name: Symbol::intern(complete_name),\n+                                    span: sp,\n                                     reason,\n-                                );\n+                                    tool: tool_name,\n+                                };\n                                 for &id in ids {\n                                     if self.check_gated_lint(id, attr.span) {\n                                         self.insert_spec(id, (level, src));\n                                     }\n                                 }\n                                 if let Level::Expect(expect_id) = level {\n-                                    self.lint_expectations.push((\n+                                    self.provider.push_expectation(\n                                         expect_id,\n                                         LintExpectation::new(reason, sp, false, tool_name),\n-                                    ));\n+                                    );\n                                 }\n                             }\n                             Err((Some(ids), ref new_lint_name)) => {\n                                 let lint = builtin::RENAMED_AND_REMOVED_LINTS;\n-                                let (lvl, src) = self.sets.get_lint_level(\n-                                    lint,\n-                                    self.cur,\n-                                    Some(self.current_specs()),\n-                                    &sess,\n-                                );\n+                                let (lvl, src) = self.provider.get_lint_level(lint, &sess);\n                                 struct_lint_level(\n                                     self.sess,\n                                     lint,\n@@ -481,19 +677,20 @@ impl<'s> LintLevelsBuilder<'s> {\n                                     },\n                                 );\n \n-                                let src = LintLevelSource::Node(\n-                                    Symbol::intern(&new_lint_name),\n-                                    sp,\n+                                let src = LintLevelSource::Node {\n+                                    name: Symbol::intern(&new_lint_name),\n+                                    span: sp,\n                                     reason,\n-                                );\n+                                    tool: tool_name,\n+                                };\n                                 for id in ids {\n                                     self.insert_spec(*id, (level, src));\n                                 }\n                                 if let Level::Expect(expect_id) = level {\n-                                    self.lint_expectations.push((\n+                                    self.provider.push_expectation(\n                                         expect_id,\n                                         LintExpectation::new(reason, sp, false, tool_name),\n-                                    ));\n+                                    );\n                                 }\n                             }\n                             Err((None, _)) => {\n@@ -519,12 +716,7 @@ impl<'s> LintLevelsBuilder<'s> {\n \n                     CheckLintNameResult::Warning(msg, renamed) => {\n                         let lint = builtin::RENAMED_AND_REMOVED_LINTS;\n-                        let (renamed_lint_level, src) = self.sets.get_lint_level(\n-                            lint,\n-                            self.cur,\n-                            Some(self.current_specs()),\n-                            &sess,\n-                        );\n+                        let (renamed_lint_level, src) = self.provider.get_lint_level(lint, &sess);\n                         struct_lint_level(\n                             self.sess,\n                             lint,\n@@ -547,12 +739,7 @@ impl<'s> LintLevelsBuilder<'s> {\n                     }\n                     CheckLintNameResult::NoLint(suggestion) => {\n                         let lint = builtin::UNKNOWN_LINTS;\n-                        let (level, src) = self.sets.get_lint_level(\n-                            lint,\n-                            self.cur,\n-                            Some(self.current_specs()),\n-                            self.sess,\n-                        );\n+                        let (level, src) = self.provider.get_lint_level(lint, self.sess);\n                         let name = if let Some(tool_ident) = tool_ident {\n                             format!(\"{}::{}\", tool_ident.name, name)\n                         } else {\n@@ -588,17 +775,22 @@ impl<'s> LintLevelsBuilder<'s> {\n                     if let CheckLintNameResult::Ok(ids) =\n                         self.store.check_lint_name(&new_name, None, self.registered_tools)\n                     {\n-                        let src = LintLevelSource::Node(Symbol::intern(&new_name), sp, reason);\n+                        let src = LintLevelSource::Node {\n+                            name: Symbol::intern(&new_name),\n+                            span: sp,\n+                            reason,\n+                            tool: tool_name,\n+                        };\n                         for &id in ids {\n                             if self.check_gated_lint(id, attr.span) {\n                                 self.insert_spec(id, (level, src));\n                             }\n                         }\n                         if let Level::Expect(expect_id) = level {\n-                            self.lint_expectations.push((\n+                            self.provider.push_expectation(\n                                 expect_id,\n                                 LintExpectation::new(reason, sp, false, tool_name),\n-                            ));\n+                            );\n                         }\n                     } else {\n                         panic!(\"renamed lint does not exist: {}\", new_name);\n@@ -613,13 +805,12 @@ impl<'s> LintLevelsBuilder<'s> {\n                     continue;\n                 }\n \n-                let LintLevelSource::Node(lint_attr_name, lint_attr_span, _) = *src else {\n+                let LintLevelSource::Node { name: lint_attr_name, span: lint_attr_span, .. } = *src else {\n                     continue\n                 };\n \n                 let lint = builtin::UNUSED_ATTRIBUTES;\n-                let (lint_level, lint_src) =\n-                    self.sets.get_lint_level(lint, self.cur, Some(self.current_specs()), self.sess);\n+                let (lint_level, lint_src) = self.provider.get_lint_level(lint, &self.sess);\n                 struct_lint_level(\n                     self.sess,\n                     lint,\n@@ -637,27 +828,6 @@ impl<'s> LintLevelsBuilder<'s> {\n                 break;\n             }\n         }\n-\n-        if self.current_specs().is_empty() {\n-            self.sets.list.pop();\n-            self.cur = prev;\n-        }\n-\n-        BuilderPush { prev, changed: prev != self.cur }\n-    }\n-\n-    fn create_stable_id(\n-        &mut self,\n-        unstable_id: LintExpectationId,\n-        hir_id: HirId,\n-        attr_index: usize,\n-    ) -> LintExpectationId {\n-        let stable_id =\n-            LintExpectationId::Stable { hir_id, attr_index: attr_index as u16, lint_index: None };\n-\n-        self.expectation_id_map.insert(unstable_id, stable_id);\n-\n-        stable_id\n     }\n \n     /// Checks if the lint is gated on a feature that is not enabled.\n@@ -689,14 +859,9 @@ impl<'s> LintLevelsBuilder<'s> {\n         true\n     }\n \n-    /// Called after `push` when the scope of a set of attributes are exited.\n-    pub fn pop(&mut self, push: BuilderPush) {\n-        self.cur = push.prev;\n-    }\n-\n     /// Find the lint level for a lint.\n-    pub fn lint_level(&self, lint: &'static Lint) -> (Level, LintLevelSource) {\n-        self.sets.get_lint_level(lint, self.cur, None, self.sess)\n+    pub fn lint_level(&self, lint: &'static Lint) -> LevelAndSource {\n+        self.provider.get_lint_level(lint, self.sess)\n     }\n \n     /// Used to emit a lint-related diagnostic based on the current state of\n@@ -713,141 +878,8 @@ impl<'s> LintLevelsBuilder<'s> {\n         let (level, src) = self.lint_level(lint);\n         struct_lint_level(self.sess, lint, level, src, span, msg, decorate)\n     }\n-\n-    /// Registers the ID provided with the current set of lints stored in\n-    /// this context.\n-    pub fn register_id(&mut self, id: HirId) {\n-        self.id_to_set.insert(id, self.cur);\n-    }\n-\n-    fn update_unstable_expectation_ids(&self) {\n-        self.sess.diagnostic().update_unstable_expectation_id(&self.expectation_id_map);\n-    }\n-\n-    pub fn build_map(self) -> LintLevelMap {\n-        LintLevelMap {\n-            sets: self.sets,\n-            id_to_set: self.id_to_set,\n-            lint_expectations: self.lint_expectations,\n-        }\n-    }\n-}\n-\n-struct LintLevelMapBuilder<'tcx> {\n-    levels: LintLevelsBuilder<'tcx>,\n-    tcx: TyCtxt<'tcx>,\n-}\n-\n-impl LintLevelMapBuilder<'_> {\n-    fn with_lint_attrs<F>(&mut self, id: hir::HirId, f: F)\n-    where\n-        F: FnOnce(&mut Self),\n-    {\n-        let is_crate_hir = id == hir::CRATE_HIR_ID;\n-        let attrs = self.tcx.hir().attrs(id);\n-        let push = self.levels.push(attrs, is_crate_hir, Some(id));\n-\n-        if push.changed {\n-            self.levels.register_id(id);\n-        }\n-        f(self);\n-        self.levels.pop(push);\n-    }\n-}\n-\n-impl<'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'tcx> {\n-    type NestedFilter = nested_filter::All;\n-\n-    fn nested_visit_map(&mut self) -> Self::Map {\n-        self.tcx.hir()\n-    }\n-\n-    fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n-        self.with_lint_attrs(param.hir_id, |builder| {\n-            intravisit::walk_param(builder, param);\n-        });\n-    }\n-\n-    fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n-        self.with_lint_attrs(it.hir_id(), |builder| {\n-            intravisit::walk_item(builder, it);\n-        });\n-    }\n-\n-    fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem<'tcx>) {\n-        self.with_lint_attrs(it.hir_id(), |builder| {\n-            intravisit::walk_foreign_item(builder, it);\n-        })\n-    }\n-\n-    fn visit_stmt(&mut self, e: &'tcx hir::Stmt<'tcx>) {\n-        // We will call `with_lint_attrs` when we walk\n-        // the `StmtKind`. The outer statement itself doesn't\n-        // define the lint levels.\n-        intravisit::walk_stmt(self, e);\n-    }\n-\n-    fn visit_expr(&mut self, e: &'tcx hir::Expr<'tcx>) {\n-        self.with_lint_attrs(e.hir_id, |builder| {\n-            intravisit::walk_expr(builder, e);\n-        })\n-    }\n-\n-    fn visit_expr_field(&mut self, field: &'tcx hir::ExprField<'tcx>) {\n-        self.with_lint_attrs(field.hir_id, |builder| {\n-            intravisit::walk_expr_field(builder, field);\n-        })\n-    }\n-\n-    fn visit_field_def(&mut self, s: &'tcx hir::FieldDef<'tcx>) {\n-        self.with_lint_attrs(s.hir_id, |builder| {\n-            intravisit::walk_field_def(builder, s);\n-        })\n-    }\n-\n-    fn visit_variant(&mut self, v: &'tcx hir::Variant<'tcx>) {\n-        self.with_lint_attrs(v.id, |builder| {\n-            intravisit::walk_variant(builder, v);\n-        })\n-    }\n-\n-    fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n-        self.with_lint_attrs(l.hir_id, |builder| {\n-            intravisit::walk_local(builder, l);\n-        })\n-    }\n-\n-    fn visit_arm(&mut self, a: &'tcx hir::Arm<'tcx>) {\n-        self.with_lint_attrs(a.hir_id, |builder| {\n-            intravisit::walk_arm(builder, a);\n-        })\n-    }\n-\n-    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n-        self.with_lint_attrs(trait_item.hir_id(), |builder| {\n-            intravisit::walk_trait_item(builder, trait_item);\n-        });\n-    }\n-\n-    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n-        self.with_lint_attrs(impl_item.hir_id(), |builder| {\n-            intravisit::walk_impl_item(builder, impl_item);\n-        });\n-    }\n-\n-    fn visit_pat_field(&mut self, field: &'tcx hir::PatField<'tcx>) {\n-        self.with_lint_attrs(field.hir_id, |builder| {\n-            intravisit::walk_pat_field(builder, field);\n-        })\n-    }\n-\n-    fn visit_generic_param(&mut self, p: &'tcx hir::GenericParam<'tcx>) {\n-        self.with_lint_attrs(p.hir_id, |builder| {\n-            intravisit::walk_generic_param(builder, p);\n-        });\n-    }\n }\n \n pub fn provide(providers: &mut Providers) {\n-    providers.lint_levels = lint_levels;\n+    *providers = Providers { lint_levels_on, lint_expectations, ..*providers };\n }"}, {"sha": "cbe7afc8e5558b2e2fe0bbe79f183d6ddf42c52a", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3cb1811e459d1cf30dcb553ab99ce090cd5c76f1/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb1811e459d1cf30dcb553ab99ce090cd5c76f1/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=3cb1811e459d1cf30dcb553ab99ce090cd5c76f1", "patch": "@@ -92,7 +92,7 @@ pub enum LintExpectationId {\n     /// stable and can be cached. The additional index ensures that nodes with\n     /// several expectations can correctly match diagnostics to the individual\n     /// expectation.\n-    Stable { hir_id: HirId, attr_index: u16, lint_index: Option<u16> },\n+    Stable { hir_id: HirId, attr_index: u16, lint_index: Option<u16>, attr_id: Option<AttrId> },\n }\n \n impl LintExpectationId {\n@@ -116,13 +116,31 @@ impl LintExpectationId {\n \n         *lint_index = new_lint_index\n     }\n+\n+    /// Prepares the id for hashing. Removes references to the ast.\n+    /// Should only be called when the id is stable.\n+    pub fn normalize(self) -> Self {\n+        match self {\n+            Self::Stable { hir_id, attr_index, lint_index, .. } => {\n+                Self::Stable { hir_id, attr_index, lint_index, attr_id: None }\n+            }\n+            Self::Unstable { .. } => {\n+                unreachable!(\"`normalize` called when `ExpectationId` is unstable\")\n+            }\n+        }\n+    }\n }\n \n impl<HCX: rustc_hir::HashStableContext> HashStable<HCX> for LintExpectationId {\n     #[inline]\n     fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n         match self {\n-            LintExpectationId::Stable { hir_id, attr_index, lint_index: Some(lint_index) } => {\n+            LintExpectationId::Stable {\n+                hir_id,\n+                attr_index,\n+                lint_index: Some(lint_index),\n+                attr_id: _,\n+            } => {\n                 hir_id.hash_stable(hcx, hasher);\n                 attr_index.hash_stable(hcx, hasher);\n                 lint_index.hash_stable(hcx, hasher);\n@@ -142,9 +160,12 @@ impl<HCX: rustc_hir::HashStableContext> ToStableHashKey<HCX> for LintExpectation\n     #[inline]\n     fn to_stable_hash_key(&self, _: &HCX) -> Self::KeyType {\n         match self {\n-            LintExpectationId::Stable { hir_id, attr_index, lint_index: Some(lint_index) } => {\n-                (*hir_id, *attr_index, *lint_index)\n-            }\n+            LintExpectationId::Stable {\n+                hir_id,\n+                attr_index,\n+                lint_index: Some(lint_index),\n+                attr_id: _,\n+            } => (*hir_id, *attr_index, *lint_index),\n             _ => {\n                 unreachable!(\"HashStable should only be called for a filled `LintExpectationId`\")\n             }"}, {"sha": "571d9d6a73c52c0b2001da5f40507f949cc2192a", "filename": "compiler/rustc_middle/src/lint.rs", "status": "modified", "additions": 92, "deletions": 19, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/3cb1811e459d1cf30dcb553ab99ce090cd5c76f1/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb1811e459d1cf30dcb553ab99ce090cd5c76f1/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flint.rs?ref=3cb1811e459d1cf30dcb553ab99ce090cd5c76f1", "patch": "@@ -15,6 +15,8 @@ use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::{DesugaringKind, ExpnKind};\n use rustc_span::{symbol, Span, Symbol, DUMMY_SP};\n \n+use crate::ty::TyCtxt;\n+\n /// How a lint level was set.\n #[derive(Clone, Copy, PartialEq, Eq, HashStable, Debug)]\n pub enum LintLevelSource {\n@@ -23,7 +25,14 @@ pub enum LintLevelSource {\n     Default,\n \n     /// Lint level was set by an attribute.\n-    Node(Symbol, Span, Option<Symbol> /* RFC 2383 reason */),\n+    Node {\n+        name: Symbol,\n+        span: Span,\n+        /// RFC 2383 reason\n+        reason: Option<Symbol>,\n+        /// The lint tool. (e.g. rustdoc, clippy)\n+        tool: Option<Symbol>,\n+    },\n \n     /// Lint level was set by a command-line flag.\n     /// The provided `Level` is the level specified on the command line.\n@@ -35,15 +44,15 @@ impl LintLevelSource {\n     pub fn name(&self) -> Symbol {\n         match *self {\n             LintLevelSource::Default => symbol::kw::Default,\n-            LintLevelSource::Node(name, _, _) => name,\n+            LintLevelSource::Node { name, .. } => name,\n             LintLevelSource::CommandLine(name, _) => name,\n         }\n     }\n \n     pub fn span(&self) -> Span {\n         match *self {\n             LintLevelSource::Default => DUMMY_SP,\n-            LintLevelSource::Node(_, span, _) => span,\n+            LintLevelSource::Node { span, .. } => span,\n             LintLevelSource::CommandLine(_, _) => DUMMY_SP,\n         }\n     }\n@@ -55,7 +64,6 @@ pub type LevelAndSource = (Level, LintLevelSource);\n #[derive(Debug, HashStable)]\n pub struct LintLevelSets {\n     pub list: IndexVec<LintStackIndex, LintSet>,\n-    pub lint_cap: Level,\n }\n \n rustc_index::newtype_index! {\n@@ -76,18 +84,16 @@ pub struct LintSet {\n \n impl LintLevelSets {\n     pub fn new() -> Self {\n-        LintLevelSets { list: IndexVec::new(), lint_cap: Level::Forbid }\n+        LintLevelSets { list: IndexVec::new() }\n     }\n \n-    pub fn get_lint_level(\n-        &self,\n-        lint: &'static Lint,\n-        idx: LintStackIndex,\n-        aux: Option<&FxHashMap<LintId, LevelAndSource>>,\n+    pub fn actual_level(\n+        level: Option<Level>,\n+        src: &mut LintLevelSource,\n         sess: &Session,\n-    ) -> LevelAndSource {\n-        let (level, mut src) = self.get_lint_id_level(LintId::of(lint), idx, aux);\n-\n+        lint: &'static Lint,\n+        get_lint_id_level: impl FnOnce(LintId) -> (Option<Level>, LintLevelSource),\n+    ) -> Level {\n         // If `level` is none then we actually assume the default level for this\n         // lint.\n         let mut level = level.unwrap_or_else(|| lint.default_level(sess.edition()));\n@@ -101,12 +107,11 @@ impl LintLevelSets {\n         // and so if we turned that into an error, it'd defeat the purpose of the\n         // future compatibility warning.\n         if level == Level::Warn && LintId::of(lint) != LintId::of(FORBIDDEN_LINT_GROUPS) {\n-            let (warnings_level, warnings_src) =\n-                self.get_lint_id_level(LintId::of(builtin::WARNINGS), idx, aux);\n+            let (warnings_level, warnings_src) = get_lint_id_level(LintId::of(builtin::WARNINGS));\n             if let Some(configured_warning_level) = warnings_level {\n                 if configured_warning_level != Level::Warn {\n                     level = configured_warning_level;\n-                    src = warnings_src;\n+                    *src = warnings_src;\n                 }\n             }\n         }\n@@ -116,14 +121,30 @@ impl LintLevelSets {\n         level = if let LintLevelSource::CommandLine(_, Level::ForceWarn(_)) = src {\n             level\n         } else {\n-            cmp::min(level, self.lint_cap)\n+            cmp::min(level, sess.opts.lint_cap.unwrap_or(Level::Forbid))\n         };\n \n         if let Some(driver_level) = sess.driver_lint_caps.get(&LintId::of(lint)) {\n             // Ensure that we never exceed driver level.\n             level = cmp::min(*driver_level, level);\n         }\n \n+        level\n+    }\n+\n+    pub fn get_lint_level(\n+        &self,\n+        lint: &'static Lint,\n+        idx: LintStackIndex,\n+        aux: Option<&FxHashMap<LintId, LevelAndSource>>,\n+        sess: &Session,\n+    ) -> LevelAndSource {\n+        let (level, mut src) = self.get_lint_id_level(LintId::of(lint), idx, aux);\n+\n+        let level = Self::actual_level(level, &mut src, sess, lint, |id| {\n+            self.get_lint_id_level(id, idx, aux)\n+        });\n+\n         (level, src)\n     }\n \n@@ -193,6 +214,58 @@ impl<'a> HashStable<StableHashingContext<'a>> for LintLevelMap {\n         hcx.while_hashing_spans(true, |hcx| sets.hash_stable(hcx, hasher))\n     }\n }\n+pub struct LintLevelQueryMap<'tcx> {\n+    pub tcx: TyCtxt<'tcx>,\n+    pub cur: HirId,\n+    pub specs: FxHashMap<LintId, LevelAndSource>,\n+}\n+\n+impl<'tcx> LintLevelQueryMap<'tcx> {\n+    pub fn lint_id_level(&self, id: LintId) -> (Option<Level>, LintLevelSource) {\n+        Self::get_lint_id_level(id, self.cur, self.tcx, &self.specs)\n+    }\n+\n+    pub fn lint_level(&self, lint: &'static Lint) -> LevelAndSource {\n+        Self::get_lint_level(LintId::of(lint), self.cur, self.tcx, &self.specs)\n+    }\n+\n+    pub fn get_lint_id_level(\n+        id: LintId,\n+        cur: HirId,\n+        tcx: TyCtxt<'tcx>,\n+        specs: &FxHashMap<LintId, LevelAndSource>,\n+    ) -> (Option<Level>, LintLevelSource) {\n+        if let Some(&(level, src)) = specs.get(&id) {\n+            return (Some(level), src);\n+        }\n+        let mut cur = cur;\n+\n+        loop {\n+            let parent = tcx.hir().get_parent_node(cur);\n+            if cur == parent {\n+                return (None, LintLevelSource::Default);\n+            }\n+            let specs = tcx.lint_levels_on(parent);\n+            if let Some(&(level, src)) = specs.get(&id) {\n+                return (Some(level), src);\n+            }\n+            cur = parent\n+        }\n+    }\n+\n+    pub fn get_lint_level(\n+        id: LintId,\n+        cur: HirId,\n+        tcx: TyCtxt<'tcx>,\n+        specs: &FxHashMap<LintId, LevelAndSource>,\n+    ) -> (Level, LintLevelSource) {\n+        let (level, mut src) = Self::get_lint_id_level(id, cur, tcx, specs);\n+        let level = LintLevelSets::actual_level(level, &mut src, tcx.sess, id.lint, |id| {\n+            Self::get_lint_id_level(id, cur, tcx, specs)\n+        });\n+        (level, src)\n+    }\n+}\n \n /// This struct represents a lint expectation and holds all required information\n /// to emit the `unfulfilled_lint_expectations` lint if it is unfulfilled after\n@@ -261,11 +334,11 @@ pub fn explain_lint_level_source(\n                 ));\n             }\n         }\n-        LintLevelSource::Node(lint_attr_name, src, reason) => {\n+        LintLevelSource::Node { name: lint_attr_name, span, reason, .. } => {\n             if let Some(rationale) = reason {\n                 err.note(rationale.as_str());\n             }\n-            err.span_note_once(src, \"the lint level is defined here\");\n+            err.span_note_once(span, \"the lint level is defined here\");\n             if lint_attr_name.as_str() != name {\n                 let level_str = level.as_str();\n                 err.note_once(&format!("}, {"sha": "0fb8fbcb27ac41f97aff45c339c6b9f4e1c45bb9", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3cb1811e459d1cf30dcb553ab99ce090cd5c76f1/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb1811e459d1cf30dcb553ab99ce090cd5c76f1/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=3cb1811e459d1cf30dcb553ab99ce090cd5c76f1", "patch": "@@ -274,10 +274,14 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n-    query lint_levels(_: ()) -> LintLevelMap {\n+    query lint_levels_on(key: HirId) -> FxHashMap<LintId, LevelAndSource> {\n         arena_cache\n-        eval_always\n-        desc { \"computing the lint levels for items in this crate\" }\n+        desc { |tcx| \"looking up lint levels for `{}`\", key }\n+    }\n+\n+    query lint_expectations(_: ()) -> Vec<(LintExpectationId, LintExpectation)> {\n+        arena_cache\n+        desc { \"computing `#[expect]`ed lints in this crate\" }\n     }\n \n     query parent_module_from_def_id(key: LocalDefId) -> LocalDefId {"}, {"sha": "2cb63229a8d3ea3ea5d09ea3c4272f721e3d15e4", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3cb1811e459d1cf30dcb553ab99ce090cd5c76f1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb1811e459d1cf30dcb553ab99ce090cd5c76f1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=3cb1811e459d1cf30dcb553ab99ce090cd5c76f1", "patch": "@@ -57,7 +57,7 @@ use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n use rustc_session::config::{CrateType, OutputFilenames};\n use rustc_session::cstore::CrateStoreDyn;\n use rustc_session::errors::TargetDataLayoutErrorsWrapper;\n-use rustc_session::lint::{Level, Lint};\n+use rustc_session::lint::{Level, Lint, LintId};\n use rustc_session::Limit;\n use rustc_session::Session;\n use rustc_span::def_id::{DefPathHash, StableCrateId};\n@@ -2835,19 +2835,16 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn lint_level_at_node(\n         self,\n         lint: &'static Lint,\n-        mut id: hir::HirId,\n+        id: hir::HirId,\n     ) -> (Level, LintLevelSource) {\n-        let sets = self.lint_levels(());\n-        loop {\n-            if let Some(pair) = sets.level_and_source(lint, id, self.sess) {\n-                return pair;\n-            }\n-            let next = self.hir().get_parent_node(id);\n-            if next == id {\n-                bug!(\"lint traversal reached the root of the crate\");\n-            }\n-            id = next;\n-        }\n+        let level_and_src = crate::lint::LintLevelQueryMap::get_lint_level(\n+            LintId::of(lint),\n+            id,\n+            self,\n+            self.lint_levels_on(id),\n+        );\n+        debug!(?id, ?level_and_src);\n+        level_and_src\n     }\n \n     /// Emit a lint at `span` from a lint struct (some type that implements `DecorateLint`,"}, {"sha": "f8ccf07d48997668d7cbf614fdb1870c8c9a1b49", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3cb1811e459d1cf30dcb553ab99ce090cd5c76f1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb1811e459d1cf30dcb553ab99ce090cd5c76f1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=3cb1811e459d1cf30dcb553ab99ce090cd5c76f1", "patch": "@@ -1,6 +1,6 @@\n use crate::dep_graph;\n use crate::infer::canonical::{self, Canonical};\n-use crate::lint::LintLevelMap;\n+use crate::lint::{LevelAndSource, LintExpectation};\n use crate::metadata::ModChild;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n use crate::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo};\n@@ -44,13 +44,14 @@ use rustc_errors::ErrorGuaranteed;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, LocalDefId};\n-use rustc_hir::hir_id::OwnerId;\n+use rustc_hir::hir_id::{HirId, OwnerId};\n use rustc_hir::lang_items::{LangItem, LanguageItems};\n use rustc_hir::{Crate, ItemLocalId, TraitCandidate};\n use rustc_index::{bit_set::FiniteBitSet, vec::IndexVec};\n use rustc_session::config::{EntryFnType, OptLevel, OutputFilenames, SymbolManglingVersion};\n use rustc_session::cstore::{CrateDepKind, CrateSource};\n use rustc_session::cstore::{ExternCrate, ForeignModule, LinkagePreference, NativeLib};\n+use rustc_session::lint::{LintExpectationId, LintId};\n use rustc_session::utils::NativeLibKind;\n use rustc_session::Limits;\n use rustc_span::symbol::Symbol;"}, {"sha": "b6cf79b828b321fd5fc0102fb7ec725bdb38d5b5", "filename": "compiler/rustc_query_impl/src/keys.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3cb1811e459d1cf30dcb553ab99ce090cd5c76f1/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3cb1811e459d1cf30dcb553ab99ce090cd5c76f1/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs?ref=3cb1811e459d1cf30dcb553ab99ce090cd5c76f1", "patch": "@@ -1,7 +1,7 @@\n //! Defines the set of legal keys that can be used in queries.\n \n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n-use rustc_hir::hir_id::OwnerId;\n+use rustc_hir::hir_id::{HirId, OwnerId};\n use rustc_middle::infer::canonical::Canonical;\n use rustc_middle::mir;\n use rustc_middle::traits;\n@@ -557,3 +557,19 @@ impl<'tcx> Key for (Ty<'tcx>, ty::ValTree<'tcx>) {\n         DUMMY_SP\n     }\n }\n+\n+impl Key for HirId {\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n+    }\n+\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n+        self.owner.default_span(tcx)\n+    }\n+\n+    #[inline(always)]\n+    fn key_as_def_id(&self) -> Option<DefId> {\n+        Some(self.owner.to_def_id())\n+    }\n+}"}, {"sha": "5942fa8aeb4f0de429a93871f9db96999c7add99", "filename": "src/test/ui/lint/rfc-2383-lint-reason/force_warn_expected_lints_fulfilled.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/3cb1811e459d1cf30dcb553ab99ce090cd5c76f1/src%2Ftest%2Fui%2Flint%2Frfc-2383-lint-reason%2Fforce_warn_expected_lints_fulfilled.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3cb1811e459d1cf30dcb553ab99ce090cd5c76f1/src%2Ftest%2Fui%2Flint%2Frfc-2383-lint-reason%2Fforce_warn_expected_lints_fulfilled.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Frfc-2383-lint-reason%2Fforce_warn_expected_lints_fulfilled.stderr?ref=3cb1811e459d1cf30dcb553ab99ce090cd5c76f1", "patch": "@@ -1,11 +1,3 @@\n-warning: denote infinite loops with `loop { ... }`\n-  --> $DIR/force_warn_expected_lints_fulfilled.rs:10:5\n-   |\n-LL |     while true {\n-   |     ^^^^^^^^^^ help: use `loop`\n-   |\n-   = note: requested on the command line with `--force-warn while-true`\n-\n warning: unused variable: `x`\n   --> $DIR/force_warn_expected_lints_fulfilled.rs:20:9\n    |\n@@ -36,5 +28,13 @@ LL |     let mut what_does_the_fox_say = \"*ding* *deng* *dung*\";\n    |\n    = note: requested on the command line with `--force-warn unused-mut`\n \n+warning: denote infinite loops with `loop { ... }`\n+  --> $DIR/force_warn_expected_lints_fulfilled.rs:10:5\n+   |\n+LL |     while true {\n+   |     ^^^^^^^^^^ help: use `loop`\n+   |\n+   = note: requested on the command line with `--force-warn while-true`\n+\n warning: 5 warnings emitted\n "}]}