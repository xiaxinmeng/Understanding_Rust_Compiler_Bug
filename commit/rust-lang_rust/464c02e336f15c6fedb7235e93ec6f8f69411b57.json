{"sha": "464c02e336f15c6fedb7235e93ec6f8f69411b57", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2NGMwMmUzMzZmMTVjNmZlZGI3MjM1ZTkzZWM2ZjhmNjk0MTFiNTc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-09T16:04:26Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-23T20:37:48Z"}, "message": "integrate scopes into MIR", "tree": {"sha": "1c36c73bb1e32b82a2eaaf09025e1cd732493d7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c36c73bb1e32b82a2eaaf09025e1cd732493d7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/464c02e336f15c6fedb7235e93ec6f8f69411b57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/464c02e336f15c6fedb7235e93ec6f8f69411b57", "html_url": "https://github.com/rust-lang/rust/commit/464c02e336f15c6fedb7235e93ec6f8f69411b57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/464c02e336f15c6fedb7235e93ec6f8f69411b57/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b76f818cad31c7910fb6f0fa5e628dbaf4db1108", "url": "https://api.github.com/repos/rust-lang/rust/commits/b76f818cad31c7910fb6f0fa5e628dbaf4db1108", "html_url": "https://github.com/rust-lang/rust/commit/b76f818cad31c7910fb6f0fa5e628dbaf4db1108"}], "stats": {"total": 189, "additions": 168, "deletions": 21}, "files": [{"sha": "6723fc72a40eb2189f6d2b1fc446c10292c56db7", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 54, "deletions": 2, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/464c02e336f15c6fedb7235e93ec6f8f69411b57/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464c02e336f15c6fedb7235e93ec6f8f69411b57/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=464c02e336f15c6fedb7235e93ec6f8f69411b57", "patch": "@@ -32,6 +32,10 @@ pub struct Mir<'tcx> {\n     /// that indexes into this vector.\n     pub basic_blocks: Vec<BasicBlockData<'tcx>>,\n \n+    /// List of lexical scopes; these are referenced by statements and\n+    /// used (eventually) for debuginfo. Indexed by a `ScopeId`.\n+    pub scopes: ScopeDataVec,\n+\n     /// Return type of the function.\n     pub return_ty: FnOutput<'tcx>,\n \n@@ -613,13 +617,61 @@ impl<'tcx> Debug for Lvalue<'tcx> {\n     }\n }\n \n+///////////////////////////////////////////////////////////////////////////\n+// Scopes\n+\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub struct ScopeDataVec {\n+    pub vec: Vec<ScopeData>\n+}\n+\n+impl ScopeDataVec {\n+    pub fn new() -> Self {\n+        ScopeDataVec { vec: Vec::new() }\n+    }\n+}\n+\n+impl Index<ScopeId> for ScopeDataVec {\n+    type Output = ScopeData;\n+\n+    #[inline]\n+    fn index(&self, index: ScopeId) -> &ScopeData {\n+        &self.vec[index.index()]\n+    }\n+}\n+\n+impl IndexMut<ScopeId> for ScopeDataVec {\n+    #[inline]\n+    fn index_mut(&mut self, index: ScopeId) -> &mut ScopeData {\n+        &mut self.vec[index.index()]\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub struct ScopeId(u32);\n+\n+impl ScopeId {\n+    pub fn new(index: usize) -> ScopeId {\n+        assert!(index < (u32::MAX as usize));\n+        ScopeId(index as u32)\n+    }\n+\n+    pub fn index(self) -> usize {\n+        self.0 as usize\n+    }\n+}\n+\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub struct ScopeData {\n+    pub parent_scope: Option<ScopeId>,\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Operands\n-//\n+\n /// These are values that can appear inside an rvalue (or an index\n /// lvalue). They are intentionally limited to prevent rvalues from\n /// being nested in one another.\n-\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum Operand<'tcx> {\n     Consume(Lvalue<'tcx>),"}, {"sha": "ca23be7dc06185402caeae8cdc70a7b89a28045e", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/464c02e336f15c6fedb7235e93ec6f8f69411b57/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464c02e336f15c6fedb7235e93ec6f8f69411b57/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=464c02e336f15c6fedb7235e93ec6f8f69411b57", "patch": "@@ -51,7 +51,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                         }));\n                     }\n                     StmtKind::Let { remainder_scope, init_scope, pattern, initializer } => {\n-                        this.push_scope(remainder_scope);\n+                        this.push_scope(remainder_scope, block);\n                         let_extent_stack.push(remainder_scope);\n                         unpack!(block = this.in_scope(init_scope, block, move |this| {\n                             // FIXME #30046                              ^~~~"}, {"sha": "d804fc8635a92526765802e870fef0f579e7ad6a", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/464c02e336f15c6fedb7235e93ec6f8f69411b57/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464c02e336f15c6fedb7235e93ec6f8f69411b57/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=464c02e336f15c6fedb7235e93ec6f8f69411b57", "patch": "@@ -13,7 +13,7 @@\n \n //! Routines for manipulating the control-flow graph.\n \n-use build::CFG;\n+use build::{CFG, Location};\n use rustc::mir::repr::*;\n use syntax::codemap::Span;\n \n@@ -43,6 +43,11 @@ impl<'tcx> CFG<'tcx> {\n         self.block_data_mut(block).statements.push(statement);\n     }\n \n+    pub fn current_location(&mut self, block: BasicBlock) -> Location {\n+        let index = self.block_data(block).statements.len();\n+        Location { block: block, statement_index: index }\n+    }\n+\n     pub fn push_assign(&mut self,\n                        block: BasicBlock,\n                        span: Span,"}, {"sha": "41259f8a281dead5be4ed97e1577720a11cd57e5", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 68, "deletions": 8, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/464c02e336f15c6fedb7235e93ec6f8f69411b57/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464c02e336f15c6fedb7235e93ec6f8f69411b57/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=464c02e336f15c6fedb7235e93ec6f8f69411b57", "patch": "@@ -21,8 +21,26 @@ use syntax::codemap::Span;\n pub struct Builder<'a, 'tcx: 'a> {\n     hir: Cx<'a, 'tcx>,\n     cfg: CFG<'tcx>,\n+\n+    // the current set of scopes, updated as we traverse;\n+    // see the `scope` module for more details\n     scopes: Vec<scope::Scope<'tcx>>,\n+\n+    // for each scope, a span of blocks that defines it;\n+    // we track these for use in region and borrow checking,\n+    // but these are liable to get out of date once optimization\n+    // begins. They are also hopefully temporary, and will be\n+    // no longer needed when we adopt graph-based regions.\n+    scope_auxiliary: Vec<ScopeAuxiliary>,\n+\n+    // the current set of loops; see the `scope` module for more\n+    // details\n     loop_scopes: Vec<scope::LoopScope>,\n+\n+    // the vector of all scopes that we have created thus far;\n+    // we track this for debuginfo later\n+    scope_data_vec: ScopeDataVec,\n+\n     var_decls: Vec<VarDecl<'tcx>>,\n     var_indices: FnvHashMap<ast::NodeId, u32>,\n     temp_decls: Vec<TempDecl<'tcx>>,\n@@ -33,6 +51,42 @@ struct CFG<'tcx> {\n     basic_blocks: Vec<BasicBlockData<'tcx>>,\n }\n \n+/// For each scope, we track the extent (from the HIR) and a\n+/// single-entry-multiple-exit subgraph that contains all the\n+/// statements/terminators within it.\n+///\n+/// This information is separated out from the main `ScopeData`\n+/// because it is short-lived. First, the extent contains node-ids,\n+/// so it cannot be saved and re-loaded. Second, any optimization will mess up\n+/// the dominator/postdominator information.\n+///\n+/// The intention is basically to use this information to do\n+/// regionck/borrowck and then throw it away once we are done.\n+pub struct ScopeAuxiliary {\n+    /// extent of this scope from the MIR.\n+    pub extent: CodeExtent,\n+\n+    /// \"entry point\": dominator of all nodes in the scope\n+    pub dom: Location,\n+\n+    /// \"exit points\": mutual postdominators of all nodes in the scope\n+    pub postdoms: Vec<Location>,\n+}\n+\n+pub struct Location {\n+    /// the location is within this block\n+    pub block: BasicBlock,\n+\n+    /// the location is the start of the this statement; or, if `statement_index`\n+    /// == num-statements, then the start of the terminator.\n+    pub statement_index: usize,\n+}\n+\n+pub struct MirPlusPlus<'tcx> {\n+    pub mir: Mir<'tcx>,\n+    pub scope_auxiliary: Vec<ScopeAuxiliary>,\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n /// The `BlockAnd` \"monad\" packages up the new basic block along with a\n /// produced value (sometimes just unit, of course). The `unpack!`\n@@ -86,13 +140,15 @@ pub fn construct<'a,'tcx>(hir: Cx<'a,'tcx>,\n                           argument_extent: CodeExtent,\n                           return_ty: FnOutput<'tcx>,\n                           ast_block: &'tcx hir::Block)\n-                          -> Mir<'tcx> {\n+                          -> MirPlusPlus<'tcx> {\n     let cfg = CFG { basic_blocks: vec![] };\n \n     let mut builder = Builder {\n         hir: hir,\n         cfg: cfg,\n         scopes: vec![],\n+        scope_data_vec: ScopeDataVec::new(),\n+        scope_auxiliary: vec![],\n         loop_scopes: vec![],\n         temp_decls: vec![],\n         var_decls: vec![],\n@@ -113,13 +169,17 @@ pub fn construct<'a,'tcx>(hir: Cx<'a,'tcx>,\n     builder.cfg.terminate(block, Terminator::Goto { target: END_BLOCK });\n     builder.cfg.terminate(END_BLOCK, Terminator::Return);\n \n-    Mir {\n-        basic_blocks: builder.cfg.basic_blocks,\n-        var_decls: builder.var_decls,\n-        arg_decls: arg_decls,\n-        temp_decls: builder.temp_decls,\n-        return_ty: return_ty,\n-        span: span\n+    MirPlusPlus {\n+        mir: Mir {\n+            basic_blocks: builder.cfg.basic_blocks,\n+            scopes: builder.scope_data_vec,\n+            var_decls: builder.var_decls,\n+            arg_decls: arg_decls,\n+            temp_decls: builder.temp_decls,\n+            return_ty: return_ty,\n+            span: span\n+        },\n+        scope_auxiliary: builder.scope_auxiliary,\n     }\n }\n "}, {"sha": "6a734e1816a25dc3f296a364c1df17b8ea2793fa", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 30, "deletions": 6, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/464c02e336f15c6fedb7235e93ec6f8f69411b57/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464c02e336f15c6fedb7235e93ec6f8f69411b57/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=464c02e336f15c6fedb7235e93ec6f8f69411b57", "patch": "@@ -86,7 +86,7 @@ should go to.\n \n */\n \n-use build::{BlockAnd, BlockAndExtension, Builder, CFG};\n+use build::{BlockAnd, BlockAndExtension, Builder, CFG, ScopeAuxiliary};\n use rustc::middle::region::CodeExtent;\n use rustc::middle::lang_items;\n use rustc::middle::subst::{Substs, Subst, VecPerParamSpace};\n@@ -98,8 +98,11 @@ use rustc::middle::const_eval::ConstVal;\n use rustc_const_eval::ConstInt;\n \n pub struct Scope<'tcx> {\n+    // the scope-id within the scope_data_vec\n+    id: ScopeId,\n     extent: CodeExtent,\n     drops: Vec<DropData<'tcx>>,\n+\n     // A scope may only have one associated free, because:\n     // 1. We require a `free` to only be scheduled in the scope of `EXPR` in `box EXPR`;\n     // 2. It only makes sense to have it translated into the diverge-path.\n@@ -208,7 +211,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         where F: FnOnce(&mut Builder<'a, 'tcx>) -> BlockAnd<R>\n     {\n         debug!(\"in_scope(extent={:?}, block={:?})\", extent, block);\n-        self.push_scope(extent);\n+        self.push_scope(extent, block);\n         let rv = unpack!(block = f(self));\n         unpack!(block = self.pop_scope(extent, block));\n         debug!(\"in_scope: exiting extent={:?} block={:?}\", extent, block);\n@@ -219,26 +222,44 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     /// scope and call `pop_scope` afterwards. Note that these two\n     /// calls must be paired; using `in_scope` as a convenience\n     /// wrapper maybe preferable.\n-    pub fn push_scope(&mut self, extent: CodeExtent) {\n+    pub fn push_scope(&mut self, extent: CodeExtent, entry: BasicBlock) {\n         debug!(\"push_scope({:?})\", extent);\n+        let parent_id = self.scopes.last().map(|s| s.id);\n+        let id = ScopeId::new(self.scope_data_vec.vec.len());\n+        self.scope_data_vec.vec.push(ScopeData {\n+            parent_scope: parent_id,\n+        });\n         self.scopes.push(Scope {\n-            extent: extent.clone(),\n+            id: id,\n+            extent: extent,\n             drops: vec![],\n             free: None\n         });\n+        self.scope_auxiliary.push(ScopeAuxiliary {\n+            extent: extent,\n+            dom: self.cfg.current_location(entry),\n+            postdoms: vec![]\n+        });\n     }\n \n     /// Pops a scope, which should have extent `extent`, adding any\n     /// drops onto the end of `block` that are needed.  This must\n     /// match 1-to-1 with `push_scope`.\n-    pub fn pop_scope(&mut self, extent: CodeExtent, block: BasicBlock) -> BlockAnd<()> {\n+    pub fn pop_scope(&mut self,\n+                     extent: CodeExtent,\n+                     mut block: BasicBlock)\n+                     -> BlockAnd<()> {\n         debug!(\"pop_scope({:?}, {:?})\", extent, block);\n         // We need to have `cached_block`s available for all the drops, so we call diverge_cleanup\n         // to make sure all the `cached_block`s are filled in.\n         self.diverge_cleanup();\n         let scope = self.scopes.pop().unwrap();\n         assert_eq!(scope.extent, extent);\n-        build_scope_drops(&mut self.cfg, &scope, &self.scopes[..], block)\n+        unpack!(block = build_scope_drops(&mut self.cfg, &scope, &self.scopes, block));\n+        self.scope_auxiliary[scope.id.index()]\n+            .postdoms\n+            .push(self.cfg.current_location(block));\n+        block.and(())\n     }\n \n \n@@ -269,6 +290,9 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 self.cfg.terminate(block, free);\n                 block = next;\n             }\n+            self.scope_auxiliary[scope.id.index()]\n+                .postdoms\n+                .push(self.cfg.current_location(block));\n         }\n         self.cfg.terminate(block, Terminator::Goto { target: target });\n     }"}, {"sha": "71037d1f080700b6d6311eb9e91e8fa638daad1b", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/464c02e336f15c6fedb7235e93ec6f8f69411b57/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/464c02e336f15c6fedb7235e93ec6f8f69411b57/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=464c02e336f15c6fedb7235e93ec6f8f69411b57", "patch": "@@ -19,7 +19,7 @@\n extern crate syntax;\n extern crate rustc_front;\n \n-use build;\n+use build::{self, MirPlusPlus};\n use rustc::dep_graph::DepNode;\n use rustc::mir::repr::Mir;\n use hair::cx::Cx;\n@@ -182,8 +182,14 @@ fn build_mir<'a,'tcx:'a>(cx: Cx<'a,'tcx>,\n     let parameter_scope =\n         cx.tcx().region_maps.lookup_code_extent(\n             CodeExtentData::ParameterScope { fn_id: fn_id, body_id: body.id });\n-    let mut mir = build::construct(cx, span, implicit_arg_tys, arguments,\n-                                  parameter_scope, fn_sig.output, body);\n+    let MirPlusPlus { mut mir, scope_auxiliary: _ } =\n+        build::construct(cx,\n+                         span,\n+                         implicit_arg_tys,\n+                         arguments,\n+                         parameter_scope,\n+                         fn_sig.output,\n+                         body);\n \n     match cx.tcx().node_id_to_type(fn_id).sty {\n         ty::TyFnDef(_, _, f) if f.abi == Abi::RustCall => {"}]}