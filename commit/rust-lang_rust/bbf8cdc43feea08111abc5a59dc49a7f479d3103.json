{"sha": "bbf8cdc43feea08111abc5a59dc49a7f479d3103", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiZjhjZGM0M2ZlZWEwODExMWFiYzVhNTlkYzQ5YTdmNDc5ZDMxMDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-22T01:51:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-22T01:51:51Z"}, "message": "auto merge of #12833 : alexcrichton/rust/libnative, r=brson\n\nThe compiler will no longer inject libgreen as the default runtime for rust\r\nprograms, this commit switches it over to libnative by default. Now that\r\nlibnative has baked for some time, it is ready enough to start getting more\r\nserious usage as the default runtime for rustc generated binaries.\r\n\r\nWe've found that there isn't really a correct decision in choosing a 1:1 or M:N\r\nruntime as a default for all applications, but it seems that a larger number of\r\nprograms today would work more reasonably with a native default rather than a\r\ngreen default.\r\n\r\nWith this commit come a number of bugfixes:\r\n\r\n* The main native task is now named `<main>`\r\n* The main native task has the stack bounds set up properly\r\n* #[no_uv] was renamed to #[no_start]\r\n* The core-run-destroy test was rewritten for both libnative and libgreen and\r\n  one of the tests was modified to be more robust.\r\n* The process-detach test was locked to libgreen because it uses signal handling", "tree": {"sha": "d950bd4e8c38fae4bdc1c62e615f187416d6884b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d950bd4e8c38fae4bdc1c62e615f187416d6884b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bbf8cdc43feea08111abc5a59dc49a7f479d3103", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bbf8cdc43feea08111abc5a59dc49a7f479d3103", "html_url": "https://github.com/rust-lang/rust/commit/bbf8cdc43feea08111abc5a59dc49a7f479d3103", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bbf8cdc43feea08111abc5a59dc49a7f479d3103/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e3a3cf712ec1032420d1d10504b92cea6973da6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e3a3cf712ec1032420d1d10504b92cea6973da6", "html_url": "https://github.com/rust-lang/rust/commit/3e3a3cf712ec1032420d1d10504b92cea6973da6"}, {"sha": "e7c4fb692bc0daf519da1d84132cda151d0fb4b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7c4fb692bc0daf519da1d84132cda151d0fb4b1", "html_url": "https://github.com/rust-lang/rust/commit/e7c4fb692bc0daf519da1d84132cda151d0fb4b1"}], "stats": {"total": 519, "additions": 280, "deletions": 239}, "files": [{"sha": "e86309f81af436957eb8854dc63e61526fef95e0", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=bbf8cdc43feea08111abc5a59dc49a7f479d3103", "patch": "@@ -19,6 +19,8 @@ extern crate test;\n extern crate getopts;\n #[phase(link, syntax)]\n extern crate log;\n+extern crate green;\n+extern crate rustuv;\n \n use std::os;\n use std::io;\n@@ -41,6 +43,9 @@ pub mod runtest;\n pub mod common;\n pub mod errors;\n \n+#[start]\n+fn start(argc: int, argv: **u8) -> int { green::start(argc, argv, main) }\n+\n pub fn main() {\n     let args = os::args();\n     let config = parse_config(args.move_iter().collect());"}, {"sha": "bd7096cda036d2e1089803929a85173cb26b4b67", "filename": "src/driver/driver.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fdriver.rs?ref=bbf8cdc43feea08111abc5a59dc49a7f479d3103", "patch": "@@ -8,15 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[no_uv];\n+#[no_uv]; // remove this after stage0\n+#[allow(attribute_usage)]; // remove this after stage0\n+extern crate native; // remove this after stage0\n \n #[cfg(rustdoc)]\n extern crate this = \"rustdoc\";\n \n #[cfg(rustc)]\n extern crate this = \"rustc\";\n \n-extern crate native;\n+#[cfg(not(stage0))]\n+fn main() { this::main() }\n \n+#[cfg(stage0)]\n #[start]\n fn start(argc: int, argv: **u8) -> int { native::start(argc, argv, this::main) }"}, {"sha": "926b9028a7a2dddc82a044ae7ebe77025dc14c78", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=bbf8cdc43feea08111abc5a59dc49a7f479d3103", "patch": "@@ -209,7 +209,7 @@ pub mod stack;\n pub mod task;\n \n #[lang = \"start\"]\n-#[cfg(not(test))]\n+#[cfg(not(test), stage0)]\n pub fn lang_start(main: *u8, argc: int, argv: **u8) -> int {\n     use std::cast;\n     start(argc, argv, proc() {"}, {"sha": "afe440cc1e0c5a051607adf8b21c237b82305655", "filename": "src/libnative/lib.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Flibnative%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Flibnative%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Flib.rs?ref=bbf8cdc43feea08111abc5a59dc49a7f479d3103", "patch": "@@ -58,6 +58,7 @@\n \n use std::os;\n use std::rt;\n+use std::str;\n \n pub mod io;\n pub mod task;\n@@ -68,6 +69,16 @@ static OS_DEFAULT_STACK_ESTIMATE: uint = 1 << 20;\n #[cfg(unix, not(android))]\n static OS_DEFAULT_STACK_ESTIMATE: uint = 2 * (1 << 20);\n \n+#[lang = \"start\"]\n+#[cfg(not(test), not(stage0))]\n+pub fn lang_start(main: *u8, argc: int, argv: **u8) -> int {\n+    use std::cast;\n+    start(argc, argv, proc() {\n+        let main: extern \"Rust\" fn() = unsafe { cast::transmute(main) };\n+        main();\n+    })\n+}\n+\n /// Executes the given procedure after initializing the runtime with the given\n /// argc/argv.\n ///\n@@ -90,7 +101,12 @@ pub fn start(argc: int, argv: **u8, main: proc()) -> int {\n     rt::init(argc, argv);\n     let mut exit_code = None;\n     let mut main = Some(main);\n-    let t = task::new((my_stack_bottom, my_stack_top)).run(|| {\n+    let mut task = task::new((my_stack_bottom, my_stack_top));\n+    task.name = Some(str::Slice(\"<main>\"));\n+    let t = task.run(|| {\n+        unsafe {\n+            rt::stack::record_stack_bounds(my_stack_bottom, my_stack_top);\n+        }\n         exit_code = Some(run(main.take_unwrap()));\n     });\n     drop(t);"}, {"sha": "0f4169bfe28cdfced418e35f8b01810134270700", "filename": "src/librand/os.rs", "status": "modified", "additions": 150, "deletions": 96, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Flibrand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Flibrand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fos.rs?ref=bbf8cdc43feea08111abc5a59dc49a7f479d3103", "patch": "@@ -11,124 +11,178 @@\n //! Interfaces to the operating system provided random number\n //! generators.\n \n-use Rng;\n+pub use self::imp::OSRng;\n \n #[cfg(unix)]\n-use reader::ReaderRng;\n-#[cfg(unix)]\n-use std::io::File;\n-\n-#[cfg(windows)]\n-use std::cast;\n-#[cfg(windows)]\n-use std::libc::{c_long, DWORD, BYTE};\n-#[cfg(windows)]\n-type HCRYPTPROV = c_long;\n-// the extern functions imported from the runtime on Windows are\n-// implemented so that they either succeed or abort(), so we can just\n-// assume they work when we call them.\n-\n-/// A random number generator that retrieves randomness straight from\n-/// the operating system. Platform sources:\n-///\n-/// - Unix-like systems (Linux, Android, Mac OSX): read directly from\n-///   `/dev/urandom`.\n-/// - Windows: calls `CryptGenRandom`, using the default cryptographic\n-///   service provider with the `PROV_RSA_FULL` type.\n-///\n-/// This does not block.\n-#[cfg(unix)]\n-pub struct OSRng {\n-    priv inner: ReaderRng<File>\n-}\n-/// A random number generator that retrieves randomness straight from\n-/// the operating system. Platform sources:\n-///\n-/// - Unix-like systems (Linux, Android, Mac OSX): read directly from\n-///   `/dev/urandom`.\n-/// - Windows: calls `CryptGenRandom`, using the default cryptographic\n-///   service provider with the `PROV_RSA_FULL` type.\n-///\n-/// This does not block.\n-#[cfg(windows)]\n-pub struct OSRng {\n-    priv hcryptprov: HCRYPTPROV\n-}\n-\n-impl OSRng {\n-    /// Create a new `OSRng`.\n+mod imp {\n+    use Rng;\n+    use reader::ReaderRng;\n+    use std::io::File;\n+\n+    /// A random number generator that retrieves randomness straight from\n+    /// the operating system. Platform sources:\n+    ///\n+    /// - Unix-like systems (Linux, Android, Mac OSX): read directly from\n+    ///   `/dev/urandom`.\n+    /// - Windows: calls `CryptGenRandom`, using the default cryptographic\n+    ///   service provider with the `PROV_RSA_FULL` type.\n+    ///\n+    /// This does not block.\n     #[cfg(unix)]\n-    pub fn new() -> OSRng {\n-        let reader = File::open(&Path::new(\"/dev/urandom\"));\n-        let reader = reader.ok().expect(\"Error opening /dev/urandom\");\n-        let reader_rng = ReaderRng::new(reader);\n-\n-        OSRng { inner: reader_rng }\n+    pub struct OSRng {\n+        priv inner: ReaderRng<File>\n     }\n \n-    /// Create a new `OSRng`.\n-    #[cfg(windows)]\n-    pub fn new() -> OSRng {\n-        extern { fn rust_win32_rand_acquire(phProv: *mut HCRYPTPROV); }\n+    impl OSRng {\n+        /// Create a new `OSRng`.\n+        pub fn new() -> OSRng {\n+            let reader = File::open(&Path::new(\"/dev/urandom\"));\n+            let reader = reader.ok().expect(\"Error opening /dev/urandom\");\n+            let reader_rng = ReaderRng::new(reader);\n \n-        let mut hcp = 0;\n-        unsafe {rust_win32_rand_acquire(&mut hcp)};\n-\n-        OSRng { hcryptprov: hcp }\n+            OSRng { inner: reader_rng }\n+        }\n     }\n-}\n \n-#[cfg(unix)]\n-impl Rng for OSRng {\n-    fn next_u32(&mut self) -> u32 {\n-        self.inner.next_u32()\n-    }\n-    fn next_u64(&mut self) -> u64 {\n-        self.inner.next_u64()\n-    }\n-    fn fill_bytes(&mut self, v: &mut [u8]) {\n-        self.inner.fill_bytes(v)\n+    impl Rng for OSRng {\n+        fn next_u32(&mut self) -> u32 {\n+            self.inner.next_u32()\n+        }\n+        fn next_u64(&mut self) -> u64 {\n+            self.inner.next_u64()\n+        }\n+        fn fill_bytes(&mut self, v: &mut [u8]) {\n+            self.inner.fill_bytes(v)\n+        }\n     }\n }\n \n #[cfg(windows)]\n-impl Rng for OSRng {\n-    fn next_u32(&mut self) -> u32 {\n-        let mut v = [0u8, .. 4];\n-        self.fill_bytes(v);\n-        unsafe { cast::transmute(v) }\n-    }\n-    fn next_u64(&mut self) -> u64 {\n-        let mut v = [0u8, .. 8];\n-        self.fill_bytes(v);\n-        unsafe { cast::transmute(v) }\n+mod imp {\n+    use Rng;\n+    use std::cast;\n+    use std::libc::{c_ulong, DWORD, BYTE, LPCSTR, BOOL};\n+    use std::os;\n+    use std::rt::stack;\n+\n+    type HCRYPTPROV = c_ulong;\n+\n+    /// A random number generator that retrieves randomness straight from\n+    /// the operating system. Platform sources:\n+    ///\n+    /// - Unix-like systems (Linux, Android, Mac OSX): read directly from\n+    ///   `/dev/urandom`.\n+    /// - Windows: calls `CryptGenRandom`, using the default cryptographic\n+    ///   service provider with the `PROV_RSA_FULL` type.\n+    ///\n+    /// This does not block.\n+    pub struct OSRng {\n+        priv hcryptprov: HCRYPTPROV\n     }\n-    fn fill_bytes(&mut self, v: &mut [u8]) {\n-        extern {\n-            fn rust_win32_rand_gen(hProv: HCRYPTPROV, dwLen: DWORD,\n-                                   pbBuffer: *mut BYTE);\n-        }\n \n-        unsafe {rust_win32_rand_gen(self.hcryptprov, v.len() as DWORD, v.as_mut_ptr())}\n+    static PROV_RSA_FULL: DWORD = 1;\n+    static CRYPT_SILENT: DWORD = 64;\n+    static CRYPT_VERIFYCONTEXT: DWORD = 0xF0000000;\n+    static NTE_BAD_SIGNATURE: DWORD = 0x80090006;\n+\n+    extern \"system\" {\n+        fn CryptAcquireContextA(phProv: *mut HCRYPTPROV,\n+                                pszContainer: LPCSTR,\n+                                pszProvider: LPCSTR,\n+                                dwProvType: DWORD,\n+                                dwFlags: DWORD) -> BOOL;\n+        fn CryptGenRandom(hProv: HCRYPTPROV,\n+                          dwLen: DWORD,\n+                          pbBuffer: *mut BYTE) -> BOOL;\n+        fn CryptReleaseContext(hProv: HCRYPTPROV, dwFlags: DWORD) -> BOOL;\n     }\n-}\n \n-impl Drop for OSRng {\n-    #[cfg(unix)]\n-    fn drop(&mut self) {\n-        // ensure that OSRng is not implicitly copyable on all\n-        // platforms, for consistency.\n+    impl OSRng {\n+        /// Create a new `OSRng`.\n+        pub fn new() -> OSRng {\n+            let mut hcp = 0;\n+            let mut ret = unsafe {\n+                CryptAcquireContextA(&mut hcp, 0 as LPCSTR, 0 as LPCSTR,\n+                                     PROV_RSA_FULL,\n+                                     CRYPT_VERIFYCONTEXT | CRYPT_SILENT)\n+            };\n+\n+            // It turns out that if we can't acquire a context with the\n+            // NTE_BAD_SIGNATURE error code, the documentation states:\n+            //\n+            //     The provider DLL signature could not be verified. Either the\n+            //     DLL or the digital signature has been tampered with.\n+            //\n+            // Sounds fishy, no? As it turns out, our signature can be bad\n+            // because our Thread Information Block (TIB) isn't exactly what it\n+            // expects. As to why, I have no idea. The only data we store in the\n+            // TIB is the stack limit for each thread, but apparently that's\n+            // enough to make the signature valid.\n+            //\n+            // Furthermore, this error only happens the *first* time we call\n+            // CryptAcquireContext, so we don't have to worry about future\n+            // calls.\n+            //\n+            // Anyway, the fix employed here is that if we see this error, we\n+            // pray that we're not close to the end of the stack, temporarily\n+            // set the stack limit to 0 (what the TIB originally was), acquire a\n+            // context, and then reset the stack limit.\n+            //\n+            // Again, I'm not sure why this is the fix, nor why we're getting\n+            // this error. All I can say is that this seems to allow libnative\n+            // to progress where it otherwise would be hindered. Who knew?\n+            if ret == 0 && os::errno() as DWORD == NTE_BAD_SIGNATURE {\n+                unsafe {\n+                    let limit = stack::get_sp_limit();\n+                    stack::record_sp_limit(0);\n+                    ret = CryptAcquireContextA(&mut hcp, 0 as LPCSTR, 0 as LPCSTR,\n+                                               PROV_RSA_FULL,\n+                                               CRYPT_VERIFYCONTEXT | CRYPT_SILENT);\n+                    stack::record_sp_limit(limit);\n+                }\n+            }\n+\n+            if ret == 0 {\n+                fail!(\"couldn't create context: {}\", os::last_os_error());\n+            }\n+            OSRng { hcryptprov: hcp }\n+        }\n     }\n \n-    #[cfg(windows)]\n-    fn drop(&mut self) {\n-        extern { fn rust_win32_rand_release(hProv: HCRYPTPROV); }\n+    impl Rng for OSRng {\n+        fn next_u32(&mut self) -> u32 {\n+            let mut v = [0u8, .. 4];\n+            self.fill_bytes(v);\n+            unsafe { cast::transmute(v) }\n+        }\n+        fn next_u64(&mut self) -> u64 {\n+            let mut v = [0u8, .. 8];\n+            self.fill_bytes(v);\n+            unsafe { cast::transmute(v) }\n+        }\n+        fn fill_bytes(&mut self, v: &mut [u8]) {\n+            let ret = unsafe {\n+                CryptGenRandom(self.hcryptprov, v.len() as DWORD,\n+                               v.as_mut_ptr())\n+            };\n+            if ret == 0 {\n+                fail!(\"couldn't generate random bytes: {}\", os::last_os_error());\n+            }\n+        }\n+    }\n \n-        unsafe {rust_win32_rand_release(self.hcryptprov)}\n+    impl Drop for OSRng {\n+        fn drop(&mut self) {\n+            let ret = unsafe {\n+                CryptReleaseContext(self.hcryptprov, 0)\n+            };\n+            if ret == 0 {\n+                fail!(\"couldn't release context: {}\", os::last_os_error());\n+            }\n+        }\n     }\n }\n \n-\n #[cfg(test)]\n mod test {\n     use super::OSRng;"}, {"sha": "a78f90cbe870419e3b24302f43c34eca39866ed5", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=bbf8cdc43feea08111abc5a59dc49a7f479d3103", "patch": "@@ -46,8 +46,8 @@ fn use_std(krate: &ast::Crate) -> bool {\n     !attr::contains_name(krate.attrs.as_slice(), \"no_std\")\n }\n \n-fn use_uv(krate: &ast::Crate) -> bool {\n-    !attr::contains_name(krate.attrs.as_slice(), \"no_uv\")\n+fn use_start(krate: &ast::Crate) -> bool {\n+    !attr::contains_name(krate.attrs.as_slice(), \"no_start\")\n }\n \n fn no_prelude(attrs: &[ast::Attribute]) -> bool {\n@@ -87,18 +87,10 @@ impl<'a> fold::Folder for StandardLibraryInjector<'a> {\n             span: DUMMY_SP\n         });\n \n-        if use_uv(&krate) && !self.sess.building_library.get() {\n+        if use_start(&krate) && !self.sess.building_library.get() {\n             vis.push(ast::ViewItem {\n-                node: ast::ViewItemExternCrate(token::str_to_ident(\"green\"),\n-                                             with_version(\"green\"),\n-                                             ast::DUMMY_NODE_ID),\n-                attrs: Vec::new(),\n-                vis: ast::Inherited,\n-                span: DUMMY_SP\n-            });\n-            vis.push(ast::ViewItem {\n-                node: ast::ViewItemExternCrate(token::str_to_ident(\"rustuv\"),\n-                                             with_version(\"rustuv\"),\n+                node: ast::ViewItemExternCrate(token::str_to_ident(\"native\"),\n+                                             with_version(\"native\"),\n                                              ast::DUMMY_NODE_ID),\n                 attrs: Vec::new(),\n                 vis: ast::Inherited,"}, {"sha": "286ecbd6c8f3cea1a966ba94713937927778cc01", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=bbf8cdc43feea08111abc5a59dc49a7f479d3103", "patch": "@@ -961,7 +961,7 @@ fn check_heap_item(cx: &Context, it: &ast::Item) {\n }\n \n static crate_attrs: &'static [&'static str] = &[\n-    \"crate_type\", \"feature\", \"no_uv\", \"no_main\", \"no_std\", \"crate_id\",\n+    \"crate_type\", \"feature\", \"no_start\", \"no_main\", \"no_std\", \"crate_id\",\n     \"desc\", \"comment\", \"license\", \"copyright\", // not used in rustc now\n ];\n "}, {"sha": "42ccdaf956282b9794a93f06a453b005aaa7cd3d", "filename": "src/librustuv/lib.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Flibrustuv%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Flibrustuv%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Flib.rs?ref=bbf8cdc43feea08111abc5a59dc49a7f479d3103", "patch": "@@ -45,6 +45,7 @@ via `close` and `delete` methods.\n #[allow(deprecated_owned_vector)]; // NOTE: remove after stage0\n \n #[cfg(test)] extern crate green;\n+#[cfg(test)] extern crate realrustuv = \"rustuv\";\n \n use std::cast;\n use std::fmt;\n@@ -69,6 +70,16 @@ pub use self::signal::SignalWatcher;\n pub use self::timer::TimerWatcher;\n pub use self::tty::TtyWatcher;\n \n+// Run tests with libgreen instead of libnative.\n+//\n+// FIXME: This egregiously hacks around starting the test runner in a different\n+//        threading mode than the default by reaching into the auto-generated\n+//        '__test' module.\n+#[cfg(test)] #[start]\n+fn start(argc: int, argv: **u8) -> int {\n+    green::start(argc, argv, __test::main)\n+}\n+\n mod macros;\n \n mod access;"}, {"sha": "7d734469b1293e3917507f8da2576d34ae1c5393", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=bbf8cdc43feea08111abc5a59dc49a7f479d3103", "patch": "@@ -81,6 +81,16 @@\n #[cfg(stage0)]\n pub use vec_ng = vec;\n \n+// Run tests with libgreen instead of libnative.\n+//\n+// FIXME: This egregiously hacks around starting the test runner in a different\n+//        threading mode than the default by reaching into the auto-generated\n+//        '__test' module.\n+#[cfg(test)] #[start]\n+fn start(argc: int, argv: **u8) -> int {\n+    green::start(argc, argv, __test::main)\n+}\n+\n pub mod macros;\n \n mod rtdeps;"}, {"sha": "9c27fe1c5e446990c370dcc530eda6a5e77b499d", "filename": "src/rt/rust_builtin.c", "status": "modified", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Frt%2Frust_builtin.c", "raw_url": "https://github.com/rust-lang/rust/raw/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Frt%2Frust_builtin.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.c?ref=bbf8cdc43feea08111abc5a59dc49a7f479d3103", "patch": "@@ -387,65 +387,6 @@ rust_unset_sigprocmask() {\n \n #endif\n \n-#if defined(__WIN32__)\n-void\n-win32_require(LPCTSTR fn, BOOL ok) {\n-    if (!ok) {\n-        LPTSTR buf;\n-        DWORD err = GetLastError();\n-        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n-                      FORMAT_MESSAGE_FROM_SYSTEM |\n-                      FORMAT_MESSAGE_IGNORE_INSERTS,\n-                      NULL, err,\n-                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n-                      (LPTSTR) &buf, 0, NULL );\n-        fprintf(stderr, \"%s failed with error %ld: %s\", fn, err, buf);\n-        LocalFree((HLOCAL)buf);\n-        abort();\n-    }\n-}\n-\n-void\n-rust_win32_rand_acquire(HCRYPTPROV* phProv) {\n-    win32_require\n-        (_T(\"CryptAcquireContext\"),\n-         // changes to the parameters here should be reflected in the docs of\n-         // rand::os::OSRng\n-         CryptAcquireContext(phProv, NULL, NULL, PROV_RSA_FULL,\n-                             CRYPT_VERIFYCONTEXT|CRYPT_SILENT));\n-\n-}\n-void\n-rust_win32_rand_gen(HCRYPTPROV hProv, DWORD dwLen, BYTE* pbBuffer) {\n-    win32_require\n-        (_T(\"CryptGenRandom\"), CryptGenRandom(hProv, dwLen, pbBuffer));\n-}\n-void\n-rust_win32_rand_release(HCRYPTPROV hProv) {\n-    win32_require\n-        (_T(\"CryptReleaseContext\"), CryptReleaseContext(hProv, 0));\n-}\n-\n-#else\n-\n-// these symbols are listed in rustrt.def.in, so they need to exist; but they\n-// should never be called.\n-\n-void\n-rust_win32_rand_acquire() {\n-    abort();\n-}\n-void\n-rust_win32_rand_gen() {\n-    abort();\n-}\n-void\n-rust_win32_rand_release() {\n-    abort();\n-}\n-\n-#endif\n-\n //\n // Local Variables:\n // mode: C++"}, {"sha": "377057a75ff1f2a6baa3d4b52a8aacf67abc4a39", "filename": "src/test/run-fail/native-failure.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Ftest%2Frun-fail%2Fnative-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Ftest%2Frun-fail%2Fnative-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fnative-failure.rs?ref=bbf8cdc43feea08111abc5a59dc49a7f479d3103", "patch": "@@ -11,8 +11,6 @@\n // ignore-android (FIXME #11419)\n // error-pattern:explicit failure\n \n-#[no_uv];\n-\n extern crate native;\n \n #[start]"}, {"sha": "62c5a06dbbf7baa3bb10e70e2374e1a2232d278c", "filename": "src/test/run-make/bootstrap-from-c-with-green/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-green%2Flib.rs?ref=bbf8cdc43feea08111abc5a59dc49a7f479d3103", "patch": "@@ -10,7 +10,6 @@\n \n #[crate_id=\"boot#0.1\"];\n #[crate_type=\"dylib\"];\n-#[no_uv];\n \n extern crate rustuv;\n extern crate green;"}, {"sha": "33c8d4ffab7a884ad5a15b849b1e4003e8411489", "filename": "src/test/run-make/bootstrap-from-c-with-native/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fbootstrap-from-c-with-native%2Flib.rs?ref=bbf8cdc43feea08111abc5a59dc49a7f479d3103", "patch": "@@ -10,7 +10,6 @@\n \n #[crate_id=\"boot#0.1\"];\n #[crate_type=\"dylib\"];\n-#[no_uv];\n \n extern crate native;\n "}, {"sha": "97dfbb0d8e27242002c8e97a09fa6b6707839164", "filename": "src/test/run-pass/capturing-logging.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs?ref=bbf8cdc43feea08111abc5a59dc49a7f479d3103", "patch": "@@ -14,10 +14,9 @@\n \n #[feature(phase)];\n \n-#[no_uv];\n-extern crate native;\n #[phase(syntax, link)]\n extern crate log;\n+extern crate native;\n \n use std::fmt;\n use std::io::{ChanReader, ChanWriter};"}, {"sha": "bda7a30762a1e94aa01342e8043d81ce836cfed3", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 67, "deletions": 58, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=bbf8cdc43feea08111abc5a59dc49a7f479d3103", "patch": "@@ -9,19 +9,50 @@\n // except according to those terms.\n \n // ignore-fast\n+// ignore-pretty\n // compile-flags:--test\n \n // NB: These tests kill child processes. Valgrind sees these children as leaking\n // memory, which makes for some *confusing* logs. That's why these are here\n // instead of in std.\n \n-use std::io::timer;\n-use std::libc;\n-use std::str;\n-use std::io::process::{Process, ProcessOutput};\n+#[feature(macro_rules)];\n \n-#[test]\n-fn test_destroy_once() {\n+extern crate native;\n+extern crate green;\n+extern crate rustuv;\n+\n+macro_rules! iotest (\n+    { fn $name:ident() $b:block $($a:attr)* } => (\n+        mod $name {\n+            #[allow(unused_imports)];\n+\n+            use std::io::timer;\n+            use std::libc;\n+            use std::str;\n+            use std::io::process::{Process, ProcessOutput};\n+            use native;\n+            use super::*;\n+\n+            fn f() $b\n+\n+            $($a)* #[test] fn green() { f() }\n+            $($a)* #[test] fn native() {\n+                use native;\n+                let (tx, rx) = channel();\n+                native::task::spawn(proc() { tx.send(f()) });\n+                rx.recv();\n+            }\n+        }\n+    )\n+)\n+\n+#[cfg(test)] #[start]\n+fn start(argc: int, argv: **u8) -> int {\n+    green::start(argc, argv, __test::main)\n+}\n+\n+iotest!(fn test_destroy_once() {\n     #[cfg(not(target_os=\"android\"))]\n     static mut PROG: &'static str = \"echo\";\n \n@@ -30,10 +61,9 @@ fn test_destroy_once() {\n \n     let mut p = unsafe {Process::new(PROG, []).unwrap()};\n     p.signal_exit().unwrap(); // this shouldn't crash (and nor should the destructor)\n-}\n+})\n \n-#[test]\n-fn test_destroy_twice() {\n+iotest!(fn test_destroy_twice() {\n     #[cfg(not(target_os=\"android\"))]\n     static mut PROG: &'static str = \"echo\";\n     #[cfg(target_os=\"android\")]\n@@ -45,75 +75,54 @@ fn test_destroy_twice() {\n     };\n     p.signal_exit().unwrap(); // this shouldnt crash...\n     p.signal_exit().unwrap(); // ...and nor should this (and nor should the destructor)\n-}\n+})\n \n-fn test_destroy_actually_kills(force: bool) {\n+pub fn test_destroy_actually_kills(force: bool) {\n+    use std::io::process::{Process, ProcessOutput, ExitStatus, ExitSignal};\n+    use std::io::timer;\n+    use std::libc;\n+    use std::str;\n \n     #[cfg(unix,not(target_os=\"android\"))]\n-    static mut BLOCK_COMMAND: &'static str = \"cat\";\n+    static BLOCK_COMMAND: &'static str = \"cat\";\n \n     #[cfg(unix,target_os=\"android\")]\n-    static mut BLOCK_COMMAND: &'static str = \"/system/bin/cat\";\n+    static BLOCK_COMMAND: &'static str = \"/system/bin/cat\";\n \n     #[cfg(windows)]\n-    static mut BLOCK_COMMAND: &'static str = \"cmd\";\n-\n-    #[cfg(unix,not(target_os=\"android\"))]\n-    fn process_exists(pid: libc::pid_t) -> bool {\n-        let ProcessOutput {output, ..} = Process::output(\"ps\", [~\"-p\", pid.to_str()])\n-            .unwrap();\n-        str::from_utf8_owned(output).unwrap().contains(pid.to_str())\n-    }\n-\n-    #[cfg(unix,target_os=\"android\")]\n-    fn process_exists(pid: libc::pid_t) -> bool {\n-        let ProcessOutput {output, ..} = Process::output(\"/system/bin/ps\", [pid.to_str()])\n-            .unwrap();\n-        str::from_utf8_owned(output).unwrap().contains(~\"root\")\n-    }\n-\n-    #[cfg(windows)]\n-    fn process_exists(pid: libc::pid_t) -> bool {\n-        use std::libc::types::os::arch::extra::DWORD;\n-        use std::libc::funcs::extra::kernel32::{CloseHandle, GetExitCodeProcess, OpenProcess};\n-        use std::libc::consts::os::extra::{FALSE, PROCESS_QUERY_INFORMATION, STILL_ACTIVE };\n-\n-        unsafe {\n-            let process = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, pid as DWORD);\n-            if process.is_null() {\n-                return false;\n-            }\n-            // process will be non-null if the process is alive, or if it died recently\n-            let mut status = 0;\n-            GetExitCodeProcess(process, &mut status);\n-            CloseHandle(process);\n-            return status == STILL_ACTIVE;\n-        }\n-    }\n+    static BLOCK_COMMAND: &'static str = \"cmd\";\n \n     // this process will stay alive indefinitely trying to read from stdin\n-    let mut p = unsafe {Process::new(BLOCK_COMMAND, []).unwrap()};\n+    let mut p = Process::new(BLOCK_COMMAND, []).unwrap();\n \n-    assert!(process_exists(p.id()));\n+    assert!(p.signal(0).is_ok());\n \n     if force {\n         p.signal_kill().unwrap();\n     } else {\n         p.signal_exit().unwrap();\n     }\n \n-    if process_exists(p.id()) {\n-        timer::sleep(500);\n-        assert!(!process_exists(p.id()));\n+    // Don't let this test time out, this should be quick\n+    let (tx, rx1) = channel();\n+    let mut t = timer::Timer::new().unwrap();\n+    let rx2 = t.oneshot(1000);\n+    spawn(proc() {\n+        select! {\n+            () = rx2.recv() => unsafe { libc::exit(1) },\n+            () = rx1.recv() => {}\n+        }\n+    });\n+    match p.wait() {\n+        ExitStatus(..) => fail!(\"expected a signal\"),\n+        ExitSignal(..) => tx.send(()),\n     }\n }\n \n-#[test]\n-fn test_unforced_destroy_actually_kills() {\n+iotest!(fn test_unforced_destroy_actually_kills() {\n     test_destroy_actually_kills(false);\n-}\n+})\n \n-#[test]\n-fn test_forced_destroy_actually_kills() {\n+iotest!(fn test_forced_destroy_actually_kills() {\n     test_destroy_actually_kills(true);\n-}\n+})"}, {"sha": "150435959e42c3de4322d556c25193dc4f48c8d4", "filename": "src/test/run-pass/native-print-no-runtime.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Ftest%2Frun-pass%2Fnative-print-no-runtime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Ftest%2Frun-pass%2Fnative-print-no-runtime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnative-print-no-runtime.rs?ref=bbf8cdc43feea08111abc5a59dc49a7f479d3103", "patch": "@@ -10,8 +10,6 @@\n \n // ignore-fast\n \n-#[no_uv];\n-\n #[start]\n pub fn main(_: int, _: **u8) -> int {\n     println!(\"hello\");"}, {"sha": "319c2682013183d9bbee6a44819e09d281eda4d1", "filename": "src/test/run-pass/process-detach.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Ftest%2Frun-pass%2Fprocess-detach.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbf8cdc43feea08111abc5a59dc49a7f479d3103/src%2Ftest%2Frun-pass%2Fprocess-detach.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fprocess-detach.rs?ref=bbf8cdc43feea08111abc5a59dc49a7f479d3103", "patch": "@@ -20,10 +20,16 @@\n // Note that the first thing we do is put ourselves in our own process group so\n // we don't interfere with other running tests.\n \n+extern crate green;\n+extern crate rustuv;\n+\n use std::libc;\n use std::io::process;\n use std::io::signal::{Listener, Interrupt};\n \n+#[start]\n+fn start(argc: int, argv: **u8) -> int { green::start(argc, argv, main) }\n+\n fn main() {\n     unsafe { libc::setsid(); }\n "}]}