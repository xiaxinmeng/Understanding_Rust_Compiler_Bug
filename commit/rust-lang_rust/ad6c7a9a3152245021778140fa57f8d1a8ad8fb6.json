{"sha": "ad6c7a9a3152245021778140fa57f8d1a8ad8fb6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkNmM3YTlhMzE1MjI0NTAyMTc3ODE0MGZhNTdmOGQxYThhZDhmYjY=", "commit": {"author": {"name": "Jonathan Behrens", "email": "fintelia@gmail.com", "date": "2018-09-07T20:47:19Z"}, "committer": {"name": "Jonathan Behrens", "email": "fintelia@gmail.com", "date": "2018-09-07T20:47:19Z"}, "message": "Cleanup API somewhat", "tree": {"sha": "b09f54785d4e0b407864f0f941173c589c1dce76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b09f54785d4e0b407864f0f941173c589c1dce76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad6c7a9a3152245021778140fa57f8d1a8ad8fb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad6c7a9a3152245021778140fa57f8d1a8ad8fb6", "html_url": "https://github.com/rust-lang/rust/commit/ad6c7a9a3152245021778140fa57f8d1a8ad8fb6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad6c7a9a3152245021778140fa57f8d1a8ad8fb6/comments", "author": {"login": "fintelia", "id": 4943209, "node_id": "MDQ6VXNlcjQ5NDMyMDk=", "avatar_url": "https://avatars.githubusercontent.com/u/4943209?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fintelia", "html_url": "https://github.com/fintelia", "followers_url": "https://api.github.com/users/fintelia/followers", "following_url": "https://api.github.com/users/fintelia/following{/other_user}", "gists_url": "https://api.github.com/users/fintelia/gists{/gist_id}", "starred_url": "https://api.github.com/users/fintelia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fintelia/subscriptions", "organizations_url": "https://api.github.com/users/fintelia/orgs", "repos_url": "https://api.github.com/users/fintelia/repos", "events_url": "https://api.github.com/users/fintelia/events{/privacy}", "received_events_url": "https://api.github.com/users/fintelia/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fintelia", "id": 4943209, "node_id": "MDQ6VXNlcjQ5NDMyMDk=", "avatar_url": "https://avatars.githubusercontent.com/u/4943209?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fintelia", "html_url": "https://github.com/fintelia", "followers_url": "https://api.github.com/users/fintelia/followers", "following_url": "https://api.github.com/users/fintelia/following{/other_user}", "gists_url": "https://api.github.com/users/fintelia/gists{/gist_id}", "starred_url": "https://api.github.com/users/fintelia/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fintelia/subscriptions", "organizations_url": "https://api.github.com/users/fintelia/orgs", "repos_url": "https://api.github.com/users/fintelia/repos", "events_url": "https://api.github.com/users/fintelia/events{/privacy}", "received_events_url": "https://api.github.com/users/fintelia/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6089af72c0060ee0f88db77a142762abf194a326", "url": "https://api.github.com/repos/rust-lang/rust/commits/6089af72c0060ee0f88db77a142762abf194a326", "html_url": "https://github.com/rust-lang/rust/commit/6089af72c0060ee0f88db77a142762abf194a326"}], "stats": {"total": 413, "additions": 195, "deletions": 218}, "files": [{"sha": "1a432e5bd3d03a670b877f8a9e8fa5908b331314", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 195, "deletions": 217, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/ad6c7a9a3152245021778140fa57f8d1a8ad8fb6/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad6c7a9a3152245021778140fa57f8d1a8ad8fb6/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=ad6c7a9a3152245021778140fa57f8d1a8ad8fb6", "patch": "@@ -443,7 +443,7 @@ fn search_hashed<K, V, M, F>(table: M, hash: SafeHash, is_match: F) -> InternalE\n #[inline]\n fn search_hashed_mut<K, V, M, F>(table: M, hash: SafeHash, is_match: F) -> InternalEntry<K, V, M>\n     where M: DerefMut<Target = RawTable<K, V>>,\n-          F: FnMut(&mut K) -> bool\n+          F: FnMut(&K) -> bool\n {\n     // This is the only function where capacity can be zero. To avoid\n     // undefined behavior when Bucket::new gets the raw bucket in this\n@@ -510,7 +510,7 @@ fn search_hashed_nonempty<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F)\n fn search_hashed_nonempty_mut<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F)\n     -> InternalEntry<K, V, M>\n     where M: DerefMut<Target = RawTable<K, V>>,\n-          F: FnMut(&mut K) -> bool\n+          F: FnMut(&K) -> bool\n {\n     // Do not check the capacity as an extra branch could slow the lookup.\n \n@@ -1591,9 +1591,9 @@ impl<K, V, S> HashMap<K, V, S>\n     ///\n     ///\n     #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n-    pub fn raw_entry(&mut self) -> RawEntryBuilder<K, V, S> {\n+    pub fn raw_entry_mut(&mut self) -> RawEntryBuilderMut<K, V, S> {\n         self.reserve(1);\n-        RawEntryBuilder { map: self }\n+        RawEntryBuilderMut { map: self }\n     }\n \n     /// Creates a raw immutable entry builder for the HashMap.\n@@ -1611,9 +1611,9 @@ impl<K, V, S> HashMap<K, V, S>\n     /// `get` should be preferred.\n     ///\n     /// Immutable raw entries have very limited use; you might instead want `raw_entry`.\n-    #[unstable(feature = \"hash_raw_entry_immut\", issue = \"42069\")]\n-    pub fn raw_entry_immut(&self) -> RawImmutableEntryBuilder<K, V, S> {\n-        RawImmutableEntryBuilder { map: self }\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+    pub fn raw_entry(&self) -> RawEntryBuilder<K, V, S> {\n+        RawEntryBuilder { map: self }\n     }\n }\n \n@@ -1842,13 +1842,14 @@ impl<'a, K, V> InternalEntry<K, V, &'a mut RawTable<K, V>> {\n             InternalEntry::Occupied { elem } => {\n                 Some(Occupied(OccupiedEntry {\n                     key: Some(key),\n-                    entry: RawOccupiedEntry { elem },\n+                    elem,\n                 }))\n             }\n             InternalEntry::Vacant { hash, elem } => {\n                 Some(Vacant(VacantEntry {\n+                    hash,\n                     key,\n-                    entry: RawVacantEntry { hash, elem }\n+                    elem,\n                 }))\n             }\n             InternalEntry::TableIsEmpty => None,\n@@ -1858,22 +1859,12 @@ impl<'a, K, V> InternalEntry<K, V, &'a mut RawTable<K, V>> {\n \n /// A builder for computing where in a HashMap a key-value pair would be stored.\n ///\n-/// See the [`HashMap::raw_entry`][] docs for usage examples.\n+/// See the [`HashMap::raw_entry_mut`][] docs for usage examples.\n #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n-pub struct RawEntryBuilder<'a, K: 'a, V: 'a, S: 'a> {\n+pub struct RawEntryBuilderMut<'a, K: 'a, V: 'a, S: 'a> {\n     map: &'a mut HashMap<K, V, S>,\n }\n \n-/// A builder for computing where in a HashMap a key-value pair would be stored,\n-/// where the hash has already been specified.\n-///\n-/// See the [`HashMap::raw_entry`][] docs for usage examples.\n-#[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n-pub struct RawEntryBuilderHashed<'a, K: 'a, V: 'a> {\n-    map: &'a mut RawTable<K, V>,\n-    hash: SafeHash,\n-}\n-\n /// A view into a single entry in a map, which may either be vacant or occupied.\n ///\n /// This is a lower-level version of [`Entry`].\n@@ -1884,191 +1875,170 @@ pub struct RawEntryBuilderHashed<'a, K: 'a, V: 'a> {\n /// [`Entry`]: struct.Entry.html\n /// [`raw_entry`]: struct.HashMap.html#method.raw_entry\n #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n-pub enum RawEntry<'a, K: 'a, V: 'a> {\n+pub enum RawEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n     /// An occupied entry.\n-    Occupied(RawOccupiedEntry<'a, K, V>),\n+    Occupied(RawOccupiedEntryMut<'a, K, V>),\n     /// A vacant entry.\n-    Vacant(RawVacantEntry<'a, K, V>),\n+    Vacant(RawVacantEntryMut<'a, K, V, S>),\n }\n \n /// A view into an occupied entry in a `HashMap`.\n-/// It is part of the [`RawEntry`] enum.\n+/// It is part of the [`RawEntryMut`] enum.\n ///\n-/// [`RawEntry`]: enum.RawEntry.html\n+/// [`RawEntryMut`]: enum.RawEntryMut.html\n #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n-pub struct RawOccupiedEntry<'a, K: 'a, V: 'a> {\n+pub struct RawOccupiedEntryMut<'a, K: 'a, V: 'a> {\n     elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n }\n \n /// A view into a vacant entry in a `HashMap`.\n-/// It is part of the [`RawEntry`] enum.\n+/// It is part of the [`RawEntryMut`] enum.\n ///\n-/// [`RawEntry`]: enum.RawEntry.html\n+/// [`RawEntryMut`]: enum.RawEntryMut.html\n #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n-pub struct RawVacantEntry<'a, K: 'a, V: 'a> {\n-    hash: SafeHash,\n+pub struct RawVacantEntryMut<'a, K: 'a, V: 'a, S: 'a> {\n     elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n+    hash_builder: &'a S,\n }\n \n /// A builder for computing where in a HashMap a key-value pair would be stored.\n ///\n-/// See the [`HashMap::raw_entry_immut`][] docs for usage examples.\n-#[unstable(feature = \"hash_raw_entry_immut\", issue = \"42069\")]\n-pub struct RawImmutableEntryBuilder<'a, K: 'a, V: 'a, S: 'a> {\n+/// See the [`HashMap::raw_entry`][] docs for usage examples.\n+#[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+pub struct RawEntryBuilder<'a, K: 'a, V: 'a, S: 'a> {\n     map: &'a HashMap<K, V, S>,\n }\n \n-/// A builder for computing where in a HashMap a key-value pair would be stored,\n-/// where the hash has already been specified.\n-///\n-/// See the [`HashMap::raw_entry_immut`][] docs for usage examples.\n-#[unstable(feature = \"hash_raw_entry_immut\", issue = \"42069\")]\n-pub struct RawImmutableEntryBuilderHashed<'a, K: 'a, V: 'a> {\n-    map: &'a RawTable<K, V>,\n-    hash: SafeHash,\n-}\n-\n-impl<'a, K, V, S> RawEntryBuilder<'a, K, V, S>\n+impl<'a, K, V, S> RawEntryBuilderMut<'a, K, V, S>\n     where S: BuildHasher,\n+          K: Eq + Hash,\n {\n-    /// Initializes the raw entry builder with the hash of the given query value.\n+    /// Create a `RawEntryMut` from the given key.\n     #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n-    pub fn hash_by<Q: ?Sized>(self, k: &Q) -> RawEntryBuilderHashed<'a, K, V>\n-        where Q: Hash\n-    {\n-        self.hash_with(|mut hasher| {\n-            k.hash(&mut hasher);\n-            hasher.finish()\n-        })\n-    }\n-\n-    /// Initializes the raw entry builder with the hash yielded by the given function.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n-    pub fn hash_with<F>(self, func: F) -> RawEntryBuilderHashed<'a, K, V>\n-        where F: FnOnce(S::Hasher) -> u64\n-    {\n-        let hasher = self.map.hash_builder.build_hasher();\n-        let hash = SafeHash::new(func(hasher));\n-\n-        RawEntryBuilderHashed { map: &mut self.map.table, hash }\n-    }\n-\n-    /// Searches for the location of the raw entry with the given query value.\n-    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n-    pub fn search_by<Q: ?Sized>(self, k: &Q) -> RawEntry<'a, K, V>\n+    pub fn from_key<Q: ?Sized>(self, k: &Q) -> RawEntryMut<'a, K, V, S>\n         where K: Borrow<Q>,\n-              Q: Eq + Hash\n+              Q: Hash + Eq\n     {\n-        self.hash_by(k).search_by(k)\n+        let mut hasher = self.map.hash_builder.build_hasher();\n+        k.hash(&mut hasher);\n+        self.from_key_hashed_nocheck(hasher.finish(), k)\n     }\n-}\n \n-impl<'a, K, V> RawEntryBuilderHashed<'a, K, V>\n-{\n-    /// Searches for the location of the raw entry with the given query value.\n-    ///\n-    /// Note that it isn't required that the query value be hashable, as the\n-    /// builder's hash is used.\n+    /// Create a `RawEntryMut` from the given key and its hash.\n     #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n-    pub fn search_by<Q: ?Sized>(self, k: &Q) -> RawEntry<'a, K, V>\n+    pub fn from_key_hashed_nocheck<Q: ?Sized>(self, hash: u64, k: &Q) -> RawEntryMut<'a, K, V, S>\n         where K: Borrow<Q>,\n-              Q: Eq,\n+              Q: Eq\n     {\n-        // I don't know why we need this `&mut -> &` transform to resolve Borrow, but we do\n-        self.search_with(|key| (&*key).borrow() == k)\n+        self.from_hash(hash, |q| q.borrow().eq(k))\n     }\n \n-    /// Searches for the location of the raw entry with the given comparison function.\n-    ///\n-    /// Note that mutable access is given to each key that is visited, because\n-    /// this land is truly godless, and *someone* might have a use for this.\n+    /// Create a `RawEntryMut` from the given hash.\n     #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n-    pub fn search_with<F>(self, func: F) -> RawEntry<'a, K, V>\n-        where F: FnMut(&mut K) -> bool,\n+    pub fn from_hash<F>(self, hash: u64, is_match: F) -> RawEntryMut<'a, K, V, S>\n+        where for<'b> F: FnMut(&'b K) -> bool,\n     {\n-        match search_hashed_mut(self.map, self.hash, func) {\n+        match search_hashed_mut(&mut self.map.table, SafeHash::new(hash), is_match) {\n             InternalEntry::Occupied { elem } => {\n-                RawEntry::Occupied(RawOccupiedEntry { elem })\n+                RawEntryMut::Occupied(RawOccupiedEntryMut { elem })\n             }\n-            InternalEntry::Vacant { hash, elem } => {\n-                RawEntry::Vacant(RawVacantEntry { hash, elem })\n+            InternalEntry::Vacant { elem, .. } => {\n+                RawEntryMut::Vacant(RawVacantEntryMut {\n+                    elem,\n+                    hash_builder: &self.map.hash_builder,\n+                })\n             }\n             InternalEntry::TableIsEmpty => {\n                 unreachable!()\n             }\n         }\n     }\n-}\n \n-impl<'a, K, V, S> RawImmutableEntryBuilder<'a, K, V, S>\n-    where S: BuildHasher,\n-{\n-    /// Initializes the raw entry builder with the hash of the given query value.\n-    #[unstable(feature = \"hash_raw_entry_immut\", issue = \"42069\")]\n-    pub fn hash_by<Q: ?Sized>(self, k: &Q) -> RawImmutableEntryBuilderHashed<'a, K, V>\n-        where Q: Hash\n+    /// Create a `RawEntryMut` by examining the elements of a hash bucket until `is_match` returns true for one of them.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+    pub fn from_bucket<F>(self, hash_bucket: u64, mut is_match: F) -> RawEntryMut<'a, K, V, S>\n+        where for<'b> F: FnMut(&'b K) -> bool,\n     {\n-        self.hash_with(|mut hasher| {\n-            k.hash(&mut hasher);\n-            hasher.finish()\n-        })\n-    }\n+        let hash = SafeHash::new(hash_bucket);\n \n-    /// Initializes the raw entry builder with the hash yielded by the given function.\n-    #[unstable(feature = \"hash_raw_entry_immut\", issue = \"42069\")]\n-    pub fn hash_with<F>(self, func: F) -> RawImmutableEntryBuilderHashed<'a, K, V>\n-        where F: FnOnce(S::Hasher) -> u64\n-    {\n-        let hasher = self.map.hash_builder.build_hasher();\n-        let hash = SafeHash::new(func(hasher));\n+        let size = self.map.table.size();\n+        let mut probe = Bucket::new(&mut self.map.table, hash);\n+        let mut displacement = 0;\n \n-        RawImmutableEntryBuilderHashed { map: &self.map.table, hash }\n+        loop {\n+            let full = match probe.peek() {\n+                Empty(bucket) => {\n+                    // Found a hole!\n+                    return RawEntryMut::Vacant(RawVacantEntryMut {\n+                        elem: NoElem(bucket, displacement),\n+                        hash_builder: &self.map.hash_builder,\n+                    });\n+                }\n+                Full(bucket) => bucket,\n+            };\n+\n+            let probe_displacement = full.displacement();\n+\n+            if probe_displacement < displacement {\n+                // Found a luckier bucket than me.\n+                // We can finish the search early if we hit any bucket\n+                // with a lower distance to initial bucket than we've probed.\n+                return RawEntryMut::Vacant(RawVacantEntryMut {\n+                    elem: NeqElem(full, probe_displacement),\n+                    hash_builder: &self.map.hash_builder,\n+                })\n+            }\n+\n+            // Call is_match even if hash doesn't match hash_bucket.\n+            if is_match(full.read().0) {\n+                return RawEntryMut::Occupied(RawOccupiedEntryMut { elem: full });\n+            }\n+\n+            displacement += 1;\n+            probe = full.next();\n+            debug_assert!(displacement <= size);\n+        }\n     }\n+}\n \n-    /// Searches for the location of the raw entry with the given query value.\n-    #[unstable(feature = \"hash_raw_entry_immut\", issue = \"42069\")]\n-    pub fn search_by<Q: ?Sized>(self, k: &Q) -> Option<(&'a K, &'a V)>\n+impl<'a, K, V, S> RawEntryBuilder<'a, K, V, S>\n+    where S: BuildHasher,\n+{\n+    /// Access an entry by key.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+    pub fn from_key<Q: ?Sized>(self, k: &Q) -> Option<(&'a K, &'a V)>\n         where K: Borrow<Q>,\n-              Q: Eq + Hash\n+              Q: Hash + Eq\n     {\n-        self.hash_by(k).search_by(k)\n+        let mut hasher = self.map.hash_builder.build_hasher();\n+        k.hash(&mut hasher);\n+        self.from_key_hashed_nocheck(hasher.finish(), k)\n     }\n-}\n \n-impl<'a, K, V> RawImmutableEntryBuilderHashed<'a, K, V>\n-{\n-    /// Searches for the location of the raw entry with the given query value.\n-    ///\n-    /// Note that it isn't required that the query value be hashable, as the\n-    /// builder's hash is used.\n-    #[unstable(feature = \"hash_raw_entry_immut\", issue = \"42069\")]\n-    pub fn search_by<Q: ?Sized>(self, k: &Q) -> Option<(&'a K, &'a V)>\n+    /// Access an entry by a key and its hash.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+    pub fn from_key_hashed_nocheck<Q: ?Sized>(self, hash: u64, k: &Q) -> Option<(&'a K, &'a V)>\n         where K: Borrow<Q>,\n-              Q: Eq,\n+              Q: Hash + Eq\n+\n     {\n-        self.search_with(|key| key.borrow() == k)\n+        self.from_hash(hash, |q| q.borrow().eq(k))\n     }\n \n-    /// Searches for the location of the raw entry with the given comparison function.\n-    ///\n-    /// Note that mutable access is given to each key that is visited, because\n-    /// this land is truly godless, and *someone* might have a use for this.\n-    #[unstable(feature = \"hash_raw_entry_immut\", issue = \"42069\")]\n-    pub fn search_with<F>(self, func: F) -> Option<(&'a K, &'a V)>\n-        where F: FnMut(&K) -> bool,\n+    /// Access an entry by hash.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+    pub fn from_hash<F>(self, hash: u64, is_match: F) -> Option<(&'a K, &'a V)>\n+        where F: FnMut(&K) -> bool\n     {\n-        match search_hashed(self.map, self.hash, func) {\n-            InternalEntry::Occupied { elem } => {\n-                Some(elem.into_refs())\n-            }\n-            InternalEntry::Vacant { .. } | InternalEntry::TableIsEmpty  => {\n-                None\n-            }\n+        match search_hashed(&self.map.table, SafeHash::new(hash), is_match) {\n+            InternalEntry::Occupied { elem } => Some(elem.into_refs()),\n+            InternalEntry::Vacant { .. } => None,\n+            InternalEntry::TableIsEmpty => unreachable!(),\n         }\n     }\n }\n \n-impl<'a, K, V> RawEntry<'a, K, V> {\n+impl<'a, K, V, S> RawEntryMut<'a, K, V, S> {\n     /// Ensures a value is in the entry by inserting the default if empty, and returns\n     /// mutable references to the key and value in the entry.\n     ///\n@@ -2086,10 +2056,13 @@ impl<'a, K, V> RawEntry<'a, K, V> {\n     /// assert_eq!(map[\"poneyland\"], 22);\n     /// ```\n     #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n-    pub fn or_insert(self, default_key: K, default_val: V) -> (&'a mut K, &'a mut V) {\n+    pub fn or_insert(self, default_key: K, default_val: V) -> (&'a mut K, &'a mut V)\n+        where K: Hash,\n+              S: BuildHasher,\n+    {\n         match self {\n-            RawEntry::Occupied(entry) => entry.into_kv(),\n-            RawEntry::Vacant(entry) => entry.insert(default_key, default_val),\n+            RawEntryMut::Occupied(entry) => entry.into_key_value(),\n+            RawEntryMut::Vacant(entry) => entry.insert(default_key, default_val),\n         }\n     }\n \n@@ -2112,10 +2085,12 @@ impl<'a, K, V> RawEntry<'a, K, V> {\n     #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n     pub fn or_insert_with<F>(self, default: F) -> (&'a mut K, &'a mut V)\n         where F: FnOnce() -> (K, V),\n+              K: Hash,\n+              S: BuildHasher,\n     {\n         match self {\n-            RawEntry::Occupied(entry) => entry.into_kv(),\n-            RawEntry::Vacant(entry) => {\n+            RawEntryMut::Occupied(entry) => entry.into_key_value(),\n+            RawEntryMut::Vacant(entry) => {\n                 let (k, v) = default();\n                 entry.insert(k, v)\n             }\n@@ -2149,19 +2124,19 @@ impl<'a, K, V> RawEntry<'a, K, V> {\n         where F: FnOnce(&mut K, &mut V)\n     {\n         match self {\n-            RawEntry::Occupied(mut entry) => {\n+            RawEntryMut::Occupied(mut entry) => {\n                 {\n-                    let (k, v) = entry.kv_mut();\n+                    let (k, v) = entry.get_key_value_mut();\n                     f(k, v);\n                 }\n-                RawEntry::Occupied(entry)\n+                RawEntryMut::Occupied(entry)\n             },\n-            RawEntry::Vacant(entry) => RawEntry::Vacant(entry),\n+            RawEntryMut::Vacant(entry) => RawEntryMut::Vacant(entry),\n         }\n     }\n }\n \n-impl<'a, K, V> RawOccupiedEntry<'a, K, V> {\n+impl<'a, K, V> RawOccupiedEntryMut<'a, K, V> {\n     /// Gets a reference to the key in the entry.\n     #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n     pub fn key(&self) -> &K {\n@@ -2202,20 +2177,20 @@ impl<'a, K, V> RawOccupiedEntry<'a, K, V> {\n \n     /// Gets a reference to the key and value in the entry.\n     #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n-    pub fn kv(&mut self) -> (&K, &V) {\n+    pub fn get_key_value(&mut self) -> (&K, &V) {\n         self.elem.read()\n     }\n \n     /// Gets a mutable reference to the key and value in the entry.\n     #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n-    pub fn kv_mut(&mut self) -> (&mut K, &mut V) {\n+    pub fn get_key_value_mut(&mut self) -> (&mut K, &mut V) {\n         self.elem.read_mut()\n     }\n \n     /// Converts the OccupiedEntry into a mutable reference to the key and value in the entry\n     /// with a lifetime bound to the map itself.\n     #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n-    pub fn into_kv(self) -> (&'a mut K, &'a mut V) {\n+    pub fn into_key_value(self) -> (&'a mut K, &'a mut V) {\n         self.elem.into_mut_refs()\n     }\n \n@@ -2246,56 +2221,60 @@ impl<'a, K, V> RawOccupiedEntry<'a, K, V> {\n     }\n }\n \n-impl<'a, K, V> RawVacantEntry<'a, K, V> {\n+impl<'a, K, V, S> RawVacantEntryMut<'a, K, V, S> {\n     /// Sets the value of the entry with the VacantEntry's key,\n     /// and returns a mutable reference to it.\n     #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n-    pub fn insert(self, key: K, value: V) -> (&'a mut K, &'a mut V) {\n+    pub fn insert(self, key: K, value: V) -> (&'a mut K, &'a mut V)\n+        where K: Hash,\n+              S: BuildHasher,\n+    {\n+        let mut hasher = self.hash_builder.build_hasher();\n+        key.hash(&mut hasher);\n+        self.insert_hashed_nocheck(hasher.finish(), key, value)\n+    }\n+\n+    /// Sets the value of the entry with the VacantEntry's key,\n+    /// and returns a mutable reference to it.\n+    #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+    pub fn insert_hashed_nocheck(self, hash: u64, key: K, value: V) -> (&'a mut K, &'a mut V) {\n+        let hash = SafeHash::new(hash);\n         let b = match self.elem {\n             NeqElem(mut bucket, disp) => {\n                 if disp >= DISPLACEMENT_THRESHOLD {\n                     bucket.table_mut().set_tag(true);\n                 }\n-                robin_hood(bucket, disp, self.hash, key, value)\n+                robin_hood(bucket, disp, hash, key, value)\n             },\n             NoElem(mut bucket, disp) => {\n                 if disp >= DISPLACEMENT_THRESHOLD {\n                     bucket.table_mut().set_tag(true);\n                 }\n-                bucket.put(self.hash, key, value)\n+                bucket.put(hash, key, value)\n             },\n         };\n         b.into_mut_refs()\n     }\n }\n \n #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n-impl<'a, K, V, S> Debug for RawEntryBuilder<'a, K, V, S> {\n+impl<'a, K, V, S> Debug for RawEntryBuilderMut<'a, K, V, S> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_struct(\"RawEntryBuilder\")\n          .finish()\n     }\n }\n \n #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n-impl<'a, K, V> Debug for RawEntryBuilderHashed<'a, K, V> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"RawEntryBuilderHashed\")\n-         .field(\"hash\", &self.hash.inspect())\n-         .finish()\n-    }\n-}\n-\n-#[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n-impl<'a, K: Debug, V: Debug> Debug for RawEntry<'a, K, V> {\n+impl<'a, K: Debug, V: Debug, S> Debug for RawEntryMut<'a, K, V, S> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            RawEntry::Vacant(ref v) => {\n+            RawEntryMut::Vacant(ref v) => {\n                 f.debug_tuple(\"RawEntry\")\n                     .field(v)\n                     .finish()\n             }\n-            RawEntry::Occupied(ref o) => {\n+            RawEntryMut::Occupied(ref o) => {\n                 f.debug_tuple(\"RawEntry\")\n                     .field(o)\n                     .finish()\n@@ -2305,37 +2284,27 @@ impl<'a, K: Debug, V: Debug> Debug for RawEntry<'a, K, V> {\n }\n \n #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n-impl<'a, K: Debug, V: Debug> Debug for RawOccupiedEntry<'a, K, V> {\n+impl<'a, K: Debug, V: Debug> Debug for RawOccupiedEntryMut<'a, K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"RawOccupiedEntry\")\n+        f.debug_struct(\"RawOccupiedEntryMut\")\n          .field(\"key\", self.key())\n          .field(\"value\", self.get())\n          .finish()\n     }\n }\n \n #[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n-impl<'a, K, V> Debug for RawVacantEntry<'a, K, V> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"RawVacantEntry\")\n-         .field(\"hash\", &self.hash.inspect())\n-         .finish()\n-    }\n-}\n-\n-#[unstable(feature = \"hash_raw_entry_immut\", issue = \"42069\")]\n-impl<'a, K, V, S> Debug for RawImmutableEntryBuilder<'a, K, V, S> {\n+impl<'a, K, V, S> Debug for RawVacantEntryMut<'a, K, V, S> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"RawImmutableEntryBuilder\")\n+        f.debug_struct(\"RawVacantEntryMut\")\n          .finish()\n     }\n }\n \n-#[unstable(feature = \"hash_raw_entry_immut\", issue = \"42069\")]\n-impl<'a, K, V> Debug for RawImmutableEntryBuilderHashed<'a, K, V> {\n+#[unstable(feature = \"hash_raw_entry\", issue = \"42069\")]\n+impl<'a, K, V, S> Debug for RawEntryBuilder<'a, K, V, S> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.debug_struct(\"RawImmutableEntryBuilderHashed\")\n-         .field(\"hash\", &self.hash.inspect())\n+        f.debug_struct(\"RawEntryBuilder\")\n          .finish()\n     }\n }\n@@ -2384,7 +2353,7 @@ impl<'a, K: 'a + Debug, V: 'a + Debug> Debug for Entry<'a, K, V> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n     key: Option<K>,\n-    entry: RawOccupiedEntry<'a, K, V>,\n+    elem: FullBucket<K, V, &'a mut RawTable<K, V>>,\n }\n \n #[stable(feature= \"debug_hash_map\", since = \"1.12.0\")]\n@@ -2403,8 +2372,9 @@ impl<'a, K: 'a + Debug, V: 'a + Debug> Debug for OccupiedEntry<'a, K, V> {\n /// [`Entry`]: enum.Entry.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct VacantEntry<'a, K: 'a, V: 'a> {\n+    hash: SafeHash,\n     key: K,\n-    entry: RawVacantEntry<'a, K, V>,\n+    elem: VacantEntryState<K, V, &'a mut RawTable<K, V>>,\n }\n \n #[stable(feature= \"debug_hash_map\", since = \"1.12.0\")]\n@@ -2828,7 +2798,7 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// ```\n     #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n     pub fn key(&self) -> &K {\n-        self.entry.key()\n+        self.elem.read().0\n     }\n \n     /// Take the ownership of the key and value from the map.\n@@ -2851,7 +2821,8 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// ```\n     #[stable(feature = \"map_entry_recover_keys2\", since = \"1.12.0\")]\n     pub fn remove_entry(self) -> (K, V) {\n-        self.entry.remove_entry()\n+        let (k, v, _) = pop_internal(self.elem);\n+        (k, v)\n     }\n \n     /// Gets a reference to the value in the entry.\n@@ -2871,7 +2842,7 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self) -> &V {\n-        self.entry.get()\n+        self.elem.read().1\n     }\n \n     /// Gets a mutable reference to the value in the entry.\n@@ -2903,7 +2874,7 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self) -> &mut V {\n-        self.entry.get_mut()\n+        self.elem.read_mut().1\n     }\n \n     /// Converts the OccupiedEntry into a mutable reference to the value in the entry\n@@ -2931,7 +2902,7 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_mut(self) -> &'a mut V {\n-        self.entry.into_mut()\n+        self.elem.into_mut_refs().1\n     }\n \n     /// Sets the value of the entry, and returns the entry's old value.\n@@ -2952,8 +2923,10 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// assert_eq!(map[\"poneyland\"], 15);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn insert(&mut self, value: V) -> V {\n-        self.entry.insert(value)\n+    pub fn insert(&mut self, mut value: V) -> V {\n+        let old_value = self.get_mut();\n+        mem::swap(&mut value, old_value);\n+        value\n     }\n \n     /// Takes the value out of the entry, and returns it.\n@@ -2975,7 +2948,7 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(self) -> V {\n-        self.entry.remove()\n+        pop_internal(self.elem).1\n     }\n \n     /// Returns a key that was used for search.\n@@ -3008,7 +2981,7 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// ```\n     #[unstable(feature = \"map_entry_replace\", issue = \"44286\")]\n     pub fn replace_entry(mut self, value: V) -> (K, V) {\n-        let (old_key, old_value) = self.entry.kv_mut();\n+        let (old_key, old_value) = self.elem.read_mut();\n \n         let old_key = mem::replace(old_key, self.key.unwrap());\n         let old_value = mem::replace(old_value, value);\n@@ -3043,7 +3016,8 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// ```\n     #[unstable(feature = \"map_entry_replace\", issue = \"44286\")]\n     pub fn replace_key(mut self) -> K {\n-        mem::replace(self.entry.key_mut(), self.key.unwrap())\n+        let (old_key, _) = self.elem.read_mut();\n+        mem::replace(old_key, self.key.unwrap())\n     }\n }\n \n@@ -3101,7 +3075,21 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(self, value: V) -> &'a mut V {\n-        self.entry.insert(self.key, value).1\n+        let b = match self.elem {\n+            NeqElem(mut bucket, disp) => {\n+                if disp >= DISPLACEMENT_THRESHOLD {\n+                    bucket.table_mut().set_tag(true);\n+                }\n+                robin_hood(bucket, disp, self.hash, self.key, value)\n+            },\n+            NoElem(mut bucket, disp) => {\n+                if disp >= DISPLACEMENT_THRESHOLD {\n+                    bucket.table_mut().set_tag(true);\n+                }\n+                bucket.put(self.hash, self.key, value)\n+            },\n+        };\n+        b.into_mut_refs().1\n     }\n }\n \n@@ -3312,7 +3300,7 @@ impl<K, S, Q: ?Sized> super::Recover<Q> for HashMap<K, (), S>\n         match self.entry(key) {\n             Occupied(mut occupied) => {\n                 let key = occupied.take_key().unwrap();\n-                Some(mem::replace(occupied.entry.key_mut(), key))\n+                Some(mem::replace(occupied.elem.read_mut().0, key))\n             }\n             Vacant(vacant) => {\n                 vacant.insert(());\n@@ -3363,6 +3351,7 @@ fn assert_covariance() {\n #[cfg(test)]\n mod test_map {\n     use super::HashMap;\n+    use super::Entry::{Occupied, Vacant};\n     use super::RandomState;\n     use cell::RefCell;\n     use rand::{thread_rng, Rng};\n@@ -3601,8 +3590,6 @@ mod test_map {\n \n     #[test]\n     fn test_empty_entry() {\n-        use super::Entry::{Occupied, Vacant};\n-\n         let mut m: HashMap<i32, bool> = HashMap::new();\n         match m.entry(0) {\n             Occupied(_) => panic!(),\n@@ -4061,8 +4048,6 @@ mod test_map {\n \n     #[test]\n     fn test_entry() {\n-        use super::Entry::{Occupied, Vacant};\n-\n         let xs = [(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (6, 60)];\n \n         let mut map: HashMap<_, _> = xs.iter().cloned().collect();\n@@ -4116,9 +4101,6 @@ mod test_map {\n     #[test]\n     fn test_entry_take_doesnt_corrupt() {\n         #![allow(deprecated)] //rand\n-\n-        use super::Entry::{Occupied, Vacant};\n-\n         // Test for #19292\n         fn check(m: &HashMap<i32, ()>) {\n             for k in m.keys() {\n@@ -4193,8 +4175,6 @@ mod test_map {\n \n     #[test]\n     fn test_occupied_entry_key() {\n-        use super::Entry::{Occupied, Vacant};\n-\n         let mut a = HashMap::new();\n         let key = \"hello there\";\n         let value = \"value goes here\";\n@@ -4213,8 +4193,6 @@ mod test_map {\n \n     #[test]\n     fn test_vacant_entry_key() {\n-        use super::Entry::{Occupied, Vacant};\n-\n         let mut a = HashMap::new();\n         let key = \"hello there\";\n         let value = \"value goes here\";\n@@ -4333,7 +4311,7 @@ mod test_map {\n         }).search_with(|k| *k == 3) {\n             Vacant(_) => unreachable!(),\n             Occupied(view) => {\n-                assert_eq!(view.remove_kv(), (3, 30));\n+                assert_eq!(view.remove_key_value(), (3, 30));\n             }\n         }\n         assert_eq!(map.raw_entry_immut().search_by(&3), None);"}, {"sha": "a3721942b9630dcbb4a6e7a9b8c16c2ebbde830d", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad6c7a9a3152245021778140fa57f8d1a8ad8fb6/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad6c7a9a3152245021778140fa57f8d1a8ad8fb6/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=ad6c7a9a3152245021778140fa57f8d1a8ad8fb6", "patch": "@@ -285,7 +285,6 @@\n #![feature(ptr_internals)]\n #![feature(raw)]\n #![feature(hash_raw_entry)]\n-#![feature(hash_raw_entry_immut)]\n #![feature(rustc_attrs)]\n #![feature(rustc_const_unstable)]\n #![feature(std_internals)]"}]}