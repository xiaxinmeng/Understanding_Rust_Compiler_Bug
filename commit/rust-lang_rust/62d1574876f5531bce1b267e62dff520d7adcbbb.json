{"sha": "62d1574876f5531bce1b267e62dff520d7adcbbb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyZDE1NzQ4NzZmNTUzMWJjZTFiMjY3ZTYyZGZmNTIwZDdhZGNiYmI=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-04-23T19:50:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-04-23T19:50:52Z"}, "message": "Rollup merge of #59823 - davidtwco:issue-54716, r=cramertj\n\n[wg-async-await] Drop `async fn` arguments in async block\n\nFixes #54716.\n\nThis PR modifies the HIR lowering (and some other places to make this work) so that unused arguments to a async function are always dropped inside the async move block and not at the end of the function body.\n\n```\nasync fn foo(<pattern>: <type>) {\n  async move {\n  }\n} // <-- dropped as you \"exit\" the fn\n\n// ...becomes...\nfn foo(__arg0: <ty>) {\n  async move {\n    let <pattern>: <ty> = __arg0;\n  } // <-- dropped as you \"exit\" the async block\n}\n```\n\nHowever, the exact ordering of drops is not the same as a regular function, [as visible in this playground example](https://play.rust-lang.org/?version=stable&mode=debug&edition=2015&gist=be39af1a58e5d430be1eb3c722cb1ec3) - I believe this to be an unrelated issue. There is a [Zulip topic](https://rust-lang.zulipchat.com/#narrow/stream/187312-t-compiler.2Fwg-async-await/topic/.2354716.20drop.20order) for this.\n\nr? @cramertj\ncc @nikomatsakis", "tree": {"sha": "df1cbb9f6f71a431a0d89164abcd9db6075a4955", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df1cbb9f6f71a431a0d89164abcd9db6075a4955"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62d1574876f5531bce1b267e62dff520d7adcbbb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcv2ycCRBK7hj4Ov3rIwAAdHIIAFhhkxF0P+RAPNRdWtXgl+tJ\nRkqHhBOoLYLXO5jgfgXstPawplZSt+mb9SFf0dQprwZeNKohC/YE2c1+AqfgHPKE\nZOo23Sdddmzj1S2YBwACCAlRyN63g9fMtyI2nocCpc7A4Ys1z22QWWYFIeORRKYw\neqyl9vQmCl6hhpaskzeHv83VnSqTAto1RJmpuHOk/iWnSzH7ikbLciqRektgNQpl\neCsztqR984cO58vnkcfnLgXkNpQx4VQOK/5FNz/I+urrpwfOHx4Ax/AkBNlWhdN5\nZvtdLpmhJiXYrZSC4G79XiOrPwTu7kRYiZro5ZJ4la0+QUIamyby0cIoQ/OnbSo=\n=u9Om\n-----END PGP SIGNATURE-----\n", "payload": "tree df1cbb9f6f71a431a0d89164abcd9db6075a4955\nparent 4eff8526a789e0dfa8b97f7dec91b7b5c18e8544\nparent 119e67ac6b7d72c2b314777ba36b2191cbfa7309\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1556049052 +0200\ncommitter GitHub <noreply@github.com> 1556049052 +0200\n\nRollup merge of #59823 - davidtwco:issue-54716, r=cramertj\n\n[wg-async-await] Drop `async fn` arguments in async block\n\nFixes #54716.\n\nThis PR modifies the HIR lowering (and some other places to make this work) so that unused arguments to a async function are always dropped inside the async move block and not at the end of the function body.\n\n```\nasync fn foo(<pattern>: <type>) {\n  async move {\n  }\n} // <-- dropped as you \"exit\" the fn\n\n// ...becomes...\nfn foo(__arg0: <ty>) {\n  async move {\n    let <pattern>: <ty> = __arg0;\n  } // <-- dropped as you \"exit\" the async block\n}\n```\n\nHowever, the exact ordering of drops is not the same as a regular function, [as visible in this playground example](https://play.rust-lang.org/?version=stable&mode=debug&edition=2015&gist=be39af1a58e5d430be1eb3c722cb1ec3) - I believe this to be an unrelated issue. There is a [Zulip topic](https://rust-lang.zulipchat.com/#narrow/stream/187312-t-compiler.2Fwg-async-await/topic/.2354716.20drop.20order) for this.\n\nr? @cramertj\ncc @nikomatsakis\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62d1574876f5531bce1b267e62dff520d7adcbbb", "html_url": "https://github.com/rust-lang/rust/commit/62d1574876f5531bce1b267e62dff520d7adcbbb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62d1574876f5531bce1b267e62dff520d7adcbbb/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4eff8526a789e0dfa8b97f7dec91b7b5c18e8544", "url": "https://api.github.com/repos/rust-lang/rust/commits/4eff8526a789e0dfa8b97f7dec91b7b5c18e8544", "html_url": "https://github.com/rust-lang/rust/commit/4eff8526a789e0dfa8b97f7dec91b7b5c18e8544"}, {"sha": "119e67ac6b7d72c2b314777ba36b2191cbfa7309", "url": "https://api.github.com/repos/rust-lang/rust/commits/119e67ac6b7d72c2b314777ba36b2191cbfa7309", "html_url": "https://github.com/rust-lang/rust/commit/119e67ac6b7d72c2b314777ba36b2191cbfa7309"}], "stats": {"total": 815, "additions": 685, "deletions": 130}, "files": [{"sha": "a0c9e5983a1d7dae5e25a0a35df0d3c37c181880", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=62d1574876f5531bce1b267e62dff520d7adcbbb", "patch": "@@ -58,10 +58,10 @@ impl<'a> FnKind<'a> {\n         }\n     }\n \n-    pub fn header(&self) -> Option<FnHeader> {\n+    pub fn header(&self) -> Option<&FnHeader> {\n         match *self {\n-            FnKind::ItemFn(_, _, header, _, _) => Some(header),\n-            FnKind::Method(_, sig, _, _) => Some(sig.header),\n+            FnKind::ItemFn(_, _, ref header, _, _) => Some(header),\n+            FnKind::Method(_, ref sig, _, _) => Some(&sig.header),\n             FnKind::Closure(_) => None,\n         }\n     }\n@@ -262,6 +262,9 @@ pub trait Visitor<'v> : Sized {\n     fn visit_pat(&mut self, p: &'v Pat) {\n         walk_pat(self, p)\n     }\n+    fn visit_argument_source(&mut self, s: &'v ArgSource) {\n+        walk_argument_source(self, s)\n+    }\n     fn visit_anon_const(&mut self, c: &'v AnonConst) {\n         walk_anon_const(self, c)\n     }\n@@ -399,10 +402,17 @@ pub fn walk_body<'v, V: Visitor<'v>>(visitor: &mut V, body: &'v Body) {\n     for argument in &body.arguments {\n         visitor.visit_id(argument.hir_id);\n         visitor.visit_pat(&argument.pat);\n+        visitor.visit_argument_source(&argument.source);\n     }\n     visitor.visit_expr(&body.value);\n }\n \n+pub fn walk_argument_source<'v, V: Visitor<'v>>(visitor: &mut V, source: &'v ArgSource) {\n+    if let ArgSource::AsyncFn(pat) = source {\n+        visitor.visit_pat(pat);\n+    }\n+}\n+\n pub fn walk_local<'v, V: Visitor<'v>>(visitor: &mut V, local: &'v Local) {\n     // Intentionally visiting the expr first - the initialization expr\n     // dominates the local's definition."}, {"sha": "380dee5fcdcc21403a51affab28b73d6369664b2", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 135, "deletions": 49, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=62d1574876f5531bce1b267e62dff520d7adcbbb", "patch": "@@ -448,10 +448,9 @@ impl<'a> LoweringContext<'a> {\n         impl<'lcx, 'interner> Visitor<'lcx> for MiscCollector<'lcx, 'interner> {\n             fn visit_pat(&mut self, p: &'lcx Pat) {\n                 match p.node {\n-                    // Doesn't generate a Hir node\n+                    // Doesn't generate a HIR node\n                     PatKind::Paren(..) => {},\n                     _ => {\n-\n                         if let Some(owner) = self.hir_id_owner {\n                             self.lctx.lower_node_id_with_owner(p.id, owner);\n                         }\n@@ -461,6 +460,32 @@ impl<'a> LoweringContext<'a> {\n                 visit::walk_pat(self, p)\n             }\n \n+            fn visit_fn(&mut self, fk: visit::FnKind<'lcx>, fd: &'lcx FnDecl, s: Span, _: NodeId) {\n+                if fk.header().map(|h| h.asyncness.node.is_async()).unwrap_or(false) {\n+                    // Don't visit the original pattern for async functions as it will be\n+                    // replaced.\n+                    for arg in &fd.inputs {\n+                        if let ArgSource::AsyncFn(pat) = &arg.source { self.visit_pat(pat); }\n+                        self.visit_ty(&arg.ty)\n+                    }\n+                    self.visit_fn_ret_ty(&fd.output);\n+\n+                    match fk {\n+                        visit::FnKind::ItemFn(_, decl, _, body) => {\n+                            self.visit_fn_header(decl);\n+                            self.visit_block(body)\n+                        },\n+                        visit::FnKind::Method(_, sig, _, body) => {\n+                            self.visit_fn_header(&sig.header);\n+                            self.visit_block(body)\n+                        },\n+                        visit::FnKind::Closure(body) => self.visit_expr(body),\n+                    }\n+                } else {\n+                    visit::walk_fn(self, fk, fd, s)\n+                }\n+            }\n+\n             fn visit_item(&mut self, item: &'lcx Item) {\n                 let hir_id = self.lctx.allocate_hir_id_counter(item.id).hir_id;\n \n@@ -784,12 +809,10 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn record_body(&mut self, value: hir::Expr, decl: Option<&FnDecl>) -> hir::BodyId {\n+    fn record_body(&mut self, value: hir::Expr, arguments: HirVec<hir::Arg>) -> hir::BodyId {\n         let body = hir::Body {\n-            arguments: decl.map_or(hir_vec![], |decl| {\n-                decl.inputs.iter().map(|x| self.lower_arg(x)).collect()\n-            }),\n             is_generator: self.is_generator,\n+            arguments,\n             value,\n         };\n         let id = body.id();\n@@ -1112,11 +1135,10 @@ impl<'a> LoweringContext<'a> {\n         capture_clause: CaptureBy,\n         closure_node_id: NodeId,\n         ret_ty: Option<&Ty>,\n+        span: Span,\n         body: impl FnOnce(&mut LoweringContext<'_>) -> hir::Expr,\n     ) -> hir::ExprKind {\n         let prev_is_generator = mem::replace(&mut self.is_generator, true);\n-        let body_expr = body(self);\n-        let span = body_expr.span;\n         let output = match ret_ty {\n             Some(ty) => FunctionRetTy::Ty(P(ty.clone())),\n             None => FunctionRetTy::Default(span),\n@@ -1126,7 +1148,11 @@ impl<'a> LoweringContext<'a> {\n             output,\n             c_variadic: false\n         };\n-        let body_id = self.record_body(body_expr, Some(&decl));\n+        // Lower the arguments before the body otherwise the body will call `lower_def` expecting\n+        // the argument to have been assigned an id already.\n+        let arguments = self.lower_args(Some(&decl));\n+        let body_expr = body(self);\n+        let body_id = self.record_body(body_expr, arguments);\n         self.is_generator = prev_is_generator;\n \n         let capture_clause = self.lower_capture_clause(capture_clause);\n@@ -1157,8 +1183,9 @@ impl<'a> LoweringContext<'a> {\n         F: FnOnce(&mut LoweringContext<'_>) -> hir::Expr,\n     {\n         let prev = mem::replace(&mut self.is_generator, false);\n+        let arguments = self.lower_args(decl);\n         let result = f(self);\n-        let r = self.record_body(result, decl);\n+        let r = self.record_body(result, arguments);\n         self.is_generator = prev;\n         return r;\n     }\n@@ -2224,22 +2251,41 @@ impl<'a> LoweringContext<'a> {\n             init: l.init.as_ref().map(|e| P(self.lower_expr(e))),\n             span: l.span,\n             attrs: l.attrs.clone(),\n-            source: hir::LocalSource::Normal,\n+            source: self.lower_local_source(l.source),\n         }, ids)\n     }\n \n+    fn lower_local_source(&mut self, ls: LocalSource) -> hir::LocalSource {\n+        match ls {\n+            LocalSource::Normal => hir::LocalSource::Normal,\n+            LocalSource::AsyncFn => hir::LocalSource::AsyncFn,\n+        }\n+    }\n+\n     fn lower_mutability(&mut self, m: Mutability) -> hir::Mutability {\n         match m {\n             Mutability::Mutable => hir::MutMutable,\n             Mutability::Immutable => hir::MutImmutable,\n         }\n     }\n \n+    fn lower_args(&mut self, decl: Option<&FnDecl>) -> HirVec<hir::Arg> {\n+        decl.map_or(hir_vec![], |decl| decl.inputs.iter().map(|x| self.lower_arg(x)).collect())\n+    }\n+\n     fn lower_arg(&mut self, arg: &Arg) -> hir::Arg {\n         let LoweredNodeId { node_id: _, hir_id } = self.lower_node_id(arg.id);\n         hir::Arg {\n             hir_id,\n             pat: self.lower_pat(&arg.pat),\n+            source: self.lower_arg_source(&arg.source),\n+        }\n+    }\n+\n+    fn lower_arg_source(&mut self, source: &ArgSource) -> hir::ArgSource {\n+        match source {\n+            ArgSource::Normal => hir::ArgSource::Normal,\n+            ArgSource::AsyncFn(pat) => hir::ArgSource::AsyncFn(self.lower_pat(pat)),\n         }\n     }\n \n@@ -2993,15 +3039,21 @@ impl<'a> LoweringContext<'a> {\n     fn lower_async_body(\n         &mut self,\n         decl: &FnDecl,\n-        asyncness: IsAsync,\n+        asyncness: &IsAsync,\n         body: &Block,\n     ) -> hir::BodyId {\n-        self.lower_body(Some(decl), |this| {\n-            if let IsAsync::Async { closure_id, .. } = asyncness {\n+        self.lower_body(Some(&decl), |this| {\n+            if let IsAsync::Async { closure_id, ref arguments, .. } = asyncness {\n+                let mut body = body.clone();\n+\n+                for a in arguments.iter().rev() {\n+                    body.stmts.insert(0, a.stmt.clone());\n+                }\n+\n                 let async_expr = this.make_async_expr(\n-                    CaptureBy::Value, closure_id, None,\n+                    CaptureBy::Value, *closure_id, None, body.span,\n                     |this| {\n-                        let body = this.lower_block(body, false);\n+                        let body = this.lower_block(&body, false);\n                         this.expr_block(body, ThinVec::new())\n                     });\n                 this.expr(body.span, async_expr, ThinVec::new())\n@@ -3060,26 +3112,42 @@ impl<'a> LoweringContext<'a> {\n                     value\n                 )\n             }\n-            ItemKind::Fn(ref decl, header, ref generics, ref body) => {\n+            ItemKind::Fn(ref decl, ref header, ref generics, ref body) => {\n                 let fn_def_id = self.resolver.definitions().local_def_id(id);\n                 self.with_new_scopes(|this| {\n-                    // Note: we don't need to change the return type from `T` to\n-                    // `impl Future<Output = T>` here because lower_body\n-                    // only cares about the input argument patterns in the function\n-                    // declaration (decl), not the return types.\n-                    let body_id = this.lower_async_body(decl, header.asyncness.node, body);\n+                    let mut lower_fn = |decl: &FnDecl| {\n+                        // Note: we don't need to change the return type from `T` to\n+                        // `impl Future<Output = T>` here because lower_body\n+                        // only cares about the input argument patterns in the function\n+                        // declaration (decl), not the return types.\n+                        let body_id = this.lower_async_body(&decl, &header.asyncness.node, body);\n+\n+                        let (generics, fn_decl) = this.add_in_band_defs(\n+                            generics,\n+                            fn_def_id,\n+                            AnonymousLifetimeMode::PassThrough,\n+                            |this, idty| this.lower_fn_decl(\n+                                &decl,\n+                                Some((fn_def_id, idty)),\n+                                true,\n+                                header.asyncness.node.opt_return_id()\n+                            ),\n+                        );\n \n-                    let (generics, fn_decl) = this.add_in_band_defs(\n-                        generics,\n-                        fn_def_id,\n-                        AnonymousLifetimeMode::PassThrough,\n-                        |this, idty| this.lower_fn_decl(\n-                            decl,\n-                            Some((fn_def_id, idty)),\n-                            true,\n-                            header.asyncness.node.opt_return_id()\n-                        ),\n-                    );\n+                        (body_id, generics, fn_decl)\n+                    };\n+\n+                    let (body_id, generics, fn_decl) = if let IsAsync::Async {\n+                        arguments, ..\n+                    } = &header.asyncness.node {\n+                        let mut decl = decl.clone();\n+                        // Replace the arguments of this async function with the generated\n+                        // arguments that will be moved into the closure.\n+                        decl.inputs = arguments.clone().drain(..).map(|a| a.arg).collect();\n+                        lower_fn(&decl)\n+                    } else {\n+                        lower_fn(decl)\n+                    };\n \n                     hir::ItemKind::Fn(\n                         fn_decl,\n@@ -3558,15 +3626,33 @@ impl<'a> LoweringContext<'a> {\n                 )\n             }\n             ImplItemKind::Method(ref sig, ref body) => {\n-                let body_id = self.lower_async_body(&sig.decl, sig.header.asyncness.node, body);\n-                let impl_trait_return_allow = !self.is_in_trait_impl;\n-                let (generics, sig) = self.lower_method_sig(\n-                    &i.generics,\n-                    sig,\n-                    impl_item_def_id,\n-                    impl_trait_return_allow,\n-                    sig.header.asyncness.node.opt_return_id(),\n-                );\n+                let mut lower_method = |sig: &MethodSig| {\n+                    let body_id = self.lower_async_body(\n+                        &sig.decl, &sig.header.asyncness.node, body\n+                    );\n+                    let impl_trait_return_allow = !self.is_in_trait_impl;\n+                    let (generics, sig) = self.lower_method_sig(\n+                        &i.generics,\n+                        sig,\n+                        impl_item_def_id,\n+                        impl_trait_return_allow,\n+                        sig.header.asyncness.node.opt_return_id(),\n+                    );\n+                    (body_id, generics, sig)\n+                };\n+\n+                let (body_id, generics, sig) = if let IsAsync::Async {\n+                    ref arguments, ..\n+                } = sig.header.asyncness.node {\n+                    let mut sig = sig.clone();\n+                    // Replace the arguments of this async function with the generated\n+                    // arguments that will be moved into the closure.\n+                    sig.decl.inputs = arguments.clone().drain(..).map(|a| a.arg).collect();\n+                    lower_method(&sig)\n+                } else {\n+                    lower_method(sig)\n+                };\n+\n                 (generics, hir::ImplItemKind::Method(sig, body_id))\n             }\n             ImplItemKind::Type(ref ty) => (\n@@ -3760,7 +3846,7 @@ impl<'a> LoweringContext<'a> {\n         impl_trait_return_allow: bool,\n         is_async: Option<NodeId>,\n     ) -> (hir::Generics, hir::MethodSig) {\n-        let header = self.lower_fn_header(sig.header);\n+        let header = self.lower_fn_header(&sig.header);\n         let (generics, decl) = self.add_in_band_defs(\n             generics,\n             fn_def_id,\n@@ -3782,10 +3868,10 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_fn_header(&mut self, h: FnHeader) -> hir::FnHeader {\n+    fn lower_fn_header(&mut self, h: &FnHeader) -> hir::FnHeader {\n         hir::FnHeader {\n             unsafety: self.lower_unsafety(h.unsafety),\n-            asyncness: self.lower_asyncness(h.asyncness.node),\n+            asyncness: self.lower_asyncness(&h.asyncness.node),\n             constness: self.lower_constness(h.constness),\n             abi: h.abi,\n         }\n@@ -3805,7 +3891,7 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_asyncness(&mut self, a: IsAsync) -> hir::IsAsync {\n+    fn lower_asyncness(&mut self, a: &IsAsync) -> hir::IsAsync {\n         match a {\n             IsAsync::Async { .. } => hir::IsAsync::Async,\n             IsAsync::NotAsync => hir::IsAsync::NotAsync,\n@@ -4110,15 +4196,15 @@ impl<'a> LoweringContext<'a> {\n                 hir::MatchSource::Normal,\n             ),\n             ExprKind::Async(capture_clause, closure_node_id, ref block) => {\n-                self.make_async_expr(capture_clause, closure_node_id, None, |this| {\n+                self.make_async_expr(capture_clause, closure_node_id, None, block.span, |this| {\n                     this.with_new_scopes(|this| {\n                         let block = this.lower_block(block, false);\n                         this.expr_block(block, ThinVec::new())\n                     })\n                 })\n             }\n             ExprKind::Closure(\n-                capture_clause, asyncness, movability, ref decl, ref body, fn_decl_span\n+                capture_clause, ref asyncness, movability, ref decl, ref body, fn_decl_span\n             ) => {\n                 if let IsAsync::Async { closure_id, .. } = asyncness {\n                     let outer_decl = FnDecl {\n@@ -4156,7 +4242,7 @@ impl<'a> LoweringContext<'a> {\n                                 Some(&**ty)\n                             } else { None };\n                             let async_body = this.make_async_expr(\n-                                capture_clause, closure_id, async_ret_ty,\n+                                capture_clause, *closure_id, async_ret_ty, body.span,\n                                 |this| {\n                                     this.with_new_scopes(|this| this.lower_expr(body))\n                                 });"}, {"sha": "0fa973853221580c01cb68e747b336a3c44f1d14", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 27, "deletions": 12, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=62d1574876f5531bce1b267e62dff520d7adcbbb", "patch": "@@ -68,16 +68,17 @@ impl<'a> DefCollector<'a> {\n         id: NodeId,\n         name: Name,\n         span: Span,\n-        header: &FnHeader,\n+        header: &'a FnHeader,\n         generics: &'a Generics,\n         decl: &'a FnDecl,\n         body: &'a Block,\n     ) {\n-        let (closure_id, return_impl_trait_id) = match header.asyncness.node {\n+        let (closure_id, return_impl_trait_id, arguments) = match &header.asyncness.node {\n             IsAsync::Async {\n                 closure_id,\n                 return_impl_trait_id,\n-            } => (closure_id, return_impl_trait_id),\n+                arguments,\n+            } => (closure_id, return_impl_trait_id, arguments),\n             _ => unreachable!(),\n         };\n \n@@ -86,17 +87,31 @@ impl<'a> DefCollector<'a> {\n         let fn_def_data = DefPathData::ValueNs(name.as_interned_str());\n         let fn_def = self.create_def(id, fn_def_data, ITEM_LIKE_SPACE, span);\n         return self.with_parent(fn_def, |this| {\n-            this.create_def(return_impl_trait_id, DefPathData::ImplTrait, REGULAR_SPACE, span);\n+            this.create_def(*return_impl_trait_id, DefPathData::ImplTrait, REGULAR_SPACE, span);\n \n             visit::walk_generics(this, generics);\n-            visit::walk_fn_decl(this, decl);\n \n-            let closure_def = this.create_def(closure_id,\n-                                              DefPathData::ClosureExpr,\n-                                              REGULAR_SPACE,\n-                                              span);\n+            // Walk the generated arguments for the `async fn`.\n+            for a in arguments {\n+                use visit::Visitor;\n+                this.visit_ty(&a.arg.ty);\n+            }\n+\n+            // We do not invoke `walk_fn_decl` as this will walk the arguments that are being\n+            // replaced.\n+            visit::walk_fn_ret_ty(this, &decl.output);\n+\n+            let closure_def = this.create_def(\n+                *closure_id, DefPathData::ClosureExpr, REGULAR_SPACE, span,\n+            );\n             this.with_parent(closure_def, |this| {\n-                visit::walk_block(this, body);\n+                for a in arguments {\n+                    use visit::Visitor;\n+                    // Walk each of the generated statements before the regular block body.\n+                    this.visit_stmt(&a.stmt);\n+                }\n+\n+                visit::walk_block(this, &body);\n             })\n         })\n     }\n@@ -290,7 +305,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n         match expr.node {\n             ExprKind::Mac(..) => return self.visit_macro_invoc(expr.id),\n-            ExprKind::Closure(_, asyncness, ..) => {\n+            ExprKind::Closure(_, ref asyncness, ..) => {\n                 let closure_def = self.create_def(expr.id,\n                                           DefPathData::ClosureExpr,\n                                           REGULAR_SPACE,\n@@ -300,7 +315,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                 // Async closures desugar to closures inside of closures, so\n                 // we must create two defs.\n                 if let IsAsync::Async { closure_id, .. } = asyncness {\n-                    let async_def = self.create_def(closure_id,\n+                    let async_def = self.create_def(*closure_id,\n                                                     DefPathData::ClosureExpr,\n                                                     REGULAR_SPACE,\n                                                     expr.span);"}, {"sha": "f114f0fc236958ef6c9ebd1ae49753eb256a0877", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=62d1574876f5531bce1b267e62dff520d7adcbbb", "patch": "@@ -1583,6 +1583,17 @@ pub enum LocalSource {\n     Normal,\n     /// A desugared `for _ in _ { .. }` loop.\n     ForLoopDesugar,\n+    /// When lowering async functions, we create locals within the `async move` so that\n+    /// all arguments are dropped after the future is polled.\n+    ///\n+    /// ```ignore (pseudo-Rust)\n+    /// async fn foo(<pattern> @ x: Type) {\n+    ///     async move {\n+    ///         let <pattern> = x;\n+    ///     }\n+    /// }\n+    /// ```\n+    AsyncFn,\n }\n \n /// Hints at the original code for a `match _ { .. }`.\n@@ -1883,6 +1894,26 @@ pub struct InlineAsm {\n pub struct Arg {\n     pub pat: P<Pat>,\n     pub hir_id: HirId,\n+    pub source: ArgSource,\n+}\n+\n+impl Arg {\n+    /// Returns the pattern representing the original binding for this argument.\n+    pub fn original_pat(&self) -> &P<Pat> {\n+        match &self.source {\n+            ArgSource::Normal => &self.pat,\n+            ArgSource::AsyncFn(pat) => &pat,\n+        }\n+    }\n+}\n+\n+/// Represents the source of an argument in a function header.\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n+pub enum ArgSource {\n+    /// Argument as specified by the user.\n+    Normal,\n+    /// Generated argument from `async fn` lowering, contains the original binding pattern.\n+    AsyncFn(P<Pat>),\n }\n \n /// Represents the header (not the body) of a function declaration."}, {"sha": "944cc8a8b1999b0112ca47b95ea4ede49cb825fc", "filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=62d1574876f5531bce1b267e62dff520d7adcbbb", "patch": "@@ -86,19 +86,16 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n         let sub_is_ret_type =\n             self.is_return_type_anon(scope_def_id_sub, bregion_sub, ty_fndecl_sub);\n \n-        let span_label_var1 = if let Some(simple_ident) = anon_arg_sup.pat.simple_ident() {\n-            format!(\" from `{}`\", simple_ident)\n-        } else {\n-            String::new()\n+        let span_label_var1 = match anon_arg_sup.original_pat().simple_ident() {\n+            Some(simple_ident) => format!(\" from `{}`\", simple_ident),\n+            None => String::new(),\n         };\n \n-        let span_label_var2 = if let Some(simple_ident) = anon_arg_sub.pat.simple_ident() {\n-            format!(\" into `{}`\", simple_ident)\n-        } else {\n-            String::new()\n+        let span_label_var2 = match anon_arg_sub.original_pat().simple_ident() {\n+            Some(simple_ident) => format!(\" into `{}`\", simple_ident),\n+            None => String::new(),\n         };\n \n-\n         let (span_1, span_2, main_label, span_label) = match (sup_is_ret_type, sub_is_ret_type) {\n             (None, None) => {\n                 let (main_label_1, span_label_1) = if ty_sup.hir_id == ty_sub.hir_id {"}, {"sha": "2d7587b11b6f8e51ea905ddc5c3f0cedfcf9fd2d", "filename": "src/librustc/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=62d1574876f5531bce1b267e62dff520d7adcbbb", "patch": "@@ -95,13 +95,12 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        let (error_var, span_label_var) = if let Some(simple_ident) = arg.pat.simple_ident() {\n-            (\n+        let (error_var, span_label_var) = match arg.original_pat().simple_ident() {\n+            Some(simple_ident) => (\n                 format!(\"the type of `{}`\", simple_ident),\n                 format!(\"the type of `{}`\", simple_ident),\n-            )\n-        } else {\n-            (\"parameter type\".to_owned(), \"type\".to_owned())\n+            ),\n+            None => (\"parameter type\".to_owned(), \"type\".to_owned()),\n         };\n \n         let mut diag = struct_span_err!("}, {"sha": "f5cb4cfa29f5cd84596de5a94ef2c28957307e10", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=62d1574876f5531bce1b267e62dff520d7adcbbb", "patch": "@@ -1326,6 +1326,25 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n \n         run_early_pass!(self, check_mac, mac);\n     }\n+\n+    fn visit_fn_header(&mut self, header: &'a ast::FnHeader) {\n+        // Unlike in HIR lowering and name resolution, the `AsyncArgument` statements are not added\n+        // to the function body and the arguments do not replace those in the declaration. They are\n+        // still visited manually here so that buffered lints can be emitted.\n+        if let ast::IsAsync::Async { ref arguments, .. } = header.asyncness.node {\n+            for a in arguments {\n+                // Visit the argument..\n+                self.visit_pat(&a.arg.pat);\n+                if let ast::ArgSource::AsyncFn(pat) = &a.arg.source {\n+                    self.visit_pat(pat);\n+                }\n+                self.visit_ty(&a.arg.ty);\n+\n+                // ..and the statement.\n+                self.visit_stmt(&a.stmt);\n+            }\n+        }\n+    }\n }\n \n struct LateLintPassObjects<'a> {"}, {"sha": "814776c21bd2afd9edda1e8aa07b4da005070fbd", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=62d1574876f5531bce1b267e62dff520d7adcbbb", "patch": "@@ -2421,7 +2421,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             let help_name = if let Some(body) = parent {\n                 let arg = &self.tcx.hir().body(body).arguments[index];\n-                format!(\"`{}`\", self.tcx.hir().hir_to_pretty_string(arg.pat.hir_id))\n+                format!(\"`{}`\", self.tcx.hir().hir_to_pretty_string(arg.original_pat().hir_id))\n             } else {\n                 format!(\"argument {}\", index + 1)\n             };"}, {"sha": "2d7f8b1a1aec9459f8b747bf05e0f101e445e523", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=62d1574876f5531bce1b267e62dff520d7adcbbb", "patch": "@@ -76,6 +76,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MatchVisitor<'a, 'tcx> {\n         self.check_irrefutable(&loc.pat, match loc.source {\n             hir::LocalSource::Normal => \"local binding\",\n             hir::LocalSource::ForLoopDesugar => \"`for` loop binding\",\n+            hir::LocalSource::AsyncFn => \"async fn binding\",\n         });\n \n         // Check legality of move bindings and `@` patterns."}, {"sha": "9dd8a7050fd289374b0bac8685ceaf521f808063", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=62d1574876f5531bce1b267e62dff520d7adcbbb", "patch": "@@ -222,7 +222,7 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n-    fn check_trait_fn_not_async(&self, span: Span, asyncness: IsAsync) {\n+    fn check_trait_fn_not_async(&self, span: Span, asyncness: &IsAsync) {\n         if asyncness.is_async() {\n             struct_span_err!(self.session, span, E0706,\n                              \"trait fns cannot be declared `async`\").emit()\n@@ -570,7 +570,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                     self.invalid_visibility(&impl_item.vis, None);\n                     if let ImplItemKind::Method(ref sig, _) = impl_item.node {\n                         self.check_trait_fn_not_const(sig.header.constness);\n-                        self.check_trait_fn_not_async(impl_item.span, sig.header.asyncness.node);\n+                        self.check_trait_fn_not_async(impl_item.span, &sig.header.asyncness.node);\n                     }\n                 }\n             }\n@@ -642,7 +642,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n                 self.no_questions_in_bounds(bounds, \"supertraits\", true);\n                 for trait_item in trait_items {\n                     if let TraitItemKind::Method(ref sig, ref block) = trait_item.node {\n-                        self.check_trait_fn_not_async(trait_item.span, sig.header.asyncness.node);\n+                        self.check_trait_fn_not_async(trait_item.span, &sig.header.asyncness.node);\n                         self.check_trait_fn_not_const(sig.header.constness);\n                         if block.is_none() {\n                             self.check_decl_no_pat(&sig.decl, |span, mut_ident| {"}, {"sha": "57e17eb6878e1a08544147686131dc7d753a1ce5", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=62d1574876f5531bce1b267e62dff520d7adcbbb", "patch": "@@ -948,6 +948,16 @@ impl<'a, 'tcx> Visitor<'tcx> for NamePrivacyVisitor<'a, 'tcx> {\n \n         intravisit::walk_pat(self, pat);\n     }\n+\n+    fn visit_argument_source(&mut self, s: &'tcx hir::ArgSource) {\n+        match s {\n+            // Don't visit the pattern in `ArgSource::AsyncFn`, it contains a pattern which has\n+            // a `NodeId` w/out a type, as it is only used for getting the name of the original\n+            // pattern for diagnostics where only an `hir::Arg` is present.\n+            hir::ArgSource::AsyncFn(..) => {},\n+            _ => intravisit::walk_argument_source(self, s),\n+        }\n+    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////////////////\n@@ -1133,6 +1143,16 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n         intravisit::walk_pat(self, pattern);\n     }\n \n+    fn visit_argument_source(&mut self, s: &'tcx hir::ArgSource) {\n+        match s {\n+            // Don't visit the pattern in `ArgSource::AsyncFn`, it contains a pattern which has\n+            // a `NodeId` w/out a type, as it is only used for getting the name of the original\n+            // pattern for diagnostics where only an `hir::Arg` is present.\n+            hir::ArgSource::AsyncFn(..) => {},\n+            _ => intravisit::walk_argument_source(self, s),\n+        }\n+    }\n+\n     fn visit_local(&mut self, local: &'tcx hir::Local) {\n         if let Some(ref init) = local.init {\n             if self.check_expr_pat_type(init.hir_id, init.span) {"}, {"sha": "2ef05f7efeb7303e8c36c87e3d4380730b106676", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 26, "deletions": 10, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=62d1574876f5531bce1b267e62dff520d7adcbbb", "patch": "@@ -817,13 +817,13 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n         debug!(\"(resolving function) entering function\");\n         let (rib_kind, asyncness) = match function_kind {\n             FnKind::ItemFn(_, ref header, ..) =>\n-                (FnItemRibKind, header.asyncness.node),\n+                (FnItemRibKind, &header.asyncness.node),\n             FnKind::Method(_, ref sig, _, _) =>\n-                (TraitOrImplItemRibKind, sig.header.asyncness.node),\n+                (TraitOrImplItemRibKind, &sig.header.asyncness.node),\n             FnKind::Closure(_) =>\n                 // Async closures aren't resolved through `visit_fn`-- they're\n                 // processed separately\n-                (ClosureRibKind(node_id), IsAsync::NotAsync),\n+                (ClosureRibKind(node_id), &IsAsync::NotAsync),\n         };\n \n         // Create a value rib for the function.\n@@ -834,26 +834,42 @@ impl<'a, 'tcx> Visitor<'tcx> for Resolver<'a> {\n \n         // Add each argument to the rib.\n         let mut bindings_list = FxHashMap::default();\n-        for argument in &declaration.inputs {\n+        let mut add_argument = |argument: &ast::Arg| {\n             self.resolve_pattern(&argument.pat, PatternSource::FnParam, &mut bindings_list);\n-\n             self.visit_ty(&argument.ty);\n-\n             debug!(\"(resolving function) recorded argument\");\n+        };\n+\n+        // Walk the generated async arguments if this is an `async fn`, otherwise walk the\n+        // normal arguments.\n+        if let IsAsync::Async { ref arguments, .. } = asyncness {\n+            for a in arguments { add_argument(&a.arg); }\n+        } else {\n+            for a in &declaration.inputs { add_argument(a); }\n         }\n+\n         visit::walk_fn_ret_ty(self, &declaration.output);\n \n         // Resolve the function body, potentially inside the body of an async closure\n         if let IsAsync::Async { closure_id, .. } = asyncness {\n-            let rib_kind = ClosureRibKind(closure_id);\n+            let rib_kind = ClosureRibKind(*closure_id);\n             self.ribs[ValueNS].push(Rib::new(rib_kind));\n             self.label_ribs.push(Rib::new(rib_kind));\n         }\n \n         match function_kind {\n-            FnKind::ItemFn(.., body) |\n-            FnKind::Method(.., body) => {\n-                self.visit_block(body);\n+            FnKind::ItemFn(.., body) | FnKind::Method(.., body) => {\n+                if let IsAsync::Async { ref arguments, .. } = asyncness {\n+                    let mut body = body.clone();\n+                    // Insert the generated statements into the body before attempting to\n+                    // resolve names.\n+                    for a in arguments {\n+                        body.stmts.insert(0, a.stmt.clone());\n+                    }\n+                    self.visit_block(&body);\n+                } else {\n+                    self.visit_block(body);\n+                }\n             }\n             FnKind::Closure(body) => {\n                 self.visit_expr(body);"}, {"sha": "5ac75d012752333c9284796841875a9c0a21c85f", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=62d1574876f5531bce1b267e62dff520d7adcbbb", "patch": "@@ -374,7 +374,7 @@ impl Sig for ast::Item {\n \n                 Ok(extend_sig(ty, text, defs, vec![]))\n             }\n-            ast::ItemKind::Fn(ref decl, header, ref generics, _) => {\n+            ast::ItemKind::Fn(ref decl, ref header, ref generics, _) => {\n                 let mut text = String::new();\n                 if header.constness.node == ast::Constness::Const {\n                     text.push_str(\"const \");"}, {"sha": "79477b6fea87dbe6ce72b7641802a8bffdf6e447", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=62d1574876f5531bce1b267e62dff520d7adcbbb", "patch": "@@ -1005,6 +1005,16 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n     // Don't descend into the bodies of nested closures\n     fn visit_fn(&mut self, _: intravisit::FnKind<'gcx>, _: &'gcx hir::FnDecl,\n                 _: hir::BodyId, _: Span, _: hir::HirId) { }\n+\n+    fn visit_argument_source(&mut self, s: &'gcx hir::ArgSource) {\n+        match s {\n+            // Don't visit the pattern in `ArgSource::AsyncFn`, it contains a pattern which has\n+            // a `NodeId` w/out a type, as it is only used for getting the name of the original\n+            // pattern for diagnostics where only an `hir::Arg` is present.\n+            hir::ArgSource::AsyncFn(..) => {},\n+            _ => intravisit::walk_argument_source(self, s),\n+        }\n+    }\n }\n \n /// When `check_fn` is invoked on a generator (i.e., a body that"}, {"sha": "efff08f66969023dec04864237e20303c7fec56f", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=62d1574876f5531bce1b267e62dff520d7adcbbb", "patch": "@@ -297,6 +297,16 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n         let ty = self.resolve(&ty, &hir_ty.span);\n         self.write_ty_to_tables(hir_ty.hir_id, ty);\n     }\n+\n+    fn visit_argument_source(&mut self, s: &'gcx hir::ArgSource) {\n+        match s {\n+            // Don't visit the pattern in `ArgSource::AsyncFn`, it contains a pattern which has\n+            // a `NodeId` w/out a type, as it is only used for getting the name of the original\n+            // pattern for diagnostics where only an `hir::Arg` is present.\n+            hir::ArgSource::AsyncFn(..) => {},\n+            _ => intravisit::walk_argument_source(self, s),\n+        }\n+    }\n }\n \n impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {"}, {"sha": "4ff16e4a26760cb7244215a65bf198cd0bf1573a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=62d1574876f5531bce1b267e62dff520d7adcbbb", "patch": "@@ -2017,7 +2017,7 @@ impl<'a> Clean<Arguments> for (&'a [hir::Ty], hir::BodyId) {\n         Arguments {\n             values: self.0.iter().enumerate().map(|(i, ty)| {\n                 Argument {\n-                    name: name_from_pat(&body.arguments[i].pat),\n+                    name: name_from_pat(&body.arguments[i].original_pat()),\n                     type_: ty.clean(cx),\n                 }\n             }).collect()"}, {"sha": "334fcfd74f357eb44fe24b4cf1c8bc7dfe8b66d3", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 45, "deletions": 6, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=62d1574876f5531bce1b267e62dff520d7adcbbb", "patch": "@@ -888,6 +888,17 @@ pub struct Local {\n     pub id: NodeId,\n     pub span: Span,\n     pub attrs: ThinVec<Attribute>,\n+    /// Origin of this local variable.\n+    pub source: LocalSource,\n+}\n+\n+#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+pub enum LocalSource {\n+    /// Local was parsed from source.\n+    Normal,\n+    /// Within `ast::IsAsync::Async`, a local is generated that will contain the moved arguments\n+    /// of an `async fn`.\n+    AsyncFn,\n }\n \n /// An arm of a 'match'.\n@@ -1725,6 +1736,16 @@ pub struct Arg {\n     pub ty: P<Ty>,\n     pub pat: P<Pat>,\n     pub id: NodeId,\n+    pub source: ArgSource,\n+}\n+\n+/// The source of an argument in a function header.\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+pub enum ArgSource {\n+    /// Argument as written by the user.\n+    Normal,\n+    /// Argument from `async fn` lowering, contains the original binding pattern.\n+    AsyncFn(P<Pat>),\n }\n \n /// Alternative representation for `Arg`s describing `self` parameter of methods.\n@@ -1784,6 +1805,7 @@ impl Arg {\n             }),\n             ty,\n             id: DUMMY_NODE_ID,\n+            source: ArgSource::Normal,\n         };\n         match eself.node {\n             SelfKind::Explicit(ty, mutbl) => arg(mutbl, ty),\n@@ -1838,31 +1860,48 @@ pub enum Unsafety {\n     Normal,\n }\n \n-#[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+pub struct AsyncArgument {\n+    /// `__arg0`\n+    pub ident: Ident,\n+    /// `__arg0: <ty>` argument to replace existing function argument `<pat>: <ty>`.\n+    pub arg: Arg,\n+    /// `let <pat>: <ty> = __arg0;` statement to be inserted at the start of the block.\n+    pub stmt: Stmt,\n+}\n+\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum IsAsync {\n     Async {\n         closure_id: NodeId,\n         return_impl_trait_id: NodeId,\n+        /// This field stores the arguments and statements that are used in HIR lowering to\n+        /// ensure that `async fn` arguments are dropped at the correct time.\n+        ///\n+        /// The argument and statements here are generated at parse time as they are required in\n+        /// both the hir lowering, def collection and name resolution and this stops them needing\n+        /// to be created in each place.\n+        arguments: Vec<AsyncArgument>,\n     },\n     NotAsync,\n }\n \n impl IsAsync {\n-    pub fn is_async(self) -> bool {\n-        if let IsAsync::Async { .. } = self {\n+    pub fn is_async(&self) -> bool {\n+        if let IsAsync::Async { .. } = *self {\n             true\n         } else {\n             false\n         }\n     }\n \n     /// In ths case this is an `async` return, the `NodeId` for the generated `impl Trait` item.\n-    pub fn opt_return_id(self) -> Option<NodeId> {\n+    pub fn opt_return_id(&self) -> Option<NodeId> {\n         match self {\n             IsAsync::Async {\n                 return_impl_trait_id,\n                 ..\n-            } => Some(return_impl_trait_id),\n+            } => Some(*return_impl_trait_id),\n             IsAsync::NotAsync => None,\n         }\n     }\n@@ -2202,7 +2241,7 @@ impl Item {\n ///\n /// All the information between the visibility and the name of the function is\n /// included in this struct (e.g., `async unsafe fn` or `const extern \"C\" fn`).\n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct FnHeader {\n     pub unsafety: Unsafety,\n     pub asyncness: Spanned<IsAsync>,"}, {"sha": "40dd187ed28a7e5560ee7eeb26e0a226dc16bfd9", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=62d1574876f5531bce1b267e62dff520d7adcbbb", "patch": "@@ -526,6 +526,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             id: ast::DUMMY_NODE_ID,\n             span: sp,\n             attrs: ThinVec::new(),\n+            source: ast::LocalSource::Normal,\n         });\n         ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n@@ -554,6 +555,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             id: ast::DUMMY_NODE_ID,\n             span: sp,\n             attrs: ThinVec::new(),\n+            source: ast::LocalSource::Normal,\n         });\n         ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n@@ -571,6 +573,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             id: ast::DUMMY_NODE_ID,\n             span,\n             attrs: ThinVec::new(),\n+            source: ast::LocalSource::Normal,\n         });\n         ast::Stmt {\n             id: ast::DUMMY_NODE_ID,\n@@ -976,7 +979,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         ast::Arg {\n             ty,\n             pat: arg_pat,\n-            id: ast::DUMMY_NODE_ID\n+            id: ast::DUMMY_NODE_ID,\n+            source: ast::ArgSource::Normal,\n         }\n     }\n "}, {"sha": "68cd3c28676f9cec9e9f5a6b5de9e9f327ff7ba6", "filename": "src/libsyntax/ext/placeholders.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=62d1574876f5531bce1b267e62dff520d7adcbbb", "patch": "@@ -102,6 +102,13 @@ impl<'a, 'b> PlaceholderExpander<'a, 'b> {\n     fn remove(&mut self, id: ast::NodeId) -> AstFragment {\n         self.expanded_fragments.remove(&id).unwrap()\n     }\n+\n+    fn next_id(&mut self, id: &mut ast::NodeId) {\n+        if self.monotonic {\n+            assert_eq!(*id, ast::DUMMY_NODE_ID);\n+            *id = self.cx.resolver.next_node_id()\n+        }\n+    }\n }\n \n impl<'a, 'b> MutVisitor for PlaceholderExpander<'a, 'b> {\n@@ -183,9 +190,16 @@ impl<'a, 'b> MutVisitor for PlaceholderExpander<'a, 'b> {\n         noop_visit_block(block, self);\n \n         for stmt in block.stmts.iter_mut() {\n-            if self.monotonic {\n-                assert_eq!(stmt.id, ast::DUMMY_NODE_ID);\n-                stmt.id = self.cx.resolver.next_node_id();\n+            self.next_id(&mut stmt.id);\n+        }\n+    }\n+\n+    fn visit_asyncness(&mut self, a: &mut ast::IsAsync) {\n+        noop_visit_asyncness(a, self);\n+\n+        if let ast::IsAsync::Async { ref mut arguments, .. } = a {\n+            for argument in arguments.iter_mut() {\n+                self.next_id(&mut argument.stmt.id);\n             }\n         }\n     }"}, {"sha": "d3441a2039b175e7ab1bf488d58b567fa2e58e16", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=62d1574876f5531bce1b267e62dff520d7adcbbb", "patch": "@@ -208,6 +208,10 @@ pub trait MutVisitor: Sized {\n         noop_visit_local(l, self);\n     }\n \n+    fn visit_local_source(&mut self, l: &mut LocalSource) {\n+        noop_visit_local_source(l, self);\n+    }\n+\n     fn visit_mac(&mut self, _mac: &mut Mac) {\n         panic!(\"visit_mac disabled by default\");\n         // N.B., see note about macros above. If you really want a visitor that\n@@ -231,6 +235,10 @@ pub trait MutVisitor: Sized {\n         noop_visit_arg(a, self);\n     }\n \n+    fn visit_arg_source(&mut self, a: &mut ArgSource) {\n+        noop_visit_arg_source(a, self);\n+    }\n+\n     fn visit_generics(&mut self, generics: &mut Generics) {\n         noop_visit_generics(generics, self);\n     }\n@@ -511,13 +519,17 @@ pub fn noop_visit_parenthesized_parameter_data<T: MutVisitor>(args: &mut Parenth\n }\n \n pub fn noop_visit_local<T: MutVisitor>(local: &mut P<Local>, vis: &mut T) {\n-    let Local { id, pat, ty, init, span, attrs } = local.deref_mut();\n+    let Local { id, pat, ty, init, span, attrs, source } = local.deref_mut();\n     vis.visit_id(id);\n     vis.visit_pat(pat);\n     visit_opt(ty, |ty| vis.visit_ty(ty));\n     visit_opt(init, |init| vis.visit_expr(init));\n     vis.visit_span(span);\n     visit_thin_attrs(attrs, vis);\n+    vis.visit_local_source(source);\n+}\n+\n+pub fn noop_visit_local_source<T: MutVisitor>(_local_source: &mut LocalSource, _vis: &mut T) {\n }\n \n pub fn noop_visit_attribute<T: MutVisitor>(attr: &mut Attribute, vis: &mut T) {\n@@ -556,10 +568,18 @@ pub fn noop_visit_meta_item<T: MutVisitor>(mi: &mut MetaItem, vis: &mut T) {\n     vis.visit_span(span);\n }\n \n-pub fn noop_visit_arg<T: MutVisitor>(Arg { id, pat, ty }: &mut Arg, vis: &mut T) {\n+pub fn noop_visit_arg<T: MutVisitor>(Arg { id, pat, ty, source }: &mut Arg, vis: &mut T) {\n     vis.visit_id(id);\n     vis.visit_pat(pat);\n     vis.visit_ty(ty);\n+    vis.visit_arg_source(source);\n+}\n+\n+pub fn noop_visit_arg_source<T: MutVisitor>(source: &mut ArgSource, vis: &mut T) {\n+    match source {\n+        ArgSource::Normal => {},\n+        ArgSource::AsyncFn(pat) => vis.visit_pat(pat),\n+    }\n }\n \n pub fn noop_visit_tt<T: MutVisitor>(tt: &mut TokenTree, vis: &mut T) {\n@@ -671,9 +691,17 @@ pub fn noop_visit_interpolated<T: MutVisitor>(nt: &mut token::Nonterminal, vis:\n \n pub fn noop_visit_asyncness<T: MutVisitor>(asyncness: &mut IsAsync, vis: &mut T) {\n     match asyncness {\n-        IsAsync::Async { closure_id, return_impl_trait_id } => {\n+        IsAsync::Async { closure_id, return_impl_trait_id, ref mut arguments } => {\n             vis.visit_id(closure_id);\n             vis.visit_id(return_impl_trait_id);\n+            for AsyncArgument { ident, arg, stmt } in arguments.iter_mut() {\n+                vis.visit_ident(ident);\n+                vis.visit_arg(arg);\n+                visit_clobber(stmt, |stmt| {\n+                    vis.flat_map_stmt(stmt)\n+                        .expect_one(\"expected visitor to produce exactly one item\")\n+                });\n+            }\n         }\n         IsAsync::NotAsync => {}\n     }"}, {"sha": "53dab510ac39fc95e1b6863a67d422bbc9e07a38", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 78, "deletions": 9, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=62d1574876f5531bce1b267e62dff520d7adcbbb", "patch": "@@ -1,7 +1,7 @@\n-use crate::ast::{AngleBracketedArgs, ParenthesizedArgs, AttrStyle, BareFnTy};\n+use crate::ast::{AngleBracketedArgs, AsyncArgument, ParenthesizedArgs, AttrStyle, BareFnTy};\n use crate::ast::{GenericBound, TraitBoundModifier};\n use crate::ast::Unsafety;\n-use crate::ast::{Mod, AnonConst, Arg, Arm, Guard, Attribute, BindingMode, TraitItemKind};\n+use crate::ast::{Mod, AnonConst, Arg, ArgSource, Arm, Guard, Attribute, BindingMode, TraitItemKind};\n use crate::ast::Block;\n use crate::ast::{BlockCheckMode, CaptureBy, Movability};\n use crate::ast::{Constness, Crate};\n@@ -14,7 +14,7 @@ use crate::ast::{GenericParam, GenericParamKind};\n use crate::ast::GenericArg;\n use crate::ast::{Ident, ImplItem, IsAsync, IsAuto, Item, ItemKind};\n use crate::ast::{Label, Lifetime, Lit, LitKind};\n-use crate::ast::Local;\n+use crate::ast::{Local, LocalSource};\n use crate::ast::MacStmtStyle;\n use crate::ast::{Mac, Mac_, MacDelimiter};\n use crate::ast::{MutTy, Mutability};\n@@ -550,7 +550,7 @@ fn dummy_arg(span: Span) -> Arg {\n         span,\n         id: ast::DUMMY_NODE_ID\n     };\n-    Arg { ty: P(ty), pat: pat, id: ast::DUMMY_NODE_ID }\n+    Arg { ty: P(ty), pat: pat, id: ast::DUMMY_NODE_ID, source: ast::ArgSource::Normal }\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -1517,6 +1517,7 @@ impl<'a> Parser<'a> {\n             IsAsync::Async {\n                 closure_id: ast::DUMMY_NODE_ID,\n                 return_impl_trait_id: ast::DUMMY_NODE_ID,\n+                arguments: Vec::new(),\n             }\n         } else {\n             IsAsync::NotAsync\n@@ -1575,7 +1576,7 @@ impl<'a> Parser<'a> {\n             // trait item macro.\n             (keywords::Invalid.ident(), ast::TraitItemKind::Macro(mac), ast::Generics::default())\n         } else {\n-            let (constness, unsafety, asyncness, abi) = self.parse_fn_front_matter()?;\n+            let (constness, unsafety, mut asyncness, abi) = self.parse_fn_front_matter()?;\n \n             let ident = self.parse_ident()?;\n             let mut generics = self.parse_generics()?;\n@@ -1589,6 +1590,7 @@ impl<'a> Parser<'a> {\n                 p.parse_arg_general(p.span.rust_2018(), true, false)\n             })?;\n             generics.where_clause = self.parse_where_clause()?;\n+            self.construct_async_arguments(&mut asyncness, &d);\n \n             let sig = ast::MethodSig {\n                 header: FnHeader {\n@@ -2124,7 +2126,7 @@ impl<'a> Parser<'a> {\n             }\n         };\n \n-        Ok(Arg { ty, pat, id: ast::DUMMY_NODE_ID })\n+        Ok(Arg { ty, pat, id: ast::DUMMY_NODE_ID, source: ast::ArgSource::Normal })\n     }\n \n     /// Parses a single function argument.\n@@ -2147,7 +2149,8 @@ impl<'a> Parser<'a> {\n         Ok(Arg {\n             ty: t,\n             pat,\n-            id: ast::DUMMY_NODE_ID\n+            id: ast::DUMMY_NODE_ID,\n+            source: ast::ArgSource::Normal,\n         })\n     }\n \n@@ -5029,6 +5032,7 @@ impl<'a> Parser<'a> {\n             id: ast::DUMMY_NODE_ID,\n             span: lo.to(hi),\n             attrs,\n+            source: LocalSource::Normal,\n         }))\n     }\n \n@@ -6566,7 +6570,7 @@ impl<'a> Parser<'a> {\n     /// Parses an item-position function declaration.\n     fn parse_item_fn(&mut self,\n                      unsafety: Unsafety,\n-                     asyncness: Spanned<IsAsync>,\n+                     mut asyncness: Spanned<IsAsync>,\n                      constness: Spanned<Constness>,\n                      abi: Abi)\n                      -> PResult<'a, ItemInfo> {\n@@ -6575,6 +6579,7 @@ impl<'a> Parser<'a> {\n         let decl = self.parse_fn_decl(allow_c_variadic)?;\n         generics.where_clause = self.parse_where_clause()?;\n         let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n+        self.construct_async_arguments(&mut asyncness, &decl);\n         let header = FnHeader { unsafety, asyncness, constness, abi };\n         Ok((ident, ItemKind::Fn(decl, header, generics, body), Some(inner_attrs)))\n     }\n@@ -6755,11 +6760,12 @@ impl<'a> Parser<'a> {\n             Ok((keywords::Invalid.ident(), vec![], ast::Generics::default(),\n                 ast::ImplItemKind::Macro(mac)))\n         } else {\n-            let (constness, unsafety, asyncness, abi) = self.parse_fn_front_matter()?;\n+            let (constness, unsafety, mut asyncness, abi) = self.parse_fn_front_matter()?;\n             let ident = self.parse_ident()?;\n             let mut generics = self.parse_generics()?;\n             let decl = self.parse_fn_decl_with_self(|p| p.parse_arg())?;\n             generics.where_clause = self.parse_where_clause()?;\n+            self.construct_async_arguments(&mut asyncness, &decl);\n             *at_end = true;\n             let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n             let header = ast::FnHeader { abi, unsafety, constness, asyncness };\n@@ -8181,6 +8187,7 @@ impl<'a> Parser<'a> {\n                                    respan(async_span, IsAsync::Async {\n                                        closure_id: ast::DUMMY_NODE_ID,\n                                        return_impl_trait_id: ast::DUMMY_NODE_ID,\n+                                       arguments: Vec::new(),\n                                    }),\n                                    respan(fn_span, Constness::NotConst),\n                                    Abi::Rust)?;\n@@ -8826,6 +8833,68 @@ impl<'a> Parser<'a> {\n             }\n         }\n     }\n+\n+    /// When lowering a `async fn` to the HIR, we need to move all of the arguments of the function\n+    /// into the generated closure so that they are dropped when the future is polled and not when\n+    /// it is created.\n+    ///\n+    /// The arguments of the function are replaced in HIR lowering with the arguments created by\n+    /// this function and the statements created here are inserted at the top of the closure body.\n+    fn construct_async_arguments(&mut self, asyncness: &mut Spanned<IsAsync>, decl: &FnDecl) {\n+        if let IsAsync::Async { ref mut arguments, .. } = asyncness.node {\n+            for (index, input) in decl.inputs.iter().enumerate() {\n+                let id = ast::DUMMY_NODE_ID;\n+                let span = input.pat.span;\n+\n+                // Construct a name for our temporary argument.\n+                let name = format!(\"__arg{}\", index);\n+                let ident = Ident::from_str(&name);\n+\n+                // Construct an argument representing `__argN: <ty>` to replace the argument of the\n+                // async function.\n+                let arg = Arg {\n+                    ty: input.ty.clone(),\n+                    id,\n+                    pat: P(Pat {\n+                        id,\n+                        node: PatKind::Ident(\n+                            BindingMode::ByValue(Mutability::Immutable), ident, None,\n+                        ),\n+                        span,\n+                    }),\n+                    source: ArgSource::AsyncFn(input.pat.clone()),\n+                };\n+\n+                // Construct a `let <pat> = __argN;` statement to insert at the top of the\n+                // async closure.\n+                let local = P(Local {\n+                    pat: input.pat.clone(),\n+                    // We explicitly do not specify the type for this statement. When the user's\n+                    // argument type is `impl Trait` then this would require the\n+                    // `impl_trait_in_bindings` feature to also be present for that same type to\n+                    // be valid in this binding. At the time of writing (13 Mar 19),\n+                    // `impl_trait_in_bindings` is not stable.\n+                    ty: None,\n+                    init: Some(P(Expr {\n+                        id,\n+                        node: ExprKind::Path(None, ast::Path {\n+                            span,\n+                            segments: vec![PathSegment { ident, id, args: None }],\n+                        }),\n+                        span,\n+                        attrs: ThinVec::new(),\n+                    })),\n+                    id,\n+                    span,\n+                    attrs: ThinVec::new(),\n+                    source: LocalSource::AsyncFn,\n+                });\n+                let stmt = Stmt { id, node: StmtKind::Local(local), span, };\n+\n+                arguments.push(AsyncArgument { ident, arg, stmt });\n+            }\n+        }\n+    }\n }\n \n pub fn emit_unclosed_delims(unclosed_delims: &mut Vec<UnmatchedBrace>, handler: &errors::Handler) {"}, {"sha": "7ce3951f13ecd9f1890231259579d18cd705fecd", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=62d1574876f5531bce1b267e62dff520d7adcbbb", "patch": "@@ -372,7 +372,7 @@ pub fn vis_to_string(v: &ast::Visibility) -> String {\n }\n \n pub fn fun_to_string(decl: &ast::FnDecl,\n-                     header: ast::FnHeader,\n+                     header: &ast::FnHeader,\n                      name: ast::Ident,\n                      generics: &ast::Generics)\n                      -> String {\n@@ -1133,7 +1133,7 @@ impl<'a> State<'a> {\n         match item.node {\n             ast::ForeignItemKind::Fn(ref decl, ref generics) => {\n                 self.head(\"\")?;\n-                self.print_fn(decl, ast::FnHeader::default(),\n+                self.print_fn(decl, &ast::FnHeader::default(),\n                               Some(item.ident),\n                               generics, &item.vis)?;\n                 self.end()?; // end head-ibox\n@@ -1263,7 +1263,7 @@ impl<'a> State<'a> {\n                 self.s.word(\";\")?;\n                 self.end()?; // end the outer cbox\n             }\n-            ast::ItemKind::Fn(ref decl, header, ref param_names, ref body) => {\n+            ast::ItemKind::Fn(ref decl, ref header, ref param_names, ref body) => {\n                 self.head(\"\")?;\n                 self.print_fn(\n                     decl,\n@@ -1615,7 +1615,7 @@ impl<'a> State<'a> {\n                             vis: &ast::Visibility)\n                             -> io::Result<()> {\n         self.print_fn(&m.decl,\n-                      m.header,\n+                      &m.header,\n                       Some(ident),\n                       &generics,\n                       vis)\n@@ -2213,7 +2213,7 @@ impl<'a> State<'a> {\n                 self.bclose_(expr.span, INDENT_UNIT)?;\n             }\n             ast::ExprKind::Closure(\n-                capture_clause, asyncness, movability, ref decl, ref body, _) => {\n+                capture_clause, ref asyncness, movability, ref decl, ref body, _) => {\n                 self.print_movability(movability)?;\n                 self.print_asyncness(asyncness)?;\n                 self.print_capture_clause(capture_clause)?;\n@@ -2798,7 +2798,7 @@ impl<'a> State<'a> {\n \n     pub fn print_fn(&mut self,\n                     decl: &ast::FnDecl,\n-                    header: ast::FnHeader,\n+                    header: &ast::FnHeader,\n                     name: Option<ast::Ident>,\n                     generics: &ast::Generics,\n                     vis: &ast::Visibility) -> io::Result<()> {\n@@ -2853,8 +2853,7 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    pub fn print_asyncness(&mut self, asyncness: ast::IsAsync)\n-                                -> io::Result<()> {\n+    pub fn print_asyncness(&mut self, asyncness: &ast::IsAsync) -> io::Result<()> {\n         if asyncness.is_async() {\n             self.word_nbsp(\"async\")?;\n         }\n@@ -3126,7 +3125,7 @@ impl<'a> State<'a> {\n             span: syntax_pos::DUMMY_SP,\n         };\n         self.print_fn(decl,\n-                      ast::FnHeader { unsafety, abi, ..ast::FnHeader::default() },\n+                      &ast::FnHeader { unsafety, abi, ..ast::FnHeader::default() },\n                       name,\n                       &generics,\n                       &source_map::dummy_spanned(ast::VisibilityKind::Inherited))?;\n@@ -3189,7 +3188,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_fn_header_info(&mut self,\n-                                header: ast::FnHeader,\n+                                header: &ast::FnHeader,\n                                 vis: &ast::Visibility) -> io::Result<()> {\n         self.s.word(visibility_qualified(vis, \"\"))?;\n \n@@ -3198,7 +3197,7 @@ impl<'a> State<'a> {\n             ast::Constness::Const => self.word_nbsp(\"const\")?\n         }\n \n-        self.print_asyncness(header.asyncness.node)?;\n+        self.print_asyncness(&header.asyncness.node)?;\n         self.print_unsafety(header.unsafety)?;\n \n         if header.abi != Abi::Rust {\n@@ -3247,7 +3246,7 @@ mod tests {\n             assert_eq!(\n                 fun_to_string(\n                     &decl,\n-                    ast::FnHeader {\n+                    &ast::FnHeader {\n                         unsafety: ast::Unsafety::Normal,\n                         constness: source_map::dummy_spanned(ast::Constness::NotConst),\n                         asyncness: source_map::dummy_spanned(ast::IsAsync::NotAsync),"}, {"sha": "fc99d10b0b6c613cb76f4ec67b8f9522a2dc8ead", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=62d1574876f5531bce1b267e62dff520d7adcbbb", "patch": "@@ -544,6 +544,9 @@ pub fn walk_fn_ret_ty<'a, V: Visitor<'a>>(visitor: &mut V, ret_ty: &'a FunctionR\n pub fn walk_fn_decl<'a, V: Visitor<'a>>(visitor: &mut V, function_declaration: &'a FnDecl) {\n     for argument in &function_declaration.inputs {\n         visitor.visit_pat(&argument.pat);\n+        if let ArgSource::AsyncFn(pat) = &argument.source {\n+            visitor.visit_pat(pat);\n+        }\n         visitor.visit_ty(&argument.ty)\n     }\n     visitor.visit_fn_ret_ty(&function_declaration.output)"}, {"sha": "2fc1fc9140dc38ce096b3f0b4cb12b74d928ba0f", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=62d1574876f5531bce1b267e62dff520d7adcbbb", "patch": "@@ -128,6 +128,7 @@ fn stmt_let_undescore(cx: &mut ExtCtxt<'_>, sp: Span, expr: P<ast::Expr>) -> ast\n         id: ast::DUMMY_NODE_ID,\n         span: sp,\n         attrs: ThinVec::new(),\n+        source: ast::LocalSource::Normal,\n     });\n     ast::Stmt {\n         id: ast::DUMMY_NODE_ID,"}, {"sha": "84567e1b4b8f26cf9e17016210eca120315a1cc8", "filename": "src/test/mir-opt/inline-closure-borrows-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Ftest%2Fmir-opt%2Finline-closure-borrows-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Ftest%2Fmir-opt%2Finline-closure-borrows-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline-closure-borrows-arg.rs?ref=62d1574876f5531bce1b267e62dff520d7adcbbb", "patch": "@@ -20,7 +20,7 @@ fn foo<T: Copy>(_t: T, q: &i32) -> i32 {\n // ...\n // bb0: {\n //     ...\n-//     _3 = [closure@HirId { owner: DefIndex(0:4), local_id: 29 }];\n+//     _3 = [closure@HirId { owner: DefIndex(0:4), local_id: 31 }];\n //     ...\n //     _4 = &_3;\n //     ..."}, {"sha": "2be48927fd3b73b5828796064e4f5225ea8668ad", "filename": "src/test/mir-opt/inline-closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Ftest%2Fmir-opt%2Finline-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Ftest%2Fmir-opt%2Finline-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline-closure.rs?ref=62d1574876f5531bce1b267e62dff520d7adcbbb", "patch": "@@ -16,7 +16,7 @@ fn foo<T: Copy>(_t: T, q: i32) -> i32 {\n // ...\n // bb0: {\n //     ...\n-//     _3 = [closure@HirId { owner: DefIndex(0:4), local_id: 13 }];\n+//     _3 = [closure@HirId { owner: DefIndex(0:4), local_id: 15 }];\n //     ...\n //     _4 = &_3;\n //     ..."}, {"sha": "ea4f5e076b005b294470c613891f52d3d35506a2", "filename": "src/test/run-pass/issue-54716.rs", "status": "added", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Ftest%2Frun-pass%2Fissue-54716.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62d1574876f5531bce1b267e62dff520d7adcbbb/src%2Ftest%2Frun-pass%2Fissue-54716.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-54716.rs?ref=62d1574876f5531bce1b267e62dff520d7adcbbb", "patch": "@@ -0,0 +1,184 @@\n+// aux-build:arc_wake.rs\n+// edition:2018\n+// run-pass\n+\n+#![allow(unused_variables)]\n+#![feature(async_await, await_macro, futures_api)]\n+\n+extern crate arc_wake;\n+\n+use arc_wake::ArcWake;\n+use std::cell::RefCell;\n+use std::future::Future;\n+use std::marker::PhantomData;\n+use std::sync::Arc;\n+use std::rc::Rc;\n+use std::task::Context;\n+\n+struct EmptyWaker;\n+\n+impl ArcWake for EmptyWaker {\n+    fn wake(self: Arc<Self>) {}\n+}\n+\n+#[derive(Debug, Eq, PartialEq)]\n+enum DropOrder {\n+    Function,\n+    Val(&'static str),\n+}\n+\n+type DropOrderListPtr = Rc<RefCell<Vec<DropOrder>>>;\n+\n+struct D(&'static str, DropOrderListPtr);\n+\n+impl Drop for D {\n+    fn drop(&mut self) {\n+        self.1.borrow_mut().push(DropOrder::Val(self.0));\n+    }\n+}\n+\n+/// Check that unused bindings are dropped after the function is polled.\n+async fn foo(x: D, _y: D) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+/// Check that underscore patterns are dropped after the function is polled.\n+async fn bar(x: D, _: D) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+/// Check that underscore patterns within more complex patterns are dropped after the function\n+/// is polled.\n+async fn baz((x, _): (D, D)) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+/// Check that underscore and unused bindings within and outwith more complex patterns are dropped\n+/// after the function is polled.\n+async fn foobar(x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n+    x.1.borrow_mut().push(DropOrder::Function);\n+}\n+\n+struct Foo;\n+\n+impl Foo {\n+    /// Check that unused bindings are dropped after the method is polled.\n+    async fn foo(x: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    /// Check that underscore patterns are dropped after the method is polled.\n+    async fn bar(x: D, _: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    /// Check that underscore patterns within more complex patterns are dropped after the method\n+    /// is polled.\n+    async fn baz((x, _): (D, D)) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    /// Check that underscore and unused bindings within and outwith more complex patterns are\n+    /// dropped after the method is polled.\n+    async fn foobar(x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+}\n+\n+struct Bar<'a>(PhantomData<&'a ()>);\n+\n+impl<'a> Bar<'a> {\n+    /// Check that unused bindings are dropped after the method with self is polled.\n+    async fn foo(&'a self, x: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    /// Check that underscore patterns are dropped after the method with self is polled.\n+    async fn bar(&'a self, x: D, _: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    /// Check that underscore patterns within more complex patterns are dropped after the method\n+    /// with self is polled.\n+    async fn baz(&'a self, (x, _): (D, D)) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+\n+    /// Check that underscore and unused bindings within and outwith more complex patterns are\n+    /// dropped after the method with self is polled.\n+    async fn foobar(&'a self, x: D, (a, _, _c): (D, D, D), _: D, _y: D) {\n+        x.1.borrow_mut().push(DropOrder::Function);\n+    }\n+}\n+\n+fn assert_drop_order_after_poll<Fut: Future<Output = ()>>(\n+    f: impl FnOnce(DropOrderListPtr) -> Fut,\n+    expected_order: &[DropOrder],\n+) {\n+    let empty = Arc::new(EmptyWaker);\n+    let waker = ArcWake::into_waker(empty);\n+    let mut cx = Context::from_waker(&waker);\n+\n+    let actual_order = Rc::new(RefCell::new(Vec::new()));\n+    let mut fut = Box::pin(f(actual_order.clone()));\n+    let _ = fut.as_mut().poll(&mut cx);\n+\n+    assert_eq!(*actual_order.borrow(), expected_order);\n+}\n+\n+fn main() {\n+    use DropOrder::*;\n+\n+    // At time of writing (23/04/19), the `bar` and `foobar` tests do not output the same order as\n+    // the equivalent non-async functions. This is because the drop order of captured variables\n+    // doesn't match the drop order of arguments in a function.\n+\n+    // Free functions (see doc comment on function for what it tests).\n+    assert_drop_order_after_poll(|l| foo(D(\"x\", l.clone()), D(\"_y\", l.clone())),\n+                                 &[Function, Val(\"_y\"), Val(\"x\")]);\n+    assert_drop_order_after_poll(|l| bar(D(\"x\", l.clone()), D(\"_\", l.clone())),\n+                                 &[Function, Val(\"x\"), Val(\"_\")]);\n+    assert_drop_order_after_poll(|l| baz((D(\"x\", l.clone()), D(\"_\", l.clone()))),\n+                                 &[Function, Val(\"x\"), Val(\"_\")]);\n+    assert_drop_order_after_poll(|l| {\n+        foobar(\n+            D(\"x\", l.clone()),\n+            (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n+            D(\"_\", l.clone()),\n+            D(\"_y\", l.clone()),\n+        )\n+    }, &[Function, Val(\"_y\"), Val(\"_c\"), Val(\"a\"), Val(\"x\"), Val(\"_\"), Val(\"_\")]);\n+\n+    // Methods w/out self (see doc comment on function for what it tests).\n+    assert_drop_order_after_poll(|l| Foo::foo(D(\"x\", l.clone()), D(\"_y\", l.clone())),\n+                                 &[Function, Val(\"_y\"), Val(\"x\")]);\n+    assert_drop_order_after_poll(|l| Foo::bar(D(\"x\", l.clone()), D(\"_\", l.clone())),\n+                                 &[Function, Val(\"x\"), Val(\"_\")]);\n+    assert_drop_order_after_poll(|l| Foo::baz((D(\"x\", l.clone()), D(\"_\", l.clone()))),\n+                                 &[Function, Val(\"x\"), Val(\"_\")]);\n+    assert_drop_order_after_poll(|l| {\n+        Foo::foobar(\n+            D(\"x\", l.clone()),\n+            (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n+            D(\"_\", l.clone()),\n+            D(\"_y\", l.clone()),\n+        )\n+    }, &[Function, Val(\"_y\"), Val(\"_c\"), Val(\"a\"), Val(\"x\"), Val(\"_\"), Val(\"_\")]);\n+\n+    // Methods (see doc comment on function for what it tests).\n+    let b = Bar(Default::default());\n+    assert_drop_order_after_poll(|l| b.foo(D(\"x\", l.clone()), D(\"_y\", l.clone())),\n+                                 &[Function, Val(\"_y\"), Val(\"x\")]);\n+    assert_drop_order_after_poll(|l| b.bar(D(\"x\", l.clone()), D(\"_\", l.clone())),\n+                                 &[Function, Val(\"x\"), Val(\"_\")]);\n+    assert_drop_order_after_poll(|l| b.baz((D(\"x\", l.clone()), D(\"_\", l.clone()))),\n+                                 &[Function, Val(\"x\"), Val(\"_\")]);\n+    assert_drop_order_after_poll(|l| {\n+        b.foobar(\n+            D(\"x\", l.clone()),\n+            (D(\"a\", l.clone()), D(\"_\", l.clone()), D(\"_c\", l.clone())),\n+            D(\"_\", l.clone()),\n+            D(\"_y\", l.clone()),\n+        )\n+    }, &[Function, Val(\"_y\"), Val(\"_c\"), Val(\"a\"), Val(\"x\"), Val(\"_\"), Val(\"_\")]);\n+}"}]}