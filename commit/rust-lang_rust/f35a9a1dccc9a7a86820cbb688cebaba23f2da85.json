{"sha": "f35a9a1dccc9a7a86820cbb688cebaba23f2da85", "node_id": "C_kwDOAAsO6NoAKGYzNWE5YTFkY2NjOWE3YTg2ODIwY2JiNjg4Y2ViYWJhMjNmMmRhODU", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-17T13:19:09Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-06-17T13:19:09Z"}, "message": "Split out tests", "tree": {"sha": "ee63d29e22b44f4d0a525a050c6859ae1278771b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee63d29e22b44f4d0a525a050c6859ae1278771b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f35a9a1dccc9a7a86820cbb688cebaba23f2da85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f35a9a1dccc9a7a86820cbb688cebaba23f2da85", "html_url": "https://github.com/rust-lang/rust/commit/f35a9a1dccc9a7a86820cbb688cebaba23f2da85", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f35a9a1dccc9a7a86820cbb688cebaba23f2da85/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2537e591af0f6ac38de0e48b2fd5374d3ebae93", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2537e591af0f6ac38de0e48b2fd5374d3ebae93", "html_url": "https://github.com/rust-lang/rust/commit/a2537e591af0f6ac38de0e48b2fd5374d3ebae93"}], "stats": {"total": 793, "additions": 396, "deletions": 397}, "files": [{"sha": "d5f754d66581cd0cd2cc34f1193500a1f973c48f", "filename": "crates/ide-completion/src/context.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f35a9a1dccc9a7a86820cbb688cebaba23f2da85/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f35a9a1dccc9a7a86820cbb688cebaba23f2da85/crates%2Fide-completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext.rs?ref=f35a9a1dccc9a7a86820cbb688cebaba23f2da85", "patch": "@@ -1,6 +1,8 @@\n //! See `CompletionContext` structure.\n \n mod analysis;\n+#[cfg(test)]\n+mod tests;\n \n use base_db::SourceDatabaseExt;\n use hir::{"}, {"sha": "dc50d82f1998c1ed88972c7de440e9273780de43", "filename": "crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 1, "deletions": 397, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/f35a9a1dccc9a7a86820cbb688cebaba23f2da85/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f35a9a1dccc9a7a86820cbb688cebaba23f2da85/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=f35a9a1dccc9a7a86820cbb688cebaba23f2da85", "patch": "@@ -1,3 +1,4 @@\n+//! Module responsible for analyzing the code surrounding the cursor for completion.\n use std::iter;\n \n use hir::{Semantics, Type, TypeInfo};\n@@ -1033,403 +1034,6 @@ fn has_ref(token: &SyntaxToken) -> bool {\n     token.kind() == T![&]\n }\n \n-#[cfg(test)]\n-mod tests {\n-    use expect_test::{expect, Expect};\n-    use hir::HirDisplay;\n-\n-    use crate::tests::{position, TEST_CONFIG};\n-\n-    use super::*;\n-\n-    fn check_expected_type_and_name(ra_fixture: &str, expect: Expect) {\n-        let (db, pos) = position(ra_fixture);\n-        let config = TEST_CONFIG;\n-        let completion_context = CompletionContext::new(&db, pos, &config).unwrap();\n-\n-        let ty = completion_context\n-            .expected_type\n-            .map(|t| t.display_test(&db).to_string())\n-            .unwrap_or(\"?\".to_owned());\n-\n-        let name = completion_context\n-            .expected_name\n-            .map_or_else(|| \"?\".to_owned(), |name| name.to_string());\n-\n-        expect.assert_eq(&format!(\"ty: {}, name: {}\", ty, name));\n-    }\n-\n-    #[test]\n-    fn expected_type_let_without_leading_char() {\n-        cov_mark::check!(expected_type_let_without_leading_char);\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() {\n-    let x: u32 = $0;\n-}\n-\"#,\n-            expect![[r#\"ty: u32, name: x\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn expected_type_let_with_leading_char() {\n-        cov_mark::check!(expected_type_let_with_leading_char);\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() {\n-    let x: u32 = c$0;\n-}\n-\"#,\n-            expect![[r#\"ty: u32, name: x\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn expected_type_let_pat() {\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() {\n-    let x$0 = 0u32;\n-}\n-\"#,\n-            expect![[r#\"ty: u32, name: ?\"#]],\n-        );\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() {\n-    let $0 = 0u32;\n-}\n-\"#,\n-            expect![[r#\"ty: u32, name: ?\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn expected_type_fn_param() {\n-        cov_mark::check!(expected_type_fn_param);\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() { bar($0); }\n-fn bar(x: u32) {}\n-\"#,\n-            expect![[r#\"ty: u32, name: x\"#]],\n-        );\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() { bar(c$0); }\n-fn bar(x: u32) {}\n-\"#,\n-            expect![[r#\"ty: u32, name: x\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn expected_type_fn_param_ref() {\n-        cov_mark::check!(expected_type_fn_param_ref);\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() { bar(&$0); }\n-fn bar(x: &u32) {}\n-\"#,\n-            expect![[r#\"ty: u32, name: x\"#]],\n-        );\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() { bar(&mut $0); }\n-fn bar(x: &mut u32) {}\n-\"#,\n-            expect![[r#\"ty: u32, name: x\"#]],\n-        );\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() { bar(& c$0); }\n-fn bar(x: &u32) {}\n-        \"#,\n-            expect![[r#\"ty: u32, name: x\"#]],\n-        );\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() { bar(&mut c$0); }\n-fn bar(x: &mut u32) {}\n-\"#,\n-            expect![[r#\"ty: u32, name: x\"#]],\n-        );\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() { bar(&c$0); }\n-fn bar(x: &u32) {}\n-        \"#,\n-            expect![[r#\"ty: u32, name: x\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn expected_type_struct_field_without_leading_char() {\n-        cov_mark::check!(expected_type_struct_field_without_leading_char);\n-        check_expected_type_and_name(\n-            r#\"\n-struct Foo { a: u32 }\n-fn foo() {\n-    Foo { a: $0 };\n-}\n-\"#,\n-            expect![[r#\"ty: u32, name: a\"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn expected_type_struct_field_followed_by_comma() {\n-        cov_mark::check!(expected_type_struct_field_followed_by_comma);\n-        check_expected_type_and_name(\n-            r#\"\n-struct Foo { a: u32 }\n-fn foo() {\n-    Foo { a: $0, };\n-}\n-\"#,\n-            expect![[r#\"ty: u32, name: a\"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn expected_type_generic_struct_field() {\n-        check_expected_type_and_name(\n-            r#\"\n-struct Foo<T> { a: T }\n-fn foo() -> Foo<u32> {\n-    Foo { a: $0 }\n-}\n-\"#,\n-            expect![[r#\"ty: u32, name: a\"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn expected_type_struct_field_with_leading_char() {\n-        cov_mark::check!(expected_type_struct_field_with_leading_char);\n-        check_expected_type_and_name(\n-            r#\"\n-struct Foo { a: u32 }\n-fn foo() {\n-    Foo { a: c$0 };\n-}\n-\"#,\n-            expect![[r#\"ty: u32, name: a\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn expected_type_match_arm_without_leading_char() {\n-        cov_mark::check!(expected_type_match_arm_without_leading_char);\n-        check_expected_type_and_name(\n-            r#\"\n-enum E { X }\n-fn foo() {\n-   match E::X { $0 }\n-}\n-\"#,\n-            expect![[r#\"ty: E, name: ?\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn expected_type_match_arm_with_leading_char() {\n-        cov_mark::check!(expected_type_match_arm_with_leading_char);\n-        check_expected_type_and_name(\n-            r#\"\n-enum E { X }\n-fn foo() {\n-   match E::X { c$0 }\n-}\n-\"#,\n-            expect![[r#\"ty: E, name: ?\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn expected_type_match_arm_body_without_leading_char() {\n-        cov_mark::check!(expected_type_match_arm_body_without_leading_char);\n-        check_expected_type_and_name(\n-            r#\"\n-struct Foo;\n-enum E { X }\n-fn foo() -> Foo {\n-   match E::X { E::X => $0 }\n-}\n-\"#,\n-            expect![[r#\"ty: Foo, name: ?\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn expected_type_match_body_arm_with_leading_char() {\n-        cov_mark::check!(expected_type_match_arm_body_with_leading_char);\n-        check_expected_type_and_name(\n-            r#\"\n-struct Foo;\n-enum E { X }\n-fn foo() -> Foo {\n-   match E::X { E::X => c$0 }\n-}\n-\"#,\n-            expect![[r#\"ty: Foo, name: ?\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn expected_type_if_let_without_leading_char() {\n-        cov_mark::check!(expected_type_if_let_without_leading_char);\n-        check_expected_type_and_name(\n-            r#\"\n-enum Foo { Bar, Baz, Quux }\n-\n-fn foo() {\n-    let f = Foo::Quux;\n-    if let $0 = f { }\n-}\n-\"#,\n-            expect![[r#\"ty: Foo, name: ?\"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn expected_type_if_let_with_leading_char() {\n-        cov_mark::check!(expected_type_if_let_with_leading_char);\n-        check_expected_type_and_name(\n-            r#\"\n-enum Foo { Bar, Baz, Quux }\n-\n-fn foo() {\n-    let f = Foo::Quux;\n-    if let c$0 = f { }\n-}\n-\"#,\n-            expect![[r#\"ty: Foo, name: ?\"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn expected_type_fn_ret_without_leading_char() {\n-        cov_mark::check!(expected_type_fn_ret_without_leading_char);\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() -> u32 {\n-    $0\n-}\n-\"#,\n-            expect![[r#\"ty: u32, name: ?\"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn expected_type_fn_ret_with_leading_char() {\n-        cov_mark::check!(expected_type_fn_ret_with_leading_char);\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() -> u32 {\n-    c$0\n-}\n-\"#,\n-            expect![[r#\"ty: u32, name: ?\"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn expected_type_fn_ret_fn_ref_fully_typed() {\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() -> u32 {\n-    foo$0\n-}\n-\"#,\n-            expect![[r#\"ty: u32, name: ?\"#]],\n-        )\n-    }\n-\n-    #[test]\n-    fn expected_type_closure_param_return() {\n-        // FIXME: make this work with `|| $0`\n-        check_expected_type_and_name(\n-            r#\"\n-//- minicore: fn\n-fn foo() {\n-    bar(|| a$0);\n-}\n-\n-fn bar(f: impl FnOnce() -> u32) {}\n-\"#,\n-            expect![[r#\"ty: u32, name: ?\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn expected_type_generic_function() {\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() {\n-    bar::<u32>($0);\n-}\n-\n-fn bar<T>(t: T) {}\n-\"#,\n-            expect![[r#\"ty: u32, name: t\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn expected_type_generic_method() {\n-        check_expected_type_and_name(\n-            r#\"\n-fn foo() {\n-    S(1u32).bar($0);\n-}\n-\n-struct S<T>(T);\n-impl<T> S<T> {\n-    fn bar(self, t: T) {}\n-}\n-\"#,\n-            expect![[r#\"ty: u32, name: t\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn expected_type_functional_update() {\n-        cov_mark::check!(expected_type_struct_func_update);\n-        check_expected_type_and_name(\n-            r#\"\n-struct Foo { field: u32 }\n-fn foo() {\n-    Foo {\n-        ..$0\n-    }\n-}\n-\"#,\n-            expect![[r#\"ty: Foo, name: ?\"#]],\n-        );\n-    }\n-\n-    #[test]\n-    fn expected_type_param_pat() {\n-        check_expected_type_and_name(\n-            r#\"\n-struct Foo { field: u32 }\n-fn foo(a$0: Foo) {}\n-\"#,\n-            expect![[r#\"ty: Foo, name: ?\"#]],\n-        );\n-        check_expected_type_and_name(\n-            r#\"\n-struct Foo { field: u32 }\n-fn foo($0: Foo) {}\n-\"#,\n-            // FIXME make this work, currently fails due to pattern recovery eating the `:`\n-            expect![[r#\"ty: ?, name: ?\"#]],\n-        );\n-    }\n-}\n-\n pub(crate) fn previous_token(element: SyntaxElement) -> Option<SyntaxToken> {\n     element.into_token().and_then(previous_non_trivia_token)\n }"}, {"sha": "ce9357270b126986bd807adf25e3768fbb974e9b", "filename": "crates/ide-completion/src/context/tests.rs", "status": "added", "additions": 393, "deletions": 0, "changes": 393, "blob_url": "https://github.com/rust-lang/rust/blob/f35a9a1dccc9a7a86820cbb688cebaba23f2da85/crates%2Fide-completion%2Fsrc%2Fcontext%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f35a9a1dccc9a7a86820cbb688cebaba23f2da85/crates%2Fide-completion%2Fsrc%2Fcontext%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext%2Ftests.rs?ref=f35a9a1dccc9a7a86820cbb688cebaba23f2da85", "patch": "@@ -0,0 +1,393 @@\n+use expect_test::{expect, Expect};\n+use hir::HirDisplay;\n+\n+use crate::{\n+    context::CompletionContext,\n+    tests::{position, TEST_CONFIG},\n+};\n+\n+fn check_expected_type_and_name(ra_fixture: &str, expect: Expect) {\n+    let (db, pos) = position(ra_fixture);\n+    let config = TEST_CONFIG;\n+    let completion_context = CompletionContext::new(&db, pos, &config).unwrap();\n+\n+    let ty = completion_context\n+        .expected_type\n+        .map(|t| t.display_test(&db).to_string())\n+        .unwrap_or(\"?\".to_owned());\n+\n+    let name =\n+        completion_context.expected_name.map_or_else(|| \"?\".to_owned(), |name| name.to_string());\n+\n+    expect.assert_eq(&format!(\"ty: {}, name: {}\", ty, name));\n+}\n+\n+#[test]\n+fn expected_type_let_without_leading_char() {\n+    cov_mark::check!(expected_type_let_without_leading_char);\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() {\n+    let x: u32 = $0;\n+}\n+\"#,\n+        expect![[r#\"ty: u32, name: x\"#]],\n+    );\n+}\n+\n+#[test]\n+fn expected_type_let_with_leading_char() {\n+    cov_mark::check!(expected_type_let_with_leading_char);\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() {\n+    let x: u32 = c$0;\n+}\n+\"#,\n+        expect![[r#\"ty: u32, name: x\"#]],\n+    );\n+}\n+\n+#[test]\n+fn expected_type_let_pat() {\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() {\n+    let x$0 = 0u32;\n+}\n+\"#,\n+        expect![[r#\"ty: u32, name: ?\"#]],\n+    );\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() {\n+    let $0 = 0u32;\n+}\n+\"#,\n+        expect![[r#\"ty: u32, name: ?\"#]],\n+    );\n+}\n+\n+#[test]\n+fn expected_type_fn_param() {\n+    cov_mark::check!(expected_type_fn_param);\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() { bar($0); }\n+fn bar(x: u32) {}\n+\"#,\n+        expect![[r#\"ty: u32, name: x\"#]],\n+    );\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() { bar(c$0); }\n+fn bar(x: u32) {}\n+\"#,\n+        expect![[r#\"ty: u32, name: x\"#]],\n+    );\n+}\n+\n+#[test]\n+fn expected_type_fn_param_ref() {\n+    cov_mark::check!(expected_type_fn_param_ref);\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() { bar(&$0); }\n+fn bar(x: &u32) {}\n+\"#,\n+        expect![[r#\"ty: u32, name: x\"#]],\n+    );\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() { bar(&mut $0); }\n+fn bar(x: &mut u32) {}\n+\"#,\n+        expect![[r#\"ty: u32, name: x\"#]],\n+    );\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() { bar(& c$0); }\n+fn bar(x: &u32) {}\n+        \"#,\n+        expect![[r#\"ty: u32, name: x\"#]],\n+    );\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() { bar(&mut c$0); }\n+fn bar(x: &mut u32) {}\n+\"#,\n+        expect![[r#\"ty: u32, name: x\"#]],\n+    );\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() { bar(&c$0); }\n+fn bar(x: &u32) {}\n+        \"#,\n+        expect![[r#\"ty: u32, name: x\"#]],\n+    );\n+}\n+\n+#[test]\n+fn expected_type_struct_field_without_leading_char() {\n+    cov_mark::check!(expected_type_struct_field_without_leading_char);\n+    check_expected_type_and_name(\n+        r#\"\n+struct Foo { a: u32 }\n+fn foo() {\n+    Foo { a: $0 };\n+}\n+\"#,\n+        expect![[r#\"ty: u32, name: a\"#]],\n+    )\n+}\n+\n+#[test]\n+fn expected_type_struct_field_followed_by_comma() {\n+    cov_mark::check!(expected_type_struct_field_followed_by_comma);\n+    check_expected_type_and_name(\n+        r#\"\n+struct Foo { a: u32 }\n+fn foo() {\n+    Foo { a: $0, };\n+}\n+\"#,\n+        expect![[r#\"ty: u32, name: a\"#]],\n+    )\n+}\n+\n+#[test]\n+fn expected_type_generic_struct_field() {\n+    check_expected_type_and_name(\n+        r#\"\n+struct Foo<T> { a: T }\n+fn foo() -> Foo<u32> {\n+    Foo { a: $0 }\n+}\n+\"#,\n+        expect![[r#\"ty: u32, name: a\"#]],\n+    )\n+}\n+\n+#[test]\n+fn expected_type_struct_field_with_leading_char() {\n+    cov_mark::check!(expected_type_struct_field_with_leading_char);\n+    check_expected_type_and_name(\n+        r#\"\n+struct Foo { a: u32 }\n+fn foo() {\n+    Foo { a: c$0 };\n+}\n+\"#,\n+        expect![[r#\"ty: u32, name: a\"#]],\n+    );\n+}\n+\n+#[test]\n+fn expected_type_match_arm_without_leading_char() {\n+    cov_mark::check!(expected_type_match_arm_without_leading_char);\n+    check_expected_type_and_name(\n+        r#\"\n+enum E { X }\n+fn foo() {\n+   match E::X { $0 }\n+}\n+\"#,\n+        expect![[r#\"ty: E, name: ?\"#]],\n+    );\n+}\n+\n+#[test]\n+fn expected_type_match_arm_with_leading_char() {\n+    cov_mark::check!(expected_type_match_arm_with_leading_char);\n+    check_expected_type_and_name(\n+        r#\"\n+enum E { X }\n+fn foo() {\n+   match E::X { c$0 }\n+}\n+\"#,\n+        expect![[r#\"ty: E, name: ?\"#]],\n+    );\n+}\n+\n+#[test]\n+fn expected_type_match_arm_body_without_leading_char() {\n+    cov_mark::check!(expected_type_match_arm_body_without_leading_char);\n+    check_expected_type_and_name(\n+        r#\"\n+struct Foo;\n+enum E { X }\n+fn foo() -> Foo {\n+   match E::X { E::X => $0 }\n+}\n+\"#,\n+        expect![[r#\"ty: Foo, name: ?\"#]],\n+    );\n+}\n+\n+#[test]\n+fn expected_type_match_body_arm_with_leading_char() {\n+    cov_mark::check!(expected_type_match_arm_body_with_leading_char);\n+    check_expected_type_and_name(\n+        r#\"\n+struct Foo;\n+enum E { X }\n+fn foo() -> Foo {\n+   match E::X { E::X => c$0 }\n+}\n+\"#,\n+        expect![[r#\"ty: Foo, name: ?\"#]],\n+    );\n+}\n+\n+#[test]\n+fn expected_type_if_let_without_leading_char() {\n+    cov_mark::check!(expected_type_if_let_without_leading_char);\n+    check_expected_type_and_name(\n+        r#\"\n+enum Foo { Bar, Baz, Quux }\n+\n+fn foo() {\n+    let f = Foo::Quux;\n+    if let $0 = f { }\n+}\n+\"#,\n+        expect![[r#\"ty: Foo, name: ?\"#]],\n+    )\n+}\n+\n+#[test]\n+fn expected_type_if_let_with_leading_char() {\n+    cov_mark::check!(expected_type_if_let_with_leading_char);\n+    check_expected_type_and_name(\n+        r#\"\n+enum Foo { Bar, Baz, Quux }\n+\n+fn foo() {\n+    let f = Foo::Quux;\n+    if let c$0 = f { }\n+}\n+\"#,\n+        expect![[r#\"ty: Foo, name: ?\"#]],\n+    )\n+}\n+\n+#[test]\n+fn expected_type_fn_ret_without_leading_char() {\n+    cov_mark::check!(expected_type_fn_ret_without_leading_char);\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() -> u32 {\n+    $0\n+}\n+\"#,\n+        expect![[r#\"ty: u32, name: ?\"#]],\n+    )\n+}\n+\n+#[test]\n+fn expected_type_fn_ret_with_leading_char() {\n+    cov_mark::check!(expected_type_fn_ret_with_leading_char);\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() -> u32 {\n+    c$0\n+}\n+\"#,\n+        expect![[r#\"ty: u32, name: ?\"#]],\n+    )\n+}\n+\n+#[test]\n+fn expected_type_fn_ret_fn_ref_fully_typed() {\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() -> u32 {\n+    foo$0\n+}\n+\"#,\n+        expect![[r#\"ty: u32, name: ?\"#]],\n+    )\n+}\n+\n+#[test]\n+fn expected_type_closure_param_return() {\n+    // FIXME: make this work with `|| $0`\n+    check_expected_type_and_name(\n+        r#\"\n+//- minicore: fn\n+fn foo() {\n+    bar(|| a$0);\n+}\n+\n+fn bar(f: impl FnOnce() -> u32) {}\n+\"#,\n+        expect![[r#\"ty: u32, name: ?\"#]],\n+    );\n+}\n+\n+#[test]\n+fn expected_type_generic_function() {\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() {\n+    bar::<u32>($0);\n+}\n+\n+fn bar<T>(t: T) {}\n+\"#,\n+        expect![[r#\"ty: u32, name: t\"#]],\n+    );\n+}\n+\n+#[test]\n+fn expected_type_generic_method() {\n+    check_expected_type_and_name(\n+        r#\"\n+fn foo() {\n+    S(1u32).bar($0);\n+}\n+\n+struct S<T>(T);\n+impl<T> S<T> {\n+    fn bar(self, t: T) {}\n+}\n+\"#,\n+        expect![[r#\"ty: u32, name: t\"#]],\n+    );\n+}\n+\n+#[test]\n+fn expected_type_functional_update() {\n+    cov_mark::check!(expected_type_struct_func_update);\n+    check_expected_type_and_name(\n+        r#\"\n+struct Foo { field: u32 }\n+fn foo() {\n+    Foo {\n+        ..$0\n+    }\n+}\n+\"#,\n+        expect![[r#\"ty: Foo, name: ?\"#]],\n+    );\n+}\n+\n+#[test]\n+fn expected_type_param_pat() {\n+    check_expected_type_and_name(\n+        r#\"\n+struct Foo { field: u32 }\n+fn foo(a$0: Foo) {}\n+\"#,\n+        expect![[r#\"ty: Foo, name: ?\"#]],\n+    );\n+    check_expected_type_and_name(\n+        r#\"\n+struct Foo { field: u32 }\n+fn foo($0: Foo) {}\n+\"#,\n+        // FIXME make this work, currently fails due to pattern recovery eating the `:`\n+        expect![[r#\"ty: ?, name: ?\"#]],\n+    );\n+}"}]}