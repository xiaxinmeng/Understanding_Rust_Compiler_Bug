{"sha": "c73e78ce649ff9d40ba74a2c9338c7b2caac4920", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3M2U3OGNlNjQ5ZmY5ZDQwYmE3NGEyYzkzMzhjN2IyY2FhYzQ5MjA=", "commit": {"author": {"name": "Ms2ger", "email": "Ms2ger@gmail.com", "date": "2015-10-07T12:37:42Z"}, "committer": {"name": "Ms2ger", "email": "Ms2ger@gmail.com", "date": "2015-10-07T12:37:45Z"}, "message": "Partially format librustc_mir with rustfmt.\n\nThis commit contains some of the changes proposed by a rustfmt invocation,\nchosen based on the fairly non-deterministic metric of how much I liked the\nchange. I expect we will run rustfmt on this crate again later, probably\naccepting more of its changes. For now, this is already an improvement over\nthe status-quo.", "tree": {"sha": "5a73ba6e835c4ecbb16cc0c32465ff94cf7a250d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a73ba6e835c4ecbb16cc0c32465ff94cf7a250d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c73e78ce649ff9d40ba74a2c9338c7b2caac4920", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c73e78ce649ff9d40ba74a2c9338c7b2caac4920", "html_url": "https://github.com/rust-lang/rust/commit/c73e78ce649ff9d40ba74a2c9338c7b2caac4920", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/comments", "author": {"login": "Ms2ger", "id": 111161, "node_id": "MDQ6VXNlcjExMTE2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/111161?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ms2ger", "html_url": "https://github.com/Ms2ger", "followers_url": "https://api.github.com/users/Ms2ger/followers", "following_url": "https://api.github.com/users/Ms2ger/following{/other_user}", "gists_url": "https://api.github.com/users/Ms2ger/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ms2ger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ms2ger/subscriptions", "organizations_url": "https://api.github.com/users/Ms2ger/orgs", "repos_url": "https://api.github.com/users/Ms2ger/repos", "events_url": "https://api.github.com/users/Ms2ger/events{/privacy}", "received_events_url": "https://api.github.com/users/Ms2ger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Ms2ger", "id": 111161, "node_id": "MDQ6VXNlcjExMTE2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/111161?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Ms2ger", "html_url": "https://github.com/Ms2ger", "followers_url": "https://api.github.com/users/Ms2ger/followers", "following_url": "https://api.github.com/users/Ms2ger/following{/other_user}", "gists_url": "https://api.github.com/users/Ms2ger/gists{/gist_id}", "starred_url": "https://api.github.com/users/Ms2ger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Ms2ger/subscriptions", "organizations_url": "https://api.github.com/users/Ms2ger/orgs", "repos_url": "https://api.github.com/users/Ms2ger/repos", "events_url": "https://api.github.com/users/Ms2ger/events{/privacy}", "received_events_url": "https://api.github.com/users/Ms2ger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ea1305fadfe0a6946506215ea213bc43ad92d04", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ea1305fadfe0a6946506215ea213bc43ad92d04", "html_url": "https://github.com/rust-lang/rust/commit/0ea1305fadfe0a6946506215ea213bc43ad92d04"}], "stats": {"total": 1180, "additions": 651, "deletions": 529}, "files": [{"sha": "318ae704089f52c0bf43fe501b4417599c72299c", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=c73e78ce649ff9d40ba74a2c9338c7b2caac4920", "patch": "@@ -29,7 +29,7 @@ impl<'tcx> CFG<'tcx> {\n     pub fn end_point(&self, block: BasicBlock) -> ExecutionPoint {\n         ExecutionPoint {\n             block: block,\n-            statement: self.block_data(block).statements.len() as u32\n+            statement: self.block_data(block).statements.len() as u32,\n         }\n     }\n "}, {"sha": "b362f981764203dce13aaf9a5f672ad6d56290e0", "filename": "src/librustc_mir/build/expr/as_constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs?ref=c73e78ce649ff9d40ba74a2c9338c7b2caac4920", "patch": "@@ -10,7 +10,7 @@\n \n //! See docs in build/expr/mod.rs\n \n-use build::{Builder};\n+use build::Builder;\n use hair::*;\n use repr::*;\n "}, {"sha": "d93304f034dd8af87b3c5d15994bf872c753de28", "filename": "src/librustc_mir/build/expr/as_lvalue.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_lvalue.rs?ref=c73e78ce649ff9d40ba74a2c9338c7b2caac4920", "patch": "@@ -30,18 +30,14 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     fn expr_as_lvalue(&mut self,\n                       mut block: BasicBlock,\n                       expr: Expr<'tcx>)\n-                      -> BlockAnd<Lvalue<'tcx>>\n-    {\n-        debug!(\"expr_as_lvalue(block={:?}, expr={:?})\",\n-               block, expr);\n+                      -> BlockAnd<Lvalue<'tcx>> {\n+        debug!(\"expr_as_lvalue(block={:?}, expr={:?})\", block, expr);\n \n         let this = self;\n         let expr_span = expr.span;\n         match expr.kind {\n             ExprKind::Scope { extent, value } => {\n-                this.in_scope(extent, block, |this| {\n-                    this.as_lvalue(block, value)\n-                })\n+                this.in_scope(extent, block, |this| this.as_lvalue(block, value))\n             }\n             ExprKind::Field { lhs, name } => {\n                 let lvalue = unpack!(block = this.as_lvalue(block, lhs));\n@@ -69,12 +65,11 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                                                            idx.clone(),\n                                                            Operand::Consume(len)));\n \n-                let (success, failure) = (this.cfg.start_new_block(),\n-                                          this.cfg.start_new_block());\n+                let (success, failure) = (this.cfg.start_new_block(), this.cfg.start_new_block());\n                 this.cfg.terminate(block,\n                                    Terminator::If {\n                                        cond: Operand::Consume(lt),\n-                                       targets: [success, failure]\n+                                       targets: [success, failure],\n                                    });\n                 this.panic(failure);\n                 success.and(slice.index(idx))"}, {"sha": "6b2c487d0f529ec5b3f1bb76d64193afeb7042a3", "filename": "src/librustc_mir/build/expr/as_operand.rs", "status": "modified", "additions": 5, "deletions": 12, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs?ref=c73e78ce649ff9d40ba74a2c9338c7b2caac4920", "patch": "@@ -20,11 +20,8 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     /// If `expr` is an lvalue like `x`, this will introduce a\n     /// temporary `tmp = x`, so that we capture the value of `x` at\n     /// this time.\n-    pub fn as_operand<M>(&mut self,\n-                         block: BasicBlock,\n-                         expr: M)\n-                         -> BlockAnd<Operand<'tcx>>\n-        where M: Mirror<'tcx, Output=Expr<'tcx>>\n+    pub fn as_operand<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Operand<'tcx>>\n+        where M: Mirror<'tcx, Output = Expr<'tcx>>\n     {\n         let expr = self.hir.mirror(expr);\n         self.expr_as_operand(block, expr)\n@@ -33,16 +30,12 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     fn expr_as_operand(&mut self,\n                        mut block: BasicBlock,\n                        expr: Expr<'tcx>)\n-                       -> BlockAnd<Operand<'tcx>>\n-    {\n-        debug!(\"expr_as_operand(block={:?}, expr={:?})\",\n-               block, expr);\n+                       -> BlockAnd<Operand<'tcx>> {\n+        debug!(\"expr_as_operand(block={:?}, expr={:?})\", block, expr);\n         let this = self;\n \n         if let ExprKind::Scope { extent, value } = expr.kind {\n-            return this.in_scope(extent, block, |this| {\n-                this.as_operand(block, value)\n-            });\n+            return this.in_scope(extent, block, |this| this.as_operand(block, value));\n         }\n \n         let category = Category::of(&expr.kind).unwrap();"}, {"sha": "3cfc51ec3c98adda6fafbda78d1caa5c25f3469c", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=c73e78ce649ff9d40ba74a2c9338c7b2caac4920", "patch": "@@ -19,11 +19,8 @@ use repr::*;\n \n impl<'a,'tcx> Builder<'a,'tcx> {\n     /// Compile `expr`, yielding an rvalue.\n-    pub fn as_rvalue<M>(&mut self,\n-                        block: BasicBlock,\n-                        expr: M)\n-                        -> BlockAnd<Rvalue<'tcx>>\n-        where M: Mirror<'tcx, Output=Expr<'tcx>>\n+    pub fn as_rvalue<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Rvalue<'tcx>>\n+        where M: Mirror<'tcx, Output = Expr<'tcx>>\n     {\n         let expr = self.hir.mirror(expr);\n         self.expr_as_rvalue(block, expr)\n@@ -32,19 +29,15 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     fn expr_as_rvalue(&mut self,\n                       mut block: BasicBlock,\n                       expr: Expr<'tcx>)\n-                      -> BlockAnd<Rvalue<'tcx>>\n-    {\n-        debug!(\"expr_as_rvalue(block={:?}, expr={:?})\",\n-               block, expr);\n+                      -> BlockAnd<Rvalue<'tcx>> {\n+        debug!(\"expr_as_rvalue(block={:?}, expr={:?})\", block, expr);\n \n         let this = self;\n         let expr_span = expr.span;\n \n         match expr.kind {\n             ExprKind::Scope { extent, value } => {\n-                this.in_scope(extent, block, |this| {\n-                    this.as_rvalue(block, value)\n-                })\n+                this.in_scope(extent, block, |this| this.as_rvalue(block, value))\n             }\n             ExprKind::InlineAsm { asm } => {\n                 block.and(Rvalue::InlineAsm(asm))\n@@ -162,11 +155,9 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                           .map(|f| (f.name, unpack!(block = this.as_operand(block, f.expr))))\n                           .collect();\n \n-                let field_names =\n-                    this.hir.fields(adt_def, variant_index);\n+                let field_names = this.hir.fields(adt_def, variant_index);\n \n-                let base =\n-                    base.map(|base| unpack!(block = this.as_lvalue(block, base)));\n+                let base = base.map(|base| unpack!(block = this.as_lvalue(block, base)));\n \n                 // for the actual values we use, take either the\n                 // expr the user specified or, if they didn't"}, {"sha": "7c85e9e7174638abbe9e7ec09aea62d8405fe361", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 6, "deletions": 18, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=c73e78ce649ff9d40ba74a2c9338c7b2caac4920", "patch": "@@ -18,39 +18,27 @@ use repr::*;\n impl<'a,'tcx> Builder<'a,'tcx> {\n     /// Compile `expr` into a fresh temporary. This is used when building\n     /// up rvalues so as to freeze the value that will be consumed.\n-    pub fn as_temp<M>(&mut self,\n-                      block: BasicBlock,\n-                      expr: M)\n-                      -> BlockAnd<Lvalue<'tcx>>\n-        where M: Mirror<'tcx, Output=Expr<'tcx>>\n+    pub fn as_temp<M>(&mut self, block: BasicBlock, expr: M) -> BlockAnd<Lvalue<'tcx>>\n+        where M: Mirror<'tcx, Output = Expr<'tcx>>\n     {\n         let expr = self.hir.mirror(expr);\n         self.expr_as_temp(block, expr)\n     }\n \n-    fn expr_as_temp(&mut self,\n-                    mut block: BasicBlock,\n-                    expr: Expr<'tcx>)\n-                    -> BlockAnd<Lvalue<'tcx>>\n-    {\n-        debug!(\"expr_as_temp(block={:?}, expr={:?})\",\n-               block, expr);\n+    fn expr_as_temp(&mut self, mut block: BasicBlock, expr: Expr<'tcx>) -> BlockAnd<Lvalue<'tcx>> {\n+        debug!(\"expr_as_temp(block={:?}, expr={:?})\", block, expr);\n         let this = self;\n \n         if let ExprKind::Scope { extent, value } = expr.kind {\n-            return this.in_scope(extent, block, |this| {\n-                this.as_temp(block, value)\n-            });\n+            return this.in_scope(extent, block, |this| this.as_temp(block, value));\n         }\n \n         let expr_ty = expr.ty.clone();\n         let temp = this.temp(expr_ty.clone());\n         let temp_lifetime = match expr.temp_lifetime {\n             Some(t) => t,\n             None => {\n-                this.hir.span_bug(\n-                    expr.span,\n-                    &format!(\"no temp_lifetime for expr\"));\n+                this.hir.span_bug(expr.span, &format!(\"no temp_lifetime for expr\"));\n             }\n         };\n         this.schedule_drop(expr.span, temp_lifetime, DropKind::Deep, &temp, expr_ty);"}, {"sha": "a7d68b09b54592bae360e504f5c96635b56a11cc", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=c73e78ce649ff9d40ba74a2c9338c7b2caac4920", "patch": "@@ -38,9 +38,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n         match expr.kind {\n             ExprKind::Scope { extent, value } => {\n-                this.in_scope(extent, block, |this| {\n-                    this.into(destination, block, value)\n-                })\n+                this.in_scope(extent, block, |this| this.into(destination, block, value))\n             }\n             ExprKind::Block { body: ast_block } => {\n                 this.ast_block(destination, block, ast_block)\n@@ -204,8 +202,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                                        |loop_scope| loop_scope.continue_block)\n             }\n             ExprKind::Break { label } => {\n-                this.break_or_continue(expr_span, label, block,\n-                                       |loop_scope| loop_scope.break_block)\n+                this.break_or_continue(expr_span, label, block, |loop_scope| loop_scope.break_block)\n             }\n             ExprKind::Return { value } => {\n                 unpack!(block = this.into(&Lvalue::ReturnPointer, block, value));\n@@ -226,9 +223,9 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                                        data: CallData {\n                                            destination: destination.clone(),\n                                            func: fun,\n-                                           args: args\n+                                           args: args,\n                                        },\n-                                       targets: [success, panic]\n+                                       targets: [success, panic],\n                                    });\n                 success.unit()\n             }"}, {"sha": "c6f1b777d663e4a0aa0eade8e24b6686113c4ee7", "filename": "src/librustc_mir/build/into.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fbuild%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fbuild%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Finto.rs?ref=c73e78ce649ff9d40ba74a2c9338c7b2caac4920", "patch": "@@ -19,8 +19,11 @@ use hair::*;\n use repr::*;\n \n pub trait EvalInto<'tcx> {\n-    fn eval_into<'a>(self, builder: &mut Builder<'a,'tcx>, destination: &Lvalue<'tcx>,\n-                     block: BasicBlock) -> BlockAnd<()>;\n+    fn eval_into<'a>(self,\n+                     builder: &mut Builder<'a, 'tcx>,\n+                     destination: &Lvalue<'tcx>,\n+                     block: BasicBlock)\n+                     -> BlockAnd<()>;\n }\n \n impl<'a,'tcx> Builder<'a,'tcx> {\n@@ -37,7 +40,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n impl<'tcx> EvalInto<'tcx> for ExprRef<'tcx> {\n     fn eval_into<'a>(self,\n-                     builder: &mut Builder<'a,'tcx>,\n+                     builder: &mut Builder<'a, 'tcx>,\n                      destination: &Lvalue<'tcx>,\n                      block: BasicBlock)\n                      -> BlockAnd<()> {\n@@ -48,7 +51,7 @@ impl<'tcx> EvalInto<'tcx> for ExprRef<'tcx> {\n \n impl<'tcx> EvalInto<'tcx> for Expr<'tcx> {\n     fn eval_into<'a>(self,\n-                     builder: &mut Builder<'a,'tcx>,\n+                     builder: &mut Builder<'a, 'tcx>,\n                      destination: &Lvalue<'tcx>,\n                      block: BasicBlock)\n                      -> BlockAnd<()> {\n@@ -58,13 +61,13 @@ impl<'tcx> EvalInto<'tcx> for Expr<'tcx> {\n \n impl<'tcx> EvalInto<'tcx> for Option<ExprRef<'tcx>> {\n     fn eval_into<'a>(self,\n-                     builder: &mut Builder<'a,'tcx>,\n+                     builder: &mut Builder<'a, 'tcx>,\n                      destination: &Lvalue<'tcx>,\n                      block: BasicBlock)\n                      -> BlockAnd<()> {\n         match self {\n             Some(expr) => builder.into(destination, block, expr),\n-            None => block.unit()\n+            None => block.unit(),\n         }\n     }\n }"}, {"sha": "6e0b05d5dea79304dca828432f32f26219f6dfe2", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 38, "deletions": 29, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=c73e78ce649ff9d40ba74a2c9338c7b2caac4920", "patch": "@@ -33,10 +33,8 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                       mut block: BasicBlock,\n                       discriminant: ExprRef<'tcx>,\n                       arms: Vec<Arm<'tcx>>)\n-                      -> BlockAnd<()>\n-    {\n-        let discriminant_lvalue =\n-            unpack!(block = self.as_lvalue(block, discriminant));\n+                      -> BlockAnd<()> {\n+        let discriminant_lvalue = unpack!(block = self.as_lvalue(block, discriminant));\n \n         // Before we do anything, create uninitialized variables with\n         // suitable extent for all of the bindings in this match. It's\n@@ -101,11 +99,10 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n     pub fn expr_into_pattern(&mut self,\n                              mut block: BasicBlock,\n-                             var_extent: CodeExtent,          // lifetime of vars\n+                             var_extent: CodeExtent, // lifetime of vars\n                              irrefutable_pat: PatternRef<'tcx>,\n                              initializer: ExprRef<'tcx>)\n-                             -> BlockAnd<()>\n-    {\n+                             -> BlockAnd<()> {\n         // optimize the case of `let x = ...`\n         let irrefutable_pat = self.hir.mirror(irrefutable_pat);\n         match irrefutable_pat.kind {\n@@ -115,25 +112,30 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                                    var,\n                                    ty,\n                                    subpattern: None } => {\n-                let index = self.declare_binding(var_extent, mutability, name,\n-                                                 var, ty, irrefutable_pat.span);\n+                let index = self.declare_binding(var_extent,\n+                                                 mutability,\n+                                                 name,\n+                                                 var,\n+                                                 ty,\n+                                                 irrefutable_pat.span);\n                 let lvalue = Lvalue::Var(index);\n                 return self.into(&lvalue, block, initializer);\n             }\n-            _ => { }\n+            _ => {}\n         }\n         let lvalue = unpack!(block = self.as_lvalue(block, initializer));\n-        self.lvalue_into_pattern(block, var_extent,\n-                                 PatternRef::Mirror(Box::new(irrefutable_pat)), &lvalue)\n+        self.lvalue_into_pattern(block,\n+                                 var_extent,\n+                                 PatternRef::Mirror(Box::new(irrefutable_pat)),\n+                                 &lvalue)\n     }\n \n     pub fn lvalue_into_pattern(&mut self,\n                                mut block: BasicBlock,\n                                var_extent: CodeExtent,\n                                irrefutable_pat: PatternRef<'tcx>,\n                                initializer: &Lvalue<'tcx>)\n-                               -> BlockAnd<()>\n-    {\n+                               -> BlockAnd<()> {\n         // first, creating the bindings\n         self.declare_bindings(var_extent, irrefutable_pat.clone());\n \n@@ -150,10 +152,10 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         unpack!(block = self.simplify_candidate(block, &mut candidate));\n \n         if !candidate.match_pairs.is_empty() {\n-            self.hir.span_bug(\n-                candidate.match_pairs[0].pattern.span,\n-                &format!(\"match pairs {:?} remaining after simplifying irrefutable pattern\",\n-                         candidate.match_pairs));\n+            self.hir.span_bug(candidate.match_pairs[0].pattern.span,\n+                              &format!(\"match pairs {:?} remaining after simplifying \\\n+                                        irrefutable pattern\",\n+                                       candidate.match_pairs));\n         }\n \n         // now apply the bindings, which will also declare the variables\n@@ -162,10 +164,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         block.unit()\n     }\n \n-    pub fn declare_bindings(&mut self,\n-                            var_extent: CodeExtent,\n-                            pattern: PatternRef<'tcx>)\n-    {\n+    pub fn declare_bindings(&mut self, var_extent: CodeExtent, pattern: PatternRef<'tcx>) {\n         let pattern = self.hir.mirror(pattern);\n         match pattern.kind {\n             PatternKind::Binding { mutability, name, mode: _, var, ty, subpattern } => {\n@@ -180,8 +179,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                     self.declare_bindings(var_extent, subpattern);\n                 }\n             }\n-            PatternKind::Constant { .. } | PatternKind::Range { .. } | PatternKind::Wild => {\n-            }\n+            PatternKind::Constant { .. } | PatternKind::Range { .. } | PatternKind::Wild => {}\n             PatternKind::Deref { subpattern } => {\n                 self.declare_bindings(var_extent, subpattern);\n             }\n@@ -239,16 +237,28 @@ struct MatchPair<'tcx> {\n #[derive(Clone, Debug, PartialEq)]\n enum TestKind<'tcx> {\n     // test the branches of enum\n-    Switch { adt_def: AdtDef<'tcx> },\n+    Switch {\n+        adt_def: AdtDef<'tcx>,\n+    },\n \n     // test for equality\n-    Eq { value: Literal<'tcx>, ty: Ty<'tcx> },\n+    Eq {\n+        value: Literal<'tcx>,\n+        ty: Ty<'tcx>,\n+    },\n \n     // test whether the value falls within an inclusive range\n-    Range { lo: Literal<'tcx>, hi: Literal<'tcx>, ty: Ty<'tcx> },\n+    Range {\n+        lo: Literal<'tcx>,\n+        hi: Literal<'tcx>,\n+        ty: Ty<'tcx>,\n+    },\n \n     // test length of the slice is equal to len\n-    Len { len: usize, op: BinOp },\n+    Len {\n+        len: usize,\n+        op: BinOp,\n+    },\n }\n \n #[derive(Debug)]\n@@ -416,4 +426,3 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         index\n     }\n }\n-"}, {"sha": "0267e9b10ceccb13740ac6381bb61abce540af95", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=c73e78ce649ff9d40ba74a2c9338c7b2caac4920", "patch": "@@ -33,15 +33,16 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     pub fn simplify_candidate(&mut self,\n                               mut block: BasicBlock,\n                               candidate: &mut Candidate<'tcx>)\n-                              -> BlockAnd<()>\n-    {\n+                              -> BlockAnd<()> {\n         // repeatedly simplify match pairs until fixed point is reached\n         loop {\n             let match_pairs = mem::replace(&mut candidate.match_pairs, vec![]);\n             let mut progress = match_pairs.len(); // count how many were simplified\n             for match_pair in match_pairs {\n                 match self.simplify_match_pair(block, match_pair, candidate) {\n-                    Ok(b) => { block = b; }\n+                    Ok(b) => {\n+                        block = b;\n+                    }\n                     Err(match_pair) => {\n                         candidate.match_pairs.push(match_pair);\n                         progress -= 1; // this one was not simplified\n@@ -63,8 +64,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                            mut block: BasicBlock,\n                            match_pair: MatchPair<'tcx>,\n                            candidate: &mut Candidate<'tcx>)\n-                           -> Result<BasicBlock, MatchPair<'tcx>>\n-    {\n+                           -> Result<BasicBlock, MatchPair<'tcx>> {\n         match match_pair.pattern.kind {\n             PatternKind::Wild(..) => {\n                 // nothing left to do\n@@ -115,8 +115,8 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n             PatternKind::Leaf { subpatterns } => {\n                 // tuple struct, match subpats (if any)\n-                candidate.match_pairs.extend(\n-                    self.field_match_pairs(match_pair.lvalue, subpatterns));\n+                candidate.match_pairs\n+                         .extend(self.field_match_pairs(match_pair.lvalue, subpatterns));\n                 Ok(block)\n             }\n \n@@ -129,4 +129,3 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         }\n     }\n }\n-"}, {"sha": "d5745eb28c7a845aface6eb6bd2f943261f3fa42", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 37, "deletions": 27, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=c73e78ce649ff9d40ba74a2c9338c7b2caac4920", "patch": "@@ -37,23 +37,31 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n             PatternKind::Constant { ref value } => {\n                 Test {\n                     span: match_pair.pattern.span,\n-                    kind: TestKind::Eq { value: value.clone(),\n-                                         ty: match_pair.pattern.ty.clone() },\n+                    kind: TestKind::Eq {\n+                        value: value.clone(),\n+                        ty: match_pair.pattern.ty.clone(),\n+                    },\n                 }\n             }\n \n             PatternKind::Range { ref lo, ref hi } => {\n                 Test {\n                     span: match_pair.pattern.span,\n-                    kind: TestKind::Range { lo: lo.clone(),\n-                                            hi: hi.clone(),\n-                                            ty: match_pair.pattern.ty.clone() },\n+                    kind: TestKind::Range {\n+                        lo: lo.clone(),\n+                        hi: hi.clone(),\n+                        ty: match_pair.pattern.ty.clone(),\n+                    },\n                 }\n             }\n \n             PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n                 let len = prefix.len() + suffix.len();\n-                let op = if slice.is_some() {BinOp::Ge} else {BinOp::Eq};\n+                let op = if slice.is_some() {\n+                    BinOp::Ge\n+                } else {\n+                    BinOp::Eq\n+                };\n                 Test {\n                     span: match_pair.pattern.span,\n                     kind: TestKind::Len { len: len, op: op },\n@@ -102,11 +110,17 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 let hi = self.push_literal(block, test.span, ty.clone(), hi);\n                 let item_ref = self.hir.partial_le(ty);\n \n-                let lo_blocks =\n-                    self.call_comparison_fn(block, test.span, item_ref.clone(), lo, lvalue.clone());\n+                let lo_blocks = self.call_comparison_fn(block,\n+                                                        test.span,\n+                                                        item_ref.clone(),\n+                                                        lo,\n+                                                        lvalue.clone());\n \n-                let hi_blocks =\n-                    self.call_comparison_fn(lo_blocks[0], test.span, item_ref, lvalue.clone(), hi);\n+                let hi_blocks = self.call_comparison_fn(lo_blocks[0],\n+                                                        test.span,\n+                                                        item_ref,\n+                                                        lvalue.clone(),\n+                                                        hi);\n \n                 let failure = self.cfg.start_new_block();\n                 self.cfg.terminate(lo_blocks[1], Terminator::Goto { target: failure });\n@@ -120,20 +134,18 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 let (actual, result) = (self.temp(usize_ty), self.temp(bool_ty));\n \n                 // actual = len(lvalue)\n-                self.cfg.push_assign(\n-                    block, test.span,\n-                    &actual, Rvalue::Len(lvalue.clone()));\n+                self.cfg.push_assign(block, test.span, &actual, Rvalue::Len(lvalue.clone()));\n \n                 // expected = <N>\n-                let expected =\n-                    self.push_usize(block, test.span, len);\n+                let expected = self.push_usize(block, test.span, len);\n \n                 // result = actual == expected OR result = actual < expected\n-                self.cfg.push_assign(\n-                    block, test.span,\n-                    &result, Rvalue::BinaryOp(op,\n-                                              Operand::Consume(actual),\n-                                              Operand::Consume(expected)));\n+                self.cfg.push_assign(block,\n+                                     test.span,\n+                                     &result,\n+                                     Rvalue::BinaryOp(op,\n+                                                      Operand::Consume(actual),\n+                                                      Operand::Consume(expected)));\n \n                 // branch based on result\n                 let target_blocks: Vec<_> = vec![self.cfg.start_new_block(),\n@@ -155,8 +167,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                           lvalue1: Lvalue<'tcx>,\n                           lvalue2: Lvalue<'tcx>)\n                           -> Vec<BasicBlock> {\n-        let target_blocks = vec![self.cfg.start_new_block(),\n-                                 self.cfg.start_new_block()];\n+        let target_blocks = vec![self.cfg.start_new_block(), self.cfg.start_new_block()];\n \n         let bool_ty = self.hir.bool_ty();\n         let eq_result = self.temp(bool_ty);\n@@ -176,7 +187,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         self.cfg.terminate(call_blocks[0],\n                            Terminator::If {\n                                cond: Operand::Consume(eq_result),\n-                               targets: [target_blocks[0], target_blocks[1]]\n+                               targets: [target_blocks[0], target_blocks[1]],\n                            });\n \n         target_blocks\n@@ -209,7 +220,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                                                                        match_pairs));\n         block.and(match result {\n             Some(match_pairs) => Some(Candidate { match_pairs: match_pairs, ..candidate }),\n-            None => None\n+            None => None,\n         })\n     }\n \n@@ -341,8 +352,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     }\n \n     fn error_simplifyable(&mut self, match_pair: &MatchPair<'tcx>) -> ! {\n-        self.hir.span_bug(\n-            match_pair.pattern.span,\n-            &format!(\"simplifyable pattern found: {:?}\", match_pair.pattern))\n+        self.hir.span_bug(match_pair.pattern.span,\n+                          &format!(\"simplifyable pattern found: {:?}\", match_pair.pattern))\n     }\n }"}, {"sha": "28925f9b38b4f3d28475bcf06f7380eb22854dd6", "filename": "src/librustc_mir/build/matches/util.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs?ref=c73e78ce649ff9d40ba74a2c9338c7b2caac4920", "patch": "@@ -27,7 +27,9 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                    .collect()\n     }\n \n-    pub fn match_pair(&mut self, lvalue: Lvalue<'tcx>, pattern: PatternRef<'tcx>)\n+    pub fn match_pair(&mut self,\n+                      lvalue: Lvalue<'tcx>,\n+                      pattern: PatternRef<'tcx>)\n                       -> MatchPair<'tcx> {\n         let pattern = self.hir.mirror(pattern);\n         MatchPair::new(lvalue, pattern)\n@@ -54,17 +56,18 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                                prefix: Vec<PatternRef<'tcx>>,\n                                opt_slice: Option<PatternRef<'tcx>>,\n                                suffix: Vec<PatternRef<'tcx>>)\n-                               -> BlockAnd<()>\n-    {\n+                               -> BlockAnd<()> {\n         // If there is a `..P` pattern, create a temporary `t0` for\n         // the slice and then a match pair `t0 @ P`:\n         if let Some(slice) = opt_slice {\n             let slice = self.hir.mirror(slice);\n             let prefix_len = prefix.len();\n             let suffix_len = suffix.len();\n-            let rvalue = Rvalue::Slice { input: lvalue.clone(),\n-                                         from_start: prefix_len,\n-                                         from_end: suffix_len };\n+            let rvalue = Rvalue::Slice {\n+                input: lvalue.clone(),\n+                from_start: prefix_len,\n+                from_end: suffix_len,\n+            };\n             let temp = self.temp(slice.ty.clone()); // no need to schedule drop, temp is always copy\n             self.cfg.push_assign(block, slice.span, &temp, rvalue);\n             match_pairs.push(MatchPair::new(temp, slice));\n@@ -80,8 +83,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                      match_pairs: &mut Vec<MatchPair<'tcx>>,\n                      lvalue: Lvalue<'tcx>,\n                      prefix: Vec<PatternRef<'tcx>>,\n-                     suffix: Vec<PatternRef<'tcx>>)\n-    {\n+                     suffix: Vec<PatternRef<'tcx>>) {\n         let min_length = prefix.len() + suffix.len();\n         assert!(min_length < u32::MAX as usize);\n         let min_length = min_length as u32;\n@@ -121,6 +123,9 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n impl<'tcx> MatchPair<'tcx> {\n     pub fn new(lvalue: Lvalue<'tcx>, pattern: Pattern<'tcx>) -> MatchPair<'tcx> {\n-        MatchPair { lvalue: lvalue, pattern: pattern }\n+        MatchPair {\n+            lvalue: lvalue,\n+            pattern: pattern,\n+        }\n     }\n }"}, {"sha": "86b6df19b77e73a55f0aae1e902c83bd7272093c", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=c73e78ce649ff9d40ba74a2c9338c7b2caac4920", "patch": "@@ -41,16 +41,16 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                         literal: Literal<'tcx>)\n                         -> Lvalue<'tcx> {\n         let temp = self.temp(ty.clone());\n-        let constant = Constant { span: span, ty: ty, literal: literal };\n+        let constant = Constant {\n+            span: span,\n+            ty: ty,\n+            literal: literal,\n+        };\n         self.cfg.push_assign_constant(block, span, &temp, constant);\n         temp\n     }\n \n-    pub fn push_usize(&mut self,\n-                      block: BasicBlock,\n-                      span: Span,\n-                      value: usize)\n-                      -> Lvalue<'tcx> {\n+    pub fn push_usize(&mut self, block: BasicBlock, span: Span, value: usize) -> Lvalue<'tcx> {\n         let usize_ty = self.hir.usize_ty();\n         let temp = self.temp(usize_ty);\n         self.cfg.push_assign_constant(\n@@ -68,7 +68,10 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                          span: Span,\n                          item_ref: ItemRef<'tcx>)\n                          -> Lvalue<'tcx> {\n-        let literal = Literal::Item { def_id: item_ref.def_id, substs: item_ref.substs };\n+        let literal = Literal::Item {\n+            def_id: item_ref.def_id,\n+            substs: item_ref.substs,\n+        };\n         self.push_literal(block, span, item_ref.ty, literal)\n     }\n }"}, {"sha": "857540e2109c02e7a51b7b45e25e385c238038de", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=c73e78ce649ff9d40ba74a2c9338c7b2caac4920", "patch": "@@ -18,7 +18,7 @@ use syntax::ast;\n use syntax::codemap::Span;\n use tcx::{Cx, PatNode};\n \n-struct Builder<'a,'tcx:'a> {\n+struct Builder<'a, 'tcx: 'a> {\n     hir: Cx<'a, 'tcx>,\n     extents: FnvHashMap<CodeExtent, Vec<GraphExtent>>,\n     cfg: CFG<'tcx>,\n@@ -31,7 +31,7 @@ struct Builder<'a,'tcx:'a> {\n }\n \n struct CFG<'tcx> {\n-    basic_blocks: Vec<BasicBlockData<'tcx>>\n+    basic_blocks: Vec<BasicBlockData<'tcx>>,\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -75,13 +75,13 @@ macro_rules! unpack {\n ///////////////////////////////////////////////////////////////////////////\n // construct() -- the main entry point for building MIR for a function\n \n-pub fn construct<'a,'tcx>(mut hir: Cx<'a,'tcx>,\n-                          _span: Span,\n-                          implicit_arguments: Vec<Ty<'tcx>>,\n-                          explicit_arguments: Vec<(Ty<'tcx>, PatNode<'tcx>)>,\n-                          argument_extent: CodeExtent,\n-                          ast_block: &'tcx hir::Block)\n-                          -> Mir<'tcx> {\n+pub fn construct<'a, 'tcx>(mut hir: Cx<'a, 'tcx>,\n+                           _span: Span,\n+                           implicit_arguments: Vec<Ty<'tcx>>,\n+                           explicit_arguments: Vec<(Ty<'tcx>, PatNode<'tcx>)>,\n+                           argument_extent: CodeExtent,\n+                           ast_block: &'tcx hir::Block)\n+                           -> Mir<'tcx> {\n     let cfg = CFG { basic_blocks: vec![] };\n \n     // it's handy to have a temporary of type `()` sometimes, so make\n@@ -115,7 +115,7 @@ pub fn construct<'a,'tcx>(mut hir: Cx<'a,'tcx>,\n     builder.cfg.terminate(block, Terminator::Goto { target: END_BLOCK });\n     builder.cfg.terminate(END_BLOCK, Terminator::Return);\n \n-    Mir  {\n+    Mir {\n         basic_blocks: builder.cfg.basic_blocks,\n         extents: builder.extents,\n         var_decls: builder.var_decls,\n@@ -177,4 +177,3 @@ mod matches;\n mod misc;\n mod scope;\n mod stmt;\n-"}, {"sha": "cecd610ff725ff39c45a409c12bc842cebb747f4", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=c73e78ce649ff9d40ba74a2c9338c7b2caac4920", "patch": "@@ -101,25 +101,27 @@ pub struct Scope<'tcx> {\n \n #[derive(Clone, Debug)]\n pub struct LoopScope {\n-    pub extent: CodeExtent,      // extent of the loop\n+    pub extent: CodeExtent, // extent of the loop\n     pub continue_block: BasicBlock, // where to go on a `loop`\n-    pub break_block: BasicBlock,    // where to go on a `break\n+    pub break_block: BasicBlock, // where to go on a `break\n }\n \n impl<'a,'tcx> Builder<'a,'tcx> {\n     /// Start a loop scope, which tracks where `continue` and `break`\n     /// should branch to. See module comment for more details.\n-    pub fn in_loop_scope<F,R>(&mut self,\n-                              loop_block: BasicBlock,\n-                              break_block: BasicBlock,\n-                              f: F)\n-                              -> BlockAnd<R>\n-        where F: FnOnce(&mut Builder<'a,'tcx>) -> BlockAnd<R>\n+    pub fn in_loop_scope<F, R>(&mut self,\n+                               loop_block: BasicBlock,\n+                               break_block: BasicBlock,\n+                               f: F)\n+                               -> BlockAnd<R>\n+        where F: FnOnce(&mut Builder<'a, 'tcx>) -> BlockAnd<R>\n     {\n         let extent = self.extent_of_innermost_scope().unwrap();\n-        let loop_scope = LoopScope { extent: extent.clone(),\n-                                     continue_block: loop_block,\n-                                     break_block: break_block };\n+        let loop_scope = LoopScope {\n+            extent: extent.clone(),\n+            continue_block: loop_block,\n+            break_block: break_block,\n+        };\n         self.loop_scopes.push(loop_scope);\n         let r = f(self);\n         assert!(self.loop_scopes.pop().unwrap().extent == extent);\n@@ -128,12 +130,8 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n     /// Start a scope. The closure `f` should translate the contents\n     /// of the scope. See module comment for more details.\n-    pub fn in_scope<F,R>(&mut self,\n-                         extent: CodeExtent,\n-                         block: BasicBlock,\n-                         f: F)\n-                         -> BlockAnd<R>\n-        where F: FnOnce(&mut Builder<'a,'tcx>) -> BlockAnd<R>\n+    pub fn in_scope<F, R>(&mut self, extent: CodeExtent, block: BasicBlock, f: F) -> BlockAnd<R>\n+        where F: FnOnce(&mut Builder<'a, 'tcx>) -> BlockAnd<R>\n     {\n         debug!(\"in_scope(extent={:?}, block={:?})\", extent, block);\n \n@@ -173,9 +171,15 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     /// exit points.\n     fn graph_extent(&self, entry: ExecutionPoint, exits: Vec<ExecutionPoint>) -> GraphExtent {\n         if exits.len() == 1 && entry.block == exits[0].block {\n-            GraphExtent { entry: entry, exit: GraphExtentExit::Statement(exits[0].statement) }\n+            GraphExtent {\n+                entry: entry,\n+                exit: GraphExtentExit::Statement(exits[0].statement),\n+            }\n         } else {\n-            GraphExtent { entry: entry, exit: GraphExtentExit::Points(exits) }\n+            GraphExtent {\n+                entry: entry,\n+                exit: GraphExtentExit::Points(exits),\n+            }\n         }\n     }\n \n@@ -204,7 +208,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n \n         match loop_scope {\n             Some(loop_scope) => loop_scope.clone(),\n-            None => self.hir.span_bug(span, \"no enclosing loop scope found?\")\n+            None => self.hir.span_bug(span, \"no enclosing loop scope found?\"),\n         }\n     }\n \n@@ -255,8 +259,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                          extent: CodeExtent,\n                          kind: DropKind,\n                          lvalue: &Lvalue<'tcx>,\n-                         lvalue_ty: Ty<'tcx>)\n-    {\n+                         lvalue_ty: Ty<'tcx>) {\n         if self.hir.needs_drop(lvalue_ty, span) {\n             match self.scopes.iter_mut().rev().find(|s| s.extent == extent) {\n                 Some(scope) => {\n@@ -278,9 +281,7 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n     }\n }\n \n-fn diverge_cleanup_helper<'tcx>(cfg: &mut CFG<'tcx>,\n-                                scopes: &mut [Scope<'tcx>])\n-                                -> BasicBlock {\n+fn diverge_cleanup_helper<'tcx>(cfg: &mut CFG<'tcx>, scopes: &mut [Scope<'tcx>]) -> BasicBlock {\n     let len = scopes.len();\n \n     if len == 0 {"}, {"sha": "9da05a27e898deefd2d5887e4b4d78027fe37fe6", "filename": "src/librustc_mir/graphviz/mod.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fgraphviz%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fgraphviz%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fgraphviz%2Fmod.rs?ref=c73e78ce649ff9d40ba74a2c9338c7b2caac4920", "patch": "@@ -70,15 +70,18 @@ impl<'a,'tcx> dot::GraphWalk<'a, BasicBlock, EdgeIndex> for Mir<'tcx> {\n         self.all_basic_blocks()\n             .into_iter()\n             .flat_map(|source| {\n-                self.basic_block_data(source).terminator\n-                                             .successors()\n-                                             .iter()\n-                                             .enumerate()\n-                                             .map(move |(index, &target)| {\n-                                                 EdgeIndex { source: source,\n-                                                             target: target,\n-                                                             index: index }\n-                                             })\n+                self.basic_block_data(source)\n+                    .terminator\n+                    .successors()\n+                    .iter()\n+                    .enumerate()\n+                    .map(move |(index, &target)| {\n+                        EdgeIndex {\n+                            source: source,\n+                            target: target,\n+                            index: index,\n+                        }\n+                    })\n             })\n             .collect::<Vec<_>>()\n             .into_cow()\n@@ -118,7 +121,10 @@ fn all_to_subscript(header: &str, mut text: String) -> String {\n     /// Returns an updated string if changes were made, else None.\n     fn to_subscript1(header: &str, text: &str, offset: &mut usize) -> Option<String> {\n         let a = match text[*offset..].find(header) {\n-            None => { *offset = text.len(); return None; }\n+            None => {\n+                *offset = text.len();\n+                return None;\n+            }\n             Some(a) => a + *offset,\n         };\n \n@@ -141,8 +147,12 @@ fn all_to_subscript(header: &str, mut text: String) -> String {\n         result.push_str(&text[..b]);\n \n         while let Some(c) = chars.next() {\n-            if c == ')' { break; }\n-            if !c.is_digit(10) { return None; }\n+            if c == ')' {\n+                break;\n+            }\n+            if !c.is_digit(10) {\n+                return None;\n+            }\n \n             // 0x208 is _0 in unicode, 0x209 is _1, etc\n             const SUBSCRIPTS: &'static str = \"\u2080\u2081\u2082\u2083\u2084\u2085\u2086\u2087\u2088\u2089\";"}, {"sha": "641cbae4be27101497259972a4d4d237ef6d5578", "filename": "src/librustc_mir/hair.rs", "status": "modified", "additions": 168, "deletions": 69, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fhair.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fhair.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair.rs?ref=c73e78ce649ff9d40ba74a2c9338c7b2caac4920", "patch": "@@ -58,7 +58,7 @@ pub enum StmtKind<'tcx> {\n         scope: CodeExtent,\n \n         /// expression being evaluated in this statement\n-        expr: ExprRef<'tcx>\n+        expr: ExprRef<'tcx>,\n     },\n \n     Let {\n@@ -77,7 +77,7 @@ pub enum StmtKind<'tcx> {\n         initializer: Option<ExprRef<'tcx>>,\n \n         /// let pat = init; <STMTS>\n-        stmts: Vec<StmtRef<'tcx>>\n+        stmts: Vec<StmtRef<'tcx>>,\n     },\n }\n \n@@ -113,45 +113,128 @@ pub struct Expr<'tcx> {\n \n #[derive(Clone, Debug)]\n pub enum ExprKind<'tcx> {\n-    Scope { extent: CodeExtent, value: ExprRef<'tcx> },\n-    Box { value: ExprRef<'tcx> },\n-    Call { fun: ExprRef<'tcx>, args: Vec<ExprRef<'tcx>> },\n-    Deref { arg: ExprRef<'tcx> }, // NOT overloaded!\n-    Binary { op: BinOp, lhs: ExprRef<'tcx>, rhs: ExprRef<'tcx> }, // NOT overloaded!\n-    LogicalOp { op: LogicalOp, lhs: ExprRef<'tcx>, rhs: ExprRef<'tcx> },\n-    Unary { op: UnOp, arg: ExprRef<'tcx> }, // NOT overloaded!\n-    Cast { source: ExprRef<'tcx> },\n-    ReifyFnPointer { source: ExprRef<'tcx> },\n-    UnsafeFnPointer { source: ExprRef<'tcx> },\n-    Unsize { source: ExprRef<'tcx> },\n-    If { condition: ExprRef<'tcx>, then: ExprRef<'tcx>, otherwise: Option<ExprRef<'tcx>> },\n-    Loop { condition: Option<ExprRef<'tcx>>, body: ExprRef<'tcx>, },\n-    Match { discriminant: ExprRef<'tcx>, arms: Vec<Arm<'tcx>> },\n-    Block { body: &'tcx hir::Block },\n-    Assign { lhs: ExprRef<'tcx>, rhs: ExprRef<'tcx> },\n-    AssignOp { op: BinOp, lhs: ExprRef<'tcx>, rhs: ExprRef<'tcx> },\n-    Field { lhs: ExprRef<'tcx>, name: Field },\n-    Index { lhs: ExprRef<'tcx>, index: ExprRef<'tcx> },\n-    VarRef { id: ast::NodeId },\n+    Scope {\n+        extent: CodeExtent,\n+        value: ExprRef<'tcx>,\n+    },\n+    Box {\n+        value: ExprRef<'tcx>,\n+    },\n+    Call {\n+        fun: ExprRef<'tcx>,\n+        args: Vec<ExprRef<'tcx>>,\n+    },\n+    Deref {\n+        arg: ExprRef<'tcx>,\n+    }, // NOT overloaded!\n+    Binary {\n+        op: BinOp,\n+        lhs: ExprRef<'tcx>,\n+        rhs: ExprRef<'tcx>,\n+    }, // NOT overloaded!\n+    LogicalOp {\n+        op: LogicalOp,\n+        lhs: ExprRef<'tcx>,\n+        rhs: ExprRef<'tcx>,\n+    },\n+    Unary {\n+        op: UnOp,\n+        arg: ExprRef<'tcx>,\n+    }, // NOT overloaded!\n+    Cast {\n+        source: ExprRef<'tcx>,\n+    },\n+    ReifyFnPointer {\n+        source: ExprRef<'tcx>,\n+    },\n+    UnsafeFnPointer {\n+        source: ExprRef<'tcx>,\n+    },\n+    Unsize {\n+        source: ExprRef<'tcx>,\n+    },\n+    If {\n+        condition: ExprRef<'tcx>,\n+        then: ExprRef<'tcx>,\n+        otherwise: Option<ExprRef<'tcx>>,\n+    },\n+    Loop {\n+        condition: Option<ExprRef<'tcx>>,\n+        body: ExprRef<'tcx>,\n+    },\n+    Match {\n+        discriminant: ExprRef<'tcx>,\n+        arms: Vec<Arm<'tcx>>,\n+    },\n+    Block {\n+        body: &'tcx hir::Block,\n+    },\n+    Assign {\n+        lhs: ExprRef<'tcx>,\n+        rhs: ExprRef<'tcx>,\n+    },\n+    AssignOp {\n+        op: BinOp,\n+        lhs: ExprRef<'tcx>,\n+        rhs: ExprRef<'tcx>,\n+    },\n+    Field {\n+        lhs: ExprRef<'tcx>,\n+        name: Field,\n+    },\n+    Index {\n+        lhs: ExprRef<'tcx>,\n+        index: ExprRef<'tcx>,\n+    },\n+    VarRef {\n+        id: ast::NodeId,\n+    },\n     SelfRef, // first argument, used for self in a closure\n-    StaticRef { id: DefId },\n-    Borrow { region: Region, borrow_kind: BorrowKind, arg: ExprRef<'tcx> },\n-    Break { label: Option<CodeExtent> },\n-    Continue { label: Option<CodeExtent> },\n-    Return { value: Option<ExprRef<'tcx>> },\n-    Repeat { value: ExprRef<'tcx>, count: ExprRef<'tcx> },\n-    Vec { fields: Vec<ExprRef<'tcx>> },\n-    Tuple { fields: Vec<ExprRef<'tcx>> },\n-    Adt { adt_def: AdtDef<'tcx>,\n-          variant_index: usize,\n-          substs: &'tcx Substs<'tcx>,\n-          fields: Vec<FieldExprRef<'tcx>>,\n-          base: Option<ExprRef<'tcx>> },\n-    Closure { closure_id: DefId,\n-              substs: &'tcx ClosureSubsts<'tcx>,\n-              upvars: Vec<ExprRef<'tcx>> },\n-    Literal { literal: Literal<'tcx> },\n-    InlineAsm { asm: &'tcx hir::InlineAsm },\n+    StaticRef {\n+        id: DefId,\n+    },\n+    Borrow {\n+        region: Region,\n+        borrow_kind: BorrowKind,\n+        arg: ExprRef<'tcx>,\n+    },\n+    Break {\n+        label: Option<CodeExtent>,\n+    },\n+    Continue {\n+        label: Option<CodeExtent>,\n+    },\n+    Return {\n+        value: Option<ExprRef<'tcx>>,\n+    },\n+    Repeat {\n+        value: ExprRef<'tcx>,\n+        count: ExprRef<'tcx>,\n+    },\n+    Vec {\n+        fields: Vec<ExprRef<'tcx>>,\n+    },\n+    Tuple {\n+        fields: Vec<ExprRef<'tcx>>,\n+    },\n+    Adt {\n+        adt_def: AdtDef<'tcx>,\n+        variant_index: usize,\n+        substs: &'tcx Substs<'tcx>,\n+        fields: Vec<FieldExprRef<'tcx>>,\n+        base: Option<ExprRef<'tcx>>,\n+    },\n+    Closure {\n+        closure_id: DefId,\n+        substs: &'tcx ClosureSubsts<'tcx>,\n+        upvars: Vec<ExprRef<'tcx>>,\n+    },\n+    Literal {\n+        literal: Literal<'tcx>,\n+    },\n+    InlineAsm {\n+        asm: &'tcx hir::InlineAsm,\n+    },\n }\n \n #[derive(Clone, Debug)]\n@@ -183,44 +266,61 @@ pub struct Pattern<'tcx> {\n #[derive(Copy, Clone, Debug)]\n pub enum LogicalOp {\n     And,\n-    Or\n+    Or,\n }\n \n #[derive(Clone, Debug)]\n pub enum PatternKind<'tcx> {\n     Wild,\n \n     // x, ref x, x @ P, etc\n-    Binding { mutability: Mutability,\n-              name: ast::Name,\n-              mode: BindingMode,\n-              var: ast::NodeId,\n-              ty: Ty<'tcx>,\n-              subpattern: Option<PatternRef<'tcx>> },\n+    Binding {\n+        mutability: Mutability,\n+        name: ast::Name,\n+        mode: BindingMode,\n+        var: ast::NodeId,\n+        ty: Ty<'tcx>,\n+        subpattern: Option<PatternRef<'tcx>>,\n+    },\n \n     // Foo(...) or Foo{...} or Foo, where `Foo` is a variant name from an adt with >1 variants\n-    Variant { adt_def: AdtDef<'tcx>,\n-              variant_index: usize,\n-              subpatterns: Vec<FieldPatternRef<'tcx>> },\n+    Variant {\n+        adt_def: AdtDef<'tcx>,\n+        variant_index: usize,\n+        subpatterns: Vec<FieldPatternRef<'tcx>>,\n+    },\n \n     // (...), Foo(...), Foo{...}, or Foo, where `Foo` is a variant name from an adt with 1 variant\n-    Leaf { subpatterns: Vec<FieldPatternRef<'tcx>> },\n+    Leaf {\n+        subpatterns: Vec<FieldPatternRef<'tcx>>,\n+    },\n \n-    Deref { subpattern: PatternRef<'tcx> }, // box P, &P, &mut P, etc\n+    Deref {\n+        subpattern: PatternRef<'tcx>,\n+    }, // box P, &P, &mut P, etc\n \n-    Constant { value: Literal<'tcx> },\n+    Constant {\n+        value: Literal<'tcx>,\n+    },\n \n-    Range { lo: Literal<'tcx>, hi: Literal<'tcx> },\n+    Range {\n+        lo: Literal<'tcx>,\n+        hi: Literal<'tcx>,\n+    },\n \n     // matches against a slice, checking the length and extracting elements\n-    Slice { prefix: Vec<PatternRef<'tcx>>,\n-            slice: Option<PatternRef<'tcx>>,\n-            suffix: Vec<PatternRef<'tcx>> },\n+    Slice {\n+        prefix: Vec<PatternRef<'tcx>>,\n+        slice: Option<PatternRef<'tcx>>,\n+        suffix: Vec<PatternRef<'tcx>>,\n+    },\n \n     // fixed match against an array, irrefutable\n-    Array { prefix: Vec<PatternRef<'tcx>>,\n-            slice: Option<PatternRef<'tcx>>,\n-            suffix: Vec<PatternRef<'tcx>> },\n+    Array {\n+        prefix: Vec<PatternRef<'tcx>>,\n+        slice: Option<PatternRef<'tcx>>,\n+        suffix: Vec<PatternRef<'tcx>>,\n+    },\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -259,21 +359,21 @@ pub struct FieldPatternRef<'tcx> {\n pub trait Mirror<'tcx> {\n     type Output;\n \n-    fn make_mirror<'a>(self, cx: &mut Cx<'a,'tcx>) -> Self::Output;\n+    fn make_mirror<'a>(self, cx: &mut Cx<'a, 'tcx>) -> Self::Output;\n }\n \n impl<'tcx> Mirror<'tcx> for Expr<'tcx> {\n     type Output = Expr<'tcx>;\n \n-    fn make_mirror<'a>(self, _: &mut Cx<'a,'tcx>) -> Expr<'tcx> {\n+    fn make_mirror<'a>(self, _: &mut Cx<'a, 'tcx>) -> Expr<'tcx> {\n         self\n     }\n }\n \n impl<'tcx> Mirror<'tcx> for ExprRef<'tcx> {\n     type Output = Expr<'tcx>;\n \n-    fn make_mirror<'a>(self, hir: &mut Cx<'a,'tcx>) -> Expr<'tcx> {\n+    fn make_mirror<'a>(self, hir: &mut Cx<'a, 'tcx>) -> Expr<'tcx> {\n         match self {\n             ExprRef::Hair(h) => h.make_mirror(hir),\n             ExprRef::Mirror(m) => *m,\n@@ -284,15 +384,15 @@ impl<'tcx> Mirror<'tcx> for ExprRef<'tcx> {\n impl<'tcx> Mirror<'tcx> for Stmt<'tcx> {\n     type Output = Stmt<'tcx>;\n \n-    fn make_mirror<'a>(self, _: &mut Cx<'a,'tcx>) -> Stmt<'tcx> {\n+    fn make_mirror<'a>(self, _: &mut Cx<'a, 'tcx>) -> Stmt<'tcx> {\n         self\n     }\n }\n \n impl<'tcx> Mirror<'tcx> for StmtRef<'tcx> {\n     type Output = Stmt<'tcx>;\n \n-    fn make_mirror<'a>(self, hir: &mut Cx<'a,'tcx>) -> Stmt<'tcx> {\n+    fn make_mirror<'a>(self, hir: &mut Cx<'a, 'tcx>) -> Stmt<'tcx> {\n         match self {\n             StmtRef::Hair(h) => h.make_mirror(hir),\n             StmtRef::Mirror(m) => *m,\n@@ -303,15 +403,15 @@ impl<'tcx> Mirror<'tcx> for StmtRef<'tcx> {\n impl<'tcx> Mirror<'tcx> for Pattern<'tcx> {\n     type Output = Pattern<'tcx>;\n \n-    fn make_mirror<'a>(self, _: &mut Cx<'a,'tcx>) -> Pattern<'tcx> {\n+    fn make_mirror<'a>(self, _: &mut Cx<'a, 'tcx>) -> Pattern<'tcx> {\n         self\n     }\n }\n \n impl<'tcx> Mirror<'tcx> for PatternRef<'tcx> {\n     type Output = Pattern<'tcx>;\n \n-    fn make_mirror<'a>(self, hir: &mut Cx<'a,'tcx>) -> Pattern<'tcx> {\n+    fn make_mirror<'a>(self, hir: &mut Cx<'a, 'tcx>) -> Pattern<'tcx> {\n         match self {\n             PatternRef::Hair(h) => h.make_mirror(hir),\n             PatternRef::Mirror(m) => *m,\n@@ -322,8 +422,7 @@ impl<'tcx> Mirror<'tcx> for PatternRef<'tcx> {\n impl<'tcx> Mirror<'tcx> for Block<'tcx> {\n     type Output = Block<'tcx>;\n \n-    fn make_mirror<'a>(self, _: &mut Cx<'a,'tcx>) -> Block<'tcx> {\n+    fn make_mirror<'a>(self, _: &mut Cx<'a, 'tcx>) -> Block<'tcx> {\n         self\n     }\n }\n-"}, {"sha": "1acbc8d733d5cea2a99df35490efcfb0a1fb0cd3", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 51, "deletions": 59, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=c73e78ce649ff9d40ba74a2c9338c7b2caac4920", "patch": "@@ -39,10 +39,13 @@ use self::syntax::codemap::Span;\n \n pub type MirMap<'tcx> = NodeMap<Mir<'tcx>>;\n \n-pub fn build_mir_for_crate<'tcx>(tcx: &ty::ctxt<'tcx>) -> MirMap<'tcx>{\n+pub fn build_mir_for_crate<'tcx>(tcx: &ty::ctxt<'tcx>) -> MirMap<'tcx> {\n     let mut map = NodeMap();\n     {\n-        let mut dump = OuterDump { tcx: tcx, map: &mut map };\n+        let mut dump = OuterDump {\n+            tcx: tcx,\n+            map: &mut map,\n+        };\n         visit::walk_crate(&mut dump, tcx.map.krate());\n     }\n     map\n@@ -51,16 +54,20 @@ pub fn build_mir_for_crate<'tcx>(tcx: &ty::ctxt<'tcx>) -> MirMap<'tcx>{\n ///////////////////////////////////////////////////////////////////////////\n // OuterDump -- walks a crate, looking for fn items and methods to build MIR from\n \n-struct OuterDump<'a,'tcx:'a> {\n+struct OuterDump<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n     map: &'a mut MirMap<'tcx>,\n }\n \n impl<'a, 'tcx> OuterDump<'a, 'tcx> {\n     fn visit_mir<OP>(&mut self, attributes: &'a [ast::Attribute], mut walk_op: OP)\n-        where OP: for<'m> FnMut(&mut InnerDump<'a,'m,'tcx>)\n+        where OP: for<'m> FnMut(&mut InnerDump<'a, 'm, 'tcx>)\n     {\n-        let mut closure_dump = InnerDump { tcx: self.tcx, attr: None, map: &mut *self.map };\n+        let mut closure_dump = InnerDump {\n+            tcx: self.tcx,\n+            attr: None,\n+            map: &mut *self.map,\n+        };\n         for attr in attributes {\n             if attr.check_name(\"rustc_mir\") {\n                 closure_dump.attr = Some(attr);\n@@ -84,8 +91,7 @@ impl<'a, 'tcx> visit::Visitor<'tcx> for OuterDump<'a, 'tcx> {\n             }\n             hir::MethodTraitItem(_, None) |\n             hir::ConstTraitItem(..) |\n-            hir::TypeTraitItem(..) => {\n-            }\n+            hir::TypeTraitItem(..) => {}\n         }\n         visit::walk_trait_item(self, trait_item);\n     }\n@@ -95,7 +101,7 @@ impl<'a, 'tcx> visit::Visitor<'tcx> for OuterDump<'a, 'tcx> {\n             hir::MethodImplItem(..) => {\n                 self.visit_mir(&impl_item.attrs, |c| visit::walk_impl_item(c, impl_item));\n             }\n-            hir::ConstImplItem(..) | hir::TypeImplItem(..) => { }\n+            hir::ConstImplItem(..) | hir::TypeImplItem(..) => {}\n         }\n         visit::walk_impl_item(self, impl_item);\n     }\n@@ -104,7 +110,7 @@ impl<'a, 'tcx> visit::Visitor<'tcx> for OuterDump<'a, 'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // InnerDump -- dumps MIR for a single fn and its contained closures\n \n-struct InnerDump<'a,'m,'tcx:'a+'m> {\n+struct InnerDump<'a, 'm, 'tcx: 'a + 'm> {\n     tcx: &'a ty::ctxt<'tcx>,\n     map: &'m mut MirMap<'tcx>,\n     attr: Option<&'a ast::Attribute>,\n@@ -136,21 +142,16 @@ impl<'a, 'm, 'tcx> visit::Visitor<'tcx> for InnerDump<'a,'m,'tcx> {\n                 (format!(\"\"), vec![]),\n         };\n \n-        let param_env =\n-            ty::ParameterEnvironment::for_item(self.tcx, id);\n+        let param_env = ty::ParameterEnvironment::for_item(self.tcx, id);\n \n-        let infcx =\n-            infer::new_infer_ctxt(self.tcx,\n-                                  &self.tcx.tables,\n-                                  Some(param_env),\n-                                  true);\n+        let infcx = infer::new_infer_ctxt(self.tcx, &self.tcx.tables, Some(param_env), true);\n \n         match build_mir(Cx::new(&infcx), implicit_arg_tys, id, span, decl, body) {\n             Ok(mir) => {\n-                let meta_item_list =\n-                    self.attr.iter()\n-                             .flat_map(|a| a.meta_item_list())\n-                             .flat_map(|l| l.iter());\n+                let meta_item_list = self.attr\n+                                         .iter()\n+                                         .flat_map(|a| a.meta_item_list())\n+                                         .flat_map(|l| l.iter());\n                 for item in meta_item_list {\n                     if item.check_name(\"graphviz\") {\n                         match item.value_str() {\n@@ -181,58 +182,49 @@ impl<'a, 'm, 'tcx> visit::Visitor<'tcx> for InnerDump<'a,'m,'tcx> {\n                 let previous = self.map.insert(id, mir);\n                 assert!(previous.is_none());\n             }\n-            Err(ErrorReported) => { }\n+            Err(ErrorReported) => {}\n         }\n \n         visit::walk_fn(self, fk, decl, body, span);\n     }\n }\n \n-fn build_mir<'a,'tcx:'a>(cx: Cx<'a,'tcx>,\n-                         implicit_arg_tys: Vec<Ty<'tcx>>,\n-                         fn_id: ast::NodeId,\n-                         span: Span,\n-                         decl: &'tcx hir::FnDecl,\n-                         body: &'tcx hir::Block)\n-                         -> Result<Mir<'tcx>, ErrorReported> {\n-    let arguments =\n-        decl.inputs\n-            .iter()\n-            .map(|arg| {\n-                let ty = cx.tcx().node_id_to_type(arg.id);\n-                (ty, PatNode::irrefutable(&arg.pat))\n-            })\n-            .collect();\n-\n-    let parameter_scope =\n-        cx.tcx().region_maps.lookup_code_extent(\n-            CodeExtentData::ParameterScope { fn_id: fn_id, body_id: body.id });\n-    Ok(build::construct(cx,\n-                        span,\n-                        implicit_arg_tys,\n-                        arguments,\n-                        parameter_scope,\n-                        body))\n+fn build_mir<'a, 'tcx: 'a>(cx: Cx<'a, 'tcx>,\n+                           implicit_arg_tys: Vec<Ty<'tcx>>,\n+                           fn_id: ast::NodeId,\n+                           span: Span,\n+                           decl: &'tcx hir::FnDecl,\n+                           body: &'tcx hir::Block)\n+                           -> Result<Mir<'tcx>, ErrorReported> {\n+    let arguments = decl.inputs\n+                        .iter()\n+                        .map(|arg| {\n+                            let ty = cx.tcx().node_id_to_type(arg.id);\n+                            (ty, PatNode::irrefutable(&arg.pat))\n+                        })\n+                        .collect();\n+\n+    let parameter_scope = cx.tcx().region_maps.lookup_code_extent(CodeExtentData::ParameterScope {\n+        fn_id: fn_id,\n+        body_id: body.id,\n+    });\n+    Ok(build::construct(cx, span, implicit_arg_tys, arguments, parameter_scope, body))\n }\n \n-fn closure_self_ty<'a,'tcx>(tcx: &ty::ctxt<'tcx>,\n-                            closure_expr_id: ast::NodeId,\n-                            body_id: ast::NodeId)\n-                            -> Ty<'tcx>\n-{\n+fn closure_self_ty<'a, 'tcx>(tcx: &ty::ctxt<'tcx>,\n+                             closure_expr_id: ast::NodeId,\n+                             body_id: ast::NodeId)\n+                             -> Ty<'tcx> {\n     let closure_ty = tcx.node_id_to_type(closure_expr_id);\n \n     // We're just hard-coding the idea that the signature will be\n     // &self or &mut self and hence will have a bound region with\n     // number 0, hokey.\n-    let region =\n-        ty::Region::ReFree(\n-            ty::FreeRegion {\n-                scope: tcx.region_maps.item_extent(body_id),\n-                bound_region: ty::BoundRegion::BrAnon(0)\n-            });\n-    let region =\n-        tcx.mk_region(region);\n+    let region = ty::Region::ReFree(ty::FreeRegion {\n+        scope: tcx.region_maps.item_extent(body_id),\n+        bound_region: ty::BoundRegion::BrAnon(0),\n+    });\n+    let region = tcx.mk_region(region);\n \n     match tcx.closure_kind(tcx.map.local_def_id(closure_expr_id)) {\n         ty::ClosureKind::FnClosureKind =>"}, {"sha": "48db0de3cecb4df6182099c3700c0126085b4a2d", "filename": "src/librustc_mir/repr.rs", "status": "modified", "additions": 42, "deletions": 20, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Frepr.rs?ref=c73e78ce649ff9d40ba74a2c9338c7b2caac4920", "patch": "@@ -110,7 +110,7 @@ pub enum BorrowKind {\n     Unique,\n \n     /// Data is mutable and not aliasable.\n-    Mut\n+    Mut,\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -226,17 +226,27 @@ pub struct BasicBlockData<'tcx> {\n \n pub enum Terminator<'tcx> {\n     /// block should have one successor in the graph; we jump there\n-    Goto { target: BasicBlock },\n+    Goto {\n+        target: BasicBlock,\n+    },\n \n     /// block should initiate unwinding; should be one successor\n     /// that does cleanup and branches to DIVERGE_BLOCK\n-    Panic { target: BasicBlock },\n+    Panic {\n+        target: BasicBlock,\n+    },\n \n     /// jump to branch 0 if this lvalue evaluates to true\n-    If { cond: Operand<'tcx>, targets: [BasicBlock; 2] },\n+    If {\n+        cond: Operand<'tcx>,\n+        targets: [BasicBlock; 2],\n+    },\n \n     /// lvalue evaluates to some enum; jump depending on the branch\n-    Switch { discr: Lvalue<'tcx>, targets: Vec<BasicBlock> },\n+    Switch {\n+        discr: Lvalue<'tcx>,\n+        targets: Vec<BasicBlock>,\n+    },\n \n     /// Indicates that the last statement in the block panics, aborts,\n     /// etc. No successors. This terminator appears on exactly one\n@@ -254,7 +264,10 @@ pub enum Terminator<'tcx> {\n     /// block ends with a call; it should have two successors. The\n     /// first successor indicates normal return. The second indicates\n     /// unwinding.\n-    Call { data: CallData<'tcx>, targets: [BasicBlock; 2] },\n+    Call {\n+        data: CallData<'tcx>,\n+        targets: [BasicBlock; 2],\n+    },\n }\n \n impl<'tcx> Terminator<'tcx> {\n@@ -312,7 +325,9 @@ impl<'tcx> Debug for Terminator<'tcx> {\n             Call { data: ref c, targets } => {\n                 try!(write!(fmt, \"{:?} = {:?}(\", c.destination, c.func));\n                 for (index, arg) in c.args.iter().enumerate() {\n-                    if index > 0 { try!(write!(fmt, \", \")); }\n+                    if index > 0 {\n+                        try!(write!(fmt, \", \"));\n+                    }\n                     try!(write!(fmt, \"{:?}\", arg));\n                 }\n                 write!(fmt, \") -> {:?}\", targets)\n@@ -339,7 +354,7 @@ pub enum StatementKind<'tcx> {\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum DropKind {\n     Shallow,\n-    Deep\n+    Deep,\n }\n \n impl<'tcx> Debug for Statement<'tcx> {\n@@ -376,21 +391,21 @@ pub enum Lvalue<'tcx> {\n     ReturnPointer,\n \n     /// projection out of an lvalue (access a field, deref a pointer, etc)\n-    Projection(Box<LvalueProjection<'tcx>>)\n+    Projection(Box<LvalueProjection<'tcx>>),\n }\n \n /// The `Projection` data structure defines things of the form `B.x`\n /// or `*B` or `B[index]`. Note that it is parameterized because it is\n /// shared between `Constant` and `Lvalue`. See the aliases\n /// `LvalueProjection` etc below.\n #[derive(Clone, Debug, PartialEq)]\n-pub struct Projection<'tcx,B,V> {\n+pub struct Projection<'tcx, B, V> {\n     pub base: B,\n-    pub elem: ProjectionElem<'tcx,V>,\n+    pub elem: ProjectionElem<'tcx, V>,\n }\n \n #[derive(Clone, Debug, PartialEq)]\n-pub enum ProjectionElem<'tcx,V> {\n+pub enum ProjectionElem<'tcx, V> {\n     Deref,\n     Field(Field),\n     Index(V),\n@@ -446,7 +461,10 @@ impl<'tcx> Lvalue<'tcx> {\n     }\n \n     pub fn elem(self, elem: LvalueElem<'tcx>) -> Lvalue<'tcx> {\n-        Lvalue::Projection(Box::new(LvalueProjection { base: self, elem: elem }))\n+        Lvalue::Projection(Box::new(LvalueProjection {\n+            base: self,\n+            elem: elem,\n+        }))\n     }\n }\n \n@@ -623,7 +641,7 @@ pub enum UnOp {\n     /// The `!` operator for logical inversion\n     Not,\n     /// The `-` operator for negation\n-    Neg\n+    Neg,\n }\n \n impl<'tcx> Debug for Rvalue<'tcx> {\n@@ -641,8 +659,8 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n             Box(ref t) => write!(fmt, \"Box {:?}\", t),\n             Aggregate(ref kind, ref lvs) => write!(fmt, \"Aggregate<{:?}>({:?})\", kind, lvs),\n             InlineAsm(ref asm) => write!(fmt, \"InlineAsm({:?})\", asm),\n-            Slice { ref input, from_start, from_end } => write!(fmt, \"{:?}[{:?}..-{:?}]\",\n-                                                                input, from_start, from_end),\n+            Slice { ref input, from_start, from_end } =>\n+                write!(fmt, \"{:?}[{:?}..-{:?}]\", input, from_start, from_end),\n         }\n     }\n }\n@@ -658,12 +676,16 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n pub struct Constant<'tcx> {\n     pub span: Span,\n     pub ty: Ty<'tcx>,\n-    pub literal: Literal<'tcx>\n+    pub literal: Literal<'tcx>,\n }\n \n #[derive(Clone, Debug, PartialEq)]\n pub enum Literal<'tcx> {\n-    Item { def_id: DefId, substs: &'tcx Substs<'tcx> },\n-    Value { value: ConstVal },\n+    Item {\n+        def_id: DefId,\n+        substs: &'tcx Substs<'tcx>,\n+    },\n+    Value {\n+        value: ConstVal,\n+    },\n }\n-"}, {"sha": "dc168bc7c2b6cad8ad15a45a8bd6263e062b58cf", "filename": "src/librustc_mir/tcx/block.rs", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Ftcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Ftcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fblock.rs?ref=c73e78ce649ff9d40ba74a2c9338c7b2caac4920", "patch": "@@ -21,35 +21,35 @@ use syntax::ptr::P;\n impl<'tcx> Mirror<'tcx> for &'tcx hir::Block {\n     type Output = Block<'tcx>;\n \n-    fn make_mirror<'a>(self, cx: &mut Cx<'a,'tcx>) -> Block<'tcx> {\n+    fn make_mirror<'a>(self, cx: &mut Cx<'a, 'tcx>) -> Block<'tcx> {\n         // We have to eagerly translate the \"spine\" of the statements\n         // in order to get the lexical scoping correctly.\n         let stmts = mirror_stmts(cx, self.id, self.stmts.iter().enumerate());\n         Block {\n             extent: cx.tcx.region_maps.node_extent(self.id),\n             span: self.span,\n             stmts: stmts,\n-            expr: self.expr.to_ref()\n+            expr: self.expr.to_ref(),\n         }\n     }\n }\n \n impl<'tcx> Mirror<'tcx> for &'tcx hir::Stmt {\n     type Output = Stmt<'tcx>;\n \n-    fn make_mirror<'a>(self, _cx: &mut Cx<'a,'tcx>) -> Stmt<'tcx> {\n+    fn make_mirror<'a>(self, _cx: &mut Cx<'a, 'tcx>) -> Stmt<'tcx> {\n         // In order to get the scoping correct, we eagerly mirror\n         // statements when we translate the enclosing block, so we\n         // should in fact never get to this point.\n         panic!(\"statements are eagerly mirrored\");\n     }\n }\n \n-fn mirror_stmts<'a,'tcx:'a,STMTS>(cx: &mut Cx<'a,'tcx>,\n-                                  block_id: ast::NodeId,\n-                                  mut stmts: STMTS)\n-                                  -> Vec<StmtRef<'tcx>>\n-    where STMTS: Iterator<Item=(usize, &'tcx P<hir::Stmt>)>\n+fn mirror_stmts<'a, 'tcx: 'a, STMTS>(cx: &mut Cx<'a, 'tcx>,\n+                                     block_id: ast::NodeId,\n+                                     mut stmts: STMTS)\n+                                     -> Vec<StmtRef<'tcx>>\n+    where STMTS: Iterator<Item = (usize, &'tcx P<hir::Stmt>)>\n {\n     let mut result = vec![];\n     while let Some((index, stmt)) = stmts.next() {\n@@ -68,7 +68,7 @@ fn mirror_stmts<'a,'tcx:'a,STMTS>(cx: &mut Cx<'a,'tcx>,\n                     hir::DeclLocal(ref local) => {\n                         let remainder_extent = CodeExtentData::Remainder(BlockRemainder {\n                             block: block_id,\n-                            first_statement_index: index as u32\n+                            first_statement_index: index as u32,\n                         });\n                         let remainder_extent =\n                             cx.tcx.region_maps.lookup_code_extent(remainder_extent);\n@@ -77,18 +77,16 @@ fn mirror_stmts<'a,'tcx:'a,STMTS>(cx: &mut Cx<'a,'tcx>,\n                         // they are within the scope of this let:\n                         let following_stmts = mirror_stmts(cx, block_id, stmts);\n \n-                        result.push(\n-                            StmtRef::Mirror(\n-                                Box::new(Stmt {\n-                                    span: stmt.span,\n-                                    kind: StmtKind::Let {\n-                                        remainder_scope: remainder_extent,\n-                                        init_scope: cx.tcx.region_maps.node_extent(id),\n-                                        pattern: PatNode::irrefutable(&local.pat).to_ref(),\n-                                        initializer: local.init.to_ref(),\n-                                        stmts: following_stmts\n-                                    }\n-                                })));\n+                        result.push(StmtRef::Mirror(Box::new(Stmt {\n+                            span: stmt.span,\n+                            kind: StmtKind::Let {\n+                                remainder_scope: remainder_extent,\n+                                init_scope: cx.tcx.region_maps.node_extent(id),\n+                                pattern: PatNode::irrefutable(&local.pat).to_ref(),\n+                                initializer: local.init.to_ref(),\n+                                stmts: following_stmts,\n+                            },\n+                        })));\n \n                         return result;\n                     }\n@@ -99,16 +97,14 @@ fn mirror_stmts<'a,'tcx:'a,STMTS>(cx: &mut Cx<'a,'tcx>,\n     return result;\n }\n \n-pub fn to_expr_ref<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n-                               block: &'tcx hir::Block)\n-                               -> ExprRef<'tcx> {\n+pub fn to_expr_ref<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, block: &'tcx hir::Block) -> ExprRef<'tcx> {\n     let block_ty = cx.tcx.node_id_to_type(block.id);\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(block.id);\n     let expr = Expr {\n         ty: block_ty,\n         temp_lifetime: temp_lifetime,\n         span: block.span,\n-        kind: ExprKind::Block { body: block }\n+        kind: ExprKind::Block { body: block },\n     };\n     expr.to_ref()\n }"}, {"sha": "9f7ecf522876f51e117ad86b45e83d5d768c210d", "filename": "src/librustc_mir/tcx/expr.rs", "status": "modified", "additions": 135, "deletions": 120, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fexpr.rs?ref=c73e78ce649ff9d40ba74a2c9338c7b2caac4920", "patch": "@@ -30,14 +30,13 @@ use syntax::ptr::P;\n impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n     type Output = Expr<'tcx>;\n \n-    fn make_mirror<'a>(self, cx: &mut Cx<'a,'tcx>) -> Expr<'tcx> {\n+    fn make_mirror<'a>(self, cx: &mut Cx<'a, 'tcx>) -> Expr<'tcx> {\n         debug!(\"Expr::make_mirror(): id={}, span={:?}\", self.id, self.span);\n \n         let expr_ty = cx.tcx.expr_ty(self); // note: no adjustments (yet)!\n \n         let kind = match self.node {\n             // Here comes the interesting stuff:\n-\n             hir::ExprMethodCall(_, _, ref args) => {\n                 // Rewrite a.b(c) into UFCS form like Trait::b(a, c)\n                 let expr = method_callee(cx, self, ty::MethodCall::expr(self.id));\n@@ -46,24 +45,24 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                                .collect();\n                 ExprKind::Call {\n                     fun: expr.to_ref(),\n-                    args: args\n+                    args: args,\n                 }\n             }\n \n             hir::ExprAddrOf(mutbl, ref expr) => {\n                 let region = match expr_ty.sty {\n                     ty::TyRef(r, _) => r,\n-                    _ => cx.tcx.sess.span_bug(expr.span, \"type of & not region\")\n+                    _ => cx.tcx.sess.span_bug(expr.span, \"type of & not region\"),\n                 };\n-                ExprKind::Borrow { region: *region,\n-                                   borrow_kind: to_borrow_kind(mutbl),\n-                                   arg: expr.to_ref() }\n+                ExprKind::Borrow {\n+                    region: *region,\n+                    borrow_kind: to_borrow_kind(mutbl),\n+                    arg: expr.to_ref(),\n+                }\n             }\n \n             hir::ExprBlock(ref blk) => {\n-                ExprKind::Block {\n-                    body: &**blk\n-                }\n+                ExprKind::Block { body: &**blk }\n             }\n \n             hir::ExprAssign(ref lhs, ref rhs) => {\n@@ -100,20 +99,26 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     // FIXME overflow\n                     match op.node {\n                         hir::BinOp_::BiAnd => {\n-                            ExprKind::LogicalOp { op: LogicalOp::And,\n-                                                  lhs: lhs.to_ref(),\n-                                                  rhs: rhs.to_ref() }\n+                            ExprKind::LogicalOp {\n+                                op: LogicalOp::And,\n+                                lhs: lhs.to_ref(),\n+                                rhs: rhs.to_ref(),\n+                            }\n                         }\n                         hir::BinOp_::BiOr => {\n-                            ExprKind::LogicalOp { op: LogicalOp::Or,\n-                                                  lhs: lhs.to_ref(),\n-                                                  rhs: rhs.to_ref() }\n+                            ExprKind::LogicalOp {\n+                                op: LogicalOp::Or,\n+                                lhs: lhs.to_ref(),\n+                                rhs: rhs.to_ref(),\n+                            }\n                         }\n                         _ => {\n                             let op = bin_op(op.node);\n-                            ExprKind::Binary { op: op,\n-                                               lhs: lhs.to_ref(),\n-                                               rhs: rhs.to_ref() }\n+                            ExprKind::Binary {\n+                                op: op,\n+                                lhs: lhs.to_ref(),\n+                                rhs: rhs.to_ref(),\n+                            }\n                         }\n                     }\n                 }\n@@ -124,8 +129,10 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     overloaded_lvalue(cx, self, ty::MethodCall::expr(self.id),\n                                       PassArgs::ByValue, lhs.to_ref(), vec![index])\n                 } else {\n-                    ExprKind::Index { lhs: lhs.to_ref(),\n-                                      index: index.to_ref() }\n+                    ExprKind::Index {\n+                        lhs: lhs.to_ref(),\n+                        index: index.to_ref(),\n+                    }\n                 }\n             }\n \n@@ -153,7 +160,10 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                                 \"UnDeref should have been handled elsewhere\");\n                         }\n                     };\n-                    ExprKind::Unary { op: op, arg: arg.to_ref() }\n+                    ExprKind::Unary {\n+                        op: op,\n+                        arg: arg.to_ref(),\n+                    }\n                 }\n             }\n \n@@ -202,8 +212,8 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     ty::TyClosure(def_id, ref substs) => (def_id, substs),\n                     _ => {\n                         cx.tcx.sess.span_bug(self.span,\n-                                          &format!(\"closure expr w/o closure type: {:?}\",\n-                                                   closure_ty));\n+                                             &format!(\"closure expr w/o closure type: {:?}\",\n+                                                      closure_ty));\n                     }\n                 };\n                 let upvars = cx.tcx.with_freevars(self.id, |freevars| {\n@@ -224,15 +234,15 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                 let (adt_def, substs) = match range_ty.sty {\n                     ty::TyStruct(adt_def, substs) => (adt_def, substs),\n                     _ => {\n-                        cx.tcx.sess.span_bug(\n-                            self.span,\n-                            &format!(\"unexpanded ast\"));\n+                        cx.tcx.sess.span_bug(self.span, &format!(\"unexpanded ast\"));\n                     }\n                 };\n \n                 let field_expr_ref = |s: &'tcx P<hir::Expr>, nm: &str| {\n-                    FieldExprRef { name: Field::Named(token::intern(nm)),\n-                                   expr: s.to_ref() }\n+                    FieldExprRef {\n+                        name: Field::Named(token::intern(nm)),\n+                        expr: s.to_ref(),\n+                    }\n                 };\n \n                 let start_field = start.as_ref()\n@@ -243,11 +253,13 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                                    .into_iter()\n                                    .map(|e| field_expr_ref(e, \"end\"));\n \n-                ExprKind::Adt { adt_def: adt_def,\n-                                variant_index: 0,\n-                                substs: substs,\n-                                fields: start_field.chain(end_field).collect(),\n-                                base: None }\n+                ExprKind::Adt {\n+                    adt_def: adt_def,\n+                    variant_index: 0,\n+                    substs: substs,\n+                    fields: start_field.chain(end_field).collect(),\n+                    base: None,\n+                }\n             }\n \n             hir::ExprPath(..) => {\n@@ -311,7 +323,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n \n         // Now apply adjustments, if any.\n         match cx.tcx.tables.borrow().adjustments.get(&self.id) {\n-            None => { }\n+            None => {}\n             Some(&ty::adjustment::AdjustReifyFnPointer) => {\n                 let adjusted_ty = cx.tcx.expr_ty_adjusted(self);\n                 expr = Expr {\n@@ -350,7 +362,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                         temp_lifetime: temp_lifetime,\n                         ty: adjusted_ty,\n                         span: self.span,\n-                        kind: kind\n+                        kind: kind,\n                     };\n                 }\n \n@@ -359,7 +371,7 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                         temp_lifetime: temp_lifetime,\n                         ty: target,\n                         span: self.span,\n-                        kind: ExprKind::Unsize { source: expr.to_ref() }\n+                        kind: ExprKind::Unsize { source: expr.to_ref() },\n                     };\n                 } else if let Some(autoref) = adj.autoref {\n                     let adjusted_ty = expr.ty.adjust_for_autoref(cx.tcx, Some(autoref));\n@@ -369,9 +381,11 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                                 temp_lifetime: temp_lifetime,\n                                 ty: adjusted_ty,\n                                 span: self.span,\n-                                kind: ExprKind::Borrow { region: *r,\n-                                                         borrow_kind: to_borrow_kind(m),\n-                                                         arg: expr.to_ref() }\n+                                kind: ExprKind::Borrow {\n+                                    region: *r,\n+                                    borrow_kind: to_borrow_kind(m),\n+                                    arg: expr.to_ref(),\n+                                },\n                             };\n                         }\n                         ty::adjustment::AutoUnsafe(m) => {\n@@ -384,15 +398,17 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                                 temp_lifetime: temp_lifetime,\n                                 ty: cx.tcx.mk_ref(region, ty::TypeAndMut { ty: expr.ty, mutbl: m }),\n                                 span: self.span,\n-                                kind: ExprKind::Borrow { region: *region,\n-                                                         borrow_kind: to_borrow_kind(m),\n-                                                         arg: expr.to_ref() }\n+                                kind: ExprKind::Borrow {\n+                                    region: *region,\n+                                    borrow_kind: to_borrow_kind(m),\n+                                    arg: expr.to_ref(),\n+                                },\n                             };\n                             expr = Expr {\n                                 temp_lifetime: temp_lifetime,\n                                 ty: adjusted_ty,\n                                 span: self.span,\n-                                kind: ExprKind::Cast { source: expr.to_ref() }\n+                                kind: ExprKind::Cast { source: expr.to_ref() },\n                             };\n                         }\n                     }\n@@ -405,8 +421,10 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n             temp_lifetime: temp_lifetime,\n             ty: expr.ty,\n             span: self.span,\n-            kind: ExprKind::Scope { extent: expr_extent,\n-                                    value: expr.to_ref() }\n+            kind: ExprKind::Scope {\n+                extent: expr_extent,\n+                value: expr.to_ref(),\n+            },\n         };\n \n         // Finally, create a destruction scope, if any.\n@@ -415,7 +433,10 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                 temp_lifetime: temp_lifetime,\n                 ty: expr.ty,\n                 span: self.span,\n-                kind: ExprKind::Scope { extent: extent, value: expr.to_ref() }\n+                kind: ExprKind::Scope {\n+                    extent: extent,\n+                    value: expr.to_ref(),\n+                },\n             };\n         }\n \n@@ -424,10 +445,10 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n     }\n }\n \n-fn method_callee<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n-                             expr: &hir::Expr,\n-                             method_call: ty::MethodCall)\n-                             -> Expr<'tcx> {\n+fn method_callee<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n+                               expr: &hir::Expr,\n+                               method_call: ty::MethodCall)\n+                               -> Expr<'tcx> {\n     let tables = cx.tcx.tables.borrow();\n     let callee = &tables.method_map[&method_call];\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n@@ -439,8 +460,8 @@ fn method_callee<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n             literal: Literal::Item {\n                 def_id: callee.def_id,\n                 substs: callee.substs,\n-            }\n-        }\n+            },\n+        },\n     }\n }\n \n@@ -451,7 +472,7 @@ fn to_borrow_kind(m: hir::Mutability) -> BorrowKind {\n     }\n }\n \n-fn convert_arm<'a,'tcx:'a>(cx: &Cx<'a,'tcx>, arm: &'tcx hir::Arm) -> Arm<'tcx> {\n+fn convert_arm<'a, 'tcx: 'a>(cx: &Cx<'a, 'tcx>, arm: &'tcx hir::Arm) -> Arm<'tcx> {\n     let map = if arm.pats.len() == 1 {\n         None\n     } else {\n@@ -462,15 +483,14 @@ fn convert_arm<'a,'tcx:'a>(cx: &Cx<'a,'tcx>, arm: &'tcx hir::Arm) -> Arm<'tcx> {\n         Some(Rc::new(map))\n     };\n \n-    Arm { patterns: arm.pats.iter().map(|p| PatNode::new(p, map.clone()).to_ref()).collect(),\n-          guard: arm.guard.to_ref(),\n-          body: arm.body.to_ref() }\n+    Arm {\n+        patterns: arm.pats.iter().map(|p| PatNode::new(p, map.clone()).to_ref()).collect(),\n+        guard: arm.guard.to_ref(),\n+        body: arm.body.to_ref(),\n+    }\n }\n \n-fn convert_path_expr<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n-                                 expr: &'tcx hir::Expr)\n-                                 -> ExprKind<'tcx>\n-{\n+fn convert_path_expr<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr) -> ExprKind<'tcx> {\n     let substs = cx.tcx.mk_substs(cx.tcx.node_id_item_substs(expr.id).substs);\n     match cx.tcx.def_map.borrow()[&expr.id].full_def() {\n         def::DefVariant(_, def_id, false) |\n@@ -499,11 +519,10 @@ fn convert_path_expr<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n     }\n }\n \n-fn convert_var<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n-                           expr: &'tcx hir::Expr,\n-                           def: def::Def)\n-                           -> ExprKind<'tcx>\n-{\n+fn convert_var<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n+                             expr: &'tcx hir::Expr,\n+                             def: def::Def)\n+                             -> ExprKind<'tcx> {\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(expr.id);\n \n     match def {\n@@ -534,20 +553,16 @@ fn convert_var<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n             };\n \n             // FIXME free regions in closures are not right\n-            let closure_ty =\n-                cx.tcx.node_id_to_type(closure_expr_id);\n+            let closure_ty = cx.tcx.node_id_to_type(closure_expr_id);\n \n             // FIXME we're just hard-coding the idea that the\n             // signature will be &self or &mut self and hence will\n             // have a bound region with number 0\n-            let region =\n-                ty::Region::ReFree(\n-                    ty::FreeRegion {\n-                        scope: cx.tcx.region_maps.node_extent(body_id),\n-                        bound_region: ty::BoundRegion::BrAnon(0)\n-                    });\n-            let region =\n-                cx.tcx.mk_region(region);\n+            let region = ty::Region::ReFree(ty::FreeRegion {\n+                scope: cx.tcx.region_maps.node_extent(body_id),\n+                bound_region: ty::BoundRegion::BrAnon(0),\n+            });\n+            let region = cx.tcx.mk_region(region);\n \n             let self_expr = match cx.tcx.closure_kind(cx.tcx.map.local_def_id(closure_expr_id)) {\n                 ty::ClosureKind::FnClosureKind => {\n@@ -593,19 +608,23 @@ fn convert_var<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n                         ty: closure_ty,\n                         temp_lifetime: temp_lifetime,\n                         span: expr.span,\n-                        kind: ExprKind::SelfRef\n+                        kind: ExprKind::SelfRef,\n                     }\n                 }\n             };\n \n             // at this point we have `self.n`, which loads up the upvar\n-            let field_kind =\n-                ExprKind::Field { lhs: self_expr.to_ref(),\n-                                  name: Field::Indexed(index) };\n+            let field_kind = ExprKind::Field {\n+                lhs: self_expr.to_ref(),\n+                name: Field::Indexed(index),\n+            };\n \n             // ...but the upvar might be an `&T` or `&mut T` capture, at which\n             // point we need an implicit deref\n-            let upvar_id = ty::UpvarId { var_id: id_var, closure_expr_id: closure_expr_id };\n+            let upvar_id = ty::UpvarId {\n+                var_id: id_var,\n+                closure_expr_id: closure_expr_id,\n+            };\n             let upvar_capture = match cx.tcx.upvar_capture(upvar_id) {\n                 Some(c) => c,\n                 None => {\n@@ -629,7 +648,7 @@ fn convert_var<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n             }\n         }\n \n-        _ => cx.tcx.sess.span_bug(expr.span, \"type of & not region\")\n+        _ => cx.tcx.sess.span_bug(expr.span, \"type of & not region\"),\n     }\n }\n \n@@ -652,23 +671,22 @@ fn bin_op(op: hir::BinOp_) -> BinOp {\n         hir::BinOp_::BiNe => BinOp::Ne,\n         hir::BinOp_::BiGe => BinOp::Ge,\n         hir::BinOp_::BiGt => BinOp::Gt,\n-        _ => panic!(\"no equivalent for ast binop {:?}\", op)\n+        _ => panic!(\"no equivalent for ast binop {:?}\", op),\n     }\n }\n \n enum PassArgs {\n     ByValue,\n-    ByRef\n+    ByRef,\n }\n \n-fn overloaded_operator<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n-                                   expr: &'tcx hir::Expr,\n-                                   method_call: ty::MethodCall,\n-                                   pass_args: PassArgs,\n-                                   receiver: ExprRef<'tcx>,\n-                                   args: Vec<&'tcx P<hir::Expr>>)\n-                                   -> ExprKind<'tcx>\n-{\n+fn overloaded_operator<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n+                                     expr: &'tcx hir::Expr,\n+                                     method_call: ty::MethodCall,\n+                                     pass_args: PassArgs,\n+                                     receiver: ExprRef<'tcx>,\n+                                     args: Vec<&'tcx P<hir::Expr>>)\n+                                     -> ExprKind<'tcx> {\n     // the receiver has all the adjustments that are needed, so we can\n     // just push a reference to it\n     let mut argrefs = vec![receiver];\n@@ -677,9 +695,7 @@ fn overloaded_operator<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n     // operator, we have to gin up the autorefs (but by value is easy)\n     match pass_args {\n         PassArgs::ByValue => {\n-            argrefs.extend(\n-                args.iter()\n-                    .map(|arg| arg.to_ref()))\n+            argrefs.extend(args.iter().map(|arg| arg.to_ref()))\n         }\n \n         PassArgs::ByRef => {\n@@ -714,14 +730,13 @@ fn overloaded_operator<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n     }\n }\n \n-fn overloaded_lvalue<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n-                                 expr: &'tcx hir::Expr,\n-                                 method_call: ty::MethodCall,\n-                                 pass_args: PassArgs,\n-                                 receiver: ExprRef<'tcx>,\n-                                 args: Vec<&'tcx P<hir::Expr>>)\n-                                 -> ExprKind<'tcx>\n-{\n+fn overloaded_lvalue<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n+                                   expr: &'tcx hir::Expr,\n+                                   method_call: ty::MethodCall,\n+                                   pass_args: PassArgs,\n+                                   receiver: ExprRef<'tcx>,\n+                                   args: Vec<&'tcx P<hir::Expr>>)\n+                                   -> ExprKind<'tcx> {\n     // For an overloaded *x or x[y] expression of type T, the method\n     // call returns an &T and we must add the deref so that the types\n     // line up (this is because `*x` and `x[y]` represent lvalues):\n@@ -750,20 +765,25 @@ fn overloaded_lvalue<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n     ExprKind::Deref { arg: ref_expr.to_ref() }\n }\n \n-fn capture_freevar<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n-                               closure_expr: &'tcx hir::Expr,\n-                               freevar: &ty::Freevar,\n-                               freevar_ty: Ty<'tcx>)\n-                               -> ExprRef<'tcx> {\n+fn capture_freevar<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>,\n+                                 closure_expr: &'tcx hir::Expr,\n+                                 freevar: &ty::Freevar,\n+                                 freevar_ty: Ty<'tcx>)\n+                                 -> ExprRef<'tcx> {\n     let id_var = freevar.def.var_id();\n-    let upvar_id = ty::UpvarId { var_id: id_var, closure_expr_id: closure_expr.id };\n+    let upvar_id = ty::UpvarId {\n+        var_id: id_var,\n+        closure_expr_id: closure_expr.id,\n+    };\n     let upvar_capture = cx.tcx.upvar_capture(upvar_id).unwrap();\n     let temp_lifetime = cx.tcx.region_maps.temporary_scope(closure_expr.id);\n     let var_ty = cx.tcx.node_id_to_type(id_var);\n-    let captured_var = Expr { temp_lifetime: temp_lifetime,\n-                              ty: var_ty,\n-                              span: closure_expr.span,\n-                              kind: convert_var(cx, closure_expr, freevar.def) };\n+    let captured_var = Expr {\n+        temp_lifetime: temp_lifetime,\n+        ty: var_ty,\n+        span: closure_expr.span,\n+        kind: convert_var(cx, closure_expr, freevar.def),\n+    };\n     match upvar_capture {\n         ty::UpvarCapture::ByValue => {\n             captured_var.to_ref()\n@@ -786,16 +806,11 @@ fn capture_freevar<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n     }\n }\n \n-fn loop_label<'a,'tcx:'a>(cx: &mut Cx<'a,'tcx>,\n-                          expr: &'tcx hir::Expr)\n-                          -> CodeExtent\n-{\n+fn loop_label<'a, 'tcx: 'a>(cx: &mut Cx<'a, 'tcx>, expr: &'tcx hir::Expr) -> CodeExtent {\n     match cx.tcx.def_map.borrow().get(&expr.id).map(|d| d.full_def()) {\n         Some(def::DefLabel(loop_id)) => cx.tcx.region_maps.node_extent(loop_id),\n         d => {\n-            cx.tcx.sess.span_bug(\n-                expr.span,\n-                &format!(\"loop scope resolved to {:?}\", d));\n+            cx.tcx.sess.span_bug(expr.span, &format!(\"loop scope resolved to {:?}\", d));\n         }\n     }\n }"}, {"sha": "92b026e5035b43f9d10c8e5686786437cac02294", "filename": "src/librustc_mir/tcx/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Ftcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Ftcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fmod.rs?ref=c73e78ce649ff9d40ba74a2c9338c7b2caac4920", "patch": "@@ -27,22 +27,25 @@ use syntax::codemap::Span;\n use syntax::parse::token::{self, special_idents};\n \n #[derive(Copy, Clone)]\n-pub struct Cx<'a,'tcx:'a> {\n+pub struct Cx<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    infcx: &'a InferCtxt<'a,'tcx>,\n+    infcx: &'a InferCtxt<'a, 'tcx>,\n }\n \n impl<'a,'tcx> Cx<'a,'tcx> {\n-    pub fn new(infcx: &'a InferCtxt<'a,'tcx>) -> Cx<'a,'tcx> {\n-        Cx { tcx: infcx.tcx, infcx: infcx }\n+    pub fn new(infcx: &'a InferCtxt<'a, 'tcx>) -> Cx<'a, 'tcx> {\n+        Cx {\n+            tcx: infcx.tcx,\n+            infcx: infcx,\n+        }\n     }\n }\n \n pub use self::pattern::PatNode;\n \n impl<'a,'tcx:'a> Cx<'a, 'tcx> {\n     /// Normalizes `ast` into the appropriate `mirror` type.\n-    pub fn mirror<M:Mirror<'tcx>>(&mut self, ast: M) -> M::Output {\n+    pub fn mirror<M: Mirror<'tcx>>(&mut self, ast: M) -> M::Output {\n         ast.make_mirror(self)\n     }\n \n@@ -141,18 +144,15 @@ impl<'a,'tcx:'a> Cx<'a, 'tcx> {\n                     }\n                 }\n                 ty::ImplOrTraitItem::ConstTraitItem(..) |\n-                ty::ImplOrTraitItem::TypeTraitItem(..) => {\n-                }\n+                ty::ImplOrTraitItem::TypeTraitItem(..) => {}\n             }\n         }\n \n-        self.tcx.sess.bug(\n-            &format!(\"found no method `{}` in `{:?}`\", method_name, trait_def_id));\n+        self.tcx.sess.bug(&format!(\"found no method `{}` in `{:?}`\", method_name, trait_def_id));\n     }\n }\n \n mod block;\n mod expr;\n mod pattern;\n mod to_ref;\n-"}, {"sha": "87ca87a103e193e4cc312ad847ff8fe0e2c57c38", "filename": "src/librustc_mir/tcx/pattern.rs", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Ftcx%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Ftcx%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fpattern.rs?ref=c73e78ce649ff9d40ba74a2c9338c7b2caac4920", "patch": "@@ -40,7 +40,7 @@ use syntax::ptr::P;\n #[derive(Clone, Debug)]\n pub struct PatNode<'tcx> {\n     pat: &'tcx hir::Pat,\n-    binding_map: Option<Rc<FnvHashMap<ast::Name, ast::NodeId>>>\n+    binding_map: Option<Rc<FnvHashMap<ast::Name, ast::NodeId>>>,\n }\n \n impl<'tcx> PatNode<'tcx> {\n@@ -53,8 +53,7 @@ impl<'tcx> PatNode<'tcx> {\n         }\n     }\n \n-    pub fn irrefutable(pat: &'tcx hir::Pat)\n-                       -> PatNode<'tcx> {\n+    pub fn irrefutable(pat: &'tcx hir::Pat) -> PatNode<'tcx> {\n         PatNode::new(pat, None)\n     }\n \n@@ -76,8 +75,7 @@ impl<'tcx> PatNode<'tcx> {\n                                   prefix: &'tcx Vec<P<hir::Pat>>,\n                                   slice: &'tcx Option<P<hir::Pat>>,\n                                   suffix: &'tcx Vec<P<hir::Pat>>)\n-                                  -> PatternKind<'tcx>\n-    {\n+                                  -> PatternKind<'tcx> {\n         match ty.sty {\n             ty::TySlice(..) =>\n                 // matching a slice or fixed-length array\n@@ -98,26 +96,25 @@ impl<'tcx> PatNode<'tcx> {\n             }\n \n             _ => {\n-                cx.tcx.sess.span_bug(\n-                    self.pat.span,\n-                    \"unexpanded macro or bad constant etc\");\n+                cx.tcx.sess.span_bug(self.pat.span, \"unexpanded macro or bad constant etc\");\n             }\n         }\n     }\n \n     fn variant_or_leaf<'a>(&self,\n                            cx: &mut Cx<'a, 'tcx>,\n                            subpatterns: Vec<FieldPatternRef<'tcx>>)\n-                           -> PatternKind<'tcx>\n-    {\n+                           -> PatternKind<'tcx> {\n         let def = cx.tcx.def_map.borrow().get(&self.pat.id).unwrap().full_def();\n         match def {\n             def::DefVariant(enum_id, variant_id, _) => {\n                 let adt_def = cx.tcx.lookup_adt_def(enum_id);\n                 if adt_def.variants.len() > 1 {\n-                    PatternKind::Variant { adt_def: adt_def,\n-                                           variant_index: adt_def.variant_index_with_id(variant_id),\n-                                           subpatterns: subpatterns }\n+                    PatternKind::Variant {\n+                        adt_def: adt_def,\n+                        variant_index: adt_def.variant_index_with_id(variant_id),\n+                        subpatterns: subpatterns,\n+                    }\n                 } else {\n                     PatternKind::Leaf { subpatterns: subpatterns }\n                 }\n@@ -130,9 +127,8 @@ impl<'tcx> PatNode<'tcx> {\n             }\n \n             _ => {\n-                cx.tcx.sess.span_bug(\n-                    self.pat.span,\n-                    &format!(\"inappropriate def for pattern: {:?}\", def));\n+                cx.tcx.sess.span_bug(self.pat.span,\n+                                     &format!(\"inappropriate def for pattern: {:?}\", def));\n             }\n         }\n     }\n@@ -141,16 +137,15 @@ impl<'tcx> PatNode<'tcx> {\n impl<'tcx> Mirror<'tcx> for PatNode<'tcx> {\n     type Output = Pattern<'tcx>;\n \n-    fn make_mirror<'a>(self, cx: &mut Cx<'a,'tcx>) -> Pattern<'tcx> {\n+    fn make_mirror<'a>(self, cx: &mut Cx<'a, 'tcx>) -> Pattern<'tcx> {\n         let kind = match self.pat.node {\n-            hir::PatWild(..) =>\n-                PatternKind::Wild,\n+            hir::PatWild(..) => PatternKind::Wild,\n \n             hir::PatLit(ref value) => {\n                 let value = const_eval::eval_const_expr(cx.tcx, value);\n                 let value = Literal::Value { value: value };\n                 PatternKind::Constant { value: value }\n-            },\n+            }\n \n             hir::PatRange(ref lo, ref hi) => {\n                 let lo = const_eval::eval_const_expr(cx.tcx, lo);\n@@ -296,16 +291,16 @@ impl<'tcx> Mirror<'tcx> for PatNode<'tcx> {\n             }\n \n             hir::PatQPath(..) => {\n-                cx.tcx.sess.span_bug(\n-                    self.pat.span,\n-                    \"unexpanded macro or bad constant etc\");\n+                cx.tcx.sess.span_bug(self.pat.span, \"unexpanded macro or bad constant etc\");\n             }\n         };\n \n         let ty = cx.tcx.node_id_to_type(self.pat.id);\n \n-        Pattern { span: self.pat.span,\n-                  ty: ty,\n-                  kind: kind }\n+        Pattern {\n+            span: self.pat.span,\n+            ty: ty,\n+            kind: kind,\n+        }\n     }\n }"}, {"sha": "13ca82e3e4c7188e3be1ae996911e9a9151d5b36", "filename": "src/librustc_mir/tcx/to_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Ftcx%2Fto_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c73e78ce649ff9d40ba74a2c9338c7b2caac4920/src%2Flibrustc_mir%2Ftcx%2Fto_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftcx%2Fto_ref.rs?ref=c73e78ce649ff9d40ba74a2c9338c7b2caac4920", "patch": "@@ -86,7 +86,7 @@ impl<'a,'tcx:'a> ToRef for &'tcx hir::Field {\n     fn to_ref(self) -> FieldExprRef<'tcx> {\n         FieldExprRef {\n             name: Field::Named(self.name.node),\n-            expr: self.expr.to_ref()\n+            expr: self.expr.to_ref(),\n         }\n     }\n }"}]}