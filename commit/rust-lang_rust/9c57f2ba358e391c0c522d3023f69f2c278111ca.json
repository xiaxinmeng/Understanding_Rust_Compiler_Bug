{"sha": "9c57f2ba358e391c0c522d3023f69f2c278111ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljNTdmMmJhMzU4ZTM5MWMwYzUyMmQzMDIzZjY5ZjJjMjc4MTExY2E=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-30T10:05:56Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-10-30T10:05:56Z"}, "message": "Merge pull request #492 from solson/rustup\n\nStacked Borrows NG", "tree": {"sha": "ef42e24f95564ef1518f12c3bcac8de5e14d5ab6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef42e24f95564ef1518f12c3bcac8de5e14d5ab6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c57f2ba358e391c0c522d3023f69f2c278111ca", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJb2C0ECRBK7hj4Ov3rIwAAdHIIAFFeJzaxDX4EV6yTTBlNTH8Q\nql80KU2bYYhAMDmCUpNn1zEOEUjdAl0dqsLVylMqXgL8yvGb/BEXwox73TjA7eU9\nJlXrbIfUrgVpfR7UmcW6GS4S9XjX+P81f0lBl9uQuyIPRiQGWG/7KcOefIBE+2Rz\niuW0xN5iw7gURYqlljwtyvqIrrh2lg6mwJSoD7/88+6FdQso1FNnkpvA4mXGDf5g\naxg79uVDTETtY2n/Pow5zSGQUlnqa4tCfdHNk3Cnff13WdapZYTSC7LT4QEyjVbG\n2n548UC8nRlt31No+hfm7oHmA5BTWGZnHqISzaYnYuyqQ/Mo+UkfjRtQbEvAFPI=\n=ZOi5\n-----END PGP SIGNATURE-----\n", "payload": "tree ef42e24f95564ef1518f12c3bcac8de5e14d5ab6\nparent af05d1d397ba0d322b3337a567bb50cc2e04e79a\nparent 1fa0ff88c03284421d99662909a4c24a8651d47d\nauthor Ralf Jung <post@ralfj.de> 1540893956 +0100\ncommitter GitHub <noreply@github.com> 1540893956 +0100\n\nMerge pull request #492 from solson/rustup\n\nStacked Borrows NG"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c57f2ba358e391c0c522d3023f69f2c278111ca", "html_url": "https://github.com/rust-lang/rust/commit/9c57f2ba358e391c0c522d3023f69f2c278111ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c57f2ba358e391c0c522d3023f69f2c278111ca/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af05d1d397ba0d322b3337a567bb50cc2e04e79a", "url": "https://api.github.com/repos/rust-lang/rust/commits/af05d1d397ba0d322b3337a567bb50cc2e04e79a", "html_url": "https://github.com/rust-lang/rust/commit/af05d1d397ba0d322b3337a567bb50cc2e04e79a"}, {"sha": "1fa0ff88c03284421d99662909a4c24a8651d47d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fa0ff88c03284421d99662909a4c24a8651d47d", "html_url": "https://github.com/rust-lang/rust/commit/1fa0ff88c03284421d99662909a4c24a8651d47d"}], "stats": {"total": 857, "additions": 643, "deletions": 214}, "files": [{"sha": "dd7bcd49200b05316440b22bd302467386e88459", "filename": ".travis.yml", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -36,30 +36,34 @@ script:\n - |\n   # Test and install plain miri\n   cargo build --release --all-features &&\n-  cargo test --release --all-features &&\n+  #cargo test --release --all-features &&\n   cargo install --all-features --force --path .\n - |\n   # get ourselves a MIR-full libstd\n   xargo/build.sh &&\n   export MIRI_SYSROOT=~/.xargo/HOST\n+#- |\n+#  # run all tests with full mir\n+#  cargo test --release --all-features\n - |\n-  # run all tests with full mir\n-  cargo test --release --all-features\n-- |\n-  # test `cargo miri`\n+  # Test cargo integration\n   cd cargo-miri-test &&\n-  if [[ \"$TRAVIS_OS_NAME\" == \"osx\" ]]; then\n-    cargo miri -q\n-  else\n-    cargo miri -q >stdout.real 2>stderr.real &&\n-    cat stdout.real stderr.real &&\n-    # Test `cargo miri` output. Not on mac because output redirecting doesn't\n-    # work. There is no error. It just stops CI.\n+  # Test `cargo miri`\n+    # We ignore the exit code because we want to see the output even on failure, and\n+    # I found no way to preserve the exit code so that we can test for it later.\n+    # Variables set in this subshell in the parenthesis are not available\n+    # on the outside.\n+    # We assume that if this fails, it'll also print something about the failure on\n+    # stdout/stderr and we'll catch that.\n+    # FIXME: Disabling validation, still investigating whether there is UB here\n+    (cargo miri -q >stdout.real 2>stderr.real -- -Zmiri-disable-validation || true) &&\n+    # Print file names and contents (`cat` would just print contents)\n+    tail -n +0 stdout.real stderr.real &&\n+    # Verify output\n     diff -u stdout.ref stdout.real &&\n-    diff -u stderr.ref stderr.real\n-  fi &&\n+    diff -u stderr.ref stderr.real &&\n   # test `cargo miri test`\n-  cargo miri test &&\n+    cargo miri test &&\n   cd ..\n \n notifications:"}, {"sha": "d025ddacf00920049358f49f78cf10349e2ae71e", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -1 +1 @@\n-nightly-2018-10-29\n+nightly-2018-10-30"}, {"sha": "9e3f49ac9fd32d36ec977d3dfc2f8ca00cf5107d", "filename": "src/fn_call.rs", "status": "modified", "additions": 44, "deletions": 35, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/src%2Ffn_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/src%2Ffn_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffn_call.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -125,15 +125,15 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                     self.write_null(dest)?;\n                 } else {\n                     let align = self.tcx.data_layout.pointer_align;\n-                    let ptr = self.memory.allocate(Size::from_bytes(size), align, MiriMemoryKind::C.into())?;\n-                    self.write_scalar(Scalar::Ptr(ptr), dest)?;\n+                    let ptr = self.memory_mut().allocate(Size::from_bytes(size), align, MiriMemoryKind::C.into())?;\n+                    self.write_scalar(Scalar::Ptr(ptr.with_default_tag()), dest)?;\n                 }\n             }\n \n             \"free\" => {\n                 let ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag(); // raw ptr operation, no tag\n                 if !ptr.is_null_ptr(&self) {\n-                    self.memory.deallocate(\n+                    self.memory_mut().deallocate(\n                         ptr.to_ptr()?.with_default_tag(),\n                         None,\n                         MiriMemoryKind::C.into(),\n@@ -150,9 +150,13 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 if !align.is_power_of_two() {\n                     return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                let ptr = self.memory.allocate(Size::from_bytes(size),\n-                                               Align::from_bytes(align, align).unwrap(),\n-                                               MiriMemoryKind::Rust.into())?;\n+                let ptr = self.memory_mut()\n+                    .allocate(\n+                        Size::from_bytes(size),\n+                        Align::from_bytes(align, align).unwrap(),\n+                        MiriMemoryKind::Rust.into()\n+                    )?\n+                    .with_default_tag();\n                 self.write_scalar(Scalar::Ptr(ptr), dest)?;\n             }\n             \"__rust_alloc_zeroed\" => {\n@@ -164,10 +168,14 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 if !align.is_power_of_two() {\n                     return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                let ptr = self.memory.allocate(Size::from_bytes(size),\n-                                               Align::from_bytes(align, align).unwrap(),\n-                                               MiriMemoryKind::Rust.into())?;\n-                self.memory.write_repeat(ptr.into(), 0, Size::from_bytes(size))?;\n+                let ptr = self.memory_mut()\n+                    .allocate(\n+                        Size::from_bytes(size),\n+                        Align::from_bytes(align, align).unwrap(),\n+                        MiriMemoryKind::Rust.into()\n+                    )?\n+                    .with_default_tag();\n+                self.memory_mut().write_repeat(ptr.into(), 0, Size::from_bytes(size))?;\n                 self.write_scalar(Scalar::Ptr(ptr), dest)?;\n             }\n             \"__rust_dealloc\" => {\n@@ -180,7 +188,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 if !align.is_power_of_two() {\n                     return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                self.memory.deallocate(\n+                self.memory_mut().deallocate(\n                     ptr.with_default_tag(),\n                     Some((Size::from_bytes(old_size), Align::from_bytes(align, align).unwrap())),\n                     MiriMemoryKind::Rust.into(),\n@@ -197,15 +205,15 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 if !align.is_power_of_two() {\n                     return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n-                let new_ptr = self.memory.reallocate(\n+                let new_ptr = self.memory_mut().reallocate(\n                     ptr.with_default_tag(),\n                     Size::from_bytes(old_size),\n                     Align::from_bytes(align, align).unwrap(),\n                     Size::from_bytes(new_size),\n                     Align::from_bytes(align, align).unwrap(),\n                     MiriMemoryKind::Rust.into(),\n                 )?;\n-                self.write_scalar(Scalar::Ptr(new_ptr), dest)?;\n+                self.write_scalar(Scalar::Ptr(new_ptr.with_default_tag()), dest)?;\n             }\n \n             \"syscall\" => {\n@@ -231,7 +239,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n             \"dlsym\" => {\n                 let _handle = self.read_scalar(args[0])?;\n                 let symbol = self.read_scalar(args[1])?.to_ptr()?.erase_tag();\n-                let symbol_name = self.memory.read_c_str(symbol.with_default_tag())?;\n+                let symbol_name = self.memory().read_c_str(symbol.with_default_tag())?;\n                 let err = format!(\"bad c unicode symbol: {:?}\", symbol_name);\n                 let symbol_name = ::std::str::from_utf8(symbol_name).unwrap_or(&err);\n                 return err!(Unimplemented(format!(\n@@ -245,7 +253,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 // We abort on panic, so not much is going on here, but we still have to call the closure\n                 let f = self.read_scalar(args[0])?.to_ptr()?;\n                 let data = self.read_scalar(args[1])?.not_undef()?;\n-                let f_instance = self.memory.get_fn(f)?;\n+                let f_instance = self.memory().get_fn(f)?;\n                 self.write_null(dest)?;\n                 trace!(\"__rust_maybe_catch_panic: {:?}\", f_instance);\n \n@@ -289,8 +297,8 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 let n = Size::from_bytes(self.read_scalar(args[2])?.to_usize(&self)?);\n \n                 let result = {\n-                    let left_bytes = self.memory.read_bytes(left.with_default_tag(), n)?;\n-                    let right_bytes = self.memory.read_bytes(right.with_default_tag(), n)?;\n+                    let left_bytes = self.memory().read_bytes(left.with_default_tag(), n)?;\n+                    let right_bytes = self.memory().read_bytes(right.with_default_tag(), n)?;\n \n                     use std::cmp::Ordering::*;\n                     match left_bytes.cmp(right_bytes) {\n@@ -311,7 +319,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 let ptr = ptr.with_default_tag();\n                 let val = self.read_scalar(args[1])?.to_bytes()? as u8;\n                 let num = self.read_scalar(args[2])?.to_usize(&self)?;\n-                if let Some(idx) = self.memory.read_bytes(ptr, Size::from_bytes(num))?\n+                if let Some(idx) = self.memory().read_bytes(ptr, Size::from_bytes(num))?\n                     .iter().rev().position(|&c| c == val)\n                 {\n                     let new_ptr = ptr.ptr_offset(Size::from_bytes(num - idx as u64 - 1), &self)?;\n@@ -326,7 +334,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 let ptr = ptr.with_default_tag();\n                 let val = self.read_scalar(args[1])?.to_bytes()? as u8;\n                 let num = self.read_scalar(args[2])?.to_usize(&self)?;\n-                if let Some(idx) = self.memory.read_bytes(ptr, Size::from_bytes(num))?.iter().position(\n+                if let Some(idx) = self.memory().read_bytes(ptr, Size::from_bytes(num))?.iter().position(\n                     |&c| c == val,\n                 )\n                 {\n@@ -340,7 +348,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n             \"getenv\" => {\n                 let result = {\n                     let name_ptr = self.read_scalar(args[0])?.to_ptr()?.erase_tag(); // raw ptr operation\n-                    let name = self.memory.read_c_str(name_ptr.with_default_tag())?;\n+                    let name = self.memory().read_c_str(name_ptr.with_default_tag())?;\n                     match self.machine.env_vars.get(name) {\n                         Some(&var) => Scalar::Ptr(var),\n                         None => Scalar::ptr_null(*self.tcx),\n@@ -354,15 +362,16 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 {\n                     let name_ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag(); // raw ptr operation\n                     if !name_ptr.is_null_ptr(&self) {\n-                        let name = self.memory.read_c_str(name_ptr.to_ptr()?.with_default_tag())?;\n+                        let name = self.memory().read_c_str(name_ptr.to_ptr()?\n+                            .with_default_tag())?.to_owned();\n                         if !name.is_empty() && !name.contains(&b'=') {\n-                            success = Some(self.machine.env_vars.remove(name));\n+                            success = Some(self.machine.env_vars.remove(&name));\n                         }\n                     }\n                 }\n                 if let Some(old) = success {\n                     if let Some(var) = old {\n-                        self.memory.deallocate(var, None, MiriMemoryKind::Env.into())?;\n+                        self.memory_mut().deallocate(var, None, MiriMemoryKind::Env.into())?;\n                     }\n                     self.write_null(dest)?;\n                 } else {\n@@ -375,30 +384,30 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 {\n                     let name_ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag(); // raw ptr operation\n                     let value_ptr = self.read_scalar(args[1])?.to_ptr()?.erase_tag(); // raw ptr operation\n-                    let value = self.memory.read_c_str(value_ptr.with_default_tag())?;\n+                    let value = self.memory().read_c_str(value_ptr.with_default_tag())?;\n                     if !name_ptr.is_null_ptr(&self) {\n-                        let name = self.memory.read_c_str(name_ptr.to_ptr()?.with_default_tag())?;\n+                        let name = self.memory().read_c_str(name_ptr.to_ptr()?.with_default_tag())?;\n                         if !name.is_empty() && !name.contains(&b'=') {\n                             new = Some((name.to_owned(), value.to_owned()));\n                         }\n                     }\n                 }\n                 if let Some((name, value)) = new {\n                     // +1 for the null terminator\n-                    let value_copy = self.memory.allocate(\n+                    let value_copy = self.memory_mut().allocate(\n                         Size::from_bytes((value.len() + 1) as u64),\n                         Align::from_bytes(1, 1).unwrap(),\n                         MiriMemoryKind::Env.into(),\n-                    )?;\n-                    self.memory.write_bytes(value_copy.into(), &value)?;\n+                    )?.with_default_tag();\n+                    self.memory_mut().write_bytes(value_copy.into(), &value)?;\n                     let trailing_zero_ptr = value_copy.offset(Size::from_bytes(value.len() as u64), &self)?.into();\n-                    self.memory.write_bytes(trailing_zero_ptr, &[0])?;\n+                    self.memory_mut().write_bytes(trailing_zero_ptr, &[0])?;\n                     if let Some(var) = self.machine.env_vars.insert(\n                         name.to_owned(),\n                         value_copy,\n                     )\n                     {\n-                        self.memory.deallocate(var, None, MiriMemoryKind::Env.into())?;\n+                        self.memory_mut().deallocate(var, None, MiriMemoryKind::Env.into())?;\n                     }\n                     self.write_null(dest)?;\n                 } else {\n@@ -415,7 +424,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                     // stdout/stderr\n                     use std::io::{self, Write};\n \n-                    let buf_cont = self.memory.read_bytes(buf.with_default_tag(), Size::from_bytes(n))?;\n+                    let buf_cont = self.memory().read_bytes(buf.with_default_tag(), Size::from_bytes(n))?;\n                     let res = if fd == 1 {\n                         io::stdout().write(buf_cont)\n                     } else {\n@@ -437,7 +446,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n \n             \"strlen\" => {\n                 let ptr = self.read_scalar(args[0])?.to_ptr()?.erase_tag();\n-                let n = self.memory.read_c_str(ptr.with_default_tag())?.len();\n+                let n = self.memory().read_c_str(ptr.with_default_tag())?.len();\n                 self.write_scalar(Scalar::from_uint(n as u64, dest.layout.size), dest)?;\n             }\n \n@@ -487,9 +496,9 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n \n                 // Extract the function type out of the signature (that seems easier than constructing it ourselves...)\n                 let dtor = match self.read_scalar(args[1])?.not_undef()? {\n-                    Scalar::Ptr(dtor_ptr) => Some(self.memory.get_fn(dtor_ptr)?),\n+                    Scalar::Ptr(dtor_ptr) => Some(self.memory().get_fn(dtor_ptr)?),\n                     Scalar::Bits { bits: 0, size } => {\n-                        assert_eq!(size as u64, self.memory.pointer_size().bytes());\n+                        assert_eq!(size as u64, self.memory().pointer_size().bytes());\n                         None\n                     },\n                     Scalar::Bits { .. } => return err!(ReadBytesAsPointer),\n@@ -505,7 +514,7 @@ impl<'a, 'mir, 'tcx: 'mir + 'a> EvalContextExt<'tcx, 'mir> for super::MiriEvalCo\n                 if key_layout.size.bits() < 128 && key >= (1u128 << key_layout.size.bits() as u128) {\n                     return err!(OutOfTls);\n                 }\n-                self.memory.write_scalar(\n+                self.memory_mut().write_scalar(\n                     key_ptr.with_default_tag(),\n                     key_layout.align,\n                     Scalar::from_uint(key, key_layout.size).into(),"}, {"sha": "ee8df3e25ec13d7b620153aec594ff361a4e36a4", "filename": "src/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/src%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/src%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -153,7 +153,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 // erase tags: this is a raw ptr operation\n                 let src = self.read_scalar(args[0])?.not_undef()?.erase_tag();\n                 let dest = self.read_scalar(args[1])?.not_undef()?.erase_tag();\n-                self.memory.copy(\n+                self.memory_mut().copy(\n                     src.with_default_tag(),\n                     elem_align,\n                     dest.with_default_tag(),\n@@ -260,7 +260,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                             // Do it in memory\n                             let mplace = self.force_allocation(dest)?;\n                             assert!(mplace.meta.is_none());\n-                            self.memory.write_repeat(mplace.ptr, 0, dest.layout.size)?;\n+                            self.memory_mut().write_repeat(mplace.ptr, 0, dest.layout.size)?;\n                         }\n                     }\n                 }\n@@ -423,7 +423,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                             // Do it in memory\n                             let mplace = self.force_allocation(dest)?;\n                             assert!(mplace.meta.is_none());\n-                            self.memory.mark_definedness(mplace.ptr.to_ptr()?, dest.layout.size, false)?;\n+                            self.memory_mut().mark_definedness(mplace.ptr.to_ptr()?, dest.layout.size, false)?;\n                         }\n                     }\n                 }\n@@ -435,8 +435,8 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 let val_byte = self.read_scalar(args[1])?.to_u8()?;\n                 let ptr = self.read_scalar(args[0])?.not_undef()?.erase_tag().with_default_tag();\n                 let count = self.read_scalar(args[2])?.to_usize(&self)?;\n-                self.memory.check_align(ptr, ty_layout.align)?;\n-                self.memory.write_repeat(ptr, val_byte, ty_layout.size * count)?;\n+                self.memory().check_align(ptr, ty_layout.align)?;\n+                self.memory_mut().write_repeat(ptr, val_byte, ty_layout.size * count)?;\n             }\n \n             name => return err!(Unimplemented(format!(\"unimplemented intrinsic: {}\", name))),"}, {"sha": "9f4eb00877e4b8471043d8fd398af2a6b13c2144", "filename": "src/lib.rs", "status": "modified", "additions": 47, "deletions": 20, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -18,7 +18,7 @@ use std::borrow::Cow;\n \n use rustc::ty::{self, Ty, TyCtxt, query::TyCtxtAt};\n use rustc::ty::layout::{TyLayout, LayoutOf, Size};\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::{self, def_id::DefId};\n use rustc::mir;\n \n use syntax::attr;\n@@ -44,8 +44,12 @@ use range_map::RangeMap;\n #[allow(unused_imports)] // FIXME rustc bug https://github.com/rust-lang/rust/issues/53682\n use helpers::{ScalarExt, EvalContextExt as HelpersEvalContextExt};\n use mono_hash_map::MonoHashMap;\n-use stacked_borrows::{EvalContextExt as StackedBorEvalContextExt, Borrow};\n+use stacked_borrows::{EvalContextExt as StackedBorEvalContextExt};\n \n+// Used by priroda\n+pub use stacked_borrows::{Borrow, Stacks, Mut as MutBorrow};\n+\n+// Used by priroda\n pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     main_id: DefId,\n@@ -108,7 +112,7 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n         let mut args = ecx.frame().mir.args_iter();\n \n         // First argument: pointer to main()\n-        let main_ptr = ecx.memory_mut().create_fn_alloc(main_instance);\n+        let main_ptr = ecx.memory_mut().create_fn_alloc(main_instance).with_default_tag();\n         let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n         ecx.write_scalar(Scalar::Ptr(main_ptr), dest)?;\n \n@@ -119,12 +123,12 @@ pub fn create_ecx<'a, 'mir: 'a, 'tcx: 'mir>(\n         // FIXME: extract main source file path\n         // Third argument (argv): &[b\"foo\"]\n         let dest = ecx.eval_place(&mir::Place::Local(args.next().unwrap()))?;\n-        let foo = ecx.memory.allocate_static_bytes(b\"foo\\0\");\n+        let foo = ecx.memory_mut().allocate_static_bytes(b\"foo\\0\").with_default_tag();\n         let foo_ty = ecx.tcx.mk_imm_ptr(ecx.tcx.types.u8);\n         let foo_layout = ecx.layout_of(foo_ty)?;\n         let foo_place = ecx.allocate(foo_layout, MiriMemoryKind::Env.into())?;\n         ecx.write_scalar(Scalar::Ptr(foo), foo_place.into())?;\n-        ecx.memory.mark_immutable(foo_place.to_ptr()?.alloc_id)?;\n+        ecx.memory_mut().mark_immutable(foo_place.to_ptr()?.alloc_id)?;\n         ecx.write_scalar(foo_place.ptr, dest)?;\n \n         assert!(args.next().is_none(), \"start lang item has more arguments than expected\");\n@@ -404,7 +408,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n         Ok(())\n     }\n \n-    fn static_with_default_tag(\n+    fn adjust_static_allocation(\n         alloc: &'_ Allocation\n     ) -> Cow<'_, Allocation<Borrow, Self::AllocExtra>> {\n         let alloc: Allocation<Borrow, Self::AllocExtra> = Allocation {\n@@ -434,7 +438,7 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n \n     #[inline(always)]\n     fn memory_deallocated(\n-        alloc: &mut Allocation<Self::PointerTag, Self::AllocExtra>,\n+        alloc: &mut Allocation<Borrow, Self::AllocExtra>,\n         ptr: Pointer<Borrow>,\n     ) -> EvalResult<'tcx> {\n         alloc.extra.memory_deallocated(ptr)\n@@ -443,30 +447,53 @@ impl<'a, 'mir, 'tcx> Machine<'a, 'mir, 'tcx> for Evaluator<'tcx> {\n     #[inline(always)]\n     fn tag_reference(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        ptr: Pointer<Borrow>,\n-        pointee_ty: Ty<'tcx>,\n-        pointee_size: Size,\n-        borrow_kind: Option<mir::BorrowKind>,\n-    ) -> EvalResult<'tcx, Borrow> {\n-        if !ecx.machine.validate {\n+        place: MemPlace<Borrow>,\n+        ty: Ty<'tcx>,\n+        size: Size,\n+        mutability: Option<hir::Mutability>,\n+    ) -> EvalResult<'tcx, MemPlace<Borrow>> {\n+        if !ecx.machine.validate || size == Size::ZERO {\n             // No tracking\n-            Ok(Borrow::default())\n+            Ok(place)\n         } else {\n-            ecx.tag_reference(ptr, pointee_ty, pointee_size, borrow_kind)\n+            let ptr = place.ptr.to_ptr()?;\n+            let tag = ecx.tag_reference(ptr, ty, size, mutability.into())?;\n+            let ptr = Scalar::Ptr(Pointer::new_with_tag(ptr.alloc_id, ptr.offset, tag));\n+            Ok(MemPlace { ptr, ..place })\n         }\n     }\n \n     #[inline(always)]\n     fn tag_dereference(\n         ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n-        ptr: Pointer<Borrow>,\n-        ptr_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, Borrow> {\n+        place: MemPlace<Borrow>,\n+        ty: Ty<'tcx>,\n+        size: Size,\n+        mutability: Option<hir::Mutability>,\n+    ) -> EvalResult<'tcx, MemPlace<Borrow>> {\n+        if !ecx.machine.validate || size == Size::ZERO {\n+            // No tracking\n+            Ok(place)\n+        } else {\n+            let ptr = place.ptr.to_ptr()?;\n+            let tag = ecx.tag_dereference(ptr, ty, size, mutability.into())?;\n+            let ptr = Scalar::Ptr(Pointer::new_with_tag(ptr.alloc_id, ptr.offset, tag));\n+            Ok(MemPlace { ptr, ..place })\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn tag_new_allocation(\n+        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        ptr: Pointer,\n+        kind: MemoryKind<Self::MemoryKinds>,\n+    ) -> EvalResult<'tcx, Pointer<Borrow>> {\n         if !ecx.machine.validate {\n             // No tracking\n-            Ok(Borrow::default())\n+            Ok(ptr.with_default_tag())\n         } else {\n-            ecx.tag_dereference(ptr, ptr_ty)\n+            let tag = ecx.tag_new_allocation(ptr.alloc_id, kind);\n+            Ok(Pointer::new_with_tag(ptr.alloc_id, ptr.offset, tag))\n         }\n     }\n }"}, {"sha": "0eac5c11276a71c32ee987e34e393f9632844bf7", "filename": "src/operator.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -80,8 +80,8 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                         Ge => left.offset >= right.offset,\n                         Sub => {\n                             // subtract the offsets\n-                            let left_offset = Scalar::from_uint(left.offset.bytes(), self.memory.pointer_size());\n-                            let right_offset = Scalar::from_uint(right.offset.bytes(), self.memory.pointer_size());\n+                            let left_offset = Scalar::from_uint(left.offset.bytes(), self.memory().pointer_size());\n+                            let right_offset = Scalar::from_uint(right.offset.bytes(), self.memory().pointer_size());\n                             let layout = self.layout_of(self.tcx.types.usize)?;\n                             return self.binary_op(\n                                 Sub,\n@@ -103,7 +103,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 self.ptr_int_arithmetic(\n                     bin_op,\n                     left.to_ptr().expect(\"we checked is_ptr\"),\n-                    right.to_bits(self.memory.pointer_size()).expect(\"we checked is_bits\"),\n+                    right.to_bits(self.memory().pointer_size()).expect(\"we checked is_bits\"),\n                     right_layout.abi.is_signed(),\n                 )\n             }\n@@ -113,7 +113,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 self.ptr_int_arithmetic(\n                     bin_op,\n                     right.to_ptr().expect(\"we checked is_ptr\"),\n-                    left.to_bits(self.memory.pointer_size()).expect(\"we checked is_bits\"),\n+                    left.to_bits(self.memory().pointer_size()).expect(\"we checked is_bits\"),\n                     left_layout.abi.is_signed(),\n                 )\n             }\n@@ -142,8 +142,8 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                     // allocations sit right next to each other.  The C/C++ standards are\n                     // somewhat fuzzy about this case, so I think for now this check is\n                     // \"good enough\".\n-                    self.memory.check_bounds_ptr(left, false)?;\n-                    self.memory.check_bounds_ptr(right, false)?;\n+                    self.memory().check_bounds_ptr(left, false)?;\n+                    self.memory().check_bounds_ptr(right, false)?;\n                     // Two live in-bounds pointers, we can compare across allocations\n                     left == right\n                 }\n@@ -153,7 +153,7 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             (Scalar::Bits { bits, size }, Scalar::Ptr(ptr)) => {\n                 assert_eq!(size as u64, self.pointer_size().bytes());\n                 let bits = bits as u64;\n-                let (alloc_size, alloc_align) = self.memory.get_size_and_align(ptr.alloc_id);\n+                let (alloc_size, alloc_align) = self.memory().get_size_and_align(ptr.alloc_id);\n \n                 // Case I: Comparing with NULL\n                 if bits == 0 {\n@@ -223,15 +223,15 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n                 map_to_primval(left.overflowing_offset(Size::from_bytes(right as u64), self)),\n \n             BitAnd if !signed => {\n-                let ptr_base_align = self.memory.get(left.alloc_id)?.align.abi();\n+                let ptr_base_align = self.memory().get(left.alloc_id)?.align.abi();\n                 let base_mask = {\n                     // FIXME: Use interpret::truncate, once that takes a Size instead of a Layout\n-                    let shift = 128 - self.memory.pointer_size().bits();\n+                    let shift = 128 - self.memory().pointer_size().bits();\n                     let value = !(ptr_base_align as u128 - 1);\n                     // truncate (shift left to drop out leftover values, shift right to fill with zeroes)\n                     (value << shift) >> shift\n                 };\n-                let ptr_size = self.memory.pointer_size().bytes() as u8;\n+                let ptr_size = self.memory().pointer_size().bytes() as u8;\n                 trace!(\"Ptr BitAnd, align {}, operand {:#010x}, base_mask {:#010x}\",\n                     ptr_base_align, right, base_mask);\n                 if right & base_mask == base_mask {\n@@ -256,9 +256,9 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n             Rem if !signed => {\n                 // Doing modulo a divisor of the alignment is allowed.\n                 // (Intuition: Modulo a divisor leaks less information.)\n-                let ptr_base_align = self.memory.get(left.alloc_id)?.align.abi();\n+                let ptr_base_align = self.memory().get(left.alloc_id)?.align.abi();\n                 let right = right as u64;\n-                let ptr_size = self.memory.pointer_size().bytes() as u8;\n+                let ptr_size = self.memory().pointer_size().bytes() as u8;\n                 if right == 1 {\n                     // modulo 1 is always 0\n                     (Scalar::Bits { bits: 0, size: ptr_size }, false)\n@@ -295,9 +295,9 @@ impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, '\n         if let Scalar::Ptr(ptr) = ptr {\n             // Both old and new pointer must be in-bounds.\n             // (Of the same allocation, but that part is trivial with our representation.)\n-            self.memory.check_bounds_ptr(ptr, false)?;\n+            self.memory().check_bounds_ptr(ptr, false)?;\n             let ptr = ptr.signed_offset(offset, self)?;\n-            self.memory.check_bounds_ptr(ptr, false)?;\n+            self.memory().check_bounds_ptr(ptr, false)?;\n             Ok(Scalar::Ptr(ptr))\n         } else {\n             // An integer pointer. They can only be offset by 0, and we pretend there"}, {"sha": "a569ed4e55513b20edb1c9dc5385af412da94931", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 274, "deletions": 73, "changes": 347, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -1,10 +1,10 @@\n-use std::cell::RefCell;\n+use std::cell::{Cell, RefCell};\n \n use rustc::ty::{Ty, layout::Size};\n-use rustc::mir;\n+use rustc::hir;\n \n use super::{\n-    MemoryAccess, RangeMap, EvalResult,\n+    MemoryAccess, MemoryKind, MiriMemoryKind, RangeMap, EvalResult, AllocId,\n     Pointer,\n };\n \n@@ -21,12 +21,20 @@ pub enum Mut {\n \n impl Mut {\n     #[inline(always)]\n-    fn is_raw(self) -> bool {\n+    pub fn is_raw(self) -> bool {\n         match self {\n             Mut::Raw => true,\n             _ => false,\n         }\n     }\n+\n+    #[inline(always)]\n+    pub fn is_uniq(self) -> bool {\n+        match self {\n+            Mut::Uniq(_) => true,\n+            _ => false,\n+        }\n+    }\n }\n \n /// Information about any kind of borrow\n@@ -40,9 +48,17 @@ pub enum Borrow {\n \n impl Borrow {\n     #[inline(always)]\n-    fn is_uniq(self) -> bool {\n+    pub fn is_uniq(self) -> bool {\n+        match self {\n+            Borrow::Mut(m) => m.is_uniq(),\n+            _ => false,\n+        }\n+    }\n+\n+    #[inline(always)]\n+    pub fn is_frz(self) -> bool {\n         match self {\n-            Borrow::Mut(Mut::Uniq(_)) => true,\n+            Borrow::Frz(_) => true,\n             _ => false,\n         }\n     }\n@@ -64,15 +80,33 @@ impl Default for Borrow {\n     }\n }\n \n+/// What kind of reference are we talking about?\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+pub enum RefKind {\n+    Mut,\n+    Shr,\n+    Raw,\n+}\n+\n+impl From<Option<hir::Mutability>> for RefKind {\n+    fn from(mutbl: Option<hir::Mutability>) -> Self {\n+        match mutbl {\n+            None => RefKind::Raw,\n+            Some(hir::MutMutable) => RefKind::Mut,\n+            Some(hir::MutImmutable) => RefKind::Shr,\n+        }\n+    }\n+}\n+\n /// Extra global machine state\n #[derive(Clone, Debug)]\n pub struct State {\n-    clock: Timestamp\n+    clock: Cell<Timestamp>\n }\n \n impl State {\n     pub fn new() -> State {\n-        State { clock: 0 }\n+        State { clock: Cell::new(0) }\n     }\n }\n \n@@ -86,7 +120,7 @@ struct Stack {\n impl Default for Stack {\n     fn default() -> Self {\n         Stack {\n-            borrows: Vec::new(),\n+            borrows: vec![BorStackItem::Mut(Mut::Raw)],\n             frozen_since: None,\n         }\n     }\n@@ -100,6 +134,9 @@ pub struct Stacks {\n \n /// Core operations\n impl<'tcx> Stack {\n+    /// Check if `bor` is currently active.  We accept a `Raw` on a frozen location\n+    /// because this could be a shared (re)borrow.  If you want to mutate, this\n+    /// is not the right function to call!\n     fn check(&self, bor: Borrow) -> bool {\n         match bor {\n             Borrow::Frz(acc_t) =>\n@@ -115,62 +152,94 @@ impl<'tcx> Stack {\n         }\n     }\n \n-    /// Reactive `bor` for this stack.  If `force_mut` is set, we want to aggressively\n-    /// unfreeze this location (because we are about to push a `Uniq`).\n-    fn reactivate(&mut self, bor: Borrow, force_mut: bool) -> EvalResult<'tcx> {\n+    /// Check if `bor` could be activated by unfreezing and popping.\n+    /// `force_mut` indicates whether being frozen is potentially acceptable.\n+    /// Returns `Err` if the answer is \"no\"; otherwise the data says\n+    /// what needs to happen to activate this: `None` = nothing,\n+    /// `Some(n)` = unfreeze and make item `n` the top item of the stack.\n+    fn reactivatable(&self, bor: Borrow, force_mut: bool) -> Result<Option<usize>, String> {\n         // Unless mutation is bound to happen, do NOT change anything if `bor` is already active.\n         // In particular, if it is a `Mut(Raw)` and we are frozen, this should be a NOP.\n         if !force_mut && self.check(bor) {\n-            return Ok(());\n+            return Ok(None);\n         }\n \n         let acc_m = match bor {\n-            Borrow::Frz(_) =>\n-                if force_mut {\n-                    return err!(MachineError(format!(\"Using a shared borrow for mutation\")))\n+            Borrow::Frz(since) =>\n+                return Err(if force_mut {\n+                    format!(\"Using a shared borrow for mutation\")\n                 } else {\n-                    return err!(MachineError(format!(\"Location should be frozen but it is not\")))\n-                }\n-            Borrow::Mut(acc_m) => acc_m,\n+                    format!(\n+                        \"Location should be frozen since {} but {}\",\n+                        since,\n+                        match self.frozen_since {\n+                            None => format!(\"it is not frozen at all\"),\n+                            Some(since) => format!(\"it is only frozen since {}\", since),\n+                        }\n+                    )\n+                }),\n+            Borrow::Mut(acc_m) => acc_m\n         };\n-        // We definitely have to unfreeze this, even if we use the topmost item.\n-        self.frozen_since = None;\n-        // Pop until we see the one we are looking for.\n-        while let Some(&itm) = self.borrows.last() {\n+        // This is where we would unfreeze.\n+        for (idx, &itm) in self.borrows.iter().enumerate().rev() {\n             match itm {\n-                BorStackItem::FnBarrier(_) => {\n-                    return err!(MachineError(format!(\"Trying to reactivate a borrow that lives behind a barrier\")));\n-                }\n+                BorStackItem::FnBarrier(_) =>\n+                    return Err(format!(\"Trying to reactivate a mutable borrow ({:?}) that lives behind a barrier\", acc_m)),\n                 BorStackItem::Mut(loc_m) => {\n-                    if loc_m == acc_m { return Ok(()); }\n-                    trace!(\"reactivate: Popping {:?}\", itm);\n-                    self.borrows.pop();\n+                    if loc_m == acc_m { return Ok(Some(idx)); }\n                 }\n             }\n         }\n-        // Nothing to be found.  Simulate a \"virtual raw\" element at the bottom of the stack.\n-        if acc_m.is_raw() {\n-            Ok(())\n-        } else {\n-            err!(MachineError(format!(\"Borrow-to-reactivate does not exist on the stack\")))\n+        // Nothing to be found.\n+        Err(format!(\"Mutable borrow-to-reactivate ({:?}) does not exist on the stack\", acc_m))\n+    }\n+\n+    /// Reactive `bor` for this stack.  If `force_mut` is set, we want to aggressively\n+    /// unfreeze this location (because we are about to mutate, so a frozen `Raw` is not okay).\n+    fn reactivate(&mut self, bor: Borrow, force_mut: bool) -> EvalResult<'tcx> {\n+        let action = match self.reactivatable(bor, force_mut) {\n+            Ok(action) => action,\n+            Err(err) => return err!(MachineError(err)),\n+        };\n+\n+        match action {\n+            None => {}, // nothing to do\n+            Some(top) => {\n+                self.frozen_since = None;\n+                self.borrows.truncate(top+1);\n+            }\n         }\n+\n+        Ok(())\n     }\n \n+    /// Initiate `bor`; mostly this means freezing or pushing.\n     fn initiate(&mut self, bor: Borrow) -> EvalResult<'tcx> {\n         match bor {\n             Borrow::Frz(t) => {\n-                trace!(\"initiate: Freezing\");\n                 match self.frozen_since {\n-                    None => self.frozen_since = Some(t),\n-                    Some(since) => assert!(since <= t),\n+                    None => {\n+                        trace!(\"initiate: Freezing\");\n+                        self.frozen_since = Some(t);\n+                    }\n+                    Some(since) => {\n+                        trace!(\"initiate: Already frozen\");\n+                        assert!(since <= t);\n+                    }\n                 }\n             }\n             Borrow::Mut(m) => {\n-                trace!(\"initiate: Pushing {:?}\", bor);\n                 match self.frozen_since {\n-                    None => self.borrows.push(BorStackItem::Mut(m)),\n+                    None => {\n+                        trace!(\"initiate: Pushing {:?}\", bor);\n+                        self.borrows.push(BorStackItem::Mut(m))\n+                    }\n+                    Some(_) if m.is_raw() =>\n+                        // We only ever initiate right after activating the ref we come from.\n+                        // If the source ref is fine being frozen, then a raw ref we create\n+                        // from it is fine with this as well.\n+                        trace!(\"initiate: Initiating a raw on a frozen location, not doing a thing\"),\n                     Some(_) =>\n-                        // FIXME: Do we want an exception for raw borrows?\n                         return err!(MachineError(format!(\"Trying to mutate frozen location\")))\n                 }\n             }\n@@ -180,9 +249,10 @@ impl<'tcx> Stack {\n }\n \n impl State {\n-    fn increment_clock(&mut self) -> Timestamp {\n-        self.clock += 1;\n-        self.clock\n+    fn increment_clock(&self) -> Timestamp {\n+        let val = self.clock.get();\n+        self.clock.set(val + 1);\n+        val\n     }\n }\n \n@@ -221,88 +291,219 @@ impl<'tcx> Stacks {\n         ptr: Pointer<Borrow>,\n         size: Size,\n         new_bor: Borrow,\n+        permit_redundant: bool,\n     ) -> EvalResult<'tcx> {\n         let mut stacks = self.stacks.borrow_mut();\n         for stack in stacks.iter_mut(ptr.offset, size) {\n-            if stack.check(new_bor) {\n+            if permit_redundant && stack.check(new_bor) {\n                 // The new borrow is already active!  This can happen when creating multiple\n                 // shared references from the same mutable reference.  Do nothing.\n+                trace!(\"reborrow: New borrow {:?} is already active, not doing a thing\", new_bor);\n             } else {\n-                // FIXME: The blog post says we should `reset` if this is a local.\n+                // If we are creating a uniq ref, we certainly want to unfreeze.\n+                // Even if we are doing so from a raw.\n+                // Notice that if this is a local, whenever we access it directly the\n+                // tag here will be the bottommost `Uniq` for that local.  That `Uniq`\n+                // never is accessible by the program, so it will not be used by any\n+                // other access.  IOW, whenever we directly use a local this will pop\n+                // everything else off the stack, invalidating all previous pointers\n+                // and, in particular, *all* raw pointers.  This subsumes the explicit\n+                // `reset` which the blog post [1] says to perform when accessing a local.\n+                //\n+                // [1] https://www.ralfj.de/blog/2018/08/07/stacked-borrows.html\n                 stack.reactivate(ptr.tag, /*force_mut*/new_bor.is_uniq())?;\n                 stack.initiate(new_bor)?;\n             }\n         }\n \n         Ok(())\n     }\n+\n+    /// Pushes the first borrow to the stacks, must be a mutable one.\n+    pub fn first_borrow(\n+        &mut self,\n+        mut_borrow: Mut,\n+        size: Size\n+    ) {\n+        for stack in self.stacks.get_mut().iter_mut(Size::ZERO, size) {\n+            assert!(stack.borrows.len() == 1 && stack.frozen_since.is_none());\n+            assert_eq!(stack.borrows.pop().unwrap(), BorStackItem::Mut(Mut::Raw));\n+            stack.borrows.push(BorStackItem::Mut(mut_borrow));\n+        }\n+    }\n }\n \n-/// Machine hooks\n pub trait EvalContextExt<'tcx> {\n+    fn tag_for_pointee(\n+        &self,\n+        pointee_ty: Ty<'tcx>,\n+        ref_kind: RefKind,\n+    ) -> Borrow;\n+\n     fn tag_reference(\n-        &mut self,\n+        &self,\n         ptr: Pointer<Borrow>,\n         pointee_ty: Ty<'tcx>,\n         size: Size,\n-        borrow_kind: Option<mir::BorrowKind>,\n+        ref_kind: RefKind,\n     ) -> EvalResult<'tcx, Borrow>;\n \n+\n     fn tag_dereference(\n         &self,\n         ptr: Pointer<Borrow>,\n-        ptr_ty: Ty<'tcx>,\n+        pointee_ty: Ty<'tcx>,\n+        size: Size,\n+        ref_kind: RefKind,\n     ) -> EvalResult<'tcx, Borrow>;\n+\n+    fn tag_new_allocation(\n+        &mut self,\n+        id: AllocId,\n+        kind: MemoryKind<MiriMemoryKind>,\n+    ) -> Borrow;\n }\n \n impl<'a, 'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'a, 'mir, 'tcx> {\n-    fn tag_reference(\n-        &mut self,\n-        ptr: Pointer<Borrow>,\n+    fn tag_for_pointee(\n+        &self,\n         pointee_ty: Ty<'tcx>,\n-        size: Size,\n-        borrow_kind: Option<mir::BorrowKind>,\n-    ) -> EvalResult<'tcx, Borrow> {\n+        ref_kind: RefKind,\n+    ) -> Borrow {\n         let time = self.machine.stacked_borrows.increment_clock();\n-        let new_bor = match borrow_kind {\n-            Some(mir::BorrowKind::Mut { .. }) => Borrow::Mut(Mut::Uniq(time)),\n-            Some(_) =>\n+        match ref_kind {\n+            RefKind::Mut => Borrow::Mut(Mut::Uniq(time)),\n+            RefKind::Shr =>\n                 // FIXME This does not do enough checking when only part of the data has\n                 // interior mutability. When the type is `(i32, Cell<i32>)`, we want the\n                 // first field to be frozen but not the second.\n                 if self.type_is_freeze(pointee_ty) {\n                     Borrow::Frz(time)\n                 } else {\n+                    // Shared reference with interior mutability.\n                     Borrow::Mut(Mut::Raw)\n                 },\n-            None => Borrow::Mut(Mut::Raw),\n-        };\n+            RefKind::Raw => Borrow::Mut(Mut::Raw),\n+        }\n+    }\n+\n+    /// Called for place-to-value conversion.\n+    fn tag_reference(\n+        &self,\n+        ptr: Pointer<Borrow>,\n+        pointee_ty: Ty<'tcx>,\n+        size: Size,\n+        ref_kind: RefKind,\n+    ) -> EvalResult<'tcx, Borrow> {\n+        let new_bor = self.tag_for_pointee(pointee_ty, ref_kind);\n         trace!(\"tag_reference: Creating new reference ({:?}) for {:?} (pointee {}, size {}): {:?}\",\n-            borrow_kind, ptr, pointee_ty, size.bytes(), new_bor);\n+            ref_kind, ptr, pointee_ty, size.bytes(), new_bor);\n \n         // Make sure this reference is not dangling or so\n-        self.memory.check_bounds(ptr, size, false)?;\n+        self.memory().check_bounds(ptr, size, false)?;\n \n         // Update the stacks.  We cannot use `get_mut` becuse this might be immutable\n         // memory.\n-        let alloc = self.memory.get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n-        alloc.extra.reborrow(ptr, size, new_bor)?;\n+        let alloc = self.memory().get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n+        let permit_redundant = ref_kind == RefKind::Shr; // redundant shared refs are okay\n+        alloc.extra.reborrow(ptr, size, new_bor, permit_redundant)?;\n \n         Ok(new_bor)\n     }\n \n+    /// Called for value-to-place conversion.\n+    ///\n+    /// Note that this does NOT mean that all this memory will actually get accessed/referenced!\n+    /// We could be in the middle of `&(*var).1`.\n     fn tag_dereference(\n         &self,\n         ptr: Pointer<Borrow>,\n-        ptr_ty: Ty<'tcx>,\n+        pointee_ty: Ty<'tcx>,\n+        size: Size,\n+        ref_kind: RefKind,\n     ) -> EvalResult<'tcx, Borrow> {\n-        // If this is a raw ptr, forget about the tag.\n-        Ok(if ptr_ty.is_unsafe_ptr() {\n-            trace!(\"tag_dereference: Erasing tag for {:?} ({})\", ptr, ptr_ty);\n-            Borrow::Mut(Mut::Raw)\n-        } else {\n-            // FIXME: Do we want to adjust the tag if it does not match the type?\n-            ptr.tag\n-        })\n+        // In principle we should not have to do anything here.  However, with transmutes involved,\n+        // it can happen that the tag of `ptr` does not actually match `ref_kind`, and we\n+        // should adjust for that.\n+        // Notably, the compiler can introduce such transmutes by optimizing away `&[mut]*`.\n+        // That can transmute a raw ptr to a (shared/mut) ref, and a mut ref to a shared one.\n+        match (ref_kind, ptr.tag) {\n+            (RefKind::Raw, _) => {\n+                // Don't use the tag, this is a raw access!  Even if there is a tag,\n+                // that means transmute happened and we ignore the tag.\n+                // Also don't do any further validation, this is raw after all.\n+                return Ok(Borrow::Mut(Mut::Raw));\n+            }\n+            (RefKind::Mut, Borrow::Mut(Mut::Uniq(_))) |\n+            (RefKind::Shr, Borrow::Frz(_)) |\n+            (RefKind::Shr, Borrow::Mut(Mut::Raw)) => {\n+                // Expected combinations.  Nothing to do.\n+                // FIXME: We probably shouldn't accept this if we got a raw shr without\n+                // interior mutability.\n+            }\n+            (RefKind::Mut, Borrow::Mut(Mut::Raw)) => {\n+                // Raw transmuted to mut ref.  Keep this as raw access.\n+                // We cannot reborrow here; there might be a raw in `&(*var).1` where\n+                // `var` is an `&mut`.  The other field of the struct might be already frozen,\n+                // also using `var`, and that would be okay.\n+            }\n+            (RefKind::Shr, Borrow::Mut(Mut::Uniq(_))) => {\n+                // A mut got transmuted to shr.  High time we freeze this location!\n+                // Make this a delayed reborrow.  Redundant reborows to shr are okay,\n+                // so we do not have to be worried about doing too much.\n+                // FIXME: Reconsider if we really want to mutate things while doing just a deref,\n+                // which, in particular, validation does.\n+                trace!(\"tag_dereference: Lazy freezing of {:?}\", ptr);\n+                return self.tag_reference(ptr, pointee_ty, size, ref_kind);\n+            }\n+            (RefKind::Mut, Borrow::Frz(_)) => {\n+                // This is just invalid.\n+                // If we ever allow this, we have to consider what we do when a turn a\n+                // `Raw`-tagged `&mut` into a raw pointer pointing to a frozen location.\n+                // We probably do not want to allow that, but we have to allow\n+                // turning a `Raw`-tagged `&` into a raw ptr to a frozen location.\n+                return err!(MachineError(format!(\"Encountered mutable reference with frozen tag {:?}\", ptr.tag)))\n+            }\n+        }\n+        // Even if we don't touch the tag, this operation is only okay if we *could*\n+        // activate it.  Also it must not be dangling.\n+        self.memory().check_bounds(ptr, size, false)?;\n+        let alloc = self.memory().get(ptr.alloc_id).expect(\"We checked that the ptr is fine!\");\n+        let mut stacks = alloc.extra.stacks.borrow_mut();\n+        // We need `iter_mut` because `iter` would skip gaps!\n+        for stack in stacks.iter_mut(ptr.offset, size) {\n+            // We accept &mut to a frozen location here, that is just normal.  There might\n+            // be shared reborrows that we are about to invalidate with this access.\n+            // We cannot invalidate them aggressively here because the deref might also be\n+            // to just create more shared refs.\n+            if let Err(err) = stack.reactivatable(ptr.tag, /*force_mut*/false) {\n+                return err!(MachineError(format!(\"Encountered {:?} reference with non-reactivatable tag: {}\", ref_kind, err)))\n+            }\n+        }\n+        // All is good.\n+        Ok(ptr.tag)\n+    }\n+\n+    fn tag_new_allocation(\n+        &mut self,\n+        id: AllocId,\n+        kind: MemoryKind<MiriMemoryKind>,\n+    ) -> Borrow {\n+        let mut_borrow = match kind {\n+            MemoryKind::Stack => {\n+                // New unique borrow\n+                let time = self.machine.stacked_borrows.increment_clock();\n+                Mut::Uniq(time)\n+            }\n+            _ => {\n+                // Raw for everything else\n+                Mut::Raw\n+            }\n+        };\n+        // Make this the active borrow for this allocation\n+        let alloc = self.memory_mut().get_mut(id).expect(\"This is a new allocation, it must still exist\");\n+        let size = Size::from_bytes(alloc.bytes.len() as u64);\n+        alloc.extra.first_borrow(mut_borrow, size);\n+        Borrow::Mut(mut_borrow)\n     }\n }"}, {"sha": "6d853e75fb4aec207cd641359002a7499cd158f3", "filename": "tests/compile-fail-fullmir/stack_free.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail-fullmir%2Fstack_free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail-fullmir%2Fstack_free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail-fullmir%2Fstack_free.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -1,3 +1,6 @@\n+// Validation changes why we fail\n+// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n+\n // error-pattern: tried to deallocate Stack memory but gave Machine(Rust) as the kind\n \n fn main() {"}, {"sha": "8e8912c81fe902de72389ff88349ea44c9f9e536", "filename": "tests/compile-fail/copy_nonoverlapping.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fcopy_nonoverlapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fcopy_nonoverlapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcopy_nonoverlapping.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -15,8 +15,8 @@\n fn main() {\n     let mut data = [0u8; 16];\n     unsafe {\n-        let a = &data[0] as *const _;\n-        let b = &mut data[1] as *mut _;\n+        let a = data.as_mut_ptr();\n+        let b = a.wrapping_offset(1) as *mut _;\n         std::ptr::copy_nonoverlapping(a, b, 2);\n     }\n }"}, {"sha": "7d56f30b3e69db4d636c4c8533527d3ccfae89ed", "filename": "tests/compile-fail/stacked_borrows/alias_through_mutation.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Falias_through_mutation.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -1,3 +1,6 @@\n+// With optimizations, we just store a raw in `x`, and there is no problem.\n+// compile-flags: -Zmir-opt-level=0\n+\n #![allow(unused_variables)]\n \n // This makes a ref that was passed to us via &mut alias with things it should not alias with\n@@ -11,5 +14,5 @@ fn main() {\n     retarget(&mut target_alias, target);\n     // now `target_alias` points to the same thing as `target`\n     *target = 13;\n-    let _val = *target_alias; //~ ERROR should be frozen\n+    let _val = *target_alias; //~ ERROR Shr reference with non-reactivatable tag\n }"}, {"sha": "dc1e3cc81e9e8af25aad5ea982dac399a808e104", "filename": "tests/compile-fail/stacked_borrows/buggy_as_mut_slice.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_as_mut_slice.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -1,3 +1,6 @@\n+// FIXME: Without retagging, optimization kills finding this problem\n+// compile-flags: -Zmir-opt-level=0\n+\n #![allow(unused_variables)]\n \n mod safe {\n@@ -14,6 +17,6 @@ fn main() {\n     let v = vec![0,1,2];\n     let v1 = safe::as_mut_slice(&v);\n     let v2 = safe::as_mut_slice(&v);\n-    v1[1] = 5; //~ ERROR does not exist on the stack\n+    v1[1] = 5; //~ ERROR Mut reference with non-reactivatable tag\n     v1[1] = 6;\n }"}, {"sha": "a697ba9167c0748042b83560a306efa026dd320d", "filename": "tests/compile-fail/stacked_borrows/buggy_split_at_mut.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fbuggy_split_at_mut.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -1,3 +1,6 @@\n+// FIXME: Without retagging, optimization kills finding this problem\n+// compile-flags: -Zmir-opt-level=0\n+\n #![allow(unused_variables)]\n \n mod safe {\n@@ -11,6 +14,7 @@ mod safe {\n             assert!(mid <= len);\n \n             (from_raw_parts_mut(ptr, len - mid), // BUG: should be \"mid\" instead of \"len - mid\"\n+            //~^ ERROR Mut reference with non-reactivatable tag\n             from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n         }\n     }\n@@ -19,6 +23,6 @@ mod safe {\n fn main() {\n     let mut array = [1,2,3,4];\n     let (a, b) = safe::split_at_mut(&mut array, 0);\n-    a[1] = 5; //~ ERROR does not exist on the stack\n+    a[1] = 5;\n     b[1] = 6;\n }"}, {"sha": "6a7ccc84012c667e0bcadff5bc1635b57ea9e11c", "filename": "tests/compile-fail/stacked_borrows/illegal_write.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/af05d1d397ba0d322b3337a567bb50cc2e04e79a/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af05d1d397ba0d322b3337a567bb50cc2e04e79a/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write.rs?ref=af05d1d397ba0d322b3337a567bb50cc2e04e79a", "patch": "@@ -1,11 +0,0 @@\n-fn evil(x: &u32) {\n-    let x : &mut u32 = unsafe { &mut *(x as *const _ as *mut _) };\n-    *x = 42; // mutating shared ref without `UnsafeCell`\n-}\n-\n-fn main() {\n-    let target = 42;\n-    let ref_ = &target;\n-    evil(ref_); // invalidates shared ref\n-    let _x = *ref_; //~ ERROR should be frozen\n-}"}, {"sha": "131e89572a5015559d0ded780003e3a3e754bff5", "filename": "tests/compile-fail/stacked_borrows/illegal_write1.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write1.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -0,0 +1,12 @@\n+fn evil(x: &u32) {\n+    // mutating shared ref without `UnsafeCell`\n+    let x : *mut u32 = x as *const _ as *mut _;\n+    unsafe { *x = 42; }\n+}\n+\n+fn main() {\n+    let target = Box::new(42); // has an implicit raw\n+    let ref_ = &*target;\n+    evil(ref_); // invalidates shared ref, activates raw\n+    let _x = *ref_; //~ ERROR Shr reference with non-reactivatable tag\n+}"}, {"sha": "ac9c3397f5348618480950bb089f848745091194", "filename": "tests/compile-fail/stacked_borrows/illegal_write2.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write2.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -1,10 +1,13 @@\n+// The reborow gets optimized away, so we can only detect this issue without optimizations\n+// compile-flags: -Zmir-opt-level=0\n+\n #![allow(unused_variables)]\n \n fn main() {\n     let target = &mut 42;\n     let target2 = target as *mut _;\n     drop(&mut *target); // reborrow\n-    // Now make sure our ref is still the only one\n-    unsafe { *target2 = 13; } // invalidate our ref\n-    let _val = *target; //~ ERROR does not exist on the stack\n+    // Now make sure our ref is still the only one.\n+    unsafe { *target2 = 13; } //~ ERROR does not exist on the stack\n+    let _val = *target;\n }"}, {"sha": "a653aa5003f6d4da712027e3f1abe154941ccffe", "filename": "tests/compile-fail/stacked_borrows/illegal_write3.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write3.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -0,0 +1,8 @@\n+fn main() {\n+    let target = 42;\n+    // Make sure raw ptr with raw tag cannot mutate frozen location without breaking the shared ref.\n+    let r#ref = &target; // freeze\n+    let ptr = r#ref as *const _ as *mut _; // raw ptr, with raw tag\n+    unsafe { *ptr = 42; } //~ ERROR does not exist on the stack\n+    let _val = *r#ref;\n+}"}, {"sha": "094a38951974bc2ac524156a1443477ddf595258", "filename": "tests/compile-fail/stacked_borrows/illegal_write4.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fillegal_write4.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -0,0 +1,31 @@\n+// The compiler inserts some reborrows, enable optimizations to\n+// get rid of them.\n+// compile-flags: -Zmir-opt-level=1\n+\n+use std::mem;\n+\n+// This is an example of a piece of code that intuitively seems like we might\n+// want to reject it, but that doesn't turn out to be possible.\n+\n+fn main() {\n+    let target = 42;\n+    // Make sure a cannot use a raw-tagged `&mut` pointing to a frozen location, not\n+    // even to create a raw.\n+    let reference = &target; // freeze\n+    let ptr = reference as *const _ as *mut i32; // raw ptr, with raw tag\n+    let mut_ref: &mut i32 = unsafe { mem::transmute(ptr) }; // &mut, with raw tag\n+    // Now we have an &mut to a frozen location, but that is completely normal:\n+    // We'd just unfreeze the location if we used it.\n+    let bad_ptr = mut_ref as *mut i32; // even just creating this is like a use of `mut_ref`.\n+    // That violates the location being frozen!  However, we do not properly detect this:\n+    // We first see a `&mut` with a `Raw` tag being deref'd for a frozen location,\n+    // which can happen legitimately if the compiler optimized away an `&mut*` that\n+    // turns a raw into a `&mut`.  Next, we create a raw ref to a frozen location\n+    // from a `Raw` tag, which can happen legitimately when interior mutability\n+    // is involved.\n+    let _val = *reference; // Make sure it is still frozen.\n+\n+    // We only actually unfreeze once we muteate through the bad pointer.\n+    unsafe { *bad_ptr = 42 }; //~ ERROR does not exist on the stack\n+    let _val = *reference;\n+}"}, {"sha": "060cec962c477d99db2cb5db3af4c8f3703136aa", "filename": "tests/compile-fail/stacked_borrows/load_invalid_mut.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_mut.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -0,0 +1,9 @@\n+// Make sure that we cannot load from memory a `&mut` that got already invalidated.\n+fn main() {\n+    let x = &mut 42;\n+    let xraw = x as *mut _;\n+    let xref = unsafe { &mut *xraw };\n+    let xref_in_mem = Box::new(xref);\n+    let _val = *x; // invalidate xraw\n+    let _val = *xref_in_mem; //~ ERROR Mut reference with non-reactivatable tag\n+}"}, {"sha": "785a15c4704a34565ecae4109284f204bc1377a5", "filename": "tests/compile-fail/stacked_borrows/load_invalid_shr.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_shr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_shr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fload_invalid_shr.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -0,0 +1,9 @@\n+// Make sure that we cannot load from memory a `&` that got already invalidated.\n+fn main() {\n+    let x = &mut 42;\n+    let xraw = x as *mut _;\n+    let xref = unsafe { &*xraw };\n+    let xref_in_mem = Box::new(xref);\n+    let _val = *x; // invalidate xraw\n+    let _val = *xref_in_mem; //~ ERROR Shr reference with non-reactivatable tag: Location should be frozen\n+}"}, {"sha": "64a8ff69108ec06f75140bb68a00325eebd66bc1", "filename": "tests/compile-fail/stacked_borrows/outdated_local.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Foutdated_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Foutdated_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Foutdated_local.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -0,0 +1,9 @@\n+fn main() {\n+    let mut x = 0;\n+    let y: *const i32 = &x;\n+    x = 1; // this invalidates y by reactivating the lowermost uniq borrow for this local\n+\n+    assert_eq!(unsafe { *y }, 1); //~ ERROR does not exist on the stack\n+\n+    assert_eq!(x, 1);\n+}"}, {"sha": "bc950771add4fb9763c9e7676f0eb0fb25ac8ac4", "filename": "tests/compile-fail/stacked_borrows/pass_invalid_mut.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_mut.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -0,0 +1,10 @@\n+// Make sure that we cannot pass by argument a `&mut` that got already invalidated.\n+fn foo(_: &mut i32) {}\n+\n+fn main() {\n+    let x = &mut 42;\n+    let xraw = x as *mut _;\n+    let xref = unsafe { &mut *xraw };\n+    let _val = *x; // invalidate xraw\n+    foo(xref); //~ ERROR Mut reference with non-reactivatable tag\n+}"}, {"sha": "8b7a846d849c0f322191f6eb02ee71cc0559ee63", "filename": "tests/compile-fail/stacked_borrows/pass_invalid_shr.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_shr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_shr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fpass_invalid_shr.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -0,0 +1,10 @@\n+// Make sure that we cannot pass by argument a `&` that got already invalidated.\n+fn foo(_: &i32) {}\n+\n+fn main() {\n+    let x = &mut 42;\n+    let xraw = &*x as *const _;\n+    let xref = unsafe { &*xraw };\n+    let _val = *x; // invalidate xraw\n+    foo(xref); //~ ERROR Shr reference with non-reactivatable tag: Location should be frozen\n+}"}, {"sha": "68f3d2923b15ff062e9695ec32a42740ef13e6ff", "filename": "tests/compile-fail/stacked_borrows/pointer_smuggling.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Fpointer_smuggling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Fpointer_smuggling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fpointer_smuggling.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -10,13 +10,12 @@ fn fun1(x: &mut u8) {\n \n fn fun2() {\n     // Now we use a pointer we are not allowed to use\n-    let _x = unsafe { *PTR };\n+    let _x = unsafe { *PTR }; //~ ERROR does not exist on the stack\n }\n \n fn main() {\n     let val = &mut 0; // FIXME: This should also work with a local variable, but currently it does not.\n     fun1(val);\n     *val = 2; // this invalidates any raw ptrs `fun1` might have created.\n     fun2(); // if they now use a raw ptr they break our reference\n-    *val = 3; //~ ERROR does not exist on the stack\n }"}, {"sha": "c02892671e907f75f9a24891098d69472691b40a", "filename": "tests/compile-fail/stacked_borrows/return_invalid_mut.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_mut.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -0,0 +1,11 @@\n+// Make sure that we cannot return a `&mut` that got already invalidated.\n+fn foo(x: &mut (i32, i32)) -> &mut i32 {\n+    let xraw = x as *mut (i32, i32);\n+    let ret = unsafe { &mut (*xraw).1 };\n+    let _val = *x; // invalidate xraw and its children\n+    ret //~ ERROR Mut reference with non-reactivatable tag\n+}\n+\n+fn main() {\n+    foo(&mut (1, 2));\n+}"}, {"sha": "89c94127b0b7143e79297b557397812c21ef2b71", "filename": "tests/compile-fail/stacked_borrows/return_invalid_shr.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Freturn_invalid_shr.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -0,0 +1,11 @@\n+// Make sure that we cannot return a `&` that got already invalidated.\n+fn foo(x: &mut (i32, i32)) -> &i32 {\n+    let xraw = x as *mut (i32, i32);\n+    let ret = unsafe { &(*xraw).1 };\n+    let _val = *x; // invalidate xraw and its children\n+    ret //~ ERROR Shr reference with non-reactivatable tag: Location should be frozen\n+}\n+\n+fn main() {\n+    foo(&mut (1, 2));\n+}"}, {"sha": "e3e4c4da7765e921a8577f9839b2614a345fa42d", "filename": "tests/compile-fail/stacked_borrows/shared_confusion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fshared_confusion.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -13,7 +13,7 @@ fn test(r: &mut RefCell<i32>) {\n     }\n     // Our old raw should be dead by now\n     unsafe { *x_evil = 0; } // this falls back to some Raw higher up the stack\n-    *x_inner = 12; //~ ERROR does not exist on the stack\n+    *x_inner = 12; //~ ERROR Mut reference with non-reactivatable tag\n }\n \n fn main() {"}, {"sha": "8627cc44c2e5002a0d9a3f1985f57af3853a6240", "filename": "tests/compile-fail/stacked_borrows/unescaped_local.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Funescaped_local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstacked_borrows%2Funescaped_local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Funescaped_local.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -0,0 +1,10 @@\n+use std::mem;\n+\n+// Make sure we cannot use raw ptrs to access a local that\n+// has never been escaped to the raw world.\n+fn main() {\n+    let mut x = 42;\n+    let ptr = &mut x;\n+    let raw: *mut i32 = unsafe { mem::transmute(ptr) };\n+    unsafe { *raw = 13; } //~ ERROR does not exist on the stack\n+}"}, {"sha": "c758926458651c30b11dcd313de3d597ed3069bb", "filename": "tests/compile-fail/static_memory_modification.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstatic_memory_modification.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstatic_memory_modification.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstatic_memory_modification.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -1,3 +1,6 @@\n+// Validation detects that we are casting & to &mut and so it changes why we fail\n+// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n+\n static X: usize = 5;\n \n #[allow(mutable_transmutes)]"}, {"sha": "c9857b20592e4410207eed01c322aabf857c8338", "filename": "tests/compile-fail/static_memory_modification2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstatic_memory_modification2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstatic_memory_modification2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstatic_memory_modification2.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -1,5 +1,5 @@\n // Validation detects that we are casting & to &mut and so it changes why we fail\n-// compile-flags: -Zmir-emit-validate=0\n+// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n \n use std::mem::transmute;\n "}, {"sha": "41a62787296f066a54c37772fc4676ecd5bbbded", "filename": "tests/compile-fail/static_memory_modification3.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstatic_memory_modification3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fstatic_memory_modification3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstatic_memory_modification3.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -1,3 +1,6 @@\n+// Validation detects that we are casting & to &mut and so it changes why we fail\n+// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n+\n use std::mem::transmute;\n \n #[allow(mutable_transmutes)]"}, {"sha": "47317afd36ec9899fa19e0446fe920978b4cc28c", "filename": "tests/compile-fail/unaligned_ptr_cast.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Funaligned_ptr_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Funaligned_ptr_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Funaligned_ptr_cast.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -1,3 +1,6 @@\n+// This should fail even without validation\n+// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n+\n fn main() {\n     let x = &2u16;\n     let x = x as *const _ as *const u32;"}, {"sha": "d146f21dfe60fd7e50820ac0d35c7abe063f829f", "filename": "tests/compile-fail/unaligned_ptr_cast2.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Funaligned_ptr_cast2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Funaligned_ptr_cast2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Funaligned_ptr_cast2.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -1,3 +1,6 @@\n+// This should fail even without validation\n+// compile-flags: -Zmir-emit-validate=0 -Zmiri-disable-validation\n+\n fn main() {\n     let x = &2u16;\n     let x = x as *const _ as *const *const u8;"}, {"sha": "c5845cb693bb3d9796a48092aebdb736d5b87e89", "filename": "tests/compile-fail/validity/dangling_ref1.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fvalidity%2Fdangling_ref1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fvalidity%2Fdangling_ref1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidity%2Fdangling_ref1.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -0,0 +1,5 @@\n+use std::mem;\n+\n+fn main() {\n+    let _x: &i32 = unsafe { mem::transmute(16usize) }; //~ ERROR tried to interpret some bytes as a pointer\n+}"}, {"sha": "21650ebf950673e4943128ef24a8e44c2a2c8cb2", "filename": "tests/compile-fail/validity/dangling_ref2.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fvalidity%2Fdangling_ref2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fvalidity%2Fdangling_ref2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidity%2Fdangling_ref2.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -0,0 +1,7 @@\n+use std::mem;\n+\n+fn main() {\n+    let val = 14;\n+    let ptr = (&val as *const i32).wrapping_offset(1);\n+    let _x: &i32 = unsafe { mem::transmute(ptr) }; //~ ERROR outside bounds of allocation\n+}"}, {"sha": "f86fef9454e82891f1b8e15a3450788b18b1a3fa", "filename": "tests/compile-fail/validity/undef.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fvalidity%2Fundef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fvalidity%2Fundef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidity%2Fundef.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -1,5 +1,5 @@\n #![allow(unused_variables)]\n-// error-pattern: encountered undefined data in pointer\n+// error-pattern: encountered undefined address in pointer\n \n use std::mem;\n "}, {"sha": "544d65a1bffa66fdef177d5814328317d8324096", "filename": "tests/compile-fail/zst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fzst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompile-fail%2Fzst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fzst.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n     let x = &() as *const () as *const i32;\n-    let _ = unsafe { *x }; //~ ERROR tried to access memory with alignment 1, but alignment 4 is required\n+    let _ = unsafe { *x }; //~ ERROR access memory with alignment 1, but alignment 4 is required\n }"}, {"sha": "0b2058597e185ab21ca826b36495bf6c46edbd74", "filename": "tests/compiletest.rs", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -37,7 +37,7 @@ fn have_fullmir() -> bool {\n     std::env::var(\"MIRI_SYSROOT\").is_ok() || rustc_test_suite().is_some()\n }\n \n-fn compile_fail(sysroot: &Path, path: &str, target: &str, host: &str, need_fullmir: bool) {\n+fn compile_fail(sysroot: &Path, path: &str, target: &str, host: &str, need_fullmir: bool, opt: bool) {\n     if need_fullmir && !have_fullmir() {\n         eprintln!(\"{}\", format!(\n             \"## Skipping compile-fail tests in {} against miri for target {} due to missing mir\",\n@@ -47,24 +47,34 @@ fn compile_fail(sysroot: &Path, path: &str, target: &str, host: &str, need_fullm\n         return;\n     }\n \n+    let opt_str = if opt { \" with optimizations\" } else { \"\" };\n     eprintln!(\"{}\", format!(\n-        \"## Running compile-fail tests in {} against miri for target {}\",\n+        \"## Running compile-fail tests in {} against miri for target {}{}\",\n         path,\n-        target\n+        target,\n+        opt_str\n     ).green().bold());\n+\n+    let mut flags = Vec::new();\n+    flags.push(format!(\"--sysroot {}\", sysroot.display()));\n+    flags.push(\"-Dwarnings -Dunused\".to_owned()); // overwrite the -Aunused in compiletest-rs\n+    flags.push(\"-Zmir-emit-validate=1\".to_owned());\n+    if opt {\n+        // Optimizing too aggressivley makes UB detection harder, but test at least\n+        // the default value.\n+        flags.push(\"-Zmir-opt-level=1\".to_owned());\n+    } else {\n+        flags.push(\"-Zmir-opt-level=0\".to_owned());\n+    }\n+\n     let mut config = compiletest::Config::default().tempdir();\n     config.mode = \"compile-fail\".parse().expect(\"Invalid mode\");\n     config.rustc_path = miri_path();\n-    let mut flags = Vec::new();\n     if rustc_test_suite().is_some() {\n         config.run_lib_path = rustc_lib_path();\n         config.compile_lib_path = rustc_lib_path();\n     }\n-    flags.push(format!(\"--sysroot {}\", sysroot.display()));\n-    flags.push(\"-Dwarnings -Dunused\".to_owned()); // overwrite the -Aunused in compiletest-rs\n     config.src_base = PathBuf::from(path.to_string());\n-    flags.push(\"-Zmir-opt-level=0\".to_owned()); // optimization circumvents some stacked borrow checks\n-    flags.push(\"-Zmir-emit-validate=1\".to_owned());\n     config.target_rustcflags = Some(flags.join(\" \"));\n     config.target = target.to_owned();\n     config.host = host.to_owned();\n@@ -88,6 +98,17 @@ fn miri_pass(sysroot: &Path, path: &str, target: &str, host: &str, need_fullmir:\n         target,\n         opt_str\n     ).green().bold());\n+\n+    let mut flags = Vec::new();\n+    flags.push(format!(\"--sysroot {}\", sysroot.display()));\n+    flags.push(\"-Dwarnings -Dunused\".to_owned()); // overwrite the -Aunused in compiletest-rs\n+    flags.push(\"-Zmir-emit-validate=1\".to_owned());\n+    if opt {\n+        flags.push(\"-Zmir-opt-level=3\".to_owned());\n+    } else {\n+        flags.push(\"-Zmir-opt-level=0\".to_owned());\n+    }\n+\n     let mut config = compiletest::Config::default().tempdir();\n     config.mode = \"ui\".parse().expect(\"Invalid mode\");\n     config.src_base = PathBuf::from(path);\n@@ -98,16 +119,6 @@ fn miri_pass(sysroot: &Path, path: &str, target: &str, host: &str, need_fullmir:\n         config.run_lib_path = rustc_lib_path();\n         config.compile_lib_path = rustc_lib_path();\n     }\n-    let mut flags = Vec::new();\n-    flags.push(format!(\"--sysroot {}\", sysroot.display()));\n-    flags.push(\"-Dwarnings -Dunused\".to_owned()); // overwrite the -Aunused in compiletest-rs\n-    if opt {\n-        flags.push(\"-Zmir-opt-level=3\".to_owned());\n-    } else {\n-        flags.push(\"-Zmir-opt-level=0\".to_owned());\n-        // For now, only validate without optimizations.  Inlining breaks validation.\n-        flags.push(\"-Zmir-emit-validate=1\".to_owned());\n-    }\n     config.target_rustcflags = Some(flags.join(\" \"));\n     compiletest::run_tests(&config);\n }\n@@ -169,13 +180,13 @@ fn run_pass_miri(opt: bool) {\n     miri_pass(&sysroot, \"tests/run-pass-fullmir\", &host, &host, true, opt);\n }\n \n-fn compile_fail_miri() {\n+fn compile_fail_miri(opt: bool) {\n     let sysroot = get_sysroot();\n     let host = get_host();\n \n     // FIXME: run tests for other targets, too\n-    compile_fail(&sysroot, \"tests/compile-fail\", &host, &host, false);\n-    compile_fail(&sysroot, \"tests/compile-fail-fullmir\", &host, &host, true);\n+    compile_fail(&sysroot, \"tests/compile-fail\", &host, &host, false, opt);\n+    compile_fail(&sysroot, \"tests/compile-fail-fullmir\", &host, &host, true, opt);\n }\n \n #[test]\n@@ -187,5 +198,6 @@ fn test() {\n     run_pass_miri(false);\n     run_pass_miri(true);\n \n-    compile_fail_miri();\n+    compile_fail_miri(false);\n+    compile_fail_miri(true);\n }"}, {"sha": "0264099eb68dc338a95acba2c16bb75cabf3aff8", "filename": "tests/run-pass-fullmir/integer-ops.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Frun-pass-fullmir%2Finteger-ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Frun-pass-fullmir%2Finteger-ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Finteger-ops.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -8,9 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// FIXME: remove -Zmir-opt-level once https://github.com/rust-lang/rust/issues/43359 is fixed\n-// compile-flags: -Zmir-opt-level=0\n-\n use std::i32;\n \n pub fn main() {"}, {"sha": "282f7a3595032d0ba427747e18a0e57d5e74fa42", "filename": "tests/run-pass-fullmir/send-is-not-static-par-for.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Frun-pass-fullmir%2Fsend-is-not-static-par-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Frun-pass-fullmir%2Fsend-is-not-static-par-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fsend-is-not-static-par-for.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// FIXME: Still investigating whether there is UB here\n+// compile-flags: -Zmiri-disable-validation\n+\n use std::sync::Mutex;\n \n fn par_for<I, F>(iter: I, f: F)"}, {"sha": "0f1b6e8b5870871f38fb0d07e3f113beb8dcee7e", "filename": "tests/run-pass-fullmir/u128.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Frun-pass-fullmir%2Fu128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Frun-pass-fullmir%2Fu128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fu128.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// FIXME: Still investigating whether there is UB here\n+// compile-flags: -Zmiri-disable-validation\n+\n fn b<T>(t: T) -> T { t }\n \n fn main() {"}, {"sha": "ffbb11668498593274c55d835a152df58e75711e", "filename": "tests/run-pass-fullmir/vecdeque.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Frun-pass-fullmir%2Fvecdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Frun-pass-fullmir%2Fvecdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-fullmir%2Fvecdeque.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -1,3 +1,6 @@\n+// FIXME: Still investigating whether there is UB here\n+// compile-flags: -Zmiri-disable-validation\n+\n use std::collections::VecDeque;\n \n fn main() {"}, {"sha": "8639a289363bad4560d30cf8b2c5910bfc5304f3", "filename": "tests/run-pass/deref_partially_dangling_raw.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Frun-pass%2Fderef_partially_dangling_raw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Frun-pass%2Fderef_partially_dangling_raw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fderef_partially_dangling_raw.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -0,0 +1,9 @@\n+// Deref a raw ptr to access a field of a large struct, where the field\n+// is allocated but not the entire struct is.\n+// For now, we want to allow this.\n+\n+fn main() {\n+    let x = (1, 1);\n+    let xptr = &x as *const _ as *const (i32, i32, i32);\n+    let _val = unsafe { (*xptr).1 };\n+}"}, {"sha": "c58e8c84bb2e794b9196ce9b45942feb338a173e", "filename": "tests/run-pass/observed_local_mut.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Frun-pass%2Fobserved_local_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Frun-pass%2Fobserved_local_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fobserved_local_mut.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -1,3 +1,6 @@\n+// Validation catches this (correctly) as UB.\n+// compile-flags: -Zmiri-disable-validation\n+\n // This test is intended to guard against the problem described in commit\n // 39bb1254d1eaf74f45a4e741097e33fc942168d5.\n //"}, {"sha": "6b778248be5c6af180d53d4d2f2fd4fd5c039e9b", "filename": "tests/run-pass/ptr_arith_offset_overflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Frun-pass%2Fptr_arith_offset_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c57f2ba358e391c0c522d3023f69f2c278111ca/tests%2Frun-pass%2Fptr_arith_offset_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fptr_arith_offset_overflow.rs?ref=9c57f2ba358e391c0c522d3023f69f2c278111ca", "patch": "@@ -1,6 +1,6 @@\n fn main() {\n     let v = [1i16, 2];\n-    let x = &v[1] as *const i16;\n+    let x = v.as_ptr().wrapping_offset(1); // ptr to the 2nd element\n     // Adding 2*isize::max and then 1 is like substracting 1\n     let x = x.wrapping_offset(isize::max_value());\n     let x = x.wrapping_offset(isize::max_value());"}]}