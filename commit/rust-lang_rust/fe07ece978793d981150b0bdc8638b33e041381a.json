{"sha": "fe07ece978793d981150b0bdc8638b33e041381a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlMDdlY2U5Nzg3OTNkOTgxMTUwYjBiZGM4NjM4YjMzZTA0MTM4MWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-24T18:03:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-24T18:03:55Z"}, "message": "Auto merge of #74724 - Manishearth:rollup-plbt8fe, r=Manishearth\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #72954 (revise RwLock for HermitCore)\n - #74367 (Rearrange the pipeline of `pow` to gain efficiency)\n - #74491 (Optimize away BitAnd and BitOr when possible)\n - #74639 (Downgrade glibc to 2.11.1 for ppc, ppc64 and s390x)\n - #74661 (Refactor `region_name`: add `RegionNameHighlight`)\n - #74692 (delay_span_bug instead of silent ignore)\n - #74698 (fixed error reporting for mismatched traits)\n - #74715 (Add a system for creating diffs across multiple mir optimizations.)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "f3ac84d7cc534725e2bda5215267c820f98a5a0f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3ac84d7cc534725e2bda5215267c820f98a5a0f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe07ece978793d981150b0bdc8638b33e041381a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe07ece978793d981150b0bdc8638b33e041381a", "html_url": "https://github.com/rust-lang/rust/commit/fe07ece978793d981150b0bdc8638b33e041381a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe07ece978793d981150b0bdc8638b33e041381a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfb6114b2a20e04e3212ed030bc68d23faf8048f", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfb6114b2a20e04e3212ed030bc68d23faf8048f", "html_url": "https://github.com/rust-lang/rust/commit/cfb6114b2a20e04e3212ed030bc68d23faf8048f"}, {"sha": "5d1d94e7b8feeed42447a8922105462969dd9e81", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d1d94e7b8feeed42447a8922105462969dd9e81", "html_url": "https://github.com/rust-lang/rust/commit/5d1d94e7b8feeed42447a8922105462969dd9e81"}], "stats": {"total": 1685, "additions": 963, "deletions": 722}, "files": [{"sha": "d6fb659178764e2e21b736cc74194f9d57cd481e", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=fe07ece978793d981150b0bdc8638b33e041381a", "patch": "@@ -1242,9 +1242,9 @@ dependencies = [\n \n [[package]]\n name = \"hermit-abi\"\n-version = \"0.1.14\"\n+version = \"0.1.15\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b9586eedd4ce6b3c498bc3b4dd92fc9f11166aa908a914071953768066c67909\"\n+checksum = \"3deed196b6e7f9e44a2ae8d94225d80302d81208b1bb673fd21fe634645c85a9\"\n dependencies = [\n  \"compiler_builtins\",\n  \"libc\","}, {"sha": "1a1c1618da40de27ec2c09fac5a7252bdb128ec9", "filename": "src/ci/docker/README.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Fci%2Fdocker%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Fci%2Fdocker%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2FREADME.md?ref=fe07ece978793d981150b0bdc8638b33e041381a", "patch": "@@ -238,7 +238,7 @@ For targets: `powerpc-unknown-linux-gnu`\n - Target options > Emit assembly for CPU = powerpc -- pure 32-bit PowerPC\n - Operating System > Target OS = linux\n - Operating System > Linux kernel version = 2.6.32.68 -- ~RHEL6 kernel\n-- C-library > glibc version = 2.12.2 -- ~RHEL6 glibc\n+- C-library > glibc version = 2.11.1 -- ~SLE11-SP4 glibc\n - C compiler > gcc version = 5.2.0\n - C compiler > C++ = ENABLE -- to cross compile LLVM\n \n@@ -255,7 +255,7 @@ For targets: `powerpc64-unknown-linux-gnu`\n - Target options > Tune for CPU = power6 -- (+)\n - Operating System > Target OS = linux\n - Operating System > Linux kernel version = 2.6.32.68 -- ~RHEL6 kernel\n-- C-library > glibc version = 2.12.2 -- ~RHEL6 glibc\n+- C-library > glibc version = 2.11.1 -- ~SLE11-SP4 glibc\n - C compiler > gcc version = 5.2.0\n - C compiler > C++ = ENABLE -- to cross compile LLVM\n \n@@ -272,7 +272,7 @@ For targets: `s390x-unknown-linux-gnu`\n - Target options > Bitness = 64-bit\n - Operating System > Target OS = linux\n - Operating System > Linux kernel version = 2.6.32.68 -- ~RHEL6 kernel\n-- C-library > glibc version = 2.12.2 -- ~RHEL6 glibc\n+- C-library > glibc version = 2.11.1 -- ~SLE11-SP4 glibc\n - C compiler > gcc version = 5.2.0\n - C compiler > gcc extra config = --with-arch=z10 -- LLVM's minimum support\n - C compiler > C++ = ENABLE -- to cross compile LLVM"}, {"sha": "744eb180cd1f670cd52f3b47ccce8ce645e20a91", "filename": "src/ci/docker/host-x86_64/dist-powerpc-linux/patches/glibc/2.11.1/001-PowerPC-Remove-unnecessary-mnew-mnemonics.patch", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc-linux%2Fpatches%2Fglibc%2F2.11.1%2F001-PowerPC-Remove-unnecessary-mnew-mnemonics.patch", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc-linux%2Fpatches%2Fglibc%2F2.11.1%2F001-PowerPC-Remove-unnecessary-mnew-mnemonics.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc-linux%2Fpatches%2Fglibc%2F2.11.1%2F001-PowerPC-Remove-unnecessary-mnew-mnemonics.patch?ref=fe07ece978793d981150b0bdc8638b33e041381a", "previous_filename": "src/ci/docker/host-x86_64/dist-powerpc-linux/patches/glibc/2.12.2/001-PowerPC-Remove-unnecessary-mnew-mnemonics.patch"}, {"sha": "a96b4882c2d5765e3a600e77ebbef747f6e4d9ff", "filename": "src/ci/docker/host-x86_64/dist-powerpc-linux/patches/glibc/2.11.1/002-newer-gcc.patch", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc-linux%2Fpatches%2Fglibc%2F2.11.1%2F002-newer-gcc.patch", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc-linux%2Fpatches%2Fglibc%2F2.11.1%2F002-newer-gcc.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc-linux%2Fpatches%2Fglibc%2F2.11.1%2F002-newer-gcc.patch?ref=fe07ece978793d981150b0bdc8638b33e041381a", "previous_filename": "src/ci/docker/host-x86_64/dist-powerpc-linux/patches/glibc/2.12.2/002-newer-gcc.patch"}, {"sha": "b358dce3cdfe855d41203fa02517c461df7d58af", "filename": "src/ci/docker/host-x86_64/dist-powerpc-linux/powerpc-linux-gnu.config", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc-linux%2Fpowerpc-linux-gnu.config", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc-linux%2Fpowerpc-linux-gnu.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc-linux%2Fpowerpc-linux-gnu.config?ref=fe07ece978793d981150b0bdc8638b33e041381a", "patch": "@@ -290,7 +290,7 @@ CT_BINUTILS_EXTRA_CONFIG_ARRAY=\"\"\n # C-library\n #\n CT_LIBC=\"glibc\"\n-CT_LIBC_VERSION=\"2.12.2\"\n+CT_LIBC_VERSION=\"2.11.1\"\n CT_LIBC_glibc=y\n # CT_LIBC_musl is not set\n # CT_LIBC_uClibc is not set\n@@ -309,9 +309,9 @@ CT_THREADS=\"nptl\"\n # CT_LIBC_GLIBC_V_2_14_1 is not set\n # CT_LIBC_GLIBC_V_2_14 is not set\n # CT_LIBC_GLIBC_V_2_13 is not set\n-CT_LIBC_GLIBC_V_2_12_2=y\n+# CT_LIBC_GLIBC_V_2_12_2 is not set\n # CT_LIBC_GLIBC_V_2_12_1 is not set\n-# CT_LIBC_GLIBC_V_2_11_1 is not set\n+CT_LIBC_GLIBC_V_2_11_1=y\n # CT_LIBC_GLIBC_V_2_11 is not set\n # CT_LIBC_GLIBC_V_2_10_1 is not set\n # CT_LIBC_GLIBC_V_2_9 is not set"}, {"sha": "744eb180cd1f670cd52f3b47ccce8ce645e20a91", "filename": "src/ci/docker/host-x86_64/dist-powerpc64-linux/patches/glibc/2.11.1/001-PowerPC-Remove-unnecessary-mnew-mnemonics.patch", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2Fpatches%2Fglibc%2F2.11.1%2F001-PowerPC-Remove-unnecessary-mnew-mnemonics.patch", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2Fpatches%2Fglibc%2F2.11.1%2F001-PowerPC-Remove-unnecessary-mnew-mnemonics.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2Fpatches%2Fglibc%2F2.11.1%2F001-PowerPC-Remove-unnecessary-mnew-mnemonics.patch?ref=fe07ece978793d981150b0bdc8638b33e041381a", "previous_filename": "src/ci/docker/host-x86_64/dist-powerpc64-linux/patches/glibc/2.12.2/001-PowerPC-Remove-unnecessary-mnew-mnemonics.patch"}, {"sha": "47cc8b28d225a11d496593d510e43f6bc7fa2e7b", "filename": "src/ci/docker/host-x86_64/dist-powerpc64-linux/patches/glibc/2.11.1/002-Prevent-inlining-in-PPC64-initfini.s.patch", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2Fpatches%2Fglibc%2F2.11.1%2F002-Prevent-inlining-in-PPC64-initfini.s.patch", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2Fpatches%2Fglibc%2F2.11.1%2F002-Prevent-inlining-in-PPC64-initfini.s.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2Fpatches%2Fglibc%2F2.11.1%2F002-Prevent-inlining-in-PPC64-initfini.s.patch?ref=fe07ece978793d981150b0bdc8638b33e041381a", "previous_filename": "src/ci/docker/host-x86_64/dist-powerpc64-linux/patches/glibc/2.12.2/002-Prevent-inlining-in-PPC64-initfini.s.patch"}, {"sha": "a96b4882c2d5765e3a600e77ebbef747f6e4d9ff", "filename": "src/ci/docker/host-x86_64/dist-powerpc64-linux/patches/glibc/2.11.1/003-newer-gcc.patch", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2Fpatches%2Fglibc%2F2.11.1%2F003-newer-gcc.patch", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2Fpatches%2Fglibc%2F2.11.1%2F003-newer-gcc.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2Fpatches%2Fglibc%2F2.11.1%2F003-newer-gcc.patch?ref=fe07ece978793d981150b0bdc8638b33e041381a", "previous_filename": "src/ci/docker/host-x86_64/dist-powerpc64-linux/patches/glibc/2.12.2/003-newer-gcc.patch"}, {"sha": "aa13119d50c19f346b521037f2f490a5e82de246", "filename": "src/ci/docker/host-x86_64/dist-powerpc64-linux/powerpc64-linux-gnu.config", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2Fpowerpc64-linux-gnu.config", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2Fpowerpc64-linux-gnu.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-powerpc64-linux%2Fpowerpc64-linux-gnu.config?ref=fe07ece978793d981150b0bdc8638b33e041381a", "patch": "@@ -290,7 +290,7 @@ CT_BINUTILS_EXTRA_CONFIG_ARRAY=\"\"\n # C-library\n #\n CT_LIBC=\"glibc\"\n-CT_LIBC_VERSION=\"2.12.2\"\n+CT_LIBC_VERSION=\"2.11.1\"\n CT_LIBC_glibc=y\n # CT_LIBC_musl is not set\n # CT_LIBC_uClibc is not set\n@@ -309,9 +309,9 @@ CT_THREADS=\"nptl\"\n # CT_LIBC_GLIBC_V_2_14_1 is not set\n # CT_LIBC_GLIBC_V_2_14 is not set\n # CT_LIBC_GLIBC_V_2_13 is not set\n-CT_LIBC_GLIBC_V_2_12_2=y\n+# CT_LIBC_GLIBC_V_2_12_2 is not set\n # CT_LIBC_GLIBC_V_2_12_1 is not set\n-# CT_LIBC_GLIBC_V_2_11_1 is not set\n+CT_LIBC_GLIBC_V_2_11_1=y\n # CT_LIBC_GLIBC_V_2_11 is not set\n # CT_LIBC_GLIBC_V_2_10_1 is not set\n # CT_LIBC_GLIBC_V_2_9 is not set"}, {"sha": "cba416ed2f70bc12990229442e23feb47a0fdd3c", "filename": "src/ci/docker/host-x86_64/dist-s390x-linux/patches/glibc/2.11.1/001-Use-.machine-to-prevent-AS-from-complaining-about-z9.patch", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-s390x-linux%2Fpatches%2Fglibc%2F2.11.1%2F001-Use-.machine-to-prevent-AS-from-complaining-about-z9.patch", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-s390x-linux%2Fpatches%2Fglibc%2F2.11.1%2F001-Use-.machine-to-prevent-AS-from-complaining-about-z9.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-s390x-linux%2Fpatches%2Fglibc%2F2.11.1%2F001-Use-.machine-to-prevent-AS-from-complaining-about-z9.patch?ref=fe07ece978793d981150b0bdc8638b33e041381a", "previous_filename": "src/ci/docker/host-x86_64/dist-s390x-linux/patches/glibc/2.12.2/001-Use-.machine-to-prevent-AS-from-complaining-about-z9.patch"}, {"sha": "a96b4882c2d5765e3a600e77ebbef747f6e4d9ff", "filename": "src/ci/docker/host-x86_64/dist-s390x-linux/patches/glibc/2.11.1/002-newer-gcc.patch", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-s390x-linux%2Fpatches%2Fglibc%2F2.11.1%2F002-newer-gcc.patch", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-s390x-linux%2Fpatches%2Fglibc%2F2.11.1%2F002-newer-gcc.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-s390x-linux%2Fpatches%2Fglibc%2F2.11.1%2F002-newer-gcc.patch?ref=fe07ece978793d981150b0bdc8638b33e041381a", "previous_filename": "src/ci/docker/host-x86_64/dist-s390x-linux/patches/glibc/2.12.2/002-newer-gcc.patch"}, {"sha": "c9c141afad131d1883466c44a7847e0108bf90a5", "filename": "src/ci/docker/host-x86_64/dist-s390x-linux/s390x-linux-gnu.config", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-s390x-linux%2Fs390x-linux-gnu.config", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-s390x-linux%2Fs390x-linux-gnu.config", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fhost-x86_64%2Fdist-s390x-linux%2Fs390x-linux-gnu.config?ref=fe07ece978793d981150b0bdc8638b33e041381a", "patch": "@@ -270,7 +270,7 @@ CT_BINUTILS_EXTRA_CONFIG_ARRAY=\"\"\n # C-library\n #\n CT_LIBC=\"glibc\"\n-CT_LIBC_VERSION=\"2.12.2\"\n+CT_LIBC_VERSION=\"2.11.1\"\n CT_LIBC_glibc=y\n # CT_LIBC_musl is not set\n # CT_LIBC_uClibc is not set\n@@ -289,9 +289,9 @@ CT_THREADS=\"nptl\"\n # CT_LIBC_GLIBC_V_2_14_1 is not set\n # CT_LIBC_GLIBC_V_2_14 is not set\n # CT_LIBC_GLIBC_V_2_13 is not set\n-CT_LIBC_GLIBC_V_2_12_2=y\n+# CT_LIBC_GLIBC_V_2_12_2 is not set\n # CT_LIBC_GLIBC_V_2_12_1 is not set\n-# CT_LIBC_GLIBC_V_2_11_1 is not set\n+CT_LIBC_GLIBC_V_2_11_1=y\n # CT_LIBC_GLIBC_V_2_11 is not set\n # CT_LIBC_GLIBC_V_2_10_1 is not set\n # CT_LIBC_GLIBC_V_2_9 is not set"}, {"sha": "8e9a90352280295f8346ae018e6783727f7575d7", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 44, "deletions": 43, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=fe07ece978793d981150b0bdc8638b33e041381a", "patch": "@@ -1095,6 +1095,9 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n+                if exp == 0 {\n+                    return Some(1);\n+                }\n                 let mut base = self;\n                 let mut acc: Self = 1;\n \n@@ -1105,15 +1108,11 @@ $EndFeature, \"\n                     exp /= 2;\n                     base = try_opt!(base.checked_mul(base));\n                 }\n-\n+                // since exp!=0, finally the exp must be 1.\n                 // Deal with the final bit of the exponent separately, since\n                 // squaring the base afterwards is not necessary and may cause a\n                 // needless overflow.\n-                if exp == 1 {\n-                    acc = try_opt!(acc.checked_mul(base));\n-                }\n-\n-                Some(acc)\n+                Some(try_opt!(acc.checked_mul(base)))\n             }\n         }\n \n@@ -1622,6 +1621,9 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n+                if exp == 0 {\n+                    return 1;\n+                }\n                 let mut base = self;\n                 let mut acc: Self = 1;\n \n@@ -1633,14 +1635,11 @@ $EndFeature, \"\n                     base = base.wrapping_mul(base);\n                 }\n \n+                // since exp!=0, finally the exp must be 1.\n                 // Deal with the final bit of the exponent separately, since\n                 // squaring the base afterwards is not necessary and may cause a\n                 // needless overflow.\n-                if exp == 1 {\n-                    acc = acc.wrapping_mul(base);\n-                }\n-\n-                acc\n+                acc.wrapping_mul(base)\n             }\n         }\n \n@@ -1989,6 +1988,9 @@ $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n+                if exp == 0 {\n+                    return (1,false);\n+                }\n                 let mut base = self;\n                 let mut acc: Self = 1;\n                 let mut overflown = false;\n@@ -2007,16 +2009,13 @@ $EndFeature, \"\n                     overflown |= r.1;\n                 }\n \n+                // since exp!=0, finally the exp must be 1.\n                 // Deal with the final bit of the exponent separately, since\n                 // squaring the base afterwards is not necessary and may cause a\n                 // needless overflow.\n-                if exp == 1 {\n-                    r = acc.overflowing_mul(base);\n-                    acc = r.0;\n-                    overflown |= r.1;\n-                }\n-\n-                (acc, overflown)\n+                r = acc.overflowing_mul(base);\n+                r.1 |= overflown;\n+                r\n             }\n         }\n \n@@ -2040,6 +2039,9 @@ $EndFeature, \"\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             pub const fn pow(self, mut exp: u32) -> Self {\n+                if exp == 0 {\n+                    return 1;\n+                }\n                 let mut base = self;\n                 let mut acc = 1;\n \n@@ -2051,14 +2053,11 @@ $EndFeature, \"\n                     base = base * base;\n                 }\n \n+                // since exp!=0, finally the exp must be 1.\n                 // Deal with the final bit of the exponent separately, since\n                 // squaring the base afterwards is not necessary and may cause a\n                 // needless overflow.\n-                if exp == 1 {\n-                    acc = acc * base;\n-                }\n-\n-                acc\n+                acc * base\n             }\n         }\n \n@@ -3295,6 +3294,9 @@ assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\", $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn checked_pow(self, mut exp: u32) -> Option<Self> {\n+                if exp == 0 {\n+                    return Some(1);\n+                }\n                 let mut base = self;\n                 let mut acc: Self = 1;\n \n@@ -3306,14 +3308,12 @@ assert_eq!(\", stringify!($SelfT), \"::MAX.checked_pow(2), None);\", $EndFeature, \"\n                     base = try_opt!(base.checked_mul(base));\n                 }\n \n+                // since exp!=0, finally the exp must be 1.\n                 // Deal with the final bit of the exponent separately, since\n                 // squaring the base afterwards is not necessary and may cause a\n                 // needless overflow.\n-                if exp == 1 {\n-                    acc = try_opt!(acc.checked_mul(base));\n-                }\n \n-                Some(acc)\n+                Some(try_opt!(acc.checked_mul(base)))\n             }\n         }\n \n@@ -3704,6 +3704,9 @@ assert_eq!(3u8.wrapping_pow(6), 217);\", $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_pow(self, mut exp: u32) -> Self {\n+                if exp == 0 {\n+                    return 1;\n+                }\n                 let mut base = self;\n                 let mut acc: Self = 1;\n \n@@ -3715,14 +3718,11 @@ assert_eq!(3u8.wrapping_pow(6), 217);\", $EndFeature, \"\n                     base = base.wrapping_mul(base);\n                 }\n \n+                // since exp!=0, finally the exp must be 1.\n                 // Deal with the final bit of the exponent separately, since\n                 // squaring the base afterwards is not necessary and may cause a\n                 // needless overflow.\n-                if exp == 1 {\n-                    acc = acc.wrapping_mul(base);\n-                }\n-\n-                acc\n+                acc.wrapping_mul(base)\n             }\n         }\n \n@@ -4029,6 +4029,9 @@ assert_eq!(3u8.overflowing_pow(6), (217, true));\", $EndFeature, \"\n                           without modifying the original\"]\n             #[inline]\n             pub const fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n+                if exp == 0{\n+                    return (1,false);\n+                }\n                 let mut base = self;\n                 let mut acc: Self = 1;\n                 let mut overflown = false;\n@@ -4047,16 +4050,14 @@ assert_eq!(3u8.overflowing_pow(6), (217, true));\", $EndFeature, \"\n                     overflown |= r.1;\n                 }\n \n+                // since exp!=0, finally the exp must be 1.\n                 // Deal with the final bit of the exponent separately, since\n                 // squaring the base afterwards is not necessary and may cause a\n                 // needless overflow.\n-                if exp == 1 {\n-                    r = acc.overflowing_mul(base);\n-                    acc = r.0;\n-                    overflown |= r.1;\n-                }\n+                r = acc.overflowing_mul(base);\n+                r.1 |= overflown;\n \n-                (acc, overflown)\n+                r\n             }\n         }\n \n@@ -4077,6 +4078,9 @@ Basic usage:\n         #[inline]\n         #[rustc_inherit_overflow_checks]\n         pub const fn pow(self, mut exp: u32) -> Self {\n+            if exp == 0 {\n+                return 1;\n+            }\n             let mut base = self;\n             let mut acc = 1;\n \n@@ -4088,14 +4092,11 @@ Basic usage:\n                 base = base * base;\n             }\n \n+            // since exp!=0, finally the exp must be 1.\n             // Deal with the final bit of the exponent separately, since\n             // squaring the base afterwards is not necessary and may cause a\n             // needless overflow.\n-            if exp == 1 {\n-                acc = acc * base;\n-            }\n-\n-            acc\n+            acc * base\n         }\n     }\n "}, {"sha": "58a585669122ca3b7859cf19b9bef7525354d705", "filename": "src/libcore/tests/num/int_macros.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fint_macros.rs?ref=fe07ece978793d981150b0bdc8638b33e041381a", "patch": "@@ -255,12 +255,43 @@ macro_rules! int_module {\n             #[test]\n             fn test_pow() {\n                 let mut r = 2 as $T;\n-\n                 assert_eq!(r.pow(2), 4 as $T);\n                 assert_eq!(r.pow(0), 1 as $T);\n+                assert_eq!(r.wrapping_pow(2), 4 as $T);\n+                assert_eq!(r.wrapping_pow(0), 1 as $T);\n+                assert_eq!(r.checked_pow(2), Some(4 as $T));\n+                assert_eq!(r.checked_pow(0), Some(1 as $T));\n+                assert_eq!(r.overflowing_pow(2), (4 as $T, false));\n+                assert_eq!(r.overflowing_pow(0), (1 as $T, false));\n+                assert_eq!(r.saturating_pow(2), 4 as $T);\n+                assert_eq!(r.saturating_pow(0), 1 as $T);\n+\n+                r = MAX;\n+                // use `^` to represent .pow() with no overflow.\n+                // if itest::MAX == 2^j-1, then itest is a `j` bit int,\n+                // so that `itest::MAX*itest::MAX == 2^(2*j)-2^(j+1)+1`,\n+                // thussaturating_pow the overflowing result is exactly 1.\n+                assert_eq!(r.wrapping_pow(2), 1 as $T);\n+                assert_eq!(r.checked_pow(2), None);\n+                assert_eq!(r.overflowing_pow(2), (1 as $T, true));\n+                assert_eq!(r.saturating_pow(2), MAX);\n+                //test for negative exponent.\n                 r = -2 as $T;\n                 assert_eq!(r.pow(2), 4 as $T);\n                 assert_eq!(r.pow(3), -8 as $T);\n+                assert_eq!(r.pow(0), 1 as $T);\n+                assert_eq!(r.wrapping_pow(2), 4 as $T);\n+                assert_eq!(r.wrapping_pow(3), -8 as $T);\n+                assert_eq!(r.wrapping_pow(0), 1 as $T);\n+                assert_eq!(r.checked_pow(2), Some(4 as $T));\n+                assert_eq!(r.checked_pow(3), Some(-8 as $T));\n+                assert_eq!(r.checked_pow(0), Some(1 as $T));\n+                assert_eq!(r.overflowing_pow(2), (4 as $T, false));\n+                assert_eq!(r.overflowing_pow(3), (-8 as $T, false));\n+                assert_eq!(r.overflowing_pow(0), (1 as $T, false));\n+                assert_eq!(r.saturating_pow(2), 4 as $T);\n+                assert_eq!(r.saturating_pow(3), -8 as $T);\n+                assert_eq!(r.saturating_pow(0), 1 as $T);\n             }\n         }\n     };"}, {"sha": "b84a8a7d9f88ba3aee84214cc61ac21f764e9a56", "filename": "src/libcore/tests/num/uint_macros.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnum%2Fuint_macros.rs?ref=fe07ece978793d981150b0bdc8638b33e041381a", "patch": "@@ -184,6 +184,31 @@ macro_rules! uint_module {\n                 assert_eq!($T::from_str_radix(\"Z\", 10).ok(), None::<$T>);\n                 assert_eq!($T::from_str_radix(\"_\", 2).ok(), None::<$T>);\n             }\n+\n+            #[test]\n+            fn test_pow() {\n+                let mut r = 2 as $T;\n+                assert_eq!(r.pow(2), 4 as $T);\n+                assert_eq!(r.pow(0), 1 as $T);\n+                assert_eq!(r.wrapping_pow(2), 4 as $T);\n+                assert_eq!(r.wrapping_pow(0), 1 as $T);\n+                assert_eq!(r.checked_pow(2), Some(4 as $T));\n+                assert_eq!(r.checked_pow(0), Some(1 as $T));\n+                assert_eq!(r.overflowing_pow(2), (4 as $T, false));\n+                assert_eq!(r.overflowing_pow(0), (1 as $T, false));\n+                assert_eq!(r.saturating_pow(2), 4 as $T);\n+                assert_eq!(r.saturating_pow(0), 1 as $T);\n+\n+                r = MAX;\n+                // use `^` to represent .pow() with no overflow.\n+                // if itest::MAX == 2^j-1, then itest is a `j` bit int,\n+                // so that `itest::MAX*itest::MAX == 2^(2*j)-2^(j+1)+1`,\n+                // thussaturating_pow the overflowing result is exactly 1.\n+                assert_eq!(r.wrapping_pow(2), 1 as $T);\n+                assert_eq!(r.checked_pow(2), None);\n+                assert_eq!(r.overflowing_pow(2), (1 as $T, true));\n+                assert_eq!(r.saturating_pow(2), MAX);\n+            }\n         }\n     };\n }"}, {"sha": "063246f79fe362ff41c69a637fcca09d3e32260d", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 24, "deletions": 5, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=fe07ece978793d981150b0bdc8638b33e041381a", "patch": "@@ -1402,8 +1402,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n \n         debug!(\"note_type_err(diag={:?})\", diag);\n+        enum Mismatch<'a> {\n+            Variable(ty::error::ExpectedFound<Ty<'a>>),\n+            Fixed(&'static str),\n+        }\n         let (expected_found, exp_found, is_simple_error) = match values {\n-            None => (None, None, false),\n+            None => (None, Mismatch::Fixed(\"type\"), false),\n             Some(values) => {\n                 let (is_simple_error, exp_found) = match values {\n                     ValuePairs::Types(exp_found) => {\n@@ -1417,9 +1421,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         )\n                         .report(diag);\n \n-                        (is_simple_err, Some(exp_found))\n+                        (is_simple_err, Mismatch::Variable(exp_found))\n                     }\n-                    _ => (false, None),\n+                    ValuePairs::TraitRefs(_) => (false, Mismatch::Fixed(\"trait\")),\n+                    _ => (false, Mismatch::Fixed(\"type\")),\n                 };\n                 let vals = match self.values_str(&values) {\n                     Some((expected, found)) => Some((expected, found)),\n@@ -1445,8 +1450,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n         };\n         if let Some((expected, found)) = expected_found {\n-            let expected_label = exp_found.map_or(\"type\".into(), |ef| ef.expected.prefix_string());\n-            let found_label = exp_found.map_or(\"type\".into(), |ef| ef.found.prefix_string());\n+            let expected_label = match exp_found {\n+                Mismatch::Variable(ef) => ef.expected.prefix_string(),\n+                Mismatch::Fixed(s) => s.into(),\n+            };\n+            let found_label = match exp_found {\n+                Mismatch::Variable(ef) => ef.found.prefix_string(),\n+                Mismatch::Fixed(s) => s.into(),\n+            };\n+            let exp_found = match exp_found {\n+                Mismatch::Variable(exp_found) => Some(exp_found),\n+                Mismatch::Fixed(_) => None,\n+            };\n             match (&terr, expected == found) {\n                 (TypeError::Sorts(values), extra) => {\n                     let sort_string = |ty: Ty<'tcx>| match (extra, &ty.kind) {\n@@ -1499,6 +1514,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 }\n             }\n         }\n+        let exp_found = match exp_found {\n+            Mismatch::Variable(exp_found) => Some(exp_found),\n+            Mismatch::Fixed(_) => None,\n+        };\n         if let Some(exp_found) = exp_found {\n             self.suggest_as_ref_where_appropriate(span, &exp_found, diag);\n         }"}, {"sha": "8521f900988e49a212043b3119e46928b45ad068", "filename": "src/librustc_mir/borrow_check/diagnostics/outlives_suggestion.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Foutlives_suggestion.rs?ref=fe07ece978793d981150b0bdc8638b33e041381a", "patch": "@@ -60,9 +60,7 @@ impl OutlivesSuggestionBuilder {\n             // Don't give suggestions for upvars, closure return types, or other unnamable\n             // regions.\n             RegionNameSource::SynthesizedFreeEnvRegion(..)\n-            | RegionNameSource::CannotMatchHirTy(..)\n-            | RegionNameSource::MatchedHirTy(..)\n-            | RegionNameSource::MatchedAdtAndSegment(..)\n+            | RegionNameSource::AnonRegionFromArgument(..)\n             | RegionNameSource::AnonRegionFromUpvar(..)\n             | RegionNameSource::AnonRegionFromOutput(..)\n             | RegionNameSource::AnonRegionFromYieldTy(..)"}, {"sha": "cc8a5e0768cba3ab721919ff033bb08b579fc153", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=fe07ece978793d981150b0bdc8638b33e041381a", "patch": "@@ -19,7 +19,7 @@ use crate::borrow_check::{\n     MirBorrowckCtxt,\n };\n \n-use super::{OutlivesSuggestionBuilder, RegionName, RegionNameSource};\n+use super::{OutlivesSuggestionBuilder, RegionName};\n \n impl ConstraintDescription for ConstraintCategory {\n     fn description(&self) -> &'static str {\n@@ -396,18 +396,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             diag.span_label(upvar_span, \"variable captured here\");\n         }\n \n-        match self.give_region_a_name(*outlived_fr).unwrap().source {\n-            RegionNameSource::NamedEarlyBoundRegion(fr_span)\n-            | RegionNameSource::NamedFreeRegion(fr_span)\n-            | RegionNameSource::SynthesizedFreeEnvRegion(fr_span, _)\n-            | RegionNameSource::CannotMatchHirTy(fr_span, _)\n-            | RegionNameSource::MatchedHirTy(fr_span)\n-            | RegionNameSource::MatchedAdtAndSegment(fr_span)\n-            | RegionNameSource::AnonRegionFromUpvar(fr_span, _)\n-            | RegionNameSource::AnonRegionFromOutput(fr_span, _, _) => {\n-                diag.span_label(fr_span, \"inferred to be a `FnMut` closure\");\n-            }\n-            _ => {}\n+        if let Some(fr_span) = self.give_region_a_name(*outlived_fr).unwrap().span() {\n+            diag.span_label(fr_span, \"inferred to be a `FnMut` closure\");\n         }\n \n         diag.note("}, {"sha": "32195adc60ef87980442f3a9054d650604be7da6", "filename": "src/librustc_mir/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 88, "deletions": 73, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=fe07ece978793d981150b0bdc8638b33e041381a", "patch": "@@ -34,13 +34,8 @@ crate enum RegionNameSource {\n     Static,\n     /// The free region corresponding to the environment of a closure.\n     SynthesizedFreeEnvRegion(Span, String),\n-    /// The region name corresponds to a region where the type annotation is completely missing\n-    /// from the code, e.g. in a closure arguments `|x| { ... }`, where `x` is a reference.\n-    CannotMatchHirTy(Span, String),\n-    /// The region name corresponds a reference that was found by traversing the type in the HIR.\n-    MatchedHirTy(Span),\n-    /// A region name from the generics list of a struct/enum/union.\n-    MatchedAdtAndSegment(Span),\n+    /// The region corresponding to an argument.\n+    AnonRegionFromArgument(RegionNameHighlight),\n     /// The region corresponding to a closure upvar.\n     AnonRegionFromUpvar(Span, String),\n     /// The region corresponding to the return type of a closure.\n@@ -51,23 +46,52 @@ crate enum RegionNameSource {\n     AnonRegionFromAsyncFn(Span),\n }\n \n+/// Describes what to highlight to explain to the user that we're giving an anonymous region a\n+/// synthesized name, and how to highlight it.\n+#[derive(Debug, Clone)]\n+crate enum RegionNameHighlight {\n+    /// The anonymous region corresponds to a reference that was found by traversing the type in the HIR.\n+    MatchedHirTy(Span),\n+    /// The anonymous region corresponds to a `'_` in the generics list of a struct/enum/union.\n+    MatchedAdtAndSegment(Span),\n+    /// The anonymous region corresponds to a region where the type annotation is completely missing\n+    /// from the code, e.g. in a closure arguments `|x| { ... }`, where `x` is a reference.\n+    CannotMatchHirTy(Span, String),\n+}\n+\n impl RegionName {\n     crate fn was_named(&self) -> bool {\n         match self.source {\n             RegionNameSource::NamedEarlyBoundRegion(..)\n             | RegionNameSource::NamedFreeRegion(..)\n             | RegionNameSource::Static => true,\n             RegionNameSource::SynthesizedFreeEnvRegion(..)\n-            | RegionNameSource::CannotMatchHirTy(..)\n-            | RegionNameSource::MatchedHirTy(..)\n-            | RegionNameSource::MatchedAdtAndSegment(..)\n+            | RegionNameSource::AnonRegionFromArgument(..)\n             | RegionNameSource::AnonRegionFromUpvar(..)\n             | RegionNameSource::AnonRegionFromOutput(..)\n             | RegionNameSource::AnonRegionFromYieldTy(..)\n             | RegionNameSource::AnonRegionFromAsyncFn(..) => false,\n         }\n     }\n \n+    crate fn span(&self) -> Option<Span> {\n+        match self.source {\n+            RegionNameSource::Static => None,\n+            RegionNameSource::NamedEarlyBoundRegion(span)\n+            | RegionNameSource::NamedFreeRegion(span)\n+            | RegionNameSource::SynthesizedFreeEnvRegion(span, _)\n+            | RegionNameSource::AnonRegionFromUpvar(span, _)\n+            | RegionNameSource::AnonRegionFromOutput(span, _, _)\n+            | RegionNameSource::AnonRegionFromYieldTy(span, _)\n+            | RegionNameSource::AnonRegionFromAsyncFn(span) => Some(span),\n+            RegionNameSource::AnonRegionFromArgument(ref highlight) => match *highlight {\n+                RegionNameHighlight::MatchedHirTy(span)\n+                | RegionNameHighlight::MatchedAdtAndSegment(span)\n+                | RegionNameHighlight::CannotMatchHirTy(span, _) => Some(span),\n+            },\n+        }\n+    }\n+\n     crate fn highlight_region_name(&self, diag: &mut DiagnosticBuilder<'_>) {\n         match &self.source {\n             RegionNameSource::NamedFreeRegion(span)\n@@ -81,17 +105,22 @@ impl RegionName {\n                 );\n                 diag.note(&note);\n             }\n-            RegionNameSource::CannotMatchHirTy(span, type_name) => {\n+            RegionNameSource::AnonRegionFromArgument(RegionNameHighlight::CannotMatchHirTy(\n+                span,\n+                type_name,\n+            )) => {\n                 diag.span_label(*span, format!(\"has type `{}`\", type_name));\n             }\n-            RegionNameSource::MatchedHirTy(span)\n+            RegionNameSource::AnonRegionFromArgument(RegionNameHighlight::MatchedHirTy(span))\n             | RegionNameSource::AnonRegionFromAsyncFn(span) => {\n                 diag.span_label(\n                     *span,\n                     format!(\"let's call the lifetime of this reference `{}`\", self),\n                 );\n             }\n-            RegionNameSource::MatchedAdtAndSegment(span) => {\n+            RegionNameSource::AnonRegionFromArgument(\n+                RegionNameHighlight::MatchedAdtAndSegment(span),\n+            ) => {\n                 diag.span_label(*span, format!(\"let's call this `{}`\", self));\n             }\n             RegionNameSource::AnonRegionFromUpvar(span, upvar_name) => {\n@@ -307,21 +336,31 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n \n         let arg_ty = self.regioncx.universal_regions().unnormalized_input_tys\n             [implicit_inputs + argument_index];\n-        if let Some(region_name) =\n-            self.give_name_if_we_can_match_hir_ty_from_argument(fr, arg_ty, argument_index)\n-        {\n-            return Some(region_name);\n-        }\n+        let (_, span) = self.regioncx.get_argument_name_and_span_for_region(\n+            &self.body,\n+            &self.local_names,\n+            argument_index,\n+        );\n \n-        self.give_name_if_we_cannot_match_hir_ty(fr, arg_ty)\n+        self.get_argument_hir_ty_for_highlighting(argument_index)\n+            .and_then(|arg_hir_ty| self.highlight_if_we_can_match_hir_ty(fr, arg_ty, arg_hir_ty))\n+            .or_else(|| {\n+                // `highlight_if_we_cannot_match_hir_ty` needs to know the number we will give to\n+                // the anonymous region. If it succeeds, the `synthesize_region_name` call below\n+                // will increment the counter, \"reserving\" the number we just used.\n+                let counter = *self.next_region_name.try_borrow().unwrap();\n+                self.highlight_if_we_cannot_match_hir_ty(fr, arg_ty, span, counter)\n+            })\n+            .map(|highlight| RegionName {\n+                name: self.synthesize_region_name(),\n+                source: RegionNameSource::AnonRegionFromArgument(highlight),\n+            })\n     }\n \n-    fn give_name_if_we_can_match_hir_ty_from_argument(\n+    fn get_argument_hir_ty_for_highlighting(\n         &self,\n-        needle_fr: RegionVid,\n-        argument_ty: Ty<'tcx>,\n         argument_index: usize,\n-    ) -> Option<RegionName> {\n+    ) -> Option<&hir::Ty<'tcx>> {\n         let mir_hir_id = self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id);\n         let fn_decl = self.infcx.tcx.hir().fn_decl_by_hir_id(mir_hir_id)?;\n         let argument_hir_ty: &hir::Ty<'_> = fn_decl.inputs.get(argument_index)?;\n@@ -333,7 +372,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             // (`give_name_if_anonymous_region_appears_in_arguments`).\n             hir::TyKind::Infer => None,\n \n-            _ => self.give_name_if_we_can_match_hir_ty(needle_fr, argument_ty, argument_hir_ty),\n+            _ => Some(argument_hir_ty),\n         }\n     }\n \n@@ -348,42 +387,28 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     ///  |          |  has type `&'1 u32`\n     ///  |          has type `&'2 u32`\n     /// ```\n-    fn give_name_if_we_cannot_match_hir_ty(\n+    fn highlight_if_we_cannot_match_hir_ty(\n         &self,\n         needle_fr: RegionVid,\n-        argument_ty: Ty<'tcx>,\n-    ) -> Option<RegionName> {\n-        let counter = *self.next_region_name.try_borrow().unwrap();\n+        ty: Ty<'tcx>,\n+        span: Span,\n+        counter: usize,\n+    ) -> Option<RegionNameHighlight> {\n         let mut highlight = RegionHighlightMode::default();\n         highlight.highlighting_region_vid(needle_fr, counter);\n-        let type_name = self.infcx.extract_type_name(&argument_ty, Some(highlight)).0;\n+        let type_name = self.infcx.extract_type_name(&ty, Some(highlight)).0;\n \n         debug!(\n-            \"give_name_if_we_cannot_match_hir_ty: type_name={:?} needle_fr={:?}\",\n+            \"highlight_if_we_cannot_match_hir_ty: type_name={:?} needle_fr={:?}\",\n             type_name, needle_fr\n         );\n-        let assigned_region_name = if type_name.find(&format!(\"'{}\", counter)).is_some() {\n+        if type_name.find(&format!(\"'{}\", counter)).is_some() {\n             // Only add a label if we can confirm that a region was labelled.\n-            let argument_index =\n-                self.regioncx.get_argument_index_for_region(self.infcx.tcx, needle_fr)?;\n-            let (_, span) = self.regioncx.get_argument_name_and_span_for_region(\n-                &self.body,\n-                &self.local_names,\n-                argument_index,\n-            );\n-\n-            Some(RegionName {\n-                // This counter value will already have been used, so this function will increment\n-                // it so the next value will be used next and return the region name that would\n-                // have been used.\n-                name: self.synthesize_region_name(),\n-                source: RegionNameSource::CannotMatchHirTy(span, type_name),\n-            })\n+\n+            Some(RegionNameHighlight::CannotMatchHirTy(span, type_name))\n         } else {\n             None\n-        };\n-\n-        assigned_region_name\n+        }\n     }\n \n     /// Attempts to highlight the specific part of a type annotation\n@@ -395,9 +420,9 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     ///  |                - let's call the lifetime of this reference `'1`\n     /// ```\n     ///\n-    /// the way this works is that we match up `argument_ty`, which is\n+    /// the way this works is that we match up `ty`, which is\n     /// a `Ty<'tcx>` (the internal form of the type) with\n-    /// `argument_hir_ty`, a `hir::Ty` (the syntax of the type\n+    /// `hir_ty`, a `hir::Ty` (the syntax of the type\n     /// annotation). We are descending through the types stepwise,\n     /// looking in to find the region `needle_fr` in the internal\n     /// type. Once we find that, we can use the span of the `hir::Ty`\n@@ -407,18 +432,17 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n     /// keep track of the **closest** type we've found. If we fail to\n     /// find the exact `&` or `'_` to highlight, then we may fall back\n     /// to highlighting that closest type instead.\n-    fn give_name_if_we_can_match_hir_ty(\n+    fn highlight_if_we_can_match_hir_ty(\n         &self,\n         needle_fr: RegionVid,\n-        argument_ty: Ty<'tcx>,\n-        argument_hir_ty: &hir::Ty<'_>,\n-    ) -> Option<RegionName> {\n-        let search_stack: &mut Vec<(Ty<'tcx>, &hir::Ty<'_>)> =\n-            &mut vec![(argument_ty, argument_hir_ty)];\n+        ty: Ty<'tcx>,\n+        hir_ty: &hir::Ty<'_>,\n+    ) -> Option<RegionNameHighlight> {\n+        let search_stack: &mut Vec<(Ty<'tcx>, &hir::Ty<'_>)> = &mut vec![(ty, hir_ty)];\n \n         while let Some((ty, hir_ty)) = search_stack.pop() {\n             match (&ty.kind, &hir_ty.kind) {\n-                // Check if the `argument_ty` is `&'X ..` where `'X`\n+                // Check if the `ty` is `&'X ..` where `'X`\n                 // is the region we are looking for -- if so, and we have a `&T`\n                 // on the RHS, then we want to highlight the `&` like so:\n                 //\n@@ -429,16 +453,11 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                     hir::TyKind::Rptr(_lifetime, referent_hir_ty),\n                 ) => {\n                     if region.to_region_vid() == needle_fr {\n-                        let region_name = self.synthesize_region_name();\n-\n                         // Just grab the first character, the `&`.\n                         let source_map = self.infcx.tcx.sess.source_map();\n                         let ampersand_span = source_map.start_point(hir_ty.span);\n \n-                        return Some(RegionName {\n-                            name: region_name,\n-                            source: RegionNameSource::MatchedHirTy(ampersand_span),\n-                        });\n+                        return Some(RegionNameHighlight::MatchedHirTy(ampersand_span));\n                     }\n \n                     // Otherwise, let's descend into the referent types.\n@@ -458,13 +477,13 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                         Res::Def(DefKind::TyAlias, _) => (),\n                         _ => {\n                             if let Some(last_segment) = path.segments.last() {\n-                                if let Some(name) = self.match_adt_and_segment(\n+                                if let Some(highlight) = self.match_adt_and_segment(\n                                     substs,\n                                     needle_fr,\n                                     last_segment,\n                                     search_stack,\n                                 ) {\n-                                    return Some(name);\n+                                    return Some(highlight);\n                                 }\n                             }\n                         }\n@@ -507,7 +526,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         needle_fr: RegionVid,\n         last_segment: &'hir hir::PathSegment<'hir>,\n         search_stack: &mut Vec<(Ty<'tcx>, &'hir hir::Ty<'hir>)>,\n-    ) -> Option<RegionName> {\n+    ) -> Option<RegionNameHighlight> {\n         // Did the user give explicit arguments? (e.g., `Foo<..>`)\n         let args = last_segment.args.as_ref()?;\n         let lifetime =\n@@ -517,12 +536,8 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             | hir::LifetimeName::Error\n             | hir::LifetimeName::Static\n             | hir::LifetimeName::Underscore => {\n-                let region_name = self.synthesize_region_name();\n-                let ampersand_span = lifetime.span;\n-                Some(RegionName {\n-                    name: region_name,\n-                    source: RegionNameSource::MatchedAdtAndSegment(ampersand_span),\n-                })\n+                let lifetime_span = lifetime.span;\n+                Some(RegionNameHighlight::MatchedAdtAndSegment(lifetime_span))\n             }\n \n             hir::LifetimeName::ImplicitObjectLifetimeDefault | hir::LifetimeName::Implicit => {"}, {"sha": "b3dedd5b8223ebe208ea8e559dfc5dddd218c806", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 85, "deletions": 21, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=fe07ece978793d981150b0bdc8638b33e041381a", "patch": "@@ -28,9 +28,9 @@ use rustc_trait_selection::traits;\n \n use crate::const_eval::error_to_const_error;\n use crate::interpret::{\n-    self, compile_time_machine, AllocId, Allocation, Frame, ImmTy, Immediate, InterpCx, LocalState,\n-    LocalValue, MemPlace, Memory, MemoryKind, OpTy, Operand as InterpOperand, PlaceTy, Pointer,\n-    ScalarMaybeUninit, StackPopCleanup,\n+    self, compile_time_machine, truncate, AllocId, Allocation, Frame, ImmTy, Immediate, InterpCx,\n+    LocalState, LocalValue, MemPlace, Memory, MemoryKind, OpTy, Operand as InterpOperand, PlaceTy,\n+    Pointer, ScalarMaybeUninit, StackPopCleanup,\n };\n use crate::transform::{MirPass, MirSource};\n \n@@ -527,11 +527,11 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         right: &Operand<'tcx>,\n         source_info: SourceInfo,\n     ) -> Option<()> {\n-        let r =\n-            self.use_ecx(|this| this.ecx.read_immediate(this.ecx.eval_operand(right, None)?))?;\n+        let r = self.use_ecx(|this| this.ecx.read_immediate(this.ecx.eval_operand(right, None)?));\n         let l = self.use_ecx(|this| this.ecx.read_immediate(this.ecx.eval_operand(left, None)?));\n         // Check for exceeding shifts *even if* we cannot evaluate the LHS.\n         if op == BinOp::Shr || op == BinOp::Shl {\n+            let r = r?;\n             // We need the type of the LHS. We cannot use `place_layout` as that is the type\n             // of the result, which for checked binops is not the same!\n             let left_ty = left.ty(&self.local_decls, self.tcx);\n@@ -564,21 +564,20 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             }\n         }\n \n-        let l = l?;\n-\n-        // The remaining operators are handled through `overflowing_binary_op`.\n-        if self.use_ecx(|this| {\n-            let (_res, overflow, _ty) = this.ecx.overflowing_binary_op(op, l, r)?;\n-            Ok(overflow)\n-        })? {\n-            self.report_assert_as_lint(\n-                lint::builtin::ARITHMETIC_OVERFLOW,\n-                source_info,\n-                \"this arithmetic operation will overflow\",\n-                AssertKind::Overflow(op, l.to_const_int(), r.to_const_int()),\n-            )?;\n+        if let (Some(l), Some(r)) = (l, r) {\n+            // The remaining operators are handled through `overflowing_binary_op`.\n+            if self.use_ecx(|this| {\n+                let (_res, overflow, _ty) = this.ecx.overflowing_binary_op(op, l, r)?;\n+                Ok(overflow)\n+            })? {\n+                self.report_assert_as_lint(\n+                    lint::builtin::ARITHMETIC_OVERFLOW,\n+                    source_info,\n+                    \"this arithmetic operation will overflow\",\n+                    AssertKind::Overflow(op, l.to_const_int(), r.to_const_int()),\n+                )?;\n+            }\n         }\n-\n         Some(())\n     }\n \n@@ -659,9 +658,74 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             return None;\n         }\n \n+        if self.tcx.sess.opts.debugging_opts.mir_opt_level >= 3 {\n+            self.eval_rvalue_with_identities(rvalue, place)\n+        } else {\n+            self.use_ecx(|this| this.ecx.eval_rvalue_into_place(rvalue, place))\n+        }\n+    }\n+\n+    // Attempt to use albegraic identities to eliminate constant expressions\n+    fn eval_rvalue_with_identities(\n+        &mut self,\n+        rvalue: &Rvalue<'tcx>,\n+        place: Place<'tcx>,\n+    ) -> Option<()> {\n         self.use_ecx(|this| {\n-            trace!(\"calling eval_rvalue_into_place(rvalue = {:?}, place = {:?})\", rvalue, place);\n-            this.ecx.eval_rvalue_into_place(rvalue, place)?;\n+            match rvalue {\n+                Rvalue::BinaryOp(op, left, right) | Rvalue::CheckedBinaryOp(op, left, right) => {\n+                    let l = this.ecx.eval_operand(left, None);\n+                    let r = this.ecx.eval_operand(right, None);\n+\n+                    let const_arg = match (l, r) {\n+                        (Ok(x), Err(_)) | (Err(_), Ok(x)) => this.ecx.read_immediate(x)?,\n+                        (Err(e), Err(_)) => return Err(e),\n+                        (Ok(_), Ok(_)) => {\n+                            this.ecx.eval_rvalue_into_place(rvalue, place)?;\n+                            return Ok(());\n+                        }\n+                    };\n+\n+                    let arg_value =\n+                        this.ecx.force_bits(const_arg.to_scalar()?, const_arg.layout.size)?;\n+                    let dest = this.ecx.eval_place(place)?;\n+\n+                    match op {\n+                        BinOp::BitAnd => {\n+                            if arg_value == 0 {\n+                                this.ecx.write_immediate(*const_arg, dest)?;\n+                            }\n+                        }\n+                        BinOp::BitOr => {\n+                            if arg_value == truncate(u128::MAX, const_arg.layout.size)\n+                                || (const_arg.layout.ty.is_bool() && arg_value == 1)\n+                            {\n+                                this.ecx.write_immediate(*const_arg, dest)?;\n+                            }\n+                        }\n+                        BinOp::Mul => {\n+                            if const_arg.layout.ty.is_integral() && arg_value == 0 {\n+                                if let Rvalue::CheckedBinaryOp(_, _, _) = rvalue {\n+                                    let val = Immediate::ScalarPair(\n+                                        const_arg.to_scalar()?.into(),\n+                                        Scalar::from_bool(false).into(),\n+                                    );\n+                                    this.ecx.write_immediate(val, dest)?;\n+                                } else {\n+                                    this.ecx.write_immediate(*const_arg, dest)?;\n+                                }\n+                            }\n+                        }\n+                        _ => {\n+                            this.ecx.eval_rvalue_into_place(rvalue, place)?;\n+                        }\n+                    }\n+                }\n+                _ => {\n+                    this.ecx.eval_rvalue_into_place(rvalue, place)?;\n+                }\n+            }\n+\n             Ok(())\n         })\n     }"}, {"sha": "4b5ab03df4327a9df7af2cf74f851ab000c913f8", "filename": "src/librustc_resolve/late.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=fe07ece978793d981150b0bdc8638b33e041381a", "patch": "@@ -1506,18 +1506,24 @@ impl<'a, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         pat.walk(&mut |pat| {\n             debug!(\"resolve_pattern pat={:?} node={:?}\", pat, pat.kind);\n             match pat.kind {\n-                // In tuple struct patterns ignore the invalid `ident @ ...`.\n-                // It will be handled as an error by the AST lowering.\n-                PatKind::Ident(bmode, ident, ref sub)\n-                    if !(is_tuple_struct_pat && sub.as_ref().filter(|p| p.is_rest()).is_some()) =>\n-                {\n-                    // First try to resolve the identifier as some existing entity,\n-                    // then fall back to a fresh binding.\n-                    let has_sub = sub.is_some();\n-                    let res = self\n-                        .try_resolve_as_non_binding(pat_src, pat, bmode, ident, has_sub)\n-                        .unwrap_or_else(|| self.fresh_binding(ident, pat.id, pat_src, bindings));\n-                    self.r.record_partial_res(pat.id, PartialRes::new(res));\n+                PatKind::Ident(bmode, ident, ref sub) => {\n+                    if is_tuple_struct_pat && sub.as_ref().filter(|p| p.is_rest()).is_some() {\n+                        // In tuple struct patterns ignore the invalid `ident @ ...`.\n+                        // It will be handled as an error by the AST lowering.\n+                        self.r\n+                            .session\n+                            .delay_span_bug(ident.span, \"ident in tuple pattern is invalid\");\n+                    } else {\n+                        // First try to resolve the identifier as some existing entity,\n+                        // then fall back to a fresh binding.\n+                        let has_sub = sub.is_some();\n+                        let res = self\n+                            .try_resolve_as_non_binding(pat_src, pat, bmode, ident, has_sub)\n+                            .unwrap_or_else(|| {\n+                                self.fresh_binding(ident, pat.id, pat_src, bindings)\n+                            });\n+                        self.r.record_partial_res(pat.id, PartialRes::new(res));\n+                    }\n                 }\n                 PatKind::TupleStruct(ref path, ..) => {\n                     self.smart_resolve_path(pat.id, None, path, PathSource::TupleStruct(pat.span));"}, {"sha": "2c1e71c64c4e5a4d01d7d02890790397d247b0e2", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=fe07ece978793d981150b0bdc8638b33e041381a", "patch": "@@ -40,7 +40,7 @@ dlmalloc = { version = \"0.1\", features = ['rustc-dep-of-std'] }\n fortanix-sgx-abi = { version = \"0.3.2\", features = ['rustc-dep-of-std'] }\n \n [target.'cfg(all(any(target_arch = \"x86_64\", target_arch = \"aarch64\"), target_os = \"hermit\"))'.dependencies]\n-hermit-abi = { version = \"0.1.14\", features = ['rustc-dep-of-std'] }\n+hermit-abi = { version = \"0.1.15\", features = ['rustc-dep-of-std'] }\n \n [target.wasm32-wasi.dependencies]\n wasi = { version = \"0.9.0\", features = ['rustc-dep-of-std'], default-features = false }"}, {"sha": "52c8c3b17e8262571775b4a41b1ab543fbd78b39", "filename": "src/libstd/sys/hermit/condvar.rs", "status": "modified", "additions": 34, "deletions": 30, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Flibstd%2Fsys%2Fhermit%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Flibstd%2Fsys%2Fhermit%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Fcondvar.rs?ref=fe07ece978793d981150b0bdc8638b33e041381a", "patch": "@@ -1,60 +1,64 @@\n-use crate::cmp;\n+use crate::ffi::c_void;\n+use crate::ptr;\n+use crate::sync::atomic::{AtomicUsize, Ordering::SeqCst};\n use crate::sys::hermit::abi;\n use crate::sys::mutex::Mutex;\n use crate::time::Duration;\n \n+// The implementation is inspired by Andrew D. Birrell's paper\n+// \"Implementing Condition Variables with Semaphores\"\n+\n pub struct Condvar {\n-    identifier: usize,\n+    counter: AtomicUsize,\n+    sem1: *const c_void,\n+    sem2: *const c_void,\n }\n \n+unsafe impl Send for Condvar {}\n+unsafe impl Sync for Condvar {}\n+\n impl Condvar {\n     pub const fn new() -> Condvar {\n-        Condvar { identifier: 0 }\n+        Condvar { counter: AtomicUsize::new(0), sem1: ptr::null(), sem2: ptr::null() }\n     }\n \n     pub unsafe fn init(&mut self) {\n-        let _ = abi::init_queue(self.id());\n+        let _ = abi::sem_init(&mut self.sem1 as *mut *const c_void, 0);\n+        let _ = abi::sem_init(&mut self.sem2 as *mut *const c_void, 0);\n     }\n \n     pub unsafe fn notify_one(&self) {\n-        let _ = abi::notify(self.id(), 1);\n+        if self.counter.load(SeqCst) > 0 {\n+            self.counter.fetch_sub(1, SeqCst);\n+            abi::sem_post(self.sem1);\n+            abi::sem_timedwait(self.sem2, 0);\n+        }\n     }\n \n-    #[inline]\n     pub unsafe fn notify_all(&self) {\n-        let _ = abi::notify(self.id(), -1 /* =all */);\n+        let counter = self.counter.swap(0, SeqCst);\n+        for _ in 0..counter {\n+            abi::sem_post(self.sem1);\n+        }\n+        for _ in 0..counter {\n+            abi::sem_timedwait(self.sem2, 0);\n+        }\n     }\n \n     pub unsafe fn wait(&self, mutex: &Mutex) {\n-        // add current task to the wait queue\n-        let _ = abi::add_queue(self.id(), -1 /* no timeout */);\n+        self.counter.fetch_add(1, SeqCst);\n         mutex.unlock();\n-        let _ = abi::wait(self.id());\n+        abi::sem_timedwait(self.sem1, 0);\n+        abi::sem_post(self.sem2);\n         mutex.lock();\n     }\n \n-    pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n-        let nanos = dur.as_nanos();\n-        let nanos = cmp::min(i64::MAX as u128, nanos);\n-\n-        // add current task to the wait queue\n-        let _ = abi::add_queue(self.id(), nanos as i64);\n-\n-        mutex.unlock();\n-        // If the return value is !0 then a timeout happened, so we return\n-        // `false` as we weren't actually notified.\n-        let ret = abi::wait(self.id()) == 0;\n-        mutex.lock();\n-\n-        ret\n+    pub unsafe fn wait_timeout(&self, _mutex: &Mutex, _dur: Duration) -> bool {\n+        panic!(\"wait_timeout not supported on hermit\");\n     }\n \n     pub unsafe fn destroy(&self) {\n-        let _ = abi::destroy_queue(self.id());\n-    }\n-\n-    #[inline]\n-    fn id(&self) -> usize {\n-        &self.identifier as *const usize as usize\n+        let _ = abi::sem_destroy(self.sem1);\n+        let _ = abi::sem_destroy(self.sem2);\n     }\n }"}, {"sha": "06442e925f4c8710d33caf6fff3e18a54e495081", "filename": "src/libstd/sys/hermit/rwlock.rs", "status": "modified", "additions": 105, "deletions": 10, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Flibstd%2Fsys%2Fhermit%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Flibstd%2Fsys%2Fhermit%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fhermit%2Frwlock.rs?ref=fe07ece978793d981150b0bdc8638b33e041381a", "patch": "@@ -1,49 +1,144 @@\n-use super::mutex::Mutex;\n+use crate::cell::UnsafeCell;\n+use crate::sys::condvar::Condvar;\n+use crate::sys::mutex::Mutex;\n \n pub struct RWLock {\n-    mutex: Mutex,\n+    lock: Mutex,\n+    cond: Condvar,\n+    state: UnsafeCell<State>,\n+}\n+\n+enum State {\n+    Unlocked,\n+    Reading(usize),\n+    Writing,\n }\n \n unsafe impl Send for RWLock {}\n unsafe impl Sync for RWLock {}\n \n+// This rwlock implementation is a relatively simple implementation which has a\n+// condition variable for readers/writers as well as a mutex protecting the\n+// internal state of the lock. A current downside of the implementation is that\n+// unlocking the lock will notify *all* waiters rather than just readers or just\n+// writers. This can cause lots of \"thundering stampede\" problems. While\n+// hopefully correct this implementation is very likely to want to be changed in\n+// the future.\n+\n impl RWLock {\n     pub const fn new() -> RWLock {\n-        RWLock { mutex: Mutex::new() }\n+        RWLock { lock: Mutex::new(), cond: Condvar::new(), state: UnsafeCell::new(State::Unlocked) }\n     }\n \n     #[inline]\n     pub unsafe fn read(&self) {\n-        self.mutex.lock();\n+        self.lock.lock();\n+        while !(*self.state.get()).inc_readers() {\n+            self.cond.wait(&self.lock);\n+        }\n+        self.lock.unlock();\n     }\n \n     #[inline]\n     pub unsafe fn try_read(&self) -> bool {\n-        self.mutex.try_lock()\n+        self.lock.lock();\n+        let ok = (*self.state.get()).inc_readers();\n+        self.lock.unlock();\n+        return ok;\n     }\n \n     #[inline]\n     pub unsafe fn write(&self) {\n-        self.mutex.lock();\n+        self.lock.lock();\n+        while !(*self.state.get()).inc_writers() {\n+            self.cond.wait(&self.lock);\n+        }\n+        self.lock.unlock();\n     }\n \n     #[inline]\n     pub unsafe fn try_write(&self) -> bool {\n-        self.mutex.try_lock()\n+        self.lock.lock();\n+        let ok = (*self.state.get()).inc_writers();\n+        self.lock.unlock();\n+        return ok;\n     }\n \n     #[inline]\n     pub unsafe fn read_unlock(&self) {\n-        self.mutex.unlock();\n+        self.lock.lock();\n+        let notify = (*self.state.get()).dec_readers();\n+        self.lock.unlock();\n+        if notify {\n+            // FIXME: should only wake up one of these some of the time\n+            self.cond.notify_all();\n+        }\n     }\n \n     #[inline]\n     pub unsafe fn write_unlock(&self) {\n-        self.mutex.unlock();\n+        self.lock.lock();\n+        (*self.state.get()).dec_writers();\n+        self.lock.unlock();\n+        // FIXME: should only wake up one of these some of the time\n+        self.cond.notify_all();\n     }\n \n     #[inline]\n     pub unsafe fn destroy(&self) {\n-        self.mutex.destroy();\n+        self.lock.destroy();\n+        self.cond.destroy();\n+    }\n+}\n+\n+impl State {\n+    fn inc_readers(&mut self) -> bool {\n+        match *self {\n+            State::Unlocked => {\n+                *self = State::Reading(1);\n+                true\n+            }\n+            State::Reading(ref mut cnt) => {\n+                *cnt += 1;\n+                true\n+            }\n+            State::Writing => false,\n+        }\n+    }\n+\n+    fn inc_writers(&mut self) -> bool {\n+        match *self {\n+            State::Unlocked => {\n+                *self = State::Writing;\n+                true\n+            }\n+            State::Reading(_) | State::Writing => false,\n+        }\n+    }\n+\n+    fn dec_readers(&mut self) -> bool {\n+        let zero = match *self {\n+            State::Reading(ref mut cnt) => {\n+                *cnt -= 1;\n+                *cnt == 0\n+            }\n+            State::Unlocked | State::Writing => invalid(),\n+        };\n+        if zero {\n+            *self = State::Unlocked;\n+        }\n+        zero\n     }\n+\n+    fn dec_writers(&mut self) {\n+        match *self {\n+            State::Writing => {}\n+            State::Unlocked | State::Reading(_) => invalid(),\n+        }\n+        *self = State::Unlocked;\n+    }\n+}\n+\n+fn invalid() -> ! {\n+    panic!(\"inconsistent rwlock\");\n }"}, {"sha": "4e09acbaa53b45b38c9266c153363602a5ed5106", "filename": "src/test/mir-opt/const_prop/boolean_identities.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fboolean_identities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fboolean_identities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fboolean_identities.rs?ref=fe07ece978793d981150b0bdc8638b33e041381a", "patch": "@@ -0,0 +1,10 @@\n+// compile-flags: -O -Zmir-opt-level=3\n+\n+// EMIT_MIR rustc.test.ConstProp.diff\n+pub fn test(x: bool, y: bool) -> bool {\n+    (y | true) & (x & false)\n+}\n+\n+fn main() {\n+    test(true, false);\n+}"}, {"sha": "b8f0ad4d434cb8e0549c0c4d8d8581f200f627d0", "filename": "src/test/mir-opt/const_prop/boolean_identities/rustc.test.ConstProp.diff", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fboolean_identities%2Frustc.test.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fboolean_identities%2Frustc.test.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fboolean_identities%2Frustc.test.ConstProp.diff?ref=fe07ece978793d981150b0bdc8638b33e041381a", "patch": "@@ -0,0 +1,53 @@\n+- // MIR for `test` before ConstProp\n++ // MIR for `test` after ConstProp\n+  \n+  fn test(_1: bool, _2: bool) -> bool {\n+      debug x => _1;                       // in scope 0 at $DIR/boolean_identities.rs:4:13: 4:14\n+      debug y => _2;                       // in scope 0 at $DIR/boolean_identities.rs:4:22: 4:23\n+      let mut _0: bool;                    // return place in scope 0 at $DIR/boolean_identities.rs:4:34: 4:38\n+      let mut _3: bool;                    // in scope 0 at $DIR/boolean_identities.rs:5:5: 5:15\n+      let mut _4: bool;                    // in scope 0 at $DIR/boolean_identities.rs:5:6: 5:7\n+      let mut _5: bool;                    // in scope 0 at $DIR/boolean_identities.rs:5:18: 5:29\n+      let mut _6: bool;                    // in scope 0 at $DIR/boolean_identities.rs:5:19: 5:20\n+  \n+      bb0: {\n+          StorageLive(_3);                 // scope 0 at $DIR/boolean_identities.rs:5:5: 5:15\n+          StorageLive(_4);                 // scope 0 at $DIR/boolean_identities.rs:5:6: 5:7\n+          _4 = _2;                         // scope 0 at $DIR/boolean_identities.rs:5:6: 5:7\n+-         _3 = BitOr(move _4, const true); // scope 0 at $DIR/boolean_identities.rs:5:5: 5:15\n++         _3 = const true;                 // scope 0 at $DIR/boolean_identities.rs:5:5: 5:15\n+                                           // ty::Const\n+                                           // + ty: bool\n+                                           // + val: Value(Scalar(0x01))\n+                                           // mir::Constant\n+-                                          // + span: $DIR/boolean_identities.rs:5:10: 5:14\n++                                          // + span: $DIR/boolean_identities.rs:5:5: 5:15\n+                                           // + literal: Const { ty: bool, val: Value(Scalar(0x01)) }\n+          StorageDead(_4);                 // scope 0 at $DIR/boolean_identities.rs:5:14: 5:15\n+          StorageLive(_5);                 // scope 0 at $DIR/boolean_identities.rs:5:18: 5:29\n+          StorageLive(_6);                 // scope 0 at $DIR/boolean_identities.rs:5:19: 5:20\n+          _6 = _1;                         // scope 0 at $DIR/boolean_identities.rs:5:19: 5:20\n+-         _5 = BitAnd(move _6, const false); // scope 0 at $DIR/boolean_identities.rs:5:18: 5:29\n++         _5 = const false;                // scope 0 at $DIR/boolean_identities.rs:5:18: 5:29\n+                                           // ty::Const\n+                                           // + ty: bool\n+                                           // + val: Value(Scalar(0x00))\n+                                           // mir::Constant\n+-                                          // + span: $DIR/boolean_identities.rs:5:23: 5:28\n++                                          // + span: $DIR/boolean_identities.rs:5:18: 5:29\n+                                           // + literal: Const { ty: bool, val: Value(Scalar(0x00)) }\n+          StorageDead(_6);                 // scope 0 at $DIR/boolean_identities.rs:5:28: 5:29\n+-         _0 = BitAnd(move _3, move _5);   // scope 0 at $DIR/boolean_identities.rs:5:5: 5:29\n++         _0 = const false;                // scope 0 at $DIR/boolean_identities.rs:5:5: 5:29\n++                                          // ty::Const\n++                                          // + ty: bool\n++                                          // + val: Value(Scalar(0x00))\n++                                          // mir::Constant\n++                                          // + span: $DIR/boolean_identities.rs:5:5: 5:29\n++                                          // + literal: Const { ty: bool, val: Value(Scalar(0x00)) }\n+          StorageDead(_5);                 // scope 0 at $DIR/boolean_identities.rs:5:28: 5:29\n+          StorageDead(_3);                 // scope 0 at $DIR/boolean_identities.rs:5:28: 5:29\n+          return;                          // scope 0 at $DIR/boolean_identities.rs:6:2: 6:2\n+      }\n+  }\n+  "}, {"sha": "f40faee3110aee197e5248af2256d849a729277f", "filename": "src/test/mir-opt/const_prop/mult_by_zero.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmult_by_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmult_by_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmult_by_zero.rs?ref=fe07ece978793d981150b0bdc8638b33e041381a", "patch": "@@ -0,0 +1,10 @@\n+// compile-flags: -O -Zmir-opt-level=3\n+\n+// EMIT_MIR rustc.test.ConstProp.diff\n+fn test(x : i32) -> i32 {\n+  x * 0\n+}\n+\n+fn main() {\n+    test(10);\n+}"}, {"sha": "7b36669bf15b2e63870562aa24ac93c7d333df5a", "filename": "src/test/mir-opt/const_prop/mult_by_zero/rustc.test.ConstProp.diff", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmult_by_zero%2Frustc.test.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmult_by_zero%2Frustc.test.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fmult_by_zero%2Frustc.test.ConstProp.diff?ref=fe07ece978793d981150b0bdc8638b33e041381a", "patch": "@@ -0,0 +1,25 @@\n+- // MIR for `test` before ConstProp\n++ // MIR for `test` after ConstProp\n+  \n+  fn test(_1: i32) -> i32 {\n+      debug x => _1;                       // in scope 0 at $DIR/mult_by_zero.rs:4:9: 4:10\n+      let mut _0: i32;                     // return place in scope 0 at $DIR/mult_by_zero.rs:4:21: 4:24\n+      let mut _2: i32;                     // in scope 0 at $DIR/mult_by_zero.rs:5:3: 5:4\n+  \n+      bb0: {\n+          StorageLive(_2);                 // scope 0 at $DIR/mult_by_zero.rs:5:3: 5:4\n+          _2 = _1;                         // scope 0 at $DIR/mult_by_zero.rs:5:3: 5:4\n+-         _0 = Mul(move _2, const 0_i32);  // scope 0 at $DIR/mult_by_zero.rs:5:3: 5:8\n++         _0 = const 0_i32;                // scope 0 at $DIR/mult_by_zero.rs:5:3: 5:8\n+                                           // ty::Const\n+                                           // + ty: i32\n+                                           // + val: Value(Scalar(0x00000000))\n+                                           // mir::Constant\n+-                                          // + span: $DIR/mult_by_zero.rs:5:7: 5:8\n++                                          // + span: $DIR/mult_by_zero.rs:5:3: 5:8\n+                                           // + literal: Const { ty: i32, val: Value(Scalar(0x00000000)) }\n+          StorageDead(_2);                 // scope 0 at $DIR/mult_by_zero.rs:5:7: 5:8\n+          return;                          // scope 0 at $DIR/mult_by_zero.rs:6:2: 6:2\n+      }\n+  }\n+  "}, {"sha": "2c5816c51e3e256a61921d6a5c43e7f1b243a520", "filename": "src/test/mir-opt/match-arm-scopes.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes.rs?ref=fe07ece978793d981150b0bdc8638b33e041381a", "patch": "@@ -9,8 +9,7 @@\n //   all of the bindings for that scope.\n // * No drop flags are used.\n \n-// EMIT_MIR rustc.complicated_match.SimplifyCfg-initial.after.mir\n-// EMIT_MIR rustc.complicated_match.ElaborateDrops.after.mir\n+// EMIT_MIR rustc.complicated_match SimplifyCfg-initial.after ElaborateDrops.after\n fn complicated_match(cond: bool, items: (bool, bool, String)) -> i32 {\n     match items {\n         (false, a, s) | (a, false, s) if if cond { return 3 } else { a } => 1,"}, {"sha": "df6a247bb5ff6dd14c69ba3363449e9981a069ac", "filename": "src/test/mir-opt/match-arm-scopes/rustc.complicated_match.ElaborateDrops.after.mir", "status": "removed", "additions": 0, "deletions": 235, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/cfb6114b2a20e04e3212ed030bc68d23faf8048f/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes%2Frustc.complicated_match.ElaborateDrops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/cfb6114b2a20e04e3212ed030bc68d23faf8048f/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes%2Frustc.complicated_match.ElaborateDrops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes%2Frustc.complicated_match.ElaborateDrops.after.mir?ref=cfb6114b2a20e04e3212ed030bc68d23faf8048f", "patch": "@@ -1,235 +0,0 @@\n-// MIR for `complicated_match` after ElaborateDrops\n-\n-fn complicated_match(_1: bool, _2: (bool, bool, std::string::String)) -> i32 {\n-    debug cond => _1;                    // in scope 0 at $DIR/match-arm-scopes.rs:14:22: 14:26\n-    debug items => _2;                   // in scope 0 at $DIR/match-arm-scopes.rs:14:34: 14:39\n-    let mut _0: i32;                     // return place in scope 0 at $DIR/match-arm-scopes.rs:14:66: 14:69\n-    let mut _3: &bool;                   // in scope 0 at $DIR/match-arm-scopes.rs:15:11: 15:16\n-    let mut _4: &bool;                   // in scope 0 at $DIR/match-arm-scopes.rs:15:11: 15:16\n-    let _5: bool;                        // in scope 0 at $DIR/match-arm-scopes.rs:16:17: 16:18\n-    let _6: &bool;                       // in scope 0 at $DIR/match-arm-scopes.rs:16:17: 16:18\n-    let _7: std::string::String;         // in scope 0 at $DIR/match-arm-scopes.rs:16:20: 16:21\n-    let _8: &std::string::String;        // in scope 0 at $DIR/match-arm-scopes.rs:16:20: 16:21\n-    let mut _9: bool;                    // in scope 0 at $DIR/match-arm-scopes.rs:16:42: 16:73\n-    let mut _10: bool;                   // in scope 0 at $DIR/match-arm-scopes.rs:16:45: 16:49\n-    let mut _11: !;                      // in scope 0 at $DIR/match-arm-scopes.rs:16:52: 16:60\n-    let mut _12: bool;                   // in scope 0 at $DIR/match-arm-scopes.rs:16:42: 16:73\n-    let mut _13: bool;                   // in scope 0 at $DIR/match-arm-scopes.rs:16:45: 16:49\n-    let mut _14: !;                      // in scope 0 at $DIR/match-arm-scopes.rs:16:52: 16:60\n-    let _15: bool;                       // in scope 0 at $DIR/match-arm-scopes.rs:17:16: 17:17\n-    let _16: std::string::String;        // in scope 0 at $DIR/match-arm-scopes.rs:17:19: 17:20\n-    scope 1 {\n-        debug a => _5;                   // in scope 1 at $DIR/match-arm-scopes.rs:16:17: 16:18\n-        debug a => _6;                   // in scope 1 at $DIR/match-arm-scopes.rs:16:17: 16:18\n-        debug s => _7;                   // in scope 1 at $DIR/match-arm-scopes.rs:16:20: 16:21\n-        debug s => _8;                   // in scope 1 at $DIR/match-arm-scopes.rs:16:20: 16:21\n-    }\n-    scope 2 {\n-        debug b => _15;                  // in scope 2 at $DIR/match-arm-scopes.rs:17:16: 17:17\n-        debug t => _16;                  // in scope 2 at $DIR/match-arm-scopes.rs:17:19: 17:20\n-    }\n-\n-    bb0: {\n-        switchInt((_2.0: bool)) -> [false: bb6, otherwise: bb2]; // scope 0 at $DIR/match-arm-scopes.rs:16:10: 16:15\n-    }\n-\n-    bb1 (cleanup): {\n-        resume;                          // scope 0 at $DIR/match-arm-scopes.rs:14:1: 19:2\n-    }\n-\n-    bb2: {\n-        switchInt((_2.1: bool)) -> [false: bb14, otherwise: bb3]; // scope 0 at $DIR/match-arm-scopes.rs:16:29: 16:34\n-    }\n-\n-    bb3: {\n-        switchInt((_2.0: bool)) -> [false: bb4, otherwise: bb21]; // scope 0 at $DIR/match-arm-scopes.rs:17:10: 17:14\n-    }\n-\n-    bb4: {\n-        StorageLive(_15);                // scope 0 at $DIR/match-arm-scopes.rs:17:32: 17:33\n-        _15 = (_2.1: bool);              // scope 0 at $DIR/match-arm-scopes.rs:17:32: 17:33\n-        StorageLive(_16);                // scope 0 at $DIR/match-arm-scopes.rs:17:35: 17:36\n-        _16 = move (_2.2: std::string::String); // scope 0 at $DIR/match-arm-scopes.rs:17:35: 17:36\n-        goto -> bb20;                    // scope 0 at $DIR/match-arm-scopes.rs:15:5: 18:6\n-    }\n-\n-    bb5: {\n-        _0 = const 1_i32;                // scope 1 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-                                         // ty::Const\n-                                         // + ty: i32\n-                                         // + val: Value(Scalar(0x00000001))\n-                                         // mir::Constant\n-                                         // + span: $DIR/match-arm-scopes.rs:16:77: 16:78\n-                                         // + literal: Const { ty: i32, val: Value(Scalar(0x00000001)) }\n-        drop(_7) -> [return: bb19, unwind: bb10]; // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-    }\n-\n-    bb6: {\n-        StorageLive(_6);                 // scope 0 at $DIR/match-arm-scopes.rs:16:17: 16:18\n-        _6 = &(_2.1: bool);              // scope 0 at $DIR/match-arm-scopes.rs:16:17: 16:18\n-        StorageLive(_8);                 // scope 0 at $DIR/match-arm-scopes.rs:16:20: 16:21\n-        _8 = &(_2.2: std::string::String); // scope 0 at $DIR/match-arm-scopes.rs:16:20: 16:21\n-        StorageLive(_9);                 // scope 0 at $DIR/match-arm-scopes.rs:16:42: 16:73\n-        StorageLive(_10);                // scope 0 at $DIR/match-arm-scopes.rs:16:45: 16:49\n-        _10 = _1;                        // scope 0 at $DIR/match-arm-scopes.rs:16:45: 16:49\n-        switchInt(_10) -> [false: bb7, otherwise: bb8]; // scope 0 at $DIR/match-arm-scopes.rs:16:42: 16:73\n-    }\n-\n-    bb7: {\n-        _9 = (*_6);                      // scope 0 at $DIR/match-arm-scopes.rs:16:70: 16:71\n-        StorageDead(_10);                // scope 0 at $DIR/match-arm-scopes.rs:16:72: 16:73\n-        switchInt(move _9) -> [false: bb13, otherwise: bb12]; // scope 0 at $DIR/match-arm-scopes.rs:16:42: 16:73\n-    }\n-\n-    bb8: {\n-        _0 = const 3_i32;                // scope 0 at $DIR/match-arm-scopes.rs:16:59: 16:60\n-                                         // ty::Const\n-                                         // + ty: i32\n-                                         // + val: Value(Scalar(0x00000003))\n-                                         // mir::Constant\n-                                         // + span: $DIR/match-arm-scopes.rs:16:59: 16:60\n-                                         // + literal: Const { ty: i32, val: Value(Scalar(0x00000003)) }\n-        StorageDead(_10);                // scope 0 at $DIR/match-arm-scopes.rs:16:72: 16:73\n-        StorageDead(_9);                 // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        StorageDead(_8);                 // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        StorageDead(_6);                 // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        goto -> bb11;                    // scope 0 at $DIR/match-arm-scopes.rs:16:52: 16:60\n-    }\n-\n-    bb9: {\n-        return;                          // scope 0 at $DIR/match-arm-scopes.rs:19:2: 19:2\n-    }\n-\n-    bb10 (cleanup): {\n-        goto -> bb25;                    // scope 0 at $DIR/match-arm-scopes.rs:19:1: 19:2\n-    }\n-\n-    bb11: {\n-        drop(_2) -> [return: bb9, unwind: bb1]; // scope 0 at $DIR/match-arm-scopes.rs:19:1: 19:2\n-    }\n-\n-    bb12: {\n-        StorageDead(_9);                 // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        StorageLive(_5);                 // scope 0 at $DIR/match-arm-scopes.rs:16:17: 16:18\n-        _5 = (_2.1: bool);               // scope 0 at $DIR/match-arm-scopes.rs:16:17: 16:18\n-        StorageLive(_7);                 // scope 0 at $DIR/match-arm-scopes.rs:16:20: 16:21\n-        _7 = move (_2.2: std::string::String); // scope 0 at $DIR/match-arm-scopes.rs:16:20: 16:21\n-        goto -> bb5;                     // scope 0 at $DIR/match-arm-scopes.rs:15:5: 18:6\n-    }\n-\n-    bb13: {\n-        StorageDead(_9);                 // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        StorageDead(_8);                 // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        StorageDead(_6);                 // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        goto -> bb2;                     // scope 0 at $DIR/match-arm-scopes.rs:16:42: 16:73\n-    }\n-\n-    bb14: {\n-        StorageLive(_6);                 // scope 0 at $DIR/match-arm-scopes.rs:16:26: 16:27\n-        _6 = &(_2.0: bool);              // scope 0 at $DIR/match-arm-scopes.rs:16:26: 16:27\n-        StorageLive(_8);                 // scope 0 at $DIR/match-arm-scopes.rs:16:36: 16:37\n-        _8 = &(_2.2: std::string::String); // scope 0 at $DIR/match-arm-scopes.rs:16:36: 16:37\n-        StorageLive(_12);                // scope 0 at $DIR/match-arm-scopes.rs:16:42: 16:73\n-        StorageLive(_13);                // scope 0 at $DIR/match-arm-scopes.rs:16:45: 16:49\n-        _13 = _1;                        // scope 0 at $DIR/match-arm-scopes.rs:16:45: 16:49\n-        switchInt(_13) -> [false: bb15, otherwise: bb16]; // scope 0 at $DIR/match-arm-scopes.rs:16:42: 16:73\n-    }\n-\n-    bb15: {\n-        _12 = (*_6);                     // scope 0 at $DIR/match-arm-scopes.rs:16:70: 16:71\n-        StorageDead(_13);                // scope 0 at $DIR/match-arm-scopes.rs:16:72: 16:73\n-        switchInt(move _12) -> [false: bb18, otherwise: bb17]; // scope 0 at $DIR/match-arm-scopes.rs:16:42: 16:73\n-    }\n-\n-    bb16: {\n-        _0 = const 3_i32;                // scope 0 at $DIR/match-arm-scopes.rs:16:59: 16:60\n-                                         // ty::Const\n-                                         // + ty: i32\n-                                         // + val: Value(Scalar(0x00000003))\n-                                         // mir::Constant\n-                                         // + span: $DIR/match-arm-scopes.rs:16:59: 16:60\n-                                         // + literal: Const { ty: i32, val: Value(Scalar(0x00000003)) }\n-        StorageDead(_13);                // scope 0 at $DIR/match-arm-scopes.rs:16:72: 16:73\n-        StorageDead(_12);                // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        StorageDead(_8);                 // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        StorageDead(_6);                 // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        goto -> bb11;                    // scope 0 at $DIR/match-arm-scopes.rs:16:52: 16:60\n-    }\n-\n-    bb17: {\n-        StorageDead(_12);                // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        StorageLive(_5);                 // scope 0 at $DIR/match-arm-scopes.rs:16:26: 16:27\n-        _5 = (_2.0: bool);               // scope 0 at $DIR/match-arm-scopes.rs:16:26: 16:27\n-        StorageLive(_7);                 // scope 0 at $DIR/match-arm-scopes.rs:16:36: 16:37\n-        _7 = move (_2.2: std::string::String); // scope 0 at $DIR/match-arm-scopes.rs:16:36: 16:37\n-        goto -> bb5;                     // scope 0 at $DIR/match-arm-scopes.rs:15:5: 18:6\n-    }\n-\n-    bb18: {\n-        StorageDead(_12);                // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        StorageDead(_8);                 // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        StorageDead(_6);                 // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        goto -> bb3;                     // scope 0 at $DIR/match-arm-scopes.rs:16:42: 16:73\n-    }\n-\n-    bb19: {\n-        StorageDead(_7);                 // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        StorageDead(_5);                 // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        StorageDead(_8);                 // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        StorageDead(_6);                 // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        goto -> bb23;                    // scope 0 at $DIR/match-arm-scopes.rs:15:5: 18:6\n-    }\n-\n-    bb20: {\n-        _0 = const 2_i32;                // scope 2 at $DIR/match-arm-scopes.rs:17:41: 17:42\n-                                         // ty::Const\n-                                         // + ty: i32\n-                                         // + val: Value(Scalar(0x00000002))\n-                                         // mir::Constant\n-                                         // + span: $DIR/match-arm-scopes.rs:17:41: 17:42\n-                                         // + literal: Const { ty: i32, val: Value(Scalar(0x00000002)) }\n-        drop(_16) -> [return: bb22, unwind: bb10]; // scope 0 at $DIR/match-arm-scopes.rs:17:41: 17:42\n-    }\n-\n-    bb21: {\n-        StorageLive(_15);                // scope 0 at $DIR/match-arm-scopes.rs:17:16: 17:17\n-        _15 = (_2.1: bool);              // scope 0 at $DIR/match-arm-scopes.rs:17:16: 17:17\n-        StorageLive(_16);                // scope 0 at $DIR/match-arm-scopes.rs:17:19: 17:20\n-        _16 = move (_2.2: std::string::String); // scope 0 at $DIR/match-arm-scopes.rs:17:19: 17:20\n-        goto -> bb20;                    // scope 0 at $DIR/match-arm-scopes.rs:15:5: 18:6\n-    }\n-\n-    bb22: {\n-        StorageDead(_16);                // scope 0 at $DIR/match-arm-scopes.rs:17:41: 17:42\n-        StorageDead(_15);                // scope 0 at $DIR/match-arm-scopes.rs:17:41: 17:42\n-        goto -> bb23;                    // scope 0 at $DIR/match-arm-scopes.rs:15:5: 18:6\n-    }\n-\n-    bb23: {\n-        goto -> bb29;                    // scope 0 at $DIR/match-arm-scopes.rs:19:1: 19:2\n-    }\n-\n-    bb24 (cleanup): {\n-        goto -> bb1;                     // scope 0 at $DIR/match-arm-scopes.rs:19:1: 19:2\n-    }\n-\n-    bb25 (cleanup): {\n-        goto -> bb24;                    // scope 0 at $DIR/match-arm-scopes.rs:19:1: 19:2\n-    }\n-\n-    bb26: {\n-        goto -> bb9;                     // scope 0 at $DIR/match-arm-scopes.rs:19:1: 19:2\n-    }\n-\n-    bb27 (cleanup): {\n-        goto -> bb1;                     // scope 0 at $DIR/match-arm-scopes.rs:19:1: 19:2\n-    }\n-\n-    bb28 (cleanup): {\n-        goto -> bb27;                    // scope 0 at $DIR/match-arm-scopes.rs:19:1: 19:2\n-    }\n-\n-    bb29: {\n-        goto -> bb26;                    // scope 0 at $DIR/match-arm-scopes.rs:19:1: 19:2\n-    }\n-}"}, {"sha": "58847e1bceee66e208ec2c55c5d73600b1998d34", "filename": "src/test/mir-opt/match-arm-scopes/rustc.complicated_match.SimplifyCfg-initial.after-ElaborateDrops.after.diff", "status": "added", "additions": 313, "deletions": 0, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes%2Frustc.complicated_match.SimplifyCfg-initial.after-ElaborateDrops.after.diff", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes%2Frustc.complicated_match.SimplifyCfg-initial.after-ElaborateDrops.after.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes%2Frustc.complicated_match.SimplifyCfg-initial.after-ElaborateDrops.after.diff?ref=fe07ece978793d981150b0bdc8638b33e041381a", "patch": "@@ -0,0 +1,313 @@\n+- // MIR for `complicated_match` after SimplifyCfg-initial\n++ // MIR for `complicated_match` after ElaborateDrops\n+  \n+  fn complicated_match(_1: bool, _2: (bool, bool, std::string::String)) -> i32 {\n+      debug cond => _1;                    // in scope 0 at $DIR/match-arm-scopes.rs:13:22: 13:26\n+      debug items => _2;                   // in scope 0 at $DIR/match-arm-scopes.rs:13:34: 13:39\n+      let mut _0: i32;                     // return place in scope 0 at $DIR/match-arm-scopes.rs:13:66: 13:69\n+      let mut _3: &bool;                   // in scope 0 at $DIR/match-arm-scopes.rs:14:11: 14:16\n+      let mut _4: &bool;                   // in scope 0 at $DIR/match-arm-scopes.rs:14:11: 14:16\n+      let _5: bool;                        // in scope 0 at $DIR/match-arm-scopes.rs:15:17: 15:18\n+      let _6: &bool;                       // in scope 0 at $DIR/match-arm-scopes.rs:15:17: 15:18\n+      let _7: std::string::String;         // in scope 0 at $DIR/match-arm-scopes.rs:15:20: 15:21\n+      let _8: &std::string::String;        // in scope 0 at $DIR/match-arm-scopes.rs:15:20: 15:21\n+      let mut _9: bool;                    // in scope 0 at $DIR/match-arm-scopes.rs:15:42: 15:73\n+      let mut _10: bool;                   // in scope 0 at $DIR/match-arm-scopes.rs:15:45: 15:49\n+      let mut _11: !;                      // in scope 0 at $DIR/match-arm-scopes.rs:15:52: 15:60\n+      let mut _12: bool;                   // in scope 0 at $DIR/match-arm-scopes.rs:15:42: 15:73\n+      let mut _13: bool;                   // in scope 0 at $DIR/match-arm-scopes.rs:15:45: 15:49\n+      let mut _14: !;                      // in scope 0 at $DIR/match-arm-scopes.rs:15:52: 15:60\n+      let _15: bool;                       // in scope 0 at $DIR/match-arm-scopes.rs:16:16: 16:17\n+      let _16: std::string::String;        // in scope 0 at $DIR/match-arm-scopes.rs:16:19: 16:20\n+      scope 1 {\n+          debug a => _5;                   // in scope 1 at $DIR/match-arm-scopes.rs:15:17: 15:18\n+          debug a => _6;                   // in scope 1 at $DIR/match-arm-scopes.rs:15:17: 15:18\n+          debug s => _7;                   // in scope 1 at $DIR/match-arm-scopes.rs:15:20: 15:21\n+          debug s => _8;                   // in scope 1 at $DIR/match-arm-scopes.rs:15:20: 15:21\n+      }\n+      scope 2 {\n+          debug b => _15;                  // in scope 2 at $DIR/match-arm-scopes.rs:16:16: 16:17\n+          debug t => _16;                  // in scope 2 at $DIR/match-arm-scopes.rs:16:19: 16:20\n+      }\n+  \n+      bb0: {\n+-         FakeRead(ForMatchedPlace, _2);   // scope 0 at $DIR/match-arm-scopes.rs:14:11: 14:16\n+-         switchInt((_2.0: bool)) -> [false: bb2, otherwise: bb3]; // scope 0 at $DIR/match-arm-scopes.rs:15:10: 15:15\n++         switchInt((_2.0: bool)) -> [false: bb6, otherwise: bb2]; // scope 0 at $DIR/match-arm-scopes.rs:15:10: 15:15\n+      }\n+  \n+      bb1 (cleanup): {\n+          resume;                          // scope 0 at $DIR/match-arm-scopes.rs:13:1: 18:2\n+      }\n+  \n+      bb2: {\n+-         falseEdge -> [real: bb9, imaginary: bb4]; // scope 0 at $DIR/match-arm-scopes.rs:15:9: 15:22\n++         switchInt((_2.1: bool)) -> [false: bb14, otherwise: bb3]; // scope 0 at $DIR/match-arm-scopes.rs:15:29: 15:34\n+      }\n+  \n+      bb3: {\n+-         switchInt((_2.1: bool)) -> [false: bb4, otherwise: bb5]; // scope 0 at $DIR/match-arm-scopes.rs:15:29: 15:34\n++         switchInt((_2.0: bool)) -> [false: bb4, otherwise: bb21]; // scope 0 at $DIR/match-arm-scopes.rs:16:10: 16:14\n+      }\n+  \n+      bb4: {\n+-         falseEdge -> [real: bb18, imaginary: bb6]; // scope 0 at $DIR/match-arm-scopes.rs:15:25: 15:38\n+-     }\n+- \n+-     bb5: {\n+-         switchInt((_2.0: bool)) -> [false: bb7, otherwise: bb6]; // scope 0 at $DIR/match-arm-scopes.rs:16:10: 16:14\n+-     }\n+- \n+-     bb6: {\n+-         falseEdge -> [real: bb26, imaginary: bb7]; // scope 0 at $DIR/match-arm-scopes.rs:16:9: 16:21\n+-     }\n+- \n+-     bb7: {\n+          StorageLive(_15);                // scope 0 at $DIR/match-arm-scopes.rs:16:32: 16:33\n+          _15 = (_2.1: bool);              // scope 0 at $DIR/match-arm-scopes.rs:16:32: 16:33\n+          StorageLive(_16);                // scope 0 at $DIR/match-arm-scopes.rs:16:35: 16:36\n+          _16 = move (_2.2: std::string::String); // scope 0 at $DIR/match-arm-scopes.rs:16:35: 16:36\n+-         goto -> bb25;                    // scope 0 at $DIR/match-arm-scopes.rs:14:5: 17:6\n++         goto -> bb20;                    // scope 0 at $DIR/match-arm-scopes.rs:14:5: 17:6\n+      }\n+  \n+-     bb8: {\n++     bb5: {\n+          _0 = const 1_i32;                // scope 1 at $DIR/match-arm-scopes.rs:15:77: 15:78\n+                                           // ty::Const\n+                                           // + ty: i32\n+                                           // + val: Value(Scalar(0x00000001))\n+                                           // mir::Constant\n+                                           // + span: $DIR/match-arm-scopes.rs:15:77: 15:78\n+                                           // + literal: Const { ty: i32, val: Value(Scalar(0x00000001)) }\n+-         drop(_7) -> [return: bb24, unwind: bb14]; // scope 0 at $DIR/match-arm-scopes.rs:15:77: 15:78\n++         drop(_7) -> [return: bb19, unwind: bb10]; // scope 0 at $DIR/match-arm-scopes.rs:15:77: 15:78\n+      }\n+  \n+-     bb9: {\n++     bb6: {\n+          StorageLive(_6);                 // scope 0 at $DIR/match-arm-scopes.rs:15:17: 15:18\n+          _6 = &(_2.1: bool);              // scope 0 at $DIR/match-arm-scopes.rs:15:17: 15:18\n+          StorageLive(_8);                 // scope 0 at $DIR/match-arm-scopes.rs:15:20: 15:21\n+          _8 = &(_2.2: std::string::String); // scope 0 at $DIR/match-arm-scopes.rs:15:20: 15:21\n+-         _3 = &shallow (_2.0: bool);      // scope 0 at $DIR/match-arm-scopes.rs:14:11: 14:16\n+-         _4 = &shallow (_2.1: bool);      // scope 0 at $DIR/match-arm-scopes.rs:14:11: 14:16\n+          StorageLive(_9);                 // scope 0 at $DIR/match-arm-scopes.rs:15:42: 15:73\n+          StorageLive(_10);                // scope 0 at $DIR/match-arm-scopes.rs:15:45: 15:49\n+          _10 = _1;                        // scope 0 at $DIR/match-arm-scopes.rs:15:45: 15:49\n+-         FakeRead(ForMatchedPlace, _10);  // scope 0 at $DIR/match-arm-scopes.rs:15:45: 15:49\n+-         switchInt(_10) -> [false: bb11, otherwise: bb10]; // scope 0 at $DIR/match-arm-scopes.rs:15:42: 15:73\n++         switchInt(_10) -> [false: bb7, otherwise: bb8]; // scope 0 at $DIR/match-arm-scopes.rs:15:42: 15:73\n+      }\n+  \n+-     bb10: {\n+-         falseEdge -> [real: bb12, imaginary: bb11]; // scope 0 at $DIR/match-arm-scopes.rs:15:42: 15:73\n+-     }\n+- \n+-     bb11: {\n++     bb7: {\n+          _9 = (*_6);                      // scope 0 at $DIR/match-arm-scopes.rs:15:70: 15:71\n+          StorageDead(_10);                // scope 0 at $DIR/match-arm-scopes.rs:15:72: 15:73\n+-         switchInt(move _9) -> [false: bb17, otherwise: bb16]; // scope 0 at $DIR/match-arm-scopes.rs:15:42: 15:73\n++         switchInt(move _9) -> [false: bb13, otherwise: bb12]; // scope 0 at $DIR/match-arm-scopes.rs:15:42: 15:73\n+      }\n+  \n+-     bb12: {\n++     bb8: {\n+          _0 = const 3_i32;                // scope 0 at $DIR/match-arm-scopes.rs:15:59: 15:60\n+                                           // ty::Const\n+                                           // + ty: i32\n+                                           // + val: Value(Scalar(0x00000003))\n+                                           // mir::Constant\n+                                           // + span: $DIR/match-arm-scopes.rs:15:59: 15:60\n+                                           // + literal: Const { ty: i32, val: Value(Scalar(0x00000003)) }\n+          StorageDead(_10);                // scope 0 at $DIR/match-arm-scopes.rs:15:72: 15:73\n+          StorageDead(_9);                 // scope 0 at $DIR/match-arm-scopes.rs:15:77: 15:78\n+          StorageDead(_8);                 // scope 0 at $DIR/match-arm-scopes.rs:15:77: 15:78\n+          StorageDead(_6);                 // scope 0 at $DIR/match-arm-scopes.rs:15:77: 15:78\n+-         goto -> bb15;                    // scope 0 at $DIR/match-arm-scopes.rs:15:52: 15:60\n++         goto -> bb11;                    // scope 0 at $DIR/match-arm-scopes.rs:15:52: 15:60\n+      }\n+  \n+-     bb13: {\n++     bb9: {\n+          return;                          // scope 0 at $DIR/match-arm-scopes.rs:18:2: 18:2\n+      }\n+  \n+-     bb14 (cleanup): {\n+-         drop(_2) -> bb1;                 // scope 0 at $DIR/match-arm-scopes.rs:18:1: 18:2\n++     bb10 (cleanup): {\n++         goto -> bb25;                    // scope 0 at $DIR/match-arm-scopes.rs:18:1: 18:2\n+      }\n+  \n+-     bb15: {\n+-         drop(_2) -> [return: bb13, unwind: bb1]; // scope 0 at $DIR/match-arm-scopes.rs:18:1: 18:2\n++     bb11: {\n++         drop(_2) -> [return: bb9, unwind: bb1]; // scope 0 at $DIR/match-arm-scopes.rs:18:1: 18:2\n+      }\n+  \n+-     bb16: {\n++     bb12: {\n+          StorageDead(_9);                 // scope 0 at $DIR/match-arm-scopes.rs:15:77: 15:78\n+-         FakeRead(ForMatchGuard, _3);     // scope 0 at $DIR/match-arm-scopes.rs:15:72: 15:73\n+-         FakeRead(ForMatchGuard, _4);     // scope 0 at $DIR/match-arm-scopes.rs:15:72: 15:73\n+-         FakeRead(ForGuardBinding, _6);   // scope 0 at $DIR/match-arm-scopes.rs:15:72: 15:73\n+-         FakeRead(ForGuardBinding, _8);   // scope 0 at $DIR/match-arm-scopes.rs:15:72: 15:73\n+          StorageLive(_5);                 // scope 0 at $DIR/match-arm-scopes.rs:15:17: 15:18\n+          _5 = (_2.1: bool);               // scope 0 at $DIR/match-arm-scopes.rs:15:17: 15:18\n+          StorageLive(_7);                 // scope 0 at $DIR/match-arm-scopes.rs:15:20: 15:21\n+          _7 = move (_2.2: std::string::String); // scope 0 at $DIR/match-arm-scopes.rs:15:20: 15:21\n+-         goto -> bb8;                     // scope 0 at $DIR/match-arm-scopes.rs:14:5: 17:6\n++         goto -> bb5;                     // scope 0 at $DIR/match-arm-scopes.rs:14:5: 17:6\n+      }\n+  \n+-     bb17: {\n++     bb13: {\n+          StorageDead(_9);                 // scope 0 at $DIR/match-arm-scopes.rs:15:77: 15:78\n+          StorageDead(_8);                 // scope 0 at $DIR/match-arm-scopes.rs:15:77: 15:78\n+          StorageDead(_6);                 // scope 0 at $DIR/match-arm-scopes.rs:15:77: 15:78\n+-         falseEdge -> [real: bb3, imaginary: bb4]; // scope 0 at $DIR/match-arm-scopes.rs:15:42: 15:73\n++         goto -> bb2;                     // scope 0 at $DIR/match-arm-scopes.rs:15:42: 15:73\n+      }\n+  \n+-     bb18: {\n++     bb14: {\n+          StorageLive(_6);                 // scope 0 at $DIR/match-arm-scopes.rs:15:26: 15:27\n+          _6 = &(_2.0: bool);              // scope 0 at $DIR/match-arm-scopes.rs:15:26: 15:27\n+          StorageLive(_8);                 // scope 0 at $DIR/match-arm-scopes.rs:15:36: 15:37\n+          _8 = &(_2.2: std::string::String); // scope 0 at $DIR/match-arm-scopes.rs:15:36: 15:37\n+-         _3 = &shallow (_2.0: bool);      // scope 0 at $DIR/match-arm-scopes.rs:14:11: 14:16\n+-         _4 = &shallow (_2.1: bool);      // scope 0 at $DIR/match-arm-scopes.rs:14:11: 14:16\n+          StorageLive(_12);                // scope 0 at $DIR/match-arm-scopes.rs:15:42: 15:73\n+          StorageLive(_13);                // scope 0 at $DIR/match-arm-scopes.rs:15:45: 15:49\n+          _13 = _1;                        // scope 0 at $DIR/match-arm-scopes.rs:15:45: 15:49\n+-         FakeRead(ForMatchedPlace, _13);  // scope 0 at $DIR/match-arm-scopes.rs:15:45: 15:49\n+-         switchInt(_13) -> [false: bb20, otherwise: bb19]; // scope 0 at $DIR/match-arm-scopes.rs:15:42: 15:73\n++         switchInt(_13) -> [false: bb15, otherwise: bb16]; // scope 0 at $DIR/match-arm-scopes.rs:15:42: 15:73\n+      }\n+  \n+-     bb19: {\n+-         falseEdge -> [real: bb21, imaginary: bb20]; // scope 0 at $DIR/match-arm-scopes.rs:15:42: 15:73\n+-     }\n+- \n+-     bb20: {\n++     bb15: {\n+          _12 = (*_6);                     // scope 0 at $DIR/match-arm-scopes.rs:15:70: 15:71\n+          StorageDead(_13);                // scope 0 at $DIR/match-arm-scopes.rs:15:72: 15:73\n+-         switchInt(move _12) -> [false: bb23, otherwise: bb22]; // scope 0 at $DIR/match-arm-scopes.rs:15:42: 15:73\n++         switchInt(move _12) -> [false: bb18, otherwise: bb17]; // scope 0 at $DIR/match-arm-scopes.rs:15:42: 15:73\n+      }\n+  \n+-     bb21: {\n++     bb16: {\n+          _0 = const 3_i32;                // scope 0 at $DIR/match-arm-scopes.rs:15:59: 15:60\n+                                           // ty::Const\n+                                           // + ty: i32\n+                                           // + val: Value(Scalar(0x00000003))\n+                                           // mir::Constant\n+                                           // + span: $DIR/match-arm-scopes.rs:15:59: 15:60\n+                                           // + literal: Const { ty: i32, val: Value(Scalar(0x00000003)) }\n+          StorageDead(_13);                // scope 0 at $DIR/match-arm-scopes.rs:15:72: 15:73\n+          StorageDead(_12);                // scope 0 at $DIR/match-arm-scopes.rs:15:77: 15:78\n+          StorageDead(_8);                 // scope 0 at $DIR/match-arm-scopes.rs:15:77: 15:78\n+          StorageDead(_6);                 // scope 0 at $DIR/match-arm-scopes.rs:15:77: 15:78\n+-         goto -> bb15;                    // scope 0 at $DIR/match-arm-scopes.rs:15:52: 15:60\n++         goto -> bb11;                    // scope 0 at $DIR/match-arm-scopes.rs:15:52: 15:60\n+      }\n+  \n+-     bb22: {\n++     bb17: {\n+          StorageDead(_12);                // scope 0 at $DIR/match-arm-scopes.rs:15:77: 15:78\n+-         FakeRead(ForMatchGuard, _3);     // scope 0 at $DIR/match-arm-scopes.rs:15:72: 15:73\n+-         FakeRead(ForMatchGuard, _4);     // scope 0 at $DIR/match-arm-scopes.rs:15:72: 15:73\n+-         FakeRead(ForGuardBinding, _6);   // scope 0 at $DIR/match-arm-scopes.rs:15:72: 15:73\n+-         FakeRead(ForGuardBinding, _8);   // scope 0 at $DIR/match-arm-scopes.rs:15:72: 15:73\n+          StorageLive(_5);                 // scope 0 at $DIR/match-arm-scopes.rs:15:26: 15:27\n+          _5 = (_2.0: bool);               // scope 0 at $DIR/match-arm-scopes.rs:15:26: 15:27\n+          StorageLive(_7);                 // scope 0 at $DIR/match-arm-scopes.rs:15:36: 15:37\n+          _7 = move (_2.2: std::string::String); // scope 0 at $DIR/match-arm-scopes.rs:15:36: 15:37\n+-         goto -> bb8;                     // scope 0 at $DIR/match-arm-scopes.rs:14:5: 17:6\n++         goto -> bb5;                     // scope 0 at $DIR/match-arm-scopes.rs:14:5: 17:6\n+      }\n+  \n+-     bb23: {\n++     bb18: {\n+          StorageDead(_12);                // scope 0 at $DIR/match-arm-scopes.rs:15:77: 15:78\n+          StorageDead(_8);                 // scope 0 at $DIR/match-arm-scopes.rs:15:77: 15:78\n+          StorageDead(_6);                 // scope 0 at $DIR/match-arm-scopes.rs:15:77: 15:78\n+-         falseEdge -> [real: bb5, imaginary: bb6]; // scope 0 at $DIR/match-arm-scopes.rs:15:42: 15:73\n++         goto -> bb3;                     // scope 0 at $DIR/match-arm-scopes.rs:15:42: 15:73\n+      }\n+  \n+-     bb24: {\n++     bb19: {\n+          StorageDead(_7);                 // scope 0 at $DIR/match-arm-scopes.rs:15:77: 15:78\n+          StorageDead(_5);                 // scope 0 at $DIR/match-arm-scopes.rs:15:77: 15:78\n+          StorageDead(_8);                 // scope 0 at $DIR/match-arm-scopes.rs:15:77: 15:78\n+          StorageDead(_6);                 // scope 0 at $DIR/match-arm-scopes.rs:15:77: 15:78\n+-         goto -> bb28;                    // scope 0 at $DIR/match-arm-scopes.rs:14:5: 17:6\n++         goto -> bb23;                    // scope 0 at $DIR/match-arm-scopes.rs:14:5: 17:6\n+      }\n+  \n+-     bb25: {\n++     bb20: {\n+          _0 = const 2_i32;                // scope 2 at $DIR/match-arm-scopes.rs:16:41: 16:42\n+                                           // ty::Const\n+                                           // + ty: i32\n+                                           // + val: Value(Scalar(0x00000002))\n+                                           // mir::Constant\n+                                           // + span: $DIR/match-arm-scopes.rs:16:41: 16:42\n+                                           // + literal: Const { ty: i32, val: Value(Scalar(0x00000002)) }\n+-         drop(_16) -> [return: bb27, unwind: bb14]; // scope 0 at $DIR/match-arm-scopes.rs:16:41: 16:42\n++         drop(_16) -> [return: bb22, unwind: bb10]; // scope 0 at $DIR/match-arm-scopes.rs:16:41: 16:42\n+      }\n+  \n+-     bb26: {\n++     bb21: {\n+          StorageLive(_15);                // scope 0 at $DIR/match-arm-scopes.rs:16:16: 16:17\n+          _15 = (_2.1: bool);              // scope 0 at $DIR/match-arm-scopes.rs:16:16: 16:17\n+          StorageLive(_16);                // scope 0 at $DIR/match-arm-scopes.rs:16:19: 16:20\n+          _16 = move (_2.2: std::string::String); // scope 0 at $DIR/match-arm-scopes.rs:16:19: 16:20\n+-         goto -> bb25;                    // scope 0 at $DIR/match-arm-scopes.rs:14:5: 17:6\n++         goto -> bb20;                    // scope 0 at $DIR/match-arm-scopes.rs:14:5: 17:6\n+      }\n+  \n+-     bb27: {\n++     bb22: {\n+          StorageDead(_16);                // scope 0 at $DIR/match-arm-scopes.rs:16:41: 16:42\n+          StorageDead(_15);                // scope 0 at $DIR/match-arm-scopes.rs:16:41: 16:42\n+-         goto -> bb28;                    // scope 0 at $DIR/match-arm-scopes.rs:14:5: 17:6\n++         goto -> bb23;                    // scope 0 at $DIR/match-arm-scopes.rs:14:5: 17:6\n+      }\n+  \n+-     bb28: {\n+-         drop(_2) -> [return: bb13, unwind: bb1]; // scope 0 at $DIR/match-arm-scopes.rs:18:1: 18:2\n++     bb23: {\n++         goto -> bb29;                    // scope 0 at $DIR/match-arm-scopes.rs:18:1: 18:2\n++     }\n++ \n++     bb24 (cleanup): {\n++         goto -> bb1;                     // scope 0 at $DIR/match-arm-scopes.rs:18:1: 18:2\n++     }\n++ \n++     bb25 (cleanup): {\n++         goto -> bb24;                    // scope 0 at $DIR/match-arm-scopes.rs:18:1: 18:2\n++     }\n++ \n++     bb26: {\n++         goto -> bb9;                     // scope 0 at $DIR/match-arm-scopes.rs:18:1: 18:2\n++     }\n++ \n++     bb27 (cleanup): {\n++         goto -> bb1;                     // scope 0 at $DIR/match-arm-scopes.rs:18:1: 18:2\n++     }\n++ \n++     bb28 (cleanup): {\n++         goto -> bb27;                    // scope 0 at $DIR/match-arm-scopes.rs:18:1: 18:2\n++     }\n++ \n++     bb29: {\n++         goto -> bb26;                    // scope 0 at $DIR/match-arm-scopes.rs:18:1: 18:2\n+      }\n+  }\n+  "}, {"sha": "dadbc3668cb29bf9200a64bab83ff3d0c55c9e64", "filename": "src/test/mir-opt/match-arm-scopes/rustc.complicated_match.SimplifyCfg-initial.after.mir", "status": "removed", "additions": 0, "deletions": 246, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/cfb6114b2a20e04e3212ed030bc68d23faf8048f/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes%2Frustc.complicated_match.SimplifyCfg-initial.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/cfb6114b2a20e04e3212ed030bc68d23faf8048f/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes%2Frustc.complicated_match.SimplifyCfg-initial.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch-arm-scopes%2Frustc.complicated_match.SimplifyCfg-initial.after.mir?ref=cfb6114b2a20e04e3212ed030bc68d23faf8048f", "patch": "@@ -1,246 +0,0 @@\n-// MIR for `complicated_match` after SimplifyCfg-initial\n-\n-fn complicated_match(_1: bool, _2: (bool, bool, std::string::String)) -> i32 {\n-    debug cond => _1;                    // in scope 0 at $DIR/match-arm-scopes.rs:14:22: 14:26\n-    debug items => _2;                   // in scope 0 at $DIR/match-arm-scopes.rs:14:34: 14:39\n-    let mut _0: i32;                     // return place in scope 0 at $DIR/match-arm-scopes.rs:14:66: 14:69\n-    let mut _3: &bool;                   // in scope 0 at $DIR/match-arm-scopes.rs:15:11: 15:16\n-    let mut _4: &bool;                   // in scope 0 at $DIR/match-arm-scopes.rs:15:11: 15:16\n-    let _5: bool;                        // in scope 0 at $DIR/match-arm-scopes.rs:16:17: 16:18\n-    let _6: &bool;                       // in scope 0 at $DIR/match-arm-scopes.rs:16:17: 16:18\n-    let _7: std::string::String;         // in scope 0 at $DIR/match-arm-scopes.rs:16:20: 16:21\n-    let _8: &std::string::String;        // in scope 0 at $DIR/match-arm-scopes.rs:16:20: 16:21\n-    let mut _9: bool;                    // in scope 0 at $DIR/match-arm-scopes.rs:16:42: 16:73\n-    let mut _10: bool;                   // in scope 0 at $DIR/match-arm-scopes.rs:16:45: 16:49\n-    let mut _11: !;                      // in scope 0 at $DIR/match-arm-scopes.rs:16:52: 16:60\n-    let mut _12: bool;                   // in scope 0 at $DIR/match-arm-scopes.rs:16:42: 16:73\n-    let mut _13: bool;                   // in scope 0 at $DIR/match-arm-scopes.rs:16:45: 16:49\n-    let mut _14: !;                      // in scope 0 at $DIR/match-arm-scopes.rs:16:52: 16:60\n-    let _15: bool;                       // in scope 0 at $DIR/match-arm-scopes.rs:17:16: 17:17\n-    let _16: std::string::String;        // in scope 0 at $DIR/match-arm-scopes.rs:17:19: 17:20\n-    scope 1 {\n-        debug a => _5;                   // in scope 1 at $DIR/match-arm-scopes.rs:16:17: 16:18\n-        debug a => _6;                   // in scope 1 at $DIR/match-arm-scopes.rs:16:17: 16:18\n-        debug s => _7;                   // in scope 1 at $DIR/match-arm-scopes.rs:16:20: 16:21\n-        debug s => _8;                   // in scope 1 at $DIR/match-arm-scopes.rs:16:20: 16:21\n-    }\n-    scope 2 {\n-        debug b => _15;                  // in scope 2 at $DIR/match-arm-scopes.rs:17:16: 17:17\n-        debug t => _16;                  // in scope 2 at $DIR/match-arm-scopes.rs:17:19: 17:20\n-    }\n-\n-    bb0: {\n-        FakeRead(ForMatchedPlace, _2);   // scope 0 at $DIR/match-arm-scopes.rs:15:11: 15:16\n-        switchInt((_2.0: bool)) -> [false: bb2, otherwise: bb3]; // scope 0 at $DIR/match-arm-scopes.rs:16:10: 16:15\n-    }\n-\n-    bb1 (cleanup): {\n-        resume;                          // scope 0 at $DIR/match-arm-scopes.rs:14:1: 19:2\n-    }\n-\n-    bb2: {\n-        falseEdge -> [real: bb9, imaginary: bb4]; // scope 0 at $DIR/match-arm-scopes.rs:16:9: 16:22\n-    }\n-\n-    bb3: {\n-        switchInt((_2.1: bool)) -> [false: bb4, otherwise: bb5]; // scope 0 at $DIR/match-arm-scopes.rs:16:29: 16:34\n-    }\n-\n-    bb4: {\n-        falseEdge -> [real: bb18, imaginary: bb6]; // scope 0 at $DIR/match-arm-scopes.rs:16:25: 16:38\n-    }\n-\n-    bb5: {\n-        switchInt((_2.0: bool)) -> [false: bb7, otherwise: bb6]; // scope 0 at $DIR/match-arm-scopes.rs:17:10: 17:14\n-    }\n-\n-    bb6: {\n-        falseEdge -> [real: bb26, imaginary: bb7]; // scope 0 at $DIR/match-arm-scopes.rs:17:9: 17:21\n-    }\n-\n-    bb7: {\n-        StorageLive(_15);                // scope 0 at $DIR/match-arm-scopes.rs:17:32: 17:33\n-        _15 = (_2.1: bool);              // scope 0 at $DIR/match-arm-scopes.rs:17:32: 17:33\n-        StorageLive(_16);                // scope 0 at $DIR/match-arm-scopes.rs:17:35: 17:36\n-        _16 = move (_2.2: std::string::String); // scope 0 at $DIR/match-arm-scopes.rs:17:35: 17:36\n-        goto -> bb25;                    // scope 0 at $DIR/match-arm-scopes.rs:15:5: 18:6\n-    }\n-\n-    bb8: {\n-        _0 = const 1_i32;                // scope 1 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-                                         // ty::Const\n-                                         // + ty: i32\n-                                         // + val: Value(Scalar(0x00000001))\n-                                         // mir::Constant\n-                                         // + span: $DIR/match-arm-scopes.rs:16:77: 16:78\n-                                         // + literal: Const { ty: i32, val: Value(Scalar(0x00000001)) }\n-        drop(_7) -> [return: bb24, unwind: bb14]; // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-    }\n-\n-    bb9: {\n-        StorageLive(_6);                 // scope 0 at $DIR/match-arm-scopes.rs:16:17: 16:18\n-        _6 = &(_2.1: bool);              // scope 0 at $DIR/match-arm-scopes.rs:16:17: 16:18\n-        StorageLive(_8);                 // scope 0 at $DIR/match-arm-scopes.rs:16:20: 16:21\n-        _8 = &(_2.2: std::string::String); // scope 0 at $DIR/match-arm-scopes.rs:16:20: 16:21\n-        _3 = &shallow (_2.0: bool);      // scope 0 at $DIR/match-arm-scopes.rs:15:11: 15:16\n-        _4 = &shallow (_2.1: bool);      // scope 0 at $DIR/match-arm-scopes.rs:15:11: 15:16\n-        StorageLive(_9);                 // scope 0 at $DIR/match-arm-scopes.rs:16:42: 16:73\n-        StorageLive(_10);                // scope 0 at $DIR/match-arm-scopes.rs:16:45: 16:49\n-        _10 = _1;                        // scope 0 at $DIR/match-arm-scopes.rs:16:45: 16:49\n-        FakeRead(ForMatchedPlace, _10);  // scope 0 at $DIR/match-arm-scopes.rs:16:45: 16:49\n-        switchInt(_10) -> [false: bb11, otherwise: bb10]; // scope 0 at $DIR/match-arm-scopes.rs:16:42: 16:73\n-    }\n-\n-    bb10: {\n-        falseEdge -> [real: bb12, imaginary: bb11]; // scope 0 at $DIR/match-arm-scopes.rs:16:42: 16:73\n-    }\n-\n-    bb11: {\n-        _9 = (*_6);                      // scope 0 at $DIR/match-arm-scopes.rs:16:70: 16:71\n-        StorageDead(_10);                // scope 0 at $DIR/match-arm-scopes.rs:16:72: 16:73\n-        switchInt(move _9) -> [false: bb17, otherwise: bb16]; // scope 0 at $DIR/match-arm-scopes.rs:16:42: 16:73\n-    }\n-\n-    bb12: {\n-        _0 = const 3_i32;                // scope 0 at $DIR/match-arm-scopes.rs:16:59: 16:60\n-                                         // ty::Const\n-                                         // + ty: i32\n-                                         // + val: Value(Scalar(0x00000003))\n-                                         // mir::Constant\n-                                         // + span: $DIR/match-arm-scopes.rs:16:59: 16:60\n-                                         // + literal: Const { ty: i32, val: Value(Scalar(0x00000003)) }\n-        StorageDead(_10);                // scope 0 at $DIR/match-arm-scopes.rs:16:72: 16:73\n-        StorageDead(_9);                 // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        StorageDead(_8);                 // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        StorageDead(_6);                 // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        goto -> bb15;                    // scope 0 at $DIR/match-arm-scopes.rs:16:52: 16:60\n-    }\n-\n-    bb13: {\n-        return;                          // scope 0 at $DIR/match-arm-scopes.rs:19:2: 19:2\n-    }\n-\n-    bb14 (cleanup): {\n-        drop(_2) -> bb1;                 // scope 0 at $DIR/match-arm-scopes.rs:19:1: 19:2\n-    }\n-\n-    bb15: {\n-        drop(_2) -> [return: bb13, unwind: bb1]; // scope 0 at $DIR/match-arm-scopes.rs:19:1: 19:2\n-    }\n-\n-    bb16: {\n-        StorageDead(_9);                 // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        FakeRead(ForMatchGuard, _3);     // scope 0 at $DIR/match-arm-scopes.rs:16:72: 16:73\n-        FakeRead(ForMatchGuard, _4);     // scope 0 at $DIR/match-arm-scopes.rs:16:72: 16:73\n-        FakeRead(ForGuardBinding, _6);   // scope 0 at $DIR/match-arm-scopes.rs:16:72: 16:73\n-        FakeRead(ForGuardBinding, _8);   // scope 0 at $DIR/match-arm-scopes.rs:16:72: 16:73\n-        StorageLive(_5);                 // scope 0 at $DIR/match-arm-scopes.rs:16:17: 16:18\n-        _5 = (_2.1: bool);               // scope 0 at $DIR/match-arm-scopes.rs:16:17: 16:18\n-        StorageLive(_7);                 // scope 0 at $DIR/match-arm-scopes.rs:16:20: 16:21\n-        _7 = move (_2.2: std::string::String); // scope 0 at $DIR/match-arm-scopes.rs:16:20: 16:21\n-        goto -> bb8;                     // scope 0 at $DIR/match-arm-scopes.rs:15:5: 18:6\n-    }\n-\n-    bb17: {\n-        StorageDead(_9);                 // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        StorageDead(_8);                 // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        StorageDead(_6);                 // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        falseEdge -> [real: bb3, imaginary: bb4]; // scope 0 at $DIR/match-arm-scopes.rs:16:42: 16:73\n-    }\n-\n-    bb18: {\n-        StorageLive(_6);                 // scope 0 at $DIR/match-arm-scopes.rs:16:26: 16:27\n-        _6 = &(_2.0: bool);              // scope 0 at $DIR/match-arm-scopes.rs:16:26: 16:27\n-        StorageLive(_8);                 // scope 0 at $DIR/match-arm-scopes.rs:16:36: 16:37\n-        _8 = &(_2.2: std::string::String); // scope 0 at $DIR/match-arm-scopes.rs:16:36: 16:37\n-        _3 = &shallow (_2.0: bool);      // scope 0 at $DIR/match-arm-scopes.rs:15:11: 15:16\n-        _4 = &shallow (_2.1: bool);      // scope 0 at $DIR/match-arm-scopes.rs:15:11: 15:16\n-        StorageLive(_12);                // scope 0 at $DIR/match-arm-scopes.rs:16:42: 16:73\n-        StorageLive(_13);                // scope 0 at $DIR/match-arm-scopes.rs:16:45: 16:49\n-        _13 = _1;                        // scope 0 at $DIR/match-arm-scopes.rs:16:45: 16:49\n-        FakeRead(ForMatchedPlace, _13);  // scope 0 at $DIR/match-arm-scopes.rs:16:45: 16:49\n-        switchInt(_13) -> [false: bb20, otherwise: bb19]; // scope 0 at $DIR/match-arm-scopes.rs:16:42: 16:73\n-    }\n-\n-    bb19: {\n-        falseEdge -> [real: bb21, imaginary: bb20]; // scope 0 at $DIR/match-arm-scopes.rs:16:42: 16:73\n-    }\n-\n-    bb20: {\n-        _12 = (*_6);                     // scope 0 at $DIR/match-arm-scopes.rs:16:70: 16:71\n-        StorageDead(_13);                // scope 0 at $DIR/match-arm-scopes.rs:16:72: 16:73\n-        switchInt(move _12) -> [false: bb23, otherwise: bb22]; // scope 0 at $DIR/match-arm-scopes.rs:16:42: 16:73\n-    }\n-\n-    bb21: {\n-        _0 = const 3_i32;                // scope 0 at $DIR/match-arm-scopes.rs:16:59: 16:60\n-                                         // ty::Const\n-                                         // + ty: i32\n-                                         // + val: Value(Scalar(0x00000003))\n-                                         // mir::Constant\n-                                         // + span: $DIR/match-arm-scopes.rs:16:59: 16:60\n-                                         // + literal: Const { ty: i32, val: Value(Scalar(0x00000003)) }\n-        StorageDead(_13);                // scope 0 at $DIR/match-arm-scopes.rs:16:72: 16:73\n-        StorageDead(_12);                // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        StorageDead(_8);                 // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        StorageDead(_6);                 // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        goto -> bb15;                    // scope 0 at $DIR/match-arm-scopes.rs:16:52: 16:60\n-    }\n-\n-    bb22: {\n-        StorageDead(_12);                // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        FakeRead(ForMatchGuard, _3);     // scope 0 at $DIR/match-arm-scopes.rs:16:72: 16:73\n-        FakeRead(ForMatchGuard, _4);     // scope 0 at $DIR/match-arm-scopes.rs:16:72: 16:73\n-        FakeRead(ForGuardBinding, _6);   // scope 0 at $DIR/match-arm-scopes.rs:16:72: 16:73\n-        FakeRead(ForGuardBinding, _8);   // scope 0 at $DIR/match-arm-scopes.rs:16:72: 16:73\n-        StorageLive(_5);                 // scope 0 at $DIR/match-arm-scopes.rs:16:26: 16:27\n-        _5 = (_2.0: bool);               // scope 0 at $DIR/match-arm-scopes.rs:16:26: 16:27\n-        StorageLive(_7);                 // scope 0 at $DIR/match-arm-scopes.rs:16:36: 16:37\n-        _7 = move (_2.2: std::string::String); // scope 0 at $DIR/match-arm-scopes.rs:16:36: 16:37\n-        goto -> bb8;                     // scope 0 at $DIR/match-arm-scopes.rs:15:5: 18:6\n-    }\n-\n-    bb23: {\n-        StorageDead(_12);                // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        StorageDead(_8);                 // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        StorageDead(_6);                 // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        falseEdge -> [real: bb5, imaginary: bb6]; // scope 0 at $DIR/match-arm-scopes.rs:16:42: 16:73\n-    }\n-\n-    bb24: {\n-        StorageDead(_7);                 // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        StorageDead(_5);                 // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        StorageDead(_8);                 // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        StorageDead(_6);                 // scope 0 at $DIR/match-arm-scopes.rs:16:77: 16:78\n-        goto -> bb28;                    // scope 0 at $DIR/match-arm-scopes.rs:15:5: 18:6\n-    }\n-\n-    bb25: {\n-        _0 = const 2_i32;                // scope 2 at $DIR/match-arm-scopes.rs:17:41: 17:42\n-                                         // ty::Const\n-                                         // + ty: i32\n-                                         // + val: Value(Scalar(0x00000002))\n-                                         // mir::Constant\n-                                         // + span: $DIR/match-arm-scopes.rs:17:41: 17:42\n-                                         // + literal: Const { ty: i32, val: Value(Scalar(0x00000002)) }\n-        drop(_16) -> [return: bb27, unwind: bb14]; // scope 0 at $DIR/match-arm-scopes.rs:17:41: 17:42\n-    }\n-\n-    bb26: {\n-        StorageLive(_15);                // scope 0 at $DIR/match-arm-scopes.rs:17:16: 17:17\n-        _15 = (_2.1: bool);              // scope 0 at $DIR/match-arm-scopes.rs:17:16: 17:17\n-        StorageLive(_16);                // scope 0 at $DIR/match-arm-scopes.rs:17:19: 17:20\n-        _16 = move (_2.2: std::string::String); // scope 0 at $DIR/match-arm-scopes.rs:17:19: 17:20\n-        goto -> bb25;                    // scope 0 at $DIR/match-arm-scopes.rs:15:5: 18:6\n-    }\n-\n-    bb27: {\n-        StorageDead(_16);                // scope 0 at $DIR/match-arm-scopes.rs:17:41: 17:42\n-        StorageDead(_15);                // scope 0 at $DIR/match-arm-scopes.rs:17:41: 17:42\n-        goto -> bb28;                    // scope 0 at $DIR/match-arm-scopes.rs:15:5: 18:6\n-    }\n-\n-    bb28: {\n-        drop(_2) -> [return: bb13, unwind: bb1]; // scope 0 at $DIR/match-arm-scopes.rs:19:1: 19:2\n-    }\n-}"}, {"sha": "795c5154f815551d04c1b0dfa6354c002081a9c1", "filename": "src/test/ui/consts/const-eval/index-out-of-bounds-never-type.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Findex-out-of-bounds-never-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Findex-out-of-bounds-never-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Findex-out-of-bounds-never-type.rs?ref=fe07ece978793d981150b0bdc8638b33e041381a", "patch": "@@ -1,14 +1,15 @@\n // build-fail\n \n // Regression test for #66975\n-#![warn(const_err)]\n+#![warn(const_err, unconditional_panic)]\n #![feature(never_type)]\n \n struct PrintName<T>(T);\n \n impl<T> PrintName<T> {\n     const VOID: ! = { let x = 0 * std::mem::size_of::<T>(); [][x] };\n     //~^ WARN any use of this value will cause an error\n+\n }\n \n fn f<T>() {"}, {"sha": "33e60dd7c9138c725e43441a8b2dbd677829ed3e", "filename": "src/test/ui/consts/const-eval/index-out-of-bounds-never-type.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Findex-out-of-bounds-never-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Findex-out-of-bounds-never-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Findex-out-of-bounds-never-type.stderr?ref=fe07ece978793d981150b0bdc8638b33e041381a", "patch": "@@ -9,11 +9,11 @@ LL |     const VOID: ! = { let x = 0 * std::mem::size_of::<T>(); [][x] };\n note: the lint level is defined here\n   --> $DIR/index-out-of-bounds-never-type.rs:4:9\n    |\n-LL | #![warn(const_err)]\n+LL | #![warn(const_err, unconditional_panic)]\n    |         ^^^^^^^^^\n \n error: erroneous constant encountered\n-  --> $DIR/index-out-of-bounds-never-type.rs:15:13\n+  --> $DIR/index-out-of-bounds-never-type.rs:16:13\n    |\n LL |     let _ = PrintName::<T>::VOID;\n    |             ^^^^^^^^^^^^^^^^^^^^"}, {"sha": "157f992da994033d36abf51c84e6c589d643588b", "filename": "src/test/ui/error-codes/E0308-2.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Ftest%2Fui%2Ferror-codes%2FE0308-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Ftest%2Fui%2Ferror-codes%2FE0308-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0308-2.rs?ref=fe07ece978793d981150b0bdc8638b33e041381a", "patch": "@@ -0,0 +1,12 @@\n+trait DynEq {}\n+\n+impl<'a> PartialEq for &'a (dyn DynEq + 'static) {\n+    fn eq(&self, _other: &Self) -> bool {\n+        true\n+    }\n+}\n+\n+impl Eq for &dyn DynEq {} //~ ERROR E0308\n+\n+fn main() {\n+}"}, {"sha": "e7c5e4b42405f9765056e1d76d36cf15c440f968", "filename": "src/test/ui/error-codes/E0308-2.stderr", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Ftest%2Fui%2Ferror-codes%2FE0308-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Ftest%2Fui%2Ferror-codes%2FE0308-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0308-2.stderr?ref=fe07ece978793d981150b0bdc8638b33e041381a", "patch": "@@ -0,0 +1,18 @@\n+error[E0308]: mismatched types\n+  --> $DIR/E0308-2.rs:9:6\n+   |\n+LL | impl Eq for &dyn DynEq {}\n+   |      ^^ lifetime mismatch\n+   |\n+   = note: expected trait `std::cmp::PartialEq`\n+              found trait `std::cmp::PartialEq`\n+note: the lifetime `'_` as defined on the impl at 9:13...\n+  --> $DIR/E0308-2.rs:9:13\n+   |\n+LL | impl Eq for &dyn DynEq {}\n+   |             ^\n+   = note: ...does not necessarily outlive the static lifetime\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "21fb7673ce061c9eb1b2fffd812edafde83cb576", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 43, "deletions": 10, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/fe07ece978793d981150b0bdc8638b33e041381a/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe07ece978793d981150b0bdc8638b33e041381a/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=fe07ece978793d981150b0bdc8638b33e041381a", "patch": "@@ -3135,14 +3135,47 @@ impl<'test> TestCx<'test> {\n         }\n         for l in test_file_contents.lines() {\n             if l.starts_with(\"// EMIT_MIR \") {\n-                let test_name = l.trim_start_matches(\"// EMIT_MIR \");\n-                let expected_file = test_dir.join(test_name);\n-\n-                let dumped_string = if test_name.ends_with(\".diff\") {\n-                    let test_name = test_name.trim_end_matches(\".diff\");\n-                    let before = format!(\"{}.before.mir\", test_name);\n-                    let after = format!(\"{}.after.mir\", test_name);\n-                    let before = self.get_mir_dump_dir().join(before);\n+                let test_name = l.trim_start_matches(\"// EMIT_MIR \").trim();\n+                let mut test_names = test_name.split(' ');\n+                // sometimes we specify two files so that we get a diff between the two files\n+                let test_name = test_names.next().unwrap();\n+                let expected_file;\n+                let from_file;\n+                let to_file;\n+\n+                if test_name.ends_with(\".diff\") {\n+                    let trimmed = test_name.trim_end_matches(\".diff\");\n+                    let test_against = format!(\"{}.after.mir\", trimmed);\n+                    from_file = format!(\"{}.before.mir\", trimmed);\n+                    expected_file = test_name.to_string();\n+                    assert!(\n+                        test_names.next().is_none(),\n+                        \"two mir pass names specified for MIR diff\"\n+                    );\n+                    to_file = Some(test_against);\n+                } else if let Some(first_pass) = test_names.next() {\n+                    let second_pass = test_names.next().unwrap();\n+                    assert!(\n+                        test_names.next().is_none(),\n+                        \"three mir pass names specified for MIR diff\"\n+                    );\n+                    expected_file = format!(\"{}.{}-{}.diff\", test_name, first_pass, second_pass);\n+                    let second_file = format!(\"{}.{}.mir\", test_name, second_pass);\n+                    from_file = format!(\"{}.{}.mir\", test_name, first_pass);\n+                    to_file = Some(second_file);\n+                } else {\n+                    expected_file = test_name.to_string();\n+                    from_file = test_name.to_string();\n+                    assert!(\n+                        test_names.next().is_none(),\n+                        \"two mir pass names specified for MIR dump\"\n+                    );\n+                    to_file = None;\n+                };\n+                let expected_file = test_dir.join(expected_file);\n+\n+                let dumped_string = if let Some(after) = to_file {\n+                    let before = self.get_mir_dump_dir().join(from_file);\n                     let after = self.get_mir_dump_dir().join(after);\n                     debug!(\n                         \"comparing the contents of: {} with {}\",\n@@ -3166,7 +3199,7 @@ impl<'test> TestCx<'test> {\n                 } else {\n                     let mut output_file = PathBuf::new();\n                     output_file.push(self.get_mir_dump_dir());\n-                    output_file.push(test_name);\n+                    output_file.push(&from_file);\n                     debug!(\n                         \"comparing the contents of: {} with {}\",\n                         output_file.display(),\n@@ -3179,7 +3212,7 @@ impl<'test> TestCx<'test> {\n                             output_file.parent().unwrap().display()\n                         );\n                     }\n-                    self.check_mir_test_timestamp(test_name, &output_file);\n+                    self.check_mir_test_timestamp(&from_file, &output_file);\n                     let dumped_string = fs::read_to_string(&output_file).unwrap();\n                     self.normalize_output(&dumped_string, &[])\n                 };"}]}