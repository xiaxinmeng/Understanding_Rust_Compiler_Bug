{"sha": "d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4ZTQ1ZWE3YzA1NGI0YWQ2ZmI4MmVjM2E5ZmNmMTczNmI0ZDcyNjA=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-04-02T23:54:22Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-04-10T12:10:10Z"}, "message": "libstd: Implement `StrBuf`, a new string buffer type like `Vec`, and\nport all code over to use it.", "tree": {"sha": "3ff220512aeae37710c8b1c783e1229e685bfce3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ff220512aeae37710c8b1c783e1229e685bfce3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "html_url": "https://github.com/rust-lang/rust/commit/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7fbcb400f0697621ece9f9773b0f0bf1ec73e9c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/7fbcb400f0697621ece9f9773b0f0bf1ec73e9c1", "html_url": "https://github.com/rust-lang/rust/commit/7fbcb400f0697621ece9f9773b0f0bf1ec73e9c1"}], "stats": {"total": 1915, "additions": 987, "deletions": 928}, "files": [{"sha": "9c5a71efac6f3d3a353e1228843ba9deda377431", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -31,6 +31,7 @@ use std::io::timer;\n use std::io;\n use std::os;\n use std::str;\n+use std::strbuf::StrBuf;\n use std::task;\n use std::slice;\n use test::MetricMap;\n@@ -328,10 +329,10 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n             }\n \n             let args = split_maybe_args(&config.target_rustcflags);\n-            let mut tool_path:~str = ~\"\";\n+            let mut tool_path = StrBuf::new();\n             for arg in args.iter() {\n                 if arg.contains(\"android-cross-path=\") {\n-                    tool_path = arg.replace(\"android-cross-path=\",\"\");\n+                    tool_path = StrBuf::from_str(arg.replace(\"android-cross-path=\", \"\"));\n                     break;\n                 }\n             }\n@@ -348,7 +349,7 @@ fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n             let gdb_path = tool_path.append(\"/bin/arm-linux-androideabi-gdb\");\n             let procsrv::Result{ out, err, status }=\n                 procsrv::run(\"\",\n-                             gdb_path,\n+                             gdb_path.as_slice(),\n                              debugger_opts.as_slice(),\n                              vec!((~\"\",~\"\")),\n                              None)"}, {"sha": "a0a012ef69bf59921145c5b18277af28a682960a", "filename": "src/doc/tutorial.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Fdoc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Fdoc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftutorial.md?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -1579,6 +1579,8 @@ allocated memory on the heap. A unique vector owns the elements it contains, so\n the elements are mutable if the vector is mutable.\n \n ~~~\n+use std::strbuf::StrBuf;\n+\n // A dynamically sized vector (unique vector)\n let mut numbers = ~[1, 2, 3];\n numbers.push(4);\n@@ -1589,7 +1591,7 @@ let more_numbers: ~[int] = numbers;\n \n // The original `numbers` value can no longer be used, due to move semantics.\n \n-let mut string = ~\"fo\";\n+let mut string = StrBuf::from_str(\"fo\");\n string.push_char('o');\n ~~~\n "}, {"sha": "49865cf5272bd84ce95c36afaa4f1baa188298c8", "filename": "src/libcollections/bitv.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibcollections%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibcollections%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbitv.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -15,8 +15,9 @@ use std::cmp;\n use std::iter::RandomAccessIterator;\n use std::iter::{Rev, Enumerate, Repeat, Map, Zip};\n use std::ops;\n-use std::uint;\n use std::slice;\n+use std::strbuf::StrBuf;\n+use std::uint;\n \n #[deriving(Clone)]\n struct SmallBitv {\n@@ -499,15 +500,15 @@ impl Bitv {\n      * character is either '0' or '1'.\n      */\n      pub fn to_str(&self) -> ~str {\n-        let mut rs = ~\"\";\n+        let mut rs = StrBuf::new();\n         for i in self.iter() {\n             if i {\n                 rs.push_char('1');\n             } else {\n                 rs.push_char('0');\n             }\n         };\n-        rs\n+        rs.into_owned()\n      }\n \n "}, {"sha": "bd0e2ebec6fd723e26987d83680f10801fb06126", "filename": "src/libcollections/hashmap.rs", "status": "modified", "additions": 111, "deletions": 70, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fhashmap.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -795,6 +795,97 @@ impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     fn search(&self, k: &K) -> Option<table::FullIndex> {\n         self.search_hashed(&self.make_hash(k), k)\n     }\n+\n+    fn pop_internal(&mut self, starting_index: table::FullIndex) -> Option<V> {\n+        let starting_probe = starting_index.raw_index();\n+\n+        let ending_probe = {\n+            let mut probe = self.probe_next(starting_probe);\n+            for _ in range(0u, self.table.size()) {\n+                match self.table.peek(probe) {\n+                    table::Empty(_) => {}, // empty bucket. this is the end of our shifting.\n+                    table::Full(idx) => {\n+                        // Bucket that isn't us, which has a non-zero probe distance.\n+                        // This isn't the ending index, so keep searching.\n+                        if self.bucket_distance(&idx) != 0 {\n+                            probe = self.probe_next(probe);\n+                            continue;\n+                        }\n+\n+                        // if we do have a bucket_distance of zero, we're at the end\n+                        // of what we need to shift.\n+                    }\n+                }\n+                break;\n+            }\n+\n+            probe\n+        };\n+\n+        let (_, _, retval) = self.table.take(starting_index);\n+\n+        let mut      probe = starting_probe;\n+        let mut next_probe = self.probe_next(probe);\n+\n+        // backwards-shift all the elements after our newly-deleted one.\n+        while next_probe != ending_probe {\n+            match self.table.peek(next_probe) {\n+                table::Empty(_) => {\n+                    // nothing to shift in. just empty it out.\n+                    match self.table.peek(probe) {\n+                        table::Empty(_) => {},\n+                        table::Full(idx) => { self.table.take(idx); }\n+                    }\n+                },\n+                table::Full(next_idx) => {\n+                    // something to shift. move it over!\n+                    let next_hash = next_idx.hash();\n+                    let (_, next_key, next_val) = self.table.take(next_idx);\n+                    match self.table.peek(probe) {\n+                        table::Empty(idx) => {\n+                            self.table.put(idx, next_hash, next_key, next_val);\n+                        },\n+                        table::Full(idx) => {\n+                            let (emptyidx, _, _) = self.table.take(idx);\n+                            self.table.put(emptyidx, next_hash, next_key, next_val);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            probe = next_probe;\n+            next_probe = self.probe_next(next_probe);\n+        }\n+\n+        // Done the backwards shift, but there's still an element left!\n+        // Empty it out.\n+        match self.table.peek(probe) {\n+            table::Empty(_) => {},\n+            table::Full(idx) => { self.table.take(idx); }\n+        }\n+\n+        // Now we're done all our shifting. Return the value we grabbed\n+        // earlier.\n+        return Some(retval);\n+    }\n+\n+    /// Like `pop`, but can operate on any type that is equivalent to a key.\n+    #[experimental]\n+    pub fn pop_equiv<Q:Hash<S> + Equiv<K>>(&mut self, k: &Q) -> Option<V> {\n+        if self.table.size() == 0 {\n+            return None\n+        }\n+\n+        let potential_new_size = self.table.size() - 1;\n+        self.make_some_room(potential_new_size);\n+\n+        let starting_index = match self.search_equiv(k) {\n+            Some(idx) => idx,\n+            None      => return None,\n+        };\n+\n+        self.pop_internal(starting_index)\n+    }\n }\n \n impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> Container for HashMap<K, V, H> {\n@@ -894,77 +985,9 @@ impl<K: TotalEq + Hash<S>, V, S, H: Hasher<S>> MutableMap<K, V> for HashMap<K, V\n             None      => return None,\n         };\n \n-        let starting_probe = starting_index.raw_index();\n-\n-        let ending_probe = {\n-            let mut probe = self.probe_next(starting_probe);\n-            for _ in range(0u, self.table.size()) {\n-                match self.table.peek(probe) {\n-                    table::Empty(_) => {}, // empty bucket. this is the end of our shifting.\n-                    table::Full(idx) => {\n-                        // Bucket that isn't us, which has a non-zero probe distance.\n-                        // This isn't the ending index, so keep searching.\n-                        if self.bucket_distance(&idx) != 0 {\n-                            probe = self.probe_next(probe);\n-                            continue;\n-                        }\n-\n-                        // if we do have a bucket_distance of zero, we're at the end\n-                        // of what we need to shift.\n-                    }\n-                }\n-                break;\n-            }\n-\n-            probe\n-        };\n-\n-        let (_, _, retval) = self.table.take(starting_index);\n-\n-        let mut      probe = starting_probe;\n-        let mut next_probe = self.probe_next(probe);\n-\n-        // backwards-shift all the elements after our newly-deleted one.\n-        while next_probe != ending_probe {\n-            match self.table.peek(next_probe) {\n-                table::Empty(_) => {\n-                    // nothing to shift in. just empty it out.\n-                    match self.table.peek(probe) {\n-                        table::Empty(_) => {},\n-                        table::Full(idx) => { self.table.take(idx); }\n-                    }\n-                },\n-                table::Full(next_idx) => {\n-                    // something to shift. move it over!\n-                    let next_hash = next_idx.hash();\n-                    let (_, next_key, next_val) = self.table.take(next_idx);\n-                    match self.table.peek(probe) {\n-                        table::Empty(idx) => {\n-                            self.table.put(idx, next_hash, next_key, next_val);\n-                        },\n-                        table::Full(idx) => {\n-                            let (emptyidx, _, _) = self.table.take(idx);\n-                            self.table.put(emptyidx, next_hash, next_key, next_val);\n-                        }\n-                    }\n-                }\n-            }\n-\n-            probe = next_probe;\n-            next_probe = self.probe_next(next_probe);\n-        }\n-\n-        // Done the backwards shift, but there's still an element left!\n-        // Empty it out.\n-        match self.table.peek(probe) {\n-            table::Empty(_) => {},\n-            table::Full(idx) => { self.table.take(idx); }\n-        }\n-\n-        // Now we're done all our shifting. Return the value we grabbed\n-        // earlier.\n-        return Some(retval);\n+        self.pop_internal(starting_index)\n     }\n+\n }\n \n impl<K: Hash + TotalEq, V> HashMap<K, V, sip::SipHasher> {\n@@ -1571,10 +1594,20 @@ pub type SetAlgebraItems<'a, T, H> =\n #[cfg(test)]\n mod test_map {\n     use super::HashMap;\n+    use std::cmp::Equiv;\n     use std::iter::{Iterator,range_inclusive,range_step_inclusive};\n     use std::local_data;\n     use std::vec;\n \n+    struct KindaIntLike(int);\n+\n+    impl Equiv<int> for KindaIntLike {\n+        fn equiv(&self, other: &int) -> bool {\n+            let KindaIntLike(this) = *self;\n+            this == *other\n+        }\n+    }\n+\n     #[test]\n     fn test_create_capacity_zero() {\n         let mut m = HashMap::with_capacity(0);\n@@ -1814,6 +1847,14 @@ mod test_map {\n         assert_eq!(m.pop(&1), None);\n     }\n \n+    #[test]\n+    fn test_pop_equiv() {\n+        let mut m = HashMap::new();\n+        m.insert(1, 2);\n+        assert_eq!(m.pop_equiv(&KindaIntLike(1), Some(2)));\n+        assert_eq!(m.pop_equiv(&KindaIntLike(1), None));\n+    }\n+\n     #[test]\n     fn test_swap() {\n         let mut m = HashMap::new();"}, {"sha": "c8c013b99f2210f2589a7c486075513488084b6d", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -92,6 +92,7 @@\n use std::cmp::Eq;\n use std::result::{Err, Ok};\n use std::result;\n+use std::strbuf::StrBuf;\n \n /// Name of an option. Either a string or a single char.\n #[deriving(Clone, Eq)]\n@@ -664,7 +665,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> ~str {\n                      hasarg: hasarg,\n                      ..} = (*optref).clone();\n \n-        let mut row = \" \".repeat(4);\n+        let mut row = StrBuf::from_owned_str(\" \".repeat(4));\n \n         // short option\n         match short_name.len() {\n@@ -700,7 +701,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> ~str {\n \n         // FIXME: #5516 should be graphemes not codepoints\n         // here we just need to indent the start of the description\n-        let rowlen = row.char_len();\n+        let rowlen = row.as_slice().char_len();\n         if rowlen < 24 {\n             for _ in range(0, 24 - rowlen) {\n                 row.push_char(' ');\n@@ -710,15 +711,17 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> ~str {\n         }\n \n         // Normalize desc to contain words separated by one space character\n-        let mut desc_normalized_whitespace = ~\"\";\n+        let mut desc_normalized_whitespace = StrBuf::new();\n         for word in desc.words() {\n             desc_normalized_whitespace.push_str(word);\n             desc_normalized_whitespace.push_char(' ');\n         }\n \n         // FIXME: #5516 should be graphemes not codepoints\n         let mut desc_rows = Vec::new();\n-        each_split_within(desc_normalized_whitespace, 54, |substr| {\n+        each_split_within(desc_normalized_whitespace.as_slice(),\n+                          54,\n+                          |substr| {\n             desc_rows.push(substr.to_owned());\n             true\n         });\n@@ -727,14 +730,14 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> ~str {\n         // wrapped description\n         row.push_str(desc_rows.connect(desc_sep));\n \n-        row\n+        row.into_owned()\n     });\n \n     format!(\"{}\\n\\nOptions:\\n{}\\n\", brief, rows.collect::<Vec<~str> >().connect(\"\\n\"))\n }\n \n fn format_option(opt: &OptGroup) -> ~str {\n-    let mut line = ~\"\";\n+    let mut line = StrBuf::new();\n \n     if opt.occur != Req {\n         line.push_char('[');\n@@ -767,15 +770,14 @@ fn format_option(opt: &OptGroup) -> ~str {\n         line.push_str(\"..\");\n     }\n \n-    line\n+    line.into_owned()\n }\n \n /// Derive a short one-line usage summary from a set of long options.\n pub fn short_usage(program_name: &str, opts: &[OptGroup]) -> ~str {\n-    let mut line = ~\"Usage: \" + program_name + \" \";\n+    let mut line = StrBuf::from_str(\"Usage: \" + program_name + \" \");\n     line.push_str(opts.iter().map(format_option).collect::<Vec<~str>>().connect(\" \"));\n-\n-    line\n+    line.into_owned()\n }\n \n "}, {"sha": "e7661b26b7645cbed36f2cbf9f67f7c6bd7719ba", "filename": "src/libglob/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibglob%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibglob%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibglob%2Flib.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -35,6 +35,7 @@ use std::cell::Cell;\n use std::{cmp, os, path};\n use std::io::fs;\n use std::path::is_sep;\n+use std::strbuf::StrBuf;\n \n /**\n  * An iterator that yields Paths from the filesystem that match a particular\n@@ -308,7 +309,7 @@ impl Pattern {\n      * match the input string and nothing else.\n      */\n     pub fn escape(s: &str) -> ~str {\n-        let mut escaped = ~\"\";\n+        let mut escaped = StrBuf::new();\n         for c in s.chars() {\n             match c {\n                 // note that ! does not need escaping because it is only special inside brackets\n@@ -322,7 +323,7 @@ impl Pattern {\n                 }\n             }\n         }\n-        escaped\n+        escaped.into_owned()\n     }\n \n     /**"}, {"sha": "8ef46239e6161f6b09ee043f92e20a62a13cfe94", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -20,6 +20,7 @@ use super::IoResult;\n use super::file;\n \n #[cfg(windows)] use std::cast;\n+#[cfg(windows)] use std::strbuf::StrBuf;\n #[cfg(not(windows))] use super::retry;\n \n /**\n@@ -395,15 +396,15 @@ fn zeroed_process_information() -> libc::types::os::arch::extra::PROCESS_INFORMA\n \n #[cfg(windows)]\n fn make_command_line(prog: &str, args: &[~str]) -> ~str {\n-    let mut cmd = ~\"\";\n+    let mut cmd = StrBuf::new();\n     append_arg(&mut cmd, prog);\n     for arg in args.iter() {\n         cmd.push_char(' ');\n         append_arg(&mut cmd, *arg);\n     }\n-    return cmd;\n+    return cmd.to_owned_str();\n \n-    fn append_arg(cmd: &mut ~str, arg: &str) {\n+    fn append_arg(cmd: &mut StrBuf, arg: &str) {\n         let quote = arg.chars().any(|c| c == ' ' || c == '\\t');\n         if quote {\n             cmd.push_char('\"');\n@@ -416,7 +417,7 @@ fn make_command_line(prog: &str, args: &[~str]) -> ~str {\n         }\n     }\n \n-    fn append_char_at(cmd: &mut ~str, arg: &str, i: uint) {\n+    fn append_char_at(cmd: &mut StrBuf, arg: &str, i: uint) {\n         match arg[i] as char {\n             '\"' => {\n                 // Escape quotes."}, {"sha": "399fc89bb19d1c1387563c3c038a49962d088261", "filename": "src/libnum/bigint.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnum%2Fbigint.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -25,7 +25,7 @@ use std::num::CheckedDiv;\n use std::num::{Bitwise, ToPrimitive, FromPrimitive};\n use std::num::{Zero, One, ToStrRadix, FromStrRadix};\n use rand::Rng;\n-use std::str;\n+use std::strbuf::StrBuf;\n use std::uint;\n use std::{i64, u64};\n \n@@ -666,13 +666,13 @@ impl ToStrRadix for BigUint {\n \n         fn fill_concat(v: &[BigDigit], radix: uint, l: uint) -> ~str {\n             if v.is_empty() { return ~\"0\" }\n-            let mut s = str::with_capacity(v.len() * l);\n+            let mut s = StrBuf::with_capacity(v.len() * l);\n             for n in v.rev_iter() {\n                 let ss = (*n as uint).to_str_radix(radix);\n                 s.push_str(\"0\".repeat(l - ss.len()));\n                 s.push_str(ss);\n             }\n-            s.trim_left_chars(&'0').to_owned()\n+            s.as_slice().trim_left_chars(&'0').to_owned()\n         }\n     }\n }"}, {"sha": "e297dd43617cf6d286de2fe62c269447ebba21b7", "filename": "src/librand/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -80,7 +80,7 @@ use std::cast;\n use std::io::IoResult;\n use std::kinds::marker;\n use std::local_data;\n-use std::str;\n+use std::strbuf::StrBuf;\n \n pub use isaac::{IsaacRng, Isaac64Rng};\n pub use os::OSRng;\n@@ -258,11 +258,11 @@ pub trait Rng {\n         static GEN_ASCII_STR_CHARSET: &'static [u8] = bytes!(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n                                                              abcdefghijklmnopqrstuvwxyz\\\n                                                              0123456789\");\n-        let mut s = str::with_capacity(len);\n+        let mut s = StrBuf::with_capacity(len);\n         for _ in range(0, len) {\n             s.push_char(self.choose(GEN_ASCII_STR_CHARSET) as char)\n         }\n-        s\n+        s.into_owned()\n     }\n \n     /// Choose an item randomly, failing if `values` is empty."}, {"sha": "4e407d52329ff1b5ac043032d0fd9e577dadd36e", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -28,11 +28,12 @@ use util::sha2::{Digest, Sha256};\n \n use std::c_str::{ToCStr, CString};\n use std::char;\n+use std::io::{fs, TempDir, Process};\n+use std::io;\n use std::os::consts::{macos, freebsd, linux, android, win32};\n use std::ptr;\n use std::str;\n-use std::io;\n-use std::io::{fs, TempDir, Process};\n+use std::strbuf::StrBuf;\n use flate;\n use serialize::hex::ToHex;\n use syntax::abi;\n@@ -546,8 +547,11 @@ fn truncated_hash_result(symbol_hasher: &mut Sha256) -> ~str {\n \n \n // This calculates STH for a symbol, as defined above\n-fn symbol_hash(tcx: &ty::ctxt, symbol_hasher: &mut Sha256,\n-               t: ty::t, link_meta: &LinkMeta) -> ~str {\n+fn symbol_hash(tcx: &ty::ctxt,\n+               symbol_hasher: &mut Sha256,\n+               t: ty::t,\n+               link_meta: &LinkMeta)\n+               -> ~str {\n     // NB: do *not* use abbrevs here as we want the symbol names\n     // to be independent of one another in the crate.\n \n@@ -557,10 +561,10 @@ fn symbol_hash(tcx: &ty::ctxt, symbol_hasher: &mut Sha256,\n     symbol_hasher.input_str(link_meta.crate_hash.as_str());\n     symbol_hasher.input_str(\"-\");\n     symbol_hasher.input_str(encoder::encoded_ty(tcx, t));\n-    let mut hash = truncated_hash_result(symbol_hasher);\n     // Prefix with 'h' so that it never blends into adjacent digits\n-    hash.unshift_char('h');\n-    hash\n+    let mut hash = StrBuf::from_str(\"h\");\n+    hash.push_str(truncated_hash_result(symbol_hasher));\n+    hash.into_owned()\n }\n \n fn get_symbol_hash(ccx: &CrateContext, t: ty::t) -> ~str {\n@@ -580,7 +584,7 @@ fn get_symbol_hash(ccx: &CrateContext, t: ty::t) -> ~str {\n // gas doesn't!\n // gas accepts the following characters in symbols: a-z, A-Z, 0-9, ., _, $\n pub fn sanitize(s: &str) -> ~str {\n-    let mut result = ~\"\";\n+    let mut result = StrBuf::new();\n     for c in s.chars() {\n         match c {\n             // Escape these with $ sequences\n@@ -605,15 +609,16 @@ pub fn sanitize(s: &str) -> ~str {\n             | '_' | '.' | '$' => result.push_char(c),\n \n             _ => {\n-                let mut tstr = ~\"\";\n+                let mut tstr = StrBuf::new();\n                 char::escape_unicode(c, |c| tstr.push_char(c));\n                 result.push_char('$');\n-                result.push_str(tstr.slice_from(1));\n+                result.push_str(tstr.as_slice().slice_from(1));\n             }\n         }\n     }\n \n     // Underscore-qualify anything that didn't start as an ident.\n+    let result = result.into_owned();\n     if result.len() > 0u &&\n         result[0] != '_' as u8 &&\n         ! char::is_XID_start(result[0] as char) {\n@@ -640,9 +645,9 @@ pub fn mangle<PI: Iterator<PathElem>>(mut path: PI,\n     // To be able to work on all platforms and get *some* reasonable output, we\n     // use C++ name-mangling.\n \n-    let mut n = ~\"_ZN\"; // _Z == Begin name-sequence, N == nested\n+    let mut n = StrBuf::from_str(\"_ZN\"); // _Z == Begin name-sequence, N == nested\n \n-    fn push(n: &mut ~str, s: &str) {\n+    fn push(n: &mut StrBuf, s: &str) {\n         let sani = sanitize(s);\n         n.push_str(format!(\"{}{}\", sani.len(), sani));\n     }\n@@ -662,7 +667,7 @@ pub fn mangle<PI: Iterator<PathElem>>(mut path: PI,\n     }\n \n     n.push_char('E'); // End name-sequence.\n-    n\n+    n.into_owned()\n }\n \n pub fn exported_name(path: PathElems, hash: &str, vers: &str) -> ~str {\n@@ -679,7 +684,7 @@ pub fn exported_name(path: PathElems, hash: &str, vers: &str) -> ~str {\n \n pub fn mangle_exported_name(ccx: &CrateContext, path: PathElems,\n                             t: ty::t, id: ast::NodeId) -> ~str {\n-    let mut hash = get_symbol_hash(ccx, t);\n+    let mut hash = StrBuf::from_owned_str(get_symbol_hash(ccx, t));\n \n     // Paths can be completely identical for different nodes,\n     // e.g. `fn foo() { { fn a() {} } { fn a() {} } }`, so we\n@@ -699,7 +704,9 @@ pub fn mangle_exported_name(ccx: &CrateContext, path: PathElems,\n     hash.push_char(EXTRA_CHARS[extra2] as char);\n     hash.push_char(EXTRA_CHARS[extra3] as char);\n \n-    exported_name(path, hash, ccx.link_meta.crateid.version_or_default())\n+    exported_name(path,\n+                  hash.as_slice(),\n+                  ccx.link_meta.crateid.version_or_default())\n }\n \n pub fn mangle_internal_name_by_type_and_seq(ccx: &CrateContext,"}, {"sha": "f0fcabdabb70a6ec7b63488233ea5229ff6b5d11", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -19,6 +19,7 @@\n use middle::ty;\n \n use std::str;\n+use std::strbuf::StrBuf;\n use std::uint;\n use syntax::abi;\n use syntax::ast;\n@@ -276,14 +277,14 @@ fn parse_opt<T>(st: &mut PState, f: |&mut PState| -> T) -> Option<T> {\n }\n \n fn parse_str(st: &mut PState, term: char) -> ~str {\n-    let mut result = ~\"\";\n+    let mut result = StrBuf::new();\n     while peek(st) != term {\n         unsafe {\n-            str::raw::push_byte(&mut result, next_byte(st));\n+            result.push_bytes([next_byte(st)])\n         }\n     }\n     next(st);\n-    return result;\n+    return result.into_owned();\n }\n \n fn parse_trait_ref(st: &mut PState, conv: conv_did) -> ty::TraitRef {"}, {"sha": "e5b87d716e0e7cc5fa6867b065f50a53e0d8428d", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -40,6 +40,7 @@ use std::cell::RefCell;\n use std::io::Seek;\n use std::io::MemWriter;\n use std::rc::Rc;\n+use std::strbuf::StrBuf;\n \n use serialize::ebml::reader;\n use serialize::ebml;\n@@ -1192,11 +1193,11 @@ impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n         }).unwrap();\n \n         fn type_string(doc: ebml::Doc) -> ~str {\n-            let mut str = ~\"\";\n+            let mut str = StrBuf::new();\n             for i in range(doc.start, doc.end) {\n                 str.push_char(doc.data[i] as char);\n             }\n-            str\n+            str.into_owned()\n         }\n     }\n "}, {"sha": "83c45dc830f115cfb58166bd2a5398c38509cb31", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -24,7 +24,8 @@ use util::ppaux::{note_and_explain_region, Repr, UserString};\n use std::cell::{Cell, RefCell};\n use collections::HashMap;\n use std::ops::{BitOr, BitAnd};\n-use std::result::{Result};\n+use std::result::Result;\n+use std::strbuf::StrBuf;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util;\n@@ -802,7 +803,7 @@ impl<'a> BorrowckCtxt<'a> {\n \n     pub fn append_loan_path_to_str(&self,\n                                    loan_path: &LoanPath,\n-                                   out: &mut ~str) {\n+                                   out: &mut StrBuf) {\n         match *loan_path {\n             LpVar(id) => {\n                 out.push_str(ty::local_var_name_str(self.tcx, id).get());\n@@ -836,7 +837,7 @@ impl<'a> BorrowckCtxt<'a> {\n \n     pub fn append_autoderefd_loan_path_to_str(&self,\n                                               loan_path: &LoanPath,\n-                                              out: &mut ~str) {\n+                                              out: &mut StrBuf) {\n         match *loan_path {\n             LpExtend(lp_base, _, LpDeref(_)) => {\n                 // For a path like `(*x).f` or `(*x)[3]`, autoderef\n@@ -852,9 +853,9 @@ impl<'a> BorrowckCtxt<'a> {\n     }\n \n     pub fn loan_path_to_str(&self, loan_path: &LoanPath) -> ~str {\n-        let mut result = ~\"\";\n+        let mut result = StrBuf::new();\n         self.append_loan_path_to_str(loan_path, &mut result);\n-        result\n+        result.into_owned()\n     }\n \n     pub fn cmt_to_str(&self, cmt: mc::cmt) -> ~str {"}, {"sha": "13e16ec9d82dce318a5f4d3ff2471305c6284268", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -18,8 +18,9 @@\n \n \n use std::io;\n-use std::uint;\n use std::slice;\n+use std::strbuf::StrBuf;\n+use std::uint;\n use syntax::ast;\n use syntax::ast_util;\n use syntax::ast_util::IdRange;\n@@ -832,7 +833,7 @@ fn mut_bits_to_str(words: &mut [uint]) -> ~str {\n }\n \n fn bits_to_str(words: &[uint]) -> ~str {\n-    let mut result = ~\"\";\n+    let mut result = StrBuf::new();\n     let mut sep = '[';\n \n     // Note: this is a little endian printout of bytes.\n@@ -847,7 +848,7 @@ fn bits_to_str(words: &[uint]) -> ~str {\n         }\n     }\n     result.push_char(']');\n-    return result;\n+    return result.into_owned();\n }\n \n fn copy_bits(in_vec: &[uint], out_vec: &mut [uint]) -> bool {"}, {"sha": "25720b7d7ca91caf365176980a3386159477f791", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -31,10 +31,11 @@ use syntax::owned_slice::OwnedSlice;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n+use collections::{HashMap, HashSet};\n use std::cell::{Cell, RefCell};\n-use std::uint;\n use std::mem::replace;\n-use collections::{HashMap, HashSet};\n+use std::strbuf::StrBuf;\n+use std::uint;\n \n // Definition mapping\n pub type DefMap = @RefCell<NodeMap<Def>>;\n@@ -2096,7 +2097,7 @@ impl<'a> Resolver<'a> {\n \n     fn idents_to_str(&mut self, idents: &[Ident]) -> ~str {\n         let mut first = true;\n-        let mut result = ~\"\";\n+        let mut result = StrBuf::new();\n         for ident in idents.iter() {\n             if first {\n                 first = false\n@@ -2105,7 +2106,7 @@ impl<'a> Resolver<'a> {\n             }\n             result.push_str(token::get_ident(*ident).get());\n         };\n-        return result;\n+        result.into_owned()\n     }\n \n     fn path_idents_to_str(&mut self, path: &Path) -> ~str {"}, {"sha": "43b74c387aee8ae3e63843b801f680388b292302", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -23,6 +23,7 @@ use middle::trans::type_of;\n use middle::trans::type_::Type;\n \n use std::c_str::ToCStr;\n+use std::strbuf::StrBuf;\n use syntax::ast;\n \n // Take an inline assembly expression and splat it out via LLVM\n@@ -62,27 +63,30 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n     // no failure occurred preparing operands, no need to cleanup\n     fcx.pop_custom_cleanup_scope(temp_scope);\n \n-    let mut constraints = constraints.iter()\n-                                     .map(|s| s.get().to_str())\n-                                     .collect::<Vec<~str>>()\n-                                     .connect(\",\");\n+    let mut constraints =\n+        StrBuf::from_str(constraints.iter()\n+                                    .map(|s| s.get().to_str())\n+                                    .collect::<Vec<~str>>()\n+                                    .connect(\",\"));\n \n-    let mut clobbers = getClobbers();\n+    let mut clobbers = StrBuf::from_str(getClobbers());\n     if !ia.clobbers.get().is_empty() && !clobbers.is_empty() {\n-        clobbers = format!(\"{},{}\", ia.clobbers.get(), clobbers);\n+        clobbers = StrBuf::from_owned_str(format!(\"{},{}\",\n+                                                  ia.clobbers.get(),\n+                                                  clobbers));\n     } else {\n         clobbers.push_str(ia.clobbers.get());\n     }\n \n     // Add the clobbers to our constraints list\n     if clobbers.len() != 0 && constraints.len() != 0 {\n         constraints.push_char(',');\n-        constraints.push_str(clobbers);\n+        constraints.push_str(clobbers.as_slice());\n     } else {\n-        constraints.push_str(clobbers);\n+        constraints.push_str(clobbers.as_slice());\n     }\n \n-    debug!(\"Asm Constraints: {:?}\", constraints);\n+    debug!(\"Asm Constraints: {:?}\", constraints.as_slice());\n \n     let num_outputs = outputs.len();\n \n@@ -101,7 +105,7 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n     };\n \n     let r = ia.asm.get().with_c_str(|a| {\n-        constraints.with_c_str(|c| {\n+        constraints.as_slice().with_c_str(|c| {\n             InlineAsmCall(bcx,\n                           a,\n                           c,"}, {"sha": "7d99ac3e7f38f2349e9201b51a0a20de4c80439f", "filename": "src/librustc/middle/trans/builder.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuilder.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -20,8 +20,8 @@ use middle::trans::common::*;\n use middle::trans::machine::llalign_of_pref;\n use middle::trans::type_::Type;\n use collections::HashMap;\n-use std::vec::Vec;\n use libc::{c_uint, c_ulonglong, c_char};\n+use std::strbuf::StrBuf;\n use syntax::codemap::Span;\n \n pub struct Builder<'a> {\n@@ -69,7 +69,7 @@ impl<'a> Builder<'a> {\n                 // Pass 2: concat strings for each elt, skipping\n                 // forwards over any cycles by advancing to rightmost\n                 // occurrence of each element in path.\n-                let mut s = ~\".\";\n+                let mut s = StrBuf::from_str(\".\");\n                 i = 0u;\n                 while i < len {\n                     i = *mm.get(&v[i]);\n@@ -81,7 +81,8 @@ impl<'a> Builder<'a> {\n                 s.push_char('/');\n                 s.push_str(category);\n \n-                let n = match h.find(&s) {\n+                let s = s.into_owned();\n+                let n = match h.find_equiv(&s) {\n                     Some(&n) => n,\n                     _ => 0u\n                 };"}, {"sha": "6719bba2492aef30b8833f5fcae75629ef734ed3", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -147,8 +147,9 @@ use collections::HashMap;\n use collections::HashSet;\n use libc::{c_uint, c_ulonglong, c_longlong};\n use std::ptr;\n-use std::sync::atomics;\n use std::slice;\n+use std::strbuf::StrBuf;\n+use std::sync::atomics;\n use syntax::codemap::{Span, Pos};\n use syntax::{abi, ast, codemap, ast_util, ast_map};\n use syntax::owned_slice::OwnedSlice;\n@@ -678,7 +679,7 @@ pub fn create_function_debug_context(cx: &CrateContext,\n     };\n \n     // get_template_parameters() will append a `<...>` clause to the function name if necessary.\n-    let mut function_name = token::get_ident(ident).get().to_str();\n+    let mut function_name = StrBuf::from_str(token::get_ident(ident).get());\n     let template_parameters = get_template_parameters(cx,\n                                                       generics,\n                                                       param_substs,\n@@ -690,19 +691,20 @@ pub fn create_function_debug_context(cx: &CrateContext,\n     // ast_map, or construct a path using the enclosing function).\n     let (linkage_name, containing_scope) = if has_path {\n         let namespace_node = namespace_for_item(cx, ast_util::local_def(fn_ast_id));\n-        let linkage_name = namespace_node.mangled_name_of_contained_item(function_name);\n+        let linkage_name = namespace_node.mangled_name_of_contained_item(\n+            function_name.as_slice());\n         let containing_scope = namespace_node.scope;\n         (linkage_name, containing_scope)\n     } else {\n-        (function_name.clone(), file_metadata)\n+        (function_name.as_slice().to_owned(), file_metadata)\n     };\n \n     // Clang sets this parameter to the opening brace of the function's block, so let's do this too.\n     let scope_line = span_start(cx, top_level_block.span).line;\n \n     let is_local_to_unit = is_node_local_to_unit(cx, fn_ast_id);\n \n-    let fn_metadata = function_name.with_c_str(|function_name| {\n+    let fn_metadata = function_name.as_slice().with_c_str(|function_name| {\n                           linkage_name.with_c_str(|linkage_name| {\n             unsafe {\n                 llvm::LLVMDIBuilderCreateFunction(\n@@ -803,8 +805,8 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                                generics: &ast::Generics,\n                                param_substs: Option<@param_substs>,\n                                file_metadata: DIFile,\n-                               name_to_append_suffix_to: &mut ~str)\n-                            -> DIArray {\n+                               name_to_append_suffix_to: &mut StrBuf)\n+                               -> DIArray {\n         let self_type = match param_substs {\n             Some(param_substs) => param_substs.self_ty,\n             _ => None\n@@ -2779,7 +2781,7 @@ struct NamespaceTreeNode {\n \n impl NamespaceTreeNode {\n     fn mangled_name_of_contained_item(&self, item_name: &str) -> ~str {\n-        fn fill_nested(node: &NamespaceTreeNode, output: &mut ~str) {\n+        fn fill_nested(node: &NamespaceTreeNode, output: &mut StrBuf) {\n             match node.parent {\n                 Some(parent) => fill_nested(parent, output),\n                 None => {}\n@@ -2789,12 +2791,12 @@ impl NamespaceTreeNode {\n             output.push_str(string.get());\n         }\n \n-        let mut name = ~\"_ZN\";\n+        let mut name = StrBuf::from_str(\"_ZN\");\n         fill_nested(self, &mut name);\n         name.push_str(format!(\"{}\", item_name.len()));\n         name.push_str(item_name);\n         name.push_char('E');\n-        name\n+        name.into_owned()\n     }\n }\n "}, {"sha": "4fd68e622bcd9f0207e601cbc6df2831e1012657", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -76,6 +76,7 @@ use middle::typeck::infer::region_inference::ProcessedErrors;\n use middle::typeck::infer::region_inference::SameRegions;\n use std::cell::{Cell, RefCell};\n use std::char::from_u32;\n+use std::strbuf::StrBuf;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util;\n@@ -1361,13 +1362,13 @@ impl LifeGiver {\n \n         // 0 .. 25 generates a .. z, 26 .. 51 generates aa .. zz, and so on\n         fn num_to_str(counter: uint) -> ~str {\n-            let mut s = ~\"\";\n+            let mut s = StrBuf::new();\n             let (n, r) = (counter/26 + 1, counter % 26);\n             let letter: char = from_u32((r+97) as u32).unwrap();\n             for _ in range(0, n) {\n                 s.push_char(letter);\n             }\n-            return s;\n+            s.into_owned()\n         }\n     }\n "}, {"sha": "fec86b0bbe8e1a90ff86ecd38baa1c655693177a", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -23,6 +23,7 @@ use middle::ty::{ty_uniq, ty_trait, ty_int, ty_uint, ty_infer};\n use middle::ty;\n use middle::typeck;\n \n+use std::strbuf::StrBuf;\n use syntax::abi;\n use syntax::ast_map;\n use syntax::codemap::{Span, Pos};\n@@ -258,9 +259,9 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n                       sig: &ty::FnSig)\n                       -> ~str {\n         let mut s = if abi == abi::Rust {\n-            ~\"\"\n+            StrBuf::new()\n         } else {\n-            format!(\"extern {} \", abi.to_str())\n+            StrBuf::from_owned_str(format!(\"extern {} \", abi.to_str()))\n         };\n \n         match purity {\n@@ -283,17 +284,18 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n \n         push_sig_to_str(cx, &mut s, '(', ')', sig);\n \n-        return s;\n+        s.into_owned()\n     }\n+\n     fn closure_to_str(cx: &ctxt, cty: &ty::ClosureTy) -> ~str {\n         let is_proc =\n             (cty.sigil, cty.onceness) == (ast::OwnedSigil, ast::Once);\n         let is_borrowed_closure = cty.sigil == ast::BorrowedSigil;\n \n         let mut s = if is_proc || is_borrowed_closure {\n-            ~\"\"\n+            StrBuf::new()\n         } else {\n-            cty.sigil.to_str()\n+            StrBuf::from_owned_str(cty.sigil.to_str())\n         };\n \n         match (cty.sigil, cty.region) {\n@@ -349,10 +351,11 @@ pub fn ty_to_str(cx: &ctxt, typ: t) -> ~str {\n             }\n         }\n \n-        return s;\n+        s.into_owned()\n     }\n+\n     fn push_sig_to_str(cx: &ctxt,\n-                       s: &mut ~str,\n+                       s: &mut StrBuf,\n                        bra: char,\n                        ket: char,\n                        sig: &ty::FnSig) {"}, {"sha": "6a189acab3a12f9cbd6da76780a1e2ebd2cbb6d1", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -24,12 +24,13 @@ use rustc::metadata::cstore;\n use rustc::metadata::csearch;\n use rustc::metadata::decoder;\n \n+use std::local_data;\n+use std::strbuf::StrBuf;\n use std;\n \n use core;\n use doctree;\n use visit_ast;\n-use std::local_data;\n \n pub trait Clean<T> {\n     fn clean(&self) -> T;\n@@ -917,7 +918,7 @@ impl Clean<PathSegment> for ast::PathSegment {\n fn path_to_str(p: &ast::Path) -> ~str {\n     use syntax::parse::token;\n \n-    let mut s = ~\"\";\n+    let mut s = StrBuf::new();\n     let mut first = true;\n     for i in p.segments.iter().map(|x| token::get_ident(x.identifier)) {\n         if !first || p.global {\n@@ -927,7 +928,7 @@ fn path_to_str(p: &ast::Path) -> ~str {\n         }\n         s.push_str(i.get());\n     }\n-    s\n+    s.into_owned()\n }\n \n impl Clean<~str> for ast::Ident {"}, {"sha": "a762ccd97c26a4d18c4fe3ad54ae218d1a965f0b", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -16,8 +16,9 @@\n //! them in the future to instead emit any format desired.\n \n use std::fmt;\n-use std::local_data;\n use std::io;\n+use std::local_data;\n+use std::strbuf::StrBuf;\n \n use syntax::ast;\n use syntax::ast_util;\n@@ -185,7 +186,7 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n     -> fmt::Result\n {\n     // The generics will get written to both the title and link\n-    let mut generics = ~\"\";\n+    let mut generics = StrBuf::new();\n     let last = path.segments.last().unwrap();\n     if last.lifetimes.len() > 0 || last.types.len() > 0 {\n         let mut counter = 0;\n@@ -219,7 +220,7 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n                 let amt = path.segments.len() - 1;\n                 match rel_root {\n                     Some(root) => {\n-                        let mut root = root;\n+                        let mut root = StrBuf::from_str(root);\n                         for seg in path.segments.slice_to(amt).iter() {\n                             if \"super\" == seg.name || \"self\" == seg.name {\n                                 try!(write!(w, \"{}::\", seg.name));\n@@ -228,7 +229,7 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n                                 root.push_str(\"/\");\n                                 try!(write!(w, \"<a class='mod'\n                                                     href='{}index.html'>{}</a>::\",\n-                                              root,\n+                                              root.as_slice(),\n                                               seg.name));\n                             }\n                         }\n@@ -244,7 +245,7 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n             match info(&**cache) {\n                 // This is a documented path, link to it!\n                 Some((ref fqp, shortty)) if abs_root.is_some() => {\n-                    let mut url = abs_root.unwrap();\n+                    let mut url = StrBuf::from_str(abs_root.unwrap());\n                     let to_link = fqp.slice_to(fqp.len() - 1);\n                     for component in to_link.iter() {\n                         url.push_str(*component);\n@@ -271,7 +272,7 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n                     try!(write!(w, \"{}\", last.name));\n                 }\n             }\n-            try!(write!(w, \"{}\", generics));\n+            try!(write!(w, \"{}\", generics.as_slice()));\n             Ok(())\n         })\n     })\n@@ -430,7 +431,7 @@ impl fmt::Show for clean::FnDecl {\n impl<'a> fmt::Show for Method<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let Method(selfty, d) = *self;\n-        let mut args = ~\"\";\n+        let mut args = StrBuf::new();\n         match *selfty {\n             clean::SelfStatic => {},\n             clean::SelfValue => args.push_str(\"self\"),\n@@ -455,7 +456,8 @@ impl<'a> fmt::Show for Method<'a> {\n             }\n             args.push_str(format!(\"{}\", input.type_));\n         }\n-        write!(f.buf, \"({args}){arrow, select, yes{ -&gt; {ret}} other{}}\",\n+        write!(f.buf,\n+               \"({args}){arrow, select, yes{ -&gt; {ret}} other{}}\",\n                args = args,\n                arrow = match d.output { clean::Unit => \"no\", _ => \"yes\" },\n                ret = d.output)"}, {"sha": "0fde87af9002078f780dac52b4f74eacb36d6dc2", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -33,13 +33,14 @@\n //! These tasks are not parallelized (they haven't been a bottleneck yet), and\n //! both occur before the crate is rendered.\n \n+use collections::{HashMap, HashSet};\n use std::fmt;\n-use std::local_data;\n-use std::io;\n use std::io::{fs, File, BufferedWriter, MemWriter, BufferedReader};\n-use std::str;\n+use std::io;\n+use std::local_data;\n use std::slice;\n-use collections::{HashMap, HashSet};\n+use std::str;\n+use std::strbuf::StrBuf;\n \n use sync::Arc;\n use serialize::json::ToJson;\n@@ -71,7 +72,7 @@ pub struct Context {\n     pub current: Vec<~str> ,\n     /// String representation of how to get back to the root path of the 'doc/'\n     /// folder in terms of a relative URL.\n-    pub root_path: ~str,\n+    pub root_path: StrBuf,\n     /// The current destination folder of where HTML artifacts should be placed.\n     /// This changes as the context descends into the module hierarchy.\n     pub dst: Path,\n@@ -209,7 +210,7 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n     let mut cx = Context {\n         dst: dst,\n         current: Vec::new(),\n-        root_path: ~\"\",\n+        root_path: StrBuf::new(),\n         sidebar: HashMap::new(),\n         layout: layout::Layout {\n             logo: ~\"\",\n@@ -498,7 +499,7 @@ impl<'a> SourceCollector<'a> {\n \n         // Create the intermediate directories\n         let mut cur = self.dst.clone();\n-        let mut root_path = ~\"../../\";\n+        let mut root_path = StrBuf::from_str(\"../../\");\n         clean_srcpath(p.dirname(), |component| {\n             cur.push(component);\n             mkdir(&cur).unwrap();\n@@ -512,7 +513,7 @@ impl<'a> SourceCollector<'a> {\n         let page = layout::Page {\n             title: title,\n             ty: \"source\",\n-            root_path: root_path,\n+            root_path: root_path.as_slice(),\n         };\n         try!(layout::render(&mut w as &mut Writer, &self.cx.layout,\n                               &page, &(\"\"), &Source(contents)));\n@@ -813,16 +814,18 @@ impl Context {\n             // does make formatting *a lot* nicer.\n             local_data::set(current_location_key, cx.current.clone());\n \n-            let mut title = cx.current.connect(\"::\");\n+            let mut title = StrBuf::from_str(cx.current.connect(\"::\"));\n             if pushname {\n-                if title.len() > 0 { title.push_str(\"::\"); }\n+                if title.len() > 0 {\n+                    title.push_str(\"::\");\n+                }\n                 title.push_str(*it.name.get_ref());\n             }\n             title.push_str(\" - Rust\");\n             let page = layout::Page {\n                 ty: shortty(it),\n-                root_path: cx.root_path,\n-                title: title,\n+                root_path: cx.root_path.as_slice(),\n+                title: title.as_slice(),\n             };\n \n             markdown::reset_headers();\n@@ -955,7 +958,7 @@ impl<'a> fmt::Show for Item<'a> {\n         let cur = self.cx.current.as_slice();\n         let amt = if self.ismodule() { cur.len() - 1 } else { cur.len() };\n         for (i, component) in cur.iter().enumerate().take(amt) {\n-            let mut trail = ~\"\";\n+            let mut trail = StrBuf::new();\n             for _ in range(0, cur.len() - i - 1) {\n                 trail.push_str(\"../\");\n             }\n@@ -989,10 +992,10 @@ fn item_path(item: &clean::Item) -> ~str {\n }\n \n fn full_path(cx: &Context, item: &clean::Item) -> ~str {\n-    let mut s = cx.current.connect(\"::\");\n+    let mut s = StrBuf::from_str(cx.current.connect(\"::\"));\n     s.push_str(\"::\");\n     s.push_str(item.name.get_ref().as_slice());\n-    return s;\n+    return s.into_owned();\n }\n \n fn blank<'a>(s: Option<&'a str>) -> &'a str {\n@@ -1190,7 +1193,7 @@ fn item_function(w: &mut Writer, it: &clean::Item,\n \n fn item_trait(w: &mut Writer, it: &clean::Item,\n               t: &clean::Trait) -> fmt::Result {\n-    let mut parents = ~\"\";\n+    let mut parents = StrBuf::new();\n     if t.parents.len() > 0 {\n         parents.push_str(\": \");\n         for (i, p) in t.parents.iter().enumerate() {\n@@ -1664,7 +1667,9 @@ impl<'a> fmt::Show for Sidebar<'a> {\n                 try!(write!(fmt.buf, \"&\\\\#8203;::\"));\n             }\n             try!(write!(fmt.buf, \"<a href='{}index.html'>{}</a>\",\n-                          cx.root_path.slice_to((cx.current.len() - i - 1) * 3),\n+                          cx.root_path\n+                            .as_slice()\n+                            .slice_to((cx.current.len() - i - 1) * 3),\n                           *name));\n         }\n         try!(write!(fmt.buf, \"</p>\"));"}, {"sha": "128cabe16deb299dd93080231a3bf0f61ddc36f9", "filename": "src/librustdoc/html/toc.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustdoc%2Fhtml%2Ftoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftoc.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -11,6 +11,7 @@\n //! Table-of-contents creation.\n \n use std::fmt;\n+use std::strbuf::StrBuf;\n \n /// A (recursive) table of contents\n #[deriving(Eq)]\n@@ -136,11 +137,11 @@ impl TocBuilder {\n         {\n             let (toc_level, toc) = match self.chain.last() {\n                 None => {\n-                    sec_number = ~\"\";\n+                    sec_number = StrBuf::new();\n                     (0, &self.top_level)\n                 }\n                 Some(entry) => {\n-                    sec_number = entry.sec_number.clone();\n+                    sec_number = StrBuf::from_str(entry.sec_number.clone());\n                     sec_number.push_str(\".\");\n                     (entry.level, &entry.children)\n                 }\n@@ -156,12 +157,12 @@ impl TocBuilder {\n         }\n \n         self.chain.push(TocEntry {\n-                level: level,\n-                name: name,\n-                sec_number: sec_number,\n-                id: id,\n-                children: Toc { entries: Vec::new() }\n-            });\n+            level: level,\n+            name: name,\n+            sec_number: sec_number.into_owned(),\n+            id: id,\n+            children: Toc { entries: Vec::new() }\n+        });\n \n         // get the thing we just pushed, so we can borrow the string\n         // out of it with the right lifetime"}, {"sha": "983478a4de2907a4017023f960688acdd08fd290", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::{str, io};\n-\n use collections::HashSet;\n+use std::{str, io};\n+use std::strbuf::StrBuf;\n \n use getopts;\n use testing;\n@@ -62,12 +62,12 @@ fn extract_leading_metadata<'a>(s: &'a str) -> (Vec<&'a str>, &'a str) {\n }\n \n fn load_external_files(names: &[~str]) -> Option<~str> {\n-    let mut out = ~\"\";\n+    let mut out = StrBuf::new();\n     for name in names.iter() {\n         out.push_str(load_or_return!(name.as_slice(), None, None));\n         out.push_char('\\n');\n     }\n-    Some(out)\n+    Some(out.into_owned())\n }\n \n /// Render `input` (e.g. \"foo.md\") into an HTML file in `output`\n@@ -77,7 +77,7 @@ pub fn render(input: &str, mut output: Path, matches: &getopts::Matches) -> int\n     output.push(input_p.filestem().unwrap());\n     output.set_extension(\"html\");\n \n-    let mut css = ~\"\";\n+    let mut css = StrBuf::new();\n     for name in matches.opt_strs(\"markdown-css\").iter() {\n         let s = format!(\"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{}\\\">\\n\", name);\n         css.push_str(s)"}, {"sha": "3f45b1a7e699edde842547358671d99e1c04420c", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -8,12 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cmp;\n use collections::HashSet;\n+use rustc::util::nodemap::NodeSet;\n+use std::cmp;\n use std::local_data;\n+use std::strbuf::StrBuf;\n use std::uint;\n use syntax::ast;\n-use rustc::util::nodemap::NodeSet;\n \n use clean;\n use clean::Item;\n@@ -235,7 +236,7 @@ pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n     struct Collapser;\n     impl fold::DocFolder for Collapser {\n         fn fold_item(&mut self, i: Item) -> Option<Item> {\n-            let mut docstr = ~\"\";\n+            let mut docstr = StrBuf::new();\n             let mut i = i;\n             for attr in i.attrs.iter() {\n                 match *attr {\n@@ -250,8 +251,8 @@ pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n                 &clean::NameValue(ref x, _) if \"doc\" == *x => false,\n                 _ => true\n             }).map(|x| x.clone()).collect();\n-            if \"\" != docstr {\n-                a.push(clean::NameValue(~\"doc\", docstr));\n+            if docstr.len() > 0 {\n+                a.push(clean::NameValue(~\"doc\", docstr.into_owned()));\n             }\n             i.attrs = a;\n             self.fold_item_recur(i)"}, {"sha": "234796c5c3f21b40d0e7770d459106335d1b70a2", "filename": "src/librustdoc/plugins.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustdoc%2Fplugins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustdoc%2Fplugins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fplugins.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -10,8 +10,9 @@\n \n use clean;\n \n-use serialize::json;\n use dl = std::unstable::dynamic_lib;\n+use serialize::json;\n+use std::strbuf::StrBuf;\n \n pub type PluginJson = Option<(~str, json::Json)>;\n pub type PluginResult = (clean::Crate, PluginJson);\n@@ -70,21 +71,23 @@ impl PluginManager {\n }\n \n #[cfg(target_os=\"win32\")]\n-fn libname(mut n: ~str) -> ~str {\n+fn libname(n: ~str) -> ~str {\n+    let mut n = StrBuf::from_owned_str(n);\n     n.push_str(\".dll\");\n-    n\n+    n.into_owned()\n }\n \n #[cfg(target_os=\"macos\")]\n-fn libname(mut n: ~str) -> ~str {\n+fn libname(n: ~str) -> ~str {\n+    let mut n = StrBuf::from_owned_str(n);\n     n.push_str(\".dylib\");\n-    n\n+    n.into_owned()\n }\n \n #[cfg(not(target_os=\"win32\"), not(target_os=\"macos\"))]\n fn libname(n: ~str) -> ~str {\n-    let mut i = ~\"lib\";\n+    let mut i = StrBuf::from_str(\"lib\");\n     i.push_str(n);\n     i.push_str(\".so\");\n-    i\n+    i.into_owned()\n }"}, {"sha": "ad49f41f64afcbb9785cd6337dd8fbec4ca60df0", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -15,6 +15,7 @@ use std::io::{Process, TempDir};\n use std::local_data;\n use std::os;\n use std::str;\n+use std::strbuf::StrBuf;\n \n use collections::HashSet;\n use testing;\n@@ -167,10 +168,10 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n }\n \n fn maketest(s: &str, cratename: &str, loose_feature_gating: bool) -> ~str {\n-    let mut prog = ~r\"\n-#![deny(warnings)]\n-#![allow(unused_variable, dead_assignment, unused_mut, attribute_usage, dead_code)]\n-\";\n+    let mut prog = StrBuf::from_str(r\"\n+#![deny(warnings)];\n+#![allow(unused_variable, dead_assignment, unused_mut, attribute_usage, dead_code)];\n+\");\n \n     if loose_feature_gating {\n         // FIXME #12773: avoid inserting these when the tutorial & manual\n@@ -191,7 +192,7 @@ fn maketest(s: &str, cratename: &str, loose_feature_gating: bool) -> ~str {\n         prog.push_str(\"\\n}\");\n     }\n \n-    return prog;\n+    return prog.into_owned();\n }\n \n pub struct Collector {"}, {"sha": "23d437b0594c833e10f9b8719dd5f7cdd6a8b62a", "filename": "src/libsemver/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibsemver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibsemver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsemver%2Flib.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -42,6 +42,7 @@ use std::cmp;\n use std::fmt;\n use std::fmt::Show;\n use std::option::{Option, Some, None};\n+use std::strbuf::StrBuf;\n \n /// An identifier in the pre-release or build metadata. If the identifier can\n /// be parsed as a decimal value, it will be represented with `Numeric`.\n@@ -158,7 +159,7 @@ impl cmp::Ord for Version {\n \n fn take_nonempty_prefix<T:Iterator<char>>(rdr: &mut T, pred: |char| -> bool)\n                         -> (~str, Option<char>) {\n-    let mut buf = ~\"\";\n+    let mut buf = StrBuf::new();\n     let mut ch = rdr.next();\n     loop {\n         match ch {\n@@ -170,7 +171,7 @@ fn take_nonempty_prefix<T:Iterator<char>>(rdr: &mut T, pred: |char| -> bool)\n             }\n         }\n     }\n-    (buf, ch)\n+    (buf.into_owned(), ch)\n }\n \n fn take_num<T: Iterator<char>>(rdr: &mut T) -> Option<(uint, Option<char>)> {"}, {"sha": "6c980f2f834a536457c602b0df256bc4a2990f66", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -231,14 +231,15 @@ fn main() {\n \n */\n \n+use collections::HashMap;\n use std::char;\n use std::f64;\n-use collections::HashMap;\n-use std::io;\n+use std::fmt;\n use std::io::MemWriter;\n+use std::io;\n use std::num;\n use std::str;\n-use std::fmt;\n+use std::strbuf::StrBuf;\n \n use Encodable;\n use collections::TreeMap;\n@@ -271,7 +272,7 @@ pub type EncodeResult = io::IoResult<()>;\n pub type DecodeResult<T> = Result<T, Error>;\n \n fn escape_str(s: &str) -> ~str {\n-    let mut escaped = ~\"\\\"\";\n+    let mut escaped = StrBuf::from_str(\"\\\"\");\n     for c in s.chars() {\n         match c {\n           '\"' => escaped.push_str(\"\\\\\\\"\"),\n@@ -284,16 +285,16 @@ fn escape_str(s: &str) -> ~str {\n           _ => escaped.push_char(c),\n         }\n     };\n-\n     escaped.push_char('\"');\n-\n-    escaped\n+    escaped.into_owned()\n }\n \n fn spaces(n: uint) -> ~str {\n-    let mut ss = ~\"\";\n-    for _ in range(0, n) { ss.push_str(\" \"); }\n-    return ss;\n+    let mut ss = StrBuf::new();\n+    for _ in range(0, n) {\n+        ss.push_str(\" \");\n+    }\n+    return ss.into_owned();\n }\n \n /// A structure for implementing serialization to JSON.\n@@ -1130,7 +1131,7 @@ impl<T : Iterator<char>> Parser<T> {\n \n     fn parse_str(&mut self) -> DecodeResult<~str> {\n         let mut escape = false;\n-        let mut res = ~\"\";\n+        let mut res = StrBuf::new();\n \n         loop {\n             self.bump();\n@@ -1184,7 +1185,10 @@ impl<T : Iterator<char>> Parser<T> {\n                 escape = true;\n             } else {\n                 match self.ch {\n-                    Some('\"') => { self.bump(); return Ok(res); },\n+                    Some('\"') => {\n+                        self.bump();\n+                        return Ok(res.into_owned());\n+                    },\n                     Some(c) => res.push_char(c),\n                     None => unreachable!()\n                 }"}, {"sha": "702dbcca8be390b87eb1a882d9f66d57e4815dab", "filename": "src/libstd/char.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibstd%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibstd%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fchar.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -30,7 +30,8 @@ use iter::{Iterator, range_step};\n use str::StrSlice;\n use unicode::{derived_property, property, general_category, decompose, conversions};\n \n-#[cfg(test)] use str::OwnedStr;\n+#[cfg(test)] use str::Str;\n+#[cfg(test)] use strbuf::StrBuf;\n \n #[cfg(not(test))] use cmp::{Eq, Ord};\n #[cfg(not(test))] use default::Default;\n@@ -747,9 +748,9 @@ fn test_is_digit() {\n #[test]\n fn test_escape_default() {\n     fn string(c: char) -> ~str {\n-        let mut result = ~\"\";\n+        let mut result = StrBuf::new();\n         escape_default(c, |c| { result.push_char(c); });\n-        return result;\n+        return result.into_owned();\n     }\n     assert_eq!(string('\\n'), ~\"\\\\n\");\n     assert_eq!(string('\\r'), ~\"\\\\r\");\n@@ -769,9 +770,9 @@ fn test_escape_default() {\n #[test]\n fn test_escape_unicode() {\n     fn string(c: char) -> ~str {\n-        let mut result = ~\"\";\n+        let mut result = StrBuf::new();\n         escape_unicode(c, |c| { result.push_char(c); });\n-        return result;\n+        return result.into_owned();\n     }\n     assert_eq!(string('\\x00'), ~\"\\\\x00\");\n     assert_eq!(string('\\n'), ~\"\\\\x0a\");"}, {"sha": "69b35df50e48bfd69c9d8d8b4500c5194ff43e55", "filename": "src/libstd/hash/sip.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibstd%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibstd%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash%2Fsip.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -292,6 +292,7 @@ mod tests {\n     use num::ToStrRadix;\n     use option::{Some, None};\n     use str::{Str, OwnedStr};\n+    use strbuf::StrBuf;\n     use slice::{Vector, ImmutableVector, OwnedVector};\n     use self::test::BenchHarness;\n \n@@ -387,11 +388,11 @@ mod tests {\n         let mut state_full = SipState::new_with_keys(k0, k1);\n \n         fn to_hex_str(r: &[u8, ..8]) -> ~str {\n-            let mut s = ~\"\";\n+            let mut s = StrBuf::new();\n             for b in r.iter() {\n                 s.push_str((*b as uint).to_str_radix(16u));\n             }\n-            s\n+            s.into_owned()\n         }\n \n         fn result_bytes(h: u64) -> ~[u8] {\n@@ -408,11 +409,11 @@ mod tests {\n \n         fn result_str(h: u64) -> ~str {\n             let r = result_bytes(h);\n-            let mut s = ~\"\";\n+            let mut s = StrBuf::new();\n             for b in r.iter() {\n                 s.push_str((*b as uint).to_str_radix(16u));\n             }\n-            s\n+            s.into_owned()\n         }\n \n         while t < 64 {"}, {"sha": "9325a0ad11266740fb1fcdda433741a5e489f7b8", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -128,6 +128,7 @@ pub mod tuple;\n pub mod slice;\n pub mod vec;\n pub mod str;\n+pub mod strbuf;\n \n pub mod ascii;\n "}, {"sha": "57dae68b8427b15865f9311a3f9caea47421f68e", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -20,9 +20,10 @@ use from_str::FromStr;\n use io::Writer;\n use iter::{AdditiveIterator, DoubleEndedIterator, Extendable, Rev, Iterator, Map};\n use option::{Option, Some, None};\n-use str;\n-use str::{CharSplits, OwnedStr, Str, StrVector, StrSlice};\n use slice::{Vector, OwnedVector, ImmutableVector};\n+use str::{CharSplits, OwnedStr, Str, StrVector, StrSlice};\n+use str;\n+use strbuf::StrBuf;\n use super::{contains_nul, BytesContainer, GenericPath, GenericPathUnsafe};\n \n /// Iterator that yields successive components of a Path as &str\n@@ -175,7 +176,7 @@ impl GenericPathUnsafe for Path {\n         let filename = filename.container_as_str().unwrap();\n         match self.sepidx_or_prefix_len() {\n             None if \"..\" == self.repr => {\n-                let mut s = str::with_capacity(3 + filename.len());\n+                let mut s = StrBuf::with_capacity(3 + filename.len());\n                 s.push_str(\"..\");\n                 s.push_char(SEP);\n                 s.push_str(filename);\n@@ -185,20 +186,20 @@ impl GenericPathUnsafe for Path {\n                 self.update_normalized(filename);\n             }\n             Some((_,idxa,end)) if self.repr.slice(idxa,end) == \"..\" => {\n-                let mut s = str::with_capacity(end + 1 + filename.len());\n+                let mut s = StrBuf::with_capacity(end + 1 + filename.len());\n                 s.push_str(self.repr.slice_to(end));\n                 s.push_char(SEP);\n                 s.push_str(filename);\n                 self.update_normalized(s);\n             }\n             Some((idxb,idxa,_)) if self.prefix == Some(DiskPrefix) && idxa == self.prefix_len() => {\n-                let mut s = str::with_capacity(idxb + filename.len());\n+                let mut s = StrBuf::with_capacity(idxb + filename.len());\n                 s.push_str(self.repr.slice_to(idxb));\n                 s.push_str(filename);\n                 self.update_normalized(s);\n             }\n             Some((idxb,_,_)) => {\n-                let mut s = str::with_capacity(idxb + 1 + filename.len());\n+                let mut s = StrBuf::with_capacity(idxb + 1 + filename.len());\n                 s.push_str(self.repr.slice_to(idxb));\n                 s.push_char(SEP);\n                 s.push_str(filename);\n@@ -252,7 +253,7 @@ impl GenericPathUnsafe for Path {\n             let path_ = if is_verbatim(me) { Path::normalize__(path, None) }\n                         else { None };\n             let pathlen = path_.as_ref().map_or(path.len(), |p| p.len());\n-            let mut s = str::with_capacity(me.repr.len() + 1 + pathlen);\n+            let mut s = StrBuf::with_capacity(me.repr.len() + 1 + pathlen);\n             s.push_str(me.repr);\n             let plen = me.prefix_len();\n             // if me is \"C:\" we don't want to add a path separator\n@@ -699,9 +700,9 @@ impl Path {\n             match prefix {\n                 Some(VerbatimUNCPrefix(x, 0)) if s.len() == 8 + x => {\n                     // the server component has no trailing '\\'\n-                    let mut s = s.into_owned();\n+                    let mut s = StrBuf::from_owned_str(s.into_owned());\n                     s.push_char(SEP);\n-                    Some(s)\n+                    Some(s.into_owned())\n                 }\n                 _ => None\n             }\n@@ -764,7 +765,7 @@ impl Path {\n                         let n = prefix_.len() +\n                                 if is_abs { comps.len() } else { comps.len() - 1} +\n                                 comps.iter().map(|v| v.len()).sum();\n-                        let mut s = str::with_capacity(n);\n+                        let mut s = StrBuf::with_capacity(n);\n                         match prefix {\n                             Some(DiskPrefix) => {\n                                 s.push_char(prefix_[0].to_ascii().to_upper().to_char());\n@@ -795,7 +796,7 @@ impl Path {\n                             s.push_char(SEP);\n                             s.push_str(comp);\n                         }\n-                        Some(s)\n+                        Some(s.into_owned())\n                     }\n                 }\n             }"}, {"sha": "b7bcbefa46810b36d6156e4b74549d48f25506d4", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -59,6 +59,7 @@ pub use slice::{ImmutableEqVector, ImmutableTotalOrdVector, ImmutableCloneableVe\n pub use slice::{OwnedVector, OwnedCloneableVector, OwnedEqVector};\n pub use slice::{MutableVector, MutableTotalOrdVector};\n pub use slice::{Vector, VectorVector, CloneableVector, ImmutableVector};\n+pub use strbuf::StrBuf;\n pub use vec::Vec;\n \n // Reexported runtime types"}, {"sha": "525988c698ffd8b226ee864c4fa07d2a60221b84", "filename": "src/libstd/str.rs", "status": "modified", "additions": 82, "deletions": 477, "changes": 559, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -60,13 +60,6 @@ to that string. With these guarantees, strings can easily transition between\n being mutable/immutable with the same benefits of having mutable strings in\n other languages.\n \n-```rust\n-let mut buf = ~\"testing\";\n-buf.push_char(' ');\n-buf.push_str(\"123\");\n-assert_eq!(buf, ~\"testing 123\");\n- ```\n-\n # Representation\n \n Rust's string type, `str`, is a sequence of unicode codepoints encoded as a\n@@ -97,14 +90,14 @@ use libc;\n use num::Saturating;\n use option::{None, Option, Some};\n use ptr;\n-use ptr::RawPtr;\n use from_str::FromStr;\n use slice;\n use slice::{OwnedVector, OwnedCloneableVector, ImmutableVector, MutableVector};\n use slice::{Vector};\n use vec::Vec;\n use default::Default;\n use raw::Repr;\n+use strbuf::StrBuf;\n \n /*\n Section: Creating a string\n@@ -149,21 +142,16 @@ pub fn from_byte(b: u8) -> ~str {\n \n /// Convert a char to a string\n pub fn from_char(ch: char) -> ~str {\n-    let mut buf = ~\"\";\n+    let mut buf = StrBuf::new();\n     buf.push_char(ch);\n-    buf\n+    buf.into_owned()\n }\n \n /// Convert a vector of chars to a string\n pub fn from_chars(chs: &[char]) -> ~str {\n     chs.iter().map(|c| *c).collect()\n }\n \n-#[doc(hidden)]\n-pub fn push_str(lhs: &mut ~str, rhs: &str) {\n-    lhs.push_str(rhs)\n-}\n-\n /// Methods for vectors of strings\n pub trait StrVector {\n     /// Concatenate a vector of strings.\n@@ -180,12 +168,13 @@ impl<'a, S: Str> StrVector for &'a [S] {\n         // `len` calculation may overflow but push_str but will check boundaries\n         let len = self.iter().map(|s| s.as_slice().len()).sum();\n \n-        let mut result = with_capacity(len);\n+        let mut result = StrBuf::with_capacity(len);\n \n         for s in self.iter() {\n             result.push_str(s.as_slice())\n         }\n-        result\n+\n+        result.into_owned()\n     }\n \n     fn connect(&self, sep: &str) -> ~str {\n@@ -198,7 +187,7 @@ impl<'a, S: Str> StrVector for &'a [S] {\n         // `len` calculation may overflow but push_str but will check boundaries\n         let len = sep.len() * (self.len() - 1)\n             + self.iter().map(|s| s.as_slice().len()).sum();\n-        let mut result = with_capacity(len);\n+        let mut result = StrBuf::with_capacity(len);\n         let mut first = true;\n \n         for s in self.iter() {\n@@ -209,7 +198,7 @@ impl<'a, S: Str> StrVector for &'a [S] {\n             }\n             result.push_str(s.as_slice());\n         }\n-        result\n+        result.into_owned()\n     }\n }\n \n@@ -675,15 +664,15 @@ impl<'a> Iterator<char> for Normalizations<'a> {\n ///\n /// The original string with all occurances of `from` replaced with `to`\n pub fn replace(s: &str, from: &str, to: &str) -> ~str {\n-    let mut result = ~\"\";\n+    let mut result = StrBuf::new();\n     let mut last_end = 0;\n     for (start, end) in s.match_indices(from) {\n         result.push_str(unsafe{raw::slice_bytes(s, last_end, start)});\n         result.push_str(to);\n         last_end = end;\n     }\n     result.push_str(unsafe{raw::slice_bytes(s, last_end, s.len())});\n-    result\n+    result.into_owned()\n }\n \n /*\n@@ -992,14 +981,14 @@ pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {\n /// assert_eq!(str::from_utf16(v), None);\n /// ```\n pub fn from_utf16(v: &[u16]) -> Option<~str> {\n-    let mut s = with_capacity(v.len() / 2);\n+    let mut s = StrBuf::with_capacity(v.len() / 2);\n     for c in utf16_items(v) {\n         match c {\n             ScalarValue(c) => s.push_char(c),\n             LoneSurrogate(_) => return None\n         }\n     }\n-    Some(s)\n+    Some(s.into_owned())\n }\n \n /// Decode a UTF-16 encoded vector `v` into a string, replacing\n@@ -1021,15 +1010,6 @@ pub fn from_utf16_lossy(v: &[u16]) -> ~str {\n     utf16_items(v).map(|c| c.to_char_lossy()).collect()\n }\n \n-/// Allocates a new string with the specified capacity. The string returned is\n-/// the empty string, but has capacity for much more.\n-#[inline]\n-pub fn with_capacity(capacity: uint) -> ~str {\n-    unsafe {\n-        cast::transmute(slice::with_capacity::<~[u8]>(capacity))\n-    }\n-}\n-\n // https://tools.ietf.org/html/rfc3629\n static UTF8_CHAR_WIDTH: [u8, ..256] = [\n 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,\n@@ -1109,10 +1089,13 @@ pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> MaybeOwned<'a> {\n             unsafe_get(xs, i)\n         }\n     }\n-    let mut res = with_capacity(total);\n+\n+    let mut res = StrBuf::with_capacity(total);\n \n     if i > 0 {\n-        unsafe { raw::push_bytes(&mut res, v.slice_to(i)) };\n+        unsafe {\n+            res.push_bytes(v.slice_to(i))\n+        };\n     }\n \n     // subseqidx is the index of the first byte of the subsequence we're looking at.\n@@ -1128,10 +1111,10 @@ pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> MaybeOwned<'a> {\n         macro_rules! error(() => ({\n             unsafe {\n                 if subseqidx != i_ {\n-                    raw::push_bytes(&mut res, v.slice(subseqidx, i_));\n+                    res.push_bytes(v.slice(subseqidx, i_));\n                 }\n                 subseqidx = i;\n-                raw::push_bytes(&mut res, REPLACEMENT);\n+                res.push_bytes(REPLACEMENT);\n             }\n         }))\n \n@@ -1196,9 +1179,11 @@ pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> MaybeOwned<'a> {\n         }\n     }\n     if subseqidx < total {\n-        unsafe { raw::push_bytes(&mut res, v.slice(subseqidx, total)) };\n+        unsafe {\n+            res.push_bytes(v.slice(subseqidx, total))\n+        };\n     }\n-    Owned(res)\n+    Owned(res.into_owned())\n }\n \n /*\n@@ -1354,7 +1339,6 @@ pub mod raw {\n     use libc;\n     use ptr;\n     use ptr::RawPtr;\n-    use option::{Option, Some, None};\n     use str::{is_utf8, OwnedStr, StrSlice};\n     use slice;\n     use slice::{MutableVector, ImmutableVector, OwnedVector};\n@@ -1448,48 +1432,6 @@ pub mod raw {\n             })\n     }\n \n-    /// Appends a byte to a string.\n-    /// The caller must preserve the valid UTF-8 property.\n-    #[inline]\n-    pub unsafe fn push_byte(s: &mut ~str, b: u8) {\n-        as_owned_vec(s).push(b)\n-    }\n-\n-    /// Appends a vector of bytes to a string.\n-    /// The caller must preserve the valid UTF-8 property.\n-    #[inline]\n-    pub unsafe fn push_bytes(s: &mut ~str, bytes: &[u8]) {\n-        slice::bytes::push_bytes(as_owned_vec(s), bytes);\n-    }\n-\n-    /// Removes the last byte from a string and returns it.\n-    /// Returns None when an empty string is passed.\n-    /// The caller must preserve the valid UTF-8 property.\n-    pub unsafe fn pop_byte(s: &mut ~str) -> Option<u8> {\n-        let len = s.len();\n-        if len == 0u {\n-            return None;\n-        } else {\n-            let b = s[len - 1u];\n-            s.set_len(len - 1);\n-            return Some(b);\n-        }\n-    }\n-\n-    /// Removes the first byte from a string and returns it.\n-    /// Returns None when an empty string is passed.\n-    /// The caller must preserve the valid UTF-8 property.\n-    pub unsafe fn shift_byte(s: &mut ~str) -> Option<u8> {\n-        let len = s.len();\n-        if len == 0u {\n-            return None;\n-        } else {\n-            let b = s[0];\n-            *s = s.slice(1, len).to_owned();\n-            return Some(b);\n-        }\n-    }\n-\n     /// Access the str in its vector representation.\n     /// The caller must preserve the valid UTF-8 property when modifying.\n     #[inline]\n@@ -1525,14 +1467,15 @@ pub mod traits {\n     use iter::Iterator;\n     use ops::Add;\n     use option::{Some, None};\n-    use str::{Str, StrSlice, OwnedStr, eq_slice};\n+    use str::{Str, StrSlice, eq_slice};\n+    use strbuf::StrBuf;\n \n     impl<'a> Add<&'a str,~str> for &'a str {\n         #[inline]\n         fn add(&self, rhs: & &'a str) -> ~str {\n-            let mut ret = self.to_owned();\n+            let mut ret = StrBuf::from_owned_str(self.to_owned());\n             ret.push_str(*rhs);\n-            ret\n+            ret.into_owned()\n         }\n     }\n \n@@ -1605,8 +1548,20 @@ pub trait Str {\n     /// Work with `self` as a slice.\n     fn as_slice<'a>(&'a self) -> &'a str;\n \n-    /// Convert `self` into a ~str, not making a copy if possible\n+    /// Convert `self` into a ~str, not making a copy if possible.\n     fn into_owned(self) -> ~str;\n+\n+    /// Convert `self` into a `StrBuf`.\n+    #[inline]\n+    fn to_strbuf(&self) -> StrBuf {\n+        StrBuf::from_str(self.as_slice())\n+    }\n+\n+    /// Convert `self` into a `StrBuf`, not making a copy if possible.\n+    #[inline]\n+    fn into_strbuf(self) -> StrBuf {\n+        StrBuf::from_owned_str(self.into_owned())\n+    }\n }\n \n impl<'a> Str for &'a str {\n@@ -2519,19 +2474,19 @@ impl<'a> StrSlice<'a> for &'a str {\n     }\n \n     fn escape_default(&self) -> ~str {\n-        let mut out = with_capacity(self.len());\n+        let mut out = StrBuf::with_capacity(self.len());\n         for c in self.chars() {\n             c.escape_default(|c| out.push_char(c));\n         }\n-        out\n+        out.into_owned()\n     }\n \n     fn escape_unicode(&self) -> ~str {\n-        let mut out = with_capacity(self.len());\n+        let mut out = StrBuf::with_capacity(self.len());\n         for c in self.chars() {\n             c.escape_unicode(|c| out.push_char(c));\n         }\n-        out\n+        out.into_owned()\n     }\n \n     #[inline]\n@@ -2574,15 +2529,15 @@ impl<'a> StrSlice<'a> for &'a str {\n     }\n \n     fn replace(&self, from: &str, to: &str) -> ~str {\n-        let mut result = ~\"\";\n+        let mut result = StrBuf::new();\n         let mut last_end = 0;\n         for (start, end) in self.match_indices(from) {\n             result.push_str(unsafe{raw::slice_bytes(*self, last_end, start)});\n             result.push_str(to);\n             last_end = end;\n         }\n         result.push_str(unsafe{raw::slice_bytes(*self, last_end, self.len())});\n-        result\n+        result.into_owned()\n     }\n \n     #[inline]\n@@ -2727,11 +2682,11 @@ impl<'a> StrSlice<'a> for &'a str {\n     }\n \n     fn repeat(&self, nn: uint) -> ~str {\n-        let mut ret = with_capacity(nn * self.len());\n+        let mut ret = StrBuf::with_capacity(nn * self.len());\n         for _ in range(0, nn) {\n             ret.push_str(*self);\n         }\n-        ret\n+        ret.into_owned()\n     }\n \n     #[inline]\n@@ -2796,75 +2751,6 @@ impl<'a> StrSlice<'a> for &'a str {\n \n /// Methods for owned strings\n pub trait OwnedStr {\n-    /// Appends a string slice to the back of a string, without overallocating.\n-    fn push_str_no_overallocate(&mut self, rhs: &str);\n-\n-    /// Appends a string slice to the back of a string\n-    fn push_str(&mut self, rhs: &str);\n-\n-    /// Appends a character to the back of a string\n-    fn push_char(&mut self, c: char);\n-\n-    /// Remove the final character from a string and return it. Return None\n-    /// when the string is empty.\n-    fn pop_char(&mut self) -> Option<char>;\n-\n-    /// Remove the first character from a string and return it. Return None\n-    /// when the string is empty.\n-    fn shift_char(&mut self) -> Option<char>;\n-\n-    /// Prepend a char to a string\n-    fn unshift_char(&mut self, ch: char);\n-\n-    /// Insert a new sub-string at the given position in a string, in O(n + m) time\n-    /// (with n and m the lengths of the string and the substring.)\n-    /// This fails if `position` is not at a character boundary.\n-    fn insert(&mut self, position: uint, substring: &str);\n-\n-    /// Insert a char at the given position in a string, in O(n + m) time\n-    /// (with n and m the lengths of the string and the substring.)\n-    /// This fails if `position` is not at a character boundary.\n-    fn insert_char(&mut self, position: uint, ch: char);\n-\n-    /// Concatenate two strings together.\n-    fn append(self, rhs: &str) -> ~str;\n-\n-    /// Reserves capacity for exactly `n` bytes in the given string.\n-    ///\n-    /// Assuming single-byte characters, the resulting string will be large\n-    /// enough to hold a string of length `n`.\n-    ///\n-    /// If the capacity for `s` is already equal to or greater than the requested\n-    /// capacity, then no action is taken.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * s - A string\n-    /// * n - The number of bytes to reserve space for\n-    fn reserve_exact(&mut self, n: uint);\n-\n-    /// Reserves capacity for at least `n` bytes in the given string.\n-    ///\n-    /// Assuming single-byte characters, the resulting string will be large\n-    /// enough to hold a string of length `n`.\n-    ///\n-    /// This function will over-allocate in order to amortize the allocation costs\n-    /// in scenarios where the caller may need to repeatedly reserve additional\n-    /// space.\n-    ///\n-    /// If the capacity for `s` is already equal to or greater than the requested\n-    /// capacity, then no action is taken.\n-    ///\n-    /// # Arguments\n-    ///\n-    /// * s - A string\n-    /// * n - The number of bytes to reserve space for\n-    fn reserve(&mut self, n: uint);\n-\n-    /// Returns the number of single-byte characters the string can hold without\n-    /// reallocating\n-    fn capacity(&self) -> uint;\n-\n     /// Shorten a string to the specified length (which must be <= the current length)\n     fn truncate(&mut self, len: uint);\n \n@@ -2879,119 +2765,12 @@ pub trait OwnedStr {\n     /// modifying its buffers, so it is up to the caller to ensure that\n     /// the string is actually the specified size.\n     unsafe fn set_len(&mut self, new_len: uint);\n+\n+    /// Pushes the given string onto this string, returning the concatenation of the two strings.\n+    fn append(self, rhs: &str) -> ~str;\n }\n \n impl OwnedStr for ~str {\n-    #[inline]\n-    fn push_str_no_overallocate(&mut self, rhs: &str) {\n-        let new_cap = self.len() + rhs.len();\n-        self.reserve_exact(new_cap);\n-        self.push_str(rhs);\n-    }\n-\n-    #[inline]\n-    fn push_str(&mut self, rhs: &str) {\n-        unsafe {\n-            raw::push_bytes(self, rhs.as_bytes());\n-        }\n-    }\n-\n-    #[inline]\n-    fn push_char(&mut self, c: char) {\n-        let cur_len = self.len();\n-        // may use up to 4 bytes.\n-        unsafe {\n-            let v = raw::as_owned_vec(self);\n-            v.reserve_additional(4);\n-\n-            // Attempt to not use an intermediate buffer by just pushing bytes\n-            // directly onto this string.\n-            let write_ptr = v.as_mut_ptr().offset(cur_len as int);\n-            let used = slice::raw::mut_buf_as_slice(write_ptr, 4, |slc| c.encode_utf8(slc));\n-\n-            v.set_len(cur_len + used);\n-        }\n-    }\n-\n-    #[inline]\n-    fn pop_char(&mut self) -> Option<char> {\n-        let end = self.len();\n-        if end == 0u {\n-            return None;\n-        } else {\n-            let CharRange {ch, next} = self.char_range_at_reverse(end);\n-            unsafe { self.set_len(next); }\n-            return Some(ch);\n-        }\n-    }\n-\n-    #[inline]\n-    fn shift_char(&mut self) -> Option<char> {\n-        if self.is_empty() {\n-            return None;\n-        } else {\n-            let CharRange {ch, next} = self.char_range_at(0u);\n-            *self = self.slice(next, self.len()).to_owned();\n-            return Some(ch);\n-        }\n-    }\n-\n-    #[inline]\n-    fn unshift_char(&mut self, ch: char) {\n-        // This could be more efficient.\n-        let mut new_str = ~\"\";\n-        new_str.push_char(ch);\n-        new_str.push_str(*self);\n-        *self = new_str;\n-    }\n-\n-    #[inline]\n-    fn insert(&mut self, position: uint, substring: &str) {\n-        // This could be more efficient.\n-        let mut new_str = self.slice_to(position).to_owned();\n-        new_str.push_str(substring);\n-        new_str.push_str(self.slice_from(position));\n-        *self = new_str;\n-    }\n-\n-    #[inline]\n-    fn insert_char(&mut self, position: uint, ch: char) {\n-        // This could be more efficient.\n-        let mut new_str = self.slice_to(position).to_owned();\n-        new_str.push_char(ch);\n-        new_str.push_str(self.slice_from(position));\n-        *self = new_str;\n-    }\n-\n-    #[inline]\n-    fn append(self, rhs: &str) -> ~str {\n-        let mut new_str = self;\n-        new_str.push_str_no_overallocate(rhs);\n-        new_str\n-    }\n-\n-    #[inline]\n-    fn reserve_exact(&mut self, n: uint) {\n-        unsafe {\n-            raw::as_owned_vec(self).reserve_exact(n)\n-        }\n-    }\n-\n-    #[inline]\n-    fn reserve(&mut self, n: uint) {\n-        unsafe {\n-            raw::as_owned_vec(self).reserve(n)\n-        }\n-    }\n-\n-    #[inline]\n-    fn capacity(&self) -> uint {\n-        unsafe {\n-            let buf: &~[u8] = cast::transmute(self);\n-            buf.capacity()\n-        }\n-    }\n-\n     #[inline]\n     fn truncate(&mut self, len: uint) {\n         assert!(len <= self.len());\n@@ -3008,6 +2787,13 @@ impl OwnedStr for ~str {\n     unsafe fn set_len(&mut self, new_len: uint) {\n         raw::as_owned_vec(self).set_len(new_len)\n     }\n+\n+    #[inline]\n+    fn append(self, rhs: &str) -> ~str {\n+        let mut new_str = StrBuf::from_owned_str(self);\n+        new_str.push_str(rhs);\n+        new_str.into_owned()\n+    }\n }\n \n impl Clone for ~str {\n@@ -3021,21 +2807,9 @@ impl FromIterator<char> for ~str {\n     #[inline]\n     fn from_iter<T: Iterator<char>>(iterator: T) -> ~str {\n         let (lower, _) = iterator.size_hint();\n-        let mut buf = with_capacity(lower);\n+        let mut buf = StrBuf::with_capacity(lower);\n         buf.extend(iterator);\n-        buf\n-    }\n-}\n-\n-impl Extendable<char> for ~str {\n-    #[inline]\n-    fn extend<T: Iterator<char>>(&mut self, mut iterator: T) {\n-        let (lower, _) = iterator.size_hint();\n-        let reserve = lower + self.len();\n-        self.reserve(reserve);\n-        for ch in iterator {\n-            self.push_char(ch)\n-        }\n+        buf.into_owned()\n     }\n }\n \n@@ -3054,6 +2828,7 @@ mod tests {\n     use default::Default;\n     use prelude::*;\n     use str::*;\n+    use strbuf::StrBuf;\n \n     #[test]\n     fn test_eq() {\n@@ -3117,92 +2892,6 @@ mod tests {\n         assert_eq!(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".rfind(|c: char| c == '\u534e'), Some(30u));\n     }\n \n-    #[test]\n-    fn test_push_str() {\n-        let mut s = ~\"\";\n-        s.push_str(\"\");\n-        assert_eq!(s.slice_from(0), \"\");\n-        s.push_str(\"abc\");\n-        assert_eq!(s.slice_from(0), \"abc\");\n-        s.push_str(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n-        assert_eq!(s.slice_from(0), \"abc\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n-    }\n-\n-    #[test]\n-    fn test_append() {\n-        let mut s = ~\"\";\n-        s = s.append(\"\");\n-        assert_eq!(s.slice_from(0), \"\");\n-        s = s.append(\"abc\");\n-        assert_eq!(s.slice_from(0), \"abc\");\n-        s = s.append(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n-        assert_eq!(s.slice_from(0), \"abc\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n-    }\n-\n-    #[test]\n-    fn test_pop_char() {\n-        let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        let cc = data.pop_char();\n-        assert_eq!(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", data);\n-        assert_eq!(Some('\u534e'), cc);\n-    }\n-\n-    #[test]\n-    fn test_pop_char_2() {\n-        let mut data2 = ~\"\u534e\";\n-        let cc2 = data2.pop_char();\n-        assert_eq!(~\"\", data2);\n-        assert_eq!(Some('\u534e'), cc2);\n-    }\n-\n-    #[test]\n-    fn test_pop_char_empty() {\n-        let mut data = ~\"\";\n-        let cc3 = data.pop_char();\n-        assert_eq!(~\"\", data);\n-        assert_eq!(None, cc3);\n-    }\n-\n-    #[test]\n-    fn test_push_char() {\n-        let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n-        data.push_char('\u534e');\n-        data.push_char('b'); // 1 byte\n-        data.push_char('\u00a2'); // 2 byte\n-        data.push_char('\u20ac'); // 3 byte\n-        data.push_char('\ud852\udf62'); // 4 byte\n-        assert_eq!(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eb\u00a2\u20ac\ud852\udf62\", data);\n-    }\n-\n-    #[test]\n-    fn test_shift_char() {\n-        let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n-        let cc = data.shift_char();\n-        assert_eq!(~\"\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", data);\n-        assert_eq!(Some('\u0e1b'), cc);\n-    }\n-\n-    #[test]\n-    fn test_unshift_char() {\n-        let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n-        data.unshift_char('\u534e');\n-        assert_eq!(~\"\u534e\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\", data);\n-    }\n-\n-    #[test]\n-    fn test_insert_char() {\n-        let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n-        data.insert_char(15, '\u534e');\n-        assert_eq!(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u534e\u0e28\u0e44\u0e17\u0e22\u4e2d\", data);\n-    }\n-\n-    #[test]\n-    fn test_insert() {\n-        let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n-        data.insert(15, \"\u534e\u4e2d\");\n-        assert_eq!(~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u534e\u4e2d\u0e28\u0e44\u0e17\u0e22\u4e2d\", data);\n-    }\n-\n     #[test]\n     fn test_collect() {\n         let empty = ~\"\";\n@@ -3213,28 +2902,6 @@ mod tests {\n         assert_eq!(data, s);\n     }\n \n-    #[test]\n-    fn test_extend() {\n-        let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n-        let mut cpy = data.clone();\n-        let other = \"abc\";\n-        let it = other.chars();\n-        cpy.extend(it);\n-        assert_eq!(cpy, data + other);\n-    }\n-\n-    #[test]\n-    fn test_clear() {\n-        let mut empty = ~\"\";\n-        empty.clear();\n-        assert_eq!(\"\", empty.as_slice());\n-        let mut data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\";\n-        data.clear();\n-        assert_eq!(\"\", data.as_slice());\n-        data.push_char('\u534e');\n-        assert_eq!(\"\u534e\", data.as_slice());\n-    }\n-\n     #[test]\n     fn test_into_bytes() {\n         let data = ~\"asdf\";\n@@ -3346,15 +3013,21 @@ mod tests {\n         assert_eq!(\"\", unsafe {raw::slice_bytes(\"abc\", 1, 1)});\n         fn a_million_letter_a() -> ~str {\n             let mut i = 0;\n-            let mut rs = ~\"\";\n-            while i < 100000 { rs.push_str(\"aaaaaaaaaa\"); i += 1; }\n-            rs\n+            let mut rs = StrBuf::new();\n+            while i < 100000 {\n+                rs.push_str(\"aaaaaaaaaa\");\n+                i += 1;\n+            }\n+            rs.into_owned()\n         }\n         fn half_a_million_letter_a() -> ~str {\n             let mut i = 0;\n-            let mut rs = ~\"\";\n-            while i < 100000 { rs.push_str(\"aaaaa\"); i += 1; }\n-            rs\n+            let mut rs = StrBuf::new();\n+            while i < 100000 {\n+                rs.push_str(\"aaaaa\");\n+                i += 1;\n+            }\n+            rs.into_owned()\n         }\n         let letters = a_million_letter_a();\n         assert!(half_a_million_letter_a() ==\n@@ -3455,18 +3128,21 @@ mod tests {\n \n         fn a_million_letter_X() -> ~str {\n             let mut i = 0;\n-            let mut rs = ~\"\";\n+            let mut rs = StrBuf::new();\n             while i < 100000 {\n-                push_str(&mut rs, \"\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\");\n+                rs.push_str(\"\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\u534e\");\n                 i += 1;\n             }\n-            rs\n+            rs.into_owned()\n         }\n         fn half_a_million_letter_X() -> ~str {\n             let mut i = 0;\n-            let mut rs = ~\"\";\n-            while i < 100000 { push_str(&mut rs, \"\u534e\u534e\u534e\u534e\u534e\"); i += 1; }\n-            rs\n+            let mut rs = StrBuf::new();\n+            while i < 100000 {\n+                rs.push_str(\"\u534e\u534e\u534e\u534e\u534e\");\n+                i += 1;\n+            }\n+            rs.into_owned()\n         }\n         let letters = a_million_letter_X();\n         assert!(half_a_million_letter_X() ==\n@@ -3608,29 +3284,6 @@ mod tests {\n         assert_eq!(empty.slice_shift_char(), (None, \"\"));\n     }\n \n-    #[test]\n-    fn test_push_byte() {\n-        let mut s = ~\"ABC\";\n-        unsafe{raw::push_byte(&mut s, 'D' as u8)};\n-        assert_eq!(s, ~\"ABCD\");\n-    }\n-\n-    #[test]\n-    fn test_shift_byte() {\n-        let mut s = ~\"ABC\";\n-        let b = unsafe{raw::shift_byte(&mut s)};\n-        assert_eq!(s, ~\"BC\");\n-        assert_eq!(b, Some(65u8));\n-    }\n-\n-    #[test]\n-    fn test_pop_byte() {\n-        let mut s = ~\"ABC\";\n-        let b = unsafe{raw::pop_byte(&mut s)};\n-        assert_eq!(s, ~\"AB\");\n-        assert_eq!(b, Some(67u8));\n-    }\n-\n     #[test]\n     fn test_is_utf8() {\n         // deny overlong encodings\n@@ -4323,38 +3976,6 @@ mod tests {\n         assert_eq!(5, sum_len([s.as_slice()]));\n     }\n \n-    #[test]\n-    fn test_str_truncate() {\n-        let mut s = ~\"12345\";\n-        s.truncate(5);\n-        assert_eq!(s.as_slice(), \"12345\");\n-        s.truncate(3);\n-        assert_eq!(s.as_slice(), \"123\");\n-        s.truncate(0);\n-        assert_eq!(s.as_slice(), \"\");\n-\n-        let mut s = ~\"12345\";\n-        let p = s.as_ptr();\n-        s.truncate(3);\n-        s.push_str(\"6\");\n-        let p_ = s.as_ptr();\n-        assert_eq!(p_, p);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_str_truncate_invalid_len() {\n-        let mut s = ~\"12345\";\n-        s.truncate(6);\n-    }\n-\n-    #[test]\n-    #[should_fail]\n-    fn test_str_truncate_split_codepoint() {\n-        let mut s = ~\"\\u00FC\"; // \u00fc\n-        s.truncate(1);\n-    }\n-\n     #[test]\n     fn test_str_from_utf8() {\n         let xs = bytes!(\"hello\");\n@@ -4657,22 +4278,6 @@ mod bench {\n         });\n     }\n \n-    #[bench]\n-    fn bench_with_capacity(bh: &mut BenchHarness) {\n-        bh.iter(|| {\n-            with_capacity(100)\n-        });\n-    }\n-\n-    #[bench]\n-    fn bench_push_str(bh: &mut BenchHarness) {\n-        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n-        bh.iter(|| {\n-            let mut r = ~\"\";\n-            r.push_str(s);\n-        });\n-    }\n-\n     #[bench]\n     fn bench_connect(bh: &mut BenchHarness) {\n         let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";"}, {"sha": "e9e50f0a07a1f78e6460ea1e4bab83d9d9e3ecfe", "filename": "src/libstd/strbuf.rs", "status": "added", "additions": 355, "deletions": 0, "changes": 355, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibstd%2Fstrbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibstd%2Fstrbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstrbuf.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -0,0 +1,355 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! An owned, growable string that enforces that its contents are valid UTF-8.\n+\n+use c_vec::CVec;\n+use cast;\n+use char::Char;\n+use container::Container;\n+use fmt;\n+use io::Writer;\n+use iter::{Extendable, FromIterator, Iterator, range};\n+use option::{None, Option, Some};\n+use ptr::RawPtr;\n+use slice::{OwnedVector, Vector};\n+use str::{OwnedStr, Str, StrSlice};\n+use vec::Vec;\n+\n+#[deriving(Clone, Eq, Ord, TotalEq, TotalOrd)]\n+pub struct StrBuf {\n+    vec: Vec<u8>,\n+}\n+\n+impl StrBuf {\n+    /// Creates a new string buffer initalized with the empty string.\n+    #[inline]\n+    pub fn new() -> StrBuf {\n+        StrBuf {\n+            vec: Vec::new(),\n+        }\n+    }\n+\n+    /// Creates a new string buffer with the given capacity.\n+    #[inline]\n+    pub fn with_capacity(capacity: uint) -> StrBuf {\n+        StrBuf {\n+            vec: Vec::with_capacity(capacity),\n+        }\n+    }\n+\n+    /// Creates a new string buffer from length, capacity, and a pointer.\n+    #[inline]\n+    pub unsafe fn from_raw_parts(length: uint, capacity: uint, ptr: *mut u8) -> StrBuf {\n+        StrBuf {\n+            vec: Vec::from_raw_parts(length, capacity, ptr),\n+        }\n+    }\n+\n+    /// Creates a new string buffer from the given string.\n+    #[inline]\n+    pub fn from_str(string: &str) -> StrBuf {\n+        StrBuf {\n+            vec: Vec::from_slice(string.as_bytes())\n+        }\n+    }\n+\n+    /// Creates a new string buffer from the given owned string, taking care not to copy it.\n+    #[inline]\n+    pub fn from_owned_str(string: ~str) -> StrBuf {\n+        StrBuf {\n+            vec: string.into_bytes().move_iter().collect(),\n+        }\n+    }\n+\n+    /// Pushes the given string onto this buffer; then, returns `self` so that it can be used\n+    /// again.\n+    #[inline]\n+    pub fn append(mut self, second: &str) -> StrBuf {\n+        self.push_str(second);\n+        self\n+    }\n+\n+    /// Creates a string buffer by repeating a character `length` times.\n+    #[inline]\n+    pub fn from_char(length: uint, ch: char) -> StrBuf {\n+        if length == 0 {\n+            return StrBuf::new()\n+        }\n+\n+        let mut buf = StrBuf::new();\n+        buf.push_char(ch);\n+        let size = buf.len() * length;\n+        buf.reserve(size);\n+        for _ in range(1, length) {\n+            buf.push_char(ch)\n+        }\n+        buf\n+    }\n+\n+    /// Pushes the given string onto this string buffer.\n+    #[inline]\n+    pub fn push_str(&mut self, string: &str) {\n+        self.vec.push_all(string.as_bytes())\n+    }\n+\n+    #[inline]\n+    pub fn grow(&mut self, count: uint, ch: char) {\n+        for _ in range(0, count) {\n+            self.push_char(ch)\n+        }\n+    }\n+\n+    /// Returns the number of bytes that this string buffer can hold without reallocating.\n+    #[inline]\n+    pub fn byte_capacity(&self) -> uint {\n+        self.vec.capacity()\n+    }\n+\n+    /// Reserves capacity for at least `extra` additional bytes in this string buffer.\n+    #[inline]\n+    pub fn reserve_additional(&mut self, extra: uint) {\n+        self.vec.reserve_additional(extra)\n+    }\n+\n+    /// Reserves capacity for at least `capacity` bytes in this string buffer.\n+    #[inline]\n+    pub fn reserve(&mut self, capacity: uint) {\n+        self.vec.reserve(capacity)\n+    }\n+\n+    /// Reserves capacity for exactly `capacity` bytes in this string buffer.\n+    #[inline]\n+    pub fn reserve_exact(&mut self, capacity: uint) {\n+        self.vec.reserve_exact(capacity)\n+    }\n+\n+    /// Shrinks the capacity of this string buffer to match its length.\n+    #[inline]\n+    pub fn shrink_to_fit(&mut self) {\n+        self.vec.shrink_to_fit()\n+    }\n+\n+    /// Adds the given character to the end of the string.\n+    #[inline]\n+    pub fn push_char(&mut self, ch: char) {\n+        let cur_len = self.len();\n+        unsafe {\n+            // This may use up to 4 bytes.\n+            self.vec.reserve_additional(4);\n+\n+            // Attempt to not use an intermediate buffer by just pushing bytes\n+            // directly onto this string.\n+            let mut c_vector = CVec::new(self.vec.as_mut_ptr().offset(cur_len as int), 4);\n+            let used = ch.encode_utf8(c_vector.as_mut_slice());\n+            self.vec.set_len(cur_len + used);\n+        }\n+    }\n+\n+    /// Pushes the given bytes onto this string buffer. This is unsafe because it does not check\n+    /// to ensure that the resulting string will be valid UTF-8.\n+    #[inline]\n+    pub unsafe fn push_bytes(&mut self, bytes: &[u8]) {\n+        self.vec.push_all(bytes)\n+    }\n+\n+    /// Works with the underlying buffer as a byte slice.\n+    #[inline]\n+    pub fn as_bytes<'a>(&'a self) -> &'a [u8] {\n+        self.vec.as_slice()\n+    }\n+\n+    /// Shorten a string to the specified length (which must be <= the current length)\n+    #[inline]\n+    pub fn truncate(&mut self, len: uint) {\n+        assert!(self.as_slice().is_char_boundary(len));\n+        self.vec.truncate(len)\n+    }\n+\n+    /// Appends a byte to this string buffer. The caller must preserve the valid UTF-8 property.\n+    #[inline]\n+    pub unsafe fn push_byte(&mut self, byte: u8) {\n+        self.push_bytes([byte])\n+    }\n+\n+    /// Removes the last byte from the string buffer and returns it. Returns `None` if this string\n+    /// buffer is empty.\n+    ///\n+    /// The caller must preserve the valid UTF-8 property.\n+    #[inline]\n+    pub unsafe fn pop_byte(&mut self) -> Option<u8> {\n+        let len = self.len();\n+        if len == 0 {\n+            return None\n+        }\n+\n+        let byte = self.as_slice()[len - 1];\n+        self.vec.set_len(len - 1);\n+        Some(byte)\n+    }\n+\n+    /// Removes the first byte from the string buffer and returns it. Returns `None` if this string\n+    /// buffer is empty.\n+    ///\n+    /// The caller must preserve the valid UTF-8 property.\n+    pub unsafe fn shift_byte(&mut self) -> Option<u8> {\n+        let len = self.len();\n+        if len == 0 {\n+            return None\n+        }\n+\n+        let byte = self.as_slice()[0];\n+        *self = self.as_slice().slice(1, len).into_strbuf();\n+        Some(byte)\n+    }\n+}\n+\n+impl Container for StrBuf {\n+    #[inline]\n+    fn len(&self) -> uint {\n+        self.vec.len()\n+    }\n+}\n+\n+impl FromIterator<char> for StrBuf {\n+    fn from_iter<I:Iterator<char>>(iterator: I) -> StrBuf {\n+        let mut buf = StrBuf::new();\n+        buf.extend(iterator);\n+        buf\n+    }\n+}\n+\n+impl Extendable<char> for StrBuf {\n+    fn extend<I:Iterator<char>>(&mut self, mut iterator: I) {\n+        for ch in iterator {\n+            self.push_char(ch)\n+        }\n+    }\n+}\n+\n+impl Str for StrBuf {\n+    #[inline]\n+    fn as_slice<'a>(&'a self) -> &'a str {\n+        unsafe {\n+            cast::transmute(self.vec.as_slice())\n+        }\n+    }\n+\n+    #[inline]\n+    fn into_owned(self) -> ~str {\n+        let StrBuf {\n+            vec: vec\n+        } = self;\n+        unsafe {\n+            cast::transmute::<~[u8],~str>(vec.move_iter().collect())\n+        }\n+    }\n+}\n+\n+impl fmt::Show for StrBuf {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.as_slice().fmt(f)\n+    }\n+}\n+\n+impl<H:Writer> ::hash::Hash<H> for StrBuf {\n+    #[inline]\n+    fn hash(&self, hasher: &mut H) {\n+        self.as_slice().hash(hasher)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    extern crate test;\n+    use self::test::BenchHarness;\n+    use str::{Str, StrSlice};\n+    use super::StrBuf;\n+\n+    #[bench]\n+    fn bench_with_capacity(bh: &mut BenchHarness) {\n+        bh.iter(|| {\n+            StrBuf::with_capacity(100)\n+        });\n+    }\n+\n+    #[bench]\n+    fn bench_push_str(bh: &mut BenchHarness) {\n+        let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n+        bh.iter(|| {\n+            let mut r = StrBuf::new();\n+            r.push_str(s);\n+        });\n+    }\n+\n+    #[test]\n+    fn test_push_bytes() {\n+        let mut s = StrBuf::from_str(\"ABC\");\n+        unsafe {\n+            s.push_bytes([ 'D' as u8 ]);\n+        }\n+        assert_eq!(s.as_slice(), \"ABCD\");\n+    }\n+\n+    #[test]\n+    fn test_push_str() {\n+        let mut s = StrBuf::new();\n+        s.push_str(\"\");\n+        assert_eq!(s.as_slice().slice_from(0), \"\");\n+        s.push_str(\"abc\");\n+        assert_eq!(s.as_slice().slice_from(0), \"abc\");\n+        s.push_str(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+        assert_eq!(s.as_slice().slice_from(0), \"abc\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+    }\n+\n+    #[test]\n+    fn test_push_char() {\n+        let mut data = StrBuf::from_str(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\");\n+        data.push_char('\u534e');\n+        data.push_char('b'); // 1 byte\n+        data.push_char('\u00a2'); // 2 byte\n+        data.push_char('\u20ac'); // 3 byte\n+        data.push_char('\ud852\udf62'); // 4 byte\n+        assert_eq!(data.as_slice(), \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eb\u00a2\u20ac\ud852\udf62\");\n+    }\n+\n+    #[test]\n+    fn test_str_truncate() {\n+        let mut s = StrBuf::from_str(\"12345\");\n+        s.truncate(5);\n+        assert_eq!(s.as_slice(), \"12345\");\n+        s.truncate(3);\n+        assert_eq!(s.as_slice(), \"123\");\n+        s.truncate(0);\n+        assert_eq!(s.as_slice(), \"\");\n+\n+        let mut s = StrBuf::from_str(\"12345\");\n+        let p = s.as_slice().as_ptr();\n+        s.truncate(3);\n+        s.push_str(\"6\");\n+        let p_ = s.as_slice().as_ptr();\n+        assert_eq!(p_, p);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_str_truncate_invalid_len() {\n+        let mut s = StrBuf::from_str(\"12345\");\n+        s.truncate(6);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    fn test_str_truncate_split_codepoint() {\n+        let mut s = StrBuf::from_str(\"\\u00FC\"); // \u00fc\n+        s.truncate(1);\n+    }\n+}\n+"}, {"sha": "da0e0d73feddccdf21709947991f659a2d4e6ebf", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -7,6 +7,7 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n+\n //! An owned, growable vector.\n \n use cast::{forget, transmute};\n@@ -28,7 +29,7 @@ use ptr;\n use rt::global_heap::{malloc_raw, realloc_raw};\n use raw::Slice;\n use slice::{ImmutableEqVector, ImmutableVector, Items, MutItems, MutableVector};\n-use slice::{MutableTotalOrdVector, Vector};\n+use slice::{MutableTotalOrdVector, OwnedVector, Vector};\n \n /// An owned, growable vector.\n ///"}, {"sha": "4c7803f022a159dce92a09f11772841db27a22fe", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -19,9 +19,10 @@ use print::pprust;\n use util::small_vector::SmallVector;\n \n use std::cell::RefCell;\n+use std::fmt;\n use std::iter;\n use std::slice;\n-use std::fmt;\n+use std::strbuf::StrBuf;\n \n #[deriving(Clone, Eq)]\n pub enum PathElem {\n@@ -81,14 +82,14 @@ pub type PathElems<'a, 'b> = iter::Chain<Values<'a, PathElem>, LinkedPath<'b>>;\n pub fn path_to_str<PI: Iterator<PathElem>>(mut path: PI) -> ~str {\n     let itr = token::get_ident_interner();\n \n-    path.fold(~\"\", |mut s, e| {\n+    path.fold(StrBuf::new(), |mut s, e| {\n         let e = itr.get(e.name());\n         if !s.is_empty() {\n             s.push_str(\"::\");\n         }\n         s.push_str(e.as_slice());\n         s\n-    })\n+    }).into_owned()\n }\n \n #[deriving(Clone)]"}, {"sha": "cf82b9642dedcad38886f2960b8b001a3e55e028", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -21,6 +21,7 @@ use visit;\n \n use std::cell::Cell;\n use std::cmp;\n+use std::strbuf::StrBuf;\n use std::u32;\n \n pub fn path_name_i(idents: &[Ident]) -> ~str {\n@@ -235,15 +236,15 @@ pub fn unguarded_pat(a: &Arm) -> Option<Vec<@Pat> > {\n /// listed as `__extensions__::method_name::hash`, with no indication\n /// of the type).\n pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: &Ty) -> Ident {\n-    let mut pretty = pprust::ty_to_str(ty);\n+    let mut pretty = StrBuf::from_owned_str(pprust::ty_to_str(ty));\n     match *trait_ref {\n         Some(ref trait_ref) => {\n             pretty.push_char('.');\n             pretty.push_str(pprust::path_to_str(&trait_ref.path));\n         }\n         None => {}\n     }\n-    token::gensym_ident(pretty)\n+    token::gensym_ident(pretty.as_slice())\n }\n \n pub fn public_methods(ms: Vec<@Method> ) -> Vec<@Method> {"}, {"sha": "b174dffdfeccf72540a4ddd9a4b521d67d5daefc", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -21,9 +21,10 @@ source code snippets, etc.\n \n */\n \n+use serialize::{Encodable, Decodable, Encoder, Decoder};\n use std::cell::RefCell;\n use std::rc::Rc;\n-use serialize::{Encodable, Decodable, Encoder, Decoder};\n+use std::strbuf::StrBuf;\n \n pub trait Pos {\n     fn from_uint(n: uint) -> Self;\n@@ -305,22 +306,22 @@ impl CodeMap {\n         // FIXME #12884: no efficient/safe way to remove from the start of a string\n         // and reuse the allocation.\n         let mut src = if src.starts_with(\"\\ufeff\") {\n-            src.as_slice().slice_from(3).into_owned()\n+            StrBuf::from_str(src.as_slice().slice_from(3))\n         } else {\n-            src\n+            StrBuf::from_owned_str(src)\n         };\n \n         // Append '\\n' in case it's not already there.\n         // This is a workaround to prevent CodeMap.lookup_filemap_idx from accidentally\n         // overflowing into the next filemap in case the last byte of span is also the last\n         // byte of filemap, which leads to incorrect results from CodeMap.span_to_*.\n-        if src.len() > 0 && !src.ends_with(\"\\n\") {\n+        if src.len() > 0 && !src.as_slice().ends_with(\"\\n\") {\n             src.push_char('\\n');\n         }\n \n         let filemap = Rc::new(FileMap {\n             name: filename,\n-            src: src,\n+            src: src.into_owned(),\n             start_pos: Pos::from_uint(start_pos),\n             lines: RefCell::new(Vec::new()),\n             multibyte_chars: RefCell::new(Vec::new()),"}, {"sha": "e63f2960421af50921f34d2cd63628f33a5f20b6", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -17,6 +17,7 @@ use std::cell::{RefCell, Cell};\n use std::fmt;\n use std::io;\n use std::iter::range;\n+use std::strbuf::StrBuf;\n use term;\n \n // maximum number of lines we will print for each error; arbitrary.\n@@ -368,11 +369,13 @@ fn highlight_lines(err: &mut EmitterWriter,\n \n         // indent past |name:## | and the 0-offset column location\n         let left = fm.name.len() + digits + lo.col.to_uint() + 3u;\n-        let mut s = ~\"\";\n+        let mut s = StrBuf::new();\n         // Skip is the number of characters we need to skip because they are\n         // part of the 'filename:line ' part of the previous line.\n         let skip = fm.name.len() + digits + 3u;\n-        for _ in range(0, skip) { s.push_char(' '); }\n+        for _ in range(0, skip) {\n+            s.push_char(' ');\n+        }\n         let orig = fm.get_line(*lines.lines.get(0) as int);\n         for pos in range(0u, left-skip) {\n             let cur_char = orig[pos] as char;\n@@ -386,14 +389,16 @@ fn highlight_lines(err: &mut EmitterWriter,\n             };\n         }\n         try!(write!(&mut err.dst, \"{}\", s));\n-        let mut s = ~\"^\";\n+        let mut s = StrBuf::from_str(\"^\");\n         let hi = cm.lookup_char_pos(sp.hi);\n         if hi.col != lo.col {\n             // the ^ already takes up one space\n             let num_squigglies = hi.col.to_uint()-lo.col.to_uint()-1u;\n-            for _ in range(0, num_squigglies) { s.push_char('~'); }\n+            for _ in range(0, num_squigglies) {\n+                s.push_char('~');\n+            }\n         }\n-        try!(print_maybe_styled(err, s + \"\\n\",\n+        try!(print_maybe_styled(err, s.into_owned() + \"\\n\",\n                                 term::attr::ForegroundColor(lvl.color())));\n     }\n     Ok(())\n@@ -409,7 +414,8 @@ fn custom_highlight_lines(w: &mut EmitterWriter,\n                           cm: &codemap::CodeMap,\n                           sp: Span,\n                           lvl: Level,\n-                          lines: codemap::FileLines) -> io::IoResult<()> {\n+                          lines: codemap::FileLines)\n+                          -> io::IoResult<()> {\n     let fm = &*lines.file;\n \n     let lines = lines.lines.as_slice();\n@@ -430,15 +436,21 @@ fn custom_highlight_lines(w: &mut EmitterWriter,\n     let hi = cm.lookup_char_pos(sp.hi);\n     // Span seems to use half-opened interval, so subtract 1\n     let skip = last_line_start.len() + hi.col.to_uint() - 1;\n-    let mut s = ~\"\";\n-    for _ in range(0, skip) { s.push_char(' '); }\n+    let mut s = StrBuf::new();\n+    for _ in range(0, skip) {\n+        s.push_char(' ');\n+    }\n     s.push_char('^');\n-    print_maybe_styled(w, s + \"\\n\", term::attr::ForegroundColor(lvl.color()))\n+    s.push_char('\\n');\n+    print_maybe_styled(w,\n+                       s.into_owned(),\n+                       term::attr::ForegroundColor(lvl.color()))\n }\n \n fn print_macro_backtrace(w: &mut EmitterWriter,\n                          cm: &codemap::CodeMap,\n-                         sp: Span) -> io::IoResult<()> {\n+                         sp: Span)\n+                         -> io::IoResult<()> {\n     for ei in sp.expn_info.iter() {\n         let ss = ei.callee.span.as_ref().map_or(~\"\", |span| cm.span_to_str(*span));\n         let (pre, post) = match ei.callee.format {"}, {"sha": "1db65e3b9e49f3aaea9d14233903b31229956d03", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -8,22 +8,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::char;\n-\n use ast;\n use codemap;\n use ext::base;\n use ext::build::AstBuilder;\n use parse::token;\n \n+use std::char;\n+use std::strbuf::StrBuf;\n+\n pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n                          sp: codemap::Span,\n                          tts: &[ast::TokenTree]) -> base::MacResult {\n     let es = match base::get_exprs_from_tts(cx, sp, tts) {\n         Some(e) => e,\n         None => return base::MacResult::dummy_expr(sp)\n     };\n-    let mut accumulator = ~\"\";\n+    let mut accumulator = StrBuf::new();\n     for e in es.move_iter() {\n         match e.node {\n             ast::ExprLit(lit) => {\n@@ -56,5 +57,7 @@ pub fn expand_syntax_ext(cx: &mut base::ExtCtxt,\n             }\n         }\n     }\n-    base::MRExpr(cx.expr_str(sp, token::intern_and_get_ident(accumulator)))\n+    base::MRExpr(cx.expr_str(\n+            sp,\n+            token::intern_and_get_ident(accumulator.into_owned())))\n }"}, {"sha": "a5faa693982d7d52a77f5a0fa2a7a88096c0a8e4", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -16,9 +16,11 @@ use owned_slice::OwnedSlice;\n use parse::token;\n use parse::token::{str_to_ident};\n \n+use std::strbuf::StrBuf;\n+\n pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     -> base::MacResult {\n-    let mut res_str = ~\"\";\n+    let mut res_str = StrBuf::new();\n     for (i, e) in tts.iter().enumerate() {\n         if i & 1 == 1 {\n             match *e {\n@@ -40,7 +42,7 @@ pub fn expand_syntax_ext(cx: &mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n             }\n         }\n     }\n-    let res = str_to_ident(res_str);\n+    let res = str_to_ident(res_str.into_owned());\n \n     let e = @ast::Expr {\n         id: ast::DUMMY_NODE_ID,"}, {"sha": "067958e4bdec7111076577620336c5afd58cd814", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -15,10 +15,10 @@ use ext::format;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::deriving::generic::*;\n-\n use parse::token;\n \n use collections::HashMap;\n+use std::strbuf::StrBuf;\n \n pub fn expand_deriving_show(cx: &mut ExtCtxt,\n                             span: Span,\n@@ -68,7 +68,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n         }\n     };\n \n-    let mut format_string = token::get_ident(name).get().to_owned();\n+    let mut format_string = StrBuf::from_str(token::get_ident(name).get());\n     // the internal fields we're actually formatting\n     let mut exprs = Vec::new();\n \n@@ -129,7 +129,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n     let write_call = cx.expr_call_global(span, std_write, vec!(buf, cx.expr_ident(span, args)));\n     let format_closure = cx.lambda_expr(span, vec!(args), write_call);\n \n-    let s = token::intern_and_get_ident(format_string);\n+    let s = token::intern_and_get_ident(format_string.as_slice());\n     let format_string = cx.expr_str(span, s);\n \n     // phew, not our responsibility any more!"}, {"sha": "1a246eb7f2cd6621999a39e624c69aa0754e424b", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -19,6 +19,7 @@ use parse::token;\n \n use std::io;\n use std::str;\n+use std::strbuf::StrBuf;\n use std::uint;\n \n #[deriving(Clone, Eq)]\n@@ -134,13 +135,13 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n }\n \n fn read_to_eol(rdr: &mut StringReader) -> ~str {\n-    let mut val = ~\"\";\n+    let mut val = StrBuf::new();\n     while !rdr.curr_is('\\n') && !is_eof(rdr) {\n         val.push_char(rdr.curr.unwrap());\n         bump(rdr);\n     }\n     if rdr.curr_is('\\n') { bump(rdr); }\n-    return val;\n+    return val.into_owned();\n }\n \n fn read_one_line_comment(rdr: &mut StringReader) -> ~str {\n@@ -255,7 +256,7 @@ fn read_block_comment(rdr: &mut StringReader,\n     bump(rdr);\n     bump(rdr);\n \n-    let mut curr_line = ~\"/*\";\n+    let mut curr_line = StrBuf::from_str(\"/*\");\n \n     // doc-comments are not really comments, they are attributes\n     if (rdr.curr_is('*') && !nextch_is(rdr, '*')) || rdr.curr_is('!') {\n@@ -268,9 +269,11 @@ fn read_block_comment(rdr: &mut StringReader,\n             bump(rdr);\n             bump(rdr);\n         }\n-        if !is_block_non_doc_comment(curr_line) { return; }\n-        assert!(!curr_line.contains_char('\\n'));\n-        lines.push(curr_line);\n+        if !is_block_non_doc_comment(curr_line.as_slice()) {\n+            return\n+        }\n+        assert!(!curr_line.as_slice().contains_char('\\n'));\n+        lines.push(curr_line.into_owned());\n     } else {\n         let mut level: int = 1;\n         while level > 0 {\n@@ -279,9 +282,10 @@ fn read_block_comment(rdr: &mut StringReader,\n                 rdr.fatal(~\"unterminated block comment\");\n             }\n             if rdr.curr_is('\\n') {\n-                trim_whitespace_prefix_and_push_line(&mut lines, curr_line,\n+                trim_whitespace_prefix_and_push_line(&mut lines,\n+                                                     curr_line.into_owned(),\n                                                      col);\n-                curr_line = ~\"\";\n+                curr_line = StrBuf::new();\n                 bump(rdr);\n             } else {\n                 curr_line.push_char(rdr.curr.unwrap());\n@@ -301,7 +305,9 @@ fn read_block_comment(rdr: &mut StringReader,\n             }\n         }\n         if curr_line.len() != 0 {\n-            trim_whitespace_prefix_and_push_line(&mut lines, curr_line, col);\n+            trim_whitespace_prefix_and_push_line(&mut lines,\n+                                                 curr_line.into_owned(),\n+                                                 col);\n         }\n     }\n "}, {"sha": "c1c91cb6a4f88fd65fd97b58a12458c5e26c8eaa", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -21,6 +21,7 @@ use std::mem::replace;\n use std::num::from_str_radix;\n use std::rc::Rc;\n use std::str;\n+use std::strbuf::StrBuf;\n \n pub use ext::tt::transcribe::{TtReader, new_tt_reader};\n \n@@ -152,10 +153,10 @@ fn fatal_span_char(rdr: &mut StringReader,\n                    m: ~str,\n                    c: char)\n                 -> ! {\n-    let mut m = m;\n+    let mut m = StrBuf::from_owned_str(m);\n     m.push_str(\": \");\n     char::escape_default(c, |c| m.push_char(c));\n-    fatal_span(rdr, from_pos, to_pos, m);\n+    fatal_span(rdr, from_pos, to_pos, m.into_owned());\n }\n \n // report a lexical error spanning [`from_pos`, `to_pos`), appending the\n@@ -165,12 +166,12 @@ fn fatal_span_verbose(rdr: &mut StringReader,\n                       to_pos: BytePos,\n                       m: ~str)\n                    -> ! {\n-    let mut m = m;\n+    let mut m = StrBuf::from_owned_str(m);\n     m.push_str(\": \");\n     let from = byte_offset(rdr, from_pos).to_uint();\n     let to = byte_offset(rdr, to_pos).to_uint();\n     m.push_str(rdr.filemap.src.slice(from, to));\n-    fatal_span(rdr, from_pos, to_pos, m);\n+    fatal_span(rdr, from_pos, to_pos, m.into_owned());\n }\n \n // EFFECT: advance peek_tok and peek_span to refer to the next token.\n@@ -440,7 +441,7 @@ fn consume_block_comment(rdr: &mut StringReader) -> Option<TokenAndSpan> {\n fn scan_exponent(rdr: &mut StringReader, start_bpos: BytePos) -> Option<~str> {\n     // \\x00 hits the `return None` case immediately, so this is fine.\n     let mut c = rdr.curr.unwrap_or('\\x00');\n-    let mut rslt = ~\"\";\n+    let mut rslt = StrBuf::new();\n     if c == 'e' || c == 'E' {\n         rslt.push_char(c);\n         bump(rdr);\n@@ -451,7 +452,8 @@ fn scan_exponent(rdr: &mut StringReader, start_bpos: BytePos) -> Option<~str> {\n         }\n         let exponent = scan_digits(rdr, 10u);\n         if exponent.len() > 0u {\n-            return Some(rslt + exponent);\n+            rslt.push_str(exponent);\n+            return Some(rslt.into_owned());\n         } else {\n             fatal_span(rdr, start_bpos, rdr.last_pos,\n                        ~\"scan_exponent: bad fp literal\");\n@@ -460,7 +462,7 @@ fn scan_exponent(rdr: &mut StringReader, start_bpos: BytePos) -> Option<~str> {\n }\n \n fn scan_digits(rdr: &mut StringReader, radix: uint) -> ~str {\n-    let mut rslt = ~\"\";\n+    let mut rslt = StrBuf::new();\n     loop {\n         let c = rdr.curr;\n         if c == Some('_') { bump(rdr); continue; }\n@@ -469,7 +471,7 @@ fn scan_digits(rdr: &mut StringReader, radix: uint) -> ~str {\n             rslt.push_char(c.unwrap());\n             bump(rdr);\n           }\n-          _ => return rslt\n+          _ => return rslt.into_owned()\n         }\n     };\n }\n@@ -506,7 +508,7 @@ fn scan_number(c: char, rdr: &mut StringReader) -> token::Token {\n         bump(rdr);\n         base = 2u;\n     }\n-    num_str = scan_digits(rdr, base);\n+    num_str = StrBuf::from_owned_str(scan_digits(rdr, base));\n     c = rdr.curr.unwrap_or('\\x00');\n     nextch(rdr);\n     if c == 'u' || c == 'i' {\n@@ -544,7 +546,8 @@ fn scan_number(c: char, rdr: &mut StringReader) -> token::Token {\n             fatal_span(rdr, start_bpos, rdr.last_pos,\n                        ~\"no valid digits found for number\");\n         }\n-        let parsed = match from_str_radix::<u64>(num_str, base as uint) {\n+        let parsed = match from_str_radix::<u64>(num_str.as_slice(),\n+                                                 base as uint) {\n             Some(p) => p,\n             None => fatal_span(rdr, start_bpos, rdr.last_pos,\n                                ~\"int literal is too large\")\n@@ -579,12 +582,14 @@ fn scan_number(c: char, rdr: &mut StringReader) -> token::Token {\n             bump(rdr);\n             bump(rdr);\n             check_float_base(rdr, start_bpos, rdr.last_pos, base);\n-            return token::LIT_FLOAT(str_to_ident(num_str), ast::TyF32);\n+            return token::LIT_FLOAT(str_to_ident(num_str.into_owned()),\n+                                    ast::TyF32);\n         } else if c == '6' && n == '4' {\n             bump(rdr);\n             bump(rdr);\n             check_float_base(rdr, start_bpos, rdr.last_pos, base);\n-            return token::LIT_FLOAT(str_to_ident(num_str), ast::TyF64);\n+            return token::LIT_FLOAT(str_to_ident(num_str.into_owned()),\n+                                    ast::TyF64);\n             /* FIXME (#2252): if this is out of range for either a\n             32-bit or 64-bit float, it won't be noticed till the\n             back-end.  */\n@@ -595,19 +600,22 @@ fn scan_number(c: char, rdr: &mut StringReader) -> token::Token {\n     }\n     if is_float {\n         check_float_base(rdr, start_bpos, rdr.last_pos, base);\n-        return token::LIT_FLOAT_UNSUFFIXED(str_to_ident(num_str));\n+        return token::LIT_FLOAT_UNSUFFIXED(str_to_ident(\n+                num_str.into_owned()));\n     } else {\n         if num_str.len() == 0u {\n             fatal_span(rdr, start_bpos, rdr.last_pos,\n                        ~\"no valid digits found for number\");\n         }\n-        let parsed = match from_str_radix::<u64>(num_str, base as uint) {\n+        let parsed = match from_str_radix::<u64>(num_str.as_slice(),\n+                                                 base as uint) {\n             Some(p) => p,\n             None => fatal_span(rdr, start_bpos, rdr.last_pos,\n                                ~\"int literal is too large\")\n         };\n \n-        debug!(\"lexing {} as an unsuffixed integer literal\", num_str);\n+        debug!(\"lexing {} as an unsuffixed integer literal\",\n+               num_str.as_slice());\n         return token::LIT_INT_UNSUFFIXED(parsed as i64);\n     }\n }\n@@ -863,7 +871,7 @@ fn next_token_inner(rdr: &mut StringReader) -> token::Token {\n         return token::LIT_CHAR(c2 as u32);\n       }\n       '\"' => {\n-        let mut accum_str = ~\"\";\n+        let mut accum_str = StrBuf::new();\n         let start_bpos = rdr.last_pos;\n         bump(rdr);\n         while !rdr.curr_is('\"') {\n@@ -912,7 +920,7 @@ fn next_token_inner(rdr: &mut StringReader) -> token::Token {\n             }\n         }\n         bump(rdr);\n-        return token::LIT_STR(str_to_ident(accum_str));\n+        return token::LIT_STR(str_to_ident(accum_str.as_slice()));\n       }\n       'r' => {\n         let start_bpos = rdr.last_pos;"}, {"sha": "704b6a50dc3a2cb2d79282ee3f2316967127579f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -79,6 +79,7 @@ use owned_slice::OwnedSlice;\n use collections::HashSet;\n use std::mem::replace;\n use std::rc::Rc;\n+use std::strbuf::StrBuf;\n \n #[allow(non_camel_case_types)]\n #[deriving(Eq)]\n@@ -4136,14 +4137,14 @@ impl<'a> Parser<'a> {\n         let mut included_mod_stack = self.sess.included_mod_stack.borrow_mut();\n         match included_mod_stack.iter().position(|p| *p == path) {\n             Some(i) => {\n-                let mut err = ~\"circular modules: \";\n+                let mut err = StrBuf::from_str(\"circular modules: \");\n                 let len = included_mod_stack.len();\n                 for p in included_mod_stack.slice(i, len).iter() {\n                     err.push_str(p.display().as_maybe_owned().as_slice());\n                     err.push_str(\" -> \");\n                 }\n                 err.push_str(path.display().as_maybe_owned().as_slice());\n-                self.span_fatal(id_sp, err);\n+                self.span_fatal(id_sp, err.into_owned());\n             }\n             None => ()\n         }\n@@ -4711,14 +4712,14 @@ impl<'a> Parser<'a> {\n \n         // FAILURE TO PARSE ITEM\n         if visibility != Inherited {\n-            let mut s = ~\"unmatched visibility `\";\n+            let mut s = StrBuf::from_str(\"unmatched visibility `\");\n             if visibility == Public {\n                 s.push_str(\"pub\")\n             } else {\n                 s.push_str(\"priv\")\n             }\n             s.push_char('`');\n-            self.span_fatal(self.last_span, s);\n+            self.span_fatal(self.last_span, s.as_slice());\n         }\n         return IoviNone(attrs);\n     }"}, {"sha": "baade21d942a64f37a068081d19a58edbc39c63a", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -23,6 +23,7 @@ use std::fmt;\n use std::local_data;\n use std::path::BytesContainer;\n use std::rc::Rc;\n+use std::strbuf::StrBuf;\n \n #[allow(non_camel_case_types)]\n #[deriving(Clone, Encodable, Decodable, Eq, TotalEq, Hash, Show)]\n@@ -193,12 +194,12 @@ pub fn to_str(t: &Token) -> ~str {\n \n       /* Literals */\n       LIT_CHAR(c) => {\n-          let mut res = ~\"'\";\n+          let mut res = StrBuf::from_str(\"'\");\n           char::from_u32(c).unwrap().escape_default(|c| {\n               res.push_char(c);\n           });\n           res.push_char('\\'');\n-          res\n+          res.into_owned()\n       }\n       LIT_INT(i, t) => {\n           i.to_str() + ast_util::int_ty_to_str(t)\n@@ -208,18 +209,19 @@ pub fn to_str(t: &Token) -> ~str {\n       }\n       LIT_INT_UNSUFFIXED(i) => { i.to_str() }\n       LIT_FLOAT(s, t) => {\n-        let mut body = get_ident(s).get().to_str();\n-        if body.ends_with(\".\") {\n+        let mut body = StrBuf::from_str(get_ident(s).get());\n+        if body.as_slice().ends_with(\".\") {\n             body.push_char('0');  // `10.f` is not a float literal\n         }\n-        body + ast_util::float_ty_to_str(t)\n+        body.push_str(ast_util::float_ty_to_str(t));\n+        body.into_owned()\n       }\n       LIT_FLOAT_UNSUFFIXED(s) => {\n-        let mut body = get_ident(s).get().to_str();\n-        if body.ends_with(\".\") {\n+        let mut body = StrBuf::from_str(get_ident(s).get());\n+        if body.as_slice().ends_with(\".\") {\n             body.push_char('0');  // `10.f` is not a float literal\n         }\n-        body\n+        body.into_owned()\n       }\n       LIT_STR(s) => {\n           format!(\"\\\"{}\\\"\", get_ident(s).get().escape_default())"}, {"sha": "6cd72cb58f1f7b7685dca81209e87242cd76a864", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -62,6 +62,7 @@\n  */\n \n use std::io;\n+use std::strbuf::StrBuf;\n \n #[deriving(Clone, Eq)]\n pub enum Breaks {\n@@ -118,13 +119,17 @@ pub fn tok_str(t: Token) -> ~str {\n     }\n }\n \n-pub fn buf_str(toks: Vec<Token> , szs: Vec<int> , left: uint, right: uint,\n-               lim: uint) -> ~str {\n+pub fn buf_str(toks: Vec<Token>,\n+               szs: Vec<int>,\n+               left: uint,\n+               right: uint,\n+               lim: uint)\n+               -> ~str {\n     let n = toks.len();\n     assert_eq!(n, szs.len());\n     let mut i = left;\n     let mut l = lim;\n-    let mut s = ~\"[\";\n+    let mut s = StrBuf::from_str(\"[\");\n     while i != right && l != 0u {\n         l -= 1u;\n         if i != left {\n@@ -135,7 +140,7 @@ pub fn buf_str(toks: Vec<Token> , szs: Vec<int> , left: uint, right: uint,\n         i %= n;\n     }\n     s.push_char(']');\n-    return s;\n+    return s.into_owned();\n }\n \n pub enum PrintStackBreak {"}, {"sha": "0d8cd02fc7affd9fcdbfbd33824e489244ef558d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -27,10 +27,11 @@ use print::pp;\n \n use std::cast;\n use std::char;\n-use std::str;\n-use std::io;\n use std::io::{IoResult, MemWriter};\n+use std::io;\n use std::rc::Rc;\n+use std::str;\n+use std::strbuf::StrBuf;\n \n pub enum AnnNode<'a> {\n     NodeBlock(&'a ast::Block),\n@@ -2156,10 +2157,10 @@ impl<'a> State<'a> {\n         match lit.node {\n             ast::LitStr(ref st, style) => self.print_string(st.get(), style),\n             ast::LitChar(ch) => {\n-                let mut res = ~\"'\";\n+                let mut res = StrBuf::from_str(\"'\");\n                 char::from_u32(ch).unwrap().escape_default(|c| res.push_char(c));\n                 res.push_char('\\'');\n-                word(&mut self.s, res)\n+                word(&mut self.s, res.into_owned())\n             }\n             ast::LitInt(i, t) => {\n                 word(&mut self.s, format!(\"{}{}\", i, ast_util::int_ty_to_str(t)))"}, {"sha": "8c6f7576ec4e040f861583d0255fe57c6e4294e7", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -59,6 +59,7 @@ use std::io::{File, ChanReader, ChanWriter};\n use std::io;\n use std::os;\n use std::str;\n+use std::strbuf::StrBuf;\n use std::task;\n \n // to be used by rustc to compile tests in libtest\n@@ -99,13 +100,19 @@ enum NamePadding { PadNone, PadOnLeft, PadOnRight }\n impl TestDesc {\n     fn padded_name(&self, column_count: uint, align: NamePadding) -> ~str {\n         use std::num::Saturating;\n-        let name = self.name.to_str();\n+        let mut name = StrBuf::from_str(self.name.to_str());\n         let fill = column_count.saturating_sub(name.len());\n-        let pad = \" \".repeat(fill);\n+        let mut pad = StrBuf::from_owned_str(\" \".repeat(fill));\n         match align {\n-            PadNone => name,\n-            PadOnLeft => pad.append(name),\n-            PadOnRight => name.append(pad),\n+            PadNone => name.into_owned(),\n+            PadOnLeft => {\n+                pad.push_str(name.as_slice());\n+                pad.into_owned()\n+            }\n+            PadOnRight => {\n+                name.push_str(pad.as_slice());\n+                name.into_owned()\n+            }\n         }\n     }\n }\n@@ -543,7 +550,7 @@ impl<T: Writer> ConsoleTestState<T> {\n     pub fn write_failures(&mut self) -> io::IoResult<()> {\n         try!(self.write_plain(\"\\nfailures:\\n\"));\n         let mut failures = Vec::new();\n-        let mut fail_out  = ~\"\";\n+        let mut fail_out = StrBuf::new();\n         for &(ref f, ref stdout) in self.failures.iter() {\n             failures.push(f.name.to_str());\n             if stdout.len() > 0 {\n@@ -556,7 +563,7 @@ impl<T: Writer> ConsoleTestState<T> {\n         }\n         if fail_out.len() > 0 {\n             try!(self.write_plain(\"\\n\"));\n-            try!(self.write_plain(fail_out));\n+            try!(self.write_plain(fail_out.as_slice()));\n         }\n \n         try!(self.write_plain(\"\\nfailures:\\n\"));"}, {"sha": "d50ecc2a2abf8c0981fc6c491b82380621969a99", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -24,6 +24,7 @@ extern crate libc;\n \n use std::io::BufReader;\n use std::num;\n+use std::strbuf::StrBuf;\n use std::str;\n \n static NSEC_PER_SEC: i32 = 1_000_000_000_i32;\n@@ -236,7 +237,10 @@ pub struct Tm {\n pub fn empty_tm() -> Tm {\n     // 64 is the max size of the timezone buffer allocated on windows\n     // in rust_localtime. In glibc the max timezone size is supposedly 3.\n-    let zone = str::with_capacity(64);\n+    let mut zone = StrBuf::new();\n+    for _ in range(0, 64) {\n+        zone.push_char(' ')\n+    }\n     Tm {\n         tm_sec: 0_i32,\n         tm_min: 0_i32,\n@@ -248,7 +252,7 @@ pub fn empty_tm() -> Tm {\n         tm_yday: 0_i32,\n         tm_isdst: 0_i32,\n         tm_gmtoff: 0_i32,\n-        tm_zone: zone,\n+        tm_zone: zone.into_owned(),\n         tm_nsec: 0_i32,\n     }\n }"}, {"sha": "1ea67f2bee1f2f6f947a6b856121a8b95d675692", "filename": "src/liburl/lib.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Fliburl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Fliburl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliburl%2Flib.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -21,15 +21,15 @@\n \n extern crate collections;\n \n+use collections::HashMap;\n use std::cmp::Eq;\n use std::fmt;\n+use std::from_str::FromStr;\n use std::hash::Hash;\n use std::io::BufReader;\n-use std::from_str::FromStr;\n+use std::strbuf::StrBuf;\n use std::uint;\n \n-use collections::HashMap;\n-\n /// A Uniform Resource Locator (URL).  A URL is a form of URI (Uniform Resource\n /// Identifier) that includes network location information, such as hostname or\n /// port number.\n@@ -133,7 +133,7 @@ impl UserInfo {\n \n fn encode_inner(s: &str, full_url: bool) -> ~str {\n     let mut rdr = BufReader::new(s.as_bytes());\n-    let mut out = ~\"\";\n+    let mut out = StrBuf::new();\n \n     loop {\n         let mut buf = [0];\n@@ -171,7 +171,7 @@ fn encode_inner(s: &str, full_url: bool) -> ~str {\n         }\n     }\n \n-    out\n+    out.into_owned()\n }\n \n /**\n@@ -206,7 +206,7 @@ pub fn encode_component(s: &str) -> ~str {\n \n fn decode_inner(s: &str, full_url: bool) -> ~str {\n     let mut rdr = BufReader::new(s.as_bytes());\n-    let mut out = ~\"\";\n+    let mut out = StrBuf::new();\n \n     loop {\n         let mut buf = [0];\n@@ -247,7 +247,7 @@ fn decode_inner(s: &str, full_url: bool) -> ~str {\n         }\n     }\n \n-    out\n+    out.into_owned()\n }\n \n /**\n@@ -277,7 +277,7 @@ pub fn decode_component(s: &str) -> ~str {\n \n fn encode_plus(s: &str) -> ~str {\n     let mut rdr = BufReader::new(s.as_bytes());\n-    let mut out = ~\"\";\n+    let mut out = StrBuf::new();\n \n     loop {\n         let mut buf = [0];\n@@ -294,14 +294,14 @@ fn encode_plus(s: &str) -> ~str {\n         }\n     }\n \n-    out\n+    out.into_owned()\n }\n \n /**\n  * Encode a hashmap to the 'application/x-www-form-urlencoded' media type.\n  */\n pub fn encode_form_urlencoded(m: &HashMap<~str, Vec<~str>>) -> ~str {\n-    let mut out = ~\"\";\n+    let mut out = StrBuf::new();\n     let mut first = true;\n \n     for (key, values) in m.iter() {\n@@ -319,18 +319,19 @@ pub fn encode_form_urlencoded(m: &HashMap<~str, Vec<~str>>) -> ~str {\n         }\n     }\n \n-    out\n+    out.into_owned()\n }\n \n /**\n  * Decode a string encoded with the 'application/x-www-form-urlencoded' media\n  * type into a hashmap.\n  */\n+#[allow(experimental)]\n pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<~str, Vec<~str>> {\n     let mut rdr = BufReader::new(s);\n-    let mut m = HashMap::new();\n-    let mut key = ~\"\";\n-    let mut value = ~\"\";\n+    let mut m: HashMap<~str,Vec<~str>> = HashMap::new();\n+    let mut key = StrBuf::new();\n+    let mut value = StrBuf::new();\n     let mut parsing_key = true;\n \n     loop {\n@@ -341,19 +342,19 @@ pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<~str, Vec<~str>> {\n         };\n         match ch {\n             '&' | ';' => {\n-                if key != ~\"\" && value != ~\"\" {\n-                    let mut values = match m.pop(&key) {\n+                if key.len() > 0 && value.len() > 0 {\n+                    let mut values = match m.pop_equiv(&key.as_slice()) {\n                         Some(values) => values,\n                         None => vec!(),\n                     };\n \n-                    values.push(value);\n-                    m.insert(key, values);\n+                    values.push(value.into_owned());\n+                    m.insert(key.into_owned(), values);\n                 }\n \n                 parsing_key = true;\n-                key = ~\"\";\n-                value = ~\"\";\n+                key = StrBuf::new();\n+                value = StrBuf::new();\n             }\n             '=' => parsing_key = false,\n             ch => {\n@@ -379,14 +380,14 @@ pub fn decode_form_urlencoded(s: &[u8]) -> HashMap<~str, Vec<~str>> {\n         }\n     }\n \n-    if key != ~\"\" && value != ~\"\" {\n-        let mut values = match m.pop(&key) {\n+    if key.len() > 0 && value.len() > 0 {\n+        let mut values = match m.pop_equiv(&key.as_slice()) {\n             Some(values) => values,\n             None => vec!(),\n         };\n \n-        values.push(value);\n-        m.insert(key, values);\n+        values.push(value.into_owned());\n+        m.insert(key.into_owned(), values);\n     }\n \n     m"}, {"sha": "18900abace69c551d62cae5d2a27f1782529c192", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -12,6 +12,7 @@\n \n use std::option;\n use std::os;\n+use std::strbuf::StrBuf;\n use std::task;\n \n fn print_complements() {\n@@ -40,12 +41,12 @@ fn show_color(cc: color) -> ~str {\n }\n \n fn show_color_list(set: Vec<color>) -> ~str {\n-    let mut out = ~\"\";\n+    let mut out = StrBuf::new();\n     for col in set.iter() {\n         out.push_char(' ');\n         out.push_str(show_color(*col));\n     }\n-    return out;\n+    return out.to_owned_str();\n }\n \n fn show_digit(nn: uint) -> ~str {"}, {"sha": "ca88f1073360cb87320975873b18b2e022d90e14", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -23,6 +23,7 @@ use std::option;\n use std::os;\n use std::io;\n use std::str;\n+use std::strbuf::StrBuf;\n use std::task;\n use std::vec;\n \n@@ -63,8 +64,7 @@ fn sort_and_fmt(mm: &HashMap<Vec<u8> , uint>, total: uint) -> ~str {\n \n    let pairs_sorted = sortKV(pairs);\n \n-   let mut buffer = ~\"\";\n-\n+   let mut buffer = StrBuf::new();\n    for &(ref k, v) in pairs_sorted.iter() {\n        unsafe {\n            buffer.push_str(format!(\"{} {:0.3f}\\n\",\n@@ -75,7 +75,7 @@ fn sort_and_fmt(mm: &HashMap<Vec<u8> , uint>, total: uint) -> ~str {\n        }\n    }\n \n-   return buffer;\n+   return buffer.to_owned_str();\n }\n \n // given a map, search for the frequency of a pattern"}, {"sha": "c9794d54829a4a87a67006da0d295ca8f6713082", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -13,6 +13,7 @@\n \n use std::ascii::OwnedStrAsciiExt;\n use std::str;\n+use std::strbuf::StrBuf;\n use std::slice;\n \n static TABLE: [u8, ..4] = [ 'A' as u8, 'C' as u8, 'G' as u8, 'T' as u8 ];\n@@ -249,13 +250,13 @@ fn print_occurrences(frequencies: &mut Table, occurrence: &'static str) {\n }\n \n fn get_sequence<R: Buffer>(r: &mut R, key: &str) -> ~[u8] {\n-    let mut res = ~\"\";\n+    let mut res = StrBuf::new();\n     for l in r.lines().map(|l| l.ok().unwrap())\n         .skip_while(|l| key != l.slice_to(key.len())).skip(1)\n     {\n         res.push_str(l.trim());\n     }\n-    res.into_ascii_upper().into_bytes()\n+    res.to_owned_str().into_ascii_upper().into_bytes()\n }\n \n fn main() {"}, {"sha": "458a95b91cf9cbdc6a51766097a1012b252fb30b", "filename": "src/test/run-fail/glob-use-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Ftest%2Frun-fail%2Fglob-use-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Ftest%2Frun-fail%2Fglob-use-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fglob-use-std.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -16,7 +16,7 @@\n use std::*;\n \n fn main() {\n-    str::with_capacity(10); // avoid an unused import message\n+    str::from_byte('a' as u8); // avoid an unused import message\n \n     fail!(\"fail works\")\n }"}, {"sha": "67cb87145db0bf368f2d9e3260fba3313bc8ae13", "filename": "src/test/run-pass/istr.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Ftest%2Frun-pass%2Fistr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Ftest%2Frun-pass%2Fistr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fistr.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::strbuf::StrBuf;\n+\n fn test_stack_assign() {\n     let s: ~str = ~\"a\";\n     println!(\"{}\", s.clone());\n@@ -43,21 +45,21 @@ fn test_heap_add() {\n }\n \n fn test_append() {\n-    let mut s = ~\"\";\n+    let mut s = StrBuf::new();\n     s.push_str(\"a\");\n-    assert_eq!(s, ~\"a\");\n+    assert_eq!(s.as_slice(), \"a\");\n \n-    let mut s = ~\"a\";\n+    let mut s = StrBuf::from_str(\"a\");\n     s.push_str(\"b\");\n     println!(\"{}\", s.clone());\n-    assert_eq!(s, ~\"ab\");\n+    assert_eq!(s.as_slice(), \"ab\");\n \n-    let mut s = ~\"c\";\n+    let mut s = StrBuf::from_str(\"c\");\n     s.push_str(\"offee\");\n-    assert!(s == ~\"coffee\");\n+    assert!(s.as_slice() == \"coffee\");\n \n     s.push_str(\"&tea\");\n-    assert!(s == ~\"coffee&tea\");\n+    assert!(s.as_slice() == \"coffee&tea\");\n }\n \n pub fn main() {"}, {"sha": "42b61695d602d71296b696e795bca81a01163db6", "filename": "src/test/run-pass/move-out-of-field.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Ftest%2Frun-pass%2Fmove-out-of-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Ftest%2Frun-pass%2Fmove-out-of-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmove-out-of-field.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -8,8 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::strbuf::StrBuf;\n+\n struct StringBuffer {\n-    s: ~str\n+    s: StrBuf,\n }\n \n impl StringBuffer {\n@@ -18,14 +20,16 @@ impl StringBuffer {\n     }\n }\n \n-fn to_str(sb: StringBuffer) -> ~str {\n+fn to_str(sb: StringBuffer) -> StrBuf {\n     sb.s\n }\n \n pub fn main() {\n-    let mut sb = StringBuffer {s: ~\"\"};\n+    let mut sb = StringBuffer {\n+        s: StrBuf::new(),\n+    };\n     sb.append(\"Hello, \");\n     sb.append(\"World!\");\n     let str = to_str(sb);\n-    assert_eq!(str, ~\"Hello, World!\");\n+    assert_eq!(str.as_slice(), \"Hello, World!\");\n }"}, {"sha": "6c66938af51f9ebcc79d45e4d8839ef37a42f223", "filename": "src/test/run-pass/overloaded-autoderef.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-autoderef.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -10,6 +10,7 @@\n \n use std::cell::RefCell;\n use std::rc::Rc;\n+use std::strbuf::StrBuf;\n \n #[deriving(Eq, Show)]\n struct Point {\n@@ -33,7 +34,7 @@ pub fn main() {\n     assert!(s.equiv(&(\"foo\")));\n     assert_eq!(s.as_slice(), \"foo\");\n \n-    let mut_s = Rc::new(RefCell::new(~\"foo\"));\n+    let mut_s = Rc::new(RefCell::new(StrBuf::from_str(\"foo\")));\n     mut_s.borrow_mut().push_str(\"bar\");\n     // HACK assert_eq! would fail here because it stores the LHS and RHS in two locals.\n     assert!(mut_s.borrow().as_slice() == \"foobar\");"}, {"sha": "27edb2f0088bc24110a9c76c093cf47e456ff82c", "filename": "src/test/run-pass/overloaded-deref.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Ftest%2Frun-pass%2Foverloaded-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Ftest%2Frun-pass%2Foverloaded-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foverloaded-deref.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -10,6 +10,7 @@\n \n use std::cell::RefCell;\n use std::rc::Rc;\n+use std::strbuf::StrBuf;\n \n #[deriving(Eq, Show)]\n struct Point {\n@@ -31,7 +32,7 @@ pub fn main() {\n     assert_eq!(*s, ~\"foo\");\n     assert_eq!((*s).as_slice(), \"foo\");\n \n-    let mut_s = Rc::new(RefCell::new(~\"foo\"));\n+    let mut_s = Rc::new(RefCell::new(StrBuf::from_str(\"foo\")));\n     (*(*mut_s).borrow_mut()).push_str(\"bar\");\n     // assert_eq! would fail here because it stores the LHS and RHS in two locals.\n     assert!((*(*mut_s).borrow()).as_slice() == \"foobar\");"}, {"sha": "ad6e668524cb2e003b3066bba15f2f8e28581ca5", "filename": "src/test/run-pass/str-append.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7fbcb400f0697621ece9f9773b0f0bf1ec73e9c1/src%2Ftest%2Frun-pass%2Fstr-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fbcb400f0697621ece9f9773b0f0bf1ec73e9c1/src%2Ftest%2Frun-pass%2Fstr-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstr-append.rs?ref=7fbcb400f0697621ece9f9773b0f0bf1ec73e9c1", "patch": "@@ -1,30 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-fn test1() {\n-    let mut s: ~str = ~\"hello\";\n-    s.push_str(\"world\");\n-    println!(\"{}\", s.clone());\n-    assert_eq!(s[9], 'd' as u8);\n-}\n-\n-fn test2() {\n-    // This tests for issue #163\n-\n-    let ff: ~str = ~\"abc\";\n-    let a: ~str = ff + \"ABC\" + ff;\n-    let b: ~str = ~\"ABC\" + ff + \"ABC\";\n-    println!(\"{}\", a.clone());\n-    println!(\"{}\", b.clone());\n-    assert_eq!(a, ~\"abcABCabc\");\n-    assert_eq!(b, ~\"ABCabcABC\");\n-}\n-\n-pub fn main() { test1(); test2(); }"}, {"sha": "0cdf1841331a8d36fbac057fbeaf9782dec85257", "filename": "src/test/run-pass/str-growth.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7fbcb400f0697621ece9f9773b0f0bf1ec73e9c1/src%2Ftest%2Frun-pass%2Fstr-growth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fbcb400f0697621ece9f9773b0f0bf1ec73e9c1/src%2Ftest%2Frun-pass%2Fstr-growth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstr-growth.rs?ref=7fbcb400f0697621ece9f9773b0f0bf1ec73e9c1", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-\n-pub fn main() {\n-    let mut s = ~\"a\";\n-    s.push_char('b');\n-    assert_eq!(s[0], 'a' as u8);\n-    assert_eq!(s[1], 'b' as u8);\n-    s.push_char('c');\n-    s.push_char('d');\n-    assert_eq!(s[0], 'a' as u8);\n-    assert_eq!(s[1], 'b' as u8);\n-    assert_eq!(s[2], 'c' as u8);\n-    assert_eq!(s[3], 'd' as u8);\n-}"}, {"sha": "a418cd0ae022d68694c74719a5295aca9a6c654a", "filename": "src/test/run-pass/utf8_chars.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Ftest%2Frun-pass%2Futf8_chars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8_chars.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -38,14 +38,4 @@ pub fn main() {\n     assert!((!str::is_utf8([0xf0_u8, 0x10_u8])));\n     assert!((!str::is_utf8([0xf0_u8, 0xff_u8, 0x10_u8])));\n     assert!((!str::is_utf8([0xf0_u8, 0xff_u8, 0xff_u8, 0x10_u8])));\n-\n-    let mut stack = ~\"a\u00d7c\u20ac\";\n-    assert_eq!(stack.pop_char(), Some('\u20ac'));\n-    assert_eq!(stack.pop_char(), Some('c'));\n-    stack.push_char('u');\n-    assert!(stack == ~\"a\u00d7u\");\n-    assert_eq!(stack.shift_char(), Some('a'));\n-    assert_eq!(stack.shift_char(), Some('\u00d7'));\n-    stack.unshift_char('\u00df');\n-    assert!(stack == ~\"\u00dfu\");\n }"}, {"sha": "358d296de495407808ad306beda858c50f1fa6c6", "filename": "src/test/run-pass/while-prelude-drop.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Ftest%2Frun-pass%2Fwhile-prelude-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260/src%2Ftest%2Frun-pass%2Fwhile-prelude-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhile-prelude-drop.rs?ref=d8e45ea7c054b4ad6fb82ec3a9fcf1736b4d7260", "patch": "@@ -8,13 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::strbuf::StrBuf;\n \n #[deriving(Eq)]\n-enum t { a, b(~str), }\n+enum t { a, b(StrBuf), }\n \n fn make(i: int) -> t {\n     if i > 10 { return a; }\n-    let mut s = ~\"hello\";\n+    let mut s = StrBuf::from_str(\"hello\");\n     // Ensure s is non-const.\n \n     s.push_str(\"there\");"}]}