{"sha": "f90de1110d93ea389342220caad19e05c4e6ad10", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5MGRlMTExMGQ5M2VhMzg5MzQyMjIwY2FhZDE5ZTA1YzRlNmFkMTA=", "commit": {"author": {"name": "Zack M. Davis", "email": "code@zackmdavis.net", "date": "2018-10-12T07:21:21Z"}, "committer": {"name": "Zack M. Davis", "email": "code@zackmdavis.net", "date": "2018-10-27T19:31:20Z"}, "message": "in which lint reasons are restricted to come last in the attribute\n\nVadim Petrochenkov suggested this in review (\"an error? just to be\nconservative\"), and it turns out to be convenient from the\nimplementer's perspective: in the initial proposed implementation (or\n`HEAD~2`, as some might prefer to call it), we were doing an entire\nwhole iteration over the meta items just to find the reason (before\niterating over them to set the actual lint levels). This way, we can\njust peek at the end rather than adding that extra loop (or\nrestructuring the existing code). The RFC doesn't seem to take a\nposition on this, and there's some precedent for restricting things to\nbe at the end of a sequence (we only allow `..` at the end of a struct\npattern, even if it would be possible to let it appear anywhere in the\nsequence).", "tree": {"sha": "7508a7b5f49ace9233668d9c027dacd968b8952d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7508a7b5f49ace9233668d9c027dacd968b8952d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f90de1110d93ea389342220caad19e05c4e6ad10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f90de1110d93ea389342220caad19e05c4e6ad10", "html_url": "https://github.com/rust-lang/rust/commit/f90de1110d93ea389342220caad19e05c4e6ad10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f90de1110d93ea389342220caad19e05c4e6ad10/comments", "author": {"login": "zackmdavis", "id": 1076988, "node_id": "MDQ6VXNlcjEwNzY5ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/1076988?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zackmdavis", "html_url": "https://github.com/zackmdavis", "followers_url": "https://api.github.com/users/zackmdavis/followers", "following_url": "https://api.github.com/users/zackmdavis/following{/other_user}", "gists_url": "https://api.github.com/users/zackmdavis/gists{/gist_id}", "starred_url": "https://api.github.com/users/zackmdavis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zackmdavis/subscriptions", "organizations_url": "https://api.github.com/users/zackmdavis/orgs", "repos_url": "https://api.github.com/users/zackmdavis/repos", "events_url": "https://api.github.com/users/zackmdavis/events{/privacy}", "received_events_url": "https://api.github.com/users/zackmdavis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zackmdavis", "id": 1076988, "node_id": "MDQ6VXNlcjEwNzY5ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/1076988?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zackmdavis", "html_url": "https://github.com/zackmdavis", "followers_url": "https://api.github.com/users/zackmdavis/followers", "following_url": "https://api.github.com/users/zackmdavis/following{/other_user}", "gists_url": "https://api.github.com/users/zackmdavis/gists{/gist_id}", "starred_url": "https://api.github.com/users/zackmdavis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zackmdavis/subscriptions", "organizations_url": "https://api.github.com/users/zackmdavis/orgs", "repos_url": "https://api.github.com/users/zackmdavis/repos", "events_url": "https://api.github.com/users/zackmdavis/events{/privacy}", "received_events_url": "https://api.github.com/users/zackmdavis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dc0609c2473c01f521c5a3b9959edf7dd11f2d86", "url": "https://api.github.com/repos/rust-lang/rust/commits/dc0609c2473c01f521c5a3b9959edf7dd11f2d86", "html_url": "https://github.com/rust-lang/rust/commit/dc0609c2473c01f521c5a3b9959edf7dd11f2d86"}], "stats": {"total": 105, "additions": 69, "deletions": 36}, "files": [{"sha": "d44facedc8b7c31a85a94972c874d69f1aedc40e", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 42, "deletions": 31, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/f90de1110d93ea389342220caad19e05c4e6ad10/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90de1110d93ea389342220caad19e05c4e6ad10/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=f90de1110d93ea389342220caad19e05c4e6ad10", "patch": "@@ -21,6 +21,7 @@ use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n use session::Session;\n use syntax::ast;\n use syntax::attr;\n+use syntax::feature_gate;\n use syntax::source_map::MultiSpan;\n use syntax::symbol::Symbol;\n use util::nodemap::FxHashMap;\n@@ -210,60 +211,70 @@ impl<'a> LintLevelsBuilder<'a> {\n             let meta = unwrap_or!(attr.meta(), continue);\n             attr::mark_used(attr);\n \n-            let metas = if let Some(metas) = meta.meta_item_list() {\n+            let mut metas = if let Some(metas) = meta.meta_item_list() {\n                 metas\n             } else {\n                 let mut err = bad_attr(meta.span);\n                 err.emit();\n                 continue\n             };\n \n-            // Before processing the lint names, look for a reason (RFC 2383).\n+            // Before processing the lint names, look for a reason (RFC 2383)\n+            // at the end.\n             let mut reason = None;\n-            for li in metas {\n-                if let Some(item) = li.meta_item() {\n-                    match item.node {\n-                        ast::MetaItemKind::Word => {}  // actual lint names handled later\n-                        ast::MetaItemKind::NameValue(ref name_value) => {\n-                            let gate_reasons = !self.sess.features_untracked().lint_reasons;\n-                            let name_ident = item.ident.segments[0].ident;\n-                            let name = name_ident.name.as_str();\n-\n-                            if name == \"reason\" {\n-                                if let ast::LitKind::Str(rationale, _) = name_value.node {\n-                                    if gate_reasons {\n-                                        feature_gate::emit_feature_err(\n-                                            &self.sess.parse_sess,\n-                                            \"lint_reasons\",\n-                                            item.span,\n-                                            feature_gate::GateIssue::Language,\n-                                            \"lint reasons are experimental\"\n-                                        );\n-                                    } else {\n-                                        reason = Some(rationale);\n-                                    }\n+            let tail_li = &metas[metas.len()-1];\n+            if let Some(item) = tail_li.meta_item() {\n+                match item.node {\n+                    ast::MetaItemKind::Word => {}  // actual lint names handled later\n+                    ast::MetaItemKind::NameValue(ref name_value) => {\n+                        let gate_reasons = !self.sess.features_untracked().lint_reasons;\n+                        if item.ident == \"reason\" {\n+                            // found reason, reslice meta list to exclude it\n+                            metas = &metas[0..metas.len()-1];\n+                            if let ast::LitKind::Str(rationale, _) = name_value.node {\n+                                if gate_reasons {\n+                                    feature_gate::emit_feature_err(\n+                                        &self.sess.parse_sess,\n+                                        \"lint_reasons\",\n+                                        item.span,\n+                                        feature_gate::GateIssue::Language,\n+                                        \"lint reasons are experimental\"\n+                                    );\n                                 } else {\n-                                    let mut err = bad_attr(name_value.span);\n-                                    err.help(\"reason must be a string literal\");\n-                                    err.emit();\n+                                    reason = Some(rationale);\n                                 }\n                             } else {\n-                                let mut err = bad_attr(item.span);\n+                                let mut err = bad_attr(name_value.span);\n+                                err.help(\"reason must be a string literal\");\n                                 err.emit();\n                             }\n-                        },\n-                        ast::MetaItemKind::List(_) => {\n+                        } else {\n                             let mut err = bad_attr(item.span);\n                             err.emit();\n                         }\n+                    },\n+                    ast::MetaItemKind::List(_) => {\n+                        let mut err = bad_attr(item.span);\n+                        err.emit();\n                     }\n                 }\n             }\n \n             for li in metas {\n                 let word = match li.word() {\n                     Some(word) => word,\n-                    None => { continue; }\n+                    None => {\n+                        let mut err = bad_attr(li.span);\n+                        if let Some(item) = li.meta_item() {\n+                            if let ast::MetaItemKind::NameValue(_) = item.node {\n+                                if item.ident == \"reason\" {\n+                                    err.help(\"reason in lint attribute must come last\");\n+                                }\n+                            }\n+                        }\n+                        err.emit();\n+                        continue;\n+                    }\n                 };\n                 let tool_name = if let Some(lint_tool) = word.is_scoped() {\n                     if !attr::is_known_lint_tool(lint_tool) {"}, {"sha": "e42b329338b5a2c71d47759b0e7051dd0ef1209d", "filename": "src/test/ui/lint/reasons-erroneous.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f90de1110d93ea389342220caad19e05c4e6ad10/src%2Ftest%2Fui%2Flint%2Freasons-erroneous.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f90de1110d93ea389342220caad19e05c4e6ad10/src%2Ftest%2Fui%2Flint%2Freasons-erroneous.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Freasons-erroneous.rs?ref=f90de1110d93ea389342220caad19e05c4e6ad10", "patch": "@@ -12,7 +12,13 @@\n //~^ ERROR malformed lint attribute\n #![warn(elided_lifetimes_in_paths, reason(\"disrespectful to ancestors\", \"irresponsible to heirs\"))]\n //~^ ERROR malformed lint attribute\n-#![warn(ellipsis_inclusive_range_patterns, reason)]\n+#![warn(ellipsis_inclusive_range_patterns, reason = \"born barren\", reason = \"a freak growth\")]\n+//~^ ERROR malformed lint attribute\n+//~| HELP reason in lint attribute must come last\n+#![warn(keyword_idents, reason = \"root in rubble\", macro_use_extern_crate)]\n+//~^ ERROR malformed lint attribute\n+//~| HELP reason in lint attribute must come last\n+#![warn(missing_copy_implementations, reason)]\n //~^ WARN unknown lint\n \n fn main() {}"}, {"sha": "6842686ecbab581a38343874bb5bdc2ec3c179a2", "filename": "src/test/ui/lint/reasons-erroneous.stderr", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f90de1110d93ea389342220caad19e05c4e6ad10/src%2Ftest%2Fui%2Flint%2Freasons-erroneous.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f90de1110d93ea389342220caad19e05c4e6ad10/src%2Ftest%2Fui%2Flint%2Freasons-erroneous.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Freasons-erroneous.stderr?ref=f90de1110d93ea389342220caad19e05c4e6ad10", "patch": "@@ -32,14 +32,30 @@ error[E0452]: malformed lint attribute\n LL | #![warn(elided_lifetimes_in_paths, reason(\"disrespectful to ancestors\", \"irresponsible to heirs\"))]\n    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-warning: unknown lint: `reason`\n+error[E0452]: malformed lint attribute\n   --> $DIR/reasons-erroneous.rs:15:44\n    |\n-LL | #![warn(ellipsis_inclusive_range_patterns, reason)]\n-   |                                            ^^^^^^\n+LL | #![warn(ellipsis_inclusive_range_patterns, reason = \"born barren\", reason = \"a freak growth\")]\n+   |                                            ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: reason in lint attribute must come last\n+\n+error[E0452]: malformed lint attribute\n+  --> $DIR/reasons-erroneous.rs:18:25\n+   |\n+LL | #![warn(keyword_idents, reason = \"root in rubble\", macro_use_extern_crate)]\n+   |                         ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: reason in lint attribute must come last\n+\n+warning: unknown lint: `reason`\n+  --> $DIR/reasons-erroneous.rs:21:39\n+   |\n+LL | #![warn(missing_copy_implementations, reason)]\n+   |                                       ^^^^^^\n    |\n    = note: #[warn(unknown_lints)] on by default\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 7 previous errors\n \n For more information about this error, try `rustc --explain E0452`."}]}