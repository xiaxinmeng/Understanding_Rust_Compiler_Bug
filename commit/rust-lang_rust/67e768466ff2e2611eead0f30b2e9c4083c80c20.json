{"sha": "67e768466ff2e2611eead0f30b2e9c4083c80c20", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3ZTc2ODQ2NmZmMmUyNjExZWVhZDBmMzBiMmU5YzQwODNjODBjMjA=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-12-24T14:40:11Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-12-24T14:40:11Z"}, "message": "Merge #327\n\n327: Beginnings of type inference r=flodiebold a=flodiebold\n\nI was a bit bored, so I thought I'd try to start implementing the type system and see how far I come :wink:  This is obviously still extremely WIP, only very basic stuff working, but I thought I'd post this now to get some feedback as to whether this approach makes sense at all.\r\n\r\nThere's no user-visible effect yet, but the type inference has tests similar to the ones for the parser. My next step will probably be to implement struct types, after which this could probably be used to complete fields.\r\n\r\nI realize this may all get thrown away when/if the compiler query system gets usable, but I feel like there are lots of IDE features that could be implemented with somewhat working type inference in the meantime :smile: \n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "8984028019837c91131fc30f60eecf8c2a457368", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8984028019837c91131fc30f60eecf8c2a457368"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67e768466ff2e2611eead0f30b2e9c4083c80c20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67e768466ff2e2611eead0f30b2e9c4083c80c20", "html_url": "https://github.com/rust-lang/rust/commit/67e768466ff2e2611eead0f30b2e9c4083c80c20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67e768466ff2e2611eead0f30b2e9c4083c80c20/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "abe09eb5edfe8f4c58baa16140acbd414635836f", "url": "https://api.github.com/repos/rust-lang/rust/commits/abe09eb5edfe8f4c58baa16140acbd414635836f", "html_url": "https://github.com/rust-lang/rust/commit/abe09eb5edfe8f4c58baa16140acbd414635836f"}, {"sha": "4befde1eee5b1e2b7ddc9bf764b77f82b792c318", "url": "https://api.github.com/repos/rust-lang/rust/commits/4befde1eee5b1e2b7ddc9bf764b77f82b792c318", "html_url": "https://github.com/rust-lang/rust/commit/4befde1eee5b1e2b7ddc9bf764b77f82b792c318"}], "stats": {"total": 1337, "additions": 1189, "deletions": 148}, "files": [{"sha": "51cf1825d6bf8cac7a12e0005257abb1334bcdd9", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/67e768466ff2e2611eead0f30b2e9c4083c80c20/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/67e768466ff2e2611eead0f30b2e9c4083c80c20/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=67e768466ff2e2611eead0f30b2e9c4083c80c20", "patch": "@@ -695,6 +695,7 @@ name = \"ra_hir\"\n version = \"0.1.0\"\n dependencies = [\n  \"arrayvec 0.4.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"flexi_logger 0.10.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"id-arena 2.0.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.6.4 (registry+https://github.com/rust-lang/crates.io-index)\","}, {"sha": "780a84291ac106e4c1850cadc93713b48d40e4de", "filename": "crates/ra_analysis/src/db.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb.rs?ref=67e768466ff2e2611eead0f30b2e9c4083c80c20", "patch": "@@ -93,6 +93,8 @@ salsa::database_storage! {\n             fn item_map() for hir::db::ItemMapQuery;\n             fn fn_syntax() for hir::db::FnSyntaxQuery;\n             fn submodules() for hir::db::SubmodulesQuery;\n+            fn infer() for hir::db::InferQuery;\n+            fn type_for_def() for hir::db::TypeForDefQuery;\n         }\n     }\n }"}, {"sha": "40996bfd738269cab2b3b9cc87c38278df0cc118", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=67e768466ff2e2611eead0f30b2e9c4083c80c20", "patch": "@@ -5,7 +5,8 @@ use std::{\n \n use ra_editor::{self, find_node_at_offset, FileSymbol, LineIndex, LocalEdit};\n use ra_syntax::{\n-    ast::{self, ArgListOwner, Expr, NameOwner},\n+    ast::{self, ArgListOwner, Expr, NameOwner, FnDef},\n+    algo::find_covering_node,\n     AstNode, SourceFileNode,\n     SyntaxKind::*,\n     SyntaxNodeRef, TextRange, TextUnit,\n@@ -510,6 +511,23 @@ impl AnalysisImpl {\n         Ok(None)\n     }\n \n+    pub fn type_of(&self, file_id: FileId, range: TextRange) -> Cancelable<Option<String>> {\n+        let file = self.db.source_file(file_id);\n+        let syntax = file.syntax();\n+        let node = find_covering_node(syntax, range);\n+        let parent_fn = node.ancestors().filter_map(FnDef::cast).next();\n+        let parent_fn = if let Some(p) = parent_fn {\n+            p\n+        } else {\n+            return Ok(None);\n+        };\n+        let function = ctry!(source_binder::function_from_source(\n+            &*self.db, file_id, parent_fn\n+        )?);\n+        let infer = function.infer(&*self.db)?;\n+        Ok(infer.type_of_node(node).map(|t| t.to_string()))\n+    }\n+\n     fn index_resolve(&self, name_ref: ast::NameRef) -> Cancelable<Vec<(FileId, FileSymbol)>> {\n         let name = name_ref.text();\n         let mut query = Query::new(name.to_string());"}, {"sha": "8308981405b52934ff9c911a845fd520ef41aa47", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=67e768466ff2e2611eead0f30b2e9c4083c80c20", "patch": "@@ -366,6 +366,9 @@ impl Analysis {\n     ) -> Cancelable<Option<(FnSignatureInfo, Option<usize>)>> {\n         self.imp.resolve_callable(position)\n     }\n+    pub fn type_of(&self, file_id: FileId, range: TextRange) -> Cancelable<Option<String>> {\n+        self.imp.type_of(file_id, range)\n+    }\n }\n \n pub struct LibraryData {"}, {"sha": "594176337d4b886656bd7977adc865076f80ade6", "filename": "crates/ra_hir/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2FCargo.toml?ref=67e768466ff2e2611eead0f30b2e9c4083c80c20", "patch": "@@ -16,3 +16,6 @@ ra_syntax = { path = \"../ra_syntax\" }\n ra_editor = { path = \"../ra_editor\" }\n ra_db = { path = \"../ra_db\" }\n test_utils = { path = \"../test_utils\" }\n+\n+[dev-dependencies]\n+flexi_logger = \"0.10.0\""}, {"sha": "d94f75857fca5b64b62b4cf89640716ee93e2f8e", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=67e768466ff2e2611eead0f30b2e9c4083c80c20", "patch": "@@ -14,6 +14,7 @@ use crate::{\n     function::FnId,\n     module::{ModuleId, ModuleTree, ModuleSource,\n     nameres::{ItemMap, InputModuleItems}},\n+    ty::{InferenceResult, Ty},\n };\n \n salsa::query_group! {\n@@ -30,6 +31,16 @@ pub trait HirDatabase: SyntaxDatabase\n         use fn query_definitions::fn_syntax;\n     }\n \n+    fn infer(fn_id: FnId) -> Cancelable<Arc<InferenceResult>> {\n+        type InferQuery;\n+        use fn query_definitions::infer;\n+    }\n+\n+    fn type_for_def(def_id: DefId) -> Cancelable<Ty> {\n+        type TypeForDefQuery;\n+        use fn query_definitions::type_for_def;\n+    }\n+\n     fn file_items(file_id: FileId) -> Arc<SourceFileItems> {\n         type SourceFileItemsQuery;\n         use fn query_definitions::file_items;"}, {"sha": "d36477b48d1dbb045fbda5f524d5fcb082fcc7c4", "filename": "crates/ra_hir/src/function.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_hir%2Fsrc%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_hir%2Fsrc%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Ffunction.rs?ref=67e768466ff2e2611eead0f30b2e9c4083c80c20", "patch": "@@ -5,20 +5,21 @@ use std::{\n     sync::Arc,\n };\n \n+use ra_db::Cancelable;\n use ra_syntax::{\n     TextRange, TextUnit,\n     ast::{self, AstNode, DocCommentsOwner, NameOwner},\n };\n \n-use crate::{ DefId, HirDatabase };\n+use crate::{ DefId, HirDatabase, ty::InferenceResult, Module };\n \n pub use self::scope::FnScopes;\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub struct FnId(pub(crate) DefId);\n \n pub struct Function {\n-    fn_id: FnId,\n+    pub(crate) fn_id: FnId,\n }\n \n impl Function {\n@@ -27,6 +28,10 @@ impl Function {\n         Function { fn_id }\n     }\n \n+    pub fn syntax(&self, db: &impl HirDatabase) -> ast::FnDefNode {\n+        db.fn_syntax(self.fn_id)\n+    }\n+\n     pub fn scopes(&self, db: &impl HirDatabase) -> Arc<FnScopes> {\n         db.fn_scopes(self.fn_id)\n     }\n@@ -35,6 +40,15 @@ impl Function {\n         let syntax = db.fn_syntax(self.fn_id);\n         FnSignatureInfo::new(syntax.borrowed())\n     }\n+\n+    pub fn infer(&self, db: &impl HirDatabase) -> Cancelable<Arc<InferenceResult>> {\n+        db.infer(self.fn_id)\n+    }\n+\n+    pub fn module(&self, db: &impl HirDatabase) -> Cancelable<Module> {\n+        let loc = self.fn_id.0.loc(db);\n+        Module::new(db, loc.source_root_id, loc.module_id)\n+    }\n }\n \n #[derive(Debug, Clone)]"}, {"sha": "a0d99a84dfa556d69b6b52b2554de28a302a64ca", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=67e768466ff2e2611eead0f30b2e9c4083c80c20", "patch": "@@ -25,10 +25,11 @@ pub mod source_binder;\n mod krate;\n mod module;\n mod function;\n+mod ty;\n \n use std::ops::Index;\n \n-use ra_syntax::{SyntaxNodeRef, SyntaxNode};\n+use ra_syntax::{SyntaxNodeRef, SyntaxNode, SyntaxKind};\n use ra_db::{LocationIntener, SourceRootId, FileId, Cancelable};\n \n use crate::{\n@@ -66,6 +67,23 @@ pub struct DefLoc {\n     source_item_id: SourceItemId,\n }\n \n+impl DefKind {\n+    pub(crate) fn for_syntax_kind(kind: SyntaxKind) -> Option<DefKind> {\n+        match kind {\n+            SyntaxKind::FN_DEF => Some(DefKind::Function),\n+            SyntaxKind::MODULE => Some(DefKind::Module),\n+            // These define items, but don't have their own DefKinds yet:\n+            SyntaxKind::STRUCT_DEF => Some(DefKind::Item),\n+            SyntaxKind::ENUM_DEF => Some(DefKind::Item),\n+            SyntaxKind::TRAIT_DEF => Some(DefKind::Item),\n+            SyntaxKind::TYPE_DEF => Some(DefKind::Item),\n+            SyntaxKind::CONST_DEF => Some(DefKind::Item),\n+            SyntaxKind::STATIC_DEF => Some(DefKind::Item),\n+            _ => None,\n+        }\n+    }\n+}\n+\n impl DefId {\n     pub(crate) fn loc(self, db: &impl AsRef<LocationIntener<DefLoc, DefId>>) -> DefLoc {\n         db.as_ref().id2loc(self)"}, {"sha": "b5a99717072ac8835dc10c025287e34a98fc7959", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=67e768466ff2e2611eead0f30b2e9c4083c80c20", "patch": "@@ -8,7 +8,7 @@ use test_utils::{parse_fixture, CURSOR_MARKER, extract_offset};\n \n use crate::{db, DefId, DefLoc};\n \n-const WORKSPACE: SourceRootId = SourceRootId(0);\n+pub const WORKSPACE: SourceRootId = SourceRootId(0);\n \n #[derive(Debug)]\n pub(crate) struct MockDatabase {\n@@ -24,6 +24,15 @@ impl MockDatabase {\n         (db, source_root)\n     }\n \n+    pub(crate) fn with_single_file(text: &str) -> (MockDatabase, SourceRoot, FileId) {\n+        let mut db = MockDatabase::default();\n+        let mut source_root = SourceRoot::default();\n+        let file_id = db.add_file(&mut source_root, \"/main.rs\", text);\n+        db.query_mut(ra_db::SourceRootQuery)\n+            .set(WORKSPACE, Arc::new(source_root.clone()));\n+        (db, source_root, file_id)\n+    }\n+\n     pub(crate) fn with_position(fixture: &str) -> (MockDatabase, FilePosition) {\n         let (db, _, position) = MockDatabase::from_fixture(fixture);\n         let position = position.expect(\"expected a marker ( <|> )\");\n@@ -182,6 +191,8 @@ salsa::database_storage! {\n             fn item_map() for db::ItemMapQuery;\n             fn fn_syntax() for db::FnSyntaxQuery;\n             fn submodules() for db::SubmodulesQuery;\n+            fn infer() for db::InferQuery;\n+            fn type_for_def() for db::TypeForDefQuery;\n         }\n     }\n }"}, {"sha": "89111995306d5cca58ee57029c6dfb665f38f725", "filename": "crates/ra_hir/src/module.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_hir%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_hir%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule.rs?ref=67e768466ff2e2611eead0f30b2e9c4083c80c20", "patch": "@@ -2,6 +2,7 @@ pub(super) mod imp;\n pub(super) mod nameres;\n \n use std::sync::Arc;\n+use log;\n \n use ra_syntax::{\n     algo::generate,"}, {"sha": "0b152a406230ab94005589b0afd4dd71c93c70bc", "filename": "crates/ra_hir/src/module/nameres.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule%2Fnameres.rs?ref=67e768466ff2e2611eead0f30b2e9c4083c80c20", "patch": "@@ -272,13 +272,13 @@ where\n                 }\n             }\n         }\n-        // Populate explicitelly declared items, except modules\n+        // Populate explicitly declared items, except modules\n         for item in input.items.iter() {\n             if item.kind == MODULE {\n                 continue;\n             }\n             let def_loc = DefLoc {\n-                kind: DefKind::Item,\n+                kind: DefKind::for_syntax_kind(item.kind).unwrap_or(DefKind::Item),\n                 source_root_id: self.source_root,\n                 module_id,\n                 source_item_id: SourceItemId {"}, {"sha": "b654af9204f35fb8b60801d7b23748cc77a8f3bd", "filename": "crates/ra_hir/src/query_definitions.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fquery_definitions.rs?ref=67e768466ff2e2611eead0f30b2e9c4083c80c20", "patch": "@@ -11,14 +11,15 @@ use ra_syntax::{\n use ra_db::{SourceRootId, FileId, Cancelable,};\n \n use crate::{\n-    SourceFileItems, SourceItemId, DefKind,\n+    SourceFileItems, SourceItemId, DefKind, Function, DefId,\n     db::HirDatabase,\n     function::{FnScopes, FnId},\n     module::{\n         ModuleSource, ModuleSourceNode, ModuleId,\n         imp::Submodule,\n         nameres::{InputModuleItems, ItemMap, Resolver},\n     },\n+    ty::{self, InferenceResult, Ty}\n };\n \n /// Resolve `FnId` to the corresponding `SyntaxNode`\n@@ -35,6 +36,15 @@ pub(super) fn fn_scopes(db: &impl HirDatabase, fn_id: FnId) -> Arc<FnScopes> {\n     Arc::new(res)\n }\n \n+pub(super) fn infer(db: &impl HirDatabase, fn_id: FnId) -> Cancelable<Arc<InferenceResult>> {\n+    let function = Function { fn_id };\n+    ty::infer(db, function).map(Arc::new)\n+}\n+\n+pub(super) fn type_for_def(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Ty> {\n+    ty::type_for_def(db, def_id)\n+}\n+\n pub(super) fn file_items(db: &impl HirDatabase, file_id: FileId) -> Arc<SourceFileItems> {\n     let mut res = SourceFileItems::new(file_id);\n     let source_file = db.source_file(file_id);"}, {"sha": "c759d4c8b1d7a983146438cd00c3cf268540e58f", "filename": "crates/ra_hir/src/ty.rs", "status": "added", "additions": 601, "deletions": 0, "changes": 601, "blob_url": "https://github.com/rust-lang/rust/blob/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=67e768466ff2e2611eead0f30b2e9c4083c80c20", "patch": "@@ -0,0 +1,601 @@\n+mod primitive;\n+#[cfg(test)]\n+mod tests;\n+\n+use std::sync::Arc;\n+use std::fmt;\n+\n+use log;\n+use rustc_hash::{FxHashMap};\n+\n+use ra_db::{LocalSyntaxPtr, Cancelable};\n+use ra_syntax::{\n+    SmolStr,\n+    ast::{self, AstNode, LoopBodyOwner, ArgListOwner},\n+    SyntaxNodeRef\n+};\n+\n+use crate::{Def, DefId, FnScopes, Module, Function, Path, db::HirDatabase};\n+\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+pub enum Ty {\n+    /// The primitive boolean type. Written as `bool`.\n+    Bool,\n+\n+    /// The primitive character type; holds a Unicode scalar value\n+    /// (a non-surrogate code point).  Written as `char`.\n+    Char,\n+\n+    /// A primitive signed integer type. For example, `i32`.\n+    Int(primitive::IntTy),\n+\n+    /// A primitive unsigned integer type. For example, `u32`.\n+    Uint(primitive::UintTy),\n+\n+    /// A primitive floating-point type. For example, `f64`.\n+    Float(primitive::FloatTy),\n+\n+    // Structures, enumerations and unions.\n+    // Adt(AdtDef, Substs),\n+    /// The pointee of a string slice. Written as `str`.\n+    Str,\n+\n+    // An array with the given length. Written as `[T; n]`.\n+    // Array(Ty, ty::Const),\n+    /// The pointee of an array slice.  Written as `[T]`.\n+    Slice(TyRef),\n+\n+    // A raw pointer. Written as `*mut T` or `*const T`\n+    // RawPtr(TypeAndMut<'tcx>),\n+\n+    // A reference; a pointer with an associated lifetime. Written as\n+    // `&'a mut T` or `&'a T`.\n+    // Ref(Ty<'tcx>, hir::Mutability),\n+    /// A pointer to a function.  Written as `fn() -> i32`.\n+    ///\n+    /// For example the type of `bar` here:\n+    ///\n+    /// ```rust\n+    /// fn foo() -> i32 { 1 }\n+    /// let bar: fn() -> i32 = foo;\n+    /// ```\n+    FnPtr(Arc<FnSig>),\n+\n+    // A trait, defined with `dyn trait`.\n+    // Dynamic(),\n+    /// The anonymous type of a closure. Used to represent the type of\n+    /// `|a| a`.\n+    // Closure(DefId, ClosureSubsts<'tcx>),\n+\n+    /// The anonymous type of a generator. Used to represent the type of\n+    /// `|a| yield a`.\n+    // Generator(DefId, GeneratorSubsts<'tcx>, hir::GeneratorMovability),\n+\n+    /// A type representin the types stored inside a generator.\n+    /// This should only appear in GeneratorInteriors.\n+    // GeneratorWitness(Binder<&'tcx List<Ty<'tcx>>>),\n+\n+    /// The never type `!`\n+    Never,\n+\n+    /// A tuple type.  For example, `(i32, bool)`.\n+    Tuple(Vec<Ty>),\n+\n+    // The projection of an associated type.  For example,\n+    // `<T as Trait<..>>::N`.\n+    // Projection(ProjectionTy),\n+\n+    // Opaque (`impl Trait`) type found in a return type.\n+    // The `DefId` comes either from\n+    // * the `impl Trait` ast::Ty node,\n+    // * or the `existential type` declaration\n+    // The substitutions are for the generics of the function in question.\n+    // Opaque(DefId, Substs),\n+\n+    // A type parameter; for example, `T` in `fn f<T>(x: T) {}\n+    // Param(ParamTy),\n+\n+    // A placeholder type - universally quantified higher-ranked type.\n+    // Placeholder(ty::PlaceholderType),\n+\n+    // A type variable used during type checking.\n+    // Infer(InferTy),\n+    /// A placeholder for a type which could not be computed; this is\n+    /// propagated to avoid useless error messages.\n+    Unknown,\n+}\n+\n+type TyRef = Arc<Ty>;\n+\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n+pub struct FnSig {\n+    input: Vec<Ty>,\n+    output: Ty,\n+}\n+\n+impl Ty {\n+    pub fn new(_db: &impl HirDatabase, node: ast::TypeRef) -> Cancelable<Self> {\n+        use ra_syntax::ast::TypeRef::*;\n+        Ok(match node {\n+            ParenType(_inner) => Ty::Unknown, // TODO\n+            TupleType(_inner) => Ty::Unknown, // TODO\n+            NeverType(..) => Ty::Never,\n+            PathType(inner) => {\n+                let path = if let Some(p) = inner.path() {\n+                    p\n+                } else {\n+                    return Ok(Ty::Unknown);\n+                };\n+                if path.qualifier().is_none() {\n+                    let name = path\n+                        .segment()\n+                        .and_then(|s| s.name_ref())\n+                        .map(|n| n.text())\n+                        .unwrap_or(SmolStr::new(\"\"));\n+                    if let Some(int_ty) = primitive::IntTy::from_string(&name) {\n+                        Ty::Int(int_ty)\n+                    } else if let Some(uint_ty) = primitive::UintTy::from_string(&name) {\n+                        Ty::Uint(uint_ty)\n+                    } else if let Some(float_ty) = primitive::FloatTy::from_string(&name) {\n+                        Ty::Float(float_ty)\n+                    } else {\n+                        // TODO\n+                        Ty::Unknown\n+                    }\n+                } else {\n+                    // TODO\n+                    Ty::Unknown\n+                }\n+            }\n+            PointerType(_inner) => Ty::Unknown,     // TODO\n+            ArrayType(_inner) => Ty::Unknown,       // TODO\n+            SliceType(_inner) => Ty::Unknown,       // TODO\n+            ReferenceType(_inner) => Ty::Unknown,   // TODO\n+            PlaceholderType(_inner) => Ty::Unknown, // TODO\n+            FnPointerType(_inner) => Ty::Unknown,   // TODO\n+            ForType(_inner) => Ty::Unknown,         // TODO\n+            ImplTraitType(_inner) => Ty::Unknown,   // TODO\n+            DynTraitType(_inner) => Ty::Unknown,    // TODO\n+        })\n+    }\n+\n+    pub fn unit() -> Self {\n+        Ty::Tuple(Vec::new())\n+    }\n+}\n+\n+impl fmt::Display for Ty {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self {\n+            Ty::Bool => write!(f, \"bool\"),\n+            Ty::Char => write!(f, \"char\"),\n+            Ty::Int(t) => write!(f, \"{}\", t.ty_to_string()),\n+            Ty::Uint(t) => write!(f, \"{}\", t.ty_to_string()),\n+            Ty::Float(t) => write!(f, \"{}\", t.ty_to_string()),\n+            Ty::Str => write!(f, \"str\"),\n+            Ty::Slice(t) => write!(f, \"[{}]\", t),\n+            Ty::Never => write!(f, \"!\"),\n+            Ty::Tuple(ts) => {\n+                write!(f, \"(\")?;\n+                for t in ts {\n+                    write!(f, \"{},\", t)?;\n+                }\n+                write!(f, \")\")\n+            }\n+            Ty::FnPtr(sig) => {\n+                write!(f, \"fn(\")?;\n+                for t in &sig.input {\n+                    write!(f, \"{},\", t)?;\n+                }\n+                write!(f, \") -> {}\", sig.output)\n+            }\n+            Ty::Unknown => write!(f, \"[unknown]\"),\n+        }\n+    }\n+}\n+\n+pub fn type_for_fn(db: &impl HirDatabase, f: Function) -> Cancelable<Ty> {\n+    let syntax = f.syntax(db);\n+    let node = syntax.borrowed();\n+    // TODO we ignore type parameters for now\n+    let input = node\n+        .param_list()\n+        .map(|pl| {\n+            pl.params()\n+                .map(|p| {\n+                    p.type_ref()\n+                        .map(|t| Ty::new(db, t))\n+                        .unwrap_or(Ok(Ty::Unknown))\n+                })\n+                .collect()\n+        })\n+        .unwrap_or_else(|| Ok(Vec::new()))?;\n+    let output = node\n+        .ret_type()\n+        .and_then(|rt| rt.type_ref())\n+        .map(|t| Ty::new(db, t))\n+        .unwrap_or(Ok(Ty::Unknown))?;\n+    let sig = FnSig { input, output };\n+    Ok(Ty::FnPtr(Arc::new(sig)))\n+}\n+\n+// TODO this should probably be per namespace (i.e. types vs. values), since for\n+// a tuple struct `struct Foo(Bar)`, Foo has function type as a value, but\n+// defines the struct type Foo when used in the type namespace. rustc has a\n+// separate DefId for the constructor, but with the current DefId approach, that\n+// seems complicated.\n+pub fn type_for_def(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Ty> {\n+    let def = def_id.resolve(db)?;\n+    match def {\n+        Def::Module(..) => {\n+            log::debug!(\"trying to get type for module {:?}\", def_id);\n+            Ok(Ty::Unknown)\n+        }\n+        Def::Function(f) => type_for_fn(db, f),\n+        Def::Item => {\n+            log::debug!(\"trying to get type for item of unknown type {:?}\", def_id);\n+            Ok(Ty::Unknown)\n+        }\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Debug)]\n+pub struct InferenceResult {\n+    type_of: FxHashMap<LocalSyntaxPtr, Ty>,\n+}\n+\n+impl InferenceResult {\n+    pub fn type_of_node(&self, node: SyntaxNodeRef) -> Option<Ty> {\n+        self.type_of.get(&LocalSyntaxPtr::new(node)).cloned()\n+    }\n+}\n+\n+#[derive(Clone, Debug)]\n+pub struct InferenceContext<'a, D: HirDatabase> {\n+    db: &'a D,\n+    scopes: Arc<FnScopes>,\n+    module: Module,\n+    // TODO unification tables...\n+    type_of: FxHashMap<LocalSyntaxPtr, Ty>,\n+}\n+\n+impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n+    fn new(db: &'a D, scopes: Arc<FnScopes>, module: Module) -> Self {\n+        InferenceContext {\n+            type_of: FxHashMap::default(),\n+            db,\n+            scopes,\n+            module,\n+        }\n+    }\n+\n+    fn write_ty(&mut self, node: SyntaxNodeRef, ty: Ty) {\n+        self.type_of.insert(LocalSyntaxPtr::new(node), ty);\n+    }\n+\n+    fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> Option<Ty> {\n+        if *ty1 == Ty::Unknown {\n+            return Some(ty2.clone());\n+        }\n+        if *ty2 == Ty::Unknown {\n+            return Some(ty1.clone());\n+        }\n+        if ty1 == ty2 {\n+            return Some(ty1.clone());\n+        }\n+        // TODO implement actual unification\n+        return None;\n+    }\n+\n+    fn unify_with_coercion(&mut self, ty1: &Ty, ty2: &Ty) -> Option<Ty> {\n+        // TODO implement coercion\n+        self.unify(ty1, ty2)\n+    }\n+\n+    fn infer_path_expr(&mut self, expr: ast::PathExpr) -> Cancelable<Option<Ty>> {\n+        let ast_path = ctry!(expr.path());\n+        let path = ctry!(Path::from_ast(ast_path));\n+        if path.is_ident() {\n+            // resolve locally\n+            let name = ctry!(ast_path.segment().and_then(|s| s.name_ref()));\n+            if let Some(scope_entry) = self.scopes.resolve_local_name(name) {\n+                let ty = ctry!(self.type_of.get(&scope_entry.ptr()));\n+                return Ok(Some(ty.clone()));\n+            };\n+        };\n+\n+        // resolve in module\n+        let resolved = ctry!(self.module.resolve_path(self.db, path)?);\n+        let ty = self.db.type_for_def(resolved)?;\n+        // TODO we will need to add type variables for type parameters etc. here\n+        Ok(Some(ty))\n+    }\n+\n+    fn infer_expr(&mut self, expr: ast::Expr) -> Cancelable<Ty> {\n+        let ty = match expr {\n+            ast::Expr::IfExpr(e) => {\n+                if let Some(condition) = e.condition() {\n+                    if let Some(e) = condition.expr() {\n+                        // TODO if no pat, this should be bool\n+                        self.infer_expr(e)?;\n+                    }\n+                    // TODO write type for pat\n+                };\n+                let if_ty = if let Some(block) = e.then_branch() {\n+                    self.infer_block(block)?\n+                } else {\n+                    Ty::Unknown\n+                };\n+                let else_ty = if let Some(block) = e.else_branch() {\n+                    self.infer_block(block)?\n+                } else {\n+                    Ty::Unknown\n+                };\n+                if let Some(ty) = self.unify(&if_ty, &else_ty) {\n+                    ty\n+                } else {\n+                    // TODO report diagnostic\n+                    Ty::Unknown\n+                }\n+            }\n+            ast::Expr::BlockExpr(e) => {\n+                if let Some(block) = e.block() {\n+                    self.infer_block(block)?\n+                } else {\n+                    Ty::Unknown\n+                }\n+            }\n+            ast::Expr::LoopExpr(e) => {\n+                if let Some(block) = e.loop_body() {\n+                    self.infer_block(block)?;\n+                };\n+                // TODO never, or the type of the break param\n+                Ty::Unknown\n+            }\n+            ast::Expr::WhileExpr(e) => {\n+                if let Some(condition) = e.condition() {\n+                    if let Some(e) = condition.expr() {\n+                        // TODO if no pat, this should be bool\n+                        self.infer_expr(e)?;\n+                    }\n+                    // TODO write type for pat\n+                };\n+                if let Some(block) = e.loop_body() {\n+                    // TODO\n+                    self.infer_block(block)?;\n+                };\n+                // TODO always unit?\n+                Ty::Unknown\n+            }\n+            ast::Expr::ForExpr(e) => {\n+                if let Some(expr) = e.iterable() {\n+                    self.infer_expr(expr)?;\n+                }\n+                if let Some(_pat) = e.pat() {\n+                    // TODO write type for pat\n+                }\n+                if let Some(block) = e.loop_body() {\n+                    self.infer_block(block)?;\n+                }\n+                // TODO always unit?\n+                Ty::Unknown\n+            }\n+            ast::Expr::LambdaExpr(e) => {\n+                let _body_ty = if let Some(body) = e.body() {\n+                    self.infer_expr(body)?\n+                } else {\n+                    Ty::Unknown\n+                };\n+                Ty::Unknown\n+            }\n+            ast::Expr::CallExpr(e) => {\n+                let callee_ty = if let Some(e) = e.expr() {\n+                    self.infer_expr(e)?\n+                } else {\n+                    Ty::Unknown\n+                };\n+                if let Some(arg_list) = e.arg_list() {\n+                    for arg in arg_list.args() {\n+                        // TODO unify / expect argument type\n+                        self.infer_expr(arg)?;\n+                    }\n+                }\n+                match callee_ty {\n+                    Ty::FnPtr(sig) => sig.output.clone(),\n+                    _ => {\n+                        // not callable\n+                        // TODO report an error?\n+                        Ty::Unknown\n+                    }\n+                }\n+            }\n+            ast::Expr::MethodCallExpr(e) => {\n+                let _receiver_ty = if let Some(e) = e.expr() {\n+                    self.infer_expr(e)?\n+                } else {\n+                    Ty::Unknown\n+                };\n+                if let Some(arg_list) = e.arg_list() {\n+                    for arg in arg_list.args() {\n+                        // TODO unify / expect argument type\n+                        self.infer_expr(arg)?;\n+                    }\n+                }\n+                Ty::Unknown\n+            }\n+            ast::Expr::MatchExpr(e) => {\n+                let _ty = if let Some(match_expr) = e.expr() {\n+                    self.infer_expr(match_expr)?\n+                } else {\n+                    Ty::Unknown\n+                };\n+                if let Some(match_arm_list) = e.match_arm_list() {\n+                    for arm in match_arm_list.arms() {\n+                        // TODO type the bindings in pat\n+                        // TODO type the guard\n+                        let _ty = if let Some(e) = arm.expr() {\n+                            self.infer_expr(e)?\n+                        } else {\n+                            Ty::Unknown\n+                        };\n+                    }\n+                    // TODO unify all the match arm types\n+                    Ty::Unknown\n+                } else {\n+                    Ty::Unknown\n+                }\n+            }\n+            ast::Expr::TupleExpr(_e) => Ty::Unknown,\n+            ast::Expr::ArrayExpr(_e) => Ty::Unknown,\n+            ast::Expr::PathExpr(e) => self.infer_path_expr(e)?.unwrap_or(Ty::Unknown),\n+            ast::Expr::ContinueExpr(_e) => Ty::Never,\n+            ast::Expr::BreakExpr(_e) => Ty::Never,\n+            ast::Expr::ParenExpr(e) => {\n+                if let Some(e) = e.expr() {\n+                    self.infer_expr(e)?\n+                } else {\n+                    Ty::Unknown\n+                }\n+            }\n+            ast::Expr::Label(_e) => Ty::Unknown,\n+            ast::Expr::ReturnExpr(e) => {\n+                if let Some(e) = e.expr() {\n+                    // TODO unify with return type\n+                    self.infer_expr(e)?;\n+                };\n+                Ty::Never\n+            }\n+            ast::Expr::MatchArmList(_) | ast::Expr::MatchArm(_) | ast::Expr::MatchGuard(_) => {\n+                // Can this even occur outside of a match expression?\n+                Ty::Unknown\n+            }\n+            ast::Expr::StructLit(_e) => Ty::Unknown,\n+            ast::Expr::NamedFieldList(_) | ast::Expr::NamedField(_) => {\n+                // Can this even occur outside of a struct literal?\n+                Ty::Unknown\n+            }\n+            ast::Expr::IndexExpr(_e) => Ty::Unknown,\n+            ast::Expr::FieldExpr(_e) => Ty::Unknown,\n+            ast::Expr::TryExpr(e) => {\n+                let _inner_ty = if let Some(e) = e.expr() {\n+                    self.infer_expr(e)?\n+                } else {\n+                    Ty::Unknown\n+                };\n+                Ty::Unknown\n+            }\n+            ast::Expr::CastExpr(e) => {\n+                let _inner_ty = if let Some(e) = e.expr() {\n+                    self.infer_expr(e)?\n+                } else {\n+                    Ty::Unknown\n+                };\n+                let cast_ty = e\n+                    .type_ref()\n+                    .map(|t| Ty::new(self.db, t))\n+                    .unwrap_or(Ok(Ty::Unknown))?;\n+                // TODO do the coercion...\n+                cast_ty\n+            }\n+            ast::Expr::RefExpr(e) => {\n+                let _inner_ty = if let Some(e) = e.expr() {\n+                    self.infer_expr(e)?\n+                } else {\n+                    Ty::Unknown\n+                };\n+                Ty::Unknown\n+            }\n+            ast::Expr::PrefixExpr(e) => {\n+                let _inner_ty = if let Some(e) = e.expr() {\n+                    self.infer_expr(e)?\n+                } else {\n+                    Ty::Unknown\n+                };\n+                Ty::Unknown\n+            }\n+            ast::Expr::RangeExpr(_e) => Ty::Unknown,\n+            ast::Expr::BinExpr(_e) => Ty::Unknown,\n+            ast::Expr::Literal(_e) => Ty::Unknown,\n+        };\n+        self.write_ty(expr.syntax(), ty.clone());\n+        Ok(ty)\n+    }\n+\n+    fn infer_block(&mut self, node: ast::Block) -> Cancelable<Ty> {\n+        for stmt in node.statements() {\n+            match stmt {\n+                ast::Stmt::LetStmt(stmt) => {\n+                    let decl_ty = if let Some(type_ref) = stmt.type_ref() {\n+                        Ty::new(self.db, type_ref)?\n+                    } else {\n+                        Ty::Unknown\n+                    };\n+                    let ty = if let Some(expr) = stmt.initializer() {\n+                        // TODO pass expectation\n+                        let expr_ty = self.infer_expr(expr)?;\n+                        self.unify_with_coercion(&expr_ty, &decl_ty)\n+                            .unwrap_or(decl_ty)\n+                    } else {\n+                        decl_ty\n+                    };\n+\n+                    if let Some(pat) = stmt.pat() {\n+                        self.write_ty(pat.syntax(), ty);\n+                    };\n+                }\n+                ast::Stmt::ExprStmt(expr_stmt) => {\n+                    if let Some(expr) = expr_stmt.expr() {\n+                        self.infer_expr(expr)?;\n+                    }\n+                }\n+            }\n+        }\n+        let ty = if let Some(expr) = node.expr() {\n+            self.infer_expr(expr)?\n+        } else {\n+            Ty::unit()\n+        };\n+        self.write_ty(node.syntax(), ty.clone());\n+        Ok(ty)\n+    }\n+}\n+\n+pub fn infer(db: &impl HirDatabase, function: Function) -> Cancelable<InferenceResult> {\n+    let scopes = function.scopes(db);\n+    let module = function.module(db)?;\n+    let mut ctx = InferenceContext::new(db, scopes, module);\n+\n+    let syntax = function.syntax(db);\n+    let node = syntax.borrowed();\n+\n+    if let Some(param_list) = node.param_list() {\n+        for param in param_list.params() {\n+            let pat = if let Some(pat) = param.pat() {\n+                pat\n+            } else {\n+                continue;\n+            };\n+            if let Some(type_ref) = param.type_ref() {\n+                let ty = Ty::new(db, type_ref)?;\n+                ctx.type_of.insert(LocalSyntaxPtr::new(pat.syntax()), ty);\n+            } else {\n+                // TODO self param\n+                ctx.type_of\n+                    .insert(LocalSyntaxPtr::new(pat.syntax()), Ty::Unknown);\n+            };\n+        }\n+    }\n+\n+    // TODO get Ty for node.ret_type() and pass that to infer_block as expectation\n+    // (see Expectation in rustc_typeck)\n+\n+    if let Some(block) = node.body() {\n+        ctx.infer_block(block)?;\n+    }\n+\n+    // TODO 'resolve' the types: replace inference variables by their inferred results\n+\n+    Ok(InferenceResult {\n+        type_of: ctx.type_of,\n+    })\n+}"}, {"sha": "ad79b17e41859f186a759fd0785615d8ba81c07c", "filename": "crates/ra_hir/src/ty/primitive.rs", "status": "added", "additions": 130, "deletions": 0, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fprimitive.rs?ref=67e768466ff2e2611eead0f30b2e9c4083c80c20", "patch": "@@ -0,0 +1,130 @@\n+use std::fmt;\n+\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy)]\n+pub enum IntTy {\n+    Isize,\n+    I8,\n+    I16,\n+    I32,\n+    I64,\n+    I128,\n+}\n+\n+impl fmt::Debug for IntTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::Display for IntTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.ty_to_string())\n+    }\n+}\n+\n+impl IntTy {\n+    pub fn ty_to_string(&self) -> &'static str {\n+        match *self {\n+            IntTy::Isize => \"isize\",\n+            IntTy::I8 => \"i8\",\n+            IntTy::I16 => \"i16\",\n+            IntTy::I32 => \"i32\",\n+            IntTy::I64 => \"i64\",\n+            IntTy::I128 => \"i128\",\n+        }\n+    }\n+\n+    pub fn from_string(s: &str) -> Option<IntTy> {\n+        match s {\n+            \"isize\" => Some(IntTy::Isize),\n+            \"i8\" => Some(IntTy::I8),\n+            \"i16\" => Some(IntTy::I16),\n+            \"i32\" => Some(IntTy::I32),\n+            \"i64\" => Some(IntTy::I64),\n+            \"i128\" => Some(IntTy::I128),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy)]\n+pub enum UintTy {\n+    Usize,\n+    U8,\n+    U16,\n+    U32,\n+    U64,\n+    U128,\n+}\n+\n+impl UintTy {\n+    pub fn ty_to_string(&self) -> &'static str {\n+        match *self {\n+            UintTy::Usize => \"usize\",\n+            UintTy::U8 => \"u8\",\n+            UintTy::U16 => \"u16\",\n+            UintTy::U32 => \"u32\",\n+            UintTy::U64 => \"u64\",\n+            UintTy::U128 => \"u128\",\n+        }\n+    }\n+\n+    pub fn from_string(s: &str) -> Option<UintTy> {\n+        match s {\n+            \"usize\" => Some(UintTy::Usize),\n+            \"u8\" => Some(UintTy::U8),\n+            \"u16\" => Some(UintTy::U16),\n+            \"u32\" => Some(UintTy::U32),\n+            \"u64\" => Some(UintTy::U64),\n+            \"u128\" => Some(UintTy::U128),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for UintTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::Display for UintTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.ty_to_string())\n+    }\n+}\n+\n+#[derive(Clone, PartialEq, Eq, Hash, Copy, PartialOrd, Ord)]\n+pub enum FloatTy {\n+    F32,\n+    F64,\n+}\n+\n+impl fmt::Debug for FloatTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self, f)\n+    }\n+}\n+\n+impl fmt::Display for FloatTy {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}\", self.ty_to_string())\n+    }\n+}\n+\n+impl FloatTy {\n+    pub fn ty_to_string(self) -> &'static str {\n+        match self {\n+            FloatTy::F32 => \"f32\",\n+            FloatTy::F64 => \"f64\",\n+        }\n+    }\n+\n+    pub fn from_string(s: &str) -> Option<FloatTy> {\n+        match s {\n+            \"f32\" => Some(FloatTy::F32),\n+            \"f64\" => Some(FloatTy::F64),\n+            _ => None,\n+        }\n+    }\n+}"}, {"sha": "b6c02cd80c2bbed09c6f33578e92fc65fdf18cde", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=67e768466ff2e2611eead0f30b2e9c4083c80c20", "patch": "@@ -0,0 +1,134 @@\n+use std::fmt::Write;\n+use std::path::{PathBuf, Path};\n+use std::fs;\n+\n+use ra_db::{SyntaxDatabase};\n+use ra_syntax::ast::{self, AstNode};\n+use test_utils::{project_dir, assert_eq_text, read_text};\n+\n+use crate::{\n+    source_binder,\n+    mock::MockDatabase,\n+};\n+\n+// These tests compare the inference results for all expressions in a file\n+// against snapshots of the current results. If you change something and these\n+// tests fail expectedly, you can update the comparison files by deleting them\n+// and running the tests again. Similarly, to add a new test, just write the\n+// test here in the same pattern and it will automatically write the snapshot.\n+\n+#[test]\n+fn infer_basics() {\n+    check_inference(\n+        r#\"\n+fn test(a: u32, b: isize, c: !, d: &str) {\n+    a;\n+    b;\n+    c;\n+    d;\n+    1usize;\n+    1isize;\n+    \"test\";\n+    1.0f32;\n+}\"#,\n+        \"0001_basics.txt\",\n+    );\n+}\n+\n+#[test]\n+fn infer_let() {\n+    check_inference(\n+        r#\"\n+fn test() {\n+    let a = 1isize;\n+    let b: usize = 1;\n+    let c = b;\n+}\n+}\"#,\n+        \"0002_let.txt\",\n+    );\n+}\n+\n+#[test]\n+fn infer_paths() {\n+    check_inference(\n+        r#\"\n+fn a() -> u32 { 1 }\n+\n+mod b {\n+    fn c() -> u32 { 1 }\n+}\n+\n+fn test() {\n+    a();\n+    b::c();\n+}\n+}\"#,\n+        \"0003_paths.txt\",\n+    );\n+}\n+\n+fn infer(content: &str) -> String {\n+    let (db, _, file_id) = MockDatabase::with_single_file(content);\n+    let source_file = db.source_file(file_id);\n+    let mut acc = String::new();\n+    for fn_def in source_file\n+        .syntax()\n+        .descendants()\n+        .filter_map(ast::FnDef::cast)\n+    {\n+        let func = source_binder::function_from_source(&db, file_id, fn_def)\n+            .unwrap()\n+            .unwrap();\n+        let inference_result = func.infer(&db).unwrap();\n+        for (syntax_ptr, ty) in &inference_result.type_of {\n+            let node = syntax_ptr.resolve(&source_file);\n+            write!(\n+                acc,\n+                \"{} '{}': {}\\n\",\n+                syntax_ptr.range(),\n+                ellipsize(node.text().to_string().replace(\"\\n\", \" \"), 15),\n+                ty\n+            )\n+            .unwrap();\n+        }\n+    }\n+    acc\n+}\n+\n+fn check_inference(content: &str, data_file: impl AsRef<Path>) {\n+    let data_file_path = test_data_dir().join(data_file);\n+    let result = infer(content);\n+\n+    if !data_file_path.exists() {\n+        println!(\"File with expected result doesn't exist, creating...\\n\");\n+        println!(\"{}\\n{}\", content, result);\n+        fs::write(&data_file_path, &result).unwrap();\n+        panic!(\"File {:?} with expected result was created\", data_file_path);\n+    }\n+\n+    let expected = read_text(&data_file_path);\n+    assert_eq_text!(&expected, &result);\n+}\n+\n+fn ellipsize(mut text: String, max_len: usize) -> String {\n+    if text.len() <= max_len {\n+        return text;\n+    }\n+    let ellipsis = \"...\";\n+    let e_len = ellipsis.len();\n+    let mut prefix_len = (max_len - e_len) / 2;\n+    while !text.is_char_boundary(prefix_len) {\n+        prefix_len += 1;\n+    }\n+    let mut suffix_len = max_len - e_len - prefix_len;\n+    while !text.is_char_boundary(text.len() - suffix_len) {\n+        suffix_len += 1;\n+    }\n+    text.replace_range(prefix_len..text.len() - suffix_len, ellipsis);\n+    text\n+}\n+\n+fn test_data_dir() -> PathBuf {\n+    project_dir().join(\"crates/ra_hir/src/ty/tests/data\")\n+}"}, {"sha": "0c46f243a8e04645f083df0b10587f7038c7591f", "filename": "crates/ra_hir/src/ty/tests/data/0001_basics.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0001_basics.txt", "raw_url": "https://github.com/rust-lang/rust/raw/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0001_basics.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0001_basics.txt?ref=67e768466ff2e2611eead0f30b2e9c4083c80c20", "patch": "@@ -0,0 +1,13 @@\n+[33; 34) 'd': [unknown]\n+[88; 94) '1isize': [unknown]\n+[48; 49) 'a': u32\n+[55; 56) 'b': isize\n+[112; 118) '1.0f32': [unknown]\n+[76; 82) '1usize': [unknown]\n+[9; 10) 'a': u32\n+[27; 28) 'c': !\n+[62; 63) 'c': !\n+[17; 18) 'b': isize\n+[100; 106) '\"test\"': [unknown]\n+[42; 121) '{     ...f32; }': ()\n+[69; 70) 'd': [unknown]"}, {"sha": "2d0d1f57b3fad925721bd7a7eed828a84171ce08", "filename": "crates/ra_hir/src/ty/tests/data/0002_let.txt", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0002_let.txt", "raw_url": "https://github.com/rust-lang/rust/raw/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0002_let.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0002_let.txt?ref=67e768466ff2e2611eead0f30b2e9c4083c80c20", "patch": "@@ -0,0 +1,7 @@\n+[21; 22) 'a': [unknown]\n+[52; 53) '1': [unknown]\n+[11; 71) '{     ...= b; }': ()\n+[63; 64) 'c': usize\n+[25; 31) '1isize': [unknown]\n+[41; 42) 'b': usize\n+[67; 68) 'b': usize"}, {"sha": "dcb5456ae36d2b6254a35504c01fadc01e5381e8", "filename": "crates/ra_hir/src/ty/tests/data/0003_paths.txt", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0003_paths.txt", "raw_url": "https://github.com/rust-lang/rust/raw/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0003_paths.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0003_paths.txt?ref=67e768466ff2e2611eead0f30b2e9c4083c80c20", "patch": "@@ -0,0 +1,9 @@\n+[15; 20) '{ 1 }': [unknown]\n+[17; 18) '1': [unknown]\n+[50; 51) '1': [unknown]\n+[48; 53) '{ 1 }': [unknown]\n+[82; 88) 'b::c()': u32\n+[67; 91) '{     ...c(); }': ()\n+[73; 74) 'a': fn() -> u32\n+[73; 76) 'a()': u32\n+[82; 86) 'b::c': fn() -> u32"}, {"sha": "c735338619aa09b3a784b2c1d42538e1c5c341b0", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 52, "deletions": 8, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=67e768466ff2e2611eead0f30b2e9c4083c80c20", "patch": "@@ -523,7 +523,15 @@ impl<R: TreeRoot<RaTypes>> CastExprNode<R> {\n }\n \n \n-impl<'a> CastExpr<'a> {}\n+impl<'a> CastExpr<'a> {\n+    pub fn expr(self) -> Option<Expr<'a>> {\n+        super::child_opt(self)\n+    }\n+\n+    pub fn type_ref(self) -> Option<TypeRef<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // Char\n #[derive(Debug, Clone, Copy,)]\n@@ -1553,6 +1561,10 @@ impl<'a> LetStmt<'a> {\n         super::child_opt(self)\n     }\n \n+    pub fn type_ref(self) -> Option<TypeRef<'a>> {\n+        super::child_opt(self)\n+    }\n+\n     pub fn initializer(self) -> Option<Expr<'a>> {\n         super::child_opt(self)\n     }\n@@ -2312,6 +2324,10 @@ impl<'a> Param<'a> {\n     pub fn pat(self) -> Option<Pat<'a>> {\n         super::child_opt(self)\n     }\n+\n+    pub fn type_ref(self) -> Option<TypeRef<'a>> {\n+        super::child_opt(self)\n+    }\n }\n \n // ParamList\n@@ -2394,7 +2410,11 @@ impl<R: TreeRoot<RaTypes>> ParenExprNode<R> {\n }\n \n \n-impl<'a> ParenExpr<'a> {}\n+impl<'a> ParenExpr<'a> {\n+    pub fn expr(self) -> Option<Expr<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // ParenType\n #[derive(Debug, Clone, Copy,)]\n@@ -2681,7 +2701,11 @@ impl<R: TreeRoot<RaTypes>> PathTypeNode<R> {\n }\n \n \n-impl<'a> PathType<'a> {}\n+impl<'a> PathType<'a> {\n+    pub fn path(self) -> Option<Path<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // PlaceholderPat\n #[derive(Debug, Clone, Copy,)]\n@@ -2829,7 +2853,11 @@ impl<R: TreeRoot<RaTypes>> PrefixExprNode<R> {\n }\n \n \n-impl<'a> PrefixExpr<'a> {}\n+impl<'a> PrefixExpr<'a> {\n+    pub fn expr(self) -> Option<Expr<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // RangeExpr\n #[derive(Debug, Clone, Copy,)]\n@@ -2940,7 +2968,11 @@ impl<R: TreeRoot<RaTypes>> RefExprNode<R> {\n }\n \n \n-impl<'a> RefExpr<'a> {}\n+impl<'a> RefExpr<'a> {\n+    pub fn expr(self) -> Option<Expr<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // RefPat\n #[derive(Debug, Clone, Copy,)]\n@@ -3051,7 +3083,11 @@ impl<R: TreeRoot<RaTypes>> RetTypeNode<R> {\n }\n \n \n-impl<'a> RetType<'a> {}\n+impl<'a> RetType<'a> {\n+    pub fn type_ref(self) -> Option<TypeRef<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // ReturnExpr\n #[derive(Debug, Clone, Copy,)]\n@@ -3088,7 +3124,11 @@ impl<R: TreeRoot<RaTypes>> ReturnExprNode<R> {\n }\n \n \n-impl<'a> ReturnExpr<'a> {}\n+impl<'a> ReturnExpr<'a> {\n+    pub fn expr(self) -> Option<Expr<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // SelfParam\n #[derive(Debug, Clone, Copy,)]\n@@ -3578,7 +3618,11 @@ impl<R: TreeRoot<RaTypes>> TryExprNode<R> {\n }\n \n \n-impl<'a> TryExpr<'a> {}\n+impl<'a> TryExpr<'a> {\n+    pub fn expr(self) -> Option<Expr<'a>> {\n+        super::child_opt(self)\n+    }\n+}\n \n // TupleExpr\n #[derive(Debug, Clone, Copy,)]"}, {"sha": "e3b9032a0c6eb45ddf49168efcfc771865fcfd48", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=67e768466ff2e2611eead0f30b2e9c4083c80c20", "patch": "@@ -254,7 +254,7 @@ Grammar(\n             ],\n             options: [ \"ParamList\", [\"body\", \"Block\"], \"RetType\" ],\n         ),\n-        \"RetType\": (),\n+        \"RetType\": (options: [\"TypeRef\"]),\n         \"StructDef\": (\n             traits: [\n                 \"NameOwner\",\n@@ -304,7 +304,7 @@ Grammar(\n         \"ParenType\": (),\n         \"TupleType\": (),\n         \"NeverType\": (),\n-        \"PathType\": (),\n+        \"PathType\": (options: [\"Path\"]),\n         \"PointerType\": (),\n         \"ArrayType\": (),\n         \"SliceType\": (),\n@@ -346,7 +346,7 @@ Grammar(\n \n         \"TupleExpr\": (),\n         \"ArrayExpr\": (),\n-        \"ParenExpr\": (),\n+        \"ParenExpr\": (options: [\"Expr\"]),\n         \"PathExpr\": (options: [\"Path\"]),\n         \"LambdaExpr\": (\n             options: [\n@@ -377,7 +377,7 @@ Grammar(\n         \"BlockExpr\": (\n             options: [ \"Block\" ]\n         ),\n-        \"ReturnExpr\": (),\n+        \"ReturnExpr\": (options: [\"Expr\"]),\n         \"MatchExpr\": (\n             options: [ \"Expr\", \"MatchArmList\" ],\n         ),\n@@ -405,10 +405,10 @@ Grammar(\n         ),\n         \"IndexExpr\": (),\n         \"FieldExpr\": (),\n-        \"TryExpr\": (),\n-        \"CastExpr\": (),\n-        \"RefExpr\": (),\n-        \"PrefixExpr\": (),\n+        \"TryExpr\": (options: [\"Expr\"]),\n+        \"CastExpr\": (options: [\"Expr\", \"TypeRef\"]),\n+        \"RefExpr\": (options: [\"Expr\"]),\n+        \"PrefixExpr\": (options: [\"Expr\"]),\n         \"RangeExpr\": (),\n         \"BinExpr\": (),\n         \"String\": (),\n@@ -499,6 +499,7 @@ Grammar(\n         ),\n         \"LetStmt\": ( options: [\n             [\"pat\", \"Pat\"],\n+            [\"type_ref\", \"TypeRef\"],\n             [\"initializer\", \"Expr\"],\n         ]),\n         \"Condition\": (\n@@ -521,7 +522,7 @@ Grammar(\n         ),\n         \"SelfParam\": (),\n         \"Param\": (\n-            options: [ \"Pat\" ],\n+            options: [ \"Pat\", \"TypeRef\" ],\n         ),\n         \"UseItem\": (\n             options: [ \"UseTree\" ]"}, {"sha": "2235dc401d937dddb15380809de860a59b209028", "filename": "crates/ra_syntax/tests/test.rs", "status": "modified", "additions": 34, "deletions": 123, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_syntax%2Ftests%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Fra_syntax%2Ftests%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftests%2Ftest.rs?ref=67e768466ff2e2611eead0f30b2e9c4083c80c20", "patch": "@@ -1,56 +1,63 @@\n extern crate ra_syntax;\n-#[macro_use]\n extern crate test_utils;\n extern crate walkdir;\n \n use std::{\n     fmt::Write,\n-    fs,\n-    path::{Path, PathBuf, Component},\n+    path::{PathBuf, Component},\n };\n \n+use test_utils::{project_dir, dir_tests, read_text, collect_tests};\n use ra_syntax::{\n     utils::{check_fuzz_invariants, dump_tree},\n     SourceFileNode,\n };\n \n #[test]\n fn lexer_tests() {\n-    dir_tests(&[\"lexer\"], |text, _| {\n+    dir_tests(&test_data_dir(), &[\"lexer\"], |text, _| {\n         let tokens = ra_syntax::tokenize(text);\n         dump_tokens(&tokens, text)\n     })\n }\n \n #[test]\n fn parser_tests() {\n-    dir_tests(&[\"parser/inline/ok\", \"parser/ok\"], |text, path| {\n-        let file = SourceFileNode::parse(text);\n-        let errors = file.errors();\n-        assert_eq!(\n-            &*errors,\n-            &[] as &[ra_syntax::SyntaxError],\n-            \"There should be no errors in the file {:?}\",\n-            path.display()\n-        );\n-        dump_tree(file.syntax())\n-    });\n-    dir_tests(&[\"parser/err\", \"parser/inline/err\"], |text, path| {\n-        let file = SourceFileNode::parse(text);\n-        let errors = file.errors();\n-        assert_ne!(\n-            &*errors,\n-            &[] as &[ra_syntax::SyntaxError],\n-            \"There should be errors in the file {:?}\",\n-            path.display()\n-        );\n-        dump_tree(file.syntax())\n-    });\n+    dir_tests(\n+        &test_data_dir(),\n+        &[\"parser/inline/ok\", \"parser/ok\"],\n+        |text, path| {\n+            let file = SourceFileNode::parse(text);\n+            let errors = file.errors();\n+            assert_eq!(\n+                &*errors,\n+                &[] as &[ra_syntax::SyntaxError],\n+                \"There should be no errors in the file {:?}\",\n+                path.display()\n+            );\n+            dump_tree(file.syntax())\n+        },\n+    );\n+    dir_tests(\n+        &test_data_dir(),\n+        &[\"parser/err\", \"parser/inline/err\"],\n+        |text, path| {\n+            let file = SourceFileNode::parse(text);\n+            let errors = file.errors();\n+            assert_ne!(\n+                &*errors,\n+                &[] as &[ra_syntax::SyntaxError],\n+                \"There should be errors in the file {:?}\",\n+                path.display()\n+            );\n+            dump_tree(file.syntax())\n+        },\n+    );\n }\n \n #[test]\n fn parser_fuzz_tests() {\n-    for (_, text) in collect_tests(&[\"parser/fuzz-failures\"]) {\n+    for (_, text) in collect_tests(&test_data_dir(), &[\"parser/fuzz-failures\"]) {\n         check_fuzz_invariants(&text)\n     }\n }\n@@ -92,102 +99,6 @@ fn self_hosting_parsing() {\n         \"self_hosting_parsing found too few files - is it running in the right directory?\"\n     )\n }\n-/// Read file and normalize newlines.\n-///\n-/// `rustc` seems to always normalize `\\r\\n` newlines to `\\n`:\n-///\n-/// ```\n-/// let s = \"\n-/// \";\n-/// assert_eq!(s.as_bytes(), &[10]);\n-/// ```\n-///\n-/// so this should always be correct.\n-fn read_text(path: &Path) -> String {\n-    fs::read_to_string(path)\n-        .expect(&format!(\"File at {:?} should be valid\", path))\n-        .replace(\"\\r\\n\", \"\\n\")\n-}\n-\n-fn dir_tests<F>(paths: &[&str], f: F)\n-where\n-    F: Fn(&str, &Path) -> String,\n-{\n-    for (path, input_code) in collect_tests(paths) {\n-        let parse_tree = f(&input_code, &path);\n-        let path = path.with_extension(\"txt\");\n-        if !path.exists() {\n-            println!(\"\\nfile: {}\", path.display());\n-            println!(\"No .txt file with expected result, creating...\\n\");\n-            println!(\"{}\\n{}\", input_code, parse_tree);\n-            fs::write(&path, &parse_tree).unwrap();\n-            panic!(\"No expected result\")\n-        }\n-        let expected = read_text(&path);\n-        let expected = expected.as_str();\n-        let parse_tree = parse_tree.as_str();\n-        assert_equal_text(expected, parse_tree, &path);\n-    }\n-}\n-\n-const REWRITE: bool = false;\n-\n-fn assert_equal_text(expected: &str, actual: &str, path: &Path) {\n-    if expected == actual {\n-        return;\n-    }\n-    let dir = project_dir();\n-    let pretty_path = path.strip_prefix(&dir).unwrap_or_else(|_| path);\n-    if expected.trim() == actual.trim() {\n-        println!(\"whitespace difference, rewriting\");\n-        println!(\"file: {}\\n\", pretty_path.display());\n-        fs::write(path, actual).unwrap();\n-        return;\n-    }\n-    if REWRITE {\n-        println!(\"rewriting {}\", pretty_path.display());\n-        fs::write(path, actual).unwrap();\n-        return;\n-    }\n-    assert_eq_text!(expected, actual, \"file: {}\", pretty_path.display());\n-}\n-\n-fn collect_tests(paths: &[&str]) -> Vec<(PathBuf, String)> {\n-    paths\n-        .iter()\n-        .flat_map(|path| {\n-            let path = test_data_dir().join(path);\n-            test_from_dir(&path).into_iter()\n-        })\n-        .map(|path| {\n-            let text = read_text(&path);\n-            (path, text)\n-        })\n-        .collect()\n-}\n-\n-fn test_from_dir(dir: &Path) -> Vec<PathBuf> {\n-    let mut acc = Vec::new();\n-    for file in fs::read_dir(&dir).unwrap() {\n-        let file = file.unwrap();\n-        let path = file.path();\n-        if path.extension().unwrap_or_default() == \"rs\" {\n-            acc.push(path);\n-        }\n-    }\n-    acc.sort();\n-    acc\n-}\n-\n-fn project_dir() -> PathBuf {\n-    let dir = env!(\"CARGO_MANIFEST_DIR\");\n-    PathBuf::from(dir)\n-        .parent()\n-        .unwrap()\n-        .parent()\n-        .unwrap()\n-        .to_owned()\n-}\n \n fn test_data_dir() -> PathBuf {\n     project_dir().join(\"crates/ra_syntax/tests/data\")"}, {"sha": "012b1d0b40218dd3889be719c80ae246bba92a3a", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67e768466ff2e2611eead0f30b2e9c4083c80c20/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=67e768466ff2e2611eead0f30b2e9c4083c80c20", "patch": "@@ -1,4 +1,6 @@\n use std::fmt;\n+use std::fs;\n+use std::path::{Path, PathBuf};\n \n use itertools::Itertools;\n use text_unit::{TextRange, TextUnit};\n@@ -262,3 +264,100 @@ pub fn find_mismatch<'a>(expected: &'a Value, actual: &'a Value) -> Option<(&'a\n         _ => Some((expected, actual)),\n     }\n }\n+\n+pub fn dir_tests<F>(test_data_dir: &Path, paths: &[&str], f: F)\n+where\n+    F: Fn(&str, &Path) -> String,\n+{\n+    for (path, input_code) in collect_tests(test_data_dir, paths) {\n+        let parse_tree = f(&input_code, &path);\n+        let path = path.with_extension(\"txt\");\n+        if !path.exists() {\n+            println!(\"\\nfile: {}\", path.display());\n+            println!(\"No .txt file with expected result, creating...\\n\");\n+            println!(\"{}\\n{}\", input_code, parse_tree);\n+            fs::write(&path, &parse_tree).unwrap();\n+            panic!(\"No expected result\")\n+        }\n+        let expected = read_text(&path);\n+        let expected = expected.as_str();\n+        let parse_tree = parse_tree.as_str();\n+        assert_equal_text(expected, parse_tree, &path);\n+    }\n+}\n+\n+pub fn collect_tests(test_data_dir: &Path, paths: &[&str]) -> Vec<(PathBuf, String)> {\n+    paths\n+        .iter()\n+        .flat_map(|path| {\n+            let path = test_data_dir.to_owned().join(path);\n+            test_from_dir(&path).into_iter()\n+        })\n+        .map(|path| {\n+            let text = read_text(&path);\n+            (path, text)\n+        })\n+        .collect()\n+}\n+\n+fn test_from_dir(dir: &Path) -> Vec<PathBuf> {\n+    let mut acc = Vec::new();\n+    for file in fs::read_dir(&dir).unwrap() {\n+        let file = file.unwrap();\n+        let path = file.path();\n+        if path.extension().unwrap_or_default() == \"rs\" {\n+            acc.push(path);\n+        }\n+    }\n+    acc.sort();\n+    acc\n+}\n+\n+pub fn project_dir() -> PathBuf {\n+    let dir = env!(\"CARGO_MANIFEST_DIR\");\n+    PathBuf::from(dir)\n+        .parent()\n+        .unwrap()\n+        .parent()\n+        .unwrap()\n+        .to_owned()\n+}\n+\n+/// Read file and normalize newlines.\n+///\n+/// `rustc` seems to always normalize `\\r\\n` newlines to `\\n`:\n+///\n+/// ```\n+/// let s = \"\n+/// \";\n+/// assert_eq!(s.as_bytes(), &[10]);\n+/// ```\n+///\n+/// so this should always be correct.\n+pub fn read_text(path: &Path) -> String {\n+    fs::read_to_string(path)\n+        .expect(&format!(\"File at {:?} should be valid\", path))\n+        .replace(\"\\r\\n\", \"\\n\")\n+}\n+\n+const REWRITE: bool = false;\n+\n+fn assert_equal_text(expected: &str, actual: &str, path: &Path) {\n+    if expected == actual {\n+        return;\n+    }\n+    let dir = project_dir();\n+    let pretty_path = path.strip_prefix(&dir).unwrap_or_else(|_| path);\n+    if expected.trim() == actual.trim() {\n+        println!(\"whitespace difference, rewriting\");\n+        println!(\"file: {}\\n\", pretty_path.display());\n+        fs::write(path, actual).unwrap();\n+        return;\n+    }\n+    if REWRITE {\n+        println!(\"rewriting {}\", pretty_path.display());\n+        fs::write(path, actual).unwrap();\n+        return;\n+    }\n+    assert_eq_text!(expected, actual, \"file: {}\", pretty_path.display());\n+}"}]}