{"sha": "d3d054f5740a38e94d5b358da4ac16b16cd87854", "node_id": "C_kwDOAAsO6NoAKGQzZDA1NGY1NzQwYTM4ZTk0ZDViMzU4ZGE0YWMxNmIxNmNkODc4NTQ", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-02-23T10:57:11Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-02-23T11:00:04Z"}, "message": "Reduce visibility of proc-macros to pub(crate)", "tree": {"sha": "efaf33a968965b754503d7b60292c8389175021b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efaf33a968965b754503d7b60292c8389175021b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3d054f5740a38e94d5b358da4ac16b16cd87854", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3d054f5740a38e94d5b358da4ac16b16cd87854", "html_url": "https://github.com/rust-lang/rust/commit/d3d054f5740a38e94d5b358da4ac16b16cd87854", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3d054f5740a38e94d5b358da4ac16b16cd87854/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e759db361ef36423933fab6d5e1af9a7eb2de7d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/e759db361ef36423933fab6d5e1af9a7eb2de7d8", "html_url": "https://github.com/rust-lang/rust/commit/e759db361ef36423933fab6d5e1af9a7eb2de7d8"}], "stats": {"total": 198, "additions": 100, "deletions": 98}, "files": [{"sha": "41e4bf8e8bf49a3f08dd99190757a766dbc1311a", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 100, "deletions": 98, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/d3d054f5740a38e94d5b358da4ac16b16cd87854/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3d054f5740a38e94d5b358da4ac16b16cd87854/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=d3d054f5740a38e94d5b358da4ac16b16cd87854", "patch": "@@ -1417,13 +1417,6 @@ impl ModCollector<'_, '_> {\n     }\n \n     fn collect(&mut self, items: &[ModItem], container: ItemContainerId) {\n-        struct DefData<'a> {\n-            id: ModuleDefId,\n-            name: &'a Name,\n-            visibility: &'a RawVisibility,\n-            has_constructor: bool,\n-        }\n-\n         let krate = self.def_collector.def_map.krate;\n \n         // Note: don't assert that inserted value is fresh: it's simply not true\n@@ -1473,22 +1466,37 @@ impl ModCollector<'_, '_> {\n                 continue;\n             }\n \n+            let db = self.def_collector.db;\n             let module = self.def_collector.def_map.module_id(self.module_id);\n+            let def_map = &mut self.def_collector.def_map;\n+            let update_def =\n+                |def_collector: &mut DefCollector, id, name: &Name, vis, has_constructor| {\n+                    def_collector.def_map.modules[self.module_id].scope.declare(id);\n+                    def_collector.update(\n+                        self.module_id,\n+                        &[(Some(name.clone()), PerNs::from_def(id, vis, has_constructor))],\n+                        vis,\n+                        ImportType::Named,\n+                    )\n+                };\n+            let resolve_vis = |def_map: &DefMap, visibility| {\n+                def_map\n+                    .resolve_visibility(db, self.module_id, visibility)\n+                    .unwrap_or(Visibility::Public)\n+            };\n \n-            let mut def = None;\n             match item {\n                 ModItem::Mod(m) => self.collect_module(&self.item_tree[m], &attrs),\n                 ModItem::Import(import_id) => {\n-                    let module_id = self.module_id;\n                     let imports = Import::from_use(\n-                        self.def_collector.db,\n+                        db,\n                         krate,\n                         self.item_tree,\n                         ItemTreeId::new(self.tree_id, import_id),\n                     );\n                     self.def_collector.unresolved_imports.extend(imports.into_iter().map(\n                         |import| ImportDirective {\n-                            module_id,\n+                            module_id: self.module_id,\n                             import,\n                             status: PartialResolvedImport::Unresolved,\n                         },\n@@ -1498,7 +1506,7 @@ impl ModCollector<'_, '_> {\n                     self.def_collector.unresolved_imports.push(ImportDirective {\n                         module_id: self.module_id,\n                         import: Import::from_extern_crate(\n-                            self.def_collector.db,\n+                            db,\n                             krate,\n                             self.item_tree,\n                             ItemTreeId::new(self.tree_id, import_id),\n@@ -1513,7 +1521,7 @@ impl ModCollector<'_, '_> {\n                             container: module,\n                             id: ItemTreeId::new(self.tree_id, block),\n                         }\n-                        .intern(self.def_collector.db),\n+                        .intern(db),\n                     ),\n                 ),\n                 ModItem::MacroCall(mac) => self.collect_macro_call(&self.item_tree[mac], container),\n@@ -1523,73 +1531,84 @@ impl ModCollector<'_, '_> {\n                     let module = self.def_collector.def_map.module_id(self.module_id);\n                     let impl_id =\n                         ImplLoc { container: module, id: ItemTreeId::new(self.tree_id, imp) }\n-                            .intern(self.def_collector.db);\n+                            .intern(db);\n                     self.def_collector.def_map.modules[self.module_id].scope.define_impl(impl_id)\n                 }\n                 ModItem::Function(id) => {\n-                    let func = &self.item_tree[id];\n-\n-                    let ast_id = InFile::new(self.file_id(), func.ast_id);\n-                    self.collect_proc_macro_def(&func.name, ast_id, &attrs);\n+                    let it = &self.item_tree[id];\n \n-                    def = Some(DefData {\n-                        id: FunctionLoc { container, id: ItemTreeId::new(self.tree_id, id) }\n-                            .intern(self.def_collector.db)\n+                    let is_proc_macro = attrs.parse_proc_macro_decl(&it.name);\n+                    let vis = match is_proc_macro {\n+                        Some(proc_macro) => {\n+                            // FIXME: this should only be done in the root module of `proc-macro` crates, not everywhere\n+                            let ast_id = InFile::new(self.tree_id.file_id(), it.ast_id);\n+                            let module_id = def_map.module_id(def_map.root());\n+                            self.def_collector.export_proc_macro(proc_macro, ast_id);\n+                            Visibility::Module(module_id)\n+                        }\n+                        None => resolve_vis(def_map, &self.item_tree[it.visibility]),\n+                    };\n+                    update_def(\n+                        self.def_collector,\n+                        FunctionLoc { container, id: ItemTreeId::new(self.tree_id, id) }\n+                            .intern(db)\n                             .into(),\n-                        name: &func.name,\n-                        visibility: &self.item_tree[func.visibility],\n-                        has_constructor: false,\n-                    });\n+                        &it.name,\n+                        vis,\n+                        false,\n+                    );\n                 }\n                 ModItem::Struct(id) => {\n                     let it = &self.item_tree[id];\n \n-                    def = Some(DefData {\n-                        id: StructLoc { container: module, id: ItemTreeId::new(self.tree_id, id) }\n-                            .intern(self.def_collector.db)\n+                    let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n+                    update_def(\n+                        self.def_collector,\n+                        StructLoc { container: module, id: ItemTreeId::new(self.tree_id, id) }\n+                            .intern(db)\n                             .into(),\n-                        name: &it.name,\n-                        visibility: &self.item_tree[it.visibility],\n-                        has_constructor: !matches!(it.fields, Fields::Record(_)),\n-                    });\n+                        &it.name,\n+                        vis,\n+                        !matches!(it.fields, Fields::Record(_)),\n+                    );\n                 }\n                 ModItem::Union(id) => {\n                     let it = &self.item_tree[id];\n \n-                    def = Some(DefData {\n-                        id: UnionLoc { container: module, id: ItemTreeId::new(self.tree_id, id) }\n-                            .intern(self.def_collector.db)\n+                    let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n+                    update_def(\n+                        self.def_collector,\n+                        UnionLoc { container: module, id: ItemTreeId::new(self.tree_id, id) }\n+                            .intern(db)\n                             .into(),\n-                        name: &it.name,\n-                        visibility: &self.item_tree[it.visibility],\n-                        has_constructor: false,\n-                    });\n+                        &it.name,\n+                        vis,\n+                        false,\n+                    );\n                 }\n                 ModItem::Enum(id) => {\n                     let it = &self.item_tree[id];\n \n-                    def = Some(DefData {\n-                        id: EnumLoc { container: module, id: ItemTreeId::new(self.tree_id, id) }\n-                            .intern(self.def_collector.db)\n+                    let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n+                    update_def(\n+                        self.def_collector,\n+                        EnumLoc { container: module, id: ItemTreeId::new(self.tree_id, id) }\n+                            .intern(db)\n                             .into(),\n-                        name: &it.name,\n-                        visibility: &self.item_tree[it.visibility],\n-                        has_constructor: false,\n-                    });\n+                        &it.name,\n+                        vis,\n+                        false,\n+                    );\n                 }\n                 ModItem::Const(id) => {\n                     let it = &self.item_tree[id];\n-                    let const_id = ConstLoc { container, id: ItemTreeId::new(self.tree_id, id) }\n-                        .intern(self.def_collector.db);\n+                    let const_id =\n+                        ConstLoc { container, id: ItemTreeId::new(self.tree_id, id) }.intern(db);\n \n                     match &it.name {\n                         Some(name) => {\n-                            def = Some(DefData {\n-                                id: const_id.into(),\n-                                name,\n-                                visibility: &self.item_tree[it.visibility],\n-                                has_constructor: false,\n-                            });\n+                            let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n+                            update_def(self.def_collector, const_id.into(), name, vis, false);\n                         }\n                         None => {\n                             // const _: T = ...;\n@@ -1602,55 +1621,46 @@ impl ModCollector<'_, '_> {\n                 ModItem::Static(id) => {\n                     let it = &self.item_tree[id];\n \n-                    def = Some(DefData {\n-                        id: StaticLoc { container, id: ItemTreeId::new(self.tree_id, id) }\n-                            .intern(self.def_collector.db)\n+                    let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n+                    update_def(\n+                        self.def_collector,\n+                        StaticLoc { container, id: ItemTreeId::new(self.tree_id, id) }\n+                            .intern(db)\n                             .into(),\n-                        name: &it.name,\n-                        visibility: &self.item_tree[it.visibility],\n-                        has_constructor: false,\n-                    });\n+                        &it.name,\n+                        vis,\n+                        false,\n+                    );\n                 }\n                 ModItem::Trait(id) => {\n                     let it = &self.item_tree[id];\n \n-                    def = Some(DefData {\n-                        id: TraitLoc { container: module, id: ItemTreeId::new(self.tree_id, id) }\n-                            .intern(self.def_collector.db)\n+                    let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n+                    update_def(\n+                        self.def_collector,\n+                        TraitLoc { container: module, id: ItemTreeId::new(self.tree_id, id) }\n+                            .intern(db)\n                             .into(),\n-                        name: &it.name,\n-                        visibility: &self.item_tree[it.visibility],\n-                        has_constructor: false,\n-                    });\n+                        &it.name,\n+                        vis,\n+                        false,\n+                    );\n                 }\n                 ModItem::TypeAlias(id) => {\n                     let it = &self.item_tree[id];\n \n-                    def = Some(DefData {\n-                        id: TypeAliasLoc { container, id: ItemTreeId::new(self.tree_id, id) }\n-                            .intern(self.def_collector.db)\n+                    let vis = resolve_vis(def_map, &self.item_tree[it.visibility]);\n+                    update_def(\n+                        self.def_collector,\n+                        TypeAliasLoc { container, id: ItemTreeId::new(self.tree_id, id) }\n+                            .intern(db)\n                             .into(),\n-                        name: &it.name,\n-                        visibility: &self.item_tree[it.visibility],\n-                        has_constructor: false,\n-                    });\n+                        &it.name,\n+                        vis,\n+                        false,\n+                    );\n                 }\n             }\n-\n-            if let Some(DefData { id, name, visibility, has_constructor }) = def {\n-                self.def_collector.def_map.modules[self.module_id].scope.declare(id);\n-                let vis = self\n-                    .def_collector\n-                    .def_map\n-                    .resolve_visibility(self.def_collector.db, self.module_id, visibility)\n-                    .unwrap_or(Visibility::Public);\n-                self.def_collector.update(\n-                    self.module_id,\n-                    &[(Some(name.clone()), PerNs::from_def(id, vis, has_constructor))],\n-                    vis,\n-                    ImportType::Named,\n-                )\n-            }\n         }\n     }\n \n@@ -1835,14 +1845,6 @@ impl ModCollector<'_, '_> {\n         Ok(())\n     }\n \n-    /// If `attrs` registers a procedural macro, collects its definition.\n-    fn collect_proc_macro_def(&mut self, func_name: &Name, ast_id: AstId<ast::Fn>, attrs: &Attrs) {\n-        // FIXME: this should only be done in the root module of `proc-macro` crates, not everywhere\n-        if let Some(proc_macro) = attrs.parse_proc_macro_decl(func_name) {\n-            self.def_collector.export_proc_macro(proc_macro, ast_id);\n-        }\n-    }\n-\n     fn collect_macro_rules(&mut self, id: FileItemTreeId<MacroRules>) {\n         let krate = self.def_collector.def_map.krate;\n         let mac = &self.item_tree[id];"}]}