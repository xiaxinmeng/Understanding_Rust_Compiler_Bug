{"sha": "557ff049f098ab0d53670291fca660eb23549827", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1N2ZmMDQ5ZjA5OGFiMGQ1MzY3MDI5MWZjYTY2MGViMjM1NDk4Mjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-19T02:32:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-19T02:32:36Z"}, "message": "auto merge of #8565 : bblum/rust/select-bugfix, r=brson\n\n@brson grilled me about how this bugfix worked the first time around, and it occurred to me that it didn't in the case where the task is unwinding. Now it will.", "tree": {"sha": "c45aa57a74b36fc05431a7edaf2744a0842cb629", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c45aa57a74b36fc05431a7edaf2744a0842cb629"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/557ff049f098ab0d53670291fca660eb23549827", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/557ff049f098ab0d53670291fca660eb23549827", "html_url": "https://github.com/rust-lang/rust/commit/557ff049f098ab0d53670291fca660eb23549827", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/557ff049f098ab0d53670291fca660eb23549827/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8fff3f40f290df5bcd25bcefdc0e19f74d0af0a5", "url": "https://api.github.com/repos/rust-lang/rust/commits/8fff3f40f290df5bcd25bcefdc0e19f74d0af0a5", "html_url": "https://github.com/rust-lang/rust/commit/8fff3f40f290df5bcd25bcefdc0e19f74d0af0a5"}, {"sha": "65cf75af67de10d335391cfd66ee15e462d806f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/65cf75af67de10d335391cfd66ee15e462d806f7", "html_url": "https://github.com/rust-lang/rust/commit/65cf75af67de10d335391cfd66ee15e462d806f7"}], "stats": {"total": 41, "additions": 23, "deletions": 18}, "files": [{"sha": "f537a1f6c33a24289092b782bb7a258040cd7779", "filename": "src/libstd/select.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/557ff049f098ab0d53670291fca660eb23549827/src%2Flibstd%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/557ff049f098ab0d53670291fca660eb23549827/src%2Flibstd%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fselect.rs?ref=557ff049f098ab0d53670291fca660eb23549827", "patch": "@@ -20,6 +20,7 @@ use rt::select::{SelectInner, SelectPortInner};\n use rt::local::Local;\n use rt::rtio::EventLoop;\n use task;\n+use unstable::finally::Finally;\n use vec::{OwnedVector, MutableVector};\n \n /// Trait for message-passing primitives that can be select()ed on.\n@@ -57,28 +58,32 @@ pub fn select<A: Select>(ports: &mut [A]) -> uint {\n     let p = Cell::new(p);\n     let c = Cell::new(c);\n \n-    let sched = Local::take::<Scheduler>();\n-    do sched.deschedule_running_task_and_then |sched, task| {\n-        let task_handles = task.make_selectable(ports.len());\n-\n-        for (index, (port, task_handle)) in\n-                ports.mut_iter().zip(task_handles.move_iter()).enumerate() {\n-            // If one of the ports has data by now, it will wake the handle.\n-            if port.block_on(sched, task_handle) {\n-                ready_index = index;\n-                break;\n+    do (|| {\n+        let c = Cell::new(c.take());\n+        let sched = Local::take::<Scheduler>();\n+        do sched.deschedule_running_task_and_then |sched, task| {\n+            let task_handles = task.make_selectable(ports.len());\n+\n+            for (index, (port, task_handle)) in\n+                    ports.mut_iter().zip(task_handles.move_iter()).enumerate() {\n+                // If one of the ports has data by now, it will wake the handle.\n+                if port.block_on(sched, task_handle) {\n+                    ready_index = index;\n+                    break;\n+                }\n             }\n-        }\n \n-        let c = Cell::new(c.take());\n-        do sched.event_loop.callback { c.take().send_deferred(()) }\n+            let c = Cell::new(c.take());\n+            do sched.event_loop.callback { c.take().send_deferred(()) }\n+        }\n+    }).finally {\n+        let p = Cell::new(p.take());\n+        // Unkillable is necessary not because getting killed is dangerous here,\n+        // but to force the recv not to use the same kill-flag that we used for\n+        // selecting. Otherwise a user-sender could spuriously wakeup us here.\n+        do task::unkillable { p.take().recv(); }\n     }\n \n-    // Unkillable is necessary not because getting killed is dangerous here,\n-    // but to force the recv not to use the same kill-flag that we used for\n-    // selecting. Otherwise a user-sender could spuriously wakeup us here.\n-    do task::unkillable { p.take().recv(); }\n-\n     // Task resumes. Now unblock ourselves from all the ports we blocked on.\n     // If the success index wasn't reset, 'take' will just take all of them.\n     // Iterate in reverse so the 'earliest' index that's ready gets returned."}]}