{"sha": "986f654f3b087809fbf9b1168708e46b4211da84", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4NmY2NTRmM2IwODc4MDlmYmY5YjExNjg3MDhlNDZiNDIxMWRhODQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-17T21:00:34Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-30T14:32:42Z"}, "message": "Rename `trait_ref` field to `predicate`, since `trait_ref` is really\noverly general, and the value is always *some* sort of predicate.", "tree": {"sha": "99c136a773fee68101e73416a20ec3cd37bb254f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/99c136a773fee68101e73416a20ec3cd37bb254f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/986f654f3b087809fbf9b1168708e46b4211da84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/986f654f3b087809fbf9b1168708e46b4211da84", "html_url": "https://github.com/rust-lang/rust/commit/986f654f3b087809fbf9b1168708e46b4211da84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/986f654f3b087809fbf9b1168708e46b4211da84/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5edd22646fcde05b39490558371c7ea9d525a0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5edd22646fcde05b39490558371c7ea9d525a0f", "html_url": "https://github.com/rust-lang/rust/commit/c5edd22646fcde05b39490558371c7ea9d525a0f"}], "stats": {"total": 107, "additions": 56, "deletions": 51}, "files": [{"sha": "6c80a22536a349ecf2468a12afc65ef0b5646ba7", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/986f654f3b087809fbf9b1168708e46b4211da84/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/986f654f3b087809fbf9b1168708e46b4211da84/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=986f654f3b087809fbf9b1168708e46b4211da84", "patch": "@@ -126,7 +126,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n         let trait_obligation = Obligation { cause: cause,\n                                             recursion_depth: 0,\n-                                            trait_ref: ty::Predicate::Trait(trait_ref) };\n+                                            predicate: ty::Predicate::Trait(trait_ref) };\n         self.register_predicate(tcx, trait_obligation)\n     }\n \n@@ -141,15 +141,15 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n     pub fn register_predicate<'a>(&mut self,\n                                   tcx: &ty::ctxt<'tcx>,\n-                                  predicate: PredicateObligation<'tcx>)\n+                                  obligation: PredicateObligation<'tcx>)\n     {\n-        if !self.duplicate_set.insert(predicate.trait_ref.clone()) {\n-            debug!(\"register_predicate({}) -- already seen, skip\", predicate.repr(tcx));\n+        if !self.duplicate_set.insert(obligation.predicate.clone()) {\n+            debug!(\"register_predicate({}) -- already seen, skip\", obligation.repr(tcx));\n             return;\n         }\n \n-        debug!(\"register_predicate({})\", predicate.repr(tcx));\n-        self.predicates.push(predicate);\n+        debug!(\"register_predicate({})\", obligation.repr(tcx));\n+        self.predicates.push(obligation);\n     }\n \n     pub fn region_obligations(&self,\n@@ -289,7 +289,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n }\n \n fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n-                              predicate: &PredicateObligation<'tcx>,\n+                              obligation: &PredicateObligation<'tcx>,\n                               selections: &mut Vec<Selection<'tcx>>,\n                               errors: &mut Vec<FulfillmentError<'tcx>>,\n                               region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n@@ -303,11 +303,9 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n      */\n \n     let tcx = selcx.tcx();\n-    match predicate.trait_ref {\n+    match obligation.predicate {\n         ty::Predicate::Trait(ref trait_ref) => {\n-            let trait_obligation = Obligation { cause: predicate.cause.clone(),\n-                                                recursion_depth: predicate.recursion_depth,\n-                                                trait_ref: trait_ref.clone() };\n+            let trait_obligation = obligation.with(trait_ref.clone());\n             match selcx.select(&trait_obligation) {\n                 Ok(None) => {\n                     false\n@@ -318,37 +316,37 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n                 }\n                 Err(selection_err) => {\n                     debug!(\"predicate: {} error: {}\",\n-                           predicate.repr(tcx),\n+                           obligation.repr(tcx),\n                            selection_err.repr(tcx));\n                     errors.push(\n                         FulfillmentError::new(\n-                            predicate.clone(),\n+                            obligation.clone(),\n                             CodeSelectionError(selection_err)));\n                     true\n                 }\n             }\n         }\n \n         ty::Predicate::Equate(ref binder) => {\n-            match selcx.infcx().equality_predicate(predicate.cause.span, binder) {\n+            match selcx.infcx().equality_predicate(obligation.cause.span, binder) {\n                 Ok(()) => { }\n                 Err(_) => {\n                     errors.push(\n                         FulfillmentError::new(\n-                            predicate.clone(),\n+                            obligation.clone(),\n                             CodeSelectionError(Unimplemented)));\n                 }\n             }\n             true\n         }\n \n         ty::Predicate::RegionOutlives(ref binder) => {\n-            match selcx.infcx().region_outlives_predicate(predicate.cause.span, binder) {\n+            match selcx.infcx().region_outlives_predicate(obligation.cause.span, binder) {\n                 Ok(()) => { }\n                 Err(_) => {\n                     errors.push(\n                         FulfillmentError::new(\n-                            predicate.clone(),\n+                            obligation.clone(),\n                             CodeSelectionError(Unimplemented)));\n                 }\n             }\n@@ -364,12 +362,12 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n             if ty::count_late_bound_regions(selcx.tcx(), binder) != 0 {\n                 errors.push(\n                     FulfillmentError::new(\n-                        predicate.clone(),\n+                        obligation.clone(),\n                         CodeSelectionError(Unimplemented)));\n             } else {\n                 let ty::OutlivesPredicate(t_a, r_b) = binder.0;\n                 register_region_obligation(tcx, t_a, r_b,\n-                                           predicate.cause.clone(),\n+                                           obligation.cause.clone(),\n                                            region_obligations);\n             }\n             true"}, {"sha": "41c55abc9ae0f808d8b58b48b3b572053cc4b7fd", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/986f654f3b087809fbf9b1168708e46b4211da84/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/986f654f3b087809fbf9b1168708e46b4211da84/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=986f654f3b087809fbf9b1168708e46b4211da84", "patch": "@@ -53,7 +53,7 @@ mod util;\n pub struct Obligation<'tcx, T> {\n     pub cause: ObligationCause<'tcx>,\n     pub recursion_depth: uint,\n-    pub trait_ref: T,\n+    pub predicate: T,\n }\n \n pub type PredicateObligation<'tcx> = Obligation<'tcx, ty::Predicate<'tcx>>;\n@@ -310,7 +310,7 @@ impl<'tcx,O> Obligation<'tcx,O> {\n     {\n         Obligation { cause: cause,\n                      recursion_depth: 0,\n-                     trait_ref: trait_ref }\n+                     predicate: trait_ref }\n     }\n \n     pub fn misc(span: Span, body_id: ast::NodeId, trait_ref: O) -> Obligation<'tcx, O> {\n@@ -320,13 +320,13 @@ impl<'tcx,O> Obligation<'tcx,O> {\n     pub fn with<P>(&self, value: P) -> Obligation<'tcx,P> {\n         Obligation { cause: self.cause.clone(),\n                      recursion_depth: self.recursion_depth,\n-                     trait_ref: value }\n+                     predicate: value }\n     }\n }\n \n impl<'tcx> TraitObligation<'tcx> {\n     pub fn self_ty(&self) -> Ty<'tcx> {\n-        self.trait_ref.self_ty()\n+        self.predicate.self_ty()\n     }\n }\n "}, {"sha": "6b56bbac20101fd7e1d33e61dc7511f15a64fef1", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/986f654f3b087809fbf9b1168708e46b4211da84/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/986f654f3b087809fbf9b1168708e46b4211da84/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=986f654f3b087809fbf9b1168708e46b4211da84", "patch": "@@ -218,7 +218,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     pub fn select(&mut self, obligation: &TraitObligation<'tcx>)\n                   -> SelectionResult<'tcx, Selection<'tcx>> {\n         debug!(\"select({})\", obligation.repr(self.tcx()));\n-        assert!(!obligation.trait_ref.has_escaping_regions());\n+        assert!(!obligation.predicate.has_escaping_regions());\n \n         let stack = self.push_stack(None, obligation);\n         match try!(self.candidate_from_obligation(&stack)) {\n@@ -280,7 +280,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(\"evaluate_predicate_recursively({})\",\n                obligation.repr(self.tcx()));\n \n-        match obligation.trait_ref {\n+        match obligation.predicate {\n             ty::Predicate::Trait(ref t) => {\n                 assert!(!t.has_escaping_regions());\n                 let obligation = obligation.with(t.clone());\n@@ -411,7 +411,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         self.infcx.probe(|snapshot| {\n             let (skol_obligation_trait_ref, skol_map) =\n-                self.infcx().skolemize_late_bound_regions(&*obligation.trait_ref, snapshot);\n+                self.infcx().skolemize_late_bound_regions(&*obligation.predicate, snapshot);\n             match self.match_impl(impl_def_id, obligation, snapshot,\n                                   &skol_map, Rc::new(skol_obligation_trait_ref)) {\n                 Ok(substs) => {\n@@ -456,11 +456,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // is because we want the unbound variables to be replaced\n         // with fresh skolemized types starting from index 0.\n         let cache_fresh_trait_ref =\n-            self.infcx.freshen(stack.obligation.trait_ref.clone());\n+            self.infcx.freshen(stack.obligation.predicate.clone());\n         debug!(\"candidate_from_obligation(cache_fresh_trait_ref={}, obligation={})\",\n                cache_fresh_trait_ref.repr(self.tcx()),\n                stack.repr(self.tcx()));\n-        assert!(!stack.obligation.trait_ref.has_escaping_regions());\n+        assert!(!stack.obligation.predicate.has_escaping_regions());\n \n         match self.check_candidate_cache(cache_fresh_trait_ref.clone()) {\n             Some(c) => {\n@@ -655,7 +655,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // Other bounds. Consider both in-scope bounds from fn decl\n         // and applicable impls. There is a certain set of precedence rules here.\n \n-        match self.tcx().lang_items.to_builtin_kind(obligation.trait_ref.def_id()) {\n+        match self.tcx().lang_items.to_builtin_kind(obligation.predicate.def_id()) {\n             Some(ty::BoundCopy) => {\n                 debug!(\"obligation self ty is {}\",\n                        obligation.self_ty().repr(self.tcx()));\n@@ -747,7 +747,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                            candidates: &mut CandidateSet<'tcx>)\n                                            -> Result<(),SelectionError<'tcx>>\n     {\n-        let kind = match self.fn_family_trait_kind(obligation.trait_ref.def_id()) {\n+        let kind = match self.fn_family_trait_kind(obligation.predicate.def_id()) {\n             Some(k) => k,\n             None => { return Ok(()); }\n         };\n@@ -795,7 +795,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // We provide a `Fn` impl for fn pointers. There is no need to provide\n         // the other traits (e.g. `FnMut`) since those are provided by blanket\n         // impls.\n-        if Some(obligation.trait_ref.def_id()) != self.tcx().lang_items.fn_trait() {\n+        if Some(obligation.predicate.def_id()) != self.tcx().lang_items.fn_trait() {\n             return Ok(());\n         }\n \n@@ -830,11 +830,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                       candidate_vec: &mut Vec<Candidate<'tcx>>)\n                                       -> Result<(), SelectionError<'tcx>>\n     {\n-        let all_impls = self.all_impls(obligation.trait_ref.def_id());\n+        let all_impls = self.all_impls(obligation.predicate.def_id());\n         for &impl_def_id in all_impls.iter() {\n             self.infcx.probe(|snapshot| {\n                 let (skol_obligation_trait_ref, skol_map) =\n-                    self.infcx().skolemize_late_bound_regions(&*obligation.trait_ref, snapshot);\n+                    self.infcx().skolemize_late_bound_regions(&*obligation.predicate, snapshot);\n                 match self.match_impl(impl_def_id, obligation, snapshot,\n                                       &skol_map, Rc::new(skol_obligation_trait_ref)) {\n                     Ok(_) => {\n@@ -931,7 +931,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.infcx.probe(|snapshot| {\n                     let (skol_obligation_trait_ref, skol_map) =\n                         self.infcx().skolemize_late_bound_regions(\n-                            &*stack.obligation.trait_ref, snapshot);\n+                            &*stack.obligation.predicate, snapshot);\n                     let impl_substs =\n                         self.rematch_impl(impl_def_id, stack.obligation, snapshot,\n                                           &skol_map, Rc::new(skol_obligation_trait_ref));\n@@ -987,7 +987,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                      obligation: &TraitObligation<'tcx>)\n                      -> Result<BuiltinBoundConditions<'tcx>,SelectionError<'tcx>>\n     {\n-        let self_ty = self.infcx.shallow_resolve(obligation.trait_ref.self_ty());\n+        let self_ty = self.infcx.shallow_resolve(obligation.predicate.self_ty());\n         return match self_ty.sty {\n             ty::ty_infer(ty::IntVar(_)) |\n             ty::ty_infer(ty::FloatVar(_)) |\n@@ -1415,7 +1415,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // trait-ref. Repeat that unification now without any\n         // transactional boundary; it should not fail.\n         match self.confirm_poly_trait_refs(obligation.cause.clone(),\n-                                           obligation.trait_ref.clone(),\n+                                           obligation.predicate.clone(),\n                                            param.bound.clone()) {\n             Ok(()) => Ok(param),\n             Err(_) => {\n@@ -1472,7 +1472,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             obligations.push(Obligation {\n                 cause: obligation.cause.clone(),\n                 recursion_depth: obligation.recursion_depth+1,\n-                trait_ref: ty::Binder(ty::OutlivesPredicate(obligation.self_ty(),\n+                predicate: ty::Binder(ty::OutlivesPredicate(obligation.self_ty(),\n                                                             ty::ReStatic)).as_predicate(),\n             });\n         }\n@@ -1500,7 +1500,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // this time not in a probe.\n         self.infcx.try(|snapshot| {\n             let (skol_obligation_trait_ref, skol_map) =\n-                self.infcx().skolemize_late_bound_regions(&*obligation.trait_ref, snapshot);\n+                self.infcx().skolemize_late_bound_regions(&*obligation.predicate, snapshot);\n             let substs = self.rematch_impl(impl_def_id, obligation,\n                                            snapshot, &skol_map, Rc::new(skol_obligation_trait_ref));\n             debug!(\"confirm_impl_candidate substs={}\", substs);\n@@ -1574,12 +1574,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 vec![],\n                 self_ty);\n         let trait_ref = Rc::new(ty::Binder(ty::TraitRef {\n-            def_id: obligation.trait_ref.def_id(),\n+            def_id: obligation.predicate.def_id(),\n             substs: self.tcx().mk_substs(substs),\n         }));\n \n         try!(self.confirm_poly_trait_refs(obligation.cause.clone(),\n-                                          obligation.trait_ref.clone(),\n+                                          obligation.predicate.clone(),\n                                           trait_ref));\n         Ok(self_ty)\n     }\n@@ -1615,7 +1615,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 vec![],\n                 obligation.self_ty());\n         let trait_ref = Rc::new(ty::Binder(ty::TraitRef {\n-            def_id: obligation.trait_ref.def_id(),\n+            def_id: obligation.predicate.def_id(),\n             substs: self.tcx().mk_substs(substs),\n         }));\n \n@@ -1624,7 +1624,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                trait_ref.repr(self.tcx()));\n \n         self.confirm_poly_trait_refs(obligation.cause.clone(),\n-                                     obligation.trait_ref.clone(),\n+                                     obligation.predicate.clone(),\n                                      trait_ref)\n     }\n \n@@ -1769,7 +1769,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // substitution if we find that any of the input types, when\n         // simplified, do not match.\n \n-        obligation.trait_ref.input_types().iter()\n+        obligation.predicate.input_types().iter()\n             .zip(impl_trait_ref.input_types().iter())\n             .any(|(&obligation_ty, &impl_ty)| {\n                 let simplified_obligation_ty =\n@@ -1796,7 +1796,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         match self.infcx.sub_poly_trait_refs(false,\n                                              origin,\n                                              where_clause_trait_ref,\n-                                             obligation.trait_ref.clone()) {\n+                                             obligation.predicate.clone()) {\n             Ok(()) => Ok(()),\n             Err(_) => Err(()),\n         }\n@@ -1878,7 +1878,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             obligation: &'o TraitObligation<'tcx>)\n                             -> TraitObligationStack<'o, 'tcx>\n     {\n-        let fresh_trait_ref = obligation.trait_ref.fold_with(&mut self.freshener);\n+        let fresh_trait_ref = obligation.predicate.fold_with(&mut self.freshener);\n \n         TraitObligationStack {\n             obligation: obligation,\n@@ -2020,7 +2020,8 @@ impl<'tcx> EvaluationResult<'tcx> {\n             EvaluatedToOk |\n             EvaluatedToAmbig |\n             EvaluatedToErr(Overflow) |\n-            EvaluatedToErr(OutputTypeParameterMismatch(..)) => {\n+            EvaluatedToErr(OutputTypeParameterMismatch(..)) |\n+            EvaluatedToErr(ProjectionMismatch(..)) => {\n                 true\n             }\n             EvaluatedToErr(Unimplemented) => {"}, {"sha": "6b95e983e88916d72e0cdf3a7ceb361b42470ee1", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/986f654f3b087809fbf9b1168708e46b4211da84/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/986f654f3b087809fbf9b1168708e46b4211da84/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=986f654f3b087809fbf9b1168708e46b4211da84", "patch": "@@ -261,7 +261,7 @@ pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n     generic_bounds.predicates.map(|predicate| {\n         Obligation { cause: cause.clone(),\n                      recursion_depth: recursion_depth,\n-                     trait_ref: predicate.clone() }\n+                     predicate: predicate.clone() }\n     })\n }\n \n@@ -297,7 +297,7 @@ pub fn predicate_for_builtin_bound<'tcx>(\n     Ok(Obligation {\n         cause: cause,\n         recursion_depth: recursion_depth,\n-        trait_ref: ty::Predicate::Trait(trait_ref),\n+        predicate: ty::Predicate::Trait(trait_ref),\n     })\n }\n \n@@ -323,8 +323,8 @@ pub fn search_trait_and_supertraits_from_bound<'tcx,F>(tcx: &ty::ctxt<'tcx>,\n \n impl<'tcx,O:Repr<'tcx>> Repr<'tcx> for super::Obligation<'tcx, O> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        format!(\"Obligation(trait_ref={},depth={})\",\n-                self.trait_ref.repr(tcx),\n+        format!(\"Obligation(predicate={},depth={})\",\n+                self.predicate.repr(tcx),\n                 self.recursion_depth)\n     }\n }\n@@ -390,6 +390,12 @@ impl<'tcx> Repr<'tcx> for super::SelectionError<'tcx> {\n                         a.repr(tcx),\n                         b.repr(tcx),\n                         c.repr(tcx)),\n+\n+            super::ProjectionMismatch(ref a, ref b, ref c) =>\n+                format!(\"PrjectionMismatch({},{},{})\",\n+                        a.repr(tcx),\n+                        b.repr(tcx),\n+                        c.repr(tcx)),\n         }\n     }\n }"}, {"sha": "11a130f0c540784539d655a9d10b82d41ecee650", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/986f654f3b087809fbf9b1168708e46b4211da84/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/986f654f3b087809fbf9b1168708e46b4211da84/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=986f654f3b087809fbf9b1168708e46b4211da84", "patch": "@@ -441,7 +441,7 @@ impl<'tcx,O> TypeFoldable<'tcx> for traits::Obligation<'tcx,O>\n         traits::Obligation {\n             cause: self.cause.clone(),\n             recursion_depth: self.recursion_depth,\n-            trait_ref: self.trait_ref.fold_with(folder),\n+            predicate: self.predicate.fold_with(folder),\n         }\n     }\n }"}]}