{"sha": "85397286071c7971aded6b2c987aaa7f507d2312", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1Mzk3Mjg2MDcxYzc5NzFhZGVkNmIyYzk4N2FhYTdmNTA3ZDIzMTI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-08-25T12:41:59Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2017-08-25T12:41:59Z"}, "message": "memory: make sure we check non-NULL/undef even fore 0-sized accesses", "tree": {"sha": "e516f6758c84d786f6e060669fb844eeb3755665", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e516f6758c84d786f6e060669fb844eeb3755665"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85397286071c7971aded6b2c987aaa7f507d2312", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85397286071c7971aded6b2c987aaa7f507d2312", "html_url": "https://github.com/rust-lang/rust/commit/85397286071c7971aded6b2c987aaa7f507d2312", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85397286071c7971aded6b2c987aaa7f507d2312/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e3c502c53319728702088b06de8a9cb6953a7aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e3c502c53319728702088b06de8a9cb6953a7aa", "html_url": "https://github.com/rust-lang/rust/commit/4e3c502c53319728702088b06de8a9cb6953a7aa"}], "stats": {"total": 97, "additions": 47, "deletions": 50}, "files": [{"sha": "8c722a46ae3081df68d8d12c02c7e5c81f430040", "filename": "miri/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85397286071c7971aded6b2c987aaa7f507d2312/miri%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85397286071c7971aded6b2c987aaa7f507d2312/miri%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/miri%2Fintrinsic.rs?ref=85397286071c7971aded6b2c987aaa7f507d2312", "patch": "@@ -4,7 +4,7 @@ use rustc::ty::layout::Layout;\n use rustc::ty::{self, Ty};\n \n use rustc_miri::interpret::{EvalResult, Lvalue, LvalueExtra, PrimVal, PrimValKind, Value, Pointer,\n-                            HasMemory, EvalContext, PtrAndAlign, ValTy};\n+                            HasMemory, AccessKind, EvalContext, PtrAndAlign, ValTy};\n \n use helpers::EvalContextExt as HelperEvalContextExt;\n \n@@ -624,7 +624,7 @@ impl<'a, 'tcx> EvalContextExt<'tcx> for EvalContext<'a, 'tcx, super::Evaluator>\n                 if count > 0 {\n                     // HashMap relies on write_bytes on a NULL ptr with count == 0 to work\n                     // TODO: Should we, at least, validate the alignment? (Also see the copy intrinsic)\n-                    self.memory.check_align(ptr, ty_align)?;\n+                    self.memory.check_align(ptr, ty_align, Some(AccessKind::Write))?;\n                     self.memory.write_repeat(ptr, val_byte, size * count)?;\n                 }\n             }"}, {"sha": "8c7a36f866da349e1272374bc5b4a366464484d2", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 40, "deletions": 43, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/85397286071c7971aded6b2c987aaa7f507d2312/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85397286071c7971aded6b2c987aaa7f507d2312/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=85397286071c7971aded6b2c987aaa7f507d2312", "patch": "@@ -3,7 +3,7 @@ use std::collections::{btree_map, BTreeMap, HashMap, HashSet, VecDeque};\n use std::{fmt, iter, ptr, mem, io};\n use std::cell::Cell;\n \n-use rustc::ty;\n+use rustc::ty::Instance;\n use rustc::ty::layout::{self, TargetDataLayout, HasDataLayout};\n use syntax::ast::Mutability;\n use rustc::middle::region::CodeExtent;\n@@ -250,10 +250,10 @@ pub struct Memory<'a, 'tcx, M: Machine<'tcx>> {\n \n     /// Function \"allocations\". They exist solely so pointers have something to point to, and\n     /// we can figure out what they point to.\n-    functions: Vec<ty::Instance<'tcx>>,\n+    functions: Vec<Instance<'tcx>>,\n \n     /// Inverse map of `functions` so we don't allocate a new pointer every time we need one\n-    function_alloc_cache: HashMap<ty::Instance<'tcx>, AllocId>,\n+    function_alloc_cache: HashMap<Instance<'tcx>, AllocId>,\n \n     /// Target machine data layout to emulate.\n     pub layout: &'a TargetDataLayout,\n@@ -297,7 +297,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         })\n     }\n \n-    pub fn create_fn_alloc(&mut self, instance: ty::Instance<'tcx>) -> MemoryPointer {\n+    pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> MemoryPointer {\n         if let Some(&alloc_id) = self.function_alloc_cache.get(&instance) {\n             return MemoryPointer::new(alloc_id, 0);\n         }\n@@ -476,27 +476,38 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     }\n \n     /// Check that the pointer is aligned AND non-NULL.\n-    pub fn check_align(&self, ptr: Pointer, align: u64) -> EvalResult<'tcx> {\n-        let offset = match ptr.into_inner_primval() {\n+    pub fn check_align(&self, ptr: Pointer, align: u64, access: Option<AccessKind>) -> EvalResult<'tcx> {\n+        // Check non-NULL/Undef, extract offset\n+        let (offset, alloc_align) = match ptr.into_inner_primval() {\n             PrimVal::Ptr(ptr) => {\n                 let alloc = self.get(ptr.alloc_id)?;\n-                if alloc.align < align {\n-                    return err!(AlignmentCheckFailed {\n-                        has: alloc.align,\n-                        required: align,\n-                    });\n-                }\n-                ptr.offset\n+                (ptr.offset, alloc.align)\n             }\n             PrimVal::Bytes(bytes) => {\n                 let v = ((bytes as u128) % (1 << self.pointer_size())) as u64;\n                 if v == 0 {\n                     return err!(InvalidNullPointerUsage);\n                 }\n-                v\n+                (v, align) // the base address if the \"integer allocation\" is 0 and hence always aligned\n             }\n             PrimVal::Undef => return err!(ReadUndefBytes),\n         };\n+        // See if alignment checking is disabled\n+        let enforce_alignment = match access {\n+            Some(AccessKind::Read) => self.reads_are_aligned.get(),\n+            Some(AccessKind::Write) => self.writes_are_aligned.get(),\n+            None => true,\n+        };\n+        if !enforce_alignment {\n+            return Ok(());\n+        }\n+        // Check alignment\n+        if alloc_align < align {\n+            return err!(AlignmentCheckFailed {\n+                has: alloc_align,\n+                required: align,\n+            });\n+        }\n         if offset % align == 0 {\n             Ok(())\n         } else {\n@@ -804,7 +815,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         }\n     }\n \n-    pub fn get_mut(&mut self, id: AllocId) -> EvalResult<'tcx, &mut Allocation<M::MemoryKinds>> {\n+    fn get_mut(&mut self, id: AllocId) -> EvalResult<'tcx, &mut Allocation<M::MemoryKinds>> {\n         let alloc = self.get_mut_unchecked(id)?;\n         if alloc.mutable == Mutability::Mutable {\n             Ok(alloc)\n@@ -813,7 +824,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         }\n     }\n \n-    pub fn get_fn(&self, ptr: MemoryPointer) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n+    pub fn get_fn(&self, ptr: MemoryPointer) -> EvalResult<'tcx, Instance<'tcx>> {\n         if ptr.offset != 0 {\n             return err!(InvalidFunctionPointer);\n         }\n@@ -933,9 +944,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         align: u64,\n     ) -> EvalResult<'tcx, &[u8]> {\n         // Zero-sized accesses can use dangling pointers, but they still have to be aligned and non-NULL\n-        if self.reads_are_aligned.get() {\n-            self.check_align(ptr.into(), align)?;\n-        }\n+        self.check_align(ptr.into(), align, Some(AccessKind::Read))?;\n         if size == 0 {\n             return Ok(&[]);\n         }\n@@ -955,9 +964,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         align: u64,\n     ) -> EvalResult<'tcx, &mut [u8]> {\n         // Zero-sized accesses can use dangling pointers, but they still have to be aligned and non-NULL\n-        if self.writes_are_aligned.get() {\n-            self.check_align(ptr.into(), align)?;\n-        }\n+        self.check_align(ptr.into(), align, Some(AccessKind::Write))?;\n         if size == 0 {\n             return Ok(&mut []);\n         }\n@@ -995,7 +1002,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n /// Reading and writing\n impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     /// mark an allocation pointed to by a static as static and initialized\n-    pub fn mark_inner_allocation(\n+    fn mark_inner_allocation_initialized(\n         &mut self,\n         alloc: AllocId,\n         mutability: Mutability,\n@@ -1056,7 +1063,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         };\n         // recurse into inner allocations\n         for &alloc in relocations.values() {\n-            self.mark_inner_allocation(alloc, mutability)?;\n+            self.mark_inner_allocation_initialized(alloc, mutability)?;\n         }\n         // put back the relocations\n         self.alloc_map\n@@ -1074,14 +1081,10 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n         align: u64,\n         nonoverlapping: bool,\n     ) -> EvalResult<'tcx> {\n+        // Empty accesses don't need to be valid pointers, but they should still be aligned\n+        self.check_align(src, align, Some(AccessKind::Read))?;\n+        self.check_align(dest, align, Some(AccessKind::Write))?;\n         if size == 0 {\n-            // Empty accesses don't need to be valid pointers, but they should still be aligned\n-            if self.reads_are_aligned.get() {\n-                self.check_align(src, align)?;\n-            }\n-            if self.writes_are_aligned.get() {\n-                self.check_align(dest, align)?;\n-            }\n             return Ok(());\n         }\n         let src = src.to_ptr()?;\n@@ -1136,22 +1139,18 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     }\n \n     pub fn read_bytes(&self, ptr: Pointer, size: u64) -> EvalResult<'tcx, &[u8]> {\n+        // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n+        self.check_align(ptr, 1, Some(AccessKind::Read))?;\n         if size == 0 {\n-            // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n-            if self.reads_are_aligned.get() {\n-                self.check_align(ptr, 1)?;\n-            }\n             return Ok(&[]);\n         }\n         self.get_bytes(ptr.to_ptr()?, size, 1)\n     }\n \n     pub fn write_bytes(&mut self, ptr: Pointer, src: &[u8]) -> EvalResult<'tcx> {\n+        // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n+        self.check_align(ptr, 1, Some(AccessKind::Write))?;\n         if src.is_empty() {\n-            // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n-            if self.writes_are_aligned.get() {\n-                self.check_align(ptr, 1)?;\n-            }\n             return Ok(());\n         }\n         let bytes = self.get_bytes_mut(ptr.to_ptr()?, src.len() as u64, 1)?;\n@@ -1160,11 +1159,9 @@ impl<'a, 'tcx, M: Machine<'tcx>> Memory<'a, 'tcx, M> {\n     }\n \n     pub fn write_repeat(&mut self, ptr: Pointer, val: u8, count: u64) -> EvalResult<'tcx> {\n+        // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n+        self.check_align(ptr, 1, Some(AccessKind::Write))?;\n         if count == 0 {\n-            // Empty accesses don't need to be valid pointers, but they should still be non-NULL\n-            if self.writes_are_aligned.get() {\n-                self.check_align(ptr, 1)?;\n-            }\n             return Ok(());\n         }\n         let bytes = self.get_bytes_mut(ptr.to_ptr()?, count, 1)?;"}, {"sha": "634b8a0eeb8a4e7cbe87ddc571e5d2797338bca9", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/85397286071c7971aded6b2c987aaa7f507d2312/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85397286071c7971aded6b2c987aaa7f507d2312/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=85397286071c7971aded6b2c987aaa7f507d2312", "patch": "@@ -27,9 +27,9 @@ pub use self::eval_context::{EvalContext, Frame, ResourceLimits, StackPopCleanup\n \n pub use self::lvalue::{Lvalue, LvalueExtra, GlobalId};\n \n-pub use self::memory::{AllocId, Memory, MemoryPointer, MemoryKind, HasMemory};\n+pub use self::memory::{AllocId, Memory, MemoryPointer, MemoryKind, HasMemory, AccessKind};\n \n-use self::memory::{PointerArithmetic, Lock, AccessKind};\n+use self::memory::{PointerArithmetic, Lock};\n \n use self::range_map::RangeMap;\n "}, {"sha": "6454e12e037f4919de13e18b71ec4d922f91dfbd", "filename": "src/librustc_mir/interpret/validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85397286071c7971aded6b2c987aaa7f507d2312/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85397286071c7971aded6b2c987aaa7f507d2312/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidation.rs?ref=85397286071c7971aded6b2c987aaa7f507d2312", "patch": "@@ -275,7 +275,7 @@ impl<'a, 'tcx, M: Machine<'tcx>> EvalContext<'a, 'tcx, M> {\n         // Check alignment and non-NULLness\n         let (_, align) = self.size_and_align_of_dst(pointee_ty, val)?;\n         let ptr = val.into_ptr(&self.memory)?;\n-        self.memory.check_align(ptr, align)?;\n+        self.memory.check_align(ptr, align, None)?;\n \n         // Recurse\n         let pointee_lvalue = self.val_to_lvalue(val, pointee_ty)?;"}, {"sha": "5a26856eba0879d8cd55f0b4f6d1b589844e174e", "filename": "tests/compile-fail/null_pointer_deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85397286071c7971aded6b2c987aaa7f507d2312/tests%2Fcompile-fail%2Fnull_pointer_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85397286071c7971aded6b2c987aaa7f507d2312/tests%2Fcompile-fail%2Fnull_pointer_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fnull_pointer_deref.rs?ref=85397286071c7971aded6b2c987aaa7f507d2312", "patch": "@@ -1,4 +1,4 @@\n fn main() {\n-    let x: i32 = unsafe { *std::ptr::null() }; //~ ERROR: a memory access tried to interpret some bytes as a pointer\n+    let x: i32 = unsafe { *std::ptr::null() }; //~ ERROR: invalid use of NULL pointer\n     panic!(\"this should never print: {}\", x);\n }"}, {"sha": "57da8dfc01b27f2931f05c0bff5cf0bc18c58816", "filename": "tests/compile-fail/wild_pointer_deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85397286071c7971aded6b2c987aaa7f507d2312/tests%2Fcompile-fail%2Fwild_pointer_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85397286071c7971aded6b2c987aaa7f507d2312/tests%2Fcompile-fail%2Fwild_pointer_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fwild_pointer_deref.rs?ref=85397286071c7971aded6b2c987aaa7f507d2312", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n-    let p = 42 as *const i32;\n+    let p = 44 as *const i32;\n     let x = unsafe { *p }; //~ ERROR: a memory access tried to interpret some bytes as a pointer\n     panic!(\"this should never print: {}\", x);\n }"}]}