{"sha": "2d4e94a501d77248e6c8bbf08b8489a823bc7c29", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkNGU5NGE1MDFkNzcyNDhlNmM4YmJmMDhiODQ4OWE4MjNiYzdjMjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-03T13:05:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-02-03T13:05:18Z"}, "message": "Auto merge of #31385 - oli-obk:doc/mir, r=nagisa\n\nI didn't change any content, just added another slash so we can see those comments in the docs\n\nr? @steveklabnik", "tree": {"sha": "6d0ab3b839c3e0cba17afbb7a3efc8f9c16958c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d0ab3b839c3e0cba17afbb7a3efc8f9c16958c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d4e94a501d77248e6c8bbf08b8489a823bc7c29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d4e94a501d77248e6c8bbf08b8489a823bc7c29", "html_url": "https://github.com/rust-lang/rust/commit/2d4e94a501d77248e6c8bbf08b8489a823bc7c29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d4e94a501d77248e6c8bbf08b8489a823bc7c29/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db6f888e7830b0b91a03b2cf141ba0511adaca5b", "url": "https://api.github.com/repos/rust-lang/rust/commits/db6f888e7830b0b91a03b2cf141ba0511adaca5b", "html_url": "https://github.com/rust-lang/rust/commit/db6f888e7830b0b91a03b2cf141ba0511adaca5b"}, {"sha": "4e44ef1e29932ad7ca69ddf6bc7ad4011a8bb3fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e44ef1e29932ad7ca69ddf6bc7ad4011a8bb3fa", "html_url": "https://github.com/rust-lang/rust/commit/4e44ef1e29932ad7ca69ddf6bc7ad4011a8bb3fa"}], "stats": {"total": 178, "additions": 92, "deletions": 86}, "files": [{"sha": "988bf2c76a80f1a4d84bbcf4a8015b84fd7e69ad", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 59, "deletions": 55, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/2d4e94a501d77248e6c8bbf08b8489a823bc7c29/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d4e94a501d77248e6c8bbf08b8489a823bc7c29/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=2d4e94a501d77248e6c8bbf08b8489a823bc7c29", "patch": "@@ -144,33 +144,33 @@ pub enum BorrowKind {\n ///////////////////////////////////////////////////////////////////////////\n // Variables and temps\n \n-// A \"variable\" is a binding declared by the user as part of the fn\n-// decl, a let, etc.\n+/// A \"variable\" is a binding declared by the user as part of the fn\n+/// decl, a let, etc.\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct VarDecl<'tcx> {\n     pub mutability: Mutability,\n     pub name: Name,\n     pub ty: Ty<'tcx>,\n }\n \n-// A \"temp\" is a temporary that we place on the stack. They are\n-// anonymous, always mutable, and have only a type.\n+/// A \"temp\" is a temporary that we place on the stack. They are\n+/// anonymous, always mutable, and have only a type.\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct TempDecl<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n \n-// A \"arg\" is one of the function's formal arguments. These are\n-// anonymous and distinct from the bindings that the user declares.\n-//\n-// For example, in this function:\n-//\n-// ```\n-// fn foo((x, y): (i32, u32)) { ... }\n-// ```\n-//\n-// there is only one argument, of type `(i32, u32)`, but two bindings\n-// (`x` and `y`).\n+/// A \"arg\" is one of the function's formal arguments. These are\n+/// anonymous and distinct from the bindings that the user declares.\n+///\n+/// For example, in this function:\n+///\n+/// ```\n+/// fn foo((x, y): (i32, u32)) { ... }\n+/// ```\n+///\n+/// there is only one argument, of type `(i32, u32)`, but two bindings\n+/// (`x` and `y`).\n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub struct ArgDecl<'tcx> {\n     pub ty: Ty<'tcx>,\n@@ -495,7 +495,8 @@ pub enum StatementKind<'tcx> {\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable)]\n pub enum DropKind {\n-    Free, // free a partially constructed box, should go away eventually\n+    /// free a partially constructed box, should go away eventually\n+    Free,\n     Deep\n }\n \n@@ -552,24 +553,27 @@ pub enum ProjectionElem<'tcx, V> {\n     Field(Field),\n     Index(V),\n \n-    // These indices are generated by slice patterns. Easiest to explain\n-    // by example:\n-    //\n-    // ```\n-    // [X, _, .._, _, _] => { offset: 0, min_length: 4, from_end: false },\n-    // [_, X, .._, _, _] => { offset: 1, min_length: 4, from_end: false },\n-    // [_, _, .._, X, _] => { offset: 2, min_length: 4, from_end: true },\n-    // [_, _, .._, _, X] => { offset: 1, min_length: 4, from_end: true },\n-    // ```\n+    /// These indices are generated by slice patterns. Easiest to explain\n+    /// by example:\n+    ///\n+    /// ```\n+    /// [X, _, .._, _, _] => { offset: 0, min_length: 4, from_end: false },\n+    /// [_, X, .._, _, _] => { offset: 1, min_length: 4, from_end: false },\n+    /// [_, _, .._, X, _] => { offset: 2, min_length: 4, from_end: true },\n+    /// [_, _, .._, _, X] => { offset: 1, min_length: 4, from_end: true },\n+    /// ```\n     ConstantIndex {\n-        offset: u32,      // index or -index (in Python terms), depending on from_end\n-        min_length: u32,  // thing being indexed must be at least this long\n-        from_end: bool,   // counting backwards from end?\n+        /// index or -index (in Python terms), depending on from_end\n+        offset: u32,\n+        /// thing being indexed must be at least this long\n+        min_length: u32,\n+        /// counting backwards from end?\n+        from_end: bool,\n     },\n \n-    // \"Downcast\" to a variant of an ADT. Currently, we only introduce\n-    // this for ADTs with more than one variant. It may be better to\n-    // just introduce it always, or always for enums.\n+    /// \"Downcast\" to a variant of an ADT. Currently, we only introduce\n+    /// this for ADTs with more than one variant. It may be better to\n+    /// just introduce it always, or always for enums.\n     Downcast(AdtDef<'tcx>, usize),\n }\n \n@@ -654,9 +658,9 @@ impl<'tcx> Debug for Lvalue<'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Operands\n //\n-// These are values that can appear inside an rvalue (or an index\n-// lvalue). They are intentionally limited to prevent rvalues from\n-// being nested in one another.\n+/// These are values that can appear inside an rvalue (or an index\n+/// lvalue). They are intentionally limited to prevent rvalues from\n+/// being nested in one another.\n \n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n pub enum Operand<'tcx> {\n@@ -675,20 +679,20 @@ impl<'tcx> Debug for Operand<'tcx> {\n }\n \n ///////////////////////////////////////////////////////////////////////////\n-// Rvalues\n+/// Rvalues\n \n #[derive(Clone, RustcEncodable, RustcDecodable)]\n pub enum Rvalue<'tcx> {\n-    // x (either a move or copy, depending on type of x)\n+    /// x (either a move or copy, depending on type of x)\n     Use(Operand<'tcx>),\n \n-    // [x; 32]\n+    /// [x; 32]\n     Repeat(Operand<'tcx>, TypedConstVal<'tcx>),\n \n-    // &x or &mut x\n+    /// &x or &mut x\n     Ref(Region, BorrowKind, Lvalue<'tcx>),\n \n-    // length of a [X] or [X;n] value\n+    /// length of a [X] or [X;n] value\n     Len(Lvalue<'tcx>),\n \n     Cast(CastKind, Operand<'tcx>, Ty<'tcx>),\n@@ -697,21 +701,21 @@ pub enum Rvalue<'tcx> {\n \n     UnaryOp(UnOp, Operand<'tcx>),\n \n-    // Creates an *uninitialized* Box\n+    /// Creates an *uninitialized* Box\n     Box(Ty<'tcx>),\n \n-    // Create an aggregate value, like a tuple or struct.  This is\n-    // only needed because we want to distinguish `dest = Foo { x:\n-    // ..., y: ... }` from `dest.x = ...; dest.y = ...;` in the case\n-    // that `Foo` has a destructor. These rvalues can be optimized\n-    // away after type-checking and before lowering.\n+    /// Create an aggregate value, like a tuple or struct.  This is\n+    /// only needed because we want to distinguish `dest = Foo { x:\n+    /// ..., y: ... }` from `dest.x = ...; dest.y = ...;` in the case\n+    /// that `Foo` has a destructor. These rvalues can be optimized\n+    /// away after type-checking and before lowering.\n     Aggregate(AggregateKind<'tcx>, Vec<Operand<'tcx>>),\n \n-    // Generates a slice of the form `&input[from_start..L-from_end]`\n-    // where `L` is the length of the slice. This is only created by\n-    // slice pattern matching, so e.g. a pattern of the form `[x, y,\n-    // .., z]` might create a slice with `from_start=2` and\n-    // `from_end=1`.\n+    /// Generates a slice of the form `&input[from_start..L-from_end]`\n+    /// where `L` is the length of the slice. This is only created by\n+    /// slice pattern matching, so e.g. a pattern of the form `[x, y,\n+    /// .., z]` might create a slice with `from_start=2` and\n+    /// `from_end=1`.\n     Slice {\n         input: Lvalue<'tcx>,\n         from_start: usize,\n@@ -878,11 +882,11 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n }\n \n ///////////////////////////////////////////////////////////////////////////\n-// Constants\n-//\n-// Two constants are equal if they are the same constant. Note that\n-// this does not necessarily mean that they are \"==\" in Rust -- in\n-// particular one must be wary of `NaN`!\n+/// Constants\n+///\n+/// Two constants are equal if they are the same constant. Note that\n+/// this does not necessarily mean that they are \"==\" in Rust -- in\n+/// particular one must be wary of `NaN`!\n \n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable)]\n pub struct Constant<'tcx> {"}, {"sha": "86b348581892b63e07b70708adf8b7c9a674073c", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2d4e94a501d77248e6c8bbf08b8489a823bc7c29/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d4e94a501d77248e6c8bbf08b8489a823bc7c29/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=2d4e94a501d77248e6c8bbf08b8489a823bc7c29", "patch": "@@ -34,10 +34,10 @@ struct CFG<'tcx> {\n }\n \n ///////////////////////////////////////////////////////////////////////////\n-// The `BlockAnd` \"monad\" packages up the new basic block along with a\n-// produced value (sometimes just unit, of course). The `unpack!`\n-// macro (and methods below) makes working with `BlockAnd` much more\n-// convenient.\n+/// The `BlockAnd` \"monad\" packages up the new basic block along with a\n+/// produced value (sometimes just unit, of course). The `unpack!`\n+/// macro (and methods below) makes working with `BlockAnd` much more\n+/// convenient.\n \n #[must_use] // if you don't use one of these results, you're leaving a dangling edge\n pub struct BlockAnd<T>(BasicBlock, T);\n@@ -77,7 +77,7 @@ macro_rules! unpack {\n }\n \n ///////////////////////////////////////////////////////////////////////////\n-// construct() -- the main entry point for building MIR for a function\n+/// the main entry point for building MIR for a function\n \n pub fn construct<'a,'tcx>(hir: Cx<'a,'tcx>,\n                           _span: Span,"}, {"sha": "b356e3886d10ab2a41c4ee66db5cb4fcab17689d", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/2d4e94a501d77248e6c8bbf08b8489a823bc7c29/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d4e94a501d77248e6c8bbf08b8489a823bc7c29/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=2d4e94a501d77248e6c8bbf08b8489a823bc7c29", "patch": "@@ -85,33 +85,33 @@ pub enum StmtKind<'tcx> {\n     },\n }\n \n-// The Hair trait implementor translates their expressions (`&'tcx H::Expr`)\n-// into instances of this `Expr` enum. This translation can be done\n-// basically as lazilly or as eagerly as desired: every recursive\n-// reference to an expression in this enum is an `ExprRef<'tcx>`, which\n-// may in turn be another instance of this enum (boxed), or else an\n-// untranslated `&'tcx H::Expr`. Note that instances of `Expr` are very\n-// shortlived. They are created by `Hair::to_expr`, analyzed and\n-// converted into MIR, and then discarded.\n-//\n-// If you compare `Expr` to the full compiler AST, you will see it is\n-// a good bit simpler. In fact, a number of the more straight-forward\n-// MIR simplifications are already done in the impl of `Hair`. For\n-// example, method calls and overloaded operators are absent: they are\n-// expected to be converted into `Expr::Call` instances.\n+/// The Hair trait implementor translates their expressions (`&'tcx H::Expr`)\n+/// into instances of this `Expr` enum. This translation can be done\n+/// basically as lazilly or as eagerly as desired: every recursive\n+/// reference to an expression in this enum is an `ExprRef<'tcx>`, which\n+/// may in turn be another instance of this enum (boxed), or else an\n+/// untranslated `&'tcx H::Expr`. Note that instances of `Expr` are very\n+/// shortlived. They are created by `Hair::to_expr`, analyzed and\n+/// converted into MIR, and then discarded.\n+///\n+/// If you compare `Expr` to the full compiler AST, you will see it is\n+/// a good bit simpler. In fact, a number of the more straight-forward\n+/// MIR simplifications are already done in the impl of `Hair`. For\n+/// example, method calls and overloaded operators are absent: they are\n+/// expected to be converted into `Expr::Call` instances.\n #[derive(Clone, Debug)]\n pub struct Expr<'tcx> {\n-    // type of this expression\n+    /// type of this expression\n     pub ty: Ty<'tcx>,\n \n-    // lifetime of this expression if it should be spilled into a\n-    // temporary; should be None only if in a constant context\n+    /// lifetime of this expression if it should be spilled into a\n+    /// temporary; should be None only if in a constant context\n     pub temp_lifetime: Option<CodeExtent>,\n \n-    // span of the expression in the source\n+    /// span of the expression in the source\n     pub span: Span,\n \n-    // kind of expression\n+    /// kind of expression\n     pub kind: ExprKind<'tcx>,\n }\n \n@@ -194,7 +194,8 @@ pub enum ExprKind<'tcx> {\n     VarRef {\n         id: ast::NodeId,\n     },\n-    SelfRef, // first argument, used for self in a closure\n+    /// first argument, used for self in a closure\n+    SelfRef,\n     StaticRef {\n         id: DefId,\n     },\n@@ -278,7 +279,7 @@ pub enum LogicalOp {\n pub enum PatternKind<'tcx> {\n     Wild,\n \n-    // x, ref x, x @ P, etc\n+    /// x, ref x, x @ P, etc\n     Binding {\n         mutability: Mutability,\n         name: ast::Name,\n@@ -288,21 +289,22 @@ pub enum PatternKind<'tcx> {\n         subpattern: Option<Pattern<'tcx>>,\n     },\n \n-    // Foo(...) or Foo{...} or Foo, where `Foo` is a variant name from an adt with >1 variants\n+    /// Foo(...) or Foo{...} or Foo, where `Foo` is a variant name from an adt with >1 variants\n     Variant {\n         adt_def: AdtDef<'tcx>,\n         variant_index: usize,\n         subpatterns: Vec<FieldPattern<'tcx>>,\n     },\n \n-    // (...), Foo(...), Foo{...}, or Foo, where `Foo` is a variant name from an adt with 1 variant\n+    /// (...), Foo(...), Foo{...}, or Foo, where `Foo` is a variant name from an adt with 1 variant\n     Leaf {\n         subpatterns: Vec<FieldPattern<'tcx>>,\n     },\n \n+    /// box P, &P, &mut P, etc\n     Deref {\n         subpattern: Pattern<'tcx>,\n-    }, // box P, &P, &mut P, etc\n+    },\n \n     Constant {\n         value: ConstVal,\n@@ -313,14 +315,14 @@ pub enum PatternKind<'tcx> {\n         hi: Literal<'tcx>,\n     },\n \n-    // matches against a slice, checking the length and extracting elements\n+    /// matches against a slice, checking the length and extracting elements\n     Slice {\n         prefix: Vec<Pattern<'tcx>>,\n         slice: Option<Pattern<'tcx>>,\n         suffix: Vec<Pattern<'tcx>>,\n     },\n \n-    // fixed match against an array, irrefutable\n+    /// fixed match against an array, irrefutable\n     Array {\n         prefix: Vec<Pattern<'tcx>>,\n         slice: Option<Pattern<'tcx>>,"}]}