{"sha": "2c25b29c9cabefa319e05d9797e3a98f301a4e08", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjMjViMjljOWNhYmVmYTMxOWUwNWQ5Nzk3ZTNhOThmMzAxYTRlMDg=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-12-25T15:47:33Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-12-25T15:54:41Z"}, "message": "Simplify argument storage", "tree": {"sha": "cc4f21b1216efd6bfd3766691b10b16d005c8bbf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc4f21b1216efd6bfd3766691b10b16d005c8bbf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c25b29c9cabefa319e05d9797e3a98f301a4e08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c25b29c9cabefa319e05d9797e3a98f301a4e08", "html_url": "https://github.com/rust-lang/rust/commit/2c25b29c9cabefa319e05d9797e3a98f301a4e08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c25b29c9cabefa319e05d9797e3a98f301a4e08/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf5c7a9f07142bee9317c923148664a42434e24f", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf5c7a9f07142bee9317c923148664a42434e24f", "html_url": "https://github.com/rust-lang/rust/commit/cf5c7a9f07142bee9317c923148664a42434e24f"}], "stats": {"total": 119, "additions": 53, "deletions": 66}, "files": [{"sha": "dcc33a6abfd615d32d11a4d362c6257c4bb3fa54", "filename": "src/abi.rs", "status": "modified", "additions": 53, "deletions": 66, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/2c25b29c9cabefa319e05d9797e3a98f301a4e08/src%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c25b29c9cabefa319e05d9797e3a98f301a4e08/src%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi.rs?ref=2c25b29c9cabefa319e05d9797e3a98f301a4e08", "patch": "@@ -6,7 +6,7 @@ use rustc_target::spec::abi::Abi;\n \n use crate::prelude::*;\n \n-#[derive(Debug)]\n+#[derive(Copy, Clone, Debug)]\n enum PassMode {\n     NoPass,\n     ByVal(Type),\n@@ -306,6 +306,37 @@ fn add_local_header_comment(fx: &mut FunctionCx<impl Backend>) {\n     fx.add_global_comment(format!(\"msg   loc.idx    param    pass mode            ssa flags  ty\"));\n }\n \n+fn arg_place<'a, 'tcx: 'a>(\n+    fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n+    local: Local,\n+    layout: TyLayout<'tcx>,\n+    is_ssa: bool,\n+) -> CPlace<'tcx> {\n+    let place = if is_ssa {\n+        fx.bcx.declare_var(mir_var(local), fx.clif_type(layout.ty).unwrap());\n+        CPlace::Var(local, layout)\n+    } else {\n+        let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n+            kind: StackSlotKind::ExplicitSlot,\n+            size: layout.size.bytes() as u32,\n+            offset: None,\n+        });\n+\n+        CPlace::from_stack_slot(fx, stack_slot, layout.ty)\n+    };\n+\n+    debug_assert!(fx.local_map.insert(local, place).is_none());\n+    fx.local_map[&local]\n+}\n+\n+fn param_to_cvalue<'a, 'tcx: 'a>(fx: &FunctionCx<'a, 'tcx, impl Backend>, ebb_param: Value, layout: TyLayout<'tcx>) -> CValue<'tcx> {\n+    match get_pass_mode(fx.tcx, fx.self_sig().abi, layout.ty, false) {\n+        PassMode::NoPass => unimplemented!(\"pass mode nopass\"),\n+        PassMode::ByVal(_) => CValue::ByVal(ebb_param, layout),\n+        PassMode::ByRef => CValue::ByRef(ebb_param, layout),\n+    }\n+}\n+\n pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n     fx: &mut FunctionCx<'a, 'tcx, impl Backend>,\n     start_ebb: Ebb,\n@@ -344,19 +375,24 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n                 };\n \n                 let mut ebb_params = Vec::new();\n-                for arg_ty in tupled_arg_tys.iter() {\n-                    let clif_type =\n-                        get_pass_mode(fx.tcx, fx.self_sig().abi, arg_ty, false).get_param_ty(fx);\n-                    ebb_params.push(fx.bcx.append_ebb_param(start_ebb, clif_type));\n+                for (i, arg_ty) in tupled_arg_tys.iter().enumerate() {\n+                    let pass_mode = get_pass_mode(fx.tcx, fx.self_sig().abi, arg_ty, false);;\n+                    let clif_type = pass_mode.get_param_ty(fx);\n+                    let ebb_param = fx.bcx.append_ebb_param(start_ebb, clif_type);\n+                    add_local_comment(fx, \"arg\", local, Some(i), Some(ebb_param), Some(pass_mode), ssa_analyzed[&local], arg_ty);\n+                    ebb_params.push(ebb_param);\n                 }\n \n                 (local, ArgKind::Spread(ebb_params), arg_ty)\n             } else {\n                 let clif_type =\n                     get_pass_mode(fx.tcx, fx.self_sig().abi, arg_ty, false).get_param_ty(fx);\n+                let ebb_param = fx.bcx.append_ebb_param(start_ebb, clif_type);\n+                let pass_mode = get_pass_mode(fx.tcx, fx.self_sig().abi, arg_ty, false);\n+                add_local_comment(fx, \"arg\", local, None, Some(ebb_param), Some(pass_mode), ssa_analyzed[&local], arg_ty);\n                 (\n                     local,\n-                    ArgKind::Normal(fx.bcx.append_ebb_param(start_ebb, clif_type)),\n+                    ArgKind::Normal(ebb_param),\n                     arg_ty,\n                 )\n             }\n@@ -370,7 +406,6 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n     match output_pass_mode {\n         PassMode::NoPass => {\n             let null = fx.bcx.ins().iconst(fx.pointer_type, 0);\n-            //unimplemented!(\"pass mode nopass\");\n             fx.local_map.insert(\n                 RETURN_PLACE,\n                 CPlace::Addr(null, None, fx.layout_of(fx.return_type())),\n@@ -395,74 +430,26 @@ pub fn codegen_fn_prelude<'a, 'tcx: 'a>(\n     for (local, arg_kind, ty) in func_params {\n         let layout = fx.layout_of(ty);\n \n+        let is_ssa = !ssa_analyzed\n+            .get(&local)\n+            .unwrap()\n+            .contains(crate::analyze::Flags::NOT_SSA);\n+\n         match arg_kind {\n             ArgKind::Normal(ebb_param) => {\n-                let pass_mode = get_pass_mode(fx.tcx, fx.self_sig().abi, ty, false);\n-                add_local_comment(fx, \"arg\", local, None, Some(ebb_param), Some(pass_mode), ssa_analyzed[&local], ty);\n+                let cvalue = param_to_cvalue(fx, ebb_param, layout);\n+                arg_place(fx, local, layout, is_ssa).write_cvalue(fx, cvalue);\n             }\n-            ArgKind::Spread(ref ebb_params) => {\n-                for (i, &ebb_param) in ebb_params.iter().enumerate() {\n-                    let sub_layout = layout.field(fx, i);\n-                    let pass_mode = get_pass_mode(fx.tcx, fx.self_sig().abi, sub_layout.ty, false);\n-                    add_local_comment(fx, \"arg\", local, Some(i), Some(ebb_param), Some(pass_mode), ssa_analyzed[&local], sub_layout.ty);\n-                }\n-            }\n-        }\n-\n-        if let ArgKind::Normal(ebb_param) = arg_kind {\n-            if !ssa_analyzed\n-                .get(&local)\n-                .unwrap()\n-                .contains(crate::analyze::Flags::NOT_SSA)\n-            {\n-                fx.bcx\n-                    .declare_var(mir_var(local), fx.clif_type(ty).unwrap());\n-                match get_pass_mode(fx.tcx, fx.self_sig().abi, ty, false) {\n-                    PassMode::NoPass => unimplemented!(\"pass mode nopass\"),\n-                    PassMode::ByVal(_) => fx.bcx.def_var(mir_var(local), ebb_param),\n-                    PassMode::ByRef => {\n-                        let val = CValue::ByRef(ebb_param, fx.layout_of(ty)).load_value(fx);\n-                        fx.bcx.def_var(mir_var(local), val);\n-                    }\n-                }\n-                fx.local_map.insert(local, CPlace::Var(local, layout));\n-                continue;\n-            }\n-        }\n-\n-        let stack_slot = fx.bcx.create_stack_slot(StackSlotData {\n-            kind: StackSlotKind::ExplicitSlot,\n-            size: layout.size.bytes() as u32,\n-            offset: None,\n-        });\n-\n-        let place = CPlace::from_stack_slot(fx, stack_slot, ty);\n-\n-        match arg_kind {\n-            ArgKind::Normal(ebb_param) => match get_pass_mode(fx.tcx, fx.self_sig().abi, ty, false)\n-            {\n-                PassMode::NoPass => unimplemented!(\"pass mode nopass\"),\n-                PassMode::ByVal(_) => {\n-                    place.write_cvalue(fx, CValue::ByVal(ebb_param, place.layout()))\n-                }\n-                PassMode::ByRef => place.write_cvalue(fx, CValue::ByRef(ebb_param, place.layout())),\n-            },\n             ArgKind::Spread(ebb_params) => {\n+                let place = arg_place(fx, local, layout, is_ssa);\n+\n                 for (i, ebb_param) in ebb_params.into_iter().enumerate() {\n                     let sub_place = place.place_field(fx, mir::Field::new(i));\n-                    match get_pass_mode(fx.tcx, fx.self_sig().abi, sub_place.layout().ty, false) {\n-                        PassMode::NoPass => unimplemented!(\"pass mode nopass\"),\n-                        PassMode::ByVal(_) => {\n-                            sub_place.write_cvalue(fx, CValue::ByVal(ebb_param, sub_place.layout()))\n-                        }\n-                        PassMode::ByRef => {\n-                            sub_place.write_cvalue(fx, CValue::ByRef(ebb_param, sub_place.layout()))\n-                        }\n-                    }\n+                    let cvalue = param_to_cvalue(fx, ebb_param, sub_place.layout());\n+                    sub_place.write_cvalue(fx, cvalue);\n                 }\n             }\n         }\n-        fx.local_map.insert(local, place);\n     }\n \n     for local in fx.mir.vars_and_temps_iter() {"}]}