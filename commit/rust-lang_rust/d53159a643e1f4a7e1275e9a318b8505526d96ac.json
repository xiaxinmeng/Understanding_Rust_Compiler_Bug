{"sha": "d53159a643e1f4a7e1275e9a318b8505526d96ac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1MzE1OWE2NDNlMWY0YTdlMTI3NWU5YTMxOGI4NTA1NTI2ZDk2YWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-26T07:06:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-10-26T07:06:09Z"}, "message": "auto merge of #10070 : alexcrichton/rust/fewer-missiles, r=brson\n\nThis optimizes the `home_for_io` code path by requiring fewer scheduler\r\noperations in some situtations.\r\n\r\nWhen moving to your home scheduler, this no longer forces a context switch if\r\nyou're already on the home scheduler. Instead, the homing code now simply pins\r\nyou to your current scheduler (making it so you can't be stolen away). If you're\r\nnot on your home scheduler, then we context switch away, sending you to your\r\nhome scheduler.\r\n\r\nWhen the I/O operation is done, then we also no longer forcibly trigger a\r\ncontext switch. Instead, the action is cased on whether the task is homed or\r\nnot. If a task does not have a home, then the task is re-flagged as not having a\r\nhome and no context switch is performed. If a task is homed to the current\r\nscheduler, then we don't do anything, and if the task is homed to a foreign\r\nscheduler, then it's sent along its merry way.\r\n\r\nI verified that there are about a third as many `write` syscalls done in print\r\noperations now. Libuv uses write to implement async handles, and the homing\r\nbefore and after each I/O operation was triggering a write on these async\r\nhandles. Additionally, using the terrible benchmark of printing 10k times in a\r\nloop, this drives the runtime from 0.6s down to 0.3s (yay!).", "tree": {"sha": "1467d25f9e8d3483222c968cf52bcf44ac5f6aff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1467d25f9e8d3483222c968cf52bcf44ac5f6aff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d53159a643e1f4a7e1275e9a318b8505526d96ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d53159a643e1f4a7e1275e9a318b8505526d96ac", "html_url": "https://github.com/rust-lang/rust/commit/d53159a643e1f4a7e1275e9a318b8505526d96ac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d53159a643e1f4a7e1275e9a318b8505526d96ac/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5074ae6463876bbb9511e980fe890bebc881e41", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5074ae6463876bbb9511e980fe890bebc881e41", "html_url": "https://github.com/rust-lang/rust/commit/c5074ae6463876bbb9511e980fe890bebc881e41"}, {"sha": "e4c6523c65c45d0fc4485b9e691043c7b5c61a94", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4c6523c65c45d0fc4485b9e691043c7b5c61a94", "html_url": "https://github.com/rust-lang/rust/commit/e4c6523c65c45d0fc4485b9e691043c7b5c61a94"}], "stats": {"total": 85, "additions": 49, "deletions": 36}, "files": [{"sha": "9965380d9dc31ab6cf1a21a8d3a1081655962133", "filename": "src/libstd/rt/sched.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d53159a643e1f4a7e1275e9a318b8505526d96ac/src%2Flibstd%2Frt%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d53159a643e1f4a7e1275e9a318b8505526d96ac/src%2Flibstd%2Frt%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsched.rs?ref=d53159a643e1f4a7e1275e9a318b8505526d96ac", "patch": "@@ -338,6 +338,12 @@ impl Scheduler {\n                 this.process_task(task, Scheduler::resume_task_immediately_cl);\n                 return None;\n             }\n+            Some(RunOnce(task)) => {\n+                // bypass the process_task logic to force running this task once\n+                // on this home scheduler. This is often used for I/O (homing).\n+                Scheduler::resume_task_immediately_cl(this, task);\n+                return None;\n+            }\n             Some(Wake) => {\n                 this.sleepy = false;\n                 Local::put(this);\n@@ -797,7 +803,8 @@ pub enum SchedMessage {\n     Wake,\n     Shutdown,\n     PinnedTask(~Task),\n-    TaskFromFriend(~Task)\n+    TaskFromFriend(~Task),\n+    RunOnce(~Task),\n }\n \n pub struct SchedHandle {"}, {"sha": "dc202ecc174aed1fa656fa6299d22186226638c2", "filename": "src/libstd/rt/uv/uvio.rs", "status": "modified", "additions": 41, "deletions": 35, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/d53159a643e1f4a7e1275e9a318b8505526d96ac/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d53159a643e1f4a7e1275e9a318b8505526d96ac/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fuvio.rs?ref=d53159a643e1f4a7e1275e9a318b8505526d96ac", "patch": "@@ -29,7 +29,7 @@ use rt::local::Local;\n use rt::rtio::*;\n use rt::sched::{Scheduler, SchedHandle};\n use rt::tube::Tube;\n-use rt::task::SchedHome;\n+use rt::task::Task;\n use rt::uv::*;\n use rt::uv::idle::IdleWatcher;\n use rt::uv::net::{UvIpv4SocketAddr, UvIpv6SocketAddr};\n@@ -59,66 +59,72 @@ trait HomingIO {\n \n     fn home<'r>(&'r mut self) -> &'r mut SchedHandle;\n \n-    /* XXX This will move pinned tasks to do IO on the proper scheduler\n-     * and then move them back to their home.\n-     */\n-    fn go_to_IO_home(&mut self) -> SchedHome {\n-        use rt::sched::PinnedTask;\n+    /// This function will move tasks to run on their home I/O scheduler. Note\n+    /// that this function does *not* pin the task to the I/O scheduler, but\n+    /// rather it simply moves it to running on the I/O scheduler.\n+    fn go_to_IO_home(&mut self) -> uint {\n+        use rt::sched::RunOnce;\n \n-        do task::unkillable { // FIXME(#8674)\n-            let mut old = None;\n-            {\n-                let ptr = &mut old;\n+        let current_sched_id = do Local::borrow |sched: &mut Scheduler| {\n+            sched.sched_id()\n+        };\n+\n+        // Only need to invoke a context switch if we're not on the right\n+        // scheduler.\n+        if current_sched_id != self.home().sched_id {\n+            do task::unkillable { // FIXME(#8674)\n                 let scheduler: ~Scheduler = Local::take();\n                 do scheduler.deschedule_running_task_and_then |_, task| {\n                     /* FIXME(#8674) if the task was already killed then wake\n-                     * will return None. In that case, the home pointer will never be set.\n+                     * will return None. In that case, the home pointer will\n+                     * never be set.\n                      *\n-                     * RESOLUTION IDEA: Since the task is dead, we should just abort the IO action.\n+                     * RESOLUTION IDEA: Since the task is dead, we should\n+                     * just abort the IO action.\n                      */\n-                    do task.wake().map |mut task| {\n-                        *ptr = Some(task.take_unwrap_home());\n-                        self.home().send(PinnedTask(task));\n+                    do task.wake().map |task| {\n+                        self.home().send(RunOnce(task));\n                     };\n                 }\n             }\n-            old.expect(\"No old home because task had already been killed.\")\n         }\n+\n+        self.home().sched_id\n     }\n \n-    // XXX dummy self param\n-    fn restore_original_home(_dummy_self: Option<Self>, old: SchedHome) {\n-        use rt::sched::TaskFromFriend;\n+    // XXX: dummy self parameter\n+    fn restore_original_home(_: Option<Self>, io_home: uint) {\n+        // It would truly be a sad day if we had moved off the home I/O\n+        // scheduler while we were doing I/O.\n+        assert_eq!(Local::borrow(|sched: &mut Scheduler| sched.sched_id()),\n+                   io_home);\n \n-        let old = Cell::new(old);\n-        do task::unkillable { // FIXME(#8674)\n-            let scheduler: ~Scheduler = Local::take();\n-            do scheduler.deschedule_running_task_and_then |scheduler, task| {\n-                /* FIXME(#8674) if the task was already killed then wake\n-                 * will return None. In that case, the home pointer will never be restored.\n-                 *\n-                 * RESOLUTION IDEA: Since the task is dead, we should just abort the IO action.\n-                 */\n-                do task.wake().map |mut task| {\n-                    task.give_home(old.take());\n-                    scheduler.make_handle().send(TaskFromFriend(task));\n-                };\n+        // If we were a homed task, then we must send ourselves back to the\n+        // original scheduler. Otherwise, we can just return and keep running\n+        if !Task::on_appropriate_sched() {\n+            do task::unkillable { // FIXME(#8674)\n+                let scheduler: ~Scheduler = Local::take();\n+                do scheduler.deschedule_running_task_and_then |_, task| {\n+                    do task.wake().map |task| {\n+                        Scheduler::run_task(task);\n+                    };\n+                }\n             }\n         }\n     }\n \n     fn home_for_io<A>(&mut self, io: &fn(&mut Self) -> A) -> A {\n         let home = self.go_to_IO_home();\n         let a = io(self); // do IO\n-        HomingIO::restore_original_home(None::<Self> /* XXX dummy self */, home);\n+        HomingIO::restore_original_home(None::<Self>, home);\n         a // return the result of the IO\n     }\n \n     fn home_for_io_consume<A>(self, io: &fn(Self) -> A) -> A {\n         let mut this = self;\n         let home = this.go_to_IO_home();\n         let a = io(this); // do IO\n-        HomingIO::restore_original_home(None::<Self> /* XXX dummy self */, home);\n+        HomingIO::restore_original_home(None::<Self>, home);\n         a // return the result of the IO\n     }\n \n@@ -128,7 +134,7 @@ trait HomingIO {\n             let scheduler: ~Scheduler = Local::take();\n             io_sched(self, scheduler) // do IO and scheduling action\n         };\n-        HomingIO::restore_original_home(None::<Self> /* XXX dummy self */, home);\n+        HomingIO::restore_original_home(None::<Self>, home);\n         a // return result of IO\n     }\n }"}]}