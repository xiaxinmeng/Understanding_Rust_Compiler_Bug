{"sha": "21c69d4ba4ddaabbc43c82c040ecc8edd916e27b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxYzY5ZDRiYTRkZGFhYmJjNDNjODJjMDQwZWNjOGVkZDkxNmUyN2I=", "commit": {"author": {"name": "Stefan Plantikow", "email": "stefan.plantikow@googlemail.com", "date": "2011-11-16T22:14:18Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-12-02T19:06:03Z"}, "message": "Added cross-platform fsync api to io; win32 impl needs to be refined\n\nNo tests, need mktmpfile first", "tree": {"sha": "d20ab2b7f274a7202e634ca143a017047a245de0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d20ab2b7f274a7202e634ca143a017047a245de0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21c69d4ba4ddaabbc43c82c040ecc8edd916e27b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21c69d4ba4ddaabbc43c82c040ecc8edd916e27b", "html_url": "https://github.com/rust-lang/rust/commit/21c69d4ba4ddaabbc43c82c040ecc8edd916e27b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21c69d4ba4ddaabbc43c82c040ecc8edd916e27b/comments", "author": {"login": "boggle", "id": 50886, "node_id": "MDQ6VXNlcjUwODg2", "avatar_url": "https://avatars.githubusercontent.com/u/50886?v=4", "gravatar_id": "", "url": "https://api.github.com/users/boggle", "html_url": "https://github.com/boggle", "followers_url": "https://api.github.com/users/boggle/followers", "following_url": "https://api.github.com/users/boggle/following{/other_user}", "gists_url": "https://api.github.com/users/boggle/gists{/gist_id}", "starred_url": "https://api.github.com/users/boggle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/boggle/subscriptions", "organizations_url": "https://api.github.com/users/boggle/orgs", "repos_url": "https://api.github.com/users/boggle/repos", "events_url": "https://api.github.com/users/boggle/events{/privacy}", "received_events_url": "https://api.github.com/users/boggle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46e5e2f6859d0e924c24e8e73c91366e86ab9ac0", "url": "https://api.github.com/repos/rust-lang/rust/commits/46e5e2f6859d0e924c24e8e73c91366e86ab9ac0", "html_url": "https://github.com/rust-lang/rust/commit/46e5e2f6859d0e924c24e8e73c91366e86ab9ac0"}], "stats": {"total": 160, "additions": 147, "deletions": 13}, "files": [{"sha": "910ec8bb9ea3b0669a97cd7145dfb9d98e75b8ef", "filename": "src/lib/io.rs", "status": "modified", "additions": 93, "deletions": 1, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/21c69d4ba4ddaabbc43c82c040ecc8edd916e27b/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21c69d4ba4ddaabbc43c82c040ecc8edd916e27b/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=21c69d4ba4ddaabbc43c82c040ecc8edd916e27b", "patch": "@@ -25,6 +25,9 @@ type buf_reader =\n         fn eof() -> bool;\n         fn seek(int, seek_style);\n         fn tell() -> uint;\n+        // Needed on readers in case one needs to flush metadata\n+        // changes (atime)\n+        fn fsync(level: fsync::level) -> int;\n     };\n \n \n@@ -58,7 +61,9 @@ fn convert_whence(whence: seek_style) -> i32 {\n     };\n }\n \n-resource FILE_res(f: os::libc::FILE) { os::libc::fclose(f); }\n+resource FILE_res(f: os::libc::FILE) {\n+    os::libc::fclose(f);\n+}\n \n obj FILE_buf_reader(f: os::libc::FILE, res: option::t<@FILE_res>) {\n     fn read(len: uint) -> [u8] unsafe {\n@@ -76,6 +81,9 @@ obj FILE_buf_reader(f: os::libc::FILE, res: option::t<@FILE_res>) {\n         assert (os::libc::fseek(f, offset, convert_whence(whence)) == 0i32);\n     }\n     fn tell() -> uint { ret os::libc::ftell(f) as uint; }\n+    fn fsync(level: fsync::level) -> int {\n+        ret os::fsync_fd(os::libc::fileno(f), level) as int;\n+    }\n }\n \n \n@@ -219,6 +227,7 @@ obj byte_buf_reader(bbuf: byte_buf) {\n         bbuf.pos = seek_in_buf(offset, pos, len, whence);\n     }\n     fn tell() -> uint { ret bbuf.pos; }\n+    fn fsync(_level: fsync::level) -> int { ret 0; }\n }\n \n fn new_byte_buf_reader(buf: [u8]) -> buf_reader {\n@@ -242,6 +251,8 @@ type buf_writer =\n         fn write([u8]);\n         fn seek(int, seek_style);\n         fn tell() -> uint;\n+        fn flush() -> int;\n+        fn fsync(level: fsync::level) -> int;\n     };\n \n obj FILE_writer(f: os::libc::FILE, res: option::t<@FILE_res>) {\n@@ -255,6 +266,10 @@ obj FILE_writer(f: os::libc::FILE, res: option::t<@FILE_res>) {\n         assert (os::libc::fseek(f, offset, convert_whence(whence)) == 0i32);\n     }\n     fn tell() -> uint { ret os::libc::ftell(f) as uint; }\n+    fn flush() -> int { ret os::libc::fflush(f) as int; }\n+    fn fsync(level: fsync::level) -> int {\n+        ret os::fsync_fd(os::libc::fileno(f), level) as int;\n+    }\n }\n \n resource fd_res(fd: fd_t) { os::libc::close(fd); }\n@@ -283,6 +298,12 @@ obj fd_buf_writer(fd: fd_t, res: option::t<@fd_res>) {\n         log_err \"need 64-bit native calls for tell, sorry\";\n         fail;\n     }\n+\n+    fn flush() -> int { ret 0; }\n+\n+    fn fsync(level: fsync::level) -> int {\n+        ret os::fsync_fd(fd, level) as int;\n+    }\n }\n \n fn file_buf_writer(path: str,\n@@ -433,6 +454,8 @@ obj byte_buf_writer(buf: mutable_byte_buf) {\n         buf.pos = seek_in_buf(offset, pos, len, whence);\n     }\n     fn tell() -> uint { ret buf.pos; }\n+    fn flush() -> int { ret 0; }\n+    fn fsync(_level: fsync::level) -> int { ret 0; }\n }\n \n fn string_writer() -> str_writer {\n@@ -477,6 +500,75 @@ fn read_whole_file(file: str) -> result::t<[u8], str> {\n     })\n }\n \n+// fsync related\n+\n+mod fsync {\n+\n+    tag level {\n+        // whatever fsync does on that platform\n+        fsync;\n+\n+        // fdatasync on linux, similiar or more on other platforms\n+        fdatasync;\n+\n+        // full fsync\n+        //\n+        // You must additionally sync the parent directory as well!\n+        fullfsync;\n+    }\n+\n+\n+    // Resource of artifacts that need to fsync on destruction\n+    resource res<t>(arg: arg<t>) {\n+        alt arg.opt_level {\n+          option::none::<level>. { }\n+          option::some::<level>(level) {\n+            // fail hard if not succesful\n+            assert(arg.fsync_fn(arg.val, level) != -1);\n+          }\n+        }\n+    }\n+\n+    type arg<t> = {\n+        val: t,\n+        opt_level: option::t<level>,\n+        fsync_fn: fn(t, level) -> int\n+    };\n+\n+    // fsync file after executing blk\n+    // FIXME find better way to create resources within lifetime of outer res\n+    fn FILE_res_sync(&&file: FILE_res, opt_level: option::t<level>,\n+                  blk: block(&&res<os::libc::FILE>)) {\n+        blk(res({\n+            val: *file, opt_level: opt_level,\n+            fsync_fn: fn(&&file: os::libc::FILE, l: level) -> int {\n+                ret os::fsync_fd(os::libc::fileno(file), l) as int;\n+            }\n+        }));\n+    }\n+\n+    // fsync fd after executing blk\n+    fn fd_res_sync(&&fd: fd_res, opt_level: option::t<level>,\n+                   blk: block(&&res<fd_t>)) {\n+        blk(res({\n+            val: *fd, opt_level: opt_level,\n+            fsync_fn: fn(&&fd: fd_t, l: level) -> int {\n+                ret os::fsync_fd(fd, l) as int;\n+            }\n+        }));\n+    }\n+\n+    // Type of objects that may want to fsync\n+    type t = obj { fn fsync(l: level) -> int; };\n+\n+    // Call o.fsync after executing blk\n+    fn obj_sync(&&o: t, opt_level: option::t<level>, blk: block(&&res<t>)) {\n+        blk(res({\n+            val: o, opt_level: opt_level,\n+            fsync_fn: fn(&&o: t, l: level) -> int { ret o.fsync(l); }\n+        }));\n+    }\n+}\n \n \n //"}, {"sha": "7e30088ee3c378f10765bc405e5dee7e1769c21c", "filename": "src/lib/linux_os.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/21c69d4ba4ddaabbc43c82c040ecc8edd916e27b/src%2Flib%2Flinux_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21c69d4ba4ddaabbc43c82c040ecc8edd916e27b/src%2Flib%2Flinux_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flinux_os.rs?ref=21c69d4ba4ddaabbc43c82c040ecc8edd916e27b", "patch": "@@ -18,6 +18,7 @@ export exec_suffix;\n export target_os;\n export dylib_filename;\n export get_exe_path;\n+export fsync_fd;\n \n // FIXME Somehow merge stuff duplicated here and macosx_os.rs. Made difficult\n // by https://github.com/graydon/rust/issues#issue/268\n@@ -35,6 +36,10 @@ native mod libc {\n     fn fopen(path: str::sbuf, mode: str::sbuf) -> FILE;\n     fn fdopen(fd: fd_t, mode: str::sbuf) -> FILE;\n     fn fclose(f: FILE);\n+    fn fflush(f: FILE) -> c_int;\n+    fn fsync(fd: fd_t) -> c_int;\n+    fn fdatasync(fd: fd_t) -> c_int;\n+    fn fileno(f: FILE) -> fd_t;\n     fn fgetc(f: FILE) -> c_int;\n     fn ungetc(c: c_int, f: FILE);\n     fn feof(f: FILE) -> c_int;\n@@ -89,6 +94,13 @@ fn fclose(file: libc::FILE) {\n     libc::fclose(file)\n }\n \n+fn fsync_fd(fd: fd_t, level: io::fsync::level) -> c_int {\n+    alt level {\n+      io::fsync::fsync. | io::fsync::fullfsync. { ret libc::fsync(fd); }\n+      io::fsync::fdatasync. { ret libc::fdatasync(fd); }\n+    }\n+}\n+\n fn waitpid(pid: pid_t) -> i32 {\n     let status = 0i32;\n     assert (os::libc::waitpid(pid, status, 0i32) != -1i32);"}, {"sha": "f23e82eaa630d23ec0c3da2f8eedfb9cb6555b1c", "filename": "src/lib/macos_os.rs", "status": "modified", "additions": 34, "deletions": 12, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/21c69d4ba4ddaabbc43c82c040ecc8edd916e27b/src%2Flib%2Fmacos_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21c69d4ba4ddaabbc43c82c040ecc8edd916e27b/src%2Flib%2Fmacos_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmacos_os.rs?ref=21c69d4ba4ddaabbc43c82c040ecc8edd916e27b", "patch": "@@ -12,6 +12,7 @@ export exec_suffix;\n export target_os;\n export dylib_filename;\n export get_exe_path;\n+export fsync_fd;\n \n // FIXME Refactor into unix_os module or some such. Doesn't\n // seem to work right now.\n@@ -28,6 +29,9 @@ native mod libc {\n     type FILE;\n     fn fopen(path: str::sbuf, mode: str::sbuf) -> FILE;\n     fn fdopen(fd: fd_t, mode: str::sbuf) -> FILE;\n+    fn fflush(f: FILE) -> c_int;\n+    fn fsync(fd: fd_t) -> c_int;\n+    fn fileno(f: FILE) -> fd_t;\n     fn fclose(f: FILE);\n     fn fgetc(f: FILE) -> c_int;\n     fn ungetc(c: c_int, f: FILE);\n@@ -47,21 +51,26 @@ native mod libc {\n     fn mkdir(s: str::sbuf, mode: c_int) -> c_int;\n     fn rmdir(s: str::sbuf) -> c_int;\n     fn chdir(s: str::sbuf) -> c_int;\n+\n+    // FIXME: Needs varags\n+    fn fcntl(fd: fd_t, cmd: c_int) -> c_int;\n }\n \n mod libc_constants {\n-    const O_RDONLY: c_int   = 0i32;\n-    const O_WRONLY: c_int   = 1i32;\n-    const O_RDWR: c_int     = 2i32;\n-    const O_APPEND: c_int   = 8i32;\n-    const O_CREAT: c_int    = 512i32;\n-    const O_EXCL: c_int     = 2048i32;\n-    const O_TRUNC: c_int    = 1024i32;\n-    const O_TEXT: c_int     = 0i32;    // nonexistent in darwin libc\n-    const O_BINARY: c_int   = 0i32;    // nonexistent in darwin libc\n-\n-    const S_IRUSR: unsigned = 256u32;\n-    const S_IWUSR: unsigned = 128u32;\n+    const O_RDONLY: c_int    = 0i32;\n+    const O_WRONLY: c_int    = 1i32;\n+    const O_RDWR: c_int      = 2i32;\n+    const O_APPEND: c_int    = 8i32;\n+    const O_CREAT: c_int     = 512i32;\n+    const O_EXCL: c_int      = 2048i32;\n+    const O_TRUNC: c_int     = 1024i32;\n+    const O_TEXT: c_int      = 0i32;    // nonexistent in darwin libc\n+    const O_BINARY: c_int    = 0i32;    // nonexistent in darwin libc\n+\n+    const S_IRUSR: unsigned  = 256u32;\n+    const S_IWUSR: unsigned  = 128u32;\n+\n+    const F_FULLFSYNC: c_int = 51i32;\n }\n \n fn pipe() -> {in: fd_t, out: fd_t} {\n@@ -88,6 +97,19 @@ fn waitpid(pid: pid_t) -> i32 {\n     ret status;\n }\n \n+fn fsync_fd(fd: fd_t, level: io::fsync::level) -> c_int {\n+    alt level {\n+      io::fsync::fsync. { ret libc::fsync(fd); }\n+      _ {\n+        // According to man fnctl, the ok retval is only specified to be !=-1\n+        if (libc::fcntl(libc_constants::F_FULLFSYNC, fd) == -1 as c_int)\n+            { ret -1 as c_int; }\n+        else\n+            { ret 0 as c_int; }\n+      }\n+    }\n+}\n+\n #[abi = \"cdecl\"]\n native mod rustrt {\n     fn rust_getcwd() -> str;"}, {"sha": "e2c4583df183c6f5d3faa7eb7e5a71b895c43ac4", "filename": "src/lib/win32_os.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/21c69d4ba4ddaabbc43c82c040ecc8edd916e27b/src%2Flib%2Fwin32_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21c69d4ba4ddaabbc43c82c040ecc8edd916e27b/src%2Flib%2Fwin32_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_os.rs?ref=21c69d4ba4ddaabbc43c82c040ecc8edd916e27b", "patch": "@@ -15,6 +15,9 @@ native mod libc {\n     fn fopen(path: str::sbuf, mode: str::sbuf) -> FILE;\n     fn _fdopen(fd: fd_t, mode: str::sbuf) -> FILE;\n     fn fclose(f: FILE);\n+    fn fflush(f: FILE) -> c_int;\n+    fn fsync(fd: fd_t) -> c_int;\n+    fn fileno(f: FILE) -> fd_t;\n     fn fgetc(f: FILE) -> c_int;\n     fn ungetc(c: c_int, f: FILE);\n     fn feof(f: FILE) -> c_int;\n@@ -93,6 +96,11 @@ fn fclose(file: libc::FILE) {\n     libc::fclose(file)\n }\n \n+fn fsync_fd(fd: fd_t, level: io::fsync::level) -> c_int {\n+    // FIXME do something more apropriate\n+    ret libc::fsync(fd);\n+}\n+\n #[abi = \"cdecl\"]\n native mod rustrt {\n     fn rust_process_wait(handle: c_int) -> c_int;"}]}