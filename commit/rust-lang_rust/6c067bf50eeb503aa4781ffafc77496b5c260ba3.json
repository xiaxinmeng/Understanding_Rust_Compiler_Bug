{"sha": "6c067bf50eeb503aa4781ffafc77496b5c260ba3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjMDY3YmY1MGVlYjUwM2FhNDc4MWZmYWZjNzc0OTZiNWMyNjBiYTM=", "commit": {"author": {"name": "daxpedda", "email": "1645124+daxpedda@users.noreply.github.com", "date": "2019-07-15T14:02:50Z"}, "committer": {"name": "daxpedda", "email": "1645124+daxpedda@users.noreply.github.com", "date": "2019-07-15T14:02:50Z"}, "message": "false positives fixes of `implicit_return`\n\n-  Handle returning macro statements properly\n-  Handle functions that return never type\n-  Handle functions that panic but do not return never type", "tree": {"sha": "ef675d99a92eecab56511dbe427e755594b50df1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ef675d99a92eecab56511dbe427e755594b50df1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c067bf50eeb503aa4781ffafc77496b5c260ba3", "comment_count": 0, "verification": {"verified": false, "reason": "bad_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEtfVYniVMfR+YKQUSxyLctqGR7qsFAl0sh4oACgkQxyLctqGR\n7qvAGg/8D2sEVNDnq/yD9EvrARAJnCL4wf88KGKo8cuDqma+pGfv+iuAwYAqceNS\nGUHyk4kEoZ0fw7q7oz5L5zseM6xtifETxsN3Cs1OZs/P+o9Fo5rZUylxlI3UTeQo\n55gHPjAOiY7skiJ+Lt01YpFu40CQ3tGmN5Bjija/+u0v3Ua36/k3f2qJoRRlEEIs\nHKcQq4+zVJOzjMrJrjNtJ+nZbpCfYplPLIIcpTnEtwpayXFpdYIQoSm82gstTj8e\nhDtF19yJzGbQd5V7EV/o5NCDIw6liJeH8zhANHrXrD8aEZqA2TXQ4sMDIUPppSl6\n89mUchQVRF0jI4NRohf74b5e5qiYCqoUvdsEZoKV8+gh/If8m9c/qhOtM6jj+8pa\nBmmylhq9IhEvsTdFi6aOxHFClhxjexIdb6+yMl1L8Ny7YEDUNsVvNozoCPnNQzzw\n03eoVIyZ6/nGU7hlcOuURKeHsR34N+S7wee7dx4e+npY8NWOZsQwoxdizC5bklE7\np2p+tdnvK/zt3xtHy0ZeJsw1ggNY4c+HuKGosLDXSttVBkBmLx3vZSJIYK5n63nQ\nl9z8Q0x9ko8NTsGnLHpisEpTKoXmmk+riSw75tvsG1Mes88zngYaeNhbpfBWhNVP\nIB3Z3msFLh0kdtxWp7ZFeI1tyj3KTdREAzhodYNW0RA/01kkD7g=\n=Xs5b\n-----END PGP SIGNATURE-----", "payload": "tree ef675d99a92eecab56511dbe427e755594b50df1\nparent 36fb64639401d815f005dba1d437dd1a31c3a5e8\nauthor daxpedda <1645124+daxpedda@users.noreply.github.com> 1563199370 +0200\ncommitter daxpedda <1645124+daxpedda@users.noreply.github.com> 1563199370 +0200\n\nfalse positives fixes of `implicit_return`\n\n-  Handle returning macro statements properly\n-  Handle functions that return never type\n-  Handle functions that panic but do not return never type\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c067bf50eeb503aa4781ffafc77496b5c260ba3", "html_url": "https://github.com/rust-lang/rust/commit/6c067bf50eeb503aa4781ffafc77496b5c260ba3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c067bf50eeb503aa4781ffafc77496b5c260ba3/comments", "author": {"login": "daxpedda", "id": 1645124, "node_id": "MDQ6VXNlcjE2NDUxMjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1645124?v=4", "gravatar_id": "", "url": "https://api.github.com/users/daxpedda", "html_url": "https://github.com/daxpedda", "followers_url": "https://api.github.com/users/daxpedda/followers", "following_url": "https://api.github.com/users/daxpedda/following{/other_user}", "gists_url": "https://api.github.com/users/daxpedda/gists{/gist_id}", "starred_url": "https://api.github.com/users/daxpedda/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/daxpedda/subscriptions", "organizations_url": "https://api.github.com/users/daxpedda/orgs", "repos_url": "https://api.github.com/users/daxpedda/repos", "events_url": "https://api.github.com/users/daxpedda/events{/privacy}", "received_events_url": "https://api.github.com/users/daxpedda/received_events", "type": "User", "site_admin": false}, "committer": {"login": "daxpedda", "id": 1645124, "node_id": "MDQ6VXNlcjE2NDUxMjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1645124?v=4", "gravatar_id": "", "url": "https://api.github.com/users/daxpedda", "html_url": "https://github.com/daxpedda", "followers_url": "https://api.github.com/users/daxpedda/followers", "following_url": "https://api.github.com/users/daxpedda/following{/other_user}", "gists_url": "https://api.github.com/users/daxpedda/gists{/gist_id}", "starred_url": "https://api.github.com/users/daxpedda/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/daxpedda/subscriptions", "organizations_url": "https://api.github.com/users/daxpedda/orgs", "repos_url": "https://api.github.com/users/daxpedda/repos", "events_url": "https://api.github.com/users/daxpedda/events{/privacy}", "received_events_url": "https://api.github.com/users/daxpedda/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36fb64639401d815f005dba1d437dd1a31c3a5e8", "url": "https://api.github.com/repos/rust-lang/rust/commits/36fb64639401d815f005dba1d437dd1a31c3a5e8", "html_url": "https://github.com/rust-lang/rust/commit/36fb64639401d815f005dba1d437dd1a31c3a5e8"}], "stats": {"total": 213, "additions": 137, "deletions": 76}, "files": [{"sha": "409a10f82eb34d7a30dacc186a17c5a9131d6a27", "filename": "clippy_lints/src/implicit_return.rs", "status": "modified", "additions": 100, "deletions": 65, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/6c067bf50eeb503aa4781ffafc77496b5c260ba3/clippy_lints%2Fsrc%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c067bf50eeb503aa4781ffafc77496b5c260ba3/clippy_lints%2Fsrc%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fimplicit_return.rs?ref=6c067bf50eeb503aa4781ffafc77496b5c260ba3", "patch": "@@ -1,9 +1,16 @@\n-use crate::utils::{in_macro_or_desugar, is_expn_of, snippet_opt, span_lint_and_then};\n-use rustc::hir::{intravisit::FnKind, Body, ExprKind, FnDecl, HirId, MatchSource};\n-use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use rustc::{declare_lint_pass, declare_tool_lint};\n+use crate::utils::{\n+    in_macro_or_desugar, match_def_path,\n+    paths::{BEGIN_PANIC, BEGIN_PANIC_FMT},\n+    resolve_node, snippet_opt, span_lint_and_then,\n+};\n+use if_chain::if_chain;\n+use rustc::{\n+    declare_lint_pass, declare_tool_lint,\n+    hir::{intravisit::FnKind, Body, Expr, ExprKind, FnDecl, HirId, MatchSource, StmtKind},\n+    lint::{LateContext, LateLintPass, LintArray, LintPass},\n+};\n use rustc_errors::Applicability;\n-use syntax::source_map::Span;\n+use syntax_pos::Span;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for missing return statements at the end of a block.\n@@ -35,71 +42,98 @@ declare_clippy_lint! {\n \n declare_lint_pass!(ImplicitReturn => [IMPLICIT_RETURN]);\n \n-impl ImplicitReturn {\n-    fn lint(cx: &LateContext<'_, '_>, outer_span: syntax_pos::Span, inner_span: syntax_pos::Span, msg: &str) {\n-        span_lint_and_then(cx, IMPLICIT_RETURN, outer_span, \"missing return statement\", |db| {\n-            if let Some(snippet) = snippet_opt(cx, inner_span) {\n-                db.span_suggestion(\n-                    outer_span,\n-                    msg,\n-                    format!(\"return {}\", snippet),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        });\n+fn lint(cx: &LateContext<'_, '_>, outer_span: Span, inner_span: Span, msg: &str) {\n+    let outer_span = span_to_outer_expn(outer_span);\n+    let inner_span = span_to_outer_expn(inner_span);\n+\n+    span_lint_and_then(cx, IMPLICIT_RETURN, outer_span, \"missing return statement\", |db| {\n+        if let Some(snippet) = snippet_opt(cx, inner_span) {\n+            db.span_suggestion(\n+                outer_span,\n+                msg,\n+                format!(\"return {}\", snippet),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    });\n+}\n+\n+fn span_to_outer_expn(span: Span) -> Span {\n+    if let Some(expr) = span.ctxt().outer_expn_info() {\n+        span_to_outer_expn(expr.call_site)\n+    } else {\n+        span\n     }\n+}\n \n-    fn expr_match(cx: &LateContext<'_, '_>, expr: &rustc::hir::Expr) {\n-        match &expr.node {\n-            // loops could be using `break` instead of `return`\n-            ExprKind::Block(block, ..) | ExprKind::Loop(block, ..) => {\n-                if let Some(expr) = &block.expr {\n-                    Self::expr_match(cx, expr);\n-                }\n-                // only needed in the case of `break` with `;` at the end\n-                else if let Some(stmt) = block.stmts.last() {\n-                    if let rustc::hir::StmtKind::Semi(expr, ..) = &stmt.node {\n-                        // make sure it's a break, otherwise we want to skip\n-                        if let ExprKind::Break(.., break_expr) = &expr.node {\n-                            if let Some(break_expr) = break_expr {\n-                                Self::lint(cx, expr.span, break_expr.span, \"change `break` to `return` as shown\");\n-                            }\n-                        }\n+fn expr_match(cx: &LateContext<'_, '_>, expr: &Expr, ret_ty_is_never: bool) {\n+    match &expr.node {\n+        // loops could be using `break` instead of `return`\n+        ExprKind::Block(block, ..) | ExprKind::Loop(block, ..) => {\n+            if let Some(expr) = &block.expr {\n+                expr_match(cx, expr, ret_ty_is_never);\n+            }\n+            // only needed in the case of `break` with `;` at the end\n+            else if let Some(stmt) = block.stmts.last() {\n+                if_chain! {\n+                    if let StmtKind::Semi(expr, ..) = &stmt.node;\n+                    // make sure it's a break, otherwise we want to skip\n+                    if let ExprKind::Break(.., break_expr) = &expr.node;\n+                    if let Some(break_expr) = break_expr;\n+                    then {\n+                            lint(cx, expr.span, break_expr.span, \"change `break` to `return` as shown\");\n                     }\n                 }\n-            },\n-            // use `return` instead of `break`\n-            ExprKind::Break(.., break_expr) => {\n-                if let Some(break_expr) = break_expr {\n-                    Self::lint(cx, expr.span, break_expr.span, \"change `break` to `return` as shown\");\n-                }\n-            },\n-            ExprKind::Match(.., arms, source) => {\n-                let check_all_arms = match source {\n-                    MatchSource::IfLetDesugar {\n-                        contains_else_clause: has_else,\n-                    } => *has_else,\n-                    _ => true,\n-                };\n+            }\n+        },\n+        // use `return` instead of `break`\n+        ExprKind::Break(.., break_expr) => {\n+            if let Some(break_expr) = break_expr {\n+                lint(cx, expr.span, break_expr.span, \"change `break` to `return` as shown\");\n+            }\n+        },\n+        ExprKind::Match(.., arms, source) => {\n+            let check_all_arms = match source {\n+                MatchSource::IfLetDesugar {\n+                    contains_else_clause: has_else,\n+                } => *has_else,\n+                _ => true,\n+            };\n \n-                if check_all_arms {\n-                    for arm in arms {\n-                        Self::expr_match(cx, &arm.body);\n+            if check_all_arms {\n+                for arm in arms {\n+                    expr_match(cx, &arm.body, ret_ty_is_never);\n+                }\n+            } else {\n+                expr_match(\n+                    cx,\n+                    &arms.first().expect(\"if let doesn't have a single arm\").body,\n+                    ret_ty_is_never,\n+                );\n+            }\n+        },\n+        // skip if it already has a return statement\n+        ExprKind::Ret(..) => (),\n+        // make sure it's not a call that panics unless we intend to return a panic\n+        ExprKind::Call(expr, ..) => {\n+            if_chain! {\n+                if let ExprKind::Path(qpath) = &expr.node;\n+                if let Some(path_def_id) = resolve_node(cx, qpath, expr.hir_id).opt_def_id();\n+                if match_def_path(cx, path_def_id, &BEGIN_PANIC) ||\n+                    match_def_path(cx, path_def_id, &BEGIN_PANIC_FMT);\n+                then {\n+                    // only put `return` on panics if the return type of the function/closure is a panic\n+                    if ret_ty_is_never {\n+                        lint(cx, expr.span, expr.span, \"add `return` as shown\")\n                     }\n-                } else {\n-                    Self::expr_match(cx, &arms.first().expect(\"if let doesn't have a single arm\").body);\n                 }\n-            },\n-            // skip if it already has a return statement\n-            ExprKind::Ret(..) => (),\n-            // everything else is missing `return`\n-            _ => {\n-                // make sure it's not just an unreachable expression\n-                if is_expn_of(expr.span, \"unreachable\").is_none() {\n-                    Self::lint(cx, expr.span, expr.span, \"add `return` as shown\")\n+                else {\n+                    lint(cx, expr.span, expr.span, \"add `return` as shown\")\n                 }\n-            },\n-        }\n+            }\n+        },\n+        // everything else is missing `return`\n+        _ => lint(cx, expr.span, expr.span, \"add `return` as shown\"),\n     }\n }\n \n@@ -110,16 +144,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitReturn {\n         _: FnKind<'tcx>,\n         _: &'tcx FnDecl,\n         body: &'tcx Body,\n-        span: Span,\n+        span: syntax::source_map::Span,\n         _: HirId,\n     ) {\n         let def_id = cx.tcx.hir().body_owner_def_id(body.id());\n         let mir = cx.tcx.optimized_mir(def_id);\n+        let ret_ty = mir.return_ty();\n \n         // checking return type through MIR, HIR is not able to determine inferred closure return types\n         // make sure it's not a macro\n-        if !mir.return_ty().is_unit() && !in_macro_or_desugar(span) {\n-            Self::expr_match(cx, &body.value);\n+        if !ret_ty.is_unit() && !in_macro_or_desugar(span) {\n+            expr_match(cx, &body.value, ret_ty.is_never());\n         }\n     }\n }"}, {"sha": "ade3dc00a535ebbd51491a0693f62fc99eb7c50a", "filename": "tests/ui/implicit_return.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6c067bf50eeb503aa4781ffafc77496b5c260ba3/tests%2Fui%2Fimplicit_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c067bf50eeb503aa4781ffafc77496b5c260ba3/tests%2Fui%2Fimplicit_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_return.rs?ref=6c067bf50eeb503aa4781ffafc77496b5c260ba3", "patch": "@@ -5,6 +5,7 @@ fn test_end_of_fn() -> bool {\n         // no error!\n         return true;\n     }\n+\n     true\n }\n \n@@ -76,6 +77,18 @@ fn test_closure() {\n     let _ = || true;\n }\n \n+fn test_return_never() -> ! {\n+    panic!()\n+}\n+\n+fn test_panic() -> bool {\n+    panic!()\n+}\n+\n+fn test_return_macro() -> String {\n+    format!(\"test {}\", \"test\")\n+}\n+\n fn main() {\n     let _ = test_end_of_fn();\n     let _ = test_if_block();\n@@ -86,4 +99,5 @@ fn main() {\n     let _ = test_loop_with_nests();\n     let _ = test_loop_with_if_let();\n     test_closure();\n+    let _ = test_return_macro();\n }"}, {"sha": "ac6a76cd39ce2d40f96d9df66a2287001a826f9d", "filename": "tests/ui/implicit_return.stderr", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6c067bf50eeb503aa4781ffafc77496b5c260ba3/tests%2Fui%2Fimplicit_return.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6c067bf50eeb503aa4781ffafc77496b5c260ba3/tests%2Fui%2Fimplicit_return.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_return.stderr?ref=6c067bf50eeb503aa4781ffafc77496b5c260ba3", "patch": "@@ -1,64 +1,76 @@\n error: missing return statement\n-  --> $DIR/implicit_return.rs:8:5\n+  --> $DIR/implicit_return.rs:9:5\n    |\n LL |     true\n    |     ^^^^ help: add `return` as shown: `return true`\n    |\n    = note: `-D clippy::implicit-return` implied by `-D warnings`\n \n error: missing return statement\n-  --> $DIR/implicit_return.rs:14:9\n+  --> $DIR/implicit_return.rs:15:9\n    |\n LL |         true\n    |         ^^^^ help: add `return` as shown: `return true`\n \n error: missing return statement\n-  --> $DIR/implicit_return.rs:16:9\n+  --> $DIR/implicit_return.rs:17:9\n    |\n LL |         false\n    |         ^^^^^ help: add `return` as shown: `return false`\n \n error: missing return statement\n-  --> $DIR/implicit_return.rs:24:17\n+  --> $DIR/implicit_return.rs:25:17\n    |\n LL |         true => false,\n    |                 ^^^^^ help: add `return` as shown: `return false`\n \n error: missing return statement\n-  --> $DIR/implicit_return.rs:25:20\n+  --> $DIR/implicit_return.rs:26:20\n    |\n LL |         false => { true },\n    |                    ^^^^ help: add `return` as shown: `return true`\n \n error: missing return statement\n-  --> $DIR/implicit_return.rs:40:9\n+  --> $DIR/implicit_return.rs:41:9\n    |\n LL |         break true;\n    |         ^^^^^^^^^^ help: change `break` to `return` as shown: `return true`\n \n error: missing return statement\n-  --> $DIR/implicit_return.rs:48:13\n+  --> $DIR/implicit_return.rs:49:13\n    |\n LL |             break true;\n    |             ^^^^^^^^^^ help: change `break` to `return` as shown: `return true`\n \n error: missing return statement\n-  --> $DIR/implicit_return.rs:57:13\n+  --> $DIR/implicit_return.rs:58:13\n    |\n LL |             break true;\n    |             ^^^^^^^^^^ help: change `break` to `return` as shown: `return true`\n \n error: missing return statement\n-  --> $DIR/implicit_return.rs:75:18\n+  --> $DIR/implicit_return.rs:76:18\n    |\n LL |     let _ = || { true };\n    |                  ^^^^ help: add `return` as shown: `return true`\n \n error: missing return statement\n-  --> $DIR/implicit_return.rs:76:16\n+  --> $DIR/implicit_return.rs:77:16\n    |\n LL |     let _ = || true;\n    |                ^^^^ help: add `return` as shown: `return true`\n \n-error: aborting due to 10 previous errors\n+error: missing return statement\n+  --> $DIR/implicit_return.rs:81:5\n+   |\n+LL |     panic!()\n+   |     ^^^^^^^^ help: add `return` as shown: `return panic!()`\n+\n+error: missing return statement\n+  --> $DIR/implicit_return.rs:89:5\n+   |\n+LL |     format!(\"test {}\", \"test\")\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: add `return` as shown: `return format!(\"test {}\", \"test\")`\n+\n+error: aborting due to 12 previous errors\n "}]}