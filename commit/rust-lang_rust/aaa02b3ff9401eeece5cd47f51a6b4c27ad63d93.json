{"sha": "aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhYTAyYjNmZjk0MDFlZWVjZTVjZDQ3ZjUxYTZiNGMyN2FkNjNkOTM=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-12-23T06:27:20Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-12-30T01:27:59Z"}, "message": "Refactoring", "tree": {"sha": "12bd0cad2dac1ac728cca59bd750f2abf46f87e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12bd0cad2dac1ac728cca59bd750f2abf46f87e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93", "html_url": "https://github.com/rust-lang/rust/commit/aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95dc7efad0df3640096a48a84c1d7a29044be750", "url": "https://api.github.com/repos/rust-lang/rust/commits/95dc7efad0df3640096a48a84c1d7a29044be750", "html_url": "https://github.com/rust-lang/rust/commit/95dc7efad0df3640096a48a84c1d7a29044be750"}], "stats": {"total": 462, "additions": 237, "deletions": 225}, "files": [{"sha": "464f29a33937f053c0ba9ae191b5b7ddd5667219", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93", "patch": "@@ -368,18 +368,18 @@ pub fn raw_emit_lint(sess: &Session,\n                      lvlsrc: LevelSource,\n                      span: Option<Span>,\n                      msg: &str) {\n-    raw_struct_lint(sess, lint, lvlsrc, span, msg).map(|mut e| e.emit());\n+    raw_struct_lint(sess, lint, lvlsrc, span, msg).emit();\n }\n \n pub fn raw_struct_lint<'a>(sess: &'a Session,\n                            lint: &'static Lint,\n                            lvlsrc: LevelSource,\n                            span: Option<Span>,\n                            msg: &str)\n-                           -> Option<DiagnosticBuilder<'a>> {\n+                           -> DiagnosticBuilder<'a> {\n     let (mut level, source) = lvlsrc;\n     if level == Allow {\n-        return None;\n+        return sess.diagnostic().struct_dummy();\n     }\n \n     let name = lint.name_lower();\n@@ -416,7 +416,8 @@ pub fn raw_struct_lint<'a>(sess: &'a Session,\n     if let Some(span) = def {\n         err.span_note(span, \"lint level defined here\");\n     }\n-    Some(err)\n+\n+    err\n }\n \n pub trait LintContext: Sized {\n@@ -456,9 +457,9 @@ pub trait LintContext: Sized {\n               lint: &'static Lint,\n               span: Option<Span>,\n               msg: &str)\n-              -> Option<DiagnosticBuilder> {\n+              -> DiagnosticBuilder {\n         let (level, src) = match self.level_src(lint) {\n-            None => return None,\n+            None => return self.sess().diagnostic().struct_dummy(),\n             Some(pair) => pair,\n         };\n \n@@ -474,17 +475,14 @@ pub trait LintContext: Sized {\n                         lint: &'static Lint,\n                         span: Span,\n                         msg: &str)\n-                        -> Option<DiagnosticBuilder> {\n+                        -> DiagnosticBuilder {\n         self.lookup(lint, Some(span), msg)\n     }\n \n     /// Emit a lint and note at the appropriate level, for a particular span.\n     fn span_lint_note(&self, lint: &'static Lint, span: Span, msg: &str,\n                       note_span: Span, note: &str) {\n-        let mut err = match self.lookup(lint, Some(span), msg) {\n-            Some(e) => e,\n-            None => return\n-        };\n+        let mut err = self.lookup(lint, Some(span), msg);\n         if self.current_level(lint) != Level::Allow {\n             if note_span == span {\n                 err.fileline_note(note_span, note);\n@@ -498,10 +496,7 @@ pub trait LintContext: Sized {\n     /// Emit a lint and help at the appropriate level, for a particular span.\n     fn span_lint_help(&self, lint: &'static Lint, span: Span,\n                       msg: &str, help: &str) {\n-        let mut err = match self.lookup(lint, Some(span), msg) {\n-            Some(e) => e,\n-            None => return\n-        };\n+        let mut err = self.lookup(lint, Some(span), msg);\n         self.span_lint(lint, span, msg);\n         if self.current_level(lint) != Level::Allow {\n             err.span_help(span, help);"}, {"sha": "d628227d5e63cacad504cbc7c232eb909502c4cb", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93", "patch": "@@ -237,7 +237,7 @@ pub trait ErrorReporting<'tcx> {\n     fn report_type_error(&self,\n                          trace: TypeTrace<'tcx>,\n                          terr: &TypeError<'tcx>)\n-                         -> Option<DiagnosticBuilder<'tcx>>;\n+                         -> DiagnosticBuilder<'tcx>;\n \n     fn check_and_note_conflicting_crates(&self,\n                                          err: &mut DiagnosticBuilder,\n@@ -478,11 +478,11 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n     fn report_type_error(&self,\n                          trace: TypeTrace<'tcx>,\n                          terr: &TypeError<'tcx>)\n-                         -> Option<DiagnosticBuilder<'tcx>> {\n+                         -> DiagnosticBuilder<'tcx> {\n         let expected_found_str = match self.values_str(&trace.values) {\n             Some(v) => v,\n             None => {\n-                return None; /* derived error */\n+                return self.tcx.sess.diagnostic().struct_dummy(); /* derived error */\n             }\n         };\n \n@@ -507,7 +507,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             },\n             _ => ()\n         }\n-        Some(err)\n+        err\n     }\n \n     /// Adds a note if the types come from similarly named crates\n@@ -560,11 +560,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                      trace: TypeTrace<'tcx>,\n                                      terr: &TypeError<'tcx>) {\n         let span = trace.origin.span();\n-        let err = self.report_type_error(trace, terr);\n-        err.map(|mut err| {\n-            self.tcx.note_and_explain_type_err(&mut err, terr, span);\n-            err.emit();\n-        });\n+        let mut err = self.report_type_error(trace, terr);\n+        self.tcx.note_and_explain_type_err(&mut err, terr, span);\n+        err.emit();\n     }\n \n     /// Returns a string of the form \"expected `{}`, found `{}`\", or None if this is a derived"}, {"sha": "21a1ee37b7f436c1e8fb772e9ad2511263193a76", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93", "patch": "@@ -1281,7 +1281,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                     mk_msg: M,\n                                     actual_ty: String,\n                                     err: Option<&TypeError<'tcx>>)\n-                                    -> Option<DiagnosticBuilder<'tcx>>\n+                                    -> DiagnosticBuilder<'tcx>\n         where M: FnOnce(Option<String>, String) -> String,\n     {\n         self.type_error_struct_str_with_expected(sp, mk_msg, None, actual_ty, err)\n@@ -1296,7 +1296,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         where M: FnOnce(Option<String>, String) -> String,\n     {\n         self.type_error_struct_str_with_expected(sp, mk_msg, expected_ty, actual_ty, err)\n-            .map(|mut e| e.emit());\n+            .emit();\n     }\n \n     pub fn type_error_struct_str_with_expected<M>(&self,\n@@ -1305,7 +1305,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                                   expected_ty: Option<Ty<'tcx>>,\n                                                   actual_ty: String,\n                                                   err: Option<&TypeError<'tcx>>)\n-                                                  -> Option<DiagnosticBuilder<'tcx>>\n+                                                  -> DiagnosticBuilder<'tcx>\n         where M: FnOnce(Option<String>, String) -> String,\n     {\n         debug!(\"hi! expected_ty = {:?}, actual_ty = {}\", expected_ty, actual_ty);\n@@ -1324,9 +1324,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             if let Some(err) = err {\n                 self.tcx.note_and_explain_type_err(&mut db, err, sp);\n             }\n-            Some(db)\n+            db\n         } else {\n-            None\n+            self.tcx.sess.diagnostic().struct_dummy()\n         }\n     }\n \n@@ -1337,22 +1337,22 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                  err: Option<&TypeError<'tcx>>)\n         where M: FnOnce(String) -> String,\n     {\n-        self.type_error_struct(sp, mk_msg, actual_ty, err).map(|mut e| e.emit());\n+        self.type_error_struct(sp, mk_msg, actual_ty, err).emit();\n     }\n \n     pub fn type_error_struct<M>(&self,\n                                 sp: Span,\n                                 mk_msg: M,\n                                 actual_ty: Ty<'tcx>,\n                                 err: Option<&TypeError<'tcx>>)\n-                                -> Option<DiagnosticBuilder<'tcx>>\n+                                -> DiagnosticBuilder<'tcx>\n         where M: FnOnce(String) -> String,\n     {\n         let actual_ty = self.resolve_type_vars_if_possible(&actual_ty);\n \n         // Don't report an error if actual type is TyError.\n         if actual_ty.references_error() {\n-            return None;\n+            return self.tcx.sess.diagnostic().struct_dummy();\n         }\n \n         self.type_error_struct_str(sp,"}, {"sha": "7bcf3276da7a450693eb3994a5d628b66d838536", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93", "patch": "@@ -60,7 +60,7 @@ struct ExpectErrorEmitter {\n fn remove_message(e: &mut ExpectErrorEmitter, msg: &str, lvl: Level) {\n     match lvl {\n         Level::Bug | Level::Fatal | Level::Error => {}\n-        Level::Warning | Level::Note | Level::Help => {\n+        _ => {\n             return;\n         }\n     }"}, {"sha": "09e6f454fb4f51c5ffaccba9fdccff42e83da4b7", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93", "patch": "@@ -754,18 +754,17 @@ impl LateLintPass for UnconditionalRecursion {\n         if !reached_exit_without_self_call && !self_call_spans.is_empty() {\n             let mut db = cx.struct_span_lint(UNCONDITIONAL_RECURSION, sp,\n                                              \"function cannot return without recurring\");\n-            let mut db = db.as_mut();\n \n             // FIXME #19668: these could be span_lint_note's instead of this manual guard.\n             if cx.current_level(UNCONDITIONAL_RECURSION) != Level::Allow {\n                 // offer some help to the programmer.\n                 for call in &self_call_spans {\n-                    db = db.map(|db| db.span_note(*call, \"recursive call site\"));\n+                    db.span_note(*call, \"recursive call site\");\n                 }\n-                db = db.map(|db| db.fileline_help(sp, \"a `loop` may express intention \\\n-                                                       better if this is on purpose\"));\n+                db.fileline_help(sp, \"a `loop` may express intention \\\n+                                      better if this is on purpose\");\n             }\n-            db.map(|db| db.emit());\n+            db.emit();\n         }\n \n         // all done"}, {"sha": "1d3f2b79844ea0094120458537cc139239d58055", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93", "patch": "@@ -144,9 +144,9 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n \n                 if let Some(sp) = child[ns].span() {\n                     let note = format!(\"first definition of {} `{}` here\", ns_str, name);\n-                    err.as_mut().map(|mut e| e.span_note(sp, &note));\n+                    err.span_note(sp, &note);\n                 }\n-                err.as_mut().map(|mut e| e.emit());\n+                err.emit();\n                 child\n             }\n         }\n@@ -261,10 +261,9 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                           mod_spans[0],\n                                           ResolutionError::SelfImportCanOnlyAppearOnceInTheList);\n                             for other_span in mod_spans.iter().skip(1) {\n-                                e.as_mut().map(|mut e| e.span_note(*other_span,\n-                                                          \"another `self` import appears here\"));\n+                                e.span_note(*other_span, \"another `self` import appears here\");\n                             }\n-                            e.as_mut().map(|mut e| e.emit());\n+                            e.emit();\n                         }\n \n                         for source_item in source_items {"}, {"sha": "c2dd764f224b2e45839b225f807807f485ca5504", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93", "patch": "@@ -216,18 +216,18 @@ pub enum UnresolvedNameContext {\n fn resolve_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n                                        span: syntax::codemap::Span,\n                                        resolution_error: ResolutionError<'b>) {\n-    resolve_struct_error(resolver, span, resolution_error).map(|mut e| e.emit());\n+    resolve_struct_error(resolver, span, resolution_error).emit();\n }\n \n fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n                                               span: syntax::codemap::Span,\n                                               resolution_error: ResolutionError<'b>)\n-                                              -> Option<DiagnosticBuilder<'a>> {\n+                                              -> DiagnosticBuilder<'a> {\n     if !resolver.emit_errors {\n-        return None;\n+        return resolver.session.diagnostic().struct_dummy();\n     }\n \n-    Some(match resolution_error {\n+    match resolution_error {\n         ResolutionError::TypeParametersFromOuterFunction => {\n             struct_span_err!(resolver.session,\n                              span,\n@@ -532,7 +532,7 @@ fn resolve_struct_error<'b, 'a: 'b, 'tcx: 'a>(resolver: &'b Resolver<'a, 'tcx>,\n                              E0435,\n                              \"attempt to use a non-constant value in a constant\")\n         }\n-    })\n+    }\n }\n \n #[derive(Copy, Clone)]\n@@ -2202,10 +2202,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                 // If it's a typedef, give a note\n                 if let DefTy(..) = path_res.base_def {\n-                    err.as_mut().map(|mut e| e.span_note(trait_path.span,\n-                                                      \"`type` aliases cannot be used for traits\"));\n+                    err.span_note(trait_path.span,\n+                                  \"`type` aliases cannot be used for traits\");\n                 }\n-                err.as_mut().map(|mut e| e.emit());\n+                err.emit();\n                 Err(())\n             }\n         } else {\n@@ -3493,11 +3493,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         let msg = format!(\"did you mean to write: `{} {{ /* fields */ }}`?\",\n                                           path_name);\n                         if self.emit_errors {\n-                            err.as_mut().map(|mut e| e.fileline_help(expr.span, &msg));\n+                            err.fileline_help(expr.span, &msg);\n                         } else {\n-                            err.as_mut().map(|mut e| e.span_help(expr.span, &msg));\n+                            err.span_help(expr.span, &msg);\n                         }\n-                        err.as_mut().map(|mut e| e.emit());\n+                        err.emit();\n                         self.record_def(expr.id, err_path_resolution());\n                     } else {\n                         // Write the result into the def map.\n@@ -3534,11 +3534,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             let msg = format!(\"did you mean to write: `{} {{ /* fields */ }}`?\",\n                                               path_name);\n                             if self.emit_errors {\n-                                err.as_mut().map(|mut e| e.fileline_help(expr.span, &msg));\n+                                err.fileline_help(expr.span, &msg);\n                             } else {\n-                                err.as_mut().map(|mut e| e.span_help(expr.span, &msg));\n+                                err.span_help(expr.span, &msg);\n                             }\n-                            err.as_mut().map(|mut e| e.emit());\n+                            err.emit();\n                         }\n                         _ => {\n                             // Keep reporting some errors even if they're ignored above."}, {"sha": "996e72bdad3250e55adc87a102e26125c5c13f9f", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93", "patch": "@@ -2213,11 +2213,9 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &hir::EnumDef, sp: Span,\n                               &format!(\"enum variant is more than three times larger ({} bytes) \\\n                                         than the next largest (ignoring padding)\",\n                                        largest))\n-            .map(|mut e| {\n-                e.span_note(enum_def.variants[largest_index].span,\n+            .span_note(enum_def.variants[largest_index].span,\n                        \"this variant is the largest\")\n-                 .emit();\n-            });\n+            .emit();\n     }\n }\n "}, {"sha": "a1b378d84d0010faf8f9a1fbbb3a4c1c612d748f", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93", "patch": "@@ -232,20 +232,19 @@ fn confirm_builtin_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n             let mut err = fcx.type_error_struct(call_expr.span, |actual| {\n                 format!(\"expected function, found `{}`\", actual)\n             }, callee_ty, None);\n-            let mut err = err.as_mut();\n \n             if let hir::ExprCall(ref expr, _) = call_expr.node {\n                 let tcx = fcx.tcx();\n                 if let Some(pr) = tcx.def_map.borrow().get(&expr.id) {\n                     if pr.depth == 0 && pr.base_def != def::DefErr {\n                         if let Some(span) = tcx.map.span_if_local(pr.def_id()) {\n-                            err = err.map(|e| e.span_note(span, \"defined here\"));\n+                            err.span_note(span, \"defined here\");\n                         }\n                     }\n                 }\n             }\n \n-            err.map(|e| e.emit());\n+            err.emit();\n \n             // This is the \"default\" function signature, used in case of error.\n             // In that case, we check each argument against \"error\" in order to"}, {"sha": "90e67944ef90481474fb4f1caf713b6c2aa8348e", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93", "patch": "@@ -132,17 +132,15 @@ impl<'tcx> CastCheck<'tcx> {\n                             actual,\n                             fcx.infcx().ty_to_string(self.cast_ty))\n                 }, self.expr_ty, None)\n-                    .map(|mut err| {\n-                        err.fileline_help(self.span,\n-                            &format!(\"cast through {} first\", match e {\n-                                CastError::NeedViaPtr => \"a raw pointer\",\n-                                CastError::NeedViaThinPtr => \"a thin pointer\",\n-                                CastError::NeedViaInt => \"an integer\",\n-                                CastError::NeedViaUsize => \"a usize\",\n-                                _ => unreachable!()\n-                            }));\n-                        err.emit();\n-                    });\n+                    .fileline_help(self.span,\n+                        &format!(\"cast through {} first\", match e {\n+                            CastError::NeedViaPtr => \"a raw pointer\",\n+                            CastError::NeedViaThinPtr => \"a thin pointer\",\n+                            CastError::NeedViaInt => \"an integer\",\n+                            CastError::NeedViaUsize => \"a usize\",\n+                            _ => unreachable!()\n+                        }))\n+                    .emit();\n             }\n             CastError::CastToBool => {\n                 struct_span_err!(fcx.tcx().sess, self.span, E0054, \"cannot cast as `bool`\")\n@@ -174,10 +172,8 @@ impl<'tcx> CastCheck<'tcx> {\n                             actual,\n                             fcx.infcx().ty_to_string(self.cast_ty))\n                 }, self.expr_ty, None)\n-                    .map(|mut err| {\n-                        err.fileline_note(self.span, \"vtable kinds may not match\");\n-                        err.emit();\n-                    });\n+                    .fileline_note(self.span, \"vtable kinds may not match\")\n+                    .emit();\n             }\n         }\n     }"}, {"sha": "65b0d5892756c2790735810db1a975f6daace4a3", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 82, "deletions": 84, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93", "patch": "@@ -69,103 +69,101 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 rcvr_ty,\n                 None);\n \n-            if let Some(ref mut err) = err {\n-                // If the item has the name of a field, give a help note\n-                if let (&ty::TyStruct(def, substs), Some(expr)) = (&rcvr_ty.sty, rcvr_expr) {\n-                    if let Some(field) = def.struct_variant().find_field_named(item_name) {\n-                        let expr_string = match cx.sess.codemap().span_to_snippet(expr.span) {\n-                            Ok(expr_string) => expr_string,\n-                            _ => \"s\".into() // Default to a generic placeholder for the\n-                                            // expression when we can't generate a string\n-                                            // snippet\n-                        };\n-\n-                        macro_rules! span_stored_function {\n-                            () => {\n-                                err.span_note(span,\n-                                              &format!(\"use `({0}.{1})(...)` if you meant to call \\\n-                                                        the function stored in the `{1}` field\",\n-                                                       expr_string, item_name));\n-                            }\n+            // If the item has the name of a field, give a help note\n+            if let (&ty::TyStruct(def, substs), Some(expr)) = (&rcvr_ty.sty, rcvr_expr) {\n+                if let Some(field) = def.struct_variant().find_field_named(item_name) {\n+                    let expr_string = match cx.sess.codemap().span_to_snippet(expr.span) {\n+                        Ok(expr_string) => expr_string,\n+                        _ => \"s\".into() // Default to a generic placeholder for the\n+                                        // expression when we can't generate a string\n+                                        // snippet\n+                    };\n+\n+                    macro_rules! span_stored_function {\n+                        () => {\n+                            err.span_note(span,\n+                                          &format!(\"use `({0}.{1})(...)` if you meant to call \\\n+                                                    the function stored in the `{1}` field\",\n+                                                   expr_string, item_name));\n                         }\n+                    }\n \n-                        macro_rules! span_did_you_mean {\n-                            () => {\n-                                err.span_note(span, &format!(\"did you mean to write `{0}.{1}`?\",\n-                                                             expr_string, item_name));\n-                            }\n+                    macro_rules! span_did_you_mean {\n+                        () => {\n+                            err.span_note(span, &format!(\"did you mean to write `{0}.{1}`?\",\n+                                                         expr_string, item_name));\n                         }\n+                    }\n \n-                        // Determine if the field can be used as a function in some way\n-                        let field_ty = field.ty(cx, substs);\n+                    // Determine if the field can be used as a function in some way\n+                    let field_ty = field.ty(cx, substs);\n \n-                        match field_ty.sty {\n-                            // Not all of these (e.g. unsafe fns) implement FnOnce\n-                            // so we look for these beforehand\n-                            ty::TyClosure(..) | ty::TyBareFn(..) => {\n-                                span_stored_function!();\n-                            }\n-                            // If it's not a simple function, look for things which implement FnOnce\n-                            _ => {\n-                                if let Ok(fn_once_trait_did) =\n-                                        cx.lang_items.require(FnOnceTraitLangItem) {\n-                                    let infcx = fcx.infcx();\n-                                    infcx.probe(|_| {\n-                                        let fn_once_substs =\n-                                            Substs::new_trait(vec![infcx.next_ty_var()],\n-                                                              Vec::new(),\n-                                                              field_ty);\n-                                        let trait_ref =\n-                                          ty::TraitRef::new(fn_once_trait_did,\n-                                                            cx.mk_substs(fn_once_substs));\n-                                        let poly_trait_ref = trait_ref.to_poly_trait_ref();\n-                                        let obligation = Obligation::misc(span,\n-                                                                          fcx.body_id,\n-                                                                          poly_trait_ref\n-                                                                             .to_predicate());\n-                                        let mut selcx = SelectionContext::new(infcx);\n-\n-                                        if selcx.evaluate_obligation(&obligation) {\n-                                            span_stored_function!();\n-                                        } else {\n-                                            span_did_you_mean!();\n-                                        }\n-                                    });\n-                                } else {\n-                                    span_did_you_mean!();\n-                                }\n+                    match field_ty.sty {\n+                        // Not all of these (e.g. unsafe fns) implement FnOnce\n+                        // so we look for these beforehand\n+                        ty::TyClosure(..) | ty::TyBareFn(..) => {\n+                            span_stored_function!();\n+                        }\n+                        // If it's not a simple function, look for things which implement FnOnce\n+                        _ => {\n+                            if let Ok(fn_once_trait_did) =\n+                                    cx.lang_items.require(FnOnceTraitLangItem) {\n+                                let infcx = fcx.infcx();\n+                                infcx.probe(|_| {\n+                                    let fn_once_substs =\n+                                        Substs::new_trait(vec![infcx.next_ty_var()],\n+                                                          Vec::new(),\n+                                                          field_ty);\n+                                    let trait_ref =\n+                                      ty::TraitRef::new(fn_once_trait_did,\n+                                                        cx.mk_substs(fn_once_substs));\n+                                    let poly_trait_ref = trait_ref.to_poly_trait_ref();\n+                                    let obligation = Obligation::misc(span,\n+                                                                      fcx.body_id,\n+                                                                      poly_trait_ref\n+                                                                         .to_predicate());\n+                                    let mut selcx = SelectionContext::new(infcx);\n+\n+                                    if selcx.evaluate_obligation(&obligation) {\n+                                        span_stored_function!();\n+                                    } else {\n+                                        span_did_you_mean!();\n+                                    }\n+                                });\n+                            } else {\n+                                span_did_you_mean!();\n                             }\n                         }\n                     }\n                 }\n+            }\n \n-                if !static_sources.is_empty() {\n-                    err.fileline_note(\n-                        span,\n-                        \"found defined static methods, maybe a `self` is missing?\");\n-\n-                    report_candidates(fcx, err, span, item_name, static_sources);\n-                }\n+            if !static_sources.is_empty() {\n+                err.fileline_note(\n+                    span,\n+                    \"found defined static methods, maybe a `self` is missing?\");\n \n-                if !unsatisfied_predicates.is_empty() {\n-                    let bound_list = unsatisfied_predicates.iter()\n-                        .map(|p| format!(\"`{} : {}`\",\n-                                         p.self_ty(),\n-                                         p))\n-                        .collect::<Vec<_>>()\n-                        .join(\", \");\n-                    err.fileline_note(\n-                        span,\n-                        &format!(\"the method `{}` exists but the \\\n-                                 following trait bounds were not satisfied: {}\",\n-                                 item_name,\n-                                 bound_list));\n-                }\n+                report_candidates(fcx, &mut err, span, item_name, static_sources);\n+            }\n \n-                suggest_traits_to_import(fcx, err, span, rcvr_ty, item_name,\n-                                         rcvr_expr, out_of_scope_traits);\n-                err.emit();\n+            if !unsatisfied_predicates.is_empty() {\n+                let bound_list = unsatisfied_predicates.iter()\n+                    .map(|p| format!(\"`{} : {}`\",\n+                                     p.self_ty(),\n+                                     p))\n+                    .collect::<Vec<_>>()\n+                    .join(\", \");\n+                err.fileline_note(\n+                    span,\n+                    &format!(\"the method `{}` exists but the \\\n+                             following trait bounds were not satisfied: {}\",\n+                             item_name,\n+                             bound_list));\n             }\n+\n+            suggest_traits_to_import(fcx, &mut err, span, rcvr_ty, item_name,\n+                                     rcvr_expr, out_of_scope_traits);\n+            err.emit();\n         }\n \n         MethodError::Ambiguity(sources) => {"}, {"sha": "ea08343bbc04c998bc3bd3895b07f58b9097f8ef", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93", "patch": "@@ -1051,37 +1051,37 @@ fn report_cast_to_unsized_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             if t_cast.is_trait() {\n                 match fcx.tcx().sess.codemap().span_to_snippet(t_span) {\n                     Ok(s) => {\n-                        err.as_mut().unwrap().span_suggestion(t_span,\n-                                                              \"try casting to a reference instead:\",\n-                                                              format!(\"&{}{}\", mtstr, s));\n+                        err.span_suggestion(t_span,\n+                                            \"try casting to a reference instead:\",\n+                                            format!(\"&{}{}\", mtstr, s));\n                     },\n                     Err(_) =>\n-                        span_help!(err.as_mut().unwrap(), t_span,\n+                        span_help!(err, t_span,\n                                    \"did you mean `&{}{}`?\", mtstr, tstr),\n                 }\n             } else {\n-                span_help!(err.as_mut().unwrap(), span,\n+                span_help!(err, span,\n                            \"consider using an implicit coercion to `&{}{}` instead\",\n                            mtstr, tstr);\n             }\n         }\n         ty::TyBox(..) => {\n             match fcx.tcx().sess.codemap().span_to_snippet(t_span) {\n                 Ok(s) => {\n-                    err.as_mut().unwrap().span_suggestion(t_span,\n+                    err.span_suggestion(t_span,\n                                                           \"try casting to a `Box` instead:\",\n                                                            format!(\"Box<{}>\", s));\n                 },\n                 Err(_) =>\n-                    span_help!(err.as_mut().unwrap(), t_span, \"did you mean `Box<{}>`?\", tstr),\n+                    span_help!(err, t_span, \"did you mean `Box<{}>`?\", tstr),\n             }\n         }\n         _ => {\n-            span_help!(err.as_mut().unwrap(), e_span,\n+            span_help!(err, e_span,\n                        \"consider using a box or reference as appropriate\");\n         }\n     }\n-    err.map(|mut e| e.emit());\n+    err.emit();\n     fcx.write_error(id);\n }\n \n@@ -1630,7 +1630,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 mk_msg: M,\n                                 actual_ty: Ty<'tcx>,\n                                 err: Option<&TypeError<'tcx>>)\n-                                -> Option<DiagnosticBuilder<'tcx>>\n+                                -> DiagnosticBuilder<'tcx>\n         where M: FnOnce(String) -> String,\n     {\n         self.infcx().type_error_struct(sp, mk_msg, actual_ty, err)\n@@ -2966,13 +2966,12 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                `{}`\", field.node, actual)\n                                    },\n                                    expr_t, None)\n-                .unwrap()\n                 .fileline_help(field.span,\n                                \"maybe a `()` to call it is missing? \\\n                                If not, try an anonymous function\")\n                 .emit();\n         } else {\n-            fcx.type_error_struct(\n+            let mut err = fcx.type_error_struct(\n                 expr.span,\n                 |actual| {\n                     format!(\"attempted access of field `{}` on \\\n@@ -2981,13 +2980,11 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                             field.node,\n                             actual)\n                 },\n-                expr_t, None)\n-            .map(|mut e| {\n-                if let ty::TyStruct(def, _) = expr_t.sty {\n-                    suggest_field_names(&mut e, def.struct_variant(), field, vec![]);\n-                }\n-                e.emit();\n-            });\n+                expr_t, None);\n+            if let ty::TyStruct(def, _) = expr_t.sty {\n+                suggest_field_names(&mut err, def.struct_variant(), field, vec![]);\n+            }\n+            err.emit();\n         }\n \n         fcx.write_error(expr.id);\n@@ -3089,7 +3086,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                       variant: ty::VariantDef<'tcx>,\n                                       field: &hir::Field,\n                                       skip_fields: &[hir::Field]) {\n-        fcx.type_error_struct(\n+        let mut err = fcx.type_error_struct(\n             field.name.span,\n             |actual| if let ty::TyEnum(..) = ty.sty {\n                 format!(\"struct variant `{}::{}` has no field named `{}`\",\n@@ -3099,13 +3096,11 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                         actual, field.name.node)\n             },\n             ty,\n-            None)\n-        .map(|mut e| {\n-            // prevent all specified fields from being suggested\n-            let skip_fields = skip_fields.iter().map(|ref x| x.name.node.as_str());\n-            suggest_field_names(&mut e, variant, &field.name, skip_fields.collect());\n-            e.emit();\n-        });\n+            None);\n+        // prevent all specified fields from being suggested\n+        let skip_fields = skip_fields.iter().map(|ref x| x.name.node.as_str());\n+        suggest_field_names(&mut err, variant, &field.name, skip_fields.collect());\n+        err.emit();\n     }\n \n     fn check_expr_struct_fields<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,"}, {"sha": "3cee14538a905d23c11b9fbc94dd415f70681d79", "filename": "src/libsyntax/errors/mod.rs", "status": "modified", "additions": 70, "deletions": 35, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93/src%2Flibsyntax%2Ferrors%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93/src%2Flibsyntax%2Ferrors%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ferrors%2Fmod.rs?ref=aaa02b3ff9401eeece5cd47f51a6b4c27ad63d93", "patch": "@@ -107,7 +107,6 @@ pub struct DiagnosticBuilder<'a> {\n     code: Option<String>,\n     span: Option<Span>,\n     children: Vec<SubDiagnostic>,\n-    cancelled: bool,\n }\n \n // For example a note attached to an error.\n@@ -121,12 +120,12 @@ struct SubDiagnostic {\n impl<'a> DiagnosticBuilder<'a> {\n     // Emit the diagnostic.\n     pub fn emit(&mut self) {\n-        if self.cancelled {\n+        if self.cancelled() {\n             return;\n         }\n \n-        self.cancel();\n         self.emitter.borrow_mut().emit_struct(&self);\n+        self.cancel();\n \n         // if self.is_fatal() {\n         //     panic!(FatalError);\n@@ -135,8 +134,15 @@ impl<'a> DiagnosticBuilder<'a> {\n \n     // Cancel the diagnostic (a structured diagnostic must either be emitted or\n     // cancelled or it will panic when dropped).\n+    // BEWARE: if this DiagnosticBuilder is an error, then creating it will\n+    // bump the error count on the Handler and cancelling it won't undo that.\n+    // If you want to decrement the error count you should use `Handler::cancel`.\n     pub fn cancel(&mut self) {\n-        self.cancelled = true;\n+        self.level = Level::Cancelled;\n+    }\n+\n+    pub fn cancelled(&self) -> bool {\n+        self.level == Level::Cancelled\n     }\n \n     pub fn is_fatal(&self) -> bool {\n@@ -204,21 +210,28 @@ impl<'a> DiagnosticBuilder<'a> {\n         self\n     }\n \n+    pub fn span(&mut self, sp: Span) -> &mut Self {\n+        self.span = Some(sp);\n+        self\n+    }\n+\n+    pub fn code(&mut self, s: String) -> &mut Self {\n+        self.code = Some(s);\n+        self\n+    }\n+\n     // Convenience function for internal use, clients should use one of the\n     // struct_* methods on Handler.\n     fn new(emitter: &'a RefCell<Box<Emitter>>,\n            level: Level,\n-           message: &str,\n-           code: Option<String>,\n-           span: Option<Span>) -> DiagnosticBuilder<'a>  {\n+           message: &str) -> DiagnosticBuilder<'a>  {\n         DiagnosticBuilder {\n             emitter: emitter,\n             level: level,\n             message: message.to_owned(),\n-            code: code,\n-            span: span,\n+            code: None,\n+            span: None,\n             children: vec![],\n-            cancelled: false,\n         }\n     }\n \n@@ -249,7 +262,7 @@ impl<'a> fmt::Debug for DiagnosticBuilder<'a> {\n // we emit a bug.\n impl<'a> Drop for DiagnosticBuilder<'a> {\n     fn drop(&mut self) {\n-        if !self.cancelled {\n+        if !self.cancelled() {\n             self.emitter.borrow_mut().emit(None, \"Error constructed but not emitted\", None, Bug);\n             panic!();\n         }\n@@ -290,11 +303,16 @@ impl Handler {\n         }\n     }\n \n+    pub fn struct_dummy<'a>(&'a self) -> DiagnosticBuilder<'a> {\n+        DiagnosticBuilder::new(&self.emit, Level::Cancelled, \"\")\n+    }\n+\n     pub fn struct_span_warn<'a>(&'a self,\n                                 sp: Span,\n                                 msg: &str)\n-                                -> DiagnosticBuilder<'a>  {\n-        let mut result = DiagnosticBuilder::new(&self.emit, Level::Warning, msg, None, Some(sp));\n+                                -> DiagnosticBuilder<'a> {\n+        let mut result = DiagnosticBuilder::new(&self.emit, Level::Warning, msg);\n+        result.span(sp);\n         if !self.can_emit_warnings {\n             result.cancel();\n         }\n@@ -304,19 +322,17 @@ impl Handler {\n                                           sp: Span,\n                                           msg: &str,\n                                           code: &str)\n-                                          -> DiagnosticBuilder<'a>  {\n-        let mut result = DiagnosticBuilder::new(&self.emit,\n-                                                Level::Warning,\n-                                                msg,\n-                                                Some(code.to_owned()),\n-                                                Some(sp));\n+                                          -> DiagnosticBuilder<'a> {\n+        let mut result = DiagnosticBuilder::new(&self.emit, Level::Warning, msg);\n+        result.span(sp);\n+        result.code(code.to_owned());\n         if !self.can_emit_warnings {\n             result.cancel();\n         }\n         result\n     }\n-    pub fn struct_warn<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a>  {\n-        let mut result = DiagnosticBuilder::new(&self.emit, Level::Warning, msg, None, None);\n+    pub fn struct_warn<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a> {\n+        let mut result = DiagnosticBuilder::new(&self.emit, Level::Warning, msg);\n         if !self.can_emit_warnings {\n             result.cancel();\n         }\n@@ -325,42 +341,58 @@ impl Handler {\n     pub fn struct_span_err<'a>(&'a self,\n                                sp: Span,\n                                msg: &str)\n-                               -> DiagnosticBuilder<'a>  {\n+                               -> DiagnosticBuilder<'a> {\n         self.bump_err_count();\n-        DiagnosticBuilder::new(&self.emit, Level::Error, msg, None, Some(sp))\n+        let mut result = DiagnosticBuilder::new(&self.emit, Level::Error, msg);\n+        result.span(sp);\n+        result\n     }\n     pub fn struct_span_err_with_code<'a>(&'a self,\n                                          sp: Span,\n                                          msg: &str,\n                                          code: &str)\n-                                         -> DiagnosticBuilder<'a>  {\n-        // FIXME (and below) this is potentially inaccurate, since the DiagnosticBuilder\n-        // might be cancelled.\n+                                         -> DiagnosticBuilder<'a> {\n         self.bump_err_count();\n-        DiagnosticBuilder::new(&self.emit, Level::Error, msg, Some(code.to_owned()), Some(sp))\n+        let mut result = DiagnosticBuilder::new(&self.emit, Level::Error, msg);\n+        result.span(sp);\n+        result.code(code.to_owned());\n+        result\n     }\n-    pub fn struct_err<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a>  {\n+    pub fn struct_err<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a> {\n         self.bump_err_count();\n-        DiagnosticBuilder::new(&self.emit, Level::Error, msg, None, None)\n+        DiagnosticBuilder::new(&self.emit, Level::Error, msg)\n     }\n     pub fn struct_span_fatal<'a>(&'a self,\n                                  sp: Span,\n                                  msg: &str)\n-                                 -> DiagnosticBuilder<'a>  {\n+                                 -> DiagnosticBuilder<'a> {\n         self.bump_err_count();\n-        DiagnosticBuilder::new(&self.emit, Level::Fatal, msg, None, Some(sp))\n+        let mut result = DiagnosticBuilder::new(&self.emit, Level::Fatal, msg);\n+        result.span(sp);\n+        result\n     }\n     pub fn struct_span_fatal_with_code<'a>(&'a self,\n                                            sp: Span,\n                                            msg: &str,\n                                            code: &str)\n-                                           -> DiagnosticBuilder<'a>  {\n+                                           -> DiagnosticBuilder<'a> {\n         self.bump_err_count();\n-        DiagnosticBuilder::new(&self.emit, Level::Fatal, msg, Some(code.to_owned()), Some(sp))\n+        let mut result = DiagnosticBuilder::new(&self.emit, Level::Fatal, msg);\n+        result.span(sp);\n+        result.code(code.to_owned());\n+        result\n     }\n-    pub fn struct_fatal<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a>  {\n+    pub fn struct_fatal<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a> {\n         self.bump_err_count();\n-        DiagnosticBuilder::new(&self.emit, Level::Fatal, msg, None, None)\n+        DiagnosticBuilder::new(&self.emit, Level::Fatal, msg)\n+    }\n+\n+    pub fn cancel(&mut self, err: &mut DiagnosticBuilder) {\n+        if err.level == Level::Error || err.level == Level::Fatal {\n+            assert!(self.has_errors());\n+            self.err_count.set(self.err_count.get() + 1);\n+        }\n+        err.cancel();\n     }\n \n     pub fn span_fatal(&self, sp: Span, msg: &str) -> FatalError {\n@@ -514,6 +546,7 @@ pub enum Level {\n     Warning,\n     Note,\n     Help,\n+    Cancelled,\n }\n \n impl fmt::Display for Level {\n@@ -526,6 +559,7 @@ impl fmt::Display for Level {\n             Warning => \"warning\".fmt(f),\n             Note => \"note\".fmt(f),\n             Help => \"help\".fmt(f),\n+            Cancelled => unreachable!(),\n         }\n     }\n }\n@@ -537,6 +571,7 @@ impl Level {\n             Warning => term::color::BRIGHT_YELLOW,\n             Note => term::color::BRIGHT_GREEN,\n             Help => term::color::BRIGHT_CYAN,\n+            Cancelled => unreachable!(),\n         }\n     }\n }"}]}