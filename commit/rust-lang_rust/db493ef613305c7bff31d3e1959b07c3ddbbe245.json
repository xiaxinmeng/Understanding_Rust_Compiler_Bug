{"sha": "db493ef613305c7bff31d3e1959b07c3ddbbe245", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiNDkzZWY2MTMzMDVjN2JmZjMxZDNlMTk1OWIwN2MzZGRiYmUyNDU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-09-07T06:06:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-07T06:06:04Z"}, "message": "Rollup merge of #63919 - matthewjasper:remove-gensymmed, r=petrochenkov\n\nUse hygiene for AST passes\n\nAST passes are now able to have resolve consider their expansions as if they were opaque macros defined either in some module in the current crate, or a fake empty module with `#[no_implicit_prelude]`.\n\n* Add an ExpnKind for AST passes.\n* Remove gensyms in AST passes.\n* Remove gensyms in`#[test]`, `#[bench]` and `#[test_case]`.\n* Allow opaque macros to define tests.\n* Move tests for unit tests to their own directory.\n* Remove `Ident::{gensym, is_gensymed}` - `Ident::gensym_if_underscore` still exists.\n\ncc #60869, #61019\n\nr? @petrochenkov", "tree": {"sha": "a7fc1a3835731254574aa13bb7907e09facf5730", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7fc1a3835731254574aa13bb7907e09facf5730"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db493ef613305c7bff31d3e1959b07c3ddbbe245", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdc0jMCRBK7hj4Ov3rIwAAdHIIAG1Yte1NzTVzIPK4BNDqq3Ng\nGYUXZcNfJ31IJsUyTgm6zCxSAqrzb3REAFW/n4ziPEdfpq6iI1C1P5Kn1HbaIn4G\n7P2YUEj4M6x2piREP6wC/BTGlsbyuGtDsE530ojq4hVXut+J0nQpeO7ZBT4vAdIF\nyOSLXbCoaDgYGOjo9+coXcKt+yct45x2LNb8+MGxAuNR3IxT+8H61Brt/XzBjlv6\nqvKNodg07KJLA5ntGNwPvg/iOGe59TQKW0kRgEj7NXRT3yARUtLcYp7j9jikehDD\ncohqmrAVgJXwAuTo8XYjsNrSTfqTDli7kG7veVWOkdWfImhvBXbzLKFPf3+TGBg=\n=4i3u\n-----END PGP SIGNATURE-----\n", "payload": "tree a7fc1a3835731254574aa13bb7907e09facf5730\nparent da13f06ea0dc368f1350bfc356b7f81a838defde\nparent 3f3fc52bfa255e68d84ca40a497137f5c6bae4a8\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1567836364 +0200\ncommitter GitHub <noreply@github.com> 1567836364 +0200\n\nRollup merge of #63919 - matthewjasper:remove-gensymmed, r=petrochenkov\n\nUse hygiene for AST passes\n\nAST passes are now able to have resolve consider their expansions as if they were opaque macros defined either in some module in the current crate, or a fake empty module with `#[no_implicit_prelude]`.\n\n* Add an ExpnKind for AST passes.\n* Remove gensyms in AST passes.\n* Remove gensyms in`#[test]`, `#[bench]` and `#[test_case]`.\n* Allow opaque macros to define tests.\n* Move tests for unit tests to their own directory.\n* Remove `Ident::{gensym, is_gensymed}` - `Ident::gensym_if_underscore` still exists.\n\ncc #60869, #61019\n\nr? @petrochenkov\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db493ef613305c7bff31d3e1959b07c3ddbbe245", "html_url": "https://github.com/rust-lang/rust/commit/db493ef613305c7bff31d3e1959b07c3ddbbe245", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db493ef613305c7bff31d3e1959b07c3ddbbe245/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da13f06ea0dc368f1350bfc356b7f81a838defde", "url": "https://api.github.com/repos/rust-lang/rust/commits/da13f06ea0dc368f1350bfc356b7f81a838defde", "html_url": "https://github.com/rust-lang/rust/commit/da13f06ea0dc368f1350bfc356b7f81a838defde"}, {"sha": "3f3fc52bfa255e68d84ca40a497137f5c6bae4a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f3fc52bfa255e68d84ca40a497137f5c6bae4a8", "html_url": "https://github.com/rust-lang/rust/commit/3f3fc52bfa255e68d84ca40a497137f5c6bae4a8"}], "stats": {"total": 994, "additions": 555, "deletions": 439}, "files": [{"sha": "646060bc8be775152611214da6074c31559e05c5", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "patch": "@@ -390,9 +390,17 @@ impl_stable_hash_for!(struct ::syntax_pos::hygiene::ExpnData {\n impl_stable_hash_for!(enum ::syntax_pos::hygiene::ExpnKind {\n     Root,\n     Macro(kind, descr),\n+    AstPass(kind),\n     Desugaring(kind)\n });\n \n+impl_stable_hash_for!(enum ::syntax_pos::hygiene::AstPass {\n+    StdImports,\n+    TestHarness,\n+    ProcMacroHarness,\n+    PluginMacroDefs,\n+});\n+\n impl_stable_hash_for!(enum ::syntax_pos::hygiene::DesugaringKind {\n     CondTemporary,\n     Async,"}, {"sha": "e33f8e27871b2aa3c335bdf7c742ead20ec3844b", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "patch": "@@ -646,6 +646,30 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n         (Level::Forbid, None) => sess.struct_err(msg),\n     };\n \n+    // Check for future incompatibility lints and issue a stronger warning.\n+    let lints = sess.lint_store.borrow();\n+    let lint_id = LintId::of(lint);\n+    let future_incompatible = lints.future_incompatible(lint_id);\n+\n+    // If this code originates in a foreign macro, aka something that this crate\n+    // did not itself author, then it's likely that there's nothing this crate\n+    // can do about it. We probably want to skip the lint entirely.\n+    if err.span.primary_spans().iter().any(|s| in_external_macro(sess, *s)) {\n+        // Any suggestions made here are likely to be incorrect, so anything we\n+        // emit shouldn't be automatically fixed by rustfix.\n+        err.allow_suggestions(false);\n+\n+        // If this is a future incompatible lint it'll become a hard error, so\n+        // we have to emit *something*. Also allow lints to whitelist themselves\n+        // on a case-by-case basis for emission in a foreign macro.\n+        if future_incompatible.is_none() && !lint.report_in_external_macro {\n+            err.cancel();\n+            // Don't continue further, since we don't want to have\n+            // `diag_span_note_once` called for a diagnostic that isn't emitted.\n+            return err;\n+        }\n+    }\n+\n     let name = lint.name_lower();\n     match src {\n         LintSource::Default => {\n@@ -695,10 +719,6 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n \n     err.code(DiagnosticId::Lint(name));\n \n-    // Check for future incompatibility lints and issue a stronger warning.\n-    let lints = sess.lint_store.borrow();\n-    let lint_id = LintId::of(lint);\n-    let future_incompatible = lints.future_incompatible(lint_id);\n     if let Some(future_incompatible) = future_incompatible {\n         const STANDARD_MESSAGE: &str =\n             \"this was previously accepted by the compiler but is being phased out; \\\n@@ -723,22 +743,6 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n         err.note(&citation);\n     }\n \n-    // If this code originates in a foreign macro, aka something that this crate\n-    // did not itself author, then it's likely that there's nothing this crate\n-    // can do about it. We probably want to skip the lint entirely.\n-    if err.span.primary_spans().iter().any(|s| in_external_macro(sess, *s)) {\n-        // Any suggestions made here are likely to be incorrect, so anything we\n-        // emit shouldn't be automatically fixed by rustfix.\n-        err.allow_suggestions(false);\n-\n-        // If this is a future incompatible lint it'll become a hard error, so\n-        // we have to emit *something*. Also allow lints to whitelist themselves\n-        // on a case-by-case basis for emission in a foreign macro.\n-        if future_incompatible.is_none() && !lint.report_in_external_macro {\n-            err.cancel()\n-        }\n-    }\n-\n     return err\n }\n \n@@ -868,7 +872,7 @@ pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n     let expn_data = span.ctxt().outer_expn_data();\n     match expn_data.kind {\n         ExpnKind::Root | ExpnKind::Desugaring(DesugaringKind::ForLoop) => false,\n-        ExpnKind::Desugaring(_) => true, // well, it's \"external\"\n+        ExpnKind::AstPass(_) | ExpnKind::Desugaring(_) => true, // well, it's \"external\"\n         ExpnKind::Macro(MacroKind::Bang, _) => {\n             if expn_data.def_site.is_dummy() {\n                 // dummy span for the def_site means it's an external macro"}, {"sha": "5ad737776da09e1276321b6e48563d3f87b2b5ea", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "patch": "@@ -233,7 +233,7 @@ pub fn register_plugins<'a>(\n         syntax::attr::inject(krate, &sess.parse_sess, &sess.opts.debugging_opts.crate_attr)\n     });\n \n-    let (mut krate, features) = syntax::config::features(\n+    let (krate, features) = syntax::config::features(\n         krate,\n         &sess.parse_sess,\n         sess.edition(),\n@@ -268,16 +268,6 @@ pub fn register_plugins<'a>(\n         middle::recursion_limit::update_limits(sess, &krate);\n     });\n \n-    krate = time(sess, \"crate injection\", || {\n-        let alt_std_name = sess.opts.alt_std_name.as_ref().map(|s| &**s);\n-        let (krate, name) =\n-            syntax_ext::standard_library_imports::inject(krate, alt_std_name, sess.edition());\n-        if let Some(name) = name {\n-            sess.parse_sess.injected_crate_name.set(name);\n-        }\n-        krate\n-    });\n-\n     let registrars = time(sess, \"plugin loading\", || {\n         plugin::load::load_plugins(\n             sess,\n@@ -370,6 +360,21 @@ fn configure_and_expand_inner<'a>(\n         &resolver_arenas,\n     );\n     syntax_ext::register_builtin_macros(&mut resolver, sess.edition());\n+\n+    krate = time(sess, \"crate injection\", || {\n+        let alt_std_name = sess.opts.alt_std_name.as_ref().map(|s| Symbol::intern(s));\n+        let (krate, name) = syntax_ext::standard_library_imports::inject(\n+            krate,\n+            &mut resolver,\n+            &sess.parse_sess,\n+            alt_std_name,\n+        );\n+        if let Some(name) = name {\n+            sess.parse_sess.injected_crate_name.set(name);\n+        }\n+        krate\n+    });\n+\n     syntax_ext::plugin_macro_defs::inject(\n         &mut krate, &mut resolver, plugin_info.syntax_exts, sess.edition()\n     );"}, {"sha": "81bd687e263213b28f991a9b26a956fe98ae8443", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "patch": "@@ -126,7 +126,8 @@ impl<'a> Resolver<'a> {\n     crate fn macro_def_scope(&mut self, expn_id: ExpnId) -> Module<'a> {\n         let def_id = match self.macro_defs.get(&expn_id) {\n             Some(def_id) => *def_id,\n-            None => return self.graph_root,\n+            None => return self.ast_transform_scopes.get(&expn_id)\n+                .unwrap_or(&self.graph_root),\n         };\n         if let Some(id) = self.definitions.as_local_node_id(def_id) {\n             self.local_macro_def_scopes[&id]"}, {"sha": "c479912b4ef814949d839341736555384865445f", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "patch": "@@ -604,6 +604,14 @@ impl<'a> Resolver<'a> {\n         if lookup_ident.span.rust_2018() {\n             let extern_prelude_names = self.extern_prelude.clone();\n             for (ident, _) in extern_prelude_names.into_iter() {\n+                if ident.span.from_expansion() {\n+                    // Idents are adjusted to the root context before being\n+                    // resolved in the extern prelude, so reporting this to the\n+                    // user is no help. This skips the injected\n+                    // `extern crate std` in the 2018 edition, which would\n+                    // otherwise cause duplicate suggestions.\n+                    continue;\n+                }\n                 if let Some(crate_id) = self.crate_loader.maybe_process_path_extern(ident.name,\n                                                                                     ident.span) {\n                     let crate_root = self.get_module(DefId {"}, {"sha": "7f65e5dfaa2bf78c17488e51cb9dee00ae80ae46", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "patch": "@@ -880,6 +880,10 @@ pub struct Resolver<'a> {\n     /// There will be an anonymous module created around `g` with the ID of the\n     /// entry block for `f`.\n     block_map: NodeMap<Module<'a>>,\n+    /// A fake module that contains no definition and no prelude. Used so that\n+    /// some AST passes can generate identifiers that only resolve to local or\n+    /// language items.\n+    empty_module: Module<'a>,\n     module_map: FxHashMap<DefId, Module<'a>>,\n     extern_module_map: FxHashMap<(DefId, bool /* MacrosOnly? */), Module<'a>>,\n     binding_parent_modules: FxHashMap<PtrKey<'a, NameBinding<'a>>, Module<'a>>,\n@@ -914,6 +918,7 @@ pub struct Resolver<'a> {\n     non_macro_attrs: [Lrc<SyntaxExtension>; 2],\n     macro_defs: FxHashMap<ExpnId, DefId>,\n     local_macro_def_scopes: FxHashMap<NodeId, Module<'a>>,\n+    ast_transform_scopes: FxHashMap<ExpnId, Module<'a>>,\n     unused_macros: NodeMap<Span>,\n     proc_macro_stubs: NodeSet,\n     /// Traces collected during macro resolution and validated when it's complete.\n@@ -1081,6 +1086,21 @@ impl<'a> Resolver<'a> {\n             no_implicit_prelude: attr::contains_name(&krate.attrs, sym::no_implicit_prelude),\n             ..ModuleData::new(None, root_module_kind, root_def_id, ExpnId::root(), krate.span)\n         });\n+        let empty_module_kind = ModuleKind::Def(\n+            DefKind::Mod,\n+            root_def_id,\n+            kw::Invalid,\n+        );\n+        let empty_module = arenas.alloc_module(ModuleData {\n+            no_implicit_prelude: true,\n+            ..ModuleData::new(\n+                Some(graph_root),\n+                empty_module_kind,\n+                root_def_id,\n+                ExpnId::root(),\n+                DUMMY_SP,\n+            )\n+        });\n         let mut module_map = FxHashMap::default();\n         module_map.insert(DefId::local(CRATE_DEF_INDEX), graph_root);\n \n@@ -1140,10 +1160,12 @@ impl<'a> Resolver<'a> {\n             label_res_map: Default::default(),\n             export_map: FxHashMap::default(),\n             trait_map: Default::default(),\n+            empty_module,\n             module_map,\n             block_map: Default::default(),\n             extern_module_map: FxHashMap::default(),\n             binding_parent_modules: FxHashMap::default(),\n+            ast_transform_scopes: FxHashMap::default(),\n \n             glob_map: Default::default(),\n "}, {"sha": "054b17fec78491b5ee6eff49205c17ee6819f2ae", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 33, "deletions": 10, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "patch": "@@ -8,6 +8,7 @@ use crate::{ModuleOrUniformRoot, KNOWN_TOOLS};\n use crate::Namespace::*;\n use crate::resolve_imports::ImportResolver;\n use rustc::hir::def::{self, DefKind, NonMacroAttrKind};\n+use rustc::hir::def_id;\n use rustc::middle::stability;\n use rustc::{ty, lint, span_bug};\n use syntax::ast::{self, NodeId, Ident};\n@@ -25,6 +26,7 @@ use syntax_pos::{Span, DUMMY_SP};\n \n use std::{mem, ptr};\n use rustc_data_structures::sync::Lrc;\n+use syntax_pos::hygiene::AstPass;\n \n type Res = def::Res<NodeId>;\n \n@@ -95,16 +97,6 @@ impl<'a> base::Resolver for Resolver<'a> {\n         self.session.next_node_id()\n     }\n \n-    fn get_module_scope(&mut self, id: NodeId) -> ExpnId {\n-        let expn_id = ExpnId::fresh(Some(ExpnData::default(\n-            ExpnKind::Macro(MacroKind::Attr, sym::test_case), DUMMY_SP, self.session.edition()\n-        )));\n-        let module = self.module_map[&self.definitions.local_def_id(id)];\n-        self.invocation_parent_scopes.insert(expn_id, ParentScope::module(module));\n-        self.definitions.set_invocation_parent(expn_id, module.def_id().unwrap().index);\n-        expn_id\n-    }\n-\n     fn resolve_dollar_crates(&mut self) {\n         hygiene::update_dollar_crate_names(|ctxt| {\n             let ident = Ident::new(kw::DollarCrate, DUMMY_SP.with_ctxt(ctxt));\n@@ -136,6 +128,37 @@ impl<'a> base::Resolver for Resolver<'a> {\n         }\n     }\n \n+    // Create a new Expansion with a definition site of the provided module, or\n+    // a fake empty `#[no_implicit_prelude]` module if no module is provided.\n+    fn expansion_for_ast_pass(\n+        &mut self,\n+        call_site: Span,\n+        pass: AstPass,\n+        features: &[Symbol],\n+        parent_module_id: Option<NodeId>,\n+    ) -> ExpnId {\n+        let expn_id = ExpnId::fresh(Some(ExpnData::allow_unstable(\n+            ExpnKind::AstPass(pass),\n+            call_site,\n+            self.session.edition(),\n+            features.into(),\n+        )));\n+\n+        let parent_scope = if let Some(module_id) = parent_module_id {\n+            let parent_def_id = self.definitions.local_def_id(module_id);\n+            self.definitions.add_parent_module_of_macro_def(expn_id, parent_def_id);\n+            self.module_map[&parent_def_id]\n+        } else {\n+            self.definitions.add_parent_module_of_macro_def(\n+                expn_id,\n+                def_id::DefId::local(def_id::CRATE_DEF_INDEX),\n+            );\n+            self.empty_module\n+        };\n+        self.ast_transform_scopes.insert(expn_id, parent_scope);\n+        expn_id\n+    }\n+\n     fn resolve_imports(&mut self) {\n         ImportResolver { r: self }.resolve_imports()\n     }"}, {"sha": "ca189e71800b36a4a9d7f59296d024e64c6ebb00", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "patch": "@@ -1307,12 +1307,11 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                 None => continue,\n             };\n \n-            // Filter away ambiguous and gensymed imports. Gensymed imports\n-            // (e.g. implicitly injected `std`) cannot be properly encoded in metadata,\n-            // so they can cause name conflict errors downstream.\n-            let is_good_import = binding.is_import() && !binding.is_ambiguity() &&\n-                                 // Note that as_str() de-gensyms the Symbol\n-                                 !(ident.is_gensymed() && ident.name.as_str() != \"_\");\n+            // Filter away ambiguous imports and anything that has def-site\n+            // hygiene.\n+            // FIXME: Implement actual cross-crate hygiene.\n+            let is_good_import = binding.is_import() && !binding.is_ambiguity()\n+                && !ident.span.modern().from_expansion();\n             if is_good_import || binding.is_macro_def() {\n                 let res = binding.res();\n                 if res != Res::Err {"}, {"sha": "5b2515d20cbab23504273eda22233492b8da7fe8", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "patch": "@@ -3,7 +3,7 @@ use crate::attr::{self, HasAttrs, Stability, Deprecation};\n use crate::source_map::SourceMap;\n use crate::edition::Edition;\n use crate::ext::expand::{self, AstFragment, Invocation};\n-use crate::ext::hygiene::{ExpnId, Transparency};\n+use crate::ext::hygiene::ExpnId;\n use crate::mut_visit::{self, MutVisitor};\n use crate::parse::{self, parser, ParseSess, DirectoryOwnership};\n use crate::parse::token;\n@@ -16,7 +16,7 @@ use crate::visit::Visitor;\n use errors::{DiagnosticBuilder, DiagnosticId};\n use smallvec::{smallvec, SmallVec};\n use syntax_pos::{FileName, Span, MultiSpan, DUMMY_SP};\n-use syntax_pos::hygiene::{ExpnData, ExpnKind};\n+use syntax_pos::hygiene::{AstPass, ExpnData, ExpnKind};\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::sync::{self, Lrc};\n@@ -732,13 +732,19 @@ bitflags::bitflags! {\n pub trait Resolver {\n     fn next_node_id(&mut self) -> NodeId;\n \n-    fn get_module_scope(&mut self, id: NodeId) -> ExpnId;\n-\n     fn resolve_dollar_crates(&mut self);\n     fn visit_ast_fragment_with_placeholders(&mut self, expn_id: ExpnId, fragment: &AstFragment,\n                                             extra_placeholders: &[NodeId]);\n     fn register_builtin_macro(&mut self, ident: ast::Ident, ext: SyntaxExtension);\n \n+    fn expansion_for_ast_pass(\n+        &mut self,\n+        call_site: Span,\n+        pass: AstPass,\n+        features: &[Symbol],\n+        parent_module_id: Option<NodeId>,\n+    ) -> ExpnId;\n+\n     fn resolve_imports(&mut self);\n \n     fn resolve_macro_invocation(\n@@ -822,20 +828,20 @@ impl<'a> ExtCtxt<'a> {\n     /// Equivalent of `Span::def_site` from the proc macro API,\n     /// except that the location is taken from the span passed as an argument.\n     pub fn with_def_site_ctxt(&self, span: Span) -> Span {\n-        span.with_ctxt_from_mark(self.current_expansion.id, Transparency::Opaque)\n+        span.with_def_site_ctxt(self.current_expansion.id)\n     }\n \n     /// Equivalent of `Span::call_site` from the proc macro API,\n     /// except that the location is taken from the span passed as an argument.\n     pub fn with_call_site_ctxt(&self, span: Span) -> Span {\n-        span.with_ctxt_from_mark(self.current_expansion.id, Transparency::Transparent)\n+        span.with_call_site_ctxt(self.current_expansion.id)\n     }\n \n     /// Span with a context reproducing `macro_rules` hygiene (hygienic locals, unhygienic items).\n     /// FIXME: This should be eventually replaced either with `with_def_site_ctxt` (preferably),\n     /// or with `with_call_site_ctxt` (where necessary).\n     pub fn with_legacy_ctxt(&self, span: Span) -> Span {\n-        span.with_ctxt_from_mark(self.current_expansion.id, Transparency::SemiTransparent)\n+        span.with_legacy_ctxt(self.current_expansion.id)\n     }\n \n     /// Returns span for the macro which originally caused the current expansion to happen."}, {"sha": "8c1632dc7808d7a574343844c45afbb9e57f6a78", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "patch": "@@ -128,10 +128,14 @@ pub fn print_crate<'a>(cm: &'a SourceMap,\n         let fake_attr = attr::mk_attr_inner(list);\n         s.print_attribute(&fake_attr);\n \n-        // #![no_std]\n-        let no_std_meta = attr::mk_word_item(ast::Ident::with_dummy_span(sym::no_std));\n-        let fake_attr = attr::mk_attr_inner(no_std_meta);\n-        s.print_attribute(&fake_attr);\n+        // Currently on Rust 2018 we don't have `extern crate std;` at the crate\n+        // root, so this is not needed, and actually breaks things.\n+        if sess.edition == syntax_pos::edition::Edition::Edition2015 {\n+            // #![no_std]\n+            let no_std_meta = attr::mk_word_item(ast::Ident::with_dummy_span(sym::no_std));\n+            let fake_attr = attr::mk_attr_inner(no_std_meta);\n+            s.print_attribute(&fake_attr);\n+        }\n     }\n \n     s.print_mod(&krate.module, &krate.attrs);"}, {"sha": "ccdc5bd81a04b0bc133e71c0795e9ee3c01fa79a", "filename": "src/libsyntax_ext/plugin_macro_defs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fplugin_macro_defs.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "patch": "@@ -11,7 +11,7 @@ use syntax::source_map::respan;\n use syntax::symbol::sym;\n use syntax::tokenstream::*;\n use syntax_pos::{Span, DUMMY_SP};\n-use syntax_pos::hygiene::{ExpnData, ExpnKind, MacroKind};\n+use syntax_pos::hygiene::{ExpnData, ExpnKind, AstPass};\n \n use std::mem;\n \n@@ -44,7 +44,7 @@ pub fn inject(\n     if !named_exts.is_empty() {\n         let mut extra_items = Vec::new();\n         let span = DUMMY_SP.fresh_expansion(ExpnData::allow_unstable(\n-            ExpnKind::Macro(MacroKind::Attr, sym::plugin), DUMMY_SP, edition,\n+            ExpnKind::AstPass(AstPass::PluginMacroDefs), DUMMY_SP, edition,\n             [sym::rustc_attrs][..].into(),\n         ));\n         for (name, ext) in named_exts {"}, {"sha": "31d32d23a645ebd3b1a7109b0d0226323f7de770", "filename": "src/libsyntax_ext/proc_macro_harness.rs", "status": "modified", "additions": 33, "deletions": 36, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_harness.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "patch": "@@ -3,15 +3,15 @@ use std::mem;\n use smallvec::smallvec;\n use syntax::ast::{self, Ident};\n use syntax::attr;\n-use syntax::source_map::{ExpnData, ExpnKind, respan};\n-use syntax::ext::base::{ExtCtxt, MacroKind};\n+use syntax::ext::base::ExtCtxt;\n use syntax::ext::expand::{AstFragment, ExpansionConfig};\n use syntax::ext::proc_macro::is_proc_macro_attr;\n use syntax::parse::ParseSess;\n use syntax::ptr::P;\n use syntax::symbol::{kw, sym};\n use syntax::visit::{self, Visitor};\n use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::hygiene::AstPass;\n \n struct ProcMacroDerive {\n     trait_name: ast::Name,\n@@ -308,8 +308,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n \n // Creates a new module which looks like:\n //\n-//      #[doc(hidden)]\n-//      mod $gensym {\n+//      const _: () = {\n //          extern crate proc_macro;\n //\n //          use proc_macro::bridge::client::ProcMacro;\n@@ -327,32 +326,30 @@ fn mk_decls(\n     custom_attrs: &[ProcMacroDef],\n     custom_macros: &[ProcMacroDef],\n ) -> P<ast::Item> {\n-    let span = DUMMY_SP.fresh_expansion(ExpnData::allow_unstable(\n-        ExpnKind::Macro(MacroKind::Attr, sym::proc_macro), DUMMY_SP, cx.parse_sess.edition,\n-        [sym::rustc_attrs, sym::proc_macro_internals][..].into(),\n-    ));\n-\n-    let hidden = cx.meta_list_item_word(span, sym::hidden);\n-    let doc = cx.meta_list(span, sym::doc, vec![hidden]);\n-    let doc_hidden = cx.attribute(doc);\n-\n-    let proc_macro = Ident::with_dummy_span(sym::proc_macro);\n+    let expn_id = cx.resolver.expansion_for_ast_pass(\n+        DUMMY_SP,\n+        AstPass::ProcMacroHarness,\n+        &[sym::rustc_attrs, sym::proc_macro_internals],\n+        None,\n+    );\n+    let span = DUMMY_SP.with_def_site_ctxt(expn_id);\n+\n+    let proc_macro = Ident::new(sym::proc_macro, span);\n     let krate = cx.item(span,\n                         proc_macro,\n                         Vec::new(),\n                         ast::ItemKind::ExternCrate(None));\n \n-    let bridge = Ident::from_str(\"bridge\");\n-    let client = Ident::from_str(\"client\");\n-    let proc_macro_ty = Ident::from_str(\"ProcMacro\");\n-    let custom_derive = Ident::from_str(\"custom_derive\");\n-    let attr = Ident::from_str(\"attr\");\n-    let bang = Ident::from_str(\"bang\");\n-    let crate_kw = Ident::with_dummy_span(kw::Crate);\n+    let bridge = Ident::from_str_and_span(\"bridge\", span);\n+    let client = Ident::from_str_and_span(\"client\", span);\n+    let proc_macro_ty = Ident::from_str_and_span(\"ProcMacro\", span);\n+    let custom_derive = Ident::from_str_and_span(\"custom_derive\", span);\n+    let attr = Ident::from_str_and_span(\"attr\", span);\n+    let bang = Ident::from_str_and_span(\"bang\", span);\n \n     let decls = {\n         let local_path = |sp: Span, name| {\n-            cx.expr_path(cx.path(sp.with_ctxt(span.ctxt()), vec![crate_kw, name]))\n+            cx.expr_path(cx.path(sp.with_ctxt(span.ctxt()), vec![name]))\n         };\n         let proc_macro_ty_method_path = |method| cx.expr_path(cx.path(span, vec![\n             proc_macro, bridge, client, proc_macro_ty, method,\n@@ -381,7 +378,7 @@ fn mk_decls(\n \n     let decls_static = cx.item_static(\n         span,\n-        Ident::from_str(\"_DECLS\"),\n+        Ident::from_str_and_span(\"_DECLS\", span),\n         cx.ty_rptr(span,\n             cx.ty(span, ast::TyKind::Slice(\n                 cx.ty_path(cx.path(span,\n@@ -392,22 +389,22 @@ fn mk_decls(\n     ).map(|mut i| {\n         let attr = cx.meta_word(span, sym::rustc_proc_macro_decls);\n         i.attrs.push(cx.attribute(attr));\n-        i.vis = respan(span, ast::VisibilityKind::Public);\n         i\n     });\n \n-    let module = cx.item_mod(\n+    let block = cx.expr_block(cx.block(\n         span,\n-        span,\n-        ast::Ident::from_str(\"decls\").gensym(),\n-        vec![doc_hidden],\n-        vec![krate, decls_static],\n-    ).map(|mut i| {\n-        i.vis = respan(span, ast::VisibilityKind::Public);\n-        i\n-    });\n+        vec![cx.stmt_item(span, krate), cx.stmt_item(span, decls_static)],\n+    ));\n \n-    // Integrate the new module into existing module structures.\n-    let module = AstFragment::Items(smallvec![module]);\n-    cx.monotonic_expander().fully_expand_fragment(module).make_items().pop().unwrap()\n+    let anon_constant = cx.item_const(\n+        span,\n+        ast::Ident::new(kw::Underscore, span),\n+        cx.ty(span, ast::TyKind::Tup(Vec::new())),\n+        block,\n+    );\n+\n+    // Integrate the new item into existing module structures.\n+    let items = AstFragment::Items(smallvec![anon_constant]);\n+    cx.monotonic_expander().fully_expand_fragment(items).make_items().pop().unwrap()\n }"}, {"sha": "c577b1e33cfebab0f18d8fc90d33d569bcaa051f", "filename": "src/libsyntax_ext/standard_library_imports.rs", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibsyntax_ext%2Fstandard_library_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibsyntax_ext%2Fstandard_library_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fstandard_library_imports.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "patch": "@@ -1,86 +1,86 @@\n use syntax::{ast, attr};\n use syntax::edition::Edition;\n-use syntax::ext::hygiene::MacroKind;\n+use syntax::ext::expand::ExpansionConfig;\n+use syntax::ext::hygiene::AstPass;\n+use syntax::ext::base::{ExtCtxt, Resolver};\n+use syntax::parse::ParseSess;\n use syntax::ptr::P;\n-use syntax::source_map::{ExpnData, ExpnKind, dummy_spanned, respan};\n use syntax::symbol::{Ident, Symbol, kw, sym};\n use syntax_pos::DUMMY_SP;\n \n-use std::iter;\n-\n pub fn inject(\n-    mut krate: ast::Crate, alt_std_name: Option<&str>, edition: Edition\n+    mut krate: ast::Crate,\n+    resolver: &mut dyn Resolver,\n+    sess: &ParseSess,\n+    alt_std_name: Option<Symbol>,\n ) -> (ast::Crate, Option<Symbol>) {\n-    let rust_2018 = edition >= Edition::Edition2018;\n+    let rust_2018 = sess.edition >= Edition::Edition2018;\n \n     // the first name in this list is the crate name of the crate with the prelude\n-    let names: &[&str] = if attr::contains_name(&krate.attrs, sym::no_core) {\n+    let names: &[Symbol] = if attr::contains_name(&krate.attrs, sym::no_core) {\n         return (krate, None);\n     } else if attr::contains_name(&krate.attrs, sym::no_std) {\n         if attr::contains_name(&krate.attrs, sym::compiler_builtins) {\n-            &[\"core\"]\n+            &[sym::core]\n         } else {\n-            &[\"core\", \"compiler_builtins\"]\n+            &[sym::core, sym::compiler_builtins]\n         }\n     } else {\n-        &[\"std\"]\n+        &[sym::std]\n     };\n \n+    let expn_id = resolver.expansion_for_ast_pass(\n+        DUMMY_SP,\n+        AstPass::StdImports,\n+        &[sym::prelude_import],\n+        None,\n+    );\n+    let span = DUMMY_SP.with_def_site_ctxt(expn_id);\n+    let call_site = DUMMY_SP.with_call_site_ctxt(expn_id);\n+\n+    let ecfg = ExpansionConfig::default(\"std_lib_injection\".to_string());\n+    let cx = ExtCtxt::new(sess, ecfg, resolver);\n+\n+\n     // .rev() to preserve ordering above in combination with insert(0, ...)\n-    let alt_std_name = alt_std_name.map(Symbol::intern);\n-    for orig_name_str in names.iter().rev() {\n-        // HACK(eddyb) gensym the injected crates on the Rust 2018 edition,\n-        // so they don't accidentally interfere with the new import paths.\n-        let orig_name_sym = Symbol::intern(orig_name_str);\n-        let orig_name_ident = Ident::with_dummy_span(orig_name_sym);\n-        let (rename, orig_name) = if rust_2018 {\n-            (orig_name_ident.gensym(), Some(orig_name_sym))\n+    for &name in names.iter().rev() {\n+        let ident = if rust_2018 {\n+            Ident::new(name, span)\n         } else {\n-            (orig_name_ident, None)\n+            Ident::new(name, call_site)\n         };\n-        krate.module.items.insert(0, P(ast::Item {\n-            attrs: vec![attr::mk_attr_outer(\n-                attr::mk_word_item(ast::Ident::with_dummy_span(sym::macro_use))\n-            )],\n-            vis: dummy_spanned(ast::VisibilityKind::Inherited),\n-            node: ast::ItemKind::ExternCrate(alt_std_name.or(orig_name)),\n-            ident: rename,\n-            id: ast::DUMMY_NODE_ID,\n-            span: DUMMY_SP,\n-            tokens: None,\n-        }));\n+        krate.module.items.insert(0, cx.item(\n+            span,\n+            ident,\n+            vec![cx.attribute(cx.meta_word(span, sym::macro_use))],\n+            ast::ItemKind::ExternCrate(alt_std_name),\n+        ));\n     }\n \n-    // the crates have been injected, the assumption is that the first one is the one with\n-    // the prelude.\n+    // The crates have been injected, the assumption is that the first one is\n+    // the one with the prelude.\n     let name = names[0];\n \n-    let span = DUMMY_SP.fresh_expansion(ExpnData::allow_unstable(\n-        ExpnKind::Macro(MacroKind::Attr, sym::std_inject), DUMMY_SP, edition,\n-        [sym::prelude_import][..].into(),\n-    ));\n+    let import_path = if rust_2018 {\n+        [name, sym::prelude, sym::v1].iter()\n+            .map(|symbol| ast::Ident::new(*symbol, span)).collect()\n+    } else {\n+        [kw::PathRoot, name, sym::prelude, sym::v1].iter()\n+            .map(|symbol| ast::Ident::new(*symbol, span)).collect()\n+    };\n \n-    krate.module.items.insert(0, P(ast::Item {\n-        attrs: vec![attr::mk_attr_outer(\n-            attr::mk_word_item(ast::Ident::new(sym::prelude_import, span)))],\n-        vis: respan(span.shrink_to_lo(), ast::VisibilityKind::Inherited),\n-        node: ast::ItemKind::Use(P(ast::UseTree {\n-            prefix: ast::Path {\n-                segments: iter::once(ast::Ident::with_dummy_span(kw::PathRoot))\n-                    .chain(\n-                        [name, \"prelude\", \"v1\"].iter().cloned()\n-                            .map(ast::Ident::from_str)\n-                    ).map(ast::PathSegment::from_ident).collect(),\n-                span,\n-            },\n+    let use_item = cx.item(\n+        span,\n+        ast::Ident::invalid(),\n+        vec![cx.attribute(cx.meta_word(span, sym::prelude_import))],\n+        ast::ItemKind::Use(P(ast::UseTree {\n+            prefix: cx.path(span, import_path),\n             kind: ast::UseTreeKind::Glob,\n             span,\n         })),\n-        id: ast::DUMMY_NODE_ID,\n-        ident: ast::Ident::invalid(),\n-        span,\n-        tokens: None,\n-    }));\n+    );\n+\n+    krate.module.items.insert(0, use_item);\n \n-    (krate, Some(Symbol::intern(name)))\n+    (krate, Some(name))\n }"}, {"sha": "be5aca73f5cb1d504849c19ece1f934b0837c2ee", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "patch": "@@ -28,11 +28,11 @@ pub fn expand_test_case(\n \n     if !ecx.ecfg.should_test { return vec![]; }\n \n-    let sp = ecx.with_legacy_ctxt(attr_sp);\n+    let sp = ecx.with_def_site_ctxt(attr_sp);\n     let mut item = anno_item.expect_item();\n     item = item.map(|mut item| {\n         item.vis = respan(item.vis.span, ast::VisibilityKind::Public);\n-        item.ident = item.ident.gensym();\n+        item.ident.span = item.ident.span.with_ctxt(sp.ctxt());\n         item.attrs.push(\n             ecx.attribute(ecx.meta_word(sp, sym::rustc_test_marker))\n         );\n@@ -92,10 +92,9 @@ pub fn expand_test_or_bench(\n         return vec![Annotatable::Item(item)];\n     }\n \n-    let (sp, attr_sp) = (cx.with_legacy_ctxt(item.span), cx.with_legacy_ctxt(attr_sp));\n+    let (sp, attr_sp) = (cx.with_def_site_ctxt(item.span), cx.with_def_site_ctxt(attr_sp));\n \n-    // Gensym \"test\" so we can extern crate without conflicting with any local names\n-    let test_id = cx.ident_of(\"test\").gensym();\n+    let test_id = ast::Ident::new(sym::test, attr_sp);\n \n     // creates test::$name\n     let test_path = |name| {\n@@ -112,7 +111,7 @@ pub fn expand_test_or_bench(\n \n     let test_fn = if is_bench {\n         // A simple ident for a lambda\n-        let b = cx.ident_of(\"b\");\n+        let b = ast::Ident::from_str_and_span(\"b\", attr_sp);\n \n         cx.expr_call(sp, cx.expr_path(test_path(\"StaticBenchFn\")), vec![\n             // |b| self::test::assert_test_result(\n@@ -143,7 +142,7 @@ pub fn expand_test_or_bench(\n         ])\n     };\n \n-    let mut test_const = cx.item(sp, ast::Ident::new(item.ident.name, sp).gensym(),\n+    let mut test_const = cx.item(sp, ast::Ident::new(item.ident.name, sp),\n         vec![\n             // #[cfg(test)]\n             cx.attribute(cx.meta_list(attr_sp, sym::cfg, vec![\n@@ -192,17 +191,17 @@ pub fn expand_test_or_bench(\n         ));\n     test_const = test_const.map(|mut tc| { tc.vis.node = ast::VisibilityKind::Public; tc});\n \n-    // extern crate test as test_gensym\n+    // extern crate test\n     let test_extern = cx.item(sp,\n         test_id,\n         vec![],\n-        ast::ItemKind::ExternCrate(Some(sym::test))\n+        ast::ItemKind::ExternCrate(None)\n     );\n \n     log::debug!(\"synthetic test item:\\n{}\\n\", pprust::item_to_string(&test_const));\n \n     vec![\n-        // Access to libtest under a gensymed name\n+        // Access to libtest under a hygienic name\n         Annotatable::Item(test_extern),\n         // The generated test case\n         Annotatable::Item(test_const),"}, {"sha": "b93c11fad382391f3f2c4c5f40cb2854b6342991", "filename": "src/libsyntax_ext/test_harness.rs", "status": "modified", "additions": 95, "deletions": 148, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibsyntax_ext%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibsyntax_ext%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_harness.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "patch": "@@ -5,32 +5,30 @@ use smallvec::{smallvec, SmallVec};\n use syntax::ast::{self, Ident};\n use syntax::attr;\n use syntax::entry::{self, EntryPointType};\n-use syntax::ext::base::{ExtCtxt, MacroKind, Resolver};\n+use syntax::ext::base::{ExtCtxt, Resolver};\n use syntax::ext::expand::{AstFragment, ExpansionConfig};\n use syntax::feature_gate::Features;\n use syntax::mut_visit::{*, ExpectOne};\n use syntax::parse::ParseSess;\n use syntax::ptr::P;\n-use syntax::source_map::{ExpnData, ExpnKind, dummy_spanned};\n-use syntax::symbol::{kw, sym, Symbol};\n+use syntax::source_map::respan;\n+use syntax::symbol::{sym, Symbol};\n use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::hygiene::{AstPass, SyntaxContext, Transparency};\n \n use std::{iter, mem};\n \n struct Test {\n     span: Span,\n-    path: Vec<Ident>,\n+    ident: Ident,\n }\n \n struct TestCtxt<'a> {\n-    span_diagnostic: &'a errors::Handler,\n-    path: Vec<Ident>,\n     ext_cx: ExtCtxt<'a>,\n+    def_site: Span,\n     test_cases: Vec<Test>,\n     reexport_test_harness_main: Option<Symbol>,\n     test_runner: Option<ast::Path>,\n-    // top-level re-export submodule, filled out after folding is finished\n-    toplevel_reexport: Option<Ident>,\n }\n \n // Traverse the crate, collecting all the test functions, eliding any\n@@ -43,8 +41,8 @@ pub fn inject(\n     span_diagnostic: &errors::Handler,\n     features: &Features,\n ) {\n-    // Check for #[reexport_test_harness_main = \"some_name\"] which\n-    // creates a `use __test::main as some_name;`. This needs to be\n+    // Check for #![reexport_test_harness_main = \"some_name\"] which gives the\n+    // main test function the name `some_name` without hygiene. This needs to be\n     // unconditional, so that the attribute is still marked as used in\n     // non-test builds.\n     let reexport_test_harness_main =\n@@ -56,16 +54,13 @@ pub fn inject(\n \n     if should_test {\n         generate_test_harness(sess, resolver, reexport_test_harness_main,\n-                              krate, span_diagnostic, features, test_runner)\n+                              krate, features, test_runner)\n     }\n }\n \n struct TestHarnessGenerator<'a> {\n     cx: TestCtxt<'a>,\n-    tests: Vec<Ident>,\n-\n-    // submodule name, gensym'd identifier for re-exports\n-    tested_submods: Vec<(Ident, Ident)>,\n+    tests: Vec<Test>,\n }\n \n impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n@@ -77,49 +72,47 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n     }\n \n     fn flat_map_item(&mut self, i: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n-        let ident = i.ident;\n-        if ident.name != kw::Invalid {\n-            self.cx.path.push(ident);\n-        }\n-        debug!(\"current path: {}\", path_name_i(&self.cx.path));\n-\n         let mut item = i.into_inner();\n         if is_test_case(&item) {\n             debug!(\"this is a test item\");\n \n             let test = Test {\n                 span: item.span,\n-                path: self.cx.path.clone(),\n+                ident: item.ident,\n             };\n-            self.cx.test_cases.push(test);\n-            self.tests.push(item.ident);\n+            self.tests.push(test);\n         }\n \n         // We don't want to recurse into anything other than mods, since\n         // mods or tests inside of functions will break things\n         if let ast::ItemKind::Mod(mut module) = item.node {\n             let tests = mem::take(&mut self.tests);\n-            let tested_submods = mem::take(&mut self.tested_submods);\n             noop_visit_mod(&mut module, self);\n-            let tests = mem::replace(&mut self.tests, tests);\n-            let tested_submods = mem::replace(&mut self.tested_submods, tested_submods);\n+            let mut tests = mem::replace(&mut self.tests, tests);\n \n-            if !tests.is_empty() || !tested_submods.is_empty() {\n-                let (it, sym) = mk_reexport_mod(&mut self.cx, item.id, tests, tested_submods);\n-                module.items.push(it);\n-\n-                if !self.cx.path.is_empty() {\n-                    self.tested_submods.push((self.cx.path[self.cx.path.len()-1], sym));\n+            if !tests.is_empty() {\n+                let parent = if item.id == ast::DUMMY_NODE_ID {\n+                    ast::CRATE_NODE_ID\n                 } else {\n-                    debug!(\"pushing nothing, sym: {:?}\", sym);\n-                    self.cx.toplevel_reexport = Some(sym);\n+                    item.id\n+                };\n+                // Create an identifier that will hygienically resolve the test\n+                // case name, even in another module.\n+                let expn_id = self.cx.ext_cx.resolver.expansion_for_ast_pass(\n+                    module.inner,\n+                    AstPass::TestHarness,\n+                    &[],\n+                    Some(parent),\n+                );\n+                for test in &mut tests {\n+                    // See the comment on `mk_main` for why we're using\n+                    // `apply_mark` directly.\n+                    test.ident.span = test.ident.span.apply_mark(expn_id, Transparency::Opaque);\n                 }\n+                self.cx.test_cases.extend(tests);\n             }\n             item.node = ast::ItemKind::Mod(module);\n         }\n-        if ident.name != kw::Invalid {\n-            self.cx.path.pop();\n-        }\n         smallvec![P(item)]\n     }\n \n@@ -133,6 +126,7 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n struct EntryPointCleaner {\n     // Current depth in the ast\n     depth: usize,\n+    def_site: Span,\n }\n \n impl MutVisitor for EntryPointCleaner {\n@@ -149,8 +143,10 @@ impl MutVisitor for EntryPointCleaner {\n             EntryPointType::MainAttr |\n             EntryPointType::Start =>\n                 item.map(|ast::Item {id, ident, attrs, node, vis, span, tokens}| {\n-                    let allow_ident = Ident::with_dummy_span(sym::allow);\n-                    let dc_nested = attr::mk_nested_word_item(Ident::from_str(\"dead_code\"));\n+                    let allow_ident = Ident::new(sym::allow, self.def_site);\n+                    let dc_nested = attr::mk_nested_word_item(\n+                        Ident::from_str_and_span(\"dead_code\", self.def_site),\n+                    );\n                     let allow_dead_code_item = attr::mk_list_item(allow_ident, vec![dc_nested]);\n                     let allow_dead_code = attr::mk_attr_outer(allow_dead_code_item);\n \n@@ -181,124 +177,99 @@ impl MutVisitor for EntryPointCleaner {\n     }\n }\n \n-/// Creates an item (specifically a module) that \"pub use\"s the tests passed in.\n-/// Each tested submodule will contain a similar reexport module that we will export\n-/// under the name of the original module. That is, `submod::__test_reexports` is\n-/// reexported like so `pub use submod::__test_reexports as submod`.\n-fn mk_reexport_mod(cx: &mut TestCtxt<'_>,\n-                   parent: ast::NodeId,\n-                   tests: Vec<Ident>,\n-                   tested_submods: Vec<(Ident, Ident)>)\n-                   -> (P<ast::Item>, Ident) {\n-    let super_ = Ident::with_dummy_span(kw::Super);\n-\n-    let items = tests.into_iter().map(|r| {\n-        cx.ext_cx.item_use_simple(DUMMY_SP, dummy_spanned(ast::VisibilityKind::Public),\n-                                  cx.ext_cx.path(DUMMY_SP, vec![super_, r]))\n-    }).chain(tested_submods.into_iter().map(|(r, sym)| {\n-        let path = cx.ext_cx.path(DUMMY_SP, vec![super_, r, sym]);\n-        cx.ext_cx.item_use_simple_(DUMMY_SP, dummy_spanned(ast::VisibilityKind::Public),\n-                                   Some(r), path)\n-    })).collect();\n-\n-    let reexport_mod = ast::Mod {\n-        inline: true,\n-        inner: DUMMY_SP,\n-        items,\n-    };\n-\n-    let name = Ident::from_str(\"__test_reexports\").gensym();\n-    let parent = if parent == ast::DUMMY_NODE_ID { ast::CRATE_NODE_ID } else { parent };\n-    cx.ext_cx.current_expansion.id = cx.ext_cx.resolver.get_module_scope(parent);\n-    let module = P(ast::Item {\n-        ident: name,\n-        attrs: Vec::new(),\n-        id: ast::DUMMY_NODE_ID,\n-        node: ast::ItemKind::Mod(reexport_mod),\n-        vis: dummy_spanned(ast::VisibilityKind::Public),\n-        span: DUMMY_SP,\n-        tokens: None,\n-    });\n-\n-    // Integrate the new module into existing module structures.\n-    let module = AstFragment::Items(smallvec![module]);\n-    let module =\n-        cx.ext_cx.monotonic_expander().fully_expand_fragment(module).make_items().pop().unwrap();\n-\n-    (module, name)\n-}\n-\n /// Crawl over the crate, inserting test reexports and the test main function\n fn generate_test_harness(sess: &ParseSess,\n                          resolver: &mut dyn Resolver,\n                          reexport_test_harness_main: Option<Symbol>,\n                          krate: &mut ast::Crate,\n-                         sd: &errors::Handler,\n                          features: &Features,\n                          test_runner: Option<ast::Path>) {\n-    // Remove the entry points\n-    let mut cleaner = EntryPointCleaner { depth: 0 };\n-    cleaner.visit_crate(krate);\n-\n     let mut econfig = ExpansionConfig::default(\"test\".to_string());\n     econfig.features = Some(features);\n \n+    let ext_cx = ExtCtxt::new(sess, econfig, resolver);\n+\n+    let expn_id = ext_cx.resolver.expansion_for_ast_pass(\n+        DUMMY_SP,\n+        AstPass::TestHarness,\n+        &[sym::main, sym::test, sym::rustc_attrs],\n+        None,\n+    );\n+    let def_site = DUMMY_SP.with_def_site_ctxt(expn_id);\n+\n+    // Remove the entry points\n+    let mut cleaner = EntryPointCleaner { depth: 0, def_site };\n+    cleaner.visit_crate(krate);\n+\n     let cx = TestCtxt {\n-        span_diagnostic: sd,\n-        ext_cx: ExtCtxt::new(sess, econfig, resolver),\n-        path: Vec::new(),\n+        ext_cx,\n+        def_site,\n         test_cases: Vec::new(),\n         reexport_test_harness_main,\n-        toplevel_reexport: None,\n         test_runner\n     };\n \n     TestHarnessGenerator {\n         cx,\n         tests: Vec::new(),\n-        tested_submods: Vec::new(),\n     }.visit_crate(krate);\n }\n \n /// Creates a function item for use as the main function of a test build.\n /// This function will call the `test_runner` as specified by the crate attribute\n+///\n+/// By default this expands to\n+///\n+/// #[main]\n+/// pub fn main() {\n+///     extern crate test;\n+///     test::test_main_static(&[\n+///         &test_const1,\n+///         &test_const2,\n+///         &test_const3,\n+///     ]);\n+/// }\n+///\n+/// Most of the Ident have the usual def-site hygiene for the AST pass. The\n+/// exception is the `test_const`s. These have a syntax context that has two\n+/// opaque marks: one from the expansion of `test` or `test_case`, and one\n+/// generated  in `TestHarnessGenerator::flat_map_item`. When resolving this\n+/// identifier after failing to find a matching identifier in the root module\n+/// we remove the outer mark, and try resolving at its def-site, which will\n+/// then resolve to `test_const`.\n+///\n+/// The expansion here can be controlled by two attributes:\n+///\n+/// `reexport_test_harness_main` provides a different name for the `main`\n+/// function and `test_runner` provides a path that replaces\n+/// `test::test_main_static`.\n fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n-    // Writing this out by hand:\n-    //        pub fn main() {\n-    //            #![main]\n-    //            test::test_main_static(&[..tests]);\n-    //        }\n-    let sp = DUMMY_SP.fresh_expansion(ExpnData::allow_unstable(\n-        ExpnKind::Macro(MacroKind::Attr, sym::test_case), DUMMY_SP, cx.ext_cx.parse_sess.edition,\n-        [sym::main, sym::test, sym::rustc_attrs][..].into(),\n-    ));\n+    let sp = cx.def_site;\n     let ecx = &cx.ext_cx;\n-    let test_id = Ident::with_dummy_span(sym::test);\n+    let test_id = Ident::new(sym::test, sp);\n \n     // test::test_main_static(...)\n     let mut test_runner = cx.test_runner.clone().unwrap_or(\n-        ecx.path(sp, vec![\n-            test_id, ecx.ident_of(\"test_main_static\")\n-        ]));\n+        ecx.path(sp, vec![test_id, Ident::from_str_and_span(\"test_main_static\", sp)]));\n \n     test_runner.span = sp;\n \n     let test_main_path_expr = ecx.expr_path(test_runner);\n     let call_test_main = ecx.expr_call(sp, test_main_path_expr,\n-                                       vec![mk_tests_slice(cx)]);\n+                                       vec![mk_tests_slice(cx, sp)]);\n     let call_test_main = ecx.stmt_expr(call_test_main);\n \n-    // #![main]\n-    let main_meta = ecx.meta_word(sp, sym::main);\n-    let main_attr = ecx.attribute(main_meta);\n-\n-    // extern crate test as test_gensym\n+    // extern crate test\n     let test_extern_stmt = ecx.stmt_item(sp, ecx.item(sp,\n         test_id,\n         vec![],\n         ast::ItemKind::ExternCrate(None)\n     ));\n \n+    // #[main]\n+    let main_meta = ecx.meta_word(sp, sym::main);\n+    let main_attr = ecx.attribute(main_meta);\n+\n     // pub fn main() { ... }\n     let main_ret_ty = ecx.ty(sp, ast::TyKind::Tup(vec![]));\n \n@@ -316,16 +287,16 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n \n     // Honor the reexport_test_harness_main attribute\n     let main_id = match cx.reexport_test_harness_main {\n-        Some(sym) => Ident::new(sym, sp),\n-        None => Ident::from_str_and_span(\"main\", sp).gensym(),\n+        Some(sym) => Ident::new(sym, sp.with_ctxt(SyntaxContext::root())),\n+        None => Ident::from_str_and_span(\"main\", sp),\n     };\n \n     let main = P(ast::Item {\n         ident: main_id,\n         attrs: vec![main_attr],\n         id: ast::DUMMY_NODE_ID,\n         node: main,\n-        vis: dummy_spanned(ast::VisibilityKind::Public),\n+        vis: respan(sp, ast::VisibilityKind::Public),\n         span: sp,\n         tokens: None,\n     });\n@@ -335,44 +306,20 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n     cx.ext_cx.monotonic_expander().fully_expand_fragment(main).make_items().pop().unwrap()\n }\n \n-fn path_name_i(idents: &[Ident]) -> String {\n-    let mut path_name = \"\".to_string();\n-    let mut idents_iter = idents.iter().peekable();\n-    while let Some(ident) = idents_iter.next() {\n-        path_name.push_str(&ident.as_str());\n-        if idents_iter.peek().is_some() {\n-            path_name.push_str(\"::\")\n-        }\n-    }\n-    path_name\n-}\n-\n /// Creates a slice containing every test like so:\n-/// &[path::to::test1, path::to::test2]\n-fn mk_tests_slice(cx: &TestCtxt<'_>) -> P<ast::Expr> {\n+/// &[&test1, &test2]\n+fn mk_tests_slice(cx: &TestCtxt<'_>, sp: Span) -> P<ast::Expr> {\n     debug!(\"building test vector from {} tests\", cx.test_cases.len());\n     let ref ecx = cx.ext_cx;\n \n-    ecx.expr_vec_slice(DUMMY_SP,\n+\n+    ecx.expr_vec_slice(sp,\n         cx.test_cases.iter().map(|test| {\n             ecx.expr_addr_of(test.span,\n-                ecx.expr_path(ecx.path(test.span, visible_path(cx, &test.path))))\n+                ecx.expr_path(ecx.path(test.span, vec![test.ident])))\n         }).collect())\n }\n \n-/// Creates a path from the top-level __test module to the test via __test_reexports\n-fn visible_path(cx: &TestCtxt<'_>, path: &[Ident]) -> Vec<Ident>{\n-    let mut visible_path = vec![];\n-    match cx.toplevel_reexport {\n-        Some(id) => visible_path.push(id),\n-        None => {\n-            cx.span_diagnostic.bug(\"expected to find top-level re-export name, but found None\");\n-        }\n-    }\n-    visible_path.extend_from_slice(path);\n-    visible_path\n-}\n-\n fn is_test_case(i: &ast::Item) -> bool {\n     attr::contains_name(&i.attrs, sym::rustc_test_marker)\n }"}, {"sha": "f0e7344c1b9860ff950da975c486b457f2e752d2", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "patch": "@@ -360,7 +360,7 @@ impl SyntaxContext {\n     }\n \n     /// Extend a syntax context with a given expansion and transparency.\n-    pub fn apply_mark(self, expn_id: ExpnId, transparency: Transparency) -> SyntaxContext {\n+    crate fn apply_mark(self, expn_id: ExpnId, transparency: Transparency) -> SyntaxContext {\n         HygieneData::with(|data| data.apply_mark(self, expn_id, transparency))\n     }\n \n@@ -550,7 +550,7 @@ impl Span {\n     /// The returned span belongs to the created expansion and has the new properties,\n     /// but its location is inherited from the current span.\n     pub fn fresh_expansion(self, expn_data: ExpnData) -> Span {\n-        self.fresh_expansion_with_transparency(expn_data, Transparency::SemiTransparent)\n+        self.fresh_expansion_with_transparency(expn_data, Transparency::Transparent)\n     }\n \n     pub fn fresh_expansion_with_transparency(\n@@ -639,8 +639,9 @@ pub enum ExpnKind {\n     /// No expansion, aka root expansion. Only `ExpnId::root()` has this kind.\n     Root,\n     /// Expansion produced by a macro.\n-    /// FIXME: Some code injected by the compiler before HIR lowering also gets this kind.\n     Macro(MacroKind, Symbol),\n+    /// Transform done by the compiler on the AST.\n+    AstPass(AstPass),\n     /// Desugaring done by the compiler during HIR lowering.\n     Desugaring(DesugaringKind)\n }\n@@ -650,6 +651,7 @@ impl ExpnKind {\n         match *self {\n             ExpnKind::Root => kw::PathRoot,\n             ExpnKind::Macro(_, descr) => descr,\n+            ExpnKind::AstPass(kind) => Symbol::intern(kind.descr()),\n             ExpnKind::Desugaring(kind) => Symbol::intern(kind.descr()),\n         }\n     }\n@@ -683,6 +685,26 @@ impl MacroKind {\n     }\n }\n \n+/// The kind of AST transform.\n+#[derive(Clone, Copy, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n+pub enum AstPass {\n+    StdImports,\n+    TestHarness,\n+    ProcMacroHarness,\n+    PluginMacroDefs,\n+}\n+\n+impl AstPass {\n+    fn descr(self) -> &'static str {\n+        match self {\n+            AstPass::StdImports => \"standard library imports\",\n+            AstPass::TestHarness => \"test harness\",\n+            AstPass::ProcMacroHarness => \"proc macro harness\",\n+            AstPass::PluginMacroDefs => \"plugin macro definitions\",\n+        }\n+    }\n+}\n+\n /// The kind of compiler desugaring.\n #[derive(Clone, Copy, PartialEq, Debug, RustcEncodable, RustcDecodable)]\n pub enum DesugaringKind {"}, {"sha": "9a296f17aaf4aa26cc274ba2b0644b4e8e1887f6", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "patch": "@@ -442,6 +442,7 @@ impl Span {\n                 let (pre, post) = match expn_data.kind {\n                     ExpnKind::Root => break,\n                     ExpnKind::Desugaring(..) => (\"desugaring of \", \"\"),\n+                    ExpnKind::AstPass(..) => (\"\", \"\"),\n                     ExpnKind::Macro(macro_kind, _) => match macro_kind {\n                         MacroKind::Bang => (\"\", \"!\"),\n                         MacroKind::Attr => (\"#[\", \"]\"),\n@@ -513,6 +514,25 @@ impl Span {\n                   span.ctxt)\n     }\n \n+    /// Equivalent of `Span::def_site` from the proc macro API,\n+    /// except that the location is taken from the `self` span.\n+    pub fn with_def_site_ctxt(self, expn_id: ExpnId) -> Span {\n+        self.with_ctxt_from_mark(expn_id, Transparency::Opaque)\n+    }\n+\n+    /// Equivalent of `Span::call_site` from the proc macro API,\n+    /// except that the location is taken from the `self` span.\n+    pub fn with_call_site_ctxt(&self, expn_id: ExpnId) -> Span {\n+        self.with_ctxt_from_mark(expn_id, Transparency::Transparent)\n+    }\n+\n+    /// Span with a context reproducing `macro_rules` hygiene (hygienic locals, unhygienic items).\n+    /// FIXME: This should be eventually replaced either with `with_def_site_ctxt` (preferably),\n+    /// or with `with_call_site_ctxt` (where necessary).\n+    pub fn with_legacy_ctxt(&self, expn_id: ExpnId) -> Span {\n+        self.with_ctxt_from_mark(expn_id, Transparency::SemiTransparent)\n+    }\n+\n     /// Produces a span with the same location as `self` and context produced by a macro with the\n     /// given ID and transparency, assuming that macro was defined directly and not produced by\n     /// some other macro (which is the case for built-in and procedural macros)."}, {"sha": "ecc31cfeb3d1f00491f7bde328ef2c7a47bea18c", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "patch": "@@ -801,21 +801,15 @@ impl Ident {\n         Ident::new(self.name, self.span.modern_and_legacy())\n     }\n \n-    /// Transforms an identifier into one with the same name, but gensymed.\n-    pub fn gensym(self) -> Ident {\n-        let name = with_interner(|interner| interner.gensymed(self.name));\n-        Ident::new(name, self.span)\n-    }\n-\n     /// Transforms an underscore identifier into one with the same name, but\n     /// gensymed. Leaves non-underscore identifiers unchanged.\n     pub fn gensym_if_underscore(self) -> Ident {\n-        if self.name == kw::Underscore { self.gensym() } else { self }\n-    }\n-\n-    // WARNING: this function is deprecated and will be removed in the future.\n-    pub fn is_gensymed(self) -> bool {\n-        with_interner(|interner| interner.is_gensymed(self.name))\n+        if self.name == kw::Underscore {\n+            let name = with_interner(|interner| interner.gensymed(self.name));\n+            Ident::new(name, self.span)\n+        } else {\n+            self\n+        }\n     }\n \n     /// Convert the name to a `LocalInternedString`. This is a slowish\n@@ -892,9 +886,12 @@ impl UseSpecializedDecodable for Ident {\n ///\n /// Examples:\n /// ```\n-/// assert_eq!(Ident::from_str(\"x\"), Ident::from_str(\"x\"))\n-/// assert_ne!(Ident::from_str(\"x\").gensym(), Ident::from_str(\"x\"))\n-/// assert_ne!(Ident::from_str(\"x\").gensym(), Ident::from_str(\"x\").gensym())\n+/// assert_eq!(Ident::from_str(\"_\"), Ident::from_str(\"_\"))\n+/// assert_ne!(Ident::from_str(\"_\").gensym_if_underscore(), Ident::from_str(\"_\"))\n+/// assert_ne!(\n+///     Ident::from_str(\"_\").gensym_if_underscore(),\n+///     Ident::from_str(\"_\").gensym_if_underscore(),\n+/// )\n /// ```\n /// Internally, a symbol is implemented as an index, and all operations\n /// (including hashing, equality, and ordering) operate on that index. The use"}, {"sha": "babba293d03bdded07a45c0a558a857cedb7445c", "filename": "src/test/ui/hygiene/auxiliary/not-libstd.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fnot-libstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fnot-libstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fauxiliary%2Fnot-libstd.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "patch": "@@ -0,0 +1 @@\n+pub fn not_in_lib_std() {}"}, {"sha": "51e7bed6580b35b369281f9a7b4399d33089d3e1", "filename": "src/test/ui/hygiene/prelude-import-hygiene.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Fhygiene%2Fprelude-import-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Fhygiene%2Fprelude-import-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fprelude-import-hygiene.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "patch": "@@ -0,0 +1,29 @@\n+// Make sure that attribute used when injecting the prelude are resolved\n+// hygienically.\n+\n+// check-pass\n+// aux-build:not-libstd.rs\n+\n+//revisions: rust2015 rust2018\n+//[rust2018] edition:2018\n+\n+// The prelude import shouldn't see these as candidates for when it's trying to\n+// use the built-in macros.\n+extern crate core;\n+use core::prelude::v1::test as prelude_import;\n+use core::prelude::v1::test as macro_use;\n+\n+// Should not be used for the prelude import - not a concern in the 2015 edition\n+// because `std` is already declared in the crate root.\n+#[cfg(rust2018)]\n+extern crate not_libstd as std;\n+\n+#[cfg(rust2018)]\n+mod x {\n+    // The extern crate item should override `std` in the extern prelude.\n+    fn f() {\n+        std::not_in_lib_std();\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "7b53f0c536ad9917b1f40e40e61b2112ce3d023e", "filename": "src/test/ui/imports/gensymed.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Fimports%2Fgensymed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Fimports%2Fgensymed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fgensymed.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "patch": "@@ -1,7 +1,9 @@\n-// build-pass (FIXME(62277): could be check-pass?)\n+// check-pass\n // edition:2018\n // aux-build:gensymed.rs\n \n extern crate gensymed;\n \n+use gensymed::*;\n+\n fn main() {}"}, {"sha": "b6a817e6b1d303c6c1444105ae1c9d585ebd45a2", "filename": "src/test/ui/inaccessible-test-modules.stderr", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/da13f06ea0dc368f1350bfc356b7f81a838defde/src%2Ftest%2Fui%2Finaccessible-test-modules.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/da13f06ea0dc368f1350bfc356b7f81a838defde/src%2Ftest%2Fui%2Finaccessible-test-modules.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finaccessible-test-modules.stderr?ref=da13f06ea0dc368f1350bfc356b7f81a838defde", "patch": "@@ -1,21 +0,0 @@\n-error[E0432]: unresolved import `__test`\n-  --> $DIR/inaccessible-test-modules.rs:5:5\n-   |\n-LL | use __test as x;\n-   |     ------^^^^^\n-   |     |\n-   |     no `__test` in the root\n-   |     help: a similar name exists in the module: `test`\n-\n-error[E0432]: unresolved import `__test_reexports`\n-  --> $DIR/inaccessible-test-modules.rs:6:5\n-   |\n-LL | use __test_reexports as y;\n-   |     ----------------^^^^^\n-   |     |\n-   |     no `__test_reexports` in the root\n-   |     help: a similar name exists in the module: `__test_reexports`\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0432`."}, {"sha": "ea06f6c1acaf993b948b6c64543e0c6c6cfe597b", "filename": "src/test/ui/proc-macro/dollar-crate-issue-57089.stdout", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-57089.stdout?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "patch": "@@ -2,80 +2,80 @@ PRINT-BANG INPUT (DISPLAY): struct M ($crate :: S) ;\n PRINT-BANG INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"M\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"$crate\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Joint,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Alone,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Ident {\n                 ident: \"S\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n         ],\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n ]\n PRINT-ATTR INPUT (DISPLAY): struct A(crate::S);\n PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ($crate :: S) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"A\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"$crate\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Joint,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Alone,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Ident {\n                 ident: \"S\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n         ],\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n ]"}, {"sha": "7ee8078b2c5d2210f7aacefc22ab4cad1da28656", "filename": "src/test/ui/proc-macro/dollar-crate-issue-62325.stdout", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-62325.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-62325.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate-issue-62325.stdout?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "patch": "@@ -3,110 +3,110 @@ PRINT-ATTR RE-COLLECTED (DISPLAY): struct A (identity ! ($crate :: S)) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"A\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"identity\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: '!',\n                 spacing: Alone,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Group {\n                 delimiter: Parenthesis,\n                 stream: TokenStream [\n                     Ident {\n                         ident: \"$crate\",\n-                        span: #2 bytes(LO..HI),\n+                        span: #3 bytes(LO..HI),\n                     },\n                     Punct {\n                         ch: ':',\n                         spacing: Joint,\n-                        span: #2 bytes(LO..HI),\n+                        span: #3 bytes(LO..HI),\n                     },\n                     Punct {\n                         ch: ':',\n                         spacing: Alone,\n-                        span: #2 bytes(LO..HI),\n+                        span: #3 bytes(LO..HI),\n                     },\n                     Ident {\n                         ident: \"S\",\n-                        span: #2 bytes(LO..HI),\n+                        span: #3 bytes(LO..HI),\n                     },\n                 ],\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n         ],\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n ]\n PRINT-ATTR INPUT (DISPLAY): struct B(identity!(::dollar_crate_external :: S));\n PRINT-ATTR RE-COLLECTED (DISPLAY): struct B (identity ! ($crate :: S)) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #7 bytes(LO..HI),\n+        span: #8 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"B\",\n-        span: #7 bytes(LO..HI),\n+        span: #8 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"identity\",\n-                span: #7 bytes(LO..HI),\n+                span: #8 bytes(LO..HI),\n             },\n             Punct {\n                 ch: '!',\n                 spacing: Alone,\n-                span: #7 bytes(LO..HI),\n+                span: #8 bytes(LO..HI),\n             },\n             Group {\n                 delimiter: Parenthesis,\n                 stream: TokenStream [\n                     Ident {\n                         ident: \"$crate\",\n-                        span: #7 bytes(LO..HI),\n+                        span: #8 bytes(LO..HI),\n                     },\n                     Punct {\n                         ch: ':',\n                         spacing: Joint,\n-                        span: #7 bytes(LO..HI),\n+                        span: #8 bytes(LO..HI),\n                     },\n                     Punct {\n                         ch: ':',\n                         spacing: Alone,\n-                        span: #7 bytes(LO..HI),\n+                        span: #8 bytes(LO..HI),\n                     },\n                     Ident {\n                         ident: \"S\",\n-                        span: #7 bytes(LO..HI),\n+                        span: #8 bytes(LO..HI),\n                     },\n                 ],\n-                span: #7 bytes(LO..HI),\n+                span: #8 bytes(LO..HI),\n             },\n         ],\n-        span: #7 bytes(LO..HI),\n+        span: #8 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #7 bytes(LO..HI),\n+        span: #8 bytes(LO..HI),\n     },\n ]"}, {"sha": "4f7e000265eb02fd757f6160b04b79851662940f", "filename": "src/test/ui/proc-macro/dollar-crate.stdout", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fdollar-crate.stdout?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "patch": "@@ -2,243 +2,243 @@ PRINT-BANG INPUT (DISPLAY): struct M ($crate :: S) ;\n PRINT-BANG INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"M\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"$crate\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Joint,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Alone,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Ident {\n                 ident: \"S\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n         ],\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n ]\n PRINT-ATTR INPUT (DISPLAY): struct A(crate::S);\n PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ($crate :: S) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"A\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"$crate\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Joint,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Alone,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Ident {\n                 ident: \"S\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n         ],\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n ]\n PRINT-DERIVE INPUT (DISPLAY): struct D(crate::S);\n PRINT-DERIVE RE-COLLECTED (DISPLAY): struct D ($crate :: S) ;\n PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"D\",\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"$crate\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Joint,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Alone,\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n             Ident {\n                 ident: \"S\",\n-                span: #2 bytes(LO..HI),\n+                span: #3 bytes(LO..HI),\n             },\n         ],\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #2 bytes(LO..HI),\n+        span: #3 bytes(LO..HI),\n     },\n ]\n PRINT-BANG INPUT (DISPLAY): struct M ($crate :: S) ;\n PRINT-BANG INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"M\",\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"$crate\",\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Joint,\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Alone,\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n             Ident {\n                 ident: \"S\",\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n         ],\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n ]\n PRINT-ATTR INPUT (DISPLAY): struct A(::dollar_crate_external::S);\n PRINT-ATTR RE-COLLECTED (DISPLAY): struct A ($crate :: S) ;\n PRINT-ATTR INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"A\",\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"$crate\",\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Joint,\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Alone,\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n             Ident {\n                 ident: \"S\",\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n         ],\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n ]\n PRINT-DERIVE INPUT (DISPLAY): struct D(::dollar_crate_external::S);\n PRINT-DERIVE RE-COLLECTED (DISPLAY): struct D ($crate :: S) ;\n PRINT-DERIVE INPUT (DEBUG): TokenStream [\n     Ident {\n         ident: \"struct\",\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n     Ident {\n         ident: \"D\",\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n     Group {\n         delimiter: Parenthesis,\n         stream: TokenStream [\n             Ident {\n                 ident: \"$crate\",\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Joint,\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n             Punct {\n                 ch: ':',\n                 spacing: Alone,\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n             Ident {\n                 ident: \"S\",\n-                span: #9 bytes(LO..HI),\n+                span: #10 bytes(LO..HI),\n             },\n         ],\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n     Punct {\n         ch: ';',\n         spacing: Alone,\n-        span: #9 bytes(LO..HI),\n+        span: #10 bytes(LO..HI),\n     },\n ]"}, {"sha": "60a98ab6a026be32398e5645e40e16b6bb9f175a", "filename": "src/test/ui/test-attrs/auxiliary/test_macro.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Fauxiliary%2Ftest_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Fauxiliary%2Ftest_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Fauxiliary%2Ftest_macro.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "previous_filename": "src/test/ui/test-shadowing/auxiliary/test_macro.rs"}, {"sha": "fcbe9f49e556497b49d0ed97162969ac9f86a78e", "filename": "src/test/ui/test-attrs/decl-macro-test.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Fdecl-macro-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Fdecl-macro-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Fdecl-macro-test.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "patch": "@@ -0,0 +1,22 @@\n+// Check that declarative macros can declare tests\n+\n+// check-pass\n+// compile-flags: --test\n+\n+#![feature(decl_macro)]\n+\n+macro create_test() {\n+    #[test]\n+    fn test() {}\n+}\n+\n+macro create_module_test() {\n+    mod x {\n+        #[test]\n+        fn test() {}\n+    }\n+}\n+\n+create_test!();\n+create_test!();\n+create_module_test!();"}, {"sha": "f5b34793794805cf44dbd090e16b977b5b40e670", "filename": "src/test/ui/test-attrs/inaccessible-test-modules.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Finaccessible-test-modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Finaccessible-test-modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Finaccessible-test-modules.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "patch": "@@ -2,8 +2,8 @@\n \n // the `--test` harness creates modules with these textual names, but\n // they should be inaccessible from normal code.\n-use __test as x; //~ ERROR unresolved import `__test`\n-use __test_reexports as y; //~ ERROR unresolved import `__test_reexports`\n+use main as x; //~ ERROR unresolved import `main`\n+use test as y; //~ ERROR unresolved import `test`\n \n #[test]\n fn baz() {}", "previous_filename": "src/test/ui/inaccessible-test-modules.rs"}, {"sha": "a94ea1e79bc5199afe75779d024cf0f59551ff8d", "filename": "src/test/ui/test-attrs/inaccessible-test-modules.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Finaccessible-test-modules.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Finaccessible-test-modules.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Finaccessible-test-modules.stderr?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "patch": "@@ -0,0 +1,21 @@\n+error[E0432]: unresolved import `main`\n+  --> $DIR/inaccessible-test-modules.rs:5:5\n+   |\n+LL | use main as x;\n+   |     ----^^^^^\n+   |     |\n+   |     no `main` in the root\n+   |     help: a similar name exists in the module: `main`\n+\n+error[E0432]: unresolved import `test`\n+  --> $DIR/inaccessible-test-modules.rs:6:5\n+   |\n+LL | use test as y;\n+   |     ----^^^^^\n+   |     |\n+   |     no `test` in the root\n+   |     help: a similar name exists in the module: `test`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0432`."}, {"sha": "1a478460efc6c8954c6714450b848652cd700a85", "filename": "src/test/ui/test-attrs/test-allow-fail-attr.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-allow-fail-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-allow-fail-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-allow-fail-attr.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "previous_filename": "src/test/ui/test-allow-fail-attr.rs"}, {"sha": "e475f5b4a75a515f7d97b02a1583ce120617bc94", "filename": "src/test/ui/test-attrs/test-attr-non-associated-functions.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-attr-non-associated-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-attr-non-associated-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-attr-non-associated-functions.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "previous_filename": "src/test/ui/test-attr-non-associated-functions.rs"}, {"sha": "cb3ae51823e45bd993f6500b2f54613be44306ee", "filename": "src/test/ui/test-attrs/test-attr-non-associated-functions.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-attr-non-associated-functions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-attr-non-associated-functions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-attr-non-associated-functions.stderr?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "previous_filename": "src/test/ui/test-attr-non-associated-functions.stderr"}, {"sha": "831372d4506b312288dcb831d5b4da0995a587fa", "filename": "src/test/ui/test-attrs/test-cant-be-shadowed.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-cant-be-shadowed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-cant-be-shadowed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-cant-be-shadowed.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "previous_filename": "src/test/ui/test-shadowing/test-cant-be-shadowed.rs"}, {"sha": "ff62d84925f2be110481038ef91511a185d28788", "filename": "src/test/ui/test-attrs/test-fn-signature-verification-for-explicit-return-type.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-fn-signature-verification-for-explicit-return-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-fn-signature-verification-for-explicit-return-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-fn-signature-verification-for-explicit-return-type.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "previous_filename": "src/test/ui/test-fn-signature-verification-for-explicit-return-type.rs"}, {"sha": "628b1896ace4f32a4b1baae1e18cf57a23b3ac8e", "filename": "src/test/ui/test-attrs/test-main-not-dead-attr.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-main-not-dead-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-main-not-dead-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-main-not-dead-attr.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "previous_filename": "src/test/ui/test-main-not-dead-attr.rs"}, {"sha": "30a9c85e3d2abe503f89abd97c5541fb6feb5bdb", "filename": "src/test/ui/test-attrs/test-main-not-dead.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-main-not-dead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-main-not-dead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-main-not-dead.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "previous_filename": "src/test/ui/test-main-not-dead.rs"}, {"sha": "a238db6d716238c699c745d29922045376fd7010", "filename": "src/test/ui/test-attrs/test-on-macro.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-on-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-on-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-on-macro.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "previous_filename": "src/test/ui/test-on-macro.rs"}, {"sha": "256a41722fa956534e09d2b713d65b83a44c3f37", "filename": "src/test/ui/test-attrs/test-on-macro.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-on-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-on-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-on-macro.stderr?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "previous_filename": "src/test/ui/test-on-macro.stderr"}, {"sha": "917c09801e1750f62a25d4912abe41f17c4f083c", "filename": "src/test/ui/test-attrs/test-runner-hides-buried-main.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-runner-hides-buried-main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-runner-hides-buried-main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-runner-hides-buried-main.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "previous_filename": "src/test/ui/test-runner-hides-buried-main.rs"}, {"sha": "0de1d64f0fcc71420fb58e68fdd8fb6e84eb65b3", "filename": "src/test/ui/test-attrs/test-runner-hides-main.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-runner-hides-main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-runner-hides-main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-runner-hides-main.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "previous_filename": "src/test/ui/test-runner-hides-main.rs"}, {"sha": "56212bb6f4b7357a475baab7cd5a5612d67b77d9", "filename": "src/test/ui/test-attrs/test-runner-hides-start.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-runner-hides-start.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-runner-hides-start.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-runner-hides-start.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "previous_filename": "src/test/ui/test-runner-hides-start.rs"}, {"sha": "9fa759f9eb4837a25ff0b215cba976b78f849412", "filename": "src/test/ui/test-attrs/test-should-fail-good-message.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-should-fail-good-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-should-fail-good-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-should-fail-good-message.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "previous_filename": "src/test/ui/test-should-fail-good-message.rs"}, {"sha": "9c38322fe96fd754f209b1b26bdeb2b0d21bd645", "filename": "src/test/ui/test-attrs/test-should-panic-attr.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-should-panic-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-should-panic-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-should-panic-attr.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "previous_filename": "src/test/ui/test-should-panic-attr.rs"}, {"sha": "4b032eba5f8d577e0d25634858b9e8d2253cad41", "filename": "src/test/ui/test-attrs/test-should-panic-attr.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-should-panic-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-should-panic-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-should-panic-attr.stderr?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "previous_filename": "src/test/ui/test-should-panic-attr.stderr"}, {"sha": "cd1cd33c2840b5d28b8384fd6f8f8d3d750f94bc", "filename": "src/test/ui/test-attrs/test-vs-cfg-test.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-vs-cfg-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-vs-cfg-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-vs-cfg-test.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "previous_filename": "src/test/ui/test-vs-cfg-test.rs"}, {"sha": "936461f162d688cf3c08506372f3299f724f950d", "filename": "src/test/ui/test-attrs/test-warns-dead-code.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-warns-dead-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-warns-dead-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-warns-dead-code.rs?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "previous_filename": "src/test/ui/test-warns-dead-code.rs"}, {"sha": "62e99225dd90266c00dcba212613a50f48403c5c", "filename": "src/test/ui/test-attrs/test-warns-dead-code.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-warns-dead-code.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/db493ef613305c7bff31d3e1959b07c3ddbbe245/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-warns-dead-code.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftest-attrs%2Ftest-warns-dead-code.stderr?ref=db493ef613305c7bff31d3e1959b07c3ddbbe245", "previous_filename": "src/test/ui/test-warns-dead-code.stderr"}]}