{"sha": "3dcde0b2ab8bc28dc8ef98ec07cb6d1072b93de8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkY2RlMGIyYWI4YmMyOGRjOGVmOThlYzA3Y2I2ZDEwNzJiOTNkZTg=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-17T18:19:27Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-17T18:19:27Z"}, "message": "Merge #847\n\n847: Refactor vfs r=matklad a=matklad\n\nSome slight refctorings of VFS, in preparation for moving it to a separate repo\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "0ff3415e45d74a00e4d62666b13b4f17e91682fa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ff3415e45d74a00e4d62666b13b4f17e91682fa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3dcde0b2ab8bc28dc8ef98ec07cb6d1072b93de8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3dcde0b2ab8bc28dc8ef98ec07cb6d1072b93de8", "html_url": "https://github.com/rust-lang/rust/commit/3dcde0b2ab8bc28dc8ef98ec07cb6d1072b93de8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3dcde0b2ab8bc28dc8ef98ec07cb6d1072b93de8/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "982f72c022b45629e6adbaef22884359d3495ecf", "url": "https://api.github.com/repos/rust-lang/rust/commits/982f72c022b45629e6adbaef22884359d3495ecf", "html_url": "https://github.com/rust-lang/rust/commit/982f72c022b45629e6adbaef22884359d3495ecf"}, {"sha": "aea986001fe42398589871b13e3a307d23f83461", "url": "https://api.github.com/repos/rust-lang/rust/commits/aea986001fe42398589871b13e3a307d23f83461", "html_url": "https://github.com/rust-lang/rust/commit/aea986001fe42398589871b13e3a307d23f83461"}], "stats": {"total": 396, "additions": 201, "deletions": 195}, "files": [{"sha": "89a234f4c34290687cf9fd863f942cee1578f5bb", "filename": "crates/ra_batch/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3dcde0b2ab8bc28dc8ef98ec07cb6d1072b93de8/crates%2Fra_batch%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcde0b2ab8bc28dc8ef98ec07cb6d1072b93de8/crates%2Fra_batch%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_batch%2Fsrc%2Flib.rs?ref=3dcde0b2ab8bc28dc8ef98ec07cb6d1072b93de8", "patch": "@@ -75,7 +75,7 @@ impl BatchDatabase {\n                         let source_root = SourceRoot { files: file_map };\n                         db.set_source_root(source_root_id, Arc::new(source_root));\n                         roots_loaded.insert(source_root_id);\n-                        if roots_loaded.len() == vfs.num_roots() {\n+                        if roots_loaded.len() == vfs.n_roots() {\n                             done = true;\n                         }\n                     }\n@@ -137,14 +137,14 @@ mod tests {\n             path = path.parent().unwrap().to_owned();\n         }\n         let (db, roots) = BatchDatabase::load_cargo(path).unwrap();\n-        let mut num_crates = 0;\n+        let mut n_crates = 0;\n         for root in roots {\n             for _krate in Crate::source_root_crates(&db, root) {\n-                num_crates += 1;\n+                n_crates += 1;\n             }\n         }\n \n         // RA has quite a few crates, but the exact count doesn't matter\n-        assert!(num_crates > 20);\n+        assert!(n_crates > 20);\n     }\n }"}, {"sha": "0cffc03f3ece2ef27b46b5e9ba9cf14c1ace66f2", "filename": "crates/ra_vfs/src/io.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3dcde0b2ab8bc28dc8ef98ec07cb6d1072b93de8/crates%2Fra_vfs%2Fsrc%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcde0b2ab8bc28dc8ef98ec07cb6d1072b93de8/crates%2Fra_vfs%2Fsrc%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fio.rs?ref=3dcde0b2ab8bc28dc8ef98ec07cb6d1072b93de8", "patch": "@@ -9,10 +9,10 @@ use relative_path::RelativePathBuf;\n use walkdir::WalkDir;\n use notify::{DebouncedEvent, RecommendedWatcher, RecursiveMode, Watcher as _Watcher};\n \n-use crate::{RootConfig, Roots, VfsRoot};\n+use crate::{Roots, VfsRoot};\n \n pub(crate) enum Task {\n-    AddRoot { root: VfsRoot, config: Arc<RootConfig> },\n+    AddRoot { root: VfsRoot },\n }\n \n /// `TaskResult` transfers files read on the IO thread to the VFS on the main\n@@ -98,8 +98,8 @@ pub(crate) fn start(roots: Arc<Roots>) -> Worker {\n                                 drop(input_receiver);\n                                 break\n                             },\n-                            Ok(Task::AddRoot { root, config }) => {\n-                                watch_root(watcher.as_mut(), &output_sender, root, Arc::clone(&config));\n+                            Ok(Task::AddRoot { root }) => {\n+                                watch_root(watcher.as_mut(), &output_sender, &*roots, root);\n                             }\n                         },\n                         // Watcher send us changes. If **this** channel is\n@@ -123,20 +123,21 @@ pub(crate) fn start(roots: Arc<Roots>) -> Worker {\n fn watch_root(\n     watcher: Option<&mut RecommendedWatcher>,\n     sender: &Sender<TaskResult>,\n+    roots: &Roots,\n     root: VfsRoot,\n-    config: Arc<RootConfig>,\n ) {\n-    log::debug!(\"loading {} ...\", config.root.as_path().display());\n-    let files = watch_recursive(watcher, config.root.as_path(), &*config)\n+    let root_path = roots.path(root);\n+    log::debug!(\"loading {} ...\", root_path.display());\n+    let files = watch_recursive(watcher, root_path, roots, root)\n         .into_iter()\n         .filter_map(|path| {\n-            let abs_path = path.to_path(&config.root);\n+            let abs_path = path.to_path(&root_path);\n             let text = read_to_string(&abs_path)?;\n             Some((path, text))\n         })\n         .collect();\n     sender.send(TaskResult::BulkLoadRoot { root, files }).unwrap();\n-    log::debug!(\"... loaded {}\", config.root.as_path().display());\n+    log::debug!(\"... loaded {}\", root_path.display());\n }\n \n fn convert_notify_event(event: DebouncedEvent, sender: &Sender<(PathBuf, ChangeKind)>) {\n@@ -181,19 +182,18 @@ fn handle_change(\n         None => return,\n         Some(it) => it,\n     };\n-    let config = &roots[root];\n     match kind {\n         ChangeKind::Create => {\n             let mut paths = Vec::new();\n             if path.is_dir() {\n-                paths.extend(watch_recursive(watcher, &path, &config));\n+                paths.extend(watch_recursive(watcher, &path, roots, root));\n             } else {\n                 paths.push(rel_path);\n             }\n             paths\n                 .into_iter()\n                 .try_for_each(|rel_path| {\n-                    let abs_path = rel_path.to_path(&config.root);\n+                    let abs_path = rel_path.to_path(&roots.path(root));\n                     let text = read_to_string(&abs_path);\n                     sender.send(TaskResult::SingleFile { root, path: rel_path, text })\n                 })\n@@ -209,20 +209,21 @@ fn handle_change(\n fn watch_recursive(\n     mut watcher: Option<&mut RecommendedWatcher>,\n     dir: &Path,\n-    config: &RootConfig,\n+    roots: &Roots,\n+    root: VfsRoot,\n ) -> Vec<RelativePathBuf> {\n     let mut files = Vec::new();\n     for entry in WalkDir::new(dir)\n         .into_iter()\n-        .filter_entry(|it| config.contains(it.path()).is_some())\n+        .filter_entry(|it| roots.contains(root, it.path()).is_some())\n         .filter_map(|it| it.map_err(|e| log::warn!(\"watcher error: {}\", e)).ok())\n     {\n         if entry.file_type().is_dir() {\n             if let Some(watcher) = &mut watcher {\n                 watch_one(watcher, entry.path());\n             }\n         } else {\n-            let path = config.contains(entry.path()).unwrap();\n+            let path = roots.contains(root, entry.path()).unwrap();\n             files.push(path.to_owned());\n         }\n     }"}, {"sha": "7f555a3c009cc4bc156e2155c6ca443888b023ed", "filename": "crates/ra_vfs/src/lib.rs", "status": "modified", "additions": 72, "deletions": 176, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/3dcde0b2ab8bc28dc8ef98ec07cb6d1072b93de8/crates%2Fra_vfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcde0b2ab8bc28dc8ef98ec07cb6d1072b93de8/crates%2Fra_vfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Flib.rs?ref=3dcde0b2ab8bc28dc8ef98ec07cb6d1072b93de8", "patch": "@@ -15,117 +15,29 @@\n //! VFS is based on a concept of roots: a set of directories on the file system\n //! which are watched for changes. Typically, there will be a root for each\n //! Cargo package.\n+mod roots;\n mod io;\n \n use std::{\n-    cmp::Reverse,\n     fmt, fs, mem,\n     path::{Path, PathBuf},\n     sync::Arc,\n };\n \n use crossbeam_channel::Receiver;\n use ra_arena::{impl_arena_id, Arena, RawId, map::ArenaMap};\n-use relative_path::{Component, RelativePath, RelativePathBuf};\n+use relative_path::{RelativePath, RelativePathBuf};\n use rustc_hash::{FxHashMap, FxHashSet};\n \n-pub use crate::io::TaskResult as VfsTask;\n-use io::{TaskResult, Worker};\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct VfsRoot(pub RawId);\n-impl_arena_id!(VfsRoot);\n-\n-/// Describes the contents of a single source root.\n-///\n-/// `RootConfig` can be thought of as a glob pattern like `src/**.rs` which\n-/// specifies the source root or as a function which takes a `PathBuf` and\n-/// returns `true` iff path belongs to the source root\n-pub(crate) struct RootConfig {\n-    root: PathBuf,\n-    // result of `root.canonicalize()` if that differs from `root`; `None` otherwise.\n-    canonical_root: Option<PathBuf>,\n-    excluded_dirs: Vec<PathBuf>,\n-}\n-\n-pub(crate) struct Roots {\n-    roots: Arena<VfsRoot, Arc<RootConfig>>,\n-}\n-\n-impl std::ops::Deref for Roots {\n-    type Target = Arena<VfsRoot, Arc<RootConfig>>;\n-    fn deref(&self) -> &Self::Target {\n-        &self.roots\n-    }\n-}\n-\n-impl RootConfig {\n-    fn new(root: PathBuf, excluded_dirs: Vec<PathBuf>) -> RootConfig {\n-        let mut canonical_root = root.canonicalize().ok();\n-        if Some(&root) == canonical_root.as_ref() {\n-            canonical_root = None;\n-        }\n-        RootConfig { root, canonical_root, excluded_dirs }\n-    }\n-    /// Checks if root contains a path and returns a root-relative path.\n-    pub(crate) fn contains(&self, path: &Path) -> Option<RelativePathBuf> {\n-        // First, check excluded dirs\n-        if self.excluded_dirs.iter().any(|it| path.starts_with(it)) {\n-            return None;\n-        }\n-        let rel_path = path\n-            .strip_prefix(&self.root)\n-            .or_else(|err_payload| {\n-                self.canonical_root\n-                    .as_ref()\n-                    .map_or(Err(err_payload), |canonical_root| path.strip_prefix(canonical_root))\n-            })\n-            .ok()?;\n-        let rel_path = RelativePathBuf::from_path(rel_path).ok()?;\n-\n-        // Ignore some common directories.\n-        //\n-        // FIXME: don't hard-code, specify at source-root creation time using\n-        // gitignore\n-        for (i, c) in rel_path.components().enumerate() {\n-            if let Component::Normal(c) = c {\n-                if (i == 0 && c == \"target\") || c == \".git\" || c == \"node_modules\" {\n-                    return None;\n-                }\n-            }\n-        }\n-\n-        if path.is_file() && rel_path.extension() != Some(\"rs\") {\n-            return None;\n-        }\n-\n-        Some(rel_path)\n-    }\n-}\n+use crate::{\n+    io::{TaskResult, Worker},\n+    roots::Roots,\n+};\n \n-impl Roots {\n-    pub(crate) fn new(mut paths: Vec<PathBuf>) -> Roots {\n-        let mut roots = Arena::default();\n-        // A hack to make nesting work.\n-        paths.sort_by_key(|it| Reverse(it.as_os_str().len()));\n-        paths.dedup();\n-        for (i, path) in paths.iter().enumerate() {\n-            let nested_roots = paths[..i]\n-                .iter()\n-                .filter(|it| it.starts_with(path))\n-                .map(|it| it.clone())\n-                .collect::<Vec<_>>();\n-\n-            let config = Arc::new(RootConfig::new(path.clone(), nested_roots));\n-\n-            roots.alloc(config.clone());\n-        }\n-        Roots { roots }\n-    }\n-    pub(crate) fn find(&self, path: &Path) -> Option<(VfsRoot, RelativePathBuf)> {\n-        self.roots.iter().find_map(|(root, data)| data.contains(path).map(|it| (root, it)))\n-    }\n-}\n+pub use crate::{\n+    io::TaskResult as VfsTask,\n+    roots::VfsRoot,\n+};\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct VfsFile(pub RawId);\n@@ -162,18 +74,18 @@ impl Vfs {\n         let worker = io::start(Arc::clone(&roots));\n         let mut root2files = ArenaMap::default();\n \n-        for (root, config) in roots.iter() {\n+        for root in roots.iter() {\n             root2files.insert(root, Default::default());\n-            worker.sender().send(io::Task::AddRoot { root, config: Arc::clone(config) }).unwrap();\n+            worker.sender().send(io::Task::AddRoot { root }).unwrap();\n         }\n         let res =\n             Vfs { roots, files: Arena::default(), root2files, worker, pending_changes: Vec::new() };\n-        let vfs_roots = res.roots.iter().map(|(id, _)| id).collect();\n+        let vfs_roots = res.roots.iter().collect();\n         (res, vfs_roots)\n     }\n \n     pub fn root2path(&self, root: VfsRoot) -> PathBuf {\n-        self.roots[root].root.clone()\n+        self.roots.path(root).to_path_buf()\n     }\n \n     pub fn path2file(&self, path: &Path) -> Option<VfsFile> {\n@@ -185,18 +97,11 @@ impl Vfs {\n \n     pub fn file2path(&self, file: VfsFile) -> PathBuf {\n         let rel_path = &self.files[file].path;\n-        let root_path = &self.roots[self.files[file].root].root;\n+        let root_path = &self.roots.path(self.files[file].root);\n         rel_path.to_path(root_path)\n     }\n \n-    pub fn file_for_path(&self, path: &Path) -> Option<VfsFile> {\n-        if let Some((_root, _path, Some(file))) = self.find_root(path) {\n-            return Some(file);\n-        }\n-        None\n-    }\n-\n-    pub fn num_roots(&self) -> usize {\n+    pub fn n_roots(&self) -> usize {\n         self.roots.len()\n     }\n \n@@ -207,7 +112,7 @@ impl Vfs {\n             } else {\n                 let text = fs::read_to_string(path).unwrap_or_default();\n                 let text = Arc::new(text);\n-                let file = self.add_file(root, rel_path.clone(), Arc::clone(&text), false);\n+                let file = self.raw_add_file(root, rel_path.clone(), Arc::clone(&text), false);\n                 let change = VfsChange::AddFile { file, text, root, path: rel_path };\n                 self.pending_changes.push(change);\n                 Some(file)\n@@ -216,6 +121,39 @@ impl Vfs {\n         None\n     }\n \n+    pub fn add_file_overlay(&mut self, path: &Path, text: String) -> Option<VfsFile> {\n+        let (root, rel_path, file) = self.find_root(path)?;\n+        if let Some(file) = file {\n+            self.change_file_event(file, text, true);\n+            Some(file)\n+        } else {\n+            self.add_file_event(root, rel_path, text, true)\n+        }\n+    }\n+\n+    pub fn change_file_overlay(&mut self, path: &Path, new_text: String) {\n+        if let Some((_root, _path, file)) = self.find_root(path) {\n+            let file = file.expect(\"can't change a file which wasn't added\");\n+            self.change_file_event(file, new_text, true);\n+        }\n+    }\n+\n+    pub fn remove_file_overlay(&mut self, path: &Path) -> Option<VfsFile> {\n+        let (root, rel_path, file) = self.find_root(path)?;\n+        let file = file.expect(\"can't remove a file which wasn't added\");\n+        let full_path = rel_path.to_path(&self.roots.path(root));\n+        if let Ok(text) = fs::read_to_string(&full_path) {\n+            self.change_file_event(file, text, false);\n+        } else {\n+            self.remove_file_event(root, rel_path, file);\n+        }\n+        Some(file)\n+    }\n+\n+    pub fn commit_changes(&mut self) -> Vec<VfsChange> {\n+        mem::replace(&mut self.pending_changes, Vec::new())\n+    }\n+\n     pub fn task_receiver(&self) -> &Receiver<io::TaskResult> {\n         self.worker.receiver()\n     }\n@@ -237,106 +175,64 @@ impl Vfs {\n                         continue;\n                     }\n                     let text = Arc::new(text);\n-                    let file = self.add_file(root, path.clone(), Arc::clone(&text), false);\n+                    let file = self.raw_add_file(root, path.clone(), Arc::clone(&text), false);\n                     cur_files.push((file, path, text));\n                 }\n \n                 let change = VfsChange::AddRoot { root, files: cur_files };\n                 self.pending_changes.push(change);\n             }\n             TaskResult::SingleFile { root, path, text } => {\n-                match (self.find_file(root, &path), text) {\n+                let existing_file = self.find_file(root, &path);\n+                if existing_file.map(|file| self.files[file].is_overlayed) == Some(true) {\n+                    return;\n+                }\n+                match (existing_file, text) {\n                     (Some(file), None) => {\n-                        self.do_remove_file(root, path, file, false);\n+                        self.remove_file_event(root, path, file);\n                     }\n                     (None, Some(text)) => {\n-                        self.do_add_file(root, path, text, false);\n+                        self.add_file_event(root, path, text, false);\n                     }\n                     (Some(file), Some(text)) => {\n-                        self.do_change_file(file, text, false);\n+                        self.change_file_event(file, text, false);\n                     }\n                     (None, None) => (),\n                 }\n             }\n         }\n     }\n \n-    fn do_add_file(\n+    // *_event calls change the state of VFS and push a change onto pending\n+    // changes array.\n+\n+    fn add_file_event(\n         &mut self,\n         root: VfsRoot,\n         path: RelativePathBuf,\n         text: String,\n         is_overlay: bool,\n     ) -> Option<VfsFile> {\n         let text = Arc::new(text);\n-        let file = self.add_file(root, path.clone(), text.clone(), is_overlay);\n+        let file = self.raw_add_file(root, path.clone(), text.clone(), is_overlay);\n         self.pending_changes.push(VfsChange::AddFile { file, root, path, text });\n         Some(file)\n     }\n \n-    fn do_change_file(&mut self, file: VfsFile, text: String, is_overlay: bool) {\n-        if !is_overlay && self.files[file].is_overlayed {\n-            return;\n-        }\n+    fn change_file_event(&mut self, file: VfsFile, text: String, is_overlay: bool) {\n         let text = Arc::new(text);\n-        self.change_file(file, text.clone(), is_overlay);\n+        self.raw_change_file(file, text.clone(), is_overlay);\n         self.pending_changes.push(VfsChange::ChangeFile { file, text });\n     }\n \n-    fn do_remove_file(\n-        &mut self,\n-        root: VfsRoot,\n-        path: RelativePathBuf,\n-        file: VfsFile,\n-        is_overlay: bool,\n-    ) {\n-        if !is_overlay && self.files[file].is_overlayed {\n-            return;\n-        }\n-        self.remove_file(file);\n+    fn remove_file_event(&mut self, root: VfsRoot, path: RelativePathBuf, file: VfsFile) {\n+        self.raw_remove_file(file);\n         self.pending_changes.push(VfsChange::RemoveFile { root, path, file });\n     }\n \n-    pub fn add_file_overlay(&mut self, path: &Path, text: String) -> Option<VfsFile> {\n-        if let Some((root, rel_path, file)) = self.find_root(path) {\n-            if let Some(file) = file {\n-                self.do_change_file(file, text, true);\n-                Some(file)\n-            } else {\n-                self.do_add_file(root, rel_path, text, true)\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub fn change_file_overlay(&mut self, path: &Path, new_text: String) {\n-        if let Some((_root, _path, file)) = self.find_root(path) {\n-            let file = file.expect(\"can't change a file which wasn't added\");\n-            self.do_change_file(file, new_text, true);\n-        }\n-    }\n-\n-    pub fn remove_file_overlay(&mut self, path: &Path) -> Option<VfsFile> {\n-        if let Some((root, path, file)) = self.find_root(path) {\n-            let file = file.expect(\"can't remove a file which wasn't added\");\n-            let full_path = path.to_path(&self.roots[root].root);\n-            if let Ok(text) = fs::read_to_string(&full_path) {\n-                self.do_change_file(file, text, true);\n-            } else {\n-                self.do_remove_file(root, path, file, true);\n-            }\n-            Some(file)\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub fn commit_changes(&mut self) -> Vec<VfsChange> {\n-        mem::replace(&mut self.pending_changes, Vec::new())\n-    }\n+    // raw_* calls change the state of VFS, but **do not** emit events.\n \n-    fn add_file(\n+    fn raw_add_file(\n         &mut self,\n         root: VfsRoot,\n         path: RelativePathBuf,\n@@ -349,13 +245,13 @@ impl Vfs {\n         file\n     }\n \n-    fn change_file(&mut self, file: VfsFile, new_text: Arc<String>, is_overlayed: bool) {\n+    fn raw_change_file(&mut self, file: VfsFile, new_text: Arc<String>, is_overlayed: bool) {\n         let mut file_data = &mut self.files[file];\n         file_data.text = new_text;\n         file_data.is_overlayed = is_overlayed;\n     }\n \n-    fn remove_file(&mut self, file: VfsFile) {\n+    fn raw_remove_file(&mut self, file: VfsFile) {\n         // FIXME: use arena with removal\n         self.files[file].text = Default::default();\n         self.files[file].path = Default::default();"}, {"sha": "5e2776a35871fb04cf61a327c6062f49a14fad3b", "filename": "crates/ra_vfs/src/roots.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/3dcde0b2ab8bc28dc8ef98ec07cb6d1072b93de8/crates%2Fra_vfs%2Fsrc%2Froots.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3dcde0b2ab8bc28dc8ef98ec07cb6d1072b93de8/crates%2Fra_vfs%2Fsrc%2Froots.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Froots.rs?ref=3dcde0b2ab8bc28dc8ef98ec07cb6d1072b93de8", "patch": "@@ -0,0 +1,109 @@\n+use std::{\n+    iter,\n+    sync::Arc,\n+    path::{Path, PathBuf},\n+};\n+\n+use relative_path::{ RelativePath, RelativePathBuf};\n+use ra_arena::{impl_arena_id, Arena, RawId};\n+\n+/// VfsRoot identifies a watched directory on the file system.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct VfsRoot(pub RawId);\n+impl_arena_id!(VfsRoot);\n+\n+/// Describes the contents of a single source root.\n+///\n+/// `RootConfig` can be thought of as a glob pattern like `src/**.rs` which\n+/// specifies the source root or as a function which takes a `PathBuf` and\n+/// returns `true` iff path belongs to the source root\n+struct RootData {\n+    path: PathBuf,\n+    // result of `root.canonicalize()` if that differs from `root`; `None` otherwise.\n+    canonical_path: Option<PathBuf>,\n+    excluded_dirs: Vec<RelativePathBuf>,\n+}\n+\n+pub(crate) struct Roots {\n+    roots: Arena<VfsRoot, Arc<RootData>>,\n+}\n+\n+impl Roots {\n+    pub(crate) fn new(mut paths: Vec<PathBuf>) -> Roots {\n+        let mut roots = Arena::default();\n+        // A hack to make nesting work.\n+        paths.sort_by_key(|it| std::cmp::Reverse(it.as_os_str().len()));\n+        paths.dedup();\n+        for (i, path) in paths.iter().enumerate() {\n+            let nested_roots =\n+                paths[..i].iter().filter_map(|it| rel_path(path, it)).collect::<Vec<_>>();\n+\n+            let config = Arc::new(RootData::new(path.clone(), nested_roots));\n+\n+            roots.alloc(config.clone());\n+        }\n+        Roots { roots }\n+    }\n+    pub(crate) fn find(&self, path: &Path) -> Option<(VfsRoot, RelativePathBuf)> {\n+        self.iter().find_map(|root| {\n+            let rel_path = self.contains(root, path)?;\n+            Some((root, rel_path))\n+        })\n+    }\n+    pub(crate) fn len(&self) -> usize {\n+        self.roots.len()\n+    }\n+    pub(crate) fn iter<'a>(&'a self) -> impl Iterator<Item = VfsRoot> + 'a {\n+        self.roots.iter().map(|(id, _)| id)\n+    }\n+    pub(crate) fn path(&self, root: VfsRoot) -> &Path {\n+        self.roots[root].path.as_path()\n+    }\n+    /// Checks if root contains a path and returns a root-relative path.\n+    pub(crate) fn contains(&self, root: VfsRoot, path: &Path) -> Option<RelativePathBuf> {\n+        let data = &self.roots[root];\n+        iter::once(&data.path)\n+            .chain(data.canonical_path.as_ref().into_iter())\n+            .find_map(|base| rel_path(base, path))\n+            .filter(|path| !data.excluded_dirs.contains(path))\n+            .filter(|path| !data.is_excluded(path))\n+    }\n+}\n+\n+impl RootData {\n+    fn new(path: PathBuf, excluded_dirs: Vec<RelativePathBuf>) -> RootData {\n+        let mut canonical_path = path.canonicalize().ok();\n+        if Some(&path) == canonical_path.as_ref() {\n+            canonical_path = None;\n+        }\n+        RootData { path, canonical_path, excluded_dirs }\n+    }\n+\n+    fn is_excluded(&self, path: &RelativePath) -> bool {\n+        if self.excluded_dirs.iter().any(|it| it == path) {\n+            return true;\n+        }\n+        // Ignore some common directories.\n+        //\n+        // FIXME: don't hard-code, specify at source-root creation time using\n+        // gitignore\n+        for (i, c) in path.components().enumerate() {\n+            if let relative_path::Component::Normal(c) = c {\n+                if (i == 0 && c == \"target\") || c == \".git\" || c == \"node_modules\" {\n+                    return true;\n+                }\n+            }\n+        }\n+\n+        match path.extension() {\n+            None | Some(\"rs\") => false,\n+            _ => true,\n+        }\n+    }\n+}\n+\n+fn rel_path(base: &Path, path: &Path) -> Option<RelativePathBuf> {\n+    let path = path.strip_prefix(base).ok()?;\n+    let path = RelativePathBuf::from_path(path).unwrap();\n+    Some(path)\n+}"}]}