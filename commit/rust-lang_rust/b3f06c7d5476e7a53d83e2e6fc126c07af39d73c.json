{"sha": "b3f06c7d5476e7a53d83e2e6fc126c07af39d73c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzZjA2YzdkNTQ3NmU3YTUzZDgzZTJlNmZjMTI2YzA3YWYzOWQ3M2M=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-27T11:55:21Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-27T12:20:36Z"}, "message": "Stop passing spans to middle::trans functions that don't need them\n\nRemoves a bunch of (eventually) unused arguments. Makes span passing to debuginfo\nexplicit, instead of relying on the (usually incorrect) spans held in the contexts.\n\nCloses #1439", "tree": {"sha": "c40584ff101adec1c3b94b05a2a4926ef1c9c860", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c40584ff101adec1c3b94b05a2a4926ef1c9c860"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3f06c7d5476e7a53d83e2e6fc126c07af39d73c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3f06c7d5476e7a53d83e2e6fc126c07af39d73c", "html_url": "https://github.com/rust-lang/rust/commit/b3f06c7d5476e7a53d83e2e6fc126c07af39d73c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3f06c7d5476e7a53d83e2e6fc126c07af39d73c/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad5e6091eb6e0b4f483690fd9566989d8e971dd1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad5e6091eb6e0b4f483690fd9566989d8e971dd1", "html_url": "https://github.com/rust-lang/rust/commit/ad5e6091eb6e0b4f483690fd9566989d8e971dd1"}], "stats": {"total": 388, "additions": 164, "deletions": 224}, "files": [{"sha": "5fdb1eedcbe2e811d77ee0a3be5164391459f6b7", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/b3f06c7d5476e7a53d83e2e6fc126c07af39d73c/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3f06c7d5476e7a53d83e2e6fc126c07af39d73c/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=b3f06c7d5476e7a53d83e2e6fc126c07af39d73c", "patch": "@@ -7,6 +7,7 @@ import middle::trans_common::*;\n import middle::trans_build::B;\n import middle::ty;\n import syntax::{ast, codemap};\n+import codemap::span;\n import ast::ty;\n import pat_util::*;\n import util::ppaux::ty_to_str;\n@@ -218,17 +219,17 @@ fn create_file(cx: @crate_ctxt, full_path: str) -> @metadata<file_md> {\n     ret mdval;\n }\n \n-fn line_from_span(cm: codemap::codemap, sp: codemap::span) -> uint {\n+fn line_from_span(cm: codemap::codemap, sp: span) -> uint {\n     codemap::lookup_char_pos(cm, sp.lo).line\n }\n \n-fn create_block(cx: @block_ctxt) -> @metadata<block_md> {\n+fn create_block(cx: @block_ctxt, sp: span) -> @metadata<block_md> {\n     let cache = get_cache(bcx_ccx(cx));\n     let start = codemap::lookup_char_pos(bcx_ccx(cx).sess.codemap,\n-                                         cx.sp.lo);\n+                                         sp.lo);\n     let fname = start.filename;\n     let end = codemap::lookup_char_pos(bcx_ccx(cx).sess.codemap,\n-                                       cx.sp.hi);\n+                                       sp.hi);\n     let tg = LexicalBlockTag;\n     alt cached_metadata::<@metadata<block_md>>(\n         cache, tg,\n@@ -238,8 +239,8 @@ fn create_block(cx: @block_ctxt) -> @metadata<block_md> {\n     }\n \n     let parent = alt cx.parent {\n-      trans_common::parent_none { create_function(cx.fcx).node }\n-      trans_common::parent_some(bcx) { create_block(cx).node }\n+      trans_common::parent_none { create_function(cx.fcx, sp).node }\n+      trans_common::parent_some(bcx) { create_block(cx, sp).node }\n     };\n     let file_node = create_file(bcx_ccx(cx), fname);\n     let unique_id = alt cache.find(LexicalBlockTag) {\n@@ -317,7 +318,7 @@ fn create_basic_type(cx: @crate_ctxt, t: ty::t, ty: @ast::ty)\n     ret mdval;\n }\n \n-fn create_pointer_type(cx: @crate_ctxt, t: ty::t, span: codemap::span,\n+fn create_pointer_type(cx: @crate_ctxt, t: ty::t, span: span,\n                        pointee: @metadata<tydesc_md>)\n     -> @metadata<tydesc_md> {\n     let tg = PointerTypeTag;\n@@ -391,7 +392,7 @@ fn add_member(cx: @struct_ctxt, name: str, line: int, size: int, align: int,\n }\n \n fn create_record(cx: @crate_ctxt, t: ty::t, fields: [ast::ty_field],\n-                 span: codemap::span) -> @metadata<tydesc_md> {\n+                 span: span) -> @metadata<tydesc_md> {\n     let fname = filename_from_span(cx, span);\n     let file_node = create_file(cx, fname);\n     let scx = create_structure(file_node,\n@@ -411,7 +412,7 @@ fn create_record(cx: @crate_ctxt, t: ty::t, fields: [ast::ty_field],\n }\n \n fn create_boxed_type(cx: @crate_ctxt, outer: ty::t, _inner: ty::t,\n-                     span: codemap::span, boxed: @metadata<tydesc_md>)\n+                     span: span, boxed: @metadata<tydesc_md>)\n     -> @metadata<tydesc_md> {\n     //let tg = StructureTypeTag;\n     /*let cache = cx.llmetadata;\n@@ -537,7 +538,7 @@ fn create_ty(cx: @crate_ctxt, t: ty::t, ty: @ast::ty)\n       option::none {}\n     }*/\n \n-    fn t_to_ty(cx: @crate_ctxt, t: ty::t, span: codemap::span) -> @ast::ty {\n+    fn t_to_ty(cx: @crate_ctxt, t: ty::t, span: span) -> @ast::ty {\n         let ty = alt ty::struct(ccx_tcx(cx), t) {\n           ty::ty_nil { ast::ty_nil }\n           ty::ty_bot { ast::ty_bot }\n@@ -602,7 +603,7 @@ fn create_ty(cx: @crate_ctxt, t: ty::t, ty: @ast::ty)\n     };\n }\n \n-fn filename_from_span(cx: @crate_ctxt, sp: codemap::span) -> str {\n+fn filename_from_span(cx: @crate_ctxt, sp: span) -> str {\n     codemap::lookup_char_pos(cx.sess.codemap, sp.lo).filename\n }\n \n@@ -633,15 +634,15 @@ fn create_local_var(bcx: @block_ctxt, local: @ast::local)\n     let name = path_to_ident(alt pat_util::normalize_pat(bcx_tcx(bcx),\n                                            local.node.pat).node {\n       ast::pat_ident(ident, _) { ident /*XXX deal w/ optional node binding*/ }\n-     });\n+    });\n     let loc = codemap::lookup_char_pos(cx.sess.codemap,\n                                        local.span.lo);\n     let ty = trans::node_id_type(cx, local.node.id);\n     let tymd = create_ty(cx, ty, local.node.ty);\n     let filemd = create_file(cx, loc.filename);\n     let context = alt bcx.parent {\n-      trans_common::parent_none { create_function(bcx.fcx).node }\n-      trans_common::parent_some(_) { create_block(bcx).node }\n+      trans_common::parent_none { create_function(bcx.fcx, local.span).node }\n+      trans_common::parent_some(_) { create_block(bcx, local.span).node }\n     };\n     let mdnode = create_var(tg, context, name, filemd.node,\n                             loc.line as int, tymd.node);\n@@ -662,7 +663,7 @@ fn create_local_var(bcx: @block_ctxt, local: @ast::local)\n     ret mdval;\n }\n \n-fn create_arg(bcx: @block_ctxt, arg: ast::arg)\n+fn create_arg(bcx: @block_ctxt, arg: ast::arg, sp: span)\n     -> @metadata<argument_md> unsafe {\n     let fcx = bcx_fcx(bcx);\n     let cx = fcx_ccx(fcx);\n@@ -678,11 +679,11 @@ fn create_arg(bcx: @block_ctxt, arg: ast::arg)\n       ast_map::node_arg(_, n) { n - 2u }\n     };*/\n     let loc = codemap::lookup_char_pos(cx.sess.codemap,\n-                                       fcx.sp.lo);\n+                                       sp.lo);\n     let ty = trans::node_id_type(cx, arg.id);\n     let tymd = create_ty(cx, ty, arg.ty);\n     let filemd = create_file(cx, loc.filename);\n-    let context = create_function(bcx.fcx);\n+    let context = create_function(bcx.fcx, sp);\n     let mdnode = create_var(tg, context.node, arg.ident, filemd.node,\n                             loc.line as int, tymd.node);\n     let mdval = @{node: mdnode, data: {id: arg.id}};\n@@ -697,12 +698,12 @@ fn create_arg(bcx: @block_ctxt, arg: ast::arg)\n     ret mdval;\n }\n \n-fn update_source_pos(cx: @block_ctxt, s: codemap::span) {\n+fn update_source_pos(cx: @block_ctxt, s: span) {\n     if !bcx_ccx(cx).sess.opts.debuginfo {\n         ret;\n     }\n     let cm = bcx_ccx(cx).sess.codemap;\n-    let blockmd = create_block(cx);\n+    let blockmd = create_block(cx, s);\n     let loc = codemap::lookup_char_pos(cm, s.lo);\n     let scopedata = [lli32(loc.line as int),\n                      lli32(loc.col as int),\n@@ -712,14 +713,14 @@ fn update_source_pos(cx: @block_ctxt, s: codemap::span) {\n     llvm::LLVMSetCurrentDebugLocation(trans_build::B(cx), dbgscope);\n }\n \n-fn create_function(fcx: @fn_ctxt) -> @metadata<subprogram_md> {\n+fn create_function(fcx: @fn_ctxt, sp: span) -> @metadata<subprogram_md> {\n     let cx = fcx_ccx(fcx);\n     let dbg_cx = option::get(cx.dbg_cx);\n \n     #debug(\"~~\");\n     log(debug, fcx.id);\n \n-    log(debug, codemap::span_to_str(fcx.sp, cx.sess.codemap));\n+    log(debug, codemap::span_to_str(sp, cx.sess.codemap));\n \n     let (ident, ret_ty, id) = alt cx.ast_map.get(fcx.id) {\n       ast_map::node_item(item) {\n@@ -763,7 +764,7 @@ fn create_function(fcx: @fn_ctxt) -> @metadata<subprogram_md> {\n     }\n \n     let loc = codemap::lookup_char_pos(cx.sess.codemap,\n-                                       fcx.sp.lo);\n+                                       sp.lo);\n     let file_node = create_file(cx, loc.filename).node;\n     let key = cx.item_symbols.contains_key(fcx.id) ? fcx.id : id;\n     let mangled = cx.item_symbols.get(key);"}, {"sha": "cf8808bd35a5a27133cc2510beab475820291db9", "filename": "src/comp/middle/shape.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b3f06c7d5476e7a53d83e2e6fc126c07af39d73c/src%2Fcomp%2Fmiddle%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3f06c7d5476e7a53d83e2e6fc126c07af39d73c/src%2Fcomp%2Fmiddle%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fshape.rs?ref=b3f06c7d5476e7a53d83e2e6fc126c07af39d73c", "patch": "@@ -135,7 +135,7 @@ fn largest_variants(ccx: @crate_ctxt, tag_id: ast::def_id) -> [uint] {\n                 // (Could add a postcondition to type_contains_params,\n                 // once we implement Issue #586.)\n                 check (trans_common::type_has_static_size(ccx, elem_t));\n-                let llty = trans::type_of(ccx, dummy_sp(), elem_t);\n+                let llty = trans::type_of(ccx, elem_t);\n                 min_size += llsize_of_real(ccx, llty);\n                 min_align += llalign_of_real(ccx, llty);\n             }\n@@ -214,7 +214,7 @@ fn compute_static_enum_size(ccx: @crate_ctxt, largest_variants: [uint],\n             // on enum_variants that would obviate the need for\n             // this check. (Issue #586)\n             check (trans_common::type_has_static_size(ccx, typ));\n-            lltys += [trans::type_of(ccx, dummy_sp(), typ)];\n+            lltys += [trans::type_of(ccx, typ)];\n         }\n \n         let llty = trans_common::T_struct(lltys);\n@@ -584,7 +584,7 @@ fn gen_resource_shapes(ccx: @crate_ctxt) -> ValueRef {\n     let len = interner::len(ccx.shape_cx.resources);\n     while i < len {\n         let ri = interner::get(ccx.shape_cx.resources, i);\n-        dtors += [trans_common::get_res_dtor(ccx, dummy_sp(), ri.did, ri.t)];\n+        dtors += [trans_common::get_res_dtor(ccx, ri.did, ri.t)];\n         i += 1u;\n     }\n \n@@ -627,7 +627,7 @@ type tag_metrics = {\n fn size_of(bcx: @block_ctxt, t: ty::t) -> result {\n     let ccx = bcx_ccx(bcx);\n     if check type_has_static_size(ccx, t) {\n-        rslt(bcx, llsize_of(ccx, trans::type_of(ccx, bcx.sp, t)))\n+        rslt(bcx, llsize_of(ccx, trans::type_of(ccx, t)))\n     } else {\n         let { bcx, sz, align: _ } = dynamic_metrics(bcx, t);\n         rslt(bcx, sz)\n@@ -637,7 +637,7 @@ fn size_of(bcx: @block_ctxt, t: ty::t) -> result {\n fn align_of(bcx: @block_ctxt, t: ty::t) -> result {\n     let ccx = bcx_ccx(bcx);\n     if check type_has_static_size(ccx, t) {\n-        rslt(bcx, llalign_of(ccx, trans::type_of(ccx, bcx.sp, t)))\n+        rslt(bcx, llalign_of(ccx, trans::type_of(ccx, t)))\n     } else {\n         let { bcx, sz: _, align } = dynamic_metrics(bcx, t);\n         rslt(bcx, align)\n@@ -647,7 +647,7 @@ fn align_of(bcx: @block_ctxt, t: ty::t) -> result {\n fn metrics(bcx: @block_ctxt, t: ty::t) -> metrics {\n     let ccx = bcx_ccx(bcx);\n     if check type_has_static_size(ccx, t) {\n-        let llty = trans::type_of(ccx, bcx.sp, t);\n+        let llty = trans::type_of(ccx, t);\n         { bcx: bcx, sz: llsize_of(ccx, llty), align: llalign_of(ccx, llty) }\n     } else {\n         dynamic_metrics(bcx, t)\n@@ -675,7 +675,7 @@ fn llalign_of(cx: @crate_ctxt, t: TypeRef) -> ValueRef {\n }\n \n // Computes the size of the data part of a non-dynamically-sized enum.\n-fn static_size_of_enum(cx: @crate_ctxt, sp: span, t: ty::t)\n+fn static_size_of_enum(cx: @crate_ctxt, t: ty::t)\n     : type_has_static_size(cx, t) -> uint {\n     if cx.enum_sizes.contains_key(t) { ret cx.enum_sizes.get(t); }\n     alt ty::struct(cx.tcx, t) {\n@@ -696,16 +696,12 @@ fn static_size_of_enum(cx: @crate_ctxt, sp: span, t: ty::t)\n             // express that with constrained types.\n             check (type_has_static_size(cx, tup_ty));\n             let this_size =\n-                llsize_of_real(cx, trans::type_of(cx, sp, tup_ty));\n+                llsize_of_real(cx, trans::type_of(cx, tup_ty));\n             if max_size < this_size { max_size = this_size; }\n         }\n         cx.enum_sizes.insert(t, max_size);\n         ret max_size;\n       }\n-      _ {\n-        cx.tcx.sess.span_fatal(\n-            sp, \"non-enum passed to static_size_of_enum()\");\n-      }\n     }\n }\n "}, {"sha": "7d9f240d9b8daaa111715700c3d30646d5ebeebe", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 111, "deletions": 160, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/b3f06c7d5476e7a53d83e2e6fc126c07af39d73c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3f06c7d5476e7a53d83e2e6fc126c07af39d73c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=b3f06c7d5476e7a53d83e2e6fc126c07af39d73c", "patch": "@@ -49,26 +49,26 @@ import tvec = trans_vec;\n fn type_of_1(bcx: @block_ctxt, t: ty::t) -> TypeRef {\n     let cx = bcx_ccx(bcx);\n     check type_has_static_size(cx, t);\n-    type_of(cx, bcx.sp, t)\n+    type_of(cx, t)\n }\n \n-fn type_of(cx: @crate_ctxt, sp: span, t: ty::t) : type_has_static_size(cx, t)\n+fn type_of(cx: @crate_ctxt, t: ty::t) : type_has_static_size(cx, t)\n    -> TypeRef {\n     // Should follow from type_has_static_size -- argh.\n     // FIXME (requires Issue #586)\n     check non_ty_var(cx, t);\n-    type_of_inner(cx, sp, t)\n+    type_of_inner(cx, t)\n }\n \n-fn type_of_explicit_args(cx: @crate_ctxt, sp: span, inputs: [ty::arg]) ->\n+fn type_of_explicit_args(cx: @crate_ctxt, inputs: [ty::arg]) ->\n    [TypeRef] {\n     let atys = [];\n     for arg in inputs {\n         let arg_ty = arg.ty;\n         // FIXME: would be nice to have a constraint on arg\n         // that would obviate the need for this check\n         check non_ty_var(cx, arg_ty);\n-        let llty = type_of_inner(cx, sp, arg_ty);\n+        let llty = type_of_inner(cx, arg_ty);\n         atys += [arg.mode == ast::by_val ? llty : T_ptr(llty)];\n     }\n     ret atys;\n@@ -81,13 +81,13 @@ fn type_of_explicit_args(cx: @crate_ctxt, sp: span, inputs: [ty::arg]) ->\n //  - create_llargs_for_fn_args.\n //  - new_fn_ctxt\n //  - trans_args\n-fn type_of_fn(cx: @crate_ctxt, sp: span, inputs: [ty::arg],\n+fn type_of_fn(cx: @crate_ctxt, inputs: [ty::arg],\n               output: ty::t, params: [ty::param_bounds]) -> TypeRef {\n     let atys: [TypeRef] = [];\n \n     // Arg 0: Output pointer.\n     check non_ty_var(cx, output);\n-    let out_ty = T_ptr(type_of_inner(cx, sp, output));\n+    let out_ty = T_ptr(type_of_inner(cx, output));\n     atys += [out_ty];\n \n     // Arg 1: Environment\n@@ -104,22 +104,22 @@ fn type_of_fn(cx: @crate_ctxt, sp: span, inputs: [ty::arg],\n         }\n     }\n     // ... then explicit args.\n-    atys += type_of_explicit_args(cx, sp, inputs);\n+    atys += type_of_explicit_args(cx, inputs);\n     ret T_fn(atys, llvm::LLVMVoidType());\n }\n \n // Given a function type and a count of ty params, construct an llvm type\n-fn type_of_fn_from_ty(cx: @crate_ctxt, sp: span, fty: ty::t,\n+fn type_of_fn_from_ty(cx: @crate_ctxt, fty: ty::t,\n                       param_bounds: [ty::param_bounds]) -> TypeRef {\n     // FIXME: Check should be unnecessary, b/c it's implied\n     // by returns_non_ty_var(t). Make that a postcondition\n     // (see Issue #586)\n     let ret_ty = ty::ty_fn_ret(cx.tcx, fty);\n-    ret type_of_fn(cx, sp, ty::ty_fn_args(cx.tcx, fty),\n+    ret type_of_fn(cx, ty::ty_fn_args(cx.tcx, fty),\n                    ret_ty, param_bounds);\n }\n \n-fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n+fn type_of_inner(cx: @crate_ctxt, t: ty::t)\n     : non_ty_var(cx, t) -> TypeRef {\n     // Check the cache.\n \n@@ -135,46 +135,46 @@ fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n       ty::ty_uint(t) { T_uint_ty(cx, t) }\n       ty::ty_float(t) { T_float_ty(cx, t) }\n       ty::ty_str { T_ptr(T_vec(cx, T_i8())) }\n-      ty::ty_enum(did, _) { type_of_enum(cx, sp, did, t) }\n+      ty::ty_enum(did, _) { type_of_enum(cx, did, t) }\n       ty::ty_box(mt) {\n         let mt_ty = mt.ty;\n         check non_ty_var(cx, mt_ty);\n-        T_ptr(T_box(cx, type_of_inner(cx, sp, mt_ty))) }\n+        T_ptr(T_box(cx, type_of_inner(cx, mt_ty))) }\n       ty::ty_uniq(mt) {\n         let mt_ty = mt.ty;\n         check non_ty_var(cx, mt_ty);\n-        T_ptr(type_of_inner(cx, sp, mt_ty)) }\n+        T_ptr(type_of_inner(cx, mt_ty)) }\n       ty::ty_vec(mt) {\n         let mt_ty = mt.ty;\n         if ty::type_has_dynamic_size(cx.tcx, mt_ty) {\n             T_ptr(cx.opaque_vec_type)\n         } else {\n             // should be unnecessary\n             check non_ty_var(cx, mt_ty);\n-            T_ptr(T_vec(cx, type_of_inner(cx, sp, mt_ty))) }\n+            T_ptr(T_vec(cx, type_of_inner(cx, mt_ty))) }\n       }\n       ty::ty_ptr(mt) {\n         let mt_ty = mt.ty;\n         check non_ty_var(cx, mt_ty);\n-        T_ptr(type_of_inner(cx, sp, mt_ty)) }\n+        T_ptr(type_of_inner(cx, mt_ty)) }\n       ty::ty_rec(fields) {\n         let tys: [TypeRef] = [];\n         for f: ty::field in fields {\n             let mt_ty = f.mt.ty;\n             check non_ty_var(cx, mt_ty);\n-            tys += [type_of_inner(cx, sp, mt_ty)];\n+            tys += [type_of_inner(cx, mt_ty)];\n         }\n         T_struct(tys)\n       }\n       ty::ty_fn(_) {\n-        T_fn_pair(cx, type_of_fn_from_ty(cx, sp, t, []))\n+        T_fn_pair(cx, type_of_fn_from_ty(cx, t, []))\n       }\n       ty::ty_iface(_, _) { T_opaque_iface_ptr(cx) }\n       ty::ty_res(_, sub, tps) {\n         let sub1 = ty::substitute_type_params(cx.tcx, tps, sub);\n         check non_ty_var(cx, sub1);\n         // FIXME #1184: Resource flag is larger than necessary\n-        ret T_struct([cx.int_type, type_of_inner(cx, sp, sub1)]);\n+        ret T_struct([cx.int_type, type_of_inner(cx, sub1)]);\n       }\n       ty::ty_var(_) {\n         // Should be unreachable b/c of precondition.\n@@ -189,7 +189,7 @@ fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n         let tys = [];\n         for elt in elts {\n             check non_ty_var(cx, elt);\n-            tys += [type_of_inner(cx, sp, elt)];\n+            tys += [type_of_inner(cx, elt)];\n         }\n         T_struct(tys)\n       }\n@@ -199,7 +199,7 @@ fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n       ty::ty_constr(subt,_) {\n         // FIXME: could be a constraint on ty_fn\n           check non_ty_var(cx, subt);\n-          type_of_inner(cx, sp, subt)\n+          type_of_inner(cx, subt)\n       }\n       _ {\n         fail \"type_of_inner not implemented for this kind of type\";\n@@ -209,11 +209,11 @@ fn type_of_inner(cx: @crate_ctxt, sp: span, t: ty::t)\n     ret llty;\n }\n \n-fn type_of_enum(cx: @crate_ctxt, sp: span, did: ast::def_id, t: ty::t)\n+fn type_of_enum(cx: @crate_ctxt, did: ast::def_id, t: ty::t)\n     -> TypeRef {\n     let degen = vec::len(*ty::enum_variants(cx.tcx, did)) == 1u;\n     if check type_has_static_size(cx, t) {\n-        let size = static_size_of_enum(cx, sp, t);\n+        let size = static_size_of_enum(cx, t);\n         if !degen { T_enum(cx, size) }\n         else if size == 0u { T_struct([T_enum_variant(cx)]) }\n         else { T_array(T_i8(), size) }\n@@ -224,13 +224,13 @@ fn type_of_enum(cx: @crate_ctxt, sp: span, did: ast::def_id, t: ty::t)\n     }\n }\n \n-fn type_of_ty_param_bounds_and_ty(lcx: @local_ctxt, sp: span,\n+fn type_of_ty_param_bounds_and_ty(lcx: @local_ctxt,\n                                  tpt: ty::ty_param_bounds_and_ty) -> TypeRef {\n     let cx = lcx.ccx;\n     let t = tpt.ty;\n     alt ty::struct(cx.tcx, t) {\n       ty::ty_fn(_) {\n-        ret type_of_fn_from_ty(cx, sp, t, *tpt.bounds);\n+        ret type_of_fn_from_ty(cx, t, *tpt.bounds);\n       }\n       _ {\n         // fall through\n@@ -240,14 +240,13 @@ fn type_of_ty_param_bounds_and_ty(lcx: @local_ctxt, sp: span,\n     // doesn't work right now because one predicate can't imply\n     // another\n     check (type_has_static_size(cx, t));\n-    type_of(cx, sp, t)\n+    type_of(cx, t)\n }\n \n fn type_of_or_i8(bcx: @block_ctxt, typ: ty::t) -> TypeRef {\n     let ccx = bcx_ccx(bcx);\n     if check type_has_static_size(ccx, typ) {\n-        let sp = bcx.sp;\n-        type_of(ccx, sp, typ)\n+        type_of(ccx, typ)\n     } else { T_i8() }\n }\n \n@@ -414,16 +413,14 @@ fn size_of(cx: @block_ctxt, t: ty::t) -> result {\n fn size_of_(cx: @block_ctxt, t: ty::t) -> result {\n     let ccx = bcx_ccx(cx);\n     if check type_has_static_size(ccx, t) {\n-        let sp = cx.sp;\n-        rslt(cx, llsize_of(bcx_ccx(cx), type_of(ccx, sp, t)))\n+        rslt(cx, llsize_of(bcx_ccx(cx), type_of(ccx, t)))\n     } else { dynamic_size_of(cx, t) }\n }\n \n fn align_of(cx: @block_ctxt, t: ty::t) -> result {\n     let ccx = bcx_ccx(cx);\n     if check type_has_static_size(ccx, t) {\n-        let sp = cx.sp;\n-        rslt(cx, llalign_of(bcx_ccx(cx), type_of(ccx, sp, t)))\n+        rslt(cx, llalign_of(bcx_ccx(cx), type_of(ccx, t)))\n     } else { dynamic_align_of(cx, t) }\n }\n \n@@ -495,7 +492,7 @@ fn simplify_type(ccx: @crate_ctxt, typ: ty::t) -> ty::t {\n \n \n // Computes the size of the data part of a non-dynamically-sized enum.\n-fn static_size_of_enum(cx: @crate_ctxt, sp: span, t: ty::t)\n+fn static_size_of_enum(cx: @crate_ctxt, t: ty::t)\n     : type_has_static_size(cx, t) -> uint {\n     if cx.enum_sizes.contains_key(t) { ret cx.enum_sizes.get(t); }\n     alt ty::struct(cx.tcx, t) {\n@@ -515,7 +512,7 @@ fn static_size_of_enum(cx: @crate_ctxt, sp: span, t: ty::t)\n             // size, any field must as well. There should be a way to\n             // express that with constrained types.\n             check (type_has_static_size(cx, tup_ty));\n-            let this_size = llsize_of_real(cx, type_of(cx, sp, tup_ty));\n+            let this_size = llsize_of_real(cx, type_of(cx, tup_ty));\n             if max_size < this_size { max_size = this_size; }\n         }\n         cx.enum_sizes.insert(t, max_size);\n@@ -656,8 +653,7 @@ fn bump_ptr(bcx: @block_ctxt, t: ty::t, base: ValueRef, sz: ValueRef) ->\n     let ccx = bcx_ccx(bcx);\n     let bumped = ptr_offs(bcx, base, sz);\n     if check type_has_static_size(ccx, t) {\n-        let sp = bcx.sp;\n-        let typ = T_ptr(type_of(ccx, sp, t));\n+        let typ = T_ptr(type_of(ccx, t));\n         PointerCast(bcx, bumped, typ)\n     } else { bumped }\n }\n@@ -762,10 +758,9 @@ fn GEP_enum(cx: @block_ctxt, llblobptr: ValueRef, enum_id: ast::def_id,\n     // the blob pointer isn't dynamically sized).\n \n     let llunionptr: ValueRef;\n-    let sp = cx.sp;\n     let ccx = bcx_ccx(cx);\n     if check type_has_static_size(ccx, tup_ty) {\n-        let llty = type_of(ccx, sp, tup_ty);\n+        let llty = type_of(ccx, tup_ty);\n         llunionptr = TruncOrBitCast(cx, llblobptr, T_ptr(llty));\n     } else { llunionptr = llblobptr; }\n \n@@ -778,7 +773,7 @@ fn GEP_enum(cx: @block_ctxt, llblobptr: ValueRef, enum_id: ast::def_id,\n     let rs_ccx = bcx_ccx(rs.bcx);\n     let val =\n         if check type_has_static_size(rs_ccx, elem_ty) {\n-            let llelemty = type_of(rs_ccx, sp, elem_ty);\n+            let llelemty = type_of(rs_ccx, elem_ty);\n             PointerCast(rs.bcx, rs.val, T_ptr(llelemty))\n         } else { rs.val };\n \n@@ -824,9 +819,8 @@ fn trans_malloc_boxed_raw(cx: @block_ctxt, t: ty::t) -> result {\n     // FIXME: Could avoid this check with a postcondition on mk_imm_box?\n     // (requires Issue #586)\n     let ccx = bcx_ccx(bcx);\n-    let sp = bcx.sp;\n     check (type_has_static_size(ccx, box_ptr));\n-    let llty = type_of(ccx, sp, box_ptr);\n+    let llty = type_of(ccx, box_ptr);\n \n     let ti = none;\n     let tydesc_result = get_tydesc(bcx, t, true, ti);\n@@ -1000,12 +994,9 @@ fn get_tydesc(cx: @block_ctxt, t: ty::t, escapes: bool,\n             ret {kind: tk_param,\n                  result: rslt(cx, cx.fcx.lltyparams[id].desc)};\n         } else {\n-            bcx_tcx(cx).sess.span_bug(cx.sp,\n-                                      \"Unbound typaram in get_tydesc: \" +\n-                                          \"t = \" +\n-                                          ty_to_str(bcx_tcx(cx), t) +\n-                                          \" ty_param = \" +\n-                                          uint::str(id));\n+            bcx_tcx(cx).sess.bug(\"Unbound typaram in get_tydesc: t = \" +\n+                                 ty_to_str(bcx_tcx(cx), t) + \" ty_param = \" +\n+                                 uint::str(id));\n         }\n       }\n       none {/* fall through */ }\n@@ -1028,7 +1019,7 @@ fn get_static_tydesc(cx: @block_ctxt, t: ty::t, ty_params: [uint])\n       some(info) { ret info; }\n       none {\n         bcx_ccx(cx).stats.n_static_tydescs += 1u;\n-        let info = declare_tydesc(cx.fcx.lcx, cx.sp, t, ty_params);\n+        let info = declare_tydesc(cx.fcx.lcx, t, ty_params);\n         bcx_ccx(cx).tydescs.insert(t, info);\n         ret info;\n       }\n@@ -1072,14 +1063,14 @@ fn set_glue_inlining(cx: @local_ctxt, f: ValueRef, t: ty::t) {\n \n \n // Generates the declaration for (but doesn't emit) a type descriptor.\n-fn declare_tydesc(cx: @local_ctxt, sp: span, t: ty::t, ty_params: [uint])\n+fn declare_tydesc(cx: @local_ctxt, t: ty::t, ty_params: [uint])\n     -> @tydesc_info {\n     log(debug, \"+++ declare_tydesc \" + ty_to_str(cx.ccx.tcx, t));\n     let ccx = cx.ccx;\n     let llsize;\n     let llalign;\n     if check type_has_static_size(ccx, t) {\n-        let llty = type_of(ccx, sp, t);\n+        let llty = type_of(ccx, t);\n         llsize = llsize_of(ccx, llty);\n         llalign = llalign_of(ccx, llty);\n     } else {\n@@ -1129,10 +1120,10 @@ fn declare_generic_glue(cx: @local_ctxt, t: ty::t, llfnty: TypeRef, name: str)\n }\n \n // FIXME: was this causing the leak?\n-fn make_generic_glue_inner(cx: @local_ctxt, sp: span, t: ty::t,\n+fn make_generic_glue_inner(cx: @local_ctxt, t: ty::t,\n                            llfn: ValueRef, helper: glue_helper,\n                            ty_params: [uint]) -> ValueRef {\n-    let fcx = new_fn_ctxt(cx, sp, llfn);\n+    let fcx = new_fn_ctxt(cx, llfn);\n     llvm::LLVMSetLinkage(llfn,\n                          lib::llvm::LLVMInternalLinkage as llvm::Linkage);\n     cx.ccx.stats.n_glues_created += 1u;\n@@ -1144,7 +1135,7 @@ fn make_generic_glue_inner(cx: @local_ctxt, sp: span, t: ty::t,\n     let ccx = cx.ccx;\n     let llty =\n         if check type_has_static_size(ccx, t) {\n-            T_ptr(type_of(ccx, sp, t))\n+            T_ptr(type_of(ccx, t))\n         } else { T_ptr(T_i8()) };\n \n     let ty_param_count = vec::len::<uint>(ty_params);\n@@ -1170,15 +1161,15 @@ fn make_generic_glue_inner(cx: @local_ctxt, sp: span, t: ty::t,\n     ret llfn;\n }\n \n-fn make_generic_glue(cx: @local_ctxt, sp: span, t: ty::t, llfn: ValueRef,\n+fn make_generic_glue(cx: @local_ctxt, t: ty::t, llfn: ValueRef,\n                      helper: glue_helper, ty_params: [uint], name: str) ->\n    ValueRef {\n     if !cx.ccx.sess.opts.stats {\n-        ret make_generic_glue_inner(cx, sp, t, llfn, helper, ty_params);\n+        ret make_generic_glue_inner(cx, t, llfn, helper, ty_params);\n     }\n \n     let start = time::get_time();\n-    let llval = make_generic_glue_inner(cx, sp, t, llfn, helper, ty_params);\n+    let llval = make_generic_glue_inner(cx, t, llfn, helper, ty_params);\n     let end = time::get_time();\n     log_fn_time(cx.ccx, \"glue \" + name + \" \" + ty_to_short_str(cx.ccx.tcx, t),\n                 start, end);\n@@ -1407,7 +1398,7 @@ fn trans_res_drop(cx: @block_ctxt, rs: ValueRef, did: ast::def_id,\n     let val = GEP_tup_like(cx, tup_ty, rs, [0, 1]);\n     cx = val.bcx;\n     // Find and call the actual destructor.\n-    let dtor_addr = trans_common::get_res_dtor(ccx, cx.sp, did, inner_t);\n+    let dtor_addr = trans_common::get_res_dtor(ccx, did, inner_t);\n     let args = [cx.fcx.llretptr, null_env_ptr(cx)];\n     for tp: ty::t in tps {\n         let ti: option::t<@tydesc_info> = none;\n@@ -1482,7 +1473,7 @@ fn compare_scalar_types(cx: @block_ctxt, lhs: ValueRef, rhs: ValueRef,\n                  C_nil());\n       }\n       ty::ty_native(_) {\n-        let cx = trans_fail(cx, none::<span>,\n+        let cx = trans_fail(cx, none,\n                             \"attempt to compare values of type native\");\n         ret rslt(cx, C_nil());\n       }\n@@ -1703,7 +1694,7 @@ fn lazily_emit_tydesc_glue(cx: @block_ctxt, field: int,\n                     declare_generic_glue(lcx, ti.ty, T_glue_fn(lcx.ccx),\n                                          \"take\");\n                 ti.take_glue = some::<ValueRef>(glue_fn);\n-                make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n+                make_generic_glue(lcx, ti.ty, glue_fn,\n                                   make_take_glue,\n                                   ti.ty_params, \"take\");\n                 #debug(\"--- lazily_emit_tydesc_glue TAKE %s\",\n@@ -1721,7 +1712,7 @@ fn lazily_emit_tydesc_glue(cx: @block_ctxt, field: int,\n                     declare_generic_glue(lcx, ti.ty, T_glue_fn(lcx.ccx),\n                                          \"drop\");\n                 ti.drop_glue = some::<ValueRef>(glue_fn);\n-                make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n+                make_generic_glue(lcx, ti.ty, glue_fn,\n                                   make_drop_glue,\n                                   ti.ty_params, \"drop\");\n                 #debug(\"--- lazily_emit_tydesc_glue DROP %s\",\n@@ -1739,7 +1730,7 @@ fn lazily_emit_tydesc_glue(cx: @block_ctxt, field: int,\n                     declare_generic_glue(lcx, ti.ty, T_glue_fn(lcx.ccx),\n                                          \"free\");\n                 ti.free_glue = some::<ValueRef>(glue_fn);\n-                make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n+                make_generic_glue(lcx, ti.ty, glue_fn,\n                                   make_free_glue,\n                                   ti.ty_params, \"free\");\n                 #debug(\"--- lazily_emit_tydesc_glue FREE %s\",\n@@ -1919,8 +1910,7 @@ fn memmove_ty(bcx: @block_ctxt, dst: ValueRef, src: ValueRef, t: ty::t) ->\n     let ccx = bcx_ccx(bcx);\n     if check type_has_static_size(ccx, t) {\n         if ty::type_is_structural(bcx_tcx(bcx), t) {\n-            let sp = bcx.sp;\n-            let llsz = llsize_of(ccx, type_of(ccx, sp, t));\n+            let llsz = llsize_of(ccx, type_of(ccx, t));\n             ret call_memmove(bcx, dst, src, llsz).bcx;\n         }\n         Store(bcx, Load(bcx, src), dst);\n@@ -2062,15 +2052,6 @@ fn node_id_type(cx: @crate_ctxt, id: ast::node_id) -> ty::t {\n     ret ty::node_id_to_monotype(cx.tcx, id);\n }\n \n-fn node_type(cx: @crate_ctxt, sp: span, id: ast::node_id) -> TypeRef {\n-    let ty = node_id_type(cx, id);\n-    // How to make this a precondition?\n-    // FIXME (again, would require a predicate that implies\n-    // another predicate)\n-    check (type_has_static_size(cx, ty));\n-    type_of(cx, sp, ty)\n-}\n-\n fn trans_unary(bcx: @block_ctxt, op: ast::unop, e: @ast::expr,\n                un_expr: @ast::expr, dest: dest) -> @block_ctxt {\n     // Check for user-defined method call\n@@ -2107,8 +2088,7 @@ fn trans_unary(bcx: @block_ctxt, op: ast::unop, e: @ast::expr,\n         // on whether they're boxed or not\n         let ccx = bcx_ccx(bcx);\n         if check type_has_static_size(ccx, e_ty) {\n-            let e_sp = e.span;\n-            let llety = T_ptr(type_of(ccx, e_sp, e_ty));\n+            let llety = T_ptr(type_of(ccx, e_ty));\n             body = PointerCast(bcx, body, llety);\n         }\n         bcx = trans_expr_save_in(bcx, e, body);\n@@ -2255,7 +2235,6 @@ fn autoderef(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n     let v1: ValueRef = v;\n     let t1: ty::t = t;\n     let ccx = bcx_ccx(cx);\n-    let sp = cx.sp;\n     while true {\n         alt ty::struct(ccx.tcx, t1) {\n           ty::ty_box(mt) {\n@@ -2267,7 +2246,7 @@ fn autoderef(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n             // different types depending on whether they're behind a box\n             // or not.\n             if check type_has_static_size(ccx, t1) {\n-                let llty = type_of(ccx, sp, t1);\n+                let llty = type_of(ccx, t1);\n                 v1 = PointerCast(cx, body, T_ptr(llty));\n             } else { v1 = body; }\n           }\n@@ -2290,7 +2269,7 @@ fn autoderef(cx: @block_ctxt, v: ValueRef, t: ty::t) -> result_t {\n             t1 =\n                 ty::substitute_type_params(ccx.tcx, tps, variants[0].args[0]);\n             if check type_has_static_size(ccx, t1) {\n-                v1 = PointerCast(cx, v1, T_ptr(type_of(ccx, sp, t1)));\n+                v1 = PointerCast(cx, v1, T_ptr(type_of(ccx, t1)));\n             } else { } // FIXME: typestate hack\n           }\n           _ { break; }\n@@ -2572,7 +2551,7 @@ fn trans_external_path(cx: @block_ctxt, did: ast::def_id,\n     let lcx = cx.fcx.lcx;\n     let name = csearch::get_symbol(lcx.ccx.sess.cstore, did);\n     ret get_extern_const(lcx.ccx.externs, lcx.ccx.llmod, name,\n-                         type_of_ty_param_bounds_and_ty(lcx, cx.sp, tpt));\n+                         type_of_ty_param_bounds_and_ty(lcx, tpt));\n }\n \n fn lval_static_fn(bcx: @block_ctxt, fn_id: ast::def_id, id: ast::node_id)\n@@ -2658,18 +2637,17 @@ fn trans_local_var(cx: @block_ctxt, def: ast::def) -> local_var_result {\n         ret {val: ptr, kind: owned};\n       }\n       _ {\n-        bcx_ccx(cx).sess.span_unimpl\n-            (cx.sp, \"unsupported def type in trans_local_def\");\n+        bcx_ccx(cx).sess.unimpl(\"unsupported def type in trans_local_def\");\n       }\n     }\n }\n \n-fn trans_path(cx: @block_ctxt, p: @ast::path, id: ast::node_id)\n+fn trans_path(cx: @block_ctxt, id: ast::node_id)\n     -> lval_maybe_callee {\n-    ret trans_var(cx, p.span, bcx_tcx(cx).def_map.get(id), id);\n+    ret trans_var(cx, bcx_tcx(cx).def_map.get(id), id);\n }\n \n-fn trans_var(cx: @block_ctxt, sp: span, def: ast::def, id: ast::node_id)\n+fn trans_var(cx: @block_ctxt, def: ast::def, id: ast::node_id)\n     -> lval_maybe_callee {\n     let ccx = bcx_ccx(cx);\n     alt def {\n@@ -2685,7 +2663,7 @@ fn trans_var(cx: @block_ctxt, sp: span, def: ast::def, id: ast::node_id)\n             let enum_ty = node_id_type(ccx, id);\n             let alloc_result = alloc_ty(cx, enum_ty);\n             let llenumblob = alloc_result.val;\n-            let llenumty = type_of_enum(ccx, sp, tid, enum_ty);\n+            let llenumty = type_of_enum(ccx, tid, enum_ty);\n             let bcx = alloc_result.bcx;\n             let llenumptr = PointerCast(bcx, llenumblob, T_ptr(llenumty));\n             let lldiscrimptr = GEPi(bcx, llenumptr, [0, 0]);\n@@ -2763,7 +2741,7 @@ fn trans_index(cx: @block_ctxt, ex: @ast::expr, base: @ast::expr,\n     let elt =\n         if check type_has_static_size(ncx, unit_ty) {\n             let elt_1 = GEP(next_cx, body, [ix_val]);\n-            let llunitty = type_of(ncx, ex.span, unit_ty);\n+            let llunitty = type_of(ncx, unit_ty);\n             PointerCast(next_cx, elt_1, T_ptr(llunitty))\n         } else {\n             body = PointerCast(next_cx, body, T_ptr(T_i8()));\n@@ -2780,7 +2758,7 @@ fn expr_is_lval(bcx: @block_ctxt, e: @ast::expr) -> bool {\n \n fn trans_callee(bcx: @block_ctxt, e: @ast::expr) -> lval_maybe_callee {\n     alt e.node {\n-      ast::expr_path(p) { ret trans_path(bcx, p, e.id); }\n+      ast::expr_path(_) { ret trans_path(bcx, e.id); }\n       ast::expr_field(base, ident, _) {\n         // Lval means this is a record field, so not a method\n         if !expr_is_lval(bcx, e) {\n@@ -2803,8 +2781,8 @@ fn trans_callee(bcx: @block_ctxt, e: @ast::expr) -> lval_maybe_callee {\n // immediate).\n fn trans_lval(cx: @block_ctxt, e: @ast::expr) -> lval_result {\n     alt e.node {\n-      ast::expr_path(p) {\n-        let v = trans_path(cx, p, e.id);\n+      ast::expr_path(_) {\n+        let v = trans_path(cx, e.id);\n         ret lval_maybe_callee_to_lval(v, ty::expr_ty(bcx_tcx(cx), e));\n       }\n       ast::expr_field(base, ident, _) {\n@@ -2827,10 +2805,9 @@ fn trans_lval(cx: @block_ctxt, e: @ast::expr) -> lval_result {\n               }\n               ty::ty_enum(_, _) {\n                 let ety = ty::expr_ty(ccx.tcx, e);\n-                let sp = e.span;\n                 let ellty =\n                     if check type_has_static_size(ccx, ety) {\n-                        T_ptr(type_of(ccx, sp, ety))\n+                        T_ptr(type_of(ccx, ety))\n                     } else { T_typaram_ptr(ccx.tn) };\n                 PointerCast(sub.bcx, sub.val, ellty)\n               }\n@@ -2919,7 +2896,7 @@ fn trans_cast(cx: @block_ctxt, e: @ast::expr, id: ast::node_id,\n     // Check should be avoidable because it's a cast.\n     // FIXME: Constrain types so as to avoid this check.\n     check (type_has_static_size(ccx, t_out));\n-    let ll_t_out = type_of(ccx, e.span, t_out);\n+    let ll_t_out = type_of(ccx, t_out);\n \n     enum kind { pointer, integral, float, enum_, other, }\n     fn t_kind(tcx: ty::ctxt, t: ty::t) -> kind {\n@@ -3130,7 +3107,7 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef,\n         // of. If so, cast the caller's view of the restlot to the callee's\n         // view, for the sake of making a type-compatible call.\n         check non_ty_var(ccx, retty);\n-        let llretty = T_ptr(type_of_inner(ccx, bcx.sp, retty));\n+        let llretty = T_ptr(type_of_inner(ccx, retty));\n         llargs += [PointerCast(cx, llretslot, llretty)];\n     } else { llargs += [llretslot]; }\n \n@@ -3145,7 +3122,7 @@ fn trans_args(cx: @block_ctxt, llenv: ValueRef,\n     // First we figure out the caller's view of the types of the arguments.\n     // This will be needed if this is a generic call, because the callee has\n     // to cast her view of the arguments to the caller's view.\n-    let arg_tys = type_of_explicit_args(ccx, cx.sp, args);\n+    let arg_tys = type_of_explicit_args(ccx, args);\n     let i = 0u;\n     for e: @ast::expr in es {\n         let r = trans_arg_expr(bcx, args[i], arg_tys[i], to_zero, to_revoke,\n@@ -3572,11 +3549,11 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n       // These return nothing\n       ast::expr_break {\n         assert dest == ignore;\n-        ret trans_break(e.span, bcx);\n+        ret trans_break(bcx);\n       }\n       ast::expr_cont {\n         assert dest == ignore;\n-        ret trans_cont(e.span, bcx);\n+        ret trans_cont(bcx);\n       }\n       ast::expr_ret(ex) {\n         assert dest == ignore;\n@@ -3864,7 +3841,7 @@ fn trans_fail_value(bcx: @block_ctxt, sp_opt: option::t<span>,\n     ret bcx;\n }\n \n-fn trans_break_cont(sp: span, bcx: @block_ctxt, to_end: bool)\n+fn trans_break_cont(bcx: @block_ctxt, to_end: bool)\n     -> @block_ctxt {\n     // Locate closest loop block, outputting cleanup as we go.\n     let cleanup_cx = bcx, bcx = bcx;\n@@ -3887,8 +3864,8 @@ fn trans_break_cont(sp: span, bcx: @block_ctxt, to_end: bool)\n             alt cleanup_cx.parent {\n               parent_some(cx) { cleanup_cx = cx; }\n               parent_none {\n-                bcx_ccx(bcx).sess.span_fatal\n-                    (sp, if to_end { \"Break\" } else { \"Cont\" } +\n+                bcx_ccx(bcx).sess.bug\n+                    (if to_end { \"Break\" } else { \"Cont\" } +\n                      \" outside a loop\");\n               }\n             }\n@@ -3899,12 +3876,12 @@ fn trans_break_cont(sp: span, bcx: @block_ctxt, to_end: bool)\n     bcx_ccx(bcx).sess.bug(\"in trans::trans_break_cont()\");\n }\n \n-fn trans_break(sp: span, cx: @block_ctxt) -> @block_ctxt {\n-    ret trans_break_cont(sp, cx, true);\n+fn trans_break(cx: @block_ctxt) -> @block_ctxt {\n+    ret trans_break_cont(cx, true);\n }\n \n-fn trans_cont(sp: span, cx: @block_ctxt) -> @block_ctxt {\n-    ret trans_break_cont(sp, cx, false);\n+fn trans_cont(cx: @block_ctxt) -> @block_ctxt {\n+    ret trans_break_cont(cx, false);\n }\n \n fn trans_ret(bcx: @block_ctxt, e: option::t<@ast::expr>) -> @block_ctxt {\n@@ -3989,8 +3966,7 @@ fn zero_alloca(cx: @block_ctxt, llptr: ValueRef, t: ty::t)\n     let bcx = cx;\n     let ccx = bcx_ccx(cx);\n     if check type_has_static_size(ccx, t) {\n-        let sp = cx.sp;\n-        let llty = type_of(ccx, sp, t);\n+        let llty = type_of(ccx, t);\n         Store(bcx, C_null(llty), llptr);\n     } else {\n         let key = alt ccx.sess.targ_cfg.arch {\n@@ -4010,8 +3986,6 @@ fn zero_alloca(cx: @block_ctxt, llptr: ValueRef, t: ty::t)\n }\n \n fn trans_stmt(cx: @block_ctxt, s: ast::stmt) -> @block_ctxt {\n-    // FIXME Fill in cx.sp\n-\n     if (!bcx_ccx(cx).sess.opts.no_asm_comments) {\n         add_span_comment(cx, s.span, stmt_to_str(s));\n     }\n@@ -4065,7 +4039,6 @@ fn new_block_ctxt(cx: @fn_ctxt, parent: block_parent, kind: block_kind,\n                 mutable cleanups: [],\n                 mutable lpad_dirty: true,\n                 mutable lpad: option::none,\n-                sp: cx.sp,\n                 fcx: cx};\n     alt parent {\n       parent_some(cx) {\n@@ -4109,7 +4082,6 @@ fn new_raw_block_ctxt(fcx: @fn_ctxt, llbb: BasicBlockRef) -> @block_ctxt {\n           mutable cleanups: [],\n           mutable lpad_dirty: true,\n           mutable lpad: option::none,\n-          sp: fcx.sp,\n           fcx: fcx};\n }\n \n@@ -4176,7 +4148,6 @@ fn llstaticallocas_block_ctxt(fcx: @fn_ctxt) -> @block_ctxt {\n           mutable cleanups: [],\n           mutable lpad_dirty: true,\n           mutable lpad: option::none,\n-          sp: fcx.sp,\n           fcx: fcx};\n }\n \n@@ -4189,7 +4160,6 @@ fn llderivedtydescs_block_ctxt(fcx: @fn_ctxt) -> @block_ctxt {\n           mutable cleanups: [],\n           mutable lpad_dirty: true,\n           mutable lpad: option::none,\n-          sp: fcx.sp,\n           fcx: fcx};\n }\n \n@@ -4199,8 +4169,7 @@ fn alloc_ty(cx: @block_ctxt, t: ty::t) -> result {\n     let ccx = bcx_ccx(cx);\n     let val =\n         if check type_has_static_size(ccx, t) {\n-            let sp = cx.sp;\n-            alloca(bcx, type_of(ccx, sp, t))\n+            alloca(bcx, type_of(ccx, t))\n         } else {\n             // NB: we have to run this particular 'size_of' in a\n             // block_ctxt built on the llderivedtydescs block for the fn,\n@@ -4321,7 +4290,7 @@ fn mk_standard_basic_blocks(llfn: ValueRef) ->\n //  - create_llargs_for_fn_args.\n //  - new_fn_ctxt\n //  - trans_args\n-fn new_fn_ctxt_w_id(cx: @local_ctxt, sp: span, llfndecl: ValueRef,\n+fn new_fn_ctxt_w_id(cx: @local_ctxt, llfndecl: ValueRef,\n                     id: ast::node_id, rstyle: ast::ret_style)\n     -> @fn_ctxt {\n     let llbbs = mk_standard_basic_blocks(llfndecl);\n@@ -4343,12 +4312,11 @@ fn new_fn_ctxt_w_id(cx: @local_ctxt, sp: span, llfndecl: ValueRef,\n           derived_tydescs: ty::new_ty_hash(),\n           id: id,\n           ret_style: rstyle,\n-          sp: sp,\n           lcx: cx};\n }\n \n-fn new_fn_ctxt(cx: @local_ctxt, sp: span, llfndecl: ValueRef) -> @fn_ctxt {\n-    ret new_fn_ctxt_w_id(cx, sp, llfndecl, -1, ast::return_val);\n+fn new_fn_ctxt(cx: @local_ctxt, llfndecl: ValueRef) -> @fn_ctxt {\n+    ret new_fn_ctxt_w_id(cx, llfndecl, -1, ast::return_val);\n }\n \n // NB: must keep 4 fns in sync:\n@@ -4432,7 +4400,7 @@ fn copy_args_to_allocas(fcx: @fn_ctxt, bcx: @block_ctxt, args: [ast::arg],\n           ast::by_ref {}\n         }\n         if fcx_ccx(fcx).sess.opts.extra_debuginfo {\n-            debuginfo::create_arg(bcx, args[arg_n]);\n+            debuginfo::create_arg(bcx, args[arg_n], args[arg_n].ty.span);\n         }\n         arg_n += 1u;\n     }\n@@ -4463,14 +4431,14 @@ enum self_arg { impl_self(ty::t), no_self, }\n // trans_closure: Builds an LLVM function out of a source function.\n // If the function closes over its environment a closure will be\n // returned.\n-fn trans_closure(cx: @local_ctxt, sp: span, decl: ast::fn_decl,\n+fn trans_closure(cx: @local_ctxt, decl: ast::fn_decl,\n                  body: ast::blk, llfndecl: ValueRef,\n                  ty_self: self_arg, ty_params: [ast::ty_param],\n                  id: ast::node_id, maybe_load_env: fn(@fn_ctxt)) {\n     set_uwtable(llfndecl);\n \n     // Set up arguments to the function.\n-    let fcx = new_fn_ctxt_w_id(cx, sp, llfndecl, id, decl.cf);\n+    let fcx = new_fn_ctxt_w_id(cx, llfndecl, id, decl.cf);\n     create_llargs_for_fn_args(fcx, ty_self, decl.inputs, ty_params);\n \n     // Create the first basic block in the function and keep a handle on it to\n@@ -4511,28 +4479,24 @@ fn trans_fn(cx: @local_ctxt, sp: span, decl: ast::fn_decl, body: ast::blk,\n     let do_time = cx.ccx.sess.opts.stats;\n     let start = do_time ? time::get_time() : {sec: 0u32, usec: 0u32};\n     let fcx = option::none;\n-    trans_closure(cx, sp, decl, body, llfndecl, ty_self, ty_params, id,\n+    trans_closure(cx, decl, body, llfndecl, ty_self, ty_params, id,\n                   {|new_fcx| fcx = option::some(new_fcx);});\n     if cx.ccx.sess.opts.extra_debuginfo {\n-        debuginfo::create_function(option::get(fcx));\n+        debuginfo::create_function(option::get(fcx), sp);\n     }\n     if do_time {\n         let end = time::get_time();\n         log_fn_time(cx.ccx, str::connect(cx.path, \"::\"), start, end);\n     }\n }\n \n-fn trans_res_ctor(cx: @local_ctxt, sp: span, dtor: ast::fn_decl,\n+fn trans_res_ctor(cx: @local_ctxt, dtor: ast::fn_decl,\n                   ctor_id: ast::node_id, ty_params: [ast::ty_param]) {\n     let ccx = cx.ccx;\n \n     // Create a function for the constructor\n-    let llctor_decl;\n-    alt ccx.item_ids.find(ctor_id) {\n-      some(x) { llctor_decl = x; }\n-      _ { ccx.sess.span_fatal(sp, \"unbound ctor_id in trans_res_ctor\"); }\n-    }\n-    let fcx = new_fn_ctxt(cx, sp, llctor_decl);\n+    let llctor_decl = ccx.item_ids.get(ctor_id);\n+    let fcx = new_fn_ctxt(cx, llctor_decl);\n     let ret_t = ty::ret_ty_of_fn(cx.ccx.tcx, ctor_id);\n     create_llargs_for_fn_args(fcx, no_self, dtor.inputs, ty_params);\n     let bcx = new_top_block_ctxt(fcx);\n@@ -4592,7 +4556,7 @@ fn trans_enum_variant(cx: @local_ctxt, enum_id: ast::node_id,\n                                \"unbound variant id in trans_enum_variant\");\n       }\n     }\n-    let fcx = new_fn_ctxt(cx, variant.span, llfndecl);\n+    let fcx = new_fn_ctxt(cx, llfndecl);\n     create_llargs_for_fn_args(fcx, no_self, fn_args, ty_params);\n     let ty_param_substs: [ty::t] = [];\n     i = 0u;\n@@ -4740,14 +4704,13 @@ type c_stack_tys = {\n };\n \n fn c_stack_tys(ccx: @crate_ctxt,\n-               sp: span,\n                id: ast::node_id) -> @c_stack_tys {\n     alt ty::struct(ccx.tcx, ty::node_id_to_type(ccx.tcx, id)) {\n       ty::ty_fn({inputs: arg_tys, output: ret_ty, _}) {\n         let tcx = ccx.tcx;\n-        let llargtys = type_of_explicit_args(ccx, sp, arg_tys);\n+        let llargtys = type_of_explicit_args(ccx, arg_tys);\n         check non_ty_var(ccx, ret_ty); // NDM does this truly hold?\n-        let llretty = type_of_inner(ccx, sp, ret_ty);\n+        let llretty = type_of_inner(ccx, ret_ty);\n         let bundle_ty = T_struct(llargtys + [T_ptr(llretty)]);\n         ret @{\n             arg_tys: llargtys,\n@@ -4759,12 +4722,6 @@ fn c_stack_tys(ccx: @crate_ctxt,\n             shim_fn_ty: T_fn([T_ptr(bundle_ty)], T_void())\n         };\n       }\n-\n-      _ {\n-        ccx.sess.span_fatal(\n-            sp,\n-            \"Non-function type for native fn\");\n-      }\n     }\n }\n \n@@ -4811,7 +4768,6 @@ fn trans_native_mod(lcx: @local_ctxt, native_mod: ast::native_mod,\n                      cc: uint) -> ValueRef {\n         let lname = link_name(native_item);\n         let ccx = lcx_ccx(lcx);\n-        let span = native_item.span;\n \n         // Declare the \"prototype\" for the base function F:\n         let llbasefn = decl_fn(ccx.llmod, lname, cc, tys.base_fn_ty);\n@@ -4822,7 +4778,7 @@ fn trans_native_mod(lcx: @local_ctxt, native_mod: ast::native_mod,\n             ccx.llmod, shim_name, tys.shim_fn_ty);\n \n         // Declare the body of the shim function:\n-        let fcx = new_fn_ctxt(lcx, span, llshimfn);\n+        let fcx = new_fn_ctxt(lcx, llshimfn);\n         let bcx = new_top_block_ctxt(fcx);\n         let lltop = bcx.llbb;\n         let llargbundle = llvm::LLVMGetParam(llshimfn, 0 as c_uint);\n@@ -4854,14 +4810,12 @@ fn trans_native_mod(lcx: @local_ctxt, native_mod: ast::native_mod,\n     }\n \n     fn build_wrap_fn(lcx: @local_ctxt,\n-                     native_item: @ast::native_item,\n                      tys: @c_stack_tys,\n                      num_tps: uint,\n                      llshimfn: ValueRef,\n                      llwrapfn: ValueRef) {\n-        let span = native_item.span;\n         let ccx = lcx_ccx(lcx);\n-        let fcx = new_fn_ctxt(lcx, span, llwrapfn);\n+        let fcx = new_fn_ctxt(lcx, llwrapfn);\n         let bcx = new_top_block_ctxt(fcx);\n         let lltop = bcx.llbb;\n \n@@ -4899,14 +4853,12 @@ fn trans_native_mod(lcx: @local_ctxt, native_mod: ast::native_mod,\n       alt native_item.node {\n         ast::native_item_ty {}\n         ast::native_item_fn(fn_decl, tps) {\n-          let span = native_item.span;\n           let id = native_item.id;\n-          let tys = c_stack_tys(ccx, span, id);\n+          let tys = c_stack_tys(ccx, id);\n           alt ccx.item_ids.find(id) {\n             some(llwrapfn) {\n               let llshimfn = build_shim_fn(lcx, native_item, tys, cc);\n-              build_wrap_fn(lcx, native_item, tys,\n-                            vec::len(tps), llshimfn, llwrapfn);\n+              build_wrap_fn(lcx, tys, vec::len(tps), llshimfn, llwrapfn);\n             }\n \n             none {\n@@ -4939,7 +4891,7 @@ fn trans_item(cx: @local_ctxt, item: ast::item) {\n         trans_impl::trans_impl(cx, item.ident, ms, item.id, tps);\n       }\n       ast::item_res(decl, tps, body, dtor_id, ctor_id) {\n-        trans_res_ctor(cx, item.span, decl, ctor_id, tps);\n+        trans_res_ctor(cx, decl, ctor_id, tps);\n \n         // Create a function for the destructor\n         alt cx.ccx.item_ids.find(item.id) {\n@@ -5014,7 +4966,7 @@ fn register_fn_full(ccx: @crate_ctxt, sp: span, path: [str], _flav: str,\n                     node_type: ty::t)\n     : returns_non_ty_var(ccx, node_type) {\n     let path = path;\n-    let llfty = type_of_fn_from_ty(ccx, sp, node_type,\n+    let llfty = type_of_fn_from_ty(ccx, node_type,\n                                    vec::map(tps, {|p| param_bounds(ccx, p)}));\n     let ps: str = mangle_exported_name(ccx, path, node_type);\n     let llfn: ValueRef = decl_cdecl_fn(ccx.llmod, ps, llfty);\n@@ -5039,23 +4991,23 @@ fn create_main_wrapper(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n           ty::ty_fn({inputs, _}) { vec::len(inputs) != 0u }\n         };\n \n-    let llfn = create_main(ccx, sp, main_llfn, main_takes_argv);\n+    let llfn = create_main(ccx, main_llfn, main_takes_argv);\n     ccx.main_fn = some(llfn);\n     create_entry_fn(ccx, llfn);\n \n-    fn create_main(ccx: @crate_ctxt, sp: span, main_llfn: ValueRef,\n+    fn create_main(ccx: @crate_ctxt, main_llfn: ValueRef,\n                    takes_argv: bool) -> ValueRef {\n         let unit_ty = ty::mk_str(ccx.tcx);\n         let vecarg_ty: ty::arg =\n             {mode: ast::by_val,\n              ty: ty::mk_vec(ccx.tcx, {ty: unit_ty, mut: ast::imm})};\n         // FIXME: mk_nil should have a postcondition\n         let nt = ty::mk_nil(ccx.tcx);\n-        let llfty = type_of_fn(ccx, sp, [vecarg_ty], nt, []);\n+        let llfty = type_of_fn(ccx, [vecarg_ty], nt, []);\n         let llfdecl = decl_fn(ccx.llmod, \"_rust_main\",\n                               lib::llvm::LLVMCCallConv, llfty);\n \n-        let fcx = new_fn_ctxt(new_local_ctxt(ccx), sp, llfdecl);\n+        let fcx = new_fn_ctxt(new_local_ctxt(ccx), llfdecl);\n \n         let bcx = new_top_block_ctxt(fcx);\n         let lltop = bcx.llbb;\n@@ -5144,20 +5096,20 @@ fn native_fn_ty_param_count(cx: @crate_ctxt, id: ast::node_id) -> uint {\n     ret count;\n }\n \n-fn native_fn_wrapper_type(cx: @crate_ctxt, sp: span,\n+fn native_fn_wrapper_type(cx: @crate_ctxt,\n                           param_bounds: [ty::param_bounds],\n                           x: ty::t) -> TypeRef {\n     alt ty::struct(cx.tcx, x) {\n       ty::ty_fn({inputs: args, output: out, _}) {\n-        ret type_of_fn(cx, sp, args, out, param_bounds);\n+        ret type_of_fn(cx, args, out, param_bounds);\n       }\n     }\n }\n \n-fn raw_native_fn_type(ccx: @crate_ctxt, sp: span, args: [ty::arg],\n+fn raw_native_fn_type(ccx: @crate_ctxt, args: [ty::arg],\n                       ret_ty: ty::t) -> TypeRef {\n     check type_has_static_size(ccx, ret_ty);\n-    ret T_fn(type_of_explicit_args(ccx, sp, args), type_of(ccx, sp, ret_ty));\n+    ret T_fn(type_of_explicit_args(ccx, args), type_of(ccx, ret_ty));\n }\n \n fn link_name(i: @ast::native_item) -> str {\n@@ -5174,7 +5126,6 @@ fn collect_native_item(ccx: @crate_ctxt,\n                        _v: vt<[str]>) {\n     alt i.node {\n       ast::native_item_fn(_, tps) {\n-        let sp = i.span;\n         let id = i.id;\n         let node_type = node_id_type(ccx, id);\n         let fn_abi =\n@@ -5196,7 +5147,7 @@ fn collect_native_item(ccx: @crate_ctxt,\n             // For intrinsics: link the function directly to the intrinsic\n             // function itself.\n             let fn_type = type_of_fn_from_ty(\n-                ccx, sp, node_type,\n+                ccx, node_type,\n                 vec::map(tps, {|p| param_bounds(ccx, p)}));\n             let ri_name = \"rust_intrinsic_\" + link_name(i);\n             let llnativefn = get_extern_fn(\n@@ -5232,7 +5183,7 @@ fn collect_item(ccx: @crate_ctxt, abi: @mutable option::t<ast::native_abi>,\n         // items\n         let g = str::as_buf(s, {|buf|\n             check (type_has_static_size(ccx, typ));\n-            llvm::LLVMAddGlobal(ccx.llmod, type_of(ccx, i.span, typ), buf)\n+            llvm::LLVMAddGlobal(ccx.llmod, type_of(ccx, typ), buf)\n         });\n         ccx.item_symbols.insert(i.id, s);\n         ccx.consts.insert(i.id, g);"}, {"sha": "c6fa03ebe40771bfc9e75cbfbda3cb3bfbe8a311", "filename": "src/comp/middle/trans_alt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3f06c7d5476e7a53d83e2e6fc126c07af39d73c/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3f06c7d5476e7a53d83e2e6fc126c07af39d73c/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_alt.rs?ref=b3f06c7d5476e7a53d83e2e6fc126c07af39d73c", "patch": "@@ -713,7 +713,7 @@ fn bind_irrefutable_pat(bcx: @block_ctxt, pat: @ast::pat, val: ValueRef,\n             // check unnecessary.\n             check (type_has_static_size(ccx, ty));\n             check non_ty_var(ccx, ty);\n-            let llty = trans::type_of(ccx, pat.span, ty);\n+            let llty = trans::type_of(ccx, ty);\n             let alloc = trans::alloca(bcx, llty);\n             bcx = trans::copy_val(bcx, trans::INIT, alloc,\n                                   trans::load_if_immediate(bcx, val, ty), ty);"}, {"sha": "8d643888ff8302ac93710e8bc76120e0c81de36d", "filename": "src/comp/middle/trans_closure.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b3f06c7d5476e7a53d83e2e6fc126c07af39d73c/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3f06c7d5476e7a53d83e2e6fc126c07af39d73c/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs?ref=b3f06c7d5476e7a53d83e2e6fc126c07af39d73c", "patch": "@@ -268,7 +268,7 @@ type closure_result = {\n fn cast_if_we_can(bcx: @block_ctxt, llbox: ValueRef, t: ty::t) -> ValueRef {\n     let ccx = bcx_ccx(bcx);\n     if check type_has_static_size(ccx, t) {\n-        let llty = type_of(ccx, bcx.sp, t);\n+        let llty = type_of(ccx, t);\n         ret PointerCast(bcx, llbox, llty);\n     } else {\n         ret llbox;\n@@ -450,10 +450,9 @@ fn load_environment(enclosing_cx: @block_ctxt,\n     let ccx = bcx_ccx(bcx);\n     let tcx = bcx_tcx(bcx);\n \n-    let sp = bcx.sp;\n     let cboxptr_ty = ty::mk_ptr(tcx, {ty:cbox_ty, mut:ast::imm});\n     check (type_has_static_size(ccx, cboxptr_ty));\n-    let llty = type_of(ccx, sp, cboxptr_ty);\n+    let llty = type_of(ccx, cboxptr_ty);\n     let llclosure = PointerCast(bcx, fcx.llenv, llty);\n \n     // Populate the type parameters from the environment. We need to\n@@ -511,7 +510,7 @@ fn trans_expr_fn(bcx: @block_ctxt,\n     if dest == ignore { ret bcx; }\n     let ccx = bcx_ccx(bcx), bcx = bcx;\n     let fty = node_id_type(ccx, id);\n-    let llfnty = type_of_fn_from_ty(ccx, sp, fty, []);\n+    let llfnty = type_of_fn_from_ty(ccx, fty, []);\n     let sub_cx = extend_path(bcx.fcx.lcx, ccx.names(\"anon\"));\n     let s = mangle_internal_name_by_path(ccx, sub_cx.path);\n     let llfn = decl_internal_cdecl_fn(ccx.llmod, s, llfnty);\n@@ -521,7 +520,7 @@ fn trans_expr_fn(bcx: @block_ctxt,\n         let cap_vars = capture::compute_capture_vars(\n             ccx.tcx, id, proto, cap_clause);\n         let {llbox, cbox_ty, bcx} = build_closure(bcx, cap_vars, ck);\n-        trans_closure(sub_cx, sp, decl, body, llfn, no_self, [], id, {|fcx|\n+        trans_closure(sub_cx, decl, body, llfn, no_self, [], id, {|fcx|\n             load_environment(bcx, fcx, cbox_ty, cap_vars, ck);\n         });\n         llbox\n@@ -533,7 +532,7 @@ fn trans_expr_fn(bcx: @block_ctxt,\n       ast::proto_uniq { trans_closure_env(ty::ck_uniq) }\n       ast::proto_bare {\n         let closure = C_null(T_opaque_cbox_ptr(ccx));\n-        trans_closure(sub_cx, sp, decl, body, llfn, no_self, [],\n+        trans_closure(sub_cx, decl, body, llfn, no_self, [],\n                       id, {|_fcx|});\n         closure\n       }\n@@ -610,8 +609,7 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n         // Cast the function we are binding to be the type that the\n         // closure will expect it to have. The type the closure knows\n         // about has the type parameters substituted with the real types.\n-        let sp = cx.sp;\n-        let llclosurety = T_ptr(type_of(ccx, sp, outgoing_fty));\n+        let llclosurety = T_ptr(type_of(ccx, outgoing_fty));\n         let src_loc = PointerCast(bcx, cl, llclosurety);\n         ([env_copy(src_loc, pair_ty, owned)], none)\n       }\n@@ -626,7 +624,7 @@ fn trans_bind_1(cx: @block_ctxt, outgoing_fty: ty::t,\n \n     // Make thunk\n     let llthunk =\n-        trans_bind_thunk(cx.fcx.lcx, cx.sp, pair_ty, outgoing_fty_real, args,\n+        trans_bind_thunk(cx.fcx.lcx, pair_ty, outgoing_fty_real, args,\n                          cbox_ty, *param_bounds, target_res);\n \n     // Fill the function pair\n@@ -781,7 +779,6 @@ fn make_opaque_cbox_free_glue(\n \n // pth is cx.path\n fn trans_bind_thunk(cx: @local_ctxt,\n-                    sp: span,\n                     incoming_fty: ty::t,\n                     outgoing_fty: ty::t,\n                     args: [option::t<@ast::expr>],\n@@ -823,12 +820,12 @@ fn trans_bind_thunk(cx: @local_ctxt,\n \n     // Give the thunk a name, type, and value.\n     let s: str = mangle_internal_name_by_path_and_seq(ccx, cx.path, \"thunk\");\n-    let llthunk_ty: TypeRef = get_pair_fn_ty(type_of(ccx, sp, incoming_fty));\n+    let llthunk_ty: TypeRef = get_pair_fn_ty(type_of(ccx, incoming_fty));\n     let llthunk: ValueRef = decl_internal_cdecl_fn(ccx.llmod, s, llthunk_ty);\n \n     // Create a new function context and block context for the thunk, and hold\n     // onto a pointer to the first block in the function for later use.\n-    let fcx = new_fn_ctxt(cx, sp, llthunk);\n+    let fcx = new_fn_ctxt(cx, llthunk);\n     let bcx = new_top_block_ctxt(fcx);\n     let lltop = bcx.llbb;\n     // Since we might need to construct derived tydescs that depend on\n@@ -845,7 +842,7 @@ fn trans_bind_thunk(cx: @local_ctxt,\n     // 'cbox_ty', which was determined by trans_bind.\n     let cboxptr_ty = ty::mk_ptr(tcx, {ty:cbox_ty, mut:ast::imm});\n     check type_has_static_size(ccx, cboxptr_ty);\n-    let llclosure_ptr_ty = type_of(ccx, sp, cboxptr_ty);\n+    let llclosure_ptr_ty = type_of(ccx, cboxptr_ty);\n     let llclosure = PointerCast(l_bcx, fcx.llenv, llclosure_ptr_ty);\n \n     // \"target\", in this context, means the function that's having some of its\n@@ -888,7 +885,7 @@ fn trans_bind_thunk(cx: @local_ctxt,\n     let ccx = cx.ccx;\n     if ty::type_contains_params(ccx.tcx, outgoing_ret_ty) {\n         check non_ty_var(ccx, outgoing_ret_ty);\n-        let llretty = type_of_inner(ccx, sp, outgoing_ret_ty);\n+        let llretty = type_of_inner(ccx, outgoing_ret_ty);\n         llretptr = PointerCast(bcx, llretptr, T_ptr(llretty));\n     }\n \n@@ -928,7 +925,7 @@ fn trans_bind_thunk(cx: @local_ctxt,\n     let b: int = starting_idx;\n     let outgoing_arg_index: uint = 0u;\n     let llout_arg_tys: [TypeRef] =\n-        type_of_explicit_args(cx.ccx, sp, outgoing_args);\n+        type_of_explicit_args(cx.ccx, outgoing_args);\n     for arg: option::t<@ast::expr> in args {\n         let out_arg = outgoing_args[outgoing_arg_index];\n         let llout_arg_ty = llout_arg_tys[outgoing_arg_index];\n@@ -979,7 +976,7 @@ fn trans_bind_thunk(cx: @local_ctxt,\n     let ccx = bcx_ccx(bcx);\n \n     let lltargetty =\n-        type_of_fn_from_ty(ccx, sp, outgoing_fty, param_bounds);\n+        type_of_fn_from_ty(ccx, outgoing_fty, param_bounds);\n     lltargetfn = PointerCast(bcx, lltargetfn, T_ptr(lltargetty));\n     Call(bcx, lltargetfn, llargs);\n     build_return(bcx);"}, {"sha": "ac75c454585cfedc10928f43c4ca7f7517e89205", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b3f06c7d5476e7a53d83e2e6fc126c07af39d73c/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3f06c7d5476e7a53d83e2e6fc126c07af39d73c/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=b3f06c7d5476e7a53d83e2e6fc126c07af39d73c", "patch": "@@ -240,7 +240,6 @@ type fn_ctxt =\n      derived_tydescs: hashmap<ty::t, derived_tydesc_info>,\n      id: ast::node_id,\n      ret_style: ast::ret_style,\n-     sp: span,\n      lcx: @local_ctxt};\n \n enum cleanup {\n@@ -311,7 +310,7 @@ fn revoke_clean(cx: @block_ctxt, val: ValueRef) {\n     ret;\n }\n \n-fn get_res_dtor(ccx: @crate_ctxt, sp: span, did: ast::def_id, inner_t: ty::t)\n+fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id, inner_t: ty::t)\n    -> ValueRef {\n     if did.crate == ast::local_crate {\n         alt ccx.item_ids.find(did.node) {\n@@ -324,8 +323,7 @@ fn get_res_dtor(ccx: @crate_ctxt, sp: span, did: ast::def_id, inner_t: ty::t)\n     let nil_res = ty::mk_nil(ccx.tcx);\n     // FIXME: Silly check -- mk_nil should have a postcondition\n     check non_ty_var(ccx, nil_res);\n-    let f_t = type_of_fn(ccx, sp,\n-                         [{mode: ast::by_ref, ty: inner_t}],\n+    let f_t = type_of_fn(ccx, [{mode: ast::by_ref, ty: inner_t}],\n                          nil_res, *param_bounds);\n     ret trans::get_extern_const(ccx.externs, ccx.llmod,\n                                 csearch::get_symbol(ccx.sess.cstore,\n@@ -384,7 +382,6 @@ type block_ctxt =\n      mutable cleanups: [cleanup],\n      mutable lpad_dirty: bool,\n      mutable lpad: option::t<BasicBlockRef>,\n-     sp: span,\n      fcx: @fn_ctxt};\n \n // FIXME: we should be able to use option::t<@block_parent> here but"}, {"sha": "4803fe034e67aebb016a32a392c33cb238fd3765", "filename": "src/comp/middle/trans_impl.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b3f06c7d5476e7a53d83e2e6fc126c07af39d73c/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3f06c7d5476e7a53d83e2e6fc126c07af39d73c/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_impl.rs?ref=b3f06c7d5476e7a53d83e2e6fc126c07af39d73c", "patch": "@@ -89,8 +89,7 @@ fn trans_static_callee(bcx: @block_ctxt, callee_id: ast::node_id,\n fn wrapper_fn_ty(ccx: @crate_ctxt, dict_ty: TypeRef, m: ty::method)\n     -> {ty: ty::t, llty: TypeRef} {\n     let fty = ty::mk_fn(ccx.tcx, m.fty);\n-    let bare_fn_ty = type_of_fn_from_ty(ccx, ast_util::dummy_sp(),\n-                                        fty, *m.tps);\n+    let bare_fn_ty = type_of_fn_from_ty(ccx, fty, *m.tps);\n     let {inputs, output} = llfn_arg_tys(bare_fn_ty);\n     {ty: fty, llty: T_fn([dict_ty] + inputs, output)}\n }\n@@ -179,7 +178,7 @@ fn trans_wrapper(ccx: @crate_ctxt, pt: [ast::ident], llfty: TypeRef,\n     let lcx = @{path: pt, module_path: [], ccx: ccx};\n     let name = link::mangle_internal_name_by_path(ccx, pt);\n     let llfn = decl_internal_cdecl_fn(ccx.llmod, name, llfty);\n-    let fcx = new_fn_ctxt(lcx, ast_util::dummy_sp(), llfn);\n+    let fcx = new_fn_ctxt(lcx, llfn);\n     let bcx = new_top_block_ctxt(fcx), lltop = bcx.llbb;\n     let bcx = fill(llfn, bcx);\n     build_return(bcx);"}, {"sha": "16bb235d1b921dbaa2f8f0ae320db1105c3bf0bb", "filename": "src/comp/middle/trans_uniq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3f06c7d5476e7a53d83e2e6fc126c07af39d73c/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3f06c7d5476e7a53d83e2e6fc126c07af39d73c/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_uniq.rs?ref=b3f06c7d5476e7a53d83e2e6fc126c07af39d73c", "patch": "@@ -44,7 +44,7 @@ fn alloc_uniq(cx: @block_ctxt, uniq_ty: ty::t)\n \n     let ccx = bcx_ccx(bcx);\n     check non_ty_var(ccx, contents_ty);\n-    let llptrty = T_ptr(type_of_inner(ccx, bcx.sp, contents_ty));\n+    let llptrty = T_ptr(type_of_inner(ccx, contents_ty));\n \n     r = trans_shared_malloc(bcx, llptrty, llsz);\n     bcx = r.bcx;"}, {"sha": "b24f3aae4737648e107eebb30eca3504d8d65c27", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b3f06c7d5476e7a53d83e2e6fc126c07af39d73c/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3f06c7d5476e7a53d83e2e6fc126c07af39d73c/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=b3f06c7d5476e7a53d83e2e6fc126c07af39d73c", "patch": "@@ -124,10 +124,9 @@ fn fold_attribute_(at: attribute, fmi: fn@(&&@meta_item) -> @meta_item) ->\n }\n //used in noop_fold_native_item and noop_fold_fn_decl\n fn fold_arg_(a: arg, fld: ast_fold) -> arg {\n-    ret {mode: a.mode,\n-         ty: fld.fold_ty(a.ty),\n-         ident: fld.fold_ident(a.ident),\n-         id: a.id};\n+    ret {ty: fld.fold_ty(a.ty),\n+         ident: fld.fold_ident(a.ident)\n+         with a};\n }\n //used in noop_fold_expr, and possibly elsewhere in the future\n fn fold_mac_(m: mac, fld: ast_fold) -> mac {"}]}