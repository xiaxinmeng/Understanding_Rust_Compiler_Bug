{"sha": "5c8525ce4ae8bb969f2ac263bf14adad1c835c03", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjODUyNWNlNGFlOGJiOTY5ZjJhYzI2M2JmMTRhZGFkMWM4MzVjMDM=", "commit": {"author": {"name": "Bernardo", "email": "berublan@gmail.com", "date": "2018-12-22T14:44:27Z"}, "committer": {"name": "Bernardo", "email": "berublan@gmail.com", "date": "2018-12-25T19:03:14Z"}, "message": "column translation implemented but not quite working yet", "tree": {"sha": "19df6e95432bbbc0e1c9c75b0867ffe3d378fa0a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/19df6e95432bbbc0e1c9c75b0867ffe3d378fa0a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c8525ce4ae8bb969f2ac263bf14adad1c835c03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c8525ce4ae8bb969f2ac263bf14adad1c835c03", "html_url": "https://github.com/rust-lang/rust/commit/5c8525ce4ae8bb969f2ac263bf14adad1c835c03", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c8525ce4ae8bb969f2ac263bf14adad1c835c03/comments", "author": {"login": "vemoo", "id": 4866051, "node_id": "MDQ6VXNlcjQ4NjYwNTE=", "avatar_url": "https://avatars.githubusercontent.com/u/4866051?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vemoo", "html_url": "https://github.com/vemoo", "followers_url": "https://api.github.com/users/vemoo/followers", "following_url": "https://api.github.com/users/vemoo/following{/other_user}", "gists_url": "https://api.github.com/users/vemoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/vemoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vemoo/subscriptions", "organizations_url": "https://api.github.com/users/vemoo/orgs", "repos_url": "https://api.github.com/users/vemoo/repos", "events_url": "https://api.github.com/users/vemoo/events{/privacy}", "received_events_url": "https://api.github.com/users/vemoo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vemoo", "id": 4866051, "node_id": "MDQ6VXNlcjQ4NjYwNTE=", "avatar_url": "https://avatars.githubusercontent.com/u/4866051?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vemoo", "html_url": "https://github.com/vemoo", "followers_url": "https://api.github.com/users/vemoo/followers", "following_url": "https://api.github.com/users/vemoo/following{/other_user}", "gists_url": "https://api.github.com/users/vemoo/gists{/gist_id}", "starred_url": "https://api.github.com/users/vemoo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vemoo/subscriptions", "organizations_url": "https://api.github.com/users/vemoo/orgs", "repos_url": "https://api.github.com/users/vemoo/repos", "events_url": "https://api.github.com/users/vemoo/events{/privacy}", "received_events_url": "https://api.github.com/users/vemoo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36f2b1f3b9c36ace65852d971f998a090cf9b5d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/36f2b1f3b9c36ace65852d971f998a090cf9b5d5", "html_url": "https://github.com/rust-lang/rust/commit/36f2b1f3b9c36ace65852d971f998a090cf9b5d5"}], "stats": {"total": 120, "additions": 70, "deletions": 50}, "files": [{"sha": "89ed998235ad5664d9e3e5dd6b3bf7e947202ead", "filename": "crates/ra_editor/benches/translate_offset_with_edit_benchmark.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c8525ce4ae8bb969f2ac263bf14adad1c835c03/crates%2Fra_editor%2Fbenches%2Ftranslate_offset_with_edit_benchmark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c8525ce4ae8bb969f2ac263bf14adad1c835c03/crates%2Fra_editor%2Fbenches%2Ftranslate_offset_with_edit_benchmark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fbenches%2Ftranslate_offset_with_edit_benchmark.rs?ref=5c8525ce4ae8bb969f2ac263bf14adad1c835c03", "patch": "@@ -72,10 +72,10 @@ fn compare_translates(c: &mut Criterion) {\n         })\n     });\n \n-    let f2 = Fun::new(\"count_newlines\", |b, _| {\n+    let f2 = Fun::new(\"translate_offset_with_edit\", |b, _| {\n         b.iter(|| {\n             let d = &*DATA;\n-            line_index_utils::count_newlines(d.offset, &d.line_index, &d.edits);\n+            line_index_utils::translate_offset_with_edit(&d.line_index, d.offset, &d.edits);\n         })\n     });\n "}, {"sha": "6dbabd97e000b4241b8056373dd77eb1794b1887", "filename": "crates/ra_editor/src/line_index.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5c8525ce4ae8bb969f2ac263bf14adad1c835c03/crates%2Fra_editor%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c8525ce4ae8bb969f2ac263bf14adad1c835c03/crates%2Fra_editor%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fline_index.rs?ref=5c8525ce4ae8bb969f2ac263bf14adad1c835c03", "patch": "@@ -4,8 +4,8 @@ use superslice::Ext;\n \n #[derive(Clone, Debug, PartialEq, Eq)]\n pub struct LineIndex {\n-    newlines: Vec<TextUnit>,\n-    utf16_lines: FxHashMap<u32, Vec<Utf16Char>>,\n+    pub(crate) newlines: Vec<TextUnit>,\n+    pub(crate) utf16_lines: FxHashMap<u32, Vec<Utf16Char>>,\n }\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n@@ -120,16 +120,6 @@ impl LineIndex {\n \n         col\n     }\n-\n-    pub(crate) fn newlines(&self) -> &[TextUnit] {\n-        &self.newlines[..]\n-    }\n-\n-    pub(crate) fn utf16_chars(&self, newline_idx: usize) -> Option<&[Utf16Char]> {\n-        self.utf16_lines\n-            .get(&(newline_idx as u32))\n-            .map(|x| x.as_slice())\n-    }\n }\n \n #[test]"}, {"sha": "382f3ac7200919241c643bb828af0984694b3dfa", "filename": "crates/ra_editor/src/line_index_utils.rs", "status": "modified", "additions": 66, "deletions": 36, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/5c8525ce4ae8bb969f2ac263bf14adad1c835c03/crates%2Fra_editor%2Fsrc%2Fline_index_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c8525ce4ae8bb969f2ac263bf14adad1c835c03/crates%2Fra_editor%2Fsrc%2Fline_index_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fline_index_utils.rs?ref=5c8525ce4ae8bb969f2ac263bf14adad1c835c03", "patch": "@@ -9,18 +9,17 @@ enum Step {\n     Utf16Char(TextRange),\n }\n \n+#[derive(Debug)]\n struct LineIndexStepIter<'a> {\n     line_index: &'a LineIndex,\n-    newlines: std::slice::Iter<'a, TextUnit>,\n     next_newline_idx: usize,\n-    utf16_chars: Option<std::slice::Iter<'a, Utf16Char>>,\n+    utf16_chars: Option<(TextUnit, std::slice::Iter<'a, Utf16Char>)>,\n }\n \n impl<'a> LineIndexStepIter<'a> {\n     fn from(line_index: &LineIndex) -> LineIndexStepIter {\n         let mut x = LineIndexStepIter {\n             line_index,\n-            newlines: line_index.newlines().iter(),\n             next_newline_idx: 0,\n             utf16_chars: None,\n         };\n@@ -35,20 +34,22 @@ impl<'a> Iterator for LineIndexStepIter<'a> {\n     fn next(&mut self) -> Option<Step> {\n         self.utf16_chars\n             .as_mut()\n-            .and_then(|x| {\n-                None\n-                // TODO Enable\n-                // let x = x.next()?;\n-                // Some(Step::Utf16Char(TextRange::from_to(x.start, x.end)))\n+            .and_then(|(newline, x)| {\n+                let x = x.next()?;\n+                Some(Step::Utf16Char(TextRange::from_to(\n+                    *newline + x.start,\n+                    *newline + x.end,\n+                )))\n             })\n             .or_else(|| {\n+                let next_newline = *self.line_index.newlines.get(self.next_newline_idx)?;\n                 self.utf16_chars = self\n                     .line_index\n-                    .utf16_chars(self.next_newline_idx)\n-                    .map(|x| x.iter());\n+                    .utf16_lines\n+                    .get(&(self.next_newline_idx as u32))\n+                    .map(|x| (next_newline, x.iter()));\n                 self.next_newline_idx += 1;\n-                let x = self.newlines.next()?;\n-                Some(Step::Newline(*x))\n+                Some(Step::Newline(next_newline))\n             })\n     }\n }\n@@ -71,18 +72,16 @@ impl<'a> Iterator for OffsetNewlineIter<'a> {\n                     let next = Step::Newline(next_offset);\n                     Some((next, next_offset))\n                 } else {\n-                    None\n-                    // TODO enable\n-                    // let char_len = TextUnit::of_char(c);\n-                    // if char_len.to_usize() > 1 {\n-                    //     let start = self.offset + TextUnit::from_usize(i);\n-                    //     let end = start + char_len;\n-                    //     let next = Step::Utf16Char(TextRange::from_to(start, end));\n-                    //     let next_offset = end;\n-                    //     Some((next, next_offset))\n-                    // } else {\n-                    //     None\n-                    // }\n+                    let char_len = TextUnit::of_char(c);\n+                    if char_len.to_usize() > 1 {\n+                        let start = self.offset + TextUnit::from_usize(i);\n+                        let end = start + char_len;\n+                        let next = Step::Utf16Char(TextRange::from_to(start, end));\n+                        let next_offset = end;\n+                        Some((next, next_offset))\n+                    } else {\n+                        None\n+                    }\n                 }\n             })\n             .next()?;\n@@ -155,7 +154,7 @@ impl<'a, 'b> Edits<'a, 'b> {\n     fn next_step(&mut self, step: &Step) -> NextNewlines {\n         let step_pos = match step {\n             &Step::Newline(n) => n,\n-            &Step::Utf16Char(r) => unimplemented!(),\n+            &Step::Utf16Char(r) => r.start(),\n         };\n         let res = match &mut self.current {\n             Some(edit) => {\n@@ -215,7 +214,11 @@ impl<'a, 'b> Edits<'a, 'b> {\n     }\n }\n \n-pub fn count_newlines(offset: TextUnit, line_index: &LineIndex, edits: &[AtomTextEdit]) -> u32 {\n+pub fn translate_offset_with_edit(\n+    line_index: &LineIndex,\n+    offset: TextUnit,\n+    edits: &[AtomTextEdit],\n+) -> LineCol {\n     let mut sorted_edits: Vec<&AtomTextEdit> = Vec::with_capacity(edits.len());\n     for edit in edits {\n         let insert_index =\n@@ -225,29 +228,55 @@ pub fn count_newlines(offset: TextUnit, line_index: &LineIndex, edits: &[AtomTex\n \n     let mut state = Edits::new(&sorted_edits);\n \n-    let mut lines: u32 = 0;\n+    let mut pos: LineCol = LineCol {\n+        line: 0,\n+        col_utf16: 0,\n+    };\n+\n+    let mut last_newline: TextUnit = TextUnit::from(0);\n+    let mut col_adjust: TextUnit = TextUnit::from(0);\n \n     macro_rules! test_step {\n         ($x:ident) => {\n             match &$x {\n                 Step::Newline(n) => {\n                     if offset < *n {\n-                        return lines;\n+                        return_pos!();\n+                    } else if offset == *n {\n+                        pos.line += 1;\n+                        pos.col_utf16 = 0;\n+                        return pos;\n                     } else {\n-                        lines += 1;\n+                        pos.line += 1;\n+                        pos.col_utf16 = 0;\n+                        last_newline = *n;\n+                        col_adjust = TextUnit::from(0);\n+                    }\n+                }\n+                Step::Utf16Char(x) => {\n+                    if offset < x.end() {\n+                        return_pos!();\n+                    } else {\n+                        col_adjust += x.len() - TextUnit::from(1);\n                     }\n                 }\n-                Step::Utf16Char(x) => unimplemented!(),\n             }\n         };\n     }\n \n+    macro_rules! return_pos {\n+        () => {\n+            pos.col_utf16 = ((offset - last_newline) - col_adjust).into();\n+            return pos;\n+        };\n+    }\n+\n     for orig_step in LineIndexStepIter::from(line_index) {\n         loop {\n-            let translated_newline = state.translate_step(&orig_step);\n-            match state.next_step(&translated_newline) {\n+            let translated_step = state.translate_step(&orig_step);\n+            match state.next_step(&translated_step) {\n                 NextNewlines::Use => {\n-                    test_step!(translated_newline);\n+                    test_step!(translated_step);\n                     break;\n                 }\n                 NextNewlines::ReplaceMany(ns) => {\n@@ -276,7 +305,7 @@ pub fn count_newlines(offset: TextUnit, line_index: &LineIndex, edits: &[AtomTex\n         }\n     }\n \n-    lines\n+    return_pos!();\n }\n \n // for bench\n@@ -337,8 +366,9 @@ mod test {\n         fn test_translate_offset_with_edit(x in arb_text_with_offset_and_edits()) {\n             let line_index = LineIndex::new(&x.text);\n             let expected = translate_after_edit(&x.text, x.offset, x.edits.clone());\n-            let actual_lines = count_newlines(x.offset, &line_index, &x.edits);\n-            assert_eq!(actual_lines, expected.line);\n+            let actual = translate_offset_with_edit(&line_index, x.offset, &x.edits);\n+            // assert_eq!(actual, expected);\n+            assert_eq!(actual.line, expected.line);\n         }\n     }\n }"}]}