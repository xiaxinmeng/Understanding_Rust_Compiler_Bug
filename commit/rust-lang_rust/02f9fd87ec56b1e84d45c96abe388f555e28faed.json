{"sha": "02f9fd87ec56b1e84d45c96abe388f555e28faed", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyZjlmZDg3ZWM1NmIxZTg0ZDQ1Yzk2YWJlMzg4ZjU1NWUyOGZhZWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-15T15:46:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-08-15T15:46:17Z"}, "message": "auto merge of #16511 : luqmana/rust/sbnt, r=pcwalton\n\nFixes #15397.\r\nFixes #7261.\r\nFixes #6573.", "tree": {"sha": "a7d0f605f76c3247f0faecc4dad35d92f34feac0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7d0f605f76c3247f0faecc4dad35d92f34feac0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02f9fd87ec56b1e84d45c96abe388f555e28faed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02f9fd87ec56b1e84d45c96abe388f555e28faed", "html_url": "https://github.com/rust-lang/rust/commit/02f9fd87ec56b1e84d45c96abe388f555e28faed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02f9fd87ec56b1e84d45c96abe388f555e28faed/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cafa47506db7f0ac8407d5771ec81f560c5a481f", "url": "https://api.github.com/repos/rust-lang/rust/commits/cafa47506db7f0ac8407d5771ec81f560c5a481f", "html_url": "https://github.com/rust-lang/rust/commit/cafa47506db7f0ac8407d5771ec81f560c5a481f"}, {"sha": "28882c44ef0cfc031a931c0ca0509707a9b4729e", "url": "https://api.github.com/repos/rust-lang/rust/commits/28882c44ef0cfc031a931c0ca0509707a9b4729e", "html_url": "https://github.com/rust-lang/rust/commit/28882c44ef0cfc031a931c0ca0509707a9b4729e"}], "stats": {"total": 108, "additions": 56, "deletions": 52}, "files": [{"sha": "896d37669e6f101a84ba9351a43063d47f6d3570", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02f9fd87ec56b1e84d45c96abe388f555e28faed/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f9fd87ec56b1e84d45c96abe388f555e28faed/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=02f9fd87ec56b1e84d45c96abe388f555e28faed", "patch": "@@ -1947,12 +1947,10 @@ pub fn trans_named_tuple_constructor<'a>(mut bcx: &'a Block<'a>,\n     };\n \n     if !type_is_zero_size(ccx, result_ty) {\n-        let repr = adt::represent_type(ccx, result_ty);\n-\n         match args {\n             callee::ArgExprs(exprs) => {\n                 let fields = exprs.iter().map(|x| *x).enumerate().collect::<Vec<_>>();\n-                bcx = expr::trans_adt(bcx, &*repr, disr, fields.as_slice(),\n+                bcx = expr::trans_adt(bcx, result_ty, disr, fields.as_slice(),\n                                       None, expr::SaveIn(llresult));\n             }\n             _ => ccx.sess().bug(\"expected expr as arguments for variant/struct tuple constructor\")"}, {"sha": "748274b1201e58cc82a430bd33b43f58f5ce1ae1", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 55, "deletions": 49, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/02f9fd87ec56b1e84d45c96abe388f555e28faed/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f9fd87ec56b1e84d45c96abe388f555e28faed/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=02f9fd87ec56b1e84d45c96abe388f555e28faed", "patch": "@@ -746,18 +746,17 @@ fn trans_rvalue_dps_unadjusted<'a>(bcx: &'a Block<'a>,\n             controlflow::trans_block(bcx, &**blk, dest)\n         }\n         ast::ExprStruct(_, ref fields, base) => {\n-            trans_rec_or_struct(bcx,\n-                                fields.as_slice(),\n-                                base,\n-                                expr.span,\n-                                expr.id,\n-                                dest)\n+            trans_struct(bcx,\n+                         fields.as_slice(),\n+                         base,\n+                         expr.span,\n+                         expr.id,\n+                         dest)\n         }\n         ast::ExprTup(ref args) => {\n-            let repr = adt::represent_type(bcx.ccx(), expr_ty(bcx, expr));\n             let numbered_fields: Vec<(uint, Gc<ast::Expr>)> =\n                 args.iter().enumerate().map(|(i, arg)| (i, *arg)).collect();\n-            trans_adt(bcx, &*repr, 0, numbered_fields.as_slice(), None, dest)\n+            trans_adt(bcx, expr_ty(bcx, expr), 0, numbered_fields.as_slice(), None, dest)\n         }\n         ast::ExprLit(lit) => {\n             match lit.node {\n@@ -1042,16 +1041,13 @@ pub fn with_field_tys<R>(tcx: &ty::ctxt,\n     }\n }\n \n-fn trans_rec_or_struct<'a>(\n-                       bcx: &'a Block<'a>,\n-                       fields: &[ast::Field],\n-                       base: Option<Gc<ast::Expr>>,\n-                       expr_span: codemap::Span,\n-                       id: ast::NodeId,\n-                       dest: Dest)\n-                       -> &'a Block<'a> {\n+fn trans_struct<'a>(bcx: &'a Block<'a>,\n+                    fields: &[ast::Field],\n+                    base: Option<Gc<ast::Expr>>,\n+                    expr_span: codemap::Span,\n+                    id: ast::NodeId,\n+                    dest: Dest) -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_rec\");\n-    let bcx = bcx;\n \n     let ty = node_id_type(bcx, id);\n     let tcx = bcx.tcx();\n@@ -1092,8 +1088,7 @@ fn trans_rec_or_struct<'a>(\n             }\n         };\n \n-        let repr = adt::represent_type(bcx.ccx(), ty);\n-        trans_adt(bcx, &*repr, discr, numbered_fields.as_slice(), optbase, dest)\n+        trans_adt(bcx, ty, discr, numbered_fields.as_slice(), optbase, dest)\n     })\n }\n \n@@ -1121,60 +1116,71 @@ pub struct StructBaseInfo {\n  * - `optbase` contains information on the base struct (if any) from\n  * which remaining fields are copied; see comments on `StructBaseInfo`.\n  */\n-pub fn trans_adt<'a>(bcx: &'a Block<'a>,\n-                     repr: &adt::Repr,\n+pub fn trans_adt<'a>(mut bcx: &'a Block<'a>,\n+                     ty: ty::t,\n                      discr: ty::Disr,\n                      fields: &[(uint, Gc<ast::Expr>)],\n                      optbase: Option<StructBaseInfo>,\n                      dest: Dest) -> &'a Block<'a> {\n     let _icx = push_ctxt(\"trans_adt\");\n     let fcx = bcx.fcx;\n-    let mut bcx = bcx;\n+    let repr = adt::represent_type(bcx.ccx(), ty);\n+\n+    // If we don't care about the result, just make a\n+    // temporary stack slot\n     let addr = match dest {\n-        Ignore => {\n-            for &(_i, ref e) in fields.iter() {\n-                bcx = trans_into(bcx, &**e, Ignore);\n-            }\n-            for sbi in optbase.iter() {\n-                // FIXME #7261: this moves entire base, not just certain fields\n-                bcx = trans_into(bcx, &*sbi.expr, Ignore);\n-            }\n-            return bcx;\n-        }\n-        SaveIn(pos) => pos\n+        SaveIn(pos) => pos,\n+        Ignore => alloc_ty(bcx, ty, \"temp\"),\n     };\n \n     // This scope holds intermediates that must be cleaned should\n     // failure occur before the ADT as a whole is ready.\n     let custom_cleanup_scope = fcx.push_custom_cleanup_scope();\n \n+    // First we trans the base, if we have one, to the dest\n+    for base in optbase.iter() {\n+        assert_eq!(discr, 0);\n+\n+        match ty::expr_kind(bcx.tcx(), &*base.expr) {\n+            ty::LvalueExpr => {\n+                let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &*base.expr, \"base\"));\n+                for &(i, t) in base.fields.iter() {\n+                    let datum = base_datum.get_element(\n+                            t, |srcval| adt::trans_field_ptr(bcx, &*repr, srcval, discr, i));\n+                    let dest = adt::trans_field_ptr(bcx, &*repr, addr, discr, i);\n+                    bcx = datum.store_to(bcx, dest);\n+                }\n+            },\n+            ty::RvalueDpsExpr | ty::RvalueDatumExpr => {\n+                bcx = trans_into(bcx, &*base.expr, SaveIn(addr));\n+            },\n+            ty::RvalueStmtExpr => bcx.tcx().sess.bug(\"unexpected expr kind for struct base expr\")\n+        }\n+    }\n+\n+    // Now, we just overwrite the fields we've explicity specified\n     for &(i, ref e) in fields.iter() {\n-        let dest = adt::trans_field_ptr(bcx, repr, addr, discr, i);\n+        let dest = adt::trans_field_ptr(bcx, &*repr, addr, discr, i);\n         let e_ty = expr_ty_adjusted(bcx, &**e);\n         bcx = trans_into(bcx, &**e, SaveIn(dest));\n         let scope = cleanup::CustomScope(custom_cleanup_scope);\n         fcx.schedule_lifetime_end(scope, dest);\n         fcx.schedule_drop_mem(scope, dest, e_ty);\n     }\n \n-    for base in optbase.iter() {\n-        // FIXME #6573: is it sound to use the destination's repr on the base?\n-        // And, would it ever be reasonable to be here with discr != 0?\n-        let base_datum = unpack_datum!(bcx, trans_to_lvalue(bcx, &*base.expr, \"base\"));\n-        for &(i, t) in base.fields.iter() {\n-            let datum = base_datum.get_element(\n-                t,\n-                |srcval| adt::trans_field_ptr(bcx, repr, srcval, discr, i));\n-            let dest = adt::trans_field_ptr(bcx, repr, addr, discr, i);\n-            bcx = datum.store_to(bcx, dest);\n-        }\n-    }\n-\n-    adt::trans_set_discr(bcx, repr, addr, discr);\n+    adt::trans_set_discr(bcx, &*repr, addr, discr);\n \n     fcx.pop_custom_cleanup_scope(custom_cleanup_scope);\n \n-    return bcx;\n+    // If we don't care about the result drop the temporary we made\n+    match dest {\n+        SaveIn(_) => bcx,\n+        Ignore => {\n+            bcx = glue::drop_ty(bcx, addr, ty);\n+            base::call_lifetime_end(bcx, addr);\n+            bcx\n+        }\n+    }\n }\n \n "}]}