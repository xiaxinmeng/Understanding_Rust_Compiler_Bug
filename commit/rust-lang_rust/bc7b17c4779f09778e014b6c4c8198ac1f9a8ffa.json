{"sha": "bc7b17c4779f09778e014b6c4c8198ac1f9a8ffa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjN2IxN2M0Nzc5ZjA5Nzc4ZTAxNGI2YzRjODE5OGFjMWY5YThmZmE=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-11-21T00:24:44Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-11-21T01:19:23Z"}, "message": "Fix cycle when debug-printing opaque types\n\nFixes #61577\n\nWhen printing an opaque type in non-verbose mode, we use the\n`tcx.predicates_of` query to retrieve the opaque type's bounds for\npretty-printing. However, the pervasiveness of logging within librustc\nmeans that we may already be executing `tcx.predicates_of` for the\nopaque type we're trying to print, leading to a cycle error.\n\nThis commit adds a new 'no queries' thread-local flag to the pretty\nprinter. This flag is enabled during the computation of `predicates_of`\nfor opaque types, and causes us to print the opaque type in 'verbose'\nmode (which does not require computing any additinal queries). This\nshould only affect debug logging for highly nested log messages, not any\nuser-visible output.", "tree": {"sha": "bfe7eb8b69665d0e780da1557ba08d19fe4f9c67", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bfe7eb8b69665d0e780da1557ba08d19fe4f9c67"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc7b17c4779f09778e014b6c4c8198ac1f9a8ffa", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl3V5h0ACgkQtAh+UQ6Y\nsWQUCQ//VGwCBMmDTtbxo/D6tAvA8cze9hec270bOwZ3VwlKTeo/GRYDapQtEY8v\n1YqiAYLdQfem+Lm/epz65PiOlG9On59pWb/mXdA/dj6A88MZe+Lqnc3lja6Wj0n0\nEJKipQ+IbUF0Q1SavNfWY48ISVeH2pkCiWAfnl6j1NfYDh2FJnT2UJsmGCf3Zu1E\nKX0BuzjYe68RAo/DOnHWm+9v2dSQUzkXQo2wLXNfQRbr5GgH7bsEcSTLFhwcL4N6\nIfeujGBQiacT1TQKGUsqIfdG2LXfXZ0eTfopGDEjXu5nJEDH6Oi4poQpF+LNA/Xb\nf0jPcek5L6CMIzJcbSn9ajhAtRo2YEAfRXVdAlYAidUbu7Ms5qPOSe262zfR4lL0\nijJpaLIfwMepF+Qge5H/kqwiwVk57sLd3cZaLKbI5Bl8mxfTojkVAuvYVkbMfM5b\nC5ggKRSCQAS7e4/9gBl//ZxM3NuCiAr4Du/T83q8Q9TqYmn5vPSXbog+QCZZ3d7S\nO5BSK/gcSfLgwfmR2yk91+bGP8WS/qBuHzFUqE/vPLA7+1TX+MrIJ5oOWF0fJrsJ\nqJhHTitiyybI0zagdB5lMfhKirhVu0ht6Bmpy3oRR+4KFnE8PVDwapadOk9pHYOS\nalarG5PvdF8Ur1v3UgKIYgNuwknbqxJdIyvwYkqBg0SHvAEN1ms=\n=5JWY\n-----END PGP SIGNATURE-----", "payload": "tree bfe7eb8b69665d0e780da1557ba08d19fe4f9c67\nparent f1b882b55805c342e46ee4ca3beeef1d1fa2044b\nauthor Aaron Hill <aa1ronham@gmail.com> 1574295884 -0500\ncommitter Aaron Hill <aa1ronham@gmail.com> 1574299163 -0500\n\nFix cycle when debug-printing opaque types\n\nFixes #61577\n\nWhen printing an opaque type in non-verbose mode, we use the\n`tcx.predicates_of` query to retrieve the opaque type's bounds for\npretty-printing. However, the pervasiveness of logging within librustc\nmeans that we may already be executing `tcx.predicates_of` for the\nopaque type we're trying to print, leading to a cycle error.\n\nThis commit adds a new 'no queries' thread-local flag to the pretty\nprinter. This flag is enabled during the computation of `predicates_of`\nfor opaque types, and causes us to print the opaque type in 'verbose'\nmode (which does not require computing any additinal queries). This\nshould only affect debug logging for highly nested log messages, not any\nuser-visible output.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc7b17c4779f09778e014b6c4c8198ac1f9a8ffa", "html_url": "https://github.com/rust-lang/rust/commit/bc7b17c4779f09778e014b6c4c8198ac1f9a8ffa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc7b17c4779f09778e014b6c4c8198ac1f9a8ffa/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1b882b55805c342e46ee4ca3beeef1d1fa2044b", "html_url": "https://github.com/rust-lang/rust/commit/f1b882b55805c342e46ee4ca3beeef1d1fa2044b"}], "stats": {"total": 159, "additions": 95, "deletions": 64}, "files": [{"sha": "ee05d57d239104b2b890a22647e842034a3caeaa", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 65, "deletions": 38, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/bc7b17c4779f09778e014b6c4c8198ac1f9a8ffa/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc7b17c4779f09778e014b6c4c8198ac1f9a8ffa/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=bc7b17c4779f09778e014b6c4c8198ac1f9a8ffa", "patch": "@@ -49,6 +49,24 @@ macro_rules! define_scoped_cx {\n thread_local! {\n     static FORCE_IMPL_FILENAME_LINE: Cell<bool> = Cell::new(false);\n     static SHOULD_PREFIX_WITH_CRATE: Cell<bool> = Cell::new(false);\n+    static NO_QUERIES: Cell<bool> = Cell::new(false);\n+}\n+\n+/// Avoids running any queries during any prints that occur\n+/// during the closure. This may alter the apperance of some\n+/// types (e.g. forcing verbose printing for opaque types).\n+/// This method is used during some queries (e.g. `predicates_of`\n+/// for opaque types), to ensure that any debug printing that\n+/// occurs during the query computation does not end up recursively\n+/// calling the same query.\n+pub fn with_no_queries<F: FnOnce() -> R, R>(f: F) -> R {\n+    NO_QUERIES.with(|no_queries| {\n+        let old = no_queries.get();\n+        no_queries.set(true);\n+        let result = f();\n+        no_queries.set(old);\n+        result\n+    })\n }\n \n /// Force us to name impls with just the filename/line number. We\n@@ -556,52 +574,61 @@ pub trait PrettyPrinter<'tcx>:\n             }\n             ty::Opaque(def_id, substs) => {\n                 // FIXME(eddyb) print this with `print_def_path`.\n-                if self.tcx().sess.verbose() {\n+                // We use verbose printing in 'NO_QUERIES' mode, to\n+                // avoid needing to call `predicates_of`. This should\n+                // only affect certain debug messages (e.g. messages printed\n+                // from `rustc::ty` during the computation of `tcx.predicates_of`),\n+                // and should have no effect on any compiler output.\n+                if self.tcx().sess.verbose() || NO_QUERIES.with(|q| q.get())  {\n                     p!(write(\"Opaque({:?}, {:?})\", def_id, substs));\n                     return Ok(self);\n                 }\n \n-                let def_key = self.tcx().def_key(def_id);\n-                if let Some(name) = def_key.disambiguated_data.data.get_opt_name() {\n-                    p!(write(\"{}\", name));\n-                    let mut substs = substs.iter();\n-                    // FIXME(eddyb) print this with `print_def_path`.\n-                    if let Some(first) = substs.next() {\n-                        p!(write(\"::<\"));\n-                        p!(print(first));\n-                        for subst in substs {\n-                            p!(write(\", \"), print(subst));\n+                return Ok(with_no_queries(|| {\n+\n+                    let def_key = self.tcx().def_key(def_id);\n+                    if let Some(name) = def_key.disambiguated_data.data.get_opt_name() {\n+                        p!(write(\"{}\", name));\n+                        let mut substs = substs.iter();\n+                        // FIXME(eddyb) print this with `print_def_path`.\n+                        if let Some(first) = substs.next() {\n+                            p!(write(\"::<\"));\n+                            p!(print(first));\n+                            for subst in substs {\n+                                p!(write(\", \"), print(subst));\n+                            }\n+                            p!(write(\">\"));\n                         }\n-                        p!(write(\">\"));\n+                        return Ok(self);\n                     }\n-                    return Ok(self);\n-                }\n-                // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n-                // by looking up the projections associated with the def_id.\n-                let bounds = self.tcx().predicates_of(def_id).instantiate(self.tcx(), substs);\n-\n-                let mut first = true;\n-                let mut is_sized = false;\n-                p!(write(\"impl\"));\n-                for predicate in bounds.predicates {\n-                    if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n-                        // Don't print +Sized, but rather +?Sized if absent.\n-                        if Some(trait_ref.def_id()) == self.tcx().lang_items().sized_trait() {\n-                            is_sized = true;\n-                            continue;\n-                        }\n+                    // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n+                    // by looking up the projections associated with the def_id.\n+                    let bounds = self.tcx().predicates_of(def_id).instantiate(self.tcx(), substs);\n+\n+                    let mut first = true;\n+                    let mut is_sized = false;\n+                    p!(write(\"impl\"));\n+                    for predicate in bounds.predicates {\n+                        if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n+                            // Don't print +Sized, but rather +?Sized if absent.\n+                            if Some(trait_ref.def_id()) == self.tcx().lang_items().sized_trait() {\n+                                is_sized = true;\n+                                continue;\n+                            }\n \n-                        p!(\n-                                write(\"{}\", if first { \" \" } else { \"+\" }),\n-                                print(trait_ref));\n-                        first = false;\n+                            p!(\n+                                    write(\"{}\", if first { \" \" } else { \"+\" }),\n+                                    print(trait_ref));\n+                            first = false;\n+                        }\n                     }\n-                }\n-                if !is_sized {\n-                    p!(write(\"{}?Sized\", if first { \" \" } else { \"+\" }));\n-                } else if first {\n-                    p!(write(\" Sized\"));\n-                }\n+                    if !is_sized {\n+                        p!(write(\"{}?Sized\", if first { \" \" } else { \"+\" }));\n+                    } else if first {\n+                        p!(write(\" Sized\"));\n+                    }\n+                    Ok(self)\n+                })?);\n             }\n             ty::Str => p!(write(\"str\")),\n             ty::Generator(did, substs, movability) => {"}, {"sha": "f4c8763f87910aae1f6e6a8f2b779277adf07d9d", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/bc7b17c4779f09778e014b6c4c8198ac1f9a8ffa/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc7b17c4779f09778e014b6c4c8198ac1f9a8ffa/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=bc7b17c4779f09778e014b6c4c8198ac1f9a8ffa", "patch": "@@ -2056,20 +2056,22 @@ fn explicit_predicates_of(\n \n         Node::ImplItem(item) => match item.kind {\n             ImplItemKind::OpaqueTy(ref bounds) => {\n-                let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                let opaque_ty = tcx.mk_opaque(def_id, substs);\n-\n-                // Collect the bounds, i.e., the `A + B + 'c` in `impl A + B + 'c`.\n-                let bounds = AstConv::compute_bounds(\n-                    &icx,\n-                    opaque_ty,\n-                    bounds,\n-                    SizedByDefault::Yes,\n-                    tcx.def_span(def_id),\n-                );\n+                ty::print::with_no_queries(|| {\n+                    let substs = InternalSubsts::identity_for_item(tcx, def_id);\n+                    let opaque_ty = tcx.mk_opaque(def_id, substs);\n+\n+                    // Collect the bounds, i.e., the `A + B + 'c` in `impl A + B + 'c`.\n+                    let bounds = AstConv::compute_bounds(\n+                        &icx,\n+                        opaque_ty,\n+                        bounds,\n+                        SizedByDefault::Yes,\n+                        tcx.def_span(def_id),\n+                    );\n \n-                predicates.extend(bounds.predicates(tcx, opaque_ty));\n-                &item.generics\n+                    predicates.extend(bounds.predicates(tcx, opaque_ty));\n+                    &item.generics\n+                })\n             }\n             _ => &item.generics,\n         },\n@@ -2102,19 +2104,21 @@ fn explicit_predicates_of(\n                     ref generics,\n                     origin: _,\n                 }) => {\n-                    let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                    let opaque_ty = tcx.mk_opaque(def_id, substs);\n-\n-                    // Collect the bounds, i.e., the `A + B + 'c` in `impl A + B + 'c`.\n-                    let bounds = AstConv::compute_bounds(\n-                        &icx,\n-                        opaque_ty,\n-                        bounds,\n-                        SizedByDefault::Yes,\n-                        tcx.def_span(def_id),\n-                    );\n+                    let bounds_predicates = ty::print::with_no_queries(|| {\n+                        let substs = InternalSubsts::identity_for_item(tcx, def_id);\n+                        let opaque_ty = tcx.mk_opaque(def_id, substs);\n+\n+                        // Collect the bounds, i.e., the `A + B + 'c` in `impl A + B + 'c`.\n+                        let bounds = AstConv::compute_bounds(\n+                            &icx,\n+                            opaque_ty,\n+                            bounds,\n+                            SizedByDefault::Yes,\n+                            tcx.def_span(def_id),\n+                        );\n \n-                    let bounds_predicates = bounds.predicates(tcx, opaque_ty);\n+                        bounds.predicates(tcx, opaque_ty)\n+                    });\n                     if impl_trait_fn.is_some() {\n                         // opaque types\n                         return ty::GenericPredicates {\n@@ -2124,7 +2128,7 @@ fn explicit_predicates_of(\n                     } else {\n                         // named opaque types\n                         predicates.extend(bounds_predicates);\n-                        generics\n+                        generics.clone()\n                     }\n                 }\n "}]}