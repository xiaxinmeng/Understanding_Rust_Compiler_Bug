{"sha": "6768d0dd72ddde27f7b297f1eec8e58b9eeaaedc", "node_id": "C_kwDOAAsO6NoAKDY3NjhkMGRkNzJkZGRlMjdmN2IyOTdmMWVlYzhlNThiOWVlYWFlZGM", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-10-25T17:13:33Z"}, "committer": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2022-12-01T17:45:59Z"}, "message": "Booleans have been removed from Cranelift", "tree": {"sha": "b60a39b3d510005a1121ffafb8c494fa35c7a60f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b60a39b3d510005a1121ffafb8c494fa35c7a60f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6768d0dd72ddde27f7b297f1eec8e58b9eeaaedc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6768d0dd72ddde27f7b297f1eec8e58b9eeaaedc", "html_url": "https://github.com/rust-lang/rust/commit/6768d0dd72ddde27f7b297f1eec8e58b9eeaaedc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6768d0dd72ddde27f7b297f1eec8e58b9eeaaedc/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70ba23b109f84e2f88ac5057297c527146a4a303", "url": "https://api.github.com/repos/rust-lang/rust/commits/70ba23b109f84e2f88ac5057297c527146a4a303", "html_url": "https://github.com/rust-lang/rust/commit/70ba23b109f84e2f88ac5057297c527146a4a303"}], "stats": {"total": 48, "additions": 9, "deletions": 39}, "files": [{"sha": "41e58d34b0070585ca96e2f2d54a23d3f0604ee6", "filename": "src/base.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6768d0dd72ddde27f7b297f1eec8e58b9eeaaedc/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6768d0dd72ddde27f7b297f1eec8e58b9eeaaedc/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=6768d0dd72ddde27f7b297f1eec8e58b9eeaaedc", "patch": "@@ -388,11 +388,9 @@ fn codegen_fn_body(fx: &mut FunctionCx<'_, '_, '_>, start_block: Block) {\n                         _ => unreachable!(\"{:?}\", targets),\n                     };\n \n-                    let discr = crate::optimize::peephole::maybe_unwrap_bint(&mut fx.bcx, discr);\n                     let (discr, is_inverted) =\n                         crate::optimize::peephole::maybe_unwrap_bool_not(&mut fx.bcx, discr);\n                     let test_zero = if is_inverted { !test_zero } else { test_zero };\n-                    let discr = crate::optimize::peephole::maybe_unwrap_bint(&mut fx.bcx, discr);\n                     if let Some(taken) = crate::optimize::peephole::maybe_known_branch_taken(\n                         &fx.bcx, discr, test_zero,\n                     ) {\n@@ -569,7 +567,7 @@ fn codegen_stmt<'tcx>(\n                         UnOp::Not => match layout.ty.kind() {\n                             ty::Bool => {\n                                 let res = fx.bcx.ins().icmp_imm(IntCC::Equal, val, 0);\n-                                CValue::by_val(fx.bcx.ins().bint(types::I8, res), layout)\n+                                CValue::by_val(res, layout)\n                             }\n                             ty::Uint(_) | ty::Int(_) => {\n                                 CValue::by_val(fx.bcx.ins().bnot(val), layout)"}, {"sha": "5c90ef8588bd4ccff68ff9704576c671941c98ab", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6768d0dd72ddde27f7b297f1eec8e58b9eeaaedc/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6768d0dd72ddde27f7b297f1eec8e58b9eeaaedc/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=6768d0dd72ddde27f7b297f1eec8e58b9eeaaedc", "patch": "@@ -197,7 +197,9 @@ fn bool_to_zero_or_max_uint<'tcx>(\n         ty => ty,\n     };\n \n-    let val = fx.bcx.ins().bint(int_ty, val);\n+    let val = if int_ty == types::I8 { val } else { fx.bcx.ins().uextend(int_ty, val) };\n+\n+    // FIXME use bmask instead\n     let mut res = fx.bcx.ins().ineg(val);\n \n     if ty.is_float() {\n@@ -938,8 +940,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n             let old = fx.bcx.ins().atomic_cas(MemFlags::trusted(), ptr, test_old, new);\n             let is_eq = fx.bcx.ins().icmp(IntCC::Equal, old, test_old);\n \n-            let ret_val =\n-                CValue::by_val_pair(old, fx.bcx.ins().bint(types::I8, is_eq), ret.layout());\n+            let ret_val = CValue::by_val_pair(old, is_eq, ret.layout());\n             ret.write_cvalue(fx, ret_val)\n         }\n \n@@ -1261,8 +1262,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                 flags.set_notrap();\n                 let lhs_val = fx.bcx.ins().load(clty, flags, lhs_ref, 0);\n                 let rhs_val = fx.bcx.ins().load(clty, flags, rhs_ref, 0);\n-                let eq = fx.bcx.ins().icmp(IntCC::Equal, lhs_val, rhs_val);\n-                fx.bcx.ins().bint(types::I8, eq)\n+                fx.bcx.ins().icmp(IntCC::Equal, lhs_val, rhs_val)\n             } else {\n                 // Just call `memcmp` (like slices do in core) when the\n                 // size is too large or it's not a power-of-two.\n@@ -1272,8 +1272,7 @@ fn codegen_regular_intrinsic_call<'tcx>(\n                 let returns = vec![AbiParam::new(types::I32)];\n                 let args = &[lhs_ref, rhs_ref, bytes_val];\n                 let cmp = fx.lib_call(\"memcmp\", params, returns, args)[0];\n-                let eq = fx.bcx.ins().icmp_imm(IntCC::Equal, cmp, 0);\n-                fx.bcx.ins().bint(types::I8, eq)\n+                fx.bcx.ins().icmp_imm(IntCC::Equal, cmp, 0)\n             };\n             ret.write_cvalue(fx, CValue::by_val(is_eq_value, ret.layout()));\n         }"}, {"sha": "567c12fe316d718545daac4fec26a148254729ea", "filename": "src/intrinsics/simd.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6768d0dd72ddde27f7b297f1eec8e58b9eeaaedc/src%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6768d0dd72ddde27f7b297f1eec8e58b9eeaaedc/src%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fsimd.rs?ref=6768d0dd72ddde27f7b297f1eec8e58b9eeaaedc", "patch": "@@ -112,10 +112,7 @@ pub(super) fn codegen_simd_intrinsic_call<'tcx>(\n                     _ => unreachable!(),\n                 };\n \n-                let ty = fx.clif_type(res_lane_ty).unwrap();\n-\n-                let res_lane = fx.bcx.ins().bint(ty, res_lane);\n-                fx.bcx.ins().ineg(res_lane)\n+                bool_to_zero_or_max_uint(fx, res_lane_ty, res_lane)\n             });\n         }\n "}, {"sha": "afacbec644582195440bcb8e3e9c58d6d99b3c74", "filename": "src/num.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6768d0dd72ddde27f7b297f1eec8e58b9eeaaedc/src%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6768d0dd72ddde27f7b297f1eec8e58b9eeaaedc/src%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnum.rs?ref=6768d0dd72ddde27f7b297f1eec8e58b9eeaaedc", "patch": "@@ -49,7 +49,6 @@ fn codegen_compare_bin_op<'tcx>(\n ) -> CValue<'tcx> {\n     let intcc = crate::num::bin_op_to_intcc(bin_op, signed).unwrap();\n     let val = fx.bcx.ins().icmp(intcc, lhs, rhs);\n-    let val = fx.bcx.ins().bint(types::I8, val);\n     CValue::by_val(val, fx.layout_of(fx.tcx.types.bool))\n }\n \n@@ -290,8 +289,6 @@ pub(crate) fn codegen_checked_int_binop<'tcx>(\n         _ => bug!(\"binop {:?} on checked int/uint lhs: {:?} rhs: {:?}\", bin_op, in_lhs, in_rhs),\n     };\n \n-    let has_overflow = fx.bcx.ins().bint(types::I8, has_overflow);\n-\n     let out_layout = fx.layout_of(fx.tcx.mk_tup([in_lhs.layout().ty, fx.tcx.types.bool].iter()));\n     CValue::by_val_pair(res, has_overflow, out_layout)\n }\n@@ -368,7 +365,6 @@ pub(crate) fn codegen_float_binop<'tcx>(\n                 _ => unreachable!(),\n             };\n             let val = fx.bcx.ins().fcmp(fltcc, lhs, rhs);\n-            let val = fx.bcx.ins().bint(types::I8, val);\n             return CValue::by_val(val, fx.layout_of(fx.tcx.types.bool));\n         }\n         _ => unreachable!(\"{:?}({:?}, {:?})\", bin_op, in_lhs, in_rhs),\n@@ -440,7 +436,7 @@ pub(crate) fn codegen_ptr_binop<'tcx>(\n             _ => panic!(\"bin_op {:?} on ptr\", bin_op),\n         };\n \n-        CValue::by_val(fx.bcx.ins().bint(types::I8, res), fx.layout_of(fx.tcx.types.bool))\n+        CValue::by_val(res, fx.layout_of(fx.tcx.types.bool))\n     }\n }\n "}, {"sha": "7f45bbd8f28136a43b8271ba5f3e2755d19d522d", "filename": "src/optimize/peephole.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6768d0dd72ddde27f7b297f1eec8e58b9eeaaedc/src%2Foptimize%2Fpeephole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6768d0dd72ddde27f7b297f1eec8e58b9eeaaedc/src%2Foptimize%2Fpeephole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foptimize%2Fpeephole.rs?ref=6768d0dd72ddde27f7b297f1eec8e58b9eeaaedc", "patch": "@@ -3,19 +3,6 @@\n use cranelift_codegen::ir::{condcodes::IntCC, InstructionData, Opcode, Value, ValueDef};\n use cranelift_frontend::FunctionBuilder;\n \n-/// If the given value was produced by a `bint` instruction, return it's input, otherwise return the\n-/// given value.\n-pub(crate) fn maybe_unwrap_bint(bcx: &mut FunctionBuilder<'_>, arg: Value) -> Value {\n-    if let ValueDef::Result(arg_inst, 0) = bcx.func.dfg.value_def(arg) {\n-        match bcx.func.dfg[arg_inst] {\n-            InstructionData::Unary { opcode: Opcode::Bint, arg } => arg,\n-            _ => arg,\n-        }\n-    } else {\n-        arg\n-    }\n-}\n-\n /// If the given value was produced by the lowering of `Rvalue::Not` return the input and true,\n /// otherwise return the given value and false.\n pub(crate) fn maybe_unwrap_bool_not(bcx: &mut FunctionBuilder<'_>, arg: Value) -> (Value, bool) {\n@@ -48,13 +35,6 @@ pub(crate) fn maybe_known_branch_taken(\n     };\n \n     match bcx.func.dfg[arg_inst] {\n-        InstructionData::UnaryBool { opcode: Opcode::Bconst, imm } => {\n-            if test_zero {\n-                Some(!imm)\n-            } else {\n-                Some(imm)\n-            }\n-        }\n         InstructionData::UnaryImm { opcode: Opcode::Iconst, imm } => {\n             if test_zero {\n                 Some(imm.bits() == 0)"}]}