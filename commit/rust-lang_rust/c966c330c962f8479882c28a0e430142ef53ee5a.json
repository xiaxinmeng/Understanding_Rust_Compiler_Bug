{"sha": "c966c330c962f8479882c28a0e430142ef53ee5a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5NjZjMzMwYzk2MmY4NDc5ODgyYzI4YTBlNDMwMTQyZWY1M2VlNWE=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-03-18T02:01:50Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2016-03-26T17:33:14Z"}, "message": "std: Rewrite Once with poisoning\n\nThis commit rewrites the `std::sync::Once` primitive with poisoning in mind in\nlight of #31688. Currently a panic in the initialization closure will cause\nfuture initialization closures to run, but the purpose of a Once is usually to\ninitialize some global state so it's highly likely that the global state is\ncorrupt if a panic happened. The same strategy of a mutex is taken where a panic\nis propagated by default.\n\nA new API, `call_once_force`, was added to subvert panics like is available on\nMutex as well (for when panicking is handled internally).\n\nAdding this support was a significant enough change to the implementation that\nit was just completely rewritten from scratch, primarily to avoid using a\n`StaticMutex` which needs to have `destroy()` called on it at some point (a pain\nto do).\n\nCloses #31688", "tree": {"sha": "d895008cc748707d97f6be396ab0bf64a07e15e9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d895008cc748707d97f6be396ab0bf64a07e15e9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c966c330c962f8479882c28a0e430142ef53ee5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c966c330c962f8479882c28a0e430142ef53ee5a", "html_url": "https://github.com/rust-lang/rust/commit/c966c330c962f8479882c28a0e430142ef53ee5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c966c330c962f8479882c28a0e430142ef53ee5a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcfb8d72e99425686376298fd793715f35b5d512", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcfb8d72e99425686376298fd793715f35b5d512", "html_url": "https://github.com/rust-lang/rust/commit/dcfb8d72e99425686376298fd793715f35b5d512"}], "stats": {"total": 419, "additions": 363, "deletions": 56}, "files": [{"sha": "e673879d20db28c887149b8c48e5d1b222244359", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 363, "deletions": 56, "changes": 419, "blob_url": "https://github.com/rust-lang/rust/blob/c966c330c962f8479882c28a0e430142ef53ee5a/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c966c330c962f8479882c28a0e430142ef53ee5a/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=c966c330c962f8479882c28a0e430142ef53ee5a", "patch": "@@ -13,9 +13,60 @@\n //! This primitive is meant to be used to run one-time initialization. An\n //! example use case would be for initializing an FFI library.\n \n-use isize;\n-use sync::atomic::{AtomicIsize, Ordering};\n-use sync::StaticMutex;\n+// A \"once\" is a relatively simple primitive, and it's also typically provided\n+// by the OS as well (see `pthread_once` or `InitOnceExecuteOnce`). The OS\n+// primitives, however, tend to have surprising restrictions, such as the Unix\n+// one doesn't allow an argument to be passed to the function.\n+//\n+// As a result, we end up implementing it ourselves in the standard library.\n+// This also gives us the opportunity to optimize the implementation a bit which\n+// should help the fast path on call sites. Consequently, let's explain how this\n+// primitive works now!\n+//\n+// So to recap, the guarantees of a Once are that it will call the\n+// initialization closure at most once, and it will never return until the one\n+// that's running has finished running. This means that we need some form of\n+// blocking here while the custom callback is running at the very least.\n+// Additionally, we add on the restriction of **poisoning**. Whenever an\n+// initialization closure panics, the Once enters a \"poisoned\" state which means\n+// that all future calls will immediately panic as well.\n+//\n+// So to implement this, one might first reach for a `StaticMutex`, but those\n+// unfortunately need to be deallocated (e.g. call `destroy()`) to free memory\n+// on all OSes (some of the BSDs allocate memory for mutexes). It also gets a\n+// lot harder with poisoning to figure out when the mutex needs to be\n+// deallocated because it's not after the closure finishes, but after the first\n+// successful closure finishes.\n+//\n+// All in all, this is instead implemented with atomics and lock-free\n+// operations! Whee! Each `Once` has one word of atomic state, and this state is\n+// CAS'd on to determine what to do. There are four possible state of a `Once`:\n+//\n+// * Incomplete - no initialization has run yet, and no thread is currently\n+//                using the Once.\n+// * Poisoned - some thread has previously attempted to initialize the Once, but\n+//              it panicked, so the Once is now poisoned. There are no other\n+//              threads currently accessing this Once.\n+// * Running - some thread is currently attempting to run initialization. It may\n+//             succeed, so all future threads need to wait for it to finish.\n+//             Note that this state is accompanied with a payload, described\n+//             below.\n+// * Complete - initialization has completed and all future calls should finish\n+//              immediately.\n+//\n+// With 4 states we need 2 bits to encode this, and we use the remaining bits\n+// in the word we have allocated as a queue of threads waiting for the thread\n+// responsible for entering the RUNNING state. This queue is just a linked list\n+// of Waiter nodes which is monotonically increasing in size. Each node is\n+// allocated on the stack, and whenever the running closure finishes it will\n+// consume the entire queue and notify all waiters they should try again.\n+//\n+// You'll find a few more details in the implementation, but that's the gist of\n+// it!\n+\n+use marker;\n+use sync::atomic::{AtomicUsize, AtomicBool, Ordering};\n+use thread::{self, Thread};\n \n /// A synchronization primitive which can be used to run a one-time global\n /// initialization. Useful for one-time initialization for FFI or related\n@@ -35,23 +86,62 @@ use sync::StaticMutex;\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Once {\n-    mutex: StaticMutex,\n-    cnt: AtomicIsize,\n-    lock_cnt: AtomicIsize,\n+    // This `state` word is actually an encoded version of just a pointer to a\n+    // `Waiter`, so we add the `PhantomData` appropriately.\n+    state: AtomicUsize,\n+    _marker: marker::PhantomData<*mut Waiter>,\n+}\n+\n+// The `PhantomData` of a raw pointer removes these two auto traits, but we\n+// enforce both below in the implementation so this should be safe to add.\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl Sync for Once {}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+unsafe impl Send for Once {}\n+\n+/// State yielded to the `call_once_force` method which can be used to query\n+/// whether the `Once` was previously poisoned or not.\n+#[unstable(feature = \"once_poison\", issue = \"31688\")]\n+pub struct OnceState {\n+    poisoned: bool,\n }\n \n /// Initialization value for static `Once` values.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const ONCE_INIT: Once = Once::new();\n \n+// Four states that a Once can be in, encoded into the lower bits of `state` in\n+// the Once structure.\n+const INCOMPLETE: usize = 0x0;\n+const POISONED: usize = 0x1;\n+const RUNNING: usize = 0x2;\n+const COMPLETE: usize = 0x3;\n+\n+// Mask to learn about the state. All other bits are the queue of waiters if\n+// this is in the RUNNING state.\n+const STATE_MASK: usize = 0x3;\n+\n+// Representation of a node in the linked list of waiters in the RUNNING state.\n+struct Waiter {\n+    thread: Option<Thread>,\n+    signaled: AtomicBool,\n+    next: *mut Waiter,\n+}\n+\n+// Helper struct used to clean up after a closure call with a `Drop`\n+// implementation to also run on panic.\n+struct Finish {\n+    panicked: bool,\n+    me: &'static Once,\n+}\n+\n impl Once {\n     /// Creates a new `Once` value.\n     #[stable(feature = \"once_new\", since = \"1.2.0\")]\n     pub const fn new() -> Once {\n         Once {\n-            mutex: StaticMutex::new(),\n-            cnt: AtomicIsize::new(0),\n-            lock_cnt: AtomicIsize::new(0),\n+            state: AtomicUsize::new(INCOMPLETE),\n+            _marker: marker::PhantomData,\n         }\n     }\n \n@@ -68,73 +158,223 @@ impl Once {\n     /// be reliably observed by other threads at this point (there is a\n     /// happens-before relation between the closure and code executing after the\n     /// return).\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::{Once, ONCE_INIT};\n+    ///\n+    /// static mut VAL: usize = 0;\n+    /// static INIT: Once = ONCE_INIT;\n+    ///\n+    /// // Accessing a `static mut` is unsafe much of the time, but if we do so\n+    /// // in a synchronized fashion (e.g. write once or read all) then we're\n+    /// // good to go!\n+    /// //\n+    /// // This function will only call `expensive_computation` once, and will\n+    /// // otherwise always return the value returned from the first invocation.\n+    /// fn get_cached_val() -> usize {\n+    ///     unsafe {\n+    ///         INIT.call_once(|| {\n+    ///             VAL = expensive_computation();\n+    ///         });\n+    ///         VAL\n+    ///     }\n+    /// }\n+    ///\n+    /// fn expensive_computation() -> usize {\n+    ///     // ...\n+    /// # 2\n+    /// }\n+    /// ```\n+    ///\n+    /// # Panics\n+    ///\n+    /// The closure `f` will only be executed once if this is called\n+    /// concurrently amongst many threads. If that closure panics, however, then\n+    /// it will *poison* this `Once` instance, causing all future invocations of\n+    /// `call_once` to also panic.\n+    ///\n+    /// This is similar to [poisoning with mutexes][poison].\n+    ///\n+    /// [poison]: struct.Mutex.html#poisoning\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn call_once<F>(&'static self, f: F) where F: FnOnce() {\n-        // Optimize common path: load is much cheaper than fetch_add.\n-        if self.cnt.load(Ordering::SeqCst) < 0 {\n+        // Fast path, just see if we've completed initialization.\n+        if self.state.load(Ordering::SeqCst) == COMPLETE {\n             return\n         }\n \n-        // Implementation-wise, this would seem like a fairly trivial primitive.\n-        // The stickler part is where our mutexes currently require an\n-        // allocation, and usage of a `Once` shouldn't leak this allocation.\n-        //\n-        // This means that there must be a deterministic destroyer of the mutex\n-        // contained within (because it's not needed after the initialization\n-        // has run).\n-        //\n-        // The general scheme here is to gate all future threads once\n-        // initialization has completed with a \"very negative\" count, and to\n-        // allow through threads to lock the mutex if they see a non negative\n-        // count. For all threads grabbing the mutex, exactly one of them should\n-        // be responsible for unlocking the mutex, and this should only be done\n-        // once everyone else is done with the mutex.\n-        //\n-        // This atomicity is achieved by swapping a very negative value into the\n-        // shared count when the initialization routine has completed. This will\n-        // read the number of threads which will at some point attempt to\n-        // acquire the mutex. This count is then squirreled away in a separate\n-        // variable, and the last person on the way out of the mutex is then\n-        // responsible for destroying the mutex.\n-        //\n-        // It is crucial that the negative value is swapped in *after* the\n-        // initialization routine has completed because otherwise new threads\n-        // calling `call_once` will return immediately before the initialization\n-        // has completed.\n-\n-        let prev = self.cnt.fetch_add(1, Ordering::SeqCst);\n-        if prev < 0 {\n-            // Make sure we never overflow, we'll never have isize::MIN\n-            // simultaneous calls to `call_once` to make this value go back to 0\n-            self.cnt.store(isize::MIN, Ordering::SeqCst);\n+        let mut f = Some(f);\n+        self.call_inner(false, &mut |_| f.take().unwrap()());\n+    }\n+\n+    /// Performs the same function as `call_once` except ignores poisoning.\n+    ///\n+    /// If this `Once` has been poisoned (some initialization panicked) then\n+    /// this function will continue to attempt to call initialization functions\n+    /// until one of them doesn't panic.\n+    ///\n+    /// The closure `f` is yielded a structure which can be used to query the\n+    /// state of this `Once` (whether initialization has previously panicked or\n+    /// not).\n+    /// poisoned or not.\n+    #[unstable(feature = \"once_poison\", issue = \"31688\")]\n+    pub fn call_once_force<F>(&'static self, f: F) where F: FnOnce(&OnceState) {\n+        // same as above, just with a different parameter to `call_inner`.\n+        if self.state.load(Ordering::SeqCst) == COMPLETE {\n             return\n         }\n \n-        // If the count is negative, then someone else finished the job,\n-        // otherwise we run the job and record how many people will try to grab\n-        // this lock\n-        let guard = self.mutex.lock();\n-        if self.cnt.load(Ordering::SeqCst) > 0 {\n-            f();\n-            let prev = self.cnt.swap(isize::MIN, Ordering::SeqCst);\n-            self.lock_cnt.store(prev, Ordering::SeqCst);\n+        let mut f = Some(f);\n+        self.call_inner(true, &mut |p| {\n+            f.take().unwrap()(&OnceState { poisoned: p })\n+        });\n+    }\n+\n+    // This is a non-generic function to reduce the monomorphization cost of\n+    // using `call_once` (this isn't exactly a trivial or small implementation).\n+    //\n+    // Additionally, this is tagged with `#[cold]` as it should indeed be cold\n+    // and it helps let LLVM know that calls to this function should be off the\n+    // fast path. Essentially, this should help generate more straight line code\n+    // in LLVM.\n+    //\n+    // Finally, this takes an `FnMut` instead of a `FnOnce` because there's\n+    // currently no way to take an `FnOnce` and call it via virtual dispatch\n+    // without some allocation overhead.\n+    #[cold]\n+    fn call_inner(&'static self,\n+                  ignore_poisoning: bool,\n+                  mut init: &mut FnMut(bool)) {\n+        let mut state = self.state.load(Ordering::SeqCst);\n+\n+        'outer: loop {\n+            match state {\n+                // If we're complete, then there's nothing to do, we just\n+                // jettison out as we shouldn't run the closure.\n+                COMPLETE => return,\n+\n+                // If we're poisoned and we're not in a mode to ignore\n+                // poisoning, then we panic here to propagate the poison.\n+                POISONED if !ignore_poisoning => {\n+                    panic!(\"Once instance has previously been poisoned\");\n+                }\n+\n+                // Otherwise if we see a poisoned or otherwise incomplete state\n+                // we will attempt to move ourselves into the RUNNING state. If\n+                // we succeed, then the queue of waiters starts at null (all 0\n+                // bits).\n+                POISONED |\n+                INCOMPLETE => {\n+                    let old = self.state.compare_and_swap(state, RUNNING,\n+                                                          Ordering::SeqCst);\n+                    if old != state {\n+                        state = old;\n+                        continue\n+                    }\n+\n+                    // Run the initialization routine, letting it know if we're\n+                    // poisoned or not. The `Finish` struct is then dropped, and\n+                    // the `Drop` implementation here is responsible for waking\n+                    // up other waiters both in the normal return and panicking\n+                    // case.\n+                    let mut complete = Finish {\n+                        panicked: true,\n+                        me: self,\n+                    };\n+                    init(state == POISONED);\n+                    complete.panicked = false;\n+                    return\n+                }\n+\n+                // All other values we find should correspond to the RUNNING\n+                // state with an encoded waiter list in the more significant\n+                // bits. We attempt to enqueue ourselves by moving us to the\n+                // head of the list and bail out if we ever see a state that's\n+                // not RUNNING.\n+                _ => {\n+                    assert!(state & STATE_MASK == RUNNING);\n+                    let mut node = Waiter {\n+                        thread: Some(thread::current()),\n+                        signaled: AtomicBool::new(false),\n+                        next: 0 as *mut Waiter,\n+                    };\n+                    let me = &mut node as *mut Waiter as usize;\n+                    assert!(me & STATE_MASK == 0);\n+\n+                    while state & STATE_MASK == RUNNING {\n+                        node.next = (state & !STATE_MASK) as *mut Waiter;\n+                        let old = self.state.compare_and_swap(state,\n+                                                              me | RUNNING,\n+                                                              Ordering::SeqCst);\n+                        if old != state {\n+                            state = old;\n+                            continue\n+                        }\n+\n+                        // Once we've enqueued ourselves, wait in a loop.\n+                        // Aftewards reload the state and continue with what we\n+                        // were doing from before.\n+                        while !node.signaled.load(Ordering::SeqCst) {\n+                            thread::park();\n+                        }\n+                        state = self.state.load(Ordering::SeqCst);\n+                        continue 'outer\n+                    }\n+                }\n+            }\n         }\n-        drop(guard);\n+    }\n+}\n \n-        // Last one out cleans up after everyone else, no leaks!\n-        if self.lock_cnt.fetch_add(-1, Ordering::SeqCst) == 1 {\n-            unsafe { self.mutex.destroy() }\n+impl Drop for Finish {\n+    fn drop(&mut self) {\n+        // Swap out our state with however we finished. We should only ever see\n+        // an old state which was RUNNING.\n+        let queue = if self.panicked {\n+            self.me.state.swap(POISONED, Ordering::SeqCst)\n+        } else {\n+            self.me.state.swap(COMPLETE, Ordering::SeqCst)\n+        };\n+        assert_eq!(queue & STATE_MASK, RUNNING);\n+\n+        // Decode the RUNNING to a list of waiters, then walk that entire list\n+        // and wake them up. Note that it is crucial that after we store `true`\n+        // in the node it can be free'd! As a result we load the `thread` to\n+        // signal ahead of time and then unpark it after the store.\n+        unsafe {\n+            let mut queue = (queue & !STATE_MASK) as *mut Waiter;\n+            while !queue.is_null() {\n+                let next = (*queue).next;\n+                let thread = (*queue).thread.take().unwrap();\n+                (*queue).signaled.store(true, Ordering::SeqCst);\n+                thread.unpark();\n+                queue = next;\n+            }\n         }\n     }\n }\n \n+impl OnceState {\n+    /// Returns whether the associated `Once` has been poisoned.\n+    ///\n+    /// Once an initalization routine for a `Once` has panicked it will forever\n+    /// indicate to future forced initialization routines that it is poisoned.\n+    #[unstable(feature = \"once_poison\", issue = \"31688\")]\n+    pub fn poisoned(&self) -> bool {\n+        self.poisoned\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use prelude::v1::*;\n \n+    use panic;\n+    use sync::mpsc::channel;\n     use thread;\n     use super::Once;\n-    use sync::mpsc::channel;\n \n     #[test]\n     fn smoke_once() {\n@@ -179,4 +419,71 @@ mod tests {\n             rx.recv().unwrap();\n         }\n     }\n+\n+    #[test]\n+    fn poison_bad() {\n+        static O: Once = Once::new();\n+\n+        // poison the once\n+        let t = panic::recover(|| {\n+            O.call_once(|| panic!());\n+        });\n+        assert!(t.is_err());\n+\n+        // poisoning propagates\n+        let t = panic::recover(|| {\n+            O.call_once(|| {});\n+        });\n+        assert!(t.is_err());\n+\n+        // we can subvert poisoning, however\n+        let mut called = false;\n+        O.call_once_force(|p| {\n+            called = true;\n+            assert!(p.poisoned())\n+        });\n+        assert!(called);\n+\n+        // once any success happens, we stop propagating the poison\n+        O.call_once(|| {});\n+    }\n+\n+    #[test]\n+    fn wait_for_force_to_finish() {\n+        static O: Once = Once::new();\n+\n+        // poison the once\n+        let t = panic::recover(|| {\n+            O.call_once(|| panic!());\n+        });\n+        assert!(t.is_err());\n+\n+        // make sure someone's waiting inside the once via a force\n+        let (tx1, rx1) = channel();\n+        let (tx2, rx2) = channel();\n+        let t1 = thread::spawn(move || {\n+            O.call_once_force(|p| {\n+                assert!(p.poisoned());\n+                tx1.send(()).unwrap();\n+                rx2.recv().unwrap();\n+            });\n+        });\n+\n+        rx1.recv().unwrap();\n+\n+        // put another waiter on the once\n+        let t2 = thread::spawn(|| {\n+            let mut called = false;\n+            O.call_once(|| {\n+                called = true;\n+            });\n+            assert!(!called);\n+        });\n+\n+        tx2.send(()).unwrap();\n+\n+        assert!(t1.join().is_ok());\n+        assert!(t2.join().is_ok());\n+\n+    }\n }"}]}