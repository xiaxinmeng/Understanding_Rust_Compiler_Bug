{"sha": "07e968b640e8ff76fa8be4b48b70ab80ea577800", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3ZTk2OGI2NDBlOGZmNzZmYThiZTRiNDhiNzBhYjgwZWE1Nzc4MDA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-27T16:32:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-27T16:32:23Z"}, "message": "Auto merge of #76269 - ayrtonm:function-reference-lint, r=oli-obk\n\nadded a lint against function references\n\nthis lint suggests casting function references to `*const ()`\ncloses #75239\nr? `@RalfJung`", "tree": {"sha": "ba7c798f46d3c121615d5f2be68633028d776e50", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba7c798f46d3c121615d5f2be68633028d776e50"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/07e968b640e8ff76fa8be4b48b70ab80ea577800", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/07e968b640e8ff76fa8be4b48b70ab80ea577800", "html_url": "https://github.com/rust-lang/rust/commit/07e968b640e8ff76fa8be4b48b70ab80ea577800", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/07e968b640e8ff76fa8be4b48b70ab80ea577800/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a71e45411881dda12a704d7491428d8a23347c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a71e45411881dda12a704d7491428d8a23347c0", "html_url": "https://github.com/rust-lang/rust/commit/2a71e45411881dda12a704d7491428d8a23347c0"}, {"sha": "c791c64e8434b0477de667c1a0fdbe18c928274c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c791c64e8434b0477de667c1a0fdbe18c928274c", "html_url": "https://github.com/rust-lang/rust/commit/c791c64e8434b0477de667c1a0fdbe18c928274c"}], "stats": {"total": 573, "additions": 573, "deletions": 0}, "files": [{"sha": "61427422e4b597306283b396cc263a463521d83d", "filename": "compiler/rustc_mir/src/transform/function_item_references.rs", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/07e968b640e8ff76fa8be4b48b70ab80ea577800/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Ffunction_item_references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07e968b640e8ff76fa8be4b48b70ab80ea577800/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Ffunction_item_references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Ffunction_item_references.rs?ref=07e968b640e8ff76fa8be4b48b70ab80ea577800", "patch": "@@ -0,0 +1,205 @@\n+use rustc_errors::Applicability;\n+use rustc_hir::def_id::DefId;\n+use rustc_middle::mir::visit::Visitor;\n+use rustc_middle::mir::*;\n+use rustc_middle::ty::{\n+    self,\n+    subst::{GenericArgKind, Subst, SubstsRef},\n+    PredicateAtom, Ty, TyCtxt, TyS,\n+};\n+use rustc_session::lint::builtin::FUNCTION_ITEM_REFERENCES;\n+use rustc_span::{symbol::sym, Span};\n+use rustc_target::spec::abi::Abi;\n+\n+use crate::transform::MirPass;\n+\n+pub struct FunctionItemReferences;\n+\n+impl<'tcx> MirPass<'tcx> for FunctionItemReferences {\n+    fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n+        let mut checker = FunctionItemRefChecker { tcx, body };\n+        checker.visit_body(&body);\n+    }\n+}\n+\n+struct FunctionItemRefChecker<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    body: &'a Body<'tcx>,\n+}\n+\n+impl<'a, 'tcx> Visitor<'tcx> for FunctionItemRefChecker<'a, 'tcx> {\n+    /// Emits a lint for function reference arguments bound by `fmt::Pointer` or passed to\n+    /// `transmute`. This only handles arguments in calls outside macro expansions to avoid double\n+    /// counting function references formatted as pointers by macros.\n+    fn visit_terminator(&mut self, terminator: &Terminator<'tcx>, location: Location) {\n+        if let TerminatorKind::Call {\n+            func,\n+            args,\n+            destination: _,\n+            cleanup: _,\n+            from_hir_call: _,\n+            fn_span: _,\n+        } = &terminator.kind\n+        {\n+            let source_info = *self.body.source_info(location);\n+            // Only handle function calls outside macros\n+            if !source_info.span.from_expansion() {\n+                let func_ty = func.ty(self.body, self.tcx);\n+                if let ty::FnDef(def_id, substs_ref) = *func_ty.kind() {\n+                    // Handle calls to `transmute`\n+                    if self.tcx.is_diagnostic_item(sym::transmute, def_id) {\n+                        let arg_ty = args[0].ty(self.body, self.tcx);\n+                        for generic_inner_ty in arg_ty.walk() {\n+                            if let GenericArgKind::Type(inner_ty) = generic_inner_ty.unpack() {\n+                                if let Some(fn_id) = FunctionItemRefChecker::is_fn_ref(inner_ty) {\n+                                    let ident = self.tcx.item_name(fn_id).to_ident_string();\n+                                    let span = self.nth_arg_span(&args, 0);\n+                                    self.emit_lint(ident, fn_id, source_info, span);\n+                                }\n+                            }\n+                        }\n+                    } else {\n+                        self.check_bound_args(def_id, substs_ref, &args, source_info);\n+                    }\n+                }\n+            }\n+        }\n+        self.super_terminator(terminator, location);\n+    }\n+    /// Emits a lint for function references formatted with `fmt::Pointer::fmt` by macros. These\n+    /// cases are handled as operands instead of call terminators to avoid any dependence on\n+    /// unstable, internal formatting details like whether `fmt` is called directly or not.\n+    fn visit_operand(&mut self, operand: &Operand<'tcx>, location: Location) {\n+        let source_info = *self.body.source_info(location);\n+        if source_info.span.from_expansion() {\n+            let op_ty = operand.ty(self.body, self.tcx);\n+            if let ty::FnDef(def_id, substs_ref) = *op_ty.kind() {\n+                if self.tcx.is_diagnostic_item(sym::pointer_trait_fmt, def_id) {\n+                    let param_ty = substs_ref.type_at(0);\n+                    if let Some(fn_id) = FunctionItemRefChecker::is_fn_ref(param_ty) {\n+                        // The operand's ctxt wouldn't display the lint since it's inside a macro so\n+                        // we have to use the callsite's ctxt.\n+                        let callsite_ctxt = source_info.span.source_callsite().ctxt();\n+                        let span = source_info.span.with_ctxt(callsite_ctxt);\n+                        let ident = self.tcx.item_name(fn_id).to_ident_string();\n+                        self.emit_lint(ident, fn_id, source_info, span);\n+                    }\n+                }\n+            }\n+        }\n+        self.super_operand(operand, location);\n+    }\n+}\n+\n+impl<'a, 'tcx> FunctionItemRefChecker<'a, 'tcx> {\n+    /// Emits a lint for function reference arguments bound by `fmt::Pointer` in calls to the\n+    /// function defined by `def_id` with the substitutions `substs_ref`.\n+    fn check_bound_args(\n+        &self,\n+        def_id: DefId,\n+        substs_ref: SubstsRef<'tcx>,\n+        args: &Vec<Operand<'tcx>>,\n+        source_info: SourceInfo,\n+    ) {\n+        let param_env = self.tcx.param_env(def_id);\n+        let bounds = param_env.caller_bounds();\n+        for bound in bounds {\n+            if let Some(bound_ty) = self.is_pointer_trait(&bound.skip_binders()) {\n+                // Get the argument types as they appear in the function signature.\n+                let arg_defs = self.tcx.fn_sig(def_id).skip_binder().inputs();\n+                for (arg_num, arg_def) in arg_defs.iter().enumerate() {\n+                    // For all types reachable from the argument type in the fn sig\n+                    for generic_inner_ty in arg_def.walk() {\n+                        if let GenericArgKind::Type(inner_ty) = generic_inner_ty.unpack() {\n+                            // If the inner type matches the type bound by `Pointer`\n+                            if TyS::same_type(inner_ty, bound_ty) {\n+                                // Do a substitution using the parameters from the callsite\n+                                let subst_ty = inner_ty.subst(self.tcx, substs_ref);\n+                                if let Some(fn_id) = FunctionItemRefChecker::is_fn_ref(subst_ty) {\n+                                    let ident = self.tcx.item_name(fn_id).to_ident_string();\n+                                    let span = self.nth_arg_span(args, arg_num);\n+                                    self.emit_lint(ident, fn_id, source_info, span);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    /// If the given predicate is the trait `fmt::Pointer`, returns the bound parameter type.\n+    fn is_pointer_trait(&self, bound: &PredicateAtom<'tcx>) -> Option<Ty<'tcx>> {\n+        if let ty::PredicateAtom::Trait(predicate, _) = bound {\n+            if self.tcx.is_diagnostic_item(sym::pointer_trait, predicate.def_id()) {\n+                Some(predicate.trait_ref.self_ty())\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+    /// If a type is a reference or raw pointer to the anonymous type of a function definition,\n+    /// returns that function's `DefId`.\n+    fn is_fn_ref(ty: Ty<'tcx>) -> Option<DefId> {\n+        let referent_ty = match ty.kind() {\n+            ty::Ref(_, referent_ty, _) => Some(referent_ty),\n+            ty::RawPtr(ty_and_mut) => Some(&ty_and_mut.ty),\n+            _ => None,\n+        };\n+        referent_ty\n+            .map(\n+                |ref_ty| {\n+                    if let ty::FnDef(def_id, _) = *ref_ty.kind() { Some(def_id) } else { None }\n+                },\n+            )\n+            .unwrap_or(None)\n+    }\n+    fn nth_arg_span(&self, args: &Vec<Operand<'tcx>>, n: usize) -> Span {\n+        match &args[n] {\n+            Operand::Copy(place) | Operand::Move(place) => {\n+                self.body.local_decls[place.local].source_info.span\n+            }\n+            Operand::Constant(constant) => constant.span,\n+        }\n+    }\n+    fn emit_lint(&self, ident: String, fn_id: DefId, source_info: SourceInfo, span: Span) {\n+        let lint_root = self.body.source_scopes[source_info.scope]\n+            .local_data\n+            .as_ref()\n+            .assert_crate_local()\n+            .lint_root;\n+        let fn_sig = self.tcx.fn_sig(fn_id);\n+        let unsafety = fn_sig.unsafety().prefix_str();\n+        let abi = match fn_sig.abi() {\n+            Abi::Rust => String::from(\"\"),\n+            other_abi => {\n+                let mut s = String::from(\"extern \\\"\");\n+                s.push_str(other_abi.name());\n+                s.push_str(\"\\\" \");\n+                s\n+            }\n+        };\n+        let num_args = fn_sig.inputs().map_bound(|inputs| inputs.len()).skip_binder();\n+        let variadic = if fn_sig.c_variadic() { \", ...\" } else { \"\" };\n+        let ret = if fn_sig.output().skip_binder().is_unit() { \"\" } else { \" -> _\" };\n+        self.tcx.struct_span_lint_hir(FUNCTION_ITEM_REFERENCES, lint_root, span, |lint| {\n+            lint.build(\"taking a reference to a function item does not give a function pointer\")\n+                .span_suggestion(\n+                    span,\n+                    &format!(\"cast `{}` to obtain a function pointer\", ident),\n+                    format!(\n+                        \"{} as {}{}fn({}{}){}\",\n+                        ident,\n+                        unsafety,\n+                        abi,\n+                        vec![\"_\"; num_args].join(\", \"),\n+                        variadic,\n+                        ret,\n+                    ),\n+                    Applicability::Unspecified,\n+                )\n+                .emit();\n+        });\n+    }\n+}"}, {"sha": "89db6bb13cad355d2bf5a9c9e1be2519a93e4631", "filename": "compiler/rustc_mir/src/transform/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07e968b640e8ff76fa8be4b48b70ab80ea577800/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07e968b640e8ff76fa8be4b48b70ab80ea577800/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs?ref=07e968b640e8ff76fa8be4b48b70ab80ea577800", "patch": "@@ -27,6 +27,7 @@ pub mod dest_prop;\n pub mod dump_mir;\n pub mod early_otherwise_branch;\n pub mod elaborate_drops;\n+pub mod function_item_references;\n pub mod generator;\n pub mod inline;\n pub mod instcombine;\n@@ -266,6 +267,7 @@ fn mir_const<'tcx>(\n             // MIR-level lints.\n             &check_packed_ref::CheckPackedRef,\n             &check_const_item_mutation::CheckConstItemMutation,\n+            &function_item_references::FunctionItemReferences,\n             // What we need to do constant evaluation.\n             &simplify::SimplifyCfg::new(\"initial\"),\n             &rustc_peek::SanityCheck,"}, {"sha": "b8826a548b8bebbf10f1e7c459398f725792068a", "filename": "compiler/rustc_session/src/lint/builtin.rs", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/07e968b640e8ff76fa8be4b48b70ab80ea577800/compiler%2Frustc_session%2Fsrc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07e968b640e8ff76fa8be4b48b70ab80ea577800/compiler%2Frustc_session%2Fsrc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Flint%2Fbuiltin.rs?ref=07e968b640e8ff76fa8be4b48b70ab80ea577800", "patch": "@@ -2647,6 +2647,36 @@ declare_lint! {\n     };\n }\n \n+declare_lint! {\n+    /// The `function_item_references` lint detects function references that are\n+    /// formatted with [`fmt::Pointer`] or transmuted.\n+    ///\n+    /// [`fmt::Pointer`]: https://doc.rust-lang.org/std/fmt/trait.Pointer.html\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// fn foo() { }\n+    ///\n+    /// fn main() {\n+    ///     println!(\"{:p}\", &foo);\n+    /// }\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// Taking a reference to a function may be mistaken as a way to obtain a\n+    /// pointer to that function. This can give unexpected results when\n+    /// formatting the reference as a pointer or transmuting it. This lint is\n+    /// issued when function references are formatted as pointers, passed as\n+    /// arguments bound by [`fmt::Pointer`] or transmuted.\n+    pub FUNCTION_ITEM_REFERENCES,\n+    Warn,\n+    \"suggest casting to a function pointer when attempting to take references to function items\",\n+}\n+\n declare_lint! {\n     /// The `uninhabited_static` lint detects uninhabited statics.\n     ///\n@@ -2762,6 +2792,7 @@ declare_lint_pass! {\n         CONST_EVALUATABLE_UNCHECKED,\n         INEFFECTIVE_UNSTABLE_TRAIT_IMPL,\n         UNINHABITED_STATIC,\n+        FUNCTION_ITEM_REFERENCES,\n     ]\n }\n "}, {"sha": "ef0f09ae81895367dbfc13f1a47c69fbdc957e57", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07e968b640e8ff76fa8be4b48b70ab80ea577800/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07e968b640e8ff76fa8be4b48b70ab80ea577800/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=07e968b640e8ff76fa8be4b48b70ab80ea577800", "patch": "@@ -796,6 +796,8 @@ symbols! {\n         plugin_registrar,\n         plugins,\n         pointer,\n+        pointer_trait,\n+        pointer_trait_fmt,\n         poll,\n         position,\n         post_dash_lto: \"post-lto\","}, {"sha": "506d77806868215828708f419b45d15b8093b9ca", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/07e968b640e8ff76fa8be4b48b70ab80ea577800/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07e968b640e8ff76fa8be4b48b70ab80ea577800/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=07e968b640e8ff76fa8be4b48b70ab80ea577800", "patch": "@@ -920,9 +920,11 @@ pub trait UpperHex {\n /// assert_eq!(&l_ptr[..2], \"0x\");\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[rustc_diagnostic_item = \"pointer_trait\"]\n pub trait Pointer {\n     /// Formats the value using the given formatter.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_diagnostic_item = \"pointer_trait_fmt\"]\n     fn fmt(&self, f: &mut Formatter<'_>) -> Result;\n }\n "}, {"sha": "439b56967d072c2fa3eacbd712d1ed036969a0c6", "filename": "src/test/ui/lint/function-item-references.rs", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/07e968b640e8ff76fa8be4b48b70ab80ea577800/src%2Ftest%2Fui%2Flint%2Ffunction-item-references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/07e968b640e8ff76fa8be4b48b70ab80ea577800/src%2Ftest%2Fui%2Flint%2Ffunction-item-references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Ffunction-item-references.rs?ref=07e968b640e8ff76fa8be4b48b70ab80ea577800", "patch": "@@ -0,0 +1,155 @@\n+// check-pass\n+#![feature(c_variadic)]\n+#![warn(function_item_references)]\n+use std::fmt::Pointer;\n+use std::fmt::Formatter;\n+\n+fn nop() { }\n+fn foo() -> u32 { 42 }\n+fn bar(x: u32) -> u32 { x }\n+fn baz(x: u32, y: u32) -> u32 { x + y }\n+unsafe fn unsafe_fn() { }\n+extern \"C\" fn c_fn() { }\n+unsafe extern \"C\" fn unsafe_c_fn() { }\n+unsafe extern fn variadic(_x: u32, _args: ...) { }\n+\n+//function references passed to these functions should never lint\n+fn call_fn(f: &dyn Fn(u32) -> u32, x: u32) { f(x); }\n+fn parameterized_call_fn<F: Fn(u32) -> u32>(f: &F, x: u32) { f(x); }\n+\n+//function references passed to these functions should lint\n+fn print_ptr<F: Pointer>(f: F) { println!(\"{:p}\", f); }\n+fn bound_by_ptr_trait<F: Pointer>(_f: F) { }\n+fn bound_by_ptr_trait_tuple<F: Pointer, G: Pointer>(_t: (F, G)) { }\n+fn implicit_ptr_trait<F>(f: &F) { println!(\"{:p}\", f); }\n+\n+//case found in tinyvec that triggered a compiler error in an earlier version of the lint checker\n+trait HasItem {\n+  type Item;\n+  fn assoc_item(&self) -> Self::Item;\n+}\n+fn _format_assoc_item<T: HasItem>(data: T, f: &mut Formatter) -> std::fmt::Result\n+    where T::Item: Pointer {\n+    //when the arg type bound by `Pointer` is an associated type, we shouldn't attempt to normalize\n+    Pointer::fmt(&data.assoc_item(), f)\n+}\n+\n+//simple test to make sure that calls to `Pointer::fmt` aren't double counted\n+fn _call_pointer_fmt(f: &mut Formatter) -> std::fmt::Result {\n+    let zst_ref = &foo;\n+    Pointer::fmt(&zst_ref, f)\n+    //~^ WARNING taking a reference to a function item does not give a function pointer\n+}\n+\n+fn main() {\n+    //`let` bindings with function references shouldn't lint\n+    let _ = &foo;\n+    let _ = &mut foo;\n+\n+    let zst_ref = &foo;\n+    let fn_item = foo;\n+    let indirect_ref = &fn_item;\n+\n+    let _mut_zst_ref = &mut foo;\n+    let mut mut_fn_item = foo;\n+    let _mut_indirect_ref = &mut mut_fn_item;\n+\n+    let cast_zst_ptr = &foo as *const _;\n+    let coerced_zst_ptr: *const _ = &foo;\n+\n+    let _mut_cast_zst_ptr = &mut foo as *mut _;\n+    let _mut_coerced_zst_ptr: *mut _ = &mut foo;\n+\n+    let _cast_zst_ref = &foo as &dyn Fn() -> u32;\n+    let _coerced_zst_ref: &dyn Fn() -> u32 = &foo;\n+\n+    let _mut_cast_zst_ref = &mut foo as &mut dyn Fn() -> u32;\n+    let _mut_coerced_zst_ref: &mut dyn Fn() -> u32 = &mut foo;\n+\n+    //the suggested way to cast to a function pointer\n+    let fn_ptr = foo as fn() -> u32;\n+\n+    //correct ways to print function pointers\n+    println!(\"{:p}\", foo as fn() -> u32);\n+    println!(\"{:p}\", fn_ptr);\n+\n+    //potential ways to incorrectly try printing function pointers\n+    println!(\"{:p}\", &foo);\n+    //~^ WARNING taking a reference to a function item does not give a function pointer\n+    print!(\"{:p}\", &foo);\n+    //~^ WARNING taking a reference to a function item does not give a function pointer\n+    format!(\"{:p}\", &foo);\n+    //~^ WARNING taking a reference to a function item does not give a function pointer\n+\n+    println!(\"{:p}\", &foo as *const _);\n+    //~^ WARNING taking a reference to a function item does not give a function pointer\n+    println!(\"{:p}\", zst_ref);\n+    //~^ WARNING taking a reference to a function item does not give a function pointer\n+    println!(\"{:p}\", cast_zst_ptr);\n+    //~^ WARNING taking a reference to a function item does not give a function pointer\n+    println!(\"{:p}\", coerced_zst_ptr);\n+    //~^ WARNING taking a reference to a function item does not give a function pointer\n+\n+    println!(\"{:p}\", &fn_item);\n+    //~^ WARNING taking a reference to a function item does not give a function pointer\n+    println!(\"{:p}\", indirect_ref);\n+    //~^ WARNING taking a reference to a function item does not give a function pointer\n+\n+    println!(\"{:p}\", &nop);\n+    //~^ WARNING taking a reference to a function item does not give a function pointer\n+    println!(\"{:p}\", &bar);\n+    //~^ WARNING taking a reference to a function item does not give a function pointer\n+    println!(\"{:p}\", &baz);\n+    //~^ WARNING taking a reference to a function item does not give a function pointer\n+    println!(\"{:p}\", &unsafe_fn);\n+    //~^ WARNING taking a reference to a function item does not give a function pointer\n+    println!(\"{:p}\", &c_fn);\n+    //~^ WARNING taking a reference to a function item does not give a function pointer\n+    println!(\"{:p}\", &unsafe_c_fn);\n+    //~^ WARNING taking a reference to a function item does not give a function pointer\n+    println!(\"{:p}\", &variadic);\n+    //~^ WARNING taking a reference to a function item does not give a function pointer\n+    println!(\"{:p}\", &std::env::var::<String>);\n+    //~^ WARNING taking a reference to a function item does not give a function pointer\n+\n+    println!(\"{:p} {:p} {:p}\", &nop, &foo, &bar);\n+    //~^ WARNING taking a reference to a function item does not give a function pointer\n+    //~^^ WARNING taking a reference to a function item does not give a function pointer\n+    //~^^^ WARNING taking a reference to a function item does not give a function pointer\n+\n+    //using a function reference to call a function shouldn't lint\n+    (&bar)(1);\n+\n+    //passing a function reference to an arbitrary function shouldn't lint\n+    call_fn(&bar, 1);\n+    parameterized_call_fn(&bar, 1);\n+    std::mem::size_of_val(&foo);\n+\n+    unsafe {\n+        //potential ways to incorrectly try transmuting function pointers\n+        std::mem::transmute::<_, usize>(&foo);\n+        //~^ WARNING taking a reference to a function item does not give a function pointer\n+        std::mem::transmute::<_, (usize, usize)>((&foo, &bar));\n+        //~^ WARNING taking a reference to a function item does not give a function pointer\n+        //~^^ WARNING taking a reference to a function item does not give a function pointer\n+\n+        //the correct way to transmute function pointers\n+        std::mem::transmute::<_, usize>(foo as fn() -> u32);\n+        std::mem::transmute::<_, (usize, usize)>((foo as fn() -> u32, bar as fn(u32) -> u32));\n+    }\n+\n+    //function references as arguments required to be bound by std::fmt::Pointer should lint\n+    print_ptr(&bar);\n+    //~^ WARNING taking a reference to a function item does not give a function pointer\n+    bound_by_ptr_trait(&bar);\n+    //~^ WARNING taking a reference to a function item does not give a function pointer\n+    bound_by_ptr_trait_tuple((&foo, &bar));\n+    //~^ WARNING taking a reference to a function item does not give a function pointer\n+    //~^^ WARNING taking a reference to a function item does not give a function pointer\n+    implicit_ptr_trait(&bar); // ignore\n+\n+    //correct ways to pass function pointers as arguments bound by std::fmt::Pointer\n+    print_ptr(bar as fn(u32) -> u32);\n+    bound_by_ptr_trait(bar as fn(u32) -> u32);\n+    bound_by_ptr_trait_tuple((foo as fn() -> u32, bar as fn(u32) -> u32));\n+}"}, {"sha": "610dff04e6edf09b9c87a841a4cb1ec0f651bf60", "filename": "src/test/ui/lint/function-item-references.stderr", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/07e968b640e8ff76fa8be4b48b70ab80ea577800/src%2Ftest%2Fui%2Flint%2Ffunction-item-references.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/07e968b640e8ff76fa8be4b48b70ab80ea577800/src%2Ftest%2Fui%2Flint%2Ffunction-item-references.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Ffunction-item-references.stderr?ref=07e968b640e8ff76fa8be4b48b70ab80ea577800", "patch": "@@ -0,0 +1,176 @@\n+warning: taking a reference to a function item does not give a function pointer\n+  --> $DIR/function-item-references.rs:40:18\n+   |\n+LL |     Pointer::fmt(&zst_ref, f)\n+   |                  ^^^^^^^^ help: cast `foo` to obtain a function pointer: `foo as fn() -> _`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/function-item-references.rs:3:9\n+   |\n+LL | #![warn(function_item_references)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+warning: taking a reference to a function item does not give a function pointer\n+  --> $DIR/function-item-references.rs:77:22\n+   |\n+LL |     println!(\"{:p}\", &foo);\n+   |                      ^^^^ help: cast `foo` to obtain a function pointer: `foo as fn() -> _`\n+\n+warning: taking a reference to a function item does not give a function pointer\n+  --> $DIR/function-item-references.rs:79:20\n+   |\n+LL |     print!(\"{:p}\", &foo);\n+   |                    ^^^^ help: cast `foo` to obtain a function pointer: `foo as fn() -> _`\n+\n+warning: taking a reference to a function item does not give a function pointer\n+  --> $DIR/function-item-references.rs:81:21\n+   |\n+LL |     format!(\"{:p}\", &foo);\n+   |                     ^^^^ help: cast `foo` to obtain a function pointer: `foo as fn() -> _`\n+\n+warning: taking a reference to a function item does not give a function pointer\n+  --> $DIR/function-item-references.rs:84:22\n+   |\n+LL |     println!(\"{:p}\", &foo as *const _);\n+   |                      ^^^^^^^^^^^^^^^^ help: cast `foo` to obtain a function pointer: `foo as fn() -> _`\n+\n+warning: taking a reference to a function item does not give a function pointer\n+  --> $DIR/function-item-references.rs:86:22\n+   |\n+LL |     println!(\"{:p}\", zst_ref);\n+   |                      ^^^^^^^ help: cast `foo` to obtain a function pointer: `foo as fn() -> _`\n+\n+warning: taking a reference to a function item does not give a function pointer\n+  --> $DIR/function-item-references.rs:88:22\n+   |\n+LL |     println!(\"{:p}\", cast_zst_ptr);\n+   |                      ^^^^^^^^^^^^ help: cast `foo` to obtain a function pointer: `foo as fn() -> _`\n+\n+warning: taking a reference to a function item does not give a function pointer\n+  --> $DIR/function-item-references.rs:90:22\n+   |\n+LL |     println!(\"{:p}\", coerced_zst_ptr);\n+   |                      ^^^^^^^^^^^^^^^ help: cast `foo` to obtain a function pointer: `foo as fn() -> _`\n+\n+warning: taking a reference to a function item does not give a function pointer\n+  --> $DIR/function-item-references.rs:93:22\n+   |\n+LL |     println!(\"{:p}\", &fn_item);\n+   |                      ^^^^^^^^ help: cast `foo` to obtain a function pointer: `foo as fn() -> _`\n+\n+warning: taking a reference to a function item does not give a function pointer\n+  --> $DIR/function-item-references.rs:95:22\n+   |\n+LL |     println!(\"{:p}\", indirect_ref);\n+   |                      ^^^^^^^^^^^^ help: cast `foo` to obtain a function pointer: `foo as fn() -> _`\n+\n+warning: taking a reference to a function item does not give a function pointer\n+  --> $DIR/function-item-references.rs:98:22\n+   |\n+LL |     println!(\"{:p}\", &nop);\n+   |                      ^^^^ help: cast `nop` to obtain a function pointer: `nop as fn()`\n+\n+warning: taking a reference to a function item does not give a function pointer\n+  --> $DIR/function-item-references.rs:100:22\n+   |\n+LL |     println!(\"{:p}\", &bar);\n+   |                      ^^^^ help: cast `bar` to obtain a function pointer: `bar as fn(_) -> _`\n+\n+warning: taking a reference to a function item does not give a function pointer\n+  --> $DIR/function-item-references.rs:102:22\n+   |\n+LL |     println!(\"{:p}\", &baz);\n+   |                      ^^^^ help: cast `baz` to obtain a function pointer: `baz as fn(_, _) -> _`\n+\n+warning: taking a reference to a function item does not give a function pointer\n+  --> $DIR/function-item-references.rs:104:22\n+   |\n+LL |     println!(\"{:p}\", &unsafe_fn);\n+   |                      ^^^^^^^^^^ help: cast `unsafe_fn` to obtain a function pointer: `unsafe_fn as unsafe fn()`\n+\n+warning: taking a reference to a function item does not give a function pointer\n+  --> $DIR/function-item-references.rs:106:22\n+   |\n+LL |     println!(\"{:p}\", &c_fn);\n+   |                      ^^^^^ help: cast `c_fn` to obtain a function pointer: `c_fn as extern \"C\" fn()`\n+\n+warning: taking a reference to a function item does not give a function pointer\n+  --> $DIR/function-item-references.rs:108:22\n+   |\n+LL |     println!(\"{:p}\", &unsafe_c_fn);\n+   |                      ^^^^^^^^^^^^ help: cast `unsafe_c_fn` to obtain a function pointer: `unsafe_c_fn as unsafe extern \"C\" fn()`\n+\n+warning: taking a reference to a function item does not give a function pointer\n+  --> $DIR/function-item-references.rs:110:22\n+   |\n+LL |     println!(\"{:p}\", &variadic);\n+   |                      ^^^^^^^^^ help: cast `variadic` to obtain a function pointer: `variadic as unsafe extern \"C\" fn(_, ...)`\n+\n+warning: taking a reference to a function item does not give a function pointer\n+  --> $DIR/function-item-references.rs:112:22\n+   |\n+LL |     println!(\"{:p}\", &std::env::var::<String>);\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^ help: cast `var` to obtain a function pointer: `var as fn(_) -> _`\n+\n+warning: taking a reference to a function item does not give a function pointer\n+  --> $DIR/function-item-references.rs:115:32\n+   |\n+LL |     println!(\"{:p} {:p} {:p}\", &nop, &foo, &bar);\n+   |                                ^^^^ help: cast `nop` to obtain a function pointer: `nop as fn()`\n+\n+warning: taking a reference to a function item does not give a function pointer\n+  --> $DIR/function-item-references.rs:115:38\n+   |\n+LL |     println!(\"{:p} {:p} {:p}\", &nop, &foo, &bar);\n+   |                                      ^^^^ help: cast `foo` to obtain a function pointer: `foo as fn() -> _`\n+\n+warning: taking a reference to a function item does not give a function pointer\n+  --> $DIR/function-item-references.rs:115:44\n+   |\n+LL |     println!(\"{:p} {:p} {:p}\", &nop, &foo, &bar);\n+   |                                            ^^^^ help: cast `bar` to obtain a function pointer: `bar as fn(_) -> _`\n+\n+warning: taking a reference to a function item does not give a function pointer\n+  --> $DIR/function-item-references.rs:130:41\n+   |\n+LL |         std::mem::transmute::<_, usize>(&foo);\n+   |                                         ^^^^ help: cast `foo` to obtain a function pointer: `foo as fn() -> _`\n+\n+warning: taking a reference to a function item does not give a function pointer\n+  --> $DIR/function-item-references.rs:132:50\n+   |\n+LL |         std::mem::transmute::<_, (usize, usize)>((&foo, &bar));\n+   |                                                  ^^^^^^^^^^^^ help: cast `foo` to obtain a function pointer: `foo as fn() -> _`\n+\n+warning: taking a reference to a function item does not give a function pointer\n+  --> $DIR/function-item-references.rs:132:50\n+   |\n+LL |         std::mem::transmute::<_, (usize, usize)>((&foo, &bar));\n+   |                                                  ^^^^^^^^^^^^ help: cast `bar` to obtain a function pointer: `bar as fn(_) -> _`\n+\n+warning: taking a reference to a function item does not give a function pointer\n+  --> $DIR/function-item-references.rs:142:15\n+   |\n+LL |     print_ptr(&bar);\n+   |               ^^^^ help: cast `bar` to obtain a function pointer: `bar as fn(_) -> _`\n+\n+warning: taking a reference to a function item does not give a function pointer\n+  --> $DIR/function-item-references.rs:144:24\n+   |\n+LL |     bound_by_ptr_trait(&bar);\n+   |                        ^^^^ help: cast `bar` to obtain a function pointer: `bar as fn(_) -> _`\n+\n+warning: taking a reference to a function item does not give a function pointer\n+  --> $DIR/function-item-references.rs:146:30\n+   |\n+LL |     bound_by_ptr_trait_tuple((&foo, &bar));\n+   |                              ^^^^^^^^^^^^ help: cast `bar` to obtain a function pointer: `bar as fn(_) -> _`\n+\n+warning: taking a reference to a function item does not give a function pointer\n+  --> $DIR/function-item-references.rs:146:30\n+   |\n+LL |     bound_by_ptr_trait_tuple((&foo, &bar));\n+   |                              ^^^^^^^^^^^^ help: cast `foo` to obtain a function pointer: `foo as fn() -> _`\n+\n+warning: 28 warnings emitted\n+"}]}