{"sha": "e0b8942c56378b7966af39058f27b11a0d02890f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwYjg5NDJjNTYzNzhiNzk2NmFmMzkwNThmMjdiMTFhMGQwMjg5MGY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-14T18:14:47Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-02-14T18:14:47Z"}, "message": "simplify", "tree": {"sha": "2e9abadb6e64fed7738b5b3fbc2eb13787efdaca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e9abadb6e64fed7738b5b3fbc2eb13787efdaca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0b8942c56378b7966af39058f27b11a0d02890f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0b8942c56378b7966af39058f27b11a0d02890f", "html_url": "https://github.com/rust-lang/rust/commit/e0b8942c56378b7966af39058f27b11a0d02890f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0b8942c56378b7966af39058f27b11a0d02890f/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf352cd2511775a331d77dee261b64bd8359dacb", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf352cd2511775a331d77dee261b64bd8359dacb", "html_url": "https://github.com/rust-lang/rust/commit/bf352cd2511775a331d77dee261b64bd8359dacb"}], "stats": {"total": 157, "additions": 71, "deletions": 86}, "files": [{"sha": "f64b4c53233619d2f4aa3fcc28b3b73e94515810", "filename": "crates/ra_vfs/src/io.rs", "status": "modified", "additions": 70, "deletions": 85, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/e0b8942c56378b7966af39058f27b11a0d02890f/crates%2Fra_vfs%2Fsrc%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0b8942c56378b7966af39058f27b11a0d02890f/crates%2Fra_vfs%2Fsrc%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Fio.rs?ref=e0b8942c56378b7966af39058f27b11a0d02890f", "patch": "@@ -4,7 +4,7 @@ use std::{\n     sync::{mpsc, Arc},\n     time::Duration,\n };\n-use crossbeam_channel::{Receiver, Sender, unbounded, RecvError, select};\n+use crossbeam_channel::{Sender, unbounded, RecvError, select};\n use relative_path::RelativePathBuf;\n use walkdir::WalkDir;\n use notify::{DebouncedEvent, RecommendedWatcher, RecursiveMode, Watcher as _Watcher};\n@@ -46,93 +46,78 @@ enum ChangeKind {\n \n const WATCHER_DELAY: Duration = Duration::from_millis(250);\n \n-pub(crate) struct Worker {\n-    thread_worker: thread_worker::Worker<Task, TaskResult>,\n-}\n-\n-impl Worker {\n-    pub(crate) fn start(roots: Arc<Roots>) -> Worker {\n-        // This is a pretty elaborate setup of threads & channels! It is\n-        // explained by the following concerns:\n-        //    * we need to burn a thread translating from notify's mpsc to\n-        //      crossbeam_channel.\n-        //    * we want to read all files from a single thread, to guarantee that\n-        //      we always get fresher versions and never go back in time.\n-        //    * we want to tear down everything neatly during shutdown.\n-        let thread_worker = thread_worker::Worker::spawn(\n-            \"vfs\",\n-            128,\n-            // This are the channels we use to communicate with outside world.\n-            // If `input_receiver` is closed we need to tear ourselves down.\n-            // `output_sender` should not be closed unless the parent died.\n-            move |input_receiver, output_sender| {\n-                // Make sure that the destruction order is\n-                //\n-                // * notify_sender\n-                // * _thread\n-                // * watcher_sender\n-                //\n-                // this is required to avoid deadlocks.\n-\n-                // These are the corresponding crossbeam channels\n-                let (watcher_sender, watcher_receiver) = unbounded();\n-                let _thread;\n-                {\n-                    // These are `std` channels notify will send events to\n-                    let (notify_sender, notify_receiver) = mpsc::channel();\n-\n-                    let mut watcher = notify::watcher(notify_sender, WATCHER_DELAY)\n-                        .map_err(|e| log::error!(\"failed to spawn notify {}\", e))\n-                        .ok();\n-                    // Start a silly thread to transform between two channels\n-                    _thread = thread_worker::ScopedThread::spawn(\"notify-convertor\", move || {\n-                        notify_receiver\n-                            .into_iter()\n-                            .for_each(|event| convert_notify_event(event, &watcher_sender))\n-                    });\n-\n-                    // Process requests from the called or notifications from\n-                    // watcher until the caller says stop.\n-                    loop {\n-                        select! {\n-                            // Received request from the caller. If this channel is\n-                            // closed, we should shutdown everything.\n-                            recv(input_receiver) -> t => match t {\n-                                Err(RecvError) => {\n-                                    drop(input_receiver);\n-                                    break\n-                                },\n-                                Ok(Task::AddRoot { root, config }) => {\n-                                    watch_root(watcher.as_mut(), &output_sender, root, Arc::clone(&config));\n-                                }\n-                            },\n-                            // Watcher send us changes. If **this** channel is\n-                            // closed, the watcher has died, which indicates a bug\n-                            // -- escalate!\n-                            recv(watcher_receiver) -> event => match event {\n-                                Err(RecvError) => panic!(\"watcher is dead\"),\n-                                Ok((path, change)) => {\n-                                    handle_change(watcher.as_mut(), &output_sender, &*roots, path, change);\n-                                }\n+pub(crate) type Worker = thread_worker::Worker<Task, TaskResult>;\n+pub(crate) fn start(roots: Arc<Roots>) -> Worker {\n+    // This is a pretty elaborate setup of threads & channels! It is\n+    // explained by the following concerns:\n+    //    * we need to burn a thread translating from notify's mpsc to\n+    //      crossbeam_channel.\n+    //    * we want to read all files from a single thread, to guarantee that\n+    //      we always get fresher versions and never go back in time.\n+    //    * we want to tear down everything neatly during shutdown.\n+    Worker::spawn(\n+        \"vfs\",\n+        128,\n+        // This are the channels we use to communicate with outside world.\n+        // If `input_receiver` is closed we need to tear ourselves down.\n+        // `output_sender` should not be closed unless the parent died.\n+        move |input_receiver, output_sender| {\n+            // Make sure that the destruction order is\n+            //\n+            // * notify_sender\n+            // * _thread\n+            // * watcher_sender\n+            //\n+            // this is required to avoid deadlocks.\n+\n+            // These are the corresponding crossbeam channels\n+            let (watcher_sender, watcher_receiver) = unbounded();\n+            let _thread;\n+            {\n+                // These are `std` channels notify will send events to\n+                let (notify_sender, notify_receiver) = mpsc::channel();\n+\n+                let mut watcher = notify::watcher(notify_sender, WATCHER_DELAY)\n+                    .map_err(|e| log::error!(\"failed to spawn notify {}\", e))\n+                    .ok();\n+                // Start a silly thread to transform between two channels\n+                _thread = thread_worker::ScopedThread::spawn(\"notify-convertor\", move || {\n+                    notify_receiver\n+                        .into_iter()\n+                        .for_each(|event| convert_notify_event(event, &watcher_sender))\n+                });\n+\n+                // Process requests from the called or notifications from\n+                // watcher until the caller says stop.\n+                loop {\n+                    select! {\n+                        // Received request from the caller. If this channel is\n+                        // closed, we should shutdown everything.\n+                        recv(input_receiver) -> t => match t {\n+                            Err(RecvError) => {\n+                                drop(input_receiver);\n+                                break\n                             },\n-                        }\n+                            Ok(Task::AddRoot { root, config }) => {\n+                                watch_root(watcher.as_mut(), &output_sender, root, Arc::clone(&config));\n+                            }\n+                        },\n+                        // Watcher send us changes. If **this** channel is\n+                        // closed, the watcher has died, which indicates a bug\n+                        // -- escalate!\n+                        recv(watcher_receiver) -> event => match event {\n+                            Err(RecvError) => panic!(\"watcher is dead\"),\n+                            Ok((path, change)) => {\n+                                handle_change(watcher.as_mut(), &output_sender, &*roots, path, change);\n+                            }\n+                        },\n                     }\n                 }\n-                // Drain pending events: we are not interested in them anyways!\n-                watcher_receiver.into_iter().for_each(|_| ());\n-            },\n-        );\n-\n-        Worker { thread_worker }\n-    }\n-\n-    pub(crate) fn sender(&self) -> &Sender<Task> {\n-        &self.thread_worker.sender()\n-    }\n-\n-    pub(crate) fn receiver(&self) -> &Receiver<TaskResult> {\n-        &self.thread_worker.receiver()\n-    }\n+            }\n+            // Drain pending events: we are not interested in them anyways!\n+            watcher_receiver.into_iter().for_each(|_| ());\n+        },\n+    )\n }\n \n fn watch_root("}, {"sha": "cfdc1275f5c554f581188b7d9d7fd0bde0a351a4", "filename": "crates/ra_vfs/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0b8942c56378b7966af39058f27b11a0d02890f/crates%2Fra_vfs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0b8942c56378b7966af39058f27b11a0d02890f/crates%2Fra_vfs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_vfs%2Fsrc%2Flib.rs?ref=e0b8942c56378b7966af39058f27b11a0d02890f", "patch": "@@ -159,7 +159,7 @@ impl fmt::Debug for Vfs {\n impl Vfs {\n     pub fn new(roots: Vec<PathBuf>) -> (Vfs, Vec<VfsRoot>) {\n         let roots = Arc::new(Roots::new(roots));\n-        let worker = io::Worker::start(Arc::clone(&roots));\n+        let worker = io::start(Arc::clone(&roots));\n         let mut root2files = ArenaMap::default();\n \n         for (root, config) in roots.iter() {"}]}