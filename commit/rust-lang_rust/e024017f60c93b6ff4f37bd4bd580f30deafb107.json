{"sha": "e024017f60c93b6ff4f37bd4bd580f30deafb107", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwMjQwMTdmNjBjOTNiNmZmNGYzN2JkNGJkNTgwZjMwZGVhZmIxMDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-04T20:21:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-04T20:21:02Z"}, "message": "auto merge of #16986 : bjz/rust/bitflags, r=alexcrichton\n\nCloses #16469", "tree": {"sha": "7df072df6ef8016b7644340a12138dd5567a7607", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7df072df6ef8016b7644340a12138dd5567a7607"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e024017f60c93b6ff4f37bd4bd580f30deafb107", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e024017f60c93b6ff4f37bd4bd580f30deafb107", "html_url": "https://github.com/rust-lang/rust/commit/e024017f60c93b6ff4f37bd4bd580f30deafb107", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e024017f60c93b6ff4f37bd4bd580f30deafb107/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3e7922ddd5f2abfa4d5139e8bca5fab3e796f33", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3e7922ddd5f2abfa4d5139e8bca5fab3e796f33", "html_url": "https://github.com/rust-lang/rust/commit/d3e7922ddd5f2abfa4d5139e8bca5fab3e796f33"}, {"sha": "ef354d850e516e7005da050f0b5b8d3a5c2d7f45", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef354d850e516e7005da050f0b5b8d3a5c2d7f45", "html_url": "https://github.com/rust-lang/rust/commit/ef354d850e516e7005da050f0b5b8d3a5c2d7f45"}], "stats": {"total": 253, "additions": 136, "deletions": 117}, "files": [{"sha": "3d1bc20cca49ecd0870bab4346977e0260b370b0", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 123, "deletions": 104, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/e024017f60c93b6ff4f37bd4bd580f30deafb107/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e024017f60c93b6ff4f37bd4bd580f30deafb107/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=e024017f60c93b6ff4f37bd4bd580f30deafb107", "patch": "@@ -8,111 +8,112 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! The `bitflags!` macro generates a `struct` that holds a set of C-style\n-//! bitmask flags. It is useful for creating typesafe wrappers for C APIs.\n-//!\n-//! The flags should only be defined for integer types, otherwise unexpected\n-//! type errors may occur at compile time.\n-//!\n-//! # Example\n-//!\n-//! ~~~rust\n-//! bitflags!(\n-//!     flags Flags: u32 {\n-//!         static FlagA       = 0x00000001,\n-//!         static FlagB       = 0x00000010,\n-//!         static FlagC       = 0x00000100,\n-//!         static FlagABC     = FlagA.bits\n-//!                            | FlagB.bits\n-//!                            | FlagC.bits\n-//!     }\n-//! )\n-//!\n-//! fn main() {\n-//!     let e1 = FlagA | FlagC;\n-//!     let e2 = FlagB | FlagC;\n-//!     assert!((e1 | e2) == FlagABC);   // union\n-//!     assert!((e1 & e2) == FlagC);     // intersection\n-//!     assert!((e1 - e2) == FlagA);     // set difference\n-//!     assert!(!e2 == FlagA);           // set complement\n-//! }\n-//! ~~~\n-//!\n-//! The generated `struct`s can also be extended with type and trait implementations:\n-//!\n-//! ~~~rust\n-//! use std::fmt;\n-//!\n-//! bitflags!(\n-//!     flags Flags: u32 {\n-//!         static FlagA   = 0x00000001,\n-//!         static FlagB   = 0x00000010\n-//!     }\n-//! )\n-//!\n-//! impl Flags {\n-//!     pub fn clear(&mut self) {\n-//!         self.bits = 0;  // The `bits` field can be accessed from within the\n-//!                         // same module where the `bitflags!` macro was invoked.\n-//!     }\n-//! }\n-//!\n-//! impl fmt::Show for Flags {\n-//!     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-//!         write!(f, \"hi!\")\n-//!     }\n-//! }\n-//!\n-//! fn main() {\n-//!     let mut flags = FlagA | FlagB;\n-//!     flags.clear();\n-//!     assert!(flags.is_empty());\n-//!     assert_eq!(format!(\"{}\", flags).as_slice(), \"hi!\");\n-//! }\n-//! ~~~\n-//!\n-//! # Attributes\n-//!\n-//! Attributes can be attached to the generated `struct` by placing them\n-//! before the `flags` keyword.\n-//!\n-//! # Derived traits\n-//!\n-//! The `PartialEq` and `Clone` traits are automatically derived for the `struct` using\n-//! the `deriving` attribute. Additional traits can be derived by providing an\n-//! explicit `deriving` attribute on `flags`.\n-//!\n-//! # Operators\n-//!\n-//! The following operator traits are implemented for the generated `struct`:\n-//!\n-//! - `BitOr`: union\n-//! - `BitAnd`: intersection\n-//! - `Sub`: set difference\n-//! - `Not`: set complement\n-//!\n-//! # Methods\n-//!\n-//! The following methods are defined for the generated `struct`:\n-//!\n-//! - `empty`: an empty set of flags\n-//! - `all`: the set of all flags\n-//! - `bits`: the raw value of the flags currently stored\n-//! - `is_empty`: `true` if no flags are currently stored\n-//! - `is_all`: `true` if all flags are currently set\n-//! - `intersects`: `true` if there are flags common to both `self` and `other`\n-//! - `contains`: `true` all of the flags in `other` are contained within `self`\n-//! - `insert`: inserts the specified flags in-place\n-//! - `remove`: removes the specified flags in-place\n-\n #![experimental]\n #![macro_escape]\n \n+//! A typesafe bitmask flag generator.\n+\n+/// The `bitflags!` macro generates a `struct` that holds a set of C-style\n+/// bitmask flags. It is useful for creating typesafe wrappers for C APIs.\n+///\n+/// The flags should only be defined for integer types, otherwise unexpected\n+/// type errors may occur at compile time.\n+///\n+/// # Example\n+///\n+/// ~~~rust\n+/// bitflags! {\n+///     flags Flags: u32 {\n+///         static FlagA       = 0x00000001,\n+///         static FlagB       = 0x00000010,\n+///         static FlagC       = 0x00000100,\n+///         static FlagABC     = FlagA.bits\n+///                            | FlagB.bits\n+///                            | FlagC.bits,\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let e1 = FlagA | FlagC;\n+///     let e2 = FlagB | FlagC;\n+///     assert!((e1 | e2) == FlagABC);   // union\n+///     assert!((e1 & e2) == FlagC);     // intersection\n+///     assert!((e1 - e2) == FlagA);     // set difference\n+///     assert!(!e2 == FlagA);           // set complement\n+/// }\n+/// ~~~\n+///\n+/// The generated `struct`s can also be extended with type and trait implementations:\n+///\n+/// ~~~rust\n+/// use std::fmt;\n+///\n+/// bitflags! {\n+///     flags Flags: u32 {\n+///         static FlagA   = 0x00000001,\n+///         static FlagB   = 0x00000010,\n+///     }\n+/// }\n+///\n+/// impl Flags {\n+///     pub fn clear(&mut self) {\n+///         self.bits = 0;  // The `bits` field can be accessed from within the\n+///                         // same module where the `bitflags!` macro was invoked.\n+///     }\n+/// }\n+///\n+/// impl fmt::Show for Flags {\n+///     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+///         write!(f, \"hi!\")\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let mut flags = FlagA | FlagB;\n+///     flags.clear();\n+///     assert!(flags.is_empty());\n+///     assert_eq!(format!(\"{}\", flags).as_slice(), \"hi!\");\n+/// }\n+/// ~~~\n+///\n+/// # Attributes\n+///\n+/// Attributes can be attached to the generated `struct` by placing them\n+/// before the `flags` keyword.\n+///\n+/// # Derived traits\n+///\n+/// The `PartialEq` and `Clone` traits are automatically derived for the `struct` using\n+/// the `deriving` attribute. Additional traits can be derived by providing an\n+/// explicit `deriving` attribute on `flags`.\n+///\n+/// # Operators\n+///\n+/// The following operator traits are implemented for the generated `struct`:\n+///\n+/// - `BitOr`: union\n+/// - `BitAnd`: intersection\n+/// - `Sub`: set difference\n+/// - `Not`: set complement\n+///\n+/// # Methods\n+///\n+/// The following methods are defined for the generated `struct`:\n+///\n+/// - `empty`: an empty set of flags\n+/// - `all`: the set of all flags\n+/// - `bits`: the raw value of the flags currently stored\n+/// - `is_empty`: `true` if no flags are currently stored\n+/// - `is_all`: `true` if all flags are currently set\n+/// - `intersects`: `true` if there are flags common to both `self` and `other`\n+/// - `contains`: `true` all of the flags in `other` are contained within `self`\n+/// - `insert`: inserts the specified flags in-place\n+/// - `remove`: removes the specified flags in-place\n #[macro_export]\n-macro_rules! bitflags(\n+macro_rules! bitflags {\n     ($(#[$attr:meta])* flags $BitFlags:ident: $T:ty {\n         $($(#[$Flag_attr:meta])* static $Flag:ident = $value:expr),+\n-    }) => (\n+    }) => {\n         #[deriving(PartialEq, Eq, Clone, PartialOrd, Ord, Hash)]\n         $(#[$attr])*\n         pub struct $BitFlags {\n@@ -215,25 +216,43 @@ macro_rules! bitflags(\n                 $BitFlags { bits: !self.bits } & $BitFlags::all()\n             }\n         }\n-    )\n-)\n+    };\n+    ($(#[$attr:meta])* flags $BitFlags:ident: $T:ty {\n+        $($(#[$Flag_attr:meta])* static $Flag:ident = $value:expr),+,\n+    }) => {\n+        bitflags! {\n+            $(#[$attr])*\n+            flags $BitFlags: u32 {\n+                $($(#[$Flag_attr])* static $Flag = $value),+\n+            }\n+        }\n+    };\n+}\n \n #[cfg(test)]\n mod tests {\n     use hash;\n     use option::{Some, None};\n     use ops::{BitOr, BitAnd, Sub, Not};\n \n-    bitflags!(\n+    bitflags! {\n+        #[doc = \"> The first principle is that you must not fool yourself \u2014 and\"]\n+        #[doc = \"> you are the easiest person to fool.\"]\n+        #[doc = \"> \"]\n+        #[doc = \"> - Richard Feynman\"]\n         flags Flags: u32 {\n             static FlagA       = 0x00000001,\n+            #[doc = \"<pcwalton> macros are way better at generating code than trans is\"]\n             static FlagB       = 0x00000010,\n             static FlagC       = 0x00000100,\n+            #[doc = \"* cmr bed\"]\n+            #[doc = \"* strcat table\"]\n+            #[doc = \"<strcat> wait what?\"]\n             static FlagABC     = FlagA.bits\n                                | FlagB.bits\n-                               | FlagC.bits\n+                               | FlagC.bits,\n         }\n-    )\n+    }\n \n     #[test]\n     fn test_bits(){"}, {"sha": "e2de8becb3487b503e3dbc15d5457a63a7465c71", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e024017f60c93b6ff4f37bd4bd580f30deafb107/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e024017f60c93b6ff4f37bd4bd580f30deafb107/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=e024017f60c93b6ff4f37bd4bd580f30deafb107", "patch": "@@ -1794,9 +1794,9 @@ pub struct UnstableFileStat {\n     pub gen: u64,\n }\n \n-bitflags!(\n-    #[doc=\"A set of permissions for a file or directory is represented\n-by a set of flags which are or'd together.\"]\n+bitflags! {\n+    #[doc = \"A set of permissions for a file or directory is represented\"]\n+    #[doc = \"by a set of flags which are or'd together.\"]\n     flags FilePermission: u32 {\n         static UserRead     = 0o400,\n         static UserWrite    = 0o200,\n@@ -1812,23 +1812,23 @@ by a set of flags which are or'd together.\"]\n         static GroupRWX = GroupRead.bits | GroupWrite.bits | GroupExecute.bits,\n         static OtherRWX = OtherRead.bits | OtherWrite.bits | OtherExecute.bits,\n \n-        #[doc=\"Permissions for user owned files, equivalent to 0644 on\n-unix-like systems.\"]\n+        #[doc = \"Permissions for user owned files, equivalent to 0644 on\"]\n+        #[doc = \"unix-like systems.\"]\n         static UserFile = UserRead.bits | UserWrite.bits | GroupRead.bits | OtherRead.bits,\n \n-        #[doc=\"Permissions for user owned directories, equivalent to 0755 on\n-unix-like systems.\"]\n+        #[doc = \"Permissions for user owned directories, equivalent to 0755 on\"]\n+        #[doc = \"unix-like systems.\"]\n         static UserDir  = UserRWX.bits | GroupRead.bits | GroupExecute.bits |\n                    OtherRead.bits | OtherExecute.bits,\n \n-        #[doc=\"Permissions for user owned executables, equivalent to 0755\n-on unix-like systems.\"]\n+        #[doc = \"Permissions for user owned executables, equivalent to 0755\"]\n+        #[doc = \"on unix-like systems.\"]\n         static UserExec = UserDir.bits,\n \n-        #[doc=\"All possible permissions enabled.\"]\n-        static AllPermissions = UserRWX.bits | GroupRWX.bits | OtherRWX.bits\n+        #[doc = \"All possible permissions enabled.\"]\n+        static AllPermissions = UserRWX.bits | GroupRWX.bits | OtherRWX.bits,\n     }\n-)\n+}\n \n impl Default for FilePermission {\n     #[inline]"}, {"sha": "08255ba0cb2f491ccd86600144e49b95cce29b2f", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e024017f60c93b6ff4f37bd4bd580f30deafb107/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e024017f60c93b6ff4f37bd4bd580f30deafb107/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=e024017f60c93b6ff4f37bd4bd580f30deafb107", "patch": "@@ -281,7 +281,7 @@ mod std {\n     pub use fmt; // used for any formatting strings\n     pub use io; // used for println!()\n     pub use local_data; // used for local_data_key!()\n-    pub use option; // used for bitflags!()\n+    pub use option; // used for bitflags!{}\n     pub use rt; // used for fail!()\n     pub use vec; // used for vec![]\n "}]}