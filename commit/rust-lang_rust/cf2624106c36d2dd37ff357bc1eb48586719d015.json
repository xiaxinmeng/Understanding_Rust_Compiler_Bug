{"sha": "cf2624106c36d2dd37ff357bc1eb48586719d015", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmMjYyNDEwNmMzNmQyZGQzN2ZmMzU3YmMxZWI0ODU4NjcxOWQwMTU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-10-27T22:35:56Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-10-27T22:35:56Z"}, "message": "Document std::bitv", "tree": {"sha": "aff99b71f72959ac199c9cde16de5e631e28fa8a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aff99b71f72959ac199c9cde16de5e631e28fa8a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf2624106c36d2dd37ff357bc1eb48586719d015", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf2624106c36d2dd37ff357bc1eb48586719d015", "html_url": "https://github.com/rust-lang/rust/commit/cf2624106c36d2dd37ff357bc1eb48586719d015", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf2624106c36d2dd37ff357bc1eb48586719d015/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33f2f22befbe38f5ce6a5ec500fcd272f529da87", "url": "https://api.github.com/repos/rust-lang/rust/commits/33f2f22befbe38f5ce6a5ec500fcd272f529da87", "html_url": "https://github.com/rust-lang/rust/commit/33f2f22befbe38f5ce6a5ec500fcd272f529da87"}], "stats": {"total": 128, "additions": 125, "deletions": 3}, "files": [{"sha": "851a26237ee8995c2dfd3d3ee95987dbed417545", "filename": "src/lib/bitv.rs", "status": "modified", "additions": 125, "deletions": 3, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/cf2624106c36d2dd37ff357bc1eb48586719d015/src%2Flib%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf2624106c36d2dd37ff357bc1eb48586719d015/src%2Flib%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fbitv.rs?ref=cf2624106c36d2dd37ff357bc1eb48586719d015", "patch": "@@ -68,28 +68,67 @@ fn process(op: block(uint, uint) -> uint, v0: t, v1: t) -> bool {\n     ret changed;\n }\n \n+\n fn lor(w0: uint, w1: uint) -> uint { ret w0 | w1; }\n \n fn union(v0: t, v1: t) -> bool { let sub = lor; ret process(sub, v0, v1); }\n \n fn land(w0: uint, w1: uint) -> uint { ret w0 & w1; }\n \n+/*\n+Function: intersect\n+\n+Calculates the intersection of two bitvectors\n+\n+Sets `v0` to the intersection of `v0` and `v1`\n+\n+Preconditions:\n+\n+Both bitvectors must be the same length\n+\n+Returns:\n+\n+True if `v0` was changed\n+*/\n fn intersect(v0: t, v1: t) -> bool {\n     let sub = land;\n     ret process(sub, v0, v1);\n }\n \n fn right(_w0: uint, w1: uint) -> uint { ret w1; }\n \n+/*\n+Function: assign\n+\n+Assigns the value of `v1` to `v0`\n+\n+Preconditions:\n+\n+Both bitvectors must be the same length\n+\n+Returns:\n+\n+True if `v0` was changed\n+*/\n fn assign(v0: t, v1: t) -> bool { let sub = right; ret process(sub, v0, v1); }\n \n+/*\n+Function: clone\n+\n+Makes a copy of a bitvector\n+*/\n fn clone(v: t) -> t {\n     let storage = vec::init_elt_mut::<uint>(0u, v.nbits / uint_bits() + 1u);\n     let len = vec::len(v.storage);\n     uint::range(0u, len) {|i| storage[i] = v.storage[i]; };\n     ret @{storage: storage, nbits: v.nbits};\n }\n \n+/*\n+Function: get\n+\n+Retreive the value at index `i`\n+*/\n fn get(v: t, i: uint) -> bool {\n     assert (i < v.nbits);\n     let bits = uint_bits();\n@@ -99,6 +138,21 @@ fn get(v: t, i: uint) -> bool {\n     ret x == 1u;\n }\n \n+// FIXME: This doesn't account for the actual size of the vectors,\n+// so it could end up comparing garbage bits\n+/*\n+Function: equal\n+\n+Compares two bitvectors\n+\n+Preconditions:\n+\n+Both bitvectors must be the same length\n+\n+Returns:\n+\n+True if both bitvectors contain identical elements\n+*/\n fn equal(v0: t, v1: t) -> bool {\n     // FIXME: when we can break or return from inside an iterator loop,\n     //        we can eliminate this painful while-loop\n@@ -112,29 +166,67 @@ fn equal(v0: t, v1: t) -> bool {\n     ret true;\n }\n \n+/*\n+Function: clear\n+\n+Set all bits to 0\n+*/\n fn clear(v: t) {\n     uint::range(0u, vec::len(v.storage)) {|i| v.storage[i] = 0u; };\n }\n \n+/*\n+Function: set_all\n+\n+Set all bits to 1\n+*/\n fn set_all(v: t) {\n     uint::range(0u, v.nbits) {|i| set(v, i, true); };\n }\n \n+/*\n+Function: invert\n+\n+Invert all bits\n+*/\n fn invert(v: t) {\n     uint::range(0u, vec::len(v.storage)) {|i|\n         v.storage[i] = !v.storage[i];\n     };\n }\n \n+/*\n+Function: difference\n+\n+Calculate the difference between two bitvectors\n+\n+Sets each element of `v0` to the value of that element minus the element\n+of `v1` at the same index.\n+\n+Preconditions:\n+\n+Both bitvectors must be the same length\n \n-/* v0 = v0 - v1 */\n+Returns:\n+\n+True if `v0` was changed\n+*/\n fn difference(v0: t, v1: t) -> bool {\n     invert(v1);\n     let b = intersect(v0, v1);\n     invert(v1);\n     ret b;\n }\n \n+/*\n+Function: set\n+\n+Set the value of a bit at a given index\n+\n+Preconditions:\n+\n+`i` must be less than the length of the bitvector\n+*/\n fn set(v: t, i: uint, x: bool) {\n     assert (i < v.nbits);\n     let bits = uint_bits();\n@@ -145,32 +237,62 @@ fn set(v: t, i: uint, x: bool) {\n }\n \n \n-/* true if all bits are 1 */\n+/*\n+Function: is_true\n+\n+Returns true if all bits are 1\n+*/\n fn is_true(v: t) -> bool {\n     for i: uint in to_vec(v) { if i != 1u { ret false; } }\n     ret true;\n }\n \n \n-/* true if all bits are non-1 */\n+/*\n+Function: is_false\n+\n+Returns true if all bits are 0\n+*/\n fn is_false(v: t) -> bool {\n     for i: uint in to_vec(v) { if i == 1u { ret false; } }\n     ret true;\n }\n \n fn init_to_vec(v: t, i: uint) -> uint { ret if get(v, i) { 1u } else { 0u }; }\n \n+/*\n+Function: to_vec\n+\n+Converts the bitvector to a vector of uint with the same length. Each uint\n+in the resulting vector has either value 0u or 1u.\n+*/\n fn to_vec(v: t) -> [uint] {\n     let sub = bind init_to_vec(v, _);\n     ret vec::init_fn::<uint>(sub, v.nbits);\n }\n \n+/*\n+Function: to_str\n+\n+Converts the bitvector to a string. The resulting string has the same\n+length as the bitvector, and each character is either '0' or '1'.\n+*/\n fn to_str(v: t) -> str {\n     let rs = \"\";\n     for i: uint in to_vec(v) { if i == 1u { rs += \"1\"; } else { rs += \"0\"; } }\n     ret rs;\n }\n \n+/*\n+Function: eq_vec\n+\n+Compare a bitvector to a vector of uint. The uint vector is expected to\n+only contain the values 0u and 1u.\n+\n+Preconditions:\n+\n+Both the bitvector and vector must have the same length\n+*/\n fn eq_vec(v0: t, v1: [uint]) -> bool {\n     assert (v0.nbits == vec::len::<uint>(v1));\n     let len = v0.nbits;"}]}