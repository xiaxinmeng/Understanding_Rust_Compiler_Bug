{"sha": "ed2a5115daaffdab30b102405ffcfb222decf444", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkMmE1MTE1ZGFhZmZkYWIzMGIxMDI0MDVmZmNmYjIyMmRlY2Y0NDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-27T01:10:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-27T01:10:22Z"}, "message": "Auto merge of #61147 - estebank:suggest-as-ref, r=oli-obk\n\nWhen encountering move error on an `Option`, suggest using `as_ref`\n\nFix #61109, cc #15457.", "tree": {"sha": "3b4999c145e6b84429035e422d0bf5a2e9e4e8f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b4999c145e6b84429035e422d0bf5a2e9e4e8f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ed2a5115daaffdab30b102405ffcfb222decf444", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ed2a5115daaffdab30b102405ffcfb222decf444", "html_url": "https://github.com/rust-lang/rust/commit/ed2a5115daaffdab30b102405ffcfb222decf444", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ed2a5115daaffdab30b102405ffcfb222decf444/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37c45ec3980f97ecd06617d3315105eec9247432", "url": "https://api.github.com/repos/rust-lang/rust/commits/37c45ec3980f97ecd06617d3315105eec9247432", "html_url": "https://github.com/rust-lang/rust/commit/37c45ec3980f97ecd06617d3315105eec9247432"}, {"sha": "1cc42ea6750affbef2bca699bde30ac321e15939", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cc42ea6750affbef2bca699bde30ac321e15939", "html_url": "https://github.com/rust-lang/rust/commit/1cc42ea6750affbef2bca699bde30ac321e15939"}], "stats": {"total": 266, "additions": 189, "deletions": 77}, "files": [{"sha": "63d5cd4372f4a1f11736427266c5567804bd14c5", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 90, "deletions": 77, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/ed2a5115daaffdab30b102405ffcfb222decf444/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed2a5115daaffdab30b102405ffcfb222decf444/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=ed2a5115daaffdab30b102405ffcfb222decf444", "patch": "@@ -242,12 +242,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n         let (mut err, err_span) = {\n             let (span, original_path, kind): (Span, &Place<'tcx>, &IllegalMoveOriginKind<'_>) =\n                 match error {\n-                    GroupedMoveError::MovesFromPlace {\n-                        span,\n-                        ref original_path,\n-                        ref kind,\n-                        ..\n-                    } |\n+                    GroupedMoveError::MovesFromPlace { span, ref original_path, ref kind, .. } |\n                     GroupedMoveError::MovesFromValue { span, ref original_path, ref kind, .. } |\n                     GroupedMoveError::OtherIllegalMove { span, ref original_path, ref kind } => {\n                         (span, original_path, kind)\n@@ -257,81 +252,99 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             debug!(\"report: original_path={:?} span={:?}, kind={:?} \\\n                    original_path.is_upvar_field_projection={:?}\", original_path, span, kind,\n                    self.is_upvar_field_projection(original_path));\n-            (\n-                match kind {\n-                    IllegalMoveOriginKind::Static => {\n-                        self.infcx.tcx.cannot_move_out_of(span, \"static item\", origin)\n-                    }\n-                    IllegalMoveOriginKind::BorrowedContent { target_place: place } => {\n-                        // Inspect the type of the content behind the\n-                        // borrow to provide feedback about why this\n-                        // was a move rather than a copy.\n-                        let ty = place.ty(self.mir, self.infcx.tcx).ty;\n-                        let is_upvar_field_projection =\n-                            self.prefixes(&original_path, PrefixSet::All)\n-                            .any(|p| self.is_upvar_field_projection(p).is_some());\n-                        debug!(\"report: ty={:?}\", ty);\n-                        match ty.sty {\n-                            ty::Array(..) | ty::Slice(..) =>\n-                                self.infcx.tcx.cannot_move_out_of_interior_noncopy(\n-                                    span, ty, None, origin\n-                                ),\n-                            ty::Closure(def_id, closure_substs)\n-                                if def_id == self.mir_def_id && is_upvar_field_projection\n-                            => {\n-                                let closure_kind_ty =\n-                                    closure_substs.closure_kind_ty(def_id, self.infcx.tcx);\n-                                let closure_kind = closure_kind_ty.to_opt_closure_kind();\n-                                let place_description = match closure_kind {\n-                                    Some(ty::ClosureKind::Fn) => {\n-                                        \"captured variable in an `Fn` closure\"\n-                                    }\n-                                    Some(ty::ClosureKind::FnMut) => {\n-                                        \"captured variable in an `FnMut` closure\"\n-                                    }\n-                                    Some(ty::ClosureKind::FnOnce) => {\n-                                        bug!(\"closure kind does not match first argument type\")\n-                                    }\n-                                    None => bug!(\"closure kind not inferred by borrowck\"),\n-                                };\n-                                debug!(\"report: closure_kind_ty={:?} closure_kind={:?} \\\n-                                       place_description={:?}\", closure_kind_ty, closure_kind,\n-                                       place_description);\n-\n-                                let mut diag = self.infcx.tcx.cannot_move_out_of(\n-                                    span, place_description, origin);\n-\n-                                for prefix in self.prefixes(&original_path, PrefixSet::All) {\n-                                    if let Some(field) = self.is_upvar_field_projection(prefix) {\n-                                        let upvar_hir_id = self.upvars[field.index()].var_hir_id;\n-                                        let upvar_span = self.infcx.tcx.hir().span_by_hir_id(\n-                                            upvar_hir_id);\n-                                        diag.span_label(upvar_span, \"captured outer variable\");\n-                                        break;\n-                                    }\n+            let err = match kind {\n+                IllegalMoveOriginKind::Static => {\n+                    self.infcx.tcx.cannot_move_out_of(span, \"static item\", origin)\n+                }\n+                IllegalMoveOriginKind::BorrowedContent { target_place: place } => {\n+                    // Inspect the type of the content behind the\n+                    // borrow to provide feedback about why this\n+                    // was a move rather than a copy.\n+                    let ty = place.ty(self.mir, self.infcx.tcx).ty;\n+                    let is_upvar_field_projection =\n+                        self.prefixes(&original_path, PrefixSet::All)\n+                        .any(|p| self.is_upvar_field_projection(p).is_some());\n+                    debug!(\"report: ty={:?}\", ty);\n+                    let mut err = match ty.sty {\n+                        ty::Array(..) | ty::Slice(..) =>\n+                            self.infcx.tcx.cannot_move_out_of_interior_noncopy(\n+                                span, ty, None, origin\n+                            ),\n+                        ty::Closure(def_id, closure_substs)\n+                            if def_id == self.mir_def_id && is_upvar_field_projection\n+                        => {\n+                            let closure_kind_ty =\n+                                closure_substs.closure_kind_ty(def_id, self.infcx.tcx);\n+                            let closure_kind = closure_kind_ty.to_opt_closure_kind();\n+                            let place_description = match closure_kind {\n+                                Some(ty::ClosureKind::Fn) => {\n+                                    \"captured variable in an `Fn` closure\"\n+                                }\n+                                Some(ty::ClosureKind::FnMut) => {\n+                                    \"captured variable in an `FnMut` closure\"\n+                                }\n+                                Some(ty::ClosureKind::FnOnce) => {\n+                                    bug!(\"closure kind does not match first argument type\")\n+                                }\n+                                None => bug!(\"closure kind not inferred by borrowck\"),\n+                            };\n+                            debug!(\"report: closure_kind_ty={:?} closure_kind={:?} \\\n+                                    place_description={:?}\", closure_kind_ty, closure_kind,\n+                                    place_description);\n+\n+                            let mut diag = self.infcx.tcx.cannot_move_out_of(\n+                                span, place_description, origin);\n+\n+                            for prefix in self.prefixes(&original_path, PrefixSet::All) {\n+                                if let Some(field) = self.is_upvar_field_projection(prefix) {\n+                                    let upvar_hir_id = self.upvars[field.index()].var_hir_id;\n+                                    let upvar_span = self.infcx.tcx.hir().span_by_hir_id(\n+                                        upvar_hir_id);\n+                                    diag.span_label(upvar_span, \"captured outer variable\");\n+                                    break;\n                                 }\n-\n-                                diag\n                             }\n-                            _ => {\n-                                let source = self.borrowed_content_source(place);\n-                                self.infcx.tcx.cannot_move_out_of(\n-                                    span, &source.to_string(), origin\n-                                )\n-                            },\n+\n+                            diag\n                         }\n+                        _ => {\n+                            let source = self.borrowed_content_source(place);\n+                            self.infcx.tcx.cannot_move_out_of(\n+                                span, &source.to_string(), origin\n+                            )\n+                        },\n+                    };\n+                    let orig_path_ty = format!(\n+                        \"{:?}\",\n+                        original_path.ty(self.mir, self.infcx.tcx).ty,\n+                    );\n+                    let snippet = self.infcx.tcx.sess.source_map().span_to_snippet(span).unwrap();\n+                    let is_option = orig_path_ty.starts_with(\"std::option::Option\");\n+                    let is_result = orig_path_ty.starts_with(\"std::result::Result\");\n+                    if  is_option || is_result {\n+                        err.span_suggestion(\n+                            span,\n+                            &format!(\"consider borrowing the `{}`'s content\", if is_option {\n+                                \"Option\"\n+                            } else {\n+                                \"Result\"\n+                            }),\n+                            format!(\"{}.as_ref()\", snippet),\n+                            Applicability::MaybeIncorrect,\n+                        );\n                     }\n-                    IllegalMoveOriginKind::InteriorOfTypeWithDestructor { container_ty: ty } => {\n-                        self.infcx.tcx\n-                            .cannot_move_out_of_interior_of_drop(span, ty, origin)\n-                    }\n-                    IllegalMoveOriginKind::InteriorOfSliceOrArray { ty, is_index } =>\n-                        self.infcx.tcx.cannot_move_out_of_interior_noncopy(\n-                            span, ty, Some(*is_index), origin\n-                        ),\n-                },\n-                span,\n-            )\n+                    err\n+                }\n+                IllegalMoveOriginKind::InteriorOfTypeWithDestructor { container_ty: ty } => {\n+                    self.infcx.tcx\n+                        .cannot_move_out_of_interior_of_drop(span, ty, origin)\n+                }\n+                IllegalMoveOriginKind::InteriorOfSliceOrArray { ty, is_index } =>\n+                    self.infcx.tcx.cannot_move_out_of_interior_noncopy(\n+                        span, ty, Some(*is_index), origin\n+                    ),\n+            };\n+            (err, span)\n         };\n \n         self.add_move_hints(error, &mut err, err_span);"}, {"sha": "f163cd104ffa53c4be0f740228c0e6faa0bb686c", "filename": "src/test/ui/suggestions/option-content-move.fixed", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ed2a5115daaffdab30b102405ffcfb222decf444/src%2Ftest%2Fui%2Fsuggestions%2Foption-content-move.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/ed2a5115daaffdab30b102405ffcfb222decf444/src%2Ftest%2Fui%2Fsuggestions%2Foption-content-move.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Foption-content-move.fixed?ref=ed2a5115daaffdab30b102405ffcfb222decf444", "patch": "@@ -0,0 +1,39 @@\n+//run-rustfix\n+\n+pub struct LipogramCorpora {\n+    selections: Vec<(char, Option<String>)>,\n+}\n+\n+impl LipogramCorpora {\n+    pub fn validate_all(&mut self) -> Result<(), char> {\n+        for selection in &self.selections {\n+            if selection.1.is_some() {\n+                if selection.1.as_ref().unwrap().contains(selection.0) {\n+                //~^ ERROR cannot move out of borrowed content\n+                    return Err(selection.0);\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+pub struct LipogramCorpora2 {\n+    selections: Vec<(char, Result<String, String>)>,\n+}\n+\n+impl LipogramCorpora2 {\n+    pub fn validate_all(&mut self) -> Result<(), char> {\n+        for selection in &self.selections {\n+            if selection.1.is_ok() {\n+                if selection.1.as_ref().unwrap().contains(selection.0) {\n+                //~^ ERROR cannot move out of borrowed content\n+                    return Err(selection.0);\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "350486a802d312217dc882c3653ba50f85bc339c", "filename": "src/test/ui/suggestions/option-content-move.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ed2a5115daaffdab30b102405ffcfb222decf444/src%2Ftest%2Fui%2Fsuggestions%2Foption-content-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed2a5115daaffdab30b102405ffcfb222decf444/src%2Ftest%2Fui%2Fsuggestions%2Foption-content-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Foption-content-move.rs?ref=ed2a5115daaffdab30b102405ffcfb222decf444", "patch": "@@ -0,0 +1,39 @@\n+//run-rustfix\n+\n+pub struct LipogramCorpora {\n+    selections: Vec<(char, Option<String>)>,\n+}\n+\n+impl LipogramCorpora {\n+    pub fn validate_all(&mut self) -> Result<(), char> {\n+        for selection in &self.selections {\n+            if selection.1.is_some() {\n+                if selection.1.unwrap().contains(selection.0) {\n+                //~^ ERROR cannot move out of borrowed content\n+                    return Err(selection.0);\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+pub struct LipogramCorpora2 {\n+    selections: Vec<(char, Result<String, String>)>,\n+}\n+\n+impl LipogramCorpora2 {\n+    pub fn validate_all(&mut self) -> Result<(), char> {\n+        for selection in &self.selections {\n+            if selection.1.is_ok() {\n+                if selection.1.unwrap().contains(selection.0) {\n+                //~^ ERROR cannot move out of borrowed content\n+                    return Err(selection.0);\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "0a325ac54eaf10f23384f5f2692846376233c32a", "filename": "src/test/ui/suggestions/option-content-move.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ed2a5115daaffdab30b102405ffcfb222decf444/src%2Ftest%2Fui%2Fsuggestions%2Foption-content-move.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ed2a5115daaffdab30b102405ffcfb222decf444/src%2Ftest%2Fui%2Fsuggestions%2Foption-content-move.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Foption-content-move.stderr?ref=ed2a5115daaffdab30b102405ffcfb222decf444", "patch": "@@ -0,0 +1,21 @@\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/option-content-move.rs:11:20\n+   |\n+LL |                 if selection.1.unwrap().contains(selection.0) {\n+   |                    ^^^^^^^^^^^\n+   |                    |\n+   |                    cannot move out of borrowed content\n+   |                    help: consider borrowing the `Option`'s content: `selection.1.as_ref()`\n+\n+error[E0507]: cannot move out of borrowed content\n+  --> $DIR/option-content-move.rs:29:20\n+   |\n+LL |                 if selection.1.unwrap().contains(selection.0) {\n+   |                    ^^^^^^^^^^^\n+   |                    |\n+   |                    cannot move out of borrowed content\n+   |                    help: consider borrowing the `Result`'s content: `selection.1.as_ref()`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0507`."}]}