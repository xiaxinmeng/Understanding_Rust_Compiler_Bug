{"sha": "932aa893fd302172f6d5cabc64f092a159d2a0e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzMmFhODkzZmQzMDIxNzJmNmQ1Y2FiYzY0ZjA5MmExNTlkMmEwZTU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-15T10:27:24Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-04-15T10:27:24Z"}, "message": "syntax: Move comment-extraction code to its own module", "tree": {"sha": "0320fda0155bcfaf21439cd7f73196eb388f1f74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0320fda0155bcfaf21439cd7f73196eb388f1f74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/932aa893fd302172f6d5cabc64f092a159d2a0e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/932aa893fd302172f6d5cabc64f092a159d2a0e5", "html_url": "https://github.com/rust-lang/rust/commit/932aa893fd302172f6d5cabc64f092a159d2a0e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/932aa893fd302172f6d5cabc64f092a159d2a0e5/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f576275be8473a17052300aabb811a767ad7b1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f576275be8473a17052300aabb811a767ad7b1b", "html_url": "https://github.com/rust-lang/rust/commit/4f576275be8473a17052300aabb811a767ad7b1b"}], "stats": {"total": 421, "additions": 213, "deletions": 208}, "files": [{"sha": "5e46162ae98761fc9a8901ecc918e3c98c3fbaa3", "filename": "src/librustsyntax/parse/comments.rs", "status": "added", "additions": 195, "deletions": 0, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/932aa893fd302172f6d5cabc64f092a159d2a0e5/src%2Flibrustsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932aa893fd302172f6d5cabc64f092a159d2a0e5/src%2Flibrustsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Fcomments.rs?ref=932aa893fd302172f6d5cabc64f092a159d2a0e5", "patch": "@@ -0,0 +1,195 @@\n+import io::reader_util;\n+import util::interner;\n+import lexer::{ reader, new_reader, next_token, is_whitespace };\n+\n+enum cmnt_style {\n+    isolated, // No code on either side of each line of the comment\n+    trailing, // Code exists to the left of the comment\n+    mixed, // Code before /* foo */ and after the comment\n+    blank_line, // Just a manual blank line \"\\n\\n\", for layout\n+}\n+\n+type cmnt = {style: cmnt_style, lines: [str], pos: uint};\n+\n+fn read_to_eol(rdr: reader) -> str {\n+    let mut val = \"\";\n+    while rdr.curr != '\\n' && !rdr.is_eof() {\n+        str::push_char(val, rdr.curr);\n+        rdr.bump();\n+    }\n+    if rdr.curr == '\\n' { rdr.bump(); }\n+    ret val;\n+}\n+\n+fn read_one_line_comment(rdr: reader) -> str {\n+    let val = read_to_eol(rdr);\n+    assert (val[0] == '/' as u8 && val[1] == '/' as u8);\n+    ret val;\n+}\n+\n+fn consume_non_eol_whitespace(rdr: reader) {\n+    while is_whitespace(rdr.curr) && rdr.curr != '\\n' && !rdr.is_eof() {\n+        rdr.bump();\n+    }\n+}\n+\n+fn push_blank_line_comment(rdr: reader, &comments: [cmnt]) {\n+    #debug(\">>> blank-line comment\");\n+    let v: [str] = [];\n+    comments += [{style: blank_line, lines: v, pos: rdr.chpos}];\n+}\n+\n+fn consume_whitespace_counting_blank_lines(rdr: reader, &comments: [cmnt]) {\n+    while is_whitespace(rdr.curr) && !rdr.is_eof() {\n+        if rdr.col == 0u && rdr.curr == '\\n' {\n+            push_blank_line_comment(rdr, comments);\n+        }\n+        rdr.bump();\n+    }\n+}\n+\n+fn read_line_comments(rdr: reader, code_to_the_left: bool) -> cmnt {\n+    #debug(\">>> line comments\");\n+    let p = rdr.chpos;\n+    let mut lines: [str] = [];\n+    while rdr.curr == '/' && rdr.next() == '/' {\n+        let line = read_one_line_comment(rdr);\n+        log(debug, line);\n+        lines += [line];\n+        consume_non_eol_whitespace(rdr);\n+    }\n+    #debug(\"<<< line comments\");\n+    ret {style: if code_to_the_left { trailing } else { isolated },\n+         lines: lines,\n+         pos: p};\n+}\n+\n+fn all_whitespace(s: str, begin: uint, end: uint) -> bool {\n+    let mut i: uint = begin;\n+    while i != end { if !is_whitespace(s[i] as char) { ret false; } i += 1u; }\n+    ret true;\n+}\n+\n+fn trim_whitespace_prefix_and_push_line(&lines: [str],\n+                                        s: str, col: uint) unsafe {\n+    let mut s1;\n+    if all_whitespace(s, 0u, col) {\n+        if col < str::len(s) {\n+            s1 = str::slice(s, col, str::len(s));\n+        } else { s1 = \"\"; }\n+    } else { s1 = s; }\n+    log(debug, \"pushing line: \" + s1);\n+    lines += [s1];\n+}\n+\n+fn read_block_comment(rdr: reader, code_to_the_left: bool) -> cmnt {\n+    #debug(\">>> block comment\");\n+    let p = rdr.chpos;\n+    let mut lines: [str] = [];\n+    let mut col: uint = rdr.col;\n+    rdr.bump();\n+    rdr.bump();\n+    let mut curr_line = \"/*\";\n+    let mut level: int = 1;\n+    while level > 0 {\n+        #debug(\"=== block comment level %d\", level);\n+        if rdr.is_eof() { rdr.fatal(\"unterminated block comment\"); }\n+        if rdr.curr == '\\n' {\n+            trim_whitespace_prefix_and_push_line(lines, curr_line, col);\n+            curr_line = \"\";\n+            rdr.bump();\n+        } else {\n+            str::push_char(curr_line, rdr.curr);\n+            if rdr.curr == '/' && rdr.next() == '*' {\n+                rdr.bump();\n+                rdr.bump();\n+                curr_line += \"*\";\n+                level += 1;\n+            } else {\n+                if rdr.curr == '*' && rdr.next() == '/' {\n+                    rdr.bump();\n+                    rdr.bump();\n+                    curr_line += \"/\";\n+                    level -= 1;\n+                } else { rdr.bump(); }\n+            }\n+        }\n+    }\n+    if str::len(curr_line) != 0u {\n+        trim_whitespace_prefix_and_push_line(lines, curr_line, col);\n+    }\n+    let mut style = if code_to_the_left { trailing } else { isolated };\n+    consume_non_eol_whitespace(rdr);\n+    if !rdr.is_eof() && rdr.curr != '\\n' && vec::len(lines) == 1u {\n+        style = mixed;\n+    }\n+    #debug(\"<<< block comment\");\n+    ret {style: style, lines: lines, pos: p};\n+}\n+\n+fn peeking_at_comment(rdr: reader) -> bool {\n+    ret rdr.curr == '/' && rdr.next() == '/' ||\n+            rdr.curr == '/' && rdr.next() == '*';\n+}\n+\n+fn consume_comment(rdr: reader, code_to_the_left: bool, &comments: [cmnt]) {\n+    #debug(\">>> consume comment\");\n+    if rdr.curr == '/' && rdr.next() == '/' {\n+        comments += [read_line_comments(rdr, code_to_the_left)];\n+    } else if rdr.curr == '/' && rdr.next() == '*' {\n+        comments += [read_block_comment(rdr, code_to_the_left)];\n+    } else { fail; }\n+    #debug(\"<<< consume comment\");\n+}\n+\n+fn is_lit(t: token::token) -> bool {\n+    ret alt t {\n+          token::LIT_INT(_, _) { true }\n+          token::LIT_UINT(_, _) { true }\n+          token::LIT_FLOAT(_, _) { true }\n+          token::LIT_STR(_) { true }\n+          token::LIT_BOOL(_) { true }\n+          _ { false }\n+        }\n+}\n+\n+type lit = {lit: str, pos: uint};\n+\n+fn gather_comments_and_literals(cm: codemap::codemap,\n+                                span_diagnostic: diagnostic::span_handler,\n+                                path: str,\n+                                srdr: io::reader) ->\n+   {cmnts: [cmnt], lits: [lit]} {\n+    let src = @str::from_bytes(srdr.read_whole_stream());\n+    let itr = @interner::mk::<str>(str::hash, str::eq);\n+    let rdr = new_reader(cm, span_diagnostic,\n+                         codemap::new_filemap(path, src, 0u, 0u), itr);\n+    let mut comments: [cmnt] = [];\n+    let mut literals: [lit] = [];\n+    let mut first_read: bool = true;\n+    while !rdr.is_eof() {\n+        loop {\n+            let mut code_to_the_left = !first_read;\n+            consume_non_eol_whitespace(rdr);\n+            if rdr.curr == '\\n' {\n+                code_to_the_left = false;\n+                consume_whitespace_counting_blank_lines(rdr, comments);\n+            }\n+            while peeking_at_comment(rdr) {\n+                consume_comment(rdr, code_to_the_left, comments);\n+                consume_whitespace_counting_blank_lines(rdr, comments);\n+            }\n+            break;\n+        }\n+        let tok = next_token(rdr);\n+        if is_lit(tok.tok) {\n+            let s = rdr.get_str_from(tok.bpos);\n+            literals += [{lit: s, pos: tok.chpos}];\n+            log(debug, \"tok lit: \" + s);\n+        } else {\n+            log(debug, \"tok: \" + token::to_str(rdr, tok.tok));\n+        }\n+        first_read = false;\n+    }\n+    ret {cmnts: comments, lits: literals};\n+}"}, {"sha": "7b249b82e79b86df6601167b10fa27ddd5994573", "filename": "src/librustsyntax/parse/lexer.rs", "status": "modified", "additions": 0, "deletions": 192, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/932aa893fd302172f6d5cabc64f092a159d2a0e5/src%2Flibrustsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932aa893fd302172f6d5cabc64f092a159d2a0e5/src%2Flibrustsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fparse%2Flexer.rs?ref=932aa893fd302172f6d5cabc64f092a159d2a0e5", "patch": "@@ -1,4 +1,3 @@\n-import io::reader_util;\n import util::interner;\n import util::interner::intern;\n import diagnostic;\n@@ -541,201 +540,10 @@ fn next_token_inner(rdr: reader) -> token::token {\n     }\n }\n \n-enum cmnt_style {\n-    isolated, // No code on either side of each line of the comment\n-    trailing, // Code exists to the left of the comment\n-    mixed, // Code before /* foo */ and after the comment\n-    blank_line, // Just a manual blank line \"\\n\\n\", for layout\n-}\n-\n-type cmnt = {style: cmnt_style, lines: [str], pos: uint};\n-\n-fn read_to_eol(rdr: reader) -> str {\n-    let mut val = \"\";\n-    while rdr.curr != '\\n' && !rdr.is_eof() {\n-        str::push_char(val, rdr.curr);\n-        rdr.bump();\n-    }\n-    if rdr.curr == '\\n' { rdr.bump(); }\n-    ret val;\n-}\n-\n-fn read_one_line_comment(rdr: reader) -> str {\n-    let val = read_to_eol(rdr);\n-    assert (val[0] == '/' as u8 && val[1] == '/' as u8);\n-    ret val;\n-}\n-\n fn consume_whitespace(rdr: reader) {\n     while is_whitespace(rdr.curr) && !rdr.is_eof() { rdr.bump(); }\n }\n \n-fn consume_non_eol_whitespace(rdr: reader) {\n-    while is_whitespace(rdr.curr) && rdr.curr != '\\n' && !rdr.is_eof() {\n-        rdr.bump();\n-    }\n-}\n-\n-fn push_blank_line_comment(rdr: reader, &comments: [cmnt]) {\n-    #debug(\">>> blank-line comment\");\n-    let v: [str] = [];\n-    comments += [{style: blank_line, lines: v, pos: rdr.chpos}];\n-}\n-\n-fn consume_whitespace_counting_blank_lines(rdr: reader, &comments: [cmnt]) {\n-    while is_whitespace(rdr.curr) && !rdr.is_eof() {\n-        if rdr.col == 0u && rdr.curr == '\\n' {\n-            push_blank_line_comment(rdr, comments);\n-        }\n-        rdr.bump();\n-    }\n-}\n-\n-fn read_line_comments(rdr: reader, code_to_the_left: bool) -> cmnt {\n-    #debug(\">>> line comments\");\n-    let p = rdr.chpos;\n-    let mut lines: [str] = [];\n-    while rdr.curr == '/' && rdr.next() == '/' {\n-        let line = read_one_line_comment(rdr);\n-        log(debug, line);\n-        lines += [line];\n-        consume_non_eol_whitespace(rdr);\n-    }\n-    #debug(\"<<< line comments\");\n-    ret {style: if code_to_the_left { trailing } else { isolated },\n-         lines: lines,\n-         pos: p};\n-}\n-\n-fn all_whitespace(s: str, begin: uint, end: uint) -> bool {\n-    let mut i: uint = begin;\n-    while i != end { if !is_whitespace(s[i] as char) { ret false; } i += 1u; }\n-    ret true;\n-}\n-\n-fn trim_whitespace_prefix_and_push_line(&lines: [str],\n-                                        s: str, col: uint) unsafe {\n-    let mut s1;\n-    if all_whitespace(s, 0u, col) {\n-        if col < str::len(s) {\n-            s1 = str::slice(s, col, str::len(s));\n-        } else { s1 = \"\"; }\n-    } else { s1 = s; }\n-    log(debug, \"pushing line: \" + s1);\n-    lines += [s1];\n-}\n-\n-fn read_block_comment(rdr: reader, code_to_the_left: bool) -> cmnt {\n-    #debug(\">>> block comment\");\n-    let p = rdr.chpos;\n-    let mut lines: [str] = [];\n-    let mut col: uint = rdr.col;\n-    rdr.bump();\n-    rdr.bump();\n-    let mut curr_line = \"/*\";\n-    let mut level: int = 1;\n-    while level > 0 {\n-        #debug(\"=== block comment level %d\", level);\n-        if rdr.is_eof() { rdr.fatal(\"unterminated block comment\"); }\n-        if rdr.curr == '\\n' {\n-            trim_whitespace_prefix_and_push_line(lines, curr_line, col);\n-            curr_line = \"\";\n-            rdr.bump();\n-        } else {\n-            str::push_char(curr_line, rdr.curr);\n-            if rdr.curr == '/' && rdr.next() == '*' {\n-                rdr.bump();\n-                rdr.bump();\n-                curr_line += \"*\";\n-                level += 1;\n-            } else {\n-                if rdr.curr == '*' && rdr.next() == '/' {\n-                    rdr.bump();\n-                    rdr.bump();\n-                    curr_line += \"/\";\n-                    level -= 1;\n-                } else { rdr.bump(); }\n-            }\n-        }\n-    }\n-    if str::len(curr_line) != 0u {\n-        trim_whitespace_prefix_and_push_line(lines, curr_line, col);\n-    }\n-    let mut style = if code_to_the_left { trailing } else { isolated };\n-    consume_non_eol_whitespace(rdr);\n-    if !rdr.is_eof() && rdr.curr != '\\n' && vec::len(lines) == 1u {\n-        style = mixed;\n-    }\n-    #debug(\"<<< block comment\");\n-    ret {style: style, lines: lines, pos: p};\n-}\n-\n-fn peeking_at_comment(rdr: reader) -> bool {\n-    ret rdr.curr == '/' && rdr.next() == '/' ||\n-            rdr.curr == '/' && rdr.next() == '*';\n-}\n-\n-fn consume_comment(rdr: reader, code_to_the_left: bool, &comments: [cmnt]) {\n-    #debug(\">>> consume comment\");\n-    if rdr.curr == '/' && rdr.next() == '/' {\n-        comments += [read_line_comments(rdr, code_to_the_left)];\n-    } else if rdr.curr == '/' && rdr.next() == '*' {\n-        comments += [read_block_comment(rdr, code_to_the_left)];\n-    } else { fail; }\n-    #debug(\"<<< consume comment\");\n-}\n-\n-fn is_lit(t: token::token) -> bool {\n-    ret alt t {\n-          token::LIT_INT(_, _) { true }\n-          token::LIT_UINT(_, _) { true }\n-          token::LIT_FLOAT(_, _) { true }\n-          token::LIT_STR(_) { true }\n-          token::LIT_BOOL(_) { true }\n-          _ { false }\n-        }\n-}\n-\n-type lit = {lit: str, pos: uint};\n-\n-fn gather_comments_and_literals(cm: codemap::codemap,\n-                                span_diagnostic: diagnostic::span_handler,\n-                                path: str,\n-                                srdr: io::reader) ->\n-   {cmnts: [cmnt], lits: [lit]} {\n-    let src = @str::from_bytes(srdr.read_whole_stream());\n-    let itr = @interner::mk::<str>(str::hash, str::eq);\n-    let rdr = new_reader(cm, span_diagnostic,\n-                         codemap::new_filemap(path, src, 0u, 0u), itr);\n-    let mut comments: [cmnt] = [];\n-    let mut literals: [lit] = [];\n-    let mut first_read: bool = true;\n-    while !rdr.is_eof() {\n-        loop {\n-            let mut code_to_the_left = !first_read;\n-            consume_non_eol_whitespace(rdr);\n-            if rdr.curr == '\\n' {\n-                code_to_the_left = false;\n-                consume_whitespace_counting_blank_lines(rdr, comments);\n-            }\n-            while peeking_at_comment(rdr) {\n-                consume_comment(rdr, code_to_the_left, comments);\n-                consume_whitespace_counting_blank_lines(rdr, comments);\n-            }\n-            break;\n-        }\n-        let tok = next_token(rdr);\n-        if is_lit(tok.tok) {\n-            let s = rdr.get_str_from(tok.bpos);\n-            literals += [{lit: s, pos: tok.chpos}];\n-            log(debug, \"tok lit: \" + s);\n-        } else {\n-            log(debug, \"tok: \" + token::to_str(rdr, tok.tok));\n-        }\n-        first_read = false;\n-    }\n-    ret {cmnts: comments, lits: literals};\n-}\n \n //\n // Local Variables:"}, {"sha": "3b7302806550ee58efee89aed896dcfc1468b2e2", "filename": "src/librustsyntax/print/pprust.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/932aa893fd302172f6d5cabc64f092a159d2a0e5/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/932aa893fd302172f6d5cabc64f092a159d2a0e5/src%2Flibrustsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Fprint%2Fpprust.rs?ref=932aa893fd302172f6d5cabc64f092a159d2a0e5", "patch": "@@ -1,3 +1,4 @@\n+import parse::comments;\n import parse::lexer;\n import codemap::codemap;\n import pp::{break_offset, word, printer,\n@@ -22,8 +23,8 @@ fn no_ann() -> pp_ann {\n type ps =\n     @{s: pp::printer,\n       cm: option<codemap>,\n-      comments: option<[lexer::cmnt]>,\n-      literals: option<[lexer::lit]>,\n+      comments: option<[comments::cmnt]>,\n+      literals: option<[comments::lit]>,\n       mut cur_cmnt: uint,\n       mut cur_lit: uint,\n       mut boxes: [pp::breaks],\n@@ -37,8 +38,8 @@ fn rust_printer(writer: io::writer) -> ps {\n     let boxes: [pp::breaks] = [];\n     ret @{s: pp::mk_printer(writer, default_columns),\n           cm: none::<codemap>,\n-          comments: none::<[lexer::cmnt]>,\n-          literals: none::<[lexer::lit]>,\n+          comments: none::<[comments::cmnt]>,\n+          literals: none::<[comments::lit]>,\n           mut cur_cmnt: 0u,\n           mut cur_lit: 0u,\n           mut boxes: boxes,\n@@ -57,8 +58,8 @@ fn print_crate(cm: codemap, span_diagnostic: diagnostic::span_handler,\n                crate: @ast::crate, filename: str, in: io::reader,\n                out: io::writer, ann: pp_ann) {\n     let boxes: [pp::breaks] = [];\n-    let r = lexer::gather_comments_and_literals(cm, span_diagnostic, filename,\n-                                                in);\n+    let r = comments::gather_comments_and_literals(cm, span_diagnostic,\n+                                                   filename, in);\n     let s =\n         @{s: pp::mk_printer(out, default_columns),\n           cm: some(cm),\n@@ -1570,7 +1571,7 @@ fn maybe_print_trailing_comment(s: ps, span: codemap::span,\n     alt s.cm { some(ccm) { cm = ccm; } _ { ret; } }\n     alt next_comment(s) {\n       some(cmnt) {\n-        if cmnt.style != lexer::trailing { ret; }\n+        if cmnt.style != comments::trailing { ret; }\n         let span_line = codemap::lookup_char_pos(cm, span.hi);\n         let comment_line = codemap::lookup_char_pos(cm, cmnt.pos);\n         let mut next = cmnt.pos + 1u;\n@@ -1645,7 +1646,7 @@ fn print_literal(s: ps, &&lit: @ast::lit) {\n \n fn lit_to_str(l: @ast::lit) -> str { be to_str(l, print_literal); }\n \n-fn next_lit(s: ps, pos: uint) -> option<lexer::lit> {\n+fn next_lit(s: ps, pos: uint) -> option<comments::lit> {\n     alt s.literals {\n       some(lits) {\n         while s.cur_lit < vec::len(lits) {\n@@ -1674,15 +1675,15 @@ fn maybe_print_comment(s: ps, pos: uint) {\n     }\n }\n \n-fn print_comment(s: ps, cmnt: lexer::cmnt) {\n+fn print_comment(s: ps, cmnt: comments::cmnt) {\n     alt cmnt.style {\n-      lexer::mixed {\n+      comments::mixed {\n         assert (vec::len(cmnt.lines) == 1u);\n         zerobreak(s.s);\n         word(s.s, cmnt.lines[0]);\n         zerobreak(s.s);\n       }\n-      lexer::isolated {\n+      comments::isolated {\n         pprust::hardbreak_if_not_bol(s);\n         for cmnt.lines.each {|line|\n             // Don't print empty lines because they will end up as trailing\n@@ -1691,7 +1692,7 @@ fn print_comment(s: ps, cmnt: lexer::cmnt) {\n             hardbreak(s.s);\n         }\n       }\n-      lexer::trailing {\n+      comments::trailing {\n         word(s.s, \" \");\n         if vec::len(cmnt.lines) == 1u {\n             word(s.s, cmnt.lines[0]);\n@@ -1705,7 +1706,7 @@ fn print_comment(s: ps, cmnt: lexer::cmnt) {\n             end(s);\n         }\n       }\n-      lexer::blank_line {\n+      comments::blank_line {\n         // We need to do at least one, possibly two hardbreaks.\n         let is_semi =\n             alt s.s.last_token() {\n@@ -1754,14 +1755,14 @@ fn to_str<T>(t: T, f: fn@(ps, T)) -> str {\n     io::mem_buffer_str(buffer)\n }\n \n-fn next_comment(s: ps) -> option<lexer::cmnt> {\n+fn next_comment(s: ps) -> option<comments::cmnt> {\n     alt s.comments {\n       some(cmnts) {\n         if s.cur_cmnt < vec::len(cmnts) {\n             ret some(cmnts[s.cur_cmnt]);\n-        } else { ret none::<lexer::cmnt>; }\n+        } else { ret none::<comments::cmnt>; }\n       }\n-      _ { ret none::<lexer::cmnt>; }\n+      _ { ret none::<comments::cmnt>; }\n     }\n }\n "}, {"sha": "bc1def9567619a65b91dcb9dabc0d2f9e3efa076", "filename": "src/librustsyntax/rustsyntax.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/932aa893fd302172f6d5cabc64f092a159d2a0e5/src%2Flibrustsyntax%2Frustsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/932aa893fd302172f6d5cabc64f092a159d2a0e5/src%2Flibrustsyntax%2Frustsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustsyntax%2Frustsyntax.rc?ref=932aa893fd302172f6d5cabc64f092a159d2a0e5", "patch": "@@ -26,6 +26,7 @@ mod parse {\n     mod lexer;\n     mod parser;\n     mod token;\n+    mod comments;\n }\n \n mod print {"}]}