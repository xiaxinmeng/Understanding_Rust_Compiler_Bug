{"sha": "c04195da9f47e8090bc49bad605765e9a2a721b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwNDE5NWRhOWY0N2U4MDkwYmM0OWJhZDYwNTc2NWU5YTJhNzIxYjQ=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-01-31T22:06:06Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-02-11T22:10:47Z"}, "message": "Move get_lang_items query in librustc_passes.", "tree": {"sha": "69d338eb531dd6526cf4793986566fb9dee6631b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69d338eb531dd6526cf4793986566fb9dee6631b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c04195da9f47e8090bc49bad605765e9a2a721b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c04195da9f47e8090bc49bad605765e9a2a721b4", "html_url": "https://github.com/rust-lang/rust/commit/c04195da9f47e8090bc49bad605765e9a2a721b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c04195da9f47e8090bc49bad605765e9a2a721b4/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff369236a3895e144ef2ba1d8a24727e27e61f1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff369236a3895e144ef2ba1d8a24727e27e61f1c", "html_url": "https://github.com/rust-lang/rust/commit/ff369236a3895e144ef2ba1d8a24727e27e61f1c"}], "stats": {"total": 348, "additions": 176, "deletions": 172}, "files": [{"sha": "5f4c5e0b0e3016d36391cc52a23dace99b885c1e", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 0, "deletions": 167, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/c04195da9f47e8090bc49bad605765e9a2a721b4/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c04195da9f47e8090bc49bad605765e9a2a721b4/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=c04195da9f47e8090bc49bad605765e9a2a721b4", "patch": "@@ -9,180 +9,13 @@\n \n pub use self::LangItem::*;\n \n-use crate::middle::cstore::ExternCrate;\n-use crate::middle::weak_lang_items;\n use crate::ty::{self, TyCtxt};\n \n-use rustc_errors::struct_span_err;\n-use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_lang_items::lang_items::ITEM_REFS;\n-use rustc_lang_items::Target;\n-use rustc_span::symbol::{sym, Symbol};\n use rustc_span::Span;\n-use syntax::ast;\n \n pub use rustc_lang_items::{LangItem, LanguageItems};\n \n-struct LanguageItemCollector<'tcx> {\n-    items: LanguageItems,\n-    tcx: TyCtxt<'tcx>,\n-}\n-\n-impl ItemLikeVisitor<'v> for LanguageItemCollector<'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        if let Some((value, span)) = extract(&item.attrs) {\n-            let actual_target = Target::from_item(item);\n-            match ITEM_REFS.get(&*value.as_str()).cloned() {\n-                // Known lang item with attribute on correct target.\n-                Some((item_index, expected_target)) if actual_target == expected_target => {\n-                    let def_id = self.tcx.hir().local_def_id(item.hir_id);\n-                    self.collect_item(item_index, def_id);\n-                }\n-                // Known lang item with attribute on incorrect target.\n-                Some((_, expected_target)) => {\n-                    struct_span_err!(\n-                        self.tcx.sess,\n-                        span,\n-                        E0718,\n-                        \"`{}` language item must be applied to a {}\",\n-                        value,\n-                        expected_target,\n-                    )\n-                    .span_label(\n-                        span,\n-                        format!(\n-                            \"attribute should be applied to a {}, not a {}\",\n-                            expected_target, actual_target,\n-                        ),\n-                    )\n-                    .emit();\n-                }\n-                // Unknown lang item.\n-                _ => {\n-                    struct_span_err!(\n-                        self.tcx.sess,\n-                        span,\n-                        E0522,\n-                        \"definition of an unknown language item: `{}`\",\n-                        value\n-                    )\n-                    .span_label(span, format!(\"definition of unknown language item `{}`\", value))\n-                    .emit();\n-                }\n-            }\n-        }\n-    }\n-\n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem<'_>) {\n-        // At present, lang items are always items, not trait items.\n-    }\n-\n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem<'_>) {\n-        // At present, lang items are always items, not impl items.\n-    }\n-}\n-\n-impl LanguageItemCollector<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>) -> LanguageItemCollector<'tcx> {\n-        LanguageItemCollector { tcx, items: LanguageItems::new() }\n-    }\n-\n-    fn collect_item(&mut self, item_index: usize, item_def_id: DefId) {\n-        // Check for duplicates.\n-        if let Some(original_def_id) = self.items.items[item_index] {\n-            if original_def_id != item_def_id {\n-                let name = LangItem::from_u32(item_index as u32).unwrap().name();\n-                let mut err = match self.tcx.hir().span_if_local(item_def_id) {\n-                    Some(span) => struct_span_err!(\n-                        self.tcx.sess,\n-                        span,\n-                        E0152,\n-                        \"found duplicate lang item `{}`\",\n-                        name\n-                    ),\n-                    None => match self.tcx.extern_crate(item_def_id) {\n-                        Some(ExternCrate { dependency_of, .. }) => {\n-                            self.tcx.sess.struct_err(&format!(\n-                                \"duplicate lang item in crate `{}` (which `{}` depends on): `{}`.\",\n-                                self.tcx.crate_name(item_def_id.krate),\n-                                self.tcx.crate_name(*dependency_of),\n-                                name\n-                            ))\n-                        }\n-                        _ => self.tcx.sess.struct_err(&format!(\n-                            \"duplicate lang item in crate `{}`: `{}`.\",\n-                            self.tcx.crate_name(item_def_id.krate),\n-                            name\n-                        )),\n-                    },\n-                };\n-                if let Some(span) = self.tcx.hir().span_if_local(original_def_id) {\n-                    err.span_note(span, \"the lang item is first defined here\");\n-                } else {\n-                    match self.tcx.extern_crate(original_def_id) {\n-                        Some(ExternCrate { dependency_of, .. }) => {\n-                            err.note(&format!(\n-                            \"the lang item is first defined in crate `{}` (which `{}` depends on)\",\n-                                      self.tcx.crate_name(original_def_id.krate),\n-                                      self.tcx.crate_name(*dependency_of)));\n-                        }\n-                        _ => {\n-                            err.note(&format!(\n-                                \"the lang item is first defined in crate `{}`.\",\n-                                self.tcx.crate_name(original_def_id.krate)\n-                            ));\n-                        }\n-                    }\n-                }\n-                err.emit();\n-            }\n-        }\n-\n-        // Matched.\n-        self.items.items[item_index] = Some(item_def_id);\n-    }\n-}\n-\n-/// Extracts the first `lang = \"$name\"` out of a list of attributes.\n-/// The attributes `#[panic_handler]` and `#[alloc_error_handler]`\n-/// are also extracted out when found.\n-pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n-    attrs.iter().find_map(|attr| {\n-        Some(match attr {\n-            _ if attr.check_name(sym::lang) => (attr.value_str()?, attr.span),\n-            _ if attr.check_name(sym::panic_handler) => (sym::panic_impl, attr.span),\n-            _ if attr.check_name(sym::alloc_error_handler) => (sym::oom, attr.span),\n-            _ => return None,\n-        })\n-    })\n-}\n-\n-/// Traverses and collects all the lang items in all crates.\n-pub fn collect<'tcx>(tcx: TyCtxt<'tcx>) -> LanguageItems {\n-    // Initialize the collector.\n-    let mut collector = LanguageItemCollector::new(tcx);\n-\n-    // Collect lang items in other crates.\n-    for &cnum in tcx.crates().iter() {\n-        for &(def_id, item_index) in tcx.defined_lang_items(cnum).iter() {\n-            collector.collect_item(item_index, def_id);\n-        }\n-    }\n-\n-    // Collect lang items in this crate.\n-    tcx.hir().krate().visit_all_item_likes(&mut collector);\n-\n-    // Extract out the found lang items.\n-    let LanguageItemCollector { mut items, .. } = collector;\n-\n-    // Find all required but not-yet-defined lang items.\n-    weak_lang_items::check_crate(tcx, &mut items);\n-\n-    items\n-}\n-\n impl<'tcx> TyCtxt<'tcx> {\n     /// Returns the `DefId` for a given `LangItem`.\n     /// If not found, fatally aborts compilation."}, {"sha": "5649a2b9132d801e87d799b4ff9e101dacc96e94", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c04195da9f47e8090bc49bad605765e9a2a721b4/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c04195da9f47e8090bc49bad605765e9a2a721b4/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=c04195da9f47e8090bc49bad605765e9a2a721b4", "patch": "@@ -141,7 +141,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, i: &hir::ForeignItem<'_>) {\n-        if let Some((lang_item, _)) = lang_items::extract(&i.attrs) {\n+        if let Some((lang_item, _)) = rustc_lang_items::lang_items::extract(&i.attrs) {\n             self.register(lang_item, i.span);\n         }\n         intravisit::walk_foreign_item(self, i)"}, {"sha": "2adf708641798a86d08dc8307bb497f60048bf73", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c04195da9f47e8090bc49bad605765e9a2a721b4/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c04195da9f47e8090bc49bad605765e9a2a721b4/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=c04195da9f47e8090bc49bad605765e9a2a721b4", "patch": "@@ -2716,10 +2716,6 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n         assert_eq!(id, LOCAL_CRATE);\n         tcx.crate_name\n     };\n-    providers.get_lang_items = |tcx, id| {\n-        assert_eq!(id, LOCAL_CRATE);\n-        tcx.arena.alloc(middle::lang_items::collect(tcx))\n-    };\n     providers.maybe_unused_trait_import = |tcx, id| tcx.maybe_unused_trait_imports.contains(&id);\n     providers.maybe_unused_extern_crates = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);"}, {"sha": "d964777bd7cb00f5320ee3d915827f5a61f8d0e4", "filename": "src/librustc_passes/lang_items.rs", "status": "added", "additions": 173, "deletions": 0, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/c04195da9f47e8090bc49bad605765e9a2a721b4/src%2Flibrustc_passes%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c04195da9f47e8090bc49bad605765e9a2a721b4/src%2Flibrustc_passes%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flang_items.rs?ref=c04195da9f47e8090bc49bad605765e9a2a721b4", "patch": "@@ -0,0 +1,173 @@\n+//! Detecting language items.\n+//!\n+//! Language items are items that represent concepts intrinsic to the language\n+//! itself. Examples are:\n+//!\n+//! * Traits that specify \"kinds\"; e.g., `Sync`, `Send`.\n+//! * Traits that represent operators; e.g., `Add`, `Sub`, `Index`.\n+//! * Functions called by the compiler itself.\n+\n+use rustc::middle::cstore::ExternCrate;\n+use rustc::middle::weak_lang_items;\n+use rustc::ty::TyCtxt;\n+\n+use rustc_errors::struct_span_err;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::itemlikevisit::ItemLikeVisitor;\n+use rustc_lang_items::lang_items::{extract, ITEM_REFS};\n+use rustc_lang_items::{LangItem, LanguageItems, Target};\n+\n+use rustc::ty::query::Providers;\n+\n+struct LanguageItemCollector<'tcx> {\n+    items: LanguageItems,\n+    tcx: TyCtxt<'tcx>,\n+}\n+\n+impl ItemLikeVisitor<'v> for LanguageItemCollector<'tcx> {\n+    fn visit_item(&mut self, item: &hir::Item<'_>) {\n+        if let Some((value, span)) = extract(&item.attrs) {\n+            let actual_target = Target::from_item(item);\n+            match ITEM_REFS.get(&*value.as_str()).cloned() {\n+                // Known lang item with attribute on correct target.\n+                Some((item_index, expected_target)) if actual_target == expected_target => {\n+                    let def_id = self.tcx.hir().local_def_id(item.hir_id);\n+                    self.collect_item(item_index, def_id);\n+                }\n+                // Known lang item with attribute on incorrect target.\n+                Some((_, expected_target)) => {\n+                    struct_span_err!(\n+                        self.tcx.sess,\n+                        span,\n+                        E0718,\n+                        \"`{}` language item must be applied to a {}\",\n+                        value,\n+                        expected_target,\n+                    )\n+                    .span_label(\n+                        span,\n+                        format!(\n+                            \"attribute should be applied to a {}, not a {}\",\n+                            expected_target, actual_target,\n+                        ),\n+                    )\n+                    .emit();\n+                }\n+                // Unknown lang item.\n+                _ => {\n+                    struct_span_err!(\n+                        self.tcx.sess,\n+                        span,\n+                        E0522,\n+                        \"definition of an unknown language item: `{}`\",\n+                        value\n+                    )\n+                    .span_label(span, format!(\"definition of unknown language item `{}`\", value))\n+                    .emit();\n+                }\n+            }\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem<'_>) {\n+        // At present, lang items are always items, not trait items.\n+    }\n+\n+    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem<'_>) {\n+        // At present, lang items are always items, not impl items.\n+    }\n+}\n+\n+impl LanguageItemCollector<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>) -> LanguageItemCollector<'tcx> {\n+        LanguageItemCollector { tcx, items: LanguageItems::new() }\n+    }\n+\n+    fn collect_item(&mut self, item_index: usize, item_def_id: DefId) {\n+        // Check for duplicates.\n+        if let Some(original_def_id) = self.items.items[item_index] {\n+            if original_def_id != item_def_id {\n+                let name = LangItem::from_u32(item_index as u32).unwrap().name();\n+                let mut err = match self.tcx.hir().span_if_local(item_def_id) {\n+                    Some(span) => struct_span_err!(\n+                        self.tcx.sess,\n+                        span,\n+                        E0152,\n+                        \"found duplicate lang item `{}`\",\n+                        name\n+                    ),\n+                    None => match self.tcx.extern_crate(item_def_id) {\n+                        Some(ExternCrate { dependency_of, .. }) => {\n+                            self.tcx.sess.struct_err(&format!(\n+                                \"duplicate lang item in crate `{}` (which `{}` depends on): `{}`.\",\n+                                self.tcx.crate_name(item_def_id.krate),\n+                                self.tcx.crate_name(*dependency_of),\n+                                name\n+                            ))\n+                        }\n+                        _ => self.tcx.sess.struct_err(&format!(\n+                            \"duplicate lang item in crate `{}`: `{}`.\",\n+                            self.tcx.crate_name(item_def_id.krate),\n+                            name\n+                        )),\n+                    },\n+                };\n+                if let Some(span) = self.tcx.hir().span_if_local(original_def_id) {\n+                    err.span_note(span, \"the lang item is first defined here\");\n+                } else {\n+                    match self.tcx.extern_crate(original_def_id) {\n+                        Some(ExternCrate { dependency_of, .. }) => {\n+                            err.note(&format!(\n+                                \"the lang item is first defined in crate `{}` (which `{}` depends on)\",\n+                                self.tcx.crate_name(original_def_id.krate),\n+                                self.tcx.crate_name(*dependency_of)\n+                            ));\n+                        }\n+                        _ => {\n+                            err.note(&format!(\n+                                \"the lang item is first defined in crate `{}`.\",\n+                                self.tcx.crate_name(original_def_id.krate)\n+                            ));\n+                        }\n+                    }\n+                }\n+                err.emit();\n+            }\n+        }\n+\n+        // Matched.\n+        self.items.items[item_index] = Some(item_def_id);\n+    }\n+}\n+\n+/// Traverses and collects all the lang items in all crates.\n+fn collect<'tcx>(tcx: TyCtxt<'tcx>) -> LanguageItems {\n+    // Initialize the collector.\n+    let mut collector = LanguageItemCollector::new(tcx);\n+\n+    // Collect lang items in other crates.\n+    for &cnum in tcx.crates().iter() {\n+        for &(def_id, item_index) in tcx.defined_lang_items(cnum).iter() {\n+            collector.collect_item(item_index, def_id);\n+        }\n+    }\n+\n+    // Collect lang items in this crate.\n+    tcx.hir().krate().visit_all_item_likes(&mut collector);\n+\n+    // Extract out the found lang items.\n+    let LanguageItemCollector { mut items, .. } = collector;\n+\n+    // Find all required but not-yet-defined lang items.\n+    weak_lang_items::check_crate(tcx, &mut items);\n+\n+    items\n+}\n+\n+pub fn provide(providers: &mut Providers<'_>) {\n+    providers.get_lang_items = |tcx, id| {\n+        assert_eq!(id, LOCAL_CRATE);\n+        tcx.arena.alloc(collect(tcx))\n+    };\n+}"}, {"sha": "d0b1c70be65be9a4df5a4af11aa62c8588aa8d80", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c04195da9f47e8090bc49bad605765e9a2a721b4/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c04195da9f47e8090bc49bad605765e9a2a721b4/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=c04195da9f47e8090bc49bad605765e9a2a721b4", "patch": "@@ -23,6 +23,7 @@ mod diagnostic_items;\n pub mod entry;\n pub mod hir_stats;\n mod intrinsicck;\n+mod lang_items;\n pub mod layout_test;\n mod lib_features;\n mod liveness;\n@@ -37,6 +38,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n     check_const::provide(providers);\n     diagnostic_items::provide(providers);\n     entry::provide(providers);\n+    lang_items::provide(providers);\n     lib_features::provide(providers);\n     loops::provide(providers);\n     liveness::provide(providers);"}]}