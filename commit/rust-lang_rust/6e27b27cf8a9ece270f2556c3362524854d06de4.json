{"sha": "6e27b27cf8a9ece270f2556c3362524854d06de4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlMjdiMjdjZjhhOWVjZTI3MGYyNTU2YzMzNjI1MjQ4NTRkMDZkZTQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-01-18T03:05:07Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-01-18T03:48:58Z"}, "message": "libstd: Move std tests into libstd", "tree": {"sha": "e310348b211f329737cec9a1a30fbf641492ad46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e310348b211f329737cec9a1a30fbf641492ad46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e27b27cf8a9ece270f2556c3362524854d06de4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e27b27cf8a9ece270f2556c3362524854d06de4", "html_url": "https://github.com/rust-lang/rust/commit/6e27b27cf8a9ece270f2556c3362524854d06de4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e27b27cf8a9ece270f2556c3362524854d06de4/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17bf4b0e1be01bc7a54c389deb5896949736d7f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/17bf4b0e1be01bc7a54c389deb5896949736d7f2", "html_url": "https://github.com/rust-lang/rust/commit/17bf4b0e1be01bc7a54c389deb5896949736d7f2"}], "stats": {"total": 5958, "additions": 2926, "deletions": 3032}, "files": [{"sha": "d7f9f21be7fce697af52e334c20ca97171bab535", "filename": "mk/tests.mk", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6e27b27cf8a9ece270f2556c3362524854d06de4/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/6e27b27cf8a9ece270f2556c3362524854d06de4/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=6e27b27cf8a9ece270f2556c3362524854d06de4", "patch": "@@ -55,10 +55,6 @@ ifdef VERBOSE\n   CTEST_TESTARGS += --verbose\n endif\n \n-# The standard library test crate\n-STDTEST_CRATE := $(S)src/test/stdtest/stdtest.rc\n-STDTEST_INPUTS := $(wildcard $(S)src/test/stdtest/*rs)\n-\n # Run the compiletest runner itself under valgrind\n ifdef CTEST_VALGRIND\n   CFG_RUN_CTEST=$(call CFG_RUN_TEST,$(2),$(3))\n@@ -188,7 +184,7 @@ check-stage$(1)-T-$(2)-H-$(3)-core-dummy:\t\t\t\\\n # Rules for the standard library test runner\n \n $(3)/test/stdtest.stage$(1)-$(2)$$(X):\t\t\t\\\n-\t\t$$(STDTEST_CRATE) $$(STDTEST_INPUTS)\t\\\n+\t\t$$(STDLIB_CRATE) $$(STDLIB_INPUTS)\t\\\n         $$(SREQ$(1)_T_$(2)_H_$(3))\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< --test"}, {"sha": "30af05a9c4947bd9479f02edbff1aa6ccc08fff1", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 285, "deletions": 0, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=6e27b27cf8a9ece270f2556c3362524854d06de4", "patch": "@@ -305,6 +305,291 @@ fn eq_vec(v0: t, v1: [uint]) -> bool {\n     ret true;\n }\n \n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn test_0_elements() {\n+        let act;\n+        let exp;\n+        act = create(0u, false);\n+        exp = vec::init_elt::<uint>(0u, 0u);\n+        assert (eq_vec(act, exp));\n+    }\n+\n+    #[test]\n+    fn test_1_element() {\n+        let act;\n+        act = create(1u, false);\n+        assert (eq_vec(act, [0u]));\n+        act = create(1u, true);\n+        assert (eq_vec(act, [1u]));\n+    }\n+\n+    #[test]\n+    fn test_10_elements() {\n+        let act;\n+        // all 0\n+\n+        act = create(10u, false);\n+        assert (eq_vec(act, [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n+        // all 1\n+\n+        act = create(10u, true);\n+        assert (eq_vec(act, [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u]));\n+        // mixed\n+\n+        act = create(10u, false);\n+        set(act, 0u, true);\n+        set(act, 1u, true);\n+        set(act, 2u, true);\n+        set(act, 3u, true);\n+        set(act, 4u, true);\n+        assert (eq_vec(act, [1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u]));\n+        // mixed\n+\n+        act = create(10u, false);\n+        set(act, 5u, true);\n+        set(act, 6u, true);\n+        set(act, 7u, true);\n+        set(act, 8u, true);\n+        set(act, 9u, true);\n+        assert (eq_vec(act, [0u, 0u, 0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u]));\n+        // mixed\n+\n+        act = create(10u, false);\n+        set(act, 0u, true);\n+        set(act, 3u, true);\n+        set(act, 6u, true);\n+        set(act, 9u, true);\n+        assert (eq_vec(act, [1u, 0u, 0u, 1u, 0u, 0u, 1u, 0u, 0u, 1u]));\n+    }\n+\n+    #[test]\n+    fn test_31_elements() {\n+        let act;\n+        // all 0\n+\n+        act = create(31u, false);\n+        assert (eq_vec(act,\n+                       [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                        0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                        0u, 0u, 0u, 0u, 0u]));\n+        // all 1\n+\n+        act = create(31u, true);\n+        assert (eq_vec(act,\n+                       [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+                        1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+                        1u, 1u, 1u, 1u, 1u]));\n+        // mixed\n+\n+        act = create(31u, false);\n+        set(act, 0u, true);\n+        set(act, 1u, true);\n+        set(act, 2u, true);\n+        set(act, 3u, true);\n+        set(act, 4u, true);\n+        set(act, 5u, true);\n+        set(act, 6u, true);\n+        set(act, 7u, true);\n+        assert (eq_vec(act,\n+                       [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u,\n+                        0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                        0u, 0u, 0u, 0u, 0u]));\n+        // mixed\n+\n+        act = create(31u, false);\n+        set(act, 16u, true);\n+        set(act, 17u, true);\n+        set(act, 18u, true);\n+        set(act, 19u, true);\n+        set(act, 20u, true);\n+        set(act, 21u, true);\n+        set(act, 22u, true);\n+        set(act, 23u, true);\n+        assert (eq_vec(act,\n+                       [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                        0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u,\n+                        0u, 0u, 0u, 0u, 0u]));\n+        // mixed\n+\n+        act = create(31u, false);\n+        set(act, 24u, true);\n+        set(act, 25u, true);\n+        set(act, 26u, true);\n+        set(act, 27u, true);\n+        set(act, 28u, true);\n+        set(act, 29u, true);\n+        set(act, 30u, true);\n+        assert (eq_vec(act,\n+                       [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                        0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u,\n+                        1u, 1u, 1u, 1u, 1u]));\n+        // mixed\n+\n+        act = create(31u, false);\n+        set(act, 3u, true);\n+        set(act, 17u, true);\n+        set(act, 30u, true);\n+        assert (eq_vec(act,\n+                       [0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                        0u, 0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                        0u, 0u, 0u, 0u, 1u]));\n+    }\n+\n+    #[test]\n+    fn test_32_elements() {\n+        let act;\n+        // all 0\n+\n+        act = create(32u, false);\n+        assert (eq_vec(act,\n+                       [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                        0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                        0u, 0u, 0u, 0u, 0u, 0u]));\n+        // all 1\n+\n+        act = create(32u, true);\n+        assert (eq_vec(act,\n+                       [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+                        1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+                        1u, 1u, 1u, 1u, 1u, 1u]));\n+        // mixed\n+\n+        act = create(32u, false);\n+        set(act, 0u, true);\n+        set(act, 1u, true);\n+        set(act, 2u, true);\n+        set(act, 3u, true);\n+        set(act, 4u, true);\n+        set(act, 5u, true);\n+        set(act, 6u, true);\n+        set(act, 7u, true);\n+        assert (eq_vec(act,\n+                       [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u,\n+                        0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                        0u, 0u, 0u, 0u, 0u, 0u]));\n+        // mixed\n+\n+        act = create(32u, false);\n+        set(act, 16u, true);\n+        set(act, 17u, true);\n+        set(act, 18u, true);\n+        set(act, 19u, true);\n+        set(act, 20u, true);\n+        set(act, 21u, true);\n+        set(act, 22u, true);\n+        set(act, 23u, true);\n+        assert (eq_vec(act,\n+                       [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                        0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u,\n+                        0u, 0u, 0u, 0u, 0u, 0u]));\n+        // mixed\n+\n+        act = create(32u, false);\n+        set(act, 24u, true);\n+        set(act, 25u, true);\n+        set(act, 26u, true);\n+        set(act, 27u, true);\n+        set(act, 28u, true);\n+        set(act, 29u, true);\n+        set(act, 30u, true);\n+        set(act, 31u, true);\n+        assert (eq_vec(act,\n+                       [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                        0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u,\n+                        1u, 1u, 1u, 1u, 1u, 1u]));\n+        // mixed\n+\n+        act = create(32u, false);\n+        set(act, 3u, true);\n+        set(act, 17u, true);\n+        set(act, 30u, true);\n+        set(act, 31u, true);\n+        assert (eq_vec(act,\n+                       [0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                        0u, 0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                        0u, 0u, 0u, 0u, 1u, 1u]));\n+    }\n+\n+    #[test]\n+    fn test_33_elements() {\n+        let act;\n+        // all 0\n+\n+        act = create(33u, false);\n+        assert (eq_vec(act,\n+                       [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                        0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                        0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n+        // all 1\n+\n+        act = create(33u, true);\n+        assert (eq_vec(act,\n+                       [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+                        1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n+                        1u, 1u, 1u, 1u, 1u, 1u, 1u]));\n+        // mixed\n+\n+        act = create(33u, false);\n+        set(act, 0u, true);\n+        set(act, 1u, true);\n+        set(act, 2u, true);\n+        set(act, 3u, true);\n+        set(act, 4u, true);\n+        set(act, 5u, true);\n+        set(act, 6u, true);\n+        set(act, 7u, true);\n+        assert (eq_vec(act,\n+                       [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u,\n+                        0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                        0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n+        // mixed\n+\n+        act = create(33u, false);\n+        set(act, 16u, true);\n+        set(act, 17u, true);\n+        set(act, 18u, true);\n+        set(act, 19u, true);\n+        set(act, 20u, true);\n+        set(act, 21u, true);\n+        set(act, 22u, true);\n+        set(act, 23u, true);\n+        assert (eq_vec(act,\n+                       [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                        0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u,\n+                        0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n+        // mixed\n+\n+        act = create(33u, false);\n+        set(act, 24u, true);\n+        set(act, 25u, true);\n+        set(act, 26u, true);\n+        set(act, 27u, true);\n+        set(act, 28u, true);\n+        set(act, 29u, true);\n+        set(act, 30u, true);\n+        set(act, 31u, true);\n+        assert (eq_vec(act,\n+                       [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                        0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u,\n+                        1u, 1u, 1u, 1u, 1u, 1u, 0u]));\n+        // mixed\n+\n+        act = create(33u, false);\n+        set(act, 3u, true);\n+        set(act, 17u, true);\n+        set(act, 30u, true);\n+        set(act, 31u, true);\n+        set(act, 32u, true);\n+        assert (eq_vec(act,\n+                       [0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                        0u, 0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n+                        0u, 0u, 0u, 0u, 1u, 1u, 1u]));\n+    }\n+\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "58ed593a6c788223d4a4656423bc558056d1aaa4", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=6e27b27cf8a9ece270f2556c3362524854d06de4", "patch": "@@ -148,3 +148,64 @@ Returns a pointer to the first element of the vector\n unsafe fn ptr<T>(t: t<T>) -> *mutable T {\n     ret (*t).base;\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    import ctypes::*;\n+\n+    #[nolink]\n+    #[abi = \"cdecl\"]\n+    native mod libc {\n+        fn malloc(n: size_t) -> *mutable u8;\n+        fn free(m: *mutable u8);\n+    }\n+\n+    fn malloc(n: size_t) -> t<u8> {\n+        let mem = libc::malloc(n);\n+\n+        assert mem as int != 0;\n+\n+        ret unsafe { create_with_dtor(mem, n, bind libc::free(mem)) };\n+    }\n+\n+    #[test]\n+    fn test_basic() {\n+        let cv = malloc(16u);\n+\n+        set(cv, 3u, 8u8);\n+        set(cv, 4u, 9u8);\n+        assert get(cv, 3u) == 8u8;\n+        assert get(cv, 4u) == 9u8;\n+        assert len(cv) == 16u;\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(target_os = \"win32\"))]\n+    fn test_overrun_get() {\n+        let cv = malloc(16u);\n+\n+        get(cv, 17u);\n+    }\n+\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(target_os = \"win32\"))]\n+    fn test_overrun_set() {\n+        let cv = malloc(16u);\n+\n+        set(cv, 17u, 0u8);\n+    }\n+\n+    #[test]\n+    fn test_and_I_mean_it() {\n+        let cv = malloc(16u);\n+        let p = unsafe { ptr(cv) };\n+\n+        set(cv, 0u, 32u8);\n+        set(cv, 1u, 33u8);\n+        assert unsafe { *p } == 32u8;\n+        set(cv, 2u, 34u8); /* safety */\n+    }\n+\n+}\n\\ No newline at end of file"}, {"sha": "356b27d0c5b7ec68b4d4b7ca19982406d09631e5", "filename": "src/libstd/deque.rs", "status": "modified", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdeque.rs?ref=6e27b27cf8a9ece270f2556c3362524854d06de4", "patch": "@@ -131,3 +131,200 @@ fn create<T: copy>() -> t<T> {\n     };\n     repr as t::<T>\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn test_simple() {\n+        let d: deque::t<int> = deque::create::<int>();\n+        assert (d.size() == 0u);\n+        d.add_front(17);\n+        d.add_front(42);\n+        d.add_back(137);\n+        assert (d.size() == 3u);\n+        d.add_back(137);\n+        assert (d.size() == 4u);\n+        log(debug, d.peek_front());\n+        assert (d.peek_front() == 42);\n+        log(debug, d.peek_back());\n+        assert (d.peek_back() == 137);\n+        let i: int = d.pop_front();\n+        log(debug, i);\n+        assert (i == 42);\n+        i = d.pop_back();\n+        log(debug, i);\n+        assert (i == 137);\n+        i = d.pop_back();\n+        log(debug, i);\n+        assert (i == 137);\n+        i = d.pop_back();\n+        log(debug, i);\n+        assert (i == 17);\n+        assert (d.size() == 0u);\n+        d.add_back(3);\n+        assert (d.size() == 1u);\n+        d.add_front(2);\n+        assert (d.size() == 2u);\n+        d.add_back(4);\n+        assert (d.size() == 3u);\n+        d.add_front(1);\n+        assert (d.size() == 4u);\n+        log(debug, d.get(0));\n+        log(debug, d.get(1));\n+        log(debug, d.get(2));\n+        log(debug, d.get(3));\n+        assert (d.get(0) == 1);\n+        assert (d.get(1) == 2);\n+        assert (d.get(2) == 3);\n+        assert (d.get(3) == 4);\n+    }\n+\n+    fn test_boxes(a: @int, b: @int, c: @int, d: @int) {\n+        let deq: deque::t<@int> = deque::create::<@int>();\n+        assert (deq.size() == 0u);\n+        deq.add_front(a);\n+        deq.add_front(b);\n+        deq.add_back(c);\n+        assert (deq.size() == 3u);\n+        deq.add_back(d);\n+        assert (deq.size() == 4u);\n+        assert (deq.peek_front() == b);\n+        assert (deq.peek_back() == d);\n+        assert (deq.pop_front() == b);\n+        assert (deq.pop_back() == d);\n+        assert (deq.pop_back() == c);\n+        assert (deq.pop_back() == a);\n+        assert (deq.size() == 0u);\n+        deq.add_back(c);\n+        assert (deq.size() == 1u);\n+        deq.add_front(b);\n+        assert (deq.size() == 2u);\n+        deq.add_back(d);\n+        assert (deq.size() == 3u);\n+        deq.add_front(a);\n+        assert (deq.size() == 4u);\n+        assert (deq.get(0) == a);\n+        assert (deq.get(1) == b);\n+        assert (deq.get(2) == c);\n+        assert (deq.get(3) == d);\n+    }\n+\n+    type eqfn<T> = fn@(T, T) -> bool;\n+\n+    fn test_parameterized<T: copy>(e: eqfn<T>, a: T, b: T, c: T, d: T) {\n+        let deq: deque::t<T> = deque::create::<T>();\n+        assert (deq.size() == 0u);\n+        deq.add_front(a);\n+        deq.add_front(b);\n+        deq.add_back(c);\n+        assert (deq.size() == 3u);\n+        deq.add_back(d);\n+        assert (deq.size() == 4u);\n+        assert (e(deq.peek_front(), b));\n+        assert (e(deq.peek_back(), d));\n+        assert (e(deq.pop_front(), b));\n+        assert (e(deq.pop_back(), d));\n+        assert (e(deq.pop_back(), c));\n+        assert (e(deq.pop_back(), a));\n+        assert (deq.size() == 0u);\n+        deq.add_back(c);\n+        assert (deq.size() == 1u);\n+        deq.add_front(b);\n+        assert (deq.size() == 2u);\n+        deq.add_back(d);\n+        assert (deq.size() == 3u);\n+        deq.add_front(a);\n+        assert (deq.size() == 4u);\n+        assert (e(deq.get(0), a));\n+        assert (e(deq.get(1), b));\n+        assert (e(deq.get(2), c));\n+        assert (e(deq.get(3), d));\n+    }\n+\n+    tag taggy { one(int); two(int, int); three(int, int, int); }\n+\n+    tag taggypar<T> {\n+        onepar(int); twopar(int, int); threepar(int, int, int);\n+    }\n+\n+    type reccy = {x: int, y: int, t: taggy};\n+\n+    #[test]\n+    fn test() {\n+        fn inteq(&&a: int, &&b: int) -> bool { ret a == b; }\n+        fn intboxeq(&&a: @int, &&b: @int) -> bool { ret a == b; }\n+        fn taggyeq(a: taggy, b: taggy) -> bool {\n+            alt a {\n+              one(a1) { alt b { one(b1) { ret a1 == b1; } _ { ret false; } } }\n+              two(a1, a2) {\n+                alt b {\n+                  two(b1, b2) { ret a1 == b1 && a2 == b2; }\n+                  _ { ret false; }\n+                }\n+              }\n+              three(a1, a2, a3) {\n+                alt b {\n+                  three(b1, b2, b3) { ret a1 == b1 && a2 == b2 && a3 == b3; }\n+                  _ { ret false; }\n+                }\n+              }\n+            }\n+        }\n+        fn taggypareq<T>(a: taggypar<T>, b: taggypar<T>) -> bool {\n+            alt a {\n+              onepar::<T>(a1) {\n+                alt b { onepar::<T>(b1) { ret a1 == b1; } _ { ret false; } }\n+              }\n+              twopar::<T>(a1, a2) {\n+                alt b {\n+                  twopar::<T>(b1, b2) { ret a1 == b1 && a2 == b2; }\n+                  _ { ret false; }\n+                }\n+              }\n+              threepar::<T>(a1, a2, a3) {\n+                alt b {\n+                  threepar::<T>(b1, b2, b3) {\n+                    ret a1 == b1 && a2 == b2 && a3 == b3;\n+                  }\n+                  _ { ret false; }\n+                }\n+              }\n+            }\n+        }\n+        fn reccyeq(a: reccy, b: reccy) -> bool {\n+            ret a.x == b.x && a.y == b.y && taggyeq(a.t, b.t);\n+        }\n+        #debug(\"*** test boxes\");\n+        test_boxes(@5, @72, @64, @175);\n+        #debug(\"*** end test boxes\");\n+        #debug(\"test parameterized: int\");\n+        let eq1: eqfn<int> = inteq;\n+        test_parameterized::<int>(eq1, 5, 72, 64, 175);\n+        #debug(\"*** test parameterized: @int\");\n+        let eq2: eqfn<@int> = intboxeq;\n+        test_parameterized::<@int>(eq2, @5, @72, @64, @175);\n+        #debug(\"*** end test parameterized @int\");\n+        #debug(\"test parameterized: taggy\");\n+        let eq3: eqfn<taggy> = taggyeq;\n+        test_parameterized::<taggy>(eq3, one(1), two(1, 2), three(1, 2, 3),\n+                                    two(17, 42));\n+\n+        #debug(\"*** test parameterized: taggypar<int>\");\n+        let eq4: eqfn<taggypar<int>> = bind taggypareq::<int>(_, _);\n+        test_parameterized::<taggypar<int>>(eq4, onepar::<int>(1),\n+                                            twopar::<int>(1, 2),\n+                                            threepar::<int>(1, 2, 3),\n+                                            twopar::<int>(17, 42));\n+        #debug(\"*** end test parameterized: taggypar::<int>\");\n+\n+        #debug(\"*** test parameterized: reccy\");\n+        let reccy1: reccy = {x: 1, y: 2, t: one(1)};\n+        let reccy2: reccy = {x: 345, y: 2, t: two(1, 2)};\n+        let reccy3: reccy = {x: 1, y: 777, t: three(1, 2, 3)};\n+        let reccy4: reccy = {x: 19, y: 252, t: two(17, 42)};\n+        let eq5: eqfn<reccy> = reccyeq;\n+        test_parameterized::<reccy>(eq5, reccy1, reccy2, reccy3, reccy4);\n+        #debug(\"*** end test parameterized: reccy\");\n+        #debug(\"*** done\");\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "48b3d919afbb7a04d389f073f3692bddf33773ba", "filename": "src/libstd/four.rs", "status": "modified", "additions": 150, "deletions": 0, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Ffour.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Ffour.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffour.rs?ref=6e27b27cf8a9ece270f2556c3362524854d06de4", "patch": "@@ -220,6 +220,156 @@ A trit of `v` (`both` and `none` are both coalesced into `trit::unknown`)\n */\n fn to_trit(v: t) -> tri::t { v & (v ^ not(v)) }\n \n+#[cfg(test)]\n+mod tests {\n+\n+    fn eq1(a: four::t, b: four::t) -> bool { four::eq(a , b) }\n+    fn ne1(a: four::t, b: four::t) -> bool { four::ne(a , b) }\n+\n+    fn eq2(a: four::t, b: four::t) -> bool { eq1( a, b ) && eq1( b, a ) }\n+\n+    #[test]\n+    fn test_four_req_eq() {\n+        four::all_values { |a|\n+            four::all_values { |b|\n+                assert if a == b { eq1( a, b ) } else { ne1( a, b ) };\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_four_and_symmetry() {\n+        four::all_values { |a|\n+            four::all_values { |b|\n+                assert eq1( four::and(a ,b), four::and(b, a) );\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_four_xor_symmetry() {\n+        four::all_values { |a|\n+            four::all_values { |b|\n+                assert eq1( four::and(a ,b), four::and(b, a) );\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_four_or_symmetry() {\n+        four::all_values { |a|\n+            four::all_values { |b|\n+                assert eq1( four::or(a ,b), four::or(b, a) );\n+            }\n+        }\n+    }\n+\n+    fn to_tup(v: four::t) -> (bool, bool) {\n+        alt v {\n+          0u8 { (false, false) }\n+          1u8 { (false, true) }\n+          2u8 { (true, false) }\n+          3u8 { (true, true) }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_four_not() {\n+        four::all_values { |a|\n+            let (x, y) = to_tup(a);\n+            assert to_tup(four::not(a)) == (y, x);\n+        };\n+    }\n+\n+\n+    #[test]\n+    fn test_four_and() {\n+        four::all_values { |a|\n+            four::all_values { |b|\n+                let (y1, x1) = to_tup(a);\n+                let (y2, x2) = to_tup(b);\n+                let (y3, x3) = to_tup(four::and(a, b));\n+\n+                assert (x3, y3) == (x1 && x2, y1 || y2);\n+            }\n+        };\n+    }\n+\n+    #[test]\n+    fn test_four_or() {\n+        four::all_values { |a|\n+            four::all_values { |b|\n+                let (y1, x1) = to_tup(a);\n+                let (y2, x2) = to_tup(b);\n+                let (y3, x3) = to_tup(four::or(a, b));\n+\n+                assert (x3, y3) == (x1 || x2, y1 && y2);\n+            }\n+        };\n+    }\n+\n+    #[test]\n+    fn test_four_implies() {\n+        four::all_values { |a|\n+            four::all_values { |b|\n+                let (_, x1) = to_tup(a);\n+                let (y2, x2) = to_tup(b);\n+                let (y3, x3) = to_tup(four::implies(a, b));\n+\n+                assert (x3, y3) == (!x1 || x2, x1 && y2);\n+            }\n+        };\n+    }\n+\n+    #[test]\n+    fn test_four_is_true() {\n+        assert !four::is_true(four::none);\n+        assert !four::is_true(four::false);\n+        assert four::is_true(four::true);\n+        assert four::is_true(four::both);\n+    }\n+\n+    #[test]\n+    fn test_four_is_false() {\n+        assert four::is_false(four::none);\n+        assert four::is_false(four::false);\n+        assert !four::is_false(four::true);\n+        assert !four::is_false(four::both);\n+    }\n+\n+    #[test]\n+    fn test_four_from_str() {\n+        four::all_values { |v|\n+            assert eq1( v, four::from_str(four::to_str(v)) );\n+        }\n+    }\n+\n+    #[test]\n+    fn test_four_to_str() {\n+        assert four::to_str(four::none) == \"none\";\n+        assert four::to_str(four::false) == \"false\";\n+        assert four::to_str(four::true) == \"true\" ;\n+        assert four::to_str(four::both) == \"both\";\n+    }\n+\n+    #[test]\n+    fn test_four_to_tri() {\n+        assert tri::eq( four::to_trit(four::true), tri::true );\n+        assert tri::eq( four::to_trit(four::false), tri::false );\n+        assert tri::eq( four::to_trit(four::none), tri::unknown );\n+        log(debug, four::to_trit(four::both));\n+        assert tri::eq( four::to_trit(four::both), tri::unknown );\n+    }\n+\n+    #[test]\n+    fn test_four_to_bit() {\n+        four::all_values { |v|\n+            assert four::to_bit(v) ==\n+                if four::is_true(v) { 1u8 } else { 0u8 };\n+        }\n+    }\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "5a4bcbde101f3dfe2499f0f4b1aff05330266e84", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 285, "deletions": 0, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=6e27b27cf8a9ece270f2556c3362524854d06de4", "patch": "@@ -450,6 +450,291 @@ fn homedir() -> option<path> {\n     }\n }\n \n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn test_connect() {\n+        let slash = fs::path_sep();\n+        log(error, fs::connect(\"a\", \"b\"));\n+        assert (fs::connect(\"a\", \"b\") == \"a\" + slash + \"b\");\n+        assert (fs::connect(\"a\" + slash, \"b\") == \"a\" + slash + \"b\");\n+    }\n+\n+    // Issue #712\n+    #[test]\n+    fn test_list_dir_no_invalid_memory_access() { fs::list_dir(\".\"); }\n+\n+    #[test]\n+    fn list_dir() {\n+        let dirs = fs::list_dir(\".\");\n+        // Just assuming that we've got some contents in the current directory\n+        assert (vec::len(dirs) > 0u);\n+\n+        for dir in dirs { log(debug, dir); }\n+    }\n+\n+    #[test]\n+    fn path_is_dir() {\n+        assert (fs::path_is_dir(\".\"));\n+        assert (!fs::path_is_dir(\"test/stdtest/fs.rs\"));\n+    }\n+\n+    #[test]\n+    fn path_exists() {\n+        assert (fs::path_exists(\".\"));\n+        assert (!fs::path_exists(\"test/nonexistent-bogus-path\"));\n+    }\n+\n+    fn ps() -> str {\n+        fs::path_sep()\n+    }\n+\n+    fn aps() -> str {\n+        \"/\"\n+    }\n+\n+    #[test]\n+    fn split1() {\n+        let actual = fs::split(\"a\" + ps() + \"b\");\n+        let expected = [\"a\", \"b\"];\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    fn split2() {\n+        let actual = fs::split(\"a\" + aps() + \"b\");\n+        let expected = [\"a\", \"b\"];\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    fn split3() {\n+        let actual = fs::split(ps() + \"a\" + ps() + \"b\");\n+        let expected = [\"a\", \"b\"];\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    fn split4() {\n+        let actual = fs::split(\"a\" + ps() + \"b\" + aps() + \"c\");\n+        let expected = [\"a\", \"b\", \"c\"];\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    fn normalize1() {\n+        let actual = fs::normalize(\"a/b/..\");\n+        let expected = \"a\";\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    fn normalize2() {\n+        let actual = fs::normalize(\"/a/b/..\");\n+        let expected = \"/a\";\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    fn normalize3() {\n+        let actual = fs::normalize(\"a/../b\");\n+        let expected = \"b\";\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    fn normalize4() {\n+        let actual = fs::normalize(\"/a/../b\");\n+        let expected = \"/b\";\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    fn normalize5() {\n+        let actual = fs::normalize(\"a/.\");\n+        let expected = \"a\";\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    fn normalize6() {\n+        let actual = fs::normalize(\"a/./b/\");\n+        let expected = \"a/b/\";\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    fn normalize7() {\n+        let actual = fs::normalize(\"a/..\");\n+        let expected = \".\";\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    fn normalize8() {\n+        let actual = fs::normalize(\"../../..\");\n+        let expected = \"../../..\";\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    fn normalize9() {\n+        let actual = fs::normalize(\"a/b/../../..\");\n+        let expected = \"..\";\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    fn normalize10() {\n+        let actual = fs::normalize(\"/a/b/c/../d/./../../e/\");\n+        let expected = \"/a/e/\";\n+        log(error, actual);\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    fn normalize11() {\n+        let actual = fs::normalize(\"/a/..\");\n+        let expected = \"/\";\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    #[cfg(target_os = \"win32\")]\n+    fn normalize12() {\n+        let actual = fs::normalize(\"C:/whatever\");\n+        let expected = \"C:/whatever\";\n+        log(error, actual);\n+        assert actual == expected;\n+    }\n+\n+    #[test]\n+    #[cfg(target_os = \"win32\")]\n+    fn path_is_absolute_win32() {\n+        assert fs::path_is_absolute(\"C:/whatever\");\n+    }\n+\n+    #[test]\n+    fn splitext_empty() {\n+        let (base, ext) = fs::splitext(\"\");\n+        assert base == \"\";\n+        assert ext == \"\";\n+    }\n+\n+    #[test]\n+    fn splitext_ext() {\n+        let (base, ext) = fs::splitext(\"grum.exe\");\n+        assert base == \"grum\";\n+        assert ext == \".exe\";\n+    }\n+\n+    #[test]\n+    fn splitext_noext() {\n+        let (base, ext) = fs::splitext(\"grum\");\n+        assert base == \"grum\";\n+        assert ext == \"\";\n+    }\n+\n+    #[test]\n+    fn splitext_dotfile() {\n+        let (base, ext) = fs::splitext(\".grum\");\n+        assert base == \".grum\";\n+        assert ext == \"\";\n+    }\n+\n+    #[test]\n+    fn splitext_path_ext() {\n+        let (base, ext) = fs::splitext(\"oh/grum.exe\");\n+        assert base == \"oh/grum\";\n+        assert ext == \".exe\";\n+    }\n+\n+    #[test]\n+    fn splitext_path_noext() {\n+        let (base, ext) = fs::splitext(\"oh/grum\");\n+        assert base == \"oh/grum\";\n+        assert ext == \"\";\n+    }\n+\n+    #[test]\n+    fn splitext_dot_in_path() {\n+        let (base, ext) = fs::splitext(\"oh.my/grum\");\n+        assert base == \"oh.my/grum\";\n+        assert ext == \"\";\n+    }\n+\n+    #[test]\n+    fn splitext_nobasename() {\n+        let (base, ext) = fs::splitext(\"oh.my/\");\n+        assert base == \"oh.my/\";\n+        assert ext == \"\";\n+    }\n+\n+    #[test]\n+    #[cfg(target_os = \"linux\")]\n+    #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"freebsd\")]\n+    fn homedir() {\n+        import getenv = generic_os::getenv;\n+        import setenv = generic_os::setenv;\n+\n+        let oldhome = getenv(\"HOME\");\n+\n+        setenv(\"HOME\", \"/home/MountainView\");\n+        assert fs::homedir() == some(\"/home/MountainView\");\n+\n+        setenv(\"HOME\", \"\");\n+        assert fs::homedir() == none;\n+\n+        option::may(oldhome, {|s| setenv(\"HOME\", s)});\n+    }\n+\n+    #[test]\n+    #[cfg(target_os = \"win32\")]\n+    fn homedir() {\n+        import getenv = generic_os::getenv;\n+        import setenv = generic_os::setenv;\n+\n+        let oldhome = getenv(\"HOME\");\n+        let olduserprofile = getenv(\"USERPROFILE\");\n+\n+        setenv(\"HOME\", \"\");\n+        setenv(\"USERPROFILE\", \"\");\n+\n+        assert fs::homedir() == none;\n+\n+        setenv(\"HOME\", \"/home/MountainView\");\n+        assert fs::homedir() == some(\"/home/MountainView\");\n+\n+        setenv(\"HOME\", \"\");\n+\n+        setenv(\"USERPROFILE\", \"/home/MountainView\");\n+        assert fs::homedir() == some(\"/home/MountainView\");\n+\n+        setenv(\"USERPROFILE\", \"/home/MountainView\");\n+        assert fs::homedir() == some(\"/home/MountainView\");\n+\n+        setenv(\"HOME\", \"/home/MountainView\");\n+        setenv(\"USERPROFILE\", \"/home/PaloAlto\");\n+        assert fs::homedir() == some(\"/home/MountainView\");\n+\n+        option::may(oldhome, {|s| setenv(\"HOME\", s)});\n+        option::may(olduserprofile, {|s| setenv(\"USERPROFILE\", s)});\n+    }\n+}\n+\n+\n+#[test]\n+fn test() {\n+    assert (!fs::path_is_absolute(\"test-path\"));\n+\n+    log(debug, \"Current working directory: \" + os::getcwd());\n+\n+    log(debug, fs::make_absolute(\"test-path\"));\n+    log(debug, fs::make_absolute(\"/usr/bin\"));\n+}\n+\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "750b333f1a6569e179a855fd75340bdf5f302776", "filename": "src/libstd/generic_os.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Fgeneric_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Fgeneric_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgeneric_os.rs?ref=6e27b27cf8a9ece270f2556c3362524854d06de4", "patch": "@@ -93,6 +93,56 @@ fn setenv(n: str, v: str) {\n         });\n }\n \n+\n+#[cfg(test)]\n+mod tests {\n+\n+    #[test]\n+    #[ignore(reason = \"fails periodically on mac\")]\n+    fn test_setenv() {\n+        // NB: Each test of setenv needs to use different variable names or\n+        // the tests will not be threadsafe\n+        setenv(\"NAME1\", \"VALUE\");\n+        assert (getenv(\"NAME1\") == option::some(\"VALUE\"));\n+    }\n+\n+    #[test]\n+    #[ignore(reason = \"fails periodically on mac\")]\n+    fn test_setenv_overwrite() {\n+        setenv(\"NAME2\", \"1\");\n+        setenv(\"NAME2\", \"2\");\n+        assert (getenv(\"NAME2\") == option::some(\"2\"));\n+    }\n+\n+    // Windows GetEnvironmentVariable requires some extra work to make sure\n+    // the buffer the variable is copied into is the right size\n+    #[test]\n+    #[ignore(reason = \"fails periodically on mac\")]\n+    fn test_getenv_big() {\n+        let s = \"\";\n+        let i = 0;\n+        while i < 100 { s += \"aaaaaaaaaa\"; i += 1; }\n+        setenv(\"test_getenv_big\", s);\n+        log(debug, s);\n+        assert (getenv(\"test_getenv_big\") == option::some(s));\n+    }\n+\n+    #[test]\n+    fn test_get_exe_path() {\n+        let path = os::get_exe_path();\n+        assert option::is_some(path);\n+        let path = option::get(path);\n+        log(debug, path);\n+\n+        // Hard to test this function\n+        if os::target_os() != \"win32\" {\n+            assert str::starts_with(path, fs::path_sep());\n+        } else {\n+            assert path[1] == ':' as u8;\n+        }\n+    }\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "697ce4035cdcec0eccda27df5f3dd0c5968a62a4", "filename": "src/libstd/getopts.rs", "status": "modified", "additions": 473, "deletions": 0, "changes": 473, "blob_url": "https://github.com/rust-lang/rust/blob/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgetopts.rs?ref=6e27b27cf8a9ece270f2556c3362524854d06de4", "patch": "@@ -375,6 +375,479 @@ fn opt_default(m: match, nm: str, def: str) -> option::t<str> {\n     if vec::len::<optval>(vals) == 0u { ret none::<str>; }\n     ret alt vals[0] { val(s) { some::<str>(s) } _ { some::<str>(def) } }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    import opt = getopts;\n+    import result::{err, ok};\n+\n+    tag fail_type {\n+        argument_missing_;\n+        unrecognized_option_;\n+        option_missing_;\n+        option_duplicated_;\n+        unexpected_argument_;\n+    }\n+\n+    fn check_fail_type(f: fail_, ft: fail_type) {\n+        alt f {\n+          argument_missing(_) { assert (ft == argument_missing_); }\n+          unrecognized_option(_) { assert (ft == unrecognized_option_); }\n+          option_missing(_) { assert (ft == option_missing_); }\n+          option_duplicated(_) { assert (ft == option_duplicated_); }\n+          unexpected_argument(_) { assert (ft == unexpected_argument_); }\n+          _ { fail; }\n+        }\n+    }\n+\n+\n+    // Tests for reqopt\n+    #[test]\n+    fn test_reqopt_long() {\n+        let args = [\"--test=20\"];\n+        let opts = [reqopt(\"test\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          ok(m) {\n+            assert (opt_present(m, \"test\"));\n+            assert (opt_str(m, \"test\") == \"20\");\n+          }\n+          _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_reqopt_long_missing() {\n+        let args = [\"blah\"];\n+        let opts = [reqopt(\"test\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          err(f) { check_fail_type(f, option_missing_); }\n+          _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_reqopt_long_no_arg() {\n+        let args = [\"--test\"];\n+        let opts = [reqopt(\"test\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          err(f) { check_fail_type(f, argument_missing_); }\n+          _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_reqopt_long_multi() {\n+        let args = [\"--test=20\", \"--test=30\"];\n+        let opts = [reqopt(\"test\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          err(f) { check_fail_type(f, option_duplicated_); }\n+          _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_reqopt_short() {\n+        let args = [\"-t\", \"20\"];\n+        let opts = [reqopt(\"t\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          ok(m) {\n+            assert (opt_present(m, \"t\"));\n+            assert (opt_str(m, \"t\") == \"20\");\n+          }\n+          _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_reqopt_short_missing() {\n+        let args = [\"blah\"];\n+        let opts = [reqopt(\"t\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          err(f) { check_fail_type(f, option_missing_); }\n+          _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_reqopt_short_no_arg() {\n+        let args = [\"-t\"];\n+        let opts = [reqopt(\"t\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          err(f) { check_fail_type(f, argument_missing_); }\n+          _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_reqopt_short_multi() {\n+        let args = [\"-t\", \"20\", \"-t\", \"30\"];\n+        let opts = [reqopt(\"t\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          err(f) { check_fail_type(f, option_duplicated_); }\n+          _ { fail; }\n+        }\n+    }\n+\n+\n+    // Tests for optopt\n+    #[test]\n+    fn test_optopt_long() {\n+        let args = [\"--test=20\"];\n+        let opts = [optopt(\"test\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          ok(m) {\n+            assert (opt_present(m, \"test\"));\n+            assert (opt_str(m, \"test\") == \"20\");\n+          }\n+          _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optopt_long_missing() {\n+        let args = [\"blah\"];\n+        let opts = [optopt(\"test\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          ok(m) { assert (!opt_present(m, \"test\")); }\n+          _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optopt_long_no_arg() {\n+        let args = [\"--test\"];\n+        let opts = [optopt(\"test\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          err(f) { check_fail_type(f, argument_missing_); }\n+          _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optopt_long_multi() {\n+        let args = [\"--test=20\", \"--test=30\"];\n+        let opts = [optopt(\"test\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          err(f) { check_fail_type(f, option_duplicated_); }\n+          _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optopt_short() {\n+        let args = [\"-t\", \"20\"];\n+        let opts = [optopt(\"t\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          ok(m) {\n+            assert (opt_present(m, \"t\"));\n+            assert (opt_str(m, \"t\") == \"20\");\n+          }\n+          _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optopt_short_missing() {\n+        let args = [\"blah\"];\n+        let opts = [optopt(\"t\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          ok(m) { assert (!opt_present(m, \"t\")); }\n+          _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optopt_short_no_arg() {\n+        let args = [\"-t\"];\n+        let opts = [optopt(\"t\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          err(f) { check_fail_type(f, argument_missing_); }\n+          _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optopt_short_multi() {\n+        let args = [\"-t\", \"20\", \"-t\", \"30\"];\n+        let opts = [optopt(\"t\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          err(f) { check_fail_type(f, option_duplicated_); }\n+          _ { fail; }\n+        }\n+    }\n+\n+\n+    // Tests for optflag\n+    #[test]\n+    fn test_optflag_long() {\n+        let args = [\"--test\"];\n+        let opts = [optflag(\"test\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          ok(m) { assert (opt_present(m, \"test\")); }\n+          _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optflag_long_missing() {\n+        let args = [\"blah\"];\n+        let opts = [optflag(\"test\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          ok(m) { assert (!opt_present(m, \"test\")); }\n+          _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optflag_long_arg() {\n+        let args = [\"--test=20\"];\n+        let opts = [optflag(\"test\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          err(f) {\n+            log(error, fail_str(f));\n+            check_fail_type(f, unexpected_argument_);\n+          }\n+          _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optflag_long_multi() {\n+        let args = [\"--test\", \"--test\"];\n+        let opts = [optflag(\"test\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          err(f) { check_fail_type(f, option_duplicated_); }\n+          _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optflag_short() {\n+        let args = [\"-t\"];\n+        let opts = [optflag(\"t\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          ok(m) { assert (opt_present(m, \"t\")); }\n+          _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optflag_short_missing() {\n+        let args = [\"blah\"];\n+        let opts = [optflag(\"t\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          ok(m) { assert (!opt_present(m, \"t\")); }\n+          _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optflag_short_arg() {\n+        let args = [\"-t\", \"20\"];\n+        let opts = [optflag(\"t\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          ok(m) {\n+            // The next variable after the flag is just a free argument\n+\n+            assert (m.free[0] == \"20\");\n+          }\n+          _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optflag_short_multi() {\n+        let args = [\"-t\", \"-t\"];\n+        let opts = [optflag(\"t\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          err(f) { check_fail_type(f, option_duplicated_); }\n+          _ { fail; }\n+        }\n+    }\n+\n+\n+    // Tests for optmulti\n+    #[test]\n+    fn test_optmulti_long() {\n+        let args = [\"--test=20\"];\n+        let opts = [optmulti(\"test\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          ok(m) {\n+            assert (opt_present(m, \"test\"));\n+            assert (opt_str(m, \"test\") == \"20\");\n+          }\n+          _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optmulti_long_missing() {\n+        let args = [\"blah\"];\n+        let opts = [optmulti(\"test\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          ok(m) { assert (!opt_present(m, \"test\")); }\n+          _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optmulti_long_no_arg() {\n+        let args = [\"--test\"];\n+        let opts = [optmulti(\"test\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          err(f) { check_fail_type(f, argument_missing_); }\n+          _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optmulti_long_multi() {\n+        let args = [\"--test=20\", \"--test=30\"];\n+        let opts = [optmulti(\"test\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          ok(m) {\n+            assert (opt_present(m, \"test\"));\n+            assert (opt_str(m, \"test\") == \"20\");\n+            assert (opt_strs(m, \"test\")[0] == \"20\");\n+            assert (opt_strs(m, \"test\")[1] == \"30\");\n+          }\n+          _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optmulti_short() {\n+        let args = [\"-t\", \"20\"];\n+        let opts = [optmulti(\"t\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          ok(m) {\n+            assert (opt_present(m, \"t\"));\n+            assert (opt_str(m, \"t\") == \"20\");\n+          }\n+          _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optmulti_short_missing() {\n+        let args = [\"blah\"];\n+        let opts = [optmulti(\"t\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          ok(m) { assert (!opt_present(m, \"t\")); }\n+          _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optmulti_short_no_arg() {\n+        let args = [\"-t\"];\n+        let opts = [optmulti(\"t\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          err(f) { check_fail_type(f, argument_missing_); }\n+          _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_optmulti_short_multi() {\n+        let args = [\"-t\", \"20\", \"-t\", \"30\"];\n+        let opts = [optmulti(\"t\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          ok(m) {\n+            assert (opt_present(m, \"t\"));\n+            assert (opt_str(m, \"t\") == \"20\");\n+            assert (opt_strs(m, \"t\")[0] == \"20\");\n+            assert (opt_strs(m, \"t\")[1] == \"30\");\n+          }\n+          _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_unrecognized_option_long() {\n+        let args = [\"--untest\"];\n+        let opts = [optmulti(\"t\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          err(f) { check_fail_type(f, unrecognized_option_); }\n+          _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_unrecognized_option_short() {\n+        let args = [\"-t\"];\n+        let opts = [optmulti(\"test\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          err(f) { check_fail_type(f, unrecognized_option_); }\n+          _ { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_combined() {\n+        let args =\n+            [\"prog\", \"free1\", \"-s\", \"20\", \"free2\", \"--flag\", \"--long=30\",\n+             \"-f\", \"-m\", \"40\", \"-m\", \"50\", \"-n\", \"-A B\", \"-n\", \"-60 70\"];\n+        let opts =\n+            [optopt(\"s\"), optflag(\"flag\"), reqopt(\"long\"),\n+             optflag(\"f\"), optmulti(\"m\"), optmulti(\"n\"),\n+             optopt(\"notpresent\")];\n+        let rs = getopts(args, opts);\n+        alt rs {\n+          ok(m) {\n+            assert (m.free[0] == \"prog\");\n+            assert (m.free[1] == \"free1\");\n+            assert (opt_str(m, \"s\") == \"20\");\n+            assert (m.free[2] == \"free2\");\n+            assert (opt_present(m, \"flag\"));\n+            assert (opt_str(m, \"long\") == \"30\");\n+            assert (opt_present(m, \"f\"));\n+            assert (opt_strs(m, \"m\")[0] == \"40\");\n+            assert (opt_strs(m, \"m\")[1] == \"50\");\n+            assert (opt_strs(m, \"n\")[0] == \"-A B\");\n+            assert (opt_strs(m, \"n\")[1] == \"-60 70\");\n+            assert (!opt_present(m, \"notpresent\"));\n+          }\n+          _ { fail; }\n+        }\n+    }\n+\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "304e7d9e35704c67c2c373aa821a483f6d97d4cc", "filename": "src/libstd/io.rs", "status": "modified", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=6e27b27cf8a9ece270f2556c3362524854d06de4", "patch": "@@ -561,6 +561,105 @@ mod fsync {\n     }\n }\n \n+#[cfg(test)]\n+mod tests {\n+\n+    #[test]\n+    fn test_simple() {\n+        let tmpfile: str = \"tmp/lib-io-test-simple.tmp\";\n+        log(debug, tmpfile);\n+        let frood: str = \"A hoopy frood who really knows where his towel is.\";\n+        log(debug, frood);\n+        {\n+            let out: io::writer =\n+                result::get(\n+                    io::file_writer(tmpfile, [io::create, io::truncate]));\n+            out.write_str(frood);\n+        }\n+        let inp: io::reader = result::get(io::file_reader(tmpfile));\n+        let frood2: str = inp.read_c_str();\n+        log(debug, frood2);\n+        assert (str::eq(frood, frood2));\n+    }\n+\n+    #[test]\n+    fn test_readchars_empty() {\n+        let inp : io::reader = io::string_reader(\"\");\n+        let res : [char] = inp.read_chars(128u);\n+        assert(vec::len(res) == 0u);\n+    }\n+\n+    #[test]\n+    fn test_readchars_wide() {\n+        let wide_test = \"\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64hello\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64\";\n+        let ivals : [int] = [\n+            29983, 38152, 30340, 27748,\n+            21273, 20999, 32905, 27748,\n+            104, 101, 108, 108, 111,\n+            29983, 38152, 30340, 27748,\n+            21273, 20999, 32905, 27748];\n+        fn check_read_ln(len : uint, s: str, ivals: [int]) {\n+            let inp : io::reader = io::string_reader(s);\n+            let res : [char] = inp.read_chars(len);\n+            if (len <= vec::len(ivals)) {\n+                assert(vec::len(res) == len);\n+            }\n+            assert(vec::slice(ivals, 0u, vec::len(res)) ==\n+                   vec::map(res, {|x| x as int}));\n+        }\n+        let i = 0u;\n+        while i < 8u {\n+            check_read_ln(i, wide_test, ivals);\n+            i += 1u;\n+        }\n+        // check a long read for good measure\n+        check_read_ln(128u, wide_test, ivals);\n+    }\n+\n+    #[test]\n+    fn test_readchar() {\n+        let inp : io::reader = io::string_reader(\"\u751f\");\n+        let res : char = inp.read_char();\n+        assert(res as int == 29983);\n+    }\n+\n+    #[test]\n+    fn test_readchar_empty() {\n+        let inp : io::reader = io::string_reader(\"\");\n+        let res : char = inp.read_char();\n+        assert(res as int == -1);\n+    }\n+\n+    #[test]\n+    fn file_reader_not_exist() {\n+        alt io::file_reader(\"not a file\") {\n+          result::err(e) {\n+            assert e == \"error opening not a file\";\n+          }\n+          result::ok(_) { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn file_writer_bad_name() {\n+        alt io::file_writer(\"?/?\", []) {\n+          result::err(e) {\n+            assert e == \"error opening ?/?\";\n+          }\n+          result::ok(_) { fail; }\n+        }\n+    }\n+\n+    #[test]\n+    fn buffered_file_writer_bad_name() {\n+        alt io::buffered_file_writer(\"?/?\") {\n+          result::err(e) {\n+            assert e == \"error opening ?/?\";\n+          }\n+          result::ok(_) { fail; }\n+        }\n+    }\n+}\n \n //\n // Local Variables:"}, {"sha": "d433b12ec682656bbb02f9cf1ce6b65449f09207", "filename": "src/libstd/json.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=6e27b27cf8a9ece270f2556c3362524854d06de4", "patch": "@@ -268,3 +268,58 @@ fn from_str(s: str) -> option::t<json> {\n     let (j, _) = from_str_helper(s);\n     j\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn test_from_str_null() {\n+        assert(from_str(\"null\") == some(null));\n+    }\n+\n+    #[test]\n+    fn test_from_str_num() {\n+        assert(from_str(\"3\") == some(num(3f)));\n+        assert(from_str(\"3.1\") == some(num(3.1f)));\n+        assert(from_str(\"-1.2\") == some(num(-1.2f)));\n+        assert(from_str(\".4\") == some(num(0.4f)));\n+    }\n+\n+    #[test]\n+    fn test_from_str_str() {\n+        assert(from_str(\"\\\"foo\\\"\") == some(string(\"foo\")));\n+        assert(from_str(\"\\\"\\\\\\\"\\\"\") == some(string(\"\\\"\")));\n+        assert(from_str(\"\\\"lol\") == none);\n+    }\n+\n+    #[test]\n+    fn test_from_str_bool() {\n+        assert(from_str(\"true\") == some(boolean(true)));\n+        assert(from_str(\"false\") == some(boolean(false)));\n+        assert(from_str(\"truz\") == none);\n+    }\n+\n+    #[test]\n+    fn test_from_str_list() {\n+        assert(from_str(\"[]\") == some(list(@[])));\n+        assert(from_str(\"[true]\") == some(list(@[boolean(true)])));\n+        assert(from_str(\"[null]\") == some(list(@[null])));\n+        assert(from_str(\"[3, 1]\") == some(list(@[num(3f), num(1f)])));\n+        assert(from_str(\"[2, [4, 1]]\") ==\n+               some(list(@[num(2f), list(@[num(4f), num(1f)])])));\n+        assert(from_str(\"[2, ]\") == none);\n+        assert(from_str(\"[5, \") == none);\n+        assert(from_str(\"[6 7]\") == none);\n+        assert(from_str(\"[3\") == none);\n+    }\n+\n+    #[test]\n+    fn test_from_str_dict() {\n+        assert(from_str(\"{}\") != none);\n+        assert(from_str(\"{\\\"a\\\": 3}\") != none);\n+        assert(from_str(\"{\\\"a\\\": null}\") != none);\n+        assert(from_str(\"{\\\"a\\\": }\") == none);\n+        assert(from_str(\"{\\\"a\\\" }\") == none);\n+        assert(from_str(\"{\\\"a\\\"\") == none);\n+        assert(from_str(\"{\") == none);\n+    }\n+}"}, {"sha": "9e8c8e9867449fa7e9e1cb2fd3284c017d836458", "filename": "src/libstd/list.rs", "status": "modified", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flist.rs?ref=6e27b27cf8a9ece270f2556c3362524854d06de4", "patch": "@@ -183,6 +183,118 @@ fn iter<T>(l: list<T>, f: block(T)) {\n     }\n }\n \n+#[cfg(test)]\n+mod tests {\n+\n+    #[test]\n+    fn test_is_empty() {\n+        let empty : list::list<int> = from_vec([]);\n+        let full1 = from_vec([1]);\n+        let full2 = from_vec(['r', 'u']);\n+\n+        assert is_empty(empty);\n+        assert !is_empty(full1);\n+        assert !is_empty(full2);\n+\n+        assert !is_not_empty(empty);\n+        assert is_not_empty(full1);\n+        assert is_not_empty(full2);\n+    }\n+\n+    #[test]\n+    fn test_from_vec() {\n+        let l = from_vec([0, 1, 2]);\n+\n+        check is_not_empty(l);\n+        assert (head(l) == 0);\n+\n+        let tail_l = tail(l);\n+        check is_not_empty(tail_l);\n+        assert (head(tail_l) == 1);\n+\n+        let tail_tail_l = tail(tail_l);\n+        check is_not_empty(tail_tail_l);\n+        assert (head(tail_tail_l) == 2);\n+    }\n+\n+    #[test]\n+    fn test_from_vec_empty() {\n+        let empty : list::list<int> = from_vec([]);\n+        assert (empty == list::nil::<int>);\n+    }\n+\n+    #[test]\n+    fn test_from_vec_mut() {\n+        let l = from_vec([mutable 0, 1, 2]);\n+\n+        check is_not_empty(l);\n+        assert (head(l) == 0);\n+\n+        let tail_l = tail(l);\n+        check is_not_empty(tail_l);\n+        assert (head(tail_l) == 1);\n+\n+        let tail_tail_l = tail(tail_l);\n+        check is_not_empty(tail_tail_l);\n+        assert (head(tail_tail_l) == 2);\n+    }\n+\n+    #[test]\n+    fn test_foldl() {\n+        fn add(&&a: uint, &&b: int) -> uint { ret a + (b as uint); }\n+        let l = from_vec([0, 1, 2, 3, 4]);\n+        let empty = list::nil::<int>;\n+        assert (list::foldl(l, 0u, add) == 10u);\n+        assert (list::foldl(empty, 0u, add) == 0u);\n+    }\n+\n+    #[test]\n+    fn test_foldl2() {\n+        fn sub(&&a: int, &&b: int) -> int {\n+            a - b\n+        }\n+        let l = from_vec([1, 2, 3, 4]);\n+        assert (list::foldl(l, 0, sub) == -10);\n+    }\n+\n+    #[test]\n+    fn test_find_success() {\n+        fn match(&&i: int) -> option::t<int> {\n+            ret if i == 2 { option::some(i) } else { option::none::<int> };\n+        }\n+        let l = from_vec([0, 1, 2]);\n+        assert (list::find(l, match) == option::some(2));\n+    }\n+\n+    #[test]\n+    fn test_find_fail() {\n+        fn match(&&_i: int) -> option::t<int> { ret option::none::<int>; }\n+        let l = from_vec([0, 1, 2]);\n+        let empty = list::nil::<int>;\n+        assert (list::find(l, match) == option::none::<int>);\n+        assert (list::find(empty, match) == option::none::<int>);\n+    }\n+\n+    #[test]\n+    fn test_has() {\n+        let l = from_vec([5, 8, 6]);\n+        let empty = list::nil::<int>;\n+        assert (list::has(l, 5));\n+        assert (!list::has(l, 7));\n+        assert (list::has(l, 8));\n+        assert (!list::has(empty, 5));\n+    }\n+\n+    #[test]\n+    fn test_len() {\n+        let l = from_vec([0, 1, 2]);\n+        let empty = list::nil::<int>;\n+        assert (list::len(l) == 3u);\n+        assert (list::len(empty) == 0u);\n+    }\n+\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "f9cc5c665724d86a209aea9e16fe3201eaf83f5a", "filename": "src/libstd/map.rs", "status": "modified", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=6e27b27cf8a9ece270f2556c3362524854d06de4", "patch": "@@ -388,3 +388,247 @@ Function: set_add\n Convenience function for adding keys to a hashmap with nil type keys\n */\n fn set_add<K>(set: set<K>, key: K) -> bool { ret set.insert(key, ()); }\n+\n+#[cfg(test)]\n+mod tests {\n+\n+    #[test]\n+    fn test_simple() {\n+        #debug(\"*** starting test_simple\");\n+        fn eq_uint(&&x: uint, &&y: uint) -> bool { ret x == y; }\n+        fn uint_id(&&x: uint) -> uint { x }\n+        let hasher_uint: map::hashfn<uint> = uint_id;\n+        let eqer_uint: map::eqfn<uint> = eq_uint;\n+        let hasher_str: map::hashfn<str> = str::hash;\n+        let eqer_str: map::eqfn<str> = str::eq;\n+        #debug(\"uint -> uint\");\n+        let hm_uu: map::hashmap<uint, uint> =\n+            map::mk_hashmap::<uint, uint>(hasher_uint, eqer_uint);\n+        assert (hm_uu.insert(10u, 12u));\n+        assert (hm_uu.insert(11u, 13u));\n+        assert (hm_uu.insert(12u, 14u));\n+        assert (hm_uu.get(11u) == 13u);\n+        assert (hm_uu.get(12u) == 14u);\n+        assert (hm_uu.get(10u) == 12u);\n+        assert (!hm_uu.insert(12u, 14u));\n+        assert (hm_uu.get(12u) == 14u);\n+        assert (!hm_uu.insert(12u, 12u));\n+        assert (hm_uu.get(12u) == 12u);\n+        let ten: str = \"ten\";\n+        let eleven: str = \"eleven\";\n+        let twelve: str = \"twelve\";\n+        #debug(\"str -> uint\");\n+        let hm_su: map::hashmap<str, uint> =\n+            map::mk_hashmap::<str, uint>(hasher_str, eqer_str);\n+        assert (hm_su.insert(\"ten\", 12u));\n+        assert (hm_su.insert(eleven, 13u));\n+        assert (hm_su.insert(\"twelve\", 14u));\n+        assert (hm_su.get(eleven) == 13u);\n+        assert (hm_su.get(\"eleven\") == 13u);\n+        assert (hm_su.get(\"twelve\") == 14u);\n+        assert (hm_su.get(\"ten\") == 12u);\n+        assert (!hm_su.insert(\"twelve\", 14u));\n+        assert (hm_su.get(\"twelve\") == 14u);\n+        assert (!hm_su.insert(\"twelve\", 12u));\n+        assert (hm_su.get(\"twelve\") == 12u);\n+        #debug(\"uint -> str\");\n+        let hm_us: map::hashmap<uint, str> =\n+            map::mk_hashmap::<uint, str>(hasher_uint, eqer_uint);\n+        assert (hm_us.insert(10u, \"twelve\"));\n+        assert (hm_us.insert(11u, \"thirteen\"));\n+        assert (hm_us.insert(12u, \"fourteen\"));\n+        assert (str::eq(hm_us.get(11u), \"thirteen\"));\n+        assert (str::eq(hm_us.get(12u), \"fourteen\"));\n+        assert (str::eq(hm_us.get(10u), \"twelve\"));\n+        assert (!hm_us.insert(12u, \"fourteen\"));\n+        assert (str::eq(hm_us.get(12u), \"fourteen\"));\n+        assert (!hm_us.insert(12u, \"twelve\"));\n+        assert (str::eq(hm_us.get(12u), \"twelve\"));\n+        #debug(\"str -> str\");\n+        let hm_ss: map::hashmap<str, str> =\n+            map::mk_hashmap::<str, str>(hasher_str, eqer_str);\n+        assert (hm_ss.insert(ten, \"twelve\"));\n+        assert (hm_ss.insert(eleven, \"thirteen\"));\n+        assert (hm_ss.insert(twelve, \"fourteen\"));\n+        assert (str::eq(hm_ss.get(\"eleven\"), \"thirteen\"));\n+        assert (str::eq(hm_ss.get(\"twelve\"), \"fourteen\"));\n+        assert (str::eq(hm_ss.get(\"ten\"), \"twelve\"));\n+        assert (!hm_ss.insert(\"twelve\", \"fourteen\"));\n+        assert (str::eq(hm_ss.get(\"twelve\"), \"fourteen\"));\n+        assert (!hm_ss.insert(\"twelve\", \"twelve\"));\n+        assert (str::eq(hm_ss.get(\"twelve\"), \"twelve\"));\n+        #debug(\"*** finished test_simple\");\n+    }\n+\n+\n+    /**\n+    * Force map growth\n+    */\n+    #[test]\n+    fn test_growth() {\n+        #debug(\"*** starting test_growth\");\n+        let num_to_insert: uint = 64u;\n+        fn eq_uint(&&x: uint, &&y: uint) -> bool { ret x == y; }\n+        fn uint_id(&&x: uint) -> uint { x }\n+        #debug(\"uint -> uint\");\n+        let hasher_uint: map::hashfn<uint> = uint_id;\n+        let eqer_uint: map::eqfn<uint> = eq_uint;\n+        let hm_uu: map::hashmap<uint, uint> =\n+            map::mk_hashmap::<uint, uint>(hasher_uint, eqer_uint);\n+        let i: uint = 0u;\n+        while i < num_to_insert {\n+            assert (hm_uu.insert(i, i * i));\n+            #debug(\"inserting %u -> %u\", i, i*i);\n+            i += 1u;\n+        }\n+        #debug(\"-----\");\n+        i = 0u;\n+        while i < num_to_insert {\n+            #debug(\"get(%u) = %u\", i, hm_uu.get(i));\n+            assert (hm_uu.get(i) == i * i);\n+            i += 1u;\n+        }\n+        assert (hm_uu.insert(num_to_insert, 17u));\n+        assert (hm_uu.get(num_to_insert) == 17u);\n+        #debug(\"-----\");\n+        i = 0u;\n+        while i < num_to_insert {\n+            #debug(\"get(%u) = %u\", i, hm_uu.get(i));\n+            assert (hm_uu.get(i) == i * i);\n+            i += 1u;\n+        }\n+        #debug(\"str -> str\");\n+        let hasher_str: map::hashfn<str> = str::hash;\n+        let eqer_str: map::eqfn<str> = str::eq;\n+        let hm_ss: map::hashmap<str, str> =\n+            map::mk_hashmap::<str, str>(hasher_str, eqer_str);\n+        i = 0u;\n+        while i < num_to_insert {\n+            assert hm_ss.insert(uint::to_str(i, 2u), uint::to_str(i * i, 2u));\n+            #debug(\"inserting \\\"%s\\\" -> \\\"%s\\\"\",\n+                   uint::to_str(i, 2u),\n+                   uint::to_str(i*i, 2u));\n+            i += 1u;\n+        }\n+        #debug(\"-----\");\n+        i = 0u;\n+        while i < num_to_insert {\n+            #debug(\"get(\\\"%s\\\") = \\\"%s\\\"\",\n+                   uint::to_str(i, 2u),\n+                   hm_ss.get(uint::to_str(i, 2u)));\n+            assert (str::eq(hm_ss.get(uint::to_str(i, 2u)),\n+                            uint::to_str(i * i, 2u)));\n+            i += 1u;\n+        }\n+        assert (hm_ss.insert(uint::to_str(num_to_insert, 2u),\n+                             uint::to_str(17u, 2u)));\n+        assert (str::eq(hm_ss.get(uint::to_str(num_to_insert, 2u)),\n+                        uint::to_str(17u, 2u)));\n+        #debug(\"-----\");\n+        i = 0u;\n+        while i < num_to_insert {\n+            #debug(\"get(\\\"%s\\\") = \\\"%s\\\"\",\n+                   uint::to_str(i, 2u),\n+                   hm_ss.get(uint::to_str(i, 2u)));\n+            assert (str::eq(hm_ss.get(uint::to_str(i, 2u)),\n+                            uint::to_str(i * i, 2u)));\n+            i += 1u;\n+        }\n+        #debug(\"*** finished test_growth\");\n+    }\n+\n+    #[test]\n+    fn test_removal() {\n+        #debug(\"*** starting test_removal\");\n+        let num_to_insert: uint = 64u;\n+        fn eq(&&x: uint, &&y: uint) -> bool { ret x == y; }\n+        fn hash(&&u: uint) -> uint {\n+            // This hash function intentionally causes collisions between\n+            // consecutive integer pairs.\n+\n+            ret u / 2u * 2u;\n+        }\n+        assert (hash(0u) == hash(1u));\n+        assert (hash(2u) == hash(3u));\n+        assert (hash(0u) != hash(2u));\n+        let hasher: map::hashfn<uint> = hash;\n+        let eqer: map::eqfn<uint> = eq;\n+        let hm: map::hashmap<uint, uint> =\n+            map::mk_hashmap::<uint, uint>(hasher, eqer);\n+        let i: uint = 0u;\n+        while i < num_to_insert {\n+            assert (hm.insert(i, i * i));\n+            #debug(\"inserting %u -> %u\", i, i*i);\n+            i += 1u;\n+        }\n+        assert (hm.size() == num_to_insert);\n+        #debug(\"-----\");\n+        #debug(\"removing evens\");\n+        i = 0u;\n+        while i < num_to_insert {\n+            let v = hm.remove(i);\n+            alt v {\n+              option::some(u) { assert (u == i * i); }\n+              option::none. { fail; }\n+            }\n+            i += 2u;\n+        }\n+        assert (hm.size() == num_to_insert / 2u);\n+        #debug(\"-----\");\n+        i = 1u;\n+        while i < num_to_insert {\n+            #debug(\"get(%u) = %u\", i, hm.get(i));\n+            assert (hm.get(i) == i * i);\n+            i += 2u;\n+        }\n+        #debug(\"-----\");\n+        i = 1u;\n+        while i < num_to_insert {\n+            #debug(\"get(%u) = %u\", i, hm.get(i));\n+            assert (hm.get(i) == i * i);\n+            i += 2u;\n+        }\n+        #debug(\"-----\");\n+        i = 0u;\n+        while i < num_to_insert {\n+            assert (hm.insert(i, i * i));\n+            #debug(\"inserting %u -> %u\", i, i*i);\n+            i += 2u;\n+        }\n+        assert (hm.size() == num_to_insert);\n+        #debug(\"-----\");\n+        i = 0u;\n+        while i < num_to_insert {\n+            #debug(\"get(%u) = %u\", i, hm.get(i));\n+            assert (hm.get(i) == i * i);\n+            i += 1u;\n+        }\n+        #debug(\"-----\");\n+        assert (hm.size() == num_to_insert);\n+        i = 0u;\n+        while i < num_to_insert {\n+            #debug(\"get(%u) = %u\", i, hm.get(i));\n+            assert (hm.get(i) == i * i);\n+            i += 1u;\n+        }\n+        #debug(\"*** finished test_removal\");\n+    }\n+\n+    #[test]\n+    fn test_contains_key() {\n+        let key = \"k\";\n+        let map = map::mk_hashmap::<str, str>(str::hash, str::eq);\n+        assert (!map.contains_key(key));\n+        map.insert(key, \"val\");\n+        assert (map.contains_key(key));\n+    }\n+\n+    #[test]\n+    fn test_find() {\n+        let key = \"k\";\n+        let map = map::mk_hashmap::<str, str>(str::hash, str::eq);\n+        assert (option::is_none(map.find(key)));\n+        map.insert(key, \"val\");\n+        assert (option::get(map.find(key)) == \"val\");\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "ba00ae649333cac93d8e3526d73624f5fefc1f22", "filename": "src/libstd/net.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet.rs?ref=6e27b27cf8a9ece270f2556c3362524854d06de4", "patch": "@@ -54,3 +54,13 @@ fn parse_addr(ip: str) -> ip_addr {\n     for i in parts { if i > 255u { fail \"Invalid IP Address part.\"; } }\n     ipv4(parts[0] as u8, parts[1] as u8, parts[2] as u8, parts[3] as u8)\n }\n+\n+#[test]\n+fn test_format_ip() {\n+    assert (net::format_addr(net::ipv4(127u8, 0u8, 0u8, 1u8)) == \"127.0.0.1\")\n+}\n+\n+#[test]\n+fn test_parse_ip() {\n+    assert (net::parse_addr(\"127.0.0.1\") == net::ipv4(127u8, 0u8, 0u8, 1u8));\n+}"}, {"sha": "85f3d99c6c8a708c62c87e3b5724156e979ccf24", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=6e27b27cf8a9ece270f2556c3362524854d06de4", "patch": "@@ -94,6 +94,46 @@ fn mk_rng() -> rng {\n     }\n     @rand_res(rustrt::rand_new()) as rng\n }\n+\n+#[cfg(test)]\n+mod tests {\n+\n+    #[test]\n+    fn test() {\n+        let r1: rand::rng = rand::mk_rng();\n+        log(debug, r1.next());\n+        log(debug, r1.next());\n+        {\n+            let r2 = rand::mk_rng();\n+            log(debug, r1.next());\n+            log(debug, r2.next());\n+            log(debug, r1.next());\n+            log(debug, r1.next());\n+            log(debug, r2.next());\n+            log(debug, r2.next());\n+            log(debug, r1.next());\n+            log(debug, r1.next());\n+            log(debug, r1.next());\n+            log(debug, r2.next());\n+            log(debug, r2.next());\n+            log(debug, r2.next());\n+        }\n+        log(debug, r1.next());\n+        log(debug, r1.next());\n+    }\n+\n+    #[test]\n+    fn genstr() {\n+        let r: rand::rng = rand::mk_rng();\n+        log(debug, r.gen_str(10u));\n+        log(debug, r.gen_str(10u));\n+        log(debug, r.gen_str(10u));\n+        assert(str::char_len(r.gen_str(10u)) == 10u);\n+        assert(str::char_len(r.gen_str(16u)) == 16u);\n+    }\n+}\n+\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "d18038eed615cbd4d6c0527eab4b44a7af3e19fe", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=6e27b27cf8a9ece270f2556c3362524854d06de4", "patch": "@@ -1332,3 +1332,166 @@ mod node {\n     }\n }\n \n+#[cfg(test)]\n+mod tests {\n+\n+    //Utility function, used for sanity check\n+    fn rope_to_string(r: rope) -> str {\n+        alt(r) {\n+          node::empty. { ret \"\" }\n+          node::content(x) {\n+            let str = @mutable \"\";\n+            fn aux(str: @mutable str, node: @node::node) {\n+                alt(*node) {\n+                  node::leaf(x) {\n+                    *str += str::substr(\n+                        *x.content, x.byte_offset, x.byte_len);\n+                  }\n+                  node::concat(x) {\n+                    aux(str, x.left);\n+                    aux(str, x.right);\n+                  }\n+                }\n+            }\n+            aux(str, x);\n+            ret *str\n+          }\n+        }\n+    }\n+\n+\n+    #[test]\n+    fn trivial() {\n+        assert char_len(empty()) == 0u;\n+        assert byte_len(empty()) == 0u;\n+    }\n+\n+    #[test]\n+    fn of_string1() {\n+        let sample = @\"0123456789ABCDE\";\n+        let r      = of_str(sample);\n+\n+        assert char_len(r) == str::char_len(*sample);\n+        assert rope_to_string(r) == *sample;\n+    }\n+\n+    #[test]\n+    fn of_string2() {\n+        let buf = @ mutable \"1234567890\";\n+        let i = 0;\n+        while i < 10 { *buf = *buf + *buf; i+=1;}\n+        let sample = @*buf;\n+        let r      = of_str(sample);\n+        assert char_len(r) == str::char_len(*sample);\n+        assert rope_to_string(r) == *sample;\n+\n+        let string_iter = 0u;\n+        let string_len  = str::byte_len(*sample);\n+        let rope_iter   = iterator::char::start(r);\n+        let equal       = true;\n+        let pos         = 0u;\n+        while equal {\n+            alt(node::char_iterator::next(rope_iter)) {\n+              option::none. {\n+                if string_iter < string_len {\n+                    equal = false;\n+                } break; }\n+              option::some(c) {\n+                let {ch, next} = str::char_range_at(*sample, string_iter);\n+                string_iter = next;\n+                if ch != c { equal = false; break; }\n+              }\n+            }\n+            pos += 1u;\n+        }\n+\n+        assert equal;\n+    }\n+\n+    #[test]\n+    fn iter1() {\n+        let buf = @ mutable \"1234567890\";\n+        let i = 0;\n+        while i < 10 { *buf = *buf + *buf; i+=1;}\n+        let sample = @*buf;\n+        let r      = of_str(sample);\n+\n+        let len = 0u;\n+        let it  = iterator::char::start(r);\n+        while true {\n+            alt(node::char_iterator::next(it)) {\n+              option::none. { break; }\n+              option::some(_) { len += 1u; }\n+            }\n+        }\n+\n+        assert len == str::char_len(*sample);\n+    }\n+\n+    #[test]\n+    fn bal1() {\n+        let init = @ \"1234567890\";\n+        let buf  = @ mutable * init;\n+        let i = 0;\n+        while i < 8 { *buf = *buf + *buf; i+=1;}\n+        let sample = @*buf;\n+        let r1     = of_str(sample);\n+        let r2     = of_str(init);\n+        i = 0;\n+        while i < 8 { r2 = append_rope(r2, r2); i+= 1;}\n+\n+\n+        assert eq(r1, r2);\n+        let r3 = bal(r2);\n+        assert char_len(r1) == char_len(r3);\n+\n+        assert eq(r1, r3);\n+    }\n+\n+    #[test]\n+    fn char_at1() {\n+        //Generate a large rope\n+        let r = of_str(@ \"123456789\");\n+        uint::range(0u, 10u){|_i|\n+            r = append_rope(r, r);\n+        }\n+\n+        //Copy it in the slowest possible way\n+        let r2 = empty();\n+        uint::range(0u, char_len(r)){|i|\n+            r2 = append_char(r2, char_at(r, i));\n+        }\n+        assert eq(r, r2);\n+\n+        let r3 = empty();\n+        uint::range(0u, char_len(r)){|i|\n+            r3 = prepend_char(r3, char_at(r, char_len(r) - i - 1u));\n+        }\n+        assert eq(r, r3);\n+\n+        //Additional sanity checks\n+        let balr = bal(r);\n+        let bal2 = bal(r2);\n+        let bal3 = bal(r3);\n+        assert eq(r, balr);\n+        assert eq(r, bal2);\n+        assert eq(r, bal3);\n+        assert eq(r2, r3);\n+        assert eq(bal2, bal3);\n+    }\n+\n+    #[test]\n+    fn concat1() {\n+        //Generate a reasonable rope\n+        let chunk = of_str(@ \"123456789\");\n+        let r = empty();\n+        uint::range(0u, 10u){|_i|\n+            r = append_rope(r, chunk);\n+        }\n+\n+        //Same rope, obtained with rope::concat\n+        let r2 = concat(vec::init_elt(chunk, 10u));\n+\n+        assert eq(r, r2);\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "e40526b58840a61a5e3c4232a0b60e685fd73229", "filename": "src/libstd/run_program.rs", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Frun_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Frun_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun_program.rs?ref=6e27b27cf8a9ece270f2556c3362524854d06de4", "patch": "@@ -294,6 +294,75 @@ fn waitpid(pid: pid_t) -> int {\n     }\n }\n \n+#[cfg(test)]\n+mod tests {\n+\n+    import io::writer_util;\n+    import ctypes::fd_t;\n+\n+    // Regression test for memory leaks\n+    #[ignore(cfg(target_os = \"win32\"))] // FIXME\n+    fn test_leaks() {\n+        run::run_program(\"echo\", []);\n+        run::start_program(\"echo\", []);\n+        run::program_output(\"echo\", []);\n+    }\n+\n+    #[test]\n+    fn test_pipes() {\n+        let pipe_in = os::pipe();\n+        let pipe_out = os::pipe();\n+        let pipe_err = os::pipe();\n+\n+        let pid =\n+            run::spawn_process(\n+                \"cat\", [], pipe_in.in, pipe_out.out, pipe_err.out);\n+        os::close(pipe_in.in);\n+        os::close(pipe_out.out);\n+        os::close(pipe_err.out);\n+\n+        if pid == -1i32 { fail; }\n+        let expected = \"test\";\n+        writeclose(pipe_in.out, expected);\n+        let actual = readclose(pipe_out.in);\n+        readclose(pipe_err.in);\n+        os::waitpid(pid);\n+\n+        log(debug, expected);\n+        log(debug, actual);\n+        assert (expected == actual);\n+\n+        fn writeclose(fd: fd_t, s: str) {\n+            #error(\"writeclose %d, %s\", fd as int, s);\n+            let writer = io::fd_writer(fd, false);\n+            writer.write_str(s);\n+\n+            os::close(fd);\n+        }\n+\n+        fn readclose(fd: fd_t) -> str {\n+            // Copied from run::program_output\n+            let file = os::fd_FILE(fd);\n+            let reader = io::FILE_reader(file, false);\n+            let buf = \"\";\n+            while !reader.eof() {\n+                let bytes = reader.read_bytes(4096u);\n+                buf += str::unsafe_from_bytes(bytes);\n+            }\n+            os::fclose(file);\n+            ret buf;\n+        }\n+    }\n+\n+    #[test]\n+    fn waitpid() {\n+        let pid = run::spawn_process(\"false\", [], 0i32, 0i32, 0i32);\n+        let status = run::waitpid(pid);\n+        assert status == 1;\n+    }\n+\n+}\n+\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "17bb82a722b17fdc0ae19f8749c64786231600d4", "filename": "src/libstd/sha1.rs", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsha1.rs?ref=6e27b27cf8a9ece270f2556c3362524854d06de4", "patch": "@@ -287,6 +287,102 @@ fn mk_sha1() -> sha1 {\n     ret sh;\n }\n \n+#[cfg(test)]\n+mod tests {\n+\n+    #[test]\n+    fn test() {\n+        type test = {input: str, output: [u8]};\n+\n+        fn a_million_letter_a() -> str {\n+            let i = 0;\n+            let rs = \"\";\n+            while i < 100000 { rs += \"aaaaaaaaaa\"; i += 1; }\n+            ret rs;\n+        }\n+        // Test messages from FIPS 180-1\n+\n+        let fips_180_1_tests: [test] =\n+            [{input: \"abc\",\n+              output:\n+                  [0xA9u8, 0x99u8, 0x3Eu8, 0x36u8,\n+                   0x47u8, 0x06u8, 0x81u8, 0x6Au8,\n+                   0xBAu8, 0x3Eu8, 0x25u8, 0x71u8,\n+                   0x78u8, 0x50u8, 0xC2u8, 0x6Cu8,\n+                   0x9Cu8, 0xD0u8, 0xD8u8, 0x9Du8]},\n+             {input:\n+                  \"abcdbcdecdefdefgefghfghighij\" +\n+                  \"hijkijkljklmklmnlmnomnopnopq\",\n+              output:\n+                  [0x84u8, 0x98u8, 0x3Eu8, 0x44u8,\n+                   0x1Cu8, 0x3Bu8, 0xD2u8, 0x6Eu8,\n+                   0xBAu8, 0xAEu8, 0x4Au8, 0xA1u8,\n+                   0xF9u8, 0x51u8, 0x29u8, 0xE5u8,\n+                   0xE5u8, 0x46u8, 0x70u8, 0xF1u8]},\n+             {input: a_million_letter_a(),\n+              output:\n+                  [0x34u8, 0xAAu8, 0x97u8, 0x3Cu8,\n+                   0xD4u8, 0xC4u8, 0xDAu8, 0xA4u8,\n+                   0xF6u8, 0x1Eu8, 0xEBu8, 0x2Bu8,\n+                   0xDBu8, 0xADu8, 0x27u8, 0x31u8,\n+                   0x65u8, 0x34u8, 0x01u8, 0x6Fu8]}];\n+        // Examples from wikipedia\n+\n+        let wikipedia_tests: [test] =\n+            [{input: \"The quick brown fox jumps over the lazy dog\",\n+              output:\n+                  [0x2fu8, 0xd4u8, 0xe1u8, 0xc6u8,\n+                   0x7au8, 0x2du8, 0x28u8, 0xfcu8,\n+                   0xedu8, 0x84u8, 0x9eu8, 0xe1u8,\n+                   0xbbu8, 0x76u8, 0xe7u8, 0x39u8,\n+                   0x1bu8, 0x93u8, 0xebu8, 0x12u8]},\n+             {input: \"The quick brown fox jumps over the lazy cog\",\n+              output:\n+                  [0xdeu8, 0x9fu8, 0x2cu8, 0x7fu8,\n+                   0xd2u8, 0x5eu8, 0x1bu8, 0x3au8,\n+                   0xfau8, 0xd3u8, 0xe8u8, 0x5au8,\n+                   0x0bu8, 0xd1u8, 0x7du8, 0x9bu8,\n+                   0x10u8, 0x0du8, 0xb4u8, 0xb3u8]}];\n+        let tests = fips_180_1_tests + wikipedia_tests;\n+        fn check_vec_eq(v0: [u8], v1: [u8]) {\n+            assert (vec::len::<u8>(v0) == vec::len::<u8>(v1));\n+            let len = vec::len::<u8>(v0);\n+            let i = 0u;\n+            while i < len {\n+                let a = v0[i];\n+                let b = v1[i];\n+                assert (a == b);\n+                i += 1u;\n+            }\n+        }\n+        // Test that it works when accepting the message all at once\n+\n+        let sh = sha1::mk_sha1();\n+        for t: test in tests {\n+            sh.input_str(t.input);\n+            let out = sh.result();\n+            check_vec_eq(t.output, out);\n+            sh.reset();\n+        }\n+\n+\n+        // Test that it works when accepting the message in pieces\n+        for t: test in tests {\n+            let len = str::byte_len(t.input);\n+            let left = len;\n+            while left > 0u {\n+                let take = (left + 1u) / 2u;\n+                sh.input_str(str::substr(t.input, len - left, take));\n+                left = left - take;\n+            }\n+            let out = sh.result();\n+            check_vec_eq(t.output, out);\n+            sh.reset();\n+        }\n+    }\n+\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "8739e8d81c50eeb6cbb1ff50ef5bc7f535b9fe31", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=6e27b27cf8a9ece270f2556c3362524854d06de4", "patch": "@@ -157,6 +157,150 @@ fn quick_sort3<T: copy>(compare_func_lt: lteq<T>, compare_func_eq: lteq<T>,\n                 (len::<T>(arr) as int) - 1);\n }\n \n+#[cfg(test)]\n+mod test_qsort3 {\n+    fn check_sort(v1: [mutable int], v2: [mutable int]) {\n+        let len = vec::len::<int>(v1);\n+        fn lt(&&a: int, &&b: int) -> bool { ret a < b; }\n+        fn equal(&&a: int, &&b: int) -> bool { ret a == b; }\n+        let f1 = lt;\n+        let f2 = equal;\n+        quick_sort3::<int>(f1, f2, v1);\n+        let i = 0u;\n+        while i < len {\n+            log(debug, v2[i]);\n+            assert (v2[i] == v1[i]);\n+            i += 1u;\n+        }\n+    }\n+\n+    #[test]\n+    fn test() {\n+        {\n+            let v1 = [mutable 3, 7, 4, 5, 2, 9, 5, 8];\n+            let v2 = [mutable 2, 3, 4, 5, 5, 7, 8, 9];\n+            check_sort(v1, v2);\n+        }\n+        {\n+            let v1 = [mutable 1, 1, 1];\n+            let v2 = [mutable 1, 1, 1];\n+            check_sort(v1, v2);\n+        }\n+        {\n+            let v1: [mutable int] = [mutable];\n+            let v2: [mutable int] = [mutable];\n+            check_sort(v1, v2);\n+        }\n+        { let v1 = [mutable 9]; let v2 = [mutable 9]; check_sort(v1, v2); }\n+        {\n+            let v1 = [mutable 9, 3, 3, 3, 9];\n+            let v2 = [mutable 3, 3, 3, 9, 9];\n+            check_sort(v1, v2);\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test_qsort {\n+    fn check_sort(v1: [mutable int], v2: [mutable int]) {\n+        let len = vec::len::<int>(v1);\n+        fn ltequal(&&a: int, &&b: int) -> bool { ret a <= b; }\n+        let f = ltequal;\n+        quick_sort::<int>(f, v1);\n+        let i = 0u;\n+        while i < len {\n+            log(debug, v2[i]);\n+            assert (v2[i] == v1[i]);\n+            i += 1u;\n+        }\n+    }\n+\n+    #[test]\n+    fn test() {\n+        {\n+            let v1 = [mutable 3, 7, 4, 5, 2, 9, 5, 8];\n+            let v2 = [mutable 2, 3, 4, 5, 5, 7, 8, 9];\n+            check_sort(v1, v2);\n+        }\n+        {\n+            let v1 = [mutable 1, 1, 1];\n+            let v2 = [mutable 1, 1, 1];\n+            check_sort(v1, v2);\n+        }\n+        {\n+            let v1: [mutable int] = [mutable];\n+            let v2: [mutable int] = [mutable];\n+            check_sort(v1, v2);\n+        }\n+        { let v1 = [mutable 9]; let v2 = [mutable 9]; check_sort(v1, v2); }\n+        {\n+            let v1 = [mutable 9, 3, 3, 3, 9];\n+            let v2 = [mutable 3, 3, 3, 9, 9];\n+            check_sort(v1, v2);\n+        }\n+    }\n+\n+    // Regression test for #750\n+    #[test]\n+    fn test_simple() {\n+        let names = [mutable 2, 1, 3];\n+\n+        let expected = [1, 2, 3];\n+\n+        fn lteq(&&a: int, &&b: int) -> bool { int::le(a, b) }\n+        sort::quick_sort(lteq, names);\n+\n+        let immut_names = vec::from_mut(names);\n+\n+        // Silly, but what else can we do?\n+        check (vec::same_length(expected, immut_names));\n+        let pairs = vec::zip(expected, immut_names);\n+        for (a, b) in pairs { #debug(\"%d %d\", a, b); assert (a == b); }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+\n+    fn check_sort(v1: [int], v2: [int]) {\n+        let len = vec::len::<int>(v1);\n+        fn lteq(&&a: int, &&b: int) -> bool { ret a <= b; }\n+        let f = lteq;\n+        let v3 = merge_sort::<int>(f, v1);\n+        let i = 0u;\n+        while i < len {\n+            log(debug, v3[i]);\n+            assert (v3[i] == v2[i]);\n+            i += 1u;\n+        }\n+    }\n+\n+    #[test]\n+    fn test() {\n+        {\n+            let v1 = [3, 7, 4, 5, 2, 9, 5, 8];\n+            let v2 = [2, 3, 4, 5, 5, 7, 8, 9];\n+            check_sort(v1, v2);\n+        }\n+        { let v1 = [1, 1, 1]; let v2 = [1, 1, 1]; check_sort(v1, v2); }\n+        { let v1: [int] = []; let v2: [int] = []; check_sort(v1, v2); }\n+        { let v1 = [9]; let v2 = [9]; check_sort(v1, v2); }\n+        {\n+            let v1 = [9, 3, 3, 3, 9];\n+            let v2 = [3, 3, 3, 9, 9];\n+            check_sort(v1, v2);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_merge_sort_mutable() {\n+        fn lteq(&&a: int, &&b: int) -> bool { ret a <= b; }\n+        let v1 = [mutable 3, 2, 1];\n+        let v2 = merge_sort(lteq, v1);\n+        assert v2 == [1, 2, 3];\n+    }\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "197c1a71cb02d384d622289c5a932ff47419e1fc", "filename": "src/libstd/tempfile.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftempfile.rs?ref=6e27b27cf8a9ece270f2556c3362524854d06de4", "patch": "@@ -24,3 +24,15 @@ fn mkdtemp(prefix: str, suffix: str) -> option::t<str> {\n     }\n     ret none;\n }\n+\n+#[test]\n+fn test_mkdtemp() {\n+    let r = mkdtemp(\"./\", \"foobar\");\n+    alt r {\n+        some(p) {\n+            fs::remove_dir(p);\n+            assert(str::ends_with(p, \"foobar\"));\n+        }\n+        _ { assert(false); }\n+    }\n+}"}, {"sha": "7dbe8659679e78eb7d891bb31b1c7786a7b1ca9a", "filename": "src/libstd/test.rs", "status": "modified", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=6e27b27cf8a9ece270f2556c3362524854d06de4", "patch": "@@ -343,6 +343,135 @@ fn configure_test_task() {\n     task::unsupervise();\n }\n \n+#[cfg(test)]\n+mod tests {\n+\n+    #[test]\n+    fn do_not_run_ignored_tests() {\n+        fn f() { fail; }\n+        let desc = {\n+            name: \"whatever\",\n+            fn: f,\n+            ignore: true,\n+            should_fail: false\n+        };\n+        let future = test::run_test(desc, test::default_test_to_task);\n+        let result = future.wait();\n+        assert result != test::tr_ok;\n+    }\n+\n+    #[test]\n+    fn ignored_tests_result_in_ignored() {\n+        fn f() { }\n+        let desc = {\n+            name: \"whatever\",\n+            fn: f,\n+            ignore: true,\n+            should_fail: false\n+        };\n+        let res = test::run_test(desc, test::default_test_to_task).wait();\n+        assert (res == test::tr_ignored);\n+    }\n+\n+    #[test]\n+    #[ignore(cfg(target_os = \"win32\"))]\n+    fn test_should_fail() {\n+        fn f() { fail; }\n+        let desc = {\n+            name: \"whatever\",\n+            fn: f,\n+            ignore: false,\n+            should_fail: true\n+        };\n+        let res = test::run_test(desc, test::default_test_to_task).wait();\n+        assert res == test::tr_ok;\n+    }\n+\n+    #[test]\n+    fn test_should_fail_but_succeeds() {\n+        fn f() { }\n+        let desc = {\n+            name: \"whatever\",\n+            fn: f,\n+            ignore: false,\n+            should_fail: true\n+        };\n+        let res = test::run_test(desc, test::default_test_to_task).wait();\n+        assert res == test::tr_failed;\n+    }\n+\n+    #[test]\n+    fn first_free_arg_should_be_a_filter() {\n+        let args = [\"progname\", \"filter\"];\n+        check (vec::is_not_empty(args));\n+        let opts = alt test::parse_opts(args) { either::left(o) { o } };\n+        assert (str::eq(\"filter\", option::get(opts.filter)));\n+    }\n+\n+    #[test]\n+    fn parse_ignored_flag() {\n+        let args = [\"progname\", \"filter\", \"--ignored\"];\n+        check (vec::is_not_empty(args));\n+        let opts = alt test::parse_opts(args) { either::left(o) { o } };\n+        assert (opts.run_ignored);\n+    }\n+\n+    #[test]\n+    fn filter_for_ignored_option() {\n+        // When we run ignored tests the test filter should filter out all the\n+        // unignored tests and flip the ignore flag on the rest to false\n+\n+        let opts = {filter: option::none, run_ignored: true};\n+        let tests =\n+            [{name: \"1\", fn: fn@() { }, ignore: true, should_fail: false},\n+             {name: \"2\", fn: fn@() { }, ignore: false, should_fail: false}];\n+        let filtered = test::filter_tests(opts, tests);\n+\n+        assert (vec::len(filtered) == 1u);\n+        assert (filtered[0].name == \"1\");\n+        assert (filtered[0].ignore == false);\n+    }\n+\n+    #[test]\n+    fn sort_tests() {\n+        let opts = {filter: option::none, run_ignored: false};\n+\n+        let names =\n+            [\"sha1::test\", \"int::test_to_str\", \"int::test_pow\",\n+             \"test::do_not_run_ignored_tests\",\n+             \"test::ignored_tests_result_in_ignored\",\n+             \"test::first_free_arg_should_be_a_filter\",\n+             \"test::parse_ignored_flag\", \"test::filter_for_ignored_option\",\n+             \"test::sort_tests\"];\n+        let tests =\n+        {\n+        let testfn = fn@() { };\n+        let tests = [];\n+        for name: str in names {\n+            let test = {name: name, fn: testfn, ignore: false,\n+                        should_fail: false};\n+            tests += [test];\n+        }\n+        tests\n+    };\n+    let filtered = test::filter_tests(opts, tests);\n+\n+    let expected =\n+        [\"int::test_pow\", \"int::test_to_str\", \"sha1::test\",\n+         \"test::do_not_run_ignored_tests\", \"test::filter_for_ignored_option\",\n+         \"test::first_free_arg_should_be_a_filter\",\n+         \"test::ignored_tests_result_in_ignored\", \"test::parse_ignored_flag\",\n+         \"test::sort_tests\"];\n+\n+    check (vec::same_length(expected, filtered));\n+    let pairs = vec::zip(expected, filtered);\n+\n+\n+    for (a, b) in pairs { assert (a == b.name); }\n+}\n+}\n+\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "2dc539216e0444f57f856d89b9e45374187199ec", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=6e27b27cf8a9ece270f2556c3362524854d06de4", "patch": "@@ -94,3 +94,65 @@ fn traverse<K, V>(m: treemap<K, V>, f: block(K, V)) {\n       }\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+\n+    #[test]\n+    fn init_treemap() { let _m = init::<int, int>(); }\n+\n+    #[test]\n+    fn insert_one() { let m = init(); insert(m, 1, 2); }\n+\n+    #[test]\n+    fn insert_two() { let m = init(); insert(m, 1, 2); insert(m, 3, 4); }\n+\n+    #[test]\n+    fn insert_find() {\n+        let m = init();\n+        insert(m, 1, 2);\n+        assert (find(m, 1) == some(2));\n+    }\n+\n+    #[test]\n+    fn find_empty() {\n+        let m = init::<int, int>(); assert (find(m, 1) == none);\n+    }\n+\n+    #[test]\n+    fn find_not_found() {\n+        let m = init();\n+        insert(m, 1, 2);\n+        assert (find(m, 2) == none);\n+    }\n+\n+    #[test]\n+    fn traverse_in_order() {\n+        let m = init();\n+        insert(m, 3, ());\n+        insert(m, 0, ());\n+        insert(m, 4, ());\n+        insert(m, 2, ());\n+        insert(m, 1, ());\n+\n+        let n = @mutable 0;\n+        fn t(n: @mutable int, &&k: int, &&_v: ()) {\n+            assert (*n == k); *n += 1;\n+        }\n+        traverse(m, bind t(n, _, _));\n+    }\n+\n+    #[test]\n+    fn u8_map() {\n+        let m = init();\n+\n+        let k1 = str::bytes(\"foo\");\n+        let k2 = str::bytes(\"bar\");\n+\n+        insert(m, k1, \"foo\");\n+        insert(m, k2, \"bar\");\n+\n+        assert (find(m, k2) == some(\"bar\"));\n+        assert (find(m, k1) == some(\"foo\"));\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "558a45f475a51d9922b691e8122d288b96823abf", "filename": "src/libstd/tri.rs", "status": "modified", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Ftri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Ftri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftri.rs?ref=6e27b27cf8a9ece270f2556c3362524854d06de4", "patch": "@@ -179,6 +179,124 @@ An u8 whose first bit is set if `if_true(v)` holds\n */\n fn to_bit(v: t) -> u8 { v & b0 }\n \n+#[cfg(test)]\n+mod tests {\n+\n+    pure fn eq1(a: tri::t, b: tri::t) -> bool { tri::eq(a , b) }\n+    pure fn ne1(a: tri::t, b: tri::t) -> bool { tri::ne(a , b) }\n+\n+    pure fn eq2(a: tri::t, b: tri::t) -> bool { eq1( a, b ) && eq1( b, a ) }\n+\n+    #[test]\n+    fn test_eq2() {\n+        tri::all_values { |a|\n+            tri::all_values { |b|\n+                assert if a == b { eq1( a, b ) } else { ne1( a, b ) }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_tri_and_symmetry() {\n+        tri::all_values { |a|\n+            tri::all_values { |b|\n+                assert eq1( tri::and(a ,b), tri::and(b, a) );\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_tri_or_symmetry() {\n+        tri::all_values { |a|\n+            tri::all_values { |b|\n+                assert eq1( tri::or(a ,b), tri::or(b, a) );\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_tri_xor_symmetry() {\n+        tri::all_values { |a|\n+            tri::all_values { |b|\n+                assert eq1( tri::xor(a ,b), tri::xor(b, a) );\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_tri_not() {\n+        assert eq2( tri::not(tri::true), tri::false);\n+        assert eq2( tri::not(tri::unknown), tri::unknown);\n+        assert eq2( tri::not(tri::false), tri::true);\n+    }\n+\n+    #[test]\n+    fn test_tri_and() {\n+        assert eq2( tri::and(tri::true, tri::true), tri::true);\n+        assert eq2( tri::and(tri::true, tri::false), tri::false);\n+        assert eq2( tri::and(tri::true, tri::unknown), tri::unknown);\n+        assert eq2( tri::and(tri::false, tri::false), tri::false);\n+        assert eq2( tri::and(tri::false, tri::unknown), tri::false);\n+        assert eq2( tri::and(tri::unknown, tri::unknown), tri::unknown);\n+    }\n+\n+    #[test]\n+    fn test_tri_or() {\n+        assert eq2( tri::or(tri::true, tri::true), tri::true);\n+        assert eq2( tri::or(tri::true, tri::false), tri::true);\n+        assert eq2( tri::or(tri::true, tri::unknown), tri::true);\n+        assert eq2( tri::or(tri::false, tri::false), tri::false);\n+        assert eq2( tri::or(tri::false, tri::unknown), tri::unknown);\n+        assert eq2( tri::or(tri::unknown, tri::unknown), tri::unknown);\n+    }\n+\n+    #[test]\n+    fn test_tri_xor() {\n+        assert eq2( tri::xor(tri::true, tri::true), tri::false);\n+        assert eq2( tri::xor(tri::false, tri::false), tri::false);\n+        assert eq2( tri::xor(tri::true, tri::false), tri::true);\n+        assert eq2( tri::xor(tri::true, tri::unknown), tri::unknown);\n+        assert eq2( tri::xor(tri::false, tri::unknown), tri::unknown);\n+        assert eq2( tri::xor(tri::unknown, tri::unknown), tri::unknown);\n+    }\n+\n+    #[test]\n+    fn test_tri_implies() {\n+        assert eq2( tri::implies(tri::false, tri::false), tri::true);\n+        assert eq2( tri::implies(tri::false, tri::unknown), tri::true);\n+        assert eq2( tri::implies(tri::false, tri::true), tri::true);\n+\n+        assert eq2( tri::implies(tri::unknown, tri::false), tri::unknown);\n+        assert eq2( tri::implies(tri::unknown, tri::unknown), tri::unknown);\n+        assert eq2( tri::implies(tri::unknown, tri::true), tri::true);\n+\n+        assert eq2( tri::implies(tri::true, tri::false), tri::false);\n+        assert eq2( tri::implies(tri::true, tri::unknown), tri::unknown);\n+        assert eq2( tri::implies(tri::true, tri::true), tri::true);\n+    }\n+\n+    #[test]\n+    fn test_tri_from_str() {\n+        tri::all_values { |v|\n+            assert eq2( v, tri::from_str(tri::to_str(v)));\n+        }\n+    }\n+\n+    #[test]\n+    fn test_tri_to_str() {\n+        assert tri::to_str(tri::false) == \"false\";\n+        assert tri::to_str(tri::unknown) == \"unknown\";\n+        assert tri::to_str(tri::true) == \"true\";\n+    }\n+\n+    #[test]\n+    fn test_tri_to_bit() {\n+        tri::all_values { |v|\n+            assert tri::to_bit(v) == if tri::is_true(v) { 1u8 } else { 0u8 };\n+        }\n+    }\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "1640888dd0109af78106bf0cd3f6fbf3ff8de9c1", "filename": "src/libstd/unicode.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funicode.rs?ref=6e27b27cf8a9ece270f2556c3362524854d06de4", "patch": "@@ -207,3 +207,30 @@ pure fn is_upper(c: char) -> bool {\n     ret icu::libicu::u_isupper(c) == icu::TRUE;\n }\n \n+#[cfg(test)]\n+mod tests {\n+\n+    #[test]\n+    fn test_is_digit() {\n+        assert (unicode::icu::is_digit('0'));\n+        assert (!unicode::icu::is_digit('m'));\n+    }\n+\n+    #[test]\n+    fn test_is_lower() {\n+        assert (unicode::icu::is_lower('m'));\n+        assert (!unicode::icu::is_lower('M'));\n+    }\n+\n+    #[test]\n+    fn test_is_space() {\n+        assert (unicode::icu::is_space(' '));\n+        assert (!unicode::icu::is_space('m'));\n+    }\n+\n+    #[test]\n+    fn test_is_upper() {\n+        assert (unicode::icu::is_upper('M'));\n+        assert (!unicode::icu::is_upper('m'));\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "c7f6baf14a216648766cd6352686bad1fd7c922d", "filename": "src/libstd/uv.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e27b27cf8a9ece270f2556c3362524854d06de4/src%2Flibstd%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv.rs?ref=6e27b27cf8a9ece270f2556c3362524854d06de4", "patch": "@@ -153,3 +153,47 @@ fn idle_new() -> idle_t {\n         fields: handle_fields_new()\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+\n+    #[test]\n+    fn test_sanity_check() {\n+        sanity_check();\n+    }\n+\n+    // From test-ref.c\n+    mod test_ref {\n+\n+        #[test]\n+        fn ref() {\n+            let loop = loop_new();\n+            run(loop);\n+            loop_delete(loop);\n+        }\n+\n+        #[test]\n+        fn idle_ref() {\n+            let loop = loop_new();\n+            let h = idle_new();\n+            idle_init(loop, ptr::addr_of(h));\n+            idle_start(ptr::addr_of(h), ptr::null());\n+            unref(loop);\n+            run(loop);\n+            loop_delete(loop);\n+        }\n+\n+        #[test]\n+        fn async_ref() {\n+            /*\n+            let loop = loop_new();\n+            let h = async_new();\n+            async_init(loop, ptr::addr_of(h), ptr::null());\n+            unref(loop);\n+            run(loop);\n+            loop_delete(loop);\n+            */\n+        }\n+    }\n+}\n+"}, {"sha": "ffd3ec232faca7549810cbef7bf346de25065800", "filename": "src/test/stdtest/bitv.rs", "status": "removed", "additions": 0, "deletions": 287, "changes": 287, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fbitv.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -1,287 +0,0 @@\n-import core::*;\n-\n-use std;\n-import vec;\n-import std::bitv;\n-\n-#[test]\n-fn test_0_elements() {\n-    let act;\n-    let exp;\n-    act = bitv::create(0u, false);\n-    exp = vec::init_elt::<uint>(0u, 0u);\n-    assert (bitv::eq_vec(act, exp));\n-}\n-\n-#[test]\n-fn test_1_element() {\n-    let act;\n-    act = bitv::create(1u, false);\n-    assert (bitv::eq_vec(act, [0u]));\n-    act = bitv::create(1u, true);\n-    assert (bitv::eq_vec(act, [1u]));\n-}\n-\n-#[test]\n-fn test_10_elements() {\n-    let act;\n-    // all 0\n-\n-    act = bitv::create(10u, false);\n-    assert (bitv::eq_vec(act, [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n-    // all 1\n-\n-    act = bitv::create(10u, true);\n-    assert (bitv::eq_vec(act, [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u]));\n-    // mixed\n-\n-    act = bitv::create(10u, false);\n-    bitv::set(act, 0u, true);\n-    bitv::set(act, 1u, true);\n-    bitv::set(act, 2u, true);\n-    bitv::set(act, 3u, true);\n-    bitv::set(act, 4u, true);\n-    assert (bitv::eq_vec(act, [1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u]));\n-    // mixed\n-\n-    act = bitv::create(10u, false);\n-    bitv::set(act, 5u, true);\n-    bitv::set(act, 6u, true);\n-    bitv::set(act, 7u, true);\n-    bitv::set(act, 8u, true);\n-    bitv::set(act, 9u, true);\n-    assert (bitv::eq_vec(act, [0u, 0u, 0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u]));\n-    // mixed\n-\n-    act = bitv::create(10u, false);\n-    bitv::set(act, 0u, true);\n-    bitv::set(act, 3u, true);\n-    bitv::set(act, 6u, true);\n-    bitv::set(act, 9u, true);\n-    assert (bitv::eq_vec(act, [1u, 0u, 0u, 1u, 0u, 0u, 1u, 0u, 0u, 1u]));\n-}\n-\n-#[test]\n-fn test_31_elements() {\n-    let act;\n-    // all 0\n-\n-    act = bitv::create(31u, false);\n-    assert (bitv::eq_vec(act,\n-                         [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                          0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                          0u, 0u, 0u, 0u, 0u]));\n-    // all 1\n-\n-    act = bitv::create(31u, true);\n-    assert (bitv::eq_vec(act,\n-                         [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n-                          1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n-                          1u, 1u, 1u, 1u, 1u]));\n-    // mixed\n-\n-    act = bitv::create(31u, false);\n-    bitv::set(act, 0u, true);\n-    bitv::set(act, 1u, true);\n-    bitv::set(act, 2u, true);\n-    bitv::set(act, 3u, true);\n-    bitv::set(act, 4u, true);\n-    bitv::set(act, 5u, true);\n-    bitv::set(act, 6u, true);\n-    bitv::set(act, 7u, true);\n-    assert (bitv::eq_vec(act,\n-                         [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u,\n-                          0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                          0u, 0u, 0u, 0u, 0u]));\n-    // mixed\n-\n-    act = bitv::create(31u, false);\n-    bitv::set(act, 16u, true);\n-    bitv::set(act, 17u, true);\n-    bitv::set(act, 18u, true);\n-    bitv::set(act, 19u, true);\n-    bitv::set(act, 20u, true);\n-    bitv::set(act, 21u, true);\n-    bitv::set(act, 22u, true);\n-    bitv::set(act, 23u, true);\n-    assert (bitv::eq_vec(act,\n-                         [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                          0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u,\n-                          0u, 0u, 0u, 0u, 0u]));\n-    // mixed\n-\n-    act = bitv::create(31u, false);\n-    bitv::set(act, 24u, true);\n-    bitv::set(act, 25u, true);\n-    bitv::set(act, 26u, true);\n-    bitv::set(act, 27u, true);\n-    bitv::set(act, 28u, true);\n-    bitv::set(act, 29u, true);\n-    bitv::set(act, 30u, true);\n-    assert (bitv::eq_vec(act,\n-                         [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                          0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u,\n-                          1u, 1u, 1u, 1u, 1u]));\n-    // mixed\n-\n-    act = bitv::create(31u, false);\n-    bitv::set(act, 3u, true);\n-    bitv::set(act, 17u, true);\n-    bitv::set(act, 30u, true);\n-    assert (bitv::eq_vec(act,\n-                         [0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                          0u, 0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                          0u, 0u, 0u, 0u, 1u]));\n-}\n-\n-#[test]\n-fn test_32_elements() {\n-    let act;\n-    // all 0\n-\n-    act = bitv::create(32u, false);\n-    assert (bitv::eq_vec(act,\n-                         [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                          0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                          0u, 0u, 0u, 0u, 0u, 0u]));\n-    // all 1\n-\n-    act = bitv::create(32u, true);\n-    assert (bitv::eq_vec(act,\n-                         [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n-                          1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n-                          1u, 1u, 1u, 1u, 1u, 1u]));\n-    // mixed\n-\n-    act = bitv::create(32u, false);\n-    bitv::set(act, 0u, true);\n-    bitv::set(act, 1u, true);\n-    bitv::set(act, 2u, true);\n-    bitv::set(act, 3u, true);\n-    bitv::set(act, 4u, true);\n-    bitv::set(act, 5u, true);\n-    bitv::set(act, 6u, true);\n-    bitv::set(act, 7u, true);\n-    assert (bitv::eq_vec(act,\n-                         [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u,\n-                          0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                          0u, 0u, 0u, 0u, 0u, 0u]));\n-    // mixed\n-\n-    act = bitv::create(32u, false);\n-    bitv::set(act, 16u, true);\n-    bitv::set(act, 17u, true);\n-    bitv::set(act, 18u, true);\n-    bitv::set(act, 19u, true);\n-    bitv::set(act, 20u, true);\n-    bitv::set(act, 21u, true);\n-    bitv::set(act, 22u, true);\n-    bitv::set(act, 23u, true);\n-    assert (bitv::eq_vec(act,\n-                         [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                          0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u,\n-                          0u, 0u, 0u, 0u, 0u, 0u]));\n-    // mixed\n-\n-    act = bitv::create(32u, false);\n-    bitv::set(act, 24u, true);\n-    bitv::set(act, 25u, true);\n-    bitv::set(act, 26u, true);\n-    bitv::set(act, 27u, true);\n-    bitv::set(act, 28u, true);\n-    bitv::set(act, 29u, true);\n-    bitv::set(act, 30u, true);\n-    bitv::set(act, 31u, true);\n-    assert (bitv::eq_vec(act,\n-                         [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                          0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u,\n-                          1u, 1u, 1u, 1u, 1u, 1u]));\n-    // mixed\n-\n-    act = bitv::create(32u, false);\n-    bitv::set(act, 3u, true);\n-    bitv::set(act, 17u, true);\n-    bitv::set(act, 30u, true);\n-    bitv::set(act, 31u, true);\n-    assert (bitv::eq_vec(act,\n-                         [0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                          0u, 0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                          0u, 0u, 0u, 0u, 1u, 1u]));\n-}\n-\n-#[test]\n-fn test_33_elements() {\n-    let act;\n-    // all 0\n-\n-    act = bitv::create(33u, false);\n-    assert (bitv::eq_vec(act,\n-                         [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                          0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                          0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n-    // all 1\n-\n-    act = bitv::create(33u, true);\n-    assert (bitv::eq_vec(act,\n-                         [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n-                          1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u,\n-                          1u, 1u, 1u, 1u, 1u, 1u, 1u]));\n-    // mixed\n-\n-    act = bitv::create(33u, false);\n-    bitv::set(act, 0u, true);\n-    bitv::set(act, 1u, true);\n-    bitv::set(act, 2u, true);\n-    bitv::set(act, 3u, true);\n-    bitv::set(act, 4u, true);\n-    bitv::set(act, 5u, true);\n-    bitv::set(act, 6u, true);\n-    bitv::set(act, 7u, true);\n-    assert (bitv::eq_vec(act,\n-                         [1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u, 0u, 0u, 0u,\n-                          0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                          0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n-    // mixed\n-\n-    act = bitv::create(33u, false);\n-    bitv::set(act, 16u, true);\n-    bitv::set(act, 17u, true);\n-    bitv::set(act, 18u, true);\n-    bitv::set(act, 19u, true);\n-    bitv::set(act, 20u, true);\n-    bitv::set(act, 21u, true);\n-    bitv::set(act, 22u, true);\n-    bitv::set(act, 23u, true);\n-    assert (bitv::eq_vec(act,\n-                         [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                          0u, 0u, 0u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 1u, 0u, 0u,\n-                          0u, 0u, 0u, 0u, 0u, 0u, 0u]));\n-    // mixed\n-\n-    act = bitv::create(33u, false);\n-    bitv::set(act, 24u, true);\n-    bitv::set(act, 25u, true);\n-    bitv::set(act, 26u, true);\n-    bitv::set(act, 27u, true);\n-    bitv::set(act, 28u, true);\n-    bitv::set(act, 29u, true);\n-    bitv::set(act, 30u, true);\n-    bitv::set(act, 31u, true);\n-    assert (bitv::eq_vec(act,\n-                         [0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                          0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 1u, 1u,\n-                          1u, 1u, 1u, 1u, 1u, 1u, 0u]));\n-    // mixed\n-\n-    act = bitv::create(33u, false);\n-    bitv::set(act, 3u, true);\n-    bitv::set(act, 17u, true);\n-    bitv::set(act, 30u, true);\n-    bitv::set(act, 31u, true);\n-    bitv::set(act, 32u, true);\n-    assert (bitv::eq_vec(act,\n-                         [0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                          0u, 0u, 0u, 0u, 1u, 0u, 0u, 0u, 0u, 0u, 0u, 0u, 0u,\n-                          0u, 0u, 0u, 0u, 1u, 1u, 1u]));\n-}\n-"}, {"sha": "26a67e03f6349dc7933cc8965359182d048c641e", "filename": "src/test/stdtest/c_vec.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fc_vec.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -1,61 +0,0 @@\n-import core::*;\n-\n-// -*- rust -*-\n-use std;\n-import std::c_vec::*;\n-import ctypes::*;\n-\n-#[nolink]\n-#[abi = \"cdecl\"]\n-native mod libc {\n-    fn malloc(n: size_t) -> *mutable u8;\n-    fn free(m: *mutable u8);\n-}\n-\n-fn malloc(n: size_t) -> t<u8> {\n-    let mem = libc::malloc(n);\n-\n-    assert mem as int != 0;\n-\n-    ret unsafe { create_with_dtor(mem, n, bind libc::free(mem)) };\n-}\n-\n-#[test]\n-fn test_basic() {\n-    let cv = malloc(16u);\n-\n-    set(cv, 3u, 8u8);\n-    set(cv, 4u, 9u8);\n-    assert get(cv, 3u) == 8u8;\n-    assert get(cv, 4u) == 9u8;\n-    assert len(cv) == 16u;\n-}\n-\n-#[test]\n-#[should_fail]\n-#[ignore(cfg(target_os = \"win32\"))]\n-fn test_overrun_get() {\n-    let cv = malloc(16u);\n-\n-    get(cv, 17u);\n-}\n-\n-#[test]\n-#[should_fail]\n-#[ignore(cfg(target_os = \"win32\"))]\n-fn test_overrun_set() {\n-    let cv = malloc(16u);\n-\n-    set(cv, 17u, 0u8);\n-}\n-\n-#[test]\n-fn test_and_I_mean_it() {\n-    let cv = malloc(16u);\n-    let p = unsafe { ptr(cv) };\n-\n-    set(cv, 0u, 32u8);\n-    set(cv, 1u, 33u8);\n-    assert unsafe { *p } == 32u8;\n-    set(cv, 2u, 34u8); /* safety */\n-}"}, {"sha": "ef763131a414d253947ae1095702131af07d0c70", "filename": "src/test/stdtest/deque.rs", "status": "removed", "additions": 0, "deletions": 197, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fdeque.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -1,197 +0,0 @@\n-import core::*;\n-\n-// -*- rust -*-\n-use std;\n-import std::deque;\n-\n-#[test]\n-fn test_simple() {\n-    let d: deque::t<int> = deque::create::<int>();\n-    assert (d.size() == 0u);\n-    d.add_front(17);\n-    d.add_front(42);\n-    d.add_back(137);\n-    assert (d.size() == 3u);\n-    d.add_back(137);\n-    assert (d.size() == 4u);\n-    log(debug, d.peek_front());\n-    assert (d.peek_front() == 42);\n-    log(debug, d.peek_back());\n-    assert (d.peek_back() == 137);\n-    let i: int = d.pop_front();\n-    log(debug, i);\n-    assert (i == 42);\n-    i = d.pop_back();\n-    log(debug, i);\n-    assert (i == 137);\n-    i = d.pop_back();\n-    log(debug, i);\n-    assert (i == 137);\n-    i = d.pop_back();\n-    log(debug, i);\n-    assert (i == 17);\n-    assert (d.size() == 0u);\n-    d.add_back(3);\n-    assert (d.size() == 1u);\n-    d.add_front(2);\n-    assert (d.size() == 2u);\n-    d.add_back(4);\n-    assert (d.size() == 3u);\n-    d.add_front(1);\n-    assert (d.size() == 4u);\n-    log(debug, d.get(0));\n-    log(debug, d.get(1));\n-    log(debug, d.get(2));\n-    log(debug, d.get(3));\n-    assert (d.get(0) == 1);\n-    assert (d.get(1) == 2);\n-    assert (d.get(2) == 3);\n-    assert (d.get(3) == 4);\n-}\n-\n-fn test_boxes(a: @int, b: @int, c: @int, d: @int) {\n-    let deq: deque::t<@int> = deque::create::<@int>();\n-    assert (deq.size() == 0u);\n-    deq.add_front(a);\n-    deq.add_front(b);\n-    deq.add_back(c);\n-    assert (deq.size() == 3u);\n-    deq.add_back(d);\n-    assert (deq.size() == 4u);\n-    assert (deq.peek_front() == b);\n-    assert (deq.peek_back() == d);\n-    assert (deq.pop_front() == b);\n-    assert (deq.pop_back() == d);\n-    assert (deq.pop_back() == c);\n-    assert (deq.pop_back() == a);\n-    assert (deq.size() == 0u);\n-    deq.add_back(c);\n-    assert (deq.size() == 1u);\n-    deq.add_front(b);\n-    assert (deq.size() == 2u);\n-    deq.add_back(d);\n-    assert (deq.size() == 3u);\n-    deq.add_front(a);\n-    assert (deq.size() == 4u);\n-    assert (deq.get(0) == a);\n-    assert (deq.get(1) == b);\n-    assert (deq.get(2) == c);\n-    assert (deq.get(3) == d);\n-}\n-\n-type eqfn<T> = fn@(T, T) -> bool;\n-\n-fn test_parameterized<T: copy>(e: eqfn<T>, a: T, b: T, c: T, d: T) {\n-    let deq: deque::t<T> = deque::create::<T>();\n-    assert (deq.size() == 0u);\n-    deq.add_front(a);\n-    deq.add_front(b);\n-    deq.add_back(c);\n-    assert (deq.size() == 3u);\n-    deq.add_back(d);\n-    assert (deq.size() == 4u);\n-    assert (e(deq.peek_front(), b));\n-    assert (e(deq.peek_back(), d));\n-    assert (e(deq.pop_front(), b));\n-    assert (e(deq.pop_back(), d));\n-    assert (e(deq.pop_back(), c));\n-    assert (e(deq.pop_back(), a));\n-    assert (deq.size() == 0u);\n-    deq.add_back(c);\n-    assert (deq.size() == 1u);\n-    deq.add_front(b);\n-    assert (deq.size() == 2u);\n-    deq.add_back(d);\n-    assert (deq.size() == 3u);\n-    deq.add_front(a);\n-    assert (deq.size() == 4u);\n-    assert (e(deq.get(0), a));\n-    assert (e(deq.get(1), b));\n-    assert (e(deq.get(2), c));\n-    assert (e(deq.get(3), d));\n-}\n-\n-tag taggy { one(int); two(int, int); three(int, int, int); }\n-\n-tag taggypar<T> { onepar(int); twopar(int, int); threepar(int, int, int); }\n-\n-type reccy = {x: int, y: int, t: taggy};\n-\n-#[test]\n-fn test() {\n-    fn inteq(&&a: int, &&b: int) -> bool { ret a == b; }\n-    fn intboxeq(&&a: @int, &&b: @int) -> bool { ret a == b; }\n-    fn taggyeq(a: taggy, b: taggy) -> bool {\n-        alt a {\n-          one(a1) { alt b { one(b1) { ret a1 == b1; } _ { ret false; } } }\n-          two(a1, a2) {\n-            alt b {\n-              two(b1, b2) { ret a1 == b1 && a2 == b2; }\n-              _ { ret false; }\n-            }\n-          }\n-          three(a1, a2, a3) {\n-            alt b {\n-              three(b1, b2, b3) { ret a1 == b1 && a2 == b2 && a3 == b3; }\n-              _ { ret false; }\n-            }\n-          }\n-        }\n-    }\n-    fn taggypareq<T>(a: taggypar<T>, b: taggypar<T>) -> bool {\n-        alt a {\n-          onepar::<T>(a1) {\n-            alt b { onepar::<T>(b1) { ret a1 == b1; } _ { ret false; } }\n-          }\n-          twopar::<T>(a1, a2) {\n-            alt b {\n-              twopar::<T>(b1, b2) { ret a1 == b1 && a2 == b2; }\n-              _ { ret false; }\n-            }\n-          }\n-          threepar::<T>(a1, a2, a3) {\n-            alt b {\n-              threepar::<T>(b1, b2, b3) {\n-                ret a1 == b1 && a2 == b2 && a3 == b3;\n-              }\n-              _ { ret false; }\n-            }\n-          }\n-        }\n-    }\n-    fn reccyeq(a: reccy, b: reccy) -> bool {\n-        ret a.x == b.x && a.y == b.y && taggyeq(a.t, b.t);\n-    }\n-    #debug(\"*** test boxes\");\n-    test_boxes(@5, @72, @64, @175);\n-    #debug(\"*** end test boxes\");\n-    #debug(\"test parameterized: int\");\n-    let eq1: eqfn<int> = inteq;\n-    test_parameterized::<int>(eq1, 5, 72, 64, 175);\n-    #debug(\"*** test parameterized: @int\");\n-    let eq2: eqfn<@int> = intboxeq;\n-    test_parameterized::<@int>(eq2, @5, @72, @64, @175);\n-    #debug(\"*** end test parameterized @int\");\n-    #debug(\"test parameterized: taggy\");\n-    let eq3: eqfn<taggy> = taggyeq;\n-    test_parameterized::<taggy>(eq3, one(1), two(1, 2), three(1, 2, 3),\n-                                two(17, 42));\n-\n-    #debug(\"*** test parameterized: taggypar<int>\");\n-    let eq4: eqfn<taggypar<int>> = bind taggypareq::<int>(_, _);\n-    test_parameterized::<taggypar<int>>(eq4, onepar::<int>(1),\n-                                        twopar::<int>(1, 2),\n-                                        threepar::<int>(1, 2, 3),\n-                                        twopar::<int>(17, 42));\n-    #debug(\"*** end test parameterized: taggypar::<int>\");\n-\n-    #debug(\"*** test parameterized: reccy\");\n-    let reccy1: reccy = {x: 1, y: 2, t: one(1)};\n-    let reccy2: reccy = {x: 345, y: 2, t: two(1, 2)};\n-    let reccy3: reccy = {x: 1, y: 777, t: three(1, 2, 3)};\n-    let reccy4: reccy = {x: 19, y: 252, t: two(17, 42)};\n-    let eq5: eqfn<reccy> = reccyeq;\n-    test_parameterized::<reccy>(eq5, reccy1, reccy2, reccy3, reccy4);\n-    #debug(\"*** end test parameterized: reccy\");\n-    #debug(\"*** done\");\n-}"}, {"sha": "0810253c9fd48203d42b9c4b5ff9b35286564730", "filename": "src/test/stdtest/four.rs", "status": "removed", "additions": 0, "deletions": 151, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Ffour.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Ffour.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ffour.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -1,151 +0,0 @@\n-import core::*;\n-\n-use std;\n-\n-import std::tri;\n-import std::four;\n-\n-fn eq1(a: four::t, b: four::t) -> bool { four::eq(a , b) }\n-fn ne1(a: four::t, b: four::t) -> bool { four::ne(a , b) }\n-\n-fn eq2(a: four::t, b: four::t) -> bool { eq1( a, b ) && eq1( b, a ) }\n-\n-#[test]\n-fn test_four_req_eq() {\n-    four::all_values { |a|\n-        four::all_values { |b|\n-            assert if a == b { eq1( a, b ) } else { ne1( a, b ) };\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_four_and_symmetry() {\n-    four::all_values { |a|\n-        four::all_values { |b|\n-            assert eq1( four::and(a ,b), four::and(b, a) );\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_four_xor_symmetry() {\n-    four::all_values { |a|\n-        four::all_values { |b|\n-            assert eq1( four::and(a ,b), four::and(b, a) );\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_four_or_symmetry() {\n-    four::all_values { |a|\n-        four::all_values { |b|\n-            assert eq1( four::or(a ,b), four::or(b, a) );\n-        }\n-    }\n-}\n-\n-fn to_tup(v: four::t) -> (bool, bool) {\n-    alt v {\n-      0u8 { (false, false) }\n-      1u8 { (false, true) }\n-      2u8 { (true, false) }\n-      3u8 { (true, true) }\n-    }\n-}\n-\n-#[test]\n-fn test_four_not() {\n-    four::all_values { |a|\n-        let (x, y) = to_tup(a);\n-        assert to_tup(four::not(a)) == (y, x);\n-    };\n-}\n-\n-\n-#[test]\n-fn test_four_and() {\n-    four::all_values { |a|\n-        four::all_values { |b|\n-            let (y1, x1) = to_tup(a);\n-            let (y2, x2) = to_tup(b);\n-            let (y3, x3) = to_tup(four::and(a, b));\n-\n-            assert (x3, y3) == (x1 && x2, y1 || y2);\n-        }\n-    };\n-}\n-\n-#[test]\n-fn test_four_or() {\n-    four::all_values { |a|\n-        four::all_values { |b|\n-            let (y1, x1) = to_tup(a);\n-            let (y2, x2) = to_tup(b);\n-            let (y3, x3) = to_tup(four::or(a, b));\n-\n-            assert (x3, y3) == (x1 || x2, y1 && y2);\n-        }\n-    };\n-}\n-\n-#[test]\n-fn test_four_implies() {\n-    four::all_values { |a|\n-        four::all_values { |b|\n-            let (_, x1) = to_tup(a);\n-            let (y2, x2) = to_tup(b);\n-            let (y3, x3) = to_tup(four::implies(a, b));\n-\n-            assert (x3, y3) == (!x1 || x2, x1 && y2);\n-        }\n-    };\n-}\n-\n-#[test]\n-fn test_four_is_true() {\n-    assert !four::is_true(four::none);\n-    assert !four::is_true(four::false);\n-    assert four::is_true(four::true);\n-    assert four::is_true(four::both);\n-}\n-\n-#[test]\n-fn test_four_is_false() {\n-    assert four::is_false(four::none);\n-    assert four::is_false(four::false);\n-    assert !four::is_false(four::true);\n-    assert !four::is_false(four::both);\n-}\n-\n-#[test]\n-fn test_four_from_str() {\n-    four::all_values { |v|\n-        assert eq1( v, four::from_str(four::to_str(v)) );\n-    }\n-}\n-\n-#[test]\n-fn test_four_to_str() {\n-    assert four::to_str(four::none) == \"none\";\n-    assert four::to_str(four::false) == \"false\";\n-    assert four::to_str(four::true) == \"true\" ;\n-    assert four::to_str(four::both) == \"both\";\n-}\n-\n-#[test]\n-fn test_four_to_tri() {\n-    assert tri::eq( four::to_trit(four::true), tri::true );\n-    assert tri::eq( four::to_trit(four::false), tri::false );\n-    assert tri::eq( four::to_trit(four::none), tri::unknown );\n-    log(debug, four::to_trit(four::both));\n-    assert tri::eq( four::to_trit(four::both), tri::unknown );\n-}\n-\n-#[test]\n-fn test_four_to_bit() {\n-    four::all_values { |v|\n-        assert four::to_bit(v) == if four::is_true(v) { 1u8 } else { 0u8 };\n-    }\n-}\n\\ No newline at end of file"}, {"sha": "f0aacf7fe739f7c9f4f553022f65dca6a94aea5e", "filename": "src/test/stdtest/fs.rs", "status": "removed", "additions": 0, "deletions": 275, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ffs.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -1,275 +0,0 @@\n-import core::*;\n-\n-use std;\n-import std::fs;\n-import vec;\n-\n-#[test]\n-fn test_connect() {\n-    let slash = fs::path_sep();\n-    log(error, fs::connect(\"a\", \"b\"));\n-    assert (fs::connect(\"a\", \"b\") == \"a\" + slash + \"b\");\n-    assert (fs::connect(\"a\" + slash, \"b\") == \"a\" + slash + \"b\");\n-}\n-\n-// Issue #712\n-#[test]\n-fn test_list_dir_no_invalid_memory_access() { fs::list_dir(\".\"); }\n-\n-#[test]\n-fn list_dir() {\n-    let dirs = fs::list_dir(\".\");\n-    // Just assuming that we've got some contents in the current directory\n-    assert (vec::len(dirs) > 0u);\n-\n-    for dir in dirs { log(debug, dir); }\n-}\n-\n-#[test]\n-fn path_is_dir() {\n-    assert (fs::path_is_dir(\".\"));\n-    assert (!fs::path_is_dir(\"test/stdtest/fs.rs\"));\n-}\n-\n-#[test]\n-fn path_exists() {\n-    assert (fs::path_exists(\".\"));\n-    assert (!fs::path_exists(\"test/nonexistent-bogus-path\"));\n-}\n-\n-fn ps() -> str {\n-    fs::path_sep()\n-}\n-\n-fn aps() -> str {\n-    \"/\"\n-}\n-\n-#[test]\n-fn split1() {\n-    let actual = fs::split(\"a\" + ps() + \"b\");\n-    let expected = [\"a\", \"b\"];\n-    assert actual == expected;\n-}\n-\n-#[test]\n-fn split2() {\n-    let actual = fs::split(\"a\" + aps() + \"b\");\n-    let expected = [\"a\", \"b\"];\n-    assert actual == expected;\n-}\n-\n-#[test]\n-fn split3() {\n-    let actual = fs::split(ps() + \"a\" + ps() + \"b\");\n-    let expected = [\"a\", \"b\"];\n-    assert actual == expected;\n-}\n-\n-#[test]\n-fn split4() {\n-    let actual = fs::split(\"a\" + ps() + \"b\" + aps() + \"c\");\n-    let expected = [\"a\", \"b\", \"c\"];\n-    assert actual == expected;\n-}\n-\n-#[test]\n-fn normalize1() {\n-    let actual = fs::normalize(\"a/b/..\");\n-    let expected = \"a\";\n-    assert actual == expected;\n-}\n-\n-#[test]\n-fn normalize2() {\n-    let actual = fs::normalize(\"/a/b/..\");\n-    let expected = \"/a\";\n-    assert actual == expected;\n-}\n-\n-#[test]\n-fn normalize3() {\n-    let actual = fs::normalize(\"a/../b\");\n-    let expected = \"b\";\n-    assert actual == expected;\n-}\n-\n-#[test]\n-fn normalize4() {\n-    let actual = fs::normalize(\"/a/../b\");\n-    let expected = \"/b\";\n-    assert actual == expected;\n-}\n-\n-#[test]\n-fn normalize5() {\n-    let actual = fs::normalize(\"a/.\");\n-    let expected = \"a\";\n-    assert actual == expected;\n-}\n-\n-#[test]\n-fn normalize6() {\n-    let actual = fs::normalize(\"a/./b/\");\n-    let expected = \"a/b/\";\n-    assert actual == expected;\n-}\n-\n-#[test]\n-fn normalize7() {\n-    let actual = fs::normalize(\"a/..\");\n-    let expected = \".\";\n-    assert actual == expected;\n-}\n-\n-#[test]\n-fn normalize8() {\n-    let actual = fs::normalize(\"../../..\");\n-    let expected = \"../../..\";\n-    assert actual == expected;\n-}\n-\n-#[test]\n-fn normalize9() {\n-    let actual = fs::normalize(\"a/b/../../..\");\n-    let expected = \"..\";\n-    assert actual == expected;\n-}\n-\n-#[test]\n-fn normalize10() {\n-    let actual = fs::normalize(\"/a/b/c/../d/./../../e/\");\n-    let expected = \"/a/e/\";\n-    log(error, actual);\n-    assert actual == expected;\n-}\n-\n-#[test]\n-fn normalize11() {\n-    let actual = fs::normalize(\"/a/..\");\n-    let expected = \"/\";\n-    assert actual == expected;\n-}\n-\n-#[test]\n-#[cfg(target_os = \"win32\")]\n-fn normalize12() {\n-   let actual = fs::normalize(\"C:/whatever\");\n-   let expected = \"C:/whatever\";\n-   log(error, actual);\n-   assert actual == expected;\n-}\n-\n-#[test]\n-#[cfg(target_os = \"win32\")]\n-fn path_is_absolute_win32() {\n-   assert fs::path_is_absolute(\"C:/whatever\");\n-}\n-\n-#[test]\n-fn splitext_empty() {\n-    let (base, ext) = fs::splitext(\"\");\n-    assert base == \"\";\n-    assert ext == \"\";\n-}\n-\n-#[test]\n-fn splitext_ext() {\n-    let (base, ext) = fs::splitext(\"grum.exe\");\n-    assert base == \"grum\";\n-    assert ext == \".exe\";\n-}\n-\n-#[test]\n-fn splitext_noext() {\n-    let (base, ext) = fs::splitext(\"grum\");\n-    assert base == \"grum\";\n-    assert ext == \"\";\n-}\n-\n-#[test]\n-fn splitext_dotfile() {\n-    let (base, ext) = fs::splitext(\".grum\");\n-    assert base == \".grum\";\n-    assert ext == \"\";\n-}\n-\n-#[test]\n-fn splitext_path_ext() {\n-    let (base, ext) = fs::splitext(\"oh/grum.exe\");\n-    assert base == \"oh/grum\";\n-    assert ext == \".exe\";\n-}\n-\n-#[test]\n-fn splitext_path_noext() {\n-    let (base, ext) = fs::splitext(\"oh/grum\");\n-    assert base == \"oh/grum\";\n-    assert ext == \"\";\n-}\n-\n-#[test]\n-fn splitext_dot_in_path() {\n-    let (base, ext) = fs::splitext(\"oh.my/grum\");\n-    assert base == \"oh.my/grum\";\n-    assert ext == \"\";\n-}\n-\n-#[test]\n-fn splitext_nobasename() {\n-    let (base, ext) = fs::splitext(\"oh.my/\");\n-    assert base == \"oh.my/\";\n-    assert ext == \"\";\n-}\n-\n-#[test]\n-#[cfg(target_os = \"linux\")]\n-#[cfg(target_os = \"macos\")]\n-#[cfg(target_os = \"freebsd\")]\n-fn homedir() {\n-    import getenv = std::generic_os::getenv;\n-    import setenv = std::generic_os::setenv;\n-\n-    let oldhome = getenv(\"HOME\");\n-\n-    setenv(\"HOME\", \"/home/MountainView\");\n-    assert fs::homedir() == some(\"/home/MountainView\");\n-\n-    setenv(\"HOME\", \"\");\n-    assert fs::homedir() == none;\n-\n-    option::may(oldhome, {|s| setenv(\"HOME\", s)});\n-}\n-\n-#[test]\n-#[cfg(target_os = \"win32\")]\n-fn homedir() {\n-    import getenv = std::generic_os::getenv;\n-    import setenv = std::generic_os::setenv;\n-\n-    let oldhome = getenv(\"HOME\");\n-    let olduserprofile = getenv(\"USERPROFILE\");\n-\n-    setenv(\"HOME\", \"\");\n-    setenv(\"USERPROFILE\", \"\");\n-\n-    assert fs::homedir() == none;\n-\n-    setenv(\"HOME\", \"/home/MountainView\");\n-    assert fs::homedir() == some(\"/home/MountainView\");\n-\n-    setenv(\"HOME\", \"\");\n-\n-    setenv(\"USERPROFILE\", \"/home/MountainView\");\n-    assert fs::homedir() == some(\"/home/MountainView\");\n-\n-    setenv(\"USERPROFILE\", \"/home/MountainView\");\n-    assert fs::homedir() == some(\"/home/MountainView\");\n-\n-    setenv(\"HOME\", \"/home/MountainView\");\n-    setenv(\"USERPROFILE\", \"/home/PaloAlto\");\n-    assert fs::homedir() == some(\"/home/MountainView\");\n-\n-    option::may(oldhome, {|s| setenv(\"HOME\", s)});\n-    option::may(olduserprofile, {|s| setenv(\"USERPROFILE\", s)});\n-}"}, {"sha": "52b68f888c48c3ac6ab601464d44bb8f547be786", "filename": "src/test/stdtest/getopts.rs", "status": "removed", "additions": 0, "deletions": 471, "changes": 471, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fgetopts.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -1,471 +0,0 @@\n-import core::*;\n-\n-use std;\n-import opt = std::getopts;\n-import result::{err, ok};\n-\n-tag fail_type {\n-    argument_missing;\n-    unrecognized_option;\n-    option_missing;\n-    option_duplicated;\n-    unexpected_argument;\n-}\n-\n-fn check_fail_type(f: opt::fail_, ft: fail_type) {\n-    alt f {\n-      opt::argument_missing(_) { assert (ft == argument_missing); }\n-      opt::unrecognized_option(_) { assert (ft == unrecognized_option); }\n-      opt::option_missing(_) { assert (ft == option_missing); }\n-      opt::option_duplicated(_) { assert (ft == option_duplicated); }\n-      opt::unexpected_argument(_) { assert (ft == unexpected_argument); }\n-      _ { fail; }\n-    }\n-}\n-\n-\n-// Tests for reqopt\n-#[test]\n-fn test_reqopt_long() {\n-    let args = [\"--test=20\"];\n-    let opts = [opt::reqopt(\"test\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      ok(m) {\n-        assert (opt::opt_present(m, \"test\"));\n-        assert (opt::opt_str(m, \"test\") == \"20\");\n-      }\n-      _ { fail; }\n-    }\n-}\n-\n-#[test]\n-fn test_reqopt_long_missing() {\n-    let args = [\"blah\"];\n-    let opts = [opt::reqopt(\"test\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      err(f) { check_fail_type(f, option_missing); }\n-      _ { fail; }\n-    }\n-}\n-\n-#[test]\n-fn test_reqopt_long_no_arg() {\n-    let args = [\"--test\"];\n-    let opts = [opt::reqopt(\"test\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      err(f) { check_fail_type(f, argument_missing); }\n-      _ { fail; }\n-    }\n-}\n-\n-#[test]\n-fn test_reqopt_long_multi() {\n-    let args = [\"--test=20\", \"--test=30\"];\n-    let opts = [opt::reqopt(\"test\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      err(f) { check_fail_type(f, option_duplicated); }\n-      _ { fail; }\n-    }\n-}\n-\n-#[test]\n-fn test_reqopt_short() {\n-    let args = [\"-t\", \"20\"];\n-    let opts = [opt::reqopt(\"t\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      ok(m) {\n-        assert (opt::opt_present(m, \"t\"));\n-        assert (opt::opt_str(m, \"t\") == \"20\");\n-      }\n-      _ { fail; }\n-    }\n-}\n-\n-#[test]\n-fn test_reqopt_short_missing() {\n-    let args = [\"blah\"];\n-    let opts = [opt::reqopt(\"t\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      err(f) { check_fail_type(f, option_missing); }\n-      _ { fail; }\n-    }\n-}\n-\n-#[test]\n-fn test_reqopt_short_no_arg() {\n-    let args = [\"-t\"];\n-    let opts = [opt::reqopt(\"t\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      err(f) { check_fail_type(f, argument_missing); }\n-      _ { fail; }\n-    }\n-}\n-\n-#[test]\n-fn test_reqopt_short_multi() {\n-    let args = [\"-t\", \"20\", \"-t\", \"30\"];\n-    let opts = [opt::reqopt(\"t\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      err(f) { check_fail_type(f, option_duplicated); }\n-      _ { fail; }\n-    }\n-}\n-\n-\n-// Tests for optopt\n-#[test]\n-fn test_optopt_long() {\n-    let args = [\"--test=20\"];\n-    let opts = [opt::optopt(\"test\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      ok(m) {\n-        assert (opt::opt_present(m, \"test\"));\n-        assert (opt::opt_str(m, \"test\") == \"20\");\n-      }\n-      _ { fail; }\n-    }\n-}\n-\n-#[test]\n-fn test_optopt_long_missing() {\n-    let args = [\"blah\"];\n-    let opts = [opt::optopt(\"test\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      ok(m) { assert (!opt::opt_present(m, \"test\")); }\n-      _ { fail; }\n-    }\n-}\n-\n-#[test]\n-fn test_optopt_long_no_arg() {\n-    let args = [\"--test\"];\n-    let opts = [opt::optopt(\"test\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      err(f) { check_fail_type(f, argument_missing); }\n-      _ { fail; }\n-    }\n-}\n-\n-#[test]\n-fn test_optopt_long_multi() {\n-    let args = [\"--test=20\", \"--test=30\"];\n-    let opts = [opt::optopt(\"test\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      err(f) { check_fail_type(f, option_duplicated); }\n-      _ { fail; }\n-    }\n-}\n-\n-#[test]\n-fn test_optopt_short() {\n-    let args = [\"-t\", \"20\"];\n-    let opts = [opt::optopt(\"t\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      ok(m) {\n-        assert (opt::opt_present(m, \"t\"));\n-        assert (opt::opt_str(m, \"t\") == \"20\");\n-      }\n-      _ { fail; }\n-    }\n-}\n-\n-#[test]\n-fn test_optopt_short_missing() {\n-    let args = [\"blah\"];\n-    let opts = [opt::optopt(\"t\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      ok(m) { assert (!opt::opt_present(m, \"t\")); }\n-      _ { fail; }\n-    }\n-}\n-\n-#[test]\n-fn test_optopt_short_no_arg() {\n-    let args = [\"-t\"];\n-    let opts = [opt::optopt(\"t\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      err(f) { check_fail_type(f, argument_missing); }\n-      _ { fail; }\n-    }\n-}\n-\n-#[test]\n-fn test_optopt_short_multi() {\n-    let args = [\"-t\", \"20\", \"-t\", \"30\"];\n-    let opts = [opt::optopt(\"t\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      err(f) { check_fail_type(f, option_duplicated); }\n-      _ { fail; }\n-    }\n-}\n-\n-\n-// Tests for optflag\n-#[test]\n-fn test_optflag_long() {\n-    let args = [\"--test\"];\n-    let opts = [opt::optflag(\"test\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      ok(m) { assert (opt::opt_present(m, \"test\")); }\n-      _ { fail; }\n-    }\n-}\n-\n-#[test]\n-fn test_optflag_long_missing() {\n-    let args = [\"blah\"];\n-    let opts = [opt::optflag(\"test\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      ok(m) { assert (!opt::opt_present(m, \"test\")); }\n-      _ { fail; }\n-    }\n-}\n-\n-#[test]\n-fn test_optflag_long_arg() {\n-    let args = [\"--test=20\"];\n-    let opts = [opt::optflag(\"test\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      err(f) {\n-        log(error, opt::fail_str(f));\n-        check_fail_type(f, unexpected_argument);\n-      }\n-      _ { fail; }\n-    }\n-}\n-\n-#[test]\n-fn test_optflag_long_multi() {\n-    let args = [\"--test\", \"--test\"];\n-    let opts = [opt::optflag(\"test\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      err(f) { check_fail_type(f, option_duplicated); }\n-      _ { fail; }\n-    }\n-}\n-\n-#[test]\n-fn test_optflag_short() {\n-    let args = [\"-t\"];\n-    let opts = [opt::optflag(\"t\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      ok(m) { assert (opt::opt_present(m, \"t\")); }\n-      _ { fail; }\n-    }\n-}\n-\n-#[test]\n-fn test_optflag_short_missing() {\n-    let args = [\"blah\"];\n-    let opts = [opt::optflag(\"t\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      ok(m) { assert (!opt::opt_present(m, \"t\")); }\n-      _ { fail; }\n-    }\n-}\n-\n-#[test]\n-fn test_optflag_short_arg() {\n-    let args = [\"-t\", \"20\"];\n-    let opts = [opt::optflag(\"t\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      ok(m) {\n-        // The next variable after the flag is just a free argument\n-\n-        assert (m.free[0] == \"20\");\n-      }\n-      _ { fail; }\n-    }\n-}\n-\n-#[test]\n-fn test_optflag_short_multi() {\n-    let args = [\"-t\", \"-t\"];\n-    let opts = [opt::optflag(\"t\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      err(f) { check_fail_type(f, option_duplicated); }\n-      _ { fail; }\n-    }\n-}\n-\n-\n-// Tests for optmulti\n-#[test]\n-fn test_optmulti_long() {\n-    let args = [\"--test=20\"];\n-    let opts = [opt::optmulti(\"test\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      ok(m) {\n-        assert (opt::opt_present(m, \"test\"));\n-        assert (opt::opt_str(m, \"test\") == \"20\");\n-      }\n-      _ { fail; }\n-    }\n-}\n-\n-#[test]\n-fn test_optmulti_long_missing() {\n-    let args = [\"blah\"];\n-    let opts = [opt::optmulti(\"test\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      ok(m) { assert (!opt::opt_present(m, \"test\")); }\n-      _ { fail; }\n-    }\n-}\n-\n-#[test]\n-fn test_optmulti_long_no_arg() {\n-    let args = [\"--test\"];\n-    let opts = [opt::optmulti(\"test\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      err(f) { check_fail_type(f, argument_missing); }\n-      _ { fail; }\n-    }\n-}\n-\n-#[test]\n-fn test_optmulti_long_multi() {\n-    let args = [\"--test=20\", \"--test=30\"];\n-    let opts = [opt::optmulti(\"test\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      ok(m) {\n-        assert (opt::opt_present(m, \"test\"));\n-        assert (opt::opt_str(m, \"test\") == \"20\");\n-        assert (opt::opt_strs(m, \"test\")[0] == \"20\");\n-        assert (opt::opt_strs(m, \"test\")[1] == \"30\");\n-      }\n-      _ { fail; }\n-    }\n-}\n-\n-#[test]\n-fn test_optmulti_short() {\n-    let args = [\"-t\", \"20\"];\n-    let opts = [opt::optmulti(\"t\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      ok(m) {\n-        assert (opt::opt_present(m, \"t\"));\n-        assert (opt::opt_str(m, \"t\") == \"20\");\n-      }\n-      _ { fail; }\n-    }\n-}\n-\n-#[test]\n-fn test_optmulti_short_missing() {\n-    let args = [\"blah\"];\n-    let opts = [opt::optmulti(\"t\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      ok(m) { assert (!opt::opt_present(m, \"t\")); }\n-      _ { fail; }\n-    }\n-}\n-\n-#[test]\n-fn test_optmulti_short_no_arg() {\n-    let args = [\"-t\"];\n-    let opts = [opt::optmulti(\"t\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      err(f) { check_fail_type(f, argument_missing); }\n-      _ { fail; }\n-    }\n-}\n-\n-#[test]\n-fn test_optmulti_short_multi() {\n-    let args = [\"-t\", \"20\", \"-t\", \"30\"];\n-    let opts = [opt::optmulti(\"t\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      ok(m) {\n-        assert (opt::opt_present(m, \"t\"));\n-        assert (opt::opt_str(m, \"t\") == \"20\");\n-        assert (opt::opt_strs(m, \"t\")[0] == \"20\");\n-        assert (opt::opt_strs(m, \"t\")[1] == \"30\");\n-      }\n-      _ { fail; }\n-    }\n-}\n-\n-#[test]\n-fn test_unrecognized_option_long() {\n-    let args = [\"--untest\"];\n-    let opts = [opt::optmulti(\"t\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      err(f) { check_fail_type(f, unrecognized_option); }\n-      _ { fail; }\n-    }\n-}\n-\n-#[test]\n-fn test_unrecognized_option_short() {\n-    let args = [\"-t\"];\n-    let opts = [opt::optmulti(\"test\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      err(f) { check_fail_type(f, unrecognized_option); }\n-      _ { fail; }\n-    }\n-}\n-\n-#[test]\n-fn test_combined() {\n-    let args =\n-        [\"prog\", \"free1\", \"-s\", \"20\", \"free2\", \"--flag\", \"--long=30\", \"-f\",\n-         \"-m\", \"40\", \"-m\", \"50\", \"-n\", \"-A B\", \"-n\", \"-60 70\"];\n-    let opts =\n-        [opt::optopt(\"s\"), opt::optflag(\"flag\"), opt::reqopt(\"long\"),\n-         opt::optflag(\"f\"), opt::optmulti(\"m\"), opt::optmulti(\"n\"),\n-         opt::optopt(\"notpresent\")];\n-    let rs = opt::getopts(args, opts);\n-    alt rs {\n-      ok(m) {\n-        assert (m.free[0] == \"prog\");\n-        assert (m.free[1] == \"free1\");\n-        assert (opt::opt_str(m, \"s\") == \"20\");\n-        assert (m.free[2] == \"free2\");\n-        assert (opt::opt_present(m, \"flag\"));\n-        assert (opt::opt_str(m, \"long\") == \"30\");\n-        assert (opt::opt_present(m, \"f\"));\n-        assert (opt::opt_strs(m, \"m\")[0] == \"40\");\n-        assert (opt::opt_strs(m, \"m\")[1] == \"50\");\n-        assert (opt::opt_strs(m, \"n\")[0] == \"-A B\");\n-        assert (opt::opt_strs(m, \"n\")[1] == \"-60 70\");\n-        assert (!opt::opt_present(m, \"notpresent\"));\n-      }\n-      _ { fail; }\n-    }\n-}\n-"}, {"sha": "817beee22b3a846cc0ffae01ed9b5d03bcca977f", "filename": "src/test/stdtest/io.rs", "status": "removed", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fio.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -1,103 +0,0 @@\n-import core::*;\n-\n-// -*- rust -*-\n-use std;\n-import std::io;\n-import io::{writer_util, reader_util};\n-import str;\n-import result;\n-\n-#[test]\n-fn test_simple() {\n-    let tmpfile: str = \"tmp/lib-io-test-simple.tmp\";\n-    log(debug, tmpfile);\n-    let frood: str = \"A hoopy frood who really knows where his towel is.\";\n-    log(debug, frood);\n-    {\n-        let out: io::writer =\n-            result::get(io::file_writer(tmpfile, [io::create, io::truncate]));\n-        out.write_str(frood);\n-    }\n-    let inp: io::reader = result::get(io::file_reader(tmpfile));\n-    let frood2: str = inp.read_c_str();\n-    log(debug, frood2);\n-    assert (str::eq(frood, frood2));\n-}\n-\n-#[test]\n-fn test_readchars_empty() {\n-    let inp : io::reader = io::string_reader(\"\");\n-    let res : [char] = inp.read_chars(128u);\n-    assert(vec::len(res) == 0u);\n-}\n-\n-#[test]\n-fn test_readchars_wide() {\n-    let wide_test = \"\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64hello\u751f\u9508\u7684\u6c64\u5319\u5207\u8089\u6c64\";\n-    let ivals : [int] = [\n-        29983, 38152, 30340, 27748,\n-        21273, 20999, 32905, 27748,\n-        104, 101, 108, 108, 111,\n-        29983, 38152, 30340, 27748,\n-        21273, 20999, 32905, 27748];\n-    fn check_read_ln(len : uint, s: str, ivals: [int]) {\n-        let inp : io::reader = io::string_reader(s);\n-        let res : [char] = inp.read_chars(len);\n-        if (len <= vec::len(ivals)) {\n-            assert(vec::len(res) == len);\n-        }\n-        assert(vec::slice(ivals, 0u, vec::len(res)) ==\n-               vec::map(res, {|x| x as int}));\n-    }\n-    let i = 0u;\n-    while i < 8u {\n-        check_read_ln(i, wide_test, ivals);\n-        i += 1u;\n-    }\n-    // check a long read for good measure\n-    check_read_ln(128u, wide_test, ivals);\n-}\n-\n-#[test]\n-fn test_readchar() {\n-    let inp : io::reader = io::string_reader(\"\u751f\");\n-    let res : char = inp.read_char();\n-    assert(res as int == 29983);\n-}\n-\n-#[test]\n-fn test_readchar_empty() {\n-    let inp : io::reader = io::string_reader(\"\");\n-    let res : char = inp.read_char();\n-    assert(res as int == -1);\n-}\n-\n-#[test]\n-fn file_reader_not_exist() {\n-    alt io::file_reader(\"not a file\") {\n-      result::err(e) {\n-        assert e == \"error opening not a file\";\n-      }\n-      result::ok(_) { fail; }\n-    }\n-}\n-\n-#[test]\n-fn file_writer_bad_name() {\n-    alt io::file_writer(\"?/?\", []) {\n-      result::err(e) {\n-        assert e == \"error opening ?/?\";\n-      }\n-      result::ok(_) { fail; }\n-    }\n-}\n-\n-#[test]\n-fn buffered_file_writer_bad_name() {\n-    alt io::buffered_file_writer(\"?/?\") {\n-      result::err(e) {\n-        assert e == \"error opening ?/?\";\n-      }\n-      result::ok(_) { fail; }\n-    }\n-}"}, {"sha": "41031b2e16a4c2a42a09d9d72add533abadae0c0", "filename": "src/test/stdtest/json.rs", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fjson.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -1,58 +0,0 @@\n-import core::*;\n-\n-use std;\n-import option;\n-import std::json::*;\n-import option::{none, some};\n-\n-#[test]\n-fn test_from_str_null() {\n-    assert(from_str(\"null\") == some(null));\n-}\n-\n-#[test]\n-fn test_from_str_num() {\n-    assert(from_str(\"3\") == some(num(3f)));\n-    assert(from_str(\"3.1\") == some(num(3.1f)));\n-    assert(from_str(\"-1.2\") == some(num(-1.2f)));\n-    assert(from_str(\".4\") == some(num(0.4f)));\n-}\n-\n-#[test]\n-fn test_from_str_str() {\n-    assert(from_str(\"\\\"foo\\\"\") == some(string(\"foo\")));\n-    assert(from_str(\"\\\"\\\\\\\"\\\"\") == some(string(\"\\\"\")));\n-    assert(from_str(\"\\\"lol\") == none);\n-}\n-\n-#[test]\n-fn test_from_str_bool() {\n-    assert(from_str(\"true\") == some(boolean(true)));\n-    assert(from_str(\"false\") == some(boolean(false)));\n-    assert(from_str(\"truz\") == none);\n-}\n-\n-#[test]\n-fn test_from_str_list() {\n-    assert(from_str(\"[]\") == some(list(@[])));\n-    assert(from_str(\"[true]\") == some(list(@[boolean(true)])));\n-    assert(from_str(\"[null]\") == some(list(@[null])));\n-    assert(from_str(\"[3, 1]\") == some(list(@[num(3f), num(1f)])));\n-    assert(from_str(\"[2, [4, 1]]\") ==\n-        some(list(@[num(2f), list(@[num(4f), num(1f)])])));\n-    assert(from_str(\"[2, ]\") == none);\n-    assert(from_str(\"[5, \") == none);\n-    assert(from_str(\"[6 7]\") == none);\n-    assert(from_str(\"[3\") == none);\n-}\n-\n-#[test]\n-fn test_from_str_dict() {\n-    assert(from_str(\"{}\") != none);\n-    assert(from_str(\"{\\\"a\\\": 3}\") != none);\n-    assert(from_str(\"{\\\"a\\\": null}\") != none);\n-    assert(from_str(\"{\\\"a\\\": }\") == none);\n-    assert(from_str(\"{\\\"a\\\" }\") == none);\n-    assert(from_str(\"{\\\"a\\\"\") == none);\n-    assert(from_str(\"{\") == none);\n-}"}, {"sha": "b96bc9cd16a56b9ae856a00995d3fc1c17d66b18", "filename": "src/test/stdtest/list.rs", "status": "removed", "additions": 0, "deletions": 114, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Flist.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -1,114 +0,0 @@\n-import core::*;\n-\n-use std;\n-import std::list;\n-import std::list::{from_vec, head, is_empty, is_not_empty, tail};\n-import option;\n-\n-#[test]\n-fn test_is_empty() {\n-    let empty : list::list<int> = from_vec([]);\n-    let full1 = from_vec([1]);\n-    let full2 = from_vec(['r', 'u']);\n-\n-    assert is_empty(empty);\n-    assert !is_empty(full1);\n-    assert !is_empty(full2);\n-\n-    assert !is_not_empty(empty);\n-    assert is_not_empty(full1);\n-    assert is_not_empty(full2);\n-}\n-\n-#[test]\n-fn test_from_vec() {\n-    let l = from_vec([0, 1, 2]);\n-\n-    check is_not_empty(l);\n-    assert (head(l) == 0);\n-\n-    let tail_l = tail(l);\n-    check is_not_empty(tail_l);\n-    assert (head(tail_l) == 1);\n-\n-    let tail_tail_l = tail(tail_l);\n-    check is_not_empty(tail_tail_l);\n-    assert (head(tail_tail_l) == 2);\n-}\n-\n-#[test]\n-fn test_from_vec_empty() {\n-    let empty : list::list<int> = from_vec([]);\n-    assert (empty == list::nil::<int>);\n-}\n-\n-#[test]\n-fn test_from_vec_mut() {\n-    let l = from_vec([mutable 0, 1, 2]);\n-\n-    check is_not_empty(l);\n-    assert (head(l) == 0);\n-\n-    let tail_l = tail(l);\n-    check is_not_empty(tail_l);\n-    assert (head(tail_l) == 1);\n-\n-    let tail_tail_l = tail(tail_l);\n-    check is_not_empty(tail_tail_l);\n-    assert (head(tail_tail_l) == 2);\n-}\n-\n-#[test]\n-fn test_foldl() {\n-    fn add(&&a: uint, &&b: int) -> uint { ret a + (b as uint); }\n-    let l = from_vec([0, 1, 2, 3, 4]);\n-    let empty = list::nil::<int>;\n-    assert (list::foldl(l, 0u, add) == 10u);\n-    assert (list::foldl(empty, 0u, add) == 0u);\n-}\n-\n-#[test]\n-fn test_foldl2() {\n-    fn sub(&&a: int, &&b: int) -> int {\n-        a - b\n-    }\n-    let l = from_vec([1, 2, 3, 4]);\n-    assert (list::foldl(l, 0, sub) == -10);\n-}\n-\n-#[test]\n-fn test_find_success() {\n-    fn match(&&i: int) -> option::t<int> {\n-        ret if i == 2 { option::some(i) } else { option::none::<int> };\n-    }\n-    let l = from_vec([0, 1, 2]);\n-    assert (list::find(l, match) == option::some(2));\n-}\n-\n-#[test]\n-fn test_find_fail() {\n-    fn match(&&_i: int) -> option::t<int> { ret option::none::<int>; }\n-    let l = from_vec([0, 1, 2]);\n-    let empty = list::nil::<int>;\n-    assert (list::find(l, match) == option::none::<int>);\n-    assert (list::find(empty, match) == option::none::<int>);\n-}\n-\n-#[test]\n-fn test_has() {\n-    let l = from_vec([5, 8, 6]);\n-    let empty = list::nil::<int>;\n-    assert (list::has(l, 5));\n-    assert (!list::has(l, 7));\n-    assert (list::has(l, 8));\n-    assert (!list::has(empty, 5));\n-}\n-\n-#[test]\n-fn test_len() {\n-    let l = from_vec([0, 1, 2]);\n-    let empty = list::nil::<int>;\n-    assert (list::len(l) == 3u);\n-    assert (list::len(empty) == 0u);\n-}\n-"}, {"sha": "8762c9e6198c10819dc553cc7b25c098e045a123", "filename": "src/test/stdtest/map.rs", "status": "removed", "additions": 0, "deletions": 249, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fmap.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -1,249 +0,0 @@\n-import core::*;\n-\n-// -*- rust -*-\n-use std;\n-import std::map;\n-import str;\n-import uint;\n-import option;\n-\n-\n-#[test]\n-fn test_simple() {\n-    #debug(\"*** starting test_simple\");\n-    fn eq_uint(&&x: uint, &&y: uint) -> bool { ret x == y; }\n-    fn uint_id(&&x: uint) -> uint { x }\n-    let hasher_uint: map::hashfn<uint> = uint_id;\n-    let eqer_uint: map::eqfn<uint> = eq_uint;\n-    let hasher_str: map::hashfn<str> = str::hash;\n-    let eqer_str: map::eqfn<str> = str::eq;\n-    #debug(\"uint -> uint\");\n-    let hm_uu: map::hashmap<uint, uint> =\n-        map::mk_hashmap::<uint, uint>(hasher_uint, eqer_uint);\n-    assert (hm_uu.insert(10u, 12u));\n-    assert (hm_uu.insert(11u, 13u));\n-    assert (hm_uu.insert(12u, 14u));\n-    assert (hm_uu.get(11u) == 13u);\n-    assert (hm_uu.get(12u) == 14u);\n-    assert (hm_uu.get(10u) == 12u);\n-    assert (!hm_uu.insert(12u, 14u));\n-    assert (hm_uu.get(12u) == 14u);\n-    assert (!hm_uu.insert(12u, 12u));\n-    assert (hm_uu.get(12u) == 12u);\n-    let ten: str = \"ten\";\n-    let eleven: str = \"eleven\";\n-    let twelve: str = \"twelve\";\n-    #debug(\"str -> uint\");\n-    let hm_su: map::hashmap<str, uint> =\n-        map::mk_hashmap::<str, uint>(hasher_str, eqer_str);\n-    assert (hm_su.insert(\"ten\", 12u));\n-    assert (hm_su.insert(eleven, 13u));\n-    assert (hm_su.insert(\"twelve\", 14u));\n-    assert (hm_su.get(eleven) == 13u);\n-    assert (hm_su.get(\"eleven\") == 13u);\n-    assert (hm_su.get(\"twelve\") == 14u);\n-    assert (hm_su.get(\"ten\") == 12u);\n-    assert (!hm_su.insert(\"twelve\", 14u));\n-    assert (hm_su.get(\"twelve\") == 14u);\n-    assert (!hm_su.insert(\"twelve\", 12u));\n-    assert (hm_su.get(\"twelve\") == 12u);\n-    #debug(\"uint -> str\");\n-    let hm_us: map::hashmap<uint, str> =\n-        map::mk_hashmap::<uint, str>(hasher_uint, eqer_uint);\n-    assert (hm_us.insert(10u, \"twelve\"));\n-    assert (hm_us.insert(11u, \"thirteen\"));\n-    assert (hm_us.insert(12u, \"fourteen\"));\n-    assert (str::eq(hm_us.get(11u), \"thirteen\"));\n-    assert (str::eq(hm_us.get(12u), \"fourteen\"));\n-    assert (str::eq(hm_us.get(10u), \"twelve\"));\n-    assert (!hm_us.insert(12u, \"fourteen\"));\n-    assert (str::eq(hm_us.get(12u), \"fourteen\"));\n-    assert (!hm_us.insert(12u, \"twelve\"));\n-    assert (str::eq(hm_us.get(12u), \"twelve\"));\n-    #debug(\"str -> str\");\n-    let hm_ss: map::hashmap<str, str> =\n-        map::mk_hashmap::<str, str>(hasher_str, eqer_str);\n-    assert (hm_ss.insert(ten, \"twelve\"));\n-    assert (hm_ss.insert(eleven, \"thirteen\"));\n-    assert (hm_ss.insert(twelve, \"fourteen\"));\n-    assert (str::eq(hm_ss.get(\"eleven\"), \"thirteen\"));\n-    assert (str::eq(hm_ss.get(\"twelve\"), \"fourteen\"));\n-    assert (str::eq(hm_ss.get(\"ten\"), \"twelve\"));\n-    assert (!hm_ss.insert(\"twelve\", \"fourteen\"));\n-    assert (str::eq(hm_ss.get(\"twelve\"), \"fourteen\"));\n-    assert (!hm_ss.insert(\"twelve\", \"twelve\"));\n-    assert (str::eq(hm_ss.get(\"twelve\"), \"twelve\"));\n-    #debug(\"*** finished test_simple\");\n-}\n-\n-\n-/**\n- * Force map growth\n- */\n-#[test]\n-fn test_growth() {\n-    #debug(\"*** starting test_growth\");\n-    let num_to_insert: uint = 64u;\n-    fn eq_uint(&&x: uint, &&y: uint) -> bool { ret x == y; }\n-    fn uint_id(&&x: uint) -> uint { x }\n-    #debug(\"uint -> uint\");\n-    let hasher_uint: map::hashfn<uint> = uint_id;\n-    let eqer_uint: map::eqfn<uint> = eq_uint;\n-    let hm_uu: map::hashmap<uint, uint> =\n-        map::mk_hashmap::<uint, uint>(hasher_uint, eqer_uint);\n-    let i: uint = 0u;\n-    while i < num_to_insert {\n-        assert (hm_uu.insert(i, i * i));\n-        #debug(\"inserting %u -> %u\", i, i*i);\n-        i += 1u;\n-    }\n-    #debug(\"-----\");\n-    i = 0u;\n-    while i < num_to_insert {\n-        #debug(\"get(%u) = %u\", i, hm_uu.get(i));\n-        assert (hm_uu.get(i) == i * i);\n-        i += 1u;\n-    }\n-    assert (hm_uu.insert(num_to_insert, 17u));\n-    assert (hm_uu.get(num_to_insert) == 17u);\n-    #debug(\"-----\");\n-    i = 0u;\n-    while i < num_to_insert {\n-        #debug(\"get(%u) = %u\", i, hm_uu.get(i));\n-        assert (hm_uu.get(i) == i * i);\n-        i += 1u;\n-    }\n-    #debug(\"str -> str\");\n-    let hasher_str: map::hashfn<str> = str::hash;\n-    let eqer_str: map::eqfn<str> = str::eq;\n-    let hm_ss: map::hashmap<str, str> =\n-        map::mk_hashmap::<str, str>(hasher_str, eqer_str);\n-    i = 0u;\n-    while i < num_to_insert {\n-        assert (hm_ss.insert(uint::to_str(i, 2u), uint::to_str(i * i, 2u)));\n-        #debug(\"inserting \\\"%s\\\" -> \\\"%s\\\"\",\n-               uint::to_str(i, 2u),\n-               uint::to_str(i*i, 2u));\n-        i += 1u;\n-    }\n-    #debug(\"-----\");\n-    i = 0u;\n-    while i < num_to_insert {\n-        #debug(\"get(\\\"%s\\\") = \\\"%s\\\"\",\n-               uint::to_str(i, 2u),\n-               hm_ss.get(uint::to_str(i, 2u)));\n-        assert (str::eq(hm_ss.get(uint::to_str(i, 2u)),\n-                        uint::to_str(i * i, 2u)));\n-        i += 1u;\n-    }\n-    assert (hm_ss.insert(uint::to_str(num_to_insert, 2u),\n-                         uint::to_str(17u, 2u)));\n-    assert (str::eq(hm_ss.get(uint::to_str(num_to_insert, 2u)),\n-                    uint::to_str(17u, 2u)));\n-    #debug(\"-----\");\n-    i = 0u;\n-    while i < num_to_insert {\n-        #debug(\"get(\\\"%s\\\") = \\\"%s\\\"\",\n-               uint::to_str(i, 2u),\n-               hm_ss.get(uint::to_str(i, 2u)));\n-        assert (str::eq(hm_ss.get(uint::to_str(i, 2u)),\n-                        uint::to_str(i * i, 2u)));\n-        i += 1u;\n-    }\n-    #debug(\"*** finished test_growth\");\n-}\n-\n-#[test]\n-fn test_removal() {\n-    #debug(\"*** starting test_removal\");\n-    let num_to_insert: uint = 64u;\n-    fn eq(&&x: uint, &&y: uint) -> bool { ret x == y; }\n-    fn hash(&&u: uint) -> uint {\n-        // This hash function intentionally causes collisions between\n-        // consecutive integer pairs.\n-\n-        ret u / 2u * 2u;\n-    }\n-    assert (hash(0u) == hash(1u));\n-    assert (hash(2u) == hash(3u));\n-    assert (hash(0u) != hash(2u));\n-    let hasher: map::hashfn<uint> = hash;\n-    let eqer: map::eqfn<uint> = eq;\n-    let hm: map::hashmap<uint, uint> =\n-        map::mk_hashmap::<uint, uint>(hasher, eqer);\n-    let i: uint = 0u;\n-    while i < num_to_insert {\n-        assert (hm.insert(i, i * i));\n-        #debug(\"inserting %u -> %u\", i, i*i);\n-        i += 1u;\n-    }\n-    assert (hm.size() == num_to_insert);\n-    #debug(\"-----\");\n-    #debug(\"removing evens\");\n-    i = 0u;\n-    while i < num_to_insert {\n-        let v = hm.remove(i);\n-        alt v {\n-          option::some(u) { assert (u == i * i); }\n-          option::none. { fail; }\n-        }\n-        i += 2u;\n-    }\n-    assert (hm.size() == num_to_insert / 2u);\n-    #debug(\"-----\");\n-    i = 1u;\n-    while i < num_to_insert {\n-        #debug(\"get(%u) = %u\", i, hm.get(i));\n-        assert (hm.get(i) == i * i);\n-        i += 2u;\n-    }\n-    #debug(\"-----\");\n-    i = 1u;\n-    while i < num_to_insert {\n-        #debug(\"get(%u) = %u\", i, hm.get(i));\n-        assert (hm.get(i) == i * i);\n-        i += 2u;\n-    }\n-    #debug(\"-----\");\n-    i = 0u;\n-    while i < num_to_insert {\n-        assert (hm.insert(i, i * i));\n-        #debug(\"inserting %u -> %u\", i, i*i);\n-        i += 2u;\n-    }\n-    assert (hm.size() == num_to_insert);\n-    #debug(\"-----\");\n-    i = 0u;\n-    while i < num_to_insert {\n-        #debug(\"get(%u) = %u\", i, hm.get(i));\n-        assert (hm.get(i) == i * i);\n-        i += 1u;\n-    }\n-    #debug(\"-----\");\n-    assert (hm.size() == num_to_insert);\n-    i = 0u;\n-    while i < num_to_insert {\n-        #debug(\"get(%u) = %u\", i, hm.get(i));\n-        assert (hm.get(i) == i * i);\n-        i += 1u;\n-    }\n-    #debug(\"*** finished test_removal\");\n-}\n-\n-#[test]\n-fn test_contains_key() {\n-    let key = \"k\";\n-    let map = map::mk_hashmap::<str, str>(str::hash, str::eq);\n-    assert (!map.contains_key(key));\n-    map.insert(key, \"val\");\n-    assert (map.contains_key(key));\n-}\n-\n-#[test]\n-fn test_find() {\n-    let key = \"k\";\n-    let map = map::mk_hashmap::<str, str>(str::hash, str::eq);\n-    assert (option::is_none(map.find(key)));\n-    map.insert(key, \"val\");\n-    assert (option::get(map.find(key)) == \"val\");\n-}"}, {"sha": "c0872db3fc73029fb2f83b31d10906e35afc4eee", "filename": "src/test/stdtest/net.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fnet.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -1,14 +0,0 @@\n-import core::*;\n-\n-use std;\n-import std::net;\n-\n-#[test]\n-fn test_format_ip() {\n-    assert (net::format_addr(net::ipv4(127u8, 0u8, 0u8, 1u8)) == \"127.0.0.1\")\n-}\n-\n-#[test]\n-fn test_parse_ip() {\n-    assert (net::parse_addr(\"127.0.0.1\") == net::ipv4(127u8, 0u8, 0u8, 1u8));\n-}"}, {"sha": "fd773063e8d003d410a38e920d8112b0b57f3656", "filename": "src/test/stdtest/os.rs", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fos.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -1,58 +0,0 @@\n-import core::*;\n-\n-import std::generic_os::setenv;\n-import std::generic_os::getenv;\n-import option;\n-\n-#[test]\n-#[ignore(reason = \"fails periodically on mac\")]\n-fn test_setenv() {\n-    // NB: Each test of setenv needs to use different variable names or the\n-    // tests will not be threadsafe\n-    setenv(\"NAME1\", \"VALUE\");\n-    assert (getenv(\"NAME1\") == option::some(\"VALUE\"));\n-}\n-\n-#[test]\n-#[ignore(reason = \"fails periodically on mac\")]\n-fn test_setenv_overwrite() {\n-    setenv(\"NAME2\", \"1\");\n-    setenv(\"NAME2\", \"2\");\n-    assert (getenv(\"NAME2\") == option::some(\"2\"));\n-}\n-\n-// Windows GetEnvironmentVariable requires some extra work to make sure\n-// the buffer the variable is copied into is the right size\n-#[test]\n-#[ignore(reason = \"fails periodically on mac\")]\n-fn test_getenv_big() {\n-    let s = \"\";\n-    let i = 0;\n-    while i < 100 { s += \"aaaaaaaaaa\"; i += 1; }\n-    setenv(\"test_getenv_big\", s);\n-    log(debug, s);\n-    assert (getenv(\"test_getenv_big\") == option::some(s));\n-}\n-\n-#[test]\n-fn get_exe_path() {\n-    let path = std::os::get_exe_path();\n-    assert option::is_some(path);\n-    let path = option::get(path);\n-    log(debug, path);\n-\n-    // Hard to test this function\n-    if std::os::target_os() != \"win32\" {\n-        assert str::starts_with(path, std::fs::path_sep());\n-    } else {\n-        assert path[1] == ':' as u8;\n-    }\n-}\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "e711288c6152c616fdbf1b62f20e16263844865c", "filename": "src/test/stdtest/path.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fpath.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -1,18 +0,0 @@\n-import core::*;\n-\n-// Testing a few of the path manipuation functions\n-\n-use std;\n-\n-import std::fs;\n-import std::os;\n-\n-#[test]\n-fn test() {\n-    assert (!fs::path_is_absolute(\"test-path\"));\n-\n-    log(debug, \"Current working directory: \" + os::getcwd());\n-\n-    log(debug, fs::make_absolute(\"test-path\"));\n-    log(debug, fs::make_absolute(\"/usr/bin\"));\n-}"}, {"sha": "65291026bd596ebf2f8a3c0acf41835614c615fa", "filename": "src/test/stdtest/qsort.rs", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fqsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fqsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fqsort.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -1,71 +0,0 @@\n-import core::*;\n-\n-use std;\n-\n-import std::sort;\n-import vec;\n-import int;\n-\n-fn check_sort(v1: [mutable int], v2: [mutable int]) {\n-    let len = vec::len::<int>(v1);\n-    fn ltequal(&&a: int, &&b: int) -> bool { ret a <= b; }\n-    let f = ltequal;\n-    std::sort::quick_sort::<int>(f, v1);\n-    let i = 0u;\n-    while i < len {\n-        log(debug, v2[i]);\n-        assert (v2[i] == v1[i]);\n-        i += 1u;\n-    }\n-}\n-\n-#[test]\n-fn test() {\n-    {\n-        let v1 = [mutable 3, 7, 4, 5, 2, 9, 5, 8];\n-        let v2 = [mutable 2, 3, 4, 5, 5, 7, 8, 9];\n-        check_sort(v1, v2);\n-    }\n-    {\n-        let v1 = [mutable 1, 1, 1];\n-        let v2 = [mutable 1, 1, 1];\n-        check_sort(v1, v2);\n-    }\n-    {\n-        let v1: [mutable int] = [mutable];\n-        let v2: [mutable int] = [mutable];\n-        check_sort(v1, v2);\n-    }\n-    { let v1 = [mutable 9]; let v2 = [mutable 9]; check_sort(v1, v2); }\n-    {\n-        let v1 = [mutable 9, 3, 3, 3, 9];\n-        let v2 = [mutable 3, 3, 3, 9, 9];\n-        check_sort(v1, v2);\n-    }\n-}\n-\n-// Regression test for #750\n-#[test]\n-fn test_simple() {\n-    let names = [mutable 2, 1, 3];\n-\n-    let expected = [1, 2, 3];\n-\n-    fn lteq(&&a: int, &&b: int) -> bool { int::le(a, b) }\n-    sort::quick_sort(lteq, names);\n-\n-    let immut_names = vec::from_mut(names);\n-\n-    // Silly, but what else can we do?\n-    check (vec::same_length(expected, immut_names));\n-    let pairs = vec::zip(expected, immut_names);\n-    for (a, b) in pairs { #debug(\"%d %d\", a, b); assert (a == b); }\n-}\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "b4371b2c3b45b37171a3f6b75c372386d280e013", "filename": "src/test/stdtest/qsort3.rs", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fqsort3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fqsort3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fqsort3.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -1,50 +0,0 @@\n-import core::*;\n-\n-use std;\n-\n-fn check_sort(v1: [mutable int], v2: [mutable int]) {\n-    let len = vec::len::<int>(v1);\n-    fn lt(&&a: int, &&b: int) -> bool { ret a < b; }\n-    fn equal(&&a: int, &&b: int) -> bool { ret a == b; }\n-    let f1 = lt;\n-    let f2 = equal;\n-    std::sort::quick_sort3::<int>(f1, f2, v1);\n-    let i = 0u;\n-    while i < len {\n-        log(debug, v2[i]);\n-        assert (v2[i] == v1[i]);\n-        i += 1u;\n-    }\n-}\n-\n-#[test]\n-fn test() {\n-    {\n-        let v1 = [mutable 3, 7, 4, 5, 2, 9, 5, 8];\n-        let v2 = [mutable 2, 3, 4, 5, 5, 7, 8, 9];\n-        check_sort(v1, v2);\n-    }\n-    {\n-        let v1 = [mutable 1, 1, 1];\n-        let v2 = [mutable 1, 1, 1];\n-        check_sort(v1, v2);\n-    }\n-    {\n-        let v1: [mutable int] = [mutable];\n-        let v2: [mutable int] = [mutable];\n-        check_sort(v1, v2);\n-    }\n-    { let v1 = [mutable 9]; let v2 = [mutable 9]; check_sort(v1, v2); }\n-    {\n-        let v1 = [mutable 9, 3, 3, 3, 9];\n-        let v2 = [mutable 3, 3, 3, 9, 9];\n-        check_sort(v1, v2);\n-    }\n-}\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "1460fb87f808f4524b31f9c78f867116555cc7a0", "filename": "src/test/stdtest/rand.rs", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Frand.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -1,40 +0,0 @@\n-import core::*;\n-\n-// -*- rust -*-\n-use std;\n-import std::rand;\n-import str;\n-\n-#[test]\n-fn test() {\n-    let r1: rand::rng = rand::mk_rng();\n-    log(debug, r1.next());\n-    log(debug, r1.next());\n-    {\n-        let r2 = rand::mk_rng();\n-        log(debug, r1.next());\n-        log(debug, r2.next());\n-        log(debug, r1.next());\n-        log(debug, r1.next());\n-        log(debug, r2.next());\n-        log(debug, r2.next());\n-        log(debug, r1.next());\n-        log(debug, r1.next());\n-        log(debug, r1.next());\n-        log(debug, r2.next());\n-        log(debug, r2.next());\n-        log(debug, r2.next());\n-    }\n-    log(debug, r1.next());\n-    log(debug, r1.next());\n-}\n-\n-#[test]\n-fn genstr() {\n-    let r: rand::rng = rand::mk_rng();\n-    log(debug, r.gen_str(10u));\n-    log(debug, r.gen_str(10u));\n-    log(debug, r.gen_str(10u));\n-    assert(str::char_len(r.gen_str(10u)) == 10u);\n-    assert(str::char_len(r.gen_str(16u)) == 16u);\n-}"}, {"sha": "d432e0b38f965787ac5d0e79146223758707f3f4", "filename": "src/test/stdtest/rope.rs", "status": "removed", "additions": 0, "deletions": 166, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Frope.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -1,166 +0,0 @@\n-import core::*;\n-\n-import str;\n-import std::rope::*;\n-import option;\n-import uint;\n-import vec;\n-\n-//Utility function, used for sanity check\n-fn rope_to_string(r: rope) -> str {\n-    alt(r) {\n-      node::empty. { ret \"\" }\n-      node::content(x) {\n-        let str = @mutable \"\";\n-        fn aux(str: @mutable str, node: @node::node) {\n-            alt(*node) {\n-              node::leaf(x) {\n-                *str += str::substr(*x.content, x.byte_offset, x.byte_len);\n-              }\n-              node::concat(x) {\n-                aux(str, x.left);\n-                aux(str, x.right);\n-              }\n-            }\n-        }\n-        aux(str, x);\n-        ret *str\n-      }\n-    }\n-}\n-\n-\n-#[test]\n-fn trivial() {\n-    assert char_len(empty()) == 0u;\n-    assert byte_len(empty()) == 0u;\n-}\n-\n-#[test]\n-fn of_string1() {\n-    let sample = @\"0123456789ABCDE\";\n-    let r      = of_str(sample);\n-\n-    assert char_len(r) == str::char_len(*sample);\n-    assert rope_to_string(r) == *sample;\n-}\n-\n-#[test]\n-fn of_string2() {\n-    let buf = @ mutable \"1234567890\";\n-    let i = 0;\n-    while i < 10 { *buf = *buf + *buf; i+=1;}\n-    let sample = @*buf;\n-    let r      = of_str(sample);\n-    assert char_len(r) == str::char_len(*sample);\n-    assert rope_to_string(r) == *sample;\n-\n-    let string_iter = 0u;\n-    let string_len  = str::byte_len(*sample);\n-    let rope_iter   = iterator::char::start(r);\n-    let equal       = true;\n-    let pos         = 0u;\n-    while equal {\n-        alt(node::char_iterator::next(rope_iter)) {\n-          option::none. {\n-            if string_iter < string_len {\n-                equal = false;\n-            } break; }\n-          option::some(c) {\n-            let {ch, next} = str::char_range_at(*sample, string_iter);\n-            string_iter = next;\n-            if ch != c { equal = false; break; }\n-          }\n-        }\n-        pos += 1u;\n-    }\n-\n-    assert equal;\n-}\n-\n-#[test]\n-fn iter1() {\n-    let buf = @ mutable \"1234567890\";\n-    let i = 0;\n-    while i < 10 { *buf = *buf + *buf; i+=1;}\n-    let sample = @*buf;\n-    let r      = of_str(sample);\n-\n-    let len = 0u;\n-    let it  = iterator::char::start(r);\n-    while true {\n-        alt(node::char_iterator::next(it)) {\n-          option::none. { break; }\n-          option::some(_) { len += 1u; }\n-        }\n-    }\n-\n-    assert len == str::char_len(*sample);\n-}\n-\n-#[test]\n-fn bal1() {\n-    let init = @ \"1234567890\";\n-    let buf  = @ mutable * init;\n-    let i = 0;\n-    while i < 8 { *buf = *buf + *buf; i+=1;}\n-    let sample = @*buf;\n-    let r1     = of_str(sample);\n-    let r2     = of_str(init);\n-    i = 0;\n-    while i < 8 { r2 = append_rope(r2, r2); i+= 1;}\n-\n-\n-    assert eq(r1, r2);\n-    let r3 = bal(r2);\n-    assert char_len(r1) == char_len(r3);\n-\n-    assert eq(r1, r3);\n-}\n-\n-#[test]\n-fn char_at1() {\n-    //Generate a large rope\n-    let r = of_str(@ \"123456789\");\n-    uint::range(0u, 10u){|_i|\n-        r = append_rope(r, r);\n-    }\n-\n-    //Copy it in the slowest possible way\n-    let r2 = empty();\n-    uint::range(0u, char_len(r)){|i|\n-        r2 = append_char(r2, char_at(r, i));\n-    }\n-    assert eq(r, r2);\n-\n-    let r3 = empty();\n-    uint::range(0u, char_len(r)){|i|\n-        r3 = prepend_char(r3, char_at(r, char_len(r) - i - 1u));\n-    }\n-    assert eq(r, r3);\n-\n-    //Additional sanity checks\n-    let balr = bal(r);\n-    let bal2 = bal(r2);\n-    let bal3 = bal(r3);\n-    assert eq(r, balr);\n-    assert eq(r, bal2);\n-    assert eq(r, bal3);\n-    assert eq(r2, r3);\n-    assert eq(bal2, bal3);\n-}\n-\n-#[test]\n-fn concat1() {\n-    //Generate a reasonable rope\n-    let chunk = of_str(@ \"123456789\");\n-    let r = empty();\n-    uint::range(0u, 10u){|_i|\n-        r = append_rope(r, chunk);\n-    }\n-\n-    //Same rope, obtained with rope::concat\n-    let r2 = concat(vec::init_elt(chunk, 10u));\n-\n-    assert eq(r, r2);\n-}\n\\ No newline at end of file"}, {"sha": "c1e194a35905a6c547c92ff413ed78ffa8a81beb", "filename": "src/test/stdtest/run.rs", "status": "removed", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Frun.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -1,70 +0,0 @@\n-import core::*;\n-\n-use std;\n-import std::run;\n-import std::os;\n-import std::io;\n-import io::writer_util;\n-import option;\n-import str;\n-import ctypes::fd_t;\n-\n-// Regression test for memory leaks\n-#[ignore(cfg(target_os = \"win32\"))] // FIXME\n-fn test_leaks() {\n-    run::run_program(\"echo\", []);\n-    run::start_program(\"echo\", []);\n-    run::program_output(\"echo\", []);\n-}\n-\n-#[test]\n-fn test_pipes() {\n-    let pipe_in = os::pipe();\n-    let pipe_out = os::pipe();\n-    let pipe_err = os::pipe();\n-\n-    let pid =\n-        run::spawn_process(\"cat\", [], pipe_in.in, pipe_out.out, pipe_err.out);\n-    os::close(pipe_in.in);\n-    os::close(pipe_out.out);\n-    os::close(pipe_err.out);\n-\n-    if pid == -1i32 { fail; }\n-    let expected = \"test\";\n-    writeclose(pipe_in.out, expected);\n-    let actual = readclose(pipe_out.in);\n-    readclose(pipe_err.in);\n-    os::waitpid(pid);\n-\n-    log(debug, expected);\n-    log(debug, actual);\n-    assert (expected == actual);\n-\n-    fn writeclose(fd: fd_t, s: str) {\n-        #error(\"writeclose %d, %s\", fd as int, s);\n-        let writer = io::fd_writer(fd, false);\n-        writer.write_str(s);\n-\n-        os::close(fd);\n-    }\n-\n-    fn readclose(fd: fd_t) -> str {\n-        // Copied from run::program_output\n-        let file = os::fd_FILE(fd);\n-        let reader = io::FILE_reader(file, false);\n-        let buf = \"\";\n-        while !reader.eof() {\n-            let bytes = reader.read_bytes(4096u);\n-            buf += str::unsafe_from_bytes(bytes);\n-        }\n-        os::fclose(file);\n-        ret buf;\n-    }\n-}\n-\n-#[test]\n-fn waitpid() {\n-    let pid = run::spawn_process(\"false\", [], 0i32, 0i32, 0i32);\n-    let status = run::waitpid(pid);\n-    assert status == 1;\n-}"}, {"sha": "e1b8a4a8d59641be8df3c835f377d9caa0883849", "filename": "src/test/stdtest/sha1.rs", "status": "removed", "additions": 0, "deletions": 95, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fsha1.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -1,95 +0,0 @@\n-import core::*;\n-\n-// -*- rust -*-\n-\n-use std;\n-import std::sha1;\n-import vec;\n-import str;\n-\n-#[test]\n-fn test() {\n-    type test = {input: str, output: [u8]};\n-\n-    fn a_million_letter_a() -> str {\n-        let i = 0;\n-        let rs = \"\";\n-        while i < 100000 { rs += \"aaaaaaaaaa\"; i += 1; }\n-        ret rs;\n-    }\n-    // Test messages from FIPS 180-1\n-\n-    let fips_180_1_tests: [test] =\n-        [{input: \"abc\",\n-          output:\n-              [0xA9u8, 0x99u8, 0x3Eu8, 0x36u8, 0x47u8, 0x06u8, 0x81u8, 0x6Au8,\n-               0xBAu8, 0x3Eu8, 0x25u8, 0x71u8, 0x78u8, 0x50u8, 0xC2u8, 0x6Cu8,\n-               0x9Cu8, 0xD0u8, 0xD8u8, 0x9Du8]},\n-         {input:\n-              \"abcdbcdecdefdefgefghfghighij\" + \"hijkijkljklmklmnlmnomnopnopq\",\n-          output:\n-              [0x84u8, 0x98u8, 0x3Eu8, 0x44u8, 0x1Cu8, 0x3Bu8, 0xD2u8, 0x6Eu8,\n-               0xBAu8, 0xAEu8, 0x4Au8, 0xA1u8, 0xF9u8, 0x51u8, 0x29u8, 0xE5u8,\n-               0xE5u8, 0x46u8, 0x70u8, 0xF1u8]},\n-         {input: a_million_letter_a(),\n-          output:\n-              [0x34u8, 0xAAu8, 0x97u8, 0x3Cu8, 0xD4u8, 0xC4u8, 0xDAu8, 0xA4u8,\n-               0xF6u8, 0x1Eu8, 0xEBu8, 0x2Bu8, 0xDBu8, 0xADu8, 0x27u8, 0x31u8,\n-               0x65u8, 0x34u8, 0x01u8, 0x6Fu8]}];\n-    // Examples from wikipedia\n-\n-    let wikipedia_tests: [test] =\n-        [{input: \"The quick brown fox jumps over the lazy dog\",\n-          output:\n-              [0x2fu8, 0xd4u8, 0xe1u8, 0xc6u8, 0x7au8, 0x2du8, 0x28u8, 0xfcu8,\n-               0xedu8, 0x84u8, 0x9eu8, 0xe1u8, 0xbbu8, 0x76u8, 0xe7u8, 0x39u8,\n-               0x1bu8, 0x93u8, 0xebu8, 0x12u8]},\n-         {input: \"The quick brown fox jumps over the lazy cog\",\n-          output:\n-              [0xdeu8, 0x9fu8, 0x2cu8, 0x7fu8, 0xd2u8, 0x5eu8, 0x1bu8, 0x3au8,\n-               0xfau8, 0xd3u8, 0xe8u8, 0x5au8, 0x0bu8, 0xd1u8, 0x7du8, 0x9bu8,\n-               0x10u8, 0x0du8, 0xb4u8, 0xb3u8]}];\n-    let tests = fips_180_1_tests + wikipedia_tests;\n-    fn check_vec_eq(v0: [u8], v1: [u8]) {\n-        assert (vec::len::<u8>(v0) == vec::len::<u8>(v1));\n-        let len = vec::len::<u8>(v0);\n-        let i = 0u;\n-        while i < len {\n-            let a = v0[i];\n-            let b = v1[i];\n-            assert (a == b);\n-            i += 1u;\n-        }\n-    }\n-    // Test that it works when accepting the message all at once\n-\n-    let sh = sha1::mk_sha1();\n-    for t: test in tests {\n-        sh.input_str(t.input);\n-        let out = sh.result();\n-        check_vec_eq(t.output, out);\n-        sh.reset();\n-    }\n-\n-\n-    // Test that it works when accepting the message in pieces\n-    for t: test in tests {\n-        let len = str::byte_len(t.input);\n-        let left = len;\n-        while left > 0u {\n-            let take = (left + 1u) / 2u;\n-            sh.input_str(str::substr(t.input, len - left, take));\n-            left = left - take;\n-        }\n-        let out = sh.result();\n-        check_vec_eq(t.output, out);\n-        sh.reset();\n-    }\n-}\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "83d885797bfc1ce11c96b681505d3579f74e9a0b", "filename": "src/test/stdtest/sort.rs", "status": "removed", "additions": 0, "deletions": 41, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fsort.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -1,41 +0,0 @@\n-import core::*;\n-\n-use std;\n-\n-fn check_sort(v1: [int], v2: [int]) {\n-    let len = vec::len::<int>(v1);\n-    fn lteq(&&a: int, &&b: int) -> bool { ret a <= b; }\n-    let f = lteq;\n-    let v3 = std::sort::merge_sort::<int>(f, v1);\n-    let i = 0u;\n-    while i < len {\n-        log(debug, v3[i]);\n-        assert (v3[i] == v2[i]);\n-        i += 1u;\n-    }\n-}\n-\n-#[test]\n-fn test() {\n-    {\n-        let v1 = [3, 7, 4, 5, 2, 9, 5, 8];\n-        let v2 = [2, 3, 4, 5, 5, 7, 8, 9];\n-        check_sort(v1, v2);\n-    }\n-    { let v1 = [1, 1, 1]; let v2 = [1, 1, 1]; check_sort(v1, v2); }\n-    { let v1: [int] = []; let v2: [int] = []; check_sort(v1, v2); }\n-    { let v1 = [9]; let v2 = [9]; check_sort(v1, v2); }\n-    {\n-        let v1 = [9, 3, 3, 3, 9];\n-        let v2 = [3, 3, 3, 9, 9];\n-        check_sort(v1, v2);\n-    }\n-}\n-\n-#[test]\n-fn test_merge_sort_mutable() {\n-    fn lteq(&&a: int, &&b: int) -> bool { ret a <= b; }\n-    let v1 = [mutable 3, 2, 1];\n-    let v2 = std::sort::merge_sort(lteq, v1);\n-    assert v2 == [1, 2, 3];\n-}\n\\ No newline at end of file"}, {"sha": "4fd390c5c3e3fb2a5ca8383cc294e0ec0ee8705a", "filename": "src/test/stdtest/stdtest.rc", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fstdtest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fstdtest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fstdtest.rc?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -1,40 +0,0 @@\n-use std;\n-\n-mod bitv;\n-mod c_vec;\n-mod deque;\n-mod four;\n-mod fs;\n-mod getopts;\n-mod io;\n-mod json;\n-mod list;\n-mod map;\n-mod net;\n-mod os;\n-mod path;\n-mod qsort3;\n-mod qsort;\n-mod rand;\n-mod rope;\n-mod run;\n-mod sha1;\n-mod sort;\n-mod tempfile;\n-mod test;\n-mod tri;\n-mod treemap;\n-\n-#[cfg(unicode)]\n-mod unicode;\n-\n-mod uv;\n-\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n-// End:"}, {"sha": "7db30fa67a1905ebe389d2d32cc7c266042dc8f2", "filename": "src/test/stdtest/tempfile.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ftempfile.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -1,20 +0,0 @@\n-import core::*;\n-\n-use std;\n-import option;\n-import std::fs;\n-import option::some;\n-import str;\n-import std::tempfile;\n-\n-#[test]\n-fn mkdtemp() {\n-    let r = tempfile::mkdtemp(\"./\", \"foobar\");\n-    alt r {\n-        some(p) {\n-            fs::remove_dir(p);\n-            assert(str::ends_with(p, \"foobar\"));\n-        }\n-        _ { assert(false); }\n-    }\n-}"}, {"sha": "78f67c83d3bfcdc55c42e43101a8c929bee8701f", "filename": "src/test/stdtest/test.rs", "status": "removed", "additions": 0, "deletions": 119, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ftest.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -1,119 +0,0 @@\n-import core::*;\n-\n-import std::test;\n-import str;\n-import option;\n-import either;\n-import vec;\n-\n-#[test]\n-fn do_not_run_ignored_tests() {\n-    fn f() { fail; }\n-    let desc = {name: \"whatever\", fn: f, ignore: true, should_fail: false};\n-    let future = test::run_test(desc, test::default_test_to_task);\n-    let result = future.wait();\n-    assert result != test::tr_ok;\n-}\n-\n-#[test]\n-fn ignored_tests_result_in_ignored() {\n-    fn f() { }\n-    let desc = {name: \"whatever\", fn: f, ignore: true, should_fail: false};\n-    let res = test::run_test(desc, test::default_test_to_task).wait();\n-    assert (res == test::tr_ignored);\n-}\n-\n-#[test]\n-#[ignore(cfg(target_os = \"win32\"))]\n-fn test_should_fail() {\n-    fn f() { fail; }\n-    let desc = {name: \"whatever\", fn: f, ignore: false, should_fail: true};\n-    let res = test::run_test(desc, test::default_test_to_task).wait();\n-    assert res == test::tr_ok;\n-}\n-\n-#[test]\n-fn test_should_fail_but_succeeds() {\n-    fn f() { }\n-    let desc = {name: \"whatever\", fn: f, ignore: false, should_fail: true};\n-    let res = test::run_test(desc, test::default_test_to_task).wait();\n-    assert res == test::tr_failed;\n-}\n-\n-#[test]\n-fn first_free_arg_should_be_a_filter() {\n-    let args = [\"progname\", \"filter\"];\n-    check (vec::is_not_empty(args));\n-    let opts = alt test::parse_opts(args) { either::left(o) { o } };\n-    assert (str::eq(\"filter\", option::get(opts.filter)));\n-}\n-\n-#[test]\n-fn parse_ignored_flag() {\n-    let args = [\"progname\", \"filter\", \"--ignored\"];\n-    check (vec::is_not_empty(args));\n-    let opts = alt test::parse_opts(args) { either::left(o) { o } };\n-    assert (opts.run_ignored);\n-}\n-\n-#[test]\n-fn filter_for_ignored_option() {\n-    // When we run ignored tests the test filter should filter out all the\n-    // unignored tests and flip the ignore flag on the rest to false\n-\n-    let opts = {filter: option::none, run_ignored: true};\n-    let tests =\n-        [{name: \"1\", fn: fn@() { }, ignore: true, should_fail: false},\n-         {name: \"2\", fn: fn@() { }, ignore: false, should_fail: false}];\n-    let filtered = test::filter_tests(opts, tests);\n-\n-    assert (vec::len(filtered) == 1u);\n-    assert (filtered[0].name == \"1\");\n-    assert (filtered[0].ignore == false);\n-}\n-\n-#[test]\n-fn sort_tests() {\n-    let opts = {filter: option::none, run_ignored: false};\n-\n-    let names =\n-        [\"sha1::test\", \"int::test_to_str\", \"int::test_pow\",\n-         \"test::do_not_run_ignored_tests\",\n-         \"test::ignored_tests_result_in_ignored\",\n-         \"test::first_free_arg_should_be_a_filter\",\n-         \"test::parse_ignored_flag\", \"test::filter_for_ignored_option\",\n-         \"test::sort_tests\"];\n-    let tests =\n-        {\n-            let testfn = fn@() { };\n-            let tests = [];\n-            for name: str in names {\n-                let test = {name: name, fn: testfn, ignore: false,\n-                  should_fail: false};\n-                tests += [test];\n-            }\n-            tests\n-        };\n-    let filtered = test::filter_tests(opts, tests);\n-\n-    let expected =\n-        [\"int::test_pow\", \"int::test_to_str\", \"sha1::test\",\n-         \"test::do_not_run_ignored_tests\", \"test::filter_for_ignored_option\",\n-         \"test::first_free_arg_should_be_a_filter\",\n-         \"test::ignored_tests_result_in_ignored\", \"test::parse_ignored_flag\",\n-         \"test::sort_tests\"];\n-\n-    check (vec::same_length(expected, filtered));\n-    let pairs = vec::zip(expected, filtered);\n-\n-\n-    for (a, b) in pairs { assert (a == b.name); }\n-}\n-\n-// Local Variables:\n-// mode: rust;\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:"}, {"sha": "90aba286e6ea31d318b951fa1b04286ef0cd0621", "filename": "src/test/stdtest/treemap.rs", "status": "removed", "additions": 0, "deletions": 62, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ftreemap.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -1,62 +0,0 @@\n-import core::*;\n-\n-use std;\n-import option;\n-import std::treemap::*;\n-import option::some;\n-import option::none;\n-import str;\n-\n-#[test]\n-fn init_treemap() { let _m = init::<int, int>(); }\n-\n-#[test]\n-fn insert_one() { let m = init(); insert(m, 1, 2); }\n-\n-#[test]\n-fn insert_two() { let m = init(); insert(m, 1, 2); insert(m, 3, 4); }\n-\n-#[test]\n-fn insert_find() {\n-    let m = init();\n-    insert(m, 1, 2);\n-    assert (find(m, 1) == some(2));\n-}\n-\n-#[test]\n-fn find_empty() { let m = init::<int, int>(); assert (find(m, 1) == none); }\n-\n-#[test]\n-fn find_not_found() {\n-    let m = init();\n-    insert(m, 1, 2);\n-    assert (find(m, 2) == none);\n-}\n-\n-#[test]\n-fn traverse_in_order() {\n-    let m = init();\n-    insert(m, 3, ());\n-    insert(m, 0, ());\n-    insert(m, 4, ());\n-    insert(m, 2, ());\n-    insert(m, 1, ());\n-\n-    let n = @mutable 0;\n-    fn t(n: @mutable int, &&k: int, &&_v: ()) { assert (*n == k); *n += 1; }\n-    traverse(m, bind t(n, _, _));\n-}\n-\n-#[test]\n-fn u8_map() {\n-    let m = init();\n-\n-    let k1 = str::bytes(\"foo\");\n-    let k2 = str::bytes(\"bar\");\n-\n-    insert(m, k1, \"foo\");\n-    insert(m, k2, \"bar\");\n-\n-    assert (find(m, k2) == some(\"bar\"));\n-    assert (find(m, k1) == some(\"foo\"));\n-}"}, {"sha": "c560bc0b681aa13e055771987f460a8ef3f38881", "filename": "src/test/stdtest/tri.rs", "status": "removed", "additions": 0, "deletions": 119, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Ftri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Ftri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Ftri.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -1,119 +0,0 @@\n-import core::*;\n-\n-use std;\n-\n-import std::tri;\n-\n-pure fn eq1(a: tri::t, b: tri::t) -> bool { tri::eq(a , b) }\n-pure fn ne1(a: tri::t, b: tri::t) -> bool { tri::ne(a , b) }\n-\n-pure fn eq2(a: tri::t, b: tri::t) -> bool { eq1( a, b ) && eq1( b, a ) }\n-\n-#[test]\n-fn test_eq2() {\n-    tri::all_values { |a|\n-        tri::all_values { |b|\n-            assert if a == b { eq1( a, b ) } else { ne1( a, b ) }\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_tri_and_symmetry() {\n-    tri::all_values { |a|\n-        tri::all_values { |b|\n-            assert eq1( tri::and(a ,b), tri::and(b, a) );\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_tri_or_symmetry() {\n-    tri::all_values { |a|\n-        tri::all_values { |b|\n-            assert eq1( tri::or(a ,b), tri::or(b, a) );\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_tri_xor_symmetry() {\n-    tri::all_values { |a|\n-        tri::all_values { |b|\n-            assert eq1( tri::xor(a ,b), tri::xor(b, a) );\n-        }\n-    }\n-}\n-\n-#[test]\n-fn test_tri_not() {\n-    assert eq2( tri::not(tri::true), tri::false);\n-    assert eq2( tri::not(tri::unknown), tri::unknown);\n-    assert eq2( tri::not(tri::false), tri::true);\n-}\n-\n-#[test]\n-fn test_tri_and() {\n-    assert eq2( tri::and(tri::true, tri::true), tri::true);\n-    assert eq2( tri::and(tri::true, tri::false), tri::false);\n-    assert eq2( tri::and(tri::true, tri::unknown), tri::unknown);\n-    assert eq2( tri::and(tri::false, tri::false), tri::false);\n-    assert eq2( tri::and(tri::false, tri::unknown), tri::false);\n-    assert eq2( tri::and(tri::unknown, tri::unknown), tri::unknown);\n-}\n-\n-#[test]\n-fn test_tri_or() {\n-    assert eq2( tri::or(tri::true, tri::true), tri::true);\n-    assert eq2( tri::or(tri::true, tri::false), tri::true);\n-    assert eq2( tri::or(tri::true, tri::unknown), tri::true);\n-    assert eq2( tri::or(tri::false, tri::false), tri::false);\n-    assert eq2( tri::or(tri::false, tri::unknown), tri::unknown);\n-    assert eq2( tri::or(tri::unknown, tri::unknown), tri::unknown);\n-}\n-\n-#[test]\n-fn test_tri_xor() {\n-    assert eq2( tri::xor(tri::true, tri::true), tri::false);\n-    assert eq2( tri::xor(tri::false, tri::false), tri::false);\n-    assert eq2( tri::xor(tri::true, tri::false), tri::true);\n-    assert eq2( tri::xor(tri::true, tri::unknown), tri::unknown);\n-    assert eq2( tri::xor(tri::false, tri::unknown), tri::unknown);\n-    assert eq2( tri::xor(tri::unknown, tri::unknown), tri::unknown);\n-}\n-\n-#[test]\n-fn test_tri_implies() {\n-    assert eq2( tri::implies(tri::false, tri::false), tri::true);\n-    assert eq2( tri::implies(tri::false, tri::unknown), tri::true);\n-    assert eq2( tri::implies(tri::false, tri::true), tri::true);\n-\n-    assert eq2( tri::implies(tri::unknown, tri::false), tri::unknown);\n-    assert eq2( tri::implies(tri::unknown, tri::unknown), tri::unknown);\n-    assert eq2( tri::implies(tri::unknown, tri::true), tri::true);\n-\n-    assert eq2( tri::implies(tri::true, tri::false), tri::false);\n-    assert eq2( tri::implies(tri::true, tri::unknown), tri::unknown);\n-    assert eq2( tri::implies(tri::true, tri::true), tri::true);\n-}\n-\n-#[test]\n-fn test_tri_from_str() {\n-    tri::all_values { |v|\n-        assert eq2( v, tri::from_str(tri::to_str(v)));\n-    }\n-}\n-\n-#[test]\n-fn test_tri_to_str() {\n-    assert tri::to_str(tri::false) == \"false\";\n-    assert tri::to_str(tri::unknown) == \"unknown\";\n-    assert tri::to_str(tri::true) == \"true\";\n-}\n-\n-#[test]\n-fn test_tri_to_bit() {\n-    tri::all_values { |v|\n-        assert tri::to_bit(v) == if tri::is_true(v) { 1u8 } else { 0u8 };\n-    }\n-}\n\\ No newline at end of file"}, {"sha": "7c3c65685b6e41ddeae291dd107ff69fc3c82d6f", "filename": "src/test/stdtest/unicode.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Funicode.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -1,30 +0,0 @@\n-import core::*;\n-\n-use std;\n-\n-import unicode;\n-\n-#[test]\n-fn test_is_digit() {\n-    assert (unicode::icu::is_digit('0'));\n-    assert (!unicode::icu::is_digit('m'));\n-}\n-\n-#[test]\n-fn test_is_lower() {\n-    assert (unicode::icu::is_lower('m'));\n-    assert (!unicode::icu::is_lower('M'));\n-}\n-\n-#[test]\n-fn test_is_space() {\n-    assert (unicode::icu::is_space(' '));\n-    assert (!unicode::icu::is_space('m'));\n-}\n-\n-#[test]\n-fn test_is_upper() {\n-    assert (unicode::icu::is_upper('M'));\n-    assert (!unicode::icu::is_upper('m'));\n-}\n-"}, {"sha": "a7f6e0a8f15730fc3ee97b9fe83497e4b7bdbff2", "filename": "src/test/stdtest/uv.rs", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fuv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17bf4b0e1be01bc7a54c389deb5896949736d7f2/src%2Ftest%2Fstdtest%2Fuv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fuv.rs?ref=17bf4b0e1be01bc7a54c389deb5896949736d7f2", "patch": "@@ -1,48 +0,0 @@\n-\n-#[cfg(target_os = \"linux\")];\n-#[cfg(target_os = \"macos\")];\n-#[cfg(target_os = \"freebsd\")];\n-\n-import core::*;\n-\n-import std::uv;\n-import ptr;\n-\n-#[test]\n-fn sanity_check() {\n-    uv::sanity_check();\n-}\n-\n-// From test-ref.c\n-mod test_ref {\n-\n-    #[test]\n-    fn ref() {\n-        let loop = uv::loop_new();\n-        uv::run(loop);\n-        uv::loop_delete(loop);\n-    }\n-\n-    #[test]\n-    fn idle_ref() {\n-        let loop = uv::loop_new();\n-        let h = uv::idle_new();\n-        uv::idle_init(loop, ptr::addr_of(h));\n-        uv::idle_start(ptr::addr_of(h), ptr::null());\n-        uv::unref(loop);\n-        uv::run(loop);\n-        uv::loop_delete(loop);\n-    }\n-\n-    #[test]\n-    fn async_ref() {\n-        /*\n-        let loop = uv::loop_new();\n-        let h = uv::async_new();\n-        uv::async_init(loop, ptr::addr_of(h), ptr::null());\n-        uv::unref(loop);\n-        uv::run(loop);\n-        uv::loop_delete(loop);\n-        */\n-    }\n-}"}]}