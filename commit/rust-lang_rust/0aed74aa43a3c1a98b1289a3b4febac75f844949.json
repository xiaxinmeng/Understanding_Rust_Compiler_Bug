{"sha": "0aed74aa43a3c1a98b1289a3b4febac75f844949", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhZWQ3NGFhNDNhM2MxYTk4YjEyODlhM2I0ZmViYWM3NWY4NDQ5NDk=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-11-09T18:06:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-09T18:06:46Z"}, "message": "Rollup merge of #78502 - matthewjasper:chalkup, r=nikomatsakis\n\nUpdate Chalk to 0.36.0\n\nThis PR updates Chalk and fixes a number of bugs in the chalk integration code.\n\ncc `@rust-lang/wg-traits`\nr? `@nikomatsakis`", "tree": {"sha": "503994afc0a3f83bd290c6b4cc9ac50ad3480a11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/503994afc0a3f83bd290c6b4cc9ac50ad3480a11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0aed74aa43a3c1a98b1289a3b4febac75f844949", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfqYU3CRBK7hj4Ov3rIwAAdHIIAJtduE6jPnECtptS/QwuvDHp\nHkmwFV5K8HabRnvB8wbTXaGqStVnoszOBc5f6JtFGagkQIy1pAVJnl9kkfWM8b1W\n6H26bFQ6PSgZDh7O+c+Om8GJPzaAY2gsS0ZHAcLej1gQrfXxQ9glsawnZpcDVp8k\nNtdJx1a7FxpBjeOJj4MwMIep8BLa2Qjs5TTWECUsRNKQbVpKAsQlH1oTokcoBEov\n+IvWOnmK9wFd7s6Sk7b+RW5Zv4ZJj9RFJ1J4XBbvXiOCxYvAe70NcAlzTFU3V81M\nphTyCS191O2SlxCXOmuz0qXa6Nhxz1WbYZ9iHEFRS8mhvyedCqFz9vZsWmYqmXw=\n=dLGJ\n-----END PGP SIGNATURE-----\n", "payload": "tree 503994afc0a3f83bd290c6b4cc9ac50ad3480a11\nparent 2187f3c7f2a1bf1d6e4f9a1e634a887f9118532d\nparent 4d60a80713533cad5221f8b4aa2faff54b46d21d\nauthor Dylan DPC <dylan.dpc@gmail.com> 1604945206 +0100\ncommitter GitHub <noreply@github.com> 1604945206 +0100\n\nRollup merge of #78502 - matthewjasper:chalkup, r=nikomatsakis\n\nUpdate Chalk to 0.36.0\n\nThis PR updates Chalk and fixes a number of bugs in the chalk integration code.\n\ncc `@rust-lang/wg-traits`\nr? `@nikomatsakis`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0aed74aa43a3c1a98b1289a3b4febac75f844949", "html_url": "https://github.com/rust-lang/rust/commit/0aed74aa43a3c1a98b1289a3b4febac75f844949", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0aed74aa43a3c1a98b1289a3b4febac75f844949/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2187f3c7f2a1bf1d6e4f9a1e634a887f9118532d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2187f3c7f2a1bf1d6e4f9a1e634a887f9118532d", "html_url": "https://github.com/rust-lang/rust/commit/2187f3c7f2a1bf1d6e4f9a1e634a887f9118532d"}, {"sha": "4d60a80713533cad5221f8b4aa2faff54b46d21d", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d60a80713533cad5221f8b4aa2faff54b46d21d", "html_url": "https://github.com/rust-lang/rust/commit/4d60a80713533cad5221f8b4aa2faff54b46d21d"}], "stats": {"total": 739, "additions": 384, "deletions": 355}, "files": [{"sha": "45a19fd79634e68747f18d72d0d39ea5d5136ca9", "filename": "Cargo.lock", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0aed74aa43a3c1a98b1289a3b4febac75f844949/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/0aed74aa43a3c1a98b1289a3b4febac75f844949/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=0aed74aa43a3c1a98b1289a3b4febac75f844949", "patch": "@@ -460,9 +460,9 @@ checksum = \"baf1de4339761588bc0619e3cbc0120ee582ebb74b53b4efbf79117bd2da40fd\"\n \n [[package]]\n name = \"chalk-derive\"\n-version = \"0.32.0\"\n+version = \"0.36.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2d072b2ba723f0bada7c515d8b3725224bc4f5052d2a92dcbeb0b118ff37084a\"\n+checksum = \"9f88ce4deae1dace71e49b7611cfae2d5489de3530d6daba5758043c47ac3a10\"\n dependencies = [\n  \"proc-macro2\",\n  \"quote\",\n@@ -472,9 +472,9 @@ dependencies = [\n \n [[package]]\n name = \"chalk-engine\"\n-version = \"0.32.0\"\n+version = \"0.36.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"6fb5475f6083d6d6c509e1c335c4f69ad04144ac090faa1afb134a53c3695841\"\n+checksum = \"0e34c9b1b10616782143d7f49490f91ae94afaf2202de3ab0b2835e78b4f0ccc\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\",\n@@ -485,19 +485,19 @@ dependencies = [\n \n [[package]]\n name = \"chalk-ir\"\n-version = \"0.32.0\"\n+version = \"0.36.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f60cdb0e18c5455cb6a85e8464aad3622b70476018edfa8845691df66f7e9a05\"\n+checksum = \"63362c629c2014ab639b04029070763fb8224df136d1363d30e9ece4c8877da3\"\n dependencies = [\n  \"chalk-derive\",\n  \"lazy_static\",\n ]\n \n [[package]]\n name = \"chalk-solve\"\n-version = \"0.32.0\"\n+version = \"0.36.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"981534d499a8476ecc0b520be4d3864757f96211826a75360fbf2cb6fae362ab\"\n+checksum = \"cac338a67af52a7f50bb2f8232e730a3518ce432dbe303246acfe525ddd838c7\"\n dependencies = [\n  \"chalk-derive\",\n  \"chalk-ir\","}, {"sha": "3250f1830de18598575312312d7a4557a49ee5fd", "filename": "compiler/rustc_middle/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aed74aa43a3c1a98b1289a3b4febac75f844949/compiler%2Frustc_middle%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0aed74aa43a3c1a98b1289a3b4febac75f844949/compiler%2Frustc_middle%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2FCargo.toml?ref=0aed74aa43a3c1a98b1289a3b4febac75f844949", "patch": "@@ -26,7 +26,7 @@ rustc_index = { path = \"../rustc_index\" }\n rustc_serialize = { path = \"../rustc_serialize\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n-chalk-ir = \"0.32.0\"\n+chalk-ir = \"0.36.0\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n measureme = \"9.0.0\"\n rustc_session = { path = \"../rustc_session\" }"}, {"sha": "f864ad8ebcd8a0f52fa34244d6c0c211e119d78e", "filename": "compiler/rustc_middle/src/traits/chalk.rs", "status": "modified", "additions": 26, "deletions": 42, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/0aed74aa43a3c1a98b1289a3b4febac75f844949/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aed74aa43a3c1a98b1289a3b4febac75f844949/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fchalk.rs?ref=0aed74aa43a3c1a98b1289a3b4febac75f844949", "patch": "@@ -102,48 +102,6 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n         Some(write())\n     }\n \n-    fn debug_application_ty(\n-        application_ty: &chalk_ir::ApplicationTy<Self>,\n-        fmt: &mut fmt::Formatter<'_>,\n-    ) -> Option<fmt::Result> {\n-        match application_ty.name {\n-            chalk_ir::TypeName::Ref(mutbl) => {\n-                let data = application_ty.substitution.interned();\n-                match (&**data[0].interned(), &**data[1].interned()) {\n-                    (\n-                        chalk_ir::GenericArgData::Lifetime(lifetime),\n-                        chalk_ir::GenericArgData::Ty(ty),\n-                    ) => Some(match mutbl {\n-                        chalk_ir::Mutability::Not => write!(fmt, \"(&{:?} {:?})\", lifetime, ty),\n-                        chalk_ir::Mutability::Mut => write!(fmt, \"(&{:?} mut {:?})\", lifetime, ty),\n-                    }),\n-                    _ => unreachable!(),\n-                }\n-            }\n-            chalk_ir::TypeName::Array => {\n-                let data = application_ty.substitution.interned();\n-                match (&**data[0].interned(), &**data[1].interned()) {\n-                    (chalk_ir::GenericArgData::Ty(ty), chalk_ir::GenericArgData::Const(len)) => {\n-                        Some(write!(fmt, \"[{:?}; {:?}]\", ty, len))\n-                    }\n-                    _ => unreachable!(),\n-                }\n-            }\n-            chalk_ir::TypeName::Slice => {\n-                let data = application_ty.substitution.interned();\n-                let ty = match &**data[0].interned() {\n-                    chalk_ir::GenericArgData::Ty(t) => t,\n-                    _ => unreachable!(),\n-                };\n-                Some(write!(fmt, \"[{:?}]\", ty))\n-            }\n-            _ => {\n-                let chalk_ir::ApplicationTy { name, substitution } = application_ty;\n-                Some(write!(fmt, \"{:?}{:?}\", name, chalk_ir::debug::Angle(substitution.interned())))\n-            }\n-        }\n-    }\n-\n     fn debug_substitution(\n         substitution: &chalk_ir::Substitution<Self>,\n         fmt: &mut fmt::Formatter<'_>,\n@@ -174,6 +132,32 @@ impl<'tcx> chalk_ir::interner::Interner for RustInterner<'tcx> {\n         Some(write!(fmt, \"{:?}\", clauses.interned()))\n     }\n \n+    fn debug_ty(ty: &chalk_ir::Ty<Self>, fmt: &mut fmt::Formatter<'_>) -> Option<fmt::Result> {\n+        match &ty.interned().kind {\n+            chalk_ir::TyKind::Ref(chalk_ir::Mutability::Not, lifetime, ty) => {\n+                Some(write!(fmt, \"(&{:?} {:?})\", lifetime, ty))\n+            }\n+            chalk_ir::TyKind::Ref(chalk_ir::Mutability::Mut, lifetime, ty) => {\n+                Some(write!(fmt, \"(&{:?} mut {:?})\", lifetime, ty))\n+            }\n+            chalk_ir::TyKind::Array(ty, len) => Some(write!(fmt, \"[{:?}; {:?}]\", ty, len)),\n+            chalk_ir::TyKind::Slice(ty) => Some(write!(fmt, \"[{:?}]\", ty)),\n+            chalk_ir::TyKind::Tuple(len, substs) => Some((|| {\n+                write!(fmt, \"(\")?;\n+                for (idx, substitution) in substs.interned().iter().enumerate() {\n+                    if idx == *len && *len != 1 {\n+                        // Don't add a trailing comma if the tuple has more than one element\n+                        write!(fmt, \"{:?}\", substitution)?;\n+                    } else {\n+                        write!(fmt, \"{:?},\", substitution)?;\n+                    }\n+                }\n+                write!(fmt, \")\")\n+            })()),\n+            _ => None,\n+        }\n+    }\n+\n     fn debug_alias(\n         alias_ty: &chalk_ir::AliasTy<Self>,\n         fmt: &mut fmt::Formatter<'_>,"}, {"sha": "1e4fd0921ee0fd4b380f502b9aaa952e7fdbed9a", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0aed74aa43a3c1a98b1289a3b4febac75f844949/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aed74aa43a3c1a98b1289a3b4febac75f844949/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=0aed74aa43a3c1a98b1289a3b4febac75f844949", "patch": "@@ -63,7 +63,7 @@ thread_local! {\n /// Avoids running any queries during any prints that occur\n /// during the closure. This may alter the appearance of some\n /// types (e.g. forcing verbose printing for opaque types).\n-/// This method is used during some queries (e.g. `predicates_of`\n+/// This method is used during some queries (e.g. `explicit_item_bounds`\n /// for opaque types), to ensure that any debug printing that\n /// occurs during the query computation does not end up recursively\n /// calling the same query."}, {"sha": "8bd9e29629dce8baa8929764fcb2a6ec661131e2", "filename": "compiler/rustc_traits/Cargo.toml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0aed74aa43a3c1a98b1289a3b4febac75f844949/compiler%2Frustc_traits%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/0aed74aa43a3c1a98b1289a3b4febac75f844949/compiler%2Frustc_traits%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2FCargo.toml?ref=0aed74aa43a3c1a98b1289a3b4febac75f844949", "patch": "@@ -12,9 +12,9 @@ rustc_hir = { path = \"../rustc_hir\" }\n rustc_index = { path = \"../rustc_index\" }\n rustc_ast = { path = \"../rustc_ast\" }\n rustc_span = { path = \"../rustc_span\" }\n-chalk-ir = \"0.32.0\"\n-chalk-solve = \"0.32.0\"\n-chalk-engine = \"0.32.0\"\n+chalk-ir = \"0.36.0\"\n+chalk-solve = \"0.36.0\"\n+chalk-engine = \"0.36.0\"\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n rustc_infer = { path = \"../rustc_infer\" }\n rustc_trait_selection = { path = \"../rustc_trait_selection\" }"}, {"sha": "c5a46b1003dfaaf44d11710cc435dbb639f8898a", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 128, "deletions": 78, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/0aed74aa43a3c1a98b1289a3b4febac75f844949/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aed74aa43a3c1a98b1289a3b4febac75f844949/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=0aed74aa43a3c1a98b1289a3b4febac75f844949", "patch": "@@ -37,7 +37,7 @@ impl<'tcx> RustIrDatabase<'tcx> {\n         def_id: DefId,\n         bound_vars: SubstsRef<'tcx>,\n     ) -> Vec<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>> {\n-        let predicates = self.interner.tcx.predicates_of(def_id).predicates;\n+        let predicates = self.interner.tcx.predicates_defined_on(def_id).predicates;\n         let mut regions_substitutor =\n             lowering::RegionsSubstitutor::new(self.interner.tcx, self.reempty_placeholder);\n         predicates\n@@ -118,34 +118,27 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n             .map(|i| chalk_ir::AssocTypeId(i.def_id))\n             .collect();\n \n-        let well_known = if self.interner.tcx.lang_items().sized_trait() == Some(def_id) {\n+        let lang_items = self.interner.tcx.lang_items();\n+        let well_known = if lang_items.sized_trait() == Some(def_id) {\n             Some(chalk_solve::rust_ir::WellKnownTrait::Sized)\n-        } else if self.interner.tcx.lang_items().copy_trait() == Some(def_id) {\n+        } else if lang_items.copy_trait() == Some(def_id) {\n             Some(chalk_solve::rust_ir::WellKnownTrait::Copy)\n-        } else if self.interner.tcx.lang_items().clone_trait() == Some(def_id) {\n+        } else if lang_items.clone_trait() == Some(def_id) {\n             Some(chalk_solve::rust_ir::WellKnownTrait::Clone)\n-        } else if self.interner.tcx.lang_items().drop_trait() == Some(def_id) {\n+        } else if lang_items.drop_trait() == Some(def_id) {\n             Some(chalk_solve::rust_ir::WellKnownTrait::Drop)\n-        } else if self.interner.tcx.lang_items().fn_trait() == Some(def_id) {\n+        } else if lang_items.fn_trait() == Some(def_id) {\n             Some(chalk_solve::rust_ir::WellKnownTrait::Fn)\n-        } else if self\n-            .interner\n-            .tcx\n-            .lang_items()\n-            .fn_once_trait()\n-            .map(|t| def_id == t)\n-            .unwrap_or(false)\n-        {\n+        } else if lang_items.fn_once_trait() == Some(def_id) {\n             Some(chalk_solve::rust_ir::WellKnownTrait::FnOnce)\n-        } else if self\n-            .interner\n-            .tcx\n-            .lang_items()\n-            .fn_mut_trait()\n-            .map(|t| def_id == t)\n-            .unwrap_or(false)\n-        {\n+        } else if lang_items.fn_mut_trait() == Some(def_id) {\n             Some(chalk_solve::rust_ir::WellKnownTrait::FnMut)\n+        } else if lang_items.unsize_trait() == Some(def_id) {\n+            Some(chalk_solve::rust_ir::WellKnownTrait::Unsize)\n+        } else if lang_items.unpin_trait() == Some(def_id) {\n+            Some(chalk_solve::rust_ir::WellKnownTrait::Unpin)\n+        } else if lang_items.coerce_unsized_trait() == Some(def_id) {\n+            Some(chalk_solve::rust_ir::WellKnownTrait::CoerceUnsized)\n         } else {\n             None\n         };\n@@ -281,11 +274,20 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n             where_clauses,\n         };\n \n+        let associated_ty_value_ids: Vec<_> = self\n+            .interner\n+            .tcx\n+            .associated_items(def_id)\n+            .in_definition_order()\n+            .filter(|i| i.kind == AssocKind::Type)\n+            .map(|i| chalk_solve::rust_ir::AssociatedTyValueId(i.def_id))\n+            .collect();\n+\n         Arc::new(chalk_solve::rust_ir::ImplDatum {\n-            polarity: chalk_solve::rust_ir::Polarity::Positive,\n+            polarity: self.interner.tcx.impl_polarity(def_id).lower_into(&self.interner),\n             binders: chalk_ir::Binders::new(binders, value),\n             impl_type: chalk_solve::rust_ir::ImplType::Local,\n-            associated_ty_value_ids: vec![],\n+            associated_ty_value_ids,\n         })\n     }\n \n@@ -324,19 +326,19 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n     fn impl_provided_for(\n         &self,\n         auto_trait_id: chalk_ir::TraitId<RustInterner<'tcx>>,\n-        app_ty: &chalk_ir::ApplicationTy<RustInterner<'tcx>>,\n+        chalk_ty: &chalk_ir::TyKind<RustInterner<'tcx>>,\n     ) -> bool {\n         use chalk_ir::Scalar::*;\n-        use chalk_ir::TypeName::*;\n+        use chalk_ir::TyKind::*;\n \n         let trait_def_id = auto_trait_id.0;\n         let all_impls = self.interner.tcx.all_impls(trait_def_id);\n         for impl_def_id in all_impls {\n             let trait_ref = self.interner.tcx.impl_trait_ref(impl_def_id).unwrap();\n             let self_ty = trait_ref.self_ty();\n-            let provides = match (self_ty.kind(), app_ty.name) {\n-                (&ty::Adt(impl_adt_def, ..), Adt(id)) => impl_adt_def.did == id.0.did,\n-                (_, AssociatedType(_ty_id)) => {\n+            let provides = match (self_ty.kind(), chalk_ty) {\n+                (&ty::Adt(impl_adt_def, ..), Adt(id, ..)) => impl_adt_def.did == id.0.did,\n+                (_, AssociatedType(_ty_id, ..)) => {\n                     // FIXME(chalk): See https://github.com/rust-lang/rust/pull/77152#discussion_r494484774\n                     false\n                 }\n@@ -365,28 +367,30 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n                     (ast::FloatTy::F32, chalk_ir::FloatTy::F32)\n                         | (ast::FloatTy::F64, chalk_ir::FloatTy::F64)\n                 ),\n-                (&ty::Tuple(..), Tuple(..)) => true,\n-                (&ty::Array(..), Array) => true,\n-                (&ty::Slice(..), Slice) => true,\n-                (&ty::RawPtr(type_and_mut), Raw(mutability)) => {\n+                (&ty::Tuple(substs), Tuple(len, _)) => substs.len() == *len,\n+                (&ty::Array(..), Array(..)) => true,\n+                (&ty::Slice(..), Slice(..)) => true,\n+                (&ty::RawPtr(type_and_mut), Raw(mutability, _)) => {\n                     match (type_and_mut.mutbl, mutability) {\n                         (ast::Mutability::Mut, chalk_ir::Mutability::Mut) => true,\n                         (ast::Mutability::Mut, chalk_ir::Mutability::Not) => false,\n                         (ast::Mutability::Not, chalk_ir::Mutability::Mut) => false,\n                         (ast::Mutability::Not, chalk_ir::Mutability::Not) => true,\n                     }\n                 }\n-                (&ty::Ref(.., mutability1), Ref(mutability2)) => match (mutability1, mutability2) {\n-                    (ast::Mutability::Mut, chalk_ir::Mutability::Mut) => true,\n-                    (ast::Mutability::Mut, chalk_ir::Mutability::Not) => false,\n-                    (ast::Mutability::Not, chalk_ir::Mutability::Mut) => false,\n-                    (ast::Mutability::Not, chalk_ir::Mutability::Not) => true,\n-                },\n-                (&ty::Opaque(def_id, ..), OpaqueType(opaque_ty_id)) => def_id == opaque_ty_id.0,\n-                (&ty::FnDef(def_id, ..), FnDef(fn_def_id)) => def_id == fn_def_id.0,\n+                (&ty::Ref(.., mutability1), Ref(mutability2, ..)) => {\n+                    match (mutability1, mutability2) {\n+                        (ast::Mutability::Mut, chalk_ir::Mutability::Mut) => true,\n+                        (ast::Mutability::Mut, chalk_ir::Mutability::Not) => false,\n+                        (ast::Mutability::Not, chalk_ir::Mutability::Mut) => false,\n+                        (ast::Mutability::Not, chalk_ir::Mutability::Not) => true,\n+                    }\n+                }\n+                (&ty::Opaque(def_id, ..), OpaqueType(opaque_ty_id, ..)) => def_id == opaque_ty_id.0,\n+                (&ty::FnDef(def_id, ..), FnDef(fn_def_id, ..)) => def_id == fn_def_id.0,\n                 (&ty::Str, Str) => true,\n                 (&ty::Never, Never) => true,\n-                (&ty::Closure(def_id, ..), Closure(closure_id)) => def_id == closure_id.0,\n+                (&ty::Closure(def_id, ..), Closure(closure_id, _)) => def_id == closure_id.0,\n                 (&ty::Foreign(def_id), Foreign(foreign_def_id)) => def_id == foreign_def_id.0,\n                 (&ty::Error(..), Error) => false,\n                 _ => false,\n@@ -404,24 +408,38 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n     ) -> Arc<chalk_solve::rust_ir::AssociatedTyValue<RustInterner<'tcx>>> {\n         let def_id = associated_ty_id.0;\n         let assoc_item = self.interner.tcx.associated_item(def_id);\n-        let impl_id = match assoc_item.container {\n-            AssocItemContainer::TraitContainer(def_id) => def_id,\n-            _ => unimplemented!(\"Not possible??\"),\n+        let (impl_id, trait_id) = match assoc_item.container {\n+            AssocItemContainer::TraitContainer(def_id) => (def_id, def_id),\n+            AssocItemContainer::ImplContainer(def_id) => {\n+                (def_id, self.interner.tcx.impl_trait_ref(def_id).unwrap().def_id)\n+            }\n         };\n         match assoc_item.kind {\n             AssocKind::Type => {}\n             _ => unimplemented!(\"Not possible??\"),\n         }\n+\n+        let trait_item = self\n+            .interner\n+            .tcx\n+            .associated_items(trait_id)\n+            .find_by_name_and_kind(self.interner.tcx, assoc_item.ident, assoc_item.kind, trait_id)\n+            .unwrap();\n         let bound_vars = bound_vars_for_item(self.interner.tcx, def_id);\n         let binders = binders_for(&self.interner, bound_vars);\n-        let ty = self.interner.tcx.type_of(def_id);\n+        let ty = self\n+            .interner\n+            .tcx\n+            .type_of(def_id)\n+            .subst(self.interner.tcx, bound_vars)\n+            .lower_into(&self.interner);\n \n         Arc::new(chalk_solve::rust_ir::AssociatedTyValue {\n             impl_id: chalk_ir::ImplId(impl_id),\n-            associated_ty_id: chalk_ir::AssocTypeId(def_id),\n+            associated_ty_id: chalk_ir::AssocTypeId(trait_item.def_id),\n             value: chalk_ir::Binders::new(\n                 binders,\n-                chalk_solve::rust_ir::AssociatedTyValueBound { ty: ty.lower_into(&self.interner) },\n+                chalk_solve::rust_ir::AssociatedTyValueBound { ty },\n             ),\n         })\n     }\n@@ -441,19 +459,61 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         &self,\n         opaque_ty_id: chalk_ir::OpaqueTyId<RustInterner<'tcx>>,\n     ) -> Arc<chalk_solve::rust_ir::OpaqueTyDatum<RustInterner<'tcx>>> {\n-        let bound_vars = bound_vars_for_item(self.interner.tcx, opaque_ty_id.0);\n-        let binders = binders_for(&self.interner, bound_vars);\n+        let bound_vars = ty::fold::shift_vars(\n+            self.interner.tcx,\n+            &bound_vars_for_item(self.interner.tcx, opaque_ty_id.0),\n+            1,\n+        );\n         let where_clauses = self.where_clauses_for(opaque_ty_id.0, bound_vars);\n-        let bounds = self.bounds_for(opaque_ty_id.0, bound_vars);\n+\n+        let identity_substs = InternalSubsts::identity_for_item(self.interner.tcx, opaque_ty_id.0);\n+\n+        let bounds =\n+            self.interner\n+                .tcx\n+                .explicit_item_bounds(opaque_ty_id.0)\n+                .iter()\n+                .map(|(bound, _)| bound.subst(self.interner.tcx, &bound_vars))\n+                .map(|bound| {\n+                    bound.fold_with(&mut ty::fold::BottomUpFolder {\n+                        tcx: self.interner.tcx,\n+                        ty_op: |ty| {\n+                            if let ty::Opaque(def_id, substs) = *ty.kind() {\n+                                if def_id == opaque_ty_id.0 && substs == identity_substs {\n+                                    return self.interner.tcx.mk_ty(ty::Bound(\n+                                        ty::INNERMOST,\n+                                        ty::BoundTy::from(ty::BoundVar::from_u32(0)),\n+                                    ));\n+                                }\n+                            }\n+                            ty\n+                        },\n+                        lt_op: |lt| lt,\n+                        ct_op: |ct| ct,\n+                    })\n+                })\n+                .filter_map(|bound| {\n+                    LowerInto::<\n+                    Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>\n+                >::lower_into(bound, &self.interner)\n+                })\n+                .collect();\n+\n+        // Binder for the bound variable representing the concrete impl Trait type.\n+        let existential_binder = chalk_ir::VariableKinds::from1(\n+            &self.interner,\n+            chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General),\n+        );\n \n         let value = chalk_solve::rust_ir::OpaqueTyDatumBound {\n-            bounds: chalk_ir::Binders::new(binders.clone(), bounds),\n-            where_clauses: chalk_ir::Binders::new(binders, where_clauses),\n+            bounds: chalk_ir::Binders::new(existential_binder.clone(), bounds),\n+            where_clauses: chalk_ir::Binders::new(existential_binder, where_clauses),\n         };\n \n+        let binders = binders_for(&self.interner, bound_vars);\n         Arc::new(chalk_solve::rust_ir::OpaqueTyDatum {\n             opaque_ty_id,\n-            bound: chalk_ir::Binders::empty(&self.interner, value),\n+            bound: chalk_ir::Binders::new(binders, value),\n         })\n     }\n \n@@ -506,17 +566,11 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n         substs: &chalk_ir::Substitution<RustInterner<'tcx>>,\n     ) -> chalk_solve::rust_ir::ClosureKind {\n         let kind = &substs.as_slice(&self.interner)[substs.len(&self.interner) - 3];\n-        match kind.assert_ty_ref(&self.interner).data(&self.interner) {\n-            chalk_ir::TyData::Apply(apply) => match apply.name {\n-                chalk_ir::TypeName::Scalar(scalar) => match scalar {\n-                    chalk_ir::Scalar::Int(int_ty) => match int_ty {\n-                        chalk_ir::IntTy::I8 => chalk_solve::rust_ir::ClosureKind::Fn,\n-                        chalk_ir::IntTy::I16 => chalk_solve::rust_ir::ClosureKind::FnMut,\n-                        chalk_ir::IntTy::I32 => chalk_solve::rust_ir::ClosureKind::FnOnce,\n-                        _ => bug!(\"bad closure kind\"),\n-                    },\n-                    _ => bug!(\"bad closure kind\"),\n-                },\n+        match kind.assert_ty_ref(&self.interner).kind(&self.interner) {\n+            chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Int(int_ty)) => match int_ty {\n+                chalk_ir::IntTy::I8 => chalk_solve::rust_ir::ClosureKind::Fn,\n+                chalk_ir::IntTy::I16 => chalk_solve::rust_ir::ClosureKind::FnMut,\n+                chalk_ir::IntTy::I32 => chalk_solve::rust_ir::ClosureKind::FnOnce,\n                 _ => bug!(\"bad closure kind\"),\n             },\n             _ => bug!(\"bad closure kind\"),\n@@ -530,23 +584,19 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n     ) -> chalk_ir::Binders<chalk_solve::rust_ir::FnDefInputsAndOutputDatum<RustInterner<'tcx>>>\n     {\n         let sig = &substs.as_slice(&self.interner)[substs.len(&self.interner) - 2];\n-        match sig.assert_ty_ref(&self.interner).data(&self.interner) {\n-            chalk_ir::TyData::Function(f) => {\n+        match sig.assert_ty_ref(&self.interner).kind(&self.interner) {\n+            chalk_ir::TyKind::Function(f) => {\n                 let substitution = f.substitution.as_slice(&self.interner);\n                 let return_type =\n                     substitution.last().unwrap().assert_ty_ref(&self.interner).clone();\n                 // Closure arguments are tupled\n                 let argument_tuple = substitution[0].assert_ty_ref(&self.interner);\n-                let argument_types = match argument_tuple.data(&self.interner) {\n-                    chalk_ir::TyData::Apply(apply) => match apply.name {\n-                        chalk_ir::TypeName::Tuple(_) => apply\n-                            .substitution\n-                            .iter(&self.interner)\n-                            .map(|arg| arg.assert_ty_ref(&self.interner))\n-                            .cloned()\n-                            .collect(),\n-                        _ => bug!(\"Expecting closure FnSig args to be tupled.\"),\n-                    },\n+                let argument_types = match argument_tuple.kind(&self.interner) {\n+                    chalk_ir::TyKind::Tuple(_len, substitution) => substitution\n+                        .iter(&self.interner)\n+                        .map(|arg| arg.assert_ty_ref(&self.interner))\n+                        .cloned()\n+                        .collect(),\n                     _ => bug!(\"Expecting closure FnSig args to be tupled.\"),\n                 };\n \n@@ -637,7 +687,7 @@ fn binders_for<'tcx>(\n         bound_vars.iter().map(|arg| match arg.unpack() {\n             ty::subst::GenericArgKind::Lifetime(_re) => chalk_ir::VariableKind::Lifetime,\n             ty::subst::GenericArgKind::Type(_ty) => {\n-                chalk_ir::VariableKind::Ty(chalk_ir::TyKind::General)\n+                chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General)\n             }\n             ty::subst::GenericArgKind::Const(c) => {\n                 chalk_ir::VariableKind::Const(c.ty.lower_into(interner))"}, {"sha": "c4e2c7f839d70141dc310d1c999ef1a21b43efa0", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 171, "deletions": 210, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/0aed74aa43a3c1a98b1289a3b4febac75f844949/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aed74aa43a3c1a98b1289a3b4febac75f844949/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=0aed74aa43a3c1a98b1289a3b4febac75f844949", "patch": "@@ -31,11 +31,12 @@\n //! not. To lower anything wrapped in a `Binder`, we first deeply find any bound\n //! variables from the current `Binder`.\n \n+use rustc_ast::ast;\n use rustc_middle::traits::{ChalkEnvironmentAndGoal, ChalkRustInterner as RustInterner};\n use rustc_middle::ty::fold::TypeFolder;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind, SubstsRef};\n use rustc_middle::ty::{\n-    self, Binder, BoundRegion, Region, RegionKind, Ty, TyCtxt, TyKind, TypeFoldable, TypeVisitor,\n+    self, Binder, BoundRegion, Region, RegionKind, Ty, TyCtxt, TypeFoldable, TypeVisitor,\n };\n use rustc_span::def_id::DefId;\n \n@@ -240,113 +241,60 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::AliasEq<RustInterner<'tcx>>>\n \n impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n     fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::Ty<RustInterner<'tcx>> {\n-        use chalk_ir::TyData;\n         use rustc_ast as ast;\n-        use TyKind::*;\n \n-        let empty = || chalk_ir::Substitution::empty(interner);\n-        let struct_ty =\n-            |def_id| chalk_ir::TypeName::Adt(chalk_ir::AdtId(interner.tcx.adt_def(def_id)));\n-        let apply = |name, substitution| {\n-            TyData::Apply(chalk_ir::ApplicationTy { name, substitution }).intern(interner)\n-        };\n-        let int = |i| apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Int(i)), empty());\n-        let uint = |i| apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Uint(i)), empty());\n-        let float = |f| apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Float(f)), empty());\n+        let int = |i| chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Int(i));\n+        let uint = |i| chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Uint(i));\n+        let float = |f| chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Float(f));\n \n         match *self.kind() {\n-            Bool => apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Bool), empty()),\n-            Char => apply(chalk_ir::TypeName::Scalar(chalk_ir::Scalar::Char), empty()),\n-            Int(ty) => match ty {\n+            ty::Bool => chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Bool),\n+            ty::Char => chalk_ir::TyKind::Scalar(chalk_ir::Scalar::Char),\n+            ty::Int(ty) => match ty {\n                 ast::IntTy::Isize => int(chalk_ir::IntTy::Isize),\n                 ast::IntTy::I8 => int(chalk_ir::IntTy::I8),\n                 ast::IntTy::I16 => int(chalk_ir::IntTy::I16),\n                 ast::IntTy::I32 => int(chalk_ir::IntTy::I32),\n                 ast::IntTy::I64 => int(chalk_ir::IntTy::I64),\n                 ast::IntTy::I128 => int(chalk_ir::IntTy::I128),\n             },\n-            Uint(ty) => match ty {\n+            ty::Uint(ty) => match ty {\n                 ast::UintTy::Usize => uint(chalk_ir::UintTy::Usize),\n                 ast::UintTy::U8 => uint(chalk_ir::UintTy::U8),\n                 ast::UintTy::U16 => uint(chalk_ir::UintTy::U16),\n                 ast::UintTy::U32 => uint(chalk_ir::UintTy::U32),\n                 ast::UintTy::U64 => uint(chalk_ir::UintTy::U64),\n                 ast::UintTy::U128 => uint(chalk_ir::UintTy::U128),\n             },\n-            Float(ty) => match ty {\n+            ty::Float(ty) => match ty {\n                 ast::FloatTy::F32 => float(chalk_ir::FloatTy::F32),\n                 ast::FloatTy::F64 => float(chalk_ir::FloatTy::F64),\n             },\n-            Adt(def, substs) => apply(struct_ty(def.did), substs.lower_into(interner)),\n-            Foreign(def_id) => apply(chalk_ir::TypeName::Foreign(ForeignDefId(def_id)), empty()),\n-            Str => apply(chalk_ir::TypeName::Str, empty()),\n-            Array(ty, len) => {\n-                let value = match len.val {\n-                    ty::ConstKind::Value(val) => {\n-                        chalk_ir::ConstValue::Concrete(chalk_ir::ConcreteConst { interned: val })\n-                    }\n-                    ty::ConstKind::Bound(db, bound) => {\n-                        chalk_ir::ConstValue::BoundVar(chalk_ir::BoundVar::new(\n-                            chalk_ir::DebruijnIndex::new(db.as_u32()),\n-                            bound.index(),\n-                        ))\n-                    }\n-                    _ => unimplemented!(\"Const not implemented. {:?}\", len.val),\n-                };\n-                apply(\n-                    chalk_ir::TypeName::Array,\n-                    chalk_ir::Substitution::from_iter(\n-                        interner,\n-                        &[\n-                            chalk_ir::GenericArgData::Ty(ty.lower_into(interner)).intern(interner),\n-                            chalk_ir::GenericArgData::Const(\n-                                chalk_ir::ConstData { ty: len.ty.lower_into(interner), value }\n-                                    .intern(interner),\n-                            )\n-                            .intern(interner),\n-                        ],\n-                    ),\n-                )\n+            ty::Adt(def, substs) => {\n+                chalk_ir::TyKind::Adt(chalk_ir::AdtId(def), substs.lower_into(interner))\n             }\n-            Slice(ty) => apply(\n-                chalk_ir::TypeName::Slice,\n-                chalk_ir::Substitution::from1(\n-                    interner,\n-                    chalk_ir::GenericArgData::Ty(ty.lower_into(interner)).intern(interner),\n-                ),\n-            ),\n-            RawPtr(ptr) => {\n-                let name = match ptr.mutbl {\n-                    ast::Mutability::Mut => chalk_ir::TypeName::Raw(chalk_ir::Mutability::Mut),\n-                    ast::Mutability::Not => chalk_ir::TypeName::Raw(chalk_ir::Mutability::Not),\n-                };\n-                apply(name, chalk_ir::Substitution::from1(interner, ptr.ty.lower_into(interner)))\n+            ty::Foreign(def_id) => chalk_ir::TyKind::Foreign(ForeignDefId(def_id)),\n+            ty::Str => chalk_ir::TyKind::Str,\n+            ty::Array(ty, len) => {\n+                chalk_ir::TyKind::Array(ty.lower_into(interner), len.lower_into(interner))\n             }\n-            Ref(region, ty, mutability) => {\n-                let name = match mutability {\n-                    ast::Mutability::Mut => chalk_ir::TypeName::Ref(chalk_ir::Mutability::Mut),\n-                    ast::Mutability::Not => chalk_ir::TypeName::Ref(chalk_ir::Mutability::Not),\n-                };\n-                apply(\n-                    name,\n-                    chalk_ir::Substitution::from_iter(\n-                        interner,\n-                        &[\n-                            chalk_ir::GenericArgData::Lifetime(region.lower_into(interner))\n-                                .intern(interner),\n-                            chalk_ir::GenericArgData::Ty(ty.lower_into(interner)).intern(interner),\n-                        ],\n-                    ),\n-                )\n+            ty::Slice(ty) => chalk_ir::TyKind::Slice(ty.lower_into(interner)),\n+\n+            ty::RawPtr(ptr) => {\n+                chalk_ir::TyKind::Raw(ptr.mutbl.lower_into(interner), ptr.ty.lower_into(interner))\n             }\n-            FnDef(def_id, substs) => apply(\n-                chalk_ir::TypeName::FnDef(chalk_ir::FnDefId(def_id)),\n-                substs.lower_into(interner),\n+            ty::Ref(region, ty, mutability) => chalk_ir::TyKind::Ref(\n+                mutability.lower_into(interner),\n+                region.lower_into(interner),\n+                ty.lower_into(interner),\n             ),\n-            FnPtr(sig) => {\n+            ty::FnDef(def_id, substs) => {\n+                chalk_ir::TyKind::FnDef(chalk_ir::FnDefId(def_id), substs.lower_into(interner))\n+            }\n+            ty::FnPtr(sig) => {\n                 let (inputs_and_outputs, binders, _named_regions) =\n                     collect_bound_vars(interner, interner.tcx, &sig.inputs_and_output());\n-                TyData::Function(chalk_ir::FnPointer {\n+                chalk_ir::TyKind::Function(chalk_ir::FnPointer {\n                     num_binders: binders.len(interner),\n                     sig: sig.lower_into(interner),\n                     substitution: chalk_ir::Substitution::from_iter(\n@@ -356,148 +304,115 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n                         }),\n                     ),\n                 })\n-                .intern(interner)\n             }\n-            Dynamic(predicates, region) => TyData::Dyn(chalk_ir::DynTy {\n+            ty::Dynamic(predicates, region) => chalk_ir::TyKind::Dyn(chalk_ir::DynTy {\n                 bounds: predicates.lower_into(interner),\n                 lifetime: region.lower_into(interner),\n-            })\n-            .intern(interner),\n-            Closure(def_id, substs) => apply(\n-                chalk_ir::TypeName::Closure(chalk_ir::ClosureId(def_id)),\n-                substs.lower_into(interner),\n-            ),\n-            Generator(_def_id, _substs, _) => unimplemented!(),\n-            GeneratorWitness(_) => unimplemented!(),\n-            Never => apply(chalk_ir::TypeName::Never, empty()),\n-            Tuple(substs) => {\n-                apply(chalk_ir::TypeName::Tuple(substs.len()), substs.lower_into(interner))\n+            }),\n+            ty::Closure(def_id, substs) => {\n+                chalk_ir::TyKind::Closure(chalk_ir::ClosureId(def_id), substs.lower_into(interner))\n             }\n-            Projection(proj) => TyData::Alias(proj.lower_into(interner)).intern(interner),\n-            Opaque(def_id, substs) => {\n-                TyData::Alias(chalk_ir::AliasTy::Opaque(chalk_ir::OpaqueTy {\n+            ty::Generator(_def_id, _substs, _) => unimplemented!(),\n+            ty::GeneratorWitness(_) => unimplemented!(),\n+            ty::Never => chalk_ir::TyKind::Never,\n+            ty::Tuple(substs) => chalk_ir::TyKind::Tuple(substs.len(), substs.lower_into(interner)),\n+            ty::Projection(proj) => chalk_ir::TyKind::Alias(proj.lower_into(interner)),\n+            ty::Opaque(def_id, substs) => {\n+                chalk_ir::TyKind::Alias(chalk_ir::AliasTy::Opaque(chalk_ir::OpaqueTy {\n                     opaque_ty_id: chalk_ir::OpaqueTyId(def_id),\n                     substitution: substs.lower_into(interner),\n                 }))\n-                .intern(interner)\n             }\n             // This should have been done eagerly prior to this, and all Params\n             // should have been substituted to placeholders\n-            Param(_) => panic!(\"Lowering Param when not expected.\"),\n-            Bound(db, bound) => TyData::BoundVar(chalk_ir::BoundVar::new(\n+            ty::Param(_) => panic!(\"Lowering Param when not expected.\"),\n+            ty::Bound(db, bound) => chalk_ir::TyKind::BoundVar(chalk_ir::BoundVar::new(\n                 chalk_ir::DebruijnIndex::new(db.as_u32()),\n                 bound.var.index(),\n-            ))\n-            .intern(interner),\n-            Placeholder(_placeholder) => TyData::Placeholder(chalk_ir::PlaceholderIndex {\n-                ui: chalk_ir::UniverseIndex { counter: _placeholder.universe.as_usize() },\n-                idx: _placeholder.name.as_usize(),\n-            })\n-            .intern(interner),\n-            Infer(_infer) => unimplemented!(),\n-            Error(_) => apply(chalk_ir::TypeName::Error, empty()),\n+            )),\n+            ty::Placeholder(_placeholder) => {\n+                chalk_ir::TyKind::Placeholder(chalk_ir::PlaceholderIndex {\n+                    ui: chalk_ir::UniverseIndex { counter: _placeholder.universe.as_usize() },\n+                    idx: _placeholder.name.as_usize(),\n+                })\n+            }\n+            ty::Infer(_infer) => unimplemented!(),\n+            ty::Error(_) => chalk_ir::TyKind::Error,\n         }\n+        .intern(interner)\n     }\n }\n \n impl<'tcx> LowerInto<'tcx, Ty<'tcx>> for &chalk_ir::Ty<RustInterner<'tcx>> {\n     fn lower_into(self, interner: &RustInterner<'tcx>) -> Ty<'tcx> {\n-        use chalk_ir::TyData;\n-        use rustc_ast::ast;\n+        use chalk_ir::TyKind;\n \n-        let kind = match self.data(interner) {\n-            TyData::Apply(application_ty) => match application_ty.name {\n-                chalk_ir::TypeName::Adt(struct_id) => {\n-                    ty::Adt(struct_id.0, application_ty.substitution.lower_into(interner))\n-                }\n-                chalk_ir::TypeName::Scalar(scalar) => match scalar {\n-                    chalk_ir::Scalar::Bool => ty::Bool,\n-                    chalk_ir::Scalar::Char => ty::Char,\n-                    chalk_ir::Scalar::Int(int_ty) => match int_ty {\n-                        chalk_ir::IntTy::Isize => ty::Int(ast::IntTy::Isize),\n-                        chalk_ir::IntTy::I8 => ty::Int(ast::IntTy::I8),\n-                        chalk_ir::IntTy::I16 => ty::Int(ast::IntTy::I16),\n-                        chalk_ir::IntTy::I32 => ty::Int(ast::IntTy::I32),\n-                        chalk_ir::IntTy::I64 => ty::Int(ast::IntTy::I64),\n-                        chalk_ir::IntTy::I128 => ty::Int(ast::IntTy::I128),\n-                    },\n-                    chalk_ir::Scalar::Uint(int_ty) => match int_ty {\n-                        chalk_ir::UintTy::Usize => ty::Uint(ast::UintTy::Usize),\n-                        chalk_ir::UintTy::U8 => ty::Uint(ast::UintTy::U8),\n-                        chalk_ir::UintTy::U16 => ty::Uint(ast::UintTy::U16),\n-                        chalk_ir::UintTy::U32 => ty::Uint(ast::UintTy::U32),\n-                        chalk_ir::UintTy::U64 => ty::Uint(ast::UintTy::U64),\n-                        chalk_ir::UintTy::U128 => ty::Uint(ast::UintTy::U128),\n-                    },\n-                    chalk_ir::Scalar::Float(float_ty) => match float_ty {\n-                        chalk_ir::FloatTy::F32 => ty::Float(ast::FloatTy::F32),\n-                        chalk_ir::FloatTy::F64 => ty::Float(ast::FloatTy::F64),\n-                    },\n+        let kind = match self.kind(interner) {\n+            TyKind::Adt(struct_id, substitution) => {\n+                ty::Adt(struct_id.0, substitution.lower_into(interner))\n+            }\n+            TyKind::Scalar(scalar) => match scalar {\n+                chalk_ir::Scalar::Bool => ty::Bool,\n+                chalk_ir::Scalar::Char => ty::Char,\n+                chalk_ir::Scalar::Int(int_ty) => match int_ty {\n+                    chalk_ir::IntTy::Isize => ty::Int(ast::IntTy::Isize),\n+                    chalk_ir::IntTy::I8 => ty::Int(ast::IntTy::I8),\n+                    chalk_ir::IntTy::I16 => ty::Int(ast::IntTy::I16),\n+                    chalk_ir::IntTy::I32 => ty::Int(ast::IntTy::I32),\n+                    chalk_ir::IntTy::I64 => ty::Int(ast::IntTy::I64),\n+                    chalk_ir::IntTy::I128 => ty::Int(ast::IntTy::I128),\n+                },\n+                chalk_ir::Scalar::Uint(int_ty) => match int_ty {\n+                    chalk_ir::UintTy::Usize => ty::Uint(ast::UintTy::Usize),\n+                    chalk_ir::UintTy::U8 => ty::Uint(ast::UintTy::U8),\n+                    chalk_ir::UintTy::U16 => ty::Uint(ast::UintTy::U16),\n+                    chalk_ir::UintTy::U32 => ty::Uint(ast::UintTy::U32),\n+                    chalk_ir::UintTy::U64 => ty::Uint(ast::UintTy::U64),\n+                    chalk_ir::UintTy::U128 => ty::Uint(ast::UintTy::U128),\n+                },\n+                chalk_ir::Scalar::Float(float_ty) => match float_ty {\n+                    chalk_ir::FloatTy::F32 => ty::Float(ast::FloatTy::F32),\n+                    chalk_ir::FloatTy::F64 => ty::Float(ast::FloatTy::F64),\n                 },\n-                chalk_ir::TypeName::Array => {\n-                    let substs = application_ty.substitution.as_slice(interner);\n-                    let ty = substs[0].assert_ty_ref(interner).lower_into(interner);\n-                    let c = substs[1].assert_const_ref(interner).lower_into(interner);\n-                    ty::Array(ty, interner.tcx.mk_const(c))\n-                }\n-                chalk_ir::TypeName::FnDef(id) => {\n-                    ty::FnDef(id.0, application_ty.substitution.lower_into(interner))\n-                }\n-                chalk_ir::TypeName::Closure(closure) => {\n-                    ty::Closure(closure.0, application_ty.substitution.lower_into(interner))\n-                }\n-                chalk_ir::TypeName::Generator(_) => unimplemented!(),\n-                chalk_ir::TypeName::GeneratorWitness(_) => unimplemented!(),\n-                chalk_ir::TypeName::Never => ty::Never,\n-                chalk_ir::TypeName::Tuple(_size) => {\n-                    ty::Tuple(application_ty.substitution.lower_into(interner))\n-                }\n-                chalk_ir::TypeName::Slice => ty::Slice(\n-                    application_ty.substitution.as_slice(interner)[0]\n-                        .ty(interner)\n-                        .unwrap()\n-                        .lower_into(interner),\n-                ),\n-                chalk_ir::TypeName::Raw(mutbl) => ty::RawPtr(ty::TypeAndMut {\n-                    ty: application_ty.substitution.as_slice(interner)[0]\n-                        .ty(interner)\n-                        .unwrap()\n-                        .lower_into(interner),\n-                    mutbl: match mutbl {\n-                        chalk_ir::Mutability::Mut => ast::Mutability::Mut,\n-                        chalk_ir::Mutability::Not => ast::Mutability::Not,\n-                    },\n-                }),\n-                chalk_ir::TypeName::Ref(mutbl) => ty::Ref(\n-                    application_ty.substitution.as_slice(interner)[0]\n-                        .lifetime(interner)\n-                        .unwrap()\n-                        .lower_into(interner),\n-                    application_ty.substitution.as_slice(interner)[1]\n-                        .ty(interner)\n-                        .unwrap()\n-                        .lower_into(interner),\n-                    match mutbl {\n-                        chalk_ir::Mutability::Mut => ast::Mutability::Mut,\n-                        chalk_ir::Mutability::Not => ast::Mutability::Not,\n-                    },\n-                ),\n-                chalk_ir::TypeName::Str => ty::Str,\n-                chalk_ir::TypeName::OpaqueType(opaque_ty) => {\n-                    ty::Opaque(opaque_ty.0, application_ty.substitution.lower_into(interner))\n-                }\n-                chalk_ir::TypeName::AssociatedType(assoc_ty) => ty::Projection(ty::ProjectionTy {\n-                    substs: application_ty.substitution.lower_into(interner),\n-                    item_def_id: assoc_ty.0,\n-                }),\n-                chalk_ir::TypeName::Foreign(def_id) => ty::Foreign(def_id.0),\n-                chalk_ir::TypeName::Error => unimplemented!(),\n             },\n-            TyData::Placeholder(placeholder) => ty::Placeholder(ty::Placeholder {\n+            TyKind::Array(ty, c) => {\n+                let ty = ty.lower_into(interner);\n+                let c = c.lower_into(interner);\n+                ty::Array(ty, interner.tcx.mk_const(c))\n+            }\n+            TyKind::FnDef(id, substitution) => ty::FnDef(id.0, substitution.lower_into(interner)),\n+            TyKind::Closure(closure, substitution) => {\n+                ty::Closure(closure.0, substitution.lower_into(interner))\n+            }\n+            TyKind::Generator(..) => unimplemented!(),\n+            TyKind::GeneratorWitness(..) => unimplemented!(),\n+            TyKind::Never => ty::Never,\n+            TyKind::Tuple(_len, substitution) => ty::Tuple(substitution.lower_into(interner)),\n+            TyKind::Slice(ty) => ty::Slice(ty.lower_into(interner)),\n+            TyKind::Raw(mutbl, ty) => ty::RawPtr(ty::TypeAndMut {\n+                ty: ty.lower_into(interner),\n+                mutbl: mutbl.lower_into(interner),\n+            }),\n+            TyKind::Ref(mutbl, lifetime, ty) => ty::Ref(\n+                lifetime.lower_into(interner),\n+                ty.lower_into(interner),\n+                mutbl.lower_into(interner),\n+            ),\n+            TyKind::Str => ty::Str,\n+            TyKind::OpaqueType(opaque_ty, substitution) => {\n+                ty::Opaque(opaque_ty.0, substitution.lower_into(interner))\n+            }\n+            TyKind::AssociatedType(assoc_ty, substitution) => ty::Projection(ty::ProjectionTy {\n+                substs: substitution.lower_into(interner),\n+                item_def_id: assoc_ty.0,\n+            }),\n+            TyKind::Foreign(def_id) => ty::Foreign(def_id.0),\n+            TyKind::Error => return interner.tcx.ty_error(),\n+            TyKind::Placeholder(placeholder) => ty::Placeholder(ty::Placeholder {\n                 universe: ty::UniverseIndex::from_usize(placeholder.ui.counter),\n                 name: ty::BoundVar::from_usize(placeholder.idx),\n             }),\n-            chalk_ir::TyData::Alias(alias_ty) => match alias_ty {\n+            TyKind::Alias(alias_ty) => match alias_ty {\n                 chalk_ir::AliasTy::Projection(projection) => ty::Projection(ty::ProjectionTy {\n                     item_def_id: projection.associated_ty_id.0,\n                     substs: projection.substitution.lower_into(interner),\n@@ -506,16 +421,16 @@ impl<'tcx> LowerInto<'tcx, Ty<'tcx>> for &chalk_ir::Ty<RustInterner<'tcx>> {\n                     ty::Opaque(opaque.opaque_ty_id.0, opaque.substitution.lower_into(interner))\n                 }\n             },\n-            TyData::Function(_quantified_ty) => unimplemented!(),\n-            TyData::BoundVar(_bound) => ty::Bound(\n+            TyKind::Function(_quantified_ty) => unimplemented!(),\n+            TyKind::BoundVar(_bound) => ty::Bound(\n                 ty::DebruijnIndex::from_usize(_bound.debruijn.depth() as usize),\n                 ty::BoundTy {\n                     var: ty::BoundVar::from_usize(_bound.index),\n                     kind: ty::BoundTyKind::Anon,\n                 },\n             ),\n-            TyData::InferenceVar(_, _) => unimplemented!(),\n-            TyData::Dyn(_) => unimplemented!(),\n+            TyKind::InferenceVar(_, _) => unimplemented!(),\n+            TyKind::Dyn(_) => unimplemented!(),\n         };\n         interner.tcx.mk_ty(kind)\n     }\n@@ -706,8 +621,16 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Binders<chalk_ir::QuantifiedWhereClauses<Ru\n         self,\n         interner: &RustInterner<'tcx>,\n     ) -> chalk_ir::Binders<chalk_ir::QuantifiedWhereClauses<RustInterner<'tcx>>> {\n+        // `Self` has one binder:\n+        // Binder<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>\n+        // The return type has two:\n+        // Binders<&[Binders<WhereClause<I>>]>\n+        // This means that any variables that are escaping `self` need to be\n+        // shifted in by one so that they are still escaping.\n+        let shifted_predicates = ty::fold::shift_vars(interner.tcx, &self, 1);\n+\n         let (predicates, binders, _named_regions) =\n-            collect_bound_vars(interner, interner.tcx, &self);\n+            collect_bound_vars(interner, interner.tcx, &shifted_predicates);\n         let self_ty = interner.tcx.mk_ty(ty::Bound(\n             // This is going to be wrapped in a binder\n             ty::DebruijnIndex::from_usize(1),\n@@ -716,7 +639,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Binders<chalk_ir::QuantifiedWhereClauses<Ru\n         let where_clauses = predicates.into_iter().map(|predicate| match predicate {\n             ty::ExistentialPredicate::Trait(ty::ExistentialTraitRef { def_id, substs }) => {\n                 chalk_ir::Binders::new(\n-                    chalk_ir::VariableKinds::empty(interner),\n+                    binders.clone(),\n                     chalk_ir::WhereClause::Implemented(chalk_ir::TraitRef {\n                         trait_id: chalk_ir::TraitId(def_id),\n                         substitution: interner\n@@ -727,25 +650,34 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Binders<chalk_ir::QuantifiedWhereClauses<Ru\n                 )\n             }\n             ty::ExistentialPredicate::Projection(predicate) => chalk_ir::Binders::new(\n-                chalk_ir::VariableKinds::empty(interner),\n+                binders.clone(),\n                 chalk_ir::WhereClause::AliasEq(chalk_ir::AliasEq {\n                     alias: chalk_ir::AliasTy::Projection(chalk_ir::ProjectionTy {\n                         associated_ty_id: chalk_ir::AssocTypeId(predicate.item_def_id),\n-                        substitution: predicate.substs.lower_into(interner),\n+                        substitution: interner\n+                            .tcx\n+                            .mk_substs_trait(self_ty, predicate.substs)\n+                            .lower_into(interner),\n                     }),\n                     ty: predicate.ty.lower_into(interner),\n                 }),\n             ),\n             ty::ExistentialPredicate::AutoTrait(def_id) => chalk_ir::Binders::new(\n-                chalk_ir::VariableKinds::empty(interner),\n+                binders.clone(),\n                 chalk_ir::WhereClause::Implemented(chalk_ir::TraitRef {\n                     trait_id: chalk_ir::TraitId(def_id),\n                     substitution: interner.tcx.mk_substs_trait(self_ty, &[]).lower_into(interner),\n                 }),\n             ),\n         });\n+\n+        // Binder for the bound variable representing the concrete underlying type.\n+        let existential_binder = chalk_ir::VariableKinds::from1(\n+            interner,\n+            chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General),\n+        );\n         let value = chalk_ir::QuantifiedWhereClauses::from_iter(interner, where_clauses);\n-        chalk_ir::Binders::new(binders, value)\n+        chalk_ir::Binders::new(existential_binder, value)\n     }\n }\n \n@@ -818,6 +750,35 @@ impl<'tcx> LowerInto<'tcx, chalk_solve::rust_ir::TraitBound<RustInterner<'tcx>>>\n     }\n }\n \n+impl<'tcx> LowerInto<'tcx, chalk_ir::Mutability> for ast::Mutability {\n+    fn lower_into(self, _interner: &RustInterner<'tcx>) -> chalk_ir::Mutability {\n+        match self {\n+            rustc_ast::Mutability::Mut => chalk_ir::Mutability::Mut,\n+            rustc_ast::Mutability::Not => chalk_ir::Mutability::Not,\n+        }\n+    }\n+}\n+\n+impl<'tcx> LowerInto<'tcx, ast::Mutability> for chalk_ir::Mutability {\n+    fn lower_into(self, _interner: &RustInterner<'tcx>) -> ast::Mutability {\n+        match self {\n+            chalk_ir::Mutability::Mut => ast::Mutability::Mut,\n+            chalk_ir::Mutability::Not => ast::Mutability::Not,\n+        }\n+    }\n+}\n+\n+impl<'tcx> LowerInto<'tcx, chalk_solve::rust_ir::Polarity> for ty::ImplPolarity {\n+    fn lower_into(self, _interner: &RustInterner<'tcx>) -> chalk_solve::rust_ir::Polarity {\n+        match self {\n+            ty::ImplPolarity::Positive => chalk_solve::rust_ir::Polarity::Positive,\n+            ty::ImplPolarity::Negative => chalk_solve::rust_ir::Polarity::Negative,\n+            // FIXME(chalk) reservation impls\n+            ty::ImplPolarity::Reservation => chalk_solve::rust_ir::Polarity::Negative,\n+        }\n+    }\n+}\n+\n impl<'tcx> LowerInto<'tcx, chalk_solve::rust_ir::AliasEqBound<RustInterner<'tcx>>>\n     for ty::ProjectionPredicate<'tcx>\n {\n@@ -910,7 +871,7 @@ impl<'tcx> TypeVisitor<'tcx> for BoundVarsCollector<'tcx> {\n             ty::Bound(debruijn, bound_ty) if debruijn == self.binder_index => {\n                 match self.parameters.entry(bound_ty.var.as_u32()) {\n                     Entry::Vacant(entry) => {\n-                        entry.insert(chalk_ir::VariableKind::Ty(chalk_ir::TyKind::General));\n+                        entry.insert(chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General));\n                     }\n                     Entry::Occupied(entry) => match entry.get() {\n                         chalk_ir::VariableKind::Ty(_) => {}"}, {"sha": "b117e28875e768649238bc790d20a7ebd21b584b", "filename": "compiler/rustc_traits/src/chalk/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0aed74aa43a3c1a98b1289a3b4febac75f844949/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aed74aa43a3c1a98b1289a3b4febac75f844949/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs?ref=0aed74aa43a3c1a98b1289a3b4febac75f844949", "patch": "@@ -69,15 +69,15 @@ crate fn evaluate_goal<'tcx>(\n                     CanonicalVarKind::PlaceholderRegion(_ui) => unimplemented!(),\n                     CanonicalVarKind::Ty(ty) => match ty {\n                         CanonicalTyVarKind::General(ui) => chalk_ir::WithKind::new(\n-                            chalk_ir::VariableKind::Ty(chalk_ir::TyKind::General),\n+                            chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::General),\n                             chalk_ir::UniverseIndex { counter: ui.index() },\n                         ),\n                         CanonicalTyVarKind::Int => chalk_ir::WithKind::new(\n-                            chalk_ir::VariableKind::Ty(chalk_ir::TyKind::Integer),\n+                            chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::Integer),\n                             chalk_ir::UniverseIndex::root(),\n                         ),\n                         CanonicalTyVarKind::Float => chalk_ir::WithKind::new(\n-                            chalk_ir::VariableKind::Ty(chalk_ir::TyKind::Float),\n+                            chalk_ir::VariableKind::Ty(chalk_ir::TyVariableKind::Float),\n                             chalk_ir::UniverseIndex::root(),\n                         ),\n                     },\n@@ -97,7 +97,8 @@ crate fn evaluate_goal<'tcx>(\n     use chalk_solve::Solver;\n     let mut solver = chalk_engine::solve::SLGSolver::new(32, None);\n     let db = ChalkRustIrDatabase { interner, reempty_placeholder };\n-    let solution = chalk_solve::logging::with_tracing_logs(|| solver.solve(&db, &lowered_goal));\n+    let solution = solver.solve(&db, &lowered_goal);\n+    debug!(?obligation, ?solution, \"evaluatate goal\");\n \n     // Ideally, the code to convert *back* to rustc types would live close to\n     // the code to convert *from* rustc types. Right now though, we don't"}, {"sha": "e596dd1a396c910d3c68ce292b139bed2c863b3b", "filename": "compiler/rustc_typeck/src/collect/item_bounds.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0aed74aa43a3c1a98b1289a3b4febac75f844949/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aed74aa43a3c1a98b1289a3b4febac75f844949/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=0aed74aa43a3c1a98b1289a3b4febac75f844949", "patch": "@@ -61,23 +61,23 @@ fn opaque_type_bounds<'tcx>(\n     bounds: &'tcx [hir::GenericBound<'tcx>],\n     span: Span,\n ) -> &'tcx [(ty::Predicate<'tcx>, Span)] {\n-    let item_ty =\n-        tcx.mk_opaque(opaque_def_id, InternalSubsts::identity_for_item(tcx, opaque_def_id));\n+    ty::print::with_no_queries(|| {\n+        let item_ty =\n+            tcx.mk_opaque(opaque_def_id, InternalSubsts::identity_for_item(tcx, opaque_def_id));\n \n-    let bounds = ty::print::with_no_queries(|| {\n-        AstConv::compute_bounds(\n+        let bounds = AstConv::compute_bounds(\n             &ItemCtxt::new(tcx, opaque_def_id),\n             item_ty,\n             bounds,\n             SizedByDefault::Yes,\n             span,\n         )\n-    });\n+        .predicates(tcx, item_ty);\n \n-    let bounds = bounds.predicates(tcx, item_ty);\n-    debug!(\"opaque_type_bounds({}) = {:?}\", tcx.def_path_str(opaque_def_id), bounds);\n+        debug!(\"opaque_type_bounds({}) = {:?}\", tcx.def_path_str(opaque_def_id), bounds);\n \n-    tcx.arena.alloc_slice(&bounds)\n+        tcx.arena.alloc_slice(&bounds)\n+    })\n }\n \n pub(super) fn explicit_item_bounds("}, {"sha": "a20acce4c76b2e64e986ddff4dbc8c93ad1bb5be", "filename": "src/test/ui/chalkify/arithmetic.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0aed74aa43a3c1a98b1289a3b4febac75f844949/src%2Ftest%2Fui%2Fchalkify%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aed74aa43a3c1a98b1289a3b4febac75f844949/src%2Ftest%2Fui%2Fchalkify%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Farithmetic.rs?ref=0aed74aa43a3c1a98b1289a3b4febac75f844949", "patch": "@@ -0,0 +1,20 @@\n+// check-pass\n+// compile-flags: -Z chalk\n+\n+fn main() {\n+    1 + 2;\n+    3 * 6;\n+    2 - 5;\n+    17 / 6;\n+    23 % 11;\n+    4 & 6;\n+    7 | 15;\n+    4 << 7;\n+    123 >> 3;\n+    1 == 2;\n+    5 != 5;\n+    6 < 2;\n+    7 > 11;\n+    3 <= 1;\n+    9 >= 14;\n+}"}, {"sha": "13d9e6a6578856fd89c5a359bcf2f4434280ce0c", "filename": "src/test/ui/chalkify/trait-objects.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0aed74aa43a3c1a98b1289a3b4febac75f844949/src%2Ftest%2Fui%2Fchalkify%2Ftrait-objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0aed74aa43a3c1a98b1289a3b4febac75f844949/src%2Ftest%2Fui%2Fchalkify%2Ftrait-objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftrait-objects.rs?ref=0aed74aa43a3c1a98b1289a3b4febac75f844949", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+// compile-flags: -Z chalk\n+\n+use std::fmt::Display;\n+\n+fn main() {\n+    let d: &dyn Display = &mut 3;\n+    // FIXME(chalk) should be able to call d.to_string() as well, but doing so\n+    // requires Chalk to be able to prove trait object well-formed goals.\n+    (&d).to_string();\n+    let f: &dyn Fn(i32) -> _ = &|x| x + x;\n+    f(2);\n+}"}]}