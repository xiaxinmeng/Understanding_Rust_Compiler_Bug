{"sha": "4ea03c876ba864946ed50fde7788cfe2383027f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlYTAzYzg3NmJhODY0OTQ2ZWQ1MGZkZTc3ODhjZmUyMzgzMDI3ZjE=", "commit": {"author": {"name": "projektir", "email": "oprojektir@gmail.com", "date": "2017-03-29T04:52:16Z"}, "committer": {"name": "projektir", "email": "oprojektir@gmail.com", "date": "2017-03-29T04:52:16Z"}, "message": "Fixing formatting issues #29377", "tree": {"sha": "1d596bd8285c91ca4d56e83db61c1f16c94c647e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d596bd8285c91ca4d56e83db61c1f16c94c647e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ea03c876ba864946ed50fde7788cfe2383027f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ea03c876ba864946ed50fde7788cfe2383027f1", "html_url": "https://github.com/rust-lang/rust/commit/4ea03c876ba864946ed50fde7788cfe2383027f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ea03c876ba864946ed50fde7788cfe2383027f1/comments", "author": {"login": "projektir", "id": 16269746, "node_id": "MDQ6VXNlcjE2MjY5NzQ2", "avatar_url": "https://avatars.githubusercontent.com/u/16269746?v=4", "gravatar_id": "", "url": "https://api.github.com/users/projektir", "html_url": "https://github.com/projektir", "followers_url": "https://api.github.com/users/projektir/followers", "following_url": "https://api.github.com/users/projektir/following{/other_user}", "gists_url": "https://api.github.com/users/projektir/gists{/gist_id}", "starred_url": "https://api.github.com/users/projektir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/projektir/subscriptions", "organizations_url": "https://api.github.com/users/projektir/orgs", "repos_url": "https://api.github.com/users/projektir/repos", "events_url": "https://api.github.com/users/projektir/events{/privacy}", "received_events_url": "https://api.github.com/users/projektir/received_events", "type": "User", "site_admin": false}, "committer": {"login": "projektir", "id": 16269746, "node_id": "MDQ6VXNlcjE2MjY5NzQ2", "avatar_url": "https://avatars.githubusercontent.com/u/16269746?v=4", "gravatar_id": "", "url": "https://api.github.com/users/projektir", "html_url": "https://github.com/projektir", "followers_url": "https://api.github.com/users/projektir/followers", "following_url": "https://api.github.com/users/projektir/following{/other_user}", "gists_url": "https://api.github.com/users/projektir/gists{/gist_id}", "starred_url": "https://api.github.com/users/projektir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/projektir/subscriptions", "organizations_url": "https://api.github.com/users/projektir/orgs", "repos_url": "https://api.github.com/users/projektir/repos", "events_url": "https://api.github.com/users/projektir/events{/privacy}", "received_events_url": "https://api.github.com/users/projektir/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "756f2248f73d2ea2703a65855c52086a1262a290", "url": "https://api.github.com/repos/rust-lang/rust/commits/756f2248f73d2ea2703a65855c52086a1262a290", "html_url": "https://github.com/rust-lang/rust/commit/756f2248f73d2ea2703a65855c52086a1262a290"}], "stats": {"total": 80, "additions": 42, "deletions": 38}, "files": [{"sha": "ae47e6fdfa928ee6b037d9d7e1c1e80cd74bfdfc", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 42, "deletions": 38, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/4ea03c876ba864946ed50fde7788cfe2383027f1/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ea03c876ba864946ed50fde7788cfe2383027f1/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=4ea03c876ba864946ed50fde7788cfe2383027f1", "patch": "@@ -39,7 +39,7 @@\n //! atomically-reference-counted shared pointer).\n //!\n //! [`Sync`]: ../../marker/trait.Sync.html\n-//! [arc]: ../struct.Arc.html\n+//! [arc]: ../../../std/sync/struct.Arc.html\n //!\n //! Most atomic types may be stored in static variables, initialized using\n //! the provided static initializers like [`ATOMIC_BOOL_INIT`]. Atomic statics\n@@ -158,27 +158,32 @@ unsafe impl<T> Sync for AtomicPtr<T> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Copy, Clone, Debug)]\n pub enum Ordering {\n-    /// No ordering constraints, only atomic operations. Corresponds to LLVM's\n-    /// [`Monotonic`][1] ordering.\n-    /// [1]: http://llvm.org/docs/Atomics.html#monotonic\n+    /// No ordering constraints, only atomic operations.\n+    ///\n+    /// Corresponds to LLVM's [`Monotonic`] ordering.\n+    ///\n+    /// [`Monotonic`]: http://llvm.org/docs/Atomics.html#monotonic\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Relaxed,\n     /// When coupled with a store, all previous writes become visible\n-    /// to the other threads that perform a load with [`Acquire`][1] ordering\n+    /// to the other threads that perform a load with [`Acquire`] ordering\n     /// on the same value.\n-    /// [1]: http://llvm.org/docs/Atomics.html#acquire\n+    ///\n+    /// [`Acquire`]: http://llvm.org/docs/Atomics.html#acquire\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Release,\n     /// When coupled with a load, all subsequent loads will see data\n-    /// written before a store with [`Release`][1] ordering on the same value\n+    /// written before a store with [`Release`] ordering on the same value\n     /// in other threads.\n-    /// [1]: http://llvm.org/docs/Atomics.html#release\n+    ///\n+    /// [`Release`]: http://llvm.org/docs/Atomics.html#release\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Acquire,\n-    /// When coupled with a load, uses [`Acquire`][1] ordering, and with a store\n-    /// [`Release`][2] ordering.\n-    /// [1]: http://llvm.org/docs/Atomics.html#acquire\n-    /// [2]: http://llvm.org/docs/Atomics.html#release\n+    /// When coupled with a load, uses [`Acquire`] ordering, and with a store\n+    /// [`Release`] ordering.\n+    ///\n+    /// [`Acquire`]: http://llvm.org/docs/Atomics.html#acquire\n+    /// [`Release`]: http://llvm.org/docs/Atomics.html#release\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     AcqRel,\n     /// Like `AcqRel` with the additional guarantee that all threads see all\n@@ -192,6 +197,7 @@ pub enum Ordering {\n }\n \n /// An [`AtomicBool`] initialized to `false`.\n+///\n /// [`AtomicBool`]: struct.AtomicBool.html\n #[cfg(target_has_atomic = \"8\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -257,7 +263,7 @@ impl AtomicBool {\n \n     /// Loads a value from the bool.\n     ///\n-    /// `load()` takes an [`Ordering`] argument which describes the memory ordering\n+    /// `load` takes an [`Ordering`] argument which describes the memory ordering\n     /// of this operation.\n     ///\n     /// # Panics\n@@ -285,7 +291,7 @@ impl AtomicBool {\n \n     /// Stores a value into the bool.\n     ///\n-    /// `store()` takes an [`Ordering`] argument which describes the memory ordering\n+    /// `store` takes an [`Ordering`] argument which describes the memory ordering\n     /// of this operation.\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n@@ -317,7 +323,7 @@ impl AtomicBool {\n \n     /// Stores a value into the bool, returning the old value.\n     ///\n-    /// `swap()` takes an [`Ordering`] argument which describes the memory ordering\n+    /// `swap` takes an [`Ordering`] argument which describes the memory ordering\n     /// of this operation.\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n@@ -343,7 +349,7 @@ impl AtomicBool {\n     /// The return value is always the previous value. If it is equal to `current`, then the value\n     /// was updated.\n     ///\n-    /// `compare_and_swap()` also takes an [`Ordering`] argument which describes the memory\n+    /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n     /// ordering of this operation.\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n@@ -375,7 +381,7 @@ impl AtomicBool {\n     /// The return value is a result indicating whether the new value was written and containing\n     /// the previous value. On success this value is guaranteed to be equal to `current`.\n     ///\n-    /// `compare_exchange()` takes two [`Ordering`] arguments to describe the memory\n+    /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n     /// ordering of this operation. The first describes the required ordering if the\n     /// operation succeeds while the second describes the required ordering when the\n     /// operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and must\n@@ -423,18 +429,18 @@ impl AtomicBool {\n \n     /// Stores a value into the `bool` if the current value is the same as the `current` value.\n     ///\n-    /// Unlike [`compare_exchange()`], this function is allowed to spuriously fail even when the\n+    /// Unlike [`compare_exchange`], this function is allowed to spuriously fail even when the\n     /// comparison succeeds, which can result in more efficient code on some platforms. The\n     /// return value is a result indicating whether the new value was written and containing the\n     /// previous value.\n     ///\n-    /// `compare_exchange_weak()` takes two [`Ordering`] arguments to describe the memory\n+    /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n     /// ordering of this operation. The first describes the required ordering if the operation\n     /// succeeds while the second describes the required ordering when the operation fails. The\n     /// failure ordering can't be [`Release`] or [`AcqRel`] and must be equivalent or\n     /// weaker than the success ordering.\n     ///\n-    /// [`compare_exchange()`]: #method.compare_exchange\n+    /// [`compare_exchange`]: #method.compare_exchange\n     /// [`Ordering`]: enum.Ordering.html\n     /// [`Release`]: enum.Ordering.html#variant.Release\n     /// [`AcqRel`]: enum.Ordering.html#variant.Release\n@@ -665,7 +671,7 @@ impl<T> AtomicPtr<T> {\n \n     /// Loads a value from the pointer.\n     ///\n-    /// `load()` takes an [`Ordering`] argument which describes the memory ordering\n+    /// `load` takes an [`Ordering`] argument which describes the memory ordering\n     /// of this operation.\n     ///\n     /// # Panics\n@@ -694,7 +700,7 @@ impl<T> AtomicPtr<T> {\n \n     /// Stores a value into the pointer.\n     ///\n-    /// `store()` takes an [`Ordering`] argument which describes the memory ordering\n+    /// `store` takes an [`Ordering`] argument which describes the memory ordering\n     /// of this operation.\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n@@ -718,7 +724,6 @@ impl<T> AtomicPtr<T> {\n     ///\n     /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n     /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n-    ///\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn store(&self, ptr: *mut T, order: Ordering) {\n@@ -729,7 +734,7 @@ impl<T> AtomicPtr<T> {\n \n     /// Stores a value into the pointer, returning the old value.\n     ///\n-    /// `swap()` takes an [`Ordering`] argument which describes the memory ordering\n+    /// `swap` takes an [`Ordering`] argument which describes the memory ordering\n     /// of this operation.\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n@@ -757,7 +762,7 @@ impl<T> AtomicPtr<T> {\n     /// The return value is always the previous value. If it is equal to `current`, then the value\n     /// was updated.\n     ///\n-    /// `compare_and_swap()` also takes an [`Ordering`] argument which describes the memory\n+    /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n     /// ordering of this operation.\n     ///\n     /// [`Ordering`]: enum.Ordering.html\n@@ -789,7 +794,7 @@ impl<T> AtomicPtr<T> {\n     /// The return value is a result indicating whether the new value was written and containing\n     /// the previous value. On success this value is guaranteed to be equal to `current`.\n     ///\n-    /// `compare_exchange()` takes two [`Ordering`] arguments to describe the memory\n+    /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n     /// ordering of this operation. The first describes the required ordering if\n     /// the operation succeeds while the second describes the required ordering when\n     /// the operation fails. The failure ordering can't be [`Release`] or [`AcqRel`]\n@@ -836,18 +841,18 @@ impl<T> AtomicPtr<T> {\n \n     /// Stores a value into the pointer if the current value is the same as the `current` value.\n     ///\n-    /// Unlike [`compare_exchange()`], this function is allowed to spuriously fail even when the\n+    /// Unlike [`compare_exchange`], this function is allowed to spuriously fail even when the\n     /// comparison succeeds, which can result in more efficient code on some platforms. The\n     /// return value is a result indicating whether the new value was written and containing the\n     /// previous value.\n     ///\n-    /// `compare_exchange_weak()` takes two [`Ordering`] arguments to describe the memory\n+    /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n     /// ordering of this operation. The first describes the required ordering if the operation\n     /// succeeds while the second describes the required ordering when the operation fails. The\n     /// failure ordering can't be [`Release`] or [`AcqRel`] and must be equivalent or\n     /// weaker than the success ordering.\n     ///\n-    /// [`compare_exchange()`]: #method.compare_exchange\n+    /// [`compare_exchange`]: #method.compare_exchange\n     /// [`Ordering`]: enum.Ordering.html\n     /// [`Release`]: enum.Ordering.html#variant.Release\n     /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n@@ -986,7 +991,7 @@ macro_rules! atomic_int {\n \n             /// Loads a value from the atomic integer.\n             ///\n-            /// `load()` takes an [`Ordering`] argument which describes the memory ordering of this\n+            /// `load` takes an [`Ordering`] argument which describes the memory ordering of this\n             /// operation.\n             ///\n             /// # Panics\n@@ -1014,7 +1019,7 @@ macro_rules! atomic_int {\n \n             /// Stores a value into the atomic integer.\n             ///\n-            /// `store()` takes an [`Ordering`] argument which describes the memory ordering of this\n+            /// `store` takes an [`Ordering`] argument which describes the memory ordering of this\n             /// operation.\n             ///\n             /// [`Ordering`]: enum.Ordering.html\n@@ -1036,7 +1041,6 @@ macro_rules! atomic_int {\n             ///\n             /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n             /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n-            ///\n             #[inline]\n             #[$stable]\n             pub fn store(&self, val: $int_type, order: Ordering) {\n@@ -1045,7 +1049,7 @@ macro_rules! atomic_int {\n \n             /// Stores a value into the atomic integer, returning the old value.\n             ///\n-            /// `swap()` takes an [`Ordering`] argument which describes the memory ordering of this\n+            /// `swap` takes an [`Ordering`] argument which describes the memory ordering of this\n             /// operation.\n             ///\n             /// [`Ordering`]: enum.Ordering.html\n@@ -1071,7 +1075,7 @@ macro_rules! atomic_int {\n             /// The return value is always the previous value. If it is equal to `current`, then the\n             /// value was updated.\n             ///\n-            /// `compare_and_swap()` also takes an [`Ordering`] argument which describes the memory\n+            /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n             /// ordering of this operation.\n             ///\n             /// [`Ordering`]: enum.Ordering.html\n@@ -1111,7 +1115,7 @@ macro_rules! atomic_int {\n             /// containing the previous value. On success this value is guaranteed to be equal to\n             /// `current`.\n             ///\n-            /// `compare_exchange()` takes two [`Ordering`] arguments to describe the memory\n+            /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n             /// ordering of this operation. The first describes the required ordering if\n             /// the operation succeeds while the second describes the required ordering when\n             /// the operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n@@ -1153,18 +1157,18 @@ macro_rules! atomic_int {\n             /// Stores a value into the atomic integer if the current value is the same as the\n             /// `current` value.\n             ///\n-            /// Unlike [`compare_exchange()`], this function is allowed to spuriously fail even\n+            /// Unlike [`compare_exchange`], this function is allowed to spuriously fail even\n             /// when the comparison succeeds, which can result in more efficient code on some\n             /// platforms. The return value is a result indicating whether the new value was\n             /// written and containing the previous value.\n             ///\n-            /// `compare_exchange_weak()` takes two [`Ordering`] arguments to describe the memory\n+            /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n             /// ordering of this operation. The first describes the required ordering if the\n             /// operation succeeds while the second describes the required ordering when the\n             /// operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n             /// must be equivalent or weaker than the success ordering.\n             ///\n-            /// [`compare_exchange()`]: #method.compare_exchange\n+            /// [`compare_exchange`]: #method.compare_exchange\n             /// [`Ordering`]: enum.Ordering.html\n             /// [`Release`]: enum.Ordering.html#variant.Release\n             /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel"}]}