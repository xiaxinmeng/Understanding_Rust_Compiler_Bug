{"sha": "990f193f6a2a469ff710d07238508b2ecf5e51f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5MGYxOTNmNmEyYTQ2OWZmNzEwZDA3MjM4NTA4YjJlY2Y1ZTUxZjE=", "commit": {"author": {"name": "Jonathan A. Kollasch", "email": "jakllsch@kollasch.net", "date": "2016-07-28T16:57:40Z"}, "committer": {"name": "Jonathan A. Kollasch", "email": "jakllsch@kollasch.net", "date": "2016-07-28T16:57:40Z"}, "message": "Merge remote-tracking branch 'upstream/master' into remaining_cpu_x86-64", "tree": {"sha": "a31208092cbb1204f5c4c77ad8a6ad88112dd5f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a31208092cbb1204f5c4c77ad8a6ad88112dd5f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/990f193f6a2a469ff710d07238508b2ecf5e51f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/990f193f6a2a469ff710d07238508b2ecf5e51f1", "html_url": "https://github.com/rust-lang/rust/commit/990f193f6a2a469ff710d07238508b2ecf5e51f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/990f193f6a2a469ff710d07238508b2ecf5e51f1/comments", "author": {"login": "jakllsch", "id": 2145119, "node_id": "MDQ6VXNlcjIxNDUxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2145119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakllsch", "html_url": "https://github.com/jakllsch", "followers_url": "https://api.github.com/users/jakllsch/followers", "following_url": "https://api.github.com/users/jakllsch/following{/other_user}", "gists_url": "https://api.github.com/users/jakllsch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakllsch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakllsch/subscriptions", "organizations_url": "https://api.github.com/users/jakllsch/orgs", "repos_url": "https://api.github.com/users/jakllsch/repos", "events_url": "https://api.github.com/users/jakllsch/events{/privacy}", "received_events_url": "https://api.github.com/users/jakllsch/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakllsch", "id": 2145119, "node_id": "MDQ6VXNlcjIxNDUxMTk=", "avatar_url": "https://avatars.githubusercontent.com/u/2145119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakllsch", "html_url": "https://github.com/jakllsch", "followers_url": "https://api.github.com/users/jakllsch/followers", "following_url": "https://api.github.com/users/jakllsch/following{/other_user}", "gists_url": "https://api.github.com/users/jakllsch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakllsch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakllsch/subscriptions", "organizations_url": "https://api.github.com/users/jakllsch/orgs", "repos_url": "https://api.github.com/users/jakllsch/repos", "events_url": "https://api.github.com/users/jakllsch/events{/privacy}", "received_events_url": "https://api.github.com/users/jakllsch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f86005fc09eceb6b19507c466b9674013425521", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f86005fc09eceb6b19507c466b9674013425521", "html_url": "https://github.com/rust-lang/rust/commit/1f86005fc09eceb6b19507c466b9674013425521"}, {"sha": "cec262e55a92ad15196c4ea6d490fb6ef6bccab4", "url": "https://api.github.com/repos/rust-lang/rust/commits/cec262e55a92ad15196c4ea6d490fb6ef6bccab4", "html_url": "https://github.com/rust-lang/rust/commit/cec262e55a92ad15196c4ea6d490fb6ef6bccab4"}], "stats": {"total": 3122, "additions": 1820, "deletions": 1302}, "files": [{"sha": "0259db221b6bc0dbaa0a47c94e7386eec91d22a3", "filename": "src/doc/book/syntax-index.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Fdoc%2Fbook%2Fsyntax-index.md", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Fdoc%2Fbook%2Fsyntax-index.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsyntax-index.md?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -94,7 +94,7 @@\n * `|` (`|\u2026| expr`): closures.  See [Closures].\n * `|=` (`var |= expr`): bitwise or & assignment. Overloadable (`BitOrAssign`).\n * `||` (`expr || expr`): logical or.\n-* `_`: \"ignored\" pattern binding.  See [Patterns (Ignoring bindings)].\n+* `_`: \"ignored\" pattern binding (see [Patterns (Ignoring bindings)]). Also used to make integer-literals readable (see [Reference (Integer literals)]).\n \n ## Other Syntax\n \n@@ -231,6 +231,7 @@\n [Primitive Types (Tuples)]: primitive-types.html#tuples\n [Raw Pointers]: raw-pointers.html\n [Reference (Byte String Literals)]: ../reference.html#byte-string-literals\n+[Reference (Integer literals)]: ../reference.html#integer-literals\n [Reference (Raw Byte String Literals)]: ../reference.html#raw-byte-string-literals\n [Reference (Raw String Literals)]: ../reference.html#raw-string-literals\n [References and Borrowing]: references-and-borrowing.html"}, {"sha": "b1aee579aabc26ae560c72e7187532fc0fd95c00", "filename": "src/doc/book/trait-objects.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Fdoc%2Fbook%2Ftrait-objects.md", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Fdoc%2Fbook%2Ftrait-objects.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Ftrait-objects.md?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -123,7 +123,6 @@ dispatch with trait objects by casting:\n # trait Foo { fn method(&self) -> String; }\n # impl Foo for u8 { fn method(&self) -> String { format!(\"u8: {}\", *self) } }\n # impl Foo for String { fn method(&self) -> String { format!(\"string: {}\", *self) } }\n-\n fn do_something(x: &Foo) {\n     x.method();\n }\n@@ -140,7 +139,6 @@ or by coercing:\n # trait Foo { fn method(&self) -> String; }\n # impl Foo for u8 { fn method(&self) -> String { format!(\"u8: {}\", *self) } }\n # impl Foo for String { fn method(&self) -> String { format!(\"string: {}\", *self) } }\n-\n fn do_something(x: &Foo) {\n     x.method();\n }"}, {"sha": "189695716deb1bb776f46aee347699529bcd42c4", "filename": "src/doc/nomicon/phantom-data.md", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Fdoc%2Fnomicon%2Fphantom-data.md", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Fdoc%2Fnomicon%2Fphantom-data.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon%2Fphantom-data.md?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -50,7 +50,7 @@ struct Vec<T> {\n }\n ```\n \n-Unlike the previous example it *appears* that everything is exactly as we\n+Unlike the previous example, it *appears* that everything is exactly as we\n want. Every generic argument to Vec shows up in at least one field.\n Good to go!\n \n@@ -84,4 +84,3 @@ standard library made a utility for itself called `Unique<T>` which:\n * includes a `PhantomData<T>`\n * auto-derives Send/Sync as if T was contained\n * marks the pointer as NonZero for the null-pointer optimization\n-"}, {"sha": "a461023642afd6130df80eaf0b95de7c0cd32021", "filename": "src/doc/reference.md", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -1653,14 +1653,43 @@ the Rust ABI and the foreign ABI.\n A number of [attributes](#ffi-attributes) control the behavior of external blocks.\n \n By default external blocks assume that the library they are calling uses the\n-standard C \"cdecl\" ABI. Other ABIs may be specified using an `abi` string, as\n-shown here:\n+standard C ABI on the specific platform. Other ABIs may be specified using an\n+`abi` string, as shown here:\n \n ```ignore\n // Interface to the Windows API\n extern \"stdcall\" { }\n ```\n \n+There are three ABI strings which are cross-platform, and which all compilers\n+are guaranteed to support:\n+\n+* `extern \"Rust\"` -- The default ABI when you write a normal `fn foo()` in any\n+  Rust code.\n+* `extern \"C\"` -- This is the same as `extern fn foo()`; whatever the default\n+  your C compiler supports.\n+* `extern \"system\"` -- Usually the same as `extern \"C\"`, except on Win32, in\n+  which case it's `\"stdcall\"`, or what you should use to link to the Windows API\n+  itself\n+\n+There are also some platform-specific ABI strings:\n+\n+* `extern \"cdecl\"` -- The default for x86\\_32 C code.\n+* `extern \"stdcall\"` -- The default for the Win32 API on x86\\_32.\n+* `extern \"win64\"` -- The default for C code on x86\\_64 Windows.\n+* `extern \"aapcs\"` -- The default for ARM.\n+* `extern \"fastcall\"` -- The `fastcall` ABI -- corresponds to MSVC's\n+  `__fastcall` and GCC and clang's `__attribute__((fastcall))`\n+* `extern \"vectorcall\"` -- The `vectorcall` ABI -- corresponds to MSVC's\n+  `__vectorcall` and clang's `__attribute__((vectorcall))`\n+\n+Finally, there are some rustc-specific ABI strings:\n+\n+* `extern \"rust-intrinsic\"` -- The ABI of rustc intrinsics.\n+* `extern \"rust-call\"` -- The ABI of the Fn::call trait functions.\n+* `extern \"platform-intrinsic\"` -- Specific platform intrinsics -- like, for\n+  example, `sqrt` -- have this ABI. You should never have to deal with it.\n+\n The `link` attribute allows the name of the library to be specified. When\n specified the compiler will attempt to link against the native library of the\n specified name."}, {"sha": "64b780413f884f4a33045525a98d83717d6053e5", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -21,6 +21,10 @@\n //!\n //! Sharing some immutable data between threads:\n //!\n+// Note that we **do not** run these tests here. The windows builders get super\n+// unhappy of a thread outlives the main thread and then exits at the same time\n+// (something deadlocks) so we just avoid this entirely by not running these\n+// tests.\n //! ```no_run\n //! use std::sync::Arc;\n //! use std::thread;\n@@ -97,7 +101,8 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// by putting it inside `Mutex` and then share `Mutex` immutably\n /// with `Arc<T>` as shown below.\n ///\n-/// ```\n+// See comment at the top of this file for why the test is no_run\n+/// ```no_run\n /// use std::sync::{Arc, Mutex};\n /// use std::thread;\n ///"}, {"sha": "ccef6c02f9d22f4d15aa3aded94270d16d847a9e", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 31, "deletions": 6, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -691,15 +691,40 @@ impl<T> [T] {\n     ///\n     /// # Examples\n     ///\n-    /// Print the slice split by numbers divisible by 3 (i.e. `[10, 40]`,\n-    /// `[20]`, `[50]`):\n+    /// ```\n+    /// let slice = [10, 40, 33, 20];\n+    /// let mut iter = slice.split(|num| num % 3 == 0);\n     ///\n+    /// assert_eq!(iter.next().unwrap(), &[10, 40]);\n+    /// assert_eq!(iter.next().unwrap(), &[20]);\n+    /// assert!(iter.next().is_none());\n     /// ```\n-    /// let v = [10, 40, 30, 20, 60, 50];\n     ///\n-    /// for group in v.split(|num| *num % 3 == 0) {\n-    ///     println!(\"{:?}\", group);\n-    /// }\n+    /// If the first element is matched, an empty slice will be the first item\n+    /// returned by the iterator. Similarly, if the last element in the slice\n+    /// is matched, an empty slice will be the last item returned by the\n+    /// iterator:\n+    ///\n+    /// ```\n+    /// let slice = [10, 40, 33];\n+    /// let mut iter = slice.split(|num| num % 3 == 0);\n+    ///\n+    /// assert_eq!(iter.next().unwrap(), &[10, 40]);\n+    /// assert_eq!(iter.next().unwrap(), &[]);\n+    /// assert!(iter.next().is_none());\n+    /// ```\n+    ///\n+    /// If two matched elements are directly adjacent, an empty slice will be\n+    /// present between them:\n+    ///\n+    /// ```\n+    /// let slice = [10, 6, 33, 20];\n+    /// let mut iter = slice.split(|num| num % 3 == 0);\n+    ///\n+    /// assert_eq!(iter.next().unwrap(), &[10]);\n+    /// assert_eq!(iter.next().unwrap(), &[]);\n+    /// assert_eq!(iter.next().unwrap(), &[20]);\n+    /// assert!(iter.next().is_none());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]"}, {"sha": "275f38b2f787d469a8596be0b0d6bcce64fc3b19", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -73,6 +73,7 @@ use core::mem;\n use core::ops::{Index, IndexMut};\n use core::ops;\n use core::ptr;\n+use core::ptr::Shared;\n use core::slice;\n \n use super::SpecExtend;\n@@ -899,8 +900,8 @@ impl<T> Vec<T> {\n             Drain {\n                 tail_start: end,\n                 tail_len: len - end,\n-                iter: range_slice.iter_mut(),\n-                vec: self as *mut _,\n+                iter: range_slice.iter(),\n+                vec: Shared::new(self as *mut _),\n             }\n         }\n     }\n@@ -1806,8 +1807,8 @@ pub struct Drain<'a, T: 'a> {\n     /// Length of tail\n     tail_len: usize,\n     /// Current remaining range to remove\n-    iter: slice::IterMut<'a, T>,\n-    vec: *mut Vec<T>,\n+    iter: slice::Iter<'a, T>,\n+    vec: Shared<Vec<T>>,\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n@@ -1845,7 +1846,7 @@ impl<'a, T> Drop for Drain<'a, T> {\n \n         if self.tail_len > 0 {\n             unsafe {\n-                let source_vec = &mut *self.vec;\n+                let source_vec = &mut **self.vec;\n                 // memmove back untouched tail, update to new length\n                 let start = source_vec.len();\n                 let tail = self.tail_start;"}, {"sha": "9c3792afa2f1c91b5e87e234f1258028d2dc5f30", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -402,6 +402,8 @@ impl<T> VecDeque<T> {\n \n     /// Retrieves an element in the `VecDeque` by index.\n     ///\n+    /// Element at index 0 is the front of the queue.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -425,6 +427,8 @@ impl<T> VecDeque<T> {\n \n     /// Retrieves an element in the `VecDeque` mutably by index.\n     ///\n+    /// Element at index 0 is the front of the queue.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -456,6 +460,8 @@ impl<T> VecDeque<T> {\n     ///\n     /// Fails if there is no element with either index.\n     ///\n+    /// Element at index 0 is the front of the queue.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1180,6 +1186,8 @@ impl<T> VecDeque<T> {\n     ///\n     /// Returns `None` if `index` is out of bounds.\n     ///\n+    /// Element at index 0 is the front of the queue.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1214,6 +1222,8 @@ impl<T> VecDeque<T> {\n     ///\n     /// Returns `None` if `index` is out of bounds.\n     ///\n+    /// Element at index 0 is the front of the queue.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1245,6 +1255,8 @@ impl<T> VecDeque<T> {\n     /// end is closer to the insertion point will be moved to make room,\n     /// and all the affected elements will be moved to new positions.\n     ///\n+    /// Element at index 0 is the front of the queue.\n+    ///\n     /// # Panics\n     ///\n     /// Panics if `index` is greater than `VecDeque`'s length\n@@ -1472,6 +1484,8 @@ impl<T> VecDeque<T> {\n     /// room, and all the affected elements will be moved to new positions.\n     /// Returns `None` if `index` is out of bounds.\n     ///\n+    /// Element at index 0 is the front of the queue.\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1651,6 +1665,8 @@ impl<T> VecDeque<T> {\n     ///\n     /// Note that the capacity of `self` does not change.\n     ///\n+    /// Element at index 0 is the front of the queue.\n+    ///\n     /// # Panics\n     ///\n     /// Panics if `at > len`"}, {"sha": "e2a57bd8d3862df021cf5325a4c68a5b926901d8", "filename": "src/libcollectionstest/binary_heap.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibcollectionstest%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibcollectionstest%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fbinary_heap.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use std::collections::BinaryHeap;\n+use std::collections::binary_heap::Drain;\n \n #[test]\n fn test_iterator() {\n@@ -292,3 +293,8 @@ fn test_extend_specialization() {\n \n     assert_eq!(a.into_sorted_vec(), [-20, -10, 1, 2, 3, 3, 5, 43]);\n }\n+\n+#[allow(dead_code)]\n+fn assert_covariance() {\n+    fn drain<'new>(d: Drain<'static, &'static str>) -> Drain<'new, &'new str> { d }\n+}"}, {"sha": "7a6bd958a5f8c7cb915c5756e055d1d25a65be78", "filename": "src/libcollectionstest/vec.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibcollectionstest%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibcollectionstest%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fvec.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -11,6 +11,7 @@\n use std::borrow::Cow;\n use std::iter::{FromIterator, repeat};\n use std::mem::size_of;\n+use std::vec::Drain;\n \n use test::Bencher;\n \n@@ -510,6 +511,11 @@ fn test_cow_from() {\n     }\n }\n \n+#[allow(dead_code)]\n+fn assert_covariance() {\n+    fn drain<'new>(d: Drain<'static, &'static str>) -> Drain<'new, &'new str> { d }\n+}\n+\n #[bench]\n fn bench_new(b: &mut Bencher) {\n     b.iter(|| {"}, {"sha": "c645608dda7902ed3189dbe7ad6af7b948fdf1b4", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 188, "deletions": 5, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -277,17 +277,200 @@ extern \"rust-intrinsic\" {\n     /// Moves a value out of scope without running drop glue.\n     pub fn forget<T>(_: T) -> ();\n \n-    /// Unsafely transforms a value of one type into a value of another type.\n+    /// Reinterprets the bits of a value of one type as another type; both types\n+    /// must have the same size. Neither the original, nor the result, may be an\n+    /// [invalid value] (../../nomicon/meet-safe-and-unsafe.html).\n     ///\n-    /// Both types must have the same size.\n+    /// `transmute` is semantically equivalent to a bitwise move of one type\n+    /// into another. It copies the bits from the destination type into the\n+    /// source type, then forgets the original. It's equivalent to C's `memcpy`\n+    /// under the hood, just like `transmute_copy`.\n+    ///\n+    /// `transmute` is incredibly unsafe. There are a vast number of ways to\n+    /// cause undefined behavior with this function. `transmute` should be\n+    /// the absolute last resort.\n+    ///\n+    /// The [nomicon](../../nomicon/transmutes.html) has additional\n+    /// documentation.\n     ///\n     /// # Examples\n     ///\n+    /// There are a few things that `transmute` is really useful for.\n+    ///\n+    /// Getting the bitpattern of a floating point type (or, more generally,\n+    /// type punning, when `T` and `U` aren't pointers):\n+    ///\n     /// ```\n-    /// use std::mem;\n+    /// let bitpattern = unsafe {\n+    ///     std::mem::transmute::<f32, u32>(1.0)\n+    /// };\n+    /// assert_eq!(bitpattern, 0x3F800000);\n+    /// ```\n+    ///\n+    /// Turning a pointer into a function pointer:\n+    ///\n+    /// ```\n+    /// fn foo() -> i32 {\n+    ///     0\n+    /// }\n+    /// let pointer = foo as *const ();\n+    /// let function = unsafe {\n+    ///     std::mem::transmute::<*const (), fn() -> i32>(pointer)\n+    /// };\n+    /// assert_eq!(function(), 0);\n+    /// ```\n+    ///\n+    /// Extending a lifetime, or shortening an invariant lifetime; this is\n+    /// advanced, very unsafe rust:\n+    ///\n+    /// ```\n+    /// struct R<'a>(&'a i32);\n+    /// unsafe fn extend_lifetime<'b>(r: R<'b>) -> R<'static> {\n+    ///     std::mem::transmute::<R<'b>, R<'static>>(r)\n+    /// }\n+    ///\n+    /// unsafe fn shorten_invariant_lifetime<'b, 'c>(r: &'b mut R<'static>)\n+    ///                                              -> &'b mut R<'c> {\n+    ///     std::mem::transmute::<&'b mut R<'static>, &'b mut R<'c>>(r)\n+    /// }\n+    /// ```\n+    ///\n+    /// # Alternatives\n+    ///\n+    /// However, many uses of `transmute` can be achieved through other means.\n+    /// `transmute` can transform any type into any other, with just the caveat\n+    /// that they're the same size, and often interesting results occur. Below\n+    /// are common applications of `transmute` which can be replaced with safe\n+    /// applications of `as`:\n     ///\n-    /// let array: &[u8] = unsafe { mem::transmute(\"Rust\") };\n-    /// assert_eq!(array, [82, 117, 115, 116]);\n+    /// Turning a pointer into a `usize`:\n+    ///\n+    /// ```\n+    /// let ptr = &0;\n+    /// let ptr_num_transmute = unsafe {\n+    ///     std::mem::transmute::<&i32, usize>(ptr)\n+    /// };\n+    /// // Use an `as` cast instead\n+    /// let ptr_num_cast = ptr as *const i32 as usize;\n+    /// ```\n+    ///\n+    /// Turning a `*mut T` into an `&mut T`:\n+    ///\n+    /// ```\n+    /// let ptr: *mut i32 = &mut 0;\n+    /// let ref_transmuted = unsafe {\n+    ///     std::mem::transmute::<*mut i32, &mut i32>(ptr)\n+    /// };\n+    /// // Use a reborrow instead\n+    /// let ref_casted = unsafe { &mut *ptr };\n+    /// ```\n+    ///\n+    /// Turning an `&mut T` into an `&mut U`:\n+    ///\n+    /// ```\n+    /// let ptr = &mut 0;\n+    /// let val_transmuted = unsafe {\n+    ///     std::mem::transmute::<&mut i32, &mut u32>(ptr)\n+    /// };\n+    /// // Now, put together `as` and reborrowing - note the chaining of `as`\n+    /// // `as` is not transitive\n+    /// let val_casts = unsafe { &mut *(ptr as *mut i32 as *mut u32) };\n+    /// ```\n+    ///\n+    /// Turning an `&str` into an `&[u8]`:\n+    ///\n+    /// ```\n+    /// // this is not a good way to do this.\n+    /// let slice = unsafe { std::mem::transmute::<&str, &[u8]>(\"Rust\") };\n+    /// assert_eq!(slice, &[82, 117, 115, 116]);\n+    /// // You could use `str::as_bytes`\n+    /// let slice = \"Rust\".as_bytes();\n+    /// assert_eq!(slice, &[82, 117, 115, 116]);\n+    /// // Or, just use a byte string, if you have control over the string\n+    /// // literal\n+    /// assert_eq!(b\"Rust\", &[82, 117, 115, 116]);\n+    /// ```\n+    ///\n+    /// Turning a `Vec<&T>` into a `Vec<Option<&T>>`:\n+    ///\n+    /// ```\n+    /// let store = [0, 1, 2, 3];\n+    /// let mut v_orig = store.iter().collect::<Vec<&i32>>();\n+    /// // Using transmute: this is Undefined Behavior, and a bad idea.\n+    /// // However, it is no-copy.\n+    /// let v_transmuted = unsafe {\n+    ///     std::mem::transmute::<Vec<&i32>, Vec<Option<&i32>>>(\n+    ///         v_orig.clone())\n+    /// };\n+    /// // This is the suggested, safe way.\n+    /// // It does copy the entire Vector, though, into a new array.\n+    /// let v_collected = v_orig.clone()\n+    ///                         .into_iter()\n+    ///                         .map(|r| Some(r))\n+    ///                         .collect::<Vec<Option<&i32>>>();\n+    /// // The no-copy, unsafe way, still using transmute, but not UB.\n+    /// // This is equivalent to the original, but safer, and reuses the\n+    /// // same Vec internals. Therefore the new inner type must have the\n+    /// // exact same size, and the same or lesser alignment, as the old\n+    /// // type. The same caveats exist for this method as transmute, for\n+    /// // the original inner type (`&i32`) to the converted inner type\n+    /// // (`Option<&i32>`), so read the nomicon pages linked above.\n+    /// let v_from_raw = unsafe {\n+    ///     Vec::from_raw_parts(v_orig.as_mut_ptr(),\n+    ///                         v_orig.len(),\n+    ///                         v_orig.capacity())\n+    /// };\n+    /// std::mem::forget(v_orig);\n+    /// ```\n+    ///\n+    /// Implementing `split_at_mut`:\n+    ///\n+    /// ```\n+    /// use std::{slice, mem};\n+    /// // There are multiple ways to do this; and there are multiple problems\n+    /// // with the following, transmute, way.\n+    /// fn split_at_mut_transmute<T>(slice: &mut [T], mid: usize)\n+    ///                              -> (&mut [T], &mut [T]) {\n+    ///     let len = slice.len();\n+    ///     assert!(mid <= len);\n+    ///     unsafe {\n+    ///         let slice2 = mem::transmute::<&mut [T], &mut [T]>(slice);\n+    ///         // first: transmute is not typesafe; all it checks is that T and\n+    ///         // U are of the same size. Second, right here, you have two\n+    ///         // mutable references pointing to the same memory.\n+    ///         (&mut slice[0..mid], &mut slice2[mid..len])\n+    ///     }\n+    /// }\n+    /// // This gets rid of the typesafety problems; `&mut *` will *only* give\n+    /// // you an `&mut T` from an `&mut T` or `*mut T`.\n+    /// fn split_at_mut_casts<T>(slice: &mut [T], mid: usize)\n+    ///                          -> (&mut [T], &mut [T]) {\n+    ///     let len = slice.len();\n+    ///     assert!(mid <= len);\n+    ///     unsafe {\n+    ///         let slice2 = &mut *(slice as *mut [T]);\n+    ///         // however, you still have two mutable references pointing to\n+    ///         // the same memory.\n+    ///         (&mut slice[0..mid], &mut slice2[mid..len])\n+    ///     }\n+    /// }\n+    /// // This is how the standard library does it. This is the best method, if\n+    /// // you need to do something like this\n+    /// fn split_at_stdlib<T>(slice: &mut [T], mid: usize)\n+    ///                       -> (&mut [T], &mut [T]) {\n+    ///     let len = slice.len();\n+    ///     assert!(mid <= len);\n+    ///     unsafe {\n+    ///         let ptr = slice.as_mut_ptr();\n+    ///         // This now has three mutable references pointing at the same\n+    ///         // memory. `slice`, the rvalue ret.0, and the rvalue ret.1.\n+    ///         // `slice` is never used after `let ptr = ...`, and so one can\n+    ///         // treat it as \"dead\", and therefore, you only have two real\n+    ///         // mutable slices.\n+    ///         (slice::from_raw_parts_mut(ptr, mid),\n+    ///          slice::from_raw_parts_mut(ptr.offset(mid as isize), len - mid))\n+    ///     }\n+    /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn transmute<T, U>(e: T) -> U;"}, {"sha": "292d72dd362ad5c203497361cd9cda2febfaebc7", "filename": "src/libcore/iter/traits.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibcore%2Fiter%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibcore%2Fiter%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -386,10 +386,11 @@ pub trait Extend<A> {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait DoubleEndedIterator: Iterator {\n-    /// An iterator able to yield elements from both ends.\n+    /// Removes and returns an element from the end of the iterator.\n     ///\n-    /// As this is the only method for this trait, the [trait-level] docs\n-    /// contain more details.\n+    /// Returns `None` when there are no more elements.\n+    ///\n+    /// The [trait-level] docs contain more details.\n     ///\n     /// [trait-level]: trait.DoubleEndedIterator.html\n     ///"}, {"sha": "1e9e9e30f5cfe08df94cebfce04b840e9f23fca5", "filename": "src/libpanic_unwind/dwarf/eh.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2Fdwarf%2Feh.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -108,10 +108,9 @@ pub unsafe fn find_eh_action(lsda: *const u8, context: &EHContext) -> EHAction {\n                 }\n             }\n         }\n-        // If ip is not present in the table, call terminate.  This is for\n-        // a destructor inside a cleanup, or a library routine the compiler\n-        // was not expecting to throw\n-        EHAction::Terminate\n+        // Ip is not present in the table.  This should not hapen... but it does: issie #35011.\n+        // So rather than returning EHAction::Terminate, we do this.\n+        EHAction::None\n     } else {\n         // SjLj version:\n         // The \"IP\" is an index into the call-site table, with two exceptions:"}, {"sha": "511cc32d2e1e6cfeb47d00fa65076fba5445de64", "filename": "src/librustc/infer/error_reporting.rs", "status": "modified", "additions": 93, "deletions": 143, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -83,7 +83,7 @@ use hir::def_id::DefId;\n use infer::{self, TypeOrigin};\n use middle::region;\n use ty::subst;\n-use ty::{self, Ty, TyCtxt, TypeFoldable};\n+use ty::{self, TyCtxt, TypeFoldable};\n use ty::{Region, ReFree};\n use ty::error::TypeError;\n \n@@ -462,52 +462,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn report_type_error(&self,\n-                         trace: TypeTrace<'tcx>,\n-                         terr: &TypeError<'tcx>)\n-                         -> DiagnosticBuilder<'tcx> {\n-        let (expected, found) = match self.values_str(&trace.values) {\n-            Some(v) => v,\n-            None => {\n-                return self.tcx.sess.diagnostic().struct_dummy(); /* derived error */\n-            }\n-        };\n-\n-        let is_simple_error = if let &TypeError::Sorts(ref values) = terr {\n-            values.expected.is_primitive() && values.found.is_primitive()\n-        } else {\n-            false\n-        };\n-\n-        let mut err = struct_span_err!(self.tcx.sess,\n-                                       trace.origin.span(),\n-                                       E0308,\n-                                       \"{}\",\n-                                       trace.origin);\n-\n-        if !is_simple_error || check_old_school() {\n-            err.note_expected_found(&\"type\", &expected, &found);\n-        }\n-\n-        err.span_label(trace.origin.span(), &terr);\n-\n-        self.check_and_note_conflicting_crates(&mut err, terr, trace.origin.span());\n-\n-        match trace.origin {\n-            TypeOrigin::MatchExpressionArm(_, arm_span, source) => match source {\n-                hir::MatchSource::IfLetDesugar{..} => {\n-                    err.span_note(arm_span, \"`if let` arm with an incompatible type\");\n-                }\n-                _ => {\n-                    err.span_note(arm_span, \"match arm with an incompatible type\");\n-                }\n-            },\n-            _ => ()\n-        }\n-\n-        err\n-    }\n-\n     /// Adds a note if the types come from similarly named crates\n     fn check_and_note_conflicting_crates(&self,\n                                          err: &mut DiagnosticBuilder,\n@@ -550,42 +504,102 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn note_error_origin(&self,\n+                         err: &mut DiagnosticBuilder<'tcx>,\n+                         origin: &TypeOrigin)\n+    {\n+        match origin {\n+            &TypeOrigin::MatchExpressionArm(_, arm_span, source) => match source {\n+                hir::MatchSource::IfLetDesugar {..} => {\n+                    err.span_note(arm_span, \"`if let` arm with an incompatible type\");\n+                }\n+                _ => {\n+                    err.span_note(arm_span, \"match arm with an incompatible type\");\n+                }\n+            },\n+            _ => ()\n+        }\n+    }\n+\n+    pub fn note_type_err(&self,\n+                         diag: &mut DiagnosticBuilder<'tcx>,\n+                         origin: TypeOrigin,\n+                         values: Option<ValuePairs<'tcx>>,\n+                         terr: &TypeError<'tcx>)\n+    {\n+        let expected_found = match values {\n+            None => None,\n+            Some(values) => match self.values_str(&values) {\n+                Some((expected, found)) => Some((expected, found)),\n+                None => {\n+                    // Derived error. Cancel the emitter.\n+                    self.tcx.sess.diagnostic().cancel(diag);\n+                    return\n+                }\n+            }\n+        };\n+\n+        let span = origin.span();\n+\n+        let mut is_simple_error = false;\n+\n+        if let Some((expected, found)) = expected_found {\n+            is_simple_error = if let &TypeError::Sorts(ref values) = terr {\n+                values.expected.is_primitive() && values.found.is_primitive()\n+            } else {\n+                false\n+            };\n+\n+            if !is_simple_error || check_old_school() {\n+                diag.note_expected_found(&\"type\", &expected, &found);\n+            }\n+        }\n+\n+        if !is_simple_error && check_old_school() {\n+            diag.span_note(span, &format!(\"{}\", terr));\n+        } else {\n+            diag.span_label(span, &terr);\n+        }\n+\n+        self.note_error_origin(diag, &origin);\n+        self.check_and_note_conflicting_crates(diag, terr, span);\n+        self.tcx.note_and_explain_type_err(diag, terr, span);\n+    }\n+\n     pub fn report_and_explain_type_error(&self,\n                                          trace: TypeTrace<'tcx>,\n                                          terr: &TypeError<'tcx>)\n-                                         -> DiagnosticBuilder<'tcx> {\n-        let span = trace.origin.span();\n-        let mut err = self.report_type_error(trace, terr);\n-        self.tcx.note_and_explain_type_err(&mut err, terr, span);\n-        err\n+                                         -> DiagnosticBuilder<'tcx>\n+    {\n+        // FIXME: do we want to use a different error code for each origin?\n+        let mut diag = struct_span_err!(\n+            self.tcx.sess, trace.origin.span(), E0308,\n+            \"{}\", trace.origin.as_failure_str()\n+        );\n+        self.note_type_err(&mut diag, trace.origin, Some(trace.values), terr);\n+        diag\n     }\n \n-    /// Returns a string of the form \"expected `{}`, found `{}`\", or None if this is a derived\n-    /// error.\n+    /// Returns a string of the form \"expected `{}`, found `{}`\".\n     fn values_str(&self, values: &ValuePairs<'tcx>) -> Option<(String, String)> {\n         match *values {\n             infer::Types(ref exp_found) => self.expected_found_str(exp_found),\n             infer::TraitRefs(ref exp_found) => self.expected_found_str(exp_found),\n-            infer::PolyTraitRefs(ref exp_found) => self.expected_found_str(exp_found)\n+            infer::PolyTraitRefs(ref exp_found) => self.expected_found_str(exp_found),\n         }\n     }\n \n-    fn expected_found_str<T: fmt::Display + Resolvable<'tcx> + TypeFoldable<'tcx>>(\n+    fn expected_found_str<T: fmt::Display + TypeFoldable<'tcx>>(\n         &self,\n         exp_found: &ty::error::ExpectedFound<T>)\n         -> Option<(String, String)>\n     {\n-        let expected = exp_found.expected.resolve(self);\n-        if expected.references_error() {\n-            return None;\n-        }\n-\n-        let found = exp_found.found.resolve(self);\n-        if found.references_error() {\n+        let exp_found = self.resolve_type_vars_if_possible(exp_found);\n+        if exp_found.references_error() {\n             return None;\n         }\n \n-        Some((format!(\"{}\", expected), format!(\"{}\", found)))\n+        Some((format!(\"{}\", exp_found.expected), format!(\"{}\", exp_found.found)))\n     }\n \n     fn report_generic_bound_failure(&self,\n@@ -1608,59 +1622,21 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     fn note_region_origin(&self, err: &mut DiagnosticBuilder, origin: &SubregionOrigin<'tcx>) {\n         match *origin {\n             infer::Subtype(ref trace) => {\n-                let desc = match trace.origin {\n-                    TypeOrigin::Misc(_) => {\n-                        \"types are compatible\"\n-                    }\n-                    TypeOrigin::MethodCompatCheck(_) => {\n-                        \"method type is compatible with trait\"\n-                    }\n-                    TypeOrigin::ExprAssignable(_) => {\n-                        \"expression is assignable\"\n-                    }\n-                    TypeOrigin::RelateTraitRefs(_) => {\n-                        \"traits are compatible\"\n-                    }\n-                    TypeOrigin::RelateSelfType(_) => {\n-                        \"self type matches impl self type\"\n-                    }\n-                    TypeOrigin::RelateOutputImplTypes(_) => {\n-                        \"trait type parameters matches those \\\n-                                 specified on the impl\"\n-                    }\n-                    TypeOrigin::MatchExpressionArm(_, _, _) => {\n-                        \"match arms have compatible types\"\n-                    }\n-                    TypeOrigin::IfExpression(_) => {\n-                        \"if and else have compatible types\"\n-                    }\n-                    TypeOrigin::IfExpressionWithNoElse(_) => {\n-                        \"if may be missing an else clause\"\n-                    }\n-                    TypeOrigin::RangeExpression(_) => {\n-                        \"start and end of range have compatible types\"\n-                    }\n-                    TypeOrigin::EquatePredicate(_) => {\n-                        \"equality where clause is satisfied\"\n-                    }\n-                };\n-\n-                match self.values_str(&trace.values) {\n-                    Some((expected, found)) => {\n-                        err.span_note(\n-                            trace.origin.span(),\n-                            &format!(\"...so that {} (expected {}, found {})\",\n-                                    desc, expected, found));\n-                    }\n-                    None => {\n-                        // Really should avoid printing this error at\n-                        // all, since it is derived, but that would\n-                        // require more refactoring than I feel like\n-                        // doing right now. - nmatsakis\n-                        err.span_note(\n-                            trace.origin.span(),\n-                            &format!(\"...so that {}\", desc));\n-                    }\n+                if let Some((expected, found)) = self.values_str(&trace.values) {\n+                    // FIXME: do we want a \"the\" here?\n+                    err.span_note(\n+                        trace.origin.span(),\n+                        &format!(\"...so that {} (expected {}, found {})\",\n+                                 trace.origin.as_requirement_str(), expected, found));\n+                } else {\n+                    // FIXME: this really should be handled at some earlier stage. Our\n+                    // handling of region checking when type errors are present is\n+                    // *terrible*.\n+\n+                    err.span_note(\n+                        trace.origin.span(),\n+                        &format!(\"...so that {}\",\n+                                 trace.origin.as_requirement_str()));\n                 }\n             }\n             infer::Reborrow(span) => {\n@@ -1803,32 +1779,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub trait Resolvable<'tcx> {\n-    fn resolve<'a, 'gcx>(&self, infcx: &InferCtxt<'a, 'gcx, 'tcx>) -> Self;\n-}\n-\n-impl<'tcx> Resolvable<'tcx> for Ty<'tcx> {\n-    fn resolve<'a, 'gcx>(&self, infcx: &InferCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n-        infcx.resolve_type_vars_if_possible(self)\n-    }\n-}\n-\n-impl<'tcx> Resolvable<'tcx> for ty::TraitRef<'tcx> {\n-    fn resolve<'a, 'gcx>(&self, infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n-                         -> ty::TraitRef<'tcx> {\n-        infcx.resolve_type_vars_if_possible(self)\n-    }\n-}\n-\n-impl<'tcx> Resolvable<'tcx> for ty::PolyTraitRef<'tcx> {\n-    fn resolve<'a, 'gcx>(&self,\n-                         infcx: &InferCtxt<'a, 'gcx, 'tcx>)\n-                         -> ty::PolyTraitRef<'tcx>\n-    {\n-        infcx.resolve_type_vars_if_possible(self)\n-    }\n-}\n-\n fn lifetimes_in_scope<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                       scope_id: ast::NodeId)\n                                       -> Vec<hir::LifetimeDef> {"}, {"sha": "87882c5528ec163cd60fce350bc9071066f9c639", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 107, "deletions": 90, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -32,7 +32,7 @@ use ty::adjustment;\n use ty::{TyVid, IntVid, FloatVid};\n use ty::{self, Ty, TyCtxt};\n use ty::error::{ExpectedFound, TypeError, UnconstrainedNumeric};\n-use ty::fold::TypeFoldable;\n+use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n use ty::relate::{Relate, RelateResult, TypeRelation};\n use traits::{self, PredicateObligations, ProjectionMode};\n use rustc_data_structures::unify::{self, UnificationTable};\n@@ -196,12 +196,6 @@ pub enum TypeOrigin {\n     // FIXME(eddyb) #11161 is the original Expr required?\n     ExprAssignable(Span),\n \n-    // Relating trait refs when resolving vtables\n-    RelateTraitRefs(Span),\n-\n-    // Relating self types when resolving vtables\n-    RelateSelfType(Span),\n-\n     // Relating trait type parameters to those found in impl etc\n     RelateOutputImplTypes(Span),\n \n@@ -219,16 +213,26 @@ pub enum TypeOrigin {\n \n     // `where a == b`\n     EquatePredicate(Span),\n+\n+    // `main` has wrong type\n+    MainFunctionType(Span),\n+\n+    // `start` has wrong type\n+    StartFunctionType(Span),\n+\n+    // intrinsic has wrong type\n+    IntrinsicType(Span),\n+\n+    // method receiver\n+    MethodReceiver(Span),\n }\n \n impl TypeOrigin {\n-    fn as_str(&self) -> &'static str {\n+    fn as_failure_str(&self) -> &'static str {\n         match self {\n             &TypeOrigin::Misc(_) |\n-            &TypeOrigin::RelateSelfType(_) |\n             &TypeOrigin::RelateOutputImplTypes(_) |\n             &TypeOrigin::ExprAssignable(_) => \"mismatched types\",\n-            &TypeOrigin::RelateTraitRefs(_) => \"mismatched traits\",\n             &TypeOrigin::MethodCompatCheck(_) => \"method not compatible with trait\",\n             &TypeOrigin::MatchExpressionArm(_, _, source) => match source {\n                 hir::MatchSource::IfLetDesugar{..} => \"`if let` arms have incompatible types\",\n@@ -238,13 +242,31 @@ impl TypeOrigin {\n             &TypeOrigin::IfExpressionWithNoElse(_) => \"if may be missing an else clause\",\n             &TypeOrigin::RangeExpression(_) => \"start and end of range have incompatible types\",\n             &TypeOrigin::EquatePredicate(_) => \"equality predicate not satisfied\",\n+            &TypeOrigin::MainFunctionType(_) => \"main function has wrong type\",\n+            &TypeOrigin::StartFunctionType(_) => \"start function has wrong type\",\n+            &TypeOrigin::IntrinsicType(_) => \"intrinsic has wrong type\",\n+            &TypeOrigin::MethodReceiver(_) => \"mismatched method receiver\",\n         }\n     }\n-}\n \n-impl fmt::Display for TypeOrigin {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(),fmt::Error> {\n-        fmt::Display::fmt(self.as_str(), f)\n+    fn as_requirement_str(&self) -> &'static str {\n+        match self {\n+            &TypeOrigin::Misc(_) => \"types are compatible\",\n+            &TypeOrigin::MethodCompatCheck(_) => \"method type is compatible with trait\",\n+            &TypeOrigin::ExprAssignable(_) => \"expression is assignable\",\n+            &TypeOrigin::RelateOutputImplTypes(_) => {\n+                \"trait type parameters matches those specified on the impl\"\n+            }\n+            &TypeOrigin::MatchExpressionArm(_, _, _) => \"match arms have compatible types\",\n+            &TypeOrigin::IfExpression(_) => \"if and else have compatible types\",\n+            &TypeOrigin::IfExpressionWithNoElse(_) => \"if missing an else returns ()\",\n+            &TypeOrigin::RangeExpression(_) => \"start and end of range have compatible types\",\n+            &TypeOrigin::EquatePredicate(_) => \"equality where clause is satisfied\",\n+            &TypeOrigin::MainFunctionType(_) => \"`main` function has the correct type\",\n+            &TypeOrigin::StartFunctionType(_) => \"`start` function has the correct type\",\n+            &TypeOrigin::IntrinsicType(_) => \"intrinsic has the correct type\",\n+            &TypeOrigin::MethodReceiver(_) => \"method receiver has the correct type\",\n+        }\n     }\n }\n \n@@ -1468,104 +1490,50 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // error type, meaning that an error occurred when typechecking this expression),\n     // this is a derived error. The error cascaded from another error (that was already\n     // reported), so it's not useful to display it to the user.\n-    // The following four methods -- type_error_message_str, type_error_message_str_with_expected,\n-    // type_error_message, and report_mismatched_types -- implement this logic.\n+    // The following methods implement this logic.\n     // They check if either the actual or expected type is TyError, and don't print the error\n     // in this case. The typechecker should only ever report type errors involving mismatched\n-    // types using one of these four methods, and should not call span_err directly for such\n+    // types using one of these methods, and should not call span_err directly for such\n     // errors.\n-    pub fn type_error_message_str<M>(&self,\n-                                     sp: Span,\n-                                     mk_msg: M,\n-                                     actual_ty: String,\n-                                     err: Option<&TypeError<'tcx>>)\n-        where M: FnOnce(Option<String>, String) -> String,\n-    {\n-        self.type_error_message_str_with_expected(sp, mk_msg, None, actual_ty, err)\n-    }\n-\n-    pub fn type_error_struct_str<M>(&self,\n-                                    sp: Span,\n-                                    mk_msg: M,\n-                                    actual_ty: String,\n-                                    err: Option<&TypeError<'tcx>>)\n-                                    -> DiagnosticBuilder<'tcx>\n-        where M: FnOnce(Option<String>, String) -> String,\n-    {\n-        self.type_error_struct_str_with_expected(sp, mk_msg, None, actual_ty, err)\n-    }\n-\n-    pub fn type_error_message_str_with_expected<M>(&self,\n-                                                   sp: Span,\n-                                                   mk_msg: M,\n-                                                   expected_ty: Option<Ty<'tcx>>,\n-                                                   actual_ty: String,\n-                                                   err: Option<&TypeError<'tcx>>)\n-        where M: FnOnce(Option<String>, String) -> String,\n-    {\n-        self.type_error_struct_str_with_expected(sp, mk_msg, expected_ty, actual_ty, err)\n-            .emit();\n-    }\n-\n-    pub fn type_error_struct_str_with_expected<M>(&self,\n-                                                  sp: Span,\n-                                                  mk_msg: M,\n-                                                  expected_ty: Option<Ty<'tcx>>,\n-                                                  actual_ty: String,\n-                                                  err: Option<&TypeError<'tcx>>)\n-                                                  -> DiagnosticBuilder<'tcx>\n-        where M: FnOnce(Option<String>, String) -> String,\n-    {\n-        debug!(\"hi! expected_ty = {:?}, actual_ty = {}\", expected_ty, actual_ty);\n-\n-        let resolved_expected = expected_ty.map(|e_ty| self.resolve_type_vars_if_possible(&e_ty));\n-\n-        if !resolved_expected.references_error() {\n-            let error_str = err.map_or(\"\".to_string(), |t_err| {\n-                format!(\" ({})\", t_err)\n-            });\n-\n-            let mut db = self.tcx.sess.struct_span_err(sp, &format!(\"{}{}\",\n-                mk_msg(resolved_expected.map(|t| self.ty_to_string(t)), actual_ty),\n-                error_str));\n-\n-            if let Some(err) = err {\n-                self.tcx.note_and_explain_type_err(&mut db, err, sp);\n-            }\n-            db\n-        } else {\n-            self.tcx.sess.diagnostic().struct_dummy()\n-        }\n-    }\n \n     pub fn type_error_message<M>(&self,\n                                  sp: Span,\n                                  mk_msg: M,\n-                                 actual_ty: Ty<'tcx>,\n-                                 err: Option<&TypeError<'tcx>>)\n+                                 actual_ty: Ty<'tcx>)\n         where M: FnOnce(String) -> String,\n     {\n-        self.type_error_struct(sp, mk_msg, actual_ty, err).emit();\n+        self.type_error_struct(sp, mk_msg, actual_ty).emit();\n     }\n \n+    // FIXME: this results in errors without an error code. Deprecate?\n     pub fn type_error_struct<M>(&self,\n                                 sp: Span,\n                                 mk_msg: M,\n-                                actual_ty: Ty<'tcx>,\n-                                err: Option<&TypeError<'tcx>>)\n+                                actual_ty: Ty<'tcx>)\n                                 -> DiagnosticBuilder<'tcx>\n         where M: FnOnce(String) -> String,\n+    {\n+        self.type_error_struct_with_diag(sp, |actual_ty| {\n+            self.tcx.sess.struct_span_err(sp, &mk_msg(actual_ty))\n+        }, actual_ty)\n+    }\n+\n+    pub fn type_error_struct_with_diag<M>(&self,\n+                                          sp: Span,\n+                                          mk_diag: M,\n+                                          actual_ty: Ty<'tcx>)\n+                                          -> DiagnosticBuilder<'tcx>\n+        where M: FnOnce(String) -> DiagnosticBuilder<'tcx>,\n     {\n         let actual_ty = self.resolve_type_vars_if_possible(&actual_ty);\n+        debug!(\"type_error_struct_with_diag({:?}, {:?})\", sp, actual_ty);\n \n         // Don't report an error if actual type is TyError.\n         if actual_ty.references_error() {\n             return self.tcx.sess.diagnostic().struct_dummy();\n         }\n \n-        self.type_error_struct_str(sp,\n-            move |_e, a| { mk_msg(a) },\n-            self.ty_to_string(actual_ty), err)\n+        mk_diag(self.ty_to_string(actual_ty))\n     }\n \n     pub fn report_mismatched_types(&self,\n@@ -1833,14 +1801,16 @@ impl TypeOrigin {\n             TypeOrigin::MethodCompatCheck(span) => span,\n             TypeOrigin::ExprAssignable(span) => span,\n             TypeOrigin::Misc(span) => span,\n-            TypeOrigin::RelateTraitRefs(span) => span,\n-            TypeOrigin::RelateSelfType(span) => span,\n             TypeOrigin::RelateOutputImplTypes(span) => span,\n             TypeOrigin::MatchExpressionArm(match_span, _, _) => match_span,\n             TypeOrigin::IfExpression(span) => span,\n             TypeOrigin::IfExpressionWithNoElse(span) => span,\n             TypeOrigin::RangeExpression(span) => span,\n             TypeOrigin::EquatePredicate(span) => span,\n+            TypeOrigin::MainFunctionType(span) => span,\n+            TypeOrigin::StartFunctionType(span) => span,\n+            TypeOrigin::IntrinsicType(span) => span,\n+            TypeOrigin::MethodReceiver(span) => span,\n         }\n     }\n }\n@@ -1891,3 +1861,50 @@ impl RegionVariableOrigin {\n         }\n     }\n }\n+\n+impl<'tcx> TypeFoldable<'tcx> for TypeOrigin {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, _folder: &mut F) -> Self {\n+        self.clone()\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, _visitor: &mut V) -> bool {\n+        false\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ValuePairs<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        match *self {\n+            ValuePairs::Types(ref ef) => {\n+                ValuePairs::Types(ef.fold_with(folder))\n+            }\n+            ValuePairs::TraitRefs(ref ef) => {\n+                ValuePairs::TraitRefs(ef.fold_with(folder))\n+            }\n+            ValuePairs::PolyTraitRefs(ref ef) => {\n+                ValuePairs::PolyTraitRefs(ef.fold_with(folder))\n+            }\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        match *self {\n+            ValuePairs::Types(ref ef) => ef.visit_with(visitor),\n+            ValuePairs::TraitRefs(ref ef) => ef.visit_with(visitor),\n+            ValuePairs::PolyTraitRefs(ref ef) => ef.visit_with(visitor),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for TypeTrace<'tcx> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        TypeTrace {\n+            origin: self.origin.fold_with(folder),\n+            values: self.values.fold_with(folder)\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.origin.visit_with(visitor) || self.values.visit_with(visitor)\n+    }\n+}"}, {"sha": "5901c42b525826881c2746a00e16c45c9bed4847", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 4, "deletions": 77, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -126,20 +126,14 @@ impl Session {\n                                                    sp: S,\n                                                    msg: &str)\n                                                    -> DiagnosticBuilder<'a>  {\n-        match split_msg_into_multilines(msg) {\n-            Some(ref msg) => self.diagnostic().struct_span_err(sp, msg),\n-            None => self.diagnostic().struct_span_err(sp, msg),\n-        }\n+        self.diagnostic().struct_span_err(sp, msg)\n     }\n     pub fn struct_span_err_with_code<'a, S: Into<MultiSpan>>(&'a self,\n                                                              sp: S,\n                                                              msg: &str,\n                                                              code: &str)\n                                                              -> DiagnosticBuilder<'a>  {\n-        match split_msg_into_multilines(msg) {\n-            Some(ref msg) => self.diagnostic().struct_span_err_with_code(sp, msg, code),\n-            None => self.diagnostic().struct_span_err_with_code(sp, msg, code),\n-        }\n+        self.diagnostic().struct_span_err_with_code(sp, msg, code)\n     }\n     pub fn struct_err<'a>(&'a self, msg: &str) -> DiagnosticBuilder<'a>  {\n         self.diagnostic().struct_err(msg)\n@@ -178,16 +172,10 @@ impl Session {\n         }\n     }\n     pub fn span_err<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n-        match split_msg_into_multilines(msg) {\n-            Some(msg) => self.diagnostic().span_err(sp, &msg),\n-            None => self.diagnostic().span_err(sp, msg)\n-        }\n+        self.diagnostic().span_err(sp, msg)\n     }\n     pub fn span_err_with_code<S: Into<MultiSpan>>(&self, sp: S, msg: &str, code: &str) {\n-        match split_msg_into_multilines(msg) {\n-            Some(msg) => self.diagnostic().span_err_with_code(sp, &msg, code),\n-            None => self.diagnostic().span_err_with_code(sp, msg, code)\n-        }\n+        self.diagnostic().span_err_with_code(sp, &msg, code)\n     }\n     pub fn err(&self, msg: &str) {\n         self.diagnostic().err(msg)\n@@ -343,67 +331,6 @@ impl Session {\n     }\n }\n \n-fn split_msg_into_multilines(msg: &str) -> Option<String> {\n-    // Conditions for enabling multi-line errors:\n-    if !msg.contains(\"mismatched types\") &&\n-        !msg.contains(\"type mismatch resolving\") &&\n-        !msg.contains(\"if and else have incompatible types\") &&\n-        !msg.contains(\"if may be missing an else clause\") &&\n-        !msg.contains(\"match arms have incompatible types\") &&\n-        !msg.contains(\"structure constructor specifies a structure of type\") &&\n-        !msg.contains(\"has an incompatible type for trait\") {\n-            return None\n-    }\n-    let first = msg.match_indices(\"expected\").filter(|s| {\n-        let last = msg[..s.0].chars().rev().next();\n-        last == Some(' ') || last == Some('(')\n-    }).map(|(a, b)| (a - 1, a + b.len()));\n-    let second = msg.match_indices(\"found\").filter(|s| {\n-        msg[..s.0].chars().rev().next() == Some(' ')\n-    }).map(|(a, b)| (a - 1, a + b.len()));\n-\n-    let mut new_msg = String::new();\n-    let mut head = 0;\n-\n-    // Insert `\\n` before expected and found.\n-    for (pos1, pos2) in first.zip(second) {\n-        new_msg = new_msg +\n-        // A `(` may be preceded by a space and it should be trimmed\n-                  msg[head..pos1.0].trim_right() + // prefix\n-                  \"\\n\" +                           // insert before first\n-                  &msg[pos1.0..pos1.1] +           // insert what first matched\n-                  &msg[pos1.1..pos2.0] +           // between matches\n-                  \"\\n   \" +                        // insert before second\n-        //           123\n-        // `expected` is 3 char longer than `found`. To align the types,\n-        // `found` gets 3 spaces prepended.\n-                  &msg[pos2.0..pos2.1];            // insert what second matched\n-\n-        head = pos2.1;\n-    }\n-\n-    let mut tail = &msg[head..];\n-    let third = tail.find(\"(values differ\")\n-                   .or(tail.find(\"(lifetime\"))\n-                   .or(tail.find(\"(cyclic type of infinite size\"));\n-    // Insert `\\n` before any remaining messages which match.\n-    if let Some(pos) = third {\n-        // The end of the message may just be wrapped in `()` without\n-        // `expected`/`found`.  Push this also to a new line and add the\n-        // final tail after.\n-        new_msg = new_msg +\n-        // `(` is usually preceded by a space and should be trimmed.\n-                  tail[..pos].trim_right() + // prefix\n-                  \"\\n\" +                     // insert before paren\n-                  &tail[pos..];              // append the tail\n-\n-        tail = \"\";\n-    }\n-\n-    new_msg.push_str(tail);\n-    return Some(new_msg);\n-}\n-\n pub fn build_session(sopts: config::Options,\n                      dep_graph: &DepGraph,\n                      local_crate_source_file: Option<PathBuf>,"}, {"sha": "67ad887530eb318ccabe450784dc9480e11e5297", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 57, "deletions": 17, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -26,8 +26,9 @@ use super::{\n \n use fmt_macros::{Parser, Piece, Position};\n use hir::def_id::DefId;\n-use infer::{InferCtxt};\n+use infer::{self, InferCtxt, TypeOrigin};\n use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n+use ty::error::ExpectedFound;\n use ty::fast_reject;\n use ty::fold::TypeFolder;\n use ty::subst::{self, Subst, TypeSpace};\n@@ -107,24 +108,63 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         let predicate =\n             self.resolve_type_vars_if_possible(&obligation.predicate);\n \n-        if !predicate.references_error() {\n-            if let Some(warning_node_id) = warning_node_id {\n-                self.tcx.sess.add_lint(\n-                    ::lint::builtin::UNSIZED_IN_TUPLE,\n-                    warning_node_id,\n+        if predicate.references_error() {\n+            return\n+        }\n+        if let Some(warning_node_id) = warning_node_id {\n+            self.tcx.sess.add_lint(\n+                ::lint::builtin::UNSIZED_IN_TUPLE,\n+                warning_node_id,\n+                obligation.cause.span,\n+                format!(\"type mismatch resolving `{}`: {}\",\n+                        predicate,\n+                        error.err));\n+            return\n+        }\n+        self.probe(|_| {\n+            let origin = TypeOrigin::Misc(obligation.cause.span);\n+            let err_buf;\n+            let mut err = &error.err;\n+            let mut values = None;\n+\n+            // try to find the mismatched types to report the error with.\n+            //\n+            // this can fail if the problem was higher-ranked, in which\n+            // cause I have no idea for a good error message.\n+            if let ty::Predicate::Projection(ref data) = predicate {\n+                let mut selcx = SelectionContext::new(self);\n+                let (data, _) = self.replace_late_bound_regions_with_fresh_var(\n                     obligation.cause.span,\n-                    format!(\"type mismatch resolving `{}`: {}\",\n-                            predicate,\n-                            error.err));\n-            } else {\n-                let mut err = struct_span_err!(self.tcx.sess, obligation.cause.span, E0271,\n-                                               \"type mismatch resolving `{}`: {}\",\n-                                               predicate,\n-                                               error.err);\n-                self.note_obligation_cause(&mut err, obligation);\n-                err.emit();\n+                    infer::LateBoundRegionConversionTime::HigherRankedType,\n+                    data);\n+                let normalized = super::normalize_projection_type(\n+                    &mut selcx,\n+                    data.projection_ty,\n+                    obligation.cause.clone(),\n+                    0\n+                );\n+                let origin = TypeOrigin::Misc(obligation.cause.span);\n+                if let Err(error) = self.eq_types(\n+                    false, origin,\n+                    data.ty, normalized.value\n+                ) {\n+                    values = Some(infer::ValuePairs::Types(ExpectedFound {\n+                        expected: normalized.value,\n+                        found: data.ty,\n+                    }));\n+                    err_buf = error;\n+                    err = &err_buf;\n+                }\n             }\n-        }\n+\n+            let mut diag = struct_span_err!(\n+                self.tcx.sess, origin.span(), E0271,\n+                \"type mismatch resolving `{}`\", predicate\n+            );\n+            self.note_type_err(&mut diag, origin, values, err);\n+            self.note_obligation_cause(&mut diag, obligation);\n+            diag.emit();\n+        });\n     }\n \n     fn impl_substs(&self,"}, {"sha": "16a54c20925deda7b8417a3747be29e6e0289bec", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -1018,3 +1018,16 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TypeScheme<'tcx>  {\n         self.generics.visit_with(visitor) || self.ty.visit_with(visitor)\n     }\n }\n+\n+impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for ty::error::ExpectedFound<T> {\n+    fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n+        ty::error::ExpectedFound {\n+            expected: self.expected.fold_with(folder),\n+            found: self.found.fold_with(folder),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.expected.visit_with(visitor) || self.found.visit_with(visitor)\n+    }\n+}"}, {"sha": "99bc26848025ec0ec030a28776c5b3634226a455", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -70,20 +70,18 @@ macro_rules! supported_targets {\n         /// List of supported targets\n         pub const TARGETS: &'static [&'static str] = &[$($triple),*];\n \n-        // this would use a match if stringify! were allowed in pattern position\n         fn load_specific(target: &str) -> Option<Target> {\n-            let target = target.replace(\"-\", \"_\");\n-            if false { }\n-            $(\n-                else if target == stringify!($module) {\n-                    let mut t = $module::target();\n-                    t.options.is_builtin = true;\n-                    debug!(\"Got builtin target: {:?}\", t);\n-                    return Some(t);\n-                }\n-            )*\n-\n-            None\n+            match target {\n+                $(\n+                    $triple => {\n+                        let mut t = $module::target();\n+                        t.options.is_builtin = true;\n+                        debug!(\"Got builtin target: {:?}\", t);\n+                        Some(t)\n+                    },\n+                )+\n+                _ => None\n+            }\n         }\n     )\n }"}, {"sha": "8967672548b101b3b35a01f04b8207ab8b5d1198", "filename": "src/librustc_const_eval/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_const_eval%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_const_eval%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2FCargo.toml?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -14,6 +14,7 @@ serialize = { path = \"../libserialize\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n+rustc_errors = { path = \"../librustc_errors\" }\n syntax = { path = \"../libsyntax\" }\n graphviz = { path = \"../libgraphviz\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n\\ No newline at end of file"}, {"sha": "915a0cf0bdc7301ecda143b9d51745a827453b37", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 23, "deletions": 32, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -17,6 +17,7 @@ use rustc::middle::const_val::ConstVal;\n use ::{eval_const_expr, eval_const_expr_partial, compare_const_vals};\n use ::{const_expr_to_pat, lookup_const_by_id};\n use ::EvalHint::ExprTypeChecked;\n+use eval::report_const_eval_err;\n use rustc::hir::def::*;\n use rustc::hir::def_id::{DefId};\n use rustc::middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor};\n@@ -42,6 +43,7 @@ use syntax_pos::{Span, DUMMY_SP};\n use rustc::hir::fold::{Folder, noop_fold_pat};\n use rustc::hir::print::pat_to_string;\n use syntax::ptr::P;\n+use rustc::util::common::ErrorReported;\n use rustc::util::nodemap::FnvHashMap;\n \n pub const DUMMY_WILD_PAT: &'static Pat = &Pat {\n@@ -279,13 +281,7 @@ fn check_for_static_nan(cx: &MatchCheckCtxt, pat: &Pat) {\n                 Ok(_) => {}\n \n                 Err(err) => {\n-                    let mut diag = struct_span_err!(cx.tcx.sess, err.span, E0471,\n-                                                    \"constant evaluation error: {}\",\n-                                                    err.description());\n-                    if !p.span.contains(err.span) {\n-                        diag.span_note(p.span, \"in pattern here\");\n-                    }\n-                    diag.emit();\n+                    report_const_eval_err(cx.tcx, &err, p.span, \"pattern\").emit();\n                 }\n             }\n         }\n@@ -838,22 +834,19 @@ pub fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> us\n     }\n }\n \n-fn range_covered_by_constructor(ctor: &Constructor,\n-                                from: &ConstVal, to: &ConstVal) -> Option<bool> {\n+fn range_covered_by_constructor(tcx: TyCtxt, span: Span,\n+                                ctor: &Constructor,\n+                                from: &ConstVal, to: &ConstVal)\n+                                -> Result<bool, ErrorReported> {\n     let (c_from, c_to) = match *ctor {\n         ConstantValue(ref value)        => (value, value),\n         ConstantRange(ref from, ref to) => (from, to),\n-        Single                          => return Some(true),\n+        Single                          => return Ok(true),\n         _                               => bug!()\n     };\n-    let cmp_from = compare_const_vals(c_from, from);\n-    let cmp_to = compare_const_vals(c_to, to);\n-    match (cmp_from, cmp_to) {\n-        (Some(cmp_from), Some(cmp_to)) => {\n-            Some(cmp_from != Ordering::Less && cmp_to != Ordering::Greater)\n-        }\n-        _ => None\n-    }\n+    let cmp_from = compare_const_vals(tcx, span, c_from, from)?;\n+    let cmp_to = compare_const_vals(tcx, span, c_to, to)?;\n+    Ok(cmp_from != Ordering::Less && cmp_to != Ordering::Greater)\n }\n \n fn wrap_pat<'a, 'b, 'tcx>(cx: &MatchCheckCtxt<'b, 'tcx>,\n@@ -965,27 +958,25 @@ pub fn specialize<'a, 'b, 'tcx>(\n                 Some(vec![(pat, Some(mt.ty))])\n             } else {\n                 let expr_value = eval_const_expr(cx.tcx, &expr);\n-                match range_covered_by_constructor(constructor, &expr_value, &expr_value) {\n-                    Some(true) => Some(vec![]),\n-                    Some(false) => None,\n-                    None => {\n-                        span_err!(cx.tcx.sess, pat_span, E0298, \"mismatched types between arms\");\n-                        None\n-                    }\n+                match range_covered_by_constructor(\n+                    cx.tcx, expr.span, constructor, &expr_value, &expr_value\n+                ) {\n+                    Ok(true) => Some(vec![]),\n+                    Ok(false) => None,\n+                    Err(ErrorReported) => None,\n                 }\n             }\n         }\n \n         PatKind::Range(ref from, ref to) => {\n             let from_value = eval_const_expr(cx.tcx, &from);\n             let to_value = eval_const_expr(cx.tcx, &to);\n-            match range_covered_by_constructor(constructor, &from_value, &to_value) {\n-                Some(true) => Some(vec![]),\n-                Some(false) => None,\n-                None => {\n-                    span_err!(cx.tcx.sess, pat_span, E0299, \"mismatched types between arms\");\n-                    None\n-                }\n+            match range_covered_by_constructor(\n+                cx.tcx, pat_span, constructor, &from_value, &to_value\n+            ) {\n+                Ok(true) => Some(vec![]),\n+                Ok(false) => None,\n+                Err(ErrorReported) => None,\n             }\n         }\n "}, {"sha": "45414c33c075448640ef116443fcaf58f23d4e0d", "filename": "src/librustc_const_eval/diagnostics.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fdiagnostics.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -551,44 +551,46 @@ The `op_string_ref` binding has type `&Option<&String>` in both cases.\n See also https://github.com/rust-lang/rust/issues/14587\n \"##,\n \n-E0306: r##\"\n-In an array literal `[x; N]`, `N` is the number of elements in the array. This\n-must be an unsigned integer. Erroneous code example:\n+E0080: r##\"\n+This error indicates that the compiler was unable to sensibly evaluate an\n+constant expression that had to be evaluated. Attempting to divide by 0\n+or causing integer overflow are two ways to induce this error. For example:\n \n ```compile_fail\n-let x = [0i32; true]; // error: expected positive integer for repeat count,\n-                      //        found boolean\n+enum Enum {\n+    X = (1 << 500),\n+    Y = (1 / 0)\n+}\n ```\n \n-Working example:\n+Ensure that the expressions given can be evaluated as the desired integer type.\n+See the FFI section of the Reference for more information about using a custom\n+integer type:\n \n-```\n-let x = [0i32; 2];\n-```\n+https://doc.rust-lang.org/reference.html#ffi-attributes\n \"##,\n \n-E0307: r##\"\n-The length of an array is part of its type. For this reason, this length must\n-be a compile-time constant. Erroneous code example:\n+\n+E0306: r##\"\n+In an array literal `[x; N]`, `N` is the number of elements in the array. This\n+must be an unsigned integer. Erroneous code example:\n \n ```compile_fail\n-    let len = 10;\n-    let x = [0i32; len]; // error: expected constant integer for repeat count,\n-                         //        found variable\n+let x = [0i32; true]; // error: expected positive integer for repeat count,\n+                      //        found boolean\n ```\n \n Working example:\n \n ```\n-let x = [0i32; 10];\n+let x = [0i32; 2];\n ```\n \"##,\n-\n }\n \n \n register_diagnostics! {\n-E0298, // mismatched types between arms\n-E0299, // mismatched types between arms\n-E0471, // constant evaluation error: ..\n+    E0298, // cannot compare constants\n+//  E0299, // mismatched types between arms\n+//  E0471, // constant evaluation error (in pattern)\n }"}, {"sha": "dd21bb17a2da95e810945c02d3f3f0323e2fcb15", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 165, "deletions": 67, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -25,6 +25,7 @@ use rustc::hir::pat_util::def_to_path;\n use rustc::ty::{self, Ty, TyCtxt, subst};\n use rustc::ty::util::IntTypeExt;\n use rustc::traits::ProjectionMode;\n+use rustc::util::common::ErrorReported;\n use rustc::util::nodemap::NodeMap;\n use rustc::lint;\n \n@@ -43,6 +44,7 @@ use std::cmp::Ordering;\n use std::collections::hash_map::Entry::Vacant;\n \n use rustc_const_math::*;\n+use rustc_errors::{DiagnosticBuilder, check_old_school};\n \n macro_rules! math {\n     ($e:expr, $op:expr) => {\n@@ -338,20 +340,71 @@ pub fn const_expr_to_pat<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     Ok(P(hir::Pat { id: expr.id, node: pat, span: span }))\n }\n \n+pub fn report_const_eval_err<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    err: &ConstEvalErr,\n+    primary_span: Span,\n+    primary_kind: &str)\n+    -> DiagnosticBuilder<'tcx>\n+{\n+    let mut err = err;\n+    while let &ConstEvalErr { kind: ErroneousReferencedConstant(box ref i_err), .. } = err {\n+        err = i_err;\n+    }\n+\n+    let mut diag = struct_span_err!(tcx.sess, err.span, E0080, \"constant evaluation error\");\n+    note_const_eval_err(tcx, err, primary_span, primary_kind, &mut diag);\n+    diag\n+}\n+\n+pub fn fatal_const_eval_err<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    err: &ConstEvalErr,\n+    primary_span: Span,\n+    primary_kind: &str)\n+    -> !\n+{\n+    report_const_eval_err(tcx, err, primary_span, primary_kind).emit();\n+    tcx.sess.abort_if_errors();\n+    unreachable!()\n+}\n+\n+pub fn note_const_eval_err<'a, 'tcx>(\n+    _tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    err: &ConstEvalErr,\n+    primary_span: Span,\n+    primary_kind: &str,\n+    diag: &mut DiagnosticBuilder)\n+{\n+    match err.description() {\n+        ConstEvalErrDescription::Simple(message) => {\n+            if check_old_school() {\n+                diag.note(&message);\n+            } else {\n+                diag.span_label(err.span, &message);\n+            }\n+        }\n+    }\n+\n+    if !primary_span.contains(err.span) {\n+        diag.span_note(primary_span,\n+                       &format!(\"for {} here\", primary_kind));\n+    }\n+}\n+\n pub fn eval_const_expr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                  e: &Expr) -> ConstVal {\n     match eval_const_expr_partial(tcx, e, ExprTypeChecked, None) {\n         Ok(r) => r,\n         // non-const path still needs to be a fatal error, because enums are funky\n         Err(s) => {\n+            report_const_eval_err(tcx, &s, e.span, \"expression\").emit();\n             match s.kind {\n                 NonConstPath |\n-                UnimplementedConstVal(_) => tcx.sess.span_fatal(s.span, &s.description()),\n-                _ => {\n-                    tcx.sess.span_err(s.span, &s.description());\n-                    Dummy\n-                }\n+                UnimplementedConstVal(_) => tcx.sess.abort_if_errors(),\n+                _ => {}\n             }\n+            Dummy\n         },\n     }\n }\n@@ -400,6 +453,7 @@ pub enum ErrKind {\n     IntermediateUnsignedNegative,\n     /// Expected, Got\n     TypeMismatch(String, ConstInt),\n+\n     BadType(ConstVal),\n     ErroneousReferencedConstant(Box<ConstEvalErr>),\n     CharCast(ConstInt),\n@@ -411,57 +465,79 @@ impl From<ConstMathErr> for ErrKind {\n     }\n }\n \n+#[derive(Clone, Debug)]\n+pub enum ConstEvalErrDescription<'a> {\n+    Simple(Cow<'a, str>),\n+}\n+\n+impl<'a> ConstEvalErrDescription<'a> {\n+    /// Return a one-line description of the error, for lints and such\n+    pub fn into_oneline(self) -> Cow<'a, str> {\n+        match self {\n+            ConstEvalErrDescription::Simple(simple) => simple,\n+        }\n+    }\n+}\n+\n impl ConstEvalErr {\n-    pub fn description(&self) -> Cow<str> {\n+    pub fn description(&self) -> ConstEvalErrDescription {\n         use self::ErrKind::*;\n+        use self::ConstEvalErrDescription::*;\n+\n+        macro_rules! simple {\n+            ($msg:expr) => ({ Simple($msg.into_cow()) });\n+            ($fmt:expr, $($arg:tt)+) => ({\n+                Simple(format!($fmt, $($arg)+).into_cow())\n+            })\n+        }\n \n         match self.kind {\n-            CannotCast => \"can't cast this type\".into_cow(),\n-            CannotCastTo(s) => format!(\"can't cast this type to {}\", s).into_cow(),\n-            InvalidOpForInts(_) =>  \"can't do this op on integrals\".into_cow(),\n-            InvalidOpForBools(_) =>  \"can't do this op on bools\".into_cow(),\n-            InvalidOpForFloats(_) => \"can't do this op on floats\".into_cow(),\n-            InvalidOpForIntUint(..) => \"can't do this op on an isize and usize\".into_cow(),\n-            InvalidOpForUintInt(..) => \"can't do this op on a usize and isize\".into_cow(),\n-            NegateOn(ref const_val) => format!(\"negate on {}\", const_val.description()).into_cow(),\n-            NotOn(ref const_val) => format!(\"not on {}\", const_val.description()).into_cow(),\n-            CallOn(ref const_val) => format!(\"call on {}\", const_val.description()).into_cow(),\n-\n-            MissingStructField  => \"nonexistent struct field\".into_cow(),\n-            NonConstPath        => \"non-constant path in constant expression\".into_cow(),\n+            CannotCast => simple!(\"can't cast this type\"),\n+            CannotCastTo(s) => simple!(\"can't cast this type to {}\", s),\n+            InvalidOpForInts(_) =>  simple!(\"can't do this op on integrals\"),\n+            InvalidOpForBools(_) =>  simple!(\"can't do this op on bools\"),\n+            InvalidOpForFloats(_) => simple!(\"can't do this op on floats\"),\n+            InvalidOpForIntUint(..) => simple!(\"can't do this op on an isize and usize\"),\n+            InvalidOpForUintInt(..) => simple!(\"can't do this op on a usize and isize\"),\n+            NegateOn(ref const_val) => simple!(\"negate on {}\", const_val.description()),\n+            NotOn(ref const_val) => simple!(\"not on {}\", const_val.description()),\n+            CallOn(ref const_val) => simple!(\"call on {}\", const_val.description()),\n+\n+            MissingStructField  => simple!(\"nonexistent struct field\"),\n+            NonConstPath        => simple!(\"non-constant path in constant expression\"),\n             UnimplementedConstVal(what) =>\n-                format!(\"unimplemented constant expression: {}\", what).into_cow(),\n-            UnresolvedPath => \"unresolved path in constant expression\".into_cow(),\n-            ExpectedConstTuple => \"expected constant tuple\".into_cow(),\n-            ExpectedConstStruct => \"expected constant struct\".into_cow(),\n-            TupleIndexOutOfBounds => \"tuple index out of bounds\".into_cow(),\n-            IndexedNonVec => \"indexing is only supported for arrays\".into_cow(),\n-            IndexNegative => \"indices must be non-negative integers\".into_cow(),\n-            IndexNotInt => \"indices must be integers\".into_cow(),\n+                simple!(\"unimplemented constant expression: {}\", what),\n+            UnresolvedPath => simple!(\"unresolved path in constant expression\"),\n+            ExpectedConstTuple => simple!(\"expected constant tuple\"),\n+            ExpectedConstStruct => simple!(\"expected constant struct\"),\n+            TupleIndexOutOfBounds => simple!(\"tuple index out of bounds\"),\n+            IndexedNonVec => simple!(\"indexing is only supported for arrays\"),\n+            IndexNegative => simple!(\"indices must be non-negative integers\"),\n+            IndexNotInt => simple!(\"indices must be integers\"),\n             IndexOutOfBounds { len, index } => {\n-                format!(\"index out of bounds: the len is {} but the index is {}\",\n-                        len, index).into_cow()\n+                simple!(\"index out of bounds: the len is {} but the index is {}\",\n+                        len, index)\n             }\n-            RepeatCountNotNatural => \"repeat count must be a natural number\".into_cow(),\n-            RepeatCountNotInt => \"repeat count must be integers\".into_cow(),\n+            RepeatCountNotNatural => simple!(\"repeat count must be a natural number\"),\n+            RepeatCountNotInt => simple!(\"repeat count must be integers\"),\n \n-            MiscBinaryOp => \"bad operands for binary\".into_cow(),\n-            MiscCatchAll => \"unsupported constant expr\".into_cow(),\n-            IndexOpFeatureGated => \"the index operation on const values is unstable\".into_cow(),\n-            Math(ref err) => err.description().into_cow(),\n+            MiscBinaryOp => simple!(\"bad operands for binary\"),\n+            MiscCatchAll => simple!(\"unsupported constant expr\"),\n+            IndexOpFeatureGated => simple!(\"the index operation on const values is unstable\"),\n+            Math(ref err) => Simple(err.description().into_cow()),\n \n-            IntermediateUnsignedNegative => \"during the computation of an unsigned a negative \\\n-                                             number was encountered. This is most likely a bug in\\\n-                                             the constant evaluator\".into_cow(),\n+            IntermediateUnsignedNegative => simple!(\n+                \"during the computation of an unsigned a negative \\\n+                 number was encountered. This is most likely a bug in\\\n+                 the constant evaluator\"),\n \n             TypeMismatch(ref expected, ref got) => {\n-                format!(\"mismatched types: expected `{}`, found `{}`\",\n-                        expected, got.description()).into_cow()\n+                simple!(\"expected {}, found {}\", expected, got.description())\n             },\n-            BadType(ref i) => format!(\"value of wrong type: {:?}\", i).into_cow(),\n-            ErroneousReferencedConstant(_) => \"could not evaluate referenced constant\".into_cow(),\n+            BadType(ref i) => simple!(\"value of wrong type: {:?}\", i),\n+            ErroneousReferencedConstant(_) => simple!(\"could not evaluate referenced constant\"),\n             CharCast(ref got) => {\n-                format!(\"only `u8` can be cast as `char`, not `{}`\", got.description()).into_cow()\n+                simple!(\"only `u8` can be cast as `char`, not `{}`\", got.description())\n             },\n         }\n     }\n@@ -1199,71 +1275,93 @@ fn parse_float(num: &str, fty_hint: Option<ast::FloatTy>, span: Span) -> ConstFl\n     })\n }\n \n-pub fn compare_const_vals(a: &ConstVal, b: &ConstVal) -> Option<Ordering> {\n-    match (a, b) {\n+pub fn compare_const_vals(tcx: TyCtxt, span: Span, a: &ConstVal, b: &ConstVal)\n+                          -> Result<Ordering, ErrorReported>\n+{\n+    let result = match (a, b) {\n         (&Integral(a), &Integral(b)) => a.try_cmp(b).ok(),\n         (&Float(a), &Float(b)) => a.try_cmp(b).ok(),\n         (&Str(ref a), &Str(ref b)) => Some(a.cmp(b)),\n         (&Bool(a), &Bool(b)) => Some(a.cmp(&b)),\n         (&ByteStr(ref a), &ByteStr(ref b)) => Some(a.cmp(b)),\n         (&Char(a), &Char(ref b)) => Some(a.cmp(b)),\n         _ => None,\n+    };\n+\n+    match result {\n+        Some(result) => Ok(result),\n+        None => {\n+            // FIXME: can this ever be reached?\n+            span_err!(tcx.sess, span, E0298,\n+                      \"type mismatch comparing {} and {}\",\n+                      a.description(),\n+                      b.description());\n+            Err(ErrorReported)\n+        }\n     }\n }\n \n pub fn compare_lit_exprs<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                   span: Span,\n                                    a: &Expr,\n-                                   b: &Expr) -> Option<Ordering> {\n+                                   b: &Expr) -> Result<Ordering, ErrorReported> {\n     let a = match eval_const_expr_partial(tcx, a, ExprTypeChecked, None) {\n         Ok(a) => a,\n         Err(e) => {\n-            tcx.sess.span_err(a.span, &e.description());\n-            return None;\n+            report_const_eval_err(tcx, &e, a.span, \"expression\").emit();\n+            return Err(ErrorReported);\n         }\n     };\n     let b = match eval_const_expr_partial(tcx, b, ExprTypeChecked, None) {\n         Ok(b) => b,\n         Err(e) => {\n-            tcx.sess.span_err(b.span, &e.description());\n-            return None;\n+            report_const_eval_err(tcx, &e, b.span, \"expression\").emit();\n+            return Err(ErrorReported);\n         }\n     };\n-    compare_const_vals(&a, &b)\n+    compare_const_vals(tcx, span, &a, &b)\n }\n \n \n-/// Returns the repeat count for a repeating vector expression.\n-pub fn eval_repeat_count<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                   count_expr: &hir::Expr) -> usize {\n+/// Returns the value of the length-valued expression\n+pub fn eval_length<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                             count_expr: &hir::Expr,\n+                             reason: &str)\n+                             -> Result<usize, ErrorReported>\n+{\n     let hint = UncheckedExprHint(tcx.types.usize);\n     match eval_const_expr_partial(tcx, count_expr, hint, None) {\n         Ok(Integral(Usize(count))) => {\n             let val = count.as_u64(tcx.sess.target.uint_type);\n             assert_eq!(val as usize as u64, val);\n-            val as usize\n+            Ok(val as usize)\n         },\n         Ok(const_val) => {\n             span_err!(tcx.sess, count_expr.span, E0306,\n-                      \"expected positive integer for repeat count, found {}\",\n+                      \"expected usize for {}, found {}\",\n+                      reason,\n                       const_val.description());\n-            0\n+            Err(ErrorReported)\n         }\n         Err(err) => {\n-            let err_msg = match count_expr.node {\n+            let mut diag = report_const_eval_err(\n+                tcx, &err, count_expr.span, reason);\n+\n+            match count_expr.node {\n                 hir::ExprPath(None, hir::Path {\n                     global: false,\n                     ref segments,\n                     ..\n-                }) if segments.len() == 1 =>\n-                    format!(\"found variable\"),\n-                _ => match err.kind {\n-                    MiscCatchAll => format!(\"but found {}\", err.description()),\n-                    _ => format!(\"but {}\", err.description())\n+                }) if segments.len() == 1 => {\n+                    if let Some(Def::Local(..)) = tcx.expect_def_or_none(count_expr.id) {\n+                        diag.note(&format!(\"`{}` is a variable\", segments[0].name));\n+                    }\n                 }\n-            };\n-            span_err!(tcx.sess, count_expr.span, E0307,\n-                \"expected constant integer for repeat count, {}\", err_msg);\n-            0\n+                _ => {}\n+            }\n+\n+            diag.emit();\n+            Err(ErrorReported)\n         }\n     }\n }"}, {"sha": "a6714c178e7cf68c46e750891dd39703f285c401", "filename": "src/librustc_const_eval/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -36,6 +36,7 @@\n #[macro_use] extern crate rustc;\n extern crate rustc_back;\n extern crate rustc_const_math;\n+extern crate rustc_errors;\n extern crate graphviz;\n extern crate syntax_pos;\n extern crate serialize as rustc_serialize; // used by deriving"}, {"sha": "9a94cc16bfe8ceda4709be95262b1a6ff4cdc001", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -478,10 +478,6 @@ pub fn phase_1_parse_input<'a>(sess: &'a Session,\n                                cfg: ast::CrateConfig,\n                                input: &Input)\n                                -> PResult<'a, ast::Crate> {\n-    // These may be left in an incoherent state after a previous compile.\n-    syntax::ext::hygiene::reset_hygiene_data();\n-    // `clear_ident_interner` can be used to free memory, but it does not restore the initial state.\n-    token::reset_ident_interner();\n     let continue_after_error = sess.opts.continue_parse_after_error;\n     sess.diagnostic().set_continue_after_error(continue_after_error);\n \n@@ -1298,3 +1294,11 @@ pub fn build_output_filenames(input: &Input,\n         }\n     }\n }\n+\n+// For use by the `rusti` project (https://github.com/murarth/rusti).\n+pub fn reset_thread_local_state() {\n+    // These may be left in an incoherent state after a previous compile.\n+    syntax::ext::hygiene::reset_hygiene_data();\n+    // `clear_ident_interner` can be used to free memory, but it does not restore the initial state.\n+    token::reset_ident_interner();\n+}"}, {"sha": "610e5647d6d12893547923c65d361474d0914c00", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -531,10 +531,12 @@ impl Handler {\n         DiagnosticBuilder::new(self, Level::Fatal, msg)\n     }\n \n-    pub fn cancel(&mut self, err: &mut DiagnosticBuilder) {\n+    pub fn cancel(&self, err: &mut DiagnosticBuilder) {\n         if err.level == Level::Error || err.level == Level::Fatal {\n-            assert!(self.has_errors());\n-            self.err_count.set(self.err_count.get() + 1);\n+            self.err_count.set(\n+                self.err_count.get().checked_sub(1)\n+                    .expect(\"cancelled an error but err_count is 0\")\n+            );\n         }\n         err.cancel();\n     }"}, {"sha": "b0ba38f1db67322d33aa51dac8e0d5fd41f26492", "filename": "src/librustc_passes/consts.rs", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_passes%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_passes%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fconsts.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -40,6 +40,7 @@ use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::traits::ProjectionMode;\n+use rustc::util::common::ErrorReported;\n use rustc::util::nodemap::NodeMap;\n use rustc::middle::const_qualif::ConstQualif;\n use rustc::lint::builtin::CONST_ERR;\n@@ -116,7 +117,7 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n                 _ => self.tcx.sess.add_lint(CONST_ERR, expr.id, expr.span,\n                                          format!(\"constant evaluation error: {}. This will \\\n                                                  become a HARD ERROR in the future\",\n-                                                 err.description())),\n+                                                 err.description().into_oneline())),\n             }\n         }\n         self.with_mode(mode, |this| {\n@@ -211,15 +212,6 @@ impl<'a, 'gcx> CheckCrateVisitor<'a, 'gcx> {\n             }\n         }\n     }\n-\n-    fn msg(&self) -> &'static str {\n-        match self.mode {\n-            Mode::Const => \"constant\",\n-            Mode::ConstFn => \"constant function\",\n-            Mode::StaticMut | Mode::Static => \"static\",\n-            Mode::Var => bug!(),\n-        }\n-    }\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n@@ -289,18 +281,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 self.global_expr(Mode::Const, &start);\n                 self.global_expr(Mode::Const, &end);\n \n-                match compare_lit_exprs(self.tcx, start, end) {\n-                    Some(Ordering::Less) |\n-                    Some(Ordering::Equal) => {}\n-                    Some(Ordering::Greater) => {\n+                match compare_lit_exprs(self.tcx, p.span, start, end) {\n+                    Ok(Ordering::Less) |\n+                    Ok(Ordering::Equal) => {}\n+                    Ok(Ordering::Greater) => {\n                         span_err!(self.tcx.sess, start.span, E0030,\n                             \"lower range bound must be less than or equal to upper\");\n                     }\n-                    None => {\n-                        span_err!(self.tcx.sess, p.span, E0014,\n-                                  \"paths in {}s may only refer to constants\",\n-                                  self.msg());\n-                    }\n+                    Err(ErrorReported) => {}\n                 }\n             }\n             _ => intravisit::walk_pat(self, p)\n@@ -429,7 +417,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 Err(msg) => {\n                     self.tcx.sess.add_lint(CONST_ERR, ex.id,\n                                            msg.span,\n-                                           msg.description().into_owned())\n+                                           msg.description().into_oneline().into_owned())\n                 }\n             }\n         }"}, {"sha": "a616b95ef7203ad312ba54a6a6af4c127d907aca", "filename": "src/librustc_passes/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_passes%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_passes%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdiagnostics.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -11,7 +11,7 @@\n #![allow(non_snake_case)]\n \n register_long_diagnostics! {\n-\n+/*\n E0014: r##\"\n Constants can only be initialized by a constant value or, in a future\n version of Rust, a call to a const function. This error indicates the use\n@@ -30,7 +30,7 @@ const FOO: i32 = { const X : i32 = 0; X };\n const FOO2: i32 = { 0 }; // but brackets are useless here\n ```\n \"##,\n-\n+*/\n E0030: r##\"\n When matching against a range, the compiler verifies that the range is\n non-empty.  Range patterns include both end-points, so this is equivalent to"}, {"sha": "0fd95500422ff193af8a29aa1f8ea615657eb775", "filename": "src/librustc_save_analysis/csv_dumper.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fcsv_dumper.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -427,7 +427,7 @@ fn make_values_str(pairs: &[(&'static str, &str)]) -> String {\n }\n \n fn span_extent_str(span: SpanData) -> String {\n-    format!(\"file_name,\\\"{}\\\",file_line,{},file_col,{},byte_start,{}\\\n+    format!(\"file_name,\\\"{}\\\",file_line,{},file_col,{},byte_start,{},\\\n              file_line_end,{},file_col_end,{},byte_end,{}\",\n              span.file_name, span.line_start, span.column_start, span.byte_start,\n              span.line_end, span.column_end, span.byte_end)"}, {"sha": "f7fd970f37f2f89e1a4686f541ef9ea5984343bc", "filename": "src/librustc_trans/_match.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_trans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_trans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2F_match.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -190,7 +190,7 @@ use self::FailureHandler::*;\n \n use llvm::{ValueRef, BasicBlockRef};\n use rustc_const_eval::check_match::{self, Constructor, StaticInliner};\n-use rustc_const_eval::{compare_lit_exprs, eval_const_expr};\n+use rustc_const_eval::{compare_lit_exprs, eval_const_expr, fatal_const_eval_err};\n use rustc::hir::def::{Def, DefMap};\n use rustc::hir::def_id::DefId;\n use middle::expr_use_visitor as euv;\n@@ -239,9 +239,9 @@ struct ConstantExpr<'a>(&'a hir::Expr);\n \n impl<'a> ConstantExpr<'a> {\n     fn eq<'b, 'tcx>(self, other: ConstantExpr<'a>, tcx: TyCtxt<'b, 'tcx, 'tcx>) -> bool {\n-        match compare_lit_exprs(tcx, self.0, other.0) {\n-            Some(result) => result == Ordering::Equal,\n-            None => bug!(\"compare_list_exprs: type mismatch\"),\n+        match compare_lit_exprs(tcx, self.0.span, self.0, other.0) {\n+            Ok(result) => result == Ordering::Equal,\n+            Err(_) => bug!(\"compare_list_exprs: type mismatch\"),\n         }\n     }\n }\n@@ -288,7 +288,9 @@ impl<'a, 'b, 'tcx> Opt<'a, 'tcx> {\n                 let expr = consts::const_expr(ccx, &lit_expr, bcx.fcx.param_substs, None, Yes);\n                 let llval = match expr {\n                     Ok((llval, _)) => llval,\n-                    Err(err) => bcx.ccx().sess().span_fatal(lit_expr.span, &err.description()),\n+                    Err(err) => {\n+                        fatal_const_eval_err(bcx.tcx(), err.as_inner(), lit_expr.span, \"pattern\");\n+                    }\n                 };\n                 let lit_datum = immediate_rvalue(llval, lit_ty);\n                 let lit_datum = unpack_datum!(bcx, lit_datum.to_appropriate_datum(bcx));\n@@ -297,11 +299,11 @@ impl<'a, 'b, 'tcx> Opt<'a, 'tcx> {\n             ConstantRange(ConstantExpr(ref l1), ConstantExpr(ref l2), _) => {\n                 let l1 = match consts::const_expr(ccx, &l1, bcx.fcx.param_substs, None, Yes) {\n                     Ok((l1, _)) => l1,\n-                    Err(err) => bcx.ccx().sess().span_fatal(l1.span, &err.description()),\n+                    Err(err) => fatal_const_eval_err(bcx.tcx(), err.as_inner(), l1.span, \"pattern\"),\n                 };\n                 let l2 = match consts::const_expr(ccx, &l2, bcx.fcx.param_substs, None, Yes) {\n                     Ok((l2, _)) => l2,\n-                    Err(err) => bcx.ccx().sess().span_fatal(l2.span, &err.description()),\n+                    Err(err) => fatal_const_eval_err(bcx.tcx(), err.as_inner(), l2.span, \"pattern\"),\n                 };\n                 RangeResult(Result::new(bcx, l1), Result::new(bcx, l2))\n             }"}, {"sha": "f662ba75cc6fea7c5e4f014d30e4c69ba67171f8", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -14,7 +14,7 @@ use llvm::{ConstFCmp, ConstICmp, SetLinkage, SetUnnamedAddr};\n use llvm::{InternalLinkage, ValueRef, Bool, True};\n use middle::const_qualif::ConstQualif;\n use rustc_const_eval::{ConstEvalErr, lookup_const_fn_by_id, lookup_const_by_id, ErrKind};\n-use rustc_const_eval::eval_repeat_count;\n+use rustc_const_eval::{eval_length, report_const_eval_err, note_const_eval_err};\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map as hir_map;\n@@ -44,7 +44,6 @@ use rustc_const_math::{ConstInt, ConstUsize, ConstIsize};\n use rustc::hir;\n \n use std::ffi::{CStr, CString};\n-use std::borrow::Cow;\n use libc::c_uint;\n use syntax::ast::{self, LitKind};\n use syntax::attr::{self, AttrMetaMethods};\n@@ -250,10 +249,11 @@ impl ConstEvalFailure {\n             Compiletime(e) => e,\n         }\n     }\n-    pub fn description(&self) -> Cow<str> {\n+\n+    pub fn as_inner(&self) -> &ConstEvalErr {\n         match self {\n-            &Runtime(ref e) => e.description(),\n-            &Compiletime(ref e) => e.description(),\n+            &Runtime(ref e) => e,\n+            &Compiletime(ref e) => e,\n         }\n     }\n }\n@@ -274,7 +274,7 @@ fn get_const_val<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let empty_substs = ccx.tcx().mk_substs(Substs::empty());\n     match get_const_expr_as_global(ccx, expr, ConstQualif::empty(), empty_substs, TrueConst::Yes) {\n         Err(Runtime(err)) => {\n-            ccx.tcx().sess.span_err(expr.span, &err.description());\n+            report_const_eval_err(ccx.tcx(), &err, expr.span, \"expression\").emit();\n             Err(Compiletime(err))\n         },\n         other => other,\n@@ -526,12 +526,15 @@ pub fn const_err<T>(cx: &CrateContext,\n         (Ok(x), _) => Ok(x),\n         (Err(err), TrueConst::Yes) => {\n             let err = ConstEvalErr{ span: span, kind: err };\n-            cx.tcx().sess.span_err(span, &err.description());\n+            report_const_eval_err(cx.tcx(), &err, span, \"expression\").emit();\n             Err(Compiletime(err))\n         },\n         (Err(err), TrueConst::No) => {\n             let err = ConstEvalErr{ span: span, kind: err };\n-            cx.tcx().sess.span_warn(span, &err.description());\n+            let mut diag = cx.tcx().sess.struct_span_warn(\n+                span, \"this expression will panic at run-time\");\n+            note_const_eval_err(cx.tcx(), &err, span, \"expression\", &mut diag);\n+            diag.emit();\n             Err(Runtime(err))\n         },\n     }\n@@ -875,7 +878,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         hir::ExprRepeat(ref elem, ref count) => {\n             let unit_ty = ety.sequence_element_type(cx.tcx());\n             let llunitty = type_of::type_of(cx, unit_ty);\n-            let n = eval_repeat_count(cx.tcx(), count);\n+            let n = eval_length(cx.tcx(), count, \"repeat count\").unwrap();\n             let unit_val = const_expr(cx, &elem, param_substs, fn_args, trueconst)?.0;\n             let vs = vec![unit_val; n];\n             if val_ty(unit_val) != llunitty {"}, {"sha": "e657a086581e2dadfff30deedc5c7a07288b6861", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -44,6 +44,7 @@ use syntax::ptr::P;\n use syntax::parse::token;\n \n use rustc::session::Session;\n+use rustc_const_eval::fatal_const_eval_err;\n use syntax_pos::{Span, DUMMY_SP};\n \n use std::cmp::Ordering;\n@@ -1414,7 +1415,10 @@ fn generic_simd_intrinsic<'blk, 'tcx, 'a>\n                                          // this should probably help simd error reporting\n                                          consts::TrueConst::Yes) {\n                     Ok((vector, _)) => vector,\n-                    Err(err) => bcx.sess().span_fatal(span, &err.description()),\n+                    Err(err) => {\n+                        fatal_const_eval_err(bcx.tcx(), err.as_inner(), span,\n+                                             \"shuffle indices\");\n+                    }\n                 }\n             }\n             None => llargs[2]"}, {"sha": "1f3b13203163f7fbf6cbab2ea681e6fea84572f7", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -925,7 +925,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n             Err(ConstEvalFailure::Runtime(err)) => {\n                 span_bug!(constant.span,\n-                          \"MIR constant {:?} results in runtime panic: {}\",\n+                          \"MIR constant {:?} results in runtime panic: {:?}\",\n                           constant, err.description())\n             }\n         }"}, {"sha": "fc95d208f32ccdda8c926e2be3a03e1a6c11eb95", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -29,6 +29,7 @@ use rustc::hir::def_id::DefId;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::subst;\n use rustc::dep_graph::DepNode;\n+use rustc_const_eval::fatal_const_eval_err;\n use std::hash::{Hash, Hasher};\n use syntax::ast::{self, NodeId};\n use syntax::{attr,errors};\n@@ -81,7 +82,11 @@ impl<'a, 'tcx> TransItem<'tcx> {\n                 if let hir::ItemStatic(_, m, ref expr) = item.node {\n                     match consts::trans_static(&ccx, m, expr, item.id, &item.attrs) {\n                         Ok(_) => { /* Cool, everything's alright. */ },\n-                        Err(err) => ccx.tcx().sess.span_fatal(expr.span, &err.description()),\n+                        Err(err) => {\n+                            // FIXME: shouldn't this be a `span_err`?\n+                            fatal_const_eval_err(\n+                                ccx.tcx(), &err, expr.span, \"static\");\n+                        }\n                     };\n                 } else {\n                     span_bug!(item.span, \"Mismatch between hir::Item type and TransItem type\")"}, {"sha": "92a2d3787bfd6b60bc5184233f24893e10e91ab3", "filename": "src/librustc_trans/tvec.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_trans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_trans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftvec.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -30,7 +30,7 @@ use value::Value;\n use rustc::ty::{self, Ty};\n \n use rustc::hir;\n-use rustc_const_eval::eval_repeat_count;\n+use rustc_const_eval::eval_length;\n \n use syntax::ast;\n use syntax::parse::token::InternedString;\n@@ -218,7 +218,7 @@ fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     return expr::trans_into(bcx, &element, Ignore);\n                 }\n                 SaveIn(lldest) => {\n-                    match eval_repeat_count(bcx.tcx(), &count_expr) {\n+                    match eval_length(bcx.tcx(), &count_expr, \"repeat count\").unwrap() {\n                         0 => expr::trans_into(bcx, &element, Ignore),\n                         1 => expr::trans_into(bcx, &element, SaveIn(lldest)),\n                         count => {\n@@ -268,7 +268,7 @@ fn elements_required(bcx: Block, content_expr: &hir::Expr) -> usize {\n         },\n         hir::ExprVec(ref es) => es.len(),\n         hir::ExprRepeat(_, ref count_expr) => {\n-            eval_repeat_count(bcx.tcx(), &count_expr)\n+            eval_length(bcx.tcx(), &count_expr, \"repeat count\").unwrap()\n         }\n         _ => span_bug!(content_expr.span, \"unexpected vec content\")\n     }"}, {"sha": "b642a7122194de3059babc25f116b8725dbd31a1", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 5, "deletions": 32, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -48,10 +48,7 @@\n //! case but `&a` in the second.  Basically, defaults that appear inside\n //! an rptr (`&r.T`) use the region `r` that appears in the rptr.\n \n-use middle::const_val::ConstVal;\n-use rustc_const_eval::{eval_const_expr_partial, ConstEvalErr};\n-use rustc_const_eval::EvalHint::UncheckedExprHint;\n-use rustc_const_eval::ErrKind::ErroneousReferencedConstant;\n+use rustc_const_eval::eval_length;\n use hir::{self, SelfKind};\n use hir::def::{Def, PathResolution};\n use hir::def_id::DefId;\n@@ -70,7 +67,6 @@ use rscope::{self, UnelidableRscope, RegionScope, ElidableRscope,\n use util::common::{ErrorReported, FN_OUTPUT_NAME};\n use util::nodemap::{NodeMap, FnvHashSet};\n \n-use rustc_const_math::ConstInt;\n use std::cell::RefCell;\n use syntax::{abi, ast};\n use syntax::feature_gate::{GateIssue, emit_feature_err};\n@@ -1741,33 +1737,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                 ty\n             }\n             hir::TyFixedLengthVec(ref ty, ref e) => {\n-                let hint = UncheckedExprHint(tcx.types.usize);\n-                match eval_const_expr_partial(tcx.global_tcx(), &e, hint, None) {\n-                    Ok(ConstVal::Integral(ConstInt::Usize(i))) => {\n-                        let i = i.as_u64(tcx.sess.target.uint_type);\n-                        assert_eq!(i as usize as u64, i);\n-                        tcx.mk_array(self.ast_ty_to_ty(rscope, &ty), i as usize)\n-                    },\n-                    Ok(val) => {\n-                        span_err!(tcx.sess, ast_ty.span, E0249,\n-                                  \"expected usize value for array length, got {}\",\n-                                  val.description());\n-                        self.tcx().types.err\n-                    },\n-                    // array length errors happen before the global constant check\n-                    // so we need to report the real error\n-                    Err(ConstEvalErr { kind: ErroneousReferencedConstant(box r), ..}) |\n-                    Err(r) => {\n-                        let mut err = struct_span_err!(tcx.sess, r.span, E0250,\n-                                                       \"array length constant \\\n-                                                        evaluation error: {}\",\n-                                                       r.description());\n-                        if !ast_ty.span.contains(r.span) {\n-                            span_note!(&mut err, ast_ty.span, \"for array length here\")\n-                        }\n-                        err.emit();\n-                        self.tcx().types.err\n-                    }\n+                if let Ok(length) = eval_length(tcx.global_tcx(), &e, \"array length\") {\n+                    tcx.mk_array(self.ast_ty_to_ty(rscope, &ty), length)\n+                } else {\n+                    self.tcx().types.err\n                 }\n             }\n             hir::TyTypeof(ref _e) => {"}, {"sha": "aae6e3ad36dfe7ee2ba7b1ec173cd2d3f8193a82", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -103,15 +103,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     return;\n                 }\n \n-                // Check that the types of the end-points can be unified.\n-                let types_unify = self.require_same_types(pat.span, rhs_ty, lhs_ty,\n-                                                          \"mismatched types in range\");\n-\n-                // It's ok to return without a message as `require_same_types` prints an error.\n-                if !types_unify {\n-                    return;\n-                }\n-\n                 // Now that we know the types can be unified we find the unified type and use\n                 // it to type the entire expression.\n                 let common_type = self.resolve_type_vars_if_possible(&lhs_ty);\n@@ -120,6 +111,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n                 // subtyping doesn't matter here, as the value is some kind of scalar\n                 self.demand_eqtype(pat.span, expected, lhs_ty);\n+                self.demand_eqtype(pat.span, expected, rhs_ty);\n             }\n             PatKind::Binding(bm, _, ref sub) => {\n                 let typ = self.local_ty(pat.span, pat.id);"}, {"sha": "9c6727ebbfcf955d30f6507ef5b1719b3b5314d5", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -216,7 +216,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             _ => {\n                 let mut err = self.type_error_struct(call_expr.span, |actual| {\n                     format!(\"expected function, found `{}`\", actual)\n-                }, callee_ty, None);\n+                }, callee_ty);\n \n                 if let hir::ExprCall(ref expr, _) = call_expr.node {\n                     let tcx = self.tcx;"}, {"sha": "7a4cc09a7d5064d3a9ac408103df64cdf885dca3", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -149,7 +149,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                     format!(\"casting `{}` as `{}` is invalid\",\n                             actual,\n                             fcx.ty_to_string(self.cast_ty))\n-                }, self.expr_ty, None)\n+                }, self.expr_ty)\n                     .help(&format!(\"cast through {} first\", match e {\n                             CastError::NeedViaPtr => \"a raw pointer\",\n                             CastError::NeedViaThinPtr => \"a thin pointer\",\n@@ -167,35 +167,35 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n             CastError::CastToChar => {\n                 fcx.type_error_message(self.span, |actual| {\n                     format!(\"only `u8` can be cast as `char`, not `{}`\", actual)\n-                }, self.expr_ty, None);\n+                }, self.expr_ty);\n             }\n             CastError::NonScalar => {\n                 fcx.type_error_message(self.span, |actual| {\n                     format!(\"non-scalar cast: `{}` as `{}`\",\n                             actual,\n                             fcx.ty_to_string(self.cast_ty))\n-                }, self.expr_ty, None);\n+                }, self.expr_ty);\n             }\n             CastError::IllegalCast => {\n                 fcx.type_error_message(self.span, |actual| {\n                     format!(\"casting `{}` as `{}` is invalid\",\n                             actual,\n                             fcx.ty_to_string(self.cast_ty))\n-                }, self.expr_ty, None);\n+                }, self.expr_ty);\n             }\n             CastError::SizedUnsizedCast => {\n                 fcx.type_error_message(self.span, |actual| {\n                     format!(\"cannot cast thin pointer `{}` to fat pointer `{}`\",\n                             actual,\n                             fcx.ty_to_string(self.cast_ty))\n-                }, self.expr_ty, None)\n+                }, self.expr_ty)\n             }\n             CastError::DifferingKinds => {\n                 fcx.type_error_struct(self.span, |actual| {\n                     format!(\"casting `{}` as `{}` is invalid\",\n                             actual,\n                             fcx.ty_to_string(self.cast_ty))\n-                }, self.expr_ty, None)\n+                }, self.expr_ty)\n                     .note(\"vtable kinds may not match\")\n                     .emit();\n             }\n@@ -213,7 +213,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n         let tstr = fcx.ty_to_string(self.cast_ty);\n         let mut err = fcx.type_error_struct(self.span, |actual| {\n             format!(\"cast to unsized type: `{}` as `{}`\", actual, tstr)\n-        }, self.expr_ty, None);\n+        }, self.expr_ty);\n         match self.expr_ty.sty {\n             ty::TyRef(_, ty::TypeAndMut { mutbl: mt, .. }) => {\n                 let mtstr = match mt {\n@@ -484,4 +484,3 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         traits::type_known_to_meet_builtin_bound(self, ty, ty::BoundSized, span)\n     }\n }\n-"}, {"sha": "9844377d0bd32f5241c1e0cb948f48597c1d5673", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -12,6 +12,7 @@ use middle::free_region::FreeRegionMap;\n use rustc::infer::{self, InferOk, TypeOrigin};\n use rustc::ty;\n use rustc::traits::{self, ProjectionMode};\n+use rustc::ty::error::ExpectedFound;\n use rustc::ty::subst::{self, Subst, Substs, VecPerParamSpace};\n \n use syntax::ast;\n@@ -324,10 +325,19 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             debug!(\"sub_types failed: impl ty {:?}, trait ty {:?}\",\n                    impl_fty,\n                    trait_fty);\n-            span_err!(tcx.sess, impl_m_span, E0053,\n-                      \"method `{}` has an incompatible type for trait: {}\",\n-                      trait_m.name,\n-                      terr);\n+\n+            let mut diag = struct_span_err!(\n+                tcx.sess, origin.span(), E0053,\n+                \"method `{}` has an incompatible type for trait\", trait_m.name\n+            );\n+            infcx.note_type_err(\n+                &mut diag, origin,\n+                Some(infer::ValuePairs::Types(ExpectedFound {\n+                    expected: trait_fty,\n+                    found: impl_fty\n+                })), &terr\n+            );\n+            diag.emit();\n             return\n         }\n \n@@ -437,10 +447,9 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         // Compute skolemized form of impl and trait const tys.\n         let impl_ty = impl_c.ty.subst(tcx, impl_to_skol_substs);\n         let trait_ty = trait_c.ty.subst(tcx, &trait_to_skol_substs);\n+        let origin = TypeOrigin::Misc(impl_c_span);\n \n         let err = infcx.commit_if_ok(|_| {\n-            let origin = TypeOrigin::Misc(impl_c_span);\n-\n             // There is no \"body\" here, so just pass dummy id.\n             let impl_ty =\n                 assoc::normalize_associated_types_in(&infcx,\n@@ -473,11 +482,19 @@ pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             debug!(\"checking associated const for compatibility: impl ty {:?}, trait ty {:?}\",\n                    impl_ty,\n                    trait_ty);\n-            span_err!(tcx.sess, impl_c_span, E0326,\n-                      \"implemented const `{}` has an incompatible type for \\\n-                      trait: {}\",\n-                      trait_c.name,\n-                      terr);\n+            let mut diag = struct_span_err!(\n+                tcx.sess, origin.span(), E0326,\n+                \"implemented const `{}` has an incompatible type for trait\",\n+                trait_c.name\n+            );\n+            infcx.note_type_err(\n+                &mut diag, origin,\n+                Some(infer::ValuePairs::Types(ExpectedFound {\n+                    expected: trait_ty,\n+                    found: impl_ty\n+                })), &terr\n+            );\n+            diag.emit();\n         }\n     });\n }"}, {"sha": "1f3a83ebc1d567da7a2ae7174213e62feaafd451", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -33,7 +33,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn demand_eqtype(&self, sp: Span, expected: Ty<'tcx>, actual: Ty<'tcx>) {\n-        let origin = TypeOrigin::Misc(sp);\n+        self.demand_eqtype_with_origin(TypeOrigin::Misc(sp), expected, actual);\n+    }\n+\n+    pub fn demand_eqtype_with_origin(&self,\n+                                     origin: TypeOrigin,\n+                                     expected: Ty<'tcx>,\n+                                     actual: Ty<'tcx>)\n+    {\n         match self.eq_types(false, origin, actual, expected) {\n             Ok(InferOk { obligations, .. }) => {\n                 // FIXME(#32730) propagate obligations\n@@ -54,16 +61,4 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.report_mismatched_types(origin, expected, expr_ty, e);\n         }\n     }\n-\n-    pub fn require_same_types(&self, span: Span, t1: Ty<'tcx>, t2: Ty<'tcx>, msg: &str)\n-                              -> bool {\n-        if let Err(err) = self.eq_types(false, TypeOrigin::Misc(span), t1, t2) {\n-            let found_ty = self.resolve_type_vars_if_possible(&t1);\n-            let expected_ty = self.resolve_type_vars_if_possible(&t2);\n-            ::emit_type_err(self.tcx, span, found_ty, expected_ty, &err, msg);\n-            false\n-        } else {\n-            true\n-        }\n-    }\n }"}, {"sha": "8a53c59b4c7fad08dafbe1215cb6d8bf52914885", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -12,6 +12,7 @@\n //! intrinsics that the compiler exposes.\n \n use intrinsics;\n+use rustc::infer::TypeOrigin;\n use rustc::ty::subst::{self, Substs};\n use rustc::ty::FnSig;\n use rustc::ty::{self, Ty};\n@@ -56,10 +57,9 @@ fn equate_intrinsic_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n              i_n_tps, n_tps);\n     } else {\n         require_same_types(ccx,\n-                           it.span,\n+                           TypeOrigin::IntrinsicType(it.span),\n                            i_ty.ty,\n-                           fty,\n-                           \"intrinsic has wrong type\");\n+                           fty);\n     }\n }\n "}, {"sha": "346449d0a51331465bde2b99b5eec3048bb74e7c", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -160,8 +160,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 item_name,\n                                 actual)\n                     },\n-                    rcvr_ty,\n-                    None);\n+                    rcvr_ty);\n \n                 // If the item has the name of a field, give a help note\n                 if let (&ty::TyStruct(def, substs), Some(expr)) = (&rcvr_ty.sty, rcvr_expr) {"}, {"sha": "6062bd048b3d27f8972edfbdce5efa766c448aab", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -126,7 +126,7 @@ use rustc::hir::intravisit::{self, Visitor};\n use rustc::hir::{self, PatKind};\n use rustc::hir::print as pprust;\n use rustc_back::slice;\n-use rustc_const_eval::eval_repeat_count;\n+use rustc_const_eval::eval_length;\n \n mod assoc;\n mod autoderef;\n@@ -2541,21 +2541,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         self.type_error_message(arg.span, |t| {\n                             format!(\"can't pass an `{}` to variadic \\\n                                      function, cast to `c_double`\", t)\n-                        }, arg_ty, None);\n+                        }, arg_ty);\n                     }\n                     ty::TyInt(ast::IntTy::I8) | ty::TyInt(ast::IntTy::I16) | ty::TyBool => {\n                         self.type_error_message(arg.span, |t| {\n                             format!(\"can't pass `{}` to variadic \\\n                                      function, cast to `c_int`\",\n                                            t)\n-                        }, arg_ty, None);\n+                        }, arg_ty);\n                     }\n                     ty::TyUint(ast::UintTy::U8) | ty::TyUint(ast::UintTy::U16) => {\n                         self.type_error_message(arg.span, |t| {\n                             format!(\"can't pass `{}` to variadic \\\n                                      function, cast to `c_uint`\",\n                                            t)\n-                        }, arg_ty, None);\n+                        }, arg_ty);\n                     }\n                     ty::TyFnDef(_, _, f) => {\n                         let ptr_ty = self.tcx.mk_fn_ptr(f);\n@@ -2564,7 +2564,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                 |t| {\n                             format!(\"can't pass `{}` to variadic \\\n                                      function, cast to `{}`\", t, ptr_ty)\n-                        }, arg_ty, None);\n+                        }, arg_ty);\n                     }\n                     _ => {}\n                 }\n@@ -2908,9 +2908,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.type_error_struct(field.span, |actual| {\n                 format!(\"attempted to take value of method `{}` on type \\\n                          `{}`\", field.node, actual)\n-            }, expr_t, None)\n-                .help(\n-                       \"maybe a `()` to call it is missing? \\\n+            }, expr_t)\n+                .help(\"maybe a `()` to call it is missing? \\\n                        If not, try an anonymous function\")\n                 .emit();\n             self.write_error(expr.id);\n@@ -2919,7 +2918,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 format!(\"attempted access of field `{}` on type `{}`, \\\n                          but no field with that name was found\",\n                         field.node, actual)\n-            }, expr_t, None);\n+            }, expr_t);\n             if let ty::TyStruct(def, _) = expr_t.sty {\n                 Self::suggest_field_names(&mut err, def.struct_variant(), field, vec![]);\n             }\n@@ -3019,7 +3018,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     actual)\n                 }\n             },\n-            expr_t, None);\n+            expr_t);\n \n         self.write_error(expr.id);\n     }\n@@ -3029,17 +3028,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             variant: ty::VariantDef<'tcx>,\n                             field: &hir::Field,\n                             skip_fields: &[hir::Field]) {\n-        let mut err = self.type_error_struct(\n+        let mut err = self.type_error_struct_with_diag(\n             field.name.span,\n             |actual| if let ty::TyEnum(..) = ty.sty {\n-                format!(\"struct variant `{}::{}` has no field named `{}`\",\n-                        actual, variant.name.as_str(), field.name.node)\n+                struct_span_err!(self.tcx.sess, field.name.span, E0559,\n+                                 \"struct variant `{}::{}` has no field named `{}`\",\n+                                 actual, variant.name.as_str(), field.name.node)\n             } else {\n-                format!(\"structure `{}` has no field named `{}`\",\n-                        actual, field.name.node)\n+                struct_span_err!(self.tcx.sess, field.name.span, E0560,\n+                                 \"structure `{}` has no field named `{}`\",\n+                                 actual, field.name.node)\n             },\n-            ty,\n-            None);\n+            ty);\n         // prevent all specified fields from being suggested\n         let skip_fields = skip_fields.iter().map(|ref x| x.name.node.as_str());\n         Self::suggest_field_names(&mut err, variant, &field.name, skip_fields.collect());\n@@ -3272,7 +3272,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             self.type_error_message(expr.span, |actual| {\n                                 format!(\"type `{}` cannot be \\\n                                         dereferenced\", actual)\n-                            }, oprnd_t, None);\n+                            }, oprnd_t);\n                             oprnd_t = tcx.types.err;\n                         }\n                     }\n@@ -3541,7 +3541,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n           }\n           hir::ExprRepeat(ref element, ref count_expr) => {\n             self.check_expr_has_type(&count_expr, tcx.types.usize);\n-            let count = eval_repeat_count(self.tcx.global_tcx(), &count_expr);\n+            let count = eval_length(self.tcx.global_tcx(), &count_expr, \"repeat count\")\n+                  .unwrap_or(0);\n \n             let uty = match expected {\n                 ExpectHasType(uty) => {\n@@ -3647,8 +3648,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   format!(\"cannot index a value of type `{}`\",\n                                           actual)\n                               },\n-                              base_t,\n-                              None);\n+                              base_t);\n                           // Try to give some advice about indexing tuples.\n                           if let ty::TyTuple(_) = base_t.sty {\n                               let mut needs_note = true;\n@@ -4523,7 +4523,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if !self.is_tainted_by_errors() {\n                     self.type_error_message(sp, |_actual| {\n                         \"the type of this value must be known in this context\".to_string()\n-                    }, ty, None);\n+                    }, ty);\n                 }\n                 self.demand_suptype(sp, self.tcx.types.err, ty);\n                 ty = self.tcx.types.err;"}, {"sha": "d02f87d0b9cd64236700279cd10bfc1744f0c7af", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -239,7 +239,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.type_error_message(ex.span, |actual| {\n                     format!(\"cannot apply unary operator `{}` to type `{}`\",\n                             op_str, actual)\n-                }, operand_ty, None);\n+                }, operand_ty);\n                 self.tcx.types.err\n             }\n         }"}, {"sha": "907cb734c2ff9f00128641761e20eb9543b323fe", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -13,6 +13,7 @@ use constrained_type_params::{identify_constrained_type_params, Parameter};\n use CrateCtxt;\n use hir::def_id::DefId;\n use middle::region::{CodeExtent};\n+use rustc::infer::TypeOrigin;\n use rustc::ty::subst::{self, TypeSpace, FnSpace, ParamSpace, SelfSpace};\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -157,7 +158,10 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n         }\n     }\n \n-    fn check_trait_or_impl_item(&mut self, item_id: ast::NodeId, span: Span) {\n+    fn check_trait_or_impl_item(&mut self,\n+                                item_id: ast::NodeId,\n+                                span: Span,\n+                                sig_if_method: Option<&hir::MethodSig>) {\n         let code = self.code.clone();\n         self.for_id(item_id, span).with_fcx(|fcx, this| {\n             let free_substs = &fcx.parameter_environment.free_substs;\n@@ -182,7 +186,8 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                     let predicates = fcx.instantiate_bounds(span, free_substs, &method.predicates);\n                     this.check_fn_or_method(fcx, span, &method_ty, &predicates,\n                                             free_id_outlive, &mut implied_bounds);\n-                    this.check_method_receiver(fcx, span, &method,\n+                    let sig_if_method = sig_if_method.expect(\"bad signature for method\");\n+                    this.check_method_receiver(fcx, sig_if_method, &method,\n                                                free_id_outlive, self_ty);\n                 }\n                 ty::TypeTraitItem(assoc_type) => {\n@@ -405,20 +410,15 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n \n     fn check_method_receiver<'fcx, 'tcx>(&mut self,\n                                          fcx: &FnCtxt<'fcx, 'gcx, 'tcx>,\n-                                         span: Span,\n+                                         method_sig: &hir::MethodSig,\n                                          method: &ty::Method<'tcx>,\n                                          free_id_outlive: CodeExtent,\n                                          self_ty: ty::Ty<'tcx>)\n     {\n         // check that the type of the method's receiver matches the\n         // method's first parameter.\n-\n-        let free_substs = &fcx.parameter_environment.free_substs;\n-        let fty = fcx.instantiate_type_scheme(span, free_substs, &method.fty);\n-        let sig = fcx.tcx.liberate_late_bound_regions(free_id_outlive, &fty.sig);\n-\n-        debug!(\"check_method_receiver({:?},cat={:?},self_ty={:?},sig={:?})\",\n-               method.name, method.explicit_self, self_ty, sig);\n+        debug!(\"check_method_receiver({:?},cat={:?},self_ty={:?})\",\n+               method.name, method.explicit_self, self_ty);\n \n         let rcvr_ty = match method.explicit_self {\n             ty::ExplicitSelfCategory::Static => return,\n@@ -431,14 +431,23 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n             }\n             ty::ExplicitSelfCategory::ByBox => fcx.tcx.mk_box(self_ty)\n         };\n+\n+        let span = method_sig.decl.inputs[0].pat.span;\n+\n+        let free_substs = &fcx.parameter_environment.free_substs;\n+        let fty = fcx.instantiate_type_scheme(span, free_substs, &method.fty);\n+        let sig = fcx.tcx.liberate_late_bound_regions(free_id_outlive, &fty.sig);\n+\n+        debug!(\"check_method_receiver: sig={:?}\", sig);\n+\n         let rcvr_ty = fcx.instantiate_type_scheme(span, free_substs, &rcvr_ty);\n         let rcvr_ty = fcx.tcx.liberate_late_bound_regions(free_id_outlive,\n                                                           &ty::Binder(rcvr_ty));\n \n         debug!(\"check_method_receiver: receiver ty = {:?}\", rcvr_ty);\n \n-        fcx.require_same_types(span, sig.inputs[0], rcvr_ty,\n-                               \"mismatched method receiver\");\n+        let origin = TypeOrigin::MethodReceiver(span);\n+        fcx.demand_eqtype_with_origin(origin, rcvr_ty, sig.inputs[0]);\n     }\n \n     fn check_variances_for_type_defn(&self,\n@@ -553,13 +562,21 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n \n     fn visit_trait_item(&mut self, trait_item: &'v hir::TraitItem) {\n         debug!(\"visit_trait_item: {:?}\", trait_item);\n-        self.check_trait_or_impl_item(trait_item.id, trait_item.span);\n+        let method_sig = match trait_item.node {\n+            hir::TraitItem_::MethodTraitItem(ref sig, _) => Some(sig),\n+            _ => None\n+        };\n+        self.check_trait_or_impl_item(trait_item.id, trait_item.span, method_sig);\n         intravisit::walk_trait_item(self, trait_item)\n     }\n \n     fn visit_impl_item(&mut self, impl_item: &'v hir::ImplItem) {\n         debug!(\"visit_impl_item: {:?}\", impl_item);\n-        self.check_trait_or_impl_item(impl_item.id, impl_item.span);\n+        let method_sig = match impl_item.node {\n+            hir::ImplItemKind::Method(ref sig, _) => Some(sig),\n+            _ => None\n+        };\n+        self.check_trait_or_impl_item(impl_item.id, impl_item.span, method_sig);\n         intravisit::walk_impl_item(self, impl_item)\n     }\n }"}, {"sha": "57602b55cc96f10e5bb4110692cd481c361bdf95", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -66,8 +66,7 @@ use constrained_type_params as ctp;\n use middle::lang_items::SizedTraitLangItem;\n use middle::const_val::ConstVal;\n use rustc_const_eval::EvalHint::UncheckedExprHint;\n-use rustc_const_eval::{eval_const_expr_partial, ConstEvalErr};\n-use rustc_const_eval::ErrKind::ErroneousReferencedConstant;\n+use rustc_const_eval::{eval_const_expr_partial, report_const_eval_err};\n use rustc::ty::subst::{Substs, FnSpace, ParamSpace, SelfSpace, TypeSpace, VecPerParamSpace};\n use rustc::ty::{ToPredicate, ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeScheme};\n@@ -1091,14 +1090,9 @@ fn convert_struct_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             },\n             // enum variant evaluation happens before the global constant check\n             // so we need to report the real error\n-            Err(ConstEvalErr { kind: ErroneousReferencedConstant(box err), ..}) |\n             Err(err) => {\n-                let mut diag = struct_span_err!(ccx.tcx.sess, err.span, E0080,\n-                                                \"constant evaluation error: {}\",\n-                                                err.description());\n-                if !e.span.contains(err.span) {\n-                    diag.span_note(e.span, \"for enum discriminant here\");\n-                }\n+                let mut diag = report_const_eval_err(\n+                    ccx.tcx, &err, e.span, \"enum discriminant\");\n                 diag.emit();\n                 None\n             }"}, {"sha": "500f624ea3f72f870eece3b65108997dfc74f6f7", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 54, "deletions": 51, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -1079,25 +1079,6 @@ impl Foo {\n ```\n \"##,\n \n-E0080: r##\"\n-This error indicates that the compiler was unable to sensibly evaluate an\n-integer expression provided as an enum discriminant. Attempting to divide by 0\n-or causing integer overflow are two ways to induce this error. For example:\n-\n-```compile_fail\n-enum Enum {\n-    X = (1 << 500),\n-    Y = (1 / 0)\n-}\n-```\n-\n-Ensure that the expressions given can be evaluated as the desired integer type.\n-See the FFI section of the Reference for more information about using a custom\n-integer type:\n-\n-https://doc.rust-lang.org/reference.html#ffi-attributes\n-\"##,\n-\n E0081: r##\"\n Enum discriminants are used to differentiate enum variants stored in memory.\n This error indicates that the same value was used for two or more variants,\n@@ -2660,6 +2641,7 @@ For information on the design of the orphan rules, see [RFC 1023].\n [RFC 1023]: https://github.com/rust-lang/rfcs/pull/1023\n \"##,\n \n+/*\n E0211: r##\"\n You used a function or type which doesn't fit the requirements for where it was\n used. Erroneous code examples:\n@@ -2739,6 +2721,7 @@ impl Foo {\n }\n ```\n \"##,\n+     */\n \n E0214: r##\"\n A generic type was described using parentheses rather than angle brackets. For\n@@ -2968,38 +2951,6 @@ not a distinct static type. Likewise, it's not legal to attempt to\n behavior for specific enum variants.\n \"##,\n \n-E0249: r##\"\n-This error indicates a constant expression for the array length was found, but\n-it was not an integer (signed or unsigned) expression.\n-\n-Some examples of code that produces this error are:\n-\n-```compile_fail\n-const A: [u32; \"hello\"] = []; // error\n-const B: [u32; true] = []; // error\n-const C: [u32; 0.0] = []; // error\n-\"##,\n-\n-E0250: r##\"\n-There was an error while evaluating the expression for the length of a fixed-\n-size array type.\n-\n-Some examples of this error are:\n-\n-```compile_fail\n-// divide by zero in the length expression\n-const A: [u32; 1/0] = [];\n-\n-// Rust currently will not evaluate the function `foo` at compile time\n-fn foo() -> usize { 12 }\n-const B: [u32; foo()] = [];\n-\n-// it is an error to try to add `u8` and `f64`\n-use std::{f64, u8};\n-const C: [u32; u8::MAX + f64::EPSILON] = [];\n-```\n-\"##,\n-\n E0318: r##\"\n Default impls for a trait must be located in the same crate where the trait was\n defined. For more information see the [opt-in builtin traits RFC](https://github\n@@ -4029,6 +3980,57 @@ impl SpaceLlama for i32 {\n ```\n \"##,\n \n+E0559: r##\"\n+An unknown field was specified into an enum's structure variant.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0559\n+enum Field {\n+    Fool { x: u32 },\n+}\n+\n+let s = Field::Fool { joke: 0 };\n+// error: struct variant `Field::Fool` has no field named `joke`\n+```\n+\n+Verify you didn't misspell the field's name or that the field exists. Example:\n+\n+```\n+enum Field {\n+    Fool { joke: u32 },\n+}\n+\n+let s = Field::Fool { joke: 0 }; // ok!\n+```\n+\"##,\n+\n+E0560: r##\"\n+An unknown field was specified into a structure.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0560\n+struct Simba {\n+    mother: u32,\n+}\n+\n+let s = Simba { mother: 1, father: 0 };\n+// error: structure `Simba` has no field named `father`\n+```\n+\n+Verify you didn't misspell the field's name or that the field exists. Example:\n+\n+```\n+struct Simba {\n+    mother: u32,\n+    father: u32,\n+}\n+\n+let s = Simba { mother: 1, father: 0 }; // ok!\n+```\n+\"##,\n+\n }\n \n register_diagnostics! {\n@@ -4086,6 +4088,7 @@ register_diagnostics! {\n     E0245, // not a trait\n //  E0246, // invalid recursive type\n //  E0247,\n+//  E0249,\n //  E0319, // trait impls for defaulted traits allowed just for structs/enums\n     E0320, // recursive overflow during dropck\n     E0328, // cannot implement Unsize explicitly"}, {"sha": "3b2d02dc861c4c62c0b8542f0b3f0da67eddbef8", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 14, "deletions": 22, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -186,28 +186,14 @@ fn require_c_abi_if_variadic(tcx: TyCtxt,\n     }\n }\n \n-pub fn emit_type_err<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                     span: Span,\n-                                     found_ty: Ty<'tcx>,\n-                                     expected_ty: Ty<'tcx>,\n-                                     terr: &ty::error::TypeError<'tcx>,\n-                                     msg: &str) {\n-    let mut err = struct_span_err!(tcx.sess, span, E0211, \"{}\", msg);\n-    err.span_label(span, &terr);\n-    err.note_expected_found(&\"type\", &expected_ty, &found_ty);\n-    tcx.note_and_explain_type_err(&mut err, terr, span);\n-    err.emit();\n-}\n-\n fn require_same_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                span: Span,\n+                                origin: TypeOrigin,\n                                 t1: Ty<'tcx>,\n-                                t2: Ty<'tcx>,\n-                                msg: &str)\n+                                t2: Ty<'tcx>)\n                                 -> bool {\n     ccx.tcx.infer_ctxt(None, None, ProjectionMode::AnyFinal).enter(|infcx| {\n-        if let Err(err) = infcx.eq_types(false, TypeOrigin::Misc(span), t1, t2) {\n-            emit_type_err(infcx.tcx, span, t1, t2, &err, msg);\n+        if let Err(err) = infcx.eq_types(false, origin.clone(), t1, t2) {\n+            infcx.report_mismatched_types(origin, t1, t2, err);\n             false\n         } else {\n             true\n@@ -249,8 +235,11 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 })\n             }));\n \n-            require_same_types(ccx, main_span, main_t, se_ty,\n-                               \"main function has wrong type\");\n+            require_same_types(\n+                ccx,\n+                TypeOrigin::MainFunctionType(main_span),\n+                main_t,\n+                se_ty);\n         }\n         _ => {\n             span_bug!(main_span,\n@@ -298,8 +287,11 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                 }),\n             }));\n \n-            require_same_types(ccx, start_span, start_t, se_ty,\n-                               \"start function has wrong type\");\n+            require_same_types(\n+                ccx,\n+                TypeOrigin::StartFunctionType(start_span),\n+                start_t,\n+                se_ty);\n         }\n         _ => {\n             span_bug!(start_span,"}, {"sha": "fd7b0a2e6bbf6d9b0d8834c911e7dca320c7c298", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 199, "deletions": 6, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -877,7 +877,7 @@ impl<K, V, S> HashMap<K, V, S>\n     /// }\n     ///\n     /// for val in map.values() {\n-    ///     print!(\"{}\", val);\n+    ///     println!(\"{}\", val);\n     /// }\n     /// ```\n     #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n@@ -1336,6 +1336,10 @@ impl<'a, K, V> InternalEntry<K, V, &'a mut RawTable<K, V>> {\n }\n \n /// A view into a single location in a map, which may be vacant or occupied.\n+/// This enum is constructed from the [`entry`] method on [`HashMap`].\n+///\n+/// [`HashMap`]: struct.HashMap.html\n+/// [`entry`]: struct.HashMap.html#method.entry\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Entry<'a, K: 'a, V: 'a> {\n     /// An occupied Entry.\n@@ -1366,6 +1370,9 @@ impl<'a, K: 'a + Debug, V: 'a + Debug> Debug for Entry<'a, K, V> {\n }\n \n /// A view into a single occupied location in a HashMap.\n+/// It is part of the [`Entry`] enum.\n+///\n+/// [`Entry`]: enum.Entry.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n     key: Option<K>,\n@@ -1383,6 +1390,9 @@ impl<'a, K: 'a + Debug, V: 'a + Debug> Debug for OccupiedEntry<'a, K, V> {\n }\n \n /// A view into a single empty location in a HashMap.\n+/// It is part of the [`Entry`] enum.\n+///\n+/// [`Entry`]: enum.Entry.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct VacantEntry<'a, K: 'a, V: 'a> {\n     hash: SafeHash,\n@@ -1551,6 +1561,20 @@ impl<'a, K, V> Entry<'a, K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Ensures a value is in the entry by inserting the default if empty, and returns\n     /// a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 12);\n+    ///\n+    /// *map.entry(\"poneyland\").or_insert(12) += 10;\n+    /// assert_eq!(map[\"poneyland\"], 22);\n+    /// ```\n     pub fn or_insert(self, default: V) -> &'a mut V {\n         match self {\n             Occupied(entry) => entry.into_mut(),\n@@ -1561,6 +1585,19 @@ impl<'a, K, V> Entry<'a, K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Ensures a value is in the entry by inserting the result of the default function if empty,\n     /// and returns a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map: HashMap<&str, String> = HashMap::new();\n+    /// let s = \"hoho\".to_owned();\n+    ///\n+    /// map.entry(\"poneyland\").or_insert_with(|| s);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], \"hoho\".to_owned());\n+    /// ```\n     pub fn or_insert_with<F: FnOnce() -> V>(self, default: F) -> &'a mut V {\n         match self {\n             Occupied(entry) => entry.into_mut(),\n@@ -1569,6 +1606,15 @@ impl<'a, K, V> Entry<'a, K, V> {\n     }\n \n     /// Returns a reference to this entry's key.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n+    /// ```\n     #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n     pub fn key(&self) -> &K {\n         match *self {\n@@ -1580,45 +1626,154 @@ impl<'a, K, V> Entry<'a, K, V> {\n \n impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// Gets a reference to the key in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n+    /// ```\n     #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n     pub fn key(&self) -> &K {\n         self.elem.read().0\n     }\n \n     /// Take the ownership of the key and value from the map.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(map_entry_recover_keys)]\n+    ///\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hash_map::Entry;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     // We delete the entry from the map.\n+    ///     o.remove_pair();\n+    /// }\n+    ///\n+    /// assert_eq!(map.contains_key(\"poneyland\"), false);\n+    /// ```\n     #[unstable(feature = \"map_entry_recover_keys\", issue = \"34285\")]\n     pub fn remove_pair(self) -> (K, V) {\n         pop_internal(self.elem)\n     }\n \n     /// Gets a reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hash_map::Entry;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     assert_eq!(o.get(), &12);\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get(&self) -> &V {\n         self.elem.read().1\n     }\n \n     /// Gets a mutable reference to the value in the entry.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hash_map::Entry;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 12);\n+    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n+    ///      *o.get_mut() += 10;\n+    /// }\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 22);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn get_mut(&mut self) -> &mut V {\n         self.elem.read_mut().1\n     }\n \n     /// Converts the OccupiedEntry into a mutable reference to the value in the entry\n-    /// with a lifetime bound to the map itself\n+    /// with a lifetime bound to the map itself.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hash_map::Entry;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 12);\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     *o.into_mut() += 10;\n+    /// }\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 22);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_mut(self) -> &'a mut V {\n         self.elem.into_mut_refs().1\n     }\n \n-    /// Sets the value of the entry, and returns the entry's old value\n+    /// Sets the value of the entry, and returns the entry's old value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hash_map::Entry;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(mut o) = map.entry(\"poneyland\") {\n+    ///     assert_eq!(o.insert(15), 12);\n+    /// }\n+    ///\n+    /// assert_eq!(map[\"poneyland\"], 15);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, mut value: V) -> V {\n         let old_value = self.get_mut();\n         mem::swap(&mut value, old_value);\n         value\n     }\n \n-    /// Takes the value out of the entry, and returns it\n+    /// Takes the value out of the entry, and returns it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hash_map::Entry;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    /// map.entry(\"poneyland\").or_insert(12);\n+    ///\n+    /// if let Entry::Occupied(o) = map.entry(\"poneyland\") {\n+    ///     assert_eq!(o.remove(), 12);\n+    /// }\n+    ///\n+    /// assert_eq!(map.contains_key(\"poneyland\"), false);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(self) -> V {\n         pop_internal(self.elem).1\n@@ -1634,20 +1789,58 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n \n impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n     /// Gets a reference to the key that would be used when inserting a value\n-    /// through the VacantEntry.\n+    /// through the `VacantEntry`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    /// assert_eq!(map.entry(\"poneyland\").key(), &\"poneyland\");\n+    /// ```\n     #[stable(feature = \"map_entry_keys\", since = \"1.10.0\")]\n     pub fn key(&self) -> &K {\n         &self.key\n     }\n \n     /// Take ownership of the key.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(map_entry_recover_keys)]\n+    ///\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hash_map::Entry;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    ///\n+    /// if let Entry::Vacant(v) = map.entry(\"poneyland\") {\n+    ///     v.into_key();\n+    /// }\n+    /// ```\n     #[unstable(feature = \"map_entry_recover_keys\", issue = \"34285\")]\n     pub fn into_key(self) -> K {\n         self.key\n     }\n \n     /// Sets the value of the entry with the VacantEntry's key,\n-    /// and returns a mutable reference to it\n+    /// and returns a mutable reference to it.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::HashMap;\n+    /// use std::collections::hash_map::Entry;\n+    ///\n+    /// let mut map: HashMap<&str, u32> = HashMap::new();\n+    ///\n+    /// if let Entry::Vacant(o) = map.entry(\"poneyland\") {\n+    ///     o.insert(37);\n+    /// }\n+    /// assert_eq!(map[\"poneyland\"], 37);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(self, value: V) -> &'a mut V {\n         match self.elem {"}, {"sha": "d6d62ce79d4e6ff94aa780736adcce7d8b9da3ba", "filename": "src/libstd/env.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -625,6 +625,13 @@ impl ExactSizeIterator for Args {\n     fn len(&self) -> usize { self.inner.len() }\n }\n \n+#[stable(feature = \"env_iterators\", since = \"1.11.0\")]\n+impl DoubleEndedIterator for Args {\n+    fn next_back(&mut self) -> Option<String> {\n+        self.inner.next_back().map(|s| s.into_string().unwrap())\n+    }\n+}\n+\n #[stable(feature = \"env\", since = \"1.0.0\")]\n impl Iterator for ArgsOs {\n     type Item = OsString;\n@@ -637,6 +644,10 @@ impl ExactSizeIterator for ArgsOs {\n     fn len(&self) -> usize { self.inner.len() }\n }\n \n+#[stable(feature = \"env_iterators\", since = \"1.11.0\")]\n+impl DoubleEndedIterator for ArgsOs {\n+    fn next_back(&mut self) -> Option<OsString> { self.inner.next_back() }\n+}\n /// Constants associated with the current target\n #[stable(feature = \"env\", since = \"1.0.0\")]\n pub mod consts {"}, {"sha": "48753ccf1c353cfe8ba172dbb347cf47c54f4f5e", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 125, "deletions": 18, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -58,28 +58,37 @@ pub struct File {\n \n /// Metadata information about a file.\n ///\n-/// This structure is returned from the `metadata` function or method and\n+/// This structure is returned from the [`metadata`] function or method and\n /// represents known metadata about a file such as its permissions, size,\n /// modification times, etc.\n+///\n+/// [`metadata`]: fn.metadata.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Clone)]\n pub struct Metadata(fs_imp::FileAttr);\n \n /// Iterator over the entries in a directory.\n ///\n-/// This iterator is returned from the `read_dir` function of this module and\n-/// will yield instances of `io::Result<DirEntry>`. Through a `DirEntry`\n+/// This iterator is returned from the [`read_dir`] function of this module and\n+/// will yield instances of `io::Result<DirEntry>`. Through a [`DirEntry`]\n /// information like the entry's path and possibly other metadata can be\n /// learned.\n ///\n+/// [`read_dir`]: fn.read_dir.html\n+/// [`DirEntry`]: struct.DirEntry.html\n+///\n /// # Errors\n ///\n-/// This `io::Result` will be an `Err` if there's some sort of intermittent\n+/// This [`io::Result`] will be an `Err` if there's some sort of intermittent\n /// IO error during iteration.\n+///\n+/// [`io::Result`]: ../io/type.Result.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct ReadDir(fs_imp::ReadDir);\n \n-/// Entries returned by the `ReadDir` iterator.\n+/// Entries returned by the [`ReadDir`] iterator.\n+///\n+/// [`ReadDir`]: struct.ReadDir.html\n ///\n /// An instance of `DirEntry` represents an entry inside of a directory on the\n /// filesystem. Each entry can be inspected via methods to learn about the full\n@@ -89,17 +98,23 @@ pub struct DirEntry(fs_imp::DirEntry);\n \n /// Options and flags which can be used to configure how a file is opened.\n ///\n-/// This builder exposes the ability to configure how a `File` is opened and\n-/// what operations are permitted on the open file. The `File::open` and\n-/// `File::create` methods are aliases for commonly used options using this\n+/// This builder exposes the ability to configure how a [`File`] is opened and\n+/// what operations are permitted on the open file. The [`File::open`] and\n+/// [`File::create`] methods are aliases for commonly used options using this\n /// builder.\n ///\n-/// Generally speaking, when using `OpenOptions`, you'll first call `new()`,\n-/// then chain calls to methods to set each option, then call `open()`, passing\n-/// the path of the file you're trying to open. This will give you a\n+/// [`File`]: struct.File.html\n+/// [`File::open`]: struct.File.html#method.open\n+/// [`File::create`]: struct.File.html#method.create\n+///\n+/// Generally speaking, when using `OpenOptions`, you'll first call [`new()`],\n+/// then chain calls to methods to set each option, then call [`open()`],\n+/// passing the path of the file you're trying to open. This will give you a\n /// [`io::Result`][result] with a [`File`][file] inside that you can further\n /// operate on.\n ///\n+/// [`new()`]: struct.OpenOptions.html#method.new\n+/// [`open()`]: struct.OpenOptions.html#method.open\n /// [result]: ../io/type.Result.html\n /// [file]: struct.File.html\n ///\n@@ -131,10 +146,12 @@ pub struct OpenOptions(fs_imp::OpenOptions);\n \n /// Representation of the various permissions on a file.\n ///\n-/// This module only currently provides one bit of information, `readonly`,\n+/// This module only currently provides one bit of information, [`readonly`],\n /// which is exposed on all currently supported platforms. Unix-specific\n /// functionality, such as mode bits, is available through the\n /// `os::unix::PermissionsExt` trait.\n+///\n+/// [`readonly`]: struct.Permissions.html#method.readonly\n #[derive(Clone, PartialEq, Eq, Debug)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Permissions(fs_imp::FilePermissions);\n@@ -156,12 +173,14 @@ pub struct DirBuilder {\n impl File {\n     /// Attempts to open a file in read-only mode.\n     ///\n-    /// See the `OpenOptions::open` method for more details.\n+    /// See the [`OpenOptions::open`] method for more details.\n     ///\n     /// # Errors\n     ///\n     /// This function will return an error if `path` does not already exist.\n-    /// Other errors may also be returned according to `OpenOptions::open`.\n+    /// Other errors may also be returned according to [`OpenOptions::open`].\n+    ///\n+    /// [`OpenOptions::open`]: struct.OpenOptions.html#method.open\n     ///\n     /// # Examples\n     ///\n@@ -183,7 +202,9 @@ impl File {\n     /// This function will create a file if it does not exist,\n     /// and will truncate it if it does.\n     ///\n-    /// See the `OpenOptions::open` function for more details.\n+    /// See the [`OpenOptions::open`] function for more details.\n+    ///\n+    /// [`OpenOptions::open`]: struct.OpenOptions.html#method.open\n     ///\n     /// # Examples\n     ///\n@@ -224,15 +245,17 @@ impl File {\n         self.inner.fsync()\n     }\n \n-    /// This function is similar to `sync_all`, except that it may not\n+    /// This function is similar to [`sync_all`], except that it may not\n     /// synchronize file metadata to the filesystem.\n     ///\n     /// This is intended for use cases that must synchronize content, but don't\n     /// need the metadata on disk. The goal of this method is to reduce disk\n     /// operations.\n     ///\n     /// Note that some platforms may simply implement this in terms of\n-    /// `sync_all`.\n+    /// [`sync_all`].\n+    ///\n+    /// [`sync_all`]: struct.File.html#method.sync_all\n     ///\n     /// # Examples\n     ///\n@@ -304,6 +327,18 @@ impl File {\n     /// The returned `File` is a reference to the same state that this object\n     /// references. Both handles will read and write with the same cursor\n     /// position.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// let mut f = try!(File::open(\"foo.txt\"));\n+    /// let file_copy = try!(f.try_clone());\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"file_try_clone\", since = \"1.9.0\")]\n     pub fn try_clone(&self) -> io::Result<File> {\n         Ok(File {\n@@ -829,6 +864,26 @@ impl DirEntry {\n     /// On Windows this function is cheap to call (no extra system calls\n     /// needed), but on Unix platforms this function is the equivalent of\n     /// calling `symlink_metadata` on the path.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fs;\n+    ///\n+    /// if let Ok(entries) = fs::read_dir(\".\") {\n+    ///     for entry in entries {\n+    ///         if let Ok(entry) = entry {\n+    ///             // Here, `entry` is a `DirEntry`.\n+    ///             if let Ok(metadata) = entry.metadata() {\n+    ///                 // Now let's show our entry's permissions!\n+    ///                 println!(\"{:?}: {:?}\", entry.path(), metadata.permissions());\n+    ///             } else {\n+    ///                 println!(\"Couldn't get metadata for {:?}\", entry.path());\n+    ///             }\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n     #[stable(feature = \"dir_entry_ext\", since = \"1.1.0\")]\n     pub fn metadata(&self) -> io::Result<Metadata> {\n         self.0.metadata().map(Metadata)\n@@ -844,13 +899,48 @@ impl DirEntry {\n     /// On Windows and most Unix platforms this function is free (no extra\n     /// system calls needed), but some Unix platforms may require the equivalent\n     /// call to `symlink_metadata` to learn about the target file type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fs;\n+    ///\n+    /// if let Ok(entries) = fs::read_dir(\".\") {\n+    ///     for entry in entries {\n+    ///         if let Ok(entry) = entry {\n+    ///             // Here, `entry` is a `DirEntry`.\n+    ///             if let Ok(file_type) = entry.file_type() {\n+    ///                 // Now let's show our entry's file type!\n+    ///                 println!(\"{:?}: {:?}\", entry.path(), file_type);\n+    ///             } else {\n+    ///                 println!(\"Couldn't get file type for {:?}\", entry.path());\n+    ///             }\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n     #[stable(feature = \"dir_entry_ext\", since = \"1.1.0\")]\n     pub fn file_type(&self) -> io::Result<FileType> {\n         self.0.file_type().map(FileType)\n     }\n \n     /// Returns the bare file name of this directory entry without any other\n     /// leading path component.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fs;\n+    ///\n+    /// if let Ok(entries) = fs::read_dir(\".\") {\n+    ///     for entry in entries {\n+    ///         if let Ok(entry) = entry {\n+    ///             // Here, `entry` is a `DirEntry`.\n+    ///             println!(\"{:?}\", entry.file_name());\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n     #[stable(feature = \"dir_entry_ext\", since = \"1.1.0\")]\n     pub fn file_name(&self) -> OsString {\n         self.0.file_name()\n@@ -1397,6 +1487,14 @@ pub fn set_permissions<P: AsRef<Path>>(path: P, perm: Permissions)\n impl DirBuilder {\n     /// Creates a new set of options with default mode/security settings for all\n     /// platforms and also non-recursive.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fs::DirBuilder;\n+    ///\n+    /// let builder = DirBuilder::new();\n+    /// ```\n     #[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n     pub fn new() -> DirBuilder {\n         DirBuilder {\n@@ -1409,7 +1507,16 @@ impl DirBuilder {\n     /// all parent directories if they do not exist with the same security and\n     /// permissions settings.\n     ///\n-    /// This option defaults to `false`\n+    /// This option defaults to `false`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fs::DirBuilder;\n+    ///\n+    /// let mut builder = DirBuilder::new();\n+    /// builder.recursive(true);\n+    /// ```\n     #[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n     pub fn recursive(&mut self, recursive: bool) -> &mut Self {\n         self.recursive = recursive;"}, {"sha": "54340773a42b52e5bb672e41edde061cc487f769", "filename": "src/libstd/sys/unix/ext/fs.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext%2Ffs.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -196,6 +196,22 @@ impl FileTypeExt for fs::FileType {\n pub trait DirEntryExt {\n     /// Returns the underlying `d_ino` field in the contained `dirent`\n     /// structure.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fs;\n+    /// use std::os::unix::fs::DirEntryExt;\n+    ///\n+    /// if let Ok(entries) = fs::read_dir(\".\") {\n+    ///     for entry in entries {\n+    ///         if let Ok(entry) = entry {\n+    ///             // Here, `entry` is a `DirEntry`.\n+    ///             println!(\"{:?}: {}\", entry.file_name(), entry.ino());\n+    ///         }\n+    ///     }\n+    /// }\n+    /// ```\n     #[stable(feature = \"dir_entry_ext\", since = \"1.1.0\")]\n     fn ino(&self) -> u64;\n }\n@@ -239,6 +255,16 @@ pub fn symlink<P: AsRef<Path>, Q: AsRef<Path>>(src: P, dst: Q) -> io::Result<()>\n pub trait DirBuilderExt {\n     /// Sets the mode to create new directories with. This option defaults to\n     /// 0o777.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```ignore\n+    /// use std::fs::DirBuilder;\n+    /// use std::os::unix::fs::DirBuilderExt;\n+    ///\n+    /// let mut builder = DirBuilder::new();\n+    /// builder.mode(0o755);\n+    /// ```\n     #[stable(feature = \"dir_builder\", since = \"1.6.0\")]\n     fn mode(&mut self, mode: u32) -> &mut Self;\n }"}, {"sha": "6f1b70acb60bc35c3c9f5dfc0cc60c71403bcf76", "filename": "src/libstd/sys/unix/net.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibstd%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fnet.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -67,7 +67,7 @@ impl Socket {\n             // this option, however, was added in 2.6.27, and we still support\n             // 2.6.18 as a kernel, so if the returned error is EINVAL we\n             // fallthrough to the fallback.\n-            if cfg!(linux) {\n+            if cfg!(target_os = \"linux\") {\n                 match cvt(libc::socket(fam, ty | SOCK_CLOEXEC, 0)) {\n                     Ok(fd) => return Ok(Socket(FileDesc::new(fd))),\n                     Err(ref e) if e.raw_os_error() == Some(libc::EINVAL) => {}\n@@ -87,7 +87,7 @@ impl Socket {\n             let mut fds = [0, 0];\n \n             // Like above, see if we can set cloexec atomically\n-            if cfg!(linux) {\n+            if cfg!(target_os = \"linux\") {\n                 match cvt(libc::socketpair(fam, ty | SOCK_CLOEXEC, 0, fds.as_mut_ptr())) {\n                     Ok(_) => {\n                         return Ok((Socket(FileDesc::new(fds[0])), Socket(FileDesc::new(fds[1]))));"}, {"sha": "4c3558f91f5f22e65cf3c3892f45af47576e9a60", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -317,6 +317,10 @@ impl ExactSizeIterator for Args {\n     fn len(&self) -> usize { self.iter.len() }\n }\n \n+impl DoubleEndedIterator for Args {\n+    fn next_back(&mut self) -> Option<OsString> { self.iter.next_back() }\n+}\n+\n /// Returns the command line arguments\n ///\n /// Returns a list of the command line arguments."}, {"sha": "0cea7f81e363237fa745023505916db18df864fc", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -278,23 +278,30 @@ pub struct Args {\n     cur: *mut *mut u16,\n }\n \n+unsafe fn os_string_from_ptr(ptr: *mut u16) -> OsString {\n+    let mut len = 0;\n+    while *ptr.offset(len) != 0 { len += 1; }\n+\n+    // Push it onto the list.\n+    let ptr = ptr as *const u16;\n+    let buf = slice::from_raw_parts(ptr, len as usize);\n+    OsStringExt::from_wide(buf)\n+}\n+\n impl Iterator for Args {\n     type Item = OsString;\n     fn next(&mut self) -> Option<OsString> {\n-        self.range.next().map(|i| unsafe {\n-            let ptr = *self.cur.offset(i);\n-            let mut len = 0;\n-            while *ptr.offset(len) != 0 { len += 1; }\n-\n-            // Push it onto the list.\n-            let ptr = ptr as *const u16;\n-            let buf = slice::from_raw_parts(ptr, len as usize);\n-            OsStringExt::from_wide(buf)\n-        })\n+        self.range.next().map(|i| unsafe { os_string_from_ptr(*self.cur.offset(i)) } )\n     }\n     fn size_hint(&self) -> (usize, Option<usize>) { self.range.size_hint() }\n }\n \n+impl DoubleEndedIterator for Args {\n+    fn next_back(&mut self) -> Option<OsString> {\n+        self.range.next_back().map(|i| unsafe { os_string_from_ptr(*self.cur.offset(i)) } )\n+    }\n+}\n+\n impl ExactSizeIterator for Args {\n     fn len(&self) -> usize { self.range.len() }\n }"}, {"sha": "29a300b172e7562972aa22a645dfbff63ee05999", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -14,7 +14,7 @@ use syntax_pos::{Span, DUMMY_SP};\n use errors::{Handler, DiagnosticBuilder};\n use ext::tt::macro_parser::{NamedMatch, MatchedSeq, MatchedNonterminal};\n use parse::token::{DocComment, MatchNt, SubstNt};\n-use parse::token::{Token, NtIdent, SpecialMacroVar};\n+use parse::token::{Token, Interpolated, NtIdent, NtTT, SpecialMacroVar};\n use parse::token;\n use parse::lexer::TokenAndSpan;\n use tokenstream::{self, TokenTree};\n@@ -278,9 +278,9 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n             }\n             // FIXME #2887: think about span stuff here\n             TokenTree::Token(sp, SubstNt(ident)) => {\n-                r.stack.last_mut().unwrap().idx += 1;\n                 match lookup_cur_matched(r, ident) {\n                     None => {\n+                        r.stack.last_mut().unwrap().idx += 1;\n                         r.cur_span = sp;\n                         r.cur_tok = SubstNt(ident);\n                         return ret_val;\n@@ -292,14 +292,24 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n                             // (a) idents can be in lots of places, so it'd be a pain\n                             // (b) we actually can, since it's a token.\n                             MatchedNonterminal(NtIdent(ref sn)) => {\n+                                r.stack.last_mut().unwrap().idx += 1;\n                                 r.cur_span = sn.span;\n                                 r.cur_tok = token::Ident(sn.node);\n                                 return ret_val;\n                             }\n+                            MatchedNonterminal(NtTT(ref tt)) => {\n+                                r.stack.push(TtFrame {\n+                                    forest: TokenTree::Token(sp, Interpolated(NtTT(tt.clone()))),\n+                                    idx: 0,\n+                                    dotdotdoted: false,\n+                                    sep: None,\n+                                });\n+                            }\n                             MatchedNonterminal(ref other_whole_nt) => {\n+                                r.stack.last_mut().unwrap().idx += 1;\n                                 // FIXME(pcwalton): Bad copy.\n                                 r.cur_span = sp;\n-                                r.cur_tok = token::Interpolated((*other_whole_nt).clone());\n+                                r.cur_tok = Interpolated((*other_whole_nt).clone());\n                                 return ret_val;\n                             }\n                             MatchedSeq(..) => {"}, {"sha": "d38edf816880e1e44d9aa81ab93a4ba20b427257", "filename": "src/libsyntax/tokenstream.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftokenstream.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -135,6 +135,7 @@ impl TokenTree {\n             }\n             TokenTree::Token(_, token::SpecialVarNt(..)) => 2,\n             TokenTree::Token(_, token::MatchNt(..)) => 3,\n+            TokenTree::Token(_, token::Interpolated(Nonterminal::NtTT(..))) => 1,\n             TokenTree::Delimited(_, ref delimed) => delimed.tts.len() + 2,\n             TokenTree::Sequence(_, ref seq) => seq.tts.len(),\n             TokenTree::Token(..) => 0,\n@@ -197,6 +198,9 @@ impl TokenTree {\n                          TokenTree::Token(sp, token::Ident(kind))];\n                 v[index].clone()\n             }\n+            (&TokenTree::Token(_, token::Interpolated(Nonterminal::NtTT(ref tt))), _) => {\n+                tt.clone().unwrap()\n+            }\n             (&TokenTree::Sequence(_, ref seq), _) => seq.tts[index].clone(),\n             _ => panic!(\"Cannot expand a token tree\"),\n         }"}, {"sha": "0b2287cf233d15becbf9d5da283d62194d473483", "filename": "src/rustc/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Frustc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Frustc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2FCargo.lock?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -105,6 +105,7 @@ dependencies = [\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n+ \"rustc_errors 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\","}, {"sha": "501c66e75cded115892fddfe02c0be9588b0c9c0", "filename": "src/test/compile-fail/array_const_index-0.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Farray_const_index-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Farray_const_index-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farray_const_index-0.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -10,7 +10,8 @@\n \n const A: &'static [i32] = &[];\n const B: i32 = (&A)[1];\n-//~^ ERROR index out of bounds: the len is 0 but the index is 1\n+//~^ ERROR constant evaluation error\n+//~| index out of bounds: the len is 0 but the index is 1\n \n fn main() {\n     let _ = B;"}, {"sha": "d3b43e83bfe5218ac914584e6424f6fd4ee4a9d4", "filename": "src/test/compile-fail/array_const_index-1.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Farray_const_index-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Farray_const_index-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farray_const_index-1.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -10,7 +10,8 @@\n \n const A: [i32; 0] = [];\n const B: i32 = A[1];\n-//~^ ERROR index out of bounds: the len is 0 but the index is 1\n+//~^ ERROR constant evaluation error\n+//~| index out of bounds: the len is 0 but the index is 1\n \n fn main() {\n     let _ = B;"}, {"sha": "0239986f5ad3aef5dfe5886ed2f142bc93c902e1", "filename": "src/test/compile-fail/associated-const-array-len.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fassociated-const-array-len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fassociated-const-array-len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-array-len.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -14,7 +14,7 @@ trait Foo {\n     const ID: usize;\n }\n \n-const X: [i32; <i32 as Foo>::ID] = [0, 1, 2]; //~ ERROR E0250\n+const X: [i32; <i32 as Foo>::ID] = [0, 1, 2]; //~ ERROR E0080\n \n fn main() {\n     assert_eq!(1, X);"}, {"sha": "95508a31044b87797dff021bc5a6a07b23cd2ff9", "filename": "src/test/compile-fail/associated-const-impl-wrong-type.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fassociated-const-impl-wrong-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fassociated-const-impl-wrong-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-impl-wrong-type.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -18,9 +18,8 @@ struct SignedBar;\n \n impl Foo for SignedBar {\n     const BAR: i32 = -1;\n-    //~^ ERROR implemented const `BAR` has an incompatible type for trait\n-    //~| expected u32,\n-    //~| found i32 [E0326]\n+    //~^ ERROR implemented const `BAR` has an incompatible type for trait [E0326]\n+    //~| expected u32, found i32\n }\n \n fn main() {}"}, {"sha": "c3fa39659b968217fb83481c75edea49d0855a37", "filename": "src/test/compile-fail/associated-const-type-parameter-arrays-2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-type-parameter-arrays-2.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -25,7 +25,8 @@ impl Foo for Def {\n }\n \n pub fn test<A: Foo, B: Foo>() {\n-    let _array = [4; <A as Foo>::Y]; //~ error: expected constant integer\n+    let _array = [4; <A as Foo>::Y]; //~ ERROR E0080\n+                                     //~| non-constant path in constant\n }\n \n fn main() {"}, {"sha": "cb952f6534f0e57da26b0e45b6d91a14c64be083", "filename": "src/test/compile-fail/associated-types-eq-3.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-eq-3.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -47,10 +47,8 @@ pub fn main() {\n     let a = 42;\n     foo1(a);\n     //~^ ERROR type mismatch resolving\n-    //~| expected usize\n-    //~| found struct `Bar`\n+    //~| expected usize, found struct `Bar`\n     baz(&a);\n     //~^ ERROR type mismatch resolving\n-    //~| expected usize\n-    //~| found struct `Bar`\n+    //~| expected usize, found struct `Bar`\n }"}, {"sha": "12341fa8db38f790c487a7ff0382b81be3e8abb7", "filename": "src/test/compile-fail/associated-types/higher-ranked-projection.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fhigher-ranked-projection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fhigher-ranked-projection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fhigher-ranked-projection.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+// revisions: good bad\n+\n+trait Mirror {\n+    type Image;\n+}\n+\n+impl<T> Mirror for T {\n+    type Image = T;\n+}\n+\n+#[cfg(bad)]\n+fn foo<U, T>(_t: T)\n+    where for<'a> &'a T: Mirror<Image=U>\n+{}\n+\n+#[cfg(good)]\n+fn foo<U, T>(_t: T)\n+    where for<'a> &'a T: Mirror<Image=&'a U>\n+{}\n+\n+#[rustc_error]\n+fn main() { //[good]~ ERROR compilation successful\n+    foo(());\n+    //[bad]~^ ERROR type mismatch resolving `for<'a> <&'a _ as Mirror>::Image == _`\n+    //[bad]~| expected bound lifetime parameter 'a, found concrete lifetime\n+}"}, {"sha": "b980bc02c85a24fb22a4d7cb0e161768a0b858fa", "filename": "src/test/compile-fail/const-array-oob.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-array-oob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-array-oob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-array-oob.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -16,7 +16,8 @@ const FOO: [u32; 3] = [1, 2, 3];\n const BAR: u32 = FOO[5]; // no error, because the error below occurs before regular const eval\n \n const BLUB: [u32; FOO[4]] = [5, 6];\n-//~^ ERROR array length constant evaluation error: index out of bounds: the len is 3 but the index is 4 [E0250]\n+//~^ ERROR constant evaluation error [E0080]\n+//~| index out of bounds: the len is 3 but the index is 4\n \n fn main() {\n     let _ = BAR;"}, {"sha": "7e2eabf412d6c2683646b19a0bdb27c4e65c4a21", "filename": "src/test/compile-fail/const-call.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-call.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -15,5 +15,6 @@ fn f(x: usize) -> usize {\n }\n \n fn main() {\n-    let _ = [0; f(2)]; //~ ERROR: non-constant path in constant expression [E0307]\n+    let _ = [0; f(2)]; //~ ERROR constant evaluation error [E0080]\n+                       //~| non-constant path in constant expression\n }"}, {"sha": "f2079800cad311e624ee9ca644603877889353d1", "filename": "src/test/compile-fail/const-err.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-err.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -22,21 +22,29 @@ fn black_box<T>(_: T) {\n \n // Make sure that the two uses get two errors.\n const FOO: u8 = [5u8][1];\n-//~^ ERROR index out of bounds: the len is 1 but the index is 1\n-//~^^ ERROR index out of bounds: the len is 1 but the index is 1\n+//~^ ERROR constant evaluation error\n+//~| index out of bounds: the len is 1 but the index is 1\n+//~^^^ ERROR constant evaluation error\n+//~| index out of bounds: the len is 1 but the index is 1\n \n fn main() {\n     let a = -std::i8::MIN;\n-    //~^ WARN attempted to negate with overflow\n+    //~^ WARN this expression will panic at run-time\n+    //~| attempted to negate with overflow\n     let b = 200u8 + 200u8 + 200u8;\n-    //~^ WARN attempted to add with overflow\n-    //~| WARN attempted to add with overflow\n+    //~^ WARN this expression will panic at run-time\n+    //~| attempted to add with overflow\n+    //~^^^ WARN this expression will panic at run-time\n+    //~| attempted to add with overflow\n     let c = 200u8 * 4;\n-    //~^ WARN attempted to multiply with overflow\n+    //~^ WARN this expression will panic at run-time\n+    //~| attempted to multiply with overflow\n     let d = 42u8 - (42u8 + 1);\n-    //~^ WARN attempted to subtract with overflow\n+    //~^ WARN this expression will panic at run-time\n+    //~| attempted to subtract with overflow\n     let _e = [5u8][1];\n-    //~^ WARN index out of bounds: the len is 1 but the index is 1\n+    //~^ WARN this expression will panic at run-time\n+    //~| index out of bounds: the len is 1 but the index is 1\n     black_box(a);\n     black_box(b);\n     black_box(c);"}, {"sha": "4749457da8814ba89b294c624f1397770bb495ae", "filename": "src/test/compile-fail/const-eval-overflow-2.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-2.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -19,13 +19,16 @@ use std::{u8, u16, u32, u64, usize};\n \n const NEG_128: i8 = -128;\n const NEG_NEG_128: i8 = -NEG_128;\n-//~^ ERROR constant evaluation error: attempted to negate with overflow\n-//~| ERROR attempted to negate with overflow\n-//~| ERROR attempted to negate with overflow\n+//~^ ERROR constant evaluation error\n+//~| attempted to negate with overflow\n+//~| ERROR constant evaluation error\n+//~| attempted to negate with overflow\n+//~| ERROR constant evaluation error\n+//~| attempted to negate with overflow\n \n fn main() {\n     match -128i8 {\n-        NEG_NEG_128 => println!(\"A\"), //~ NOTE in pattern here\n+        NEG_NEG_128 => println!(\"A\"), //~ NOTE for pattern here\n         _ => println!(\"B\"),\n     }\n }"}, {"sha": "c78c74e9e231b5d8ccfdfbf1b2b250c6e1e4afba", "filename": "src/test/compile-fail/const-eval-overflow-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-3.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -17,7 +17,7 @@\n // self-hosted and a cross-compiled setup; therefore resorting to\n // error-pattern for now.\n \n-// error-pattern: expected constant integer for repeat count, but attempted to add with overflow\n+// error-pattern: attempted to add with overflow\n \n #![allow(unused_imports)]\n "}, {"sha": "9e7a5ecae105a2b123a51519f20a2944b26bfe6a", "filename": "src/test/compile-fail/const-eval-overflow-4b.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow-4b.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -20,9 +20,8 @@ use std::{u8, u16, u32, u64, usize};\n \n const A_I8_T\n     : [u32; (i8::MAX as i8 + 1u8) as usize]\n-    //~^ ERROR mismatched types:\n-    //~| expected `i8`,\n-    //~| found `u8` [E0250]\n+    //~^ ERROR constant evaluation error [E0080]\n+    //~| expected i8, found u8\n     = [0; (i8::MAX as usize) + 1];\n \n \n@@ -33,7 +32,8 @@ const A_CHAR_USIZE\n \n const A_BAD_CHAR_USIZE\n     : [u32; 5i8 as char as usize]\n-    //~^ ERROR only `u8` can be cast as `char`, not `i8`\n+    //~^ ERROR constant evaluation error\n+    //~| only `u8` can be cast as `char`, not `i8`\n     = [0; 5];\n \n fn main() {}"}, {"sha": "c1c693544fa96e7fd224ebdeceb01341a3894d2e", "filename": "src/test/compile-fail/const-eval-overflow.rs", "status": "modified", "additions": 56, "deletions": 28, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-overflow.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -21,86 +21,114 @@ use std::{u8, u16, u32, u64, usize};\n \n const VALS_I8: (i8, i8, i8, i8) =\n     (-i8::MIN,\n-     //~^ ERROR attempted to negate with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to negate with overflow\n      i8::MIN - 1,\n-     //~^ ERROR attempted to subtract with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to subtract with overflow\n      i8::MAX + 1,\n-     //~^ ERROR attempted to add with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to add with overflow\n      i8::MIN * 2,\n-     //~^ ERROR attempted to multiply with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to multiply with overflow\n      );\n \n const VALS_I16: (i16, i16, i16, i16) =\n     (-i16::MIN,\n-     //~^ ERROR attempted to negate with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to negate with overflow\n      i16::MIN - 1,\n-     //~^ ERROR attempted to subtract with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to subtract with overflow\n      i16::MAX + 1,\n-     //~^ ERROR attempted to add with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to add with overflow\n      i16::MIN * 2,\n-     //~^ ERROR attempted to multiply with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to multiply with overflow\n      );\n \n const VALS_I32: (i32, i32, i32, i32) =\n     (-i32::MIN,\n-     //~^ ERROR attempted to negate with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to negate with overflow\n      i32::MIN - 1,\n-     //~^ ERROR attempted to subtract with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to subtract with overflow\n      i32::MAX + 1,\n-     //~^ ERROR attempted to add with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to add with overflow\n      i32::MIN * 2,\n-     //~^ ERROR attempted to multiply with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to multiply with overflow\n      );\n \n const VALS_I64: (i64, i64, i64, i64) =\n     (-i64::MIN,\n-     //~^ ERROR attempted to negate with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to negate with overflow\n      i64::MIN - 1,\n-     //~^ ERROR attempted to subtract with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to subtract with overflow\n      i64::MAX + 1,\n-     //~^ ERROR attempted to add with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to add with overflow\n      i64::MAX * 2,\n-     //~^ ERROR attempted to multiply with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to multiply with overflow\n      );\n \n const VALS_U8: (u8, u8, u8, u8) =\n     (-(u8::MIN as i8) as u8,\n      u8::MIN - 1,\n-     //~^ ERROR attempted to subtract with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to subtract with overflow\n      u8::MAX + 1,\n-     //~^ ERROR attempted to add with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to add with overflow\n      u8::MAX * 2,\n-     //~^ ERROR attempted to multiply with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to multiply with overflow\n      );\n \n const VALS_U16: (u16, u16, u16, u16) =\n     (-(u16::MIN as i16) as u16,\n      u16::MIN - 1,\n-     //~^ ERROR attempted to subtract with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to subtract with overflow\n      u16::MAX + 1,\n-     //~^ ERROR attempted to add with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to add with overflow\n      u16::MAX * 2,\n-     //~^ ERROR attempted to multiply with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to multiply with overflow\n      );\n \n const VALS_U32: (u32, u32, u32, u32) =\n     (-(u32::MIN as i32) as u32,\n      u32::MIN - 1,\n-     //~^ ERROR attempted to subtract with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to subtract with overflow\n      u32::MAX + 1,\n-     //~^ ERROR attempted to add with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to add with overflow\n      u32::MAX * 2,\n-     //~^ ERROR attempted to multiply with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to multiply with overflow\n      );\n \n const VALS_U64: (u64, u64, u64, u64) =\n     (-(u64::MIN as i64) as u64,\n      u64::MIN - 1,\n-     //~^ ERROR attempted to subtract with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to subtract with overflow\n      u64::MAX + 1,\n-     //~^ ERROR attempted to add with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to add with overflow\n      u64::MAX * 2,\n-     //~^ ERROR attempted to multiply with overflow\n+     //~^ ERROR constant evaluation error\n+     //~| attempted to multiply with overflow\n      );\n \n fn main() {"}, {"sha": "73351429b50608b770bb11571880aa364e46d666", "filename": "src/test/compile-fail/const-eval-span.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-eval-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-eval-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-eval-span.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -14,7 +14,8 @@\n struct S(i32);\n \n const CONSTANT: S = S(0);\n-//~^ ERROR: unimplemented constant expression: tuple struct constructors [E0080]\n+//~^ ERROR E0080\n+//~| unimplemented constant expression: tuple struct constructors\n \n enum E {\n     V = CONSTANT,"}, {"sha": "dd0f058f2c95c06909e2132d64902b6a1d5c7970", "filename": "src/test/compile-fail/const-fn-error.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-fn-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-fn-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-fn-error.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -17,10 +17,11 @@ const fn f(x: usize) -> usize {\n     for i in 0..x {\n         sum += i;\n     }\n-    sum //~ ERROR: E0250\n+    sum //~ ERROR E0080\n+        //~| non-constant path in constant\n }\n \n #[allow(unused_variables)]\n fn main() {\n-    let a : [i32; f(X)];\n+    let a : [i32; f(X)]; //~ NOTE for array length here\n }"}, {"sha": "4f92770df289c50c57c43c58e163158ddea6fdc7", "filename": "src/test/compile-fail/const-index-feature-gate.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-index-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-index-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-index-feature-gate.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n const ARR: [usize; 1] = [2];\n-const ARR2: [i32; ARR[0]] = [5, 6]; //~ ERROR unstable\n+const ARR2: [i32; ARR[0]] = [5, 6]; //~ ERROR E0080\n+                                    //~| unstable\n \n fn main() {\n }"}, {"sha": "5dadd892f83520cca532436ce88986e7b4649476", "filename": "src/test/compile-fail/const-integer-bool-ops.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-integer-bool-ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-integer-bool-ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-integer-bool-ops.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -8,30 +8,34 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-const X: usize = 42 && 39; //~ ERROR: can't do this op on integrals\n+const X: usize = 42 && 39; //~ ERROR E0080\n+                           //~| can't do this op on integrals\n const ARR: [i32; X] = [99; 34]; //~ NOTE: for array length here\n \n-const X1: usize = 42 || 39; //~ ERROR: can't do this op on integrals\n+const X1: usize = 42 || 39; //~ ERROR E0080\n+                            //~| can't do this op on integrals\n const ARR1: [i32; X1] = [99; 47]; //~ NOTE: for array length here\n \n-const X2: usize = -42 || -39; //~ ERROR: unary negation of unsigned integer\n+const X2: usize = -42 || -39; //~ ERROR E0080\n+                              //~| unary negation of unsigned integer\n const ARR2: [i32; X2] = [99; 18446744073709551607]; //~ NOTE: for array length here\n \n-const X3: usize = -42 && -39; //~ ERROR: unary negation of unsigned integer\n+const X3: usize = -42 && -39; //~ ERROR E0080\n+                              //~| unary negation of unsigned integer\n const ARR3: [i32; X3] = [99; 6]; //~ NOTE: for array length here\n \n const Y: usize = 42.0 == 42.0;\n-const ARRR: [i32; Y] = [99; 1]; //~ ERROR: expected usize value for array length\n+const ARRR: [i32; Y] = [99; 1]; //~ ERROR: expected usize for array length\n const Y1: usize = 42.0 >= 42.0;\n-const ARRR1: [i32; Y] = [99; 1]; //~ ERROR: expected usize value for array length\n+const ARRR1: [i32; Y] = [99; 1]; //~ ERROR: expected usize for array length\n const Y2: usize = 42.0 <= 42.0;\n-const ARRR2: [i32; Y] = [99; 1]; //~ ERROR: expected usize value for array length\n+const ARRR2: [i32; Y] = [99; 1]; //~ ERROR: expected usize for array length\n const Y3: usize = 42.0 > 42.0;\n-const ARRR3: [i32; Y] = [99; 0]; //~ ERROR: expected usize value for array length\n+const ARRR3: [i32; Y] = [99; 0]; //~ ERROR: expected usize for array length\n const Y4: usize = 42.0 < 42.0;\n-const ARRR4: [i32; Y] = [99; 0]; //~ ERROR: expected usize value for array length\n+const ARRR4: [i32; Y] = [99; 0]; //~ ERROR: expected usize for array length\n const Y5: usize = 42.0 != 42.0;\n-const ARRR5: [i32; Y] = [99; 0]; //~ ERROR: expected usize value for array length\n+const ARRR5: [i32; Y] = [99; 0]; //~ ERROR: expected usize for array length\n \n fn main() {\n     let _ = ARR;"}, {"sha": "43375ee3d18968e83645b150088189cdfef4a9ea", "filename": "src/test/compile-fail/const-len-underflow-separate-spans.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-separate-spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-separate-spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-separate-spans.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -15,7 +15,8 @@\n const ONE: usize = 1;\n const TWO: usize = 2;\n const LEN: usize = ONE - TWO;\n-//~^ ERROR array length constant evaluation error: attempted to subtract with overflow [E0250]\n+//~^ ERROR E0080\n+//~| attempted to subtract with overflow\n \n fn main() {\n     let a: [i8; LEN] = unimplemented!();"}, {"sha": "e338f206553b422110dc9086c5190878b02f91c5", "filename": "src/test/compile-fail/const-len-underflow-subspans.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-subspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-subspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-len-underflow-subspans.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -16,5 +16,6 @@ const TWO: usize = 2;\n \n fn main() {\n     let a: [i8; ONE - TWO] = unimplemented!();\n-    //~^ ERROR array length constant evaluation error: attempted to subtract with overflow [E0250]\n+    //~^ ERROR constant evaluation error [E0080]\n+    //~| attempted to subtract with overflow\n }"}, {"sha": "d68d63683a79cc6b2db9beddf7f4ad236bb39ae0", "filename": "src/test/compile-fail/const-pattern-not-const-evaluable.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-pattern-not-const-evaluable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-pattern-not-const-evaluable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-pattern-not-const-evaluable.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -17,22 +17,26 @@ enum Cake {\n use Cake::*;\n \n const BOO: (Cake, Cake) = (Marmor, BlackForest);\n-//~^ ERROR: constant evaluation error: unimplemented constant expression: enum variants [E0471]\n+//~^ ERROR: constant evaluation error [E0080]\n+//~| unimplemented constant expression: enum variants\n const FOO: Cake = BOO.1;\n \n const fn foo() -> Cake {\n-    Marmor //~ ERROR: constant evaluation error: unimplemented constant expression: enum variants\n-    //~^ ERROR: unimplemented constant expression: enum variants\n+    Marmor\n+        //~^ ERROR: constant evaluation error [E0080]\n+        //~| unimplemented constant expression: enum variants\n+        //~^^^ ERROR: constant evaluation error [E0080]\n+        //~| unimplemented constant expression: enum variants\n }\n \n const WORKS: Cake = Marmor;\n \n-const GOO: Cake = foo();\n+const GOO: Cake = foo(); //~ NOTE for expression here\n \n fn main() {\n     match BlackForest {\n-        FOO => println!(\"hi\"), //~ NOTE: in pattern here\n-        GOO => println!(\"meh\"), //~ NOTE: in pattern here\n+        FOO => println!(\"hi\"), //~ NOTE: for pattern here\n+        GOO => println!(\"meh\"), //~ NOTE: for pattern here\n         WORKS => println!(\"m\u00f6p\"),\n         _ => println!(\"bye\"),\n     }"}, {"sha": "b1b4bfe2d1c39a1e2a08a9e76117699d1e1d854c", "filename": "src/test/compile-fail/const-slice-oob.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-slice-oob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-slice-oob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-slice-oob.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -10,7 +10,8 @@\n \n const FOO: &'static[u32] = &[1, 2, 3];\n const BAR: u32 = FOO[5];\n-//~^ ERROR index out of bounds: the len is 3 but the index is 5\n+//~^ ERROR constant evaluation error [E0080]\n+//~| index out of bounds: the len is 3 but the index is 5\n \n fn main() {\n     let _ = BAR;"}, {"sha": "6f095b3041ffedc833eef1b3ecc985f809ca60d9", "filename": "src/test/compile-fail/const-tup-index-span.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-tup-index-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fconst-tup-index-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-tup-index-span.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -11,7 +11,8 @@\n // Test spans of errors\n \n const TUP: (usize,) = 5 << 64;\n-//~^ ERROR: attempted to shift left with overflow [E0250]\n+//~^ ERROR E0080\n+//~| attempted to shift left with overflow\n const ARR: [i32; TUP.0] = [];\n \n fn main() {"}, {"sha": "c73b7e831b3217051eb1eef9b64372af92abda81", "filename": "src/test/compile-fail/discrim-ill-typed.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fdiscrim-ill-typed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fdiscrim-ill-typed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdiscrim-ill-typed.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -25,7 +25,8 @@ fn f_i8() {\n         Ok = i8::MAX - 1,\n         Ok2,\n         OhNo = 0_u8,\n-        //~^ ERROR mismatched types\n+        //~^ ERROR E0080\n+        //~| expected i8, found u8\n     }\n \n     let x = A::Ok;\n@@ -37,7 +38,8 @@ fn f_u8() {\n         Ok = u8::MAX - 1,\n         Ok2,\n         OhNo = 0_i8,\n-        //~^  ERROR mismatched types\n+        //~^ ERROR E0080\n+        //~| expected u8, found i8\n     }\n \n     let x = A::Ok;\n@@ -49,7 +51,8 @@ fn f_i16() {\n         Ok = i16::MAX - 1,\n         Ok2,\n         OhNo = 0_u16,\n-        //~^ ERROR mismatched types\n+        //~^ ERROR E0080\n+        //~| expected i16, found u16\n     }\n \n     let x = A::Ok;\n@@ -61,7 +64,8 @@ fn f_u16() {\n         Ok = u16::MAX - 1,\n         Ok2,\n         OhNo = 0_i16,\n-        //~^ ERROR mismatched types\n+        //~^ ERROR E0080\n+        //~| expected u16, found i16\n     }\n \n     let x = A::Ok;\n@@ -73,7 +77,8 @@ fn f_i32() {\n         Ok = i32::MAX - 1,\n         Ok2,\n         OhNo = 0_u32,\n-        //~^ ERROR mismatched types\n+        //~^ ERROR E0080\n+        //~| expected i32, found u32\n     }\n \n     let x = A::Ok;\n@@ -85,7 +90,8 @@ fn f_u32() {\n         Ok = u32::MAX - 1,\n         Ok2,\n         OhNo = 0_i32,\n-        //~^ ERROR mismatched types\n+        //~^ ERROR E0080\n+        //~| expected u32, found i32\n     }\n \n     let x = A::Ok;\n@@ -97,7 +103,8 @@ fn f_i64() {\n         Ok = i64::MAX - 1,\n         Ok2,\n         OhNo = 0_u64,\n-        //~^ ERROR mismatched types\n+        //~^ ERROR E0080\n+        //~| expected i64, found u64\n     }\n \n     let x = A::Ok;\n@@ -109,7 +116,8 @@ fn f_u64() {\n         Ok = u64::MAX - 1,\n         Ok2,\n         OhNo = 0_i64,\n-        //~^ ERROR mismatched types\n+        //~^ ERROR E0080\n+        //~| expected u64, found i64\n     }\n \n     let x = A::Ok;"}, {"sha": "bbdb3891d99807dbd989d231ddbcdfbb3805993c", "filename": "src/test/compile-fail/enum-discrim-too-small.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fenum-discrim-too-small.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -13,28 +13,32 @@\n enum Eu8 {\n     Au8 = 23,\n     Bu8 = 223,\n-    Cu8 = -23, //~ ERROR unary negation of unsigned integer\n+    Cu8 = -23, //~ ERROR E0080\n+               //~| unary negation of unsigned integer\n }\n \n #[repr(u16)]\n enum Eu16 {\n     Au16 = 23,\n     Bu16 = 55555,\n-    Cu16 = -22333, //~ ERROR unary negation of unsigned integer\n+    Cu16 = -22333, //~ ERROR E0080\n+                   //~| unary negation of unsigned integer\n }\n \n #[repr(u32)]\n enum Eu32 {\n     Au32 = 23,\n     Bu32 = 3_000_000_000,\n-    Cu32 = -2_000_000_000, //~ ERROR unary negation of unsigned integer\n+    Cu32 = -2_000_000_000, //~ ERROR E0080\n+                           //~| unary negation of unsigned integer\n }\n \n #[repr(u64)]\n enum Eu64 {\n     Au32 = 23,\n     Bu32 = 3_000_000_000,\n-    Cu32 = -2_000_000_000, //~ ERROR unary negation of unsigned integer\n+    Cu32 = -2_000_000_000, //~ ERROR E0080\n+                           //~| unary negation of unsigned integer\n }\n \n // u64 currently allows negative numbers, and i64 allows numbers greater than `1<<63`.  This is a"}, {"sha": "57db583aefe2355cb46bde8df1027c98637b18e7", "filename": "src/test/compile-fail/eval-enum.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Feval-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Feval-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Feval-enum.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -9,9 +9,11 @@\n // except according to those terms.\n \n enum test {\n-    div_zero = 1/0, //~ERROR constant evaluation error: attempted to divide by zero\n+    div_zero = 1/0, //~ ERROR E0080\n+                    //~| attempted to divide by zero\n     rem_zero = 1%0,\n-//~^ ERROR constant evaluation error: attempted to calculate the remainder with a divisor of zero\n+    //~^ ERROR E0080\n+    //~| attempted to calculate the remainder with a divisor of zero\n }\n \n fn main() {}"}, {"sha": "f8aa1ea95f0f66d51039d8bb09d1c11502bf1ec2", "filename": "src/test/compile-fail/explicit-self-lifetime-mismatch.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fexplicit-self-lifetime-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fexplicit-self-lifetime-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexplicit-self-lifetime-mismatch.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -14,15 +14,17 @@ struct Foo<'a,'b> {\n }\n \n impl<'a,'b> Foo<'a,'b> {\n-    fn bar(self: Foo<'b,'a>) {}\n-    //~^ ERROR mismatched types\n+    fn bar(\n+        self\n+    //~^ ERROR mismatched method receiver\n     //~| expected type `Foo<'a, 'b>`\n     //~| found type `Foo<'b, 'a>`\n     //~| lifetime mismatch\n-    //~| ERROR mismatched types\n+    //~| ERROR mismatched method receiver\n     //~| expected type `Foo<'a, 'b>`\n     //~| found type `Foo<'b, 'a>`\n     //~| lifetime mismatch\n+            : Foo<'b,'a>) {}\n }\n \n fn main() {}"}, {"sha": "89ae1a09bd3e47b2eca8b28e006031c79d1b5f72", "filename": "src/test/compile-fail/feature-gate-negate-unsigned0.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Ffeature-gate-negate-unsigned0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Ffeature-gate-negate-unsigned0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-negate-unsigned0.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -18,14 +18,17 @@ impl std::ops::Neg for S {\n \n fn main() {\n     let a = -1;\n-    //~^ ERROR unary negation of unsigned integer\n+    //~^ ERROR E0080\n+    //~| unary negation of unsigned integer\n     let _b : u8 = a; // for infering variable a to u8.\n \n     let _d = -1u8;\n-    //~^ ERROR unary negation of unsigned integer\n+    //~^ ERROR E0080\n+    //~| unary negation of unsigned integer\n \n     for _ in -10..10u8 {}\n-    //~^ ERROR unary negation of unsigned integer\n+    //~^ ERROR E0080\n+    //~| unary negation of unsigned integer\n \n     -S; // should not trigger the gate; issue 26840\n }"}, {"sha": "9a9358b787f5386cbebd0231958212dc4c61fc4d", "filename": "src/test/compile-fail/invalid-path-in-const.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Finvalid-path-in-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Finvalid-path-in-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finvalid-path-in-const.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -10,5 +10,6 @@\n \n fn main() {\n     fn f(a: [u8; u32::DOESNOTEXIST]) {}\n-    //~^ ERROR unresolved path in constant expression\n+    //~^ ERROR constant evaluation error\n+    //~| unresolved path in constant expression\n }"}, {"sha": "3d9d81471cb1e40da806c9348464d193ff9cfa98", "filename": "src/test/compile-fail/issue-13033.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fissue-13033.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fissue-13033.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13033.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -16,7 +16,9 @@ struct Baz;\n \n impl Foo for Baz {\n     fn bar(&mut self, other: &Foo) {}\n-    //~^ ERROR method `bar` has an incompatible type for trait: values differ in mutability [E0053]\n+    //~^ ERROR method `bar` has an incompatible type for trait\n+    //~| expected type `fn(&mut Baz, &mut Foo)`\n+    //~| found type `fn(&mut Baz, &Foo)`\n }\n \n fn main() {}"}, {"sha": "da48bbb3ecd711a99a730cf859ec74f17bc9cc06", "filename": "src/test/compile-fail/issue-15094.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fissue-15094.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fissue-15094.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15094.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -20,8 +20,8 @@ impl<T: fmt::Debug> ops::FnOnce<(),> for Debuger<T> {\n     type Output = ();\n     fn call_once(self, _args: ()) {\n     //~^ ERROR `call_once` has an incompatible type for trait\n-    //~| expected \"rust-call\" fn,\n-    //~| found \"Rust\" fn\n+    //~| expected type `extern \"rust-call\" fn\n+    //~| found type `fn\n         println!(\"{:?}\", self.x);\n     }\n }"}, {"sha": "664d62e87ae61cf2f61a5f45d308275ce6f60856", "filename": "src/test/compile-fail/issue-17740.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fissue-17740.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fissue-17740.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17740.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -14,11 +14,11 @@ struct Foo<'a> {\n \n impl <'a> Foo<'a>{\n     fn bar(self: &mut Foo) {\n-    //~^ mismatched types\n+    //~^ mismatched method receiver\n     //~| expected type `&mut Foo<'a>`\n     //~| found type `&mut Foo<'_>`\n     //~| lifetime mismatch\n-    //~| mismatched types\n+    //~| mismatched method receiver\n     //~| expected type `&mut Foo<'a>`\n     //~| found type `&mut Foo<'_>`\n     //~| lifetime mismatch"}, {"sha": "db3334834d44ec97e5230755df303f1f2e0b4a65", "filename": "src/test/compile-fail/issue-21332.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fissue-21332.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fissue-21332.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21332.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -14,8 +14,7 @@ impl Iterator for S {\n     type Item = i32;\n     fn next(&mut self) -> Result<i32, i32> { Ok(7) }\n     //~^ ERROR method `next` has an incompatible type for trait\n-    //~| expected enum `std::option::Option`\n-    //~|    found enum `std::result::Result` [E0053]\n+    //~| expected enum `std::option::Option`, found enum `std::result::Result`\n }\n \n fn main() {}"}, {"sha": "54a24089354614f05c4e90e04e1e3bdce16fba17", "filename": "src/test/compile-fail/issue-22933-2.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fissue-22933-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fissue-22933-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22933-2.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -12,10 +12,12 @@ enum Delicious {\n     Pie      = 0x1,\n     Apple    = 0x2,\n     ApplePie = Delicious::Apple as isize | Delicious::PIE as isize,\n-    //~^ ERROR constant evaluation error: unresolved path in constant expression\n+    //~^ ERROR constant evaluation error\n+    //~| unresolved path in constant expression\n }\n \n const FOO: [u32; u8::MIN as usize] = [];\n-//~^ ERROR array length constant evaluation error: unresolved path in constant expression\n+//~^ ERROR constant evaluation error\n+//~| unresolved path in constant expression\n \n fn main() {}"}, {"sha": "c2bcbb9d54a9a447c1f5c0bf873d8a8542226f4a", "filename": "src/test/compile-fail/issue-23217.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fissue-23217.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fissue-23217.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23217.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -10,7 +10,8 @@\n \n pub enum SomeEnum {\n     B = SomeEnum::A,\n-    //~^ ERROR constant evaluation error: unresolved path in constant expression\n+    //~^ ERROR constant evaluation error\n+    //~| unresolved path in constant expression\n }\n \n fn main() {}"}, {"sha": "ede81bea32ae3bfaea3db5168a4ea23f2ed19a1d", "filename": "src/test/compile-fail/issue-24356.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fissue-24356.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fissue-24356.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-24356.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -30,9 +30,6 @@ fn main() {\n         impl Deref for Thing {\n             //~^ ERROR not all trait items implemented, missing: `Target` [E0046]\n             fn deref(&self) -> i8 { self.0 }\n-            //~^ ERROR method `deref` has an incompatible type for trait\n-            //~| expected &-ptr\n-            //~| found i8 [E0053]\n         }\n \n         let thing = Thing(72);"}, {"sha": "93f75e9bfed0dddc09f23fbcede1fcad238e351a", "filename": "src/test/compile-fail/issue-25145.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fissue-25145.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fissue-25145.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-25145.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -17,6 +17,7 @@ impl S {\n }\n \n static STUFF: [u8; S::N] = [0; S::N];\n-//~^ ERROR array length constant evaluation error: unresolved path in constant expression\n+//~^ ERROR constant evaluation error\n+//~| unresolved path in constant expression\n \n fn main() {}"}, {"sha": "ee6ec52761266607887eef14302a41e2102c6278", "filename": "src/test/compile-fail/issue-27008.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fissue-27008.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fissue-27008.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27008.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -16,5 +16,5 @@ fn main() {\n     //~| expected type `usize`\n     //~| found type `S`\n     //~| expected usize, found struct `S`\n-    //~| ERROR expected positive integer for repeat count, found struct\n+    //~| ERROR expected usize for repeat count, found struct\n }"}, {"sha": "ca8d5a1f70473563b3badf884ffd97d5ae67111a", "filename": "src/test/compile-fail/issue-27895.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fissue-27895.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fissue-27895.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27895.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -14,7 +14,8 @@ fn main() {\n \n     match i {\n         0...index => println!(\"winner\"),\n-        //~^ ERROR non-constant path in constant expression\n+        //~^ ERROR constant evaluation error\n+        //~| non-constant path in constant expression\n         _ => println!(\"hello\"),\n     }\n }"}, {"sha": "1dfd146985ff48a8df17ee421986e27306637c67", "filename": "src/test/compile-fail/issue-28586.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fissue-28586.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fissue-28586.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28586.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -11,6 +11,6 @@\n // Regression test for issue #28586\n \n pub trait Foo {}\n-impl Foo for [u8; usize::BYTES] {} //~ ERROR E0250\n+impl Foo for [u8; usize::BYTES] {} //~ ERROR E0080\n \n fn main() { }"}, {"sha": "fb1e3cc87e88cf610da2b7a31fbb34e8bd486621", "filename": "src/test/compile-fail/issue-31173.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fissue-31173.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fissue-31173.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-31173.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::vec::IntoIter;\n+\n+pub fn get_tok(it: &mut IntoIter<u8>) {\n+    let mut found_e = false;\n+\n+    let temp: Vec<u8> = it.take_while(|&x| {\n+        found_e = true;\n+        false\n+    })\n+        .cloned()\n+        //~^ ERROR type mismatch resolving\n+        //~| expected type `u8`\n+        //~| found type `&_`\n+        .collect(); //~ ERROR no method named `collect`\n+}\n+\n+fn main() {}"}, {"sha": "1b6e4b1d289e42d31c25c39983f188e578c87c18", "filename": "src/test/compile-fail/issue-3521.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3521.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -15,7 +15,8 @@ fn main() {\n     enum Stuff {\n         Bar = foo\n         //~^ ERROR attempt to use a non-constant value in a constant\n-        //~^^ ERROR constant evaluation error: non-constant path in constant expression\n+        //~^^ ERROR constant evaluation error\n+        //~| non-constant path in constant expression\n     }\n \n     println!(\"{}\", Stuff::Bar);"}, {"sha": "91a07dd9ba6dd68ede4d5bf9129a180f1d579d89", "filename": "src/test/compile-fail/issue-8761.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fissue-8761.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fissue-8761.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-8761.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -10,13 +10,11 @@\n \n enum Foo {\n     A = 1i64,\n-    //~^ ERROR mismatched types:\n-    //~| expected `isize`,\n-    //~| found `i64` [E0080]\n+    //~^ ERROR constant evaluation error\n+    //~| expected isize, found i64\n     B = 2u8\n-    //~^ ERROR mismatched types:\n-    //~| expected `isize`,\n-    //~| found `u8` [E0080]\n+    //~^ ERROR constant evaluation error\n+    //~| expected isize, found u8\n }\n \n fn main() {}"}, {"sha": "6da87fca3f35606fe3398f127a626adc751dd763", "filename": "src/test/compile-fail/lifetime-inference-give-expl-lifetime-param.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -49,7 +49,8 @@ struct Baz<'x> {\n \n impl<'a> Baz<'a> {\n     fn baz2<'b>(&self, x: &isize) -> (&'b isize, &'b isize) {\n-        //~^ HELP consider using an explicit lifetime parameter as shown: fn baz2<'b>(&self, x: &'a isize) -> (&'a isize, &'a isize)\n+        //~^ HELP consider using an explicit lifetime parameter as shown: fn baz2<'b>(&self, x: &'\n+        // FIXME #35038: The above suggestion is different on Linux and Mac.\n         (self.bar, x) //~ ERROR E0312\n         //~^ ERROR E0312\n     }"}, {"sha": "f41da77ee989655e9b28f9424d13a8257cb79b4e", "filename": "src/test/compile-fail/macro-tt-matchers.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fmacro-tt-matchers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fmacro-tt-matchers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-tt-matchers.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+macro_rules! foo {\n+    ($x:tt) => (type Alias = $x<i32>;)\n+}\n+\n+foo!(Box);\n+\n+#[rustc_error]\n+fn main() {} //~ ERROR compilation successful"}, {"sha": "2c4c2563021867ddbd6c305f1500b60c6971a5e4", "filename": "src/test/compile-fail/match-range-fail.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fmatch-range-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fmatch-range-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmatch-range-fail.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -27,6 +27,7 @@ fn main() {\n         'c' ... 100 => { }\n         _ => { }\n     };\n-    //~^^^ ERROR mismatched types in range\n-    //~| expected char, found integral variable\n+    //~^^^ ERROR mismatched types\n+    //~| expected type `_`\n+    //~| found type `char`\n }"}, {"sha": "cadfec5a38d3d9fbdc27d1569013b31482708da2", "filename": "src/test/compile-fail/non-constant-enum-for-vec-repeat.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fnon-constant-enum-for-vec-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fnon-constant-enum-for-vec-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-enum-for-vec-repeat.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -15,5 +15,6 @@ enum State { ST_NULL, ST_WHITESPACE }\n \n fn main() {\n     [State::ST_NULL; (State::ST_WHITESPACE as usize)];\n-    //~^ ERROR expected constant integer for repeat count, but unimplemented constant expression\n+    //~^ ERROR constant evaluation error\n+    //~| unimplemented constant expression: enum variants\n }"}, {"sha": "a6f88a57b9125846a8f5ba8b52a91b18f7157736", "filename": "src/test/compile-fail/non-constant-expr-for-vec-repeat.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-vec-repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-vec-repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-expr-for-vec-repeat.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -13,6 +13,8 @@\n fn main() {\n     fn bar(n: usize) {\n         let _x = [0; n];\n-        //~^ ERROR expected constant integer for repeat count, found variable\n+        //~^ ERROR constant evaluation error\n+        //~| non-constant path in constant expression\n+        //~| NOTE `n` is a variable\n     }\n }"}, {"sha": "737f80372debf55c8e99bba7cd5970b199dea579", "filename": "src/test/compile-fail/non-constant-in-const-path.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fnon-constant-in-const-path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fnon-constant-in-const-path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-constant-in-const-path.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -12,6 +12,7 @@ fn main() {\n     let x = 0;\n     match 1 {\n         0 ... x => {}\n-        //~^ ERROR non-constant path in constant expression\n+        //~^ ERROR constant evaluation error\n+        //~| non-constant path in constant expression\n     };\n }"}, {"sha": "3a7e9cc4191ec2af4de80bacf0579705aefe9bd8", "filename": "src/test/compile-fail/repeat_count.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frepeat_count.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -13,39 +13,38 @@\n fn main() {\n     let n = 1;\n     let a = [0; n];\n-    //~^ ERROR expected constant integer for repeat count, found variable [E0307]\n+    //~^ ERROR constant evaluation error\n+    //~| non-constant path in constant expression\n     let b = [0; ()];\n     //~^ ERROR mismatched types\n     //~| expected type `usize`\n     //~| found type `()`\n     //~| expected usize, found ()\n-    //~| ERROR expected positive integer for repeat count, found tuple [E0306]\n+    //~| ERROR expected usize for repeat count, found tuple [E0306]\n     let c = [0; true];\n     //~^ ERROR mismatched types\n     //~| expected usize, found bool\n-    //~| ERROR expected positive integer for repeat count, found boolean [E0306]\n+    //~| ERROR expected usize for repeat count, found boolean [E0306]\n     let d = [0; 0.5];\n     //~^ ERROR mismatched types\n     //~| expected type `usize`\n     //~| found type `_`\n     //~| expected usize, found floating-point variable\n-    //~| ERROR expected positive integer for repeat count, found float [E0306]\n+    //~| ERROR expected usize for repeat count, found float [E0306]\n     let e = [0; \"foo\"];\n     //~^ ERROR mismatched types\n     //~| expected type `usize`\n     //~| found type `&'static str`\n     //~| expected usize, found &-ptr\n-    //~| ERROR expected positive integer for repeat count, found string literal [E0306]\n+    //~| ERROR expected usize for repeat count, found string literal [E0306]\n     let f = [0; -4_isize];\n-    //~^ ERROR mismatched types\n-    //~| expected `usize`\n-    //~| found `isize`\n-    //~| ERROR mismatched types:\n+    //~^ ERROR constant evaluation error\n+    //~| expected usize, found isize\n+    //~| ERROR mismatched types\n     //~| expected usize, found isize\n     let f = [0_usize; -1_isize];\n-    //~^ ERROR mismatched types\n-    //~| expected `usize`\n-    //~| found `isize`\n+    //~^ ERROR constant evaluation error\n+    //~| expected usize, found isize\n     //~| ERROR mismatched types\n     //~| expected usize, found isize\n     struct G {\n@@ -56,5 +55,5 @@ fn main() {\n     //~| expected type `usize`\n     //~| found type `main::G`\n     //~| expected usize, found struct `main::G`\n-    //~| ERROR expected positive integer for repeat count, found struct [E0306]\n+    //~| ERROR expected usize for repeat count, found struct [E0306]\n }"}, {"sha": "a05e007d6b7393e5774e44d76904c35b39fb3243", "filename": "src/test/compile-fail/trait-impl-method-mismatch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Ftrait-impl-method-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Ftrait-impl-method-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-impl-method-mismatch.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -17,8 +17,8 @@ impl Mumbo for usize {\n     // Cannot have a larger effect than the trait:\n     unsafe fn jumbo(&self, x: &usize) { *self + *x; }\n     //~^ ERROR method `jumbo` has an incompatible type for trait\n-    //~| expected normal fn,\n-    //~| found unsafe fn\n+    //~| expected type `fn\n+    //~| found type `unsafe fn\n }\n \n fn main() {}"}, {"sha": "a98b7cd43090f3768723cdc4fdb175eb4a91d410", "filename": "src/test/compile-fail/ufcs-explicit-self-bad.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fufcs-explicit-self-bad.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -41,14 +41,14 @@ trait SomeTrait {\n \n impl<'a, T> SomeTrait for &'a Bar<T> {\n     fn dummy1(self: &&'a Bar<T>) { }\n-    fn dummy2(self: &Bar<T>) {} //~ ERROR mismatched types\n-    //~^ ERROR mismatched types\n+    fn dummy2(self: &Bar<T>) {} //~ ERROR mismatched method receiver\n+    //~^ ERROR mismatched method receiver\n     fn dummy3(self: &&Bar<T>) {}\n-    //~^ ERROR mismatched types\n+    //~^ ERROR mismatched method receiver\n     //~| expected type `&&'a Bar<T>`\n     //~| found type `&&Bar<T>`\n     //~| lifetime mismatch\n-    //~| ERROR mismatched types\n+    //~| ERROR mismatched method receiver\n     //~| expected type `&&'a Bar<T>`\n     //~| found type `&&Bar<T>`\n     //~| lifetime mismatch"}, {"sha": "fb4652affd0d8c3ce6c8ce7f7023b57f447c3137", "filename": "src/test/compile-fail/unsafe-trait-impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Funsafe-trait-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Fcompile-fail%2Funsafe-trait-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-trait-impl.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -17,8 +17,8 @@ trait Foo {\n impl Foo for u32 {\n     fn len(&self) -> u32 { *self }\n     //~^ ERROR method `len` has an incompatible type for trait\n-    //~| expected unsafe fn,\n-    //~| found normal fn\n+    //~| expected type `unsafe fn(&u32) -> u32`\n+    //~| found type `fn(&u32) -> u32`\n }\n \n fn main() { }"}, {"sha": "b5b6ca7572703cc65fab869385623d0d4b924be5", "filename": "src/test/debuginfo/function-prologue-stepping-no-stack-check.rs", "status": "removed", "additions": 0, "deletions": 369, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/1f86005fc09eceb6b19507c466b9674013425521/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f86005fc09eceb6b19507c466b9674013425521/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs?ref=1f86005fc09eceb6b19507c466b9674013425521", "patch": "@@ -1,369 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-android: FIXME(#10381)\n-// min-lldb-version: 310\n-\n-// This test case checks if function arguments already have the correct value\n-// when breaking at the beginning of a function. Functions with the\n-// #[no_stack_check] attribute have the same prologue as regular C functions\n-// compiled with GCC or Clang and therefore are better handled by GDB. As a\n-// consequence, and as opposed to regular Rust functions, we can set the\n-// breakpoints via the function name (and don't have to fall back on using line\n-// numbers). For LLDB this shouldn't make a difference because it can handle\n-// both cases.\n-\n-// compile-flags:-g\n-\n-// === GDB TESTS ===================================================================================\n-\n-// gdb-command:rbreak immediate_args\n-// gdb-command:rbreak binding\n-// gdb-command:rbreak assignment\n-// gdb-command:rbreak function_call\n-// gdb-command:rbreak identifier\n-// gdb-command:rbreak return_expr\n-// gdb-command:rbreak arithmetic_expr\n-// gdb-command:rbreak if_expr\n-// gdb-command:rbreak while_expr\n-// gdb-command:rbreak loop_expr\n-// gdb-command:run\n-\n-// IMMEDIATE ARGS\n-// gdb-command:print a\n-// gdb-check:$1 = 1\n-// gdb-command:print b\n-// gdb-check:$2 = true\n-// gdb-command:print c\n-// gdb-check:$3 = 2.5\n-// gdb-command:continue\n-\n-// NON IMMEDIATE ARGS\n-// gdb-command:print a\n-// gdb-check:$4 = {a = 3, b = 4, c = 5, d = 6, e = 7, f = 8, g = 9, h = 10}\n-// gdb-command:print b\n-// gdb-check:$5 = {a = 11, b = 12, c = 13, d = 14, e = 15, f = 16, g = 17, h = 18}\n-// gdb-command:continue\n-\n-// BINDING\n-// gdb-command:print a\n-// gdb-check:$6 = 19\n-// gdb-command:print b\n-// gdb-check:$7 = 20\n-// gdb-command:print c\n-// gdb-check:$8 = 21.5\n-// gdb-command:continue\n-\n-// ASSIGNMENT\n-// gdb-command:print a\n-// gdb-check:$9 = 22\n-// gdb-command:print b\n-// gdb-check:$10 = 23\n-// gdb-command:print c\n-// gdb-check:$11 = 24.5\n-// gdb-command:continue\n-\n-// FUNCTION CALL\n-// gdb-command:print x\n-// gdb-check:$12 = 25\n-// gdb-command:print y\n-// gdb-check:$13 = 26\n-// gdb-command:print z\n-// gdb-check:$14 = 27.5\n-// gdb-command:continue\n-\n-// EXPR\n-// gdb-command:print x\n-// gdb-check:$15 = 28\n-// gdb-command:print y\n-// gdb-check:$16 = 29\n-// gdb-command:print z\n-// gdb-check:$17 = 30.5\n-// gdb-command:continue\n-\n-// RETURN EXPR\n-// gdb-command:print x\n-// gdb-check:$18 = 31\n-// gdb-command:print y\n-// gdb-check:$19 = 32\n-// gdb-command:print z\n-// gdb-check:$20 = 33.5\n-// gdb-command:continue\n-\n-// ARITHMETIC EXPR\n-// gdb-command:print x\n-// gdb-check:$21 = 34\n-// gdb-command:print y\n-// gdb-check:$22 = 35\n-// gdb-command:print z\n-// gdb-check:$23 = 36.5\n-// gdb-command:continue\n-\n-// IF EXPR\n-// gdb-command:print x\n-// gdb-check:$24 = 37\n-// gdb-command:print y\n-// gdb-check:$25 = 38\n-// gdb-command:print z\n-// gdb-check:$26 = 39.5\n-// gdb-command:continue\n-\n-// WHILE EXPR\n-// gdb-command:print x\n-// gdb-check:$27 = 40\n-// gdb-command:print y\n-// gdb-check:$28 = 41\n-// gdb-command:print z\n-// gdb-check:$29 = 42\n-// gdb-command:continue\n-\n-// LOOP EXPR\n-// gdb-command:print x\n-// gdb-check:$30 = 43\n-// gdb-command:print y\n-// gdb-check:$31 = 44\n-// gdb-command:print z\n-// gdb-check:$32 = 45\n-// gdb-command:continue\n-\n-\n-// === LLDB TESTS ==================================================================================\n-\n-// lldb-command:breakpoint set --name immediate_args\n-// lldb-command:breakpoint set --name non_immediate_args\n-// lldb-command:breakpoint set --name binding\n-// lldb-command:breakpoint set --name assignment\n-// lldb-command:breakpoint set --name function_call\n-// lldb-command:breakpoint set --name identifier\n-// lldb-command:breakpoint set --name return_expr\n-// lldb-command:breakpoint set --name arithmetic_expr\n-// lldb-command:breakpoint set --name if_expr\n-// lldb-command:breakpoint set --name while_expr\n-// lldb-command:breakpoint set --name loop_expr\n-// lldb-command:run\n-\n-// IMMEDIATE ARGS\n-// lldb-command:print a\n-// lldb-check:[...]$0 = 1\n-// lldb-command:print b\n-// lldb-check:[...]$1 = true\n-// lldb-command:print c\n-// lldb-check:[...]$2 = 2.5\n-// lldb-command:continue\n-\n-// NON IMMEDIATE ARGS\n-// lldb-command:print a\n-// lldb-check:[...]$3 = BigStruct { a: 3, b: 4, c: 5, d: 6, e: 7, f: 8, g: 9, h: 10 }\n-// lldb-command:print b\n-// lldb-check:[...]$4 = BigStruct { a: 11, b: 12, c: 13, d: 14, e: 15, f: 16, g: 17, h: 18 }\n-// lldb-command:continue\n-\n-// BINDING\n-// lldb-command:print a\n-// lldb-check:[...]$5 = 19\n-// lldb-command:print b\n-// lldb-check:[...]$6 = 20\n-// lldb-command:print c\n-// lldb-check:[...]$7 = 21.5\n-// lldb-command:continue\n-\n-// ASSIGNMENT\n-// lldb-command:print a\n-// lldb-check:[...]$8 = 22\n-// lldb-command:print b\n-// lldb-check:[...]$9 = 23\n-// lldb-command:print c\n-// lldb-check:[...]$10 = 24.5\n-// lldb-command:continue\n-\n-// FUNCTION CALL\n-// lldb-command:print x\n-// lldb-check:[...]$11 = 25\n-// lldb-command:print y\n-// lldb-check:[...]$12 = 26\n-// lldb-command:print z\n-// lldb-check:[...]$13 = 27.5\n-// lldb-command:continue\n-\n-// EXPR\n-// lldb-command:print x\n-// lldb-check:[...]$14 = 28\n-// lldb-command:print y\n-// lldb-check:[...]$15 = 29\n-// lldb-command:print z\n-// lldb-check:[...]$16 = 30.5\n-// lldb-command:continue\n-\n-// RETURN EXPR\n-// lldb-command:print x\n-// lldb-check:[...]$17 = 31\n-// lldb-command:print y\n-// lldb-check:[...]$18 = 32\n-// lldb-command:print z\n-// lldb-check:[...]$19 = 33.5\n-// lldb-command:continue\n-\n-// ARITHMETIC EXPR\n-// lldb-command:print x\n-// lldb-check:[...]$20 = 34\n-// lldb-command:print y\n-// lldb-check:[...]$21 = 35\n-// lldb-command:print z\n-// lldb-check:[...]$22 = 36.5\n-// lldb-command:continue\n-\n-// IF EXPR\n-// lldb-command:print x\n-// lldb-check:[...]$23 = 37\n-// lldb-command:print y\n-// lldb-check:[...]$24 = 38\n-// lldb-command:print z\n-// lldb-check:[...]$25 = 39.5\n-// lldb-command:continue\n-\n-// WHILE EXPR\n-// lldb-command:print x\n-// lldb-check:[...]$26 = 40\n-// lldb-command:print y\n-// lldb-check:[...]$27 = 41\n-// lldb-command:print z\n-// lldb-check:[...]$28 = 42\n-// lldb-command:continue\n-\n-// LOOP EXPR\n-// lldb-command:print x\n-// lldb-check:[...]$29 = 43\n-// lldb-command:print y\n-// lldb-check:[...]$30 = 44\n-// lldb-command:print z\n-// lldb-check:[...]$31 = 45\n-// lldb-command:continue\n-\n-#![allow(dead_code, unused_assignments, unused_variables)]\n-#![feature(omit_gdb_pretty_printer_section)]\n-#![omit_gdb_pretty_printer_section]\n-\n-#[no_stack_check]\n-fn immediate_args(a: isize, b: bool, c: f64) {\n-    println!(\"\");\n-}\n-\n-struct BigStruct {\n-    a: u64,\n-    b: u64,\n-    c: u64,\n-    d: u64,\n-    e: u64,\n-    f: u64,\n-    g: u64,\n-    h: u64\n-}\n-\n-#[no_stack_check]\n-fn non_immediate_args(a: BigStruct, b: BigStruct) {\n-    println!(\"\");\n-}\n-\n-#[no_stack_check]\n-fn binding(a: i64, b: u64, c: f64) {\n-    let x = 0;\n-    println!(\"\");\n-}\n-\n-#[no_stack_check]\n-fn assignment(mut a: u64, b: u64, c: f64) {\n-    a = b;\n-    println!(\"\");\n-}\n-\n-#[no_stack_check]\n-fn function_call(x: u64, y: u64, z: f64) {\n-    println!(\"Hi!\")\n-}\n-\n-#[no_stack_check]\n-fn identifier(x: u64, y: u64, z: f64) -> u64 {\n-    x\n-}\n-\n-#[no_stack_check]\n-fn return_expr(x: u64, y: u64, z: f64) -> u64 {\n-    return x;\n-}\n-\n-#[no_stack_check]\n-fn arithmetic_expr(x: u64, y: u64, z: f64) -> u64 {\n-    x + y\n-}\n-\n-#[no_stack_check]\n-fn if_expr(x: u64, y: u64, z: f64) -> u64 {\n-    if x + y < 1000 {\n-        x\n-    } else {\n-        y\n-    }\n-}\n-\n-#[no_stack_check]\n-fn while_expr(mut x: u64, y: u64, z: u64) -> u64 {\n-    while x + y < 1000 {\n-        x += z\n-    }\n-    return x;\n-}\n-\n-#[no_stack_check]\n-fn loop_expr(mut x: u64, y: u64, z: u64) -> u64 {\n-    loop {\n-        x += z;\n-\n-        if x + y > 1000 {\n-            return x;\n-        }\n-    }\n-}\n-\n-fn main() {\n-    immediate_args(1, true, 2.5);\n-\n-    non_immediate_args(\n-        BigStruct {\n-            a: 3,\n-            b: 4,\n-            c: 5,\n-            d: 6,\n-            e: 7,\n-            f: 8,\n-            g: 9,\n-            h: 10\n-        },\n-        BigStruct {\n-            a: 11,\n-            b: 12,\n-            c: 13,\n-            d: 14,\n-            e: 15,\n-            f: 16,\n-            g: 17,\n-            h: 18\n-        }\n-    );\n-\n-    binding(19, 20, 21.5);\n-    assignment(22, 23, 24.5);\n-    function_call(25, 26, 27.5);\n-    identifier(28, 29, 30.5);\n-    return_expr(31, 32, 33.5);\n-    arithmetic_expr(34, 35, 36.5);\n-    if_expr(37, 38, 39.5);\n-    while_expr(40, 41, 42);\n-    loop_expr(43, 44, 45);\n-}"}, {"sha": "c53f51d5bf5842567ff1d6e5c00ab3c3d7e83f07", "filename": "src/test/run-make/issue-33329/Makefile", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Frun-make%2Fissue-33329%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Frun-make%2Fissue-33329%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-33329%2FMakefile?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -0,0 +1,5 @@\n+-include ../tools.mk\n+\n+all:\n+\t$(RUSTC) --target x86_64_unknown-linux-musl main.rs 2>&1 | \\\n+\t\tgrep \"error: Error loading target specification: Could not find specification for target\""}, {"sha": "e06c0a5ec2a4cf45084f385854e83ec00ac110ff", "filename": "src/test/run-make/issue-33329/main.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Frun-make%2Fissue-33329%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Frun-make%2Fissue-33329%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-33329%2Fmain.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -0,0 +1,11 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {}"}, {"sha": "d22fa6494f03631ddc74a243778122a01dc20d4a", "filename": "src/test/run-pass/env-args-reverse-iterator.rs", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Frun-pass%2Fenv-args-reverse-iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/990f193f6a2a469ff710d07238508b2ecf5e51f1/src%2Ftest%2Frun-pass%2Fenv-args-reverse-iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenv-args-reverse-iterator.rs?ref=990f193f6a2a469ff710d07238508b2ecf5e51f1", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::env::args;\n+use std::process::Command;\n+\n+fn assert_reverse_iterator_for_program_arguments(program_name: &str) {\n+    let args: Vec<_> = args().rev().collect();\n+\n+    assert!(args.len() == 4);\n+    assert_eq!(args[0], \"c\");\n+    assert_eq!(args[1], \"b\");\n+    assert_eq!(args[2], \"a\");\n+    assert_eq!(args[3], program_name);\n+\n+    println!(\"passed\");\n+}\n+\n+fn main() {\n+    let mut args = args();\n+    let me = args.next().unwrap();\n+\n+    if let Some(_) = args.next() {\n+        assert_reverse_iterator_for_program_arguments(&me);\n+        return\n+    }\n+\n+    let output = Command::new(&me)\n+        .arg(\"a\")\n+        .arg(\"b\")\n+        .arg(\"c\")\n+        .output()\n+        .unwrap();\n+    assert!(output.status.success());\n+    assert!(output.stderr.is_empty());\n+    assert_eq!(output.stdout, b\"passed\\n\");\n+}"}]}