{"sha": "d45dd2754e58d12ee5a9cabc4bb19ac8db18cecc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0NWRkMjc1NGU1OGQxMmVlNWE5Y2FiYzRiYjE5YWM4ZGIxOGNlY2M=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-02-07T19:41:29Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-02-11T21:55:24Z"}, "message": "regionck -- rewrite in terms of mem_categorization, compute upvar borrow kinds", "tree": {"sha": "5f1060a38203cf447f40842f9cee4e56a7a446ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f1060a38203cf447f40842f9cee4e56a7a446ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d45dd2754e58d12ee5a9cabc4bb19ac8db18cecc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d45dd2754e58d12ee5a9cabc4bb19ac8db18cecc", "html_url": "https://github.com/rust-lang/rust/commit/d45dd2754e58d12ee5a9cabc4bb19ac8db18cecc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d45dd2754e58d12ee5a9cabc4bb19ac8db18cecc/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1962a2b2e52f16ad817339e798f90fac973c2b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1962a2b2e52f16ad817339e798f90fac973c2b1", "html_url": "https://github.com/rust-lang/rust/commit/b1962a2b2e52f16ad817339e798f90fac973c2b1"}], "stats": {"total": 1258, "additions": 680, "deletions": 578}, "files": [{"sha": "7647de9a3adad1884eb0fc7eba849cfed1160a5b", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 680, "deletions": 578, "changes": 1258, "blob_url": "https://github.com/rust-lang/rust/blob/d45dd2754e58d12ee5a9cabc4bb19ac8db18cecc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45dd2754e58d12ee5a9cabc4bb19ac8db18cecc/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=d45dd2754e58d12ee5a9cabc4bb19ac8db18cecc", "patch": "@@ -12,23 +12,115 @@\n \n The region check is a final pass that runs over the AST after we have\n inferred the type constraints but before we have actually finalized\n-the types.  Its purpose is to embed some final region constraints.\n-The reason that this is not done earlier is that sometimes we don't\n-know whether a given type will be a region pointer or not until this\n-phase.\n-\n-In particular, we ensure that, if the type of an expression or\n-variable is `&'r T`, then the expression or variable must occur within\n-the region scope `r`.  Note that in some cases `r` may still be a\n-region variable, so this gives us a chance to influence the value for\n-`r` that we infer to ensure we choose a value large enough to enclose\n-all uses.  There is a lengthy comment in visit_node() that explains\n-this point a bit better.\n+the types.  Its purpose is to embed a variety of region constraints.\n+Inserting these constraints as a separate pass is good because (1) it\n+localizes the code that has to do with region inference and (2) often\n+we cannot know what constraints are needed until the basic types have\n+been inferred.\n+\n+### Interaction with the borrow checker\n+\n+In general, the job of the borrowck module (which runs later) is to\n+check that all soundness criteria are met, given a particular set of\n+regions. The job of *this* module is to anticipate the needs of the\n+borrow checker and infer regions that will satisfy its requirements.\n+It is generally true that the inference doesn't need to be sound,\n+meaning that if there is a bug and we inferred bad regions, the borrow\n+checker should catch it. This is not entirely true though; for\n+example, the borrow checker doesn't check subtyping, and it doesn't\n+check that region pointers are always live when they are used. It\n+might be worthwhile to fix this so that borrowck serves as a kind of\n+verification step -- that would add confidence in the overall\n+correctness of the compiler, at the cost of duplicating some type\n+checks and effort.\n+\n+### Inferring the duration of borrows, automatic and otherwise\n+\n+Whenever we introduce a borrowed pointer, for example as the result of\n+a borrow expression `let x = &data`, the lifetime of the pointer `x`\n+is always specified as a region inferencr variable. `regionck` has the\n+job of adding constraints such that this inference variable is as\n+narrow as possible while still accommodating all uses (that is, every\n+dereference of the resulting pointer must be within the lifetime).\n+\n+#### Reborrows\n+\n+Generally speaking, `regionck` does NOT try to ensure that the data\n+`data` will outlive the pointer `x`. That is the job of borrowck.  The\n+one exception is when \"re-borrowing\" the contents of another borrowed\n+pointer. For example, imagine you have a borrowed pointer `b` with\n+lifetime L1 and you have an expression `&*b`. The result of this\n+expression will be another borrowed pointer with lifetime L2 (which is\n+an inference variable). The borrow checker is going to enforce the\n+constraint that L2 < L1, because otherwise you are re-borrowing data\n+for a lifetime larger than the original loan.  However, without the\n+routines in this module, the region inferencer would not know of this\n+dependency and thus it might infer the lifetime of L2 to be greater\n+than L1 (issue #3148).\n+\n+There are a number of troublesome scenarios in the tests\n+`region-dependent-*.rs`, but here is one example:\n+\n+    struct Foo { i: int }\n+    struct Bar { foo: Foo  }\n+    fn get_i(x: &'a Bar) -> &'a int {\n+       let foo = &x.foo; // Lifetime L1\n+       &foo.i            // Lifetime L2\n+    }\n+\n+Note that this comes up either with `&` expressions, `ref`\n+bindings, and `autorefs`, which are the three ways to introduce\n+a borrow.\n+\n+The key point here is that when you are borrowing a value that\n+is \"guaranteed\" by a borrowed pointer, you must link the\n+lifetime of that borrowed pointer (L1, here) to the lifetime of\n+the borrow itself (L2).  What do I mean by \"guaranteed\" by a\n+borrowed pointer? I mean any data that is reached by first\n+dereferencing a borrowed pointer and then either traversing\n+interior offsets or owned pointers.  We say that the guarantor\n+of such data it the region of the borrowed pointer that was\n+traversed.  This is essentially the same as the ownership\n+relation, except that a borrowed pointer never owns its\n+contents.\n+\n+### Inferring borrow kinds for upvars\n+\n+Whenever there is a closure expression, we need to determine how each\n+upvar is used. We do this by initially assigning each upvar an\n+immutable \"borrow kind\" (see `ty::BorrowKind` for details) and then\n+\"escalating\" the kind as needed. The borrow kind proceeds according to\n+the following lattice:\n+\n+    ty::ImmBorrow -> ty::UniqueImmBorrow -> ty::MutBorrow\n+\n+So, for example, if we see an assignment `x = 5` to an upvar `x`, we\n+will promote it's borrow kind to mutable borrow. If we see an `&mut x`\n+we'll do the same. Naturally, this applies not just to the upvar, but\n+to everything owned by `x`, so the result is the same for something\n+like `x.f = 5` and so on (presuming `x` is not a borrowed pointer to a\n+struct). These adjustments are performed in\n+`adjust_upvar_borrow_kind()` (you can trace backwards through the code\n+from there).\n+\n+The fact that we are inferring borrow kinds as we go results in a\n+semi-hacky interaction with mem-categorization. In particular,\n+mem-categorization will query the current borrow kind as it\n+categorizes, and we'll return the *current* value, but this may get\n+adjusted later. Therefore, in this module, we genreally ignore the\n+borrow kind (and derived mutabilities) that are returned from\n+mem-categorization, since they may be inaccurate. (Another option\n+would be to use a unification scheme, where instead of returning a\n+concrete borrow kind like `ty::ImmBorrow`, we return a\n+`ty::InferBorrow(upvar_id)` or something like that, but this would\n+then mean that all later passes would have to check for these figments\n+and report an error, and it just seems like more mess in the end.)\n \n */\n \n \n-use middle::freevars::get_freevars;\n+use middle::freevars;\n+use mc = middle::mem_categorization;\n use middle::ty::{ReScope};\n use middle::ty;\n use middle::typeck::astconv::AstConv;\n@@ -43,6 +135,7 @@ use util::ppaux::{ty_to_str, region_to_str, Repr};\n use syntax::ast::{ManagedSigil, OwnedSigil, BorrowedSigil};\n use syntax::ast::{DefArg, DefBinding, DefLocal, DefUpvar};\n use syntax::ast;\n+use syntax::ast_util;\n use syntax::codemap::Span;\n use syntax::visit;\n use syntax::visit::Visitor;\n@@ -149,6 +242,36 @@ impl Rcx {\n     }\n }\n \n+impl<'a> mc::Typer for &'a mut Rcx {\n+    fn tcx(&self) -> ty::ctxt {\n+        self.fcx.tcx()\n+    }\n+\n+    fn node_ty(&mut self, id: ast::NodeId) -> mc::McResult<ty::t> {\n+        let t = self.resolve_node_type(id);\n+        if ty::type_is_error(t) {Err(())} else {Ok(t)}\n+    }\n+\n+    fn adjustment(&mut self, id: ast::NodeId) -> Option<@ty::AutoAdjustment> {\n+        let adjustments = self.fcx.inh.adjustments.borrow();\n+        adjustments.get().find_copy(&id)\n+    }\n+\n+    fn is_method_call(&mut self, id: ast::NodeId) -> bool {\n+        let method_map = self.fcx.inh.method_map.borrow();\n+        method_map.get().contains_key(&id)\n+    }\n+\n+    fn temporary_scope(&mut self, id: ast::NodeId) -> Option<ast::NodeId> {\n+        self.tcx().region_maps.temporary_scope(id)\n+    }\n+\n+    fn upvar_borrow(&mut self, id: ty::UpvarId) -> ty::UpvarBorrow {\n+        let upvar_borrow_map = self.fcx.inh.upvar_borrow_map.borrow();\n+        upvar_borrow_map.get().get_copy(&id)\n+    }\n+}\n+\n pub fn regionck_expr(fcx: @FnCtxt, e: &ast::Expr) {\n     let mut rcx = Rcx { fcx: fcx, errors_reported: 0,\n                          repeating_scope: e.id };\n@@ -213,7 +336,7 @@ fn visit_arm(rcx: &mut Rcx, arm: &ast::Arm) {\n fn visit_local(rcx: &mut Rcx, l: &ast::Local) {\n     // see above\n     constrain_bindings_in_pat(l.pat, rcx);\n-    guarantor::for_local(rcx, l);\n+    link_local(rcx, l);\n     visit::walk_local(rcx, l, ());\n }\n \n@@ -273,7 +396,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n                     let expr_ty = rcx.resolve_node_type(expr.id);\n                     constrain_derefs(rcx, expr, autoderefs, expr_ty);\n                     for autoref in opt_autoref.iter() {\n-                        guarantor::for_autoref(rcx, expr, autoderefs, autoref);\n+                        link_autoref(rcx, expr, autoderefs, autoref);\n \n                         // Require that the resulting region encompasses\n                         // the current node.\n@@ -323,8 +446,22 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             visit::walk_expr(rcx, expr, ());\n         }\n \n+        ast::ExprAssign(lhs, _) => {\n+            adjust_borrow_kind_for_assignment_lhs(rcx, lhs);\n+            visit::walk_expr(rcx, expr, ());\n+        }\n+\n+        ast::ExprAssignOp(callee_id, _, lhs, rhs) => {\n+            if has_method_map {\n+                constrain_call(rcx, callee_id, expr, Some(lhs), [rhs], true);\n+            }\n+\n+            adjust_borrow_kind_for_assignment_lhs(rcx, lhs);\n+\n+            visit::walk_expr(rcx, expr, ());\n+        }\n+\n         ast::ExprIndex(callee_id, lhs, rhs) |\n-        ast::ExprAssignOp(callee_id, _, lhs, rhs) |\n         ast::ExprBinary(callee_id, _, lhs, rhs) if has_method_map => {\n             // As `expr_method_call`, but the call is via an\n             // overloaded op.  Note that we (sadly) currently use an\n@@ -388,8 +525,8 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprAddrOf(_, base) => {\n-            guarantor::for_addr_of(rcx, expr, base);\n+        ast::ExprAddrOf(m, base) => {\n+            link_addr_of(rcx, expr, m, base);\n \n             // Require that when you write a `&expr` expression, the\n             // resulting pointer has a lifetime that encompasses the\n@@ -405,13 +542,13 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n         }\n \n         ast::ExprMatch(discr, ref arms) => {\n-            guarantor::for_match(rcx, discr, *arms);\n+            link_match(rcx, discr, *arms);\n \n             visit::walk_expr(rcx, expr, ());\n         }\n \n-        ast::ExprFnBlock(..) | ast::ExprProc(..) => {\n-            check_expr_fn_block(rcx, expr);\n+        ast::ExprFnBlock(_, ref body) | ast::ExprProc(_, ref body) => {\n+            check_expr_fn_block(rcx, expr, &**body);\n         }\n \n         ast::ExprLoop(body, _) => {\n@@ -437,43 +574,136 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n }\n \n fn check_expr_fn_block(rcx: &mut Rcx,\n-                       expr: &ast::Expr) {\n+                       expr: &ast::Expr,\n+                       body: &ast::Block) {\n     let tcx = rcx.fcx.tcx();\n-    match expr.node {\n-        ast::ExprFnBlock(_, ref body) | ast::ExprProc(_, ref body) => {\n-            let function_type = rcx.resolve_node_type(expr.id);\n-            match ty::get(function_type).sty {\n-                ty::ty_closure(\n-                    ty::ClosureTy {\n-                        sigil: ast::BorrowedSigil, region: region, ..}) => {\n-                    if get_freevars(tcx, expr.id).is_empty() {\n-                        // No free variables means that the environment\n-                        // will be NULL at runtime and hence the closure\n-                        // has static lifetime.\n-                    } else {\n-                        // Otherwise, the closure must not outlive the\n-                        // variables it closes over, nor can it\n-                        // outlive the innermost repeating scope\n-                        // (since otherwise that would require\n-                        // infinite stack).\n-                        constrain_free_variables(rcx, region, expr);\n-                        let repeating_scope = ty::ReScope(rcx.repeating_scope);\n-                        rcx.fcx.mk_subr(true, infer::InfStackClosure(expr.span),\n-                                        region, repeating_scope);\n-                    }\n-                }\n-                _ => ()\n+    let function_type = rcx.resolve_node_type(expr.id);\n+    match ty::get(function_type).sty {\n+        ty::ty_closure(ty::ClosureTy {\n+                sigil: ast::BorrowedSigil, region: region, ..}) => {\n+            let freevars = freevars::get_freevars(tcx, expr.id);\n+            if freevars.is_empty() {\n+                // No free variables means that the environment\n+                // will be NULL at runtime and hence the closure\n+                // has static lifetime.\n+            } else {\n+                // Closure must not outlive the variables it closes over.\n+                constrain_free_variables(rcx, region, expr, freevars);\n+\n+                // Closure cannot outlive the appropriate temporary scope.\n+                let s = rcx.repeating_scope;\n+                rcx.fcx.mk_subr(true, infer::InfStackClosure(expr.span),\n+                                region, ty::ReScope(s));\n             }\n+        }\n+        _ => ()\n+    }\n \n-            let repeating_scope = rcx.set_repeating_scope(body.id);\n-            visit::walk_expr(rcx, expr, ());\n-            rcx.set_repeating_scope(repeating_scope);\n+    let repeating_scope = rcx.set_repeating_scope(body.id);\n+    visit::walk_expr(rcx, expr, ());\n+    rcx.set_repeating_scope(repeating_scope);\n+\n+    match ty::get(function_type).sty {\n+        ty::ty_closure(ty::ClosureTy {sigil: ast::BorrowedSigil, ..}) => {\n+            let freevars = freevars::get_freevars(tcx, expr.id);\n+            propagate_upupvar_borrow_kind(rcx, expr, freevars);\n         }\n+        _ => ()\n+    }\n \n-        _ => {\n-            tcx.sess.span_bug(\n-                expr.span,\n-                \"expected expr_fn_block\");\n+    fn constrain_free_variables(rcx: &mut Rcx,\n+                                region: ty::Region,\n+                                expr: &ast::Expr,\n+                                freevars: freevars::freevar_info) {\n+        /*!\n+         * Make sure that all free variables referenced inside the closure\n+         * outlive the closure itself. Also, create an entry in the\n+         * upvar_borrows map with a region.\n+         */\n+\n+        let tcx = rcx.fcx.ccx.tcx;\n+        let infcx = rcx.fcx.infcx();\n+        debug!(\"constrain_free_variables({}, {})\",\n+               region.repr(tcx), expr.repr(tcx));\n+        for freevar in freevars.iter() {\n+            debug!(\"freevar def is {:?}\", freevar.def);\n+\n+            // Identify the variable being closed over and its node-id.\n+            let def = freevar.def;\n+            let def_id = ast_util::def_id_of_def(def);\n+            assert!(def_id.crate == ast::LOCAL_CRATE);\n+            let upvar_id = ty::UpvarId { var_id: def_id.node,\n+                                         closure_expr_id: expr.id };\n+\n+            // Create a region variable to represent this borrow. This borrow\n+            // must outlive the region on the closure.\n+            let origin = infer::UpvarRegion(upvar_id, expr.span);\n+            let freevar_region = infcx.next_region_var(origin);\n+            rcx.fcx.mk_subr(true, infer::FreeVariable(freevar.span, def_id.node),\n+                            region, freevar_region);\n+\n+            // Create a UpvarBorrow entry. Note that we begin with a\n+            // const borrow_kind, but change it to either mut or\n+            // immutable as dictated by the uses.\n+            let upvar_borrow = ty::UpvarBorrow { kind: ty::ImmBorrow,\n+                                                 region: freevar_region };\n+            let mut upvar_borrow_map = rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n+            upvar_borrow_map.get().insert(upvar_id, upvar_borrow);\n+\n+            // Guarantee that the closure does not outlive the variable itself.\n+            let en_region = region_of_def(rcx.fcx, def);\n+            debug!(\"en_region = {}\", en_region.repr(tcx));\n+            rcx.fcx.mk_subr(true, infer::FreeVariable(freevar.span, def_id.node),\n+                            region, en_region);\n+        }\n+    }\n+\n+    fn propagate_upupvar_borrow_kind(rcx: &mut Rcx,\n+                                     expr: &ast::Expr,\n+                                     freevars: freevars::freevar_info) {\n+        let tcx = rcx.fcx.ccx.tcx;\n+        debug!(\"propagate_upupvar_borrow_kind({})\", expr.repr(tcx));\n+        for freevar in freevars.iter() {\n+            // Because of the semi-hokey way that we are doing\n+            // borrow_kind inference, we need to check for\n+            // indirect dependencies, like so:\n+            //\n+            //     let mut x = 0;\n+            //     outer_call(|| {\n+            //         inner_call(|| {\n+            //             x = 1;\n+            //         });\n+            //     });\n+            //\n+            // Here, the `inner_call` is basically \"reborrowing\" the\n+            // outer pointer. With no other changes, `inner_call`\n+            // would infer that it requires a mutable borrow, but\n+            // `outer_call` would infer that a const borrow is\n+            // sufficient. This is because we haven't linked the\n+            // borrow_kind of the borrow that occurs in the inner\n+            // closure to the borrow_kind of the borrow in the outer\n+            // closure. Note that regions *are* naturally linked\n+            // because we have a proper inference scheme there.\n+            //\n+            // Anyway, for borrow_kind, we basically go back over now\n+            // after checking the inner closure (and hence\n+            // determining the final borrow_kind) and propagate that as\n+            // a constraint on the outer closure.\n+            match freevar.def {\n+                ast::DefUpvar(var_id, _, outer_closure_id, _) => {\n+                    // thing being captured is itself an upvar:\n+                    let outer_upvar_id = ty::UpvarId {\n+                        var_id: var_id,\n+                        closure_expr_id: outer_closure_id };\n+                    let inner_upvar_id = ty::UpvarId {\n+                        var_id: var_id,\n+                        closure_expr_id: expr.id };\n+                    link_upvar_borrow_kind(rcx,\n+                                           inner_upvar_id,\n+                                           outer_upvar_id);\n+                }\n+                _ => {}\n+            }\n         }\n     }\n }\n@@ -554,7 +784,7 @@ fn constrain_call(rcx: &mut Rcx,\n         // result. modes are going away and the \"DerefArgs\" code\n         // should be ported to use adjustments\n         if implicitly_ref_args {\n-            guarantor::for_by_ref(rcx, arg_expr, callee_scope);\n+            link_by_ref(rcx, arg_expr, callee_scope);\n         }\n     }\n \n@@ -564,7 +794,7 @@ fn constrain_call(rcx: &mut Rcx,\n         constrain_regions_in_type_of_node(\n             rcx, r.id, callee_region, infer::CallRcvr(r.span));\n         if implicitly_ref_args {\n-            guarantor::for_by_ref(rcx, r, callee_scope);\n+            link_by_ref(rcx, r, callee_scope);\n         }\n     }\n \n@@ -644,27 +874,6 @@ fn constrain_index(rcx: &mut Rcx,\n     }\n }\n \n-fn constrain_free_variables(rcx: &mut Rcx,\n-                            region: ty::Region,\n-                            expr: &ast::Expr) {\n-    /*!\n-     * Make sure that all free variables referenced inside the closure\n-     * outlive the closure itself.\n-     */\n-\n-    let tcx = rcx.fcx.ccx.tcx;\n-    debug!(\"constrain_free_variables({}, {})\",\n-           region.repr(tcx), expr.repr(tcx));\n-    for freevar in get_freevars(tcx, expr.id).iter() {\n-        debug!(\"freevar def is {:?}\", freevar.def);\n-        let def = freevar.def;\n-        let def_region = region_of_def(rcx.fcx, def);\n-        debug!(\"def_region = {}\", def_region.repr(tcx));\n-        rcx.fcx.mk_subr(true, infer::FreeVariable(freevar.span),\n-                        region, def_region);\n-    }\n-}\n-\n fn constrain_regions_in_type_of_node(\n     rcx: &mut Rcx,\n     id: ast::NodeId,\n@@ -744,576 +953,469 @@ fn constrain_regions_in_type(\n     return e == rcx.errors_reported;\n }\n \n-pub mod guarantor {\n+// If mem categorization results in an error, it's because the type\n+// check failed (or will fail, when the error is uncovered and\n+// reported during writeback). In this case, we just ignore this part\n+// of the code and don't try to add any more region constraints.\n+macro_rules! ignore_err(\n+    ($inp: expr) => (\n+        match $inp {\n+            Ok(v) => { v }\n+            Err(()) => { return; }\n+        }\n+    )\n+)\n+\n+fn link_addr_of(rcx: &mut Rcx, expr: &ast::Expr,\n+               mutability: ast::Mutability, base: &ast::Expr) {\n     /*!\n-     * The routines in this module are aiming to deal with the case\n-     * where a the contents of a reference are re-borrowed.\n-     * Imagine you have a reference `b` with lifetime L1 and\n-     * you have an expression `&*b`.  The result of this borrow will\n-     * be another reference with lifetime L2 (which is an\n-     * inference variable).  The borrow checker is going to enforce\n-     * the constraint that L2 < L1, because otherwise you are\n-     * re-borrowing data for a lifetime larger than the original loan.\n-     * However, without the routines in this module, the region\n-     * inferencer would not know of this dependency and thus it might\n-     * infer the lifetime of L2 to be greater than L1 (issue #3148).\n-     *\n-     * There are a number of troublesome scenarios in the tests\n-     * `region-dependent-*.rs`, but here is one example:\n-     *\n-     *     struct Foo { i: int }\n-     *     struct Bar { foo: Foo  }\n-     *     fn get_i(x: &'a Bar) -> &'a int {\n-     *        let foo = &x.foo; // Lifetime L1\n-     *        &foo.i            // Lifetime L2\n-     *     }\n-     *\n-     * Note that this comes up either with `&` expressions, `ref`\n-     * bindings, and `autorefs`, which are the three ways to introduce\n-     * a borrow.\n-     *\n-     * The key point here is that when you are borrowing a value that\n-     * is \"guaranteed\" by a reference, you must link the\n-     * lifetime of that reference (L1, here) to the lifetime of\n-     * the borrow itself (L2).  What do I mean by \"guaranteed\" by a\n-     * reference? I mean any data that is reached by first\n-     * dereferencing a reference and then either traversing\n-     * interior offsets or owned pointers.  We say that the guarantor\n-     * of such data it the region of the reference that was\n-     * traversed.  This is essentially the same as the ownership\n-     * relation, except that a reference never owns its\n-     * contents.\n-     *\n-     * NB: I really wanted to use the `mem_categorization` code here\n-     * but I cannot because final type resolution hasn't happened yet,\n-     * and `mem_categorization` requires that all types be known.\n-     * So this is very similar logic to what you would find there,\n-     * but more special purpose.\n+     * Computes the guarantor for an expression `&base` and then\n+     * ensures that the lifetime of the resulting pointer is linked\n+     * to the lifetime of its guarantor (if any).\n      */\n \n-    use middle::typeck::astconv::AstConv;\n-    use middle::typeck::check::regionck::Rcx;\n-    use middle::typeck::check::regionck::mk_subregion_due_to_derefence;\n-    use middle::typeck::infer;\n-    use middle::ty;\n-    use syntax::ast;\n-    use syntax::codemap::Span;\n-    use util::ppaux::{ty_to_str, Repr};\n+    debug!(\"link_addr_of(base=?)\");\n \n-    pub fn for_addr_of(rcx: &mut Rcx, expr: &ast::Expr, base: &ast::Expr) {\n-        /*!\n-         * Computes the guarantor for an expression `&base` and then\n-         * ensures that the lifetime of the resulting pointer is linked\n-         * to the lifetime of its guarantor (if any).\n-         */\n+    let cmt = {\n+        let mut mc = mc::MemCategorizationContext { typer: &mut *rcx };\n+        ignore_err!(mc.cat_expr(base))\n+    };\n+    link_region_from_node_type(rcx, expr.span, expr.id, mutability, cmt);\n+}\n \n-        debug!(\"guarantor::for_addr_of(base=?)\");\n+fn link_local(rcx: &mut Rcx, local: &ast::Local) {\n+    /*!\n+     * Computes the guarantors for any ref bindings in a `let` and\n+     * then ensures that the lifetime of the resulting pointer is\n+     * linked to the lifetime of the initialization expression.\n+     */\n \n-        let guarantor = guarantor(rcx, base);\n-        link(rcx, expr.span, expr.id, guarantor);\n-    }\n+    debug!(\"regionck::for_local()\");\n+    let init_expr = match local.init {\n+        None => { return; }\n+        Some(expr) => expr,\n+    };\n+    let mut mc = mc::MemCategorizationContext { typer: rcx };\n+    let discr_cmt = ignore_err!(mc.cat_expr(init_expr));\n+    link_pattern(&mut mc, discr_cmt, local.pat);\n+}\n \n-    pub fn for_match(rcx: &mut Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n-        /*!\n-         * Computes the guarantors for any ref bindings in a match and\n-         * then ensures that the lifetime of the resulting pointer is\n-         * linked to the lifetime of its guarantor (if any).\n-         */\n+fn link_match(rcx: &mut Rcx, discr: &ast::Expr, arms: &[ast::Arm]) {\n+    /*!\n+     * Computes the guarantors for any ref bindings in a match and\n+     * then ensures that the lifetime of the resulting pointer is\n+     * linked to the lifetime of its guarantor (if any).\n+     */\n \n-        debug!(\"regionck::for_match()\");\n-        let discr_guarantor = guarantor(rcx, discr);\n-        debug!(\"discr_guarantor={}\", discr_guarantor.repr(rcx.tcx()));\n-        for arm in arms.iter() {\n-            for pat in arm.pats.iter() {\n-                link_ref_bindings_in_pat(rcx, *pat, discr_guarantor);\n-            }\n+    debug!(\"regionck::for_match()\");\n+    let mut mc = mc::MemCategorizationContext { typer: rcx };\n+    let discr_cmt = ignore_err!(mc.cat_expr(discr));\n+    debug!(\"discr_cmt={}\", discr_cmt.repr(mc.typer.tcx()));\n+    for arm in arms.iter() {\n+        for &root_pat in arm.pats.iter() {\n+            link_pattern(&mut mc, discr_cmt, root_pat);\n         }\n     }\n+}\n \n-    pub fn for_local(rcx: &mut Rcx, local: &ast::Local) {\n-        /*!\n-         * Link the lifetimes of any ref bindings in a let\n-         * pattern to the lifetimes in the initializer.\n-         *\n-         * For example, given something like this:\n-         *\n-         *    let &Foo(ref x) = ...;\n-         *\n-         * this would ensure that the lifetime 'a of the\n-         * region pointer being matched must be >= the lifetime\n-         * of the ref binding.\n-         */\n-\n-        debug!(\"regionck::for_match()\");\n-        let init_expr = match local.init {\n-            None => { return; }\n-            Some(e) => e\n-        };\n-        let init_guarantor = guarantor(rcx, init_expr);\n-        debug!(\"init_guarantor={}\", init_guarantor.repr(rcx.tcx()));\n-        link_ref_bindings_in_pat(rcx, local.pat, init_guarantor);\n-    }\n-\n-    pub fn for_autoref(rcx: &mut Rcx,\n-                       expr: &ast::Expr,\n-                       autoderefs: uint,\n-                       autoref: &ty::AutoRef) {\n-        /*!\n-         * Computes the guarantor for an expression that has an\n-         * autoref adjustment and links it to the lifetime of the\n-         * autoref.  This is only important when auto re-borrowing\n-         * region pointers.\n-         */\n-\n-        debug!(\"guarantor::for_autoref(autoref={:?})\", autoref);\n+fn link_pattern(mc: &mut mc::MemCategorizationContext<&mut Rcx>,\n+                discr_cmt: mc::cmt,\n+                root_pat: @ast::Pat) {\n+    /*!\n+     * Link lifetimes of any ref bindings in `root_pat` to\n+     * the pointers found in the discriminant, if needed.\n+     */\n \n-        let mut expr_ct = categorize_unadjusted(rcx, expr);\n-        debug!(\"    unadjusted cat={:?}\", expr_ct.cat);\n-        expr_ct = apply_autoderefs(\n-            rcx, expr, autoderefs, expr_ct);\n+    let _ = mc.cat_pattern(discr_cmt, root_pat, |mc, sub_cmt, sub_pat| {\n+            match sub_pat.node {\n+                // `ref x` pattern\n+                ast::PatIdent(ast::BindByRef(mutbl), _, _) => {\n+                    link_region_from_node_type(\n+                        mc.typer, sub_pat.span, sub_pat.id,\n+                        mutbl, sub_cmt);\n+                }\n \n-        match *autoref {\n-            ty::AutoPtr(r, _) => {\n-                // In this case, we are implicitly adding an `&`.\n-                maybe_make_subregion(rcx, expr, r, expr_ct.cat.guarantor);\n+                // `[_, ..slice, _]` pattern\n+                ast::PatVec(_, Some(slice_pat), _) => {\n+                    match mc.cat_slice_pattern(sub_cmt, slice_pat) {\n+                        Ok((slice_cmt, slice_mutbl, slice_r)) => {\n+                            link_region(mc.typer, sub_pat.span, slice_r,\n+                                        slice_mutbl, slice_cmt);\n+                        }\n+                        Err(()) => {}\n+                    }\n+                }\n+                _ => {}\n             }\n+        });\n+}\n \n-            ty::AutoBorrowVec(r, _) |\n-            ty::AutoBorrowVecRef(r, _) |\n-            ty::AutoBorrowFn(r) |\n-            ty::AutoBorrowObj(r, _) => {\n-                // In each of these cases, what is being borrowed is\n-                // not the (autoderef'd) expr itself but rather the\n-                // contents of the autoderef'd expression (i.e., what\n-                // the pointer points at).\n-                maybe_make_subregion(rcx, expr, r,\n-                                     guarantor_of_deref(&expr_ct.cat));\n-            }\n+fn link_autoref(rcx: &mut Rcx,\n+                expr: &ast::Expr,\n+                autoderefs: uint,\n+                autoref: &ty::AutoRef) {\n+    /*!\n+     * Link lifetime of borrowed pointer resulting from autoref\n+     * to lifetimes in the value being autoref'd.\n+     */\n \n-            ty::AutoUnsafe(_) => {}\n+    debug!(\"link_autoref(autoref={:?})\", autoref);\n+    let mut mc = mc::MemCategorizationContext { typer: rcx };\n+    let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n+    debug!(\"expr_cmt={}\", expr_cmt.repr(mc.typer.tcx()));\n+\n+    match *autoref {\n+        ty::AutoPtr(r, m) => {\n+            link_region(mc.typer, expr.span, r, m, expr_cmt);\n         }\n \n-        fn maybe_make_subregion(\n-            rcx: &mut Rcx,\n-            expr: &ast::Expr,\n-            sub_region: ty::Region,\n-            sup_region: Option<ty::Region>)\n-        {\n-            for r in sup_region.iter() {\n-                rcx.fcx.mk_subr(true, infer::Reborrow(expr.span),\n-                                sub_region, *r);\n-            }\n+        ty::AutoBorrowVec(r, m) | ty::AutoBorrowVecRef(r, m) => {\n+            let cmt_index = mc.cat_index(expr, expr_cmt, autoderefs+1);\n+            link_region(mc.typer, expr.span, r, m, cmt_index);\n         }\n-    }\n \n-    pub fn for_by_ref(rcx: &mut Rcx,\n-                      expr: &ast::Expr,\n-                      callee_scope: ast::NodeId) {\n-        /*!\n-         * Computes the guarantor for cases where the `expr` is\n-         * being passed by implicit reference and must outlive\n-         * `callee_scope`.\n-         */\n+        ty::AutoBorrowFn(r) => {\n+            let cmt_deref = mc.cat_deref_fn_or_obj(expr, expr_cmt, 0);\n+            link_region(mc.typer, expr.span, r, ast::MutImmutable, cmt_deref);\n+        }\n \n-        let tcx = rcx.tcx();\n-        debug!(\"guarantor::for_by_ref(expr={}, callee_scope={:?})\",\n-               expr.repr(tcx), callee_scope);\n-        let expr_cat = categorize(rcx, expr);\n-        debug!(\"guarantor::for_by_ref(expr={:?}, callee_scope={:?}) category={:?}\",\n-               expr.id, callee_scope, expr_cat);\n-        let minimum_lifetime = ty::ReScope(callee_scope);\n-        for guarantor in expr_cat.guarantor.iter() {\n-            mk_subregion_due_to_derefence(rcx, expr.span,\n-                                          minimum_lifetime, *guarantor);\n+        ty::AutoBorrowObj(r, m) => {\n+            let cmt_deref = mc.cat_deref_fn_or_obj(expr, expr_cmt, 0);\n+            link_region(mc.typer, expr.span, r, m, cmt_deref);\n         }\n+\n+        ty::AutoUnsafe(_) => {}\n     }\n+}\n \n-    fn link(\n-        rcx: &mut Rcx,\n-        span: Span,\n-        id: ast::NodeId,\n-        guarantor: Option<ty::Region>) {\n-        /*!\n-         *\n-         * Links the lifetime of the reference resulting from a borrow\n-         * to the lifetime of its guarantor (if any).\n-         */\n+fn link_by_ref(rcx: &mut Rcx,\n+               expr: &ast::Expr,\n+               callee_scope: ast::NodeId) {\n+    /*!\n+     * Computes the guarantor for cases where the `expr` is\n+     * being passed by implicit reference and must outlive\n+     * `callee_scope`.\n+     */\n \n-        debug!(\"link(id={:?}, guarantor={:?})\", id, guarantor);\n+    let tcx = rcx.tcx();\n+    debug!(\"link_by_ref(expr={}, callee_scope={})\",\n+           expr.repr(tcx), callee_scope);\n+    let mut mc = mc::MemCategorizationContext { typer: rcx };\n+    let expr_cmt = ignore_err!(mc.cat_expr(expr));\n+    let region_min = ty::ReScope(callee_scope);\n+    link_region(mc.typer, expr.span, region_min, ast::MutImmutable, expr_cmt);\n+}\n \n-        let bound = match guarantor {\n-            None => {\n-                // If guarantor is None, then the value being borrowed\n-                // is not guaranteed by a region pointer, so there are\n-                // no lifetimes to link.\n-                return;\n-            }\n-            Some(r) => { r }\n-        };\n-\n-        // this routine is used for the result of ref bindings and &\n-        // expressions, both of which always yield a region variable, so\n-        // mk_subr should never fail.\n-        let rptr_ty = rcx.resolve_node_type(id);\n-        if !ty::type_is_bot(rptr_ty) {\n-            let tcx = rcx.fcx.ccx.tcx;\n-            debug!(\"rptr_ty={}\", ty_to_str(tcx, rptr_ty));\n-            let r = ty::ty_region(tcx, span, rptr_ty);\n-            rcx.fcx.mk_subr(true, infer::Reborrow(span), r, bound);\n-        }\n-    }\n+fn link_region_from_node_type(rcx: &mut Rcx,\n+                              span: Span,\n+                              id: ast::NodeId,\n+                              mutbl: ast::Mutability,\n+                              cmt_borrowed: mc::cmt) {\n+    /*!\n+     * Like `link_region()`, except that the region is\n+     * extracted from the type of `id`, which must be some\n+     * region-typed thing.\n+     */\n \n-    /// Categorizes types based on what kind of pointer they are.\n-    /// Note that we don't bother to distinguish between rptrs (&T)\n-    /// and slices (&[T], &str)---they are all just `BorrowedPointer`.\n-    enum PointerCategorization {\n-        NotPointer,\n-        OwnedPointer,\n-        BorrowedPointer(ty::Region),\n-        OtherPointer\n+    let rptr_ty = rcx.resolve_node_type(id);\n+    if !ty::type_is_bot(rptr_ty) && !ty::type_is_error(rptr_ty) {\n+        let tcx = rcx.fcx.ccx.tcx;\n+        debug!(\"rptr_ty={}\", ty_to_str(tcx, rptr_ty));\n+        let r = ty::ty_region(tcx, span, rptr_ty);\n+        link_region(rcx, span, r, mutbl, cmt_borrowed);\n     }\n+}\n \n-    /// Guarantor of an expression paired with the\n-    /// PointerCategorization` of its type.\n-    struct ExprCategorization {\n-        guarantor: Option<ty::Region>,\n-        pointer: PointerCategorization\n-    }\n+fn link_region(rcx: &mut Rcx,\n+               span: Span,\n+               region_min: ty::Region,\n+               mutbl: ast::Mutability,\n+               cmt_borrowed: mc::cmt) {\n+    /*!\n+     * Informs the inference engine that a borrow of `cmt`\n+     * must have mutability `mutbl` and lifetime `region_min`.\n+     * If `cmt` is a deref of a region pointer with\n+     * lifetime `r_borrowed`, this will add the constraint that\n+     * `region_min <= r_borrowed`.\n+     */\n \n-    /// ExprCategorization paired with the full type of the expr\n-    struct ExprCategorizationType {\n-        cat: ExprCategorization,\n-        ty: ty::t\n-    }\n+    // Iterate through all the things that must be live at least\n+    // for the lifetime `region_min` for the borrow to be valid:\n+    let mut cmt_borrowed = cmt_borrowed;\n+    loop {\n+        debug!(\"link_region(region_min={}, mutbl={}, cmt_borrowed={})\",\n+               region_min.repr(rcx.tcx()),\n+               mutbl.repr(rcx.tcx()),\n+               cmt_borrowed.repr(rcx.tcx()));\n+        match cmt_borrowed.cat {\n+            mc::cat_deref(base, _, mc::BorrowedPtr(_, r_borrowed)) => {\n+                // References to an upvar `x` are translated to\n+                // `*x`, since that is what happens in the\n+                // underlying machine.  We detect such references\n+                // and treat them slightly differently, both to\n+                // offer better error messages and because we need\n+                // to infer the kind of borrow (mut, const, etc)\n+                // to use for each upvar.\n+                let cause = match base.cat {\n+                    mc::cat_upvar(ref upvar_id, _) => {\n+                        let mut upvar_borrow_map =\n+                            rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n+                        match upvar_borrow_map.get().find_mut(upvar_id) {\n+                            Some(upvar_borrow) => {\n+                                debug!(\"link_region: {} <= {}\",\n+                                       region_min.repr(rcx.tcx()),\n+                                       upvar_borrow.region.repr(rcx.tcx()));\n+                                adjust_upvar_borrow_kind_for_loan(\n+                                    *upvar_id,\n+                                    upvar_borrow,\n+                                    mutbl);\n+                                infer::ReborrowUpvar(span, *upvar_id)\n+                            }\n+                            None => {\n+                                rcx.tcx().sess.span_bug(\n+                                    span,\n+                                    format!(\"Illegal upvar id: {}\",\n+                                            upvar_id.repr(rcx.tcx())));\n+                            }\n+                        }\n+                    }\n \n-    fn guarantor(rcx: &mut Rcx, expr: &ast::Expr) -> Option<ty::Region> {\n-        /*!\n-         *\n-         * Computes the guarantor of `expr`, or None if `expr` is\n-         * not guaranteed by any region.  Here `expr` is some expression\n-         * whose address is being taken (e.g., there is an expression\n-         * `&expr`).\n-         */\n+                    _ => {\n+                        infer::Reborrow(span)\n+                    }\n+                };\n \n-        debug!(\"guarantor()\");\n-        match expr.node {\n-            ast::ExprUnary(_, ast::UnDeref, b) => {\n-                let cat = categorize(rcx, b);\n-                guarantor_of_deref(&cat)\n-            }\n-            ast::ExprField(b, _, _) => {\n-                categorize(rcx, b).guarantor\n-            }\n-            ast::ExprIndex(_, b, _) => {\n-                let cat = categorize(rcx, b);\n-                guarantor_of_deref(&cat)\n-            }\n+                debug!(\"link_region: {} <= {}\",\n+                       region_min.repr(rcx.tcx()),\n+                       r_borrowed.repr(rcx.tcx()));\n+                rcx.fcx.mk_subr(true, cause, region_min, r_borrowed);\n+\n+                if mutbl == ast::MutMutable {\n+                    // If this is a mutable borrow, then the thing\n+                    // being borrowed will have to be unique.\n+                    // In user code, this means it must be an `&mut`\n+                    // borrow, but for an upvar, we might opt\n+                    // for an immutable-unique borrow.\n+                    adjust_upvar_borrow_kind_for_unique(rcx, base);\n+                }\n \n-            ast::ExprParen(e) => {\n-                guarantor(rcx, e)\n+                // Borrowing an `&mut` pointee for `region_min` is\n+                // only valid if the pointer resides in a unique\n+                // location which is itself valid for\n+                // `region_min`.  We don't care about the unique\n+                // part, but we may need to influence the\n+                // inference to ensure that the location remains\n+                // valid.\n+                //\n+                // FIXME(#8624) fixing borrowck will require this\n+                // if m == ast::m_mutbl {\n+                //    cmt_borrowed = cmt_base;\n+                // } else {\n+                //    return;\n+                // }\n+                return;\n             }\n-\n-            // Either a variable or constant and hence resides\n-            // in constant memory or on the stack frame.  Either way,\n-            // not guaranteed by a region pointer.\n-            ast::ExprPath(..) => None,\n-\n-            // All of these expressions are rvalues and hence their\n-            // value is not guaranteed by a region pointer.\n-            ast::ExprInlineAsm(..) |\n-            ast::ExprMac(..) |\n-            ast::ExprLit(_) |\n-            ast::ExprUnary(..) |\n-            ast::ExprAddrOf(..) |\n-            ast::ExprBinary(..) |\n-            ast::ExprVstore(..) |\n-            ast::ExprBox(..) |\n-            ast::ExprBreak(..) |\n-            ast::ExprAgain(..) |\n-            ast::ExprRet(..) |\n-            ast::ExprLogLevel |\n-            ast::ExprWhile(..) |\n-            ast::ExprLoop(..) |\n-            ast::ExprAssign(..) |\n-            ast::ExprAssignOp(..) |\n-            ast::ExprCast(..) |\n-            ast::ExprCall(..) |\n-            ast::ExprMethodCall(..) |\n-            ast::ExprStruct(..) |\n-            ast::ExprTup(..) |\n-            ast::ExprIf(..) |\n-            ast::ExprMatch(..) |\n-            ast::ExprFnBlock(..) |\n-            ast::ExprProc(..) |\n-            ast::ExprBlock(..) |\n-            ast::ExprRepeat(..) |\n-            ast::ExprVec(..) => {\n-                assert!(!ty::expr_is_lval(\n-                    rcx.fcx.tcx(), rcx.fcx.inh.method_map, expr));\n-                None\n+            mc::cat_discr(cmt_base, _) |\n+            mc::cat_downcast(cmt_base) |\n+            mc::cat_deref(cmt_base, _, mc::OwnedPtr) |\n+            mc::cat_interior(cmt_base, _) => {\n+                // Interior or owned data requires its base to be valid\n+                cmt_borrowed = cmt_base;\n+            }\n+            mc::cat_deref(_, _, mc::GcPtr(..)) |\n+            mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n+            mc::cat_static_item |\n+            mc::cat_copied_upvar(..) |\n+            mc::cat_local(..) |\n+            mc::cat_arg(..) |\n+            mc::cat_upvar(..) |\n+            mc::cat_rvalue(..) => {\n+                // These are all \"base cases\" with independent lifetimes\n+                // that are not subject to inference\n+                return;\n             }\n-            ast::ExprForLoop(..) => fail!(\"non-desugared expr_for_loop\"),\n         }\n     }\n+}\n \n-    fn categorize(rcx: &mut Rcx, expr: &ast::Expr) -> ExprCategorization {\n-        debug!(\"categorize()\");\n-\n-        let mut expr_ct = categorize_unadjusted(rcx, expr);\n-        debug!(\"before adjustments, cat={:?}\", expr_ct.cat);\n+fn adjust_borrow_kind_for_assignment_lhs(rcx: &mut Rcx,\n+                                         lhs: &ast::Expr) {\n+    /*!\n+     * Adjusts the inferred borrow_kind as needed to account\n+     * for upvars that are assigned to in an assignment\n+     * expression.\n+     */\n \n-        let adjustments = rcx.fcx.inh.adjustments.borrow();\n-        match adjustments.get().find(&expr.id) {\n-            Some(adjustment) => {\n-                match **adjustment {\n-                    ty::AutoAddEnv(..) => {\n-                        // This is basically an rvalue, not a pointer, no regions\n-                        // involved.\n-                        expr_ct.cat = ExprCategorization {\n-                            guarantor: None,\n-                            pointer: NotPointer\n-                        };\n-                    }\n+    let mut mc = mc::MemCategorizationContext { typer: rcx };\n+    let cmt = ignore_err!(mc.cat_expr(lhs));\n+    adjust_upvar_borrow_kind_for_mut(mc.typer, cmt);\n+}\n \n-                    ty::AutoObject(ast::BorrowedSigil,\n-                                   Some(region),\n-                                   _,\n-                                   _,\n-                                   _,\n-                                   _) => {\n-                        expr_ct.cat = ExprCategorization {\n-                            guarantor: None,\n-                            pointer: BorrowedPointer(region)\n-                        };\n-                    }\n+fn adjust_upvar_borrow_kind_for_mut(rcx: &mut Rcx,\n+                                    cmt: mc::cmt) {\n+    let mut cmt = cmt;\n+    loop {\n+        debug!(\"adjust_upvar_borrow_kind_for_mut(cmt={})\",\n+               cmt.repr(rcx.tcx()));\n+\n+        match cmt.cat {\n+            mc::cat_deref(base, _, mc::OwnedPtr) |\n+            mc::cat_interior(base, _) |\n+            mc::cat_downcast(base) |\n+            mc::cat_discr(base, _) => {\n+                // Interior or owned data is mutable if base is\n+                // mutable, so iterate to the base.\n+                cmt = base;\n+                continue;\n+            }\n \n-                    ty::AutoObject(ast::OwnedSigil, _, _, _, _, _) => {\n-                        expr_ct.cat = ExprCategorization {\n-                            guarantor: None,\n-                            pointer: OwnedPointer\n-                        };\n+            mc::cat_deref(base, _, mc::BorrowedPtr(..)) => {\n+                match base.cat {\n+                    mc::cat_upvar(ref upvar_id, _) => {\n+                        // if this is an implicit deref of an\n+                        // upvar, then we need to modify the\n+                        // borrow_kind of the upvar to make sure it\n+                        // is inferred to mutable if necessary\n+                        let mut upvar_borrow_map =\n+                            rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n+                        let ub = upvar_borrow_map.get().get_mut(upvar_id);\n+                        return adjust_upvar_borrow_kind(*upvar_id, ub, ty::MutBorrow);\n                     }\n \n-                    ty::AutoObject(ast::ManagedSigil, _, _, _, _, _) => {\n-                        expr_ct.cat = ExprCategorization {\n-                            guarantor: None,\n-                            pointer: OtherPointer\n-                        };\n+                    _ => {\n+                        // assignment to deref of an `&mut`\n+                        // borrowed pointer implies that the\n+                        // pointer itself must be unique, but not\n+                        // necessarily *mutable*\n+                        return adjust_upvar_borrow_kind_for_unique(rcx, base);\n                     }\n-                    ty::AutoDerefRef(ref adjustment) => {\n-                        debug!(\"adjustment={:?}\", adjustment);\n-\n-                        expr_ct = apply_autoderefs(\n-                            rcx, expr, adjustment.autoderefs, expr_ct);\n-\n-                        match adjustment.autoref {\n-                            None => {\n-                            }\n-                            Some(ty::AutoUnsafe(_)) => {\n-                                expr_ct.cat.guarantor = None;\n-                                expr_ct.cat.pointer = OtherPointer;\n-                                debug!(\"autoref, cat={:?}\", expr_ct.cat);\n-                            }\n-                            Some(ty::AutoPtr(r, _)) |\n-                            Some(ty::AutoBorrowVec(r, _)) |\n-                            Some(ty::AutoBorrowVecRef(r, _)) |\n-                            Some(ty::AutoBorrowFn(r)) |\n-                            Some(ty::AutoBorrowObj(r, _)) => {\n-                                // If there is an autoref, then the result of\n-                                // this expression will be some sort of\n-                                // reference.\n-                                expr_ct.cat.guarantor = None;\n-                                expr_ct.cat.pointer = BorrowedPointer(r);\n-                                debug!(\"autoref, cat={:?}\", expr_ct.cat);\n-                            }\n-                        }\n-                    }\n-\n-                    _ => fail!(\"invalid or unhandled adjustment\"),\n                 }\n             }\n \n-            None => {}\n-        }\n-\n-        debug!(\"result={:?}\", expr_ct.cat);\n-        return expr_ct.cat;\n-    }\n-\n-    fn categorize_unadjusted(rcx: &mut Rcx,\n-                             expr: &ast::Expr)\n-                          -> ExprCategorizationType {\n-        debug!(\"categorize_unadjusted()\");\n-\n-        let guarantor = {\n-            let method_map = rcx.fcx.inh.method_map.borrow();\n-            if method_map.get().contains_key(&expr.id) {\n-                None\n-            } else {\n-                guarantor(rcx, expr)\n+            mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n+            mc::cat_deref(_, _, mc::GcPtr) |\n+            mc::cat_static_item |\n+            mc::cat_rvalue(_) |\n+            mc::cat_copied_upvar(_) |\n+            mc::cat_local(_) |\n+            mc::cat_arg(_) |\n+            mc::cat_upvar(..) => {\n+                return;\n             }\n-        };\n-\n-        let expr_ty = rcx.resolve_node_type(expr.id);\n-        ExprCategorizationType {\n-            cat: ExprCategorization {\n-                guarantor: guarantor,\n-                pointer: pointer_categorize(expr_ty)\n-            },\n-            ty: expr_ty\n         }\n     }\n+}\n \n-    fn apply_autoderefs(\n-        rcx: &mut Rcx,\n-        expr: &ast::Expr,\n-        autoderefs: uint,\n-        ct: ExprCategorizationType)\n-     -> ExprCategorizationType {\n-        let mut ct = ct;\n-        let tcx = rcx.fcx.ccx.tcx;\n-\n-        if ty::type_is_error(ct.ty) {\n-            ct.cat.pointer = NotPointer;\n-            return ct;\n-        }\n-\n-        for _ in range(0u, autoderefs) {\n-            ct.cat.guarantor = guarantor_of_deref(&ct.cat);\n-\n-            match ty::deref(ct.ty, true) {\n-                Some(mt) => {\n-                    ct.ty = mt.ty;\n-                    ct.cat.pointer = pointer_categorize(ct.ty);\n-                }\n-                None => {\n-                    tcx.sess.span_bug(\n-                        expr.span,\n-                        format!(\"autoderef but type not derefable: {}\",\n-                             ty_to_str(tcx, ct.ty)));\n-                }\n+fn adjust_upvar_borrow_kind_for_unique(rcx: &mut Rcx,\n+                                       cmt: mc::cmt) {\n+    let mut cmt = cmt;\n+    loop {\n+        debug!(\"adjust_upvar_borrow_kind_for_unique(cmt={})\",\n+               cmt.repr(rcx.tcx()));\n+\n+        match cmt.cat {\n+            mc::cat_deref(base, _, mc::OwnedPtr) |\n+            mc::cat_interior(base, _) |\n+            mc::cat_downcast(base) |\n+            mc::cat_discr(base, _) => {\n+                // Interior or owned data is unique if base is\n+                // unique.\n+                cmt = base;\n+                continue;\n             }\n \n-            debug!(\"autoderef, cat={:?}\", ct.cat);\n-        }\n-        return ct;\n-    }\n+            mc::cat_deref(base, _, mc::BorrowedPtr(..)) => {\n+                match base.cat {\n+                    mc::cat_upvar(ref upvar_id, _) => {\n+                        // if this is an implicit deref of an\n+                        // upvar, then we need to modify the\n+                        // borrow_kind of the upvar to make sure it\n+                        // is inferred to unique if necessary\n+                        let mut upvar_borrow_map =\n+                            rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n+                        let ub = upvar_borrow_map.get().get_mut(upvar_id);\n+                        return adjust_upvar_borrow_kind(*upvar_id, ub, ty::UniqueImmBorrow);\n+                    }\n \n-    fn pointer_categorize(ty: ty::t) -> PointerCategorization {\n-        match ty::get(ty).sty {\n-            ty::ty_rptr(r, _) |\n-            ty::ty_vec(_, ty::vstore_slice(r)) |\n-            ty::ty_trait(_, _, ty::RegionTraitStore(r), _, _) |\n-            ty::ty_str(ty::vstore_slice(r)) => {\n-                BorrowedPointer(r)\n-            }\n-            ty::ty_uniq(..) |\n-            ty::ty_str(ty::vstore_uniq) |\n-            ty::ty_trait(_, _, ty::UniqTraitStore, _, _) |\n-            ty::ty_vec(_, ty::vstore_uniq) => {\n-                OwnedPointer\n-            }\n-            ty::ty_box(..) | ty::ty_ptr(..) => {\n-                OtherPointer\n-            }\n-            ty::ty_closure(ref closure_ty) => {\n-                match closure_ty.sigil {\n-                    ast::BorrowedSigil => BorrowedPointer(closure_ty.region),\n-                    ast::OwnedSigil => OwnedPointer,\n-                    ast::ManagedSigil => OtherPointer,\n+                    _ => {\n+                        // for a borrowed pointer to be unique, its\n+                        // base must be unique\n+                        return adjust_upvar_borrow_kind_for_unique(rcx, base);\n+                    }\n                 }\n             }\n-            _ => {\n-                NotPointer\n+\n+            mc::cat_deref(_, _, mc::UnsafePtr(..)) |\n+            mc::cat_deref(_, _, mc::GcPtr) |\n+            mc::cat_static_item |\n+            mc::cat_rvalue(_) |\n+            mc::cat_copied_upvar(_) |\n+            mc::cat_local(_) |\n+            mc::cat_arg(_) |\n+            mc::cat_upvar(..) => {\n+                return;\n             }\n         }\n     }\n+}\n \n-    fn guarantor_of_deref(cat: &ExprCategorization) -> Option<ty::Region> {\n-        match cat.pointer {\n-            NotPointer => cat.guarantor,\n-            BorrowedPointer(r) => Some(r),\n-            OwnedPointer => cat.guarantor,\n-            OtherPointer => None\n+fn link_upvar_borrow_kind(rcx: &mut Rcx,\n+                          inner_upvar_id: ty::UpvarId,\n+                          outer_upvar_id: ty::UpvarId) {\n+    /*!\n+     * Indicates that the borrow_kind of `outer_upvar_id` must\n+     * permit a reborrowing with the borrow_kind of `inner_upvar_id`\n+     */\n+\n+    debug!(\"link_upvar_borrow_kind: inner_upvar_id={:?} outer_upvar_id={:?}\",\n+           inner_upvar_id, outer_upvar_id);\n+\n+    let mut upvar_borrow_map = rcx.fcx.inh.upvar_borrow_map.borrow_mut();\n+    let inner_borrow = upvar_borrow_map.get().get_copy(&inner_upvar_id);\n+    match upvar_borrow_map.get().find_mut(&outer_upvar_id) {\n+        Some(outer_borrow) => {\n+            adjust_upvar_borrow_kind(outer_upvar_id, outer_borrow, inner_borrow.kind);\n         }\n+        None => { /* outer closure is not a stack closure */ }\n     }\n+}\n \n-    fn link_ref_bindings_in_pat(\n-        rcx: &mut Rcx,\n-        pat: &ast::Pat,\n-        guarantor: Option<ty::Region>) {\n-        /*!\n-         *\n-         * Descends through the pattern, tracking the guarantor\n-         * of the value being matched.  When a ref binding is encountered,\n-         * links the lifetime of that ref binding to the lifetime of\n-         * the guarantor.  We begin with the guarantor of the\n-         * discriminant but of course as we go we may pass through\n-         * other pointers.\n-         */\n+fn adjust_upvar_borrow_kind_for_loan(upvar_id: ty::UpvarId,\n+                                     upvar_borrow: &mut ty::UpvarBorrow,\n+                                     mutbl: ast::Mutability) {\n+    debug!(\"adjust_upvar_borrow_kind_for_loan: upvar_id={:?} kind={:?} -> {:?}\",\n+           upvar_id, upvar_borrow.kind, mutbl);\n \n-        debug!(\"link_ref_bindings_in_pat(pat={}, guarantor={:?})\",\n-               rcx.fcx.pat_to_str(pat), guarantor);\n+    adjust_upvar_borrow_kind(upvar_id, upvar_borrow,\n+                             ty::BorrowKind::from_mutbl(mutbl))\n+}\n \n-        match pat.node {\n-            ast::PatWild | ast::PatWildMulti => {}\n-            ast::PatIdent(ast::BindByRef(_), _, opt_p) => {\n-                link(rcx, pat.span, pat.id, guarantor);\n+fn adjust_upvar_borrow_kind(upvar_id: ty::UpvarId,\n+                            upvar_borrow: &mut ty::UpvarBorrow,\n+                            kind: ty::BorrowKind) {\n+    /*!\n+     * We infer the borrow_kind with which to borrow upvars in a stack\n+     * closure. The borrow_kind basically follows a lattice of\n+     * `imm < unique-imm < mut`, moving from left to right as needed (but never\n+     * right to left). Here the argument `mutbl` is the borrow_kind that\n+     * is required by some particular use.\n+     */\n \n-                for p in opt_p.iter() {\n-                    link_ref_bindings_in_pat(rcx, *p, guarantor);\n-                }\n-            }\n-            ast::PatIdent(_, _, opt_p) => {\n-                for p in opt_p.iter() {\n-                    link_ref_bindings_in_pat(rcx, *p, guarantor);\n-                }\n-            }\n-            ast::PatEnum(_, None) => {}\n-            ast::PatEnum(_, Some(ref pats)) => {\n-                link_ref_bindings_in_pats(rcx, pats, guarantor);\n-            }\n-            ast::PatStruct(_, ref fpats, _) => {\n-                for fpat in fpats.iter() {\n-                    link_ref_bindings_in_pat(rcx, fpat.pat, guarantor);\n-                }\n-            }\n-            ast::PatTup(ref ps) => {\n-                link_ref_bindings_in_pats(rcx, ps, guarantor)\n-            }\n-            ast::PatUniq(p) => {\n-                link_ref_bindings_in_pat(rcx, p, guarantor)\n-            }\n-            ast::PatRegion(p) => {\n-                let rptr_ty = rcx.resolve_node_type(pat.id);\n-                let r = ty::ty_region(rcx.fcx.tcx(), pat.span, rptr_ty);\n-                link_ref_bindings_in_pat(rcx, p, Some(r));\n-            }\n-            ast::PatLit(..) => {}\n-            ast::PatRange(..) => {}\n-            ast::PatVec(ref before, ref slice, ref after) => {\n-                let vec_ty = rcx.resolve_node_type(pat.id);\n-                let vstore = ty::ty_vstore(vec_ty);\n-                let guarantor1 = match vstore {\n-                    ty::vstore_fixed(_) | ty::vstore_uniq => guarantor,\n-                    ty::vstore_slice(r) => Some(r),\n-                };\n+    debug!(\"adjust_upvar_borrow_kind: id={:?} kind=({:?} -> {:?})\",\n+           upvar_id, upvar_borrow.kind, kind);\n \n-                link_ref_bindings_in_pats(rcx, before, guarantor1);\n-                for &p in slice.iter() {\n-                    link_ref_bindings_in_pat(rcx, p, guarantor);\n-                }\n-                link_ref_bindings_in_pats(rcx, after, guarantor1);\n-            }\n+    match (upvar_borrow.kind, kind) {\n+        // Take RHS:\n+        (ty::ImmBorrow, ty::UniqueImmBorrow) |\n+        (ty::ImmBorrow, ty::MutBorrow) |\n+        (ty::UniqueImmBorrow, ty::MutBorrow) => {\n+            upvar_borrow.kind = kind;\n         }\n-    }\n-\n-    fn link_ref_bindings_in_pats(rcx: &mut Rcx,\n-                                 pats: &~[@ast::Pat],\n-                                 guarantor: Option<ty::Region>) {\n-        for pat in pats.iter() {\n-            link_ref_bindings_in_pat(rcx, *pat, guarantor);\n+        // Take LHS:\n+        (ty::ImmBorrow, ty::ImmBorrow) |\n+        (ty::UniqueImmBorrow, ty::ImmBorrow) |\n+        (ty::UniqueImmBorrow, ty::UniqueImmBorrow) |\n+        (ty::MutBorrow, _) => {\n         }\n     }\n-\n }"}]}