{"sha": "d902e7148bbc2559453d22e7d00f05cee9a3df95", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5MDJlNzE0OGJiYzI1NTk0NTNkMjJlN2QwMGYwNWNlZTlhM2RmOTU=", "commit": {"author": {"name": "Kiet Tran", "email": "ktt3ja@gmail.com", "date": "2013-11-01T00:58:15Z"}, "committer": {"name": "Kiet Tran", "email": "ktt3ja@gmail.com", "date": "2013-11-14T02:06:18Z"}, "message": "Add lru_cache to libextra", "tree": {"sha": "a1f7b3a9a19d612c547d8f961c5501a1c9a543b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1f7b3a9a19d612c547d8f961c5501a1c9a543b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d902e7148bbc2559453d22e7d00f05cee9a3df95", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d902e7148bbc2559453d22e7d00f05cee9a3df95", "html_url": "https://github.com/rust-lang/rust/commit/d902e7148bbc2559453d22e7d00f05cee9a3df95", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d902e7148bbc2559453d22e7d00f05cee9a3df95/comments", "author": {"login": "ktt3ja", "id": 1735399, "node_id": "MDQ6VXNlcjE3MzUzOTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1735399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktt3ja", "html_url": "https://github.com/ktt3ja", "followers_url": "https://api.github.com/users/ktt3ja/followers", "following_url": "https://api.github.com/users/ktt3ja/following{/other_user}", "gists_url": "https://api.github.com/users/ktt3ja/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktt3ja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktt3ja/subscriptions", "organizations_url": "https://api.github.com/users/ktt3ja/orgs", "repos_url": "https://api.github.com/users/ktt3ja/repos", "events_url": "https://api.github.com/users/ktt3ja/events{/privacy}", "received_events_url": "https://api.github.com/users/ktt3ja/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ktt3ja", "id": 1735399, "node_id": "MDQ6VXNlcjE3MzUzOTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1735399?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktt3ja", "html_url": "https://github.com/ktt3ja", "followers_url": "https://api.github.com/users/ktt3ja/followers", "following_url": "https://api.github.com/users/ktt3ja/following{/other_user}", "gists_url": "https://api.github.com/users/ktt3ja/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktt3ja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktt3ja/subscriptions", "organizations_url": "https://api.github.com/users/ktt3ja/orgs", "repos_url": "https://api.github.com/users/ktt3ja/repos", "events_url": "https://api.github.com/users/ktt3ja/events{/privacy}", "received_events_url": "https://api.github.com/users/ktt3ja/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a3b35f68a32c3d0111d12b058d24852b024f1b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a3b35f68a32c3d0111d12b058d24852b024f1b3", "html_url": "https://github.com/rust-lang/rust/commit/8a3b35f68a32c3d0111d12b058d24852b024f1b3"}], "stats": {"total": 366, "additions": 366, "deletions": 0}, "files": [{"sha": "733795fc1f7968598b901fb86695c4da083f1471", "filename": "src/libextra/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d902e7148bbc2559453d22e7d00f05cee9a3df95/src%2Flibextra%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d902e7148bbc2559453d22e7d00f05cee9a3df95/src%2Flibextra%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flib.rs?ref=d902e7148bbc2559453d22e7d00f05cee9a3df95", "patch": "@@ -71,6 +71,7 @@ pub mod sort;\n pub mod dlist;\n pub mod treemap;\n pub mod btree;\n+pub mod lru_cache;\n \n // And ... other stuff\n "}, {"sha": "ff8748e1946c1f118baa5bf85557a9eb49d17e71", "filename": "src/libextra/lru_cache.rs", "status": "added", "additions": 365, "deletions": 0, "changes": 365, "blob_url": "https://github.com/rust-lang/rust/blob/d902e7148bbc2559453d22e7d00f05cee9a3df95/src%2Flibextra%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d902e7148bbc2559453d22e7d00f05cee9a3df95/src%2Flibextra%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flru_cache.rs?ref=d902e7148bbc2559453d22e7d00f05cee9a3df95", "patch": "@@ -0,0 +1,365 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+//! A cache that holds a limited number of key-value pairs. When the\n+//! capacity of the cache is exceeded, the least-recently-used\n+//! (where \"used\" means a look-up or putting the pair into the cache)\n+//! pair is automatically removed.\n+//!\n+//! # Example\n+//!\n+//! ```rust\n+//! let mut cache: LruCache<int, int> = LruCache::new(2);\n+//! cache.put(1, 10);\n+//! cache.put(2, 20);\n+//! cache.put(3, 30);\n+//! assert!(cache.get(&1).is_none());\n+//! assert_eq!(*cache.get(&2).unwrap(), 20);\n+//! assert_eq!(*cache.get(&3).unwrap(), 30);\n+//!\n+//! cache.put(2, 22);\n+//! assert_eq!(*cache.get(&2).unwrap(), 22);\n+//!\n+//! cache.put(6, 60);\n+//! assert!(cache.get(&3).is_none());\n+//!\n+//! cache.change_capacity(1);\n+//! assert!(cache.get(&2).is_none());\n+//! ```\n+\n+use std::container::Container;\n+use std::hashmap::HashMap;\n+use std::to_bytes::Cb;\n+use std::ptr;\n+use std::cast;\n+\n+struct KeyRef<K> { priv k: *K }\n+\n+struct LruEntry<K, V> {\n+    priv key: Option<K>,\n+    priv value: Option<V>,\n+    priv next: *mut LruEntry<K, V>,\n+    priv prev: *mut LruEntry<K, V>,\n+}\n+\n+/// An LRU Cache.\n+pub struct LruCache<K, V> {\n+    priv map: HashMap<KeyRef<K>, ~LruEntry<K, V>>,\n+    priv max_size: uint,\n+    priv head: *mut LruEntry<K, V>,\n+    priv tail: *mut LruEntry<K, V>,\n+}\n+\n+impl<K: IterBytes> IterBytes for KeyRef<K> {\n+    fn iter_bytes(&self, lsb0: bool, f: Cb) -> bool {\n+        unsafe{ (*self.k).iter_bytes(lsb0, f) }\n+    }\n+}\n+\n+impl<K: Eq> Eq for KeyRef<K> {\n+    fn eq(&self, other: &KeyRef<K>) -> bool {\n+        unsafe{ (*self.k).eq(&*other.k) }\n+    }\n+}\n+\n+impl<K, V> LruEntry<K, V> {\n+    fn new() -> LruEntry<K, V> {\n+        LruEntry {\n+            key: None,\n+            value: None,\n+            next: ptr::mut_null(),\n+            prev: ptr::mut_null(),\n+        }\n+    }\n+\n+    fn with_key_value(k: K, v: V) -> LruEntry<K, V> {\n+        LruEntry {\n+            key: Some(k),\n+            value: Some(v),\n+            next: ptr::mut_null(),\n+            prev: ptr::mut_null(),\n+        }\n+    }\n+}\n+\n+impl<K: IterBytes + Eq, V> LruCache<K, V> {\n+    /// Create an LRU Cache that holds at most `capacity` items.\n+    pub fn new(capacity: uint) -> LruCache<K, V> {\n+        let cache = LruCache {\n+            map: HashMap::new(),\n+            max_size: capacity,\n+            head: unsafe{ cast::transmute(~LruEntry::<K, V>::new()) },\n+            tail: unsafe{ cast::transmute(~LruEntry::<K, V>::new()) },\n+        };\n+        unsafe {\n+            (*cache.head).next = cache.tail;\n+            (*cache.tail).prev = cache.head;\n+        }\n+        return cache;\n+    }\n+\n+    /// Put a key-value pair into cache.\n+    pub fn put(&mut self, k: K, v: V) {\n+        let mut key_existed = false;\n+        let (node_ptr, node_opt) = match self.map.find_mut(&KeyRef{k: &k}) {\n+            Some(node) => {\n+                key_existed = true;\n+                node.value = Some(v);\n+                let node_ptr: *mut LruEntry<K, V> = &mut **node;\n+                (node_ptr, None)\n+            }\n+            None => {\n+                let mut node = ~LruEntry::with_key_value(k, v);\n+                let node_ptr: *mut LruEntry<K, V> = &mut *node;\n+                (node_ptr, Some(node))\n+            }\n+        };\n+        if key_existed {\n+            self.detach(node_ptr);\n+            self.attach(node_ptr);\n+        } else {\n+            let keyref = unsafe { (*node_ptr).key.as_ref().unwrap() };\n+            self.map.swap(KeyRef{k: keyref}, node_opt.unwrap());\n+            self.attach(node_ptr);\n+            if self.len() > self.capacity() {\n+                self.remove_lru();\n+            }\n+        }\n+    }\n+\n+    /// Return a value corresponding to the key in the cache.\n+    pub fn get<'a>(&'a mut self, k: &K) -> Option<&'a V> {\n+        let (value, node_ptr_opt) = match self.map.find_mut(&KeyRef{k: k}) {\n+            None => (None, None),\n+            Some(node) => {\n+                let node_ptr: *mut LruEntry<K, V> = &mut **node;\n+                unsafe {\n+                    match (*node_ptr).value {\n+                        None => (None, None),\n+                        Some(ref value) => (Some(value), Some(node_ptr))\n+                    }\n+                }\n+            }\n+        };\n+        match node_ptr_opt {\n+            None => (),\n+            Some(node_ptr) => {\n+                self.detach(node_ptr);\n+                self.attach(node_ptr);\n+            }\n+        }\n+        return value;\n+    }\n+\n+    /// Remove and return a value corresponding to the key from the cache.\n+    pub fn pop(&mut self, k: &K) -> Option<V> {\n+        match self.map.pop(&KeyRef{k: k}) {\n+            None => None,\n+            Some(lru_entry) => lru_entry.value\n+        }\n+    }\n+\n+    /// Return the maximum number of key-value pairs the cache can hold.\n+    pub fn capacity(&self) -> uint {\n+        self.max_size\n+    }\n+\n+    /// Change the number of key-value pairs the cache can hold. Remove\n+    /// least-recently-used key-value pairs if necessary.\n+    pub fn change_capacity(&mut self, capacity: uint) {\n+        for _ in range(capacity, self.len()) {\n+            self.remove_lru();\n+        }\n+        self.max_size = capacity;\n+    }\n+\n+    #[inline]\n+    fn remove_lru(&mut self) {\n+        if self.len() > 0 {\n+            let lru = unsafe { (*self.tail).prev };\n+            self.detach(lru);\n+            unsafe {\n+                match (*lru).key {\n+                    None => (),\n+                    Some(ref k) => { self.map.pop(&KeyRef{k: k}); }\n+                }\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn detach(&mut self, node: *mut LruEntry<K, V>) {\n+        unsafe {\n+            (*(*node).prev).next = (*node).next;\n+            (*(*node).next).prev = (*node).prev;\n+        }\n+    }\n+\n+    #[inline]\n+    fn attach(&mut self, node: *mut LruEntry<K, V>) {\n+        unsafe {\n+            (*node).next = (*self.head).next;\n+            (*node).prev = self.head;\n+            (*self.head).next = node;\n+            (*(*node).next).prev = node;\n+        }\n+    }\n+}\n+\n+impl<A: ToStr + IterBytes + Eq, B: ToStr> ToStr for LruCache<A, B> {\n+    /// Return a string that lists the key-value pairs from most-recently\n+    /// used to least-recently used.\n+    #[inline]\n+    fn to_str(&self) -> ~str {\n+        let mut acc = ~\"{\";\n+        let mut cur = self.head;\n+        for i in range(0, self.len()) {\n+            if i > 0 {\n+                acc.push_str(\", \");\n+            }\n+            unsafe {\n+                cur = (*cur).next;\n+                match (*cur).key {\n+                    // should never print nil\n+                    None => acc.push_str(\"nil\"),\n+                    Some(ref k) => acc.push_str(k.to_str())\n+                }\n+            }\n+            acc.push_str(\": \");\n+            unsafe {\n+                match (*cur).value {\n+                    // should never print nil\n+                    None => acc.push_str(\"nil\"),\n+                    Some(ref value) => acc.push_str(value.to_str())\n+                }\n+            }\n+        }\n+        acc.push_char('}');\n+        acc\n+    }\n+}\n+\n+impl<K: IterBytes + Eq, V> Container for LruCache<K, V> {\n+    /// Return the number of key-value pairs in the cache.\n+    fn len(&self) -> uint {\n+        self.map.len()\n+    }\n+}\n+\n+impl<K: IterBytes + Eq, V> Mutable for LruCache<K, V> {\n+    /// Clear the cache of all key-value pairs.\n+    fn clear(&mut self) {\n+        self.map.clear();\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<K, V> Drop for LruCache<K, V> {\n+    fn drop(&mut self) {\n+        unsafe {\n+            let _: ~LruEntry<K, V> = cast::transmute(self.head);\n+            let _: ~LruEntry<K, V> = cast::transmute(self.tail);\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::LruCache;\n+\n+    fn assert_opt_eq<V: Eq>(opt: Option<&V>, v: V) {\n+        assert!(opt.is_some());\n+        assert_eq!(opt.unwrap(), &v);\n+    }\n+\n+    #[test]\n+    fn test_put_and_get() {\n+        let mut cache: LruCache<int, int> = LruCache::new(2);\n+        cache.put(1, 10);\n+        cache.put(2, 20);\n+        assert_opt_eq(cache.get(&1), 10);\n+        assert_opt_eq(cache.get(&2), 20);\n+        assert_eq!(cache.len(), 2);\n+    }\n+\n+    #[test]\n+    fn test_put_update() {\n+        let mut cache: LruCache<~str, ~[u8]> = LruCache::new(1);\n+        cache.put(~\"1\", ~[10, 10]);\n+        cache.put(~\"1\", ~[10, 19]);\n+        assert_opt_eq(cache.get(&~\"1\"), ~[10, 19]);\n+        assert_eq!(cache.len(), 1);\n+    }\n+\n+    #[test]\n+    fn test_expire_lru() {\n+        let mut cache: LruCache<~str, ~str> = LruCache::new(2);\n+        cache.put(~\"foo1\", ~\"bar1\");\n+        cache.put(~\"foo2\", ~\"bar2\");\n+        cache.put(~\"foo3\", ~\"bar3\");\n+        assert!(cache.get(&~\"foo1\").is_none());\n+        cache.put(~\"foo2\", ~\"bar2update\");\n+        cache.put(~\"foo4\", ~\"bar4\");\n+        assert!(cache.get(&~\"foo3\").is_none());\n+    }\n+\n+    #[test]\n+    fn test_pop() {\n+        let mut cache: LruCache<int, int> = LruCache::new(2);\n+        cache.put(1, 10);\n+        cache.put(2, 20);\n+        assert_eq!(cache.len(), 2);\n+        let opt1 = cache.pop(&1);\n+        assert!(opt1.is_some());\n+        assert_eq!(opt1.unwrap(), 10);\n+        assert!(cache.get(&1).is_none());\n+        assert_eq!(cache.len(), 1);\n+    }\n+\n+    #[test]\n+    fn test_change_capacity() {\n+        let mut cache: LruCache<int, int> = LruCache::new(2);\n+        assert_eq!(cache.capacity(), 2);\n+        cache.put(1, 10);\n+        cache.put(2, 20);\n+        cache.change_capacity(1);\n+        assert!(cache.get(&1).is_none());\n+        assert_eq!(cache.capacity(), 1);\n+    }\n+\n+    #[test]\n+    fn test_to_str() {\n+        let mut cache: LruCache<int, int> = LruCache::new(3);\n+        cache.put(1, 10);\n+        cache.put(2, 20);\n+        cache.put(3, 30);\n+        assert_eq!(cache.to_str(), ~\"{3: 30, 2: 20, 1: 10}\");\n+        cache.put(2, 22);\n+        assert_eq!(cache.to_str(), ~\"{2: 22, 3: 30, 1: 10}\");\n+        cache.put(6, 60);\n+        assert_eq!(cache.to_str(), ~\"{6: 60, 2: 22, 3: 30}\");\n+        cache.get(&3);\n+        assert_eq!(cache.to_str(), ~\"{3: 30, 6: 60, 2: 22}\");\n+        cache.change_capacity(2);\n+        assert_eq!(cache.to_str(), ~\"{3: 30, 6: 60}\");\n+    }\n+\n+    #[test]\n+    fn test_clear() {\n+        let mut cache: LruCache<int, int> = LruCache::new(2);\n+        cache.put(1, 10);\n+        cache.put(2, 20);\n+        cache.clear();\n+        assert!(cache.get(&1).is_none());\n+        assert!(cache.get(&2).is_none());\n+        assert_eq!(cache.to_str(), ~\"{}\");\n+    }\n+}"}]}