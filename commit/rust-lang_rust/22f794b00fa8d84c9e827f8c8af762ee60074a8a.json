{"sha": "22f794b00fa8d84c9e827f8c8af762ee60074a8a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyZjc5NGIwMGZhOGQ4NGM5ZTgyN2Y4YzhhZjc2MmVlNjAwNzRhOGE=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-01-23T01:35:13Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-01-23T10:25:45Z"}, "message": "Suggest removing leading left angle brackets.\n\nThis commit adds errors and accompanying suggestions as below:\n\n```\nbar::<<<<<T as Foo>::Output>();\n     ^^^ help: remove extra angle brackets\n```", "tree": {"sha": "9bf1bff82f65651fff490f6cbb49c70ace70f7d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9bf1bff82f65651fff490f6cbb49c70ace70f7d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/22f794b00fa8d84c9e827f8c8af762ee60074a8a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAlxIQSkACgkQAXYLT59T\n8VR08hAAqVBVsEDGXhqavmZfl+vVYHyHmEDK2k0zc61FgNSx1eMpsTgqfIcdeVnc\n5R1wIVlg+IYMrkgdV2Uqd+FEpqD5+stC94qDrbTzZZ8snSHVgj59HCT3YGHOwDV9\ntgVpC+qJe4aqw3iCRptnxBaxfSIiiV4+xHqc0kJMCaaIRhGi0yCG7j/UumcsEIxe\nvPEpAB/UuKDZocY50VWdptZ9J6hgW8p7oFnF/TJNntJR7R6iSvGSFQBRsfr8HtSk\nJV4XAY0Nn+LBrQgC/UhK86P64LFjKsmh4kIznqz3Lzak3vJxn/kFXbXG4DLswPXw\nMkycEQjH/CPvYtMO/XqUr98TYiYElsmpyqH8E4nqdLR3dtBIifjrGA/1YqZiJqsz\nNE5dXN/Vqu+orAzYkpvAyoQdAIrXEdrMspu/GkDtK+KsyrIp/KsoL2iyqoVYHzIe\nNIgHy1/X8apfLJd4lnn2D6LY+lsuQ00b3ZyBvlWsAswSQtjJdeSvRLO5ZXNMD5c+\nnJvulbfJfrjpPKoGmjUC3sml5N16J2f5G7s1yuXeHMFLjklNjoVLNIMAAaRRxvfw\nu8T3OF8HJpucqxxW7qNtgPM8/5A69y4cy4XoCRq+dH26Gv/kBtdpuYM33OgvwvMB\nOBkmC4C6QQairihnXea3bMwNJeW66GKNzqx5OJbIU3kM4NNYxyE=\n=gnLw\n-----END PGP SIGNATURE-----", "payload": "tree 9bf1bff82f65651fff490f6cbb49c70ace70f7d6\nparent 70015373b4980fbfa10130de4b0ce041f5b5da8b\nauthor David Wood <david@davidtw.co> 1548207313 +0100\ncommitter David Wood <david@davidtw.co> 1548239145 +0100\n\nSuggest removing leading left angle brackets.\n\nThis commit adds errors and accompanying suggestions as below:\n\n```\nbar::<<<<<T as Foo>::Output>();\n     ^^^ help: remove extra angle brackets\n```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/22f794b00fa8d84c9e827f8c8af762ee60074a8a", "html_url": "https://github.com/rust-lang/rust/commit/22f794b00fa8d84c9e827f8c8af762ee60074a8a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/22f794b00fa8d84c9e827f8c8af762ee60074a8a/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70015373b4980fbfa10130de4b0ce041f5b5da8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/70015373b4980fbfa10130de4b0ce041f5b5da8b", "html_url": "https://github.com/rust-lang/rust/commit/70015373b4980fbfa10130de4b0ce041f5b5da8b"}], "stats": {"total": 347, "additions": 339, "deletions": 8}, "files": [{"sha": "6ad07a8e2f1d2899257f654c988eacc13d57f5f2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 201, "deletions": 8, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/22f794b00fa8d84c9e827f8c8af762ee60074a8a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f794b00fa8d84c9e827f8c8af762ee60074a8a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=22f794b00fa8d84c9e827f8c8af762ee60074a8a", "patch": "@@ -242,6 +242,12 @@ pub struct Parser<'a> {\n     desugar_doc_comments: bool,\n     /// Whether we should configure out of line modules as we parse.\n     pub cfg_mods: bool,\n+    /// This field is used to keep track of how many left angle brackets we have seen. This is\n+    /// required in order to detect extra leading left angle brackets (`<` characters) and error\n+    /// appropriately.\n+    ///\n+    /// See the comments in the `parse_path_segment` function for more details.\n+    crate unmatched_angle_bracket_count: u32,\n }\n \n \n@@ -563,6 +569,7 @@ impl<'a> Parser<'a> {\n             },\n             desugar_doc_comments,\n             cfg_mods: true,\n+            unmatched_angle_bracket_count: 0,\n         };\n \n         let tok = parser.next_tok();\n@@ -1027,7 +1034,7 @@ impl<'a> Parser<'a> {\n     /// starting token.\n     fn eat_lt(&mut self) -> bool {\n         self.expected_tokens.push(TokenType::Token(token::Lt));\n-        match self.token {\n+        let ate = match self.token {\n             token::Lt => {\n                 self.bump();\n                 true\n@@ -1038,7 +1045,15 @@ impl<'a> Parser<'a> {\n                 true\n             }\n             _ => false,\n+        };\n+\n+        if ate {\n+            // See doc comment for `unmatched_angle_bracket_count`.\n+            self.unmatched_angle_bracket_count += 1;\n+            debug!(\"eat_lt: (increment) count={:?}\", self.unmatched_angle_bracket_count);\n         }\n+\n+        ate\n     }\n \n     fn expect_lt(&mut self) -> PResult<'a, ()> {\n@@ -1054,24 +1069,35 @@ impl<'a> Parser<'a> {\n     /// signal an error.\n     fn expect_gt(&mut self) -> PResult<'a, ()> {\n         self.expected_tokens.push(TokenType::Token(token::Gt));\n-        match self.token {\n+        let ate = match self.token {\n             token::Gt => {\n                 self.bump();\n-                Ok(())\n+                Some(())\n             }\n             token::BinOp(token::Shr) => {\n                 let span = self.span.with_lo(self.span.lo() + BytePos(1));\n-                Ok(self.bump_with(token::Gt, span))\n+                Some(self.bump_with(token::Gt, span))\n             }\n             token::BinOpEq(token::Shr) => {\n                 let span = self.span.with_lo(self.span.lo() + BytePos(1));\n-                Ok(self.bump_with(token::Ge, span))\n+                Some(self.bump_with(token::Ge, span))\n             }\n             token::Ge => {\n                 let span = self.span.with_lo(self.span.lo() + BytePos(1));\n-                Ok(self.bump_with(token::Eq, span))\n+                Some(self.bump_with(token::Eq, span))\n             }\n-            _ => self.unexpected()\n+            _ => None,\n+        };\n+\n+        match ate {\n+            Some(x) => {\n+                // See doc comment for `unmatched_angle_bracket_count`.\n+                self.unmatched_angle_bracket_count -= 1;\n+                debug!(\"expect_gt: (decrement) count={:?}\", self.unmatched_angle_bracket_count);\n+\n+                Ok(x)\n+            },\n+            None => self.unexpected(),\n         }\n     }\n \n@@ -2079,7 +2105,11 @@ impl<'a> Parser<'a> {\n             path_span = self.span.to(self.span);\n         }\n \n+        // See doc comment for `unmatched_angle_bracket_count`.\n         self.expect(&token::Gt)?;\n+        self.unmatched_angle_bracket_count -= 1;\n+        debug!(\"parse_qpath: (decrement) count={:?}\", self.unmatched_angle_bracket_count);\n+\n         self.expect(&token::ModSep)?;\n \n         let qself = QSelf { ty, path_span, position: path.segments.len() };\n@@ -2182,9 +2212,15 @@ impl<'a> Parser<'a> {\n             }\n             let lo = self.span;\n \n+            // We use `style == PathStyle::Expr` to check if this is in a recursion or not. If\n+            // it isn't, then we reset the unmatched angle bracket count as we're about to start\n+            // parsing a new path.\n+            if style == PathStyle::Expr { self.unmatched_angle_bracket_count = 0; }\n+\n             let args = if self.eat_lt() {\n                 // `<'a, T, A = U>`\n-                let (args, bindings) = self.parse_generic_args()?;\n+                let (args, bindings) =\n+                    self.parse_generic_args_with_leaning_angle_bracket_recovery(style, lo)?;\n                 self.expect_gt()?;\n                 let span = lo.to(self.prev_span);\n                 AngleBracketedArgs { args, bindings, span }.into()\n@@ -5319,6 +5355,163 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    /// Parse generic args (within a path segment) with recovery for extra leading angle brackets.\n+    /// For the purposes of understanding the parsing logic of generic arguments, this function\n+    /// can be thought of being the same as just calling `self.parse_generic_args()` if the source\n+    /// had the correct amount of leading angle brackets.\n+    ///\n+    /// ```ignore (diagnostics)\n+    /// bar::<<<<T as Foo>::Output>();\n+    ///      ^^ help: remove extra angle brackets\n+    /// ```\n+    fn parse_generic_args_with_leaning_angle_bracket_recovery(\n+        &mut self,\n+        style: PathStyle,\n+        lo: Span,\n+    ) -> PResult<'a, (Vec<GenericArg>, Vec<TypeBinding>)> {\n+        // We need to detect whether there are extra leading left angle brackets and produce an\n+        // appropriate error and suggestion. This cannot be implemented by looking ahead at\n+        // upcoming tokens for a matching `>` character - if there are unmatched `<` tokens\n+        // then there won't be matching `>` tokens to find.\n+        //\n+        // To explain how this detection works, consider the following example:\n+        //\n+        // ```ignore (diagnostics)\n+        // bar::<<<<T as Foo>::Output>();\n+        //      ^^ help: remove extra angle brackets\n+        // ```\n+        //\n+        // Parsing of the left angle brackets starts in this function. We start by parsing the\n+        // `<` token (incrementing the counter of unmatched angle brackets on `Parser` via\n+        // `eat_lt`):\n+        //\n+        // *Upcoming tokens:* `<<<<T as Foo>::Output>;`\n+        // *Unmatched count:* 1\n+        // *`parse_path_segment` calls deep:* 0\n+        //\n+        // This has the effect of recursing as this function is called if a `<` character\n+        // is found within the expected generic arguments:\n+        //\n+        // *Upcoming tokens:* `<<<T as Foo>::Output>;`\n+        // *Unmatched count:* 2\n+        // *`parse_path_segment` calls deep:* 1\n+        //\n+        // Eventually we will have recursed until having consumed all of the `<` tokens and\n+        // this will be reflected in the count:\n+        //\n+        // *Upcoming tokens:* `T as Foo>::Output>;`\n+        // *Unmatched count:* 4\n+        // `parse_path_segment` calls deep:* 3\n+        //\n+        // The parser will continue until reaching the first `>` - this will decrement the\n+        // unmatched angle bracket count and return to the parent invocation of this function\n+        // having succeeded in parsing:\n+        //\n+        // *Upcoming tokens:* `::Output>;`\n+        // *Unmatched count:* 3\n+        // *`parse_path_segment` calls deep:* 2\n+        //\n+        // This will continue until the next `>` character which will also return successfully\n+        // to the parent invocation of this function and decrement the count:\n+        //\n+        // *Upcoming tokens:* `;`\n+        // *Unmatched count:* 2\n+        // *`parse_path_segment` calls deep:* 1\n+        //\n+        // At this point, this function will expect to find another matching `>` character but\n+        // won't be able to and will return an error. This will continue all the way up the\n+        // call stack until the first invocation:\n+        //\n+        // *Upcoming tokens:* `;`\n+        // *Unmatched count:* 2\n+        // *`parse_path_segment` calls deep:* 0\n+        //\n+        // In doing this, we have managed to work out how many unmatched leading left angle\n+        // brackets there are, but we cannot recover as the unmatched angle brackets have\n+        // already been consumed. To remedy this, whenever `parse_generic_args` is invoked, we\n+        // make a snapshot of the current parser state and invoke it on that and inspect\n+        // the result:\n+        //\n+        // - If success (ie. when it found a matching `>` character) then the snapshot state\n+        //   is kept (this is required to propagate the count upwards).\n+        //\n+        // - If error and in was in a recursive call, then the snapshot state is kept (this is\n+        //   required to propagate the count upwards).\n+        //\n+        // - If error and this was the first invocation (before any recursion had taken place)\n+        //   then we choose not to keep the snapshot state - that way we haven't actually\n+        //   consumed any of the `<` characters, but can still inspect the count from the\n+        //   snapshot to know how many `<` characters to remove. Using this information, we can\n+        //   emit an error and consume the extra `<` characters before attempting to parse\n+        //   the generic arguments again (this time hopefullt successfully as the unmatched `<`\n+        //   characters are gone).\n+        //\n+        // In practice, the recursion of this function is indirect and there will be other\n+        // locations that consume some `<` characters - as long as we update the count when\n+        // this happens, it isn't an issue.\n+        let mut snapshot = self.clone();\n+        debug!(\"parse_generic_args_with_leading_angle_bracket_recovery: (snapshotting)\");\n+        match snapshot.parse_generic_args() {\n+            Ok(value) => {\n+                debug!(\n+                    \"parse_generic_args_with_leading_angle_bracket_recovery: (snapshot success) \\\n+                     snapshot.count={:?}\",\n+                    snapshot.unmatched_angle_bracket_count,\n+                );\n+                mem::replace(self, snapshot);\n+                Ok(value)\n+            },\n+            Err(mut e) => {\n+                debug!(\n+                    \"parse_generic_args_with_leading_angle_bracket_recovery: (snapshot failure) \\\n+                     snapshot.count={:?}\",\n+                    snapshot.unmatched_angle_bracket_count,\n+                );\n+                if style == PathStyle::Expr && snapshot.unmatched_angle_bracket_count > 0 {\n+                    // Cancel error from being unable to find `>`. We know the error\n+                    // must have been this due to a non-zero unmatched angle bracket\n+                    // count.\n+                    e.cancel();\n+\n+                    // Eat the unmatched angle brackets.\n+                    for _ in 0..snapshot.unmatched_angle_bracket_count {\n+                        self.eat_lt();\n+                    }\n+\n+                    // Make a span over ${unmatched angle bracket count} characters.\n+                    let span = lo.with_hi(\n+                        lo.lo() + BytePos(snapshot.unmatched_angle_bracket_count)\n+                    );\n+                    let plural = snapshot.unmatched_angle_bracket_count > 1;\n+                    self.diagnostic()\n+                        .struct_span_err(\n+                            span,\n+                            &format!(\n+                                \"unmatched angle bracket{}\",\n+                                if plural { \"s\" } else { \"\" }\n+                            ),\n+                        )\n+                        .span_suggestion_with_applicability(\n+                            span,\n+                            &format!(\n+                                \"remove extra angle bracket{}\",\n+                                if plural { \"s\" } else { \"\" }\n+                            ),\n+                            String::new(),\n+                            Applicability::MachineApplicable,\n+                        )\n+                        .emit();\n+\n+                    // Try again without unmatched angle bracket characters.\n+                    self.parse_generic_args()\n+                } else {\n+                    mem::replace(self, snapshot);\n+                    Err(e)\n+                }\n+            },\n+        }\n+    }\n+\n     /// Parses (possibly empty) list of lifetime and type arguments and associated type bindings,\n     /// possibly including trailing comma.\n     fn parse_generic_args(&mut self) -> PResult<'a, (Vec<GenericArg>, Vec<TypeBinding>)> {"}, {"sha": "3fab21db2d06e42035df10025f16c6902264bf50", "filename": "src/test/ui/issues/issue-57819.fixed", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/22f794b00fa8d84c9e827f8c8af762ee60074a8a/src%2Ftest%2Fui%2Fissues%2Fissue-57819.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/22f794b00fa8d84c9e827f8c8af762ee60074a8a/src%2Ftest%2Fui%2Fissues%2Fissue-57819.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57819.fixed?ref=22f794b00fa8d84c9e827f8c8af762ee60074a8a", "patch": "@@ -0,0 +1,47 @@\n+// run-rustfix\n+\n+#![allow(warnings)]\n+\n+// This test checks that the following error is emitted and the suggestion works:\n+//\n+// ```\n+// let _ = vec![1, 2, 3].into_iter().collect::<<<Vec<usize>>();\n+//                                            ^^ help: remove extra angle brackets\n+// ```\n+\n+trait Foo {\n+    type Output;\n+}\n+\n+fn foo<T: Foo>() {\n+    // More complex cases with more than one correct leading `<` character:\n+\n+    bar::<<T as Foo>::Output>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    bar::<<T as Foo>::Output>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    bar::<<T as Foo>::Output>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    bar::<<T as Foo>::Output>();\n+}\n+\n+fn bar<T>() {}\n+\n+fn main() {\n+    let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>();\n+}"}, {"sha": "5cafbf439be2dba4ee1bc4a5a72e6d9ac4b27376", "filename": "src/test/ui/issues/issue-57819.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/22f794b00fa8d84c9e827f8c8af762ee60074a8a/src%2Ftest%2Fui%2Fissues%2Fissue-57819.rs", "raw_url": "https://github.com/rust-lang/rust/raw/22f794b00fa8d84c9e827f8c8af762ee60074a8a/src%2Ftest%2Fui%2Fissues%2Fissue-57819.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57819.rs?ref=22f794b00fa8d84c9e827f8c8af762ee60074a8a", "patch": "@@ -0,0 +1,47 @@\n+// run-rustfix\n+\n+#![allow(warnings)]\n+\n+// This test checks that the following error is emitted and the suggestion works:\n+//\n+// ```\n+// let _ = vec![1, 2, 3].into_iter().collect::<<<Vec<usize>>();\n+//                                            ^^ help: remove extra angle brackets\n+// ```\n+\n+trait Foo {\n+    type Output;\n+}\n+\n+fn foo<T: Foo>() {\n+    // More complex cases with more than one correct leading `<` character:\n+\n+    bar::<<<<<T as Foo>::Output>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    bar::<<<<T as Foo>::Output>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    bar::<<<T as Foo>::Output>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    bar::<<T as Foo>::Output>();\n+}\n+\n+fn bar<T>() {}\n+\n+fn main() {\n+    let _ = vec![1, 2, 3].into_iter().collect::<<<<<Vec<usize>>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = vec![1, 2, 3].into_iter().collect::<<<<Vec<usize>>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = vec![1, 2, 3].into_iter().collect::<<<Vec<usize>>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = vec![1, 2, 3].into_iter().collect::<<Vec<usize>>();\n+    //~^ ERROR unmatched angle bracket\n+\n+    let _ = vec![1, 2, 3].into_iter().collect::<Vec<usize>>();\n+}"}, {"sha": "493e9835b1ca9d6b6c22b3b4394d0126e8f96512", "filename": "src/test/ui/issues/issue-57819.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/22f794b00fa8d84c9e827f8c8af762ee60074a8a/src%2Ftest%2Fui%2Fissues%2Fissue-57819.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/22f794b00fa8d84c9e827f8c8af762ee60074a8a/src%2Ftest%2Fui%2Fissues%2Fissue-57819.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57819.stderr?ref=22f794b00fa8d84c9e827f8c8af762ee60074a8a", "patch": "@@ -0,0 +1,44 @@\n+error: unmatched angle brackets\n+  --> $DIR/issue-57819.rs:19:10\n+   |\n+LL |     bar::<<<<<T as Foo>::Output>();\n+   |          ^^^ help: remove extra angle brackets\n+\n+error: unmatched angle brackets\n+  --> $DIR/issue-57819.rs:22:10\n+   |\n+LL |     bar::<<<<T as Foo>::Output>();\n+   |          ^^ help: remove extra angle brackets\n+\n+error: unmatched angle bracket\n+  --> $DIR/issue-57819.rs:25:10\n+   |\n+LL |     bar::<<<T as Foo>::Output>();\n+   |          ^ help: remove extra angle bracket\n+\n+error: unmatched angle brackets\n+  --> $DIR/issue-57819.rs:34:48\n+   |\n+LL |     let _ = vec![1, 2, 3].into_iter().collect::<<<<<Vec<usize>>();\n+   |                                                ^^^^ help: remove extra angle brackets\n+\n+error: unmatched angle brackets\n+  --> $DIR/issue-57819.rs:37:48\n+   |\n+LL |     let _ = vec![1, 2, 3].into_iter().collect::<<<<Vec<usize>>();\n+   |                                                ^^^ help: remove extra angle brackets\n+\n+error: unmatched angle brackets\n+  --> $DIR/issue-57819.rs:40:48\n+   |\n+LL |     let _ = vec![1, 2, 3].into_iter().collect::<<<Vec<usize>>();\n+   |                                                ^^ help: remove extra angle brackets\n+\n+error: unmatched angle bracket\n+  --> $DIR/issue-57819.rs:43:48\n+   |\n+LL |     let _ = vec![1, 2, 3].into_iter().collect::<<Vec<usize>>();\n+   |                                                ^ help: remove extra angle bracket\n+\n+error: aborting due to 7 previous errors\n+"}]}