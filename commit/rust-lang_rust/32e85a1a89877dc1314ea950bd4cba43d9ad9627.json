{"sha": "32e85a1a89877dc1314ea950bd4cba43d9ad9627", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyZTg1YTFhODk4NzdkYzEzMTRlYTk1MGJkNGNiYTQzZDlhZDk2Mjc=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-28T21:01:28Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-06-28T21:01:28Z"}, "message": "More standard pattern for Cargo", "tree": {"sha": "d089beafa470039653804669bfd498b615910718", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d089beafa470039653804669bfd498b615910718"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32e85a1a89877dc1314ea950bd4cba43d9ad9627", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32e85a1a89877dc1314ea950bd4cba43d9ad9627", "html_url": "https://github.com/rust-lang/rust/commit/32e85a1a89877dc1314ea950bd4cba43d9ad9627", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32e85a1a89877dc1314ea950bd4cba43d9ad9627/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eddb744d9038306d020ac46d12a373508e9d3268", "url": "https://api.github.com/repos/rust-lang/rust/commits/eddb744d9038306d020ac46d12a373508e9d3268", "html_url": "https://github.com/rust-lang/rust/commit/eddb744d9038306d020ac46d12a373508e9d3268"}], "stats": {"total": 159, "additions": 83, "deletions": 76}, "files": [{"sha": "ab1d71b981e8f25af90ae67e9d627fc35a179dad", "filename": "crates/flycheck/src/lib.rs", "status": "modified", "additions": 83, "deletions": 76, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/32e85a1a89877dc1314ea950bd4cba43d9ad9627/crates%2Fflycheck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32e85a1a89877dc1314ea950bd4cba43d9ad9627/crates%2Fflycheck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fflycheck%2Fsrc%2Flib.rs?ref=32e85a1a89877dc1314ea950bd4cba43d9ad9627", "patch": "@@ -100,8 +100,7 @@ struct FlycheckActor {\n     /// doesn't provide a way to read sub-process output without blocking, so we\n     /// have to wrap sub-processes output handling in a thread and pass messages\n     /// back over a channel.\n-    // XXX: drop order is significant\n-    check_process: Option<(Receiver<cargo_metadata::Message>, jod_thread::JoinHandle)>,\n+    check_process: Option<CargoHandle>,\n }\n \n enum Event {\n@@ -118,7 +117,7 @@ impl FlycheckActor {\n         FlycheckActor { sender, config, workspace_root, check_process: None }\n     }\n     fn next_event(&self, inbox: &Receiver<Restart>) -> Option<Event> {\n-        let check_chan = self.check_process.as_ref().map(|(chan, _thread)| chan);\n+        let check_chan = self.check_process.as_ref().map(|cargo| &cargo.receiver);\n         select! {\n             recv(inbox) -> msg => msg.ok().map(Event::Restart),\n             recv(check_chan.unwrap_or(&never())) -> msg => Some(Event::CheckEvent(msg.ok())),\n@@ -166,7 +165,7 @@ impl FlycheckActor {\n             self.send(Message::Progress(Progress::DidCancel));\n         }\n     }\n-    fn start_check_process(&self) -> (Receiver<cargo_metadata::Message>, jod_thread::JoinHandle) {\n+    fn start_check_process(&self) -> CargoHandle {\n         let mut cmd = match &self.config {\n             FlycheckConfig::CargoCommand {\n                 command,\n@@ -199,90 +198,98 @@ impl FlycheckActor {\n         };\n         cmd.current_dir(&self.workspace_root);\n \n-        let (message_send, message_recv) = unbounded();\n-        let thread = jod_thread::spawn(move || {\n-            // If we trigger an error here, we will do so in the loop instead,\n-            // which will break out of the loop, and continue the shutdown\n-            let res = run_cargo(cmd, &mut |message| {\n-                // Skip certain kinds of messages to only spend time on what's useful\n-                match &message {\n-                    cargo_metadata::Message::CompilerArtifact(artifact) if artifact.fresh => {\n-                        return true\n-                    }\n-                    cargo_metadata::Message::BuildScriptExecuted(_)\n-                    | cargo_metadata::Message::Unknown => return true,\n-                    _ => {}\n-                }\n-\n-                // if the send channel was closed, we want to shutdown\n-                message_send.send(message).is_ok()\n-            });\n-\n-            if let Err(err) = res {\n-                // FIXME: make the `message_send` to be `Sender<Result<CheckEvent, CargoError>>`\n-                // to display user-caused misconfiguration errors instead of just logging them here\n-                log::error!(\"Cargo watcher failed {:?}\", err);\n-            }\n-        });\n-        (message_recv, thread)\n+        CargoHandle::spawn(cmd)\n     }\n \n     fn send(&self, check_task: Message) {\n         (self.sender)(check_task)\n     }\n }\n \n-fn run_cargo(\n-    mut command: Command,\n-    on_message: &mut dyn FnMut(cargo_metadata::Message) -> bool,\n-) -> io::Result<()> {\n-    let child =\n-        command.stdout(Stdio::piped()).stderr(Stdio::null()).stdin(Stdio::null()).spawn()?;\n-    let mut child = ChildKiller(child);\n-\n-    // We manually read a line at a time, instead of using serde's\n-    // stream deserializers, because the deserializer cannot recover\n-    // from an error, resulting in it getting stuck, because we try to\n-    // be resillient against failures.\n-    //\n-    // Because cargo only outputs one JSON object per line, we can\n-    // simply skip a line if it doesn't parse, which just ignores any\n-    // erroneus output.\n-    let stdout = BufReader::new(child.stdout.take().unwrap());\n-    let mut read_at_least_one_message = false;\n-    for message in cargo_metadata::Message::parse_stream(stdout) {\n-        let message = match message {\n-            Ok(message) => message,\n-            Err(err) => {\n-                log::error!(\"Invalid json from cargo check, ignoring ({})\", err);\n-                continue;\n-            }\n-        };\n-\n-        read_at_least_one_message = true;\n+struct CargoHandle {\n+    receiver: Receiver<cargo_metadata::Message>,\n+    #[allow(unused)]\n+    thread: jod_thread::JoinHandle,\n+}\n \n-        if !on_message(message) {\n-            break;\n-        }\n+impl CargoHandle {\n+    fn spawn(command: Command) -> CargoHandle {\n+        let (sender, receiver) = unbounded();\n+        let actor = CargoActor::new(command, sender);\n+        let thread = jod_thread::spawn(move || {\n+            let _ = actor.run();\n+        });\n+        CargoHandle { receiver, thread }\n     }\n+}\n \n-    // It is okay to ignore the result, as it only errors if the process is already dead\n-    let _ = child.kill();\n-\n-    let exit_status = child.wait()?;\n-    if !exit_status.success() && !read_at_least_one_message {\n-        // FIXME: Read the stderr to display the reason, see `read2()` reference in PR comment:\n-        // https://github.com/rust-analyzer/rust-analyzer/pull/3632#discussion_r395605298\n-        return Err(io::Error::new(\n-            io::ErrorKind::Other,\n-            format!(\n-                \"the command produced no valid metadata (exit code: {:?}): {:?}\",\n-                exit_status, command\n-            ),\n-        ));\n+struct CargoActor {\n+    command: Command,\n+    sender: Sender<cargo_metadata::Message>,\n+}\n+\n+impl CargoActor {\n+    fn new(command: Command, sender: Sender<cargo_metadata::Message>) -> CargoActor {\n+        CargoActor { command, sender }\n     }\n+    fn run(mut self) -> io::Result<()> {\n+        let child = self\n+            .command\n+            .stdout(Stdio::piped())\n+            .stderr(Stdio::null())\n+            .stdin(Stdio::null())\n+            .spawn()?;\n+        let mut child = ChildKiller(child);\n+\n+        // We manually read a line at a time, instead of using serde's\n+        // stream deserializers, because the deserializer cannot recover\n+        // from an error, resulting in it getting stuck, because we try to\n+        // be resillient against failures.\n+        //\n+        // Because cargo only outputs one JSON object per line, we can\n+        // simply skip a line if it doesn't parse, which just ignores any\n+        // erroneus output.\n+        let stdout = BufReader::new(child.stdout.take().unwrap());\n+        let mut read_at_least_one_message = false;\n+        for message in cargo_metadata::Message::parse_stream(stdout) {\n+            let message = match message {\n+                Ok(message) => message,\n+                Err(err) => {\n+                    log::error!(\"Invalid json from cargo check, ignoring ({})\", err);\n+                    continue;\n+                }\n+            };\n+\n+            read_at_least_one_message = true;\n+\n+            // Skip certain kinds of messages to only spend time on what's useful\n+            match &message {\n+                cargo_metadata::Message::CompilerArtifact(artifact) if artifact.fresh => continue,\n+                cargo_metadata::Message::BuildScriptExecuted(_)\n+                | cargo_metadata::Message::Unknown => continue,\n+                _ => {\n+                    // if the send channel was closed, we want to shutdown\n+                    if self.sender.send(message).is_err() {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        // It is okay to ignore the result, as it only errors if the process is already dead\n+        let _ = child.kill();\n \n-    Ok(())\n+        let exit_status = child.wait()?;\n+        if !exit_status.success() && !read_at_least_one_message {\n+            // FIXME: Read the stderr to display the reason, see `read2()` reference in PR comment:\n+            // https://github.com/rust-analyzer/rust-analyzer/pull/3632#discussion_r395605298\n+\n+            // FIXME: make the `message_send` to be `Sender<Result<CheckEvent, CargoError>>`\n+            // to display user-caused misconfiguration errors instead of just logging them here\n+            log::error!(\"Cargo watcher failed,the command produced no valid metadata (exit code: {:?}): {:?}\", exit_status, self.command);\n+        }\n+        Ok(())\n+    }\n }\n \n struct ChildKiller(process::Child);"}]}