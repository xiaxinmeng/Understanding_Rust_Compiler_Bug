{"sha": "7ed2da652df2f8d81ca0d76a978da2074f8c64f3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdlZDJkYTY1MmRmMmY4ZDgxY2EwZDc2YTk3OGRhMjA3NGY4YzY0ZjM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-02-28T11:29:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-28T11:29:44Z"}, "message": "Merge #7805\n\n7805: For unresolved macros, hightlight only the last segment r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "5e0c37057750cc897031a02ec4860462a4cea9ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e0c37057750cc897031a02ec4860462a4cea9ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7ed2da652df2f8d81ca0d76a978da2074f8c64f3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgO36oCRBK7hj4Ov3rIwAAdHIIAH25nFkGmVJ5B4a1ZK4vHGT4\nu+Om8QyknMIUniu9TJVvdsWibWXulHaY+LsI2fhAMJRFeDlDjuuhx23znrvuOgTp\ntiwagfK3dBD9ighjfysaL1POKxObZBvKpC5izs58hXZlEVVEksPBERyM0fKOlm1E\ngyi/9DAcmfldIVrPojBs2jdiXhQXQo5MJOpzAg55LZnbNKfNtdkhcbmmWNoaNfJS\nVBYYNtpxv60R54xy7dCPN7abJL+TIPv2eLxugtthO1X6epF3c4tDyBqn1nWSdGkw\n8IHHBgYiOs7wOUxI1LFfNNnn/hYQ2MSRaVERM1sS6toMWMlfkL1kR4xZOWcgMNY=\n=KFqD\n-----END PGP SIGNATURE-----\n", "payload": "tree 5e0c37057750cc897031a02ec4860462a4cea9ef\nparent c412d5f8d13cd55dc1873fb55e742a317c7846a8\nparent 05729fd3c4aa542d162b54e7352c0d4bade62684\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1614511784 +0000\ncommitter GitHub <noreply@github.com> 1614511784 +0000\n\nMerge #7805\n\n7805: For unresolved macros, hightlight only the last segment r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7ed2da652df2f8d81ca0d76a978da2074f8c64f3", "html_url": "https://github.com/rust-lang/rust/commit/7ed2da652df2f8d81ca0d76a978da2074f8c64f3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7ed2da652df2f8d81ca0d76a978da2074f8c64f3/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c412d5f8d13cd55dc1873fb55e742a317c7846a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/c412d5f8d13cd55dc1873fb55e742a317c7846a8", "html_url": "https://github.com/rust-lang/rust/commit/c412d5f8d13cd55dc1873fb55e742a317c7846a8"}, {"sha": "05729fd3c4aa542d162b54e7352c0d4bade62684", "url": "https://api.github.com/repos/rust-lang/rust/commits/05729fd3c4aa542d162b54e7352c0d4bade62684", "html_url": "https://github.com/rust-lang/rust/commit/05729fd3c4aa542d162b54e7352c0d4bade62684"}], "stats": {"total": 318, "additions": 209, "deletions": 109}, "files": [{"sha": "b1ebba51648b8321fd924ac9a62c4839be38f5b7", "filename": "crates/hir/src/diagnostics.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7ed2da652df2f8d81ca0d76a978da2074f8c64f3/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed2da652df2f8d81ca0d76a978da2074f8c64f3/crates%2Fhir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdiagnostics.rs?ref=7ed2da652df2f8d81ca0d76a978da2074f8c64f3", "patch": "@@ -1,5 +1,7 @@\n //! FIXME: write short doc here\n-pub use hir_def::diagnostics::{InactiveCode, UnresolvedModule, UnresolvedProcMacro};\n+pub use hir_def::diagnostics::{\n+    InactiveCode, UnresolvedMacroCall, UnresolvedModule, UnresolvedProcMacro,\n+};\n pub use hir_expand::diagnostics::{\n     Diagnostic, DiagnosticCode, DiagnosticSink, DiagnosticSinkBuilder,\n };"}, {"sha": "144851f8348b9b0da12c85ae8df6020eef089ee3", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7ed2da652df2f8d81ca0d76a978da2074f8c64f3/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed2da652df2f8d81ca0d76a978da2074f8c64f3/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=7ed2da652df2f8d81ca0d76a978da2074f8c64f3", "patch": "@@ -16,13 +16,12 @@ use rustc_hash::{FxHashMap, FxHashSet};\n use syntax::{\n     algo::find_node_at_offset,\n     ast::{self, GenericParamsOwner, LoopBodyOwner},\n-    match_ast, AstNode, SyntaxNode, SyntaxToken, TextSize,\n+    match_ast, AstNode, SyntaxNode, SyntaxNodePtr, SyntaxToken, TextSize,\n };\n \n use crate::{\n     code_model::Access,\n     db::HirDatabase,\n-    diagnostics::Diagnostic,\n     semantics::source_to_def::{ChildContainer, SourceToDefCache, SourceToDefCtx},\n     source_analyzer::{resolve_hir_path, SourceAnalyzer},\n     AssocItem, Callable, ConstParam, Crate, Field, Function, HirFileId, Impl, InFile, Label,\n@@ -141,7 +140,7 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.original_range(node)\n     }\n \n-    pub fn diagnostics_display_range(&self, diagnostics: &dyn Diagnostic) -> FileRange {\n+    pub fn diagnostics_display_range(&self, diagnostics: InFile<SyntaxNodePtr>) -> FileRange {\n         self.imp.diagnostics_display_range(diagnostics)\n     }\n \n@@ -385,8 +384,7 @@ impl<'db> SemanticsImpl<'db> {\n         node.as_ref().original_file_range(self.db.upcast())\n     }\n \n-    fn diagnostics_display_range(&self, diagnostics: &dyn Diagnostic) -> FileRange {\n-        let src = diagnostics.display_source();\n+    fn diagnostics_display_range(&self, src: InFile<SyntaxNodePtr>) -> FileRange {\n         let root = self.db.parse_or_expand(src.file_id).unwrap();\n         let node = src.value.to_node(&root);\n         self.cache(root, src.file_id);"}, {"sha": "ff4b4a0cf2b7293a93e98fd8e16183ab5004292f", "filename": "crates/hir_def/src/body.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7ed2da652df2f8d81ca0d76a978da2074f8c64f3/crates%2Fhir_def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed2da652df2f8d81ca0d76a978da2074f8c64f3/crates%2Fhir_def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fbody.rs?ref=7ed2da652df2f8d81ca0d76a978da2074f8c64f3", "patch": "@@ -123,7 +123,7 @@ impl Expander {\n             Some(it) => it,\n             None => {\n                 if err.is_none() {\n-                    eprintln!(\"no error despite `as_call_id_with_errors` returning `None`\");\n+                    log::warn!(\"no error despite `as_call_id_with_errors` returning `None`\");\n                 }\n                 return ExpandResult { value: None, err };\n             }"}, {"sha": "ac7474f63ffa2fab64ed6ed2577e35d47305e659", "filename": "crates/hir_def/src/diagnostics.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7ed2da652df2f8d81ca0d76a978da2074f8c64f3/crates%2Fhir_def%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed2da652df2f8d81ca0d76a978da2074f8c64f3/crates%2Fhir_def%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fdiagnostics.rs?ref=7ed2da652df2f8d81ca0d76a978da2074f8c64f3", "patch": "@@ -95,6 +95,34 @@ impl Diagnostic for UnresolvedImport {\n     }\n }\n \n+// Diagnostic: unresolved-macro-call\n+//\n+// This diagnostic is triggered if rust-analyzer is unable to resolove path to a\n+// macro in a macro invocation.\n+#[derive(Debug)]\n+pub struct UnresolvedMacroCall {\n+    pub file: HirFileId,\n+    pub node: AstPtr<ast::MacroCall>,\n+}\n+\n+impl Diagnostic for UnresolvedMacroCall {\n+    fn code(&self) -> DiagnosticCode {\n+        DiagnosticCode(\"unresolved-macro-call\")\n+    }\n+    fn message(&self) -> String {\n+        \"unresolved macro call\".to_string()\n+    }\n+    fn display_source(&self) -> InFile<SyntaxNodePtr> {\n+        InFile::new(self.file, self.node.clone().into())\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+    fn is_experimental(&self) -> bool {\n+        true\n+    }\n+}\n+\n // Diagnostic: inactive-code\n //\n // This diagnostic is shown for code with inactive `#[cfg]` attributes."}, {"sha": "6802bc250c83bcc1ce5c1d1a868cebcbd3e34db4", "filename": "crates/hir_def/src/lib.rs", "status": "modified", "additions": 56, "deletions": 58, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/7ed2da652df2f8d81ca0d76a978da2074f8c64f3/crates%2Fhir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed2da652df2f8d81ca0d76a978da2074f8c64f3/crates%2Fhir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Flib.rs?ref=7ed2da652df2f8d81ca0d76a978da2074f8c64f3", "patch": "@@ -57,8 +57,10 @@ use std::{\n \n use base_db::{impl_intern_key, salsa, CrateId};\n use hir_expand::{\n-    ast_id_map::FileAstId, eager::expand_eager_macro, hygiene::Hygiene, AstId, HirFileId, InFile,\n-    MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n+    ast_id_map::FileAstId,\n+    eager::{expand_eager_macro, ErrorEmitted},\n+    hygiene::Hygiene,\n+    AstId, HirFileId, InFile, MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n };\n use la_arena::Idx;\n use nameres::DefMap;\n@@ -592,8 +594,15 @@ impl AsMacroCall for InFile<&ast::MacroCall> {\n             error_sink(mbe::ExpandError::Other(\"malformed macro invocation\".into()));\n         }\n \n-        AstIdWithPath::new(ast_id.file_id, ast_id.value, path?)\n-            .as_call_id_with_errors(db, krate, resolver, error_sink)\n+        macro_call_as_call_id(\n+            &AstIdWithPath::new(ast_id.file_id, ast_id.value, path?),\n+            db,\n+            krate,\n+            resolver,\n+            error_sink,\n+        )\n+        .ok()?\n+        .ok()\n     }\n }\n \n@@ -610,61 +619,50 @@ impl<T: ast::AstNode> AstIdWithPath<T> {\n     }\n }\n \n-impl AsMacroCall for AstIdWithPath<ast::MacroCall> {\n-    fn as_call_id_with_errors(\n-        &self,\n-        db: &dyn db::DefDatabase,\n-        krate: CrateId,\n-        resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n-        error_sink: &mut dyn FnMut(mbe::ExpandError),\n-    ) -> Option<MacroCallId> {\n-        let def: MacroDefId = resolver(self.path.clone()).or_else(|| {\n-            error_sink(mbe::ExpandError::Other(format!(\"could not resolve macro `{}`\", self.path)));\n-            None\n-        })?;\n-\n-        if let MacroDefKind::BuiltInEager(_) = def.kind {\n-            let macro_call = InFile::new(self.ast_id.file_id, self.ast_id.to_node(db.upcast()));\n-            let hygiene = Hygiene::new(db.upcast(), self.ast_id.file_id);\n-\n-            Some(\n-                expand_eager_macro(\n-                    db.upcast(),\n-                    krate,\n-                    macro_call,\n-                    def,\n-                    &|path: ast::Path| resolver(path::ModPath::from_src(path, &hygiene)?),\n-                    error_sink,\n-                )\n-                .ok()?\n-                .into(),\n-            )\n-        } else {\n-            Some(def.as_lazy_macro(db.upcast(), krate, MacroCallKind::FnLike(self.ast_id)).into())\n-        }\n-    }\n+struct UnresolvedMacro;\n+\n+fn macro_call_as_call_id(\n+    call: &AstIdWithPath<ast::MacroCall>,\n+    db: &dyn db::DefDatabase,\n+    krate: CrateId,\n+    resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n+    error_sink: &mut dyn FnMut(mbe::ExpandError),\n+) -> Result<Result<MacroCallId, ErrorEmitted>, UnresolvedMacro> {\n+    let def: MacroDefId = resolver(call.path.clone()).ok_or(UnresolvedMacro)?;\n+\n+    let res = if let MacroDefKind::BuiltInEager(_) = def.kind {\n+        let macro_call = InFile::new(call.ast_id.file_id, call.ast_id.to_node(db.upcast()));\n+        let hygiene = Hygiene::new(db.upcast(), call.ast_id.file_id);\n+\n+        expand_eager_macro(\n+            db.upcast(),\n+            krate,\n+            macro_call,\n+            def,\n+            &|path: ast::Path| resolver(path::ModPath::from_src(path, &hygiene)?),\n+            error_sink,\n+        )\n+        .map(MacroCallId::from)\n+    } else {\n+        Ok(def.as_lazy_macro(db.upcast(), krate, MacroCallKind::FnLike(call.ast_id)).into())\n+    };\n+    Ok(res)\n }\n \n-impl AsMacroCall for AstIdWithPath<ast::Item> {\n-    fn as_call_id_with_errors(\n-        &self,\n-        db: &dyn db::DefDatabase,\n-        krate: CrateId,\n-        resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n-        error_sink: &mut dyn FnMut(mbe::ExpandError),\n-    ) -> Option<MacroCallId> {\n-        let def: MacroDefId = resolver(self.path.clone()).or_else(|| {\n-            error_sink(mbe::ExpandError::Other(format!(\"could not resolve macro `{}`\", self.path)));\n-            None\n-        })?;\n-\n-        Some(\n-            def.as_lazy_macro(\n-                db.upcast(),\n-                krate,\n-                MacroCallKind::Attr(self.ast_id, self.path.segments().last()?.to_string()),\n-            )\n-            .into(),\n+fn item_attr_as_call_id(\n+    item_attr: &AstIdWithPath<ast::Item>,\n+    db: &dyn db::DefDatabase,\n+    krate: CrateId,\n+    resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n+) -> Result<MacroCallId, UnresolvedMacro> {\n+    let def: MacroDefId = resolver(item_attr.path.clone()).ok_or(UnresolvedMacro)?;\n+    let last_segment = item_attr.path.segments().last().ok_or(UnresolvedMacro)?;\n+    let res = def\n+        .as_lazy_macro(\n+            db.upcast(),\n+            krate,\n+            MacroCallKind::Attr(item_attr.ast_id, last_segment.to_string()),\n         )\n-    }\n+        .into();\n+    Ok(res)\n }"}, {"sha": "6a3456f2e9386a084e57fb3384da7242fa7e0adc", "filename": "crates/hir_def/src/nameres.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7ed2da652df2f8d81ca0d76a978da2074f8c64f3/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed2da652df2f8d81ca0d76a978da2074f8c64f3/crates%2Fhir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres.rs?ref=7ed2da652df2f8d81ca0d76a978da2074f8c64f3", "patch": "@@ -417,6 +417,8 @@ mod diagnostics {\n \n         UnresolvedProcMacro { ast: MacroCallKind },\n \n+        UnresolvedMacroCall { ast: AstId<ast::MacroCall> },\n+\n         MacroError { ast: MacroCallKind, message: String },\n     }\n \n@@ -477,6 +479,13 @@ mod diagnostics {\n             Self { in_module: container, kind: DiagnosticKind::MacroError { ast, message } }\n         }\n \n+        pub(super) fn unresolved_macro_call(\n+            container: LocalModuleId,\n+            ast: AstId<ast::MacroCall>,\n+        ) -> Self {\n+            Self { in_module: container, kind: DiagnosticKind::UnresolvedMacroCall { ast } }\n+        }\n+\n         pub(super) fn add_to(\n             &self,\n             db: &dyn DefDatabase,\n@@ -589,6 +598,11 @@ mod diagnostics {\n                     });\n                 }\n \n+                DiagnosticKind::UnresolvedMacroCall { ast } => {\n+                    let node = ast.to_node(db.upcast());\n+                    sink.push(UnresolvedMacroCall { file: ast.file_id, node: AstPtr::new(&node) });\n+                }\n+\n                 DiagnosticKind::MacroError { ast, message } => {\n                     let (file, ast) = match ast {\n                         MacroCallKind::FnLike(ast) => {"}, {"sha": "e51d89b436398b6df376ac098ae01e36117e7b0a", "filename": "crates/hir_def/src/nameres/collector.rs", "status": "modified", "additions": 48, "deletions": 33, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/7ed2da652df2f8d81ca0d76a978da2074f8c64f3/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed2da652df2f8d81ca0d76a978da2074f8c64f3/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=7ed2da652df2f8d81ca0d76a978da2074f8c64f3", "patch": "@@ -13,7 +13,7 @@ use hir_expand::{\n     builtin_macro::find_builtin_macro,\n     name::{AsName, Name},\n     proc_macro::ProcMacroExpander,\n-    HirFileId, MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n+    HirFileId, MacroCallId, MacroDefId, MacroDefKind,\n };\n use hir_expand::{InFile, MacroCallLoc};\n use rustc_hash::{FxHashMap, FxHashSet};\n@@ -24,21 +24,23 @@ use tt::{Leaf, TokenTree};\n use crate::{\n     attr::Attrs,\n     db::DefDatabase,\n+    item_attr_as_call_id,\n     item_scope::{ImportType, PerNsGlobImports},\n     item_tree::{\n         self, FileItemTreeId, ItemTree, ItemTreeId, MacroCall, MacroRules, Mod, ModItem, ModKind,\n         StructDefKind,\n     },\n+    macro_call_as_call_id,\n     nameres::{\n         diagnostics::DefDiagnostic, mod_resolution::ModDir, path_resolution::ReachedFixedPoint,\n         BuiltinShadowMode, DefMap, ModuleData, ModuleOrigin, ResolveMode,\n     },\n     path::{ImportAlias, ModPath, PathKind},\n     per_ns::PerNs,\n     visibility::{RawVisibility, Visibility},\n-    AdtId, AsMacroCall, AstId, AstIdWithPath, ConstLoc, ContainerId, EnumLoc, EnumVariantId,\n-    FunctionLoc, ImplLoc, Intern, LocalModuleId, ModuleDefId, StaticLoc, StructLoc, TraitLoc,\n-    TypeAliasLoc, UnionLoc,\n+    AdtId, AstId, AstIdWithPath, ConstLoc, ContainerId, EnumLoc, EnumVariantId, FunctionLoc,\n+    ImplLoc, Intern, LocalModuleId, ModuleDefId, StaticLoc, StructLoc, TraitLoc, TypeAliasLoc,\n+    UnionLoc, UnresolvedMacro,\n };\n \n const GLOB_RECURSION_LIMIT: usize = 100;\n@@ -790,8 +792,11 @@ impl DefCollector<'_> {\n                 return false;\n             }\n \n-            if let Some(call_id) =\n-                directive.ast_id.as_call_id(self.db, self.def_map.krate, |path| {\n+            match macro_call_as_call_id(\n+                &directive.ast_id,\n+                self.db,\n+                self.def_map.krate,\n+                |path| {\n                     let resolved_res = self.def_map.resolve_path_fp_with_macro(\n                         self.db,\n                         ResolveMode::Other,\n@@ -800,24 +805,29 @@ impl DefCollector<'_> {\n                         BuiltinShadowMode::Module,\n                     );\n                     resolved_res.resolved_def.take_macros()\n-                })\n-            {\n-                resolved.push((directive.module_id, call_id, directive.depth));\n-                res = ReachedFixedPoint::No;\n-                return false;\n+                },\n+                &mut |_err| (),\n+            ) {\n+                Ok(Ok(call_id)) => {\n+                    resolved.push((directive.module_id, call_id, directive.depth));\n+                    res = ReachedFixedPoint::No;\n+                    return false;\n+                }\n+                Err(UnresolvedMacro) | Ok(Err(_)) => {}\n             }\n \n             true\n         });\n         attribute_macros.retain(|directive| {\n-            if let Some(call_id) =\n-                directive.ast_id.as_call_id(self.db, self.def_map.krate, |path| {\n-                    self.resolve_attribute_macro(&directive, &path)\n-                })\n-            {\n-                resolved.push((directive.module_id, call_id, 0));\n-                res = ReachedFixedPoint::No;\n-                return false;\n+            match item_attr_as_call_id(&directive.ast_id, self.db, self.def_map.krate, |path| {\n+                self.resolve_attribute_macro(&directive, &path)\n+            }) {\n+                Ok(call_id) => {\n+                    resolved.push((directive.module_id, call_id, 0));\n+                    res = ReachedFixedPoint::No;\n+                    return false;\n+                }\n+                Err(UnresolvedMacro) => (),\n             }\n \n             true\n@@ -902,7 +912,8 @@ impl DefCollector<'_> {\n \n         for directive in &self.unexpanded_macros {\n             let mut error = None;\n-            directive.ast_id.as_call_id_with_errors(\n+            match macro_call_as_call_id(\n+                &directive.ast_id,\n                 self.db,\n                 self.def_map.krate,\n                 |path| {\n@@ -918,15 +929,15 @@ impl DefCollector<'_> {\n                 &mut |e| {\n                     error.get_or_insert(e);\n                 },\n-            );\n-\n-            if let Some(err) = error {\n-                self.def_map.diagnostics.push(DefDiagnostic::macro_error(\n-                    directive.module_id,\n-                    MacroCallKind::FnLike(directive.ast_id.ast_id),\n-                    err.to_string(),\n-                ));\n-            }\n+            ) {\n+                Ok(_) => (),\n+                Err(UnresolvedMacro) => {\n+                    self.def_map.diagnostics.push(DefDiagnostic::unresolved_macro_call(\n+                        directive.module_id,\n+                        directive.ast_id.ast_id,\n+                    ));\n+                }\n+            };\n         }\n \n         // Emit diagnostics for all remaining unresolved imports.\n@@ -1446,17 +1457,21 @@ impl ModCollector<'_, '_> {\n         let mut ast_id = AstIdWithPath::new(self.file_id, mac.ast_id, mac.path.clone());\n \n         // Case 1: try to resolve in legacy scope and expand macro_rules\n-        if let Some(macro_call_id) =\n-            ast_id.as_call_id(self.def_collector.db, self.def_collector.def_map.krate, |path| {\n+        if let Ok(Ok(macro_call_id)) = macro_call_as_call_id(\n+            &ast_id,\n+            self.def_collector.db,\n+            self.def_collector.def_map.krate,\n+            |path| {\n                 path.as_ident().and_then(|name| {\n                     self.def_collector.def_map.with_ancestor_maps(\n                         self.def_collector.db,\n                         self.module_id,\n                         &mut |map, module| map[module].scope.get_legacy_macro(&name),\n                     )\n                 })\n-            })\n-        {\n+            },\n+            &mut |_err| (),\n+        ) {\n             self.def_collector.unexpanded_macros.push(MacroDirective {\n                 module_id: self.module_id,\n                 ast_id,"}, {"sha": "fe32f39b643073633f34ecd85bfd5b6a72d94649", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 56, "deletions": 11, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/7ed2da652df2f8d81ca0d76a978da2074f8c64f3/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7ed2da652df2f8d81ca0d76a978da2074f8c64f3/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=7ed2da652df2f8d81ca0d76a978da2074f8c64f3", "patch": "@@ -10,15 +10,16 @@ mod field_shorthand;\n use std::cell::RefCell;\n \n use hir::{\n+    db::AstDatabase,\n     diagnostics::{Diagnostic as _, DiagnosticCode, DiagnosticSinkBuilder},\n-    Semantics,\n+    InFile, Semantics,\n };\n use ide_db::{base_db::SourceDatabase, RootDatabase};\n use itertools::Itertools;\n use rustc_hash::FxHashSet;\n use syntax::{\n     ast::{self, AstNode},\n-    SyntaxNode, TextRange,\n+    SyntaxNode, SyntaxNodePtr, TextRange,\n };\n use text_edit::TextEdit;\n \n@@ -147,20 +148,38 @@ pub(crate) fn diagnostics(\n \n             // Override severity and mark as unused.\n             res.borrow_mut().push(\n-                Diagnostic::hint(sema.diagnostics_display_range(d).range, d.message())\n-                    .with_unused(true)\n-                    .with_code(Some(d.code())),\n+                Diagnostic::hint(\n+                    sema.diagnostics_display_range(d.display_source()).range,\n+                    d.message(),\n+                )\n+                .with_unused(true)\n+                .with_code(Some(d.code())),\n             );\n         })\n         .on::<hir::diagnostics::UnresolvedProcMacro, _>(|d| {\n             // Use more accurate position if available.\n-            let display_range =\n-                d.precise_location.unwrap_or_else(|| sema.diagnostics_display_range(d).range);\n+            let display_range = d\n+                .precise_location\n+                .unwrap_or_else(|| sema.diagnostics_display_range(d.display_source()).range);\n \n             // FIXME: it would be nice to tell the user whether proc macros are currently disabled\n             res.borrow_mut()\n                 .push(Diagnostic::hint(display_range, d.message()).with_code(Some(d.code())));\n         })\n+        .on::<hir::diagnostics::UnresolvedMacroCall, _>(|d| {\n+            let last_path_segment = sema.db.parse_or_expand(d.file).and_then(|root| {\n+                d.node\n+                    .to_node(&root)\n+                    .path()\n+                    .and_then(|it| it.segment())\n+                    .and_then(|it| it.name_ref())\n+                    .map(|it| InFile::new(d.file, SyntaxNodePtr::new(it.syntax())))\n+            });\n+            let diagnostics = last_path_segment.unwrap_or_else(|| d.display_source());\n+            let display_range = sema.diagnostics_display_range(diagnostics).range;\n+            res.borrow_mut()\n+                .push(Diagnostic::error(display_range, d.message()).with_code(Some(d.code())));\n+        })\n         // Only collect experimental diagnostics when they're enabled.\n         .filter(|diag| !(diag.is_experimental() && config.disable_experimental))\n         .filter(|diag| !config.disabled.contains(diag.code().as_str()));\n@@ -170,8 +189,11 @@ pub(crate) fn diagnostics(\n         // Diagnostics not handled above get no fix and default treatment.\n         .build(|d| {\n             res.borrow_mut().push(\n-                Diagnostic::error(sema.diagnostics_display_range(d).range, d.message())\n-                    .with_code(Some(d.code())),\n+                Diagnostic::error(\n+                    sema.diagnostics_display_range(d.display_source()).range,\n+                    d.message(),\n+                )\n+                .with_code(Some(d.code())),\n             );\n         });\n \n@@ -183,13 +205,13 @@ pub(crate) fn diagnostics(\n }\n \n fn diagnostic_with_fix<D: DiagnosticWithFix>(d: &D, sema: &Semantics<RootDatabase>) -> Diagnostic {\n-    Diagnostic::error(sema.diagnostics_display_range(d).range, d.message())\n+    Diagnostic::error(sema.diagnostics_display_range(d.display_source()).range, d.message())\n         .with_fix(d.fix(&sema))\n         .with_code(Some(d.code()))\n }\n \n fn warning_with_fix<D: DiagnosticWithFix>(d: &D, sema: &Semantics<RootDatabase>) -> Diagnostic {\n-    Diagnostic::hint(sema.diagnostics_display_range(d).range, d.message())\n+    Diagnostic::hint(sema.diagnostics_display_range(d.display_source()).range, d.message())\n         .with_fix(d.fix(&sema))\n         .with_code(Some(d.code()))\n }\n@@ -645,6 +667,29 @@ fn test_fn() {\n         );\n     }\n \n+    #[test]\n+    fn test_unresolved_macro_range() {\n+        check_expect(\n+            r#\"foo::bar!(92);\"#,\n+            expect![[r#\"\n+                [\n+                    Diagnostic {\n+                        message: \"unresolved macro call\",\n+                        range: 5..8,\n+                        severity: Error,\n+                        fix: None,\n+                        unused: false,\n+                        code: Some(\n+                            DiagnosticCode(\n+                                \"unresolved-macro-call\",\n+                            ),\n+                        ),\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n+\n     #[test]\n     fn range_mapping_out_of_macros() {\n         // FIXME: this is very wrong, but somewhat tricky to fix."}]}