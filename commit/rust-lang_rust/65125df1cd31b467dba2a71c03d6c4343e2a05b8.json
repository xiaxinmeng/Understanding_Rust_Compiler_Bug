{"sha": "65125df1cd31b467dba2a71c03d6c4343e2a05b8", "node_id": "C_kwDOAAsO6NoAKDY1MTI1ZGYxY2QzMWI0NjdkYmEyYTcxYzAzZDZjNDM0M2UyYTA1Yjg", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-03-12T22:23:22Z"}, "committer": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-03-18T20:28:13Z"}, "message": "Consider the cargo workspace when checking if a frame is local", "tree": {"sha": "57e653112c1a4dc2599772fa5190336c53289f8c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/57e653112c1a4dc2599772fa5190336c53289f8c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65125df1cd31b467dba2a71c03d6c4343e2a05b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65125df1cd31b467dba2a71c03d6c4343e2a05b8", "html_url": "https://github.com/rust-lang/rust/commit/65125df1cd31b467dba2a71c03d6c4343e2a05b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65125df1cd31b467dba2a71c03d6c4343e2a05b8/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e818ffa1b85f4e740c4096fd38c62b2b73f4d83", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e818ffa1b85f4e740c4096fd38c62b2b73f4d83", "html_url": "https://github.com/rust-lang/rust/commit/8e818ffa1b85f4e740c4096fd38c62b2b73f4d83"}], "stats": {"total": 103, "additions": 79, "deletions": 24}, "files": [{"sha": "fb999d85a192c4af60d0767d2f59837ee4d70ec5", "filename": "README.md", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/65125df1cd31b467dba2a71c03d6c4343e2a05b8/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/65125df1cd31b467dba2a71c03d6c4343e2a05b8/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=65125df1cd31b467dba2a71c03d6c4343e2a05b8", "patch": "@@ -375,9 +375,12 @@ binaries, and as such worth documenting:\n   directory after loading all the source files, but before commencing\n   interpretation. This is useful if the interpreted program wants a different\n   working directory at run-time than at build-time.\n+* `MIRI_LOCAL_CRATES` is set by `cargo-miri` to tell the Miri driver which\n+  crates should be given special treatment in diagnostics, in addition to the\n+  crate currently being compiled.\n * `MIRI_VERBOSE` when set to any value tells the various `cargo-miri` phases to\n   perform verbose logging.\n-  \n+\n [testing-miri]: CONTRIBUTING.md#testing-the-miri-driver\n \n ## Miri `extern` functions"}, {"sha": "373c63647c35aed8401eb12746efd45a63fdf68d", "filename": "cargo-miri/bin.rs", "status": "modified", "additions": 31, "deletions": 10, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/65125df1cd31b467dba2a71c03d6c4343e2a05b8/cargo-miri%2Fbin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65125df1cd31b467dba2a71c03d6c4343e2a05b8/cargo-miri%2Fbin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fbin.rs?ref=65125df1cd31b467dba2a71c03d6c4343e2a05b8", "patch": "@@ -482,12 +482,13 @@ path = \"lib.rs\"\n     }\n }\n \n-/// Detect the target directory by calling `cargo metadata`.\n-fn detect_target_dir() -> PathBuf {\n-    #[derive(Deserialize)]\n-    struct Metadata {\n-        target_directory: PathBuf,\n-    }\n+#[derive(Deserialize)]\n+struct Metadata {\n+    target_directory: PathBuf,\n+    workspace_members: Vec<String>,\n+}\n+\n+fn get_cargo_metadata() -> Metadata {\n     let mut cmd = cargo();\n     // `-Zunstable-options` is required by `--config`.\n     cmd.args([\"metadata\", \"--no-deps\", \"--format-version=1\", \"-Zunstable-options\"]);\n@@ -514,9 +515,25 @@ fn detect_target_dir() -> PathBuf {\n     if !status.success() {\n         std::process::exit(status.code().unwrap_or(-1));\n     }\n-    metadata\n-        .unwrap_or_else(|e| show_error(format!(\"invalid `cargo metadata` output: {}\", e)))\n-        .target_directory\n+    metadata.unwrap_or_else(|e| show_error(format!(\"invalid `cargo metadata` output: {}\", e)))\n+}\n+\n+/// Pulls all the crates in this workspace from the cargo metadata.\n+/// Workspace members are emitted like \"miri 0.1.0 (path+file:///path/to/miri)\"\n+/// Additionally, somewhere between cargo metadata and TyCtxt, '-' gets replaced with '_' so we\n+/// make that same transformation here.\n+fn local_crates(metadata: &Metadata) -> String {\n+    assert!(metadata.workspace_members.len() > 0);\n+    let mut local_crates = String::new();\n+    for member in &metadata.workspace_members {\n+        let name = member.split(\" \").nth(0).unwrap();\n+        let name = name.replace(\"-\", \"_\");\n+        local_crates.push_str(&name);\n+        local_crates.push(',');\n+    }\n+    local_crates.pop(); // Remove the trailing ','\n+\n+    local_crates\n }\n \n fn phase_cargo_miri(mut args: env::Args) {\n@@ -595,8 +612,10 @@ fn phase_cargo_miri(mut args: env::Args) {\n         }\n     }\n \n+    let metadata = get_cargo_metadata();\n+\n     // Detect the target directory if it's not specified via `--target-dir`.\n-    let target_dir = target_dir.get_or_insert_with(detect_target_dir);\n+    let target_dir = target_dir.get_or_insert_with(|| metadata.target_directory.clone());\n \n     // Set `--target-dir` to `miri` inside the original target directory.\n     target_dir.push(\"miri\");\n@@ -628,6 +647,8 @@ fn phase_cargo_miri(mut args: env::Args) {\n     // Set rustdoc to us as well, so we can run doctests.\n     cmd.env(\"RUSTDOC\", &cargo_miri_path);\n \n+    cmd.env(\"MIRI_LOCAL_CRATES\", local_crates(&metadata));\n+\n     // Run cargo.\n     if verbose {\n         eprintln!(\"[cargo-miri miri] RUSTC_WRAPPER={:?}\", cargo_miri_path);"}, {"sha": "0815d73d9bcb791bfde9c6d7b894abdda481bc02", "filename": "src/diagnostics.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/65125df1cd31b467dba2a71c03d6c4343e2a05b8/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65125df1cd31b467dba2a71c03d6c4343e2a05b8/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=65125df1cd31b467dba2a71c03d6c4343e2a05b8", "patch": "@@ -4,7 +4,7 @@ use std::num::NonZeroU64;\n \n use log::trace;\n \n-use rustc_middle::ty::{self, TyCtxt};\n+use rustc_middle::ty;\n use rustc_span::{source_map::DUMMY_SP, Span, SpanData, Symbol};\n \n use crate::stacked_borrows::{AccessKind, SbTag};\n@@ -94,7 +94,7 @@ fn prune_stacktrace<'mir, 'tcx>(\n             // Only prune frames if there is at least one local frame. This check ensures that if\n             // we get a backtrace that never makes it to the user code because it has detected a\n             // bug in the Rust runtime, we don't prune away every frame.\n-            let has_local_frame = stacktrace.iter().any(|frame| frame.instance.def_id().is_local());\n+            let has_local_frame = stacktrace.iter().any(|frame| ecx.machine.is_local(frame));\n             if has_local_frame {\n                 // This is part of the logic that `std` uses to select the relevant part of a\n                 // backtrace. But here, we only look for __rust_begin_short_backtrace, not\n@@ -115,7 +115,7 @@ fn prune_stacktrace<'mir, 'tcx>(\n                 // This len check ensures that we don't somehow remove every frame, as doing so breaks\n                 // the primary error message.\n                 while stacktrace.len() > 1\n-                    && stacktrace.last().map_or(false, |e| !e.instance.def_id().is_local())\n+                    && stacktrace.last().map_or(false, |frame| !ecx.machine.is_local(frame))\n                 {\n                     stacktrace.pop();\n                 }\n@@ -218,7 +218,7 @@ pub fn report_error<'tcx, 'mir>(\n     e.print_backtrace();\n     msg.insert(0, e.to_string());\n     report_msg(\n-        *ecx.tcx,\n+        ecx,\n         DiagLevel::Error,\n         &if let Some(title) = title { format!(\"{}: {}\", title, msg[0]) } else { msg[0].clone() },\n         msg,\n@@ -264,19 +264,20 @@ pub fn report_error<'tcx, 'mir>(\n /// We want to present a multi-line span message for some errors. Diagnostics do not support this\n /// directly, so we pass the lines as a `Vec<String>` and display each line after the first with an\n /// additional `span_label` or `note` call.\n-fn report_msg<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n+fn report_msg<'mir, 'tcx>(\n+    ecx: &InterpCx<'mir, 'tcx, Evaluator<'mir, 'tcx>>,\n     diag_level: DiagLevel,\n     title: &str,\n     span_msg: Vec<String>,\n     mut helps: Vec<(Option<SpanData>, String)>,\n     stacktrace: &[FrameInfo<'tcx>],\n ) {\n     let span = stacktrace.first().map_or(DUMMY_SP, |fi| fi.span);\n+    let sess = ecx.tcx.sess;\n     let mut err = match diag_level {\n-        DiagLevel::Error => tcx.sess.struct_span_err(span, title).forget_guarantee(),\n-        DiagLevel::Warning => tcx.sess.struct_span_warn(span, title),\n-        DiagLevel::Note => tcx.sess.diagnostic().span_note_diag(span, title),\n+        DiagLevel::Error => sess.struct_span_err(span, title).forget_guarantee(),\n+        DiagLevel::Warning => sess.struct_span_warn(span, title),\n+        DiagLevel::Note => sess.diagnostic().span_note_diag(span, title),\n     };\n \n     // Show main message.\n@@ -306,7 +307,7 @@ fn report_msg<'tcx>(\n     }\n     // Add backtrace\n     for (idx, frame_info) in stacktrace.iter().enumerate() {\n-        let is_local = frame_info.instance.def_id().is_local();\n+        let is_local = ecx.machine.is_local(frame_info);\n         // No span for non-local frames and the first frame (which is the error site).\n         if is_local && idx > 0 {\n             err.span_note(frame_info.span, &frame_info.to_string());\n@@ -426,7 +427,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     _ => (\"tracking was triggered\", DiagLevel::Note),\n                 };\n \n-                report_msg(*this.tcx, diag_level, title, vec![msg], vec![], &stacktrace);\n+                report_msg(this, diag_level, title, vec![msg], vec![], &stacktrace);\n             }\n         });\n     }"}, {"sha": "3ffb983aa69ecff2390133bf42946a99baa79a60", "filename": "src/helpers.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/65125df1cd31b467dba2a71c03d6c4343e2a05b8/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65125df1cd31b467dba2a71c03d6c4343e2a05b8/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=65125df1cd31b467dba2a71c03d6c4343e2a05b8", "patch": "@@ -12,7 +12,7 @@ use rustc_middle::ty::{\n     layout::{LayoutOf, TyAndLayout},\n     List, TyCtxt,\n };\n-use rustc_span::Symbol;\n+use rustc_span::{def_id::CrateNum, Symbol};\n use rustc_target::abi::{Align, FieldsShape, Size, Variants};\n use rustc_target::spec::abi::Abi;\n \n@@ -775,3 +775,22 @@ pub fn isolation_abort_error(name: &str) -> InterpResult<'static> {\n         name,\n     )))\n }\n+\n+/// Retrieve the list of local crates that should have been passed by cargo-miri in\n+/// MIRI_LOCAL_CRATES and turn them into `CrateNum`s.\n+pub fn get_local_crates(tcx: &TyCtxt<'_>) -> Vec<CrateNum> {\n+    // Convert the local crate names from the passed-in config into CrateNums so that they can\n+    // be looked up quickly during execution\n+    let local_crate_names = std::env::var(\"MIRI_LOCAL_CRATES\")\n+        .map(|crates| crates.split(\",\").map(|krate| krate.to_string()).collect::<Vec<_>>())\n+        .unwrap_or_default();\n+    let mut local_crates = Vec::new();\n+    for &crate_num in tcx.crates(()) {\n+        let name = tcx.crate_name(crate_num);\n+        let name = name.as_str();\n+        if local_crate_names.iter().any(|local_name| local_name == name) {\n+            local_crates.push(crate_num);\n+        }\n+    }\n+    local_crates\n+}"}, {"sha": "2cf7cd0fae0e26f5a9d0ad37ed6422b7d69c4f72", "filename": "src/machine.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/65125df1cd31b467dba2a71c03d6c4343e2a05b8/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65125df1cd31b467dba2a71c03d6c4343e2a05b8/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=65125df1cd31b467dba2a71c03d6c4343e2a05b8", "patch": "@@ -19,7 +19,7 @@ use rustc_middle::{\n         Instance, TyCtxt,\n     },\n };\n-use rustc_span::def_id::DefId;\n+use rustc_span::def_id::{CrateNum, DefId};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_target::abi::Size;\n use rustc_target::spec::abi::Abi;\n@@ -349,10 +349,14 @@ pub struct Evaluator<'mir, 'tcx> {\n \n     /// Equivalent setting as RUST_BACKTRACE on encountering an error.\n     pub(crate) backtrace_style: BacktraceStyle,\n+\n+    /// Crates which are considered local for the purposes of error reporting.\n+    pub(crate) local_crates: Vec<CrateNum>,\n }\n \n impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n     pub(crate) fn new(config: &MiriConfig, layout_cx: LayoutCx<'tcx, TyCtxt<'tcx>>) -> Self {\n+        let local_crates = helpers::get_local_crates(&layout_cx.tcx);\n         let layouts =\n             PrimitiveLayouts::new(layout_cx).expect(\"Couldn't get layouts of primitive types\");\n         let profiler = config.measureme_out.as_ref().map(|out| {\n@@ -381,12 +385,19 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n             exported_symbols_cache: FxHashMap::default(),\n             panic_on_unsupported: config.panic_on_unsupported,\n             backtrace_style: config.backtrace_style,\n+            local_crates,\n         }\n     }\n \n     pub(crate) fn communicate(&self) -> bool {\n         self.isolated_op == IsolatedOp::Allow\n     }\n+\n+    /// Check whether the stack frame that this `FrameInfo` refers to is part of a local crate.\n+    pub(crate) fn is_local(&self, frame: &FrameInfo<'_>) -> bool {\n+        let def_id = frame.instance.def_id();\n+        def_id.is_local() || self.local_crates.contains(&def_id.krate)\n+    }\n }\n \n /// A rustc InterpCx for Miri."}]}