{"sha": "b82f149d08a0afcc17afa54f5bb3c7031babd44a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4MmYxNDlkMDhhMGFmY2MxN2FmYTU0ZjViYjNjNzAzMWJhYmQ0NGE=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-12-02T23:11:29Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2021-01-12T19:59:10Z"}, "message": "Add tests for uninhabited types", "tree": {"sha": "a04c389861c92ea57891fbc137a7f0466bd03114", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a04c389861c92ea57891fbc137a7f0466bd03114"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b82f149d08a0afcc17afa54f5bb3c7031babd44a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b82f149d08a0afcc17afa54f5bb3c7031babd44a", "html_url": "https://github.com/rust-lang/rust/commit/b82f149d08a0afcc17afa54f5bb3c7031babd44a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b82f149d08a0afcc17afa54f5bb3c7031babd44a/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "622bfdb2fdfc3da9ca2959b5e9ae686b1c9ed249", "url": "https://api.github.com/repos/rust-lang/rust/commits/622bfdb2fdfc3da9ca2959b5e9ae686b1c9ed249", "html_url": "https://github.com/rust-lang/rust/commit/622bfdb2fdfc3da9ca2959b5e9ae686b1c9ed249"}], "stats": {"total": 563, "additions": 351, "deletions": 212}, "files": [{"sha": "29a03c9e8b50c3cbaf39e5495591d060475dbdcc", "filename": "src/test/ui/pattern/usefulness/auxiliary/empty.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b82f149d08a0afcc17afa54f5bb3c7031babd44a/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fauxiliary%2Fempty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b82f149d08a0afcc17afa54f5bb3c7031babd44a/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fauxiliary%2Fempty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fauxiliary%2Fempty.rs?ref=b82f149d08a0afcc17afa54f5bb3c7031babd44a", "patch": "@@ -1,2 +1,10 @@\n #![crate_type = \"rlib\"]\n pub enum EmptyForeignEnum {}\n+\n+pub struct VisiblyUninhabitedForeignStruct {\n+    pub field: EmptyForeignEnum,\n+}\n+\n+pub struct SecretlyUninhabitedForeignStruct {\n+    _priv: EmptyForeignEnum,\n+}"}, {"sha": "b99386e74020e8da394e86cf987b490000c32ffe", "filename": "src/test/ui/pattern/usefulness/empty-match.exhaustive_patterns.stderr", "status": "modified", "additions": 80, "deletions": 80, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/b82f149d08a0afcc17afa54f5bb3c7031babd44a/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.exhaustive_patterns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b82f149d08a0afcc17afa54f5bb3c7031babd44a/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.exhaustive_patterns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.exhaustive_patterns.stderr?ref=b82f149d08a0afcc17afa54f5bb3c7031babd44a", "patch": "@@ -1,257 +1,257 @@\n error: unreachable pattern\n-  --> $DIR/empty-match.rs:53:9\n+  --> $DIR/empty-match.rs:37:9\n    |\n LL |         _ => {},\n    |         ^\n    |\n note: the lint level is defined here\n-  --> $DIR/empty-match.rs:6:9\n+  --> $DIR/empty-match.rs:8:9\n    |\n LL | #![deny(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/empty-match.rs:56:9\n+  --> $DIR/empty-match.rs:40:9\n    |\n LL |         _ if false => {},\n    |         ^\n \n error: unreachable pattern\n-  --> $DIR/empty-match.rs:63:9\n+  --> $DIR/empty-match.rs:47:9\n    |\n LL |         _ => {},\n    |         ^\n \n error: unreachable pattern\n-  --> $DIR/empty-match.rs:66:9\n+  --> $DIR/empty-match.rs:50:9\n    |\n LL |         _ if false => {},\n    |         ^\n \n error: unreachable pattern\n-  --> $DIR/empty-match.rs:73:9\n+  --> $DIR/empty-match.rs:57:9\n    |\n LL |         _ => {},\n    |         ^\n \n error: unreachable pattern\n-  --> $DIR/empty-match.rs:76:9\n+  --> $DIR/empty-match.rs:60:9\n    |\n LL |         _ if false => {},\n    |         ^\n \n-error: unreachable pattern\n-  --> $DIR/empty-match.rs:83:9\n+error[E0004]: non-exhaustive patterns: type `u8` is non-empty\n+  --> $DIR/empty-match.rs:78:20\n    |\n-LL |         Some(_) => {}\n-   |         ^^^^^^^\n-\n-error: unreachable pattern\n-  --> $DIR/empty-match.rs:87:9\n+LL |     match_no_arms!(0u8);\n+   |                    ^^^\n    |\n-LL |         Some(_) => {}\n-   |         ^^^^^^^\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `u8`\n \n-error[E0004]: non-exhaustive patterns: type `u8` is non-empty\n-  --> $DIR/empty-match.rs:90:18\n+error[E0004]: non-exhaustive patterns: type `NonEmptyStruct1` is non-empty\n+  --> $DIR/empty-match.rs:79:20\n    |\n-LL |     match_empty!(0u8);\n-   |                  ^^^\n+LL | struct NonEmptyStruct1;\n+   | ----------------------- `NonEmptyStruct1` defined here\n+...\n+LL |     match_no_arms!(NonEmptyStruct1);\n+   |                    ^^^^^^^^^^^^^^^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n-   = note: the matched value is of type `u8`\n+   = note: the matched value is of type `NonEmptyStruct1`\n \n-error[E0004]: non-exhaustive patterns: type `NonEmptyStruct` is non-empty\n-  --> $DIR/empty-match.rs:92:18\n+error[E0004]: non-exhaustive patterns: type `NonEmptyStruct2` is non-empty\n+  --> $DIR/empty-match.rs:80:20\n    |\n-LL | struct NonEmptyStruct(bool);\n-   | ---------------------------- `NonEmptyStruct` defined here\n+LL | struct NonEmptyStruct2(bool);\n+   | ----------------------------- `NonEmptyStruct2` defined here\n ...\n-LL |     match_empty!(NonEmptyStruct(true));\n-   |                  ^^^^^^^^^^^^^^^^^^^^\n+LL |     match_no_arms!(NonEmptyStruct2(true));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n-   = note: the matched value is of type `NonEmptyStruct`\n+   = note: the matched value is of type `NonEmptyStruct2`\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyUnion1` is non-empty\n-  --> $DIR/empty-match.rs:94:18\n+  --> $DIR/empty-match.rs:81:20\n    |\n LL | / union NonEmptyUnion1 {\n LL | |     foo: (),\n LL | | }\n    | |_- `NonEmptyUnion1` defined here\n ...\n-LL |       match_empty!((NonEmptyUnion1 { foo: () }));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |       match_no_arms!((NonEmptyUnion1 { foo: () }));\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyUnion1`\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyUnion2` is non-empty\n-  --> $DIR/empty-match.rs:96:18\n+  --> $DIR/empty-match.rs:82:20\n    |\n LL | / union NonEmptyUnion2 {\n LL | |     foo: (),\n LL | |     bar: (),\n LL | | }\n    | |_- `NonEmptyUnion2` defined here\n ...\n-LL |       match_empty!((NonEmptyUnion2 { foo: () }));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |       match_no_arms!((NonEmptyUnion2 { foo: () }));\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyUnion2`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n-  --> $DIR/empty-match.rs:98:18\n+  --> $DIR/empty-match.rs:83:20\n    |\n LL | / enum NonEmptyEnum1 {\n LL | |     Foo(bool),\n    | |     --- not covered\n-LL | |\n-LL | |\n LL | | }\n    | |_- `NonEmptyEnum1` defined here\n ...\n-LL |       match_empty!(NonEmptyEnum1::Foo(true));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n+LL |       match_no_arms!(NonEmptyEnum1::Foo(true));\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyEnum1`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n-  --> $DIR/empty-match.rs:100:18\n+  --> $DIR/empty-match.rs:84:20\n    |\n LL | / enum NonEmptyEnum2 {\n LL | |     Foo(bool),\n    | |     --- not covered\n-LL | |\n-LL | |\n LL | |     Bar,\n    | |     --- not covered\n-LL | |\n-LL | |\n LL | | }\n    | |_- `NonEmptyEnum2` defined here\n ...\n-LL |       match_empty!(NonEmptyEnum2::Foo(true));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n+LL |       match_no_arms!(NonEmptyEnum2::Foo(true));\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyEnum2`\n \n error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n-  --> $DIR/empty-match.rs:102:18\n+  --> $DIR/empty-match.rs:85:20\n    |\n LL | / enum NonEmptyEnum5 {\n LL | |     V1, V2, V3, V4, V5,\n LL | | }\n    | |_- `NonEmptyEnum5` defined here\n ...\n-LL |       match_empty!(NonEmptyEnum5::V1);\n-   |                    ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+LL |       match_no_arms!(NonEmptyEnum5::V1);\n+   |                      ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyEnum5`\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n-  --> $DIR/empty-match.rs:105:18\n+  --> $DIR/empty-match.rs:87:24\n    |\n-LL |     match_false!(0u8);\n-   |                  ^^^ pattern `_` not covered\n+LL |     match_guarded_arm!(0u8);\n+   |                        ^^^ pattern `_` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n \n-error[E0004]: non-exhaustive patterns: `NonEmptyStruct(_)` not covered\n-  --> $DIR/empty-match.rs:107:18\n+error[E0004]: non-exhaustive patterns: `NonEmptyStruct1` not covered\n+  --> $DIR/empty-match.rs:88:24\n+   |\n+LL | struct NonEmptyStruct1;\n+   | ----------------------- `NonEmptyStruct1` defined here\n+...\n+LL |     match_guarded_arm!(NonEmptyStruct1);\n+   |                        ^^^^^^^^^^^^^^^ pattern `NonEmptyStruct1` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NonEmptyStruct1`\n+\n+error[E0004]: non-exhaustive patterns: `NonEmptyStruct2(_)` not covered\n+  --> $DIR/empty-match.rs:89:24\n    |\n-LL | struct NonEmptyStruct(bool);\n-   | ---------------------------- `NonEmptyStruct` defined here\n+LL | struct NonEmptyStruct2(bool);\n+   | ----------------------------- `NonEmptyStruct2` defined here\n ...\n-LL |     match_false!(NonEmptyStruct(true));\n-   |                  ^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyStruct(_)` not covered\n+LL |     match_guarded_arm!(NonEmptyStruct2(true));\n+   |                        ^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyStruct2(_)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n-   = note: the matched value is of type `NonEmptyStruct`\n+   = note: the matched value is of type `NonEmptyStruct2`\n \n error[E0004]: non-exhaustive patterns: `NonEmptyUnion1 { .. }` not covered\n-  --> $DIR/empty-match.rs:109:18\n+  --> $DIR/empty-match.rs:90:24\n    |\n LL | / union NonEmptyUnion1 {\n LL | |     foo: (),\n LL | | }\n    | |_- `NonEmptyUnion1` defined here\n ...\n-LL |       match_false!((NonEmptyUnion1 { foo: () }));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion1 { .. }` not covered\n+LL |       match_guarded_arm!((NonEmptyUnion1 { foo: () }));\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion1 { .. }` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyUnion1`\n \n error[E0004]: non-exhaustive patterns: `NonEmptyUnion2 { .. }` not covered\n-  --> $DIR/empty-match.rs:111:18\n+  --> $DIR/empty-match.rs:91:24\n    |\n LL | / union NonEmptyUnion2 {\n LL | |     foo: (),\n LL | |     bar: (),\n LL | | }\n    | |_- `NonEmptyUnion2` defined here\n ...\n-LL |       match_false!((NonEmptyUnion2 { foo: () }));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion2 { .. }` not covered\n+LL |       match_guarded_arm!((NonEmptyUnion2 { foo: () }));\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion2 { .. }` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyUnion2`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n-  --> $DIR/empty-match.rs:113:18\n+  --> $DIR/empty-match.rs:92:24\n    |\n LL | / enum NonEmptyEnum1 {\n LL | |     Foo(bool),\n    | |     --- not covered\n-LL | |\n-LL | |\n LL | | }\n    | |_- `NonEmptyEnum1` defined here\n ...\n-LL |       match_false!(NonEmptyEnum1::Foo(true));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n+LL |       match_guarded_arm!(NonEmptyEnum1::Foo(true));\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyEnum1`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n-  --> $DIR/empty-match.rs:115:18\n+  --> $DIR/empty-match.rs:93:24\n    |\n LL | / enum NonEmptyEnum2 {\n LL | |     Foo(bool),\n    | |     --- not covered\n-LL | |\n-LL | |\n LL | |     Bar,\n    | |     --- not covered\n-LL | |\n-LL | |\n LL | | }\n    | |_- `NonEmptyEnum2` defined here\n ...\n-LL |       match_false!(NonEmptyEnum2::Foo(true));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n+LL |       match_guarded_arm!(NonEmptyEnum2::Foo(true));\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyEnum2`\n \n error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n-  --> $DIR/empty-match.rs:117:18\n+  --> $DIR/empty-match.rs:94:24\n    |\n LL | / enum NonEmptyEnum5 {\n LL | |     V1, V2, V3, V4, V5,\n LL | | }\n    | |_- `NonEmptyEnum5` defined here\n ...\n-LL |       match_false!(NonEmptyEnum5::V1);\n-   |                    ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+LL |       match_guarded_arm!(NonEmptyEnum5::V1);\n+   |                          ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyEnum5`"}, {"sha": "b99386e74020e8da394e86cf987b490000c32ffe", "filename": "src/test/ui/pattern/usefulness/empty-match.normal.stderr", "status": "modified", "additions": 82, "deletions": 70, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/b82f149d08a0afcc17afa54f5bb3c7031babd44a/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.normal.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b82f149d08a0afcc17afa54f5bb3c7031babd44a/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.normal.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.normal.stderr?ref=b82f149d08a0afcc17afa54f5bb3c7031babd44a", "patch": "@@ -1,249 +1,261 @@\n error: unreachable pattern\n-  --> $DIR/empty-match.rs:53:9\n+  --> $DIR/empty-match.rs:37:9\n    |\n LL |         _ => {},\n    |         ^\n    |\n note: the lint level is defined here\n-  --> $DIR/empty-match.rs:6:9\n+  --> $DIR/empty-match.rs:8:9\n    |\n LL | #![deny(unreachable_patterns)]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error: unreachable pattern\n-  --> $DIR/empty-match.rs:56:9\n+  --> $DIR/empty-match.rs:40:9\n    |\n LL |         _ if false => {},\n    |         ^\n \n error: unreachable pattern\n-  --> $DIR/empty-match.rs:63:9\n+  --> $DIR/empty-match.rs:47:9\n    |\n LL |         _ => {},\n    |         ^\n \n error: unreachable pattern\n-  --> $DIR/empty-match.rs:66:9\n+  --> $DIR/empty-match.rs:50:9\n    |\n LL |         _ if false => {},\n    |         ^\n \n error: unreachable pattern\n-  --> $DIR/empty-match.rs:73:9\n+  --> $DIR/empty-match.rs:57:9\n    |\n LL |         _ => {},\n    |         ^\n \n error: unreachable pattern\n-  --> $DIR/empty-match.rs:76:9\n+  --> $DIR/empty-match.rs:60:9\n    |\n LL |         _ if false => {},\n    |         ^\n \n error[E0004]: non-exhaustive patterns: type `u8` is non-empty\n-  --> $DIR/empty-match.rs:90:18\n+  --> $DIR/empty-match.rs:78:20\n    |\n-LL |     match_empty!(0u8);\n-   |                  ^^^\n+LL |     match_no_arms!(0u8);\n+   |                    ^^^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n \n-error[E0004]: non-exhaustive patterns: type `NonEmptyStruct` is non-empty\n-  --> $DIR/empty-match.rs:92:18\n+error[E0004]: non-exhaustive patterns: type `NonEmptyStruct1` is non-empty\n+  --> $DIR/empty-match.rs:79:20\n    |\n-LL | struct NonEmptyStruct(bool);\n-   | ---------------------------- `NonEmptyStruct` defined here\n+LL | struct NonEmptyStruct1;\n+   | ----------------------- `NonEmptyStruct1` defined here\n ...\n-LL |     match_empty!(NonEmptyStruct(true));\n-   |                  ^^^^^^^^^^^^^^^^^^^^\n+LL |     match_no_arms!(NonEmptyStruct1);\n+   |                    ^^^^^^^^^^^^^^^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n-   = note: the matched value is of type `NonEmptyStruct`\n+   = note: the matched value is of type `NonEmptyStruct1`\n+\n+error[E0004]: non-exhaustive patterns: type `NonEmptyStruct2` is non-empty\n+  --> $DIR/empty-match.rs:80:20\n+   |\n+LL | struct NonEmptyStruct2(bool);\n+   | ----------------------------- `NonEmptyStruct2` defined here\n+...\n+LL |     match_no_arms!(NonEmptyStruct2(true));\n+   |                    ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NonEmptyStruct2`\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyUnion1` is non-empty\n-  --> $DIR/empty-match.rs:94:18\n+  --> $DIR/empty-match.rs:81:20\n    |\n LL | / union NonEmptyUnion1 {\n LL | |     foo: (),\n LL | | }\n    | |_- `NonEmptyUnion1` defined here\n ...\n-LL |       match_empty!((NonEmptyUnion1 { foo: () }));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |       match_no_arms!((NonEmptyUnion1 { foo: () }));\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyUnion1`\n \n error[E0004]: non-exhaustive patterns: type `NonEmptyUnion2` is non-empty\n-  --> $DIR/empty-match.rs:96:18\n+  --> $DIR/empty-match.rs:82:20\n    |\n LL | / union NonEmptyUnion2 {\n LL | |     foo: (),\n LL | |     bar: (),\n LL | | }\n    | |_- `NonEmptyUnion2` defined here\n ...\n-LL |       match_empty!((NonEmptyUnion2 { foo: () }));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |       match_no_arms!((NonEmptyUnion2 { foo: () }));\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyUnion2`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n-  --> $DIR/empty-match.rs:98:18\n+  --> $DIR/empty-match.rs:83:20\n    |\n LL | / enum NonEmptyEnum1 {\n LL | |     Foo(bool),\n    | |     --- not covered\n-LL | |\n-LL | |\n LL | | }\n    | |_- `NonEmptyEnum1` defined here\n ...\n-LL |       match_empty!(NonEmptyEnum1::Foo(true));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n+LL |       match_no_arms!(NonEmptyEnum1::Foo(true));\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyEnum1`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n-  --> $DIR/empty-match.rs:100:18\n+  --> $DIR/empty-match.rs:84:20\n    |\n LL | / enum NonEmptyEnum2 {\n LL | |     Foo(bool),\n    | |     --- not covered\n-LL | |\n-LL | |\n LL | |     Bar,\n    | |     --- not covered\n-LL | |\n-LL | |\n LL | | }\n    | |_- `NonEmptyEnum2` defined here\n ...\n-LL |       match_empty!(NonEmptyEnum2::Foo(true));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n+LL |       match_no_arms!(NonEmptyEnum2::Foo(true));\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyEnum2`\n \n error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n-  --> $DIR/empty-match.rs:102:18\n+  --> $DIR/empty-match.rs:85:20\n    |\n LL | / enum NonEmptyEnum5 {\n LL | |     V1, V2, V3, V4, V5,\n LL | | }\n    | |_- `NonEmptyEnum5` defined here\n ...\n-LL |       match_empty!(NonEmptyEnum5::V1);\n-   |                    ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+LL |       match_no_arms!(NonEmptyEnum5::V1);\n+   |                      ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyEnum5`\n \n error[E0004]: non-exhaustive patterns: `_` not covered\n-  --> $DIR/empty-match.rs:105:18\n+  --> $DIR/empty-match.rs:87:24\n    |\n-LL |     match_false!(0u8);\n-   |                  ^^^ pattern `_` not covered\n+LL |     match_guarded_arm!(0u8);\n+   |                        ^^^ pattern `_` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `u8`\n \n-error[E0004]: non-exhaustive patterns: `NonEmptyStruct(_)` not covered\n-  --> $DIR/empty-match.rs:107:18\n+error[E0004]: non-exhaustive patterns: `NonEmptyStruct1` not covered\n+  --> $DIR/empty-match.rs:88:24\n+   |\n+LL | struct NonEmptyStruct1;\n+   | ----------------------- `NonEmptyStruct1` defined here\n+...\n+LL |     match_guarded_arm!(NonEmptyStruct1);\n+   |                        ^^^^^^^^^^^^^^^ pattern `NonEmptyStruct1` not covered\n+   |\n+   = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n+   = note: the matched value is of type `NonEmptyStruct1`\n+\n+error[E0004]: non-exhaustive patterns: `NonEmptyStruct2(_)` not covered\n+  --> $DIR/empty-match.rs:89:24\n    |\n-LL | struct NonEmptyStruct(bool);\n-   | ---------------------------- `NonEmptyStruct` defined here\n+LL | struct NonEmptyStruct2(bool);\n+   | ----------------------------- `NonEmptyStruct2` defined here\n ...\n-LL |     match_false!(NonEmptyStruct(true));\n-   |                  ^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyStruct(_)` not covered\n+LL |     match_guarded_arm!(NonEmptyStruct2(true));\n+   |                        ^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyStruct2(_)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n-   = note: the matched value is of type `NonEmptyStruct`\n+   = note: the matched value is of type `NonEmptyStruct2`\n \n error[E0004]: non-exhaustive patterns: `NonEmptyUnion1 { .. }` not covered\n-  --> $DIR/empty-match.rs:109:18\n+  --> $DIR/empty-match.rs:90:24\n    |\n LL | / union NonEmptyUnion1 {\n LL | |     foo: (),\n LL | | }\n    | |_- `NonEmptyUnion1` defined here\n ...\n-LL |       match_false!((NonEmptyUnion1 { foo: () }));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion1 { .. }` not covered\n+LL |       match_guarded_arm!((NonEmptyUnion1 { foo: () }));\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion1 { .. }` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyUnion1`\n \n error[E0004]: non-exhaustive patterns: `NonEmptyUnion2 { .. }` not covered\n-  --> $DIR/empty-match.rs:111:18\n+  --> $DIR/empty-match.rs:91:24\n    |\n LL | / union NonEmptyUnion2 {\n LL | |     foo: (),\n LL | |     bar: (),\n LL | | }\n    | |_- `NonEmptyUnion2` defined here\n ...\n-LL |       match_false!((NonEmptyUnion2 { foo: () }));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion2 { .. }` not covered\n+LL |       match_guarded_arm!((NonEmptyUnion2 { foo: () }));\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ pattern `NonEmptyUnion2 { .. }` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyUnion2`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` not covered\n-  --> $DIR/empty-match.rs:113:18\n+  --> $DIR/empty-match.rs:92:24\n    |\n LL | / enum NonEmptyEnum1 {\n LL | |     Foo(bool),\n    | |     --- not covered\n-LL | |\n-LL | |\n LL | | }\n    | |_- `NonEmptyEnum1` defined here\n ...\n-LL |       match_false!(NonEmptyEnum1::Foo(true));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n+LL |       match_guarded_arm!(NonEmptyEnum1::Foo(true));\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^ pattern `Foo(_)` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyEnum1`\n \n error[E0004]: non-exhaustive patterns: `Foo(_)` and `Bar` not covered\n-  --> $DIR/empty-match.rs:115:18\n+  --> $DIR/empty-match.rs:93:24\n    |\n LL | / enum NonEmptyEnum2 {\n LL | |     Foo(bool),\n    | |     --- not covered\n-LL | |\n-LL | |\n LL | |     Bar,\n    | |     --- not covered\n-LL | |\n-LL | |\n LL | | }\n    | |_- `NonEmptyEnum2` defined here\n ...\n-LL |       match_false!(NonEmptyEnum2::Foo(true));\n-   |                    ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n+LL |       match_guarded_arm!(NonEmptyEnum2::Foo(true));\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^^^ patterns `Foo(_)` and `Bar` not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyEnum2`\n \n error[E0004]: non-exhaustive patterns: `V1`, `V2`, `V3` and 2 more not covered\n-  --> $DIR/empty-match.rs:117:18\n+  --> $DIR/empty-match.rs:94:24\n    |\n LL | / enum NonEmptyEnum5 {\n LL | |     V1, V2, V3, V4, V5,\n LL | | }\n    | |_- `NonEmptyEnum5` defined here\n ...\n-LL |       match_false!(NonEmptyEnum5::V1);\n-   |                    ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n+LL |       match_guarded_arm!(NonEmptyEnum5::V1);\n+   |                          ^^^^^^^^^^^^^^^^^ patterns `V1`, `V2`, `V3` and 2 more not covered\n    |\n    = help: ensure that all possible cases are being handled, possibly by adding wildcards or more match arms\n    = note: the matched value is of type `NonEmptyEnum5`\n \n-error: aborting due to 20 previous errors\n+error: aborting due to 22 previous errors\n \n For more information about this error, try `rustc --explain E0004`."}, {"sha": "8110ec013d7c1bd7ffc03951f8f764f1337ab770", "filename": "src/test/ui/pattern/usefulness/empty-match.rs", "status": "modified", "additions": 38, "deletions": 62, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/b82f149d08a0afcc17afa54f5bb3c7031babd44a/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b82f149d08a0afcc17afa54f5bb3c7031babd44a/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Fempty-match.rs?ref=b82f149d08a0afcc17afa54f5bb3c7031babd44a", "patch": "@@ -1,5 +1,7 @@\n // aux-build:empty.rs\n // revisions: normal exhaustive_patterns\n+//\n+// This tests a match with no arms on various types.\n #![feature(never_type)]\n #![feature(never_type_fallback)]\n #![cfg_attr(exhaustive_patterns, feature(exhaustive_patterns))]\n@@ -9,44 +11,26 @@ extern crate empty;\n \n enum EmptyEnum {}\n \n-struct NonEmptyStruct(bool); //~ `NonEmptyStruct` defined here\n-union NonEmptyUnion1 { //~ `NonEmptyUnion1` defined here\n+struct NonEmptyStruct1;\n+struct NonEmptyStruct2(bool);\n+union NonEmptyUnion1 {\n     foo: (),\n }\n-union NonEmptyUnion2 { //~ `NonEmptyUnion2` defined here\n+union NonEmptyUnion2 {\n     foo: (),\n     bar: (),\n }\n-enum NonEmptyEnum1 { //~ `NonEmptyEnum1` defined here\n+enum NonEmptyEnum1 {\n     Foo(bool),\n-    //~^ not covered\n-    //~| not covered\n }\n-enum NonEmptyEnum2 { //~ `NonEmptyEnum2` defined here\n+enum NonEmptyEnum2 {\n     Foo(bool),\n-    //~^ not covered\n-    //~| not covered\n     Bar,\n-    //~^ not covered\n-    //~| not covered\n }\n-enum NonEmptyEnum5 { //~ `NonEmptyEnum5` defined here\n+enum NonEmptyEnum5 {\n     V1, V2, V3, V4, V5,\n }\n \n-macro_rules! match_empty {\n-    ($e:expr) => {\n-        match $e {}\n-    };\n-}\n-macro_rules! match_false {\n-    ($e:expr) => {\n-        match $e {\n-            _ if false => {}\n-        }\n-    };\n-}\n-\n fn empty_enum(x: EmptyEnum) {\n     match x {} // ok\n     match x {\n@@ -77,43 +61,35 @@ fn never(x: !) {\n     }\n }\n \n-fn main() {\n-    match None::<!> {\n-        None => {}\n-        Some(_) => {} //[exhaustive_patterns]~ ERROR unreachable pattern\n-    }\n-    match None::<EmptyEnum> {\n-        None => {}\n-        Some(_) => {} //[exhaustive_patterns]~ ERROR unreachable pattern\n-    }\n+macro_rules! match_no_arms {\n+    ($e:expr) => {\n+        match $e {}\n+    };\n+}\n+macro_rules! match_guarded_arm {\n+    ($e:expr) => {\n+        match $e {\n+            _ if false => {}\n+        }\n+    };\n+}\n \n-    match_empty!(0u8);\n-    //~^ ERROR type `u8` is non-empty\n-    match_empty!(NonEmptyStruct(true));\n-    //~^ ERROR type `NonEmptyStruct` is non-empty\n-    match_empty!((NonEmptyUnion1 { foo: () }));\n-    //~^ ERROR type `NonEmptyUnion1` is non-empty\n-    match_empty!((NonEmptyUnion2 { foo: () }));\n-    //~^ ERROR type `NonEmptyUnion2` is non-empty\n-    match_empty!(NonEmptyEnum1::Foo(true));\n-    //~^ ERROR `Foo(_)` not covered\n-    match_empty!(NonEmptyEnum2::Foo(true));\n-    //~^ ERROR `Foo(_)` and `Bar` not covered\n-    match_empty!(NonEmptyEnum5::V1);\n-    //~^ ERROR `V1`, `V2`, `V3` and 2 more not covered\n+fn main() {\n+    match_no_arms!(0u8); //~ ERROR type `u8` is non-empty\n+    match_no_arms!(NonEmptyStruct1); //~ ERROR type `NonEmptyStruct1` is non-empty\n+    match_no_arms!(NonEmptyStruct2(true)); //~ ERROR type `NonEmptyStruct2` is non-empty\n+    match_no_arms!((NonEmptyUnion1 { foo: () })); //~ ERROR type `NonEmptyUnion1` is non-empty\n+    match_no_arms!((NonEmptyUnion2 { foo: () })); //~ ERROR type `NonEmptyUnion2` is non-empty\n+    match_no_arms!(NonEmptyEnum1::Foo(true)); //~ ERROR `Foo(_)` not covered\n+    match_no_arms!(NonEmptyEnum2::Foo(true)); //~ ERROR `Foo(_)` and `Bar` not covered\n+    match_no_arms!(NonEmptyEnum5::V1); //~ ERROR `V1`, `V2`, `V3` and 2 more not covered\n \n-    match_false!(0u8);\n-    //~^ ERROR `_` not covered\n-    match_false!(NonEmptyStruct(true));\n-    //~^ ERROR `NonEmptyStruct(_)` not covered\n-    match_false!((NonEmptyUnion1 { foo: () }));\n-    //~^ ERROR `NonEmptyUnion1 { .. }` not covered\n-    match_false!((NonEmptyUnion2 { foo: () }));\n-    //~^ ERROR `NonEmptyUnion2 { .. }` not covered\n-    match_false!(NonEmptyEnum1::Foo(true));\n-    //~^ ERROR `Foo(_)` not covered\n-    match_false!(NonEmptyEnum2::Foo(true));\n-    //~^ ERROR `Foo(_)` and `Bar` not covered\n-    match_false!(NonEmptyEnum5::V1);\n-    //~^ ERROR `V1`, `V2`, `V3` and 2 more not covered\n+    match_guarded_arm!(0u8); //~ ERROR `_` not covered\n+    match_guarded_arm!(NonEmptyStruct1); //~ ERROR `NonEmptyStruct1` not covered\n+    match_guarded_arm!(NonEmptyStruct2(true)); //~ ERROR `NonEmptyStruct2(_)` not covered\n+    match_guarded_arm!((NonEmptyUnion1 { foo: () })); //~ ERROR `NonEmptyUnion1 { .. }` not covered\n+    match_guarded_arm!((NonEmptyUnion2 { foo: () })); //~ ERROR `NonEmptyUnion2 { .. }` not covered\n+    match_guarded_arm!(NonEmptyEnum1::Foo(true)); //~ ERROR `Foo(_)` not covered\n+    match_guarded_arm!(NonEmptyEnum2::Foo(true)); //~ ERROR `Foo(_)` and `Bar` not covered\n+    match_guarded_arm!(NonEmptyEnum5::V1); //~ ERROR `V1`, `V2`, `V3` and 2 more not covered\n }"}, {"sha": "77cd0f4005e95426cb21496f8589eff4485bec98", "filename": "src/test/ui/pattern/usefulness/uninhabited.rs", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/b82f149d08a0afcc17afa54f5bb3c7031babd44a/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Funinhabited.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b82f149d08a0afcc17afa54f5bb3c7031babd44a/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Funinhabited.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fusefulness%2Funinhabited.rs?ref=b82f149d08a0afcc17afa54f5bb3c7031babd44a", "patch": "@@ -0,0 +1,143 @@\n+// check-pass\n+// aux-build:empty.rs\n+//\n+// This tests plays with matching and uninhabited types. This also serves as a test for the\n+// `tcx.is_ty_uninhabited_from()` function.\n+#![feature(never_type)]\n+#![feature(never_type_fallback)]\n+#![feature(exhaustive_patterns)]\n+#![deny(unreachable_patterns)]\n+\n+macro_rules! assert_empty {\n+    ($ty:ty) => {\n+        const _: () = {\n+            fn assert_empty(x: $ty) {\n+                match x {}\n+                match Some(x) {\n+                    None => {}\n+                }\n+            }\n+        };\n+    };\n+}\n+macro_rules! assert_non_empty {\n+    ($ty:ty) => {\n+        const _: () = {\n+            fn assert_non_empty(x: $ty) {\n+                match x {\n+                    _ => {}\n+                }\n+                match Some(x) {\n+                    None => {}\n+                    Some(_) => {}\n+                }\n+            }\n+        };\n+    };\n+}\n+\n+extern crate empty;\n+assert_empty!(empty::EmptyForeignEnum);\n+assert_empty!(empty::VisiblyUninhabitedForeignStruct);\n+assert_non_empty!(empty::SecretlyUninhabitedForeignStruct);\n+\n+enum Void {}\n+assert_empty!(Void);\n+\n+enum Enum2 {\n+    Foo(Void),\n+    Bar(!),\n+}\n+assert_empty!(Enum2);\n+\n+enum Enum3 {\n+    Foo(Void),\n+    Bar {\n+        x: u64,\n+        y: !,\n+    },\n+}\n+assert_empty!(Enum3);\n+\n+enum Enum4 {\n+    Foo(u64),\n+    Bar(!),\n+}\n+assert_non_empty!(Enum4);\n+\n+struct Struct1(empty::EmptyForeignEnum);\n+assert_empty!(Struct1);\n+\n+struct Struct2 {\n+    x: u64,\n+    y: !,\n+}\n+assert_empty!(Struct2);\n+\n+union Union {\n+    foo: !,\n+}\n+assert_non_empty!(Union);\n+\n+assert_empty!((!, String));\n+\n+assert_non_empty!(&'static !);\n+assert_non_empty!(&'static Struct1);\n+assert_non_empty!(&'static &'static &'static !);\n+\n+assert_empty!([!; 1]);\n+assert_empty!([Void; 2]);\n+assert_non_empty!([!; 0]);\n+assert_non_empty!(&'static [!]);\n+\n+mod visibility {\n+    /// This struct can only be seen to be inhabited in modules `b`, `c` or `d`, because otherwise\n+    /// the uninhabitedness of both `SecretlyUninhabited` structs is hidden.\n+    struct SometimesEmptyStruct {\n+        x: a::b::SecretlyUninhabited,\n+        y: c::AlsoSecretlyUninhabited,\n+    }\n+\n+    /// This enum can only be seen to be inhabited in module `d`.\n+    enum SometimesEmptyEnum {\n+        X(c::AlsoSecretlyUninhabited),\n+        Y(c::d::VerySecretlyUninhabited),\n+    }\n+\n+    mod a {\n+        use super::*;\n+        pub mod b {\n+            use super::*;\n+            pub struct SecretlyUninhabited {\n+                _priv: !,\n+            }\n+            assert_empty!(SometimesEmptyStruct);\n+        }\n+\n+        assert_non_empty!(SometimesEmptyStruct);\n+        assert_non_empty!(SometimesEmptyEnum);\n+    }\n+\n+    mod c {\n+        use super::*;\n+        pub struct AlsoSecretlyUninhabited {\n+            _priv: ::Struct1,\n+        }\n+        assert_empty!(SometimesEmptyStruct);\n+        assert_non_empty!(SometimesEmptyEnum);\n+\n+        pub mod d {\n+            use super::*;\n+            pub struct VerySecretlyUninhabited {\n+                _priv: !,\n+            }\n+            assert_empty!(SometimesEmptyStruct);\n+            assert_empty!(SometimesEmptyEnum);\n+        }\n+    }\n+\n+    assert_non_empty!(SometimesEmptyStruct);\n+    assert_non_empty!(SometimesEmptyEnum);\n+}\n+\n+fn main() {}"}]}