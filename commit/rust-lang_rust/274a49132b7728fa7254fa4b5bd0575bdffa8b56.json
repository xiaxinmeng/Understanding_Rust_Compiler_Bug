{"sha": "274a49132b7728fa7254fa4b5bd0575bdffa8b56", "node_id": "C_kwDOAAsO6NoAKDI3NGE0OTEzMmI3NzI4ZmE3MjU0ZmE0YjViZDA1NzViZGZmYThiNTY", "commit": {"author": {"name": "Jannis Christopher K\u00f6hl", "email": "mail@koehl.dev", "date": "2022-10-19T13:56:58Z"}, "committer": {"name": "Jannis Christopher K\u00f6hl", "email": "mail@koehl.dev", "date": "2022-11-07T09:35:23Z"}, "message": "Improve documentation, plus some small changes", "tree": {"sha": "7e1728e8add8640519097978cd75413c354f8af7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e1728e8add8640519097978cd75413c354f8af7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/274a49132b7728fa7254fa4b5bd0575bdffa8b56", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/274a49132b7728fa7254fa4b5bd0575bdffa8b56", "html_url": "https://github.com/rust-lang/rust/commit/274a49132b7728fa7254fa4b5bd0575bdffa8b56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/274a49132b7728fa7254fa4b5bd0575bdffa8b56/comments", "author": {"login": "jachris", "id": 30163784, "node_id": "MDQ6VXNlcjMwMTYzNzg0", "avatar_url": "https://avatars.githubusercontent.com/u/30163784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jachris", "html_url": "https://github.com/jachris", "followers_url": "https://api.github.com/users/jachris/followers", "following_url": "https://api.github.com/users/jachris/following{/other_user}", "gists_url": "https://api.github.com/users/jachris/gists{/gist_id}", "starred_url": "https://api.github.com/users/jachris/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jachris/subscriptions", "organizations_url": "https://api.github.com/users/jachris/orgs", "repos_url": "https://api.github.com/users/jachris/repos", "events_url": "https://api.github.com/users/jachris/events{/privacy}", "received_events_url": "https://api.github.com/users/jachris/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jachris", "id": 30163784, "node_id": "MDQ6VXNlcjMwMTYzNzg0", "avatar_url": "https://avatars.githubusercontent.com/u/30163784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jachris", "html_url": "https://github.com/jachris", "followers_url": "https://api.github.com/users/jachris/followers", "following_url": "https://api.github.com/users/jachris/following{/other_user}", "gists_url": "https://api.github.com/users/jachris/gists{/gist_id}", "starred_url": "https://api.github.com/users/jachris/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jachris/subscriptions", "organizations_url": "https://api.github.com/users/jachris/orgs", "repos_url": "https://api.github.com/users/jachris/repos", "events_url": "https://api.github.com/users/jachris/events{/privacy}", "received_events_url": "https://api.github.com/users/jachris/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "931d99f61f93e244a60fb0a65198382ef9d66a75", "url": "https://api.github.com/repos/rust-lang/rust/commits/931d99f61f93e244a60fb0a65198382ef9d66a75", "html_url": "https://github.com/rust-lang/rust/commit/931d99f61f93e244a60fb0a65198382ef9d66a75"}], "stats": {"total": 232, "additions": 143, "deletions": 89}, "files": [{"sha": "4f092d36103fb262cfb6880bf53049b18d5a8c16", "filename": "compiler/rustc_mir_dataflow/src/value_analysis.rs", "status": "modified", "additions": 126, "deletions": 76, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/274a49132b7728fa7254fa4b5bd0575bdffa8b56/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/274a49132b7728fa7254fa4b5bd0575bdffa8b56/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fvalue_analysis.rs?ref=274a49132b7728fa7254fa4b5bd0575bdffa8b56", "patch": "@@ -192,13 +192,27 @@ pub trait ValueAnalysis<'tcx> {\n                 .map(ValueOrPlaceOrRef::Ref)\n                 .unwrap_or(ValueOrPlaceOrRef::top()),\n             Rvalue::Ref(_, _, place) | Rvalue::AddressOf(_, place) => {\n+                // This is not a `&x` reference and could be used for modification.\n                 state.flood(place.as_ref(), self.map());\n                 ValueOrPlaceOrRef::top()\n             }\n             Rvalue::CopyForDeref(place) => {\n                 self.handle_operand(&Operand::Copy(*place), state).into()\n             }\n-            _ => ValueOrPlaceOrRef::top(),\n+            Rvalue::Repeat(..)\n+            | Rvalue::ThreadLocalRef(..)\n+            | Rvalue::Len(..)\n+            | Rvalue::Cast(..)\n+            | Rvalue::BinaryOp(..)\n+            | Rvalue::CheckedBinaryOp(..)\n+            | Rvalue::NullaryOp(..)\n+            | Rvalue::UnaryOp(..)\n+            | Rvalue::Discriminant(..)\n+            | Rvalue::Aggregate(..)\n+            | Rvalue::ShallowInitBox(..) => {\n+                // No modification is possible through these r-values.\n+                ValueOrPlaceOrRef::top()\n+            }\n         }\n     }\n \n@@ -419,7 +433,7 @@ enum StateData<V> {\n #[derive(PartialEq, Eq, Clone, Debug)]\n pub struct State<V>(StateData<V>);\n \n-impl<V: Clone + HasTop> State<V> {\n+impl<V: Clone + HasTop + HasBottom> State<V> {\n     pub fn is_reachable(&self) -> bool {\n         matches!(&self.0, StateData::Reachable(_))\n     }\n@@ -460,6 +474,10 @@ impl<V: Clone + HasTop> State<V> {\n         self.flood_idx_with(place, map, V::top())\n     }\n \n+    /// Copies `source` to `target`, including all tracked places beneath.\n+    ///\n+    /// If `target` contains a place that is not contained in `source`, it will be overwritten with\n+    /// Top. Also, because this will copy all entries one after another, it may only be\n     pub fn assign_place_idx(&mut self, target: PlaceIndex, source: PlaceIndex, map: &Map) {\n         // We use (A3) and copy all entries one after another.\n         let StateData::Reachable(values) = &mut self.0 else { return };\n@@ -514,7 +532,7 @@ impl<V: Clone + HasTop> State<V> {\n                 // track *what* it points to (as in, what do we know about the target). For an\n                 // assignment `x = &y`, we thus copy the info we have for `y` to `*x`. This is\n                 // sound because we only track places that are `Freeze`, and (A4).\n-                if let Some(target_deref) = map.apply_elem(target, ProjElem::Deref) {\n+                if let Some(target_deref) = map.apply(target, TrackElem::Deref) {\n                     self.assign_place_idx(target_deref, source, map);\n                 }\n             }\n@@ -530,7 +548,10 @@ impl<V: Clone + HasTop> State<V> {\n             StateData::Reachable(values) => {\n                 map.places[place].value_index.map(|v| values[v].clone()).unwrap_or(V::top())\n             }\n-            StateData::Unreachable => V::top(),\n+            StateData::Unreachable => {\n+                // Because this is unreachable, we can return any value we want.\n+                V::bottom()\n+            }\n         }\n     }\n }\n@@ -548,10 +569,15 @@ impl<V: JoinSemiLattice + Clone> JoinSemiLattice for State<V> {\n     }\n }\n \n+/// A partial mapping from `Place` to `PlaceIndex`.\n+///\n+/// Some additioanl bookkeeping is done to speed up traversal:\n+/// - For iteration, every [`PlaceInfo`] contains an intrusive linked list of its children.\n+/// - To directly get the child for a specific projection, there is `projections` map.\n #[derive(Debug)]\n pub struct Map {\n     locals: IndexVec<Local, Option<PlaceIndex>>,\n-    projections: FxHashMap<(PlaceIndex, ProjElem), PlaceIndex>,\n+    projections: FxHashMap<(PlaceIndex, TrackElem), PlaceIndex>,\n     places: IndexVec<PlaceIndex, PlaceInfo>,\n     value_count: usize,\n }\n@@ -566,7 +592,10 @@ impl Map {\n         }\n     }\n \n-    /// Register all suitable places with matching types (up to a certain depth).\n+    /// Returns a map that only tracks places whose type passes the filter.\n+    ///\n+    /// This is currently the only way to create a [`Map`]. The way in which the tracked places are\n+    /// chosen is an implementation detail an may not be relied upon.\n     pub fn from_filter<'tcx>(\n         tcx: TyCtxt<'tcx>,\n         body: &Body<'tcx>,\n@@ -579,14 +608,17 @@ impl Map {\n         // the correctness relies on an aliasing model similar to Stacked Borrows (which is\n         // not yet guaranteed).\n         if tcx.sess.opts.unstable_opts.unsound_mir_opts {\n-            map.register_with_filter(tcx, body, 3, filter, &[]);\n+            // We might want to add additional limitations. If a struct has 10 boxed fields of\n+            // itself, will currently be `10.pow(max_derefs)` tracked places.\n+            map.register_with_filter(tcx, body, 2, filter, &[]);\n         } else {\n             map.register_with_filter(tcx, body, 0, filter, &escaped_places(body));\n         }\n \n         map\n     }\n \n+    /// Register all non-excluded places that pass the filter, up to a certain dereference depth.\n     fn register_with_filter<'tcx>(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n@@ -595,7 +627,9 @@ impl Map {\n         mut filter: impl FnMut(Ty<'tcx>) -> bool,\n         exclude: &[Place<'tcx>],\n     ) {\n+        // This is used to tell whether a type is `!Freeze`.\n         let param_env = tcx.param_env_reveal_all_normalized(body.source.def_id());\n+\n         let mut projection = Vec::new();\n         for (local, decl) in body.local_decls.iter_enumerated() {\n             self.register_with_filter_rec(\n@@ -622,7 +656,7 @@ impl Map {\n         param_env: ty::ParamEnv<'tcx>,\n         exclude: &[Place<'tcx>],\n     ) {\n-        // This check could be improved.\n+        // This currently does a linear scan, could be improved.\n         if exclude.contains(&Place { local, projection: tcx.intern_place_elems(projection) }) {\n             return;\n         }\n@@ -664,6 +698,9 @@ impl Map {\n         });\n     }\n \n+    /// Tries to add the place to the map, without allocating a value slot.\n+    ///\n+    /// Can fail if the projection contains non-trackable elements.\n     fn make_place<'tcx>(\n         &mut self,\n         local: Local,\n@@ -675,10 +712,6 @@ impl Map {\n \n         // Apply the projection.\n         for &elem in projection {\n-            match elem {\n-                PlaceElem::Downcast(..) => return Err(()),\n-                _ => (),\n-            }\n             let elem = elem.try_into()?;\n             index = *self.projections.entry((index, elem)).or_insert_with(|| {\n                 // Prepend new child to the linked list.\n@@ -713,6 +746,7 @@ impl Map {\n         self.register_with_ty(local, projection, place_ty.ty)\n     }\n \n+    /// Tries to track the given place. Fails if type is non-scalar or projection is not trackable.\n     fn register_with_ty<'tcx>(\n         &mut self,\n         local: Local,\n@@ -736,20 +770,21 @@ impl Map {\n         Ok(())\n     }\n \n-    pub fn apply_elem(&self, place: PlaceIndex, elem: ProjElem) -> Option<PlaceIndex> {\n+    pub fn apply(&self, place: PlaceIndex, elem: TrackElem) -> Option<PlaceIndex> {\n         self.projections.get(&(place, elem)).copied()\n     }\n \n     pub fn find(&self, place: PlaceRef<'_>) -> Option<PlaceIndex> {\n         let mut index = *self.locals.get(place.local)?.as_ref()?;\n \n         for &elem in place.projection {\n-            index = self.apply_elem(index, elem.try_into().ok()?)?;\n+            index = self.apply(index, elem.try_into().ok()?)?;\n         }\n \n         Some(index)\n     }\n \n+    /// Iterate over all direct children.\n     pub fn children(&self, parent: PlaceIndex) -> impl Iterator<Item = PlaceIndex> + '_ {\n         Children::new(self, parent)\n     }\n@@ -762,40 +797,31 @@ impl Map {\n     }\n }\n \n+/// This is the information tracked for every [`PlaceIndex`] and is stored by [`Map`].\n+///\n+/// Together, `first_child` and `next_sibling` form an intrusive linked list, which is used to\n+/// model a tree structure (a replacement for a member like `children: Vec<PlaceIndex>`).\n #[derive(Debug)]\n struct PlaceInfo {\n-    next_sibling: Option<PlaceIndex>,\n-    first_child: Option<PlaceIndex>,\n-    /// The projection used to go from parent to this node (only None for root).\n-    proj_elem: Option<ProjElem>,\n+    /// We store a [`ValueIndex`] if and only if the placed is tracked by the analysis.\n     value_index: Option<ValueIndex>,\n+\n+    /// The projection used to go from parent to this node (only None for root).\n+    proj_elem: Option<TrackElem>,\n+\n+    /// The left-most child.\n+    first_child: Option<PlaceIndex>,\n+\n+    /// Index of the sibling to the right of this node.\n+    next_sibling: Option<PlaceIndex>,\n }\n \n impl PlaceInfo {\n-    fn new(proj_elem: Option<ProjElem>) -> Self {\n+    fn new(proj_elem: Option<TrackElem>) -> Self {\n         Self { next_sibling: None, first_child: None, proj_elem, value_index: None }\n     }\n }\n \n-/// Returns all places, that have their reference or address taken.\n-fn escaped_places<'tcx>(body: &Body<'tcx>) -> Vec<Place<'tcx>> {\n-    struct Collector<'tcx> {\n-        result: Vec<Place<'tcx>>,\n-    }\n-\n-    impl<'tcx> Visitor<'tcx> for Collector<'tcx> {\n-        fn visit_place(&mut self, place: &Place<'tcx>, context: PlaceContext, _location: Location) {\n-            if context.is_borrow() || context.is_address_of() {\n-                self.result.push(*place);\n-            }\n-        }\n-    }\n-\n-    let mut collector = Collector { result: Vec::new() };\n-    collector.visit_body(body);\n-    collector.result\n-}\n-\n struct Children<'a> {\n     map: &'a Map,\n     next: Option<PlaceIndex>,\n@@ -820,25 +846,28 @@ impl<'a> Iterator for Children<'a> {\n         }\n     }\n }\n+\n+/// Used as the result of an operand.\n pub enum ValueOrPlace<V> {\n     Value(V),\n     Place(PlaceIndex),\n }\n \n-impl<V: HasTop> ValueOrPlace<V> {\n-    pub fn top() -> Self {\n+impl<V: HasTop> HasTop for ValueOrPlace<V> {\n+    fn top() -> Self {\n         ValueOrPlace::Value(V::top())\n     }\n }\n \n+/// Used as the result of an r-value.\n pub enum ValueOrPlaceOrRef<V> {\n     Value(V),\n     Place(PlaceIndex),\n     Ref(PlaceIndex),\n }\n \n-impl<V: HasTop> ValueOrPlaceOrRef<V> {\n-    pub fn top() -> Self {\n+impl<V: HasTop> HasTop for ValueOrPlaceOrRef<V> {\n+    fn top() -> Self {\n         ValueOrPlaceOrRef::Value(V::top())\n     }\n }\n@@ -872,27 +901,28 @@ impl<V> HasTop for FlatSet<V> {\n     }\n }\n \n-/// Currently, we only track places through deref and field projections.\n+/// The set of projection elements that can be used by a tracked place.\n ///\n /// For now, downcast is not allowed due to aliasing between variants (see #101168).\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum ProjElem {\n+pub enum TrackElem {\n     Deref,\n     Field(Field),\n }\n \n-impl<V, T> TryFrom<ProjectionElem<V, T>> for ProjElem {\n+impl<V, T> TryFrom<ProjectionElem<V, T>> for TrackElem {\n     type Error = ();\n \n     fn try_from(value: ProjectionElem<V, T>) -> Result<Self, Self::Error> {\n         match value {\n-            ProjectionElem::Deref => Ok(ProjElem::Deref),\n-            ProjectionElem::Field(field, _) => Ok(ProjElem::Field(field)),\n+            ProjectionElem::Deref => Ok(TrackElem::Deref),\n+            ProjectionElem::Field(field, _) => Ok(TrackElem::Field(field)),\n             _ => Err(()),\n         }\n     }\n }\n \n+/// Invokes `f` on all direct fields of `ty`.\n fn iter_fields<'tcx>(\n     ty: Ty<'tcx>,\n     tcx: TyCtxt<'tcx>,\n@@ -922,6 +952,53 @@ fn iter_fields<'tcx>(\n     }\n }\n \n+/// Returns all places, that have their reference or address taken.\n+fn escaped_places<'tcx>(body: &Body<'tcx>) -> Vec<Place<'tcx>> {\n+    struct Collector<'tcx> {\n+        result: Vec<Place<'tcx>>,\n+    }\n+\n+    impl<'tcx> Visitor<'tcx> for Collector<'tcx> {\n+        fn visit_place(&mut self, place: &Place<'tcx>, context: PlaceContext, _location: Location) {\n+            if context.is_borrow() || context.is_address_of() {\n+                self.result.push(*place);\n+            }\n+        }\n+    }\n+\n+    let mut collector = Collector { result: Vec::new() };\n+    collector.visit_body(body);\n+    collector.result\n+}\n+\n+/// This is used to visualize the dataflow analysis.\n+impl<'tcx, T> DebugWithContext<ValueAnalysisWrapper<T>> for State<T::Value>\n+where\n+    T: ValueAnalysis<'tcx>,\n+    T::Value: Debug,\n+{\n+    fn fmt_with(&self, ctxt: &ValueAnalysisWrapper<T>, f: &mut Formatter<'_>) -> std::fmt::Result {\n+        match &self.0 {\n+            StateData::Reachable(values) => debug_with_context(values, None, ctxt.0.map(), f),\n+            StateData::Unreachable => write!(f, \"unreachable\"),\n+        }\n+    }\n+\n+    fn fmt_diff_with(\n+        &self,\n+        old: &Self,\n+        ctxt: &ValueAnalysisWrapper<T>,\n+        f: &mut Formatter<'_>,\n+    ) -> std::fmt::Result {\n+        match (&self.0, &old.0) {\n+            (StateData::Reachable(this), StateData::Reachable(old)) => {\n+                debug_with_context(this, Some(old), ctxt.0.map(), f)\n+            }\n+            _ => Ok(()), // Consider printing something here.\n+        }\n+    }\n+}\n+\n fn debug_with_context_rec<V: Debug + Eq>(\n     place: PlaceIndex,\n     place_str: &str,\n@@ -945,8 +1022,8 @@ fn debug_with_context_rec<V: Debug + Eq>(\n     for child in map.children(place) {\n         let info_elem = map.places[child].proj_elem.unwrap();\n         let child_place_str = match info_elem {\n-            ProjElem::Deref => format!(\"*{}\", place_str),\n-            ProjElem::Field(field) => {\n+            TrackElem::Deref => format!(\"*{}\", place_str),\n+            TrackElem::Field(field) => {\n                 if place_str.starts_with(\"*\") {\n                     format!(\"({}).{}\", place_str, field.index())\n                 } else {\n@@ -973,30 +1050,3 @@ fn debug_with_context<V: Debug + Eq>(\n     }\n     Ok(())\n }\n-\n-impl<'tcx, T> DebugWithContext<ValueAnalysisWrapper<T>> for State<T::Value>\n-where\n-    T: ValueAnalysis<'tcx>,\n-    T::Value: Debug,\n-{\n-    fn fmt_with(&self, ctxt: &ValueAnalysisWrapper<T>, f: &mut Formatter<'_>) -> std::fmt::Result {\n-        match &self.0 {\n-            StateData::Reachable(values) => debug_with_context(values, None, ctxt.0.map(), f),\n-            StateData::Unreachable => write!(f, \"unreachable\"),\n-        }\n-    }\n-\n-    fn fmt_diff_with(\n-        &self,\n-        old: &Self,\n-        ctxt: &ValueAnalysisWrapper<T>,\n-        f: &mut Formatter<'_>,\n-    ) -> std::fmt::Result {\n-        match (&self.0, &old.0) {\n-            (StateData::Reachable(this), StateData::Reachable(old)) => {\n-                debug_with_context(this, Some(old), ctxt.0.map(), f)\n-            }\n-            _ => Ok(()), // Consider printing something here.\n-        }\n-    }\n-}"}, {"sha": "75d9ea16bd60cbfbe96ec8967b3a4ad3cbe83b23", "filename": "compiler/rustc_mir_transform/src/dataflow_const_prop.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/274a49132b7728fa7254fa4b5bd0575bdffa8b56/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/274a49132b7728fa7254fa4b5bd0575bdffa8b56/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdataflow_const_prop.rs?ref=274a49132b7728fa7254fa4b5bd0575bdffa8b56", "patch": "@@ -1,10 +1,14 @@\n+//! A constant propagation optimization pass based on dataflow analysis.\n+//!\n+//! Tracks places that have a scalar type.\n+\n use rustc_const_eval::interpret::{ConstValue, ImmTy, Immediate, InterpCx, Scalar};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::mir::visit::{MutVisitor, Visitor};\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_mir_dataflow::value_analysis::{\n-    Map, ProjElem, State, ValueAnalysis, ValueOrPlace, ValueOrPlaceOrRef,\n+    HasTop, Map, State, TrackElem, ValueAnalysis, ValueOrPlace, ValueOrPlaceOrRef,\n };\n use rustc_mir_dataflow::{lattice::FlatSet, Analysis, ResultsVisitor, SwitchIntEdgeEffects};\n use rustc_span::{sym, DUMMY_SP};\n@@ -20,7 +24,7 @@ impl<'tcx> MirPass<'tcx> for DataflowConstProp {\n \n     fn run_pass(&self, tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         // Decide which places to track during the analysis.\n-        let map = Map::from_filter(tcx, body, |ty| ty.is_scalar() && !ty.is_unsafe_ptr());\n+        let map = Map::from_filter(tcx, body, Ty::is_scalar);\n \n         // Perform the actual dataflow analysis.\n         let analysis = ConstAnalysis::new(tcx, body, map);\n@@ -65,12 +69,10 @@ impl<'tcx> ValueAnalysis<'tcx> for ConstAnalysis<'tcx> {\n                     state.flood_idx(target, self.map());\n                 }\n \n-                let value_target = target.and_then(|target| {\n-                    self.map().apply_elem(target, ProjElem::Field(0_u32.into()))\n-                });\n-                let overflow_target = target.and_then(|target| {\n-                    self.map().apply_elem(target, ProjElem::Field(1_u32.into()))\n-                });\n+                let value_target = target\n+                    .and_then(|target| self.map().apply(target, TrackElem::Field(0_u32.into())));\n+                let overflow_target = target\n+                    .and_then(|target| self.map().apply(target, TrackElem::Field(1_u32.into())));\n \n                 if value_target.is_some() || overflow_target.is_some() {\n                     let (val, overflow) = self.binary_op(state, *op, left, right);\n@@ -211,6 +213,7 @@ struct ScalarTy<'tcx>(Scalar, Ty<'tcx>);\n \n impl<'tcx> std::fmt::Debug for ScalarTy<'tcx> {\n     fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        // This is used for dataflow visualization, so we return something more concise.\n         std::fmt::Display::fmt(&ConstantKind::Val(ConstValue::Scalar(self.0), self.1), f)\n     }\n }\n@@ -341,13 +344,16 @@ impl<'mir, 'tcx, 'map> ResultsVisitor<'mir, 'tcx> for CollectAndPatch<'tcx, 'map\n         location: Location,\n     ) {\n         match statement.kind {\n+            StatementKind::Assign(box (_, Rvalue::Use(Operand::Constant(_)))) => {\n+                // Don't overwrite the assignment if it already uses a constant (to keep the span).\n+            }\n             StatementKind::Assign(box (place, _)) => match state.get(place.as_ref(), self.map) {\n                 FlatSet::Top => (),\n                 FlatSet::Elem(value) => {\n                     self.assignments.insert(location, value);\n                 }\n                 FlatSet::Bottom => {\n-                    // This statement is not reachable. Do nothing, it will (hopefully) be removed.\n+                    // This assignment is either unreachable, or an uninitialized value is assigned.\n                 }\n             },\n             _ => (),"}, {"sha": "944afed8f465abd701e2c10dc3f59997cfc1364e", "filename": "src/test/mir-opt/dataflow-const-prop/checked.main.DataflowConstProp.diff", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/274a49132b7728fa7254fa4b5bd0575bdffa8b56/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fchecked.main.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/274a49132b7728fa7254fa4b5bd0575bdffa8b56/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fchecked.main.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fchecked.main.DataflowConstProp.diff?ref=274a49132b7728fa7254fa4b5bd0575bdffa8b56", "patch": "@@ -53,8 +53,7 @@\n           StorageDead(_5);                 // scope 2 at $DIR/checked.rs:+3:17: +3:18\n           StorageDead(_4);                 // scope 2 at $DIR/checked.rs:+3:17: +3:18\n           StorageLive(_7);                 // scope 3 at $DIR/checked.rs:+5:9: +5:10\n--         _7 = const _;                    // scope 3 at $DIR/checked.rs:+5:13: +5:21\n-+         _7 = const i32::MAX;             // scope 3 at $DIR/checked.rs:+5:13: +5:21\n+          _7 = const _;                    // scope 3 at $DIR/checked.rs:+5:13: +5:21\n           StorageLive(_8);                 // scope 4 at $DIR/checked.rs:+6:9: +6:10\n           StorageLive(_9);                 // scope 4 at $DIR/checked.rs:+6:13: +6:14\n -         _9 = _7;                         // scope 4 at $DIR/checked.rs:+6:13: +6:14"}, {"sha": "d990c3b07e5180f3f5a4aea6de2a3c071f8d3573", "filename": "src/test/mir-opt/dataflow-const-prop/previous/control_flow_simplification.hello.DataflowConstProp.diff", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/274a49132b7728fa7254fa4b5bd0575bdffa8b56/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fprevious%2Fcontrol_flow_simplification.hello.DataflowConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/274a49132b7728fa7254fa4b5bd0575bdffa8b56/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fprevious%2Fcontrol_flow_simplification.hello.DataflowConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fdataflow-const-prop%2Fprevious%2Fcontrol_flow_simplification.hello.DataflowConstProp.diff?ref=274a49132b7728fa7254fa4b5bd0575bdffa8b56", "patch": "@@ -8,8 +8,7 @@\n   \n       bb0: {\n           StorageLive(_1);                 // scope 0 at $DIR/control-flow-simplification.rs:+1:8: +1:21\n--         _1 = const _;                    // scope 0 at $DIR/control-flow-simplification.rs:+1:8: +1:21\n-+         _1 = const false;                // scope 0 at $DIR/control-flow-simplification.rs:+1:8: +1:21\n+          _1 = const _;                    // scope 0 at $DIR/control-flow-simplification.rs:+1:8: +1:21\n           switchInt(const false) -> [false: bb2, otherwise: bb1]; // scope 0 at $DIR/control-flow-simplification.rs:+1:8: +1:21\n       }\n   "}]}