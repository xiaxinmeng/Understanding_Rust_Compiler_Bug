{"sha": "e3eede7b905aec5c1bd23fe48444411f012d823a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzZWVkZTdiOTA1YWVjNWMxYmQyM2ZlNDg0NDQ0MTFmMDEyZDgyM2E=", "commit": {"author": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-06-17T08:21:47Z"}, "committer": {"name": "flip1995", "email": "philipp.krones@embecosm.com", "date": "2021-06-17T08:21:47Z"}, "message": "Merge remote-tracking branch 'upstream/master' into rustup", "tree": {"sha": "f4582226b013b7b4c577b18477005316762b65f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f4582226b013b7b4c577b18477005316762b65f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3eede7b905aec5c1bd23fe48444411f012d823a", "comment_count": 0, "verification": {"verified": false, "reason": "bad_email", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEij1UXJ/PQTcb99vTHKDfKvWdaKUFAmDLBjAACgkQHKDfKvWd\naKWSexAAojtaktIxlTPEzVP7ZdbnmhCeXlY4B8XAszNt4KTT6wzT32qZ5crHyoKY\nns4J6wMjOalLToPE9hi5lKlyJwzkm+8qFvOVBLiDmrfnY1IhojIJmMot80ZWSf8b\n9yip0GIRIpPIKsJ1/2qcecsebnFEfC18zhdoHzzL3resWFox95bxk2Zsi4j0Azkn\nkbEiJFd+Znt58zx03WIwXav56JFBt1hPRi1kf8L5jeiLzoP7SpVDig6JUk4WAtIw\nLztv6hxHKjnbBopAV7SYG3vdY+SmeCZawUaI6iEiNAcoN5LUM2iVP3wplaPaosyl\n1ZAEudid+nuAEyg5BbE+lDF99wXVXiuLsjiSYkT30h7jn6NRfo3niPKEuqSblgvH\nzpiqNWVz3zKncjnJXDXjZ5kaDiB1A2EOa9SNYHqc+pvV79iyB2G6H90AR6gLmMpX\nQMYdH11WTMH9+y3uxb3EGOh38xnmKaywKFaETVuAZ+Ub+SkClziBUk6tJrHji7eS\nHQrbZHWTLKYzwgilK4FdSGNlSV/FePJRxZHPQ3VsAq1YS3m8dMt0LZzS9h/TAhq9\nY47g8Ju35edMUASpx/RLXNK6V9pP2nUC+p7PMFH8Bxvwgk+3A/BEsdkxWihHPEZS\nz0yAQKhSuXNVOL7tgUJqprbdHjPI0z6q5dC1gqhQpZDpNoK2A5o=\n=DOqB\n-----END PGP SIGNATURE-----", "payload": "tree f4582226b013b7b4c577b18477005316762b65f8\nparent 611b74e1fe48410c534c5d5a6a0832b810d8ccda\nparent 7c9da3c1e4f22504efbc198d5428ea2ac963b924\nauthor flip1995 <philipp.krones@embecosm.com> 1623918107 +0200\ncommitter flip1995 <philipp.krones@embecosm.com> 1623918107 +0200\n\nMerge remote-tracking branch 'upstream/master' into rustup\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3eede7b905aec5c1bd23fe48444411f012d823a", "html_url": "https://github.com/rust-lang/rust/commit/e3eede7b905aec5c1bd23fe48444411f012d823a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3eede7b905aec5c1bd23fe48444411f012d823a/comments", "author": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flip1995", "id": 9744647, "node_id": "MDQ6VXNlcjk3NDQ2NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/9744647?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flip1995", "html_url": "https://github.com/flip1995", "followers_url": "https://api.github.com/users/flip1995/followers", "following_url": "https://api.github.com/users/flip1995/following{/other_user}", "gists_url": "https://api.github.com/users/flip1995/gists{/gist_id}", "starred_url": "https://api.github.com/users/flip1995/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flip1995/subscriptions", "organizations_url": "https://api.github.com/users/flip1995/orgs", "repos_url": "https://api.github.com/users/flip1995/repos", "events_url": "https://api.github.com/users/flip1995/events{/privacy}", "received_events_url": "https://api.github.com/users/flip1995/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "611b74e1fe48410c534c5d5a6a0832b810d8ccda", "url": "https://api.github.com/repos/rust-lang/rust/commits/611b74e1fe48410c534c5d5a6a0832b810d8ccda", "html_url": "https://github.com/rust-lang/rust/commit/611b74e1fe48410c534c5d5a6a0832b810d8ccda"}, {"sha": "7c9da3c1e4f22504efbc198d5428ea2ac963b924", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c9da3c1e4f22504efbc198d5428ea2ac963b924", "html_url": "https://github.com/rust-lang/rust/commit/7c9da3c1e4f22504efbc198d5428ea2ac963b924"}], "stats": {"total": 1809, "additions": 1182, "deletions": 627}, "files": [{"sha": "ae6f1aa1b30be0c3ae0c57f1e8d163eea13ef41b", "filename": ".github/workflows/clippy_bors.yml", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/.github%2Fworkflows%2Fclippy_bors.yml", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/.github%2Fworkflows%2Fclippy_bors.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2Fworkflows%2Fclippy_bors.yml?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -90,11 +90,6 @@ jobs:\n     - name: Checkout\n       uses: actions/checkout@v2.3.3\n \n-    # FIXME: should not be necessary once 1.24.2 is the default version on the windows runner\n-    - name: Update rustup\n-      run: rustup self update\n-      if: runner.os == 'Windows'\n-\n     - name: Install toolchain\n       run: rustup show active-toolchain\n "}, {"sha": "52d0e8c7cdebb0eb18da69027029b6cdc94d3664", "filename": "CHANGELOG.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -2295,6 +2295,7 @@ Released 2018-09-13\n <!-- begin autogenerated links to lint list -->\n [`absurd_extreme_comparisons`]: https://rust-lang.github.io/rust-clippy/master/index.html#absurd_extreme_comparisons\n [`almost_swapped`]: https://rust-lang.github.io/rust-clippy/master/index.html#almost_swapped\n+[`append_instead_of_extend`]: https://rust-lang.github.io/rust-clippy/master/index.html#append_instead_of_extend\n [`approx_constant`]: https://rust-lang.github.io/rust-clippy/master/index.html#approx_constant\n [`as_conversions`]: https://rust-lang.github.io/rust-clippy/master/index.html#as_conversions\n [`assertions_on_constants`]: https://rust-lang.github.io/rust-clippy/master/index.html#assertions_on_constants\n@@ -2358,6 +2359,7 @@ Released 2018-09-13\n [`derive_hash_xor_eq`]: https://rust-lang.github.io/rust-clippy/master/index.html#derive_hash_xor_eq\n [`derive_ord_xor_partial_ord`]: https://rust-lang.github.io/rust-clippy/master/index.html#derive_ord_xor_partial_ord\n [`disallowed_method`]: https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_method\n+[`disallowed_type`]: https://rust-lang.github.io/rust-clippy/master/index.html#disallowed_type\n [`diverging_sub_expression`]: https://rust-lang.github.io/rust-clippy/master/index.html#diverging_sub_expression\n [`doc_markdown`]: https://rust-lang.github.io/rust-clippy/master/index.html#doc_markdown\n [`double_comparisons`]: https://rust-lang.github.io/rust-clippy/master/index.html#double_comparisons"}, {"sha": "4f7ffdcdfb499ac972c9dbd9eeced0153b492ddc", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 25, "deletions": 45, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -1,15 +1,15 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::match_type;\n-use clippy_utils::{contains_name, get_pat_name, paths, single_segment_path};\n+use clippy_utils::visitors::LocalUsedVisitor;\n+use clippy_utils::{path_to_local_id, paths, peel_ref_operators, remove_blocks, strip_pat_refs};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, BorrowKind, Expr, ExprKind, UnOp};\n+use rustc_hir::{BinOpKind, Expr, ExprKind, PatKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::{self, UintTy};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::sym;\n-use rustc_span::Symbol;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for naive byte counts\n@@ -38,42 +38,43 @@ declare_lint_pass!(ByteCount => [NAIVE_BYTECOUNT]);\n impl<'tcx> LateLintPass<'tcx> for ByteCount {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         if_chain! {\n-            if let ExprKind::MethodCall(count, _, count_args, _) = expr.kind;\n+            if let ExprKind::MethodCall(count, _, [count_recv], _) = expr.kind;\n             if count.ident.name == sym!(count);\n-            if count_args.len() == 1;\n-            if let ExprKind::MethodCall(filter, _, filter_args, _) = count_args[0].kind;\n+            if let ExprKind::MethodCall(filter, _, [filter_recv, filter_arg], _) = count_recv.kind;\n             if filter.ident.name == sym!(filter);\n-            if filter_args.len() == 2;\n-            if let ExprKind::Closure(_, _, body_id, _, _) = filter_args[1].kind;\n+            if let ExprKind::Closure(_, _, body_id, _, _) = filter_arg.kind;\n             let body = cx.tcx.hir().body(body_id);\n-            if body.params.len() == 1;\n-            if let Some(argname) = get_pat_name(body.params[0].pat);\n+            if let [param] = body.params;\n+            if let PatKind::Binding(_, arg_id, _, _) = strip_pat_refs(param.pat).kind;\n             if let ExprKind::Binary(ref op, l, r) = body.value.kind;\n             if op.node == BinOpKind::Eq;\n             if match_type(cx,\n-                       cx.typeck_results().expr_ty(&filter_args[0]).peel_refs(),\n+                       cx.typeck_results().expr_ty(filter_recv).peel_refs(),\n                        &paths::SLICE_ITER);\n+            let operand_is_arg = |expr| {\n+                let expr = peel_ref_operators(cx, remove_blocks(expr));\n+                path_to_local_id(expr, arg_id)\n+            };\n+            let needle = if operand_is_arg(l) {\n+                r\n+            } else if operand_is_arg(r) {\n+                l\n+            } else {\n+                return;\n+            };\n+            if ty::Uint(UintTy::U8) == *cx.typeck_results().expr_ty(needle).peel_refs().kind();\n+            if !LocalUsedVisitor::new(cx, arg_id).check_expr(needle);\n             then {\n-                let needle = match get_path_name(l) {\n-                    Some(name) if check_arg(name, argname, r) => r,\n-                    _ => match get_path_name(r) {\n-                        Some(name) if check_arg(name, argname, l) => l,\n-                        _ => { return; }\n-                    }\n-                };\n-                if ty::Uint(UintTy::U8) != *cx.typeck_results().expr_ty(needle).peel_refs().kind() {\n-                    return;\n-                }\n                 let haystack = if let ExprKind::MethodCall(path, _, args, _) =\n-                        filter_args[0].kind {\n+                        filter_recv.kind {\n                     let p = path.ident.name;\n                     if (p == sym::iter || p == sym!(iter_mut)) && args.len() == 1 {\n                         &args[0]\n                     } else {\n-                        &filter_args[0]\n+                        &filter_recv\n                     }\n                 } else {\n-                    &filter_args[0]\n+                    &filter_recv\n                 };\n                 let mut applicability = Applicability::MaybeIncorrect;\n                 span_lint_and_sugg(\n@@ -91,24 +92,3 @@ impl<'tcx> LateLintPass<'tcx> for ByteCount {\n         };\n     }\n }\n-\n-fn check_arg(name: Symbol, arg: Symbol, needle: &Expr<'_>) -> bool {\n-    name == arg && !contains_name(name, needle)\n-}\n-\n-fn get_path_name(expr: &Expr<'_>) -> Option<Symbol> {\n-    match expr.kind {\n-        ExprKind::Box(e) | ExprKind::AddrOf(BorrowKind::Ref, _, e) | ExprKind::Unary(UnOp::Deref, e) => {\n-            get_path_name(e)\n-        },\n-        ExprKind::Block(b, _) => {\n-            if b.stmts.is_empty() {\n-                b.expr.as_ref().and_then(|p| get_path_name(p))\n-            } else {\n-                None\n-            }\n-        },\n-        ExprKind::Path(ref qpath) => single_segment_path(qpath).map(|ps| ps.ident.name),\n-        _ => None,\n-    }\n-}"}, {"sha": "a6c3a5b0e83c466bc8b98f14e55ca7070a876da1", "filename": "clippy_lints/src/collapsible_match.rs", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_match.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -1,11 +1,10 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::visitors::LocalUsedVisitor;\n-use clippy_utils::{is_lang_ctor, path_to_local, SpanlessEq};\n+use clippy_utils::{is_lang_ctor, path_to_local, peel_ref_operators, SpanlessEq};\n use if_chain::if_chain;\n use rustc_hir::LangItem::OptionNone;\n-use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind, StmtKind, UnOp};\n+use rustc_hir::{Arm, Expr, ExprKind, Guard, HirId, Pat, PatKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::TypeckResults;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{MultiSpan, Span};\n \n@@ -73,7 +72,7 @@ fn check_arm<'tcx>(arm: &Arm<'tcx>, wild_outer_arm: &Arm<'tcx>, cx: &LateContext\n         if arms_inner.iter().all(|arm| arm.guard.is_none());\n         // match expression must be a local binding\n         // match <local> { .. }\n-        if let Some(binding_id) = path_to_local(strip_ref_operators(expr_in, cx.typeck_results()));\n+        if let Some(binding_id) = path_to_local(peel_ref_operators(cx, expr_in));\n         // one of the branches must be \"wild-like\"\n         if let Some(wild_inner_arm_idx) = arms_inner.iter().rposition(|arm_inner| arm_is_wild_like(cx, arm_inner));\n         let (wild_inner_arm, non_wild_inner_arm) =\n@@ -163,16 +162,3 @@ fn pat_contains_or(pat: &Pat<'_>) -> bool {\n     });\n     result\n }\n-\n-/// Removes `AddrOf` operators (`&`) or deref operators (`*`), but only if a reference type is\n-/// dereferenced. An overloaded deref such as `Vec` to slice would not be removed.\n-fn strip_ref_operators<'hir>(mut expr: &'hir Expr<'hir>, typeck_results: &TypeckResults<'_>) -> &'hir Expr<'hir> {\n-    loop {\n-        match expr.kind {\n-            ExprKind::AddrOf(_, _, e) => expr = e,\n-            ExprKind::Unary(UnOp::Deref, e) if typeck_results.expr_ty(e).is_ref() => expr = e,\n-            _ => break,\n-        }\n-    }\n-    expr\n-}"}, {"sha": "947479db8f5d78e77fdc1b6fa60a08357fb609fa", "filename": "clippy_lints/src/default.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -7,7 +7,6 @@ use rustc_errors::Applicability;\n use rustc_hir::def::Res;\n use rustc_hir::{Block, Expr, ExprKind, PatKind, QPath, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::symbol::{Ident, Symbol};\n@@ -122,7 +121,7 @@ impl LateLintPass<'_> for Default {\n                 if let StmtKind::Local(local) = stmt.kind;\n                 if let Some(expr) = local.init;\n                 if !any_parent_is_automatically_derived(cx.tcx, expr.hir_id);\n-                if !in_external_macro(cx.tcx.sess, expr.span);\n+                if !in_macro(expr.span);\n                 // only take bindings to identifiers\n                 if let PatKind::Binding(_, binding_id, ident, _) = local.pat.kind;\n                 // only when assigning `... = Default::default()`"}, {"sha": "a125376bffa9fa405089ba1cc483e3543496aee9", "filename": "clippy_lints/src/default_numeric_fallback.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdefault_numeric_fallback.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -7,9 +7,10 @@ use rustc_hir::{\n     intravisit::{walk_expr, walk_stmt, NestedVisitorMap, Visitor},\n     Body, Expr, ExprKind, HirId, Lit, Stmt, StmtKind,\n };\n-use rustc_lint::{LateContext, LateLintPass};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::{\n     hir::map::Map,\n+    lint::in_external_macro,\n     ty::{self, FloatTy, IntTy, PolyFnSig, Ty},\n };\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -73,6 +74,7 @@ impl<'a, 'tcx> NumericFallbackVisitor<'a, 'tcx> {\n     /// Check whether a passed literal has potential to cause fallback or not.\n     fn check_lit(&self, lit: &Lit, lit_ty: Ty<'tcx>) {\n         if_chain! {\n+                if !in_external_macro(self.cx.sess(), lit.span);\n                 if let Some(ty_bound) = self.ty_bounds.last();\n                 if matches!(lit.node,\n                             LitKind::Int(_, LitIntType::Unsuffixed) | LitKind::Float(_, LitFloatType::Unsuffixed));"}, {"sha": "aa1a609afedc0b91edfac0fbd4e3720d327f423b", "filename": "clippy_lints/src/disallowed_method.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fdisallowed_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fdisallowed_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdisallowed_method.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -2,7 +2,7 @@ use clippy_utils::diagnostics::span_lint;\n use clippy_utils::fn_def_id;\n \n use rustc_data_structures::fx::FxHashSet;\n-use rustc_hir::Expr;\n+use rustc_hir::{def::Res, def_id::DefId, Crate, Expr};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::Symbol;\n@@ -13,21 +13,14 @@ declare_clippy_lint! {\n     /// **Why is this bad?** Some methods are undesirable in certain contexts,\n     /// and it's beneficial to lint for them as needed.\n     ///\n-    /// **Known problems:** Currently, you must write each function as a\n-    /// fully-qualified path. This lint doesn't support aliases or reexported\n-    /// names; be aware that many types in `std` are actually reexports.\n-    ///\n-    /// For example, if you want to disallow `Duration::as_secs`, your clippy.toml\n-    /// configuration would look like\n-    /// `disallowed-methods = [\"core::time::Duration::as_secs\"]` and not\n-    /// `disallowed-methods = [\"std::time::Duration::as_secs\"]` as you might expect.\n+    /// **Known problems:** None.\n     ///\n     /// **Example:**\n     ///\n     /// An example clippy.toml configuration:\n     /// ```toml\n     /// # clippy.toml\n-    /// disallowed-methods = [\"alloc::vec::Vec::leak\", \"std::time::Instant::now\"]\n+    /// disallowed-methods = [\"std::vec::Vec::leak\", \"std::time::Instant::now\"]\n     /// ```\n     ///\n     /// ```rust,ignore\n@@ -52,6 +45,7 @@ declare_clippy_lint! {\n #[derive(Clone, Debug)]\n pub struct DisallowedMethod {\n     disallowed: FxHashSet<Vec<Symbol>>,\n+    def_ids: FxHashSet<(DefId, Vec<Symbol>)>,\n }\n \n impl DisallowedMethod {\n@@ -61,17 +55,28 @@ impl DisallowedMethod {\n                 .iter()\n                 .map(|s| s.split(\"::\").map(|seg| Symbol::intern(seg)).collect::<Vec<_>>())\n                 .collect(),\n+            def_ids: FxHashSet::default(),\n         }\n     }\n }\n \n impl_lint_pass!(DisallowedMethod => [DISALLOWED_METHOD]);\n \n impl<'tcx> LateLintPass<'tcx> for DisallowedMethod {\n+    fn check_crate(&mut self, cx: &LateContext<'_>, _: &Crate<'_>) {\n+        for path in &self.disallowed {\n+            let segs = path.iter().map(ToString::to_string).collect::<Vec<_>>();\n+            if let Res::Def(_, id) = clippy_utils::path_to_res(cx, &segs.iter().map(String::as_str).collect::<Vec<_>>())\n+            {\n+                self.def_ids.insert((id, path.clone()));\n+            }\n+        }\n+    }\n+\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let Some(def_id) = fn_def_id(cx, expr) {\n-            let func_path = cx.get_def_path(def_id);\n-            if self.disallowed.contains(&func_path) {\n+            if self.def_ids.iter().any(|(id, _)| def_id == *id) {\n+                let func_path = cx.get_def_path(def_id);\n                 let func_path_string = func_path\n                     .into_iter()\n                     .map(Symbol::to_ident_string)"}, {"sha": "e4a88c6324ebfdac3958c208b1d2251194deb6e4", "filename": "clippy_lints/src/disallowed_type.rs", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fdisallowed_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fdisallowed_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdisallowed_type.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -0,0 +1,126 @@\n+use clippy_utils::diagnostics::span_lint;\n+\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir::{\n+    def::Res, def_id::DefId, Crate, Item, ItemKind, PolyTraitRef, TraitBoundModifier, Ty, TyKind, UseKind,\n+};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::{Span, Symbol};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Denies the configured types in clippy.toml.\n+    ///\n+    /// **Why is this bad?** Some types are undesirable in certain contexts.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// N.B. There is no way to ban primitive types.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// An example clippy.toml configuration:\n+    /// ```toml\n+    /// # clippy.toml\n+    /// disallowed-methods = [\"std::collections::BTreeMap\"]\n+    /// ```\n+    ///\n+    /// ```rust,ignore\n+    /// use std::collections::BTreeMap;\n+    /// // or its use\n+    /// let x = std::collections::BTreeMap::new();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust,ignore\n+    /// // A similar type that is allowed by the config\n+    /// use std::collections::HashMap;\n+    /// ```\n+    pub DISALLOWED_TYPE,\n+    nursery,\n+    \"use of a disallowed type\"\n+}\n+#[derive(Clone, Debug)]\n+pub struct DisallowedType {\n+    disallowed: FxHashSet<Vec<Symbol>>,\n+    def_ids: FxHashSet<(DefId, Vec<Symbol>)>,\n+}\n+\n+impl DisallowedType {\n+    pub fn new(disallowed: &FxHashSet<String>) -> Self {\n+        Self {\n+            disallowed: disallowed\n+                .iter()\n+                .map(|s| s.split(\"::\").map(|seg| Symbol::intern(seg)).collect::<Vec<_>>())\n+                .collect(),\n+            def_ids: FxHashSet::default(),\n+        }\n+    }\n+}\n+\n+impl_lint_pass!(DisallowedType => [DISALLOWED_TYPE]);\n+\n+impl<'tcx> LateLintPass<'tcx> for DisallowedType {\n+    fn check_crate(&mut self, cx: &LateContext<'_>, _: &Crate<'_>) {\n+        for path in &self.disallowed {\n+            let segs = path.iter().map(ToString::to_string).collect::<Vec<_>>();\n+            if let Res::Def(_, id) = clippy_utils::path_to_res(cx, &segs.iter().map(String::as_str).collect::<Vec<_>>())\n+            {\n+                self.def_ids.insert((id, path.clone()));\n+            }\n+        }\n+    }\n+\n+    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n+        if_chain! {\n+            if let ItemKind::Use(path, UseKind::Single) = &item.kind;\n+            if let Res::Def(_, did) = path.res;\n+            if let Some((_, name)) = self.def_ids.iter().find(|(id, _)| *id == did);\n+            then {\n+                emit(cx, name, item.span,);\n+            }\n+        }\n+    }\n+\n+    fn check_ty(&mut self, cx: &LateContext<'tcx>, ty: &'tcx Ty<'tcx>) {\n+        if_chain! {\n+            if let TyKind::Path(path) = &ty.kind;\n+            if let Some(did) = cx.qpath_res(path, ty.hir_id).opt_def_id();\n+            if let Some((_, name)) = self.def_ids.iter().find(|(id, _)| *id == did);\n+            then {\n+                emit(cx, name, path.span());\n+            }\n+        }\n+    }\n+\n+    fn check_poly_trait_ref(&mut self, cx: &LateContext<'tcx>, poly: &'tcx PolyTraitRef<'tcx>, _: TraitBoundModifier) {\n+        if_chain! {\n+            if let Res::Def(_, did) = poly.trait_ref.path.res;\n+            if let Some((_, name)) = self.def_ids.iter().find(|(id, _)| *id == did);\n+            then {\n+                emit(cx, name, poly.trait_ref.path.span);\n+            }\n+        }\n+    }\n+\n+    // TODO: if non primitive const generics are a thing\n+    // fn check_generic_arg(&mut self, cx: &LateContext<'tcx>, arg: &'tcx GenericArg<'tcx>) {\n+    //     match arg {\n+    //         GenericArg::Const(c) => {},\n+    //     }\n+    // }\n+    // fn check_generic_param(&mut self, cx: &LateContext<'tcx>, param: &'tcx GenericParam<'tcx>) {\n+    //     match param.kind {\n+    //         GenericParamKind::Const { .. } => {},\n+    //     }\n+    // }\n+}\n+\n+fn emit(cx: &LateContext<'_>, name: &[Symbol], span: Span) {\n+    let name = name.iter().map(|s| s.to_ident_string()).collect::<Vec<_>>().join(\"::\");\n+    span_lint(\n+        cx,\n+        DISALLOWED_TYPE,\n+        span,\n+        &format!(\"`{}` is not allowed according to config\", name),\n+    );\n+}"}, {"sha": "5ab333f8aa10737d52ff47ec34d1175a252ad0af", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -187,6 +187,7 @@ mod default_numeric_fallback;\n mod dereference;\n mod derive;\n mod disallowed_method;\n+mod disallowed_type;\n mod doc;\n mod double_comparison;\n mod double_parens;\n@@ -254,7 +255,6 @@ mod manual_strip;\n mod manual_unwrap_or;\n mod map_clone;\n mod map_err_ignore;\n-mod map_identity;\n mod map_unit_fn;\n mod match_on_vec_items;\n mod matches;\n@@ -583,6 +583,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         derive::EXPL_IMPL_CLONE_ON_COPY,\n         derive::UNSAFE_DERIVE_DESERIALIZE,\n         disallowed_method::DISALLOWED_METHOD,\n+        disallowed_type::DISALLOWED_TYPE,\n         doc::DOC_MARKDOWN,\n         doc::MISSING_ERRORS_DOC,\n         doc::MISSING_PANICS_DOC,\n@@ -705,7 +706,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         manual_unwrap_or::MANUAL_UNWRAP_OR,\n         map_clone::MAP_CLONE,\n         map_err_ignore::MAP_ERR_IGNORE,\n-        map_identity::MAP_IDENTITY,\n         map_unit_fn::OPTION_MAP_UNIT_FN,\n         map_unit_fn::RESULT_MAP_UNIT_FN,\n         match_on_vec_items::MATCH_ON_VEC_ITEMS,\n@@ -730,6 +730,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         mem_replace::MEM_REPLACE_OPTION_WITH_NONE,\n         mem_replace::MEM_REPLACE_WITH_DEFAULT,\n         mem_replace::MEM_REPLACE_WITH_UNINIT,\n+        methods::APPEND_INSTEAD_OF_EXTEND,\n         methods::BIND_INSTEAD_OF_MAP,\n         methods::BYTES_NTH,\n         methods::CHARS_LAST_CMP,\n@@ -765,6 +766,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         methods::MANUAL_STR_REPEAT,\n         methods::MAP_COLLECT_RESULT_UNIT,\n         methods::MAP_FLATTEN,\n+        methods::MAP_IDENTITY,\n         methods::MAP_UNWRAP_OR,\n         methods::NEW_RET_NO_SELF,\n         methods::OK_EXPECT,\n@@ -1260,7 +1262,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(manual_strip::MANUAL_STRIP),\n         LintId::of(manual_unwrap_or::MANUAL_UNWRAP_OR),\n         LintId::of(map_clone::MAP_CLONE),\n-        LintId::of(map_identity::MAP_IDENTITY),\n         LintId::of(map_unit_fn::OPTION_MAP_UNIT_FN),\n         LintId::of(map_unit_fn::RESULT_MAP_UNIT_FN),\n         LintId::of(matches::INFALLIBLE_DESTRUCTURING_MATCH),\n@@ -1276,6 +1277,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(mem_replace::MEM_REPLACE_OPTION_WITH_NONE),\n         LintId::of(mem_replace::MEM_REPLACE_WITH_DEFAULT),\n         LintId::of(mem_replace::MEM_REPLACE_WITH_UNINIT),\n+        LintId::of(methods::APPEND_INSTEAD_OF_EXTEND),\n         LintId::of(methods::BIND_INSTEAD_OF_MAP),\n         LintId::of(methods::BYTES_NTH),\n         LintId::of(methods::CHARS_LAST_CMP),\n@@ -1301,6 +1303,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(methods::MANUAL_SATURATING_ARITHMETIC),\n         LintId::of(methods::MANUAL_STR_REPEAT),\n         LintId::of(methods::MAP_COLLECT_RESULT_UNIT),\n+        LintId::of(methods::MAP_IDENTITY),\n         LintId::of(methods::NEW_RET_NO_SELF),\n         LintId::of(methods::OK_EXPECT),\n         LintId::of(methods::OPTION_AS_REF_DEREF),\n@@ -1586,7 +1589,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(loops::WHILE_LET_LOOP),\n         LintId::of(manual_strip::MANUAL_STRIP),\n         LintId::of(manual_unwrap_or::MANUAL_UNWRAP_OR),\n-        LintId::of(map_identity::MAP_IDENTITY),\n         LintId::of(map_unit_fn::OPTION_MAP_UNIT_FN),\n         LintId::of(map_unit_fn::RESULT_MAP_UNIT_FN),\n         LintId::of(matches::MATCH_AS_REF),\n@@ -1601,6 +1603,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(methods::ITER_COUNT),\n         LintId::of(methods::MANUAL_FILTER_MAP),\n         LintId::of(methods::MANUAL_FIND_MAP),\n+        LintId::of(methods::MAP_IDENTITY),\n         LintId::of(methods::OPTION_AS_REF_DEREF),\n         LintId::of(methods::OPTION_FILTER_MAP),\n         LintId::of(methods::SEARCH_IS_SOME),\n@@ -1735,6 +1738,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(large_enum_variant::LARGE_ENUM_VARIANT),\n         LintId::of(loops::MANUAL_MEMCPY),\n         LintId::of(loops::NEEDLESS_COLLECT),\n+        LintId::of(methods::APPEND_INSTEAD_OF_EXTEND),\n         LintId::of(methods::EXPECT_FUN_CALL),\n         LintId::of(methods::ITER_NTH),\n         LintId::of(methods::MANUAL_STR_REPEAT),\n@@ -1761,6 +1765,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(attrs::EMPTY_LINE_AFTER_OUTER_ATTR),\n         LintId::of(cognitive_complexity::COGNITIVE_COMPLEXITY),\n         LintId::of(disallowed_method::DISALLOWED_METHOD),\n+        LintId::of(disallowed_type::DISALLOWED_TYPE),\n         LintId::of(fallible_impl_from::FALLIBLE_IMPL_FROM),\n         LintId::of(floating_point_arithmetic::IMPRECISE_FLOPS),\n         LintId::of(floating_point_arithmetic::SUBOPTIMAL_FLOPS),\n@@ -2039,7 +2044,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         single_char_binding_names_threshold,\n     });\n     store.register_late_pass(|| box macro_use::MacroUseImports::default());\n-    store.register_late_pass(|| box map_identity::MapIdentity);\n     store.register_late_pass(|| box pattern_type_mismatch::PatternTypeMismatch);\n     store.register_late_pass(|| box stable_sort_primitive::StableSortPrimitive);\n     store.register_late_pass(|| box repeat_once::RepeatOnce);\n@@ -2066,6 +2070,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(move || box if_then_some_else_none::IfThenSomeElseNone::new(msrv));\n     store.register_early_pass(|| box bool_assert_comparison::BoolAssertComparison);\n     store.register_late_pass(|| box unused_async::UnusedAsync);\n+    let disallowed_types = conf.disallowed_types.iter().cloned().collect::<FxHashSet<_>>();\n+    store.register_late_pass(move || box disallowed_type::DisallowedType::new(&disallowed_types));\n \n }\n "}, {"sha": "47005aba38890927d0032c025252ab51c4a97f43", "filename": "clippy_lints/src/loops/manual_memcpy.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_memcpy.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -204,11 +204,8 @@ struct MinifyingSugg<'a>(Sugg<'a>);\n \n impl<'a> MinifyingSugg<'a> {\n     fn as_str(&self) -> &str {\n-        // HACK: Don't sync to Clippy! Required because something with the `or_patterns` feature\n-        // changed and this would now require parentheses.\n-        match &self.0 {\n-            Sugg::NonParen(s) | Sugg::MaybeParen(s) | Sugg::BinOp(_, s) => s.as_ref(),\n-        }\n+        let (Sugg::NonParen(s) | Sugg::MaybeParen(s) | Sugg::BinOp(_, s)) = &self.0;\n+        s.as_ref()\n     }\n \n     fn into_sugg(self) -> Sugg<'a> {"}, {"sha": "51d7def137e409eea10816378e774726fb29e026", "filename": "clippy_lints/src/loops/needless_collect.rs", "status": "modified", "additions": 36, "deletions": 61, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fneedless_collect.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -7,10 +7,10 @@ use clippy_utils::{is_trait_method, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_block, walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{Block, Expr, ExprKind, GenericArg, GenericArgs, HirId, Local, Pat, PatKind, QPath, StmtKind, Ty};\n+use rustc_hir::{Block, Expr, ExprKind, HirId, PatKind, StmtKind};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n-use rustc_span::symbol::{sym, Ident};\n+use rustc_span::sym;\n use rustc_span::{MultiSpan, Span};\n \n const NEEDLESS_COLLECT_MSG: &str = \"avoid using `collect()` when not needed\";\n@@ -24,10 +24,8 @@ fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCont\n         if let ExprKind::MethodCall(method, _, args, _) = expr.kind;\n         if let ExprKind::MethodCall(chain_method, method0_span, _, _) = args[0].kind;\n         if chain_method.ident.name == sym!(collect) && is_trait_method(cx, &args[0], sym::Iterator);\n-        if let Some(generic_args) = chain_method.args;\n-        if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0);\n-        if let Some(ty) = cx.typeck_results().node_type_opt(ty.hir_id);\n         then {\n+            let ty = cx.typeck_results().expr_ty(&args[0]);\n             let mut applicability = Applicability::MachineApplicable;\n             let is_empty_sugg = \"next().is_none()\".to_string();\n             let method_name = &*method.ident.name.as_str();\n@@ -72,40 +70,25 @@ fn check_needless_collect_direct_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateCont\n }\n \n fn check_needless_collect_indirect_usage<'tcx>(expr: &'tcx Expr<'_>, cx: &LateContext<'tcx>) {\n-    fn get_hir_id<'tcx>(ty: Option<&Ty<'tcx>>, method_args: Option<&GenericArgs<'tcx>>) -> Option<HirId> {\n-        if let Some(ty) = ty {\n-            return Some(ty.hir_id);\n-        }\n-\n-        if let Some(generic_args) = method_args {\n-            if let Some(GenericArg::Type(ref ty)) = generic_args.args.get(0) {\n-                return Some(ty.hir_id);\n-            }\n-        }\n-\n-        None\n-    }\n     if let ExprKind::Block(block, _) = expr.kind {\n         for stmt in block.stmts {\n             if_chain! {\n-                if let StmtKind::Local(\n-                    Local { pat: Pat { hir_id: pat_id, kind: PatKind::Binding(_, _, ident, .. ), .. },\n-                    init: Some(init_expr), ty, .. }\n-                ) = stmt.kind;\n+                if let StmtKind::Local(local) = stmt.kind;\n+                if let PatKind::Binding(_, id, ..) = local.pat.kind;\n+                if let Some(init_expr) = local.init;\n                 if let ExprKind::MethodCall(method_name, collect_span, &[ref iter_source], ..) = init_expr.kind;\n                 if method_name.ident.name == sym!(collect) && is_trait_method(cx, init_expr, sym::Iterator);\n-                if let Some(hir_id) = get_hir_id(*ty, method_name.args);\n-                if let Some(ty) = cx.typeck_results().node_type_opt(hir_id);\n+                let ty = cx.typeck_results().expr_ty(init_expr);\n                 if is_type_diagnostic_item(cx, ty, sym::vec_type) ||\n                     is_type_diagnostic_item(cx, ty, sym::vecdeque_type) ||\n                     is_type_diagnostic_item(cx, ty, sym::BinaryHeap) ||\n                     is_type_diagnostic_item(cx, ty, sym::LinkedList);\n-                if let Some(iter_calls) = detect_iter_and_into_iters(block, *ident);\n+                if let Some(iter_calls) = detect_iter_and_into_iters(block, id);\n                 if let [iter_call] = &*iter_calls;\n                 then {\n                     let mut used_count_visitor = UsedCountVisitor {\n                         cx,\n-                        id: *pat_id,\n+                        id,\n                         count: 0,\n                     };\n                     walk_block(&mut used_count_visitor, block);\n@@ -187,48 +170,40 @@ enum IterFunctionKind {\n struct IterFunctionVisitor {\n     uses: Vec<IterFunction>,\n     seen_other: bool,\n-    target: Ident,\n+    target: HirId,\n }\n impl<'tcx> Visitor<'tcx> for IterFunctionVisitor {\n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n         // Check function calls on our collection\n-        if_chain! {\n-            if let ExprKind::MethodCall(method_name, _, args, _) = &expr.kind;\n-            if let Some(Expr { kind: ExprKind::Path(QPath::Resolved(_, path)), .. }) = args.get(0);\n-            if let &[name] = &path.segments;\n-            if name.ident == self.target;\n-            then {\n-                let len = sym!(len);\n-                let is_empty = sym!(is_empty);\n-                let contains = sym!(contains);\n-                match method_name.ident.name {\n-                    sym::into_iter => self.uses.push(\n-                        IterFunction { func: IterFunctionKind::IntoIter, span: expr.span }\n-                    ),\n-                    name if name == len => self.uses.push(\n-                        IterFunction { func: IterFunctionKind::Len, span: expr.span }\n-                    ),\n-                    name if name == is_empty => self.uses.push(\n-                        IterFunction { func: IterFunctionKind::IsEmpty, span: expr.span }\n-                    ),\n-                    name if name == contains => self.uses.push(\n-                        IterFunction { func: IterFunctionKind::Contains(args[1].span), span: expr.span }\n-                    ),\n+        if let ExprKind::MethodCall(method_name, _, [recv, args @ ..], _) = &expr.kind {\n+            if path_to_local_id(recv, self.target) {\n+                match &*method_name.ident.name.as_str() {\n+                    \"into_iter\" => self.uses.push(IterFunction {\n+                        func: IterFunctionKind::IntoIter,\n+                        span: expr.span,\n+                    }),\n+                    \"len\" => self.uses.push(IterFunction {\n+                        func: IterFunctionKind::Len,\n+                        span: expr.span,\n+                    }),\n+                    \"is_empty\" => self.uses.push(IterFunction {\n+                        func: IterFunctionKind::IsEmpty,\n+                        span: expr.span,\n+                    }),\n+                    \"contains\" => self.uses.push(IterFunction {\n+                        func: IterFunctionKind::Contains(args[0].span),\n+                        span: expr.span,\n+                    }),\n                     _ => self.seen_other = true,\n                 }\n-                return\n+                return;\n             }\n         }\n         // Check if the collection is used for anything else\n-        if_chain! {\n-            if let Expr { kind: ExprKind::Path(QPath::Resolved(_, path)), .. } = expr;\n-            if let &[name] = &path.segments;\n-            if name.ident == self.target;\n-            then {\n-                self.seen_other = true;\n-            } else {\n-                walk_expr(self, expr);\n-            }\n+        if path_to_local_id(expr, self.target) {\n+            self.seen_other = true;\n+        } else {\n+            walk_expr(self, expr);\n         }\n     }\n \n@@ -262,10 +237,10 @@ impl<'a, 'tcx> Visitor<'tcx> for UsedCountVisitor<'a, 'tcx> {\n \n /// Detect the occurrences of calls to `iter` or `into_iter` for the\n /// given identifier\n-fn detect_iter_and_into_iters<'tcx>(block: &'tcx Block<'tcx>, identifier: Ident) -> Option<Vec<IterFunction>> {\n+fn detect_iter_and_into_iters<'tcx>(block: &'tcx Block<'tcx>, id: HirId) -> Option<Vec<IterFunction>> {\n     let mut visitor = IterFunctionVisitor {\n         uses: Vec::new(),\n-        target: identifier,\n+        target: id,\n         seen_other: false,\n     };\n     visitor.visit_block(block);"}, {"sha": "d57588716a5bf16c8f4b28d0b75ceb251718837e", "filename": "clippy_lints/src/loops/while_let_on_iterator.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -1,7 +1,9 @@\n use super::WHILE_LET_ON_ITERATOR;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{get_enclosing_loop, is_refutable, is_trait_method, match_def_path, paths, visitors::is_res_used};\n+use clippy_utils::{\n+    get_enclosing_loop_or_closure, is_refutable, is_trait_method, match_def_path, paths, visitors::is_res_used,\n+};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, ErasedMap, NestedVisitorMap, Visitor};\n@@ -315,9 +317,10 @@ fn needs_mutable_borrow(cx: &LateContext<'tcx>, iter_expr: &IterExpr, loop_expr:\n         }\n     }\n \n-    if let Some(e) = get_enclosing_loop(cx.tcx, loop_expr) {\n-        // The iterator expression will be used on the next iteration unless it is declared within the outer\n-        // loop.\n+    if let Some(e) = get_enclosing_loop_or_closure(cx.tcx, loop_expr) {\n+        // The iterator expression will be used on the next iteration (for loops), or on the next call (for\n+        // closures) unless it is declared within the enclosing expression. TODO: Check for closures\n+        // used where an `FnOnce` type is expected.\n         let local_id = match iter_expr.path {\n             Res::Local(id) => id,\n             _ => return true,"}, {"sha": "97e4a983f32ea3ca4542d17cf63223d2aeca2303", "filename": "clippy_lints/src/manual_map.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_map.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -3,19 +3,17 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable};\n use clippy_utils::{\n-    can_move_expr_to_closure, in_constant, is_allowed, is_else_clause, is_lang_ctor, match_var, peel_hir_expr_refs,\n+    can_move_expr_to_closure, in_constant, is_allowed, is_else_clause, is_lang_ctor, path_to_local_id,\n+    peel_hir_expr_refs,\n };\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n-use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, MatchSource, Mutability, Pat, PatKind};\n+use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, HirId, MatchSource, Mutability, Pat, PatKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::{\n-    symbol::{sym, Ident},\n-    SyntaxContext,\n-};\n+use rustc_span::{sym, SyntaxContext};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for usages of `match` which could be implemented using `map`\n@@ -141,13 +139,13 @@ impl LateLintPass<'_> for ManualMap {\n                     scrutinee_str.into()\n                 };\n \n-            let body_str = if let PatKind::Binding(annotation, _, some_binding, None) = some_pat.kind {\n-                match can_pass_as_func(cx, some_binding, some_expr) {\n+            let body_str = if let PatKind::Binding(annotation, id, some_binding, None) = some_pat.kind {\n+                match can_pass_as_func(cx, id, some_expr) {\n                     Some(func) if func.span.ctxt() == some_expr.span.ctxt() => {\n                         snippet_with_applicability(cx, func.span, \"..\", &mut app).into_owned()\n                     },\n                     _ => {\n-                        if match_var(some_expr, some_binding.name)\n+                        if path_to_local_id(some_expr, id)\n                             && !is_allowed(cx, MATCH_AS_REF, expr.hir_id)\n                             && binding_ref.is_some()\n                         {\n@@ -199,10 +197,10 @@ impl LateLintPass<'_> for ManualMap {\n \n // Checks whether the expression could be passed as a function, or whether a closure is needed.\n // Returns the function to be passed to `map` if it exists.\n-fn can_pass_as_func(cx: &LateContext<'tcx>, binding: Ident, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+fn can_pass_as_func(cx: &LateContext<'tcx>, binding: HirId, expr: &'tcx Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     match expr.kind {\n         ExprKind::Call(func, [arg])\n-            if match_var(arg, binding.name) && cx.typeck_results().expr_adjustments(arg).is_empty() =>\n+            if path_to_local_id(arg, binding) && cx.typeck_results().expr_adjustments(arg).is_empty() =>\n         {\n             Some(func)\n         },"}, {"sha": "41cda23510ea2f9e19e694e534ebf0f98d5e8834", "filename": "clippy_lints/src/map_identity.rs", "status": "removed", "additions": 0, "deletions": 126, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/611b74e1fe48410c534c5d5a6a0832b810d8ccda/clippy_lints%2Fsrc%2Fmap_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/611b74e1fe48410c534c5d5a6a0832b810d8ccda/clippy_lints%2Fsrc%2Fmap_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_identity.rs?ref=611b74e1fe48410c534c5d5a6a0832b810d8ccda", "patch": "@@ -1,126 +0,0 @@\n-use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{is_adjusted, is_qpath_def_path, is_trait_method, match_var, paths, remove_blocks};\n-use if_chain::if_chain;\n-use rustc_errors::Applicability;\n-use rustc_hir::{Body, Expr, ExprKind, Pat, PatKind, QPath, StmtKind};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::sym;\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Checks for instances of `map(f)` where `f` is the identity function.\n-    ///\n-    /// **Why is this bad?** It can be written more concisely without the call to `map`.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    ///\n-    /// ```rust\n-    /// let x = [1, 2, 3];\n-    /// let y: Vec<_> = x.iter().map(|x| x).map(|x| 2*x).collect();\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// let x = [1, 2, 3];\n-    /// let y: Vec<_> = x.iter().map(|x| 2*x).collect();\n-    /// ```\n-    pub MAP_IDENTITY,\n-    complexity,\n-    \"using iterator.map(|x| x)\"\n-}\n-\n-declare_lint_pass!(MapIdentity => [MAP_IDENTITY]);\n-\n-impl<'tcx> LateLintPass<'tcx> for MapIdentity {\n-    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        if expr.span.from_expansion() {\n-            return;\n-        }\n-\n-        if_chain! {\n-            if let Some([caller, func]) = get_map_argument(cx, expr);\n-            if is_expr_identity_function(cx, func);\n-            then {\n-                span_lint_and_sugg(\n-                    cx,\n-                    MAP_IDENTITY,\n-                    expr.span.trim_start(caller.span).unwrap(),\n-                    \"unnecessary map of the identity function\",\n-                    \"remove the call to `map`\",\n-                    String::new(),\n-                    Applicability::MachineApplicable\n-                )\n-            }\n-        }\n-    }\n-}\n-\n-/// Returns the arguments passed into map() if the expression is a method call to\n-/// map(). Otherwise, returns None.\n-fn get_map_argument<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<&'a [Expr<'a>]> {\n-    if_chain! {\n-        if let ExprKind::MethodCall(method, _, args, _) = expr.kind;\n-        if args.len() == 2 && method.ident.name == sym::map;\n-        let caller_ty = cx.typeck_results().expr_ty(&args[0]);\n-        if is_trait_method(cx, expr, sym::Iterator)\n-            || is_type_diagnostic_item(cx, caller_ty, sym::result_type)\n-            || is_type_diagnostic_item(cx, caller_ty, sym::option_type);\n-        then {\n-            Some(args)\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-/// Checks if an expression represents the identity function\n-/// Only examines closures and `std::convert::identity`\n-fn is_expr_identity_function(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    match expr.kind {\n-        ExprKind::Closure(_, _, body_id, _, _) => is_body_identity_function(cx, cx.tcx.hir().body(body_id)),\n-        ExprKind::Path(ref path) => is_qpath_def_path(cx, path, expr.hir_id, &paths::CONVERT_IDENTITY),\n-        _ => false,\n-    }\n-}\n-\n-/// Checks if a function's body represents the identity function\n-/// Looks for bodies of the form `|x| x`, `|x| return x`, `|x| { return x }` or `|x| {\n-/// return x; }`\n-fn is_body_identity_function(cx: &LateContext<'_>, func: &Body<'_>) -> bool {\n-    let params = func.params;\n-    let body = remove_blocks(&func.value);\n-\n-    // if there's less/more than one parameter, then it is not the identity function\n-    if params.len() != 1 {\n-        return false;\n-    }\n-\n-    match body.kind {\n-        ExprKind::Path(QPath::Resolved(None, _)) => match_expr_param(cx, body, params[0].pat),\n-        ExprKind::Ret(Some(ret_val)) => match_expr_param(cx, ret_val, params[0].pat),\n-        ExprKind::Block(block, _) => {\n-            if_chain! {\n-                if block.stmts.len() == 1;\n-                if let StmtKind::Semi(expr) | StmtKind::Expr(expr) = block.stmts[0].kind;\n-                if let ExprKind::Ret(Some(ret_val)) = expr.kind;\n-                then {\n-                    match_expr_param(cx, ret_val, params[0].pat)\n-                } else {\n-                    false\n-                }\n-            }\n-        },\n-        _ => false,\n-    }\n-}\n-\n-/// Returns true iff an expression returns the same thing as a parameter's pattern\n-fn match_expr_param(cx: &LateContext<'_>, expr: &Expr<'_>, pat: &Pat<'_>) -> bool {\n-    if let PatKind::Binding(_, _, ident, _) = pat.kind {\n-        match_var(expr, ident.name) && !(cx.typeck_results().hir_owner == expr.hir_id.owner && is_adjusted(cx, expr))\n-    } else {\n-        false\n-    }\n-}"}, {"sha": "e39a5a1efd1e18f2a76bc64ab5cb76ef84e806a7", "filename": "clippy_lints/src/methods/append_instead_of_extend.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fmethods%2Fappend_instead_of_extend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fmethods%2Fappend_instead_of_extend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fappend_instead_of_extend.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -0,0 +1,41 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_applicability;\n+use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, LangItem};\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::sym;\n+\n+use super::APPEND_INSTEAD_OF_EXTEND;\n+\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, recv: &Expr<'_>, arg: &Expr<'_>) {\n+    let ty = cx.typeck_results().expr_ty(recv).peel_refs();\n+    if_chain! {\n+        if is_type_diagnostic_item(cx, ty, sym::vec_type);\n+        //check source object\n+        if let ExprKind::MethodCall(src_method, _, [drain_vec, drain_arg], _) = &arg.kind;\n+        if src_method.ident.as_str() == \"drain\";\n+        if let src_ty = cx.typeck_results().expr_ty(drain_vec).peel_refs();\n+        if is_type_diagnostic_item(cx, src_ty, sym::vec_type);\n+        //check drain range\n+        if let src_ty_range = cx.typeck_results().expr_ty(drain_arg).peel_refs();\n+        if is_type_lang_item(cx, src_ty_range, LangItem::RangeFull);\n+        then {\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                APPEND_INSTEAD_OF_EXTEND,\n+                expr.span,\n+                \"use of `extend` instead of `append` for adding the full range of a second vector\",\n+                \"try this\",\n+                format!(\n+                    \"{}.append(&mut {})\",\n+                    snippet_with_applicability(cx, recv.span, \"..\", &mut applicability),\n+                    snippet_with_applicability(cx, drain_vec.span, \"..\", &mut applicability)\n+                ),\n+                applicability,\n+            );\n+        }\n+    }\n+}"}, {"sha": "d1b5e945dfdaa83a85b5ce13d776b0d438b88579", "filename": "clippy_lints/src/methods/filter_map_identity.rs", "status": "modified", "additions": 11, "deletions": 29, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffilter_map_identity.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -1,6 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::{is_expr_path_def_path, is_trait_method, path_to_local_id, paths};\n-use if_chain::if_chain;\n+use clippy_utils::{is_expr_identity_function, is_trait_method};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n@@ -9,32 +8,15 @@ use rustc_span::{source_map::Span, sym};\n use super::FILTER_MAP_IDENTITY;\n \n pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, filter_map_arg: &hir::Expr<'_>, filter_map_span: Span) {\n-    if is_trait_method(cx, expr, sym::Iterator) {\n-        let apply_lint = |message: &str| {\n-            span_lint_and_sugg(\n-                cx,\n-                FILTER_MAP_IDENTITY,\n-                filter_map_span.with_hi(expr.span.hi()),\n-                message,\n-                \"try\",\n-                \"flatten()\".to_string(),\n-                Applicability::MachineApplicable,\n-            );\n-        };\n-\n-        if_chain! {\n-            if let hir::ExprKind::Closure(_, _, body_id, _, _) = filter_map_arg.kind;\n-            let body = cx.tcx.hir().body(body_id);\n-\n-            if let hir::PatKind::Binding(_, binding_id, ..) = body.params[0].pat.kind;\n-            if path_to_local_id(&body.value, binding_id);\n-            then {\n-                apply_lint(\"called `filter_map(|x| x)` on an `Iterator`\");\n-            }\n-        }\n-\n-        if is_expr_path_def_path(cx, filter_map_arg, &paths::CONVERT_IDENTITY) {\n-            apply_lint(\"called `filter_map(std::convert::identity)` on an `Iterator`\");\n-        }\n+    if is_trait_method(cx, expr, sym::Iterator) && is_expr_identity_function(cx, filter_map_arg) {\n+        span_lint_and_sugg(\n+            cx,\n+            FILTER_MAP_IDENTITY,\n+            filter_map_span.with_hi(expr.span.hi()),\n+            \"use of `filter_map` with an identity function\",\n+            \"try\",\n+            \"flatten()\".to_string(),\n+            Applicability::MachineApplicable,\n+        );\n     }\n }"}, {"sha": "6f911d79d0bc50880628e5de6f2711802601d58d", "filename": "clippy_lints/src/methods/flat_map_identity.rs", "status": "modified", "additions": 11, "deletions": 33, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fflat_map_identity.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -1,6 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::{is_expr_path_def_path, is_trait_method, paths};\n-use if_chain::if_chain;\n+use clippy_utils::{is_expr_identity_function, is_trait_method};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n@@ -15,36 +14,15 @@ pub(super) fn check<'tcx>(\n     flat_map_arg: &'tcx hir::Expr<'_>,\n     flat_map_span: Span,\n ) {\n-    if is_trait_method(cx, expr, sym::Iterator) {\n-        let apply_lint = |message: &str| {\n-            span_lint_and_sugg(\n-                cx,\n-                FLAT_MAP_IDENTITY,\n-                flat_map_span.with_hi(expr.span.hi()),\n-                message,\n-                \"try\",\n-                \"flatten()\".to_string(),\n-                Applicability::MachineApplicable,\n-            );\n-        };\n-\n-        if_chain! {\n-            if let hir::ExprKind::Closure(_, _, body_id, _, _) = flat_map_arg.kind;\n-            let body = cx.tcx.hir().body(body_id);\n-\n-            if let hir::PatKind::Binding(_, _, binding_ident, _) = body.params[0].pat.kind;\n-            if let hir::ExprKind::Path(hir::QPath::Resolved(_, path)) = body.value.kind;\n-\n-            if path.segments.len() == 1;\n-            if path.segments[0].ident.name == binding_ident.name;\n-\n-            then {\n-                apply_lint(\"called `flat_map(|x| x)` on an `Iterator`\");\n-            }\n-        }\n-\n-        if is_expr_path_def_path(cx, flat_map_arg, &paths::CONVERT_IDENTITY) {\n-            apply_lint(\"called `flat_map(std::convert::identity)` on an `Iterator`\");\n-        }\n+    if is_trait_method(cx, expr, sym::Iterator) && is_expr_identity_function(cx, flat_map_arg) {\n+        span_lint_and_sugg(\n+            cx,\n+            FLAT_MAP_IDENTITY,\n+            flat_map_span.with_hi(expr.span.hi()),\n+            \"use of `flat_map` with an identity function\",\n+            \"try\",\n+            \"flatten()\".to_string(),\n+            Applicability::MachineApplicable,\n+        );\n     }\n }"}, {"sha": "538a12566e3031880a9400f3a1f294cf491a0556", "filename": "clippy_lints/src/methods/map_identity.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fmethods%2Fmap_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fmethods%2Fmap_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmap_identity.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -0,0 +1,38 @@\n+use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::ty::is_type_diagnostic_item;\n+use clippy_utils::{is_expr_identity_function, is_trait_method};\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_span::{source_map::Span, sym};\n+\n+use super::MAP_IDENTITY;\n+\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    expr: &hir::Expr<'_>,\n+    caller: &hir::Expr<'_>,\n+    map_arg: &hir::Expr<'_>,\n+    _map_span: Span,\n+) {\n+    let caller_ty = cx.typeck_results().expr_ty(caller);\n+\n+    if_chain! {\n+        if is_trait_method(cx, expr, sym::Iterator)\n+            || is_type_diagnostic_item(cx, caller_ty, sym::result_type)\n+            || is_type_diagnostic_item(cx, caller_ty, sym::option_type);\n+        if is_expr_identity_function(cx, map_arg);\n+        if let Some(sugg_span) = expr.span.trim_start(caller.span);\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                MAP_IDENTITY,\n+                sugg_span,\n+                \"unnecessary map of the identity function\",\n+                \"remove the call to `map`\",\n+                String::new(),\n+                Applicability::MachineApplicable,\n+            )\n+        }\n+    }\n+}"}, {"sha": "b556dcb4dfe800f0e588ad6fb893e52485f87f10", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 57, "deletions": 2, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -1,3 +1,4 @@\n+mod append_instead_of_extend;\n mod bind_instead_of_map;\n mod bytes_nth;\n mod chars_cmp;\n@@ -35,6 +36,7 @@ mod manual_saturating_arithmetic;\n mod manual_str_repeat;\n mod map_collect_result_unit;\n mod map_flatten;\n+mod map_identity;\n mod map_unwrap_or;\n mod ok_expect;\n mod option_as_ref_deref;\n@@ -1031,6 +1033,30 @@ declare_clippy_lint! {\n     \"using `.get().unwrap()` or `.get_mut().unwrap()` when using `[]` would work instead\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for occurrences where one vector gets extended instead of append\n+    ///\n+    /// **Why is this bad?** Using `append` instead of `extend` is more concise and faster\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let mut a = vec![1, 2, 3];\n+    /// let mut b = vec![4, 5, 6];\n+    ///\n+    /// // Bad\n+    /// a.extend(b.drain(..));\n+    ///\n+    /// // Good\n+    /// a.append(&mut b);\n+    /// ```\n+    pub APPEND_INSTEAD_OF_EXTEND,\n+    perf,\n+    \"using vec.append(&mut vec) to move the full range of a vecor to another\"\n+}\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for the use of `.extend(s.chars())` where s is a\n     /// `&str` or `String`.\n@@ -1561,6 +1587,29 @@ declare_clippy_lint! {\n     \"call to `filter_map` where `flatten` is sufficient\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for instances of `map(f)` where `f` is the identity function.\n+    ///\n+    /// **Why is this bad?** It can be written more concisely without the call to `map`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let x = [1, 2, 3];\n+    /// let y: Vec<_> = x.iter().map(|x| x).map(|x| 2*x).collect();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let x = [1, 2, 3];\n+    /// let y: Vec<_> = x.iter().map(|x| 2*x).collect();\n+    /// ```\n+    pub MAP_IDENTITY,\n+    complexity,\n+    \"using iterator.map(|x| x)\"\n+}\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for the use of `.bytes().nth()`.\n     ///\n@@ -1728,6 +1777,7 @@ impl_lint_pass!(Methods => [\n     FILTER_NEXT,\n     SKIP_WHILE_NEXT,\n     FILTER_MAP_IDENTITY,\n+    MAP_IDENTITY,\n     MANUAL_FILTER_MAP,\n     MANUAL_FIND_MAP,\n     OPTION_FILTER_MAP,\n@@ -1760,7 +1810,8 @@ impl_lint_pass!(Methods => [\n     INSPECT_FOR_EACH,\n     IMPLICIT_CLONE,\n     SUSPICIOUS_SPLITN,\n-    MANUAL_STR_REPEAT\n+    MANUAL_STR_REPEAT,\n+    APPEND_INSTEAD_OF_EXTEND\n ]);\n \n /// Extracts a method call name, args, and `Span` of the method name.\n@@ -2022,7 +2073,10 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n                 Some((\"ok\", [recv], _)) => ok_expect::check(cx, expr, recv),\n                 _ => expect_used::check(cx, expr, recv),\n             },\n-            (\"extend\", [arg]) => string_extend_chars::check(cx, expr, recv, arg),\n+            (\"extend\", [arg]) => {\n+                string_extend_chars::check(cx, expr, recv, arg);\n+                append_instead_of_extend::check(cx, expr, recv, arg);\n+            },\n             (\"filter_map\", [arg]) => {\n                 unnecessary_filter_map::check(cx, expr, arg);\n                 filter_map_identity::check(cx, expr, arg, span);\n@@ -2058,6 +2112,7 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n                         _ => {},\n                     }\n                 }\n+                map_identity::check(cx, expr, recv, m_arg, span);\n             },\n             (\"map_or\", [def, map]) => option_map_or_none::check(cx, expr, recv, def, map),\n             (\"next\", []) => {"}, {"sha": "ec1572c26c262acc21ace9b4e95479828d4d86cd", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -7,7 +7,8 @@\n \n use clippy_utils::attrs::is_doc_hidden;\n use clippy_utils::diagnostics::span_lint;\n-use rustc_ast::ast;\n+use if_chain::if_chain;\n+use rustc_ast::ast::{self, MetaItem, MetaItemKind};\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::ty;\n@@ -55,6 +56,20 @@ impl MissingDoc {\n         *self.doc_hidden_stack.last().expect(\"empty doc_hidden_stack\")\n     }\n \n+    fn has_include(meta: Option<MetaItem>) -> bool {\n+        if_chain! {\n+            if let Some(meta) = meta;\n+            if let MetaItemKind::List(list) = meta.kind;\n+            if let Some(meta) = list.get(0);\n+            if let Some(name) = meta.ident();\n+            then {\n+                name.name == sym::include\n+            } else {\n+                false\n+            }\n+        }\n+    }\n+\n     fn check_missing_docs_attrs(\n         &self,\n         cx: &LateContext<'_>,\n@@ -80,7 +95,7 @@ impl MissingDoc {\n \n         let has_doc = attrs\n             .iter()\n-            .any(|a| a.doc_str().is_some());\n+            .any(|a| a.doc_str().is_some() || Self::has_include(a.meta()));\n         if !has_doc {\n             span_lint(\n                 cx,"}, {"sha": "81bf853300fe5aa4014612ec533aa55e572ea1a9", "filename": "clippy_lints/src/mutable_debug_assertion.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutable_debug_assertion.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -87,10 +87,6 @@ impl<'a, 'tcx> Visitor<'tcx> for MutArgVisitor<'a, 'tcx> {\n                 self.found = true;\n                 return;\n             },\n-            ExprKind::If(..) => {\n-                self.found = true;\n-                return;\n-            },\n             ExprKind::Path(_) => {\n                 if let Some(adj) = self.cx.typeck_results().adjustments().get(expr.hir_id) {\n                     if adj"}, {"sha": "b81f8d24a33e98a9dfd166fc0dc865e8269812ba", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -1,7 +1,6 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_then};\n use rustc_ast::ast::{\n-    Arm, AssocItem, AssocItemKind, Attribute, Block, FnDecl, FnKind, Item, ItemKind, Local, Pat,\n-    PatKind,\n+    Arm, AssocItem, AssocItemKind, Attribute, Block, FnDecl, FnKind, Item, ItemKind, Local, Pat, PatKind,\n };\n use rustc_ast::visit::{walk_block, walk_expr, walk_pat, Visitor};\n use rustc_lint::{EarlyContext, EarlyLintPass};"}, {"sha": "380557c81a19a9d1162e5fb0b3ad03784846664a", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -132,7 +132,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantClone {\n                 }\n             }\n \n-            // `{ cloned = &arg; clone(move cloned); }` or `{ cloned = &arg; to_path_buf(cloned); }`\n+            // `{ arg = &cloned; clone(move arg); }` or `{ arg = &cloned; to_path_buf(arg); }`\n             let (cloned, cannot_move_out) = unwrap_or_continue!(find_stmt_assigns_to(cx, mir, arg, from_borrow, bb));\n \n             let loc = mir::Location {\n@@ -628,7 +628,7 @@ fn rvalue_locals(rvalue: &mir::Rvalue<'_>, mut visit: impl FnMut(mir::Local)) {\n         BinaryOp(_, box (lhs, rhs)) | CheckedBinaryOp(_, box (lhs, rhs)) => {\n             visit_op(lhs);\n             visit_op(rhs);\n-        }\n+        },\n         _ => (),\n     }\n }"}, {"sha": "da3e30af35ca4ffd7e2a8de07ef16ce6e028e04c", "filename": "clippy_lints/src/semicolon_if_nothing_returned.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fsemicolon_if_nothing_returned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fsemicolon_if_nothing_returned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fsemicolon_if_nothing_returned.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -1,3 +1,4 @@\n+use crate::rustc_lint::LintContext;\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_macro_callsite;\n use clippy_utils::{in_macro, sugg};\n@@ -45,6 +46,7 @@ impl LateLintPass<'_> for SemicolonIfNothingReturned {\n             if t_expr.is_unit();\n             if let snippet = snippet_with_macro_callsite(cx, expr.span, \"}\");\n             if !snippet.ends_with('}');\n+            if cx.sess().source_map().is_multiline(block.span);\n             then {\n                 // filter out the desugared `for` loop\n                 if let ExprKind::DropTemps(..) = &expr.kind {"}, {"sha": "07a4e294049791f7256e41810c31ed22088a3426", "filename": "clippy_lints/src/unnested_or_patterns.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Funnested_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnested_or_patterns.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -1,6 +1,6 @@\n #![allow(clippy::wildcard_imports, clippy::enum_glob_use)]\n \n-use clippy_utils::ast_utils::{eq_field_pat, eq_id, eq_pat, eq_path, eq_maybe_qself};\n+use clippy_utils::ast_utils::{eq_field_pat, eq_id, eq_maybe_qself, eq_pat, eq_path};\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::{meets_msrv, msrvs, over};\n use rustc_ast::mut_visit::*;\n@@ -277,7 +277,8 @@ fn transform_with_focus_on_idx(alternatives: &mut Vec<P<Pat>>, focus_idx: usize)\n             ps1, start, alternatives,\n             |k, ps1, idx| matches!(\n                 k,\n-                TupleStruct(qself2, path2, ps2) if eq_maybe_qself(qself1, qself2) && eq_path(path1, path2) && eq_pre_post(ps1, ps2, idx)\n+                TupleStruct(qself2, path2, ps2)\n+                    if eq_maybe_qself(qself1, qself2) && eq_path(path1, path2) && eq_pre_post(ps1, ps2, idx)\n             ),\n             |k| always_pat!(k, TupleStruct(_, _, ps) => ps),\n         ),"}, {"sha": "f71dfd024999d832d17d5f33882e8a3bee68a48b", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 52, "deletions": 128, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -1,23 +1,21 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::source::snippet_opt;\n use clippy_utils::ty::same_type_and_consts;\n use clippy_utils::{in_macro, meets_msrv, msrvs};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{\n     self as hir,\n-    def::{self, DefKind},\n+    def::{CtorOf, DefKind, Res},\n     def_id::LocalDefId,\n     intravisit::{walk_ty, NestedVisitorMap, Visitor},\n-    Expr, ExprKind, FnRetTy, FnSig, GenericArg, HirId, Impl, ImplItemKind, Item, ItemKind, Node, Path, PathSegment,\n-    QPath, TyKind,\n+    Expr, ExprKind, FnRetTy, FnSig, GenericArg, HirId, Impl, ImplItemKind, Item, ItemKind, Node, Path, QPath, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n use rustc_middle::ty::{AssocKind, Ty};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::{BytePos, Span};\n+use rustc_span::Span;\n use rustc_typeck::hir_ty_to_ty;\n \n declare_clippy_lint! {\n@@ -234,111 +232,58 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n     }\n \n     fn check_ty(&mut self, cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>) {\n-        if in_macro(hir_ty.span)\n-            || in_impl(cx, hir_ty)\n-            || !meets_msrv(self.msrv.as_ref(), &msrvs::TYPE_ALIAS_ENUM_VARIANTS)\n-        {\n-            return;\n-        }\n-\n-        let lint_dependend_on_expr_kind = if let Some(StackItem::Check {\n-            hir_id,\n-            types_to_lint,\n-            types_to_skip,\n-            ..\n-        }) = self.stack.last()\n-        {\n-            if types_to_skip.contains(&hir_ty.hir_id) {\n-                false\n-            } else if types_to_lint.contains(&hir_ty.hir_id) {\n-                true\n-            } else {\n-                let self_ty = ty_from_hir_id(cx, *hir_id);\n-                should_lint_ty(hir_ty, hir_ty_to_ty(cx.tcx, hir_ty), self_ty)\n-            }\n-        } else {\n-            false\n-        };\n-\n-        if lint_dependend_on_expr_kind {\n-            // FIXME: this span manipulation should not be necessary\n-            // @flip1995 found an ast lowering issue in\n-            // https://github.com/rust-lang/rust/blob/master/src/librustc_ast_lowering/path.rs#l142-l162\n+        if_chain! {\n+            if !in_macro(hir_ty.span) && !in_impl(cx, hir_ty);\n+            if meets_msrv(self.msrv.as_ref(), &msrvs::TYPE_ALIAS_ENUM_VARIANTS);\n+            if let Some(StackItem::Check {\n+                hir_id,\n+                types_to_lint,\n+                types_to_skip,\n+                ..\n+            }) = self.stack.last();\n+            if !types_to_skip.contains(&hir_ty.hir_id);\n+            if types_to_lint.contains(&hir_ty.hir_id)\n+                || {\n+                    let self_ty = ty_from_hir_id(cx, *hir_id);\n+                    should_lint_ty(hir_ty, hir_ty_to_ty(cx.tcx, hir_ty), self_ty)\n+                };\n             let hir = cx.tcx.hir();\n             let id = hir.get_parent_node(hir_ty.hir_id);\n-\n-            if !hir.opt_span(id).map_or(false, in_macro) {\n-                match hir.find(id) {\n-                    Some(Node::Expr(Expr {\n-                        kind: ExprKind::Path(QPath::TypeRelative(_, segment)),\n-                        ..\n-                    })) => span_lint_until_last_segment(cx, hir_ty.span, segment),\n-                    _ => span_lint(cx, hir_ty.span),\n-                }\n+            if !hir.opt_span(id).map_or(false, in_macro);\n+            then {\n+                span_lint(cx, hir_ty.span);\n             }\n         }\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n-        fn expr_ty_matches(cx: &LateContext<'_>, expr: &Expr<'_>, self_ty: Ty<'_>) -> bool {\n-            let def_id = expr.hir_id.owner;\n-            if cx.tcx.has_typeck_results(def_id) {\n-                cx.tcx.typeck(def_id).expr_ty_opt(expr) == Some(self_ty)\n-            } else {\n-                false\n-            }\n-        }\n-\n-        if in_macro(expr.span) || !meets_msrv(self.msrv.as_ref(), &msrvs::TYPE_ALIAS_ENUM_VARIANTS) {\n-            return;\n+        if_chain! {\n+            if !in_macro(expr.span);\n+            if meets_msrv(self.msrv.as_ref(), &msrvs::TYPE_ALIAS_ENUM_VARIANTS);\n+            if let Some(StackItem::Check { hir_id, .. }) = self.stack.last();\n+            if cx.typeck_results().expr_ty(expr) == ty_from_hir_id(cx, *hir_id);\n+            then {} else { return; }\n         }\n-\n-        if let Some(StackItem::Check { hir_id, .. }) = self.stack.last() {\n-            let self_ty = ty_from_hir_id(cx, *hir_id);\n-\n-            match &expr.kind {\n-                ExprKind::Struct(QPath::Resolved(_, path), ..) => {\n-                    if expr_ty_matches(cx, expr, self_ty) {\n-                        match path.res {\n-                            def::Res::SelfTy(..) => (),\n-                            def::Res::Def(DefKind::Variant, _) => span_lint_on_path_until_last_segment(cx, path),\n-                            _ => {\n-                                span_lint(cx, path.span);\n-                            },\n-                        }\n-                    }\n-                },\n-                // tuple struct instantiation (`Foo(arg)` or `Enum::Foo(arg)`)\n-                ExprKind::Call(fun, _) => {\n-                    if let Expr {\n-                        kind: ExprKind::Path(ref qpath),\n-                        ..\n-                    } = fun\n-                    {\n-                        if expr_ty_matches(cx, expr, self_ty) {\n-                            let res = cx.qpath_res(qpath, fun.hir_id);\n-\n-                            if let def::Res::Def(DefKind::Ctor(ctor_of, _), ..) = res {\n-                                match ctor_of {\n-                                    def::CtorOf::Variant => {\n-                                        span_lint_on_qpath_resolved(cx, qpath, true);\n-                                    },\n-                                    def::CtorOf::Struct => {\n-                                        span_lint_on_qpath_resolved(cx, qpath, false);\n-                                    },\n-                                }\n-                            }\n+        match expr.kind {\n+            ExprKind::Struct(QPath::Resolved(_, path), ..) => match path.res {\n+                Res::SelfTy(..) => (),\n+                Res::Def(DefKind::Variant, _) => lint_path_to_variant(cx, path),\n+                _ => span_lint(cx, path.span),\n+            },\n+            // tuple struct instantiation (`Foo(arg)` or `Enum::Foo(arg)`)\n+            ExprKind::Call(fun, _) => {\n+                if let ExprKind::Path(QPath::Resolved(_, path)) = fun.kind {\n+                    if let Res::Def(DefKind::Ctor(ctor_of, _), ..) = path.res {\n+                        match ctor_of {\n+                            CtorOf::Variant => lint_path_to_variant(cx, path),\n+                            CtorOf::Struct => span_lint(cx, path.span),\n                         }\n                     }\n-                },\n-                // unit enum variants (`Enum::A`)\n-                ExprKind::Path(qpath) => {\n-                    if expr_ty_matches(cx, expr, self_ty) {\n-                        span_lint_on_qpath_resolved(cx, qpath, true);\n-                    }\n-                },\n-                _ => (),\n-            }\n+                }\n+            },\n+            // unit enum variants (`Enum::A`)\n+            ExprKind::Path(QPath::Resolved(_, path)) => lint_path_to_variant(cx, path),\n+            _ => (),\n         }\n     }\n \n@@ -405,33 +350,12 @@ fn span_lint(cx: &LateContext<'_>, span: Span) {\n     );\n }\n \n-#[allow(clippy::cast_possible_truncation)]\n-fn span_lint_until_last_segment(cx: &LateContext<'_>, span: Span, segment: &PathSegment<'_>) {\n-    let sp = span.with_hi(segment.ident.span.lo());\n-    // remove the trailing ::\n-    let span_without_last_segment = match snippet_opt(cx, sp) {\n-        Some(snippet) => match snippet.rfind(\"::\") {\n-            Some(bidx) => sp.with_hi(sp.lo() + BytePos(bidx as u32)),\n-            None => sp,\n-        },\n-        None => sp,\n-    };\n-    span_lint(cx, span_without_last_segment);\n-}\n-\n-fn span_lint_on_path_until_last_segment(cx: &LateContext<'_>, path: &Path<'_>) {\n-    if path.segments.len() > 1 {\n-        span_lint_until_last_segment(cx, path.span, path.segments.last().unwrap());\n-    }\n-}\n-\n-fn span_lint_on_qpath_resolved(cx: &LateContext<'_>, qpath: &QPath<'_>, until_last_segment: bool) {\n-    if let QPath::Resolved(_, path) = qpath {\n-        if until_last_segment {\n-            span_lint_on_path_until_last_segment(cx, path);\n-        } else {\n-            span_lint(cx, path.span);\n-        }\n+fn lint_path_to_variant(cx: &LateContext<'_>, path: &Path<'_>) {\n+    if let [.., self_seg, _variant] = path.segments {\n+        let span = path\n+            .span\n+            .with_hi(self_seg.args().span_ext().unwrap_or(self_seg.ident.span).hi());\n+        span_lint(cx, span);\n     }\n }\n \n@@ -462,7 +386,7 @@ fn should_lint_ty(hir_ty: &hir::Ty<'_>, ty: Ty<'_>, self_ty: Ty<'_>) -> bool {\n         if same_type_and_consts(ty, self_ty);\n         if let TyKind::Path(QPath::Resolved(_, path)) = hir_ty.kind;\n         then {\n-            !matches!(path.res, def::Res::SelfTy(..))\n+            !matches!(path.res, Res::SelfTy(..) | Res::Def(DefKind::TyParam, _))\n         } else {\n             false\n         }"}, {"sha": "ad2cb27650ece69e674ba1d48049eb84360977af", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -149,7 +149,7 @@ define_Conf! {\n         \"WebGL\",\n         \"TensorFlow\",\n         \"TrueType\",\n-        \"iOS\", \"macOS\",\n+        \"iOS\", \"macOS\", \"FreeBSD\",\n         \"TeX\", \"LaTeX\", \"BibTeX\", \"BibLaTeX\",\n         \"MinGW\",\n         \"CamelCase\",\n@@ -190,6 +190,8 @@ define_Conf! {\n     (warn_on_all_wildcard_imports: bool = false),\n     /// Lint: DISALLOWED_METHOD. The list of disallowed methods, written as fully qualified paths.\n     (disallowed_methods: Vec<String> = Vec::new()),\n+    /// Lint: DISALLOWED_TYPE. The list of disallowed types, written as fully qualified paths.\n+    (disallowed_types: Vec<String> = Vec::new()),\n     /// Lint: UNREADABLE_LITERAL. Should the fraction of a decimal be linted to include separators.\n     (unreadable_literal_lint_fractions: bool = true),\n     /// Lint: UPPER_CASE_ACRONYMS. Enables verbose mode. Triggers if there is more than one uppercase char next to each other"}, {"sha": "c980a0246fd2bb847713feea03902e7158ff45a4", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -9,6 +9,7 @@\n //! a simple mistake)\n \n use if_chain::if_chain;\n+use rustc_ast as ast;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::{\n     self as hir, def::DefKind, intravisit, intravisit::Visitor, ExprKind, Item, ItemKind, Mutability, QPath,\n@@ -485,16 +486,32 @@ fn extract_attr_docs_or_lint(cx: &LateContext<'_>, item: &Item<'_>) -> Option<St\n ///\n /// Would result in `Hello world!\\n=^.^=\\n`\n fn extract_attr_docs(cx: &LateContext<'_>, item: &Item<'_>) -> Option<String> {\n-    cx.tcx\n-        .hir()\n-        .attrs(item.hir_id())\n-        .iter()\n-        .filter_map(|x| x.doc_str().map(|sym| sym.as_str().to_string()))\n-        .reduce(|mut acc, sym| {\n-            acc.push_str(&sym);\n-            acc.push('\\n');\n-            acc\n-        })\n+    let attrs = cx.tcx.hir().attrs(item.hir_id());\n+    let mut lines = attrs.iter().filter_map(ast::Attribute::doc_str);\n+    let mut docs = String::from(&*lines.next()?.as_str());\n+    let mut in_code_block = false;\n+    for line in lines {\n+        docs.push('\\n');\n+        let line = line.as_str();\n+        let line = &*line;\n+        if let Some(info) = line.trim_start().strip_prefix(\"```\") {\n+            in_code_block = !in_code_block;\n+            if in_code_block {\n+                let lang = info\n+                    .trim()\n+                    .split(',')\n+                    // remove rustdoc directives\n+                    .find(|&s| !matches!(s, \"\" | \"ignore\" | \"no_run\" | \"should_panic\"))\n+                    // if no language is present, fill in \"rust\"\n+                    .unwrap_or(\"rust\");\n+                docs.push_str(\"```\");\n+                docs.push_str(lang);\n+                continue;\n+            }\n+        }\n+        docs.push_str(line);\n+    }\n+    Some(docs)\n }\n \n fn get_lint_group_and_level_or_lint("}, {"sha": "30c2260d15cacdeb05d30416ff5d0c6276c2ecb2", "filename": "clippy_utils/src/ast_utils.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_utils%2Fsrc%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_utils%2Fsrc%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fast_utils.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -47,9 +47,14 @@ pub fn eq_pat(l: &Pat, r: &Pat) -> bool {\n         | (Ref(l, Mutability::Mut), Ref(r, Mutability::Mut)) => eq_pat(l, r),\n         (Tuple(l), Tuple(r)) | (Slice(l), Slice(r)) => over(l, r, |l, r| eq_pat(l, r)),\n         (Path(lq, lp), Path(rq, rp)) => both(lq, rq, |l, r| eq_qself(l, r)) && eq_path(lp, rp),\n-        (TupleStruct(lqself, lp, lfs), TupleStruct(rqself, rp, rfs)) => eq_maybe_qself(lqself, rqself) && eq_path(lp, rp) && over(lfs, rfs, |l, r| eq_pat(l, r)),\n+        (TupleStruct(lqself, lp, lfs), TupleStruct(rqself, rp, rfs)) => {\n+            eq_maybe_qself(lqself, rqself) && eq_path(lp, rp) && over(lfs, rfs, |l, r| eq_pat(l, r))\n+        },\n         (Struct(lqself, lp, lfs, lr), Struct(rqself, rp, rfs, rr)) => {\n-            lr == rr && eq_maybe_qself(lqself, rqself) &&eq_path(lp, rp) && unordered_over(lfs, rfs, |lf, rf| eq_field_pat(lf, rf))\n+            lr == rr\n+                && eq_maybe_qself(lqself, rqself)\n+                && eq_path(lp, rp)\n+                && unordered_over(lfs, rfs, |lf, rf| eq_field_pat(lf, rf))\n         },\n         (Or(ls), Or(rs)) => unordered_over(ls, rs, |l, r| eq_pat(l, r)),\n         (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n@@ -82,7 +87,7 @@ pub fn eq_maybe_qself(l: &Option<QSelf>, r: &Option<QSelf>) -> bool {\n     match (l, r) {\n         (Some(l), Some(r)) => eq_qself(l, r),\n         (None, None) => true,\n-        _ => false\n+        _ => false,\n     }\n }\n \n@@ -178,7 +183,7 @@ pub fn eq_expr(l: &Expr, r: &Expr) -> bool {\n         (Path(lq, lp), Path(rq, rp)) => both(lq, rq, |l, r| eq_qself(l, r)) && eq_path(lp, rp),\n         (MacCall(l), MacCall(r)) => eq_mac_call(l, r),\n         (Struct(lse), Struct(rse)) => {\n-            eq_maybe_qself(&lse.qself, &rse.qself) \n+            eq_maybe_qself(&lse.qself, &rse.qself)\n                 && eq_path(&lse.path, &rse.path)\n                 && eq_struct_rest(&lse.rest, &rse.rest)\n                 && unordered_over(&lse.fields, &rse.fields, |l, r| eq_field(l, r))"}, {"sha": "15c27d1a996d74e97abfc58d4f9752405b8f727a", "filename": "clippy_utils/src/consts.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fconsts.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -1,6 +1,6 @@\n #![allow(clippy::float_cmp)]\n \n-use crate::{clip, sext, unsext};\n+use crate::{clip, is_direct_expn_of, sext, unsext};\n use if_chain::if_chain;\n use rustc_ast::ast::{self, LitFloatType, LitKind};\n use rustc_data_structures::sync::Lrc;\n@@ -230,7 +230,13 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n         match e.kind {\n             ExprKind::Path(ref qpath) => self.fetch_path(qpath, e.hir_id, self.typeck_results.expr_ty(e)),\n             ExprKind::Block(block, _) => self.block(block),\n-            ExprKind::Lit(ref lit) => Some(lit_to_constant(&lit.node, self.typeck_results.expr_ty_opt(e))),\n+            ExprKind::Lit(ref lit) => {\n+                if is_direct_expn_of(e.span, \"cfg\").is_some() {\n+                    None\n+                } else {\n+                    Some(lit_to_constant(&lit.node, self.typeck_results.expr_ty_opt(e)))\n+                }\n+            },\n             ExprKind::Array(vec) => self.multi(vec).map(Constant::Vec),\n             ExprKind::Tup(tup) => self.multi(tup).map(Constant::Tuple),\n             ExprKind::Repeat(value, _) => {"}, {"sha": "66e75b0c20638e8d89f50c9495fb9b3b57793c23", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 69, "deletions": 25, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -72,7 +72,7 @@ use rustc_hir::LangItem::{ResultErr, ResultOk};\n use rustc_hir::{\n     def, Arm, BindingAnnotation, Block, Body, Constness, Destination, Expr, ExprKind, FnDecl, GenericArgs, HirId, Impl,\n     ImplItem, ImplItemKind, IsAsync, Item, ItemKind, LangItem, Local, MatchSource, Node, Param, Pat, PatKind, Path,\n-    PathSegment, QPath, Stmt, StmtKind, TraitItem, TraitItemKind, TraitRef, TyKind,\n+    PathSegment, QPath, Stmt, StmtKind, TraitItem, TraitItemKind, TraitRef, TyKind, UnOp,\n };\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::exports::Export;\n@@ -326,16 +326,6 @@ pub fn is_trait_method(cx: &LateContext<'_>, expr: &Expr<'_>, diag_item: Symbol)\n         .map_or(false, |did| is_diag_trait_item(cx, did, diag_item))\n }\n \n-/// Checks if an expression references a variable of the given name.\n-pub fn match_var(expr: &Expr<'_>, var: Symbol) -> bool {\n-    if let ExprKind::Path(QPath::Resolved(None, path)) = expr.kind {\n-        if let [p] = path.segments {\n-            return p.ident.name == var;\n-        }\n-    }\n-    false\n-}\n-\n pub fn last_path_segment<'tcx>(path: &QPath<'tcx>) -> &'tcx PathSegment<'tcx> {\n     match *path {\n         QPath::Resolved(_, path) => path.segments.last().expect(\"A path must have at least one segment\"),\n@@ -707,16 +697,6 @@ pub fn get_item_name(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<Symbol> {\n     }\n }\n \n-/// Gets the name of a `Pat`, if any.\n-pub fn get_pat_name(pat: &Pat<'_>) -> Option<Symbol> {\n-    match pat.kind {\n-        PatKind::Binding(.., ref spname, _) => Some(spname.name),\n-        PatKind::Path(ref qpath) => single_segment_path(qpath).map(|ps| ps.ident.name),\n-        PatKind::Box(p) | PatKind::Ref(p, _) => get_pat_name(&*p),\n-        _ => None,\n-    }\n-}\n-\n pub struct ContainsName {\n     pub name: Symbol,\n     pub result: bool,\n@@ -861,14 +841,16 @@ pub fn get_enclosing_block<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Optio\n     })\n }\n \n-/// Gets the loop enclosing the given expression, if any.\n-pub fn get_enclosing_loop(tcx: TyCtxt<'tcx>, expr: &Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n+/// Gets the loop or closure enclosing the given expression, if any.\n+pub fn get_enclosing_loop_or_closure(tcx: TyCtxt<'tcx>, expr: &Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n     let map = tcx.hir();\n     for (_, node) in map.parent_iter(expr.hir_id) {\n         match node {\n             Node::Expr(\n-                e @ Expr {\n-                    kind: ExprKind::Loop(..),\n+                e\n+                @\n+                Expr {\n+                    kind: ExprKind::Loop(..) | ExprKind::Closure(..),\n                     ..\n                 },\n             ) => return Some(e),\n@@ -1399,6 +1381,55 @@ pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     did.map_or(false, |did| must_use_attr(cx.tcx.get_attrs(did)).is_some())\n }\n \n+/// Checks if an expression represents the identity function\n+/// Only examines closures and `std::convert::identity`\n+pub fn is_expr_identity_function(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    /// Checks if a function's body represents the identity function. Looks for bodies of the form:\n+    /// * `|x| x`\n+    /// * `|x| return x`\n+    /// * `|x| { return x }`\n+    /// * `|x| { return x; }`\n+    fn is_body_identity_function(cx: &LateContext<'_>, func: &Body<'_>) -> bool {\n+        let id = if_chain! {\n+            if let [param] = func.params;\n+            if let PatKind::Binding(_, id, _, _) = param.pat.kind;\n+            then {\n+                id\n+            } else {\n+                return false;\n+            }\n+        };\n+\n+        let mut expr = &func.value;\n+        loop {\n+            match expr.kind {\n+                #[rustfmt::skip]\n+                ExprKind::Block(&Block { stmts: [], expr: Some(e), .. }, _, )\n+                | ExprKind::Ret(Some(e)) => expr = e,\n+                #[rustfmt::skip]\n+                ExprKind::Block(&Block { stmts: [stmt], expr: None, .. }, _) => {\n+                    if_chain! {\n+                        if let StmtKind::Semi(e) | StmtKind::Expr(e) = stmt.kind;\n+                        if let ExprKind::Ret(Some(ret_val)) = e.kind;\n+                        then {\n+                            expr = ret_val;\n+                        } else {\n+                            return false;\n+                        }\n+                    }\n+                },\n+                _ => return path_to_local_id(expr, id) && cx.typeck_results().expr_adjustments(expr).is_empty(),\n+            }\n+        }\n+    }\n+\n+    match expr.kind {\n+        ExprKind::Closure(_, _, body_id, _, _) => is_body_identity_function(cx, cx.tcx.hir().body(body_id)),\n+        ExprKind::Path(ref path) => is_qpath_def_path(cx, path, expr.hir_id, &paths::CONVERT_IDENTITY),\n+        _ => false,\n+    }\n+}\n+\n /// Gets the node where an expression is either used, or it's type is unified with another branch.\n pub fn get_expr_use_or_unification_node(tcx: TyCtxt<'tcx>, expr: &Expr<'_>) -> Option<Node<'tcx>> {\n     let map = tcx.hir();\n@@ -1654,6 +1685,19 @@ pub fn peel_hir_expr_refs(expr: &'a Expr<'a>) -> (&'a Expr<'a>, usize) {\n     (e, count)\n }\n \n+/// Removes `AddrOf` operators (`&`) or deref operators (`*`), but only if a reference type is\n+/// dereferenced. An overloaded deref such as `Vec` to slice would not be removed.\n+pub fn peel_ref_operators<'hir>(cx: &LateContext<'_>, mut expr: &'hir Expr<'hir>) -> &'hir Expr<'hir> {\n+    loop {\n+        match expr.kind {\n+            ExprKind::AddrOf(_, _, e) => expr = e,\n+            ExprKind::Unary(UnOp::Deref, e) if cx.typeck_results().expr_ty(e).is_ref() => expr = e,\n+            _ => break,\n+        }\n+    }\n+    expr\n+}\n+\n #[macro_export]\n macro_rules! unwrap_cargo_metadata {\n     ($cx: ident, $lint: ident, $deps: expr) => {{"}, {"sha": "8adb691595213fd80cd036f1aa50fa20cadd97a1", "filename": "clippy_utils/src/ptr.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_utils%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/clippy_utils%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fptr.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -1,10 +1,10 @@\n use crate::source::snippet;\n-use crate::{get_pat_name, match_var};\n+use crate::{path_to_local_id, strip_pat_refs};\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n-use rustc_hir::{Body, BodyId, Expr, ExprKind, Param};\n+use rustc_hir::{Body, BodyId, Expr, ExprKind, HirId, PatKind};\n use rustc_lint::LateContext;\n use rustc_middle::hir::map::Map;\n-use rustc_span::{Span, Symbol};\n+use rustc_span::Span;\n use std::borrow::Cow;\n \n pub fn get_spans(\n@@ -14,24 +14,25 @@ pub fn get_spans(\n     replacements: &[(&'static str, &'static str)],\n ) -> Option<Vec<(Span, Cow<'static, str>)>> {\n     if let Some(body) = opt_body_id.map(|id| cx.tcx.hir().body(id)) {\n-        get_binding_name(&body.params[idx]).map_or_else(\n-            || Some(vec![]),\n-            |name| extract_clone_suggestions(cx, name, replacements, body),\n-        )\n+        if let PatKind::Binding(_, binding_id, _, _) = strip_pat_refs(body.params[idx].pat).kind {\n+            extract_clone_suggestions(cx, binding_id, replacements, body)\n+        } else {\n+            Some(vec![])\n+        }\n     } else {\n         Some(vec![])\n     }\n }\n \n fn extract_clone_suggestions<'tcx>(\n     cx: &LateContext<'tcx>,\n-    name: Symbol,\n+    id: HirId,\n     replace: &[(&'static str, &'static str)],\n     body: &'tcx Body<'_>,\n ) -> Option<Vec<(Span, Cow<'static, str>)>> {\n     let mut visitor = PtrCloneVisitor {\n         cx,\n-        name,\n+        id,\n         replace,\n         spans: vec![],\n         abort: false,\n@@ -42,7 +43,7 @@ fn extract_clone_suggestions<'tcx>(\n \n struct PtrCloneVisitor<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n-    name: Symbol,\n+    id: HirId,\n     replace: &'a [(&'static str, &'static str)],\n     spans: Vec<(Span, Cow<'static, str>)>,\n     abort: bool,\n@@ -55,16 +56,15 @@ impl<'a, 'tcx> Visitor<'tcx> for PtrCloneVisitor<'a, 'tcx> {\n         if self.abort {\n             return;\n         }\n-        if let ExprKind::MethodCall(seg, _, args, _) = expr.kind {\n-            if args.len() == 1 && match_var(&args[0], self.name) {\n+        if let ExprKind::MethodCall(seg, _, [recv], _) = expr.kind {\n+            if path_to_local_id(recv, self.id) {\n                 if seg.ident.name.as_str() == \"capacity\" {\n                     self.abort = true;\n                     return;\n                 }\n                 for &(fn_name, suffix) in self.replace {\n                     if seg.ident.name.as_str() == fn_name {\n-                        self.spans\n-                            .push((expr.span, snippet(self.cx, args[0].span, \"_\") + suffix));\n+                        self.spans.push((expr.span, snippet(self.cx, recv.span, \"_\") + suffix));\n                         return;\n                     }\n                 }\n@@ -77,7 +77,3 @@ impl<'a, 'tcx> Visitor<'tcx> for PtrCloneVisitor<'a, 'tcx> {\n         NestedVisitorMap::None\n     }\n }\n-\n-fn get_binding_name(arg: &Param<'_>) -> Option<Symbol> {\n-    get_pat_name(arg.pat)\n-}"}, {"sha": "0a85f65001101c4fa5a172ac462b73d781e5e125", "filename": "doc/common_tools_writing_lints.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/doc%2Fcommon_tools_writing_lints.md", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/doc%2Fcommon_tools_writing_lints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Fcommon_tools_writing_lints.md?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -6,7 +6,7 @@ You may need following tooltips to catch up with common operations.\n   - [Retrieving the type of an expression](#retrieving-the-type-of-an-expression)\n   - [Checking if an expression is calling a specific method](#checking-if-an-expr-is-calling-a-specific-method)\n   - [Checking if a type implements a specific trait](#checking-if-a-type-implements-a-specific-trait)\n-  - [Checking if a type defines a method](#checking-if-a-type-defines-a-method)\n+  - [Checking if a type defines a specific method](#checking-if-a-type-defines-a-specific-method)\n   - [Dealing with macros](#dealing-with-macros)\n \n Useful Rustc dev guide links:"}, {"sha": "afe3033c288cffd8d95b06ea2e833989455cb81a", "filename": "doc/release.md", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/doc%2Frelease.md", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/doc%2Frelease.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frelease.md?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -101,6 +101,21 @@ After this, the release should be available on the Clippy [release page].\n \n [release page]: https://github.com/rust-lang/rust-clippy/releases\n \n+## Update the `stable` branch\n+\n+At this step you should have already checked out the commit of the `rust-1.XX.0`\n+tag. Updating the stable branch from here is as easy as:\n+\n+```bash\n+# Assuming the current directory corresponds to the Clippy repository and the\n+# commit of the just created rust-1.XX.0 tag is checked out.\n+$ git push upstream rust-1.XX.0:stable  # `upstream` is the `rust-lang/rust-clippy` remote\n+```\n+\n+_NOTE: Usually there are no stable backports for Clippy, so this update should\n+be possible without force pushing or anything like this. If there should have\n+happened a stable backport, make sure to re-merge those changes just as with the\n+`beta` branch._\n \n ## Update `CHANGELOG.md`\n "}, {"sha": "a3245da68250c3d28939ddb5da02dc08fbb938ce", "filename": "tests/ui-toml/toml_disallowed_method/clippy.toml", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui-toml%2Ftoml_disallowed_method%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui-toml%2Ftoml_disallowed_method%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_disallowed_method%2Fclippy.toml?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -1 +1,5 @@\n-disallowed-methods = [\"core::iter::traits::iterator::Iterator::sum\", \"regex::re_unicode::Regex::is_match\", \"regex::re_unicode::Regex::new\"]\n+disallowed-methods = [\n+    \"std::iter::Iterator::sum\",\n+    \"regex::Regex::is_match\",\n+    \"regex::Regex::new\"\n+]"}, {"sha": "2eff854c22c3078e55432a8297c3b52190041de1", "filename": "tests/ui-toml/toml_disallowed_type/clippy.toml", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui-toml%2Ftoml_disallowed_type%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui-toml%2Ftoml_disallowed_type%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_disallowed_type%2Fclippy.toml?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -0,0 +1,9 @@\n+disallowed-types = [\n+    \"std::collections::HashMap\",\n+    \"std::sync::atomic::AtomicU32\",\n+    \"syn::TypePath\",\n+    \"proc_macro2::Ident\",\n+    \"std::thread::Thread\",\n+    \"std::time::Instant\",\n+    \"std::io::Read\",\n+]"}, {"sha": "567afb5aec1df83290478d785c28621b15c619fb", "filename": "tests/ui-toml/toml_disallowed_type/conf_disallowed_type.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui-toml%2Ftoml_disallowed_type%2Fconf_disallowed_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui-toml%2Ftoml_disallowed_type%2Fconf_disallowed_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_disallowed_type%2Fconf_disallowed_type.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -0,0 +1,35 @@\n+#![warn(clippy::disallowed_type)]\n+\n+extern crate quote;\n+extern crate syn;\n+\n+use std::sync as foo;\n+use std::sync::atomic::AtomicU32;\n+use std::time::Instant as Sneaky;\n+\n+struct HashMap;\n+\n+fn bad_return_type() -> fn() -> Sneaky {\n+    todo!()\n+}\n+\n+fn bad_arg_type(_: impl Fn(Sneaky) -> foo::atomic::AtomicU32) {\n+    todo!()\n+}\n+\n+fn trait_obj(_: &dyn std::io::Read) {\n+    todo!()\n+}\n+\n+static BAD: foo::atomic::AtomicPtr<()> = foo::atomic::AtomicPtr::new(std::ptr::null_mut());\n+\n+#[allow(clippy::diverging_sub_expression)]\n+fn main() {\n+    let _: std::collections::HashMap<(), ()> = std::collections::HashMap::new();\n+    let _ = Sneaky::now();\n+    let _ = foo::atomic::AtomicU32::new(0);\n+    static FOO: std::sync::atomic::AtomicU32 = foo::atomic::AtomicU32::new(1);\n+    let _: std::collections::BTreeMap<(), syn::TypePath> = Default::default();\n+    let _ = syn::Ident::new(\"\", todo!());\n+    let _ = HashMap;\n+}"}, {"sha": "4e6fd91fba1192d8d27702073679acbd609aff01", "filename": "tests/ui-toml/toml_disallowed_type/conf_disallowed_type.stderr", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui-toml%2Ftoml_disallowed_type%2Fconf_disallowed_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui-toml%2Ftoml_disallowed_type%2Fconf_disallowed_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_disallowed_type%2Fconf_disallowed_type.stderr?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -0,0 +1,88 @@\n+error: `std::sync::atomic::AtomicU32` is not allowed according to config\n+  --> $DIR/conf_disallowed_type.rs:7:1\n+   |\n+LL | use std::sync::atomic::AtomicU32;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::disallowed-type` implied by `-D warnings`\n+\n+error: `std::time::Instant` is not allowed according to config\n+  --> $DIR/conf_disallowed_type.rs:8:1\n+   |\n+LL | use std::time::Instant as Sneaky;\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `std::time::Instant` is not allowed according to config\n+  --> $DIR/conf_disallowed_type.rs:12:33\n+   |\n+LL | fn bad_return_type() -> fn() -> Sneaky {\n+   |                                 ^^^^^^\n+\n+error: `std::time::Instant` is not allowed according to config\n+  --> $DIR/conf_disallowed_type.rs:16:28\n+   |\n+LL | fn bad_arg_type(_: impl Fn(Sneaky) -> foo::atomic::AtomicU32) {\n+   |                            ^^^^^^\n+\n+error: `std::sync::atomic::AtomicU32` is not allowed according to config\n+  --> $DIR/conf_disallowed_type.rs:16:39\n+   |\n+LL | fn bad_arg_type(_: impl Fn(Sneaky) -> foo::atomic::AtomicU32) {\n+   |                                       ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `std::io::Read` is not allowed according to config\n+  --> $DIR/conf_disallowed_type.rs:20:22\n+   |\n+LL | fn trait_obj(_: &dyn std::io::Read) {\n+   |                      ^^^^^^^^^^^^^\n+\n+error: `std::collections::HashMap` is not allowed according to config\n+  --> $DIR/conf_disallowed_type.rs:28:48\n+   |\n+LL |     let _: std::collections::HashMap<(), ()> = std::collections::HashMap::new();\n+   |                                                ^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `std::collections::HashMap` is not allowed according to config\n+  --> $DIR/conf_disallowed_type.rs:28:12\n+   |\n+LL |     let _: std::collections::HashMap<(), ()> = std::collections::HashMap::new();\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `std::time::Instant` is not allowed according to config\n+  --> $DIR/conf_disallowed_type.rs:29:13\n+   |\n+LL |     let _ = Sneaky::now();\n+   |             ^^^^^^\n+\n+error: `std::sync::atomic::AtomicU32` is not allowed according to config\n+  --> $DIR/conf_disallowed_type.rs:30:13\n+   |\n+LL |     let _ = foo::atomic::AtomicU32::new(0);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `std::sync::atomic::AtomicU32` is not allowed according to config\n+  --> $DIR/conf_disallowed_type.rs:31:17\n+   |\n+LL |     static FOO: std::sync::atomic::AtomicU32 = foo::atomic::AtomicU32::new(1);\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `std::sync::atomic::AtomicU32` is not allowed according to config\n+  --> $DIR/conf_disallowed_type.rs:31:48\n+   |\n+LL |     static FOO: std::sync::atomic::AtomicU32 = foo::atomic::AtomicU32::new(1);\n+   |                                                ^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: `syn::TypePath` is not allowed according to config\n+  --> $DIR/conf_disallowed_type.rs:32:43\n+   |\n+LL |     let _: std::collections::BTreeMap<(), syn::TypePath> = Default::default();\n+   |                                           ^^^^^^^^^^^^^\n+\n+error: `proc_macro2::Ident` is not allowed according to config\n+  --> $DIR/conf_disallowed_type.rs:33:13\n+   |\n+LL |     let _ = syn::Ident::new(\"\", todo!());\n+   |             ^^^^^^^^^^\n+\n+error: aborting due to 14 previous errors\n+"}, {"sha": "06d70b66fda869e5c906c6a1c0a94569d3fd75d3", "filename": "tests/ui-toml/toml_unknown_key/conf_unknown_key.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -1,4 +1,4 @@\n-error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `avoid-breaking-exported-api`, `msrv`, `blacklisted-names`, `cognitive-complexity-threshold`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `pass-by-value-size-limit`, `too-many-lines-threshold`, `array-size-threshold`, `vec-box-size-threshold`, `max-trait-bounds`, `max-struct-bools`, `max-fn-params-bools`, `warn-on-all-wildcard-imports`, `disallowed-methods`, `unreadable-literal-lint-fractions`, `upper-case-acronyms-aggressive`, `cargo-ignore-publish`, `third-party` at line 5 column 1\n+error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `avoid-breaking-exported-api`, `msrv`, `blacklisted-names`, `cognitive-complexity-threshold`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `pass-by-value-size-limit`, `too-many-lines-threshold`, `array-size-threshold`, `vec-box-size-threshold`, `max-trait-bounds`, `max-struct-bools`, `max-fn-params-bools`, `warn-on-all-wildcard-imports`, `disallowed-methods`, `disallowed-types`, `unreadable-literal-lint-fractions`, `upper-case-acronyms-aggressive`, `cargo-ignore-publish`, `third-party` at line 5 column 1\n \n error: aborting due to previous error\n "}, {"sha": "283358333cdfd30bb4dfef176b0c25c54cc65519", "filename": "tests/ui/append_instead_of_extend.fixed", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fappend_instead_of_extend.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fappend_instead_of_extend.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fappend_instead_of_extend.fixed?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -0,0 +1,55 @@\n+// run-rustfix\n+#![warn(clippy::append_instead_of_extend)]\n+use std::collections::BinaryHeap;\n+fn main() {\n+    //gets linted\n+    let mut vec1 = vec![0u8; 1024];\n+    let mut vec2: std::vec::Vec<u8> = Vec::new();\n+\n+    vec2.append(&mut vec1);\n+\n+    let mut vec3 = vec![0u8; 1024];\n+    let mut vec4: std::vec::Vec<u8> = Vec::new();\n+\n+    vec4.append(&mut vec3);\n+\n+    let mut vec11: std::vec::Vec<u8> = Vec::new();\n+\n+    vec11.append(&mut return_vector());\n+\n+    //won't get linted it dosen't move the entire content of a vec into another\n+    let mut test1 = vec![0u8, 10];\n+    let mut test2: std::vec::Vec<u8> = Vec::new();\n+\n+    test2.extend(test1.drain(4..10));\n+\n+    let mut vec3 = vec![0u8; 104];\n+    let mut vec7: std::vec::Vec<u8> = Vec::new();\n+\n+    vec3.append(&mut vec7);\n+\n+    let mut vec5 = vec![0u8; 1024];\n+    let mut vec6: std::vec::Vec<u8> = Vec::new();\n+\n+    vec5.extend(vec6.drain(..4));\n+\n+    let mut vec9: std::vec::Vec<u8> = Vec::new();\n+\n+    return_vector().append(&mut vec9);\n+\n+    //won't get linted because it is not a vec\n+\n+    let mut heap = BinaryHeap::from(vec![1, 3]);\n+    let mut heap2 = BinaryHeap::from(vec![]);\n+    heap2.extend(heap.drain())\n+}\n+\n+fn return_vector() -> Vec<u8> {\n+    let mut new_vector = vec![];\n+\n+    for i in 1..10 {\n+        new_vector.push(i)\n+    }\n+\n+    new_vector\n+}"}, {"sha": "abde5cdac5cf7f6079c3d1b77c3595b515c13d19", "filename": "tests/ui/append_instead_of_extend.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fappend_instead_of_extend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fappend_instead_of_extend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fappend_instead_of_extend.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -0,0 +1,55 @@\n+// run-rustfix\n+#![warn(clippy::append_instead_of_extend)]\n+use std::collections::BinaryHeap;\n+fn main() {\n+    //gets linted\n+    let mut vec1 = vec![0u8; 1024];\n+    let mut vec2: std::vec::Vec<u8> = Vec::new();\n+\n+    vec2.extend(vec1.drain(..));\n+\n+    let mut vec3 = vec![0u8; 1024];\n+    let mut vec4: std::vec::Vec<u8> = Vec::new();\n+\n+    vec4.extend(vec3.drain(..));\n+\n+    let mut vec11: std::vec::Vec<u8> = Vec::new();\n+\n+    vec11.extend(return_vector().drain(..));\n+\n+    //won't get linted it dosen't move the entire content of a vec into another\n+    let mut test1 = vec![0u8, 10];\n+    let mut test2: std::vec::Vec<u8> = Vec::new();\n+\n+    test2.extend(test1.drain(4..10));\n+\n+    let mut vec3 = vec![0u8; 104];\n+    let mut vec7: std::vec::Vec<u8> = Vec::new();\n+\n+    vec3.append(&mut vec7);\n+\n+    let mut vec5 = vec![0u8; 1024];\n+    let mut vec6: std::vec::Vec<u8> = Vec::new();\n+\n+    vec5.extend(vec6.drain(..4));\n+\n+    let mut vec9: std::vec::Vec<u8> = Vec::new();\n+\n+    return_vector().append(&mut vec9);\n+\n+    //won't get linted because it is not a vec\n+\n+    let mut heap = BinaryHeap::from(vec![1, 3]);\n+    let mut heap2 = BinaryHeap::from(vec![]);\n+    heap2.extend(heap.drain())\n+}\n+\n+fn return_vector() -> Vec<u8> {\n+    let mut new_vector = vec![];\n+\n+    for i in 1..10 {\n+        new_vector.push(i)\n+    }\n+\n+    new_vector\n+}"}, {"sha": "9d309d981def99cbbc86ceeae681ed097a315b5b", "filename": "tests/ui/append_instead_of_extend.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fappend_instead_of_extend.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fappend_instead_of_extend.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fappend_instead_of_extend.stderr?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -0,0 +1,22 @@\n+error: use of `extend` instead of `append` for adding the full range of a second vector\n+  --> $DIR/append_instead_of_extend.rs:9:5\n+   |\n+LL |     vec2.extend(vec1.drain(..));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `vec2.append(&mut vec1)`\n+   |\n+   = note: `-D clippy::append-instead-of-extend` implied by `-D warnings`\n+\n+error: use of `extend` instead of `append` for adding the full range of a second vector\n+  --> $DIR/append_instead_of_extend.rs:14:5\n+   |\n+LL |     vec4.extend(vec3.drain(..));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `vec4.append(&mut vec3)`\n+\n+error: use of `extend` instead of `append` for adding the full range of a second vector\n+  --> $DIR/append_instead_of_extend.rs:18:5\n+   |\n+LL |     vec11.extend(return_vector().drain(..));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `vec11.append(&mut return_vector())`\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "6617ca183a8cb2cbd37c0fa60c3b4fe1a1eb23cc", "filename": "tests/ui/assertions_on_constants.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fassertions_on_constants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fassertions_on_constants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassertions_on_constants.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -28,4 +28,7 @@ fn main() {\n     debug_assert!(false); // #3948\n     assert_const!(3);\n     assert_const!(-1);\n+\n+    // Don't lint on this:\n+    assert!(cfg!(feature = \"hey\") || cfg!(not(feature = \"asdf\")));\n }"}, {"sha": "170955e726cc573853764fbaaf16b187450bada7", "filename": "tests/ui/auxiliary/macro_rules.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fauxiliary%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fauxiliary%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fauxiliary%2Fmacro_rules.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -106,3 +106,10 @@ macro_rules! field_reassign_with_default {\n         }\n     };\n }\n+\n+#[macro_export]\n+macro_rules! default_numeric_fallback {\n+    () => {\n+        let x = 22;\n+    };\n+}"}, {"sha": "c0625fd1b75e8af15b1e2af3f9d43f749963974b", "filename": "tests/ui/default_numeric_fallback.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fdefault_numeric_fallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fdefault_numeric_fallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -1,10 +1,15 @@\n+// aux-build:macro_rules.rs\n+\n #![warn(clippy::default_numeric_fallback)]\n #![allow(unused)]\n #![allow(clippy::never_loop)]\n #![allow(clippy::no_effect)]\n #![allow(clippy::unnecessary_operation)]\n #![allow(clippy::branches_sharing_code)]\n \n+#[macro_use]\n+extern crate macro_rules;\n+\n mod basic_expr {\n     fn test() {\n         // Should lint unsuffixed literals typed `i32`.\n@@ -133,4 +138,22 @@ mod method_calls {\n     }\n }\n \n+mod in_macro {\n+    macro_rules! internal_macro {\n+        () => {\n+            let x = 22;\n+        };\n+    }\n+\n+    // Should lint in internal macro.\n+    fn internal() {\n+        internal_macro!();\n+    }\n+\n+    // Should NOT lint in external macro.\n+    fn external() {\n+        default_numeric_fallback!();\n+    }\n+}\n+\n fn main() {}"}, {"sha": "5862cd936ac104ac03822912e75bed4dd4130c61", "filename": "tests/ui/default_numeric_fallback.stderr", "status": "modified", "additions": 36, "deletions": 25, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fdefault_numeric_fallback.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fdefault_numeric_fallback.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdefault_numeric_fallback.stderr?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -1,148 +1,159 @@\n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:11:17\n+  --> $DIR/default_numeric_fallback.rs:16:17\n    |\n LL |         let x = 22;\n    |                 ^^ help: consider adding suffix: `22_i32`\n    |\n    = note: `-D clippy::default-numeric-fallback` implied by `-D warnings`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:12:18\n+  --> $DIR/default_numeric_fallback.rs:17:18\n    |\n LL |         let x = [1, 2, 3];\n    |                  ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:12:21\n+  --> $DIR/default_numeric_fallback.rs:17:21\n    |\n LL |         let x = [1, 2, 3];\n    |                     ^ help: consider adding suffix: `2_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:12:24\n+  --> $DIR/default_numeric_fallback.rs:17:24\n    |\n LL |         let x = [1, 2, 3];\n    |                        ^ help: consider adding suffix: `3_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:13:28\n+  --> $DIR/default_numeric_fallback.rs:18:28\n    |\n LL |         let x = if true { (1, 2) } else { (3, 4) };\n    |                            ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:13:31\n+  --> $DIR/default_numeric_fallback.rs:18:31\n    |\n LL |         let x = if true { (1, 2) } else { (3, 4) };\n    |                               ^ help: consider adding suffix: `2_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:13:44\n+  --> $DIR/default_numeric_fallback.rs:18:44\n    |\n LL |         let x = if true { (1, 2) } else { (3, 4) };\n    |                                            ^ help: consider adding suffix: `3_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:13:47\n+  --> $DIR/default_numeric_fallback.rs:18:47\n    |\n LL |         let x = if true { (1, 2) } else { (3, 4) };\n    |                                               ^ help: consider adding suffix: `4_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:14:23\n+  --> $DIR/default_numeric_fallback.rs:19:23\n    |\n LL |         let x = match 1 {\n    |                       ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:15:13\n+  --> $DIR/default_numeric_fallback.rs:20:13\n    |\n LL |             1 => 1,\n    |             ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:15:18\n+  --> $DIR/default_numeric_fallback.rs:20:18\n    |\n LL |             1 => 1,\n    |                  ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:16:18\n+  --> $DIR/default_numeric_fallback.rs:21:18\n    |\n LL |             _ => 2,\n    |                  ^ help: consider adding suffix: `2_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:20:17\n+  --> $DIR/default_numeric_fallback.rs:25:17\n    |\n LL |         let x = 0.12;\n    |                 ^^^^ help: consider adding suffix: `0.12_f64`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:38:21\n+  --> $DIR/default_numeric_fallback.rs:43:21\n    |\n LL |             let y = 1;\n    |                     ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:46:21\n+  --> $DIR/default_numeric_fallback.rs:51:21\n    |\n LL |             let y = 1;\n    |                     ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:52:21\n+  --> $DIR/default_numeric_fallback.rs:57:21\n    |\n LL |             let y = 1;\n    |                     ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:64:9\n+  --> $DIR/default_numeric_fallback.rs:69:9\n    |\n LL |         1\n    |         ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:70:27\n+  --> $DIR/default_numeric_fallback.rs:75:27\n    |\n LL |         let f = || -> _ { 1 };\n    |                           ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:74:29\n+  --> $DIR/default_numeric_fallback.rs:79:29\n    |\n LL |         let f = || -> i32 { 1 };\n    |                             ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:88:21\n+  --> $DIR/default_numeric_fallback.rs:93:21\n    |\n LL |         generic_arg(1);\n    |                     ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:91:32\n+  --> $DIR/default_numeric_fallback.rs:96:32\n    |\n LL |         let x: _ = generic_arg(1);\n    |                                ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:109:28\n+  --> $DIR/default_numeric_fallback.rs:114:28\n    |\n LL |         GenericStruct { x: 1 };\n    |                            ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:112:36\n+  --> $DIR/default_numeric_fallback.rs:117:36\n    |\n LL |         let _ = GenericStruct { x: 1 };\n    |                                    ^ help: consider adding suffix: `1_i32`\n \n error: default numeric fallback might occur\n-  --> $DIR/default_numeric_fallback.rs:132:23\n+  --> $DIR/default_numeric_fallback.rs:137:23\n    |\n LL |         s.generic_arg(1);\n    |                       ^ help: consider adding suffix: `1_i32`\n \n-error: aborting due to 24 previous errors\n+error: default numeric fallback might occur\n+  --> $DIR/default_numeric_fallback.rs:144:21\n+   |\n+LL |             let x = 22;\n+   |                     ^^ help: consider adding suffix: `22_i32`\n+...\n+LL |         internal_macro!();\n+   |         ------------------ in this macro invocation\n+   |\n+   = note: this error originates in the macro `internal_macro` (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 25 previous errors\n "}, {"sha": "8afef6b23d47653c27a9f2d2398ed411fd08667a", "filename": "tests/ui/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fdoc.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -64,7 +64,7 @@ fn test_units() {\n /// WebGL\n /// TensorFlow\n /// TrueType\n-/// iOS macOS\n+/// iOS macOS FreeBSD\n /// TeX LaTeX BibTeX BibLaTeX\n /// MinGW\n /// CamelCase (see also #2395)"}, {"sha": "787053fb00064c861a75c37410ae26767ab2322e", "filename": "tests/ui/field_reassign_with_default.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Ffield_reassign_with_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Ffield_reassign_with_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffield_reassign_with_default.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -29,6 +29,21 @@ struct C {\n     i: Vec<i32>,\n     j: i64,\n }\n+\n+#[derive(Default)]\n+struct D {\n+    a: Option<i32>,\n+    b: Option<i32>,\n+}\n+\n+macro_rules! m {\n+    ($key:ident: $value:tt) => {{\n+        let mut data = $crate::D::default();\n+        data.$key = Some($value);\n+        data\n+    }};\n+}\n+\n /// Implements .next() that returns a different number each time.\n struct SideEffect(i32);\n \n@@ -143,6 +158,11 @@ fn main() {\n \n     let mut a: WrapperMulti<i32, i64> = Default::default();\n     a.i = 42;\n+\n+    // Don't lint in macros\n+    m! {\n+        a: 42\n+    };\n }\n \n mod m {"}, {"sha": "b56db08ec8a787f63c3edc31fde93178a0237982", "filename": "tests/ui/field_reassign_with_default.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Ffield_reassign_with_default.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Ffield_reassign_with_default.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffield_reassign_with_default.stderr?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -1,108 +1,108 @@\n error: field assignment outside of initializer for an instance created with Default::default()\n-  --> $DIR/field_reassign_with_default.rs:48:5\n+  --> $DIR/field_reassign_with_default.rs:63:5\n    |\n LL |     a.i = 42;\n    |     ^^^^^^^^^\n    |\n    = note: `-D clippy::field-reassign-with-default` implied by `-D warnings`\n note: consider initializing the variable with `main::A { i: 42, ..Default::default() }` and removing relevant reassignments\n-  --> $DIR/field_reassign_with_default.rs:47:5\n+  --> $DIR/field_reassign_with_default.rs:62:5\n    |\n LL |     let mut a: A = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: field assignment outside of initializer for an instance created with Default::default()\n-  --> $DIR/field_reassign_with_default.rs:88:5\n+  --> $DIR/field_reassign_with_default.rs:103:5\n    |\n LL |     a.j = 43;\n    |     ^^^^^^^^^\n    |\n note: consider initializing the variable with `main::A { j: 43, i: 42 }` and removing relevant reassignments\n-  --> $DIR/field_reassign_with_default.rs:87:5\n+  --> $DIR/field_reassign_with_default.rs:102:5\n    |\n LL |     let mut a: A = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: field assignment outside of initializer for an instance created with Default::default()\n-  --> $DIR/field_reassign_with_default.rs:93:5\n+  --> $DIR/field_reassign_with_default.rs:108:5\n    |\n LL |     a.i = 42;\n    |     ^^^^^^^^^\n    |\n note: consider initializing the variable with `main::A { i: 42, j: 44 }` and removing relevant reassignments\n-  --> $DIR/field_reassign_with_default.rs:92:5\n+  --> $DIR/field_reassign_with_default.rs:107:5\n    |\n LL |     let mut a: A = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: field assignment outside of initializer for an instance created with Default::default()\n-  --> $DIR/field_reassign_with_default.rs:99:5\n+  --> $DIR/field_reassign_with_default.rs:114:5\n    |\n LL |     a.i = 42;\n    |     ^^^^^^^^^\n    |\n note: consider initializing the variable with `main::A { i: 42, ..Default::default() }` and removing relevant reassignments\n-  --> $DIR/field_reassign_with_default.rs:98:5\n+  --> $DIR/field_reassign_with_default.rs:113:5\n    |\n LL |     let mut a = A::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: field assignment outside of initializer for an instance created with Default::default()\n-  --> $DIR/field_reassign_with_default.rs:109:5\n+  --> $DIR/field_reassign_with_default.rs:124:5\n    |\n LL |     a.i = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: consider initializing the variable with `main::A { i: Default::default(), ..Default::default() }` and removing relevant reassignments\n-  --> $DIR/field_reassign_with_default.rs:108:5\n+  --> $DIR/field_reassign_with_default.rs:123:5\n    |\n LL |     let mut a: A = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: field assignment outside of initializer for an instance created with Default::default()\n-  --> $DIR/field_reassign_with_default.rs:113:5\n+  --> $DIR/field_reassign_with_default.rs:128:5\n    |\n LL |     a.i = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: consider initializing the variable with `main::A { i: Default::default(), j: 45 }` and removing relevant reassignments\n-  --> $DIR/field_reassign_with_default.rs:112:5\n+  --> $DIR/field_reassign_with_default.rs:127:5\n    |\n LL |     let mut a: A = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: field assignment outside of initializer for an instance created with Default::default()\n-  --> $DIR/field_reassign_with_default.rs:135:5\n+  --> $DIR/field_reassign_with_default.rs:150:5\n    |\n LL |     a.i = vec![1];\n    |     ^^^^^^^^^^^^^^\n    |\n note: consider initializing the variable with `C { i: vec![1], ..Default::default() }` and removing relevant reassignments\n-  --> $DIR/field_reassign_with_default.rs:134:5\n+  --> $DIR/field_reassign_with_default.rs:149:5\n    |\n LL |     let mut a: C = C::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: field assignment outside of initializer for an instance created with Default::default()\n-  --> $DIR/field_reassign_with_default.rs:142:5\n+  --> $DIR/field_reassign_with_default.rs:157:5\n    |\n LL |     a.i = true;\n    |     ^^^^^^^^^^^\n    |\n note: consider initializing the variable with `Wrapper::<bool> { i: true }` and removing relevant reassignments\n-  --> $DIR/field_reassign_with_default.rs:141:5\n+  --> $DIR/field_reassign_with_default.rs:156:5\n    |\n LL |     let mut a: Wrapper<bool> = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: field assignment outside of initializer for an instance created with Default::default()\n-  --> $DIR/field_reassign_with_default.rs:145:5\n+  --> $DIR/field_reassign_with_default.rs:160:5\n    |\n LL |     a.i = 42;\n    |     ^^^^^^^^^\n    |\n note: consider initializing the variable with `WrapperMulti::<i32, i64> { i: 42, ..Default::default() }` and removing relevant reassignments\n-  --> $DIR/field_reassign_with_default.rs:144:5\n+  --> $DIR/field_reassign_with_default.rs:159:5\n    |\n LL |     let mut a: WrapperMulti<i32, i64> = Default::default();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "a5860aa49b3bb7f909aeee04e130285188fd0ae8", "filename": "tests/ui/filter_map_identity.fixed", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Ffilter_map_identity.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Ffilter_map_identity.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffilter_map_identity.fixed?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(unused_imports)]\n+#![allow(unused_imports, clippy::needless_return)]\n #![warn(clippy::filter_map_identity)]\n \n fn main() {\n@@ -13,4 +13,7 @@ fn main() {\n     use std::convert::identity;\n     let iterator = vec![Some(1), None, Some(2)].into_iter();\n     let _ = iterator.flatten();\n+\n+    let iterator = vec![Some(1), None, Some(2)].into_iter();\n+    let _ = iterator.flatten();\n }"}, {"sha": "7e998b9cdf7010f4cd6e1fa84af582a3450dd6eb", "filename": "tests/ui/filter_map_identity.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Ffilter_map_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Ffilter_map_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffilter_map_identity.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(unused_imports)]\n+#![allow(unused_imports, clippy::needless_return)]\n #![warn(clippy::filter_map_identity)]\n \n fn main() {\n@@ -13,4 +13,7 @@ fn main() {\n     use std::convert::identity;\n     let iterator = vec![Some(1), None, Some(2)].into_iter();\n     let _ = iterator.filter_map(identity);\n+\n+    let iterator = vec![Some(1), None, Some(2)].into_iter();\n+    let _ = iterator.filter_map(|x| return x);\n }"}, {"sha": "43c9fdca4fbe0251b54e6e6c70f4ab2fe3873eb8", "filename": "tests/ui/filter_map_identity.stderr", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Ffilter_map_identity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Ffilter_map_identity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffilter_map_identity.stderr?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -1,22 +1,28 @@\n-error: called `filter_map(|x| x)` on an `Iterator`\n+error: use of `filter_map` with an identity function\n   --> $DIR/filter_map_identity.rs:8:22\n    |\n LL |     let _ = iterator.filter_map(|x| x);\n    |                      ^^^^^^^^^^^^^^^^^ help: try: `flatten()`\n    |\n    = note: `-D clippy::filter-map-identity` implied by `-D warnings`\n \n-error: called `filter_map(std::convert::identity)` on an `Iterator`\n+error: use of `filter_map` with an identity function\n   --> $DIR/filter_map_identity.rs:11:22\n    |\n LL |     let _ = iterator.filter_map(std::convert::identity);\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `flatten()`\n \n-error: called `filter_map(std::convert::identity)` on an `Iterator`\n+error: use of `filter_map` with an identity function\n   --> $DIR/filter_map_identity.rs:15:22\n    |\n LL |     let _ = iterator.filter_map(identity);\n    |                      ^^^^^^^^^^^^^^^^^^^^ help: try: `flatten()`\n \n-error: aborting due to 3 previous errors\n+error: use of `filter_map` with an identity function\n+  --> $DIR/filter_map_identity.rs:18:22\n+   |\n+LL |     let _ = iterator.filter_map(|x| return x);\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `flatten()`\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "1f4b880ef5bcd8fa1cea502a8b9bd5efae1d7ba9", "filename": "tests/ui/flat_map_identity.fixed", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fflat_map_identity.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fflat_map_identity.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fflat_map_identity.fixed?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(unused_imports)]\n+#![allow(unused_imports, clippy::needless_return)]\n #![warn(clippy::flat_map_identity)]\n \n use std::convert;\n@@ -11,4 +11,7 @@ fn main() {\n \n     let iterator = [[0, 1], [2, 3], [4, 5]].iter();\n     let _ = iterator.flatten();\n+\n+    let iterator = [[0, 1], [2, 3], [4, 5]].iter();\n+    let _ = iterator.flatten();\n }"}, {"sha": "de14a06d4e6b3377a40d277105d073005e68229a", "filename": "tests/ui/flat_map_identity.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fflat_map_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fflat_map_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fflat_map_identity.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -1,6 +1,6 @@\n // run-rustfix\n \n-#![allow(unused_imports)]\n+#![allow(unused_imports, clippy::needless_return)]\n #![warn(clippy::flat_map_identity)]\n \n use std::convert;\n@@ -11,4 +11,7 @@ fn main() {\n \n     let iterator = [[0, 1], [2, 3], [4, 5]].iter();\n     let _ = iterator.flat_map(convert::identity);\n+\n+    let iterator = [[0, 1], [2, 3], [4, 5]].iter();\n+    let _ = iterator.flat_map(|x| return x);\n }"}, {"sha": "e776c9fdf512e2bda03316138086e2eabd4e2dcf", "filename": "tests/ui/flat_map_identity.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fflat_map_identity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fflat_map_identity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fflat_map_identity.stderr?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -1,16 +1,22 @@\n-error: called `flat_map(|x| x)` on an `Iterator`\n+error: use of `flat_map` with an identity function\n   --> $DIR/flat_map_identity.rs:10:22\n    |\n LL |     let _ = iterator.flat_map(|x| x);\n    |                      ^^^^^^^^^^^^^^^ help: try: `flatten()`\n    |\n    = note: `-D clippy::flat-map-identity` implied by `-D warnings`\n \n-error: called `flat_map(std::convert::identity)` on an `Iterator`\n+error: use of `flat_map` with an identity function\n   --> $DIR/flat_map_identity.rs:13:22\n    |\n LL |     let _ = iterator.flat_map(convert::identity);\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `flatten()`\n \n-error: aborting due to 2 previous errors\n+error: use of `flat_map` with an identity function\n+  --> $DIR/flat_map_identity.rs:16:22\n+   |\n+LL |     let _ = iterator.flat_map(|x| return x);\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^ help: try: `flatten()`\n+\n+error: aborting due to 3 previous errors\n "}, {"sha": "79ba7402f1f49285a79b0de83952e5f46c272333", "filename": "tests/ui/semicolon_if_nothing_returned.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fsemicolon_if_nothing_returned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fsemicolon_if_nothing_returned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsemicolon_if_nothing_returned.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -17,6 +17,24 @@ fn basic101(x: i32) {\n     y = x + 1\n }\n \n+#[rustfmt::skip]\n+fn closure_error() {\n+    let _d = || {\n+        hello()\n+    };\n+}\n+\n+#[rustfmt::skip]\n+fn unsafe_checks_error() {\n+    use std::mem::MaybeUninit;\n+    use std::ptr;\n+\n+    let mut s = MaybeUninit::<String>::uninit();\n+    let _d = || unsafe { \n+        ptr::drop_in_place(s.as_mut_ptr()) \n+    };\n+}\n+\n // this is fine\n fn print_sum(a: i32, b: i32) {\n     println!(\"{}\", a + b);\n@@ -53,3 +71,29 @@ fn loop_test(x: i32) {\n         println!(\"{}\", ext);\n     }\n }\n+\n+fn closure() {\n+    let _d = || hello();\n+}\n+\n+#[rustfmt::skip]\n+fn closure_block() {\n+    let _d = || { hello() };\n+}\n+\n+unsafe fn some_unsafe_op() {}\n+unsafe fn some_other_unsafe_fn() {}\n+\n+fn do_something() {\n+    unsafe { some_unsafe_op() };\n+\n+    unsafe { some_other_unsafe_fn() };\n+}\n+\n+fn unsafe_checks() {\n+    use std::mem::MaybeUninit;\n+    use std::ptr;\n+\n+    let mut s = MaybeUninit::<String>::uninit();\n+    let _d = || unsafe { ptr::drop_in_place(s.as_mut_ptr()) };\n+}"}, {"sha": "e88ebe2ad35f0bcacf64ed5f8ee3bc57e1227ae7", "filename": "tests/ui/semicolon_if_nothing_returned.stderr", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fsemicolon_if_nothing_returned.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fsemicolon_if_nothing_returned.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsemicolon_if_nothing_returned.stderr?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -18,5 +18,17 @@ error: consider adding a `;` to the last statement for consistent formatting\n LL |     y = x + 1\n    |     ^^^^^^^^^ help: add a `;` here: `y = x + 1;`\n \n-error: aborting due to 3 previous errors\n+error: consider adding a `;` to the last statement for consistent formatting\n+  --> $DIR/semicolon_if_nothing_returned.rs:23:9\n+   |\n+LL |         hello()\n+   |         ^^^^^^^ help: add a `;` here: `hello();`\n+\n+error: consider adding a `;` to the last statement for consistent formatting\n+  --> $DIR/semicolon_if_nothing_returned.rs:34:9\n+   |\n+LL |         ptr::drop_in_place(s.as_mut_ptr()) \n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: add a `;` here: `ptr::drop_in_place(s.as_mut_ptr());`\n+\n+error: aborting due to 5 previous errors\n "}, {"sha": "ac4c1bc65979fb5f38661d3f8ac37487ef802e89", "filename": "tests/ui/temporary_assignment.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftemporary_assignment.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -1,5 +1,4 @@\n #![warn(clippy::temporary_assignment)]\n-#![allow(const_item_mutation)]\n \n use std::ops::{Deref, DerefMut};\n "}, {"sha": "7d79901a28d1be70a17f22f33806278c09b0e340", "filename": "tests/ui/temporary_assignment.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Ftemporary_assignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Ftemporary_assignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftemporary_assignment.stderr?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -1,13 +1,13 @@\n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:48:5\n+  --> $DIR/temporary_assignment.rs:47:5\n    |\n LL |     Struct { field: 0 }.field = 1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::temporary-assignment` implied by `-D warnings`\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:49:5\n+  --> $DIR/temporary_assignment.rs:48:5\n    |\n LL | /     MultiStruct {\n LL | |         structure: Struct { field: 0 },\n@@ -17,13 +17,13 @@ LL | |     .field = 1;\n    | |______________^\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:54:5\n+  --> $DIR/temporary_assignment.rs:53:5\n    |\n LL |     ArrayStruct { array: [0] }.array[0] = 1;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: assignment to temporary\n-  --> $DIR/temporary_assignment.rs:55:5\n+  --> $DIR/temporary_assignment.rs:54:5\n    |\n LL |     (0, 0).0 = 1;\n    |     ^^^^^^^^^^^^"}, {"sha": "e2c28542efc76e38c89aec06fc9bf7d670800dd6", "filename": "tests/ui/use_self.fixed", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fuse_self.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fuse_self.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.fixed?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -492,3 +492,26 @@ mod issue7206 {\n         }\n     }\n }\n+\n+mod self_is_ty_param {\n+    trait Trait {\n+        type Type;\n+        type Hi;\n+\n+        fn test();\n+    }\n+\n+    impl<I> Trait for I\n+    where\n+        I: Iterator,\n+        I::Item: Trait, // changing this to Self would require <Self as Iterator>\n+    {\n+        type Type = I;\n+        type Hi = I::Item;\n+\n+        fn test() {\n+            let _: I::Item;\n+            let _: I; // this could lint, but is questionable\n+        }\n+    }\n+}"}, {"sha": "3cd99b9f5cd88775aaa07a061c5c8092fd852b96", "filename": "tests/ui/use_self.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -279,7 +279,7 @@ mod generics {\n     impl<T> Foo<T> {\n         // `Self` is applicable here\n         fn foo(value: T) -> Foo<T> {\n-            Foo { value }\n+            Foo::<T> { value }\n         }\n \n         // `Cannot` use `Self` as a return type as the generic types are different\n@@ -492,3 +492,26 @@ mod issue7206 {\n         }\n     }\n }\n+\n+mod self_is_ty_param {\n+    trait Trait {\n+        type Type;\n+        type Hi;\n+\n+        fn test();\n+    }\n+\n+    impl<I> Trait for I\n+    where\n+        I: Iterator,\n+        I::Item: Trait, // changing this to Self would require <Self as Iterator>\n+    {\n+        type Type = I;\n+        type Hi = I::Item;\n+\n+        fn test() {\n+            let _: I::Item;\n+            let _: I; // this could lint, but is questionable\n+        }\n+    }\n+}"}, {"sha": "6ac26c9e5a9cece3a876924c17595799c6efca9d", "filename": "tests/ui/use_self.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fuse_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fuse_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fuse_self.stderr?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -153,8 +153,8 @@ LL |         fn foo(value: T) -> Foo<T> {\n error: unnecessary structure name repetition\n   --> $DIR/use_self.rs:282:13\n    |\n-LL |             Foo { value }\n-   |             ^^^ help: use the applicable keyword: `Self`\n+LL |             Foo::<T> { value }\n+   |             ^^^^^^^^ help: use the applicable keyword: `Self`\n \n error: unnecessary structure name repetition\n   --> $DIR/use_self.rs:454:13"}, {"sha": "52e80ceee83cf31439c07cfff967fc46a03e09fd", "filename": "tests/ui/while_let_on_iterator.fixed", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fwhile_let_on_iterator.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fwhile_let_on_iterator.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_let_on_iterator.fixed?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -320,6 +320,20 @@ fn issue1924() {\n     println!(\"iterator field {}\", it.1);\n }\n \n+fn issue7249() {\n+    let mut it = 0..10;\n+    let mut x = || {\n+        // Needs &mut, the closure can be called multiple times\n+        for x in &mut it {\n+            if x % 2 == 0 {\n+                break;\n+            }\n+        }\n+    };\n+    x();\n+    x();\n+}\n+\n fn main() {\n     let mut it = 0..20;\n     for _ in it {"}, {"sha": "5078a3c9028c4762f9d7ea09e3b1baf5c837c7c5", "filename": "tests/ui/while_let_on_iterator.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_let_on_iterator.rs?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -320,6 +320,20 @@ fn issue1924() {\n     println!(\"iterator field {}\", it.1);\n }\n \n+fn issue7249() {\n+    let mut it = 0..10;\n+    let mut x = || {\n+        // Needs &mut, the closure can be called multiple times\n+        while let Some(x) = it.next() {\n+            if x % 2 == 0 {\n+                break;\n+            }\n+        }\n+    };\n+    x();\n+    x();\n+}\n+\n fn main() {\n     let mut it = 0..20;\n     while let Some(..) = it.next() {"}, {"sha": "cb0afeae15ee0ead89f0bbe769e7af04660ccd72", "filename": "tests/ui/while_let_on_iterator.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fwhile_let_on_iterator.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e3eede7b905aec5c1bd23fe48444411f012d823a/tests%2Fui%2Fwhile_let_on_iterator.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_let_on_iterator.stderr?ref=e3eede7b905aec5c1bd23fe48444411f012d823a", "patch": "@@ -105,10 +105,16 @@ LL |     while let Some(n) = it.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for n in &mut it`\n \n error: this loop could be written as a `for` loop\n-  --> $DIR/while_let_on_iterator.rs:325:5\n+  --> $DIR/while_let_on_iterator.rs:327:9\n+   |\n+LL |         while let Some(x) = it.next() {\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for x in &mut it`\n+\n+error: this loop could be written as a `for` loop\n+  --> $DIR/while_let_on_iterator.rs:339:5\n    |\n LL |     while let Some(..) = it.next() {\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for _ in it`\n \n-error: aborting due to 18 previous errors\n+error: aborting due to 19 previous errors\n "}]}