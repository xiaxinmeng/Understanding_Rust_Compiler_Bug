{"sha": "0ddf060b6d347f89afb584501c86a4fa96ec7acc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkZGYwNjBiNmQzNDdmODlhZmI1ODQ1MDFjODZhNGZhOTZlYzdhY2M=", "commit": {"author": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2016-08-09T12:57:41Z"}, "committer": {"name": "Andrew Cann", "email": "shum@canndrew.org", "date": "2016-09-05T04:19:07Z"}, "message": "Make write_ty and friends return adjusted type", "tree": {"sha": "9d74ccffc8df9aabc12529dd4993ba297ca6063b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d74ccffc8df9aabc12529dd4993ba297ca6063b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ddf060b6d347f89afb584501c86a4fa96ec7acc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ddf060b6d347f89afb584501c86a4fa96ec7acc", "html_url": "https://github.com/rust-lang/rust/commit/0ddf060b6d347f89afb584501c86a4fa96ec7acc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ddf060b6d347f89afb584501c86a4fa96ec7acc/comments", "author": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "committer": {"login": "canndrew", "id": 5555066, "node_id": "MDQ6VXNlcjU1NTUwNjY=", "avatar_url": "https://avatars.githubusercontent.com/u/5555066?v=4", "gravatar_id": "", "url": "https://api.github.com/users/canndrew", "html_url": "https://github.com/canndrew", "followers_url": "https://api.github.com/users/canndrew/followers", "following_url": "https://api.github.com/users/canndrew/following{/other_user}", "gists_url": "https://api.github.com/users/canndrew/gists{/gist_id}", "starred_url": "https://api.github.com/users/canndrew/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/canndrew/subscriptions", "organizations_url": "https://api.github.com/users/canndrew/orgs", "repos_url": "https://api.github.com/users/canndrew/repos", "events_url": "https://api.github.com/users/canndrew/events{/privacy}", "received_events_url": "https://api.github.com/users/canndrew/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91f057de35066d0a34102bd0673b56684509b93d", "url": "https://api.github.com/repos/rust-lang/rust/commits/91f057de35066d0a34102bd0673b56684509b93d", "html_url": "https://github.com/rust-lang/rust/commit/91f057de35066d0a34102bd0673b56684509b93d"}], "stats": {"total": 299, "additions": 153, "deletions": 146}, "files": [{"sha": "1f0faab8f2c4add1cffd2dd4da36c25ad385b454", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0ddf060b6d347f89afb584501c86a4fa96ec7acc/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ddf060b6d347f89afb584501c86a4fa96ec7acc/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=0ddf060b6d347f89afb584501c86a4fa96ec7acc", "patch": "@@ -371,7 +371,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                        discrim: &'gcx hir::Expr,\n                        arms: &'gcx [hir::Arm],\n                        expected: Expectation<'tcx>,\n-                       match_src: hir::MatchSource) {\n+                       match_src: hir::MatchSource) -> Ty<'tcx> {\n         let tcx = self.tcx;\n \n         // Not entirely obvious: if matches may create ref bindings, we\n@@ -480,7 +480,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n         }\n \n-        self.write_ty(expr.id, result_ty);\n+        self.write_ty(expr.id, result_ty)\n     }\n }\n "}, {"sha": "4f673606de52f549298c803f8631964be2f573f3", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0ddf060b6d347f89afb584501c86a4fa96ec7acc/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ddf060b6d347f89afb584501c86a4fa96ec7acc/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=0ddf060b6d347f89afb584501c86a4fa96ec7acc", "patch": "@@ -45,7 +45,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                       call_expr: &'gcx hir::Expr,\n                       callee_expr: &'gcx hir::Expr,\n                       arg_exprs: &'gcx [P<hir::Expr>],\n-                      expected: Expectation<'tcx>)\n+                      expected: Expectation<'tcx>) -> Ty<'tcx>\n     {\n         self.check_expr(callee_expr);\n         let original_callee_ty = self.expr_ty(callee_expr);\n@@ -60,20 +60,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match result {\n             None => {\n                 // this will report an error since original_callee_ty is not a fn\n-                self.confirm_builtin_call(call_expr, original_callee_ty, arg_exprs, expected);\n+                self.confirm_builtin_call(call_expr, original_callee_ty, arg_exprs, expected)\n             }\n \n             Some(CallStep::Builtin) => {\n-                self.confirm_builtin_call(call_expr, callee_ty, arg_exprs, expected);\n+                self.confirm_builtin_call(call_expr, callee_ty, arg_exprs, expected)\n             }\n \n             Some(CallStep::DeferredClosure(fn_sig)) => {\n-                self.confirm_deferred_closure_call(call_expr, arg_exprs, expected, fn_sig);\n+                self.confirm_deferred_closure_call(call_expr, arg_exprs, expected, fn_sig)\n             }\n \n             Some(CallStep::Overloaded(method_callee)) => {\n                 self.confirm_overloaded_call(call_expr, callee_expr,\n-                                             arg_exprs, expected, method_callee);\n+                                             arg_exprs, expected, method_callee)\n             }\n         }\n     }\n@@ -181,7 +181,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             call_expr: &hir::Expr,\n                             callee_ty: Ty<'tcx>,\n                             arg_exprs: &'gcx [P<hir::Expr>],\n-                            expected: Expectation<'tcx>)\n+                            expected: Expectation<'tcx>) -> Ty<'tcx>\n     {\n         let error_fn_sig;\n \n@@ -245,14 +245,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   fn_sig.variadic,\n                                   TupleArgumentsFlag::DontTupleArguments);\n \n-        self.write_call(call_expr, fn_sig.output);\n+        self.write_ty(call_expr.id, fn_sig.output)\n     }\n \n     fn confirm_deferred_closure_call(&self,\n                                      call_expr: &hir::Expr,\n                                      arg_exprs: &'gcx [P<hir::Expr>],\n                                      expected: Expectation<'tcx>,\n-                                     fn_sig: ty::FnSig<'tcx>)\n+                                     fn_sig: ty::FnSig<'tcx>) -> Ty<'tcx>\n     {\n         // `fn_sig` is the *signature* of the cosure being called. We\n         // don't know the full details yet (`Fn` vs `FnMut` etc), but we\n@@ -272,15 +272,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   fn_sig.variadic,\n                                   TupleArgumentsFlag::TupleArguments);\n \n-        self.write_call(call_expr, fn_sig.output);\n+        self.write_ty(call_expr.id, fn_sig.output)\n     }\n \n     fn confirm_overloaded_call(&self,\n                                call_expr: &hir::Expr,\n                                callee_expr: &'gcx hir::Expr,\n                                arg_exprs: &'gcx [P<hir::Expr>],\n                                expected: Expectation<'tcx>,\n-                               method_callee: ty::MethodCallee<'tcx>)\n+                               method_callee: ty::MethodCallee<'tcx>) -> Ty<'tcx>\n     {\n         let output_type =\n             self.check_method_argument_types(call_expr.span,\n@@ -289,9 +289,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                              arg_exprs,\n                                              TupleArgumentsFlag::TupleArguments,\n                                              expected);\n-        self.write_call(call_expr, output_type);\n+        let ty = self.write_ty(call_expr.id, output_type);\n \n         self.write_overloaded_call_method_map(call_expr, method_callee);\n+        ty\n     }\n \n     fn write_overloaded_call_method_map(&self,"}, {"sha": "1f4201aa39cddb30a7c6f78a11e24148c116da24", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ddf060b6d347f89afb584501c86a4fa96ec7acc/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ddf060b6d347f89afb584501c86a4fa96ec7acc/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=0ddf060b6d347f89afb584501c86a4fa96ec7acc", "patch": "@@ -24,7 +24,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               _capture: hir::CaptureClause,\n                               decl: &'gcx hir::FnDecl,\n                               body: &'gcx hir::Block,\n-                              expected: Expectation<'tcx>) {\n+                              expected: Expectation<'tcx>) -> Ty<'tcx> {\n         debug!(\"check_expr_closure(expr={:?},expected={:?})\",\n                expr,\n                expected);\n@@ -44,7 +44,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                      opt_kind: Option<ty::ClosureKind>,\n                      decl: &'gcx hir::FnDecl,\n                      body: &'gcx hir::Block,\n-                     expected_sig: Option<ty::FnSig<'tcx>>) {\n+                     expected_sig: Option<ty::FnSig<'tcx>>) -> Ty<'tcx> {\n         let expr_def_id = self.tcx.map.local_def_id(expr.id);\n \n         debug!(\"check_closure opt_kind={:?} expected_sig={:?}\",\n@@ -70,7 +70,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.parameter_environment.free_substs,\n             upvar_tys);\n \n-        self.write_ty(expr.id, closure_type);\n+        let ty = self.write_ty(expr.id, closure_type);\n \n         let fn_sig = self.tcx.liberate_late_bound_regions(\n             self.tcx.region_maps.call_site_extent(expr.id, body.id), &fn_ty.sig);\n@@ -93,6 +93,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Some(kind) => { self.tables.borrow_mut().closure_kinds.insert(expr_def_id, kind); }\n             None => { }\n         }\n+\n+        ty\n     }\n \n     fn deduce_expectations_from_expected_type(&self, expected_ty: Ty<'tcx>)"}, {"sha": "5c528cc46a73c80d33806a1437fe97bcdccbeed6", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 121, "deletions": 120, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/0ddf060b6d347f89afb584501c86a4fa96ec7acc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ddf060b6d347f89afb584501c86a4fa96ec7acc/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=0ddf060b6d347f89afb584501c86a4fa96ec7acc", "patch": "@@ -1530,18 +1530,21 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     #[inline]\n-    pub fn write_ty(&self, node_id: ast::NodeId, ty: Ty<'tcx>) {\n+    pub fn write_ty(&self, node_id: ast::NodeId, ty: Ty<'tcx>) -> Ty<'tcx> {\n         debug!(\"write_ty({}, {:?}) in fcx {}\",\n                node_id, ty, self.tag());\n         self.tables.borrow_mut().node_types.insert(node_id, ty);\n \n         // Add adjustments to !-expressions\n         if ty.is_never() {\n             if let Some(hir::map::NodeExpr(_)) = self.tcx.map.find(node_id) {\n-                let adj = adjustment::AdjustNeverToAny(self.next_diverging_ty_var());\n+                let adj_ty = self.next_diverging_ty_var();\n+                let adj = adjustment::AdjustNeverToAny(adj_ty);\n                 self.write_adjustment(node_id, adj);\n+                return adj_ty;\n             }\n         }\n+        ty\n     }\n \n     pub fn write_substs(&self, node_id: ast::NodeId, substs: ty::ItemSubsts<'tcx>) {\n@@ -1715,16 +1718,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         ty_substituted\n     }\n \n-    pub fn write_nil(&self, node_id: ast::NodeId) {\n-        self.write_ty(node_id, self.tcx.mk_nil());\n+    pub fn write_nil(&self, node_id: ast::NodeId) -> Ty<'tcx> {\n+        self.write_ty(node_id, self.tcx.mk_nil())\n     }\n \n-    pub fn write_never(&self, node_id: ast::NodeId) {\n-        self.write_ty(node_id, self.tcx.types.never);\n+    pub fn write_never(&self, node_id: ast::NodeId) -> Ty<'tcx> {\n+        self.write_ty(node_id, self.tcx.types.never)\n     }\n \n-    pub fn write_error(&self, node_id: ast::NodeId) {\n-        self.write_ty(node_id, self.tcx.types.err);\n+    pub fn write_error(&self, node_id: ast::NodeId) -> Ty<'tcx> {\n+        self.write_ty(node_id, self.tcx.types.err)\n     }\n \n     pub fn require_type_meets(&self,\n@@ -2666,12 +2669,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         (0..len).map(|_| self.tcx.types.err).collect()\n     }\n \n-    fn write_call(&self,\n-                  call_expr: &hir::Expr,\n-                  output: Ty<'tcx>) {\n-        self.write_ty(call_expr.id, output);\n-    }\n-\n     // AST fragment checking\n     fn check_lit(&self,\n                  lit: &ast::Lit,\n@@ -2727,35 +2724,37 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn check_expr_has_type(&self,\n                                expr: &'gcx hir::Expr,\n-                               expected: Ty<'tcx>) {\n-        self.check_expr_with_hint(expr, expected);\n+                               expected: Ty<'tcx>) -> Ty<'tcx> {\n+        let ty = self.check_expr_with_hint(expr, expected);\n         self.demand_suptype(expr.span, expected, self.expr_ty(expr));\n+        ty\n     }\n \n     fn check_expr_coercable_to_type(&self,\n                                     expr: &'gcx hir::Expr,\n-                                    expected: Ty<'tcx>) {\n-        self.check_expr_with_hint(expr, expected);\n+                                    expected: Ty<'tcx>) -> Ty<'tcx> {\n+        let ty = self.check_expr_with_hint(expr, expected);\n         self.demand_coerce(expr, expected);\n+        ty\n     }\n \n     fn check_expr_with_hint(&self, expr: &'gcx hir::Expr,\n-                            expected: Ty<'tcx>) {\n+                            expected: Ty<'tcx>) -> Ty<'tcx> {\n         self.check_expr_with_expectation(expr, ExpectHasType(expected))\n     }\n \n     fn check_expr_with_expectation(&self,\n                                    expr: &'gcx hir::Expr,\n-                                   expected: Expectation<'tcx>) {\n+                                   expected: Expectation<'tcx>) -> Ty<'tcx> {\n         self.check_expr_with_expectation_and_lvalue_pref(expr, expected, NoPreference)\n     }\n \n-    fn check_expr(&self, expr: &'gcx hir::Expr)  {\n+    fn check_expr(&self, expr: &'gcx hir::Expr) -> Ty<'tcx> {\n         self.check_expr_with_expectation(expr, NoExpectation)\n     }\n \n     fn check_expr_with_lvalue_pref(&self, expr: &'gcx hir::Expr,\n-                                   lvalue_pref: LvaluePreference)  {\n+                                   lvalue_pref: LvaluePreference) -> Ty<'tcx> {\n         self.check_expr_with_expectation_and_lvalue_pref(expr, NoExpectation, lvalue_pref)\n     }\n \n@@ -2820,7 +2819,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          args: &'gcx [P<hir::Expr>],\n                          tps: &[P<hir::Ty>],\n                          expected: Expectation<'tcx>,\n-                         lvalue_pref: LvaluePreference) {\n+                         lvalue_pref: LvaluePreference) -> Ty<'tcx> {\n         let rcvr = &args[0];\n         self.check_expr_with_lvalue_pref(&rcvr, lvalue_pref);\n \n@@ -2856,7 +2855,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                       DontTupleArguments,\n                                                       expected);\n \n-        self.write_call(expr, ret_ty);\n+        self.write_ty(expr.id, ret_ty)\n     }\n \n     // A generic function for checking the then and else in an if\n@@ -2867,7 +2866,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                        opt_else_expr: Option<&'gcx hir::Expr>,\n                        id: ast::NodeId,\n                        sp: Span,\n-                       expected: Expectation<'tcx>) {\n+                       expected: Expectation<'tcx>) -> Ty<'tcx> {\n         self.check_expr_has_type(cond_expr, self.tcx.types.bool);\n \n         let expected = expected.adjust_for_branches(self);\n@@ -2932,15 +2931,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n         };\n \n-        self.write_ty(id, if_ty);\n+        self.write_ty(id, if_ty)\n     }\n \n     // Check field access expressions\n     fn check_field(&self,\n                    expr: &'gcx hir::Expr,\n                    lvalue_pref: LvaluePreference,\n                    base: &'gcx hir::Expr,\n-                   field: &Spanned<ast::Name>) {\n+                   field: &Spanned<ast::Name>) -> Ty<'tcx> {\n         self.check_expr_with_lvalue_pref(base, lvalue_pref);\n         let expr_t = self.structurally_resolved_type(expr.span,\n                                                      self.expr_ty(base));\n@@ -2954,9 +2953,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         let field_ty = self.field_ty(expr.span, field, substs);\n                         if field.vis.is_accessible_from(self.body_id, &self.tcx().map) {\n                             autoderef.finalize(lvalue_pref, Some(base));\n-                            self.write_ty(expr.id, field_ty);\n+                            let ty = self.write_ty(expr.id, field_ty);\n                             self.write_autoderef_adjustment(base.id, autoderefs);\n-                            return;\n+                            return ty;\n                         }\n                         private_candidate = Some((base_def.did, field_ty));\n                     }\n@@ -2968,7 +2967,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         if let Some((did, field_ty)) = private_candidate {\n             let struct_path = self.tcx().item_path_str(did);\n-            self.write_ty(expr.id, field_ty);\n+            let ty = self.write_ty(expr.id, field_ty);\n             let msg = format!(\"field `{}` of struct `{}` is private\", field.node, struct_path);\n             let mut err = self.tcx().sess.struct_span_err(expr.span, &msg);\n             // Also check if an accessible method exists, which is often what is meant.\n@@ -2977,8 +2976,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                   field.node));\n             }\n             err.emit();\n+            ty\n         } else if field.node == keywords::Invalid.name() {\n-            self.write_error(expr.id);\n+            self.write_error(expr.id)\n         } else if self.method_exists(field.span, field.node, expr_t, expr.id, true) {\n             self.type_error_struct(field.span, |actual| {\n                 format!(\"attempted to take value of method `{}` on type \\\n@@ -2987,7 +2987,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 .help(\"maybe a `()` to call it is missing? \\\n                        If not, try an anonymous function\")\n                 .emit();\n-            self.write_error(expr.id);\n+            self.write_error(expr.id)\n         } else {\n             let mut err = self.type_error_struct(expr.span, |actual| {\n                 format!(\"attempted access of field `{}` on type `{}`, \\\n@@ -3005,7 +3005,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 _ => {}\n             }\n             err.emit();\n-            self.write_error(expr.id);\n+            self.write_error(expr.id)\n         }\n     }\n \n@@ -3037,7 +3037,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                        expr: &'gcx hir::Expr,\n                        lvalue_pref: LvaluePreference,\n                        base: &'gcx hir::Expr,\n-                       idx: codemap::Spanned<usize>) {\n+                       idx: codemap::Spanned<usize>) -> Ty<'tcx> {\n         self.check_expr_with_lvalue_pref(base, lvalue_pref);\n         let expr_t = self.structurally_resolved_type(expr.span,\n                                                      self.expr_ty(base));\n@@ -3070,9 +3070,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n             if let Some(field_ty) = field {\n                 autoderef.finalize(lvalue_pref, Some(base));\n-                self.write_ty(expr.id, field_ty);\n+                let ty = self.write_ty(expr.id, field_ty);\n                 self.write_autoderef_adjustment(base.id, autoderefs);\n-                return;\n+                return ty;\n             }\n         }\n         autoderef.unambiguous_final_ty();\n@@ -3081,8 +3081,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let struct_path = self.tcx().item_path_str(did);\n             let msg = format!(\"field `{}` of struct `{}` is private\", idx.node, struct_path);\n             self.tcx().sess.span_err(expr.span, &msg);\n-            self.write_ty(expr.id, field_ty);\n-            return;\n+            return self.write_ty(expr.id, field_ty)\n         }\n \n         self.type_error_message(\n@@ -3102,7 +3101,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             },\n             expr_t);\n \n-        self.write_error(expr.id);\n+        self.write_error(expr.id)\n     }\n \n     fn report_unknown_field(&self,\n@@ -3207,17 +3206,20 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn check_struct_fields_on_error(&self,\n                                     id: ast::NodeId,\n                                     fields: &'gcx [hir::Field],\n-                                    base_expr: &'gcx Option<P<hir::Expr>>) {\n+                                    base_expr: &'gcx Option<P<hir::Expr>>) -> Ty<'tcx> {\n         // Make sure to still write the types\n         // otherwise we might ICE\n-        self.write_error(id);\n+        let ty = self.write_error(id);\n         for field in fields {\n             self.check_expr(&field.expr);\n         }\n         match *base_expr {\n-            Some(ref base) => self.check_expr(&base),\n+            Some(ref base) => {\n+                self.check_expr(&base);\n+            },\n             None => {}\n         }\n+        ty\n     }\n \n     pub fn check_struct_path(&self,\n@@ -3267,15 +3269,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          expr: &hir::Expr,\n                          path: &hir::Path,\n                          fields: &'gcx [hir::Field],\n-                         base_expr: &'gcx Option<P<hir::Expr>>)\n+                         base_expr: &'gcx Option<P<hir::Expr>>) -> Ty<'tcx>\n     {\n         // Find the relevant variant\n         let (variant, expr_ty) = if let Some(variant_ty) = self.check_struct_path(path, expr.id,\n                                                                                   expr.span) {\n             variant_ty\n         } else {\n-            self.check_struct_fields_on_error(expr.id, fields, base_expr);\n-            return;\n+            return self.check_struct_fields_on_error(expr.id, fields, base_expr);\n         };\n \n         self.check_expr_struct_fields(expr_ty, path.span, variant, fields,\n@@ -3299,6 +3300,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n         }\n+        expr_ty\n     }\n \n \n@@ -3315,13 +3317,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn check_expr_with_expectation_and_lvalue_pref(&self,\n                                                    expr: &'gcx hir::Expr,\n                                                    expected: Expectation<'tcx>,\n-                                                   lvalue_pref: LvaluePreference) {\n+                                                   lvalue_pref: LvaluePreference) -> Ty<'tcx> {\n         debug!(\">> typechecking: expr={:?} expected={:?}\",\n                expr, expected);\n \n         let tcx = self.tcx;\n         let id = expr.id;\n-        match expr.node {\n+        let ty = match expr.node {\n           hir::ExprBox(ref subexpr) => {\n             let expected_inner = expected.to_option(self).map_or(NoExpectation, |ty| {\n                 match ty.sty {\n@@ -3331,18 +3333,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             });\n             self.check_expr_with_expectation(subexpr, expected_inner);\n             let referent_ty = self.expr_ty(&subexpr);\n-            self.write_ty(id, tcx.mk_box(referent_ty));\n+            self.write_ty(id, tcx.mk_box(referent_ty))\n           }\n \n           hir::ExprLit(ref lit) => {\n             let typ = self.check_lit(&lit, expected);\n-            self.write_ty(id, typ);\n+            self.write_ty(id, typ)\n           }\n           hir::ExprBinary(op, ref lhs, ref rhs) => {\n-            self.check_binop(expr, op, lhs, rhs);\n+            self.check_binop(expr, op, lhs, rhs)\n           }\n           hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n-            self.check_binop_assign(expr, op, lhs, rhs);\n+            self.check_binop_assign(expr, op, lhs, rhs)\n           }\n           hir::ExprUnary(unop, ref oprnd) => {\n             let expected_inner = match unop {\n@@ -3357,10 +3359,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 hir::UnDeref => lvalue_pref,\n                 _ => NoPreference\n             };\n-            self.check_expr_with_expectation_and_lvalue_pref(&oprnd,\n-                                                             expected_inner,\n-                                                             lvalue_pref);\n-            let mut oprnd_t = self.expr_ty(&oprnd);\n+            let mut oprnd_t = self.check_expr_with_expectation_and_lvalue_pref(&oprnd,\n+                                                                               expected_inner,\n+                                                                               lvalue_pref);\n \n             if !oprnd_t.references_error() {\n                 match unop {\n@@ -3402,7 +3403,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            self.write_ty(id, oprnd_t);\n+            self.write_ty(id, oprnd_t)\n           }\n           hir::ExprAddrOf(mutbl, ref oprnd) => {\n             let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n@@ -3421,9 +3422,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n             });\n             let lvalue_pref = LvaluePreference::from_mutbl(mutbl);\n-            self.check_expr_with_expectation_and_lvalue_pref(&oprnd, hint, lvalue_pref);\n+            let ty = self.check_expr_with_expectation_and_lvalue_pref(&oprnd, hint, lvalue_pref);\n \n-            let tm = ty::TypeAndMut { ty: self.expr_ty(&oprnd), mutbl: mutbl };\n+            let tm = ty::TypeAndMut { ty: ty, mutbl: mutbl };\n             let oprnd_t = if tm.ty.references_error() {\n                 tcx.types.err\n             } else {\n@@ -3443,24 +3444,25 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let region = self.next_region_var(infer::AddrOfRegion(expr.span));\n                 tcx.mk_ref(region, tm)\n             };\n-            self.write_ty(id, oprnd_t);\n+            self.write_ty(id, oprnd_t)\n           }\n           hir::ExprPath(ref opt_qself, ref path) => {\n               let opt_self_ty = opt_qself.as_ref().map(|qself| self.to_ty(&qself.ty));\n               let (def, opt_ty, segments) = self.resolve_ty_and_def_ufcs(opt_self_ty, path,\n                                                                          expr.id, expr.span);\n-              if def != Def::Err {\n-                  self.instantiate_value_path(segments, opt_ty, def, expr.span, id);\n+              let ty = if def != Def::Err {\n+                  self.instantiate_value_path(segments, opt_ty, def, expr.span, id)\n               } else {\n                   self.set_tainted_by_errors();\n-                  self.write_error(id);\n-              }\n+                  self.write_error(id)\n+              };\n \n               // We always require that the type provided as the value for\n               // a type parameter outlives the moment of instantiation.\n               self.opt_node_ty_substs(expr.id, |item_substs| {\n                   self.add_wf_bounds(&item_substs.substs, expr);\n               });\n+              ty\n           }\n           hir::ExprInlineAsm(_, ref outputs, ref inputs) => {\n               for output in outputs {\n@@ -3469,10 +3471,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n               for input in inputs {\n                   self.check_expr(input);\n               }\n-              self.write_nil(id);\n+              self.write_nil(id)\n           }\n-          hir::ExprBreak(_) => { self.write_never(id); }\n-          hir::ExprAgain(_) => { self.write_never(id); }\n+          hir::ExprBreak(_) => { self.write_never(id) }\n+          hir::ExprAgain(_) => { self.write_never(id) }\n           hir::ExprRet(ref expr_opt) => {\n             if let Some(ref e) = *expr_opt {\n                 self.check_expr_coercable_to_type(&e, self.ret_ty);\n@@ -3490,10 +3492,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         .emit();\n                 }\n             }\n-            self.write_never(id);\n+            self.write_never(id)\n           }\n           hir::ExprAssign(ref lhs, ref rhs) => {\n-            self.check_expr_with_lvalue_pref(&lhs, PreferMutLvalue);\n+            let lhs_ty = self.check_expr_with_lvalue_pref(&lhs, PreferMutLvalue);\n \n             let tcx = self.tcx;\n             if !tcx.expr_is_lval(&lhs) {\n@@ -3506,65 +3508,67 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 .emit();\n             }\n \n-            let lhs_ty = self.expr_ty(&lhs);\n-            self.check_expr_coercable_to_type(&rhs, lhs_ty);\n-            let rhs_ty = self.expr_ty(&rhs);\n+            let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty);\n \n             self.require_expr_have_sized_type(&lhs, traits::AssignmentLhsSized);\n \n             if lhs_ty.references_error() || rhs_ty.references_error() {\n-                self.write_error(id);\n+                self.write_error(id)\n             } else {\n-                self.write_nil(id);\n+                self.write_nil(id)\n             }\n           }\n           hir::ExprIf(ref cond, ref then_blk, ref opt_else_expr) => {\n             self.check_then_else(&cond, &then_blk, opt_else_expr.as_ref().map(|e| &**e),\n-                                 id, expr.span, expected);\n+                                 id, expr.span, expected)\n           }\n           hir::ExprWhile(ref cond, ref body, _) => {\n             self.check_expr_has_type(&cond, tcx.types.bool);\n             self.check_block_no_value(&body);\n             let cond_ty = self.expr_ty(&cond);\n             let body_ty = self.node_ty(body.id);\n             if cond_ty.references_error() || body_ty.references_error() {\n-                self.write_error(id);\n+                self.write_error(id)\n             }\n             else {\n-                self.write_nil(id);\n+                self.write_nil(id)\n             }\n           }\n           hir::ExprLoop(ref body, _) => {\n             self.check_block_no_value(&body);\n             if !may_break(tcx, expr.id, &body) {\n-                self.write_never(id);\n+                self.write_never(id)\n             } else {\n-                self.write_nil(id);\n+                self.write_nil(id)\n             }\n           }\n           hir::ExprMatch(ref discrim, ref arms, match_src) => {\n-            self.check_match(expr, &discrim, arms, expected, match_src);\n+            self.check_match(expr, &discrim, arms, expected, match_src)\n           }\n           hir::ExprClosure(capture, ref decl, ref body, _) => {\n-              self.check_expr_closure(expr, capture, &decl, &body, expected);\n+              self.check_expr_closure(expr, capture, &decl, &body, expected)\n           }\n           hir::ExprBlock(ref b) => {\n             self.check_block_with_expected(&b, expected);\n-            self.write_ty(id, self.node_ty(b.id));\n+            let ty = self.node_ty(b.id);\n+            self.write_ty(id, ty)\n           }\n           hir::ExprCall(ref callee, ref args) => {\n-              self.check_call(expr, &callee, &args[..], expected);\n+              let ret_ty = self.check_call(expr, &callee, &args[..], expected);\n \n               // we must check that return type of called functions is WF:\n-              let ret_ty = self.expr_ty(expr);\n               self.register_wf_obligation(ret_ty, expr.span, traits::MiscObligation);\n+              ret_ty\n           }\n           hir::ExprMethodCall(name, ref tps, ref args) => {\n-              self.check_method_call(expr, name, &args[..], &tps[..], expected, lvalue_pref);\n+              let ty = self.check_method_call(expr, name, &args[..], &tps[..], expected, lvalue_pref);\n               let arg_tys = args.iter().map(|a| self.expr_ty(&a));\n               let args_err = arg_tys.fold(false, |rest_err, a| rest_err || a.references_error());\n               if args_err {\n-                  self.write_error(id);\n+                  self.write_error(id)\n+              }\n+              else {\n+                  ty\n               }\n           }\n           hir::ExprCast(ref e, ref t) => {\n@@ -3576,34 +3580,34 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // if appropriate.\n             let t_cast = self.to_ty(t);\n             let t_cast = self.resolve_type_vars_if_possible(&t_cast);\n-            self.check_expr_with_expectation(e, ExpectCastableToType(t_cast));\n-            let t_expr = self.expr_ty(e);\n+            let t_expr = self.check_expr_with_expectation(e, ExpectCastableToType(t_cast));\n             let t_cast = self.resolve_type_vars_if_possible(&t_cast);\n \n             // Eagerly check for some obvious errors.\n             if t_expr.references_error() || t_cast.references_error() {\n-                self.write_error(id);\n+                self.write_error(id)\n             } else {\n                 // Write a type for the whole expression, assuming everything is going\n                 // to work out Ok.\n-                self.write_ty(id, t_cast);\n+                let ty = self.write_ty(id, t_cast);\n \n                 // Defer other checks until we're done type checking.\n                 let mut deferred_cast_checks = self.deferred_cast_checks.borrow_mut();\n                 match cast::CastCheck::new(self, e, t_expr, t_cast, t.span, expr.span) {\n                     Ok(cast_check) => {\n                         deferred_cast_checks.push(cast_check);\n+                        ty\n                     }\n                     Err(ErrorReported) => {\n-                        self.write_error(id);\n+                        self.write_error(id)\n                     }\n                 }\n             }\n           }\n           hir::ExprType(ref e, ref t) => {\n             let typ = self.to_ty(&t);\n             self.check_expr_eq_type(&e, typ);\n-            self.write_ty(id, typ);\n+            self.write_ty(id, typ)\n           }\n           hir::ExprVec(ref args) => {\n             let uty = expected.to_option(self).and_then(|uty| {\n@@ -3617,8 +3621,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let coerce_to = uty.unwrap_or(unified);\n \n             for (i, e) in args.iter().enumerate() {\n-                self.check_expr_with_hint(e, coerce_to);\n-                let e_ty = self.expr_ty(e);\n+                let e_ty = self.check_expr_with_hint(e, coerce_to);\n                 let origin = TypeOrigin::Misc(e.span);\n \n                 // Special-case the first element, as it has no \"previous expressions\".\n@@ -3636,7 +3639,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            self.write_ty(id, tcx.mk_array(unified, args.len()));\n+            self.write_ty(id, tcx.mk_array(unified, args.len()))\n           }\n           hir::ExprRepeat(ref element, ref count_expr) => {\n             self.check_expr_has_type(&count_expr, tcx.types.usize);\n@@ -3660,8 +3663,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n                 None => {\n                     let t: Ty = self.next_ty_var();\n-                    self.check_expr_has_type(&element, t);\n-                    (self.expr_ty(&element), t)\n+                    let element_ty = self.check_expr_has_type(&element, t);\n+                    (element_ty, t)\n                 }\n             };\n \n@@ -3672,10 +3675,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             if element_ty.references_error() {\n-                self.write_error(id);\n+                self.write_error(id)\n             } else {\n                 let t = tcx.mk_array(t, count);\n-                self.write_ty(id, t);\n+                self.write_ty(id, t)\n             }\n           }\n           hir::ExprTup(ref elts) => {\n@@ -3695,49 +3698,46 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         ety\n                     }\n                     _ => {\n-                        self.check_expr_with_expectation(&e, NoExpectation);\n-                        self.expr_ty(&e)\n+                        self.check_expr_with_expectation(&e, NoExpectation)\n                     }\n                 };\n                 err_field = err_field || t.references_error();\n                 t\n             }).collect();\n             if err_field {\n-                self.write_error(id);\n+                self.write_error(id)\n             } else {\n                 let typ = tcx.mk_tup(elt_ts);\n-                self.write_ty(id, typ);\n+                self.write_ty(id, typ)\n             }\n           }\n           hir::ExprStruct(ref path, ref fields, ref base_expr) => {\n-            self.check_expr_struct(expr, path, fields, base_expr);\n+            let ty = self.check_expr_struct(expr, path, fields, base_expr);\n \n             self.require_expr_have_sized_type(expr, traits::StructInitializerSized);\n+            ty\n           }\n           hir::ExprField(ref base, ref field) => {\n-            self.check_field(expr, lvalue_pref, &base, field);\n+            self.check_field(expr, lvalue_pref, &base, field)\n           }\n           hir::ExprTupField(ref base, idx) => {\n-            self.check_tup_field(expr, lvalue_pref, &base, idx);\n+            self.check_tup_field(expr, lvalue_pref, &base, idx)\n           }\n           hir::ExprIndex(ref base, ref idx) => {\n-              self.check_expr_with_lvalue_pref(&base, lvalue_pref);\n-              self.check_expr(&idx);\n-\n-              let base_t = self.expr_ty(&base);\n-              let idx_t = self.expr_ty(&idx);\n+              let base_t = self.check_expr_with_lvalue_pref(&base, lvalue_pref);\n+              let idx_t = self.check_expr(&idx);\n \n               if base_t.references_error() {\n-                  self.write_ty(id, base_t);\n+                  self.write_ty(id, base_t)\n               } else if idx_t.references_error() {\n-                  self.write_ty(id, idx_t);\n+                  self.write_ty(id, idx_t)\n               } else {\n                   let base_t = self.structurally_resolved_type(expr.span, base_t);\n                   match self.lookup_indexing(expr, base, base_t, idx_t, lvalue_pref) {\n                       Some((index_ty, element_ty)) => {\n                           let idx_expr_ty = self.expr_ty(idx);\n                           self.demand_eqtype(expr.span, index_ty, idx_expr_ty);\n-                          self.write_ty(id, element_ty);\n+                          self.write_ty(id, element_ty)\n                       }\n                       None => {\n                           self.check_expr_has_type(&idx, self.tcx.types.err);\n@@ -3773,18 +3773,19 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               }\n                           }\n                           err.emit();\n-                          self.write_ty(id, self.tcx().types.err);\n+                          self.write_ty(id, self.tcx().types.err)\n                       }\n                   }\n               }\n            }\n-        }\n+        };\n \n         debug!(\"type of expr({}) {} is...\", expr.id,\n                pprust::expr_to_string(expr));\n         debug!(\"... {:?}, expected is {:?}\",\n-               self.expr_ty(expr),\n+               ty,\n                expected);\n+        ty\n     }\n \n     // Finish resolving a path in a struct expression or pattern `S::A { .. }` if necessary.\n@@ -3878,9 +3879,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // referent for the reference that results is *equal to* the\n             // type of the lvalue it is referencing, and not some\n             // supertype thereof.\n-            self.check_expr_with_lvalue_pref(init, LvaluePreference::from_mutbl(m));\n-            let init_ty = self.expr_ty(init);\n+            let init_ty = self.check_expr_with_lvalue_pref(init, LvaluePreference::from_mutbl(m));\n             self.demand_eqtype(init.span, init_ty, local_ty);\n+            init_ty\n         } else {\n             self.check_expr_coercable_to_type(init, local_ty)\n         };\n@@ -3905,7 +3906,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn check_stmt(&self, stmt: &'gcx hir::Stmt)  {\n+    pub fn check_stmt(&self, stmt: &'gcx hir::Stmt) {\n         let node_id;\n         let mut saw_bot = false;\n         let mut saw_err = false;\n@@ -3945,7 +3946,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.write_error(node_id);\n         }\n         else {\n-            self.write_nil(node_id)\n+            self.write_nil(node_id);\n         }\n     }\n "}, {"sha": "feb3258c88c253af9cd0960616687abb59bba8af", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0ddf060b6d347f89afb584501c86a4fa96ec7acc/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ddf060b6d347f89afb584501c86a4fa96ec7acc/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=0ddf060b6d347f89afb584501c86a4fa96ec7acc", "patch": "@@ -23,7 +23,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                               expr: &'gcx hir::Expr,\n                               op: hir::BinOp,\n                               lhs_expr: &'gcx hir::Expr,\n-                              rhs_expr: &'gcx hir::Expr)\n+                              rhs_expr: &'gcx hir::Expr) -> Ty<'tcx>\n     {\n         self.check_expr_with_lvalue_pref(lhs_expr, PreferMutLvalue);\n \n@@ -32,12 +32,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.check_overloaded_binop(expr, lhs_expr, lhs_ty, rhs_expr, op, IsAssign::Yes);\n         let rhs_ty = self.resolve_type_vars_with_obligations(rhs_ty);\n \n-        if !lhs_ty.is_ty_var() && !rhs_ty.is_ty_var() && is_builtin_binop(lhs_ty, rhs_ty, op) {\n+        let ty = if !lhs_ty.is_ty_var() && !rhs_ty.is_ty_var() && is_builtin_binop(lhs_ty, rhs_ty, op) {\n             self.enforce_builtin_binop_types(lhs_expr, lhs_ty, rhs_expr, rhs_ty, op);\n-            self.write_nil(expr.id);\n+            self.tcx.mk_nil()\n         } else {\n-            self.write_ty(expr.id, return_ty);\n-        }\n+            return_ty\n+        };\n+        let ty = self.write_ty(expr.id, ty);\n \n         let tcx = self.tcx;\n         if !tcx.expr_is_lval(lhs_expr) {\n@@ -49,14 +50,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 &format!(\"invalid expression for left-hand side\"))\n             .emit();\n         }\n+        ty\n     }\n \n     /// Check a potentially overloaded binary operator.\n     pub fn check_binop(&self,\n                        expr: &'gcx hir::Expr,\n                        op: hir::BinOp,\n                        lhs_expr: &'gcx hir::Expr,\n-                       rhs_expr: &'gcx hir::Expr)\n+                       rhs_expr: &'gcx hir::Expr) -> Ty<'tcx>\n     {\n         let tcx = self.tcx;\n \n@@ -70,12 +72,12 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.check_expr(lhs_expr);\n         let lhs_ty = self.resolve_type_vars_with_obligations(self.expr_ty(lhs_expr));\n \n-        match BinOpCategory::from(op) {\n+        let ty = match BinOpCategory::from(op) {\n             BinOpCategory::Shortcircuit => {\n                 // && and || are a simple case.\n                 self.demand_suptype(lhs_expr.span, tcx.mk_bool(), lhs_ty);\n                 self.check_expr_coercable_to_type(rhs_expr, tcx.mk_bool());\n-                self.write_ty(expr.id, tcx.mk_bool());\n+                tcx.mk_bool()\n             }\n             _ => {\n                 // Otherwise, we always treat operators as if they are\n@@ -107,9 +109,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     self.demand_suptype(expr.span, builtin_return_ty, return_ty);\n                 }\n \n-                self.write_ty(expr.id, return_ty);\n+                return_ty\n             }\n-        }\n+        };\n+        self.write_ty(expr.id, ty)\n     }\n \n     fn enforce_builtin_binop_types(&self,"}]}