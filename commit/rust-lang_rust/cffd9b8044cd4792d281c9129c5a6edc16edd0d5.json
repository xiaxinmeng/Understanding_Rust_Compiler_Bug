{"sha": "cffd9b8044cd4792d281c9129c5a6edc16edd0d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmZmQ5YjgwNDRjZDQ3OTJkMjgxYzkxMjljNWE2ZWRjMTZlZGQwZDU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-28T00:46:13Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-08-28T00:47:06Z"}, "message": "Convert rustc driver to istrs. Issue #855", "tree": {"sha": "3d9f6370b0029cbf20ad062dd26995fe2101c3b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d9f6370b0029cbf20ad062dd26995fe2101c3b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cffd9b8044cd4792d281c9129c5a6edc16edd0d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cffd9b8044cd4792d281c9129c5a6edc16edd0d5", "html_url": "https://github.com/rust-lang/rust/commit/cffd9b8044cd4792d281c9129c5a6edc16edd0d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cffd9b8044cd4792d281c9129c5a6edc16edd0d5/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7efbfea8d08c0aaf6cb6353acae23e8fa10c2492", "url": "https://api.github.com/repos/rust-lang/rust/commits/7efbfea8d08c0aaf6cb6353acae23e8fa10c2492", "html_url": "https://github.com/rust-lang/rust/commit/7efbfea8d08c0aaf6cb6353acae23e8fa10c2492"}], "stats": {"total": 226, "additions": 115, "deletions": 111}, "files": [{"sha": "9bb5750aab2b54db1aa08a7933317c7f8e82a3c9", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 115, "deletions": 111, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/cffd9b8044cd4792d281c9129c5a6edc16edd0d5/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cffd9b8044cd4792d281c9129c5a6edc16edd0d5/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=cffd9b8044cd4792d281c9129c5a6edc16edd0d5", "patch": "@@ -42,7 +42,8 @@ import back::link::output_type;\n \n tag pp_mode { ppm_normal; ppm_expanded; ppm_typed; ppm_identified; }\n \n-fn default_configuration(sess: session::session, argv0: str, input: str) ->\n+fn default_configuration(sess: session::session,\n+                         argv0: &istr, input: &istr) ->\n    ast::crate_cfg {\n     let libc =\n         alt sess.get_targ_cfg().os {\n@@ -59,10 +60,11 @@ fn default_configuration(sess: session::session, argv0: str, input: str) ->\n         mk(~\"target_arch\", \"x86\"),\n          mk(~\"target_libc\", libc),\n          // Build bindings.\n-         mk(~\"build_compiler\", argv0), mk(~\"build_input\", input)];\n+         mk(~\"build_compiler\", istr::to_estr(argv0)),\n+        mk(~\"build_input\", istr::to_estr(input))];\n }\n \n-fn build_configuration(sess: session::session, argv0: str, input: str) ->\n+fn build_configuration(sess: session::session, argv0: &istr, input: &istr) ->\n    ast::crate_cfg {\n     // Combine the configuration requested by the session (command line) with\n     // some default and generated configuration items\n@@ -80,104 +82,104 @@ fn build_configuration(sess: session::session, argv0: str, input: str) ->\n }\n \n // Convert strings provided as --cfg [cfgspec] into a crate_cfg\n-fn parse_cfgspecs(cfgspecs: &[str]) -> ast::crate_cfg {\n+fn parse_cfgspecs(cfgspecs: &[istr]) -> ast::crate_cfg {\n     // FIXME: It would be nice to use the parser to parse all varieties of\n     // meta_item here. At the moment we just support the meta_word variant.\n     let words = [];\n-    for s: str in cfgspecs {\n-        words += [attr::mk_word_item(istr::from_estr(s))];\n+    for s: istr in cfgspecs {\n+        words += [attr::mk_word_item(s)];\n     }\n     ret words;\n }\n \n-fn input_is_stdin(filename: str) -> bool { filename == \"-\" }\n+fn input_is_stdin(filename: &istr) -> bool { filename == ~\"-\" }\n \n-fn parse_input(sess: session::session, cfg: &ast::crate_cfg, input: str) ->\n-   @ast::crate {\n+fn parse_input(sess: session::session, cfg: &ast::crate_cfg,\n+               input: &istr) -> @ast::crate {\n     if !input_is_stdin(input) {\n         parser::parse_crate_from_file(\n-            istr::from_estr(input), cfg, sess.get_parse_sess())\n+            input, cfg, sess.get_parse_sess())\n     } else { parse_input_src(sess, cfg, input).crate }\n }\n \n-fn parse_input_src(sess: session::session, cfg: &ast::crate_cfg, infile: str)\n-   -> {crate: @ast::crate, src: str} {\n+fn parse_input_src(sess: session::session, cfg: &ast::crate_cfg,\n+                   infile: &istr) -> {crate: @ast::crate, src: istr} {\n     let srcbytes =\n-        if infile != \"-\" {\n-            io::file_reader(istr::from_estr(infile))\n+        if infile != ~\"-\" {\n+            io::file_reader(infile)\n         } else { io::stdin() }.read_whole_stream();\n-    let src = str::unsafe_from_bytes(srcbytes);\n+    let src = istr::unsafe_from_bytes(srcbytes);\n     let crate =\n         parser::parse_crate_from_source_str(\n-            istr::from_estr(infile),\n-            istr::from_estr(src), cfg,\n+            infile,\n+            src, cfg,\n             sess.get_parse_sess());\n     ret {crate: crate, src: src};\n }\n \n-fn time<@T>(do_it: bool, what: str, thunk: fn() -> T) -> T {\n+fn time<@T>(do_it: bool, what: &istr, thunk: fn() -> T) -> T {\n     if !do_it { ret thunk(); }\n     let start = std::time::precise_time_s();\n     let rv = thunk();\n     let end = std::time::precise_time_s();\n-    log_err #fmt[\"time: %s took %s s\", what,\n+    log_err #fmt[\"time: %s took %s s\", istr::to_estr(what),\n                  istr::to_estr(common::float_to_str(end - start, 3u))];\n     ret rv;\n }\n \n-fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n-                 output: str) {\n+fn compile_input(sess: session::session, cfg: ast::crate_cfg, input: &istr,\n+                 output: &istr) {\n     let time_passes = sess.get_opts().time_passes;\n     let crate =\n-        time(time_passes, \"parsing\", bind parse_input(sess, cfg, input));\n+        time(time_passes, ~\"parsing\", bind parse_input(sess, cfg, input));\n     if sess.get_opts().parse_only { ret; }\n     crate =\n-        time(time_passes, \"configuration\",\n+        time(time_passes, ~\"configuration\",\n              bind front::config::strip_unconfigured_items(crate));\n     if sess.get_opts().test {\n         crate =\n-            time(time_passes, \"building test harness\",\n+            time(time_passes, ~\"building test harness\",\n                  bind front::test::modify_for_testing(crate));\n     }\n     crate =\n-        time(time_passes, \"expansion\",\n+        time(time_passes, ~\"expansion\",\n              bind syntax::ext::expand::expand_crate(sess, crate));\n \n     let ast_map =\n-        time(time_passes, \"ast indexing\",\n+        time(time_passes, ~\"ast indexing\",\n              bind middle::ast_map::map_crate(*crate));\n-    time(time_passes, \"external crate/lib resolution\",\n+    time(time_passes, ~\"external crate/lib resolution\",\n          bind creader::read_crates(sess, *crate));\n     let {def_map: def_map, ext_map: ext_map} =\n-        time(time_passes, \"resolution\",\n+        time(time_passes, ~\"resolution\",\n              bind resolve::resolve_crate(sess, ast_map, crate));\n     let freevars =\n-        time(time_passes, \"freevar finding\",\n+        time(time_passes, ~\"freevar finding\",\n              bind freevars::annotate_freevars(sess, def_map, crate));\n     let ty_cx = ty::mk_ctxt(sess, def_map, ext_map, ast_map, freevars);\n-    time(time_passes, \"typechecking\",\n+    time(time_passes, ~\"typechecking\",\n          bind typeck::check_crate(ty_cx, crate));\n-    time(time_passes, \"alt checking\",\n+    time(time_passes, ~\"alt checking\",\n          bind middle::check_alt::check_crate(ty_cx, crate));\n     if sess.get_opts().run_typestate {\n-        time(time_passes, \"typestate checking\",\n+        time(time_passes, ~\"typestate checking\",\n              bind middle::tstate::ck::check_crate(ty_cx, crate));\n     }\n-    let mut_map = time(time_passes, \"alias checking\",\n+    let mut_map = time(time_passes, ~\"alias checking\",\n                        bind middle::alias::check_crate(ty_cx, crate));\n-    time(time_passes, \"kind checking\",\n+    time(time_passes, ~\"kind checking\",\n          bind kind::check_crate(ty_cx, crate));\n     if sess.get_opts().no_trans { ret; }\n-    let llmod = time(time_passes, \"translation\",\n+    let llmod = time(time_passes, ~\"translation\",\n                      bind trans::trans_crate(sess, crate, ty_cx,\n-                                             istr::from_estr(output),\n+                                             output,\n                                              ast_map, mut_map));\n-    time(time_passes, \"LLVM passes\",\n-         bind link::write::run_passes(sess, llmod, istr::from_estr(output)));\n+    time(time_passes, ~\"LLVM passes\",\n+         bind link::write::run_passes(sess, llmod, output));\n }\n \n-fn pretty_print_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n-                      ppm: pp_mode) {\n+fn pretty_print_input(sess: session::session, cfg: ast::crate_cfg,\n+                      input: &istr, ppm: pp_mode) {\n     fn ann_paren_for_expr(node: &pprust::ann_node) {\n         alt node { pprust::node_expr(s, expr) { pprust::popen(s); } _ { } }\n     }\n@@ -247,22 +249,24 @@ fn pretty_print_input(sess: session::session, cfg: ast::crate_cfg, input: str,\n       ppm_normal. { ann = pprust::no_ann(); }\n     }\n     pprust::print_crate(sess.get_codemap(), crate,\n-                        istr::from_estr(input),\n-                        io::string_reader(istr::from_estr(src)),\n+                        input,\n+                        io::string_reader(src),\n                         io::stdout(), ann);\n }\n \n-fn version(argv0: str) {\n+fn version(argv0: &istr) {\n     let vers = \"unknown version\";\n     let env_vers = #env[\"CFG_VERSION\"];\n     if str::byte_len(env_vers) != 0u { vers = env_vers; }\n     io::stdout().write_str(\n-        istr::from_estr(#fmt[\"%s %s\\n\", argv0, vers]));\n+        istr::from_estr(#fmt[\"%s %s\\n\",\n+                             istr::to_estr(argv0),\n+                             vers]));\n }\n \n-fn usage(argv0: str) {\n+fn usage(argv0: &istr) {\n     io::stdout().write_str(istr::from_estr(\n-        #fmt[\"usage: %s [options] <input>\\n\", argv0] +\n+        #fmt[\"usage: %s [options] <input>\\n\", istr::to_estr(argv0)] +\n                                \"\n options:\n \n@@ -299,41 +303,41 @@ options:\n \"));\n }\n \n-fn get_os(triple: str) -> session::os {\n-    ret if str::find(triple, \"win32\") >= 0 ||\n-               str::find(triple, \"mingw32\") >= 0 {\n+fn get_os(triple: &istr) -> session::os {\n+    ret if istr::find(triple, ~\"win32\") >= 0 ||\n+               istr::find(triple, ~\"mingw32\") >= 0 {\n             session::os_win32\n-        } else if str::find(triple, \"darwin\") >= 0 {\n+        } else if istr::find(triple, ~\"darwin\") >= 0 {\n             session::os_macos\n-        } else if str::find(triple, \"linux\") >= 0 {\n+        } else if istr::find(triple, ~\"linux\") >= 0 {\n             session::os_linux\n-        } else { log_err \"Unknown operating system!\"; fail };\n+        } else { log_err ~\"Unknown operating system!\"; fail };\n }\n \n-fn get_arch(triple: str) -> session::arch {\n-    ret if str::find(triple, \"i386\") >= 0 || str::find(triple, \"i486\") >= 0 ||\n-               str::find(triple, \"i586\") >= 0 ||\n-               str::find(triple, \"i686\") >= 0 ||\n-               str::find(triple, \"i786\") >= 0 {\n+fn get_arch(triple: &istr) -> session::arch {\n+    ret if istr::find(triple, ~\"i386\") >= 0 ||\n+        istr::find(triple, ~\"i486\") >= 0 ||\n+               istr::find(triple, ~\"i586\") >= 0 ||\n+               istr::find(triple, ~\"i686\") >= 0 ||\n+               istr::find(triple, ~\"i786\") >= 0 {\n             session::arch_x86\n-        } else if str::find(triple, \"x86_64\") >= 0 {\n+        } else if istr::find(triple, ~\"x86_64\") >= 0 {\n             session::arch_x64\n-        } else if str::find(triple, \"arm\") >= 0 ||\n-                      str::find(triple, \"xscale\") >= 0 {\n+        } else if istr::find(triple, ~\"arm\") >= 0 ||\n+                      istr::find(triple, ~\"xscale\") >= 0 {\n             session::arch_arm\n-        } else { log_err \"Unknown architecture! \" + triple; fail };\n+        } else { log_err ~\"Unknown architecture! \" + triple; fail };\n }\n \n-fn get_default_sysroot(binary: str) -> str {\n-    let dirname = istr::to_estr(\n-        fs::dirname(istr::from_estr(binary)));\n-    if str::eq(dirname, binary) { ret \".\"; }\n+fn get_default_sysroot(binary: &istr) -> istr {\n+    let dirname = fs::dirname(binary);\n+    if istr::eq(dirname, binary) { ret ~\".\"; }\n     ret dirname;\n }\n \n fn build_target_config() -> @session::config {\n-    let triple: str = istr::to_estr(\n-        istr::str_from_cstr(llvm::llvm::LLVMRustGetHostTriple()));\n+    let triple: istr =\n+        istr::str_from_cstr(llvm::llvm::LLVMRustGetHostTriple());\n     let target_cfg: @session::config =\n         @{os: get_os(triple),\n           arch: get_arch(triple),\n@@ -343,15 +347,15 @@ fn build_target_config() -> @session::config {\n     ret target_cfg;\n }\n \n-fn build_session_options(binary: str, match: &getopts::match, binary_dir: str)\n-   -> @session::options {\n+fn build_session_options(binary: &istr, match: &getopts::match,\n+                         binary_dir: &istr) -> @session::options {\n     let library = opt_present(match, ~\"lib\");\n     let static = opt_present(match, ~\"static\");\n \n-    let library_search_paths = [binary_dir + \"/lib\"];\n+    let library_search_paths = [binary_dir + ~\"/lib\"];\n     let lsp_vec = getopts::opt_strs(match, ~\"L\");\n     for lsp: istr in lsp_vec {\n-        library_search_paths += [istr::to_estr(lsp)];\n+        library_search_paths += [lsp];\n     }\n \n     let parse_only = opt_present(match, ~\"parse-only\");\n@@ -398,10 +402,10 @@ fn build_session_options(binary: str, match: &getopts::match, binary_dir: str)\n     let sysroot =\n         alt sysroot_opt {\n           none. { get_default_sysroot(binary) }\n-          some(s) { istr::to_estr(s) }\n+          some(s) { s }\n         };\n     let cfg = parse_cfgspecs(\n-        istr::to_estrs(getopts::opt_strs(match, ~\"cfg\")));\n+        getopts::opt_strs(match, ~\"cfg\"));\n     let test = opt_present(match, ~\"test\");\n     let do_gc = opt_present(match, ~\"gc\");\n     let sopts: @session::options =\n@@ -416,8 +420,8 @@ fn build_session_options(binary: str, match: &getopts::match, binary_dir: str)\n           time_passes: time_passes,\n           time_llvm_passes: time_llvm_passes,\n           output_type: output_type,\n-          library_search_paths: istr::from_estrs(library_search_paths),\n-          sysroot: istr::from_estr(sysroot),\n+          library_search_paths: library_search_paths,\n+          sysroot: sysroot,\n           cfg: cfg,\n           test: test,\n           parse_only: parse_only,\n@@ -460,11 +464,11 @@ fn opts() -> [getopts::opt] {\n }\n \n fn main(args: [str]) {\n+    let args = istr::from_estrs(args);\n     let binary = vec::shift(args);\n-    let binary_dir = istr::to_estr(\n-        fs::dirname(istr::from_estr(binary)));\n+    let binary_dir = fs::dirname(binary);\n     let match =\n-        alt getopts::getopts(istr::from_estrs(args), opts()) {\n+        alt getopts::getopts(args, opts()) {\n           getopts::success(m) { m }\n           getopts::failure(f) {\n             log_err #fmt[\"error: %s\", istr::to_estr(getopts::fail_str(f))];\n@@ -498,17 +502,17 @@ fn main(args: [str]) {\n         sess.fatal(~\"Multiple input filenames provided.\");\n     }\n     let ifile = match.free[0];\n-    let saved_out_filename: str = \"\";\n+    let saved_out_filename: istr = ~\"\";\n     let cfg = build_configuration(sess, binary,\n-                                  istr::to_estr(ifile));\n+                                  ifile);\n     let pretty =\n         option::map::<istr,\n                       pp_mode>(bind parse_pretty(sess, _),\n                                getopts::opt_default(match, ~\"pretty\",\n                                                     ~\"normal\"));\n     alt pretty {\n       some::<pp_mode>(ppm) {\n-        pretty_print_input(sess, cfg, istr::to_estr(ifile), ppm);\n+        pretty_print_input(sess, cfg, ifile, ppm);\n         ret;\n       }\n       none::<pp_mode>. {/* continue */ }\n@@ -526,32 +530,32 @@ fn main(args: [str]) {\n         // have to make up a name\n         // We want to toss everything after the final '.'\n         let parts =\n-            if !input_is_stdin(istr::to_estr(ifile)) {\n-                istr::to_estrs(istr::split(ifile, '.' as u8))\n-            } else { [\"default\", \"rs\"] };\n+            if !input_is_stdin(ifile) {\n+                istr::split(ifile, '.' as u8)\n+            } else { [~\"default\", ~\"rs\"] };\n         vec::pop(parts);\n-        saved_out_filename = str::connect(parts, \".\");\n+        saved_out_filename = istr::connect(parts, ~\".\");\n         let suffix =\n             alt sopts.output_type {\n-              link::output_type_none. { \"none\" }\n-              link::output_type_bitcode. { \"bc\" }\n-              link::output_type_assembly. { \"s\" }\n+              link::output_type_none. { ~\"none\" }\n+              link::output_type_bitcode. { ~\"bc\" }\n+              link::output_type_assembly. { ~\"s\" }\n \n               // Object and exe output both use the '.o' extension here\n               link::output_type_object. | link::output_type_exe. {\n-                \"o\"\n+                ~\"o\"\n               }\n             };\n-        let ofile = saved_out_filename + \".\" + suffix;\n-        compile_input(sess, cfg, istr::to_estr(ifile), ofile);\n+        let ofile = saved_out_filename + ~\".\" + suffix;\n+        compile_input(sess, cfg, ifile, ofile);\n       }\n       some(ofile) {\n-        let ofile = istr::to_estr(ofile);\n+        let ofile = ofile;\n         // FIXME: what about windows? This will create a foo.exe.o.\n         saved_out_filename = ofile;\n         let temp_filename =\n-            if !stop_after_codegen { ofile + \".o\" } else { ofile };\n-        compile_input(sess, cfg, istr::to_estr(ifile), temp_filename);\n+            if !stop_after_codegen { ofile + ~\".o\" } else { ofile };\n+        compile_input(sess, cfg, ifile, temp_filename);\n       }\n     }\n \n@@ -561,23 +565,23 @@ fn main(args: [str]) {\n     // TODO: Factor this out of main.\n     if stop_after_codegen { ret; }\n \n-    let glu: str = binary_dir + \"/lib/glue.o\";\n-    let main: str = binary_dir + \"/lib/main.o\";\n-    let stage: str = \"-L\" + binary_dir + \"/lib\";\n+    let glu: istr = binary_dir + ~\"/lib/glue.o\";\n+    let main: istr = binary_dir + ~\"/lib/main.o\";\n+    let stage: istr = ~\"-L\" + binary_dir + ~\"/lib\";\n     let prog: istr = ~\"gcc\";\n     // The invocations of gcc share some flags across platforms\n \n     let gcc_args =\n-        [istr::from_estr(stage),\n-         ~\"-Lrt\", ~\"-lrustrt\", istr::from_estr(glu),\n-         ~\"-m32\", ~\"-o\", istr::from_estr(saved_out_filename),\n-         istr::from_estr(saved_out_filename) + ~\".o\"];\n+        [stage,\n+         ~\"-Lrt\", ~\"-lrustrt\", glu,\n+         ~\"-m32\", ~\"-o\", saved_out_filename,\n+         saved_out_filename + ~\".o\"];\n     let lib_cmd;\n \n     let os = sess.get_targ_cfg().os;\n     if os == session::os_macos {\n-        lib_cmd = \"-dynamiclib\";\n-    } else { lib_cmd = \"-shared\"; }\n+        lib_cmd = ~\"-dynamiclib\";\n+    } else { lib_cmd = ~\"-shared\"; }\n \n     // Converts a library file name into a gcc -l argument\n     fn unlib(config: @session::config, filename: &istr) -> istr {\n@@ -622,10 +626,10 @@ fn main(args: [str]) {\n     for l: istr in used_libs { gcc_args += [~\"-l\" + l]; }\n \n     if sopts.library {\n-        gcc_args += [istr::from_estr(lib_cmd)];\n+        gcc_args += [lib_cmd];\n     } else {\n         // FIXME: why do we hardcode -lm?\n-        gcc_args += [~\"-lm\", istr::from_estr(main)];\n+        gcc_args += [~\"-lm\", main];\n     }\n     // We run 'gcc' here\n \n@@ -642,14 +646,14 @@ fn main(args: [str]) {\n \n     if sess.get_targ_cfg().os == session::os_macos {\n         run::run_program(~\"dsymutil\",\n-                         [istr::from_estr(saved_out_filename)]);\n+                         [saved_out_filename]);\n     }\n \n \n     // Remove the temporary object file if we aren't saving temps\n     if !sopts.save_temps {\n         run::run_program(~\"rm\",\n-                         [istr::from_estr(saved_out_filename) + ~\".o\"]);\n+                         [saved_out_filename + ~\".o\"]);\n     }\n }\n \n@@ -663,9 +667,9 @@ mod test {\n             alt getopts::getopts([~\"--test\"], opts()) {\n               getopts::success(m) { m }\n             };\n-        let sessopts = build_session_options(\"whatever\", match, \"whatever\");\n+        let sessopts = build_session_options(~\"whatever\", match, ~\"whatever\");\n         let sess = build_session(sessopts);\n-        let cfg = build_configuration(sess, \"whatever\", \"whatever\");\n+        let cfg = build_configuration(sess, ~\"whatever\", ~\"whatever\");\n         assert (attr::contains_name(cfg, ~\"test\"));\n     }\n \n@@ -677,9 +681,9 @@ mod test {\n             alt getopts::getopts([~\"--test\", ~\"--cfg=test\"], opts()) {\n               getopts::success(m) { m }\n             };\n-        let sessopts = build_session_options(\"whatever\", match, \"whatever\");\n+        let sessopts = build_session_options(~\"whatever\", match, ~\"whatever\");\n         let sess = build_session(sessopts);\n-        let cfg = build_configuration(sess, \"whatever\", \"whatever\");\n+        let cfg = build_configuration(sess, ~\"whatever\", ~\"whatever\");\n         let test_items = attr::find_meta_items_by_name(cfg, ~\"test\");\n         assert (vec::len(test_items) == 1u);\n     }"}]}