{"sha": "bcf348800751e8a03fdbaa49130e53a463e3a441", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjZjM0ODgwMDc1MWU4YTAzZmRiYWE0OTEzMGU1M2E0NjNlM2E0NDE=", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-03-30T00:17:03Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-04-15T12:25:24Z"}, "message": "Minor cleanup of `map_entry` and a few additional tests.", "tree": {"sha": "b98a97a27fb4fba382e38f12af33e331da9d4f49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b98a97a27fb4fba382e38f12af33e331da9d4f49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bcf348800751e8a03fdbaa49130e53a463e3a441", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nComment: Created with Krypton\n\niF4EABYKAAYFAmB4ML8ACgkQ2lnoZDo37QYOHQD/XlbQhRZINg14A67j9beT8DP/\n/gH3EMueiQ/oilCZUJoA/3dKurPIqjzfTDkUgW2F3sXplqNCdNSx8zdwYQ+4/T4H\n=hap/\n-----END PGP SIGNATURE-----", "payload": "tree b98a97a27fb4fba382e38f12af33e331da9d4f49\nparent 3323ff71455c763a03353527d6203f90b53058fd\nauthor Jason Newcomb <jsnewcomb@pm.me> 1617063423 -0400\ncommitter Jason Newcomb <jsnewcomb@pm.me> 1618489524 -0400\n\nMinor cleanup of `map_entry` and a few additional tests.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bcf348800751e8a03fdbaa49130e53a463e3a441", "html_url": "https://github.com/rust-lang/rust/commit/bcf348800751e8a03fdbaa49130e53a463e3a441", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bcf348800751e8a03fdbaa49130e53a463e3a441/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3323ff71455c763a03353527d6203f90b53058fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/3323ff71455c763a03353527d6203f90b53058fd", "html_url": "https://github.com/rust-lang/rust/commit/3323ff71455c763a03353527d6203f90b53058fd"}], "stats": {"total": 458, "additions": 238, "deletions": 220}, "files": [{"sha": "8db5050a5ac30510ccc424c15781860db49ba2da", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 95, "deletions": 92, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/bcf348800751e8a03fdbaa49130e53a463e3a441/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf348800751e8a03fdbaa49130e53a463e3a441/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=bcf348800751e8a03fdbaa49130e53a463e3a441", "patch": "@@ -77,40 +77,33 @@ impl<'tcx> LateLintPass<'tcx> for HashMapPass {\n         let map_str = snippet_with_context(cx, contains_expr.map.span, contains_expr.call_ctxt, \"..\", &mut app).0;\n         let key_str = snippet_with_context(cx, contains_expr.key.span, contains_expr.call_ctxt, \"..\", &mut app).0;\n         let sugg = if let Some(else_expr) = else_expr {\n-            // if .. { .. } else { .. }\n             let else_search = match find_insert_calls(cx, &contains_expr, else_expr) {\n-                Some(search) if !(then_search.edits.is_empty() && search.edits.is_empty()) => search,\n-                _ => return,\n+                Some(search) => search,\n+                None => return,\n             };\n \n-            if then_search.edits.is_empty() || else_search.edits.is_empty() {\n-                // if .. { insert } else { .. } or if .. { .. } else { then } of\n-                let (then_str, else_str, entry_kind) = if else_search.edits.is_empty() {\n-                    if contains_expr.negated {\n-                        (\n-                            then_search.snippet_vacant(cx, then_expr.span, &mut app),\n-                            snippet_with_applicability(cx, else_expr.span, \"{ .. }\", &mut app),\n-                            \"Vacant(e)\",\n-                        )\n-                    } else {\n-                        (\n-                            then_search.snippet_occupied(cx, then_expr.span, &mut app),\n-                            snippet_with_applicability(cx, else_expr.span, \"{ .. }\", &mut app),\n-                            \"Occupied(mut e)\",\n-                        )\n-                    }\n-                } else if contains_expr.negated {\n-                    (\n+            if then_search.edits.is_empty() && else_search.edits.is_empty() {\n+                // No insertions\n+                return;\n+            } else if then_search.edits.is_empty() || else_search.edits.is_empty() {\n+                // if .. { insert } else { .. } or if .. { .. } else { insert }\n+                let ((then_str, entry_kind), else_str) = match (else_search.edits.is_empty(), contains_expr.negated) {\n+                    (true, true) => (\n+                        then_search.snippet_vacant(cx, then_expr.span, &mut app),\n+                        snippet_with_applicability(cx, else_expr.span, \"{ .. }\", &mut app),\n+                    ),\n+                    (true, false) => (\n+                        then_search.snippet_occupied(cx, then_expr.span, &mut app),\n+                        snippet_with_applicability(cx, else_expr.span, \"{ .. }\", &mut app),\n+                    ),\n+                    (false, true) => (\n                         else_search.snippet_occupied(cx, else_expr.span, &mut app),\n                         snippet_with_applicability(cx, then_expr.span, \"{ .. }\", &mut app),\n-                        \"Occupied(mut e)\",\n-                    )\n-                } else {\n-                    (\n+                    ),\n+                    (false, false) => (\n                         else_search.snippet_vacant(cx, else_expr.span, &mut app),\n                         snippet_with_applicability(cx, then_expr.span, \"{ .. }\", &mut app),\n-                        \"Vacant(e)\",\n-                    )\n+                    ),\n                 };\n                 format!(\n                     \"if let {}::{} = {}.entry({}) {} else {}\",\n@@ -123,19 +116,15 @@ impl<'tcx> LateLintPass<'tcx> for HashMapPass {\n                 )\n             } else {\n                 // if .. { insert } else { insert }\n-                let (then_str, else_str, then_entry, else_entry) = if contains_expr.negated {\n+                let ((then_str, then_entry), (else_str, else_entry)) = if contains_expr.negated {\n                     (\n                         then_search.snippet_vacant(cx, then_expr.span, &mut app),\n                         else_search.snippet_occupied(cx, else_expr.span, &mut app),\n-                        \"Vacant(e)\",\n-                        \"Occupied(mut e)\",\n                     )\n                 } else {\n                     (\n                         then_search.snippet_occupied(cx, then_expr.span, &mut app),\n                         else_search.snippet_vacant(cx, else_expr.span, &mut app),\n-                        \"Occupied(mut e)\",\n-                        \"Vacant(e)\",\n                     )\n                 };\n                 let indent_str = snippet_indent(cx, expr.span);\n@@ -153,19 +142,18 @@ impl<'tcx> LateLintPass<'tcx> for HashMapPass {\n                     indent = indent_str,\n                 )\n             }\n-        } else if then_search.edits.is_empty() {\n-            // no insertions\n-            return;\n         } else {\n+            if then_search.edits.is_empty() {\n+                // no insertions\n+                return;\n+            }\n+\n             // if .. { insert }\n             if !then_search.allow_insert_closure {\n                 let (body_str, entry_kind) = if contains_expr.negated {\n-                    (then_search.snippet_vacant(cx, then_expr.span, &mut app), \"Vacant(e)\")\n+                    then_search.snippet_vacant(cx, then_expr.span, &mut app)\n                 } else {\n-                    (\n-                        then_search.snippet_occupied(cx, then_expr.span, &mut app),\n-                        \"Occupied(mut e)\",\n-                    )\n+                    then_search.snippet_occupied(cx, then_expr.span, &mut app)\n                 };\n                 format!(\n                     \"if let {}::{} = {}.entry({}) {}\",\n@@ -184,15 +172,17 @@ impl<'tcx> LateLintPass<'tcx> for HashMapPass {\n                         format!(\"{}.entry({}).or_insert({});\", map_str, key_str, value_str)\n                     }\n                 } else {\n-                    // Todo: if let Some(v) = map.get_mut(k)\n+                    // TODO: suggest using `if let Some(v) = map.get_mut(k) { .. }` here.\n+                    // This would need to be a different lint.\n                     return;\n                 }\n             } else {\n                 let block_str = then_search.snippet_closure(cx, then_expr.span, &mut app);\n                 if contains_expr.negated {\n                     format!(\"{}.entry({}).or_insert_with(|| {});\", map_str, key_str, block_str)\n                 } else {\n-                    // Todo: if let Some(v) = map.get_mut(k)\n+                    // TODO: suggest using `if let Some(v) = map.get_mut(k) { .. }` here.\n+                    // This would need to be a different lint.\n                     return;\n                 }\n             }\n@@ -222,7 +212,7 @@ impl MapType {\n             Self::BTree => \"BTreeMap\",\n         }\n     }\n-    fn entry_path(self) -> &'staic str {\n+    fn entry_path(self) -> &'static str {\n         match self {\n             Self::Hash => \"std::collections::hash_map::Entry\",\n             Self::BTree => \"std::collections::btree_map::Entry\",\n@@ -312,15 +302,16 @@ struct Insertion<'tcx> {\n     value: &'tcx Expr<'tcx>,\n }\n \n-// This visitor needs to do a multiple things:\n-// * Find all usages of the map. Only insertions into the map which share the same key are\n-//   permitted. All others will prevent the lint.\n-// * Determine if the final statement executed is an insertion. This is needed to use `insert_with`.\n-// * Determine if there's any sub-expression that can't be placed in a closure.\n-// * Determine if there's only a single insert statement. This is needed to give better suggestions.\n-\n+/// This visitor needs to do a multiple things:\n+/// * Find all usages of the map. An insertion can only be made before any other usages of the map.\n+/// * Determine if there's an insertion using the same key. There's no need for the entry api\n+///   otherwise.\n+/// * Determine if the final statement executed is an insertion. This is needed to use\n+///   `or_insert_with`.\n+/// * Determine if there's any sub-expression that can't be placed in a closure.\n+/// * Determine if there's only a single insert statement. `or_insert` can be used in this case.\n #[allow(clippy::struct_excessive_bools)]\n-struct InsertSearcher<'cx, 'i, 'tcx> {\n+struct InsertSearcher<'cx, 'tcx> {\n     cx: &'cx LateContext<'tcx>,\n     /// The map expression used in the contains call.\n     map: &'tcx Expr<'tcx>,\n@@ -334,13 +325,16 @@ struct InsertSearcher<'cx, 'i, 'tcx> {\n     can_use_entry: bool,\n     /// Whether this expression is the final expression in this code path. This may be a statement.\n     in_tail_pos: bool,\n-    // A single insert expression has a slightly different suggestion.\n+    // Is this expression a single insert. A slightly better suggestion can be made in this case.\n     is_single_insert: bool,\n+    /// If the visitor has seen the map being used.\n     is_map_used: bool,\n-    edits: &'i mut Vec<Edit<'tcx>>,\n+    /// The locations where changes need to be made for the suggestion.\n+    edits: Vec<Edit<'tcx>>,\n+    /// A stack of loops the visitor is currently in.\n     loops: Vec<HirId>,\n }\n-impl<'tcx> InsertSearcher<'_, '_, 'tcx> {\n+impl<'tcx> InsertSearcher<'_, 'tcx> {\n     /// Visit the expression as a branch in control flow. Multiple insert calls can be used, but\n     /// only if they are on separate code paths. This will return whether the map was used in the\n     /// given expression.\n@@ -363,7 +357,7 @@ impl<'tcx> InsertSearcher<'_, '_, 'tcx> {\n         self.in_tail_pos = in_tail_pos;\n     }\n }\n-impl<'tcx> Visitor<'tcx> for InsertSearcher<'_, '_, 'tcx> {\n+impl<'tcx> Visitor<'tcx> for InsertSearcher<'_, 'tcx> {\n     type Map = ErasedMap<'tcx>;\n     fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n         NestedVisitorMap::None\n@@ -483,6 +477,7 @@ impl<'tcx> Visitor<'tcx> for InsertSearcher<'_, '_, 'tcx> {\n                 },\n                 ExprKind::Loop(block, ..) => {\n                     self.loops.push(expr.hir_id);\n+                    self.is_single_insert = false;\n                     self.allow_insert_closure &= !self.in_tail_pos;\n                     // Don't allow insertions inside of a loop.\n                     let edit_len = self.edits.len();\n@@ -519,7 +514,13 @@ impl InsertSearchResults<'tcx> {\n         self.is_single_insert.then(|| self.edits[0].as_insertion().unwrap())\n     }\n \n-    fn snippet_occupied(&self, cx: &LateContext<'_>, mut span: Span, app: &mut Applicability) -> String {\n+    fn snippet(\n+        &self,\n+        cx: &LateContext<'_>,\n+        mut span: Span,\n+        app: &mut Applicability,\n+        write_wrapped: impl Fn(&mut String, Insertion<'_>, SyntaxContext, &mut Applicability),\n+    ) -> String {\n         let ctxt = span.ctxt();\n         let mut res = String::new();\n         for insertion in self.edits.iter().filter_map(|e| e.as_insertion()) {\n@@ -530,56 +531,55 @@ impl InsertSearchResults<'tcx> {\n                 app,\n             ));\n             if is_expr_used_or_unified(cx.tcx, insertion.call) {\n-                res.push_str(\"Some(e.insert(\");\n-                res.push_str(&snippet_with_context(cx, insertion.value.span, ctxt, \"..\", app).0);\n-                res.push_str(\"))\");\n+                write_wrapped(&mut res, insertion, ctxt, app);\n             } else {\n-                res.push_str(\"e.insert(\");\n-                res.push_str(&snippet_with_context(cx, insertion.value.span, ctxt, \"..\", app).0);\n-                res.push(')');\n+                let _ = write!(\n+                    res,\n+                    \"e.insert({})\",\n+                    snippet_with_context(cx, insertion.value.span, ctxt, \"..\", app).0\n+                );\n             }\n             span = span.trim_start(insertion.call.span).unwrap_or(DUMMY_SP);\n         }\n         res.push_str(&snippet_with_applicability(cx, span, \"..\", app));\n         res\n     }\n \n-    fn snippet_vacant(&self, cx: &LateContext<'_>, mut span: Span, app: &mut Applicability) -> String {\n-        let ctxt = span.ctxt();\n-        let mut res = String::new();\n-        for insertion in self.edits.iter().filter_map(|e| e.as_insertion()) {\n-            res.push_str(&snippet_with_applicability(\n-                cx,\n-                span.until(insertion.call.span),\n-                \"..\",\n-                app,\n-            ));\n-            if is_expr_used_or_unified(cx.tcx, insertion.call) {\n-                if is_expr_final_block_expr(cx.tcx, insertion.call) {\n-                    let _ = write!(\n+    fn snippet_occupied(&self, cx: &LateContext<'_>, span: Span, app: &mut Applicability) -> (String, &'static str) {\n+        (\n+            self.snippet(cx, span, app, |res, insertion, ctxt, app| {\n+                // Insertion into a map would return `Some(&mut value)`, but the entry returns `&mut value`\n+                let _ = write!(\n+                    res,\n+                    \"Some(e.insert({}))\",\n+                    snippet_with_context(cx, insertion.value.span, ctxt, \"..\", app).0\n+                );\n+            }),\n+            \"Occupied(mut e)\",\n+        )\n+    }\n+\n+    fn snippet_vacant(&self, cx: &LateContext<'_>, span: Span, app: &mut Applicability) -> (String, &'static str) {\n+        (\n+            self.snippet(cx, span, app, |res, insertion, ctxt, app| {\n+                // Insertion into a map would return `None`, but the entry returns a mutable reference.\n+                let _ = if is_expr_final_block_expr(cx.tcx, insertion.call) {\n+                    write!(\n                         res,\n                         \"e.insert({});\\n{}None\",\n                         snippet_with_context(cx, insertion.value.span, ctxt, \"..\", app).0,\n                         snippet_indent(cx, insertion.call.span).as_deref().unwrap_or(\"\"),\n-                    );\n+                    )\n                 } else {\n-                    let _ = write!(\n+                    write!(\n                         res,\n                         \"{{ e.insert({}); None }}\",\n                         snippet_with_context(cx, insertion.value.span, ctxt, \"..\", app).0,\n-                    );\n-                }\n-            } else {\n-                let _ = write!(\n-                    res,\n-                    \"e.insert({})\",\n-                    snippet_with_context(cx, insertion.value.span, ctxt, \"..\", app).0,\n-                );\n-            }\n-            span = span.trim_start(insertion.call.span).unwrap_or(DUMMY_SP);\n-        }\n-        res.push_str(&snippet_with_applicability(cx, span, \"..\", app));\n-        res\n+                    )\n+                };\n+            }),\n+            \"Vacant(e)\",\n+        )\n     }\n \n     fn snippet_closure(&self, cx: &LateContext<'_>, mut span: Span, app: &mut Applicability) -> String {\n@@ -588,6 +588,7 @@ impl InsertSearchResults<'tcx> {\n         for edit in &self.edits {\n             match *edit {\n                 Edit::Insertion(insertion) => {\n+                    // Cut out the value from `map.insert(key, value)`\n                     res.push_str(&snippet_with_applicability(\n                         cx,\n                         span.until(insertion.call.span),\n@@ -598,6 +599,7 @@ impl InsertSearchResults<'tcx> {\n                     span = span.trim_start(insertion.call.span).unwrap_or(DUMMY_SP);\n                 },\n                 Edit::RemoveSemi(semi_span) => {\n+                    // Cut out the semicolon. This allows the value to be returned from the closure.\n                     res.push_str(&snippet_with_applicability(cx, span.until(semi_span), \"..\", app));\n                     span = span.trim_start(semi_span).unwrap_or(DUMMY_SP);\n                 },\n@@ -607,18 +609,18 @@ impl InsertSearchResults<'tcx> {\n         res\n     }\n }\n+\n fn find_insert_calls(\n     cx: &LateContext<'tcx>,\n     contains_expr: &ContainsExpr<'tcx>,\n     expr: &'tcx Expr<'_>,\n ) -> Option<InsertSearchResults<'tcx>> {\n-    let mut edits = Vec::new();\n     let mut s = InsertSearcher {\n         cx,\n         map: contains_expr.map,\n         key: contains_expr.key,\n         ctxt: expr.span.ctxt(),\n-        edits: &mut edits,\n+        edits: Vec::new(),\n         is_map_used: false,\n         allow_insert_closure: true,\n         can_use_entry: true,\n@@ -629,6 +631,7 @@ fn find_insert_calls(\n     s.visit_expr(expr);\n     let allow_insert_closure = s.allow_insert_closure;\n     let is_single_insert = s.is_single_insert;\n+    let edits = s.edits;\n     s.can_use_entry.then(|| InsertSearchResults {\n         edits,\n         allow_insert_closure,"}, {"sha": "d9b75149b9f13f2ab4911bc0cb1a92a109f6e04f", "filename": "clippy_lints/src/manual_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bcf348800751e8a03fdbaa49130e53a463e3a441/clippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf348800751e8a03fdbaa49130e53a463e3a441/clippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_map.rs?ref=bcf348800751e8a03fdbaa49130e53a463e3a441", "patch": "@@ -2,13 +2,13 @@ use crate::{map_unit_fn::OPTION_MAP_UNIT_FN, matches::MATCH_AS_REF};\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable};\n-use clippy_utils::{can_move_expr_to_closure, in_constant, is_allowed, is_else_clause, is_lang_ctor, match_var, peel_hir_expr_refs};\n+use clippy_utils::{\n+    can_move_expr_to_closure, in_constant, is_allowed, is_else_clause, is_lang_ctor, match_var, peel_hir_expr_refs,\n+};\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n-use rustc_hir::{\n-    Arm, BindingAnnotation, Block, Expr, ExprKind, MatchSource, Mutability, Pat, PatKind, QPath,\n-};\n+use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, MatchSource, Mutability, Pat, PatKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_session::{declare_lint_pass, declare_tool_lint};"}, {"sha": "90a6fd225ab077f6c5b7c26ee70c95fa4ffdf29a", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 14, "deletions": 45, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/bcf348800751e8a03fdbaa49130e53a463e3a441/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf348800751e8a03fdbaa49130e53a463e3a441/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=bcf348800751e8a03fdbaa49130e53a463e3a441", "patch": "@@ -64,8 +64,8 @@ use rustc_hir::intravisit::{self, walk_expr, ErasedMap, NestedVisitorMap, Visito\n use rustc_hir::LangItem::{ResultErr, ResultOk};\n use rustc_hir::{\n     def, Arm, BindingAnnotation, Block, Body, Constness, Destination, Expr, ExprKind, FnDecl, GenericArgs, HirId, Impl,\n-    ImplItem, ImplItemKind, Item, ItemKind, LangItem, MatchSource, Node, Param, Pat, PatKind, Path, PathSegment, QPath,\n-    Stmt, StmtKind, TraitItem, TraitItemKind, TraitRef, TyKind,\n+    ImplItem, ImplItemKind, Item, ItemKind, LangItem, Local, MatchSource, Node, Param, Pat, PatKind, Path, PathSegment,\n+    QPath, Stmt, StmtKind, TraitItem, TraitItemKind, TraitRef, TyKind,\n };\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n use rustc_middle::hir::exports::Export;\n@@ -1312,48 +1312,7 @@ pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     did.map_or(false, |did| must_use_attr(&cx.tcx.get_attrs(did)).is_some())\n }\n \n-pub fn get_expr_use_node(tcx: TyCtxt<'tcx>, expr: &Expr<'_>) -> Option<Node<'tcx>> {\n-    let map = tcx.hir();\n-    let mut child_id = expr.hir_id;\n-    let mut iter = map.parent_iter(child_id);\n-    loop {\n-        match iter.next() {\n-            None => break None,\n-            Some((id, Node::Block(_))) => child_id = id,\n-            Some((id, Node::Arm(arm))) if arm.body.hir_id == child_id => child_id = id,\n-            Some((_, Node::Expr(expr))) => match expr.kind {\n-                ExprKind::Break(\n-                    Destination {\n-                        target_id: Ok(dest), ..\n-                    },\n-                    _,\n-                ) => {\n-                    iter = map.parent_iter(dest);\n-                    child_id = dest;\n-                },\n-                ExprKind::DropTemps(_) | ExprKind::Block(..) => child_id = expr.hir_id,\n-                ExprKind::If(control_expr, ..) | ExprKind::Match(control_expr, ..)\n-                    if control_expr.hir_id != child_id =>\n-                {\n-                    child_id = expr.hir_id\n-                },\n-                _ => break Some(Node::Expr(expr)),\n-            },\n-            Some((_, node)) => break Some(node),\n-        }\n-    }\n-}\n-\n-pub fn is_expr_used(tcx: TyCtxt<'_>, expr: &Expr<'_>) -> bool {\n-    !matches!(\n-        get_expr_use_node(tcx, expr),\n-        Some(Node::Stmt(Stmt {\n-            kind: StmtKind::Expr(_) | StmtKind::Semi(_),\n-            ..\n-        }))\n-    )\n-}\n-\n+/// Gets the node where an expression is either used, or it's type is unified with another branch.\n pub fn get_expr_use_or_unification_node(tcx: TyCtxt<'tcx>, expr: &Expr<'_>) -> Option<Node<'tcx>> {\n     let map = tcx.hir();\n     let mut child_id = expr.hir_id;\n@@ -1374,16 +1333,26 @@ pub fn get_expr_use_or_unification_node(tcx: TyCtxt<'tcx>, expr: &Expr<'_>) -> O\n     }\n }\n \n+/// Checks if the result of an expression is used, or it's type is unified with another branch.\n pub fn is_expr_used_or_unified(tcx: TyCtxt<'_>, expr: &Expr<'_>) -> bool {\n     !matches!(\n         get_expr_use_or_unification_node(tcx, expr),\n         None | Some(Node::Stmt(Stmt {\n-            kind: StmtKind::Expr(_) | StmtKind::Semi(_),\n+            kind: StmtKind::Expr(_)\n+                | StmtKind::Semi(_)\n+                | StmtKind::Local(Local {\n+                    pat: Pat {\n+                        kind: PatKind::Wild,\n+                        ..\n+                    },\n+                    ..\n+                }),\n             ..\n         }))\n     )\n }\n \n+/// Checks if the expression is the final expression returned from a block.\n pub fn is_expr_final_block_expr(tcx: TyCtxt<'_>, expr: &Expr<'_>) -> bool {\n     matches!(get_parent_node(tcx, expr.hir_id), Some(Node::Block(..)))\n }"}, {"sha": "cfad3090ba38d2bc7a0a5482c0c97084757f4fee", "filename": "tests/ui/entry.fixed", "status": "modified", "additions": 53, "deletions": 5, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/bcf348800751e8a03fdbaa49130e53a463e3a441/tests%2Fui%2Fentry.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/bcf348800751e8a03fdbaa49130e53a463e3a441/tests%2Fui%2Fentry.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry.fixed?ref=bcf348800751e8a03fdbaa49130e53a463e3a441", "patch": "@@ -2,6 +2,7 @@\n \n #![allow(unused, clippy::needless_pass_by_value, clippy::collapsible_if)]\n #![warn(clippy::map_entry)]\n+#![feature(asm)]\n \n use std::collections::{BTreeMap, HashMap};\n use std::hash::Hash;\n@@ -10,11 +11,19 @@ macro_rules! m {\n     ($e:expr) => {{ $e }};\n }\n \n+macro_rules! insert {\n+    ($map:expr, $key:expr, $val:expr) => {\n+        $map.insert($key, $val)\n+    };\n+}\n+\n fn foo() {}\n \n-fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, k: K, v: V, v2: V) {\n+fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, m2: &mut HashMap<K, V>, k: K, k2: K, v: V, v2: V) {\n+    // or_insert(v)\n     m.entry(k).or_insert(v);\n \n+    // semicolon on insert, use or_insert_with(..)\n     m.entry(k).or_insert_with(|| {\n         if true {\n             v\n@@ -23,6 +32,7 @@ fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, k: K, v: V, v2:\n         }\n     });\n \n+    // semicolon on if, use or_insert_with(..)\n     m.entry(k).or_insert_with(|| {\n         if true {\n             v\n@@ -31,6 +41,7 @@ fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, k: K, v: V, v2:\n         }\n     });\n \n+    // early return, use if let\n     if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n         if true {\n             e.insert(v);\n@@ -40,11 +51,13 @@ fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, k: K, v: V, v2:\n         }\n     }\n \n+    // use or_insert_with(..)\n     m.entry(k).or_insert_with(|| {\n         foo();\n         v\n     });\n \n+    // semicolon on insert and match, use or_insert_with(..)\n     m.entry(k).or_insert_with(|| {\n         match 0 {\n             1 if true => {\n@@ -56,18 +69,17 @@ fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, k: K, v: V, v2:\n         }\n     });\n \n+    // one branch doesn't insert, use if let\n     if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n         match 0 {\n-            0 => {},\n-            1 => {\n-                e.insert(v);\n-            },\n+            0 => foo(),\n             _ => {\n                 e.insert(v2);\n             },\n         };\n     }\n \n+    // use or_insert_with\n     m.entry(k).or_insert_with(|| {\n         foo();\n         match 0 {\n@@ -94,10 +106,46 @@ fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, k: K, v: V, v2:\n         }\n     });\n \n+    // ok, insert in loop\n+    if !m.contains_key(&k) {\n+        for _ in 0..2 {\n+            m.insert(k, v);\n+        }\n+    }\n+\n+    // macro_expansion test, use or_insert(..)\n     m.entry(m!(k)).or_insert_with(|| m!(v));\n+\n+    // ok, map used before insertion\n+    if !m.contains_key(&k) {\n+        let _ = m.len();\n+        m.insert(k, v);\n+    }\n+\n+    // ok, inline asm\n+    if !m.contains_key(&k) {\n+        unsafe { asm!(\"nop\") }\n+        m.insert(k, v);\n+    }\n+\n+    // ok, different keys.\n+    if !m.contains_key(&k) {\n+        m.insert(k2, v);\n+    }\n+\n+    // ok, different maps\n+    if !m.contains_key(&k) {\n+        m2.insert(k, v);\n+    }\n+\n+    // ok, insert in macro\n+    if !m.contains_key(&k) {\n+        insert!(m, k, v);\n+    }\n }\n \n fn btree_map<K: Eq + Ord + Copy, V: Copy>(m: &mut BTreeMap<K, V>, k: K, v: V, v2: V) {\n+    // insert then do something, use if let\n     if let std::collections::btree_map::Entry::Vacant(e) = m.entry(k) {\n         e.insert(v);\n         foo();"}, {"sha": "fa9280b58de11cd513d6ced8c6ef0a8fe81b5cdf", "filename": "tests/ui/entry.rs", "status": "modified", "additions": 53, "deletions": 5, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/bcf348800751e8a03fdbaa49130e53a463e3a441/tests%2Fui%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf348800751e8a03fdbaa49130e53a463e3a441/tests%2Fui%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry.rs?ref=bcf348800751e8a03fdbaa49130e53a463e3a441", "patch": "@@ -2,6 +2,7 @@\n \n #![allow(unused, clippy::needless_pass_by_value, clippy::collapsible_if)]\n #![warn(clippy::map_entry)]\n+#![feature(asm)]\n \n use std::collections::{BTreeMap, HashMap};\n use std::hash::Hash;\n@@ -10,13 +11,21 @@ macro_rules! m {\n     ($e:expr) => {{ $e }};\n }\n \n+macro_rules! insert {\n+    ($map:expr, $key:expr, $val:expr) => {\n+        $map.insert($key, $val)\n+    };\n+}\n+\n fn foo() {}\n \n-fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, k: K, v: V, v2: V) {\n+fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, m2: &mut HashMap<K, V>, k: K, k2: K, v: V, v2: V) {\n+    // or_insert(v)\n     if !m.contains_key(&k) {\n         m.insert(k, v);\n     }\n \n+    // semicolon on insert, use or_insert_with(..)\n     if !m.contains_key(&k) {\n         if true {\n             m.insert(k, v);\n@@ -25,6 +34,7 @@ fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, k: K, v: V, v2:\n         }\n     }\n \n+    // semicolon on if, use or_insert_with(..)\n     if !m.contains_key(&k) {\n         if true {\n             m.insert(k, v)\n@@ -33,6 +43,7 @@ fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, k: K, v: V, v2:\n         };\n     }\n \n+    // early return, use if let\n     if !m.contains_key(&k) {\n         if true {\n             m.insert(k, v);\n@@ -42,11 +53,13 @@ fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, k: K, v: V, v2:\n         }\n     }\n \n+    // use or_insert_with(..)\n     if !m.contains_key(&k) {\n         foo();\n         m.insert(k, v);\n     }\n \n+    // semicolon on insert and match, use or_insert_with(..)\n     if !m.contains_key(&k) {\n         match 0 {\n             1 if true => {\n@@ -58,18 +71,17 @@ fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, k: K, v: V, v2:\n         };\n     }\n \n+    // one branch doesn't insert, use if let\n     if !m.contains_key(&k) {\n         match 0 {\n-            0 => {},\n-            1 => {\n-                m.insert(k, v);\n-            },\n+            0 => foo(),\n             _ => {\n                 m.insert(k, v2);\n             },\n         };\n     }\n \n+    // use or_insert_with\n     if !m.contains_key(&k) {\n         foo();\n         match 0 {\n@@ -96,12 +108,48 @@ fn hash_map<K: Eq + Hash + Copy, V: Copy>(m: &mut HashMap<K, V>, k: K, v: V, v2:\n         }\n     }\n \n+    // ok, insert in loop\n+    if !m.contains_key(&k) {\n+        for _ in 0..2 {\n+            m.insert(k, v);\n+        }\n+    }\n+\n+    // macro_expansion test, use or_insert(..)\n     if !m.contains_key(&m!(k)) {\n         m.insert(m!(k), m!(v));\n     }\n+\n+    // ok, map used before insertion\n+    if !m.contains_key(&k) {\n+        let _ = m.len();\n+        m.insert(k, v);\n+    }\n+\n+    // ok, inline asm\n+    if !m.contains_key(&k) {\n+        unsafe { asm!(\"nop\") }\n+        m.insert(k, v);\n+    }\n+\n+    // ok, different keys.\n+    if !m.contains_key(&k) {\n+        m.insert(k2, v);\n+    }\n+\n+    // ok, different maps\n+    if !m.contains_key(&k) {\n+        m2.insert(k, v);\n+    }\n+\n+    // ok, insert in macro\n+    if !m.contains_key(&k) {\n+        insert!(m, k, v);\n+    }\n }\n \n fn btree_map<K: Eq + Ord + Copy, V: Copy>(m: &mut BTreeMap<K, V>, k: K, v: V, v2: V) {\n+    // insert then do something, use if let\n     if !m.contains_key(&k) {\n         m.insert(k, v);\n         foo();"}, {"sha": "2f075a97010a63d77365ce0ac6f03eeef8e3ab50", "filename": "tests/ui/entry.stderr", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bcf348800751e8a03fdbaa49130e53a463e3a441/tests%2Fui%2Fentry.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bcf348800751e8a03fdbaa49130e53a463e3a441/tests%2Fui%2Fentry.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry.stderr?ref=bcf348800751e8a03fdbaa49130e53a463e3a441", "patch": "@@ -1,5 +1,5 @@\n error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry.rs:16:5\n+  --> $DIR/entry.rs:24:5\n    |\n LL | /     if !m.contains_key(&k) {\n LL | |         m.insert(k, v);\n@@ -9,7 +9,7 @@ LL | |     }\n    = note: `-D clippy::map-entry` implied by `-D warnings`\n \n error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry.rs:20:5\n+  --> $DIR/entry.rs:29:5\n    |\n LL | /     if !m.contains_key(&k) {\n LL | |         if true {\n@@ -31,7 +31,7 @@ LL |         }\n  ...\n \n error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry.rs:28:5\n+  --> $DIR/entry.rs:38:5\n    |\n LL | /     if !m.contains_key(&k) {\n LL | |         if true {\n@@ -53,7 +53,7 @@ LL |         }\n  ...\n \n error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry.rs:36:5\n+  --> $DIR/entry.rs:47:5\n    |\n LL | /     if !m.contains_key(&k) {\n LL | |         if true {\n@@ -75,7 +75,7 @@ LL |             return;\n  ...\n \n error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry.rs:45:5\n+  --> $DIR/entry.rs:57:5\n    |\n LL | /     if !m.contains_key(&k) {\n LL | |         foo();\n@@ -92,7 +92,7 @@ LL |     });\n    |\n \n error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry.rs:50:5\n+  --> $DIR/entry.rs:63:5\n    |\n LL | /     if !m.contains_key(&k) {\n LL | |         match 0 {\n@@ -114,12 +114,12 @@ LL |             _ => {\n  ...\n \n error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry.rs:61:5\n+  --> $DIR/entry.rs:75:5\n    |\n LL | /     if !m.contains_key(&k) {\n LL | |         match 0 {\n-LL | |             0 => {},\n-LL | |             1 => {\n+LL | |             0 => foo(),\n+LL | |             _ => {\n ...  |\n LL | |         };\n LL | |     }\n@@ -129,14 +129,14 @@ help: try this\n    |\n LL |     if let std::collections::hash_map::Entry::Vacant(e) = m.entry(k) {\n LL |         match 0 {\n-LL |             0 => {},\n-LL |             1 => {\n-LL |                 e.insert(v);\n+LL |             0 => foo(),\n+LL |             _ => {\n+LL |                 e.insert(v2);\n LL |             },\n  ...\n \n error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry.rs:73:5\n+  --> $DIR/entry.rs:85:5\n    |\n LL | /     if !m.contains_key(&k) {\n LL | |         foo();\n@@ -158,15 +158,15 @@ LL |             },\n  ...\n \n error: usage of `contains_key` followed by `insert` on a `HashMap`\n-  --> $DIR/entry.rs:99:5\n+  --> $DIR/entry.rs:119:5\n    |\n LL | /     if !m.contains_key(&m!(k)) {\n LL | |         m.insert(m!(k), m!(v));\n LL | |     }\n    | |_____^ help: try this: `m.entry(m!(k)).or_insert_with(|| m!(v));`\n \n error: usage of `contains_key` followed by `insert` on a `BTreeMap`\n-  --> $DIR/entry.rs:105:5\n+  --> $DIR/entry.rs:153:5\n    |\n LL | /     if !m.contains_key(&k) {\n LL | |         m.insert(k, v);"}, {"sha": "beb2d5c97b1d98f32babdcb475ce7b8cc528bb7e", "filename": "tests/ui/entry_unfixable.rs", "status": "removed", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/3323ff71455c763a03353527d6203f90b53058fd/tests%2Fui%2Fentry_unfixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3323ff71455c763a03353527d6203f90b53058fd/tests%2Fui%2Fentry_unfixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fentry_unfixable.rs?ref=3323ff71455c763a03353527d6203f90b53058fd", "patch": "@@ -1,50 +0,0 @@\n-#![allow(unused, clippy::needless_pass_by_value)]\n-#![warn(clippy::map_entry)]\n-\n-use std::collections::{BTreeMap, HashMap};\n-use std::hash::Hash;\n-\n-macro_rules! m {\n-    ($map:expr, $key:expr, $value:expr) => {\n-        $map.insert($key, $value)\n-    };\n-    ($e:expr) => {{ $e }};\n-}\n-\n-fn foo() {}\n-\n-// should not trigger\n-fn insert_other_if_absent<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, o: K, v: V) {\n-    if !m.contains_key(&k) {\n-        m.insert(o, v);\n-    }\n-}\n-\n-// should not trigger, because the one uses different HashMap from another one\n-fn insert_from_different_map<K: Eq + Hash, V>(m: HashMap<K, V>, n: &mut HashMap<K, V>, k: K, v: V) {\n-    if !m.contains_key(&k) {\n-        n.insert(k, v);\n-    }\n-}\n-\n-// should not trigger, because the one uses different HashMap from another one\n-fn insert_from_different_map2<K: Eq + Hash, V>(m: &mut HashMap<K, V>, n: &mut HashMap<K, V>, k: K, v: V) {\n-    if !m.contains_key(&k) {\n-        n.insert(k, v);\n-    }\n-}\n-\n-fn insert_in_macro<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n-    if !m.contains_key(&k) {\n-        m!(m, k, v);\n-    }\n-}\n-\n-fn use_map_then_insert<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n-    if !m.contains_key(&k) {\n-        let _ = m.len();\n-        m.insert(k, v);\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "df2256e4f97de98afe0285e587ac9924c000fb3a", "filename": "tests/ui/string_lit_as_bytes.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcf348800751e8a03fdbaa49130e53a463e3a441/tests%2Fui%2Fstring_lit_as_bytes.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/bcf348800751e8a03fdbaa49130e53a463e3a441/tests%2Fui%2Fstring_lit_as_bytes.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstring_lit_as_bytes.fixed?ref=bcf348800751e8a03fdbaa49130e53a463e3a441", "patch": "@@ -22,7 +22,7 @@ fn str_lit_as_bytes() {\n \n     let current_version = env!(\"CARGO_PKG_VERSION\").as_bytes();\n \n-    let includestr = include_bytes!(\"entry_unfixable.rs\");\n+    let includestr = include_bytes!(\"string_lit_as_bytes.rs\");\n \n     let _ = b\"string with newline\\t\\n\";\n }"}, {"sha": "c6bf8f732ed9f615d1ea2d660d6ed7602513270b", "filename": "tests/ui/string_lit_as_bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bcf348800751e8a03fdbaa49130e53a463e3a441/tests%2Fui%2Fstring_lit_as_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf348800751e8a03fdbaa49130e53a463e3a441/tests%2Fui%2Fstring_lit_as_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstring_lit_as_bytes.rs?ref=bcf348800751e8a03fdbaa49130e53a463e3a441", "patch": "@@ -22,7 +22,7 @@ fn str_lit_as_bytes() {\n \n     let current_version = env!(\"CARGO_PKG_VERSION\").as_bytes();\n \n-    let includestr = include_str!(\"entry_unfixable.rs\").as_bytes();\n+    let includestr = include_str!(\"string_lit_as_bytes.rs\").as_bytes();\n \n     let _ = \"string with newline\\t\\n\".as_bytes();\n }"}, {"sha": "f47d6161c6cf2c8869b90783eebd684581ee9a91", "filename": "tests/ui/string_lit_as_bytes.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bcf348800751e8a03fdbaa49130e53a463e3a441/tests%2Fui%2Fstring_lit_as_bytes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bcf348800751e8a03fdbaa49130e53a463e3a441/tests%2Fui%2Fstring_lit_as_bytes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstring_lit_as_bytes.stderr?ref=bcf348800751e8a03fdbaa49130e53a463e3a441", "patch": "@@ -27,8 +27,8 @@ LL |     let bs = \"lit to owned\".to_owned().into_bytes();\n error: calling `as_bytes()` on `include_str!(..)`\n   --> $DIR/string_lit_as_bytes.rs:25:22\n    |\n-LL |     let includestr = include_str!(\"entry_unfixable.rs\").as_bytes();\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `include_bytes!(..)` instead: `include_bytes!(\"entry_unfixable.rs\")`\n+LL |     let includestr = include_str!(\"string_lit_as_bytes.rs\").as_bytes();\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using `include_bytes!(..)` instead: `include_bytes!(\"string_lit_as_bytes.rs\")`\n \n error: calling `as_bytes()` on a string literal\n   --> $DIR/string_lit_as_bytes.rs:27:13"}]}