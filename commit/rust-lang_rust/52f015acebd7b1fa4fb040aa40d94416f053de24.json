{"sha": "52f015acebd7b1fa4fb040aa40d94416f053de24", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUyZjAxNWFjZWJkN2IxZmE0ZmIwNDBhYTQwZDk0NDE2ZjA1M2RlMjQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-07T22:57:15Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-05-14T21:52:07Z"}, "message": "core: Cleanup warnings", "tree": {"sha": "731709f26e919d67505977a88330bdce2b546735", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/731709f26e919d67505977a88330bdce2b546735"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/52f015acebd7b1fa4fb040aa40d94416f053de24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/52f015acebd7b1fa4fb040aa40d94416f053de24", "html_url": "https://github.com/rust-lang/rust/commit/52f015acebd7b1fa4fb040aa40d94416f053de24", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/52f015acebd7b1fa4fb040aa40d94416f053de24/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4472a50ceb5b6f0337371226d3ef7cc3c30ee04c", "url": "https://api.github.com/repos/rust-lang/rust/commits/4472a50ceb5b6f0337371226d3ef7cc3c30ee04c", "html_url": "https://github.com/rust-lang/rust/commit/4472a50ceb5b6f0337371226d3ef7cc3c30ee04c"}], "stats": {"total": 226, "additions": 117, "deletions": 109}, "files": [{"sha": "fda48b6ffb7d9140c845846ab0b90fefb5d26651", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/52f015acebd7b1fa4fb040aa40d94416f053de24/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f015acebd7b1fa4fb040aa40d94416f053de24/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=52f015acebd7b1fa4fb040aa40d94416f053de24", "patch": "@@ -42,6 +42,12 @@ macro_rules! abort(\n     ($( $msg:expr),+) => ( {\n         rtdebug!($($msg),+);\n \n-        unsafe { ::libc::abort(); }\n+        do_abort();\n+\n+        // NB: This is in a fn to avoid putting the `unsafe` block in a macro,\n+        // which causes spurious 'unnecessary unsafe block' warnings.\n+        fn do_abort() -> ! {\n+            unsafe { ::libc::abort(); }\n+        }\n     } )\n )"}, {"sha": "eb35eb7881d39f696c2e27bdd2238c2c4832f8bc", "filename": "src/libcore/rt/local_sched.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/52f015acebd7b1fa4fb040aa40d94416f053de24/src%2Flibcore%2Frt%2Flocal_sched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f015acebd7b1fa4fb040aa40d94416f053de24/src%2Flibcore%2Frt%2Flocal_sched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flocal_sched.rs?ref=52f015acebd7b1fa4fb040aa40d94416f053de24", "patch": "@@ -91,11 +91,9 @@ pub unsafe fn unsafe_borrow() -> *mut Scheduler {\n }\n \n pub unsafe fn unsafe_borrow_io() -> *mut IoFactoryObject {\n-    unsafe {\n-        let sched = unsafe_borrow();\n-        let io: *mut IoFactoryObject = (*sched).event_loop.io().unwrap();\n-        return io;\n-    }\n+    let sched = unsafe_borrow();\n+    let io: *mut IoFactoryObject = (*sched).event_loop.io().unwrap();\n+    return io;\n }\n \n fn tls_key() -> tls::Key {"}, {"sha": "673b2a6c2bc41d6f219111ec0a9e7e5a7fc8e2a5", "filename": "src/libcore/rt/local_services.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/52f015acebd7b1fa4fb040aa40d94416f053de24/src%2Flibcore%2Frt%2Flocal_services.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f015acebd7b1fa4fb040aa40d94416f053de24/src%2Flibcore%2Frt%2Flocal_services.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Flocal_services.rs?ref=52f015acebd7b1fa4fb040aa40d94416f053de24", "patch": "@@ -23,7 +23,7 @@ use libc::{c_void, uintptr_t};\n use cast::transmute;\n use super::sched::local_sched;\n use super::local_heap::LocalHeap;\n-use rt::logging::{Logger, StdErrLogger};\n+use rt::logging::StdErrLogger;\n \n pub struct LocalServices {\n     heap: LocalHeap,\n@@ -170,16 +170,14 @@ pub fn borrow_local_services(f: &fn(&mut LocalServices)) {\n }\n \n pub unsafe fn unsafe_borrow_local_services() -> *mut LocalServices {\n-    unsafe {\n-        match (*local_sched::unsafe_borrow()).current_task {\n-            Some(~ref mut task) => {\n-                let s: *mut LocalServices = &mut task.local_services;\n-                return s;\n-            }\n-            None => {\n-                // Don't fail. Infinite recursion\n-                abort!(\"no local services for schedulers yet\")\n-            }\n+    match (*local_sched::unsafe_borrow()).current_task {\n+        Some(~ref mut task) => {\n+            let s: *mut LocalServices = &mut task.local_services;\n+            return s;\n+        }\n+        None => {\n+            // Don't fail. Infinite recursion\n+            abort!(\"no local services for schedulers yet\")\n         }\n     }\n }"}, {"sha": "1c0c8c14fdfa6404fa2be80abf552c6a55b26ef8", "filename": "src/libcore/rt/rc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/52f015acebd7b1fa4fb040aa40d94416f053de24/src%2Flibcore%2Frt%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f015acebd7b1fa4fb040aa40d94416f053de24/src%2Flibcore%2Frt%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Frc.rs?ref=52f015acebd7b1fa4fb040aa40d94416f053de24", "patch": "@@ -21,7 +21,6 @@\n use ops::Drop;\n use clone::Clone;\n use libc::c_void;\n-use sys;\n use cast;\n \n pub struct RC<T> {"}, {"sha": "518429eeaff052efa297f29d1b48e63134693b7f", "filename": "src/libcore/rt/uv/idle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/52f015acebd7b1fa4fb040aa40d94416f053de24/src%2Flibcore%2Frt%2Fuv%2Fidle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f015acebd7b1fa4fb040aa40d94416f053de24/src%2Flibcore%2Frt%2Fuv%2Fidle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fidle.rs?ref=52f015acebd7b1fa4fb040aa40d94416f053de24", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use libc::c_int;\n-use option::{Some, None};\n+use option::Some;\n use rt::uv::uvll;\n use rt::uv::{Watcher, Loop, NativeHandle, IdleCallback};\n use rt::uv::status_to_maybe_uv_error;"}, {"sha": "fede71ec67931df0238c19b494ef98e5166f5210", "filename": "src/libcore/rt/uv/net.rs", "status": "modified", "additions": 97, "deletions": 90, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/52f015acebd7b1fa4fb040aa40d94416f053de24/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/52f015acebd7b1fa4fb040aa40d94416f053de24/src%2Flibcore%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fuv%2Fnet.rs?ref=52f015acebd7b1fa4fb040aa40d94416f053de24", "patch": "@@ -13,17 +13,11 @@ use libc::{size_t, ssize_t, c_int, c_void};\n use rt::uv::uvll;\n use rt::uv::uvll::*;\n use rt::uv::{AllocCallback, ConnectionCallback, ReadCallback};\n-use super::{Loop, Watcher, Request, UvError, Buf, NativeHandle, NullCallback,\n-            status_to_maybe_uv_error, vec_to_uv_buf, vec_from_uv_buf, slice_to_uv_buf};\n-use super::super::io::net::ip::{IpAddr, Ipv4, Ipv6};\n+use rt::uv::{Loop, Watcher, Request, UvError, Buf, NativeHandle, NullCallback,\n+             status_to_maybe_uv_error};\n+use rt::io::net::ip::{IpAddr, Ipv4, Ipv6};\n use rt::uv::last_uv_error;\n \n-#[cfg(test)] use util::ignore;\n-#[cfg(test)] use cell::Cell;\n-#[cfg(test)] use unstable::run_in_bare_thread;\n-#[cfg(test)] use super::super::thread::Thread;\n-#[cfg(test)] use super::super::test::*;\n-\n fn ip4_as_uv_ip4<T>(addr: IpAddr, f: &fn(*sockaddr_in) -> T) -> T {\n     match addr {\n         Ipv4(a, b, c, d, p) => {\n@@ -334,96 +328,109 @@ impl NativeHandle<*uvll::uv_write_t> for WriteRequest {\n }\n \n \n-#[test]\n-fn connect_close() {\n-    do run_in_bare_thread() {\n-        let mut loop_ = Loop::new();\n-        let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-        // Connect to a port where nobody is listening\n-        let addr = next_test_ip4();\n-        do tcp_watcher.connect(addr) |stream_watcher, status| {\n-            rtdebug!(\"tcp_watcher.connect!\");\n-            assert!(status.is_some());\n-            assert!(status.get().name() == ~\"ECONNREFUSED\");\n-            stream_watcher.close(||());\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use util::ignore;\n+    use cell::Cell;\n+    use vec;\n+    use unstable::run_in_bare_thread;\n+    use rt::thread::Thread;\n+    use rt::test::*;\n+    use rt::uv::{Loop, AllocCallback};\n+    use rt::uv::{vec_from_uv_buf, vec_to_uv_buf, slice_to_uv_buf};\n+\n+    #[test]\n+    fn connect_close() {\n+        do run_in_bare_thread() {\n+            let mut loop_ = Loop::new();\n+            let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+            // Connect to a port where nobody is listening\n+            let addr = next_test_ip4();\n+            do tcp_watcher.connect(addr) |stream_watcher, status| {\n+                rtdebug!(\"tcp_watcher.connect!\");\n+                assert!(status.is_some());\n+                assert!(status.get().name() == ~\"ECONNREFUSED\");\n+                stream_watcher.close(||());\n+            }\n+            loop_.run();\n+            loop_.close();\n         }\n-        loop_.run();\n-        loop_.close();\n     }\n-}\n \n-#[test]\n-fn listen() {\n-    do run_in_bare_thread() {\n-        static MAX: int = 10;\n-        let mut loop_ = Loop::new();\n-        let mut server_tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-        let addr = next_test_ip4();\n-        server_tcp_watcher.bind(addr);\n-        let loop_ = loop_;\n-        rtdebug!(\"listening\");\n-        do server_tcp_watcher.listen |server_stream_watcher, status| {\n-            rtdebug!(\"listened!\");\n-            assert!(status.is_none());\n-            let mut server_stream_watcher = server_stream_watcher;\n-            let mut loop_ = loop_;\n-            let mut client_tcp_watcher = TcpWatcher::new(&mut loop_);\n-            let mut client_tcp_watcher = client_tcp_watcher.as_stream();\n-            server_stream_watcher.accept(client_tcp_watcher);\n-            let count_cell = Cell(0);\n-            let server_stream_watcher = server_stream_watcher;\n-            rtdebug!(\"starting read\");\n-            let alloc: AllocCallback = |size| {\n-                vec_to_uv_buf(vec::from_elem(size, 0))\n-            };\n-            do client_tcp_watcher.read_start(alloc)\n-                |stream_watcher, nread, buf, status| {\n-\n-                rtdebug!(\"i'm reading!\");\n-                let buf = vec_from_uv_buf(buf);\n-                let mut count = count_cell.take();\n-                if status.is_none() {\n-                    rtdebug!(\"got %d bytes\", nread);\n-                    let buf = buf.unwrap();\n-                    for buf.slice(0, nread as uint).each |byte| {\n-                        assert!(*byte == count as u8);\n-                        rtdebug!(\"%u\", *byte as uint);\n-                        count += 1;\n-                    }\n-                } else {\n-                    assert!(count == MAX);\n-                    do stream_watcher.close {\n-                        server_stream_watcher.close(||());\n+    #[test]\n+    fn listen() {\n+        do run_in_bare_thread() {\n+            static MAX: int = 10;\n+            let mut loop_ = Loop::new();\n+            let mut server_tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+            let addr = next_test_ip4();\n+            server_tcp_watcher.bind(addr);\n+            let loop_ = loop_;\n+            rtdebug!(\"listening\");\n+            do server_tcp_watcher.listen |server_stream_watcher, status| {\n+                rtdebug!(\"listened!\");\n+                assert!(status.is_none());\n+                let mut server_stream_watcher = server_stream_watcher;\n+                let mut loop_ = loop_;\n+                let mut client_tcp_watcher = TcpWatcher::new(&mut loop_);\n+                let mut client_tcp_watcher = client_tcp_watcher.as_stream();\n+                server_stream_watcher.accept(client_tcp_watcher);\n+                let count_cell = Cell(0);\n+                let server_stream_watcher = server_stream_watcher;\n+                rtdebug!(\"starting read\");\n+                let alloc: AllocCallback = |size| {\n+                    vec_to_uv_buf(vec::from_elem(size, 0))\n+                };\n+                do client_tcp_watcher.read_start(alloc)\n+                    |stream_watcher, nread, buf, status| {\n+\n+                    rtdebug!(\"i'm reading!\");\n+                    let buf = vec_from_uv_buf(buf);\n+                    let mut count = count_cell.take();\n+                    if status.is_none() {\n+                        rtdebug!(\"got %d bytes\", nread);\n+                        let buf = buf.unwrap();\n+                        for buf.slice(0, nread as uint).each |byte| {\n+                            assert!(*byte == count as u8);\n+                            rtdebug!(\"%u\", *byte as uint);\n+                            count += 1;\n+                        }\n+                    } else {\n+                        assert!(count == MAX);\n+                        do stream_watcher.close {\n+                            server_stream_watcher.close(||());\n+                        }\n                     }\n+                    count_cell.put_back(count);\n                 }\n-                count_cell.put_back(count);\n             }\n-        }\n \n-        let _client_thread = do Thread::start {\n-            rtdebug!(\"starting client thread\");\n-            let mut loop_ = Loop::new();\n-            let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n-            do tcp_watcher.connect(addr) |stream_watcher, status| {\n-                rtdebug!(\"connecting\");\n-                assert!(status.is_none());\n-                let mut stream_watcher = stream_watcher;\n-                let msg = ~[0, 1, 2, 3, 4, 5, 6 ,7 ,8, 9];\n-                let buf = slice_to_uv_buf(msg);\n-                let msg_cell = Cell(msg);\n-                do stream_watcher.write(buf) |stream_watcher, status| {\n-                    rtdebug!(\"writing\");\n+            let _client_thread = do Thread::start {\n+                rtdebug!(\"starting client thread\");\n+                let mut loop_ = Loop::new();\n+                let mut tcp_watcher = { TcpWatcher::new(&mut loop_) };\n+                do tcp_watcher.connect(addr) |stream_watcher, status| {\n+                    rtdebug!(\"connecting\");\n                     assert!(status.is_none());\n-                    let msg_cell = Cell(msg_cell.take());\n-                    stream_watcher.close(||ignore(msg_cell.take()));\n+                    let mut stream_watcher = stream_watcher;\n+                    let msg = ~[0, 1, 2, 3, 4, 5, 6 ,7 ,8, 9];\n+                    let buf = slice_to_uv_buf(msg);\n+                    let msg_cell = Cell(msg);\n+                    do stream_watcher.write(buf) |stream_watcher, status| {\n+                        rtdebug!(\"writing\");\n+                        assert!(status.is_none());\n+                        let msg_cell = Cell(msg_cell.take());\n+                        stream_watcher.close(||ignore(msg_cell.take()));\n+                    }\n                 }\n-            }\n+                loop_.run();\n+                loop_.close();\n+            };\n+\n+            let mut loop_ = loop_;\n             loop_.run();\n             loop_.close();\n-        };\n-\n-        let mut loop_ = loop_;\n-        loop_.run();\n-        loop_.close();\n+        }\n     }\n-}\n+}\n\\ No newline at end of file"}]}