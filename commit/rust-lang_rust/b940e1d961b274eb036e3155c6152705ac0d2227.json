{"sha": "b940e1d961b274eb036e3155c6152705ac0d2227", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5NDBlMWQ5NjFiMjc0ZWIwMzZlMzE1NWM2MTUyNzA1YWMwZDIyMjc=", "commit": {"author": {"name": "Pietro Albini", "email": "pietro@pietroalbini.org", "date": "2018-09-25T20:34:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-09-25T20:34:38Z"}, "message": "Rollup merge of #54058 - Kerollmops:slice-dedup, r=shepmaster\n\nIntroduce the partition_dedup/by/by_key methods for slices\n\nThis PR propose to add three methods to the slice type, the `partition_dedup`, `partition_dedup_by` and `partition_dedup_by_key`. The two other methods are based on `slice::partition_dedup_by`.\n\nThese methods take a mutable slice, deduplicates it and moves all duplicates to the end of it, returning two mutable slices, the first containing the deduplicated elements and the second all the duplicates unordered.\n\n```rust\nlet mut slice = [1, 2, 2, 3, 3, 2];\n\nlet (dedup, duplicates) = slice.partition_dedup();\n\nassert_eq!(dedup, [1, 2, 3, 2]);\nassert_eq!(duplicates, [3, 2]);\n```\n\nThe benefits of adding these methods is that it is now possible to:\n  - deduplicate a slice without having to allocate and possibly clone elements on the heap, really useful for embedded stuff that can't allocate for example.\n  - not loose duplicate elements, because, when using `Vec::dedup`, duplicates elements are dropped. These methods add more flexibillity to the user.\n\nNote that this is near a copy/paste of the `Vec::dedup_by` function, once this method is stable the goal is to replace the algorithm in `Vec` by the following.\n\n```rust\npub fn Vec::dedup_by<F>(&mut self, same_bucket: F)\n    where F: FnMut(&mut T, &mut T) -> bool\n{\n    let (dedup, _) = self.as_mut_slice().partition_dedup_by(same_bucket);\n    let len = dedup.len();\n    self.truncate(len);\n}\n```", "tree": {"sha": "ed095f9d1178b1903dce354094cfd3174edaa553", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ed095f9d1178b1903dce354094cfd3174edaa553"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b940e1d961b274eb036e3155c6152705ac0d2227", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbqpveCRBK7hj4Ov3rIwAAdHIIABmWTAyh7Rr8+FmSOpDhzczU\nkHoQBDLKHvxK7+shW7meEs1R1JUIzqw915I7//JGuptKwyz5DjTkuKFAQHx6F65w\nBtf12Wpg25qhkJdNuQ3FzSHB+JispmJB0Cobhh3QFxqDsDqzfo2UgcvxzS47r2vD\nwDG/6W5F8ur8FQqCNZIkouqA8+fwFdXPDe4CM1prdn4nPzFcmN4b94v7/L9a0lFa\nygd0+cPe7xc4G1W9EA7gYPOSzO0wdztGF5OHtMLk3UHNGbrJXTQT3BfkG9pIdq0c\nr1gOQ2S55D9opxjgsx25T/Dzzgn4lW98GeZkGw9lPYKAj/GSA30C48oFH0LEN/g=\n=DsjO\n-----END PGP SIGNATURE-----\n", "payload": "tree ed095f9d1178b1903dce354094cfd3174edaa553\nparent 707c9795ac00bdc487f79f048618b4119f70ba0d\nparent d560292a87a89587e0345e13b9714c90495ea50f\nauthor Pietro Albini <pietro@pietroalbini.org> 1537907678 +0200\ncommitter GitHub <noreply@github.com> 1537907678 +0200\n\nRollup merge of #54058 - Kerollmops:slice-dedup, r=shepmaster\n\nIntroduce the partition_dedup/by/by_key methods for slices\n\nThis PR propose to add three methods to the slice type, the `partition_dedup`, `partition_dedup_by` and `partition_dedup_by_key`. The two other methods are based on `slice::partition_dedup_by`.\n\nThese methods take a mutable slice, deduplicates it and moves all duplicates to the end of it, returning two mutable slices, the first containing the deduplicated elements and the second all the duplicates unordered.\n\n```rust\nlet mut slice = [1, 2, 2, 3, 3, 2];\n\nlet (dedup, duplicates) = slice.partition_dedup();\n\nassert_eq!(dedup, [1, 2, 3, 2]);\nassert_eq!(duplicates, [3, 2]);\n```\n\nThe benefits of adding these methods is that it is now possible to:\n  - deduplicate a slice without having to allocate and possibly clone elements on the heap, really useful for embedded stuff that can't allocate for example.\n  - not loose duplicate elements, because, when using `Vec::dedup`, duplicates elements are dropped. These methods add more flexibillity to the user.\n\nNote that this is near a copy/paste of the `Vec::dedup_by` function, once this method is stable the goal is to replace the algorithm in `Vec` by the following.\n\n```rust\npub fn Vec::dedup_by<F>(&mut self, same_bucket: F)\n    where F: FnMut(&mut T, &mut T) -> bool\n{\n    let (dedup, _) = self.as_mut_slice().partition_dedup_by(same_bucket);\n    let len = dedup.len();\n    self.truncate(len);\n}\n```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b940e1d961b274eb036e3155c6152705ac0d2227", "html_url": "https://github.com/rust-lang/rust/commit/b940e1d961b274eb036e3155c6152705ac0d2227", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b940e1d961b274eb036e3155c6152705ac0d2227/comments", "author": {"login": "pietroalbini", "id": 2299951, "node_id": "MDQ6VXNlcjIyOTk5NTE=", "avatar_url": "https://avatars.githubusercontent.com/u/2299951?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pietroalbini", "html_url": "https://github.com/pietroalbini", "followers_url": "https://api.github.com/users/pietroalbini/followers", "following_url": "https://api.github.com/users/pietroalbini/following{/other_user}", "gists_url": "https://api.github.com/users/pietroalbini/gists{/gist_id}", "starred_url": "https://api.github.com/users/pietroalbini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pietroalbini/subscriptions", "organizations_url": "https://api.github.com/users/pietroalbini/orgs", "repos_url": "https://api.github.com/users/pietroalbini/repos", "events_url": "https://api.github.com/users/pietroalbini/events{/privacy}", "received_events_url": "https://api.github.com/users/pietroalbini/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "707c9795ac00bdc487f79f048618b4119f70ba0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/707c9795ac00bdc487f79f048618b4119f70ba0d", "html_url": "https://github.com/rust-lang/rust/commit/707c9795ac00bdc487f79f048618b4119f70ba0d"}, {"sha": "d560292a87a89587e0345e13b9714c90495ea50f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d560292a87a89587e0345e13b9714c90495ea50f", "html_url": "https://github.com/rust-lang/rust/commit/d560292a87a89587e0345e13b9714c90495ea50f"}], "stats": {"total": 333, "additions": 244, "deletions": 89}, "files": [{"sha": "6ce24b65990622b848b63912a4d94bd28f636c9a", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b940e1d961b274eb036e3155c6152705ac0d2227/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b940e1d961b274eb036e3155c6152705ac0d2227/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=b940e1d961b274eb036e3155c6152705ac0d2227", "patch": "@@ -119,6 +119,7 @@\n #![feature(exact_chunks)]\n #![feature(rustc_const_unstable)]\n #![feature(const_vec_new)]\n+#![feature(slice_partition_dedup)]\n #![feature(maybe_uninit)]\n \n // Allow testing this library"}, {"sha": "e845438c0a836972d56a39c72cd7f897e6a1e626", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 11, "deletions": 89, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/b940e1d961b274eb036e3155c6152705ac0d2227/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b940e1d961b274eb036e3155c6152705ac0d2227/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=b940e1d961b274eb036e3155c6152705ac0d2227", "patch": "@@ -947,10 +947,9 @@ impl<T> Vec<T> {\n     /// Removes all but the first of consecutive elements in the vector satisfying a given equality\n     /// relation.\n     ///\n-    /// The `same_bucket` function is passed references to two elements from the vector, and\n-    /// returns `true` if the elements compare equal, or `false` if they do not. The elements are\n-    /// passed in opposite order from their order in the vector, so if `same_bucket(a, b)` returns\n-    /// `true`, `a` is removed.\n+    /// The `same_bucket` function is passed references to two elements from the vector and\n+    /// must determine if the elements compare equal. The elements are passed in opposite order\n+    /// from their order in the slice, so if `same_bucket(a, b)` returns `true`, `a` is removed.\n     ///\n     /// If the vector is sorted, this removes all duplicates.\n     ///\n@@ -964,90 +963,12 @@ impl<T> Vec<T> {\n     /// assert_eq!(vec, [\"foo\", \"bar\", \"baz\", \"bar\"]);\n     /// ```\n     #[stable(feature = \"dedup_by\", since = \"1.16.0\")]\n-    pub fn dedup_by<F>(&mut self, mut same_bucket: F) where F: FnMut(&mut T, &mut T) -> bool {\n-        unsafe {\n-            // Although we have a mutable reference to `self`, we cannot make\n-            // *arbitrary* changes. The `same_bucket` calls could panic, so we\n-            // must ensure that the vector is in a valid state at all time.\n-            //\n-            // The way that we handle this is by using swaps; we iterate\n-            // over all the elements, swapping as we go so that at the end\n-            // the elements we wish to keep are in the front, and those we\n-            // wish to reject are at the back. We can then truncate the\n-            // vector. This operation is still O(n).\n-            //\n-            // Example: We start in this state, where `r` represents \"next\n-            // read\" and `w` represents \"next_write`.\n-            //\n-            //           r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //           w\n-            //\n-            // Comparing self[r] against self[w-1], this is not a duplicate, so\n-            // we swap self[r] and self[w] (no effect as r==w) and then increment both\n-            // r and w, leaving us with:\n-            //\n-            //               r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //               w\n-            //\n-            // Comparing self[r] against self[w-1], this value is a duplicate,\n-            // so we increment `r` but leave everything else unchanged:\n-            //\n-            //                   r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 1 | 2 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //               w\n-            //\n-            // Comparing self[r] against self[w-1], this is not a duplicate,\n-            // so swap self[r] and self[w] and advance r and w:\n-            //\n-            //                       r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 2 | 1 | 3 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //                   w\n-            //\n-            // Not a duplicate, repeat:\n-            //\n-            //                           r\n-            //     +---+---+---+---+---+---+\n-            //     | 0 | 1 | 2 | 3 | 1 | 3 |\n-            //     +---+---+---+---+---+---+\n-            //                       w\n-            //\n-            // Duplicate, advance r. End of vec. Truncate to w.\n-\n-            let ln = self.len();\n-            if ln <= 1 {\n-                return;\n-            }\n-\n-            // Avoid bounds checks by using raw pointers.\n-            let p = self.as_mut_ptr();\n-            let mut r: usize = 1;\n-            let mut w: usize = 1;\n-\n-            while r < ln {\n-                let p_r = p.add(r);\n-                let p_wm1 = p.add(w - 1);\n-                if !same_bucket(&mut *p_r, &mut *p_wm1) {\n-                    if r != w {\n-                        let p_w = p_wm1.offset(1);\n-                        mem::swap(&mut *p_r, &mut *p_w);\n-                    }\n-                    w += 1;\n-                }\n-                r += 1;\n-            }\n-\n-            self.truncate(w);\n-        }\n+    pub fn dedup_by<F>(&mut self, same_bucket: F) where F: FnMut(&mut T, &mut T) -> bool {\n+        let len = {\n+            let (dedup, _) = self.as_mut_slice().partition_dedup_by(same_bucket);\n+            dedup.len()\n+        };\n+        self.truncate(len);\n     }\n \n     /// Appends an element to the back of a collection.\n@@ -1533,7 +1454,8 @@ impl<'a> Drop for SetLenOnDrop<'a> {\n }\n \n impl<T: PartialEq> Vec<T> {\n-    /// Removes consecutive repeated elements in the vector.\n+    /// Removes consecutive repeated elements in the vector according to the\n+    /// [`PartialEq`] trait implementation.\n     ///\n     /// If the vector is sorted, this removes all duplicates.\n     ///"}, {"sha": "97aada385553eb6c962300889bb98c2f518a6896", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/b940e1d961b274eb036e3155c6152705ac0d2227/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b940e1d961b274eb036e3155c6152705ac0d2227/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=b940e1d961b274eb036e3155c6152705ac0d2227", "patch": "@@ -1402,6 +1402,178 @@ impl<T> [T] {\n         sort::quicksort(self, |a, b| f(a).lt(&f(b)));\n     }\n \n+    /// Moves all consecutive repeated elements to the end of the slice according to the\n+    /// [`PartialEq`] trait implementation.\n+    ///\n+    /// Returns two slices. The first contains no consecutive repeated elements.\n+    /// The second contains all the duplicates in no specified order.\n+    ///\n+    /// If the slice is sorted, the first returned slice contains no duplicates.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_partition_dedup)]\n+    ///\n+    /// let mut slice = [1, 2, 2, 3, 3, 2, 1, 1];\n+    ///\n+    /// let (dedup, duplicates) = slice.partition_dedup();\n+    ///\n+    /// assert_eq!(dedup, [1, 2, 3, 2, 1]);\n+    /// assert_eq!(duplicates, [2, 3, 1]);\n+    /// ```\n+    #[unstable(feature = \"slice_partition_dedup\", issue = \"54279\")]\n+    #[inline]\n+    pub fn partition_dedup(&mut self) -> (&mut [T], &mut [T])\n+        where T: PartialEq\n+    {\n+        self.partition_dedup_by(|a, b| a == b)\n+    }\n+\n+    /// Moves all but the first of consecutive elements to the end of the slice satisfying\n+    /// a given equality relation.\n+    ///\n+    /// Returns two slices. The first contains no consecutive repeated elements.\n+    /// The second contains all the duplicates in no specified order.\n+    ///\n+    /// The `same_bucket` function is passed references to two elements from the slice and\n+    /// must determine if the elements compare equal. The elements are passed in opposite order\n+    /// from their order in the slice, so if `same_bucket(a, b)` returns `true`, `a` is moved\n+    /// at the end of the slice.\n+    ///\n+    /// If the slice is sorted, the first returned slice contains no duplicates.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_partition_dedup)]\n+    ///\n+    /// let mut slice = [\"foo\", \"Foo\", \"BAZ\", \"Bar\", \"bar\", \"baz\", \"BAZ\"];\n+    ///\n+    /// let (dedup, duplicates) = slice.partition_dedup_by(|a, b| a.eq_ignore_ascii_case(b));\n+    ///\n+    /// assert_eq!(dedup, [\"foo\", \"BAZ\", \"Bar\", \"baz\"]);\n+    /// assert_eq!(duplicates, [\"bar\", \"Foo\", \"BAZ\"]);\n+    /// ```\n+    #[unstable(feature = \"slice_partition_dedup\", issue = \"54279\")]\n+    #[inline]\n+    pub fn partition_dedup_by<F>(&mut self, mut same_bucket: F) -> (&mut [T], &mut [T])\n+        where F: FnMut(&mut T, &mut T) -> bool\n+    {\n+        // Although we have a mutable reference to `self`, we cannot make\n+        // *arbitrary* changes. The `same_bucket` calls could panic, so we\n+        // must ensure that the slice is in a valid state at all times.\n+        //\n+        // The way that we handle this is by using swaps; we iterate\n+        // over all the elements, swapping as we go so that at the end\n+        // the elements we wish to keep are in the front, and those we\n+        // wish to reject are at the back. We can then split the slice.\n+        // This operation is still O(n).\n+        //\n+        // Example: We start in this state, where `r` represents \"next\n+        // read\" and `w` represents \"next_write`.\n+        //\n+        //           r\n+        //     +---+---+---+---+---+---+\n+        //     | 0 | 1 | 1 | 2 | 3 | 3 |\n+        //     +---+---+---+---+---+---+\n+        //           w\n+        //\n+        // Comparing self[r] against self[w-1], this is not a duplicate, so\n+        // we swap self[r] and self[w] (no effect as r==w) and then increment both\n+        // r and w, leaving us with:\n+        //\n+        //               r\n+        //     +---+---+---+---+---+---+\n+        //     | 0 | 1 | 1 | 2 | 3 | 3 |\n+        //     +---+---+---+---+---+---+\n+        //               w\n+        //\n+        // Comparing self[r] against self[w-1], this value is a duplicate,\n+        // so we increment `r` but leave everything else unchanged:\n+        //\n+        //                   r\n+        //     +---+---+---+---+---+---+\n+        //     | 0 | 1 | 1 | 2 | 3 | 3 |\n+        //     +---+---+---+---+---+---+\n+        //               w\n+        //\n+        // Comparing self[r] against self[w-1], this is not a duplicate,\n+        // so swap self[r] and self[w] and advance r and w:\n+        //\n+        //                       r\n+        //     +---+---+---+---+---+---+\n+        //     | 0 | 1 | 2 | 1 | 3 | 3 |\n+        //     +---+---+---+---+---+---+\n+        //                   w\n+        //\n+        // Not a duplicate, repeat:\n+        //\n+        //                           r\n+        //     +---+---+---+---+---+---+\n+        //     | 0 | 1 | 2 | 3 | 1 | 3 |\n+        //     +---+---+---+---+---+---+\n+        //                       w\n+        //\n+        // Duplicate, advance r. End of slice. Split at w.\n+\n+        let len = self.len();\n+        if len <= 1 {\n+            return (self, &mut [])\n+        }\n+\n+        let ptr = self.as_mut_ptr();\n+        let mut next_read: usize = 1;\n+        let mut next_write: usize = 1;\n+\n+        unsafe {\n+            // Avoid bounds checks by using raw pointers.\n+            while next_read < len {\n+                let ptr_read = ptr.add(next_read);\n+                let prev_ptr_write = ptr.add(next_write - 1);\n+                if !same_bucket(&mut *ptr_read, &mut *prev_ptr_write) {\n+                    if next_read != next_write {\n+                        let ptr_write = prev_ptr_write.offset(1);\n+                        mem::swap(&mut *ptr_read, &mut *ptr_write);\n+                    }\n+                    next_write += 1;\n+                }\n+                next_read += 1;\n+            }\n+        }\n+\n+        self.split_at_mut(next_write)\n+    }\n+\n+    /// Moves all but the first of consecutive elements to the end of the slice that resolve\n+    /// to the same key.\n+    ///\n+    /// Returns two slices. The first contains no consecutive repeated elements.\n+    /// The second contains all the duplicates in no specified order.\n+    ///\n+    /// If the slice is sorted, the first returned slice contains no duplicates.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_partition_dedup)]\n+    ///\n+    /// let mut slice = [10, 20, 21, 30, 30, 20, 11, 13];\n+    ///\n+    /// let (dedup, duplicates) = slice.partition_dedup_by_key(|i| *i / 10);\n+    ///\n+    /// assert_eq!(dedup, [10, 20, 30, 20, 11]);\n+    /// assert_eq!(duplicates, [21, 30, 13]);\n+    /// ```\n+    #[unstable(feature = \"slice_partition_dedup\", issue = \"54279\")]\n+    #[inline]\n+    pub fn partition_dedup_by_key<K, F>(&mut self, mut key: F) -> (&mut [T], &mut [T])\n+        where F: FnMut(&mut T) -> K,\n+              K: PartialEq,\n+    {\n+        self.partition_dedup_by(|a, b| key(a) == key(b))\n+    }\n+\n     /// Rotates the slice in-place such that the first `mid` elements of the\n     /// slice move to the end while the last `self.len() - mid` elements move to\n     /// the front. After calling `rotate_left`, the element previously at index"}, {"sha": "d05f6e07331c941d4f090865d8c1211e06cdfea6", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b940e1d961b274eb036e3155c6152705ac0d2227/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b940e1d961b274eb036e3155c6152705ac0d2227/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=b940e1d961b274eb036e3155c6152705ac0d2227", "patch": "@@ -39,6 +39,7 @@\n #![feature(inner_deref)]\n #![feature(slice_internals)]\n #![feature(option_replace)]\n+#![feature(slice_partition_dedup)]\n #![feature(copy_within)]\n \n extern crate core;"}, {"sha": "6f11880eb72dbb8bf3e19cdf974411d44667d1d1", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/b940e1d961b274eb036e3155c6152705ac0d2227/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b940e1d961b274eb036e3155c6152705ac0d2227/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=b940e1d961b274eb036e3155c6152705ac0d2227", "patch": "@@ -1001,6 +1001,65 @@ fn test_align_to_empty_mid() {\n     }\n }\n \n+#[test]\n+fn test_slice_partition_dedup_by() {\n+    let mut slice: [i32; 9] = [1, -1, 2, 3, 1, -5, 5, -2, 2];\n+\n+    let (dedup, duplicates) = slice.partition_dedup_by(|a, b| a.abs() == b.abs());\n+\n+    assert_eq!(dedup, [1, 2, 3, 1, -5, -2]);\n+    assert_eq!(duplicates, [5, -1, 2]);\n+}\n+\n+#[test]\n+fn test_slice_partition_dedup_empty() {\n+    let mut slice: [i32; 0] = [];\n+\n+    let (dedup, duplicates) = slice.partition_dedup();\n+\n+    assert_eq!(dedup, []);\n+    assert_eq!(duplicates, []);\n+}\n+\n+#[test]\n+fn test_slice_partition_dedup_one() {\n+    let mut slice = [12];\n+\n+    let (dedup, duplicates) = slice.partition_dedup();\n+\n+    assert_eq!(dedup, [12]);\n+    assert_eq!(duplicates, []);\n+}\n+\n+#[test]\n+fn test_slice_partition_dedup_multiple_ident() {\n+    let mut slice = [12, 12, 12, 12, 12, 11, 11, 11, 11, 11, 11];\n+\n+    let (dedup, duplicates) = slice.partition_dedup();\n+\n+    assert_eq!(dedup, [12, 11]);\n+    assert_eq!(duplicates, [12, 12, 12, 12, 11, 11, 11, 11, 11]);\n+}\n+\n+#[test]\n+fn test_slice_partition_dedup_partialeq() {\n+    #[derive(Debug)]\n+    struct Foo(i32, i32);\n+\n+    impl PartialEq for Foo {\n+        fn eq(&self, other: &Foo) -> bool {\n+            self.0 == other.0\n+        }\n+    }\n+\n+    let mut slice = [Foo(0, 1), Foo(0, 5), Foo(1, 7), Foo(1, 9)];\n+\n+    let (dedup, duplicates) = slice.partition_dedup();\n+\n+    assert_eq!(dedup, [Foo(0, 1), Foo(1, 7)]);\n+    assert_eq!(duplicates, [Foo(0, 5), Foo(1, 9)]);\n+}\n+\n #[test]\n fn test_copy_within() {\n     // Start to end, with a RangeTo."}]}