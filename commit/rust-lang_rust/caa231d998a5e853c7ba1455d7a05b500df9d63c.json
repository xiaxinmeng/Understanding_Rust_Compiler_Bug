{"sha": "caa231d998a5e853c7ba1455d7a05b500df9d63c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhYTIzMWQ5OThhNWU4NTNjN2JhMTQ1NWQ3YTA1YjUwMGRmOWQ2M2M=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-08T19:46:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-08T19:46:58Z"}, "message": "Auto merge of #68011 - JohnTitor:rollup-44s8twu, r=JohnTitor\n\nRollup of 10 pull requests\n\nSuccessful merges:\n\n - #67774 (Try statx for all linux-gnu target.)\n - #67781 (Move `is_min_const_fn` query to librustc_mir.)\n - #67798 (Remove wrong advice about spin locks from `spin_loop_hint` docs)\n - #67849 (Add a check for swapped words when we can't find an identifier)\n - #67875 (Distinguish between private items and hidden items in rustdoc)\n - #67887 (`Option::{expect,unwrap}` and `Result::{expect, expect_err, unwrap, unwrap_err}` have `#[track_caller]`)\n - #67955 (rustdoc: Remove more `#[doc(cfg(..))]` duplicates)\n - #67977 (Updates for VxWorks)\n - #67985 (Remove insignificant notes from CStr documentation)\n - #68003 (ci: fix wrong shared.sh import for publish_toolstate)\n\nFailed merges:\n\n - #67820 (Parse the syntax described in RFC 2632)\n - #67979 (Move `intravisit` => `rustc_hir` + misc cleanup)\n\nr? @ghost", "tree": {"sha": "16bcf8c8c892384fc5bff9f175d4e7a5aa5b6d13", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16bcf8c8c892384fc5bff9f175d4e7a5aa5b6d13"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/caa231d998a5e853c7ba1455d7a05b500df9d63c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/caa231d998a5e853c7ba1455d7a05b500df9d63c", "html_url": "https://github.com/rust-lang/rust/commit/caa231d998a5e853c7ba1455d7a05b500df9d63c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/caa231d998a5e853c7ba1455d7a05b500df9d63c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed6468da160bd67a2ce0573427f09a98daff8c07", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed6468da160bd67a2ce0573427f09a98daff8c07", "html_url": "https://github.com/rust-lang/rust/commit/ed6468da160bd67a2ce0573427f09a98daff8c07"}, {"sha": "844530e31788e4898bed66cd121aa8e7ea737ded", "url": "https://api.github.com/repos/rust-lang/rust/commits/844530e31788e4898bed66cd121aa8e7ea737ded", "html_url": "https://github.com/rust-lang/rust/commit/844530e31788e4898bed66cd121aa8e7ea737ded"}], "stats": {"total": 922, "additions": 537, "deletions": 385}, "files": [{"sha": "7c43d034d8b7f70118010289502c920696548be5", "filename": "src/ci/publish_toolstate.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Fci%2Fpublish_toolstate.sh", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Fci%2Fpublish_toolstate.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fpublish_toolstate.sh?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -3,7 +3,7 @@\n set -euo pipefail\n IFS=$'\\n\\t'\n \n-source \"$(cd \"$(dirname \"$0\")\" && pwd)/../shared.sh\"\n+source \"$(cd \"$(dirname \"$0\")\" && pwd)/shared.sh\"\n \n # The following lines are also found in src/bootstrap/toolstate.rs,\n # so if updating here, please also update that file."}, {"sha": "fb534586fc615e2c52e5fcee5197bb641e48b55b", "filename": "src/libcore/option.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -341,6 +341,7 @@ impl<T> Option<T> {\n     /// x.expect(\"the world is ending\"); // panics with `the world is ending`\n     /// ```\n     #[inline]\n+    #[track_caller]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn expect(self, msg: &str) -> T {\n         match self {\n@@ -374,6 +375,7 @@ impl<T> Option<T> {\n     /// assert_eq!(x.unwrap(), \"air\"); // fails\n     /// ```\n     #[inline]\n+    #[track_caller]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unwrap(self) -> T {\n         match self {\n@@ -1015,6 +1017,7 @@ impl<T: fmt::Debug> Option<T> {\n     /// }\n     /// ```\n     #[inline]\n+    #[track_caller]\n     #[unstable(feature = \"option_expect_none\", reason = \"newly added\", issue = \"62633\")]\n     pub fn expect_none(self, msg: &str) {\n         if let Some(val) = self {\n@@ -1057,6 +1060,7 @@ impl<T: fmt::Debug> Option<T> {\n     /// }\n     /// ```\n     #[inline]\n+    #[track_caller]\n     #[unstable(feature = \"option_unwrap_none\", reason = \"newly added\", issue = \"62633\")]\n     pub fn unwrap_none(self) {\n         if let Some(val) = self {\n@@ -1184,13 +1188,15 @@ impl<T, E> Option<Result<T, E>> {\n // This is a separate function to reduce the code size of .expect() itself.\n #[inline(never)]\n #[cold]\n+#[track_caller]\n fn expect_failed(msg: &str) -> ! {\n     panic!(\"{}\", msg)\n }\n \n // This is a separate function to reduce the code size of .expect_none() itself.\n #[inline(never)]\n #[cold]\n+#[track_caller]\n fn expect_none_failed(msg: &str, value: &dyn fmt::Debug) -> ! {\n     panic!(\"{}: {:?}\", msg, value)\n }"}, {"sha": "b39abf917850ddc62a88477b56f7b13e53501343", "filename": "src/libcore/result.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -957,6 +957,7 @@ impl<T, E: fmt::Debug> Result<T, E> {\n     /// x.unwrap(); // panics with `emergency failure`\n     /// ```\n     #[inline]\n+    #[track_caller]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unwrap(self) -> T {\n         match self {\n@@ -984,6 +985,7 @@ impl<T, E: fmt::Debug> Result<T, E> {\n     /// x.expect(\"Testing expect\"); // panics with `Testing expect: emergency failure`\n     /// ```\n     #[inline]\n+    #[track_caller]\n     #[stable(feature = \"result_expect\", since = \"1.4.0\")]\n     pub fn expect(self, msg: &str) -> T {\n         match self {\n@@ -1017,6 +1019,7 @@ impl<T: fmt::Debug, E> Result<T, E> {\n     /// assert_eq!(x.unwrap_err(), \"emergency failure\");\n     /// ```\n     #[inline]\n+    #[track_caller]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn unwrap_err(self) -> E {\n         match self {\n@@ -1044,6 +1047,7 @@ impl<T: fmt::Debug, E> Result<T, E> {\n     /// x.expect_err(\"Testing expect_err\"); // panics with `Testing expect_err: 10`\n     /// ```\n     #[inline]\n+    #[track_caller]\n     #[stable(feature = \"result_expect_err\", since = \"1.17.0\")]\n     pub fn expect_err(self, msg: &str) -> E {\n         match self {\n@@ -1188,6 +1192,7 @@ impl<T, E> Result<Option<T>, E> {\n // This is a separate function to reduce the code size of the methods\n #[inline(never)]\n #[cold]\n+#[track_caller]\n fn unwrap_failed(msg: &str, error: &dyn fmt::Debug) -> ! {\n     panic!(\"{}: {:?}\", msg, error)\n }"}, {"sha": "fae95ca5cdb36ba4182343e308d7c53f05bf810d", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -134,16 +134,10 @@ use crate::hint::spin_loop;\n /// This function is different from [`std::thread::yield_now`] which directly yields to the\n /// system's scheduler, whereas `spin_loop_hint` does not interact with the operating system.\n ///\n-/// Spin locks can be very efficient for short lock durations because they do not involve context\n-/// switches or interaction with the operating system. For long lock durations they become wasteful\n-/// however because they use CPU cycles for the entire lock duration, and using a\n-/// [`std::sync::Mutex`] is likely the better approach. If actively spinning for a long time is\n-/// required, e.g. because code polls a non-blocking API, calling [`std::thread::yield_now`]\n-/// or [`std::thread::sleep`] may be the best option.\n-///\n-/// **Note**: Spin locks are based on the underlying assumption that another thread will release\n-/// the lock 'soon'. In order for this to work, that other thread must run on a different CPU or\n-/// core (at least potentially). Spin locks do not work efficiently on single CPU / core platforms.\n+/// A common use case for `spin_loop_hint` is implementing bounded optimistic spinning in a CAS\n+/// loop in synchronization primitives. To avoid problems like priority inversion, it is strongly\n+/// recommended that the spin loop is terminated after a finite amount of iterations and an\n+/// appropriate blocking syscall is made.\n ///\n /// **Note**: On platforms that do not support receiving spin-loop hints this function does not\n /// do anything at all."}, {"sha": "cc5131cb217954b3558c91eb5e01bf71c413fc0c", "filename": "src/librustc/ty/constness.rs", "status": "removed", "additions": 0, "deletions": 156, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/ed6468da160bd67a2ce0573427f09a98daff8c07/src%2Flibrustc%2Fty%2Fconstness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed6468da160bd67a2ce0573427f09a98daff8c07/src%2Flibrustc%2Fty%2Fconstness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fconstness.rs?ref=ed6468da160bd67a2ce0573427f09a98daff8c07", "patch": "@@ -1,156 +0,0 @@\n-use crate::hir::map::blocks::FnLikeNode;\n-use crate::ty::query::Providers;\n-use crate::ty::TyCtxt;\n-use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n-use rustc_span::symbol::Symbol;\n-use rustc_target::spec::abi::Abi;\n-use syntax::attr;\n-\n-impl<'tcx> TyCtxt<'tcx> {\n-    /// Whether the `def_id` counts as const fn in your current crate, considering all active\n-    /// feature gates\n-    pub fn is_const_fn(self, def_id: DefId) -> bool {\n-        self.is_const_fn_raw(def_id)\n-            && match self.is_unstable_const_fn(def_id) {\n-                Some(feature_name) => {\n-                    // has a `rustc_const_unstable` attribute, check whether the user enabled the\n-                    // corresponding feature gate.\n-                    self.features()\n-                        .declared_lib_features\n-                        .iter()\n-                        .any(|&(sym, _)| sym == feature_name)\n-                }\n-                // functions without const stability are either stable user written\n-                // const fn or the user is using feature gates and we thus don't\n-                // care what they do\n-                None => true,\n-            }\n-    }\n-\n-    /// Whether the `def_id` is an unstable const fn and what feature gate is necessary to enable it\n-    pub fn is_unstable_const_fn(self, def_id: DefId) -> Option<Symbol> {\n-        if self.is_const_fn_raw(def_id) {\n-            let const_stab = self.lookup_const_stability(def_id)?;\n-            if const_stab.level.is_unstable() { Some(const_stab.feature) } else { None }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Returns `true` if this function must conform to `min_const_fn`\n-    pub fn is_min_const_fn(self, def_id: DefId) -> bool {\n-        // Bail out if the signature doesn't contain `const`\n-        if !self.is_const_fn_raw(def_id) {\n-            return false;\n-        }\n-\n-        if self.features().staged_api {\n-            // In order for a libstd function to be considered min_const_fn\n-            // it needs to be stable and have no `rustc_const_unstable` attribute.\n-            match self.lookup_const_stability(def_id) {\n-                // `rustc_const_unstable` functions don't need to conform.\n-                Some(&attr::ConstStability { ref level, .. }) if level.is_unstable() => false,\n-                None => {\n-                    if let Some(stab) = self.lookup_stability(def_id) {\n-                        if stab.level.is_stable() {\n-                            self.sess.span_err(\n-                                self.def_span(def_id),\n-                                \"stable const functions must have either `rustc_const_stable` or \\\n-                            `rustc_const_unstable` attribute\",\n-                            );\n-                            // While we errored above, because we don't know if we need to conform, we\n-                            // err on the \"safe\" side and require min_const_fn.\n-                            true\n-                        } else {\n-                            // Unstable functions need not conform to min_const_fn.\n-                            false\n-                        }\n-                    } else {\n-                        // Internal functions are forced to conform to min_const_fn.\n-                        // Annotate the internal function with a const stability attribute if\n-                        // you need to use unstable features.\n-                        // Note: this is an arbitrary choice that does not affect stability or const\n-                        // safety or anything, it just changes whether we need to annotate some\n-                        // internal functions with `rustc_const_stable` or with `rustc_const_unstable`\n-                        true\n-                    }\n-                }\n-                // Everything else needs to conform, because it would be callable from\n-                // other `min_const_fn` functions.\n-                _ => true,\n-            }\n-        } else {\n-            // users enabling the `const_fn` feature gate can do what they want\n-            !self.features().const_fn\n-        }\n-    }\n-}\n-\n-pub fn provide(providers: &mut Providers<'_>) {\n-    /// Const evaluability whitelist is here to check evaluability at the\n-    /// top level beforehand.\n-    fn is_const_intrinsic(tcx: TyCtxt<'_>, def_id: DefId) -> Option<bool> {\n-        match tcx.fn_sig(def_id).abi() {\n-            Abi::RustIntrinsic | Abi::PlatformIntrinsic => {\n-                Some(tcx.lookup_const_stability(def_id).is_some())\n-            }\n-            _ => None,\n-        }\n-    }\n-\n-    /// Checks whether the function has a `const` modifier or, in case it is an intrinsic, whether\n-    /// said intrinsic is on the whitelist for being const callable.\n-    fn is_const_fn_raw(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-        let hir_id = tcx\n-            .hir()\n-            .as_local_hir_id(def_id)\n-            .expect(\"Non-local call to local provider is_const_fn\");\n-\n-        let node = tcx.hir().get(hir_id);\n-\n-        if let Some(whitelisted) = is_const_intrinsic(tcx, def_id) {\n-            whitelisted\n-        } else if let Some(fn_like) = FnLikeNode::from_node(node) {\n-            fn_like.constness() == hir::Constness::Const\n-        } else if let hir::Node::Ctor(_) = node {\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n-    fn is_promotable_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-        tcx.is_const_fn(def_id)\n-            && match tcx.lookup_const_stability(def_id) {\n-                Some(stab) => {\n-                    if cfg!(debug_assertions) && stab.promotable {\n-                        let sig = tcx.fn_sig(def_id);\n-                        assert_eq!(\n-                            sig.unsafety(),\n-                            hir::Unsafety::Normal,\n-                            \"don't mark const unsafe fns as promotable\",\n-                            // https://github.com/rust-lang/rust/pull/53851#issuecomment-418760682\n-                        );\n-                    }\n-                    stab.promotable\n-                }\n-                None => false,\n-            }\n-    }\n-\n-    fn const_fn_is_allowed_fn_ptr(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-        tcx.is_const_fn(def_id)\n-            && tcx\n-                .lookup_const_stability(def_id)\n-                .map(|stab| stab.allow_const_fn_ptr)\n-                .unwrap_or(false)\n-    }\n-\n-    *providers = Providers {\n-        is_const_fn_raw,\n-        is_promotable_const_fn,\n-        const_fn_is_allowed_fn_ptr,\n-        ..*providers\n-    };\n-}"}, {"sha": "747e6e8da99af35b572c274a0dbf6e8aa55cd052", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -97,7 +97,6 @@ pub mod cast;\n #[macro_use]\n pub mod codec;\n pub mod _match;\n-mod constness;\n mod erase_regions;\n pub mod error;\n pub mod fast_reject;\n@@ -3318,7 +3317,6 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n     context::provide(providers);\n     erase_regions::provide(providers);\n     layout::provide(providers);\n-    constness::provide(providers);\n     *providers = ty::query::Providers {\n         asyncness,\n         associated_item,"}, {"sha": "7b2ce7f9ac7be9f3f4d8d318bbf1436aaf59fea0", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -9,10 +9,12 @@ use crate::interpret::{intern_const_alloc_recursive, ConstValue, InterpCx};\n \n mod error;\n mod eval_queries;\n+mod fn_queries;\n mod machine;\n \n pub use error::*;\n pub use eval_queries::*;\n+pub use fn_queries::*;\n pub use machine::*;\n \n /// Extracts a field of a (variant of a) const."}, {"sha": "2443e1e91d378faa445881e5bc39a3898a0324e4", "filename": "src/librustc_mir/const_eval/fn_queries.rs", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -0,0 +1,151 @@\n+use rustc::hir::map::blocks::FnLikeNode;\n+use rustc::ty::query::Providers;\n+use rustc::ty::TyCtxt;\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_span::symbol::Symbol;\n+use rustc_target::spec::abi::Abi;\n+use syntax::attr;\n+\n+/// Whether the `def_id` counts as const fn in your current crate, considering all active\n+/// feature gates\n+pub fn is_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+    tcx.is_const_fn_raw(def_id)\n+        && match is_unstable_const_fn(tcx, def_id) {\n+            Some(feature_name) => {\n+                // has a `rustc_const_unstable` attribute, check whether the user enabled the\n+                // corresponding feature gate.\n+                tcx.features().declared_lib_features.iter().any(|&(sym, _)| sym == feature_name)\n+            }\n+            // functions without const stability are either stable user written\n+            // const fn or the user is using feature gates and we thus don't\n+            // care what they do\n+            None => true,\n+        }\n+}\n+\n+/// Whether the `def_id` is an unstable const fn and what feature gate is necessary to enable it\n+pub fn is_unstable_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Symbol> {\n+    if tcx.is_const_fn_raw(def_id) {\n+        let const_stab = tcx.lookup_const_stability(def_id)?;\n+        if const_stab.level.is_unstable() { Some(const_stab.feature) } else { None }\n+    } else {\n+        None\n+    }\n+}\n+\n+/// Returns `true` if this function must conform to `min_const_fn`\n+pub fn is_min_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+    // Bail out if the signature doesn't contain `const`\n+    if !tcx.is_const_fn_raw(def_id) {\n+        return false;\n+    }\n+\n+    if tcx.features().staged_api {\n+        // In order for a libstd function to be considered min_const_fn\n+        // it needs to be stable and have no `rustc_const_unstable` attribute.\n+        match tcx.lookup_const_stability(def_id) {\n+            // `rustc_const_unstable` functions don't need to conform.\n+            Some(&attr::ConstStability { ref level, .. }) if level.is_unstable() => false,\n+            None => {\n+                if let Some(stab) = tcx.lookup_stability(def_id) {\n+                    if stab.level.is_stable() {\n+                        tcx.sess.span_err(\n+                            tcx.def_span(def_id),\n+                            \"stable const functions must have either `rustc_const_stable` or \\\n+                             `rustc_const_unstable` attribute\",\n+                        );\n+                        // While we errored above, because we don't know if we need to conform, we\n+                        // err on the \"safe\" side and require min_const_fn.\n+                        true\n+                    } else {\n+                        // Unstable functions need not conform to min_const_fn.\n+                        false\n+                    }\n+                } else {\n+                    // Internal functions are forced to conform to min_const_fn.\n+                    // Annotate the internal function with a const stability attribute if\n+                    // you need to use unstable features.\n+                    // Note: this is an arbitrary choice that does not affect stability or const\n+                    // safety or anything, it just changes whether we need to annotate some\n+                    // internal functions with `rustc_const_stable` or with `rustc_const_unstable`\n+                    true\n+                }\n+            }\n+            // Everything else needs to conform, because it would be callable from\n+            // other `min_const_fn` functions.\n+            _ => true,\n+        }\n+    } else {\n+        // users enabling the `const_fn` feature gate can do what they want\n+        !tcx.features().const_fn\n+    }\n+}\n+\n+pub fn provide(providers: &mut Providers<'_>) {\n+    /// Const evaluability whitelist is here to check evaluability at the\n+    /// top level beforehand.\n+    fn is_const_intrinsic(tcx: TyCtxt<'_>, def_id: DefId) -> Option<bool> {\n+        match tcx.fn_sig(def_id).abi() {\n+            Abi::RustIntrinsic | Abi::PlatformIntrinsic => {\n+                Some(tcx.lookup_const_stability(def_id).is_some())\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    /// Checks whether the function has a `const` modifier or, in case it is an intrinsic, whether\n+    /// said intrinsic is on the whitelist for being const callable.\n+    fn is_const_fn_raw(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+        let hir_id = tcx\n+            .hir()\n+            .as_local_hir_id(def_id)\n+            .expect(\"Non-local call to local provider is_const_fn\");\n+\n+        let node = tcx.hir().get(hir_id);\n+\n+        if let Some(whitelisted) = is_const_intrinsic(tcx, def_id) {\n+            whitelisted\n+        } else if let Some(fn_like) = FnLikeNode::from_node(node) {\n+            fn_like.constness() == hir::Constness::Const\n+        } else if let hir::Node::Ctor(_) = node {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    fn is_promotable_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+        is_const_fn(tcx, def_id)\n+            && match tcx.lookup_const_stability(def_id) {\n+                Some(stab) => {\n+                    if cfg!(debug_assertions) && stab.promotable {\n+                        let sig = tcx.fn_sig(def_id);\n+                        assert_eq!(\n+                            sig.unsafety(),\n+                            hir::Unsafety::Normal,\n+                            \"don't mark const unsafe fns as promotable\",\n+                            // https://github.com/rust-lang/rust/pull/53851#issuecomment-418760682\n+                        );\n+                    }\n+                    stab.promotable\n+                }\n+                None => false,\n+            }\n+    }\n+\n+    fn const_fn_is_allowed_fn_ptr(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n+        is_const_fn(tcx, def_id)\n+            && tcx\n+                .lookup_const_stability(def_id)\n+                .map(|stab| stab.allow_const_fn_ptr)\n+                .unwrap_or(false)\n+    }\n+\n+    *providers = Providers {\n+        is_const_fn_raw,\n+        is_promotable_const_fn,\n+        const_fn_is_allowed_fn_ptr,\n+        ..*providers\n+    };\n+}"}, {"sha": "36c6568029d5fd4c787959865ed03bae2a9b8f21", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -52,6 +52,7 @@ use rustc::ty::query::Providers;\n \n pub fn provide(providers: &mut Providers<'_>) {\n     borrow_check::provide(providers);\n+    const_eval::provide(providers);\n     shim::provide(providers);\n     transform::provide(providers);\n     monomorphize::partitioning::provide(providers);"}, {"sha": "b81839724762481a89592f2dece6cf048bc8c1cd", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -21,6 +21,7 @@ use super::ops::{self, NonConstOp};\n use super::qualifs::{self, HasMutInterior, NeedsDrop};\n use super::resolver::FlowSensitiveAnalysis;\n use super::{is_lang_panic_fn, ConstKind, Item, Qualif};\n+use crate::const_eval::{is_const_fn, is_unstable_const_fn};\n use crate::dataflow::{self as old_dataflow, generic as dataflow};\n \n pub type IndirectlyMutableResults<'mir, 'tcx> =\n@@ -173,7 +174,7 @@ impl Validator<'a, 'mir, 'tcx> {\n         let Item { tcx, body, def_id, const_kind, .. } = *self.item;\n \n         let use_min_const_fn_checks = (const_kind == Some(ConstKind::ConstFn)\n-            && tcx.is_min_const_fn(def_id))\n+            && crate::const_eval::is_min_const_fn(tcx, def_id))\n             && !tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you;\n \n         if use_min_const_fn_checks {\n@@ -560,13 +561,13 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n                 };\n \n                 // At this point, we are calling a function whose `DefId` is known...\n-                if self.tcx.is_const_fn(def_id) {\n+                if is_const_fn(self.tcx, def_id) {\n                     return;\n                 }\n \n                 if is_lang_panic_fn(self.tcx, def_id) {\n                     self.check_op(ops::Panic);\n-                } else if let Some(feature) = self.tcx.is_unstable_const_fn(def_id) {\n+                } else if let Some(feature) = is_unstable_const_fn(self.tcx, def_id) {\n                     // Exempt unstable const fns inside of macros with\n                     // `#[allow_internal_unstable]`.\n                     if !self.span.allows_unstable(feature) {"}, {"sha": "d07e58b7447717f543e0804e82862d4bc4bd96cb", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -14,6 +14,7 @@ use rustc_span::symbol::{sym, Symbol};\n \n use std::ops::Bound;\n \n+use crate::const_eval::{is_const_fn, is_min_const_fn};\n use crate::util;\n \n use rustc_error_codes::*;\n@@ -523,7 +524,7 @@ fn unsafety_check_result(tcx: TyCtxt<'_>, def_id: DefId) -> UnsafetyCheckResult\n     let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n     let (const_context, min_const_fn) = match tcx.hir().body_owner_kind(id) {\n         hir::BodyOwnerKind::Closure => (false, false),\n-        hir::BodyOwnerKind::Fn => (tcx.is_const_fn(def_id), tcx.is_min_const_fn(def_id)),\n+        hir::BodyOwnerKind::Fn => (is_const_fn(tcx, def_id), is_min_const_fn(tcx, def_id)),\n         hir::BodyOwnerKind::Const | hir::BodyOwnerKind::Static(_) => (true, false),\n     };\n     let mut checker = UnsafetyChecker::new(const_context, min_const_fn, body, tcx, param_env);"}, {"sha": "00a39905c023292d24e7664fbbf48c215c54b13d", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -29,6 +29,7 @@ use rustc_target::spec::abi::Abi;\n use std::cell::Cell;\n use std::{iter, mem, usize};\n \n+use crate::const_eval::{is_const_fn, is_unstable_const_fn};\n use crate::transform::check_consts::{is_lang_panic_fn, qualifs, ConstKind, Item};\n use crate::transform::{MirPass, MirSource};\n \n@@ -702,8 +703,8 @@ impl<'tcx> Validator<'_, 'tcx> {\n \n         let is_const_fn = match fn_ty.kind {\n             ty::FnDef(def_id, _) => {\n-                self.tcx.is_const_fn(def_id)\n-                    || self.tcx.is_unstable_const_fn(def_id).is_some()\n+                is_const_fn(self.tcx, def_id)\n+                    || is_unstable_const_fn(self.tcx, def_id).is_some()\n                     || is_lang_panic_fn(self.tcx, self.def_id)\n             }\n             _ => false,"}, {"sha": "fcdabb29cd0e240087c5c1cc2fb0b5e782d0d720", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -327,7 +327,7 @@ fn check_terminator(\n         TerminatorKind::Call { func, args, from_hir_call: _, destination: _, cleanup: _ } => {\n             let fn_ty = func.ty(body, tcx);\n             if let ty::FnDef(def_id, _) = fn_ty.kind {\n-                if !tcx.is_min_const_fn(def_id) {\n+                if !crate::const_eval::is_min_const_fn(tcx, def_id) {\n                     return Err((\n                         span,\n                         format!("}, {"sha": "84e6ff648a38ff9d7652a05225a8ef980aac9c7d", "filename": "src/librustdoc/clean/cfg.rs", "status": "modified", "additions": 38, "deletions": 16, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fclean%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -202,23 +202,34 @@ impl ops::Not for Cfg {\n \n impl ops::BitAndAssign for Cfg {\n     fn bitand_assign(&mut self, other: Cfg) {\n-        if *self == other {\n-            return;\n-        }\n         match (self, other) {\n             (&mut Cfg::False, _) | (_, Cfg::True) => {}\n             (s, Cfg::False) => *s = Cfg::False,\n             (s @ &mut Cfg::True, b) => *s = b,\n-            (&mut Cfg::All(ref mut a), Cfg::All(ref mut b)) => a.append(b),\n-            (&mut Cfg::All(ref mut a), ref mut b) => a.push(mem::replace(b, Cfg::True)),\n+            (&mut Cfg::All(ref mut a), Cfg::All(ref mut b)) => {\n+                for c in b.drain(..) {\n+                    if !a.contains(&c) {\n+                        a.push(c);\n+                    }\n+                }\n+            }\n+            (&mut Cfg::All(ref mut a), ref mut b) => {\n+                if !a.contains(b) {\n+                    a.push(mem::replace(b, Cfg::True));\n+                }\n+            }\n             (s, Cfg::All(mut a)) => {\n                 let b = mem::replace(s, Cfg::True);\n-                a.push(b);\n+                if !a.contains(&b) {\n+                    a.push(b);\n+                }\n                 *s = Cfg::All(a);\n             }\n             (s, b) => {\n-                let a = mem::replace(s, Cfg::True);\n-                *s = Cfg::All(vec![a, b]);\n+                if *s != b {\n+                    let a = mem::replace(s, Cfg::True);\n+                    *s = Cfg::All(vec![a, b]);\n+                }\n             }\n         }\n     }\n@@ -234,23 +245,34 @@ impl ops::BitAnd for Cfg {\n \n impl ops::BitOrAssign for Cfg {\n     fn bitor_assign(&mut self, other: Cfg) {\n-        if *self == other {\n-            return;\n-        }\n         match (self, other) {\n             (&mut Cfg::True, _) | (_, Cfg::False) => {}\n             (s, Cfg::True) => *s = Cfg::True,\n             (s @ &mut Cfg::False, b) => *s = b,\n-            (&mut Cfg::Any(ref mut a), Cfg::Any(ref mut b)) => a.append(b),\n-            (&mut Cfg::Any(ref mut a), ref mut b) => a.push(mem::replace(b, Cfg::True)),\n+            (&mut Cfg::Any(ref mut a), Cfg::Any(ref mut b)) => {\n+                for c in b.drain(..) {\n+                    if !a.contains(&c) {\n+                        a.push(c);\n+                    }\n+                }\n+            }\n+            (&mut Cfg::Any(ref mut a), ref mut b) => {\n+                if !a.contains(b) {\n+                    a.push(mem::replace(b, Cfg::True));\n+                }\n+            }\n             (s, Cfg::Any(mut a)) => {\n                 let b = mem::replace(s, Cfg::True);\n-                a.push(b);\n+                if !a.contains(&b) {\n+                    a.push(b);\n+                }\n                 *s = Cfg::Any(a);\n             }\n             (s, b) => {\n-                let a = mem::replace(s, Cfg::True);\n-                *s = Cfg::Any(vec![a, b]);\n+                if *s != b {\n+                    let a = mem::replace(s, Cfg::True);\n+                    *s = Cfg::Any(vec![a, b]);\n+                }\n             }\n         }\n     }"}, {"sha": "d090bf325038f53def6469ba94aef723fa69bc40", "filename": "src/librustdoc/clean/cfg/tests.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fcfg%2Ftests.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -87,6 +87,12 @@ fn test_cfg_and() {\n         x &= word_cfg(\"test3\");\n         assert_eq!(x, word_cfg(\"test3\"));\n \n+        x &= word_cfg(\"test3\");\n+        assert_eq!(x, word_cfg(\"test3\"));\n+\n+        x &= word_cfg(\"test4\");\n+        assert_eq!(x, Cfg::All(vec![word_cfg(\"test3\"), word_cfg(\"test4\")]));\n+\n         x &= word_cfg(\"test4\");\n         assert_eq!(x, Cfg::All(vec![word_cfg(\"test3\"), word_cfg(\"test4\")]));\n \n@@ -105,6 +111,18 @@ fn test_cfg_and() {\n             ])\n         );\n \n+        x &= Cfg::All(vec![word_cfg(\"test6\"), word_cfg(\"test7\")]);\n+        assert_eq!(\n+            x,\n+            Cfg::All(vec![\n+                word_cfg(\"test3\"),\n+                word_cfg(\"test4\"),\n+                word_cfg(\"test5\"),\n+                word_cfg(\"test6\"),\n+                word_cfg(\"test7\"),\n+            ])\n+        );\n+\n         let mut y = Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\")]);\n         y &= x;\n         assert_eq!(\n@@ -119,6 +137,14 @@ fn test_cfg_and() {\n             ])\n         );\n \n+        let mut z = word_cfg(\"test8\");\n+        z &= Cfg::All(vec![word_cfg(\"test9\"), word_cfg(\"test10\")]);\n+        assert_eq!(z, Cfg::All(vec![word_cfg(\"test9\"), word_cfg(\"test10\"), word_cfg(\"test8\")]));\n+\n+        let mut z = word_cfg(\"test11\");\n+        z &= Cfg::All(vec![word_cfg(\"test11\"), word_cfg(\"test12\")]);\n+        assert_eq!(z, Cfg::All(vec![word_cfg(\"test11\"), word_cfg(\"test12\")]));\n+\n         assert_eq!(\n             word_cfg(\"a\") & word_cfg(\"b\") & word_cfg(\"c\"),\n             Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\"), word_cfg(\"c\")])\n@@ -145,6 +171,12 @@ fn test_cfg_or() {\n         x |= word_cfg(\"test3\");\n         assert_eq!(x, word_cfg(\"test3\"));\n \n+        x |= word_cfg(\"test3\");\n+        assert_eq!(x, word_cfg(\"test3\"));\n+\n+        x |= word_cfg(\"test4\");\n+        assert_eq!(x, Cfg::Any(vec![word_cfg(\"test3\"), word_cfg(\"test4\")]));\n+\n         x |= word_cfg(\"test4\");\n         assert_eq!(x, Cfg::Any(vec![word_cfg(\"test3\"), word_cfg(\"test4\")]));\n \n@@ -163,6 +195,18 @@ fn test_cfg_or() {\n             ])\n         );\n \n+        x |= Cfg::Any(vec![word_cfg(\"test6\"), word_cfg(\"test7\")]);\n+        assert_eq!(\n+            x,\n+            Cfg::Any(vec![\n+                word_cfg(\"test3\"),\n+                word_cfg(\"test4\"),\n+                word_cfg(\"test5\"),\n+                word_cfg(\"test6\"),\n+                word_cfg(\"test7\"),\n+            ])\n+        );\n+\n         let mut y = Cfg::All(vec![word_cfg(\"a\"), word_cfg(\"b\")]);\n         y |= x;\n         assert_eq!(\n@@ -177,6 +221,14 @@ fn test_cfg_or() {\n             ])\n         );\n \n+        let mut z = word_cfg(\"test8\");\n+        z |= Cfg::Any(vec![word_cfg(\"test9\"), word_cfg(\"test10\")]);\n+        assert_eq!(z, Cfg::Any(vec![word_cfg(\"test9\"), word_cfg(\"test10\"), word_cfg(\"test8\")]));\n+\n+        let mut z = word_cfg(\"test11\");\n+        z |= Cfg::Any(vec![word_cfg(\"test11\"), word_cfg(\"test12\")]);\n+        assert_eq!(z, Cfg::Any(vec![word_cfg(\"test11\"), word_cfg(\"test12\")]));\n+\n         assert_eq!(\n             word_cfg(\"a\") | word_cfg(\"b\") | word_cfg(\"c\"),\n             Cfg::Any(vec![word_cfg(\"a\"), word_cfg(\"b\"), word_cfg(\"c\")])"}, {"sha": "c7e0f1e9e704ba0683a838307205f56a39ac8341", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -9,6 +9,7 @@ use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::Mutability;\n use rustc_metadata::creader::LoadedMacro;\n+use rustc_mir::const_eval::is_min_const_fn;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n@@ -212,7 +213,7 @@ fn build_external_function(cx: &DocContext<'_>, did: DefId) -> clean::Function {\n     let sig = cx.tcx.fn_sig(did);\n \n     let constness =\n-        if cx.tcx.is_min_const_fn(did) { hir::Constness::Const } else { hir::Constness::NotConst };\n+        if is_min_const_fn(cx.tcx, did) { hir::Constness::Const } else { hir::Constness::NotConst };\n     let asyncness = cx.tcx.asyncness(did);\n     let predicates = cx.tcx.predicates_of(did);\n     let (generics, decl) = clean::enter_impl_trait(cx, || {"}, {"sha": "be9654612f504e91163a02adc414d459735c08bd", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -21,6 +21,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX};\n use rustc_index::vec::{Idx, IndexVec};\n+use rustc_mir::const_eval::is_min_const_fn;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::{self, Pos};\n@@ -895,7 +896,7 @@ impl Clean<Item> for doctree::Function<'_> {\n             enter_impl_trait(cx, || (self.generics.clean(cx), (self.decl, self.body).clean(cx)));\n \n         let did = cx.tcx.hir().local_def_id(self.id);\n-        let constness = if cx.tcx.is_min_const_fn(did) {\n+        let constness = if is_min_const_fn(cx.tcx, did) {\n             hir::Constness::Const\n         } else {\n             hir::Constness::NotConst\n@@ -1187,7 +1188,7 @@ impl Clean<Item> for ty::AssocItem {\n                 };\n                 let (all_types, ret_types) = get_all_types(&generics, &decl, cx);\n                 if provided {\n-                    let constness = if cx.tcx.is_min_const_fn(self.def_id) {\n+                    let constness = if is_min_const_fn(cx.tcx, self.def_id) {\n                         hir::Constness::Const\n                     } else {\n                         hir::Constness::NotConst"}, {"sha": "26b49d2f9624e0fbe3b631727d24c45b8551e749", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 26, "deletions": 17, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -24,7 +24,7 @@ use crate::html;\n use crate::html::markdown::IdMap;\n use crate::html::static_files;\n use crate::opts;\n-use crate::passes::{self, DefaultPassOption};\n+use crate::passes::{self, Condition, DefaultPassOption};\n use crate::theme;\n \n /// Configuration options for rustdoc.\n@@ -98,6 +98,10 @@ pub struct Options {\n     ///\n     /// Be aware: This option can come both from the CLI and from crate attributes!\n     pub default_passes: DefaultPassOption,\n+    /// Document items that have lower than `pub` visibility.\n+    pub document_private: bool,\n+    /// Document items that have `doc(hidden)`.\n+    pub document_hidden: bool,\n     /// Any passes manually selected by the user.\n     ///\n     /// Be aware: This option can come both from the CLI and from crate attributes!\n@@ -146,6 +150,8 @@ impl fmt::Debug for Options {\n             .field(\"test_args\", &self.test_args)\n             .field(\"persist_doctests\", &self.persist_doctests)\n             .field(\"default_passes\", &self.default_passes)\n+            .field(\"document_private\", &self.document_private)\n+            .field(\"document_hidden\", &self.document_hidden)\n             .field(\"manual_passes\", &self.manual_passes)\n             .field(\"display_warnings\", &self.display_warnings)\n             .field(\"show_coverage\", &self.show_coverage)\n@@ -240,22 +246,26 @@ impl Options {\n                 println!(\"{:>20} - {}\", pass.name, pass.description);\n             }\n             println!(\"\\nDefault passes for rustdoc:\");\n-            for pass in passes::DEFAULT_PASSES {\n-                println!(\"{:>20}\", pass.name);\n-            }\n-            println!(\"\\nPasses run with `--document-private-items`:\");\n-            for pass in passes::DEFAULT_PRIVATE_PASSES {\n-                println!(\"{:>20}\", pass.name);\n+            for p in passes::DEFAULT_PASSES {\n+                print!(\"{:>20}\", p.pass.name);\n+                println_condition(p.condition);\n             }\n \n             if nightly_options::is_nightly_build() {\n                 println!(\"\\nPasses run with `--show-coverage`:\");\n-                for pass in passes::DEFAULT_COVERAGE_PASSES {\n-                    println!(\"{:>20}\", pass.name);\n+                for p in passes::COVERAGE_PASSES {\n+                    print!(\"{:>20}\", p.pass.name);\n+                    println_condition(p.condition);\n                 }\n-                println!(\"\\nPasses run with `--show-coverage --document-private-items`:\");\n-                for pass in passes::PRIVATE_COVERAGE_PASSES {\n-                    println!(\"{:>20}\", pass.name);\n+            }\n+\n+            fn println_condition(condition: Condition) {\n+                use Condition::*;\n+                match condition {\n+                    Always => println!(),\n+                    WhenDocumentPrivate => println!(\"  (when --document-private-items)\"),\n+                    WhenNotDocumentPrivate => println!(\"  (when not --document-private-items)\"),\n+                    WhenNotDocumentHidden => println!(\"  (when not --document-hidden-items)\"),\n                 }\n             }\n \n@@ -444,16 +454,11 @@ impl Options {\n             });\n \n         let show_coverage = matches.opt_present(\"show-coverage\");\n-        let document_private = matches.opt_present(\"document-private-items\");\n \n         let default_passes = if matches.opt_present(\"no-defaults\") {\n             passes::DefaultPassOption::None\n-        } else if show_coverage && document_private {\n-            passes::DefaultPassOption::PrivateCoverage\n         } else if show_coverage {\n             passes::DefaultPassOption::Coverage\n-        } else if document_private {\n-            passes::DefaultPassOption::Private\n         } else {\n             passes::DefaultPassOption::Default\n         };\n@@ -492,6 +497,8 @@ impl Options {\n         let runtool = matches.opt_str(\"runtool\");\n         let runtool_args = matches.opt_strs(\"runtool-arg\");\n         let enable_per_target_ignores = matches.opt_present(\"enable-per-target-ignores\");\n+        let document_private = matches.opt_present(\"document-private-items\");\n+        let document_hidden = matches.opt_present(\"document-hidden-items\");\n \n         let (lint_opts, describe_lints, lint_cap) = get_cmd_lint_options(matches, error_format);\n \n@@ -518,6 +525,8 @@ impl Options {\n             should_test,\n             test_args,\n             default_passes,\n+            document_private,\n+            document_hidden,\n             manual_passes,\n             display_warnings,\n             show_coverage,"}, {"sha": "be7f7ea364f4705b0945cc18c2ac6c3b4335c541", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -33,7 +33,7 @@ use crate::clean::{AttributesExt, MAX_DEF_ID};\n use crate::config::{Options as RustdocOptions, RenderOptions};\n use crate::html::render::RenderInfo;\n \n-use crate::passes;\n+use crate::passes::{self, Condition::*, ConditionalPass};\n \n pub use rustc::session::config::{CodegenOptions, DebuggingOptions, Input, Options};\n pub use rustc::session::search_paths::SearchPath;\n@@ -221,6 +221,8 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n         describe_lints,\n         lint_cap,\n         mut default_passes,\n+        mut document_private,\n+        document_hidden,\n         mut manual_passes,\n         display_warnings,\n         render_options,\n@@ -457,16 +459,14 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n                     }\n \n                     if attr.is_word() && name == sym::document_private_items {\n-                        if default_passes == passes::DefaultPassOption::Default {\n-                            default_passes = passes::DefaultPassOption::Private;\n-                        }\n+                        document_private = true;\n                     }\n                 }\n \n-                let passes = passes::defaults(default_passes).iter().chain(\n+                let passes = passes::defaults(default_passes).iter().copied().chain(\n                     manual_passes.into_iter().flat_map(|name| {\n                         if let Some(pass) = passes::find_pass(&name) {\n-                            Some(pass)\n+                            Some(ConditionalPass::always(pass))\n                         } else {\n                             error!(\"unknown pass {}, skipping\", name);\n                             None\n@@ -476,9 +476,17 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n \n                 info!(\"Executing passes\");\n \n-                for pass in passes {\n-                    debug!(\"running pass {}\", pass.name);\n-                    krate = (pass.pass)(krate, &ctxt);\n+                for p in passes {\n+                    let run = match p.condition {\n+                        Always => true,\n+                        WhenDocumentPrivate => document_private,\n+                        WhenNotDocumentPrivate => !document_private,\n+                        WhenNotDocumentHidden => !document_hidden,\n+                    };\n+                    if run {\n+                        debug!(\"running pass {}\", p.pass.name);\n+                        krate = (p.pass.run)(krate, &ctxt);\n+                    }\n                 }\n \n                 ctxt.sess().abort_if_errors();"}, {"sha": "91150899877febd611a45910bde27002068afc9e", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -32,6 +32,7 @@ extern crate rustc_interface;\n extern crate rustc_lexer;\n extern crate rustc_lint;\n extern crate rustc_metadata;\n+extern crate rustc_mir;\n extern crate rustc_parse;\n extern crate rustc_resolve;\n extern crate rustc_span as rustc_span;\n@@ -173,6 +174,9 @@ fn opts() -> Vec<RustcOptGroup> {\n         stable(\"document-private-items\", |o| {\n             o.optflag(\"\", \"document-private-items\", \"document private items\")\n         }),\n+        unstable(\"document-hidden-items\", |o| {\n+            o.optflag(\"\", \"document-hidden-items\", \"document items that have doc(hidden)\")\n+        }),\n         stable(\"test\", |o| o.optflag(\"\", \"test\", \"run code examples as tests\")),\n         stable(\"test-args\", |o| {\n             o.optmulti(\"\", \"test-args\", \"arguments to pass to the test runner\", \"ARGS\")"}, {"sha": "7ed531c9206af0db4df96227d42aa7b150631e92", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -12,7 +12,7 @@ use std::ops;\n \n pub const CALCULATE_DOC_COVERAGE: Pass = Pass {\n     name: \"calculate-doc-coverage\",\n-    pass: calculate_doc_coverage,\n+    run: calculate_doc_coverage,\n     description: \"counts the number of items with and without documentation\",\n };\n "}, {"sha": "79548eb6d647af0d141b328229d42d1188873c2a", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -14,7 +14,7 @@ use crate::passes::Pass;\n \n pub const CHECK_CODE_BLOCK_SYNTAX: Pass = Pass {\n     name: \"check-code-block-syntax\",\n-    pass: check_code_block_syntax,\n+    run: check_code_block_syntax,\n     description: \"validates syntax inside Rust code blocks\",\n };\n "}, {"sha": "c2185592d14837846d223d070532e025692b010d", "filename": "src/librustdoc/passes/collapse_docs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollapse_docs.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -8,7 +8,7 @@ use std::mem::take;\n \n pub const COLLAPSE_DOCS: Pass = Pass {\n     name: \"collapse-docs\",\n-    pass: collapse_docs,\n+    run: collapse_docs,\n     description: \"concatenates all document attributes into one document attribute\",\n };\n "}, {"sha": "b1cd3deecb479996d3eeb6f07943b391d5eadabd", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -28,7 +28,7 @@ use super::span_of_attrs;\n \n pub const COLLECT_INTRA_DOC_LINKS: Pass = Pass {\n     name: \"collect-intra-doc-links\",\n-    pass: collect_intra_doc_links,\n+    run: collect_intra_doc_links,\n     description: \"reads a crate's documentation to resolve intra-doc-links\",\n };\n "}, {"sha": "da0e97f1075b00f8d50d3e185318f7cde33e6279", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -9,7 +9,7 @@ use rustc_span::symbol::sym;\n \n pub const COLLECT_TRAIT_IMPLS: Pass = Pass {\n     name: \"collect-trait-impls\",\n-    pass: collect_trait_impls,\n+    run: collect_trait_impls,\n     description: \"retrieves trait impls for items in the crate\",\n };\n "}, {"sha": "355ea15223b0c1a2a35c5fcdf8e08c11e3fcb85e", "filename": "src/librustdoc/passes/mod.rs", "status": "modified", "additions": 51, "deletions": 36, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fpasses%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fmod.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -8,6 +8,7 @@ use rustc_span::{InnerSpan, Span, DUMMY_SP};\n use std::mem;\n use std::ops::Range;\n \n+use self::Condition::*;\n use crate::clean::{self, GetDefId, Item};\n use crate::core::DocContext;\n use crate::fold::{DocFolder, StripItem};\n@@ -52,10 +53,29 @@ pub use self::calculate_doc_coverage::CALCULATE_DOC_COVERAGE;\n #[derive(Copy, Clone)]\n pub struct Pass {\n     pub name: &'static str,\n-    pub pass: fn(clean::Crate, &DocContext<'_>) -> clean::Crate,\n+    pub run: fn(clean::Crate, &DocContext<'_>) -> clean::Crate,\n     pub description: &'static str,\n }\n \n+/// In a list of passes, a pass that may or may not need to be run depending on options.\n+#[derive(Copy, Clone)]\n+pub struct ConditionalPass {\n+    pub pass: Pass,\n+    pub condition: Condition,\n+}\n+\n+/// How to decide whether to run a conditional pass.\n+#[derive(Copy, Clone)]\n+pub enum Condition {\n+    Always,\n+    /// When `--document-private-items` is passed.\n+    WhenDocumentPrivate,\n+    /// When `--document-private-items` is not passed.\n+    WhenNotDocumentPrivate,\n+    /// When `--document-hidden-items` is not passed.\n+    WhenNotDocumentHidden,\n+}\n+\n /// The full list of passes.\n pub const PASSES: &[Pass] = &[\n     CHECK_PRIVATE_ITEMS_DOC_TESTS,\n@@ -72,63 +92,58 @@ pub const PASSES: &[Pass] = &[\n ];\n \n /// The list of passes run by default.\n-pub const DEFAULT_PASSES: &[Pass] = &[\n-    COLLECT_TRAIT_IMPLS,\n-    COLLAPSE_DOCS,\n-    UNINDENT_COMMENTS,\n-    CHECK_PRIVATE_ITEMS_DOC_TESTS,\n-    STRIP_HIDDEN,\n-    STRIP_PRIVATE,\n-    COLLECT_INTRA_DOC_LINKS,\n-    CHECK_CODE_BLOCK_SYNTAX,\n-    PROPAGATE_DOC_CFG,\n+pub const DEFAULT_PASSES: &[ConditionalPass] = &[\n+    ConditionalPass::always(COLLECT_TRAIT_IMPLS),\n+    ConditionalPass::always(COLLAPSE_DOCS),\n+    ConditionalPass::always(UNINDENT_COMMENTS),\n+    ConditionalPass::always(CHECK_PRIVATE_ITEMS_DOC_TESTS),\n+    ConditionalPass::new(STRIP_HIDDEN, WhenNotDocumentHidden),\n+    ConditionalPass::new(STRIP_PRIVATE, WhenNotDocumentPrivate),\n+    ConditionalPass::new(STRIP_PRIV_IMPORTS, WhenDocumentPrivate),\n+    ConditionalPass::always(COLLECT_INTRA_DOC_LINKS),\n+    ConditionalPass::always(CHECK_CODE_BLOCK_SYNTAX),\n+    ConditionalPass::always(PROPAGATE_DOC_CFG),\n ];\n \n-/// The list of default passes run with `--document-private-items` is passed to rustdoc.\n-pub const DEFAULT_PRIVATE_PASSES: &[Pass] = &[\n-    COLLECT_TRAIT_IMPLS,\n-    COLLAPSE_DOCS,\n-    UNINDENT_COMMENTS,\n-    CHECK_PRIVATE_ITEMS_DOC_TESTS,\n-    STRIP_PRIV_IMPORTS,\n-    COLLECT_INTRA_DOC_LINKS,\n-    CHECK_CODE_BLOCK_SYNTAX,\n-    PROPAGATE_DOC_CFG,\n+/// The list of default passes run when `--doc-coverage` is passed to rustdoc.\n+pub const COVERAGE_PASSES: &[ConditionalPass] = &[\n+    ConditionalPass::always(COLLECT_TRAIT_IMPLS),\n+    ConditionalPass::new(STRIP_HIDDEN, WhenNotDocumentHidden),\n+    ConditionalPass::new(STRIP_PRIVATE, WhenNotDocumentPrivate),\n+    ConditionalPass::always(CALCULATE_DOC_COVERAGE),\n ];\n \n-/// The list of default passes run when `--doc-coverage` is passed to rustdoc.\n-pub const DEFAULT_COVERAGE_PASSES: &[Pass] =\n-    &[COLLECT_TRAIT_IMPLS, STRIP_HIDDEN, STRIP_PRIVATE, CALCULATE_DOC_COVERAGE];\n+impl ConditionalPass {\n+    pub const fn always(pass: Pass) -> Self {\n+        Self::new(pass, Always)\n+    }\n \n-/// The list of default passes run when `--doc-coverage --document-private-items` is passed to\n-/// rustdoc.\n-pub const PRIVATE_COVERAGE_PASSES: &[Pass] = &[COLLECT_TRAIT_IMPLS, CALCULATE_DOC_COVERAGE];\n+    pub const fn new(pass: Pass, condition: Condition) -> Self {\n+        ConditionalPass { pass, condition }\n+    }\n+}\n \n /// A shorthand way to refer to which set of passes to use, based on the presence of\n-/// `--no-defaults` or `--document-private-items`.\n+/// `--no-defaults` and `--show-coverage`.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum DefaultPassOption {\n     Default,\n-    Private,\n     Coverage,\n-    PrivateCoverage,\n     None,\n }\n \n /// Returns the given default set of passes.\n-pub fn defaults(default_set: DefaultPassOption) -> &'static [Pass] {\n+pub fn defaults(default_set: DefaultPassOption) -> &'static [ConditionalPass] {\n     match default_set {\n         DefaultPassOption::Default => DEFAULT_PASSES,\n-        DefaultPassOption::Private => DEFAULT_PRIVATE_PASSES,\n-        DefaultPassOption::Coverage => DEFAULT_COVERAGE_PASSES,\n-        DefaultPassOption::PrivateCoverage => PRIVATE_COVERAGE_PASSES,\n+        DefaultPassOption::Coverage => COVERAGE_PASSES,\n         DefaultPassOption::None => &[],\n     }\n }\n \n /// If the given name matches a known pass, returns its information.\n-pub fn find_pass(pass_name: &str) -> Option<&'static Pass> {\n-    PASSES.iter().find(|p| p.name == pass_name)\n+pub fn find_pass(pass_name: &str) -> Option<Pass> {\n+    PASSES.iter().find(|p| p.name == pass_name).copied()\n }\n \n struct Stripper<'a> {"}, {"sha": "aec5a6bd4e221f8745ce722bff640007ff0cb671", "filename": "src/librustdoc/passes/private_items_doc_tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fpasses%2Fprivate_items_doc_tests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fpasses%2Fprivate_items_doc_tests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fprivate_items_doc_tests.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -5,7 +5,7 @@ use crate::passes::{look_for_tests, Pass};\n \n pub const CHECK_PRIVATE_ITEMS_DOC_TESTS: Pass = Pass {\n     name: \"check-private-items-doc-tests\",\n-    pass: check_private_items_doc_tests,\n+    run: check_private_items_doc_tests,\n     description: \"check private items doc tests\",\n };\n "}, {"sha": "64b0c45ba65d3a67a3ee27dc0837aca3268cfe8d", "filename": "src/librustdoc/passes/propagate_doc_cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -8,7 +8,7 @@ use crate::passes::Pass;\n \n pub const PROPAGATE_DOC_CFG: Pass = Pass {\n     name: \"propagate-doc-cfg\",\n-    pass: propagate_doc_cfg,\n+    run: propagate_doc_cfg,\n     description: \"propagates `#[doc(cfg(...))]` to child items\",\n };\n "}, {"sha": "f82e72b488bb764b753750a3273a0f3b4570871c", "filename": "src/librustdoc/passes/strip_hidden.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_hidden.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -10,7 +10,7 @@ use crate::passes::{ImplStripper, Pass};\n \n pub const STRIP_HIDDEN: Pass = Pass {\n     name: \"strip-hidden\",\n-    pass: strip_hidden,\n+    run: strip_hidden,\n     description: \"strips all doc(hidden) items from the output\",\n };\n "}, {"sha": "35b26fb8ab0be6633d33c882fa419fa518fe43b2", "filename": "src/librustdoc/passes/strip_priv_imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_priv_imports.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -5,7 +5,7 @@ use crate::passes::{ImportStripper, Pass};\n \n pub const STRIP_PRIV_IMPORTS: Pass = Pass {\n     name: \"strip-priv-imports\",\n-    pass: strip_priv_imports,\n+    run: strip_priv_imports,\n     description: \"strips all private import statements (`use`, `extern crate`) from a crate\",\n };\n "}, {"sha": "f244956e50336e0a24798bbff1534de76779b0d1", "filename": "src/librustdoc/passes/strip_private.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstrip_private.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -7,7 +7,7 @@ use crate::passes::{ImplStripper, ImportStripper, Pass, Stripper};\n \n pub const STRIP_PRIVATE: Pass = Pass {\n     name: \"strip-private\",\n-    pass: strip_private,\n+    run: strip_private,\n     description: \"strips all private items from a crate which cannot be seen externally, \\\n         implies strip-priv-imports\",\n };"}, {"sha": "d4e09ce47a3c1aa173e5c83e7c83664eb6d9f015", "filename": "src/librustdoc/passes/unindent_comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Funindent_comments.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -12,7 +12,7 @@ mod tests;\n \n pub const UNINDENT_COMMENTS: Pass = Pass {\n     name: \"unindent-comments\",\n-    pass: unindent_comments,\n+    run: unindent_comments,\n     description: \"removes excess indentation on comments in order for markdown to like it\",\n };\n "}, {"sha": "700e015b08edc0e282cdb288f0bc69a2cfec618c", "filename": "src/libstd/ffi/c_str.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibstd%2Fffi%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibstd%2Fffi%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fc_str.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -1187,11 +1187,6 @@ impl CStr {\n     /// function will return the corresponding [`&str`] slice. Otherwise,\n     /// it will return an error with details of where UTF-8 validation failed.\n     ///\n-    /// > **Note**: This method is currently implemented to check for validity\n-    /// > after a constant-time cast, but it is planned to alter its definition\n-    /// > in the future to perform the length calculation in addition to the\n-    /// > UTF-8 check whenever this method is called.\n-    ///\n     /// [`&str`]: ../primitive.str.html\n     ///\n     /// # Examples\n@@ -1220,11 +1215,6 @@ impl CStr {\n     /// [`U+FFFD REPLACEMENT CHARACTER`][U+FFFD] and return a\n     /// [`Cow`]`::`[`Owned`]`(`[`String`]`)` with the result.\n     ///\n-    /// > **Note**: This method is currently implemented to check for validity\n-    /// > after a constant-time cast, but it is planned to alter its definition\n-    /// > in the future to perform the length calculation in addition to the\n-    /// > UTF-8 check whenever this method is called.\n-    ///\n     /// [`Cow`]: ../borrow/enum.Cow.html\n     /// [`Borrowed`]: ../borrow/enum.Cow.html#variant.Borrowed\n     /// [`Owned`]: ../borrow/enum.Cow.html#variant.Owned"}, {"sha": "ab2a871b92df45f846d73d74432ddada4729a582", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 6, "deletions": 28, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -51,44 +51,22 @@ pub use crate::sys_common::fs::remove_dir_all;\n \n pub struct File(FileDesc);\n \n-// FIXME: This should be available on Linux with all `target_arch` and `target_env`.\n-// https://github.com/rust-lang/libc/issues/1545\n+// FIXME: This should be available on Linux with all `target_env`.\n+// But currently only glibc exposes `statx` fn and structs.\n+// We don't want to import unverified raw C structs here directly.\n+// https://github.com/rust-lang/rust/pull/67774\n macro_rules! cfg_has_statx {\n     ({ $($then_tt:tt)* } else { $($else_tt:tt)* }) => {\n         cfg_if::cfg_if! {\n-            if #[cfg(all(target_os = \"linux\", target_env = \"gnu\", any(\n-                target_arch = \"x86\",\n-                target_arch = \"arm\",\n-                // target_arch = \"mips\",\n-                target_arch = \"powerpc\",\n-                target_arch = \"x86_64\",\n-                // target_arch = \"aarch64\",\n-                target_arch = \"powerpc64\",\n-                // target_arch = \"mips64\",\n-                // target_arch = \"s390x\",\n-                target_arch = \"sparc64\",\n-                target_arch = \"riscv64\",\n-            )))] {\n+            if #[cfg(all(target_os = \"linux\", target_env = \"gnu\"))] {\n                 $($then_tt)*\n             } else {\n                 $($else_tt)*\n             }\n         }\n     };\n     ($($block_inner:tt)*) => {\n-        #[cfg(all(target_os = \"linux\", target_env = \"gnu\", any(\n-            target_arch = \"x86\",\n-            target_arch = \"arm\",\n-            // target_arch = \"mips\",\n-            target_arch = \"powerpc\",\n-            target_arch = \"x86_64\",\n-            // target_arch = \"aarch64\",\n-            target_arch = \"powerpc64\",\n-            // target_arch = \"mips64\",\n-            // target_arch = \"s390x\",\n-            target_arch = \"sparc64\",\n-            target_arch = \"riscv64\",\n-        )))]\n+        #[cfg(all(target_os = \"linux\", target_env = \"gnu\"))]\n         {\n             $($block_inner)*\n         }"}, {"sha": "12bbfa1d4e1a6e8151f71dd4fe57e0cbe119a0bf", "filename": "src/libstd/sys/vxworks/mod.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibstd%2Fsys%2Fvxworks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibstd%2Fsys%2Fvxworks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fmod.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -36,18 +36,10 @@ pub use crate::sys_common::os_str_bytes as os_str;\n \n #[cfg(not(test))]\n pub fn init() {\n-    // By default, some platforms will send a *signal* when an EPIPE error\n-    // would otherwise be delivered. This runtime doesn't install a SIGPIPE\n-    // handler, causing it to kill the program, which isn't exactly what we\n-    // want!\n-    //\n-    // Hence, we set SIGPIPE to ignore when the program starts up in order\n-    // to prevent this problem.\n+    // ignore SIGPIPE\n     unsafe {\n-        reset_sigpipe();\n+        assert!(signal(libc::SIGPIPE, libc::SIG_IGN) != libc::SIG_ERR);\n     }\n-\n-    unsafe fn reset_sigpipe() {}\n }\n \n pub use libc::signal;"}, {"sha": "4c6fddefd3f84c938e2a1ff2a6ffad202022e421", "filename": "src/libstd/sys/vxworks/weak.rs", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ed6468da160bd67a2ce0573427f09a98daff8c07/src%2Flibstd%2Fsys%2Fvxworks%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed6468da160bd67a2ce0573427f09a98daff8c07/src%2Flibstd%2Fsys%2Fvxworks%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fvxworks%2Fweak.rs?ref=ed6468da160bd67a2ce0573427f09a98daff8c07", "patch": "@@ -1,56 +0,0 @@\n-//! Support for \"weak linkage\" to symbols on Unix\n-//!\n-//! Some I/O operations we do in libstd require newer versions of OSes but we\n-//! need to maintain binary compatibility with older releases for now. In order\n-//! to use the new functionality when available we use this module for\n-//! detection.\n-//!\n-//! One option to use here is weak linkage, but that is unfortunately only\n-//! really workable on Linux. Hence, use dlsym to get the symbol value at\n-//! runtime. This is also done for compatibility with older versions of glibc,\n-//! and to avoid creating dependencies on GLIBC_PRIVATE symbols. It assumes that\n-//! we've been dynamically linked to the library the symbol comes from, but that\n-//! is currently always the case for things like libpthread/libc.\n-//!\n-//! A long time ago this used weak linkage for the __pthread_get_minstack\n-//! symbol, but that caused Debian to detect an unnecessarily strict versioned\n-//! dependency on libc6 (#23628).\n-\n-use crate::ffi::CStr;\n-use crate::marker;\n-use crate::mem;\n-use crate::sync::atomic::{AtomicUsize, Ordering};\n-\n-pub struct Weak<F> {\n-    name: &'static str,\n-    addr: AtomicUsize,\n-    _marker: marker::PhantomData<F>,\n-}\n-\n-impl<F> Weak<F> {\n-    pub const fn new(name: &'static str) -> Weak<F> {\n-        Weak { name, addr: AtomicUsize::new(1), _marker: marker::PhantomData }\n-    }\n-\n-    pub fn get(&self) -> Option<F> {\n-        assert_eq!(mem::size_of::<F>(), mem::size_of::<usize>());\n-        unsafe {\n-            if self.addr.load(Ordering::SeqCst) == 1 {\n-                self.addr.store(fetch(self.name), Ordering::SeqCst);\n-            }\n-            match self.addr.load(Ordering::SeqCst) {\n-                0 => None,\n-                addr => Some(mem::transmute_copy::<usize, F>(&addr)),\n-            }\n-        }\n-    }\n-}\n-\n-unsafe fn fetch(name: &str) -> usize {\n-    let name = match CStr::from_bytes_with_nul(name.as_bytes()) {\n-        Ok(cstr) => cstr,\n-        Err(..) => return 0,\n-    };\n-    assert!(false, \"FIXME: fetch\");\n-    libc::dlsym(libc::RTLD_DEFAULT, name.as_ptr()) as usize\n-}"}, {"sha": "cce86fed9891c14fe3b4e5c8e44d556338df3271", "filename": "src/libsyntax/util/lev_distance.rs", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibsyntax%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibsyntax%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Flev_distance.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -54,14 +54,16 @@ where\n     T: Iterator<Item = &'a Symbol>,\n {\n     let max_dist = dist.map_or_else(|| cmp::max(lookup.len(), 3) / 3, |d| d);\n+    let name_vec: Vec<&Symbol> = iter_names.collect();\n \n-    let (case_insensitive_match, levenstein_match) = iter_names\n+    let (case_insensitive_match, levenshtein_match) = name_vec\n+        .iter()\n         .filter_map(|&name| {\n             let dist = lev_distance(lookup, &name.as_str());\n             if dist <= max_dist { Some((name, dist)) } else { None }\n         })\n         // Here we are collecting the next structure:\n-        // (case_insensitive_match, (levenstein_match, levenstein_distance))\n+        // (case_insensitive_match, (levenshtein_match, levenshtein_distance))\n         .fold((None, None), |result, (candidate, dist)| {\n             (\n                 if candidate.as_str().to_uppercase() == lookup.to_uppercase() {\n@@ -75,10 +77,31 @@ where\n                 },\n             )\n         });\n-\n+    // Priority of matches:\n+    // 1. Exact case insensitive match\n+    // 2. Levenshtein distance match\n+    // 3. Sorted word match\n     if let Some(candidate) = case_insensitive_match {\n-        Some(candidate) // exact case insensitive match has a higher priority\n+        Some(*candidate)\n+    } else if levenshtein_match.is_some() {\n+        levenshtein_match.map(|(candidate, _)| *candidate)\n     } else {\n-        levenstein_match.map(|(candidate, _)| candidate)\n+        find_match_by_sorted_words(name_vec, lookup)\n     }\n }\n+\n+fn find_match_by_sorted_words<'a>(iter_names: Vec<&'a Symbol>, lookup: &str) -> Option<Symbol> {\n+    iter_names.iter().fold(None, |result, candidate| {\n+        if sort_by_words(&candidate.as_str()) == sort_by_words(lookup) {\n+            Some(**candidate)\n+        } else {\n+            result\n+        }\n+    })\n+}\n+\n+fn sort_by_words(name: &str) -> String {\n+    let mut split_words: Vec<&str> = name.split('_').collect();\n+    split_words.sort();\n+    split_words.join(\"_\")\n+}"}, {"sha": "222661687c1c29d459d3eb7baee0a60b6e019548", "filename": "src/libsyntax/util/lev_distance/tests.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibsyntax%2Futil%2Flev_distance%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Flibsyntax%2Futil%2Flev_distance%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Flev_distance%2Ftests.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -46,5 +46,11 @@ fn test_find_best_match_for_name() {\n             find_best_match_for_name(input.iter(), \"aaaa\", Some(4)),\n             Some(Symbol::intern(\"AAAA\"))\n         );\n+\n+        let input = vec![Symbol::intern(\"a_longer_variable_name\")];\n+        assert_eq!(\n+            find_best_match_for_name(input.iter(), \"a_variable_longer_name\", None),\n+            Some(Symbol::intern(\"a_longer_variable_name\"))\n+        );\n     })\n }"}, {"sha": "9ccc5d7882eb8d5e781d7bef316eeb20c3b386ba", "filename": "src/test/rustdoc/duplicate-cfg.rs", "status": "modified", "additions": 30, "deletions": 3, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Ftest%2Frustdoc%2Fduplicate-cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Ftest%2Frustdoc%2Fduplicate-cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fduplicate-cfg.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -1,15 +1,42 @@\n+// ignore-tidy-linelength\n+\n #![crate_name = \"foo\"]\n #![feature(doc_cfg)]\n \n-// @has 'foo/index.html'\n-// @!has '-' '//*[@class=\"stab portability\"]' 'feature=\"sync\" and'\n-// @has '-' '//*[@class=\"stab portability\"]' 'feature=\"sync\"'\n+// @has 'foo/struct.Foo.html'\n+// @has '-' '//*[@class=\"stab portability\"]' 'This is supported on feature=\"sync\" only.'\n #[doc(cfg(feature = \"sync\"))]\n #[doc(cfg(feature = \"sync\"))]\n pub struct Foo;\n \n+// @has 'foo/bar/struct.Bar.html'\n+// @has '-' '//*[@class=\"stab portability\"]' 'This is supported on feature=\"sync\" only.'\n #[doc(cfg(feature = \"sync\"))]\n pub mod bar {\n     #[doc(cfg(feature = \"sync\"))]\n     pub struct Bar;\n }\n+\n+// @has 'foo/baz/struct.Baz.html'\n+// @has '-' '//*[@class=\"stab portability\"]' 'This is supported on feature=\"sync\" and feature=\"send\" only.'\n+#[doc(cfg(all(feature = \"sync\", feature = \"send\")))]\n+pub mod baz {\n+    #[doc(cfg(feature = \"sync\"))]\n+    pub struct Baz;\n+}\n+\n+// @has 'foo/qux/struct.Qux.html'\n+// @has '-' '//*[@class=\"stab portability\"]' 'This is supported on feature=\"sync\" and feature=\"send\" only.'\n+#[doc(cfg(feature = \"sync\"))]\n+pub mod qux {\n+    #[doc(cfg(all(feature = \"sync\", feature = \"send\")))]\n+    pub struct Qux;\n+}\n+\n+// @has 'foo/quux/struct.Quux.html'\n+// @has '-' '//*[@class=\"stab portability\"]' 'This is supported on feature=\"sync\" and feature=\"send\" and foo and bar only.'\n+#[doc(cfg(all(feature = \"sync\", feature = \"send\", foo)))]\n+pub mod quux {\n+    #[doc(cfg(all(feature = \"send\", feature = \"sync\", bar)))]\n+    pub struct Quux;\n+}"}, {"sha": "8837a6b463e8835f3fb12a91a4c3d6fc71468d09", "filename": "src/test/rustdoc/issue-46380.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ed6468da160bd67a2ce0573427f09a98daff8c07/src%2Ftest%2Frustdoc%2Fissue-46380.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ed6468da160bd67a2ce0573427f09a98daff8c07/src%2Ftest%2Frustdoc%2Fissue-46380.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-46380.rs?ref=ed6468da160bd67a2ce0573427f09a98daff8c07", "patch": "@@ -1,5 +0,0 @@\n-// compile-flags: --document-private-items\n-\n-// @has issue_46380/struct.Hidden.html\n-#[doc(hidden)]\n-pub struct Hidden;"}, {"sha": "d69b943173412e18343f30d61d9013ea2f55fcbb", "filename": "src/test/rustdoc/issue-67851-both.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Ftest%2Frustdoc%2Fissue-67851-both.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Ftest%2Frustdoc%2Fissue-67851-both.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-67851-both.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -0,0 +1,8 @@\n+// compile-flags: -Zunstable-options --document-private-items --document-hidden-items\n+\n+// @has issue_67851_both/struct.Hidden.html\n+#[doc(hidden)]\n+pub struct Hidden;\n+\n+// @has issue_67851_both/struct.Private.html\n+struct Private;"}, {"sha": "8a3cafe4c3dc7775621b139c7c26f50b28f176d5", "filename": "src/test/rustdoc/issue-67851-hidden.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Ftest%2Frustdoc%2Fissue-67851-hidden.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Ftest%2Frustdoc%2Fissue-67851-hidden.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-67851-hidden.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -0,0 +1,8 @@\n+// compile-flags: -Zunstable-options --document-hidden-items\n+\n+// @has issue_67851_hidden/struct.Hidden.html\n+#[doc(hidden)]\n+pub struct Hidden;\n+\n+// @!has issue_67851_hidden/struct.Private.html\n+struct Private;"}, {"sha": "4e3cd832853881d0fbe4152511572308ce818815", "filename": "src/test/rustdoc/issue-67851-neither.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Ftest%2Frustdoc%2Fissue-67851-neither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Ftest%2Frustdoc%2Fissue-67851-neither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-67851-neither.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -0,0 +1,6 @@\n+// @!has issue_67851_neither/struct.Hidden.html\n+#[doc(hidden)]\n+pub struct Hidden;\n+\n+// @!has issue_67851_neither/struct.Private.html\n+struct Private;"}, {"sha": "8addc7f3e4b53c0d2fe138a90c50ab41f6e1dfb1", "filename": "src/test/rustdoc/issue-67851-private.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Ftest%2Frustdoc%2Fissue-67851-private.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Ftest%2Frustdoc%2Fissue-67851-private.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-67851-private.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -0,0 +1,8 @@\n+// compile-flags: --document-private-items\n+\n+// @!has issue_67851_private/struct.Hidden.html\n+#[doc(hidden)]\n+pub struct Hidden;\n+\n+// @has issue_67851_private/struct.Private.html\n+struct Private;"}, {"sha": "be13076b8af52cf952d0b186f3081b38e6c36819", "filename": "src/test/ui/rfc-2091-track-caller/std-panic-locations.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fstd-panic-locations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fstd-panic-locations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2091-track-caller%2Fstd-panic-locations.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -0,0 +1,38 @@\n+// run-pass\n+// ignore-wasm32-bare compiled with panic=abort by default\n+\n+#![feature(option_expect_none, option_unwrap_none)]\n+\n+//! Test that panic locations for `#[track_caller]` functions in std have the correct\n+//! location reported.\n+\n+fn main() {\n+    // inspect the `PanicInfo` we receive to ensure the right file is the source\n+    std::panic::set_hook(Box::new(|info| {\n+        let actual = info.location().unwrap();\n+        if actual.file() != file!() {\n+            eprintln!(\"expected a location in the test file, found {:?}\", actual);\n+            panic!();\n+        }\n+    }));\n+\n+    fn assert_panicked(f: impl FnOnce() + std::panic::UnwindSafe) {\n+        std::panic::catch_unwind(f).unwrap_err();\n+    }\n+\n+    let nope: Option<()> = None;\n+    assert_panicked(|| nope.unwrap());\n+    assert_panicked(|| nope.expect(\"\"));\n+\n+    let yep: Option<()> = Some(());\n+    assert_panicked(|| yep.unwrap_none());\n+    assert_panicked(|| yep.expect_none(\"\"));\n+\n+    let oops: Result<(), ()> = Err(());\n+    assert_panicked(|| oops.unwrap());\n+    assert_panicked(|| oops.expect(\"\"));\n+\n+    let fine: Result<(), ()> = Ok(());\n+    assert_panicked(|| fine.unwrap_err());\n+    assert_panicked(|| fine.expect_err(\"\"));\n+}"}, {"sha": "440bb653a83c3c85f432b3f2549b33caf345679f", "filename": "src/test/ui/suggestions/issue-66968-suggest-sorted-words.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Ftest%2Fui%2Fsuggestions%2Fissue-66968-suggest-sorted-words.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Ftest%2Fui%2Fsuggestions%2Fissue-66968-suggest-sorted-words.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-66968-suggest-sorted-words.rs?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    let a_longer_variable_name = 1;\n+    println!(\"{}\", a_variable_longer_name); //~ ERROR E0425\n+}"}, {"sha": "d7b33ea41f79a06c25098507a58daed2dc39abde", "filename": "src/test/ui/suggestions/issue-66968-suggest-sorted-words.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Ftest%2Fui%2Fsuggestions%2Fissue-66968-suggest-sorted-words.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/caa231d998a5e853c7ba1455d7a05b500df9d63c/src%2Ftest%2Fui%2Fsuggestions%2Fissue-66968-suggest-sorted-words.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-66968-suggest-sorted-words.stderr?ref=caa231d998a5e853c7ba1455d7a05b500df9d63c", "patch": "@@ -0,0 +1,9 @@\n+error[E0425]: cannot find value `a_variable_longer_name` in this scope\n+  --> $DIR/issue-66968-suggest-sorted-words.rs:3:20\n+   |\n+LL |     println!(\"{}\", a_variable_longer_name);\n+   |                    ^^^^^^^^^^^^^^^^^^^^^^ help: a local variable with a similar name exists: `a_longer_variable_name`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0425`."}]}