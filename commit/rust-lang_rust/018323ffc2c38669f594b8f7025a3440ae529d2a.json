{"sha": "018323ffc2c38669f594b8f7025a3440ae529d2a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxODMyM2ZmYzJjMzg2NjlmNTk0YjhmNzAyNWEzNDQwYWU1MjlkMmE=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-22T22:54:45Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:32Z"}, "message": "rustc: collapse the remains of Layout into Variants (enums vs everything else).", "tree": {"sha": "0852579792f5b3fe532e99333e5e46983ffb1402", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0852579792f5b3fe532e99333e5e46983ffb1402"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/018323ffc2c38669f594b8f7025a3440ae529d2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/018323ffc2c38669f594b8f7025a3440ae529d2a", "html_url": "https://github.com/rust-lang/rust/commit/018323ffc2c38669f594b8f7025a3440ae529d2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/018323ffc2c38669f594b8f7025a3440ae529d2a/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b28f668e267d6b463439e776c335f45508f5c1ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/b28f668e267d6b463439e776c335f45508f5c1ad", "html_url": "https://github.com/rust-lang/rust/commit/b28f668e267d6b463439e776c335f45508f5c1ad"}], "stats": {"total": 424, "additions": 188, "deletions": 236}, "files": [{"sha": "bfde8a58e4911be884cd0af4f08d18a6cd327adb", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 64, "deletions": 122, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/018323ffc2c38669f594b8f7025a3440ae529d2a/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018323ffc2c38669f594b8f7025a3440ae529d2a/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=018323ffc2c38669f594b8f7025a3440ae529d2a", "patch": "@@ -769,33 +769,17 @@ impl Abi {\n     }\n }\n \n-/// Type layout, from which size and alignment can be cheaply computed.\n-/// For ADTs, it also includes field placement and enum optimizations.\n-/// NOTE: Because Layout is interned, redundant information should be\n-/// kept to a minimum, e.g. it includes no sub-component Ty or Layout.\n #[derive(PartialEq, Eq, Hash, Debug)]\n-pub enum Layout {\n-    /// TyBool, TyChar, TyInt, TyUint, TyFloat, TyRawPtr, TyRef or TyFnPtr.\n-    Scalar,\n-\n-    /// SIMD vectors, from structs marked with #[repr(simd)].\n-    Vector,\n-\n-    /// TyArray, TySlice or TyStr.\n-    Array,\n-\n-    // Remaining variants are all ADTs such as structs, enums or tuples.\n-\n-    /// Single-case enums, and structs/tuples.\n-    Univariant,\n-\n-    /// Untagged unions.\n-    UntaggedUnion,\n+pub enum Variants {\n+    /// Single enum variants, structs/tuples, unions, and all non-ADTs.\n+    Single {\n+        index: usize\n+    },\n \n     /// General-case enums: for each case there is a struct, and they all have\n     /// all space reserved for the discriminant, and their first field starts\n     /// at a non-0 offset, after where the discriminant would go.\n-    General {\n+    Tagged {\n         discr: Primitive,\n         /// Inclusive wrap-around range of discriminant values, that is,\n         /// if min > max, it represents min..=u64::MAX followed by 0..=max.\n@@ -806,15 +790,15 @@ pub enum Layout {\n         variants: Vec<CachedLayout>,\n     },\n \n-    /// Two cases distinguished by a nullable pointer: the case with discriminant\n+    /// Two cases distinguished by a niche: the case with discriminant\n     /// `nndiscr` is represented by the struct `nonnull`, where field `0`\n     /// is known to be nonnull due to its type; if that field is null, then\n     /// it represents the other case, which is known to be zero sized.\n     ///\n     /// For example, `std::option::Option` instantiated at a safe pointer type\n     /// is represented such that `None` is a null pointer and `Some` is the\n     /// identity function.\n-    NullablePointer {\n+    NicheFilling {\n         nndiscr: u64,\n         discr: Primitive,\n         variants: Vec<CachedLayout>,\n@@ -842,8 +826,7 @@ impl<'tcx> fmt::Display for LayoutError<'tcx> {\n \n #[derive(PartialEq, Eq, Hash, Debug)]\n pub struct CachedLayout {\n-    pub variant_index: Option<usize>,\n-    pub layout: Layout,\n+    pub variants: Variants,\n     pub fields: FieldPlacement,\n     pub abi: Abi,\n     pub align: Align,\n@@ -865,7 +848,7 @@ fn layout_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     tcx.layout_depth.set(depth+1);\n-    let layout = Layout::compute_uncached(tcx, param_env, ty);\n+    let layout = CachedLayout::compute_uncached(tcx, param_env, ty);\n     tcx.layout_depth.set(depth);\n \n     layout\n@@ -878,18 +861,17 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n     };\n }\n \n-impl<'a, 'tcx> Layout {\n+impl<'a, 'tcx> CachedLayout {\n     fn compute_uncached(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         param_env: ty::ParamEnv<'tcx>,\n                         ty: Ty<'tcx>)\n-                        -> Result<&'tcx CachedLayout, LayoutError<'tcx>> {\n+                        -> Result<&'tcx Self, LayoutError<'tcx>> {\n         let cx = (tcx, param_env);\n         let dl = cx.data_layout();\n         let scalar = |value: Primitive| {\n             let align = value.align(dl);\n             tcx.intern_layout(CachedLayout {\n-                variant_index: None,\n-                layout: Layout::Scalar,\n+                variants: Variants::Single { index: 0 },\n                 fields: FieldPlacement::Union(0),\n                 abi: Abi::Scalar(value),\n                 size: value.size(dl),\n@@ -1028,8 +1010,7 @@ impl<'a, 'tcx> Layout {\n             }\n \n             Ok(CachedLayout {\n-                variant_index: None,\n-                layout: Layout::Univariant,\n+                variants: Variants::Single { index: 0 },\n                 fields: FieldPlacement::Arbitrary {\n                     offsets,\n                     memory_index\n@@ -1073,8 +1054,7 @@ impl<'a, 'tcx> Layout {\n                 memory_index: vec![0, 1]\n             };\n             Ok(tcx.intern_layout(CachedLayout {\n-                variant_index: None,\n-                layout: Layout::Univariant,\n+                variants: Variants::Single { index: 0 },\n                 fields,\n                 abi: Abi::Aggregate {\n                     sized: true,\n@@ -1129,8 +1109,7 @@ impl<'a, 'tcx> Layout {\n                     .ok_or(LayoutError::SizeOverflow(ty))?;\n \n                 tcx.intern_layout(CachedLayout {\n-                    variant_index: None,\n-                    layout: Layout::Array,\n+                    variants: Variants::Single { index: 0 },\n                     fields: FieldPlacement::Array {\n                         stride: element.size,\n                         count\n@@ -1147,8 +1126,7 @@ impl<'a, 'tcx> Layout {\n             ty::TySlice(element) => {\n                 let element = cx.layout_of(element)?;\n                 tcx.intern_layout(CachedLayout {\n-                    variant_index: None,\n-                    layout: Layout::Array,\n+                    variants: Variants::Single { index: 0 },\n                     fields: FieldPlacement::Array {\n                         stride: element.size,\n                         count: 0\n@@ -1164,8 +1142,7 @@ impl<'a, 'tcx> Layout {\n             }\n             ty::TyStr => {\n                 tcx.intern_layout(CachedLayout {\n-                    variant_index: None,\n-                    layout: Layout::Array,\n+                    variants: Variants::Single { index: 0 },\n                     fields: FieldPlacement::Array {\n                         stride: Size::from_bytes(1),\n                         count: 0\n@@ -1238,8 +1215,7 @@ impl<'a, 'tcx> Layout {\n                 let size = size.abi_align(align);\n \n                 tcx.intern_layout(CachedLayout {\n-                    variant_index: None,\n-                    layout: Layout::Vector,\n+                    variants: Variants::Single { index: 0 },\n                     fields: FieldPlacement::Array {\n                         stride: element.size,\n                         count\n@@ -1302,8 +1278,7 @@ impl<'a, 'tcx> Layout {\n                     }\n \n                     return Ok(tcx.intern_layout(CachedLayout {\n-                        variant_index: None,\n-                        layout: Layout::UntaggedUnion,\n+                        variants: Variants::Single { index: 0 },\n                         fields: FieldPlacement::Union(variants[0].len()),\n                         abi: Abi::Aggregate {\n                             sized: true,\n@@ -1332,11 +1307,7 @@ impl<'a, 'tcx> Layout {\n                         else { StructKind::AlwaysSized }\n                     };\n \n-                    let mut cached = univariant_uninterned(&variants[0], &def.repr, kind)?;\n-                    if def.is_enum() {\n-                        cached.variant_index = Some(0);\n-                    }\n-                    return Ok(tcx.intern_layout(cached));\n+                    return univariant(&variants[0], &def.repr, kind);\n                 }\n \n                 let no_explicit_discriminants = def.variants.iter().enumerate()\n@@ -1359,8 +1330,9 @@ impl<'a, 'tcx> Layout {\n                                     univariant_uninterned(&variants[1],\n                                         &def.repr, StructKind::AlwaysSized)?\n                                 ];\n-                                st[0].variant_index = Some(0);\n-                                st[1].variant_index = Some(1);\n+                                for (i, v) in st.iter_mut().enumerate() {\n+                                    v.variants = Variants::Single { index: i };\n+                                }\n                                 let offset = st[i].fields.offset(field_index) + offset;\n                                 let CachedLayout {\n                                     mut abi,\n@@ -1383,8 +1355,7 @@ impl<'a, 'tcx> Layout {\n                                 primitive_align = primitive_align.max(discr_align);\n \n                                 return Ok(tcx.intern_layout(CachedLayout {\n-                                    variant_index: None,\n-                                    layout: Layout::NullablePointer {\n+                                    variants: Variants::NicheFilling {\n                                         nndiscr: i as u64,\n \n                                         discr,\n@@ -1426,7 +1397,7 @@ impl<'a, 'tcx> Layout {\n                 let mut variants = variants.into_iter().enumerate().map(|(i, field_layouts)| {\n                     let mut st = univariant_uninterned(&field_layouts,\n                         &def.repr, StructKind::EnumVariant(min_ity))?;\n-                    st.variant_index = Some(i);\n+                    st.variants = Variants::Single { index: i };\n                     // Find the first field we can't move later\n                     // to make room for a larger discriminant.\n                     for field in st.fields.index_by_increasing_offset().map(|j| field_layouts[j]) {\n@@ -1506,8 +1477,7 @@ impl<'a, 'tcx> Layout {\n \n                 let discr = Int(ity, signed);\n                 tcx.intern_layout(CachedLayout {\n-                    variant_index: None,\n-                    layout: Layout::General {\n+                    variants: Variants::Tagged {\n                         discr,\n \n                         // FIXME: should be u128?\n@@ -1544,7 +1514,7 @@ impl<'a, 'tcx> Layout {\n                 return Err(LayoutError::Unknown(ty));\n             }\n             ty::TyInfer(_) | ty::TyError => {\n-                bug!(\"Layout::compute: unexpected type `{}`\", ty)\n+                bug!(\"CachedLayout::compute: unexpected type `{}`\", ty)\n             }\n         })\n     }\n@@ -1650,8 +1620,8 @@ impl<'a, 'tcx> Layout {\n             }\n         };\n \n-        match layout.layout {\n-            Layout::Univariant => {\n+        match layout.variants {\n+            Variants::Single { .. } => {\n                 let variant_names = || {\n                     adt_def.variants.iter().map(|v|format!(\"{}\", v.name)).collect::<Vec<_>>()\n                 };\n@@ -1675,8 +1645,8 @@ impl<'a, 'tcx> Layout {\n                 }\n             }\n \n-            Layout::NullablePointer { .. } |\n-            Layout::General { .. } => {\n+            Variants::NicheFilling { .. } |\n+            Variants::Tagged { .. } => {\n                 debug!(\"print-type-size `{:#?}` adt general variants def {}\",\n                        ty, adt_def.variants.len());\n                 let variant_infos: Vec<_> =\n@@ -1688,27 +1658,11 @@ impl<'a, 'tcx> Layout {\n                                             layout.for_variant(i))\n                     })\n                     .collect();\n-                record(adt_kind.into(), match layout.layout {\n-                    Layout::General { discr, .. } => Some(discr.size(tcx)),\n+                record(adt_kind.into(), match layout.variants {\n+                    Variants::Tagged { discr, .. } => Some(discr.size(tcx)),\n                     _ => None\n                 }, variant_infos);\n             }\n-\n-            Layout::UntaggedUnion => {\n-                debug!(\"print-type-size t: `{:?}` adt union\", ty);\n-                // layout does not currently store info about each\n-                // variant...\n-                record(adt_kind.into(), None, Vec::new());\n-            }\n-\n-            // other cases provide little interesting (i.e. adjustable\n-            // via representation tweaks) size info beyond total size.\n-            Layout::Scalar |\n-            Layout::Vector |\n-            Layout::Array => {\n-                debug!(\"print-type-size t: `{:?}` adt other\", ty);\n-                record(adt_kind.into(), None, Vec::new())\n-            }\n         }\n     }\n }\n@@ -1950,7 +1904,7 @@ impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for (TyCtxt<'a, 'tcx, 'tcx>, ty::ParamEnv<'tcx\n         // completed, to avoid problems around recursive structures\n         // and the like. (Admitedly, I wasn't able to reproduce a problem\n         // here, but it seems like the right thing to do. -nmatsakis)\n-        Layout::record_layout_for_printing(tcx, ty, param_env, layout);\n+        CachedLayout::record_layout_for_printing(tcx, ty, param_env, layout);\n \n         Ok(layout)\n     }\n@@ -1979,23 +1933,23 @@ impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for (ty::maps::TyCtxtAt<'a, 'tcx, 'tcx>,\n         // completed, to avoid problems around recursive structures\n         // and the like. (Admitedly, I wasn't able to reproduce a problem\n         // here, but it seems like the right thing to do. -nmatsakis)\n-        Layout::record_layout_for_printing(tcx_at.tcx, ty, param_env, layout);\n+        CachedLayout::record_layout_for_printing(tcx_at.tcx, ty, param_env, layout);\n \n         Ok(layout)\n     }\n }\n \n impl<'a, 'tcx> TyLayout<'tcx> {\n     pub fn for_variant(&self, variant_index: usize) -> Self {\n-        let cached = match self.layout {\n-            Layout::NullablePointer { ref variants, .. } |\n-            Layout::General { ref variants, .. } => {\n+        let cached = match self.variants {\n+            Variants::Single { .. } => self.cached,\n+\n+            Variants::NicheFilling { ref variants, .. } |\n+            Variants::Tagged { ref variants, .. } => {\n                 &variants[variant_index]\n             }\n-\n-            _ => self.cached\n         };\n-        assert_eq!(cached.variant_index, Some(variant_index));\n+        assert_eq!(cached.variants, Variants::Single { index: variant_index });\n \n         TyLayout {\n             ty: self.ty,\n@@ -2081,26 +2035,17 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n \n             // ADTs.\n             ty::TyAdt(def, substs) => {\n-                let v = if def.is_enum() {\n-                    match self.variant_index {\n-                        None => match self.layout {\n-                            // Discriminant field for enums (where applicable).\n-                            Layout::General { discr, .. } |\n-                            Layout::NullablePointer { discr, .. } => {\n-                                return cx.layout_of([discr.to_ty(tcx)][i]);\n-                            }\n-                            _ => {\n-                                bug!(\"TyLayout::field_type: enum `{}` has no discriminant\",\n-                                     self.ty)\n-                            }\n-                        },\n-                        Some(v) => v\n+                match self.variants {\n+                    Variants::Single { index } => {\n+                        def.variants[index].fields[i].ty(tcx, substs)\n                     }\n-                } else {\n-                    0\n-                };\n \n-                def.variants[v].fields[i].ty(tcx, substs)\n+                    // Discriminant field for enums (where applicable).\n+                    Variants::Tagged { discr, .. } |\n+                    Variants::NicheFilling { discr, .. } => {\n+                        return cx.layout_of([discr.to_ty(tcx)][i]);\n+                    }\n+                }\n             }\n \n             ty::TyProjection(_) | ty::TyAnon(..) | ty::TyParam(_) |\n@@ -2143,18 +2088,18 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n                  HasTyCtxt<'tcx>\n     {\n         let tcx = cx.tcx();\n-        match (&self.layout, self.abi, &self.ty.sty) {\n+        match (&self.variants, self.abi, &self.ty.sty) {\n             // FIXME(eddyb) check this via value ranges on scalars.\n-            (&Layout::Scalar, Abi::Scalar(Pointer), &ty::TyRef(..)) |\n-            (&Layout::Scalar, Abi::Scalar(Pointer), &ty::TyFnPtr(..)) => {\n+            (_, Abi::Scalar(Pointer), &ty::TyRef(..)) |\n+            (_, Abi::Scalar(Pointer), &ty::TyFnPtr(..)) => {\n                 Ok(Some((Size::from_bytes(0), Pointer)))\n             }\n-            (&Layout::Scalar, Abi::Scalar(Pointer), &ty::TyAdt(def, _)) if def.is_box() => {\n+            (_, Abi::Scalar(Pointer), &ty::TyAdt(def, _)) if def.is_box() => {\n                 Ok(Some((Size::from_bytes(0), Pointer)))\n             }\n \n             // FIXME(eddyb) check this via value ranges on scalars.\n-            (&Layout::General { discr, .. }, _, &ty::TyAdt(def, _)) => {\n+            (&Variants::Tagged { discr, .. }, _, &ty::TyAdt(def, _)) => {\n                 if def.discriminants(tcx).all(|d| d.to_u128_unchecked() != 0) {\n                     Ok(Some((self.fields.offset(0), discr)))\n                 } else {\n@@ -2196,20 +2141,18 @@ impl<'a, 'tcx> TyLayout<'tcx> {\n     }\n }\n \n-impl<'gcx> HashStable<StableHashingContext<'gcx>> for Layout {\n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for Variants {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'gcx>,\n                                           hasher: &mut StableHasher<W>) {\n-        use ty::layout::Layout::*;\n+        use ty::layout::Variants::*;\n         mem::discriminant(self).hash_stable(hcx, hasher);\n \n         match *self {\n-            Scalar => {}\n-            Vector => {}\n-            Array => {}\n-            Univariant => {}\n-            UntaggedUnion => {}\n-            General {\n+            Single { index } => {\n+                index.hash_stable(hcx, hasher);\n+            }\n+            Tagged {\n                 discr,\n                 discr_range: RangeInclusive { start, end },\n                 ref variants,\n@@ -2219,7 +2162,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Layout {\n                 end.hash_stable(hcx, hasher);\n                 variants.hash_stable(hcx, hasher);\n             }\n-            NullablePointer {\n+            NicheFilling {\n                 nndiscr,\n                 ref variants,\n                 ref discr,\n@@ -2279,8 +2222,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for Abi {\n }\n \n impl_stable_hash_for!(struct ::ty::layout::CachedLayout {\n-    variant_index,\n-    layout,\n+    variants,\n     fields,\n     abi,\n     size,"}, {"sha": "46debcce95843e053b1462bb3f573537b157f4ac", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/018323ffc2c38669f594b8f7025a3440ae529d2a/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018323ffc2c38669f594b8f7025a3440ae529d2a/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=018323ffc2c38669f594b8f7025a3440ae529d2a", "patch": "@@ -13,7 +13,7 @@\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, AdtKind, Ty, TyCtxt};\n-use rustc::ty::layout::{Layout, LayoutOf};\n+use rustc::ty::layout::{self, LayoutOf};\n use middle::const_val::ConstVal;\n use rustc_const_eval::ConstContext;\n use util::nodemap::FxHashSet;\n@@ -753,7 +753,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n                     bug!(\"failed to get layout for `{}`: {}\", t, e)\n                 });\n \n-                if let Layout::General { ref variants, discr, .. } = layout.layout {\n+                if let layout::Variants::Tagged { ref variants, discr, .. } = layout.variants {\n                     let discr_size = discr.size(cx.tcx).bytes();\n \n                     debug!(\"enum `{}` is {} bytes large with layout:\\n{:#?}\","}, {"sha": "d5a51fa1863e290a35ef512742dee9170179bb4a", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/018323ffc2c38669f594b8f7025a3440ae529d2a/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018323ffc2c38669f594b8f7025a3440ae529d2a/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=018323ffc2c38669f594b8f7025a3440ae529d2a", "patch": "@@ -14,7 +14,7 @@\n use abi::{ArgType, ArgAttribute, CastTarget, FnType, LayoutExt, Reg, RegKind};\n use context::CrateContext;\n \n-use rustc::ty::layout::{self, Layout, TyLayout, Size};\n+use rustc::ty::layout::{self, TyLayout, Size};\n \n #[derive(Clone, Copy, PartialEq, Debug)]\n enum Class {\n@@ -87,17 +87,15 @@ fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n             }\n \n             layout::Abi::Aggregate { .. } => {\n-                // FIXME(eddyb) have to work around Rust enums for now.\n-                // Fix is either guarantee no data where there is no field,\n-                // by putting variants in fields, or be more clever.\n-                match layout.layout {\n-                    Layout::General { .. } |\n-                    Layout::NullablePointer { .. } => return Err(Memory),\n-                    _ => {}\n-                }\n-                for i in 0..layout.fields.count() {\n-                    let field_off = off + layout.fields.offset(i);\n-                    classify(ccx, layout.field(ccx, i), cls, field_off)?;\n+                match layout.variants {\n+                    layout::Variants::Single { .. } => {\n+                        for i in 0..layout.fields.count() {\n+                            let field_off = off + layout.fields.offset(i);\n+                            classify(ccx, layout.field(ccx, i), cls, field_off)?;\n+                        }\n+                    }\n+                    layout::Variants::Tagged { .. } |\n+                    layout::Variants::NicheFilling { .. } => return Err(Memory),\n                 }\n             }\n "}, {"sha": "a905d35f3d3265b51cba449a037af68717b20ccf", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 48, "deletions": 50, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/018323ffc2c38669f594b8f7025a3440ae529d2a/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018323ffc2c38669f594b8f7025a3440ae529d2a/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=018323ffc2c38669f594b8f7025a3440ae529d2a", "patch": "@@ -1119,7 +1119,7 @@ fn prepare_union_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n // offset of zero bytes).\n struct EnumMemberDescriptionFactory<'tcx> {\n     enum_type: Ty<'tcx>,\n-    type_rep: TyLayout<'tcx>,\n+    layout: TyLayout<'tcx>,\n     discriminant_type_metadata: Option<DIType>,\n     containing_scope: DIScope,\n     span: Span,\n@@ -1129,45 +1129,16 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n     fn create_member_descriptions<'a>(&self, cx: &CrateContext<'a, 'tcx>)\n                                       -> Vec<MemberDescription> {\n         let adt = &self.enum_type.ty_adt_def().unwrap();\n-        match self.type_rep.layout {\n-            layout::Layout::General { ref variants, .. } => {\n-                let discriminant_info = RegularDiscriminant(self.discriminant_type_metadata\n-                    .expect(\"\"));\n-                (0..variants.len()).map(|i| {\n-                    let variant = self.type_rep.for_variant(i);\n-                    let (variant_type_metadata, member_desc_factory) =\n-                        describe_enum_variant(cx,\n-                                              variant,\n-                                              &adt.variants[i],\n-                                              discriminant_info,\n-                                              self.containing_scope,\n-                                              self.span);\n-\n-                    let member_descriptions = member_desc_factory\n-                        .create_member_descriptions(cx);\n-\n-                    set_members_of_composite_type(cx,\n-                                                  variant_type_metadata,\n-                                                  &member_descriptions);\n-                    MemberDescription {\n-                        name: \"\".to_string(),\n-                        type_metadata: variant_type_metadata,\n-                        offset: Size::from_bytes(0),\n-                        size: variant.size,\n-                        align: variant.align,\n-                        flags: DIFlags::FlagZero\n-                    }\n-                }).collect()\n-            },\n-            layout::Layout::Univariant => {\n+        match self.layout.variants {\n+            layout::Variants::Single { .. } => {\n                 assert!(adt.variants.len() <= 1);\n \n                 if adt.variants.is_empty() {\n                     vec![]\n                 } else {\n                     let (variant_type_metadata, member_description_factory) =\n                         describe_enum_variant(cx,\n-                                              self.type_rep,\n+                                              self.layout,\n                                               &adt.variants[0],\n                                               NoDiscriminant,\n                                               self.containing_scope,\n@@ -1184,19 +1155,48 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                             name: \"\".to_string(),\n                             type_metadata: variant_type_metadata,\n                             offset: Size::from_bytes(0),\n-                            size: self.type_rep.size,\n-                            align: self.type_rep.align,\n+                            size: self.layout.size,\n+                            align: self.layout.align,\n                             flags: DIFlags::FlagZero\n                         }\n                     ]\n                 }\n             }\n-            layout::Layout::NullablePointer {\n+            layout::Variants::Tagged { ref variants, .. } => {\n+                let discriminant_info = RegularDiscriminant(self.discriminant_type_metadata\n+                    .expect(\"\"));\n+                (0..variants.len()).map(|i| {\n+                    let variant = self.layout.for_variant(i);\n+                    let (variant_type_metadata, member_desc_factory) =\n+                        describe_enum_variant(cx,\n+                                              variant,\n+                                              &adt.variants[i],\n+                                              discriminant_info,\n+                                              self.containing_scope,\n+                                              self.span);\n+\n+                    let member_descriptions = member_desc_factory\n+                        .create_member_descriptions(cx);\n+\n+                    set_members_of_composite_type(cx,\n+                                                  variant_type_metadata,\n+                                                  &member_descriptions);\n+                    MemberDescription {\n+                        name: \"\".to_string(),\n+                        type_metadata: variant_type_metadata,\n+                        offset: Size::from_bytes(0),\n+                        size: variant.size,\n+                        align: variant.align,\n+                        flags: DIFlags::FlagZero\n+                    }\n+                }).collect()\n+            }\n+            layout::Variants::NicheFilling {\n                 nndiscr,\n                 discr,\n                 ..\n             } => {\n-                let variant = self.type_rep.for_variant(nndiscr as usize);\n+                let variant = self.layout.for_variant(nndiscr as usize);\n                 // Create a description of the non-null variant\n                 let (variant_type_metadata, member_description_factory) =\n                     describe_enum_variant(cx,\n@@ -1237,8 +1237,8 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     }\n                 }\n                 compute_field_path(cx, &mut name,\n-                                   self.type_rep,\n-                                   self.type_rep.fields.offset(0),\n+                                   self.layout,\n+                                   self.layout.fields.offset(0),\n                                    discr.size(cx));\n                 name.push_str(&adt.variants[(1 - nndiscr) as usize].name.as_str());\n \n@@ -1253,8 +1253,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                         flags: DIFlags::FlagZero\n                     }\n                 ]\n-            },\n-            ref l @ _ => bug!(\"Not an enum layout: {:#?}\", l)\n+            }\n         }\n     }\n }\n@@ -1429,21 +1428,20 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         }\n     };\n \n-    let type_rep = cx.layout_of(enum_type);\n+    let layout = cx.layout_of(enum_type);\n \n-    let discriminant_type_metadata = match type_rep.layout {\n-        layout::Layout::NullablePointer { .. } |\n-        layout::Layout::Univariant { .. } => None,\n-        layout::Layout::General { discr, .. } => Some(discriminant_type_metadata(discr)),\n-        ref l @ _ => bug!(\"Not an enum layout: {:#?}\", l)\n+    let discriminant_type_metadata = match layout.variants {\n+        layout::Variants::Single { .. } |\n+        layout::Variants::NicheFilling { .. } => None,\n+        layout::Variants::Tagged { discr, .. } => Some(discriminant_type_metadata(discr)),\n     };\n \n-    match (type_rep.abi, discriminant_type_metadata) {\n+    match (layout.abi, discriminant_type_metadata) {\n         (layout::Abi::Scalar(_), Some(discr)) => return FinalMetadata(discr),\n         _ => {}\n     }\n \n-    let (enum_type_size, enum_type_align) = type_rep.size_and_align();\n+    let (enum_type_size, enum_type_align) = layout.size_and_align();\n \n     let enum_name = CString::new(enum_name).unwrap();\n     let unique_type_id_str = CString::new(\n@@ -1471,7 +1469,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         enum_metadata,\n         EnumMDF(EnumMemberDescriptionFactory {\n             enum_type,\n-            type_rep,\n+            layout,\n             discriminant_type_metadata,\n             containing_scope,\n             span,"}, {"sha": "d982fa192b369e05278d71817be1960d91266426", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/018323ffc2c38669f594b8f7025a3440ae529d2a/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018323ffc2c38669f594b8f7025a3440ae529d2a/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=018323ffc2c38669f594b8f7025a3440ae529d2a", "patch": "@@ -394,12 +394,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         },\n \n         \"discriminant_value\" => {\n-            match substs.type_at(0).sty {\n-                ty::TyAdt(adt, ..) if adt.is_enum() => {\n-                    args[0].deref(bcx.ccx).trans_get_discr(bcx, ret_ty)\n-                }\n-                _ => C_null(llret_ty)\n-            }\n+            args[0].deref(bcx.ccx).trans_get_discr(bcx, ret_ty)\n         }\n \n         \"align_offset\" => {"}, {"sha": "5a2dcf4fb180e727d63db38b56ff3f4ab20c1d11", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/018323ffc2c38669f594b8f7025a3440ae529d2a/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018323ffc2c38669f594b8f7025a3440ae529d2a/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=018323ffc2c38669f594b8f7025a3440ae529d2a", "patch": "@@ -1094,8 +1094,26 @@ fn trans_const_adt<'a, 'tcx>(\n         mir::AggregateKind::Adt(_, index, _, _) => index,\n         _ => 0,\n     };\n-    match l.layout {\n-        layout::Layout::General { .. } => {\n+    match l.variants {\n+        layout::Variants::Single { index } => {\n+            assert_eq!(variant_index, index);\n+            if let layout::Abi::Vector { .. } = l.abi {\n+                Const::new(C_vector(&vals.iter().map(|x| x.llval).collect::<Vec<_>>()), t)\n+            } else if let layout::FieldPlacement::Union(_) = l.fields {\n+                assert_eq!(variant_index, 0);\n+                assert_eq!(vals.len(), 1);\n+                let contents = [\n+                    vals[0].llval,\n+                    padding(ccx, l.size - ccx.size_of(vals[0].ty))\n+                ];\n+\n+                Const::new(C_struct(ccx, &contents, l.is_packed()), t)\n+            } else {\n+                assert_eq!(variant_index, 0);\n+                build_const_struct(ccx, l, vals, None)\n+            }\n+        }\n+        layout::Variants::Tagged { .. } => {\n             let discr = match *kind {\n                 mir::AggregateKind::Adt(adt_def, _, _, _) => {\n                     adt_def.discriminant_for_variant(ccx.tcx(), variant_index)\n@@ -1112,23 +1130,7 @@ fn trans_const_adt<'a, 'tcx>(\n                 build_const_struct(ccx, l.for_variant(variant_index), vals, Some(discr))\n             }\n         }\n-        layout::Layout::UntaggedUnion => {\n-            assert_eq!(variant_index, 0);\n-            let contents = [\n-                vals[0].llval,\n-                padding(ccx, l.size - ccx.size_of(vals[0].ty))\n-            ];\n-\n-            Const::new(C_struct(ccx, &contents, l.is_packed()), t)\n-        }\n-        layout::Layout::Univariant => {\n-            assert_eq!(variant_index, 0);\n-            build_const_struct(ccx, l, vals, None)\n-        }\n-        layout::Layout::Vector => {\n-            Const::new(C_vector(&vals.iter().map(|x| x.llval).collect::<Vec<_>>()), t)\n-        }\n-        layout::Layout::NullablePointer { nndiscr, .. } => {\n+        layout::Variants::NicheFilling { nndiscr, .. } => {\n             if variant_index as u64 == nndiscr {\n                 build_const_struct(ccx, l.for_variant(variant_index), vals, None)\n             } else {\n@@ -1137,7 +1139,6 @@ fn trans_const_adt<'a, 'tcx>(\n                 Const::new(C_null(ccx.layout_of(t).llvm_type(ccx)), t)\n             }\n         }\n-        _ => bug!(\"trans_const_adt: cannot handle type {} repreented as {:#?}\", t, l)\n     }\n }\n "}, {"sha": "5a558e3652b51386c773575eb135def9eadd0f89", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/018323ffc2c38669f594b8f7025a3440ae529d2a/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018323ffc2c38669f594b8f7025a3440ae529d2a/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=018323ffc2c38669f594b8f7025a3440ae529d2a", "patch": "@@ -296,19 +296,24 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n     /// Obtain the actual discriminant of a value.\n     pub fn trans_get_discr(self, bcx: &Builder<'a, 'tcx>, cast_to: Ty<'tcx>) -> ValueRef {\n         let cast_to = bcx.ccx.layout_of(cast_to).immediate_llvm_type(bcx.ccx);\n-        match self.layout.layout {\n-            layout::Layout::Univariant { .. } |\n-            layout::Layout::UntaggedUnion { .. } => return C_uint(cast_to, 0),\n-            _ => {}\n+        match self.layout.variants {\n+            layout::Variants::Single { index } => {\n+                assert_eq!(index, 0);\n+                return C_uint(cast_to, 0);\n+            }\n+            layout::Variants::Tagged { .. } |\n+            layout::Variants::NicheFilling { .. } => {},\n         }\n \n         let discr = self.project_field(bcx, 0);\n         let discr_scalar = match discr.layout.abi {\n             layout::Abi::Scalar(discr) => discr,\n             _ => bug!(\"discriminant not scalar: {:#?}\", discr.layout)\n         };\n-        let (min, max) = match self.layout.layout {\n-            layout::Layout::General { ref discr_range, .. } => (discr_range.start, discr_range.end),\n+        let (min, max) = match self.layout.variants {\n+            layout::Variants::Tagged { ref discr_range, .. } => {\n+                (discr_range.start, discr_range.end)\n+            }\n             _ => (0, u64::max_value()),\n         };\n         let max_next = max.wrapping_add(1);\n@@ -333,20 +338,20 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                 bcx.load(discr.llval, discr.alignment.non_abi())\n             }\n         };\n-        match self.layout.layout {\n-            layout::Layout::General { .. } => {\n+        match self.layout.variants {\n+            layout::Variants::Single { .. } => bug!(),\n+            layout::Variants::Tagged { .. } => {\n                 let signed = match discr_scalar {\n                     layout::Int(_, signed) => signed,\n                     _ => false\n                 };\n                 bcx.intcast(lldiscr, cast_to, signed)\n             }\n-            layout::Layout::NullablePointer { nndiscr, .. } => {\n+            layout::Variants::NicheFilling { nndiscr, .. } => {\n                 let cmp = if nndiscr == 0 { llvm::IntEQ } else { llvm::IntNE };\n                 let zero = C_null(discr.layout.llvm_type(bcx.ccx));\n                 bcx.intcast(bcx.icmp(cmp, lldiscr, zero), cast_to, false)\n             }\n-            _ => bug!(\"{} is not an enum\", self.layout.ty)\n         }\n     }\n \n@@ -356,13 +361,17 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n         let to = self.layout.ty.ty_adt_def().unwrap()\n             .discriminant_for_variant(bcx.tcx(), variant_index)\n             .to_u128_unchecked() as u64;\n-        match self.layout.layout {\n-            layout::Layout::General { .. } => {\n+        match self.layout.variants {\n+            layout::Variants::Single { index } => {\n+                assert_eq!(to, 0);\n+                assert_eq!(variant_index, index);\n+            }\n+            layout::Variants::Tagged { .. } => {\n                 let ptr = self.project_field(bcx, 0);\n                 bcx.store(C_int(ptr.layout.llvm_type(bcx.ccx), to as i64),\n                     ptr.llval, ptr.alignment.non_abi());\n             }\n-            layout::Layout::NullablePointer { nndiscr, .. } => {\n+            layout::Variants::NicheFilling { nndiscr, .. } => {\n                 if to != nndiscr {\n                     let use_memset = match self.layout.abi {\n                         layout::Abi::Scalar(_) => false,\n@@ -385,9 +394,6 @@ impl<'a, 'tcx> LvalueRef<'tcx> {\n                     }\n                 }\n             }\n-            _ => {\n-                assert_eq!(to, 0);\n-            }\n         }\n     }\n "}, {"sha": "d3677e2eefd43800bafc23979366bc25227899b4", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/018323ffc2c38669f594b8f7025a3440ae529d2a/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018323ffc2c38669f594b8f7025a3440ae529d2a/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=018323ffc2c38669f594b8f7025a3440ae529d2a", "patch": "@@ -11,7 +11,7 @@\n use llvm::{self, ValueRef};\n use rustc::ty::{self, Ty};\n use rustc::ty::cast::{CastTy, IntTy};\n-use rustc::ty::layout::{self, Layout, LayoutOf};\n+use rustc::ty::layout::{self, LayoutOf};\n use rustc::mir;\n use rustc::middle::lang_items::ExchangeMallocFnLangItem;\n use rustc_apfloat::{ieee, Float, Status, Round};\n@@ -278,8 +278,10 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         let ll_t_out = cast.immediate_llvm_type(bcx.ccx);\n                         let llval = operand.immediate();\n \n-                        if let Layout::General { ref discr_range, .. } = operand.layout.layout {\n-                            if discr_range.end > discr_range.start {\n+                        match operand.layout.variants {\n+                            layout::Variants::Tagged {\n+                                ref discr_range, ..\n+                            } if discr_range.end > discr_range.start => {\n                                 // We want `table[e as usize]` to not\n                                 // have bound checks, and this is the most\n                                 // convenient place to put the `assume`.\n@@ -290,6 +292,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                     C_uint(ll_t_in, discr_range.end)\n                                 ));\n                             }\n+                            _ => {}\n                         }\n \n                         let signed = match operand.layout.abi {"}, {"sha": "2b3ac0386ee271bc8daaf1d809148fa6f8116339", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/018323ffc2c38669f594b8f7025a3440ae529d2a/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018323ffc2c38669f594b8f7025a3440ae529d2a/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=018323ffc2c38669f594b8f7025a3440ae529d2a", "patch": "@@ -40,8 +40,13 @@ fn uncached_llvm_type<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let mut name = String::with_capacity(32);\n             let printer = DefPathBasedNames::new(ccx.tcx(), true, true);\n             printer.push_type_name(layout.ty, &mut name);\n-            if let (&ty::TyAdt(def, _), Some(v)) = (&layout.ty.sty, layout.variant_index) {\n-                write!(&mut name, \"::{}\", def.variants[v].name).unwrap();\n+            match (&layout.ty.sty, &layout.variants) {\n+                (&ty::TyAdt(def, _), &layout::Variants::Single { index }) => {\n+                    if def.is_enum() && !def.variants.is_empty() {\n+                        write!(&mut name, \"::{}\", def.variants[index].name).unwrap();\n+                    }\n+                }\n+                _ => {}\n             }\n             Some(name)\n         }\n@@ -206,7 +211,11 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n \n \n         // Check the cache.\n-        if let Some(&llty) = ccx.lltypes().borrow().get(&(self.ty, self.variant_index)) {\n+        let variant_index = match self.variants {\n+            layout::Variants::Single { index } => Some(index),\n+            _ => None\n+        };\n+        if let Some(&llty) = ccx.lltypes().borrow().get(&(self.ty, variant_index)) {\n             return llty;\n         }\n \n@@ -221,7 +230,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         let mut defer = None;\n         let llty = if self.ty != normal_ty {\n             let mut layout = ccx.layout_of(normal_ty);\n-            if let Some(v) = self.variant_index {\n+            if let Some(v) = variant_index {\n                 layout = layout.for_variant(v);\n             }\n             layout.llvm_type(ccx)\n@@ -230,7 +239,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyLayout<'tcx> {\n         };\n         debug!(\"--> mapped {:#?} to llty={:?}\", self, llty);\n \n-        ccx.lltypes().borrow_mut().insert((self.ty, self.variant_index), llty);\n+        ccx.lltypes().borrow_mut().insert((self.ty, variant_index), llty);\n \n         if let Some((mut llty, layout)) = defer {\n             llty.set_struct_body(&struct_llfields(ccx, layout), layout.is_packed())"}]}