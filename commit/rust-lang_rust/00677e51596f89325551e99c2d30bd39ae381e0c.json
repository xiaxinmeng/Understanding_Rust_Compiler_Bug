{"sha": "00677e51596f89325551e99c2d30bd39ae381e0c", "node_id": "C_kwDOAAsO6NoAKDAwNjc3ZTUxNTk2Zjg5MzI1NTUxZTk5YzJkMzBiZDM5YWUzODFlMGM", "commit": {"author": {"name": "yvt", "email": "i@yvt.jp", "date": "2022-04-01T04:54:51Z"}, "committer": {"name": "yvt", "email": "i@yvt.jp", "date": "2022-04-05T16:48:37Z"}, "message": "Implement `saturating_{add, sub}` for non-native integer types\n\nUpdates their unsigned code paths to use the `Builder::gcc_` methods\nthat automatically lower non-native integer operations to native ones.\n\nAlso updates the signed code path of `saturating_add` to support non-\nnative integer types. That of `saturating_sub` already supports this,\nso no major changes have been made.", "tree": {"sha": "75f9f1d6d0a14ec4b81fd6813f5ae71256bfdb35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/75f9f1d6d0a14ec4b81fd6813f5ae71256bfdb35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/00677e51596f89325551e99c2d30bd39ae381e0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/00677e51596f89325551e99c2d30bd39ae381e0c", "html_url": "https://github.com/rust-lang/rust/commit/00677e51596f89325551e99c2d30bd39ae381e0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/00677e51596f89325551e99c2d30bd39ae381e0c/comments", "author": {"login": "yvt", "id": 5253988, "node_id": "MDQ6VXNlcjUyNTM5ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/5253988?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yvt", "html_url": "https://github.com/yvt", "followers_url": "https://api.github.com/users/yvt/followers", "following_url": "https://api.github.com/users/yvt/following{/other_user}", "gists_url": "https://api.github.com/users/yvt/gists{/gist_id}", "starred_url": "https://api.github.com/users/yvt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yvt/subscriptions", "organizations_url": "https://api.github.com/users/yvt/orgs", "repos_url": "https://api.github.com/users/yvt/repos", "events_url": "https://api.github.com/users/yvt/events{/privacy}", "received_events_url": "https://api.github.com/users/yvt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yvt", "id": 5253988, "node_id": "MDQ6VXNlcjUyNTM5ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/5253988?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yvt", "html_url": "https://github.com/yvt", "followers_url": "https://api.github.com/users/yvt/followers", "following_url": "https://api.github.com/users/yvt/following{/other_user}", "gists_url": "https://api.github.com/users/yvt/gists{/gist_id}", "starred_url": "https://api.github.com/users/yvt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yvt/subscriptions", "organizations_url": "https://api.github.com/users/yvt/orgs", "repos_url": "https://api.github.com/users/yvt/repos", "events_url": "https://api.github.com/users/yvt/events{/privacy}", "received_events_url": "https://api.github.com/users/yvt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "837a4467bc98471d5619e76cc47eac3b9a471d28", "url": "https://api.github.com/repos/rust-lang/rust/commits/837a4467bc98471d5619e76cc47eac3b9a471d28", "html_url": "https://github.com/rust-lang/rust/commit/837a4467bc98471d5619e76cc47eac3b9a471d28"}], "stats": {"total": 92, "additions": 57, "deletions": 35}, "files": [{"sha": "84395e967636c32aacde52dee53adb3cdba3acc6", "filename": "src/intrinsic/mod.rs", "status": "modified", "additions": 57, "deletions": 35, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/00677e51596f89325551e99c2d30bd39ae381e0c/src%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00677e51596f89325551e99c2d30bd39ae381e0c/src%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fmod.rs?ref=00677e51596f89325551e99c2d30bd39ae381e0c", "patch": "@@ -967,34 +967,55 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn saturating_add(&mut self, lhs: RValue<'gcc>, rhs: RValue<'gcc>, signed: bool, width: u64) -> RValue<'gcc> {\n-        let func = self.current_func.borrow().expect(\"func\");\n-\n+        let result_type = lhs.get_type();\n         if signed {\n-            // Algorithm from: https://stackoverflow.com/a/56531252/389119\n-            let after_block = func.new_block(\"after\");\n-            let func_name =\n-                match width {\n-                    8 => \"__builtin_add_overflow\",\n-                    16 => \"__builtin_add_overflow\",\n-                    32 => \"__builtin_sadd_overflow\",\n-                    64 => \"__builtin_saddll_overflow\",\n-                    128 => \"__builtin_add_overflow\",\n-                    _ => unreachable!(),\n-                };\n-            let overflow_func = self.context.get_builtin_function(func_name);\n-            let result_type = lhs.get_type();\n+            // Based on algorithm from: https://stackoverflow.com/a/56531252/389119\n+            let func = self.current_func.borrow().expect(\"func\");\n             let res = func.new_local(None, result_type, \"saturating_sum\");\n-            let overflow = self.overflow_call(overflow_func, &[lhs, rhs, res.get_address(None)], None);\n+            let supports_native_type = self.is_native_int_type(result_type);\n+            let overflow =\n+                if supports_native_type {\n+                    let func_name =\n+                        match width {\n+                            8 => \"__builtin_add_overflow\",\n+                            16 => \"__builtin_add_overflow\",\n+                            32 => \"__builtin_sadd_overflow\",\n+                            64 => \"__builtin_saddll_overflow\",\n+                            128 => \"__builtin_add_overflow\",\n+                            _ => unreachable!(),\n+                        };\n+                    let overflow_func = self.context.get_builtin_function(func_name);\n+                    self.overflow_call(overflow_func, &[lhs, rhs, res.get_address(None)], None)\n+                }\n+                else {\n+                    let func_name =\n+                        match width {\n+                            128 => \"__rust_i128_addo\",\n+                            _ => unreachable!(),\n+                        };\n+                    let param_a = self.context.new_parameter(None, result_type, \"a\");\n+                    let param_b = self.context.new_parameter(None, result_type, \"b\");\n+                    let result_field = self.context.new_field(None, result_type, \"result\");\n+                    let overflow_field = self.context.new_field(None, self.bool_type, \"overflow\");\n+                    let return_type = self.context.new_struct_type(None, \"result_overflow\", &[result_field, overflow_field]);\n+                    let func = self.context.new_function(None, FunctionType::Extern, return_type.as_type(), &[param_a, param_b], func_name, false);\n+                    let result = self.context.new_call(None, func, &[lhs, rhs]);\n+                    let overflow = result.access_field(None, overflow_field);\n+                    let int_result = result.access_field(None, result_field);\n+                    self.llbb().add_assignment(None, res, int_result);\n+                    overflow\n+                };\n \n             let then_block = func.new_block(\"then\");\n+            let after_block = func.new_block(\"after\");\n \n-            let unsigned_type = self.context.new_int_type(width as i32 / 8, false);\n-            let shifted = self.context.new_cast(None, lhs, unsigned_type) >> self.context.new_rvalue_from_int(unsigned_type, width as i32 - 1);\n-            let uint_max = self.context.new_unary_op(None, UnaryOp::BitwiseNegate, unsigned_type,\n-                self.context.new_rvalue_from_int(unsigned_type, 0)\n-            );\n-            let int_max = uint_max >> self.context.new_rvalue_one(unsigned_type);\n-            then_block.add_assignment(None, res, self.context.new_cast(None, shifted + int_max, result_type));\n+            // Return `result_type`'s maximum or minimum value on overflow\n+            // NOTE: convert the type to unsigned to have an unsigned shift.\n+            let unsigned_type = result_type.to_unsigned(&self.cx);\n+            let shifted = self.gcc_lshr(self.gcc_int_cast(lhs, unsigned_type), self.gcc_int(unsigned_type, width as i64 - 1));\n+            let uint_max = self.gcc_not(self.gcc_int(unsigned_type, 0));\n+            let int_max = self.gcc_lshr(uint_max, self.gcc_int(unsigned_type, 1));\n+            then_block.add_assignment(None, res, self.gcc_int_cast(self.gcc_add(shifted, int_max), result_type));\n             then_block.end_with_jump(None, after_block);\n \n             self.llbb().end_with_conditional(None, overflow, then_block, after_block);\n@@ -1006,20 +1027,20 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             res.to_rvalue()\n         }\n         else {\n+            assert!(!signed);\n             // Algorithm from: http://locklessinc.com/articles/sat_arithmetic/\n-            let res = lhs + rhs;\n-            let res_type = res.get_type();\n-            let cond = self.context.new_comparison(None, ComparisonOp::LessThan, res, lhs);\n-            let value = self.context.new_unary_op(None, UnaryOp::Minus, res_type, self.context.new_cast(None, cond, res_type));\n-            res | value\n+            let res = self.gcc_add(lhs, rhs);\n+            let cond = self.gcc_icmp(IntPredicate::IntULT, res, lhs);\n+            let value = self.gcc_neg(self.gcc_int_cast(cond, result_type));\n+            self.gcc_or(res, value)\n         }\n     }\n \n     // Algorithm from: https://locklessinc.com/articles/sat_arithmetic/\n     fn saturating_sub(&mut self, lhs: RValue<'gcc>, rhs: RValue<'gcc>, signed: bool, width: u64) -> RValue<'gcc> {\n+        let result_type = lhs.get_type();\n         if signed {\n-            // Also based on algorithm from: https://stackoverflow.com/a/56531252/389119\n-            let result_type = lhs.get_type();\n+            // Based on algorithm from: https://stackoverflow.com/a/56531252/389119\n             let func = self.current_func.borrow().expect(\"func\");\n             let res = func.new_local(None, result_type, \"saturating_diff\");\n             let supports_native_type = self.is_native_int_type(result_type);\n@@ -1059,6 +1080,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             let then_block = func.new_block(\"then\");\n             let after_block = func.new_block(\"after\");\n \n+            // Return `result_type`'s maximum or minimum value on overflow\n             // NOTE: convert the type to unsigned to have an unsigned shift.\n             let unsigned_type = result_type.to_unsigned(&self.cx);\n             let shifted = self.gcc_lshr(self.gcc_int_cast(lhs, unsigned_type), self.gcc_int(unsigned_type, width as i64 - 1));\n@@ -1076,11 +1098,11 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             res.to_rvalue()\n         }\n         else {\n-            let res = lhs - rhs;\n-            let comparison = self.context.new_comparison(None, ComparisonOp::LessThanEquals, res, lhs);\n-            let comparison = self.context.new_cast(None, comparison, lhs.get_type());\n-            let unary_op = self.context.new_unary_op(None, UnaryOp::Minus, comparison.get_type(), comparison);\n-            self.and(res, unary_op)\n+            assert!(!signed);\n+            let res = self.gcc_sub(lhs, rhs);\n+            let comparison = self.gcc_icmp(IntPredicate::IntULE, res, lhs);\n+            let value = self.gcc_neg(self.gcc_int_cast(comparison, result_type));\n+            self.gcc_and(res, value)\n         }\n     }\n }"}]}