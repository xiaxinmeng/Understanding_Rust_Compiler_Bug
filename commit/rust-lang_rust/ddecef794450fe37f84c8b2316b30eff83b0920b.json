{"sha": "ddecef794450fe37f84c8b2316b30eff83b0920b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRkZWNlZjc5NDQ1MGZlMzdmODRjOGIyMzE2YjMwZWZmODNiMDkyMGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-08T23:27:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-08T23:27:37Z"}, "message": "auto merge of #5287 : thestinger/rust/iter-trait, r=pcwalton\n\nCloses #2827", "tree": {"sha": "c7ceae356b8474e562c3e031cb3c6fd73af856e8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7ceae356b8474e562c3e031cb3c6fd73af856e8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ddecef794450fe37f84c8b2316b30eff83b0920b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ddecef794450fe37f84c8b2316b30eff83b0920b", "html_url": "https://github.com/rust-lang/rust/commit/ddecef794450fe37f84c8b2316b30eff83b0920b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ddecef794450fe37f84c8b2316b30eff83b0920b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eaed16cea6c83c49bfb3d4a663f9b715f86d1f37", "url": "https://api.github.com/repos/rust-lang/rust/commits/eaed16cea6c83c49bfb3d4a663f9b715f86d1f37", "html_url": "https://github.com/rust-lang/rust/commit/eaed16cea6c83c49bfb3d4a663f9b715f86d1f37"}, {"sha": "b69fb75348b5aeb0988489d748373b1900f2766b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b69fb75348b5aeb0988489d748373b1900f2766b", "html_url": "https://github.com/rust-lang/rust/commit/b69fb75348b5aeb0988489d748373b1900f2766b"}], "stats": {"total": 194, "additions": 43, "deletions": 151}, "files": [{"sha": "42312d96d1becef1313d280581891bbaf4fbfb1c", "filename": "src/libcore/core.rc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ddecef794450fe37f84c8b2316b30eff83b0920b/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/ddecef794450fe37f84c8b2316b30eff83b0920b/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=ddecef794450fe37f84c8b2316b30eff83b0920b", "patch": "@@ -142,8 +142,6 @@ pub mod option;\n pub mod result;\n pub mod either;\n pub mod dlist;\n-#[path=\"iter-trait.rs\"] #[merge = \"iter-trait/dlist.rs\"]\n-pub mod dlist_iter;\n pub mod hashmap;\n pub mod cell;\n pub mod trie;"}, {"sha": "9cb872a0542a135f1cd7bf891c8c86af0f46977d", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ddecef794450fe37f84c8b2316b30eff83b0920b/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ddecef794450fe37f84c8b2316b30eff83b0920b/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=ddecef794450fe37f84c8b2316b30eff83b0920b", "patch": "@@ -18,6 +18,8 @@ Do not use ==, !=, <, etc on doubly-linked lists -- it may not terminate.\n \n */\n \n+use iter;\n+use iter::BaseIter;\n use kinds::Copy;\n use managed;\n use option::{None, Option, Some};\n@@ -489,14 +491,54 @@ pub impl<T:Copy> DList<T> {\n         let mut v = vec::with_capacity(self.size);\n         unsafe {\n             // Take this out of the unchecked when iter's functions are pure\n-            for self.eachi |index,data| {\n+            for iter::eachi(&self) |index,data| {\n                 v[index] = *data;\n             }\n         }\n         v\n     }\n }\n \n+impl<T> BaseIter<T> for @mut DList<T> {\n+    /**\n+    * Iterates through the current contents.\n+    *\n+    * Attempts to access this dlist during iteration are allowed (to\n+    * allow for e.g. breadth-first search with in-place enqueues), but\n+    * removing the current node is forbidden.\n+    */\n+    pure fn each(&self, f: fn(v: &T) -> bool) {\n+        let mut link = self.peek_n();\n+        while option::is_some(&link) {\n+            let nobe = option::get(link);\n+            fail_unless!(nobe.linked);\n+\n+            {\n+                let frozen_nobe = &*nobe;\n+                if !f(&frozen_nobe.data) { break; }\n+            }\n+\n+            // Check (weakly) that the user didn't do a remove.\n+            if self.size == 0 {\n+                fail!(~\"The dlist became empty during iteration??\")\n+            }\n+            if !nobe.linked ||\n+                (!((nobe.prev.is_some()\n+                    || managed::mut_ptr_eq(self.hd.expect(~\"headless dlist?\"),\n+                                           nobe))\n+                   && (nobe.next.is_some()\n+                    || managed::mut_ptr_eq(self.tl.expect(~\"tailless dlist?\"),\n+                                           nobe)))) {\n+                fail!(~\"Removing a dlist node during iteration is forbidden!\")\n+            }\n+            link = nobe.next_link();\n+        }\n+    }\n+\n+    #[inline(always)]\n+    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use dlist::{DList, concat, from_vec, new_dlist_node};"}, {"sha": "7c4a99133bbdbff0fcc34e1884367e850ddab17a", "filename": "src/libcore/iter-trait.rs", "status": "removed", "additions": 0, "deletions": 89, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/eaed16cea6c83c49bfb3d4a663f9b715f86d1f37/src%2Flibcore%2Fiter-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaed16cea6c83c49bfb3d4a663f9b715f86d1f37/src%2Flibcore%2Fiter-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait.rs?ref=eaed16cea6c83c49bfb3d4a663f9b715f86d1f37", "patch": "@@ -1,89 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// This makes use of a clever hack that brson came up with to\n-// workaround our lack of traits and lack of macros.  See core.{rc,rs} for\n-// how this file is used.\n-\n-use cmp::{Eq, Ord};\n-use iter::BaseIter;\n-use iter;\n-use kinds::Copy;\n-use option::Option;\n-\n-use self::inst::{IMPL_T, EACH, SIZE_HINT};\n-\n-impl<A> iter::BaseIter<A> for IMPL_T<A> {\n-    #[inline(always)]\n-    pure fn each(&self, blk: fn(v: &A) -> bool) { EACH(self, blk) }\n-    #[inline(always)]\n-    pure fn size_hint(&self) -> Option<uint> { SIZE_HINT(self) }\n-}\n-\n-impl<A> iter::ExtendedIter<A> for IMPL_T<A> {\n-    #[inline(always)]\n-    pure fn eachi(&self, blk: fn(uint, v: &A) -> bool) {\n-        iter::eachi(self, blk)\n-    }\n-    #[inline(always)]\n-    pure fn all(&self, blk: fn(&A) -> bool) -> bool {\n-        iter::all(self, blk)\n-    }\n-    #[inline(always)]\n-    pure fn any(&self, blk: fn(&A) -> bool) -> bool {\n-        iter::any(self, blk)\n-    }\n-    #[inline(always)]\n-    pure fn foldl<B>(&self, b0: B, blk: fn(&B, &A) -> B) -> B {\n-        iter::foldl(self, b0, blk)\n-    }\n-    #[inline(always)]\n-    pure fn position(&self, f: fn(&A) -> bool) -> Option<uint> {\n-        iter::position(self, f)\n-    }\n-    #[inline(always)]\n-    pure fn map_to_vec<B>(&self, op: fn(&A) -> B) -> ~[B] {\n-        iter::map_to_vec(self, op)\n-    }\n-    #[inline(always)]\n-    pure fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: fn(&A) -> IB)\n-        -> ~[B] {\n-        iter::flat_map_to_vec(self, op)\n-    }\n-\n-}\n-\n-impl<A:Eq> iter::EqIter<A> for IMPL_T<A> {\n-    #[inline(always)]\n-    pure fn contains(&self, x: &A) -> bool { iter::contains(self, x) }\n-    #[inline(always)]\n-    pure fn count(&self, x: &A) -> uint { iter::count(self, x) }\n-}\n-\n-impl<A:Copy> iter::CopyableIter<A> for IMPL_T<A> {\n-    #[inline(always)]\n-    pure fn filter_to_vec(&self, pred: fn(&A) -> bool) -> ~[A] {\n-        iter::filter_to_vec(self, pred)\n-    }\n-    #[inline(always)]\n-    pure fn to_vec(&self) -> ~[A] { iter::to_vec(self) }\n-    #[inline(always)]\n-    pure fn find(&self, f: fn(&A) -> bool) -> Option<A> {\n-        iter::find(self, f)\n-    }\n-}\n-\n-impl<A:Copy + Ord> iter::CopyableOrderedIter<A> for IMPL_T<A> {\n-    #[inline(always)]\n-    pure fn min(&self) -> A { iter::min(self) }\n-    #[inline(always)]\n-    pure fn max(&self) -> A { iter::max(self) }\n-}\n-"}, {"sha": "245c1db2bb4b8c5eddf4ae93911480a7bae9e2e5", "filename": "src/libcore/iter-trait/dlist.rs", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/eaed16cea6c83c49bfb3d4a663f9b715f86d1f37/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaed16cea6c83c49bfb3d4a663f9b715f86d1f37/src%2Flibcore%2Fiter-trait%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdlist.rs?ref=eaed16cea6c83c49bfb3d4a663f9b715f86d1f37", "patch": "@@ -1,59 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-mod inst {\n-    use dlist::DList;\n-    use managed;\n-    use option::{Option, Some};\n-    use option;\n-\n-    #[allow(non_camel_case_types)]\n-    pub type IMPL_T<A> = @mut DList<A>;\n-\n-    /**\n-    * Iterates through the current contents.\n-    *\n-    * Attempts to access this dlist during iteration are allowed (to\n-    * allow for e.g. breadth-first search with in-place enqueues), but\n-    * removing the current node is forbidden.\n-    */\n-    pub pure fn EACH<A>(self: &IMPL_T<A>, f: fn(v: &A) -> bool) {\n-        let mut link = self.peek_n();\n-        while option::is_some(&link) {\n-            let nobe = option::get(link);\n-            fail_unless!(nobe.linked);\n-\n-            {\n-                let frozen_nobe = &*nobe;\n-                if !f(&frozen_nobe.data) { break; }\n-            }\n-\n-            // Check (weakly) that the user didn't do a remove.\n-            if self.size == 0 {\n-                fail!(~\"The dlist became empty during iteration??\")\n-            }\n-            if !nobe.linked ||\n-                (!((nobe.prev.is_some()\n-                    || managed::mut_ptr_eq(self.hd.expect(~\"headless dlist?\"),\n-                                           nobe))\n-                   && (nobe.next.is_some()\n-                    || managed::mut_ptr_eq(self.tl.expect(~\"tailless dlist?\"),\n-                                           nobe)))) {\n-                fail!(~\"Removing a dlist node during iteration is forbidden!\")\n-            }\n-            link = nobe.next_link();\n-        }\n-    }\n-\n-    #[inline(always)]\n-    pub pure fn SIZE_HINT<A>(self: &IMPL_T<A>) -> Option<uint> {\n-        Some(self.len())\n-    }\n-}"}]}