{"sha": "c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2OWJiOGE3ZTczN2UwOWM2NjdmOWUzNDNkMGYxZDNlNGMxM2I4Zjc=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-07T00:11:13Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-01-07T00:11:13Z"}, "message": "Merge #446\n\n446: Use HIR Expr for type inference r=flodiebold a=flodiebold\n\nNow we can reuse the type inference inside a function when typing whitespace etc. :)\r\n\r\nThe order of the lines in the type tests changed a bit, which I'm not sure why, but there are no actual changes in the inference results.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "d3d006919d15d6a26ff1a8091cf1e5341842c1aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3d006919d15d6a26ff1a8091cf1e5341842c1aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7", "html_url": "https://github.com/rust-lang/rust/commit/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "3c945ceb5e0dc287139de0589cc9a4b285911f17", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c945ceb5e0dc287139de0589cc9a4b285911f17", "html_url": "https://github.com/rust-lang/rust/commit/3c945ceb5e0dc287139de0589cc9a4b285911f17"}, {"sha": "d618b1f2ce25db8817d1649d7ec7720594789067", "url": "https://api.github.com/repos/rust-lang/rust/commits/d618b1f2ce25db8817d1649d7ec7720594789067", "html_url": "https://github.com/rust-lang/rust/commit/d618b1f2ce25db8817d1649d7ec7720594789067"}], "stats": {"total": 885, "additions": 459, "deletions": 426}, "files": [{"sha": "54ce1b638babc63f2f542b710215595a85338d31", "filename": "crates/ra_analysis/src/completion/complete_dot.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7", "patch": "@@ -1,4 +1,3 @@\n-use ra_syntax::ast::AstNode;\n use hir::{Ty, Def};\n \n use crate::Cancelable;\n@@ -11,11 +10,12 @@ pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) -> Ca\n         _ => return Ok(()),\n     };\n     let infer_result = function.infer(ctx.db)?;\n-    let receiver_ty = if let Some(ty) = infer_result.type_of_node(receiver.syntax()) {\n-        ty\n-    } else {\n-        return Ok(());\n+    let syntax_mapping = function.body_syntax_mapping(ctx.db)?;\n+    let expr = match syntax_mapping.node_expr(receiver) {\n+        Some(expr) => expr,\n+        None => return Ok(()),\n     };\n+    let receiver_ty = infer_result[expr].clone();\n     if !ctx.is_method_call {\n         complete_fields(acc, ctx, receiver_ty)?;\n     }"}, {"sha": "06632df4f2202d434c5bbff150be96c61123d1cf", "filename": "crates/ra_analysis/src/hover.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7/crates%2Fra_analysis%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7/crates%2Fra_analysis%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fhover.rs?ref=c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7", "patch": "@@ -64,7 +64,14 @@ pub(crate) fn type_of(db: &RootDatabase, frange: FileRange) -> Cancelable<Option\n         parent_fn\n     )?);\n     let infer = function.infer(db)?;\n-    Ok(infer.type_of_node(node).map(|t| t.to_string()))\n+    let syntax_mapping = function.body_syntax_mapping(db)?;\n+    if let Some(expr) = ast::Expr::cast(node).and_then(|e| syntax_mapping.node_expr(e)) {\n+        Ok(Some(infer[expr].to_string()))\n+    } else if let Some(pat) = ast::Pat::cast(node).and_then(|p| syntax_mapping.node_pat(p)) {\n+        Ok(Some(infer[pat].to_string()))\n+    } else {\n+        Ok(None)\n+    }\n }\n \n // FIXME: this should not really use navigation target. Rather, approximatelly"}, {"sha": "040977dc472f62a1ff1bd3c3d6deae65442973d0", "filename": "crates/ra_arena/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7/crates%2Fra_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7/crates%2Fra_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_arena%2Fsrc%2Flib.rs?ref=c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7", "patch": "@@ -6,6 +6,8 @@ use std::{\n     ops::{Index, IndexMut},\n };\n \n+pub mod map;\n+\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct RawId(u32);\n "}, {"sha": "2f09d677f1aa66c037a776f79f130fc4129513da", "filename": "crates/ra_arena/src/map.rs", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7/crates%2Fra_arena%2Fsrc%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7/crates%2Fra_arena%2Fsrc%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_arena%2Fsrc%2Fmap.rs?ref=c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7", "patch": "@@ -0,0 +1,70 @@\n+//! A map from arena IDs to some other type. Space requirement is O(highest ID).\n+\n+use std::marker::PhantomData;\n+\n+use super::ArenaId;\n+\n+/// A map from arena IDs to some other type. Space requirement is O(highest ID).\n+#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct ArenaMap<ID, T> {\n+    v: Vec<Option<T>>,\n+    _ty: PhantomData<ID>,\n+}\n+\n+impl<ID: ArenaId, T> ArenaMap<ID, T> {\n+    pub fn insert(&mut self, id: ID, t: T) {\n+        let idx = Self::to_idx(id);\n+        if self.v.capacity() <= idx {\n+            self.v.reserve(idx + 1 - self.v.capacity());\n+        }\n+        if self.v.len() <= idx {\n+            while self.v.len() <= idx {\n+                self.v.push(None);\n+            }\n+        }\n+        self.v[idx] = Some(t);\n+    }\n+\n+    pub fn get(&self, id: ID) -> Option<&T> {\n+        self.v.get(Self::to_idx(id)).and_then(|it| it.as_ref())\n+    }\n+\n+    pub fn values(&self) -> impl Iterator<Item = &T> {\n+        self.v.iter().filter_map(|o| o.as_ref())\n+    }\n+\n+    pub fn values_mut(&mut self) -> impl Iterator<Item = &mut T> {\n+        self.v.iter_mut().filter_map(|o| o.as_mut())\n+    }\n+\n+    pub fn iter(&self) -> impl Iterator<Item = (ID, &T)> {\n+        self.v\n+            .iter()\n+            .enumerate()\n+            .filter_map(|(idx, o)| Some((Self::from_idx(idx), o.as_ref()?)))\n+    }\n+\n+    fn to_idx(id: ID) -> usize {\n+        u32::from(id.into_raw()) as usize\n+    }\n+\n+    fn from_idx(idx: usize) -> ID {\n+        ID::from_raw((idx as u32).into())\n+    }\n+}\n+\n+impl<ID: ArenaId, T> std::ops::Index<ID> for ArenaMap<ID, T> {\n+    type Output = T;\n+    fn index(&self, id: ID) -> &T {\n+        self.v[Self::to_idx(id)].as_ref().unwrap()\n+    }\n+}\n+\n+impl<ID, T> Default for ArenaMap<ID, T> {\n+    fn default() -> Self {\n+        ArenaMap {\n+            v: Vec::new(),\n+            _ty: PhantomData,\n+        }\n+    }\n+}"}, {"sha": "b0063cad26de0a894c0ecfcf24e5bdfd3284e765", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 36, "deletions": 11, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7", "patch": "@@ -3,7 +3,7 @@ use std::sync::Arc;\n \n use rustc_hash::FxHashMap;\n \n-use ra_arena::{Arena, RawId, impl_arena_id};\n+use ra_arena::{Arena, RawId, impl_arena_id, map::ArenaMap};\n use ra_db::{LocalSyntaxPtr, Cancelable};\n use ra_syntax::ast::{self, AstNode, LoopBodyOwner, ArgListOwner, NameOwner};\n \n@@ -39,9 +39,9 @@ pub struct Body {\n pub struct BodySyntaxMapping {\n     body: Arc<Body>,\n     expr_syntax_mapping: FxHashMap<LocalSyntaxPtr, ExprId>,\n-    expr_syntax_mapping_back: FxHashMap<ExprId, LocalSyntaxPtr>,\n+    expr_syntax_mapping_back: ArenaMap<ExprId, LocalSyntaxPtr>,\n     pat_syntax_mapping: FxHashMap<LocalSyntaxPtr, PatId>,\n-    pat_syntax_mapping_back: FxHashMap<PatId, LocalSyntaxPtr>,\n+    pat_syntax_mapping_back: ArenaMap<PatId, LocalSyntaxPtr>,\n }\n \n impl Body {\n@@ -72,17 +72,27 @@ impl Index<PatId> for Body {\n \n impl BodySyntaxMapping {\n     pub fn expr_syntax(&self, expr: ExprId) -> Option<LocalSyntaxPtr> {\n-        self.expr_syntax_mapping_back.get(&expr).cloned()\n+        self.expr_syntax_mapping_back.get(expr).cloned()\n     }\n     pub fn syntax_expr(&self, ptr: LocalSyntaxPtr) -> Option<ExprId> {\n         self.expr_syntax_mapping.get(&ptr).cloned()\n     }\n+    pub fn node_expr(&self, node: ast::Expr) -> Option<ExprId> {\n+        self.expr_syntax_mapping\n+            .get(&LocalSyntaxPtr::new(node.syntax()))\n+            .cloned()\n+    }\n     pub fn pat_syntax(&self, pat: PatId) -> Option<LocalSyntaxPtr> {\n-        self.pat_syntax_mapping_back.get(&pat).cloned()\n+        self.pat_syntax_mapping_back.get(pat).cloned()\n     }\n     pub fn syntax_pat(&self, ptr: LocalSyntaxPtr) -> Option<PatId> {\n         self.pat_syntax_mapping.get(&ptr).cloned()\n     }\n+    pub fn node_pat(&self, node: ast::Pat) -> Option<PatId> {\n+        self.pat_syntax_mapping\n+            .get(&LocalSyntaxPtr::new(node.syntax()))\n+            .cloned()\n+    }\n \n     pub fn body(&self) -> &Arc<Body> {\n         &self.body\n@@ -159,14 +169,20 @@ pub enum Expr {\n         expr: ExprId,\n         op: Option<UnaryOp>,\n     },\n+    BinaryOp {\n+        lhs: ExprId,\n+        rhs: ExprId,\n+        op: Option<BinaryOp>,\n+    },\n     Lambda {\n         args: Vec<PatId>,\n         arg_types: Vec<Option<TypeRef>>,\n         body: ExprId,\n     },\n }\n \n-pub type UnaryOp = ast::PrefixOp;\n+pub use ra_syntax::ast::PrefixOp as UnaryOp;\n+pub use ra_syntax::ast::BinOp as BinaryOp;\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct MatchArm {\n@@ -266,6 +282,10 @@ impl Expr {\n             Expr::Lambda { body, .. } => {\n                 f(*body);\n             }\n+            Expr::BinaryOp { lhs, rhs, .. } => {\n+                f(*lhs);\n+                f(*rhs);\n+            }\n             Expr::Field { expr, .. }\n             | Expr::Try { expr }\n             | Expr::Cast { expr, .. }\n@@ -314,9 +334,9 @@ struct ExprCollector {\n     exprs: Arena<ExprId, Expr>,\n     pats: Arena<PatId, Pat>,\n     expr_syntax_mapping: FxHashMap<LocalSyntaxPtr, ExprId>,\n-    expr_syntax_mapping_back: FxHashMap<ExprId, LocalSyntaxPtr>,\n+    expr_syntax_mapping_back: ArenaMap<ExprId, LocalSyntaxPtr>,\n     pat_syntax_mapping: FxHashMap<LocalSyntaxPtr, PatId>,\n-    pat_syntax_mapping_back: FxHashMap<PatId, LocalSyntaxPtr>,\n+    pat_syntax_mapping_back: ArenaMap<PatId, LocalSyntaxPtr>,\n }\n \n impl ExprCollector {\n@@ -325,9 +345,9 @@ impl ExprCollector {\n             exprs: Arena::default(),\n             pats: Arena::default(),\n             expr_syntax_mapping: FxHashMap::default(),\n-            expr_syntax_mapping_back: FxHashMap::default(),\n+            expr_syntax_mapping_back: ArenaMap::default(),\n             pat_syntax_mapping: FxHashMap::default(),\n-            pat_syntax_mapping_back: FxHashMap::default(),\n+            pat_syntax_mapping_back: ArenaMap::default(),\n         }\n     }\n \n@@ -586,14 +606,19 @@ impl ExprCollector {\n                     syntax_ptr,\n                 )\n             }\n+            ast::Expr::BinExpr(e) => {\n+                let lhs = self.collect_expr_opt(e.lhs());\n+                let rhs = self.collect_expr_opt(e.rhs());\n+                let op = e.op();\n+                self.alloc_expr(Expr::BinaryOp { lhs, rhs, op }, syntax_ptr)\n+            }\n \n             // TODO implement HIR for these:\n             ast::Expr::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::Expr::IndexExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::Expr::TupleExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::Expr::ArrayExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::Expr::RangeExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n-            ast::Expr::BinExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::Expr::Literal(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n         }\n     }"}, {"sha": "d57990cd202a5504bab6250ce78b5a7f7174acec", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 229, "deletions": 317, "changes": 546, "blob_url": "https://github.com/rust-lang/rust/blob/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7", "patch": "@@ -17,25 +17,23 @@ mod primitive;\n #[cfg(test)]\n mod tests;\n \n+use std::ops::Index;\n use std::sync::Arc;\n use std::{fmt, mem};\n \n use log;\n-use rustc_hash::FxHashMap;\n use ena::unify::{InPlaceUnificationTable, UnifyKey, UnifyValue, NoError};\n+use ra_arena::map::ArenaMap;\n \n-use ra_db::{LocalSyntaxPtr, Cancelable};\n-use ra_syntax::{\n-    ast::{self, AstNode, LoopBodyOwner, ArgListOwner, PrefixOp, BinOp},\n-    SyntaxNodeRef\n-};\n+use ra_db::Cancelable;\n \n use crate::{\n-    Def, DefId, Module, Function, Struct, Enum, Path, Name, AsName, ImplBlock,\n+    Def, DefId, Module, Function, Struct, Enum, Path, Name, ImplBlock,\n+    FnSignature, FnScopes,\n     db::HirDatabase,\n     type_ref::{TypeRef, Mutability},\n     name::KnownName,\n-    ScopesWithSyntaxMapping,\n+    expr::{Body, Expr, ExprId, PatId, UnaryOp, BinaryOp, Statement},\n };\n \n /// The ID of a type variable.\n@@ -82,9 +80,10 @@ impl UnifyValue for TypeVarValue {\n         match (value1, value2) {\n             // We should never equate two type variables, both of which have\n             // known types. Instead, we recursively equate those types.\n-            (TypeVarValue::Known(..), TypeVarValue::Known(..)) => {\n-                panic!(\"equating two type variables, both of which have known types\")\n-            }\n+            (TypeVarValue::Known(t1), TypeVarValue::Known(t2)) => panic!(\n+                \"equating two type variables, both of which have known types: {:?} and {:?}\",\n+                t1, t2\n+            ),\n \n             // If one side is known, prefer that one.\n             (TypeVarValue::Known(..), TypeVarValue::Unknown) => Ok(value1.clone()),\n@@ -321,26 +320,6 @@ impl Ty {\n         Ok(ty)\n     }\n \n-    // TODO: These should not be necessary long-term, since everything will work on HIR\n-    pub(crate) fn from_ast_opt(\n-        db: &impl HirDatabase,\n-        module: &Module,\n-        impl_block: Option<&ImplBlock>,\n-        node: Option<ast::TypeRef>,\n-    ) -> Cancelable<Self> {\n-        node.map(|n| Ty::from_ast(db, module, impl_block, n))\n-            .unwrap_or(Ok(Ty::Unknown))\n-    }\n-\n-    pub(crate) fn from_ast(\n-        db: &impl HirDatabase,\n-        module: &Module,\n-        impl_block: Option<&ImplBlock>,\n-        node: ast::TypeRef,\n-    ) -> Cancelable<Self> {\n-        Ty::from_hir(db, module, impl_block, &TypeRef::from_ast(node))\n-    }\n-\n     pub fn unit() -> Self {\n         Ty::Tuple(Arc::new([]))\n     }\n@@ -417,26 +396,18 @@ impl fmt::Display for Ty {\n // Functions returning declared types for items\n \n /// Compute the declared type of a function. This should not need to look at the\n-/// function body (but currently uses the function AST, so does anyway - TODO).\n+/// function body.\n fn type_for_fn(db: &impl HirDatabase, f: Function) -> Cancelable<Ty> {\n-    let syntax = f.syntax(db);\n+    let signature = f.signature(db);\n     let module = f.module(db)?;\n     let impl_block = f.impl_block(db)?;\n-    let node = syntax.borrowed();\n     // TODO we ignore type parameters for now\n-    let input = node\n-        .param_list()\n-        .map(|pl| {\n-            pl.params()\n-                .map(|p| Ty::from_ast_opt(db, &module, impl_block.as_ref(), p.type_ref()))\n-                .collect()\n-        })\n-        .unwrap_or_else(|| Ok(Vec::new()))?;\n-    let output = if let Some(type_ref) = node.ret_type().and_then(|rt| rt.type_ref()) {\n-        Ty::from_ast(db, &module, impl_block.as_ref(), type_ref)?\n-    } else {\n-        Ty::unit()\n-    };\n+    let input = signature\n+        .args()\n+        .iter()\n+        .map(|tr| Ty::from_hir(db, &module, impl_block.as_ref(), tr))\n+        .collect::<Cancelable<Vec<_>>>()?;\n+    let output = Ty::from_hir(db, &module, impl_block.as_ref(), signature.ret_type())?;\n     let sig = FnSig { input, output };\n     Ok(Ty::FnPtr(Arc::new(sig)))\n }\n@@ -499,86 +470,103 @@ pub(super) fn type_for_field(db: &impl HirDatabase, def_id: DefId, field: Name)\n /// The result of type inference: A mapping from expressions and patterns to types.\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct InferenceResult {\n-    type_of: FxHashMap<LocalSyntaxPtr, Ty>,\n+    type_of_expr: ArenaMap<ExprId, Ty>,\n+    type_of_pat: ArenaMap<PatId, Ty>,\n }\n \n-impl InferenceResult {\n-    /// Returns the type of the given syntax node, if it was inferred. Will\n-    /// return `None` for syntax nodes not in the inferred function or not\n-    /// pointing to an expression/pattern, `Some(Ty::Unknown)` for\n-    /// expressions/patterns that could not be inferred.\n-    pub fn type_of_node(&self, node: SyntaxNodeRef) -> Option<Ty> {\n-        self.type_of.get(&LocalSyntaxPtr::new(node)).cloned()\n+impl Index<ExprId> for InferenceResult {\n+    type Output = Ty;\n+\n+    fn index(&self, expr: ExprId) -> &Ty {\n+        self.type_of_expr.get(expr).unwrap_or(&Ty::Unknown)\n+    }\n+}\n+\n+impl Index<PatId> for InferenceResult {\n+    type Output = Ty;\n+\n+    fn index(&self, pat: PatId) -> &Ty {\n+        self.type_of_pat.get(pat).unwrap_or(&Ty::Unknown)\n     }\n }\n \n /// The inference context contains all information needed during type inference.\n #[derive(Clone, Debug)]\n struct InferenceContext<'a, D: HirDatabase> {\n     db: &'a D,\n-    scopes: ScopesWithSyntaxMapping,\n-    /// The self param for the current method, if it exists.\n-    self_param: Option<LocalSyntaxPtr>,\n+    body: Arc<Body>,\n+    scopes: Arc<FnScopes>,\n     module: Module,\n     impl_block: Option<ImplBlock>,\n     var_unification_table: InPlaceUnificationTable<TypeVarId>,\n-    type_of: FxHashMap<LocalSyntaxPtr, Ty>,\n+    type_of_expr: ArenaMap<ExprId, Ty>,\n+    type_of_pat: ArenaMap<PatId, Ty>,\n     /// The return type of the function being inferred.\n     return_ty: Ty,\n }\n \n // helper function that determines whether a binary operator\n // always returns a boolean\n-fn is_boolean_operator(op: BinOp) -> bool {\n+fn is_boolean_operator(op: BinaryOp) -> bool {\n     match op {\n-        BinOp::BooleanOr\n-        | BinOp::BooleanAnd\n-        | BinOp::EqualityTest\n-        | BinOp::LesserEqualTest\n-        | BinOp::GreaterEqualTest\n-        | BinOp::LesserTest\n-        | BinOp::GreaterTest => true,\n+        BinaryOp::BooleanOr\n+        | BinaryOp::BooleanAnd\n+        | BinaryOp::EqualityTest\n+        | BinaryOp::LesserEqualTest\n+        | BinaryOp::GreaterEqualTest\n+        | BinaryOp::LesserTest\n+        | BinaryOp::GreaterTest => true,\n     }\n }\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn new(\n         db: &'a D,\n-        scopes: ScopesWithSyntaxMapping,\n+        body: Arc<Body>,\n+        scopes: Arc<FnScopes>,\n         module: Module,\n         impl_block: Option<ImplBlock>,\n     ) -> Self {\n         InferenceContext {\n-            type_of: FxHashMap::default(),\n+            type_of_expr: ArenaMap::default(),\n+            type_of_pat: ArenaMap::default(),\n             var_unification_table: InPlaceUnificationTable::new(),\n-            self_param: None,       // set during parameter typing\n             return_ty: Ty::Unknown, // set in collect_fn_signature\n             db,\n+            body,\n             scopes,\n             module,\n             impl_block,\n         }\n     }\n \n     fn resolve_all(mut self) -> InferenceResult {\n-        let mut types = mem::replace(&mut self.type_of, FxHashMap::default());\n-        for ty in types.values_mut() {\n+        let mut expr_types = mem::replace(&mut self.type_of_expr, ArenaMap::default());\n+        for ty in expr_types.values_mut() {\n+            let resolved = self.resolve_ty_completely(mem::replace(ty, Ty::Unknown));\n+            *ty = resolved;\n+        }\n+        let mut pat_types = mem::replace(&mut self.type_of_pat, ArenaMap::default());\n+        for ty in pat_types.values_mut() {\n             let resolved = self.resolve_ty_completely(mem::replace(ty, Ty::Unknown));\n             *ty = resolved;\n         }\n-        InferenceResult { type_of: types }\n+        InferenceResult {\n+            type_of_expr: expr_types,\n+            type_of_pat: pat_types,\n+        }\n     }\n \n-    fn write_ty(&mut self, node: SyntaxNodeRef, ty: Ty) {\n-        self.type_of.insert(LocalSyntaxPtr::new(node), ty);\n+    fn write_expr_ty(&mut self, expr: ExprId, ty: Ty) {\n+        self.type_of_expr.insert(expr, ty);\n     }\n \n-    fn make_ty(&self, type_ref: &TypeRef) -> Cancelable<Ty> {\n-        Ty::from_hir(self.db, &self.module, self.impl_block.as_ref(), type_ref)\n+    fn write_pat_ty(&mut self, pat: PatId, ty: Ty) {\n+        self.type_of_pat.insert(pat, ty);\n     }\n \n-    fn make_ty_opt(&self, type_ref: Option<&TypeRef>) -> Cancelable<Ty> {\n-        Ty::from_hir_opt(self.db, &self.module, self.impl_block.as_ref(), type_ref)\n+    fn make_ty(&self, type_ref: &TypeRef) -> Cancelable<Ty> {\n+        Ty::from_hir(self.db, &self.module, self.impl_block.as_ref(), type_ref)\n     }\n \n     fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n@@ -673,23 +661,15 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         })\n     }\n \n-    fn infer_path_expr(&mut self, expr: ast::PathExpr) -> Cancelable<Option<Ty>> {\n-        let ast_path = ctry!(expr.path());\n-        let path = ctry!(Path::from_ast(ast_path));\n-        if path.is_ident() {\n+    fn infer_path_expr(&mut self, expr: ExprId, path: &Path) -> Cancelable<Option<Ty>> {\n+        if path.is_ident() || path.is_self() {\n             // resolve locally\n-            let name = ctry!(ast_path.segment().and_then(|s| s.name_ref()));\n-            if let Some(scope_entry) = self.scopes.resolve_local_name(name) {\n-                let ty = ctry!(self.type_of.get(&scope_entry.ptr()));\n+            let name = path.as_ident().cloned().unwrap_or_else(Name::self_param);\n+            if let Some(scope_entry) = self.scopes.resolve_local_name(expr, name) {\n+                let ty = ctry!(self.type_of_pat.get(scope_entry.pat()));\n                 let ty = self.resolve_ty_as_possible(ty.clone());\n                 return Ok(Some(ty));\n             };\n-        } else if path.is_self() {\n-            // resolve `self` param\n-            let self_param = ctry!(self.self_param);\n-            let ty = ctry!(self.type_of.get(&self_param));\n-            let ty = self.resolve_ty_as_possible(ty.clone());\n-            return Ok(Some(ty));\n         };\n \n         // resolve in module\n@@ -699,8 +679,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         Ok(Some(ty))\n     }\n \n-    fn resolve_variant(&self, path: Option<ast::Path>) -> Cancelable<(Ty, Option<DefId>)> {\n-        let path = if let Some(path) = path.and_then(Path::from_ast) {\n+    fn resolve_variant(&self, path: Option<&Path>) -> Cancelable<(Ty, Option<DefId>)> {\n+        let path = if let Some(path) = path {\n             path\n         } else {\n             return Ok((Ty::Unknown, None));\n@@ -719,74 +699,51 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         })\n     }\n \n-    fn infer_expr_opt(\n-        &mut self,\n-        expr: Option<ast::Expr>,\n-        expected: &Expectation,\n-    ) -> Cancelable<Ty> {\n-        if let Some(e) = expr {\n-            self.infer_expr(e, expected)\n-        } else {\n-            Ok(Ty::Unknown)\n-        }\n-    }\n-\n-    fn infer_expr(&mut self, expr: ast::Expr, expected: &Expectation) -> Cancelable<Ty> {\n-        let ty = match expr {\n-            ast::Expr::IfExpr(e) => {\n-                if let Some(condition) = e.condition() {\n-                    let expected = if condition.pat().is_none() {\n-                        Expectation::has_type(Ty::Bool)\n-                    } else {\n-                        Expectation::none()\n-                    };\n-                    self.infer_expr_opt(condition.expr(), &expected)?;\n-                    // TODO write type for pat\n-                };\n-                let if_ty = self.infer_block_opt(e.then_branch(), expected)?;\n-                if let Some(else_branch) = e.else_branch() {\n-                    self.infer_block(else_branch, expected)?;\n+    fn infer_expr(&mut self, expr: ExprId, expected: &Expectation) -> Cancelable<Ty> {\n+        let body = Arc::clone(&self.body); // avoid borrow checker problem\n+        let ty = match &body[expr] {\n+            Expr::Missing => Ty::Unknown,\n+            Expr::If {\n+                condition,\n+                then_branch,\n+                else_branch,\n+            } => {\n+                // if let is desugared to match, so this is always simple if\n+                self.infer_expr(*condition, &Expectation::has_type(Ty::Bool))?;\n+                let then_ty = self.infer_expr(*then_branch, expected)?;\n+                if let Some(else_branch) = else_branch {\n+                    self.infer_expr(*else_branch, expected)?;\n                 } else {\n                     // no else branch -> unit\n                     self.unify(&expected.ty, &Ty::unit()); // actually coerce\n                 }\n-                if_ty\n+                then_ty\n             }\n-            ast::Expr::BlockExpr(e) => self.infer_block_opt(e.block(), expected)?,\n-            ast::Expr::LoopExpr(e) => {\n-                self.infer_block_opt(e.loop_body(), &Expectation::has_type(Ty::unit()))?;\n-                // TODO never, or the type of the break param\n-                Ty::Unknown\n+            Expr::Block { statements, tail } => self.infer_block(statements, *tail, expected)?,\n+            Expr::Loop { body } => {\n+                self.infer_expr(*body, &Expectation::has_type(Ty::unit()))?;\n+                // TODO handle break with value\n+                Ty::Never\n             }\n-            ast::Expr::WhileExpr(e) => {\n-                if let Some(condition) = e.condition() {\n-                    let expected = if condition.pat().is_none() {\n-                        Expectation::has_type(Ty::Bool)\n-                    } else {\n-                        Expectation::none()\n-                    };\n-                    self.infer_expr_opt(condition.expr(), &expected)?;\n-                    // TODO write type for pat\n-                };\n-                self.infer_block_opt(e.loop_body(), &Expectation::has_type(Ty::unit()))?;\n-                // TODO always unit?\n+            Expr::While { condition, body } => {\n+                // while let is desugared to a match loop, so this is always simple while\n+                self.infer_expr(*condition, &Expectation::has_type(Ty::Bool))?;\n+                self.infer_expr(*body, &Expectation::has_type(Ty::unit()))?;\n                 Ty::unit()\n             }\n-            ast::Expr::ForExpr(e) => {\n-                let _iterable_ty = self.infer_expr_opt(e.iterable(), &Expectation::none());\n-                if let Some(_pat) = e.pat() {\n-                    // TODO write type for pat\n-                }\n-                self.infer_block_opt(e.loop_body(), &Expectation::has_type(Ty::unit()))?;\n-                // TODO always unit?\n+            Expr::For { iterable, body, .. } => {\n+                let _iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n+                // TODO write type for pat\n+                self.infer_expr(*body, &Expectation::has_type(Ty::unit()))?;\n                 Ty::unit()\n             }\n-            ast::Expr::LambdaExpr(e) => {\n-                let _body_ty = self.infer_expr_opt(e.body(), &Expectation::none())?;\n+            Expr::Lambda { body, .. } => {\n+                // TODO write types for args, infer lambda type etc.\n+                let _body_ty = self.infer_expr(*body, &Expectation::none())?;\n                 Ty::Unknown\n             }\n-            ast::Expr::CallExpr(e) => {\n-                let callee_ty = self.infer_expr_opt(e.expr(), &Expectation::none())?;\n+            Expr::Call { callee, args } => {\n+                let callee_ty = self.infer_expr(*callee, &Expectation::none())?;\n                 let (arg_tys, ret_ty) = match &callee_ty {\n                     Ty::FnPtr(sig) => (&sig.input[..], sig.output.clone()),\n                     _ => {\n@@ -795,112 +752,102 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         (&[][..], Ty::Unknown)\n                     }\n                 };\n-                if let Some(arg_list) = e.arg_list() {\n-                    for (i, arg) in arg_list.args().enumerate() {\n-                        self.infer_expr(\n-                            arg,\n-                            &Expectation::has_type(arg_tys.get(i).cloned().unwrap_or(Ty::Unknown)),\n-                        )?;\n-                    }\n+                for (i, arg) in args.iter().enumerate() {\n+                    self.infer_expr(\n+                        *arg,\n+                        &Expectation::has_type(arg_tys.get(i).cloned().unwrap_or(Ty::Unknown)),\n+                    )?;\n                 }\n                 ret_ty\n             }\n-            ast::Expr::MethodCallExpr(e) => {\n-                let _receiver_ty = self.infer_expr_opt(e.expr(), &Expectation::none())?;\n-                if let Some(arg_list) = e.arg_list() {\n-                    for arg in arg_list.args() {\n-                        // TODO unify / expect argument type\n-                        self.infer_expr(arg, &Expectation::none())?;\n-                    }\n+            Expr::MethodCall { receiver, args, .. } => {\n+                let _receiver_ty = self.infer_expr(*receiver, &Expectation::none())?;\n+                // TODO resolve method...\n+                for (_i, arg) in args.iter().enumerate() {\n+                    // TODO unify / expect argument type\n+                    self.infer_expr(*arg, &Expectation::none())?;\n                 }\n                 Ty::Unknown\n             }\n-            ast::Expr::MatchExpr(e) => {\n-                let _ty = self.infer_expr_opt(e.expr(), &Expectation::none())?;\n-                if let Some(match_arm_list) = e.match_arm_list() {\n-                    for arm in match_arm_list.arms() {\n-                        // TODO type the bindings in pat\n-                        // TODO type the guard\n-                        let _ty = self.infer_expr_opt(arm.expr(), &Expectation::none())?;\n-                    }\n-                    // TODO unify all the match arm types\n-                    Ty::Unknown\n-                } else {\n-                    Ty::Unknown\n+            Expr::Match { expr, arms } => {\n+                let _ty = self.infer_expr(*expr, &Expectation::none())?;\n+                for arm in arms {\n+                    // TODO type the bindings in pats\n+                    // TODO type the guard\n+                    let _ty = self.infer_expr(arm.expr, &Expectation::none())?;\n                 }\n+                // TODO unify all the match arm types\n+                Ty::Unknown\n             }\n-            ast::Expr::TupleExpr(_e) => Ty::Unknown,\n-            ast::Expr::ArrayExpr(_e) => Ty::Unknown,\n-            ast::Expr::PathExpr(e) => self.infer_path_expr(e)?.unwrap_or(Ty::Unknown),\n-            ast::Expr::ContinueExpr(_e) => Ty::Never,\n-            ast::Expr::BreakExpr(_e) => Ty::Never,\n-            ast::Expr::ParenExpr(e) => self.infer_expr_opt(e.expr(), expected)?,\n-            ast::Expr::Label(_e) => Ty::Unknown,\n-            ast::Expr::ReturnExpr(e) => {\n-                // TODO expect return type of function\n-                self.infer_expr_opt(e.expr(), &Expectation::none())?;\n+            Expr::Path(p) => self.infer_path_expr(expr, p)?.unwrap_or(Ty::Unknown),\n+            Expr::Continue => Ty::Never,\n+            Expr::Break { expr } => {\n+                if let Some(expr) = expr {\n+                    // TODO handle break with value\n+                    self.infer_expr(*expr, &Expectation::none())?;\n+                }\n                 Ty::Never\n             }\n-            ast::Expr::StructLit(e) => {\n-                let (ty, def_id) = self.resolve_variant(e.path())?;\n-                if let Some(nfl) = e.named_field_list() {\n-                    for field in nfl.fields() {\n-                        let field_ty = if let (Some(def_id), Some(nr)) = (def_id, field.name_ref())\n-                        {\n-                            self.db.type_for_field(def_id, nr.as_name())?\n-                        } else {\n-                            Ty::Unknown\n-                        };\n-                        self.infer_expr_opt(field.expr(), &Expectation::has_type(field_ty))?;\n-                    }\n+            Expr::Return { expr } => {\n+                if let Some(expr) = expr {\n+                    self.infer_expr(*expr, &Expectation::has_type(self.return_ty.clone()))?;\n                 }\n-                ty\n+                Ty::Never\n             }\n-            ast::Expr::IndexExpr(_e) => Ty::Unknown,\n-            ast::Expr::FieldExpr(e) => {\n-                let receiver_ty = self.infer_expr_opt(e.expr(), &Expectation::none())?;\n-                if let Some(nr) = e.name_ref() {\n-                    let ty = match receiver_ty {\n-                        Ty::Tuple(fields) => {\n-                            let i = nr.text().parse::<usize>().ok();\n-                            i.and_then(|i| fields.get(i).cloned())\n-                                .unwrap_or(Ty::Unknown)\n-                        }\n-                        Ty::Adt { def_id, .. } => self.db.type_for_field(def_id, nr.as_name())?,\n-                        _ => Ty::Unknown,\n+            Expr::StructLit {\n+                path,\n+                fields,\n+                spread,\n+            } => {\n+                let (ty, def_id) = self.resolve_variant(path.as_ref())?;\n+                for field in fields {\n+                    let field_ty = if let Some(def_id) = def_id {\n+                        self.db.type_for_field(def_id, field.name.clone())?\n+                    } else {\n+                        Ty::Unknown\n                     };\n-                    self.insert_type_vars(ty)\n-                } else {\n-                    Ty::Unknown\n+                    self.infer_expr(field.expr, &Expectation::has_type(field_ty))?;\n+                }\n+                if let Some(expr) = spread {\n+                    self.infer_expr(*expr, &Expectation::has_type(ty.clone()))?;\n                 }\n+                ty\n+            }\n+            Expr::Field { expr, name } => {\n+                let receiver_ty = self.infer_expr(*expr, &Expectation::none())?;\n+                let ty = match receiver_ty {\n+                    Ty::Tuple(fields) => {\n+                        let i = name.to_string().parse::<usize>().ok();\n+                        i.and_then(|i| fields.get(i).cloned())\n+                            .unwrap_or(Ty::Unknown)\n+                    }\n+                    Ty::Adt { def_id, .. } => self.db.type_for_field(def_id, name.clone())?,\n+                    _ => Ty::Unknown,\n+                };\n+                self.insert_type_vars(ty)\n             }\n-            ast::Expr::TryExpr(e) => {\n-                let _inner_ty = self.infer_expr_opt(e.expr(), &Expectation::none())?;\n+            Expr::Try { expr } => {\n+                let _inner_ty = self.infer_expr(*expr, &Expectation::none())?;\n                 Ty::Unknown\n             }\n-            ast::Expr::CastExpr(e) => {\n-                let _inner_ty = self.infer_expr_opt(e.expr(), &Expectation::none())?;\n-                let cast_ty = Ty::from_ast_opt(\n-                    self.db,\n-                    &self.module,\n-                    self.impl_block.as_ref(),\n-                    e.type_ref(),\n-                )?;\n+            Expr::Cast { expr, type_ref } => {\n+                let _inner_ty = self.infer_expr(*expr, &Expectation::none())?;\n+                let cast_ty =\n+                    Ty::from_hir(self.db, &self.module, self.impl_block.as_ref(), type_ref)?;\n                 let cast_ty = self.insert_type_vars(cast_ty);\n-                // TODO do the coercion...\n+                // TODO check the cast...\n                 cast_ty\n             }\n-            ast::Expr::RefExpr(e) => {\n+            Expr::Ref { expr, mutability } => {\n                 // TODO pass the expectation down\n-                let inner_ty = self.infer_expr_opt(e.expr(), &Expectation::none())?;\n-                let m = Mutability::from_mutable(e.is_mut());\n+                let inner_ty = self.infer_expr(*expr, &Expectation::none())?;\n                 // TODO reference coercions etc.\n-                Ty::Ref(Arc::new(inner_ty), m)\n+                Ty::Ref(Arc::new(inner_ty), *mutability)\n             }\n-            ast::Expr::PrefixExpr(e) => {\n-                let inner_ty = self.infer_expr_opt(e.expr(), &Expectation::none())?;\n-                match e.op() {\n-                    Some(PrefixOp::Deref) => {\n+            Expr::UnaryOp { expr, op } => {\n+                let inner_ty = self.infer_expr(*expr, &Expectation::none())?;\n+                match op {\n+                    Some(UnaryOp::Deref) => {\n                         match inner_ty {\n                             // builtin deref:\n                             Ty::Ref(ref_inner, _) => (*ref_inner).clone(),\n@@ -912,147 +859,112 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     _ => Ty::Unknown,\n                 }\n             }\n-            ast::Expr::RangeExpr(_e) => Ty::Unknown,\n-            ast::Expr::BinExpr(e) => match e.op() {\n+            Expr::BinaryOp { lhs, rhs, op } => match op {\n                 Some(op) => {\n                     let subtype_expectation = match op {\n-                        BinOp::BooleanAnd | BinOp::BooleanOr => Expectation::has_type(Ty::Bool),\n+                        BinaryOp::BooleanAnd | BinaryOp::BooleanOr => {\n+                            Expectation::has_type(Ty::Bool)\n+                        }\n                         _ => Expectation::none(),\n                     };\n-                    let (lhs, rhs) = e.sub_exprs();\n-                    let _lhs_ty = self.infer_expr_opt(lhs, &subtype_expectation)?;\n-                    let _rhs_ty = self.infer_expr_opt(rhs, &subtype_expectation)?;\n+                    let _lhs_ty = self.infer_expr(*lhs, &subtype_expectation)?;\n+                    let _rhs_ty = self.infer_expr(*rhs, &subtype_expectation)?;\n \n-                    if is_boolean_operator(op) {\n+                    if is_boolean_operator(*op) {\n                         Ty::Bool\n                     } else {\n                         Ty::Unknown\n                     }\n                 }\n                 _ => Ty::Unknown,\n             },\n-            ast::Expr::Literal(_e) => Ty::Unknown,\n         };\n         // use a new type variable if we got Ty::Unknown here\n         let ty = self.insert_type_vars_shallow(ty);\n         self.unify(&ty, &expected.ty);\n-        self.write_ty(expr.syntax(), ty.clone());\n+        let ty = self.resolve_ty_as_possible(ty);\n+        self.write_expr_ty(expr, ty.clone());\n         Ok(ty)\n     }\n \n-    fn infer_block_opt(\n+    fn infer_block(\n         &mut self,\n-        node: Option<ast::Block>,\n+        statements: &[Statement],\n+        tail: Option<ExprId>,\n         expected: &Expectation,\n     ) -> Cancelable<Ty> {\n-        if let Some(b) = node {\n-            self.infer_block(b, expected)\n-        } else {\n-            Ok(Ty::Unknown)\n-        }\n-    }\n-\n-    fn infer_block(&mut self, node: ast::Block, expected: &Expectation) -> Cancelable<Ty> {\n-        for stmt in node.statements() {\n+        for stmt in statements {\n             match stmt {\n-                ast::Stmt::LetStmt(stmt) => {\n-                    let decl_ty = Ty::from_ast_opt(\n+                Statement::Let {\n+                    pat,\n+                    type_ref,\n+                    initializer,\n+                } => {\n+                    let decl_ty = Ty::from_hir_opt(\n                         self.db,\n                         &self.module,\n                         self.impl_block.as_ref(),\n-                        stmt.type_ref(),\n+                        type_ref.as_ref(),\n                     )?;\n                     let decl_ty = self.insert_type_vars(decl_ty);\n-                    let ty = if let Some(expr) = stmt.initializer() {\n-                        let expr_ty = self.infer_expr(expr, &Expectation::has_type(decl_ty))?;\n+                    let ty = if let Some(expr) = initializer {\n+                        let expr_ty = self.infer_expr(*expr, &Expectation::has_type(decl_ty))?;\n                         expr_ty\n                     } else {\n                         decl_ty\n                     };\n \n-                    if let Some(pat) = stmt.pat() {\n-                        self.write_ty(pat.syntax(), ty);\n-                    };\n+                    self.write_pat_ty(*pat, ty);\n                 }\n-                ast::Stmt::ExprStmt(expr_stmt) => {\n-                    self.infer_expr_opt(expr_stmt.expr(), &Expectation::none())?;\n+                Statement::Expr(expr) => {\n+                    self.infer_expr(*expr, &Expectation::none())?;\n                 }\n             }\n         }\n-        let ty = if let Some(expr) = node.expr() {\n+        let ty = if let Some(expr) = tail {\n             self.infer_expr(expr, expected)?\n         } else {\n             Ty::unit()\n         };\n-        self.write_ty(node.syntax(), ty.clone());\n         Ok(ty)\n     }\n \n-    fn collect_fn_signature(&mut self, node: ast::FnDef) -> Cancelable<()> {\n-        if let Some(param_list) = node.param_list() {\n-            if let Some(self_param) = param_list.self_param() {\n-                let self_type = if let Some(type_ref) = self_param.type_ref() {\n-                    let ty = self.make_ty(&TypeRef::from_ast(type_ref))?;\n-                    self.insert_type_vars(ty)\n-                } else {\n-                    // TODO this should be handled by desugaring during HIR conversion\n-                    let ty = self.make_ty_opt(self.impl_block.as_ref().map(|i| i.target_type()))?;\n-                    let ty = match self_param.flavor() {\n-                        ast::SelfParamFlavor::Owned => ty,\n-                        ast::SelfParamFlavor::Ref => Ty::Ref(Arc::new(ty), Mutability::Shared),\n-                        ast::SelfParamFlavor::MutRef => Ty::Ref(Arc::new(ty), Mutability::Mut),\n-                    };\n-                    self.insert_type_vars(ty)\n-                };\n-                if let Some(self_kw) = self_param.self_kw() {\n-                    let self_param = LocalSyntaxPtr::new(self_kw.syntax());\n-                    self.self_param = Some(self_param);\n-                    self.type_of.insert(self_param, self_type);\n-                }\n-            }\n-            for param in param_list.params() {\n-                let pat = if let Some(pat) = param.pat() {\n-                    pat\n-                } else {\n-                    continue;\n-                };\n-                let ty = if let Some(type_ref) = param.type_ref() {\n-                    let ty = self.make_ty(&TypeRef::from_ast(type_ref))?;\n-                    self.insert_type_vars(ty)\n-                } else {\n-                    // missing type annotation\n-                    self.new_type_var()\n-                };\n-                self.type_of.insert(LocalSyntaxPtr::new(pat.syntax()), ty);\n-            }\n+    fn collect_fn_signature(&mut self, signature: &FnSignature) -> Cancelable<()> {\n+        let body = Arc::clone(&self.body); // avoid borrow checker problem\n+        for (type_ref, pat) in signature.args().iter().zip(body.args()) {\n+            let ty = self.make_ty(type_ref)?;\n+            let ty = self.insert_type_vars(ty);\n+            self.write_pat_ty(*pat, ty);\n         }\n-\n-        self.return_ty = if let Some(type_ref) = node.ret_type().and_then(|n| n.type_ref()) {\n-            let ty = self.make_ty(&TypeRef::from_ast(type_ref))?;\n-            self.insert_type_vars(ty)\n-        } else {\n-            Ty::unit()\n+        self.return_ty = {\n+            let ty = self.make_ty(signature.ret_type())?;\n+            let ty = self.insert_type_vars(ty);\n+            ty\n         };\n+        Ok(())\n+    }\n \n+    fn infer_body(&mut self) -> Cancelable<()> {\n+        self.infer_expr(\n+            self.body.body_expr(),\n+            &Expectation::has_type(self.return_ty.clone()),\n+        )?;\n         Ok(())\n     }\n }\n \n pub fn infer(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<InferenceResult>> {\n     let function = Function::new(def_id); // TODO: consts also need inference\n-    let scopes = function.scopes(db)?;\n+    let body = function.body(db)?;\n+    let scopes = db.fn_scopes(def_id)?;\n     let module = function.module(db)?;\n     let impl_block = function.impl_block(db)?;\n-    let mut ctx = InferenceContext::new(db, scopes, module, impl_block);\n-\n-    let syntax = function.syntax(db);\n-    let node = syntax.borrowed();\n+    let mut ctx = InferenceContext::new(db, body, scopes, module, impl_block);\n \n-    ctx.collect_fn_signature(node)?;\n+    let signature = function.signature(db);\n+    ctx.collect_fn_signature(&signature)?;\n \n-    if let Some(block) = node.body() {\n-        ctx.infer_block(block, &Expectation::has_type(ctx.return_ty.clone()))?;\n-    }\n+    ctx.infer_body()?;\n \n     Ok(Arc::new(ctx.resolve_all()))\n }"}, {"sha": "83aedaa005a5e58ad4d7ec8810898c1208faf1ea", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 28, "deletions": 11, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7", "patch": "@@ -5,7 +5,7 @@ use std::fs;\n \n use salsa::Database;\n \n-use ra_db::{SyntaxDatabase};\n+use ra_db::SyntaxDatabase;\n use ra_syntax::ast::{self, AstNode};\n use test_utils::{project_dir, assert_eq_text, read_text};\n \n@@ -34,7 +34,7 @@ fn test(a: u32, b: isize, c: !, d: &str) {\n     \"test\";\n     1.0f32;\n }\"#,\n-        \"0001_basics.txt\",\n+        \"basics.txt\",\n     );\n }\n \n@@ -48,7 +48,7 @@ fn test() {\n     let c = b;\n }\n }\"#,\n-        \"0002_let.txt\",\n+        \"let.txt\",\n     );\n }\n \n@@ -67,7 +67,7 @@ fn test() {\n     b::c();\n }\n }\"#,\n-        \"0003_paths.txt\",\n+        \"paths.txt\",\n     );\n }\n \n@@ -90,7 +90,7 @@ fn test() {\n     a.c;\n }\n \"#,\n-        \"0004_struct.txt\",\n+        \"struct.txt\",\n     );\n }\n \n@@ -112,7 +112,7 @@ fn test(a: &u32, b: &mut u32, c: *const u32, d: *mut u32) {\n     *d;\n }\n \"#,\n-        \"0005_refs.txt\",\n+        \"refs_and_ptrs.txt\",\n     );\n }\n \n@@ -133,7 +133,7 @@ fn test() -> &mut &f64 {\n     &mut &c\n }\n \"#,\n-        \"0006_backwards.txt\",\n+        \"backwards.txt\",\n     );\n }\n \n@@ -152,7 +152,7 @@ impl S {\n     }\n }\n \"#,\n-        \"0007_self.txt\",\n+        \"self.txt\",\n     );\n }\n \n@@ -176,7 +176,7 @@ fn test() {\n     10 < 3\n }\n \"#,\n-        \"0008_boolean_op.txt\",\n+        \"boolean_op.txt\",\n     );\n }\n \n@@ -193,7 +193,25 @@ fn infer(content: &str) -> String {\n             .unwrap()\n             .unwrap();\n         let inference_result = func.infer(&db).unwrap();\n-        for (syntax_ptr, ty) in &inference_result.type_of {\n+        let body_syntax_mapping = func.body_syntax_mapping(&db).unwrap();\n+        let mut types = Vec::new();\n+        for (pat, ty) in inference_result.type_of_pat.iter() {\n+            let syntax_ptr = match body_syntax_mapping.pat_syntax(pat) {\n+                Some(sp) => sp,\n+                None => continue,\n+            };\n+            types.push((syntax_ptr, ty));\n+        }\n+        for (expr, ty) in inference_result.type_of_expr.iter() {\n+            let syntax_ptr = match body_syntax_mapping.expr_syntax(expr) {\n+                Some(sp) => sp,\n+                None => continue,\n+            };\n+            types.push((syntax_ptr, ty));\n+        }\n+        // sort ranges for consistency\n+        types.sort_by_key(|(ptr, _)| (ptr.range().start(), ptr.range().end()));\n+        for (syntax_ptr, ty) in &types {\n             let node = syntax_ptr.resolve(&source_file);\n             write!(\n                 acc,\n@@ -246,7 +264,6 @@ fn test_data_dir() -> PathBuf {\n }\n \n #[test]\n-#[should_panic] // TODO this should work once hir::Expr is used\n fn typing_whitespace_inside_a_function_should_not_invalidate_types() {\n     let (mut db, pos) = MockDatabase::with_position(\n         \""}, {"sha": "b6807fb2a96210fb52e1db1cbc344ed7e97b0dd8", "filename": "crates/ra_hir/src/ty/tests/data/backwards.txt", "status": "renamed", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fbackwards.txt", "raw_url": "https://github.com/rust-lang/rust/raw/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fbackwards.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fbackwards.txt?ref=c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7", "patch": "@@ -1,20 +1,20 @@\n-[22; 24) '{}': ()\n [14; 15) 'x': u32\n-[142; 158) 'unknow...nction': [unknown]\n-[126; 127) 'a': u32\n-[198; 216) 'unknow...tion()': f64\n-[228; 229) 'c': f64\n-[198; 214) 'unknow...nction': [unknown]\n-[166; 184) 'S { i3...d: b }': S\n-[222; 229) '&mut &c': &mut &f64\n-[194; 195) 'c': f64\n-[92; 110) 'unknow...tion()': u32\n-[142; 160) 'unknow...tion()': i32\n-[92; 108) 'unknow...nction': [unknown]\n-[116; 128) 'takes_u32(a)': ()\n+[22; 24) '{}': ()\n [78; 231) '{     ...t &c }': &mut &f64\n-[227; 229) '&c': &f64\n [88; 89) 'a': u32\n-[181; 182) 'b': i32\n+[92; 108) 'unknow...nction': [unknown]\n+[92; 110) 'unknow...tion()': u32\n [116; 125) 'takes_u32': fn(u32,) -> ()\n+[116; 128) 'takes_u32(a)': ()\n+[126; 127) 'a': u32\n [138; 139) 'b': i32\n+[142; 158) 'unknow...nction': [unknown]\n+[142; 160) 'unknow...tion()': i32\n+[166; 184) 'S { i3...d: b }': S\n+[181; 182) 'b': i32\n+[194; 195) 'c': f64\n+[198; 214) 'unknow...nction': [unknown]\n+[198; 216) 'unknow...tion()': f64\n+[222; 229) '&mut &c': &mut &f64\n+[227; 229) '&c': &f64\n+[228; 229) 'c': f64", "previous_filename": "crates/ra_hir/src/ty/tests/data/0006_backwards.txt"}, {"sha": "8ea244ba87b19f724fed46e9f3c98a3c5c7d4ab1", "filename": "crates/ra_hir/src/ty/tests/data/basics.txt", "status": "renamed", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fbasics.txt", "raw_url": "https://github.com/rust-lang/rust/raw/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fbasics.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fbasics.txt?ref=c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7", "patch": "@@ -1,13 +1,13 @@\n+[9; 10) 'a': u32\n+[17; 18) 'b': isize\n+[27; 28) 'c': !\n [33; 34) 'd': &[unknown]\n-[88; 94) '1isize': [unknown]\n+[42; 121) '{     ...f32; }': ()\n [48; 49) 'a': u32\n [55; 56) 'b': isize\n-[112; 118) '1.0f32': [unknown]\n-[76; 82) '1usize': [unknown]\n-[9; 10) 'a': u32\n-[27; 28) 'c': !\n [62; 63) 'c': !\n-[17; 18) 'b': isize\n-[100; 106) '\"test\"': [unknown]\n-[42; 121) '{     ...f32; }': ()\n [69; 70) 'd': &[unknown]\n+[76; 82) '1usize': [unknown]\n+[88; 94) '1isize': [unknown]\n+[100; 106) '\"test\"': [unknown]\n+[112; 118) '1.0f32': [unknown]", "previous_filename": "crates/ra_hir/src/ty/tests/data/0001_basics.txt"}, {"sha": "cce8d68fb4b4fa44673066ccb03b138f9833f272", "filename": "crates/ra_hir/src/ty/tests/data/boolean_op.txt", "status": "renamed", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fboolean_op.txt", "raw_url": "https://github.com/rust-lang/rust/raw/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fboolean_op.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fboolean_op.txt?ref=c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7", "patch": "@@ -1,31 +1,31 @@\n-[28; 32) '0i32': i32\n-[22; 34) '{     0i32 }': i32\n [6; 7) 'x': [unknown]\n-[127; 134) 'CONST_1': [unknown]\n-[201; 205) '3i32': bool\n-[76; 77) 'y': bool\n-[65; 66) 'b': bool\n+[22; 34) '{     0i32 }': i32\n+[28; 32) '0i32': i32\n+[46; 237) '{     ... < 3 }': bool\n+[56; 57) 'x': bool\n+[60; 61) 'a': bool\n [60; 66) 'a && b': bool\n+[65; 66) 'b': bool\n+[76; 77) 'y': bool\n+[80; 84) 'true': bool\n+[80; 93) 'true || false': bool\n+[88; 93) 'false': bool\n+[103; 104) 'z': bool\n+[107; 108) 'x': bool\n+[107; 113) 'x == y': bool\n+[112; 113) 'y': bool\n+[123; 124) 'h': bool\n+[127; 134) 'CONST_1': [unknown]\n [127; 145) 'CONST_...ONST_2': bool\n+[138; 145) 'CONST_2': [unknown]\n+[155; 156) 'c': [unknown]\n+[159; 172) 'f(z || y) + 5': [unknown]\n [182; 183) 'd': [unknown]\n-[229; 231) '10': [unknown]\n-[209; 222) '\"hello world\"': bool\n-[229; 235) '10 < 3': bool\n [186; 187) 'b': [unknown]\n-[159; 172) 'f(z || y) + 5': [unknown]\n-[56; 57) 'x': bool\n-[112; 113) 'y': bool\n+[197; 198) 'e': bool\n+[201; 205) '3i32': bool\n [201; 222) '3i32 &...world\"': bool\n+[209; 222) '\"hello world\"': bool\n+[229; 231) '10': [unknown]\n+[229; 235) '10 < 3': bool\n [234; 235) '3': [unknown]\n-[138; 145) 'CONST_2': [unknown]\n-[80; 93) 'true || false': bool\n-[46; 237) '{     ... < 3 }': bool\n-[197; 198) 'e': bool\n-[107; 113) 'x == y': bool\n-[88; 93) 'false': bool\n-[80; 84) 'true': bool\n-[123; 124) 'h': bool\n-[155; 156) 'c': [unknown]\n-[103; 104) 'z': bool\n-[60; 61) 'a': bool\n-[107; 108) 'x': bool", "previous_filename": "crates/ra_hir/src/ty/tests/data/0008_boolean_op.txt"}, {"sha": "30f4a2cf52a938cbe0ea1a8f13ac4c337eeb3457", "filename": "crates/ra_hir/src/ty/tests/data/let.txt", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Flet.txt", "raw_url": "https://github.com/rust-lang/rust/raw/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Flet.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Flet.txt?ref=c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7", "patch": "@@ -1,7 +1,7 @@\n-[21; 22) 'a': [unknown]\n-[52; 53) '1': usize\n [11; 71) '{     ...= b; }': ()\n-[63; 64) 'c': usize\n+[21; 22) 'a': [unknown]\n [25; 31) '1isize': [unknown]\n [41; 42) 'b': usize\n+[52; 53) '1': usize\n+[63; 64) 'c': usize\n [67; 68) 'b': usize", "previous_filename": "crates/ra_hir/src/ty/tests/data/0002_let.txt"}, {"sha": "b22f4d4a52285ba3b972eb9f9145a28144bfbfc6", "filename": "crates/ra_hir/src/ty/tests/data/paths.txt", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fpaths.txt", "raw_url": "https://github.com/rust-lang/rust/raw/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fpaths.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fpaths.txt?ref=c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7", "patch": "@@ -1,9 +1,9 @@\n [15; 20) '{ 1 }': u32\n [17; 18) '1': u32\n-[50; 51) '1': u32\n [48; 53) '{ 1 }': u32\n-[82; 88) 'b::c()': u32\n+[50; 51) '1': u32\n [67; 91) '{     ...c(); }': ()\n [73; 74) 'a': fn() -> u32\n [73; 76) 'a()': u32\n [82; 86) 'b::c': fn() -> u32\n+[82; 88) 'b::c()': u32", "previous_filename": "crates/ra_hir/src/ty/tests/data/0003_paths.txt"}, {"sha": "afab343ea5a39da06b8dea48153985adfb4ad7ea", "filename": "crates/ra_hir/src/ty/tests/data/refs_and_ptrs.txt", "status": "renamed", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Frefs_and_ptrs.txt", "raw_url": "https://github.com/rust-lang/rust/raw/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Frefs_and_ptrs.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Frefs_and_ptrs.txt?ref=c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7", "patch": "@@ -1,23 +1,23 @@\n-[115; 117) '&b': &&mut u32\n-[88; 94) '&mut a': &mut &u32\n-[146; 147) 'd': *mut u32\n-[145; 147) '*d': u32\n-[65; 66) 'a': &u32\n+[9; 10) 'a': &u32\n+[18; 19) 'b': &mut u32\n+[31; 32) 'c': *const u32\n [46; 47) 'd': *mut u32\n [59; 150) '{     ... *d; }': ()\n-[116; 117) 'b': &mut u32\n-[131; 132) 'c': *const u32\n-[130; 132) '*c': u32\n+[65; 66) 'a': &u32\n [72; 74) '*a': u32\n-[107; 109) '*b': u32\n-[108; 109) 'b': &mut u32\n-[9; 10) 'a': &u32\n-[18; 19) 'b': &mut u32\n+[73; 74) 'a': &u32\n+[80; 82) '&a': &&u32\n+[81; 82) 'a': &u32\n+[88; 94) '&mut a': &mut &u32\n [93; 94) 'a': &u32\n [100; 101) 'b': &mut u32\n-[81; 82) 'a': &u32\n-[80; 82) '&a': &&u32\n-[73; 74) 'a': &u32\n+[107; 109) '*b': u32\n+[108; 109) 'b': &mut u32\n+[115; 117) '&b': &&mut u32\n+[116; 117) 'b': &mut u32\n [123; 124) 'c': *const u32\n-[31; 32) 'c': *const u32\n+[130; 132) '*c': u32\n+[131; 132) 'c': *const u32\n [138; 139) 'd': *mut u32\n+[145; 147) '*d': u32\n+[146; 147) 'd': *mut u32", "previous_filename": "crates/ra_hir/src/ty/tests/data/0005_refs.txt"}, {"sha": "c38029f97bfdd607e57ca276169813d30cbf1ac4", "filename": "crates/ra_hir/src/ty/tests/data/self.txt", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fself.txt", "raw_url": "https://github.com/rust-lang/rust/raw/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fself.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fself.txt?ref=c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7", "patch": "@@ -1,6 +1,6 @@\n-[50; 54) 'self': &S\n [34; 38) 'self': &S\n [40; 61) '{     ...     }': ()\n+[50; 54) 'self': &S\n+[75; 79) 'self': &S\n [88; 109) '{     ...     }': ()\n [98; 102) 'self': &S\n-[75; 79) 'self': &S", "previous_filename": "crates/ra_hir/src/ty/tests/data/0007_self.txt"}, {"sha": "7b324c82faf590e832856af95e2a76d55a210fc7", "filename": "crates/ra_hir/src/ty/tests/data/struct.txt", "status": "renamed", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fstruct.txt", "raw_url": "https://github.com/rust-lang/rust/raw/c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fstruct.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2Fstruct.txt?ref=c69bb8a7e737e09c667f9e343d0f1d3e4c13b8f7", "patch": "@@ -1,16 +1,16 @@\n-[86; 90) 'C(1)': [unknown]\n-[121; 122) 'B': B\n+[72; 154) '{     ...a.c; }': ()\n+[82; 83) 'c': [unknown]\n [86; 87) 'C': [unknown]\n-[129; 130) '1': [unknown]\n+[86; 90) 'C(1)': [unknown]\n+[88; 89) '1': [unknown]\n+[96; 97) 'B': [unknown]\n [107; 108) 'a': A\n+[114; 133) 'A { b:...C(1) }': A\n+[121; 122) 'B': B\n [127; 128) 'C': [unknown]\n+[127; 131) 'C(1)': C\n+[129; 130) '1': [unknown]\n+[139; 140) 'a': A\n [139; 142) 'a.b': B\n-[114; 133) 'A { b:...C(1) }': A\n-[148; 151) 'a.c': C\n [148; 149) 'a': A\n-[139; 140) 'a': A\n-[72; 154) '{     ...a.c; }': ()\n-[96; 97) 'B': [unknown]\n-[88; 89) '1': [unknown]\n-[82; 83) 'c': [unknown]\n-[127; 131) 'C(1)': C\n+[148; 151) 'a.c': C", "previous_filename": "crates/ra_hir/src/ty/tests/data/0004_struct.txt"}]}