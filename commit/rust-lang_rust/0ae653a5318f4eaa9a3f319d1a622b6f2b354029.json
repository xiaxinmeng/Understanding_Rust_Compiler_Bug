{"sha": "0ae653a5318f4eaa9a3f319d1a622b6f2b354029", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhZTY1M2E1MzE4ZjRlYWE5YTNmMzE5ZDFhNjIyYjZmMmIzNTQwMjk=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-11-26T12:39:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-26T12:39:09Z"}, "message": "Rollup merge of #79365 - richkadel:llvm-cov-map-version-4, r=wesleywiser\n\nUpgrades the coverage map to Version 4\n\nChanges the coverage map injected into binaries compiled with\n`-Zinstrument-coverage` to LLVM Coverage Mapping Format, Version 4 (from\nVersion 3). Note, binaries compiled with this version will require LLVM\ntools from at least LLVM Version 11.\n\nr? ``@wesleywiser``", "tree": {"sha": "ee1ccbe3c67ccf329e507247083d1bb8be108e8c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee1ccbe3c67ccf329e507247083d1bb8be108e8c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0ae653a5318f4eaa9a3f319d1a622b6f2b354029", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfv6HuCRBK7hj4Ov3rIwAAdHIIAG/YegLfP9Sig2eeIvzXe4Rf\n8wegA+3AQ2yAxiJilduZ9btu9aZsQ6zxWz63FB2z5Fvv5G1un7wL7NvOR6qSvofO\neYoSMOtITFw9PgSM8oMl4lqq008Q4EQzK8/OaydB4W2kbnEYNRcmUHQLPIKZSgfn\nWJnwjFy4/QxwdiFc2Nt3oVBCyHTfSyxGZhepJv1NUqaWagHY4EzpvjFrCbtbfWcZ\ncLQQLKIiVcwcmk6z52jaORZuJvq7SHTkGbGYnK657Fv5feIyISPn2irm30BgN98V\nMq+nvkUWMbeVJxAAR4VKfIs9lGsSE/ZBnRAowh4jdvG+JEhtW8Qu5LBdxOo6V64=\n=7dPG\n-----END PGP SIGNATURE-----\n", "payload": "tree ee1ccbe3c67ccf329e507247083d1bb8be108e8c\nparent 85c11de2f2ecc9dcc1b94f550351af0cd02e96dc\nparent fdbc121620704ab50bd427ff1a2bb3282ffac745\nauthor Jonas Schievink <jonasschievink@gmail.com> 1606394349 +0100\ncommitter GitHub <noreply@github.com> 1606394349 +0100\n\nRollup merge of #79365 - richkadel:llvm-cov-map-version-4, r=wesleywiser\n\nUpgrades the coverage map to Version 4\n\nChanges the coverage map injected into binaries compiled with\n`-Zinstrument-coverage` to LLVM Coverage Mapping Format, Version 4 (from\nVersion 3). Note, binaries compiled with this version will require LLVM\ntools from at least LLVM Version 11.\n\nr? ``@wesleywiser``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0ae653a5318f4eaa9a3f319d1a622b6f2b354029", "html_url": "https://github.com/rust-lang/rust/commit/0ae653a5318f4eaa9a3f319d1a622b6f2b354029", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0ae653a5318f4eaa9a3f319d1a622b6f2b354029/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85c11de2f2ecc9dcc1b94f550351af0cd02e96dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/85c11de2f2ecc9dcc1b94f550351af0cd02e96dc", "html_url": "https://github.com/rust-lang/rust/commit/85c11de2f2ecc9dcc1b94f550351af0cd02e96dc"}, {"sha": "fdbc121620704ab50bd427ff1a2bb3282ffac745", "url": "https://api.github.com/repos/rust-lang/rust/commits/fdbc121620704ab50bd427ff1a2bb3282ffac745", "html_url": "https://github.com/rust-lang/rust/commit/fdbc121620704ab50bd427ff1a2bb3282ffac745"}], "stats": {"total": 412, "additions": 261, "deletions": 151}, "files": [{"sha": "85aaa7e8893bfa107e4985089a0a50169a943fe2", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 109, "deletions": 112, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/0ae653a5318f4eaa9a3f319d1a622b6f2b354029/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae653a5318f4eaa9a3f319d1a622b6f2b354029/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=0ae653a5318f4eaa9a3f319d1a622b6f2b354029", "patch": "@@ -4,7 +4,7 @@ use crate::llvm;\n \n use llvm::coverageinfo::CounterMappingRegion;\n use rustc_codegen_ssa::coverageinfo::map::{Counter, CounterExpression};\n-use rustc_codegen_ssa::traits::{BaseTypeMethods, ConstMethods};\n+use rustc_codegen_ssa::traits::ConstMethods;\n use rustc_data_structures::fx::FxIndexSet;\n use rustc_llvm::RustString;\n use rustc_middle::mir::coverage::CodeRegion;\n@@ -15,9 +15,9 @@ use tracing::debug;\n \n /// Generates and exports the Coverage Map.\n ///\n-/// This Coverage Map complies with Coverage Mapping Format version 3 (zero-based encoded as 2),\n-/// as defined at [LLVM Code Coverage Mapping Format](https://github.com/rust-lang/llvm-project/blob/llvmorg-8.0.0/llvm/docs/CoverageMappingFormat.rst#llvm-code-coverage-mapping-format)\n-/// and published in Rust's current (July 2020) fork of LLVM. This version is supported by the\n+/// This Coverage Map complies with Coverage Mapping Format version 4 (zero-based encoded as 3),\n+/// as defined at [LLVM Code Coverage Mapping Format](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/docs/CoverageMappingFormat.rst#llvm-code-coverage-mapping-format)\n+/// and published in Rust's current (November 2020) fork of LLVM. This version is supported by the\n /// LLVM coverage tools (`llvm-profdata` and `llvm-cov`) bundled with Rust's fork of LLVM.\n ///\n /// Consequently, Rust's bundled version of Clang also generates Coverage Maps compliant with\n@@ -26,6 +26,13 @@ use tracing::debug;\n /// undocumented details in Clang's implementation (that may or may not be important) were also\n /// replicated for Rust's Coverage Map.\n pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n+    // Ensure LLVM supports Coverage Map Version 4 (encoded as a zero-based value: 3).\n+    // If not, the LLVM Version must be less than 11.\n+    let version = coverageinfo::mapping_version();\n+    if version != 3 {\n+        cx.tcx.sess.fatal(\"rustc option `-Z instrument-coverage` requires LLVM 11 or higher.\");\n+    }\n+\n     let function_coverage_map = match cx.coverage_context() {\n         Some(ctx) => ctx.take_function_coverage_map(),\n         None => return,\n@@ -38,46 +45,50 @@ pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n     let mut mapgen = CoverageMapGenerator::new();\n \n     // Encode coverage mappings and generate function records\n-    let mut function_records = Vec::<&'ll llvm::Value>::new();\n-    let coverage_mappings_buffer = llvm::build_byte_buffer(|coverage_mappings_buffer| {\n-        for (instance, function_coverage) in function_coverage_map.into_iter() {\n-            debug!(\"Generate coverage map for: {:?}\", instance);\n-\n-            let mangled_function_name = cx.tcx.symbol_name(instance).to_string();\n-            let function_source_hash = function_coverage.source_hash();\n-            let (expressions, counter_regions) =\n-                function_coverage.get_expressions_and_counter_regions();\n-\n-            let old_len = coverage_mappings_buffer.len();\n-            mapgen.write_coverage_mappings(expressions, counter_regions, coverage_mappings_buffer);\n-            let mapping_data_size = coverage_mappings_buffer.len() - old_len;\n-            debug_assert!(\n-                mapping_data_size > 0,\n-                \"Every `FunctionCoverage` should have at least one counter\"\n-            );\n-\n-            let function_record = mapgen.make_function_record(\n-                cx,\n-                mangled_function_name,\n-                function_source_hash,\n-                mapping_data_size,\n-            );\n-            function_records.push(function_record);\n-        }\n-    });\n+    let mut function_data = Vec::new();\n+    for (instance, function_coverage) in function_coverage_map {\n+        debug!(\"Generate coverage map for: {:?}\", instance);\n+\n+        let mangled_function_name = cx.tcx.symbol_name(instance).to_string();\n+        let function_source_hash = function_coverage.source_hash();\n+        let (expressions, counter_regions) =\n+            function_coverage.get_expressions_and_counter_regions();\n+\n+        let coverage_mapping_buffer = llvm::build_byte_buffer(|coverage_mapping_buffer| {\n+            mapgen.write_coverage_mapping(expressions, counter_regions, coverage_mapping_buffer);\n+        });\n+        debug_assert!(\n+            coverage_mapping_buffer.len() > 0,\n+            \"Every `FunctionCoverage` should have at least one counter\"\n+        );\n+\n+        function_data.push((mangled_function_name, function_source_hash, coverage_mapping_buffer));\n+    }\n \n     // Encode all filenames referenced by counters/expressions in this module\n     let filenames_buffer = llvm::build_byte_buffer(|filenames_buffer| {\n         coverageinfo::write_filenames_section_to_buffer(&mapgen.filenames, filenames_buffer);\n     });\n \n+    let filenames_size = filenames_buffer.len();\n+    let filenames_val = cx.const_bytes(&filenames_buffer[..]);\n+    let filenames_ref = coverageinfo::hash_bytes(filenames_buffer);\n+\n     // Generate the LLVM IR representation of the coverage map and store it in a well-known global\n-    mapgen.save_generated_coverage_map(\n-        cx,\n-        function_records,\n-        filenames_buffer,\n-        coverage_mappings_buffer,\n-    );\n+    let cov_data_val = mapgen.generate_coverage_map(cx, version, filenames_size, filenames_val);\n+\n+    for (mangled_function_name, function_source_hash, coverage_mapping_buffer) in function_data {\n+        save_function_record(\n+            cx,\n+            mangled_function_name,\n+            function_source_hash,\n+            filenames_ref,\n+            coverage_mapping_buffer,\n+        );\n+    }\n+\n+    // Save the coverage data value to LLVM IR\n+    coverageinfo::save_cov_data_to_mod(cx, cov_data_val);\n }\n \n struct CoverageMapGenerator {\n@@ -92,12 +103,12 @@ impl CoverageMapGenerator {\n     /// Using the `expressions` and `counter_regions` collected for the current function, generate\n     /// the `mapping_regions` and `virtual_file_mapping`, and capture any new filenames. Then use\n     /// LLVM APIs to encode the `virtual_file_mapping`, `expressions`, and `mapping_regions` into\n-    /// the given `coverage_mappings` byte buffer, compliant with the LLVM Coverage Mapping format.\n-    fn write_coverage_mappings(\n+    /// the given `coverage_mapping` byte buffer, compliant with the LLVM Coverage Mapping format.\n+    fn write_coverage_mapping(\n         &mut self,\n         expressions: Vec<CounterExpression>,\n         counter_regions: impl Iterator<Item = (Counter, &'a CodeRegion)>,\n-        coverage_mappings_buffer: &RustString,\n+        coverage_mapping_buffer: &RustString,\n     ) {\n         let mut counter_regions = counter_regions.collect::<Vec<_>>();\n         if counter_regions.is_empty() {\n@@ -145,89 +156,75 @@ impl CoverageMapGenerator {\n             virtual_file_mapping,\n             expressions,\n             mapping_regions,\n-            coverage_mappings_buffer,\n+            coverage_mapping_buffer,\n         );\n     }\n \n-    /// Generate and return the function record `Value`\n-    fn make_function_record(\n-        &mut self,\n-        cx: &CodegenCx<'ll, 'tcx>,\n-        mangled_function_name: String,\n-        function_source_hash: u64,\n-        mapping_data_size: usize,\n-    ) -> &'ll llvm::Value {\n-        let name_ref = coverageinfo::compute_hash(&mangled_function_name);\n-        let name_ref_val = cx.const_u64(name_ref);\n-        let mapping_data_size_val = cx.const_u32(mapping_data_size as u32);\n-        let func_hash_val = cx.const_u64(function_source_hash);\n-        cx.const_struct(\n-            &[name_ref_val, mapping_data_size_val, func_hash_val],\n-            /*packed=*/ true,\n-        )\n-    }\n-\n-    /// Combine the filenames and coverage mappings buffers, construct coverage map header and the\n-    /// array of function records, and combine everything into the complete coverage map. Save the\n-    /// coverage map data into the LLVM IR as a static global using a specific, well-known section\n-    /// and name.\n-    fn save_generated_coverage_map(\n+    /// Construct coverage map header and the array of function records, and combine them into the\n+    /// coverage map. Save the coverage map data into the LLVM IR as a static global using a\n+    /// specific, well-known section and name.\n+    fn generate_coverage_map(\n         self,\n         cx: &CodegenCx<'ll, 'tcx>,\n-        function_records: Vec<&'ll llvm::Value>,\n-        filenames_buffer: Vec<u8>,\n-        mut coverage_mappings_buffer: Vec<u8>,\n-    ) {\n-        // Concatenate the encoded filenames and encoded coverage mappings, and add additional zero\n-        // bytes as-needed to ensure 8-byte alignment.\n-        let mut coverage_size = coverage_mappings_buffer.len();\n-        let filenames_size = filenames_buffer.len();\n-        let remaining_bytes =\n-            (filenames_size + coverage_size) % coverageinfo::COVMAP_VAR_ALIGN_BYTES;\n-        if remaining_bytes > 0 {\n-            let pad = coverageinfo::COVMAP_VAR_ALIGN_BYTES - remaining_bytes;\n-            coverage_mappings_buffer.append(&mut [0].repeat(pad));\n-            coverage_size += pad;\n-        }\n-        let filenames_and_coverage_mappings = [filenames_buffer, coverage_mappings_buffer].concat();\n-        let filenames_and_coverage_mappings_val =\n-            cx.const_bytes(&filenames_and_coverage_mappings[..]);\n-\n-        debug!(\n-            \"cov map: n_records = {}, filenames_size = {}, coverage_size = {}, 0-based version = {}\",\n-            function_records.len(),\n-            filenames_size,\n-            coverage_size,\n-            coverageinfo::mapping_version()\n-        );\n+        version: u32,\n+        filenames_size: usize,\n+        filenames_val: &'ll llvm::Value,\n+    ) -> &'ll llvm::Value {\n+        debug!(\"cov map: filenames_size = {}, 0-based version = {}\", filenames_size, version);\n \n-        // Create the coverage data header\n-        let n_records_val = cx.const_u32(function_records.len() as u32);\n+        // Create the coverage data header (Note, fields 0 and 2 are now always zero,\n+        // as of `llvm::coverage::CovMapVersion::Version4`.)\n+        let zero_was_n_records_val = cx.const_u32(0);\n         let filenames_size_val = cx.const_u32(filenames_size as u32);\n-        let coverage_size_val = cx.const_u32(coverage_size as u32);\n-        let version_val = cx.const_u32(coverageinfo::mapping_version());\n+        let zero_was_coverage_size_val = cx.const_u32(0);\n+        let version_val = cx.const_u32(version);\n         let cov_data_header_val = cx.const_struct(\n-            &[n_records_val, filenames_size_val, coverage_size_val, version_val],\n+            &[zero_was_n_records_val, filenames_size_val, zero_was_coverage_size_val, version_val],\n             /*packed=*/ false,\n         );\n \n-        // Create the function records array\n-        let name_ref_from_u64 = cx.type_i64();\n-        let mapping_data_size_from_u32 = cx.type_i32();\n-        let func_hash_from_u64 = cx.type_i64();\n-        let function_record_ty = cx.type_struct(\n-            &[name_ref_from_u64, mapping_data_size_from_u32, func_hash_from_u64],\n-            /*packed=*/ true,\n-        );\n-        let function_records_val = cx.const_array(function_record_ty, &function_records[..]);\n-\n         // Create the complete LLVM coverage data value to add to the LLVM IR\n-        let cov_data_val = cx.const_struct(\n-            &[cov_data_header_val, function_records_val, filenames_and_coverage_mappings_val],\n-            /*packed=*/ false,\n-        );\n-\n-        // Save the coverage data value to LLVM IR\n-        coverageinfo::save_map_to_mod(cx, cov_data_val);\n+        cx.const_struct(&[cov_data_header_val, filenames_val], /*packed=*/ false)\n     }\n }\n+\n+/// Construct a function record and combine it with the function's coverage mapping data.\n+/// Save the function record into the LLVM IR as a static global using a\n+/// specific, well-known section and name.\n+fn save_function_record(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    mangled_function_name: String,\n+    function_source_hash: u64,\n+    filenames_ref: u64,\n+    coverage_mapping_buffer: Vec<u8>,\n+) {\n+    // Concatenate the encoded coverage mappings\n+    let coverage_mapping_size = coverage_mapping_buffer.len();\n+    let coverage_mapping_val = cx.const_bytes(&coverage_mapping_buffer[..]);\n+\n+    let func_name_hash = coverageinfo::hash_str(&mangled_function_name);\n+    let func_name_hash_val = cx.const_u64(func_name_hash);\n+    let coverage_mapping_size_val = cx.const_u32(coverage_mapping_size as u32);\n+    let func_hash_val = cx.const_u64(function_source_hash);\n+    let filenames_ref_val = cx.const_u64(filenames_ref);\n+    let func_record_val = cx.const_struct(\n+        &[\n+            func_name_hash_val,\n+            coverage_mapping_size_val,\n+            func_hash_val,\n+            filenames_ref_val,\n+            coverage_mapping_val,\n+        ],\n+        /*packed=*/ true,\n+    );\n+\n+    // At the present time, the coverage map for Rust assumes every instrumented function `is_used`.\n+    // Note that Clang marks functions as \"unused\" in `CodeGenPGO::emitEmptyCounterMapping`. (See:\n+    // https://github.com/rust-lang/llvm-project/blob/de02a75e398415bad4df27b4547c25b896c8bf3b/clang%2Flib%2FCodeGen%2FCodeGenPGO.cpp#L877-L878\n+    // for example.)\n+    //\n+    // It's not yet clear if or how this may be applied to Rust in the future, but the `is_used`\n+    // argument is available and handled similarly.\n+    let is_used = true;\n+    coverageinfo::save_func_record_to_mod(cx, func_name_hash, func_record_val, is_used);\n+}"}, {"sha": "e777f363eb0842ee25be12f5254eb986a7b54dea", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mod.rs", "status": "modified", "additions": 46, "deletions": 8, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0ae653a5318f4eaa9a3f319d1a622b6f2b354029/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae653a5318f4eaa9a3f319d1a622b6f2b354029/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs?ref=0ae653a5318f4eaa9a3f319d1a622b6f2b354029", "patch": "@@ -23,7 +23,7 @@ use tracing::debug;\n \n pub mod mapgen;\n \n-const COVMAP_VAR_ALIGN_BYTES: usize = 8;\n+const VAR_ALIGN_BYTES: usize = 8;\n \n /// A context object for maintaining all state needed by the coverageinfo module.\n pub struct CrateCoverageContext<'tcx> {\n@@ -177,17 +177,20 @@ pub(crate) fn write_mapping_to_buffer(\n         );\n     }\n }\n+pub(crate) fn hash_str(strval: &str) -> u64 {\n+    let strval = CString::new(strval).expect(\"null error converting hashable str to C string\");\n+    unsafe { llvm::LLVMRustCoverageHashCString(strval.as_ptr()) }\n+}\n \n-pub(crate) fn compute_hash(name: &str) -> u64 {\n-    let name = CString::new(name).expect(\"null error converting hashable name to C string\");\n-    unsafe { llvm::LLVMRustCoverageComputeHash(name.as_ptr()) }\n+pub(crate) fn hash_bytes(bytes: Vec<u8>) -> u64 {\n+    unsafe { llvm::LLVMRustCoverageHashByteArray(bytes.as_ptr().cast(), bytes.len()) }\n }\n \n pub(crate) fn mapping_version() -> u32 {\n     unsafe { llvm::LLVMRustCoverageMappingVersion() }\n }\n \n-pub(crate) fn save_map_to_mod<'ll, 'tcx>(\n+pub(crate) fn save_cov_data_to_mod<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     cov_data_val: &'ll llvm::Value,\n ) {\n@@ -198,16 +201,51 @@ pub(crate) fn save_map_to_mod<'ll, 'tcx>(\n     debug!(\"covmap var name: {:?}\", covmap_var_name);\n \n     let covmap_section_name = llvm::build_string(|s| unsafe {\n-        llvm::LLVMRustCoverageWriteSectionNameToString(cx.llmod, s);\n+        llvm::LLVMRustCoverageWriteMapSectionNameToString(cx.llmod, s);\n     })\n     .expect(\"Rust Coverage section name failed UTF-8 conversion\");\n     debug!(\"covmap section name: {:?}\", covmap_section_name);\n \n     let llglobal = llvm::add_global(cx.llmod, cx.val_ty(cov_data_val), &covmap_var_name);\n     llvm::set_initializer(llglobal, cov_data_val);\n     llvm::set_global_constant(llglobal, true);\n-    llvm::set_linkage(llglobal, llvm::Linkage::InternalLinkage);\n+    llvm::set_linkage(llglobal, llvm::Linkage::PrivateLinkage);\n     llvm::set_section(llglobal, &covmap_section_name);\n-    llvm::set_alignment(llglobal, COVMAP_VAR_ALIGN_BYTES);\n+    llvm::set_alignment(llglobal, VAR_ALIGN_BYTES);\n+    cx.add_used_global(llglobal);\n+}\n+\n+pub(crate) fn save_func_record_to_mod<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    func_name_hash: u64,\n+    func_record_val: &'ll llvm::Value,\n+    is_used: bool,\n+) {\n+    // Assign a name to the function record. This is used to merge duplicates.\n+    //\n+    // In LLVM, a \"translation unit\" (effectively, a `Crate` in Rust) can describe functions that\n+    // are included-but-not-used. If (or when) Rust generates functions that are\n+    // included-but-not-used, note that a dummy description for a function included-but-not-used\n+    // in a Crate can be replaced by full description provided by a different Crate. The two kinds\n+    // of descriptions play distinct roles in LLVM IR; therefore, assign them different names (by\n+    // appending \"u\" to the end of the function record var name, to prevent `linkonce_odr` merging.\n+    let func_record_var_name =\n+        format!(\"__covrec_{:X}{}\", func_name_hash, if is_used { \"u\" } else { \"\" });\n+    debug!(\"function record var name: {:?}\", func_record_var_name);\n+\n+    let func_record_section_name = llvm::build_string(|s| unsafe {\n+        llvm::LLVMRustCoverageWriteFuncSectionNameToString(cx.llmod, s);\n+    })\n+    .expect(\"Rust Coverage function record section name failed UTF-8 conversion\");\n+    debug!(\"function record section name: {:?}\", func_record_section_name);\n+\n+    let llglobal = llvm::add_global(cx.llmod, cx.val_ty(func_record_val), &func_record_var_name);\n+    llvm::set_initializer(llglobal, func_record_val);\n+    llvm::set_global_constant(llglobal, true);\n+    llvm::set_linkage(llglobal, llvm::Linkage::LinkOnceODRLinkage);\n+    llvm::set_visibility(llglobal, llvm::Visibility::Hidden);\n+    llvm::set_section(llglobal, &func_record_section_name);\n+    llvm::set_alignment(llglobal, VAR_ALIGN_BYTES);\n+    llvm::set_comdat(cx.llmod, llglobal, &func_record_var_name);\n     cx.add_used_global(llglobal);\n }"}, {"sha": "41482d18946ad7f9ebbeacc625f7049b01ed6c47", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0ae653a5318f4eaa9a3f319d1a622b6f2b354029/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae653a5318f4eaa9a3f319d1a622b6f2b354029/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=0ae653a5318f4eaa9a3f319d1a622b6f2b354029", "patch": "@@ -642,7 +642,7 @@ pub type InlineAsmDiagHandler = unsafe extern \"C\" fn(&SMDiagnostic, *const c_voi\n pub mod coverageinfo {\n     use super::coverage_map;\n \n-    /// Aligns with [llvm::coverage::CounterMappingRegion::RegionKind](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L205-L221)\n+    /// Aligns with [llvm::coverage::CounterMappingRegion::RegionKind](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L206-L222)\n     #[derive(Copy, Clone, Debug)]\n     #[repr(C)]\n     pub enum RegionKind {\n@@ -665,13 +665,13 @@ pub mod coverageinfo {\n \n     /// This struct provides LLVM's representation of a \"CoverageMappingRegion\", encoded into the\n     /// coverage map, in accordance with the\n-    /// [LLVM Code Coverage Mapping Format](https://github.com/rust-lang/llvm-project/blob/llvmorg-8.0.0/llvm/docs/CoverageMappingFormat.rst#llvm-code-coverage-mapping-format).\n+    /// [LLVM Code Coverage Mapping Format](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/docs/CoverageMappingFormat.rst#llvm-code-coverage-mapping-format).\n     /// The struct composes fields representing the `Counter` type and value(s) (injected counter\n     /// ID, or expression type and operands), the source file (an indirect index into a \"filenames\n     /// array\", encoded separately), and source location (start and end positions of the represented\n     /// code region).\n     ///\n-    /// Aligns with [llvm::coverage::CounterMappingRegion](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L223-L226)\n+    /// Aligns with [llvm::coverage::CounterMappingRegion](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L224-L227)\n     /// Important: The Rust struct layout (order and types of fields) must match its C++\n     /// counterpart.\n     #[derive(Copy, Clone, Debug)]\n@@ -1791,10 +1791,14 @@ extern \"C\" {\n \n     pub fn LLVMRustCoverageCreatePGOFuncNameVar(F: &'a Value, FuncName: *const c_char)\n     -> &'a Value;\n-    pub fn LLVMRustCoverageComputeHash(Name: *const c_char) -> u64;\n+    pub fn LLVMRustCoverageHashCString(StrVal: *const c_char) -> u64;\n+    pub fn LLVMRustCoverageHashByteArray(Bytes: *const c_char, NumBytes: size_t) -> u64;\n \n     #[allow(improper_ctypes)]\n-    pub fn LLVMRustCoverageWriteSectionNameToString(M: &Module, Str: &RustString);\n+    pub fn LLVMRustCoverageWriteMapSectionNameToString(M: &Module, Str: &RustString);\n+\n+    #[allow(improper_ctypes)]\n+    pub fn LLVMRustCoverageWriteFuncSectionNameToString(M: &Module, Str: &RustString);\n \n     #[allow(improper_ctypes)]\n     pub fn LLVMRustCoverageWriteMappingVarNameToString(Str: &RustString);"}, {"sha": "fc40065a9664ea1c84e8917dea7da1fcfab1ca33", "filename": "compiler/rustc_codegen_llvm/src/llvm/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0ae653a5318f4eaa9a3f319d1a622b6f2b354029/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae653a5318f4eaa9a3f319d1a622b6f2b354029/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fmod.rs?ref=0ae653a5318f4eaa9a3f319d1a622b6f2b354029", "patch": "@@ -220,12 +220,24 @@ pub fn set_linkage(llglobal: &Value, linkage: Linkage) {\n     }\n }\n \n+pub fn set_visibility(llglobal: &Value, visibility: Visibility) {\n+    unsafe {\n+        LLVMRustSetVisibility(llglobal, visibility);\n+    }\n+}\n+\n pub fn set_alignment(llglobal: &Value, bytes: usize) {\n     unsafe {\n         ffi::LLVMSetAlignment(llglobal, bytes as c_uint);\n     }\n }\n \n+pub fn set_comdat(llmod: &Module, llglobal: &Value, name: &str) {\n+    unsafe {\n+        LLVMRustSetComdat(llmod, llglobal, name.as_ptr().cast(), name.len());\n+    }\n+}\n+\n /// Safe wrapper around `LLVMGetParam`, because segfaults are no fun.\n pub fn get_param(llfn: &Value, index: c_uint) -> &Value {\n     unsafe {"}, {"sha": "af6c476292bd18c3af54e50abd6c512164882260", "filename": "compiler/rustc_codegen_ssa/src/coverageinfo/ffi.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0ae653a5318f4eaa9a3f319d1a622b6f2b354029/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae653a5318f4eaa9a3f319d1a622b6f2b354029/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs?ref=0ae653a5318f4eaa9a3f319d1a622b6f2b354029", "patch": "@@ -1,6 +1,6 @@\n use rustc_middle::mir::coverage::{CounterValueReference, MappedExpressionIndex};\n \n-/// Aligns with [llvm::coverage::Counter::CounterKind](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L91)\n+/// Aligns with [llvm::coverage::Counter::CounterKind](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L206-L222)\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub enum CounterKind {\n@@ -17,7 +17,7 @@ pub enum CounterKind {\n ///     `instrprof.increment()`)\n ///   * For `CounterKind::Expression`, `id` is the index into the coverage map's array of\n ///     counter expressions.\n-/// Aligns with [llvm::coverage::Counter](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L98-L99)\n+/// Aligns with [llvm::coverage::Counter](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L99-L100)\n /// Important: The Rust struct layout (order and types of fields) must match its C++ counterpart.\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n@@ -41,15 +41,15 @@ impl Counter {\n     }\n }\n \n-/// Aligns with [llvm::coverage::CounterExpression::ExprKind](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L146)\n+/// Aligns with [llvm::coverage::CounterExpression::ExprKind](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L147)\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub enum ExprKind {\n     Subtract = 0,\n     Add = 1,\n }\n \n-/// Aligns with [llvm::coverage::CounterExpression](https://github.com/rust-lang/llvm-project/blob/rustc/10.0-2020-05-05/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L147-L148)\n+/// Aligns with [llvm::coverage::CounterExpression](https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L148-L149)\n /// Important: The Rust struct layout (order and types of fields) must match its C++\n /// counterpart.\n #[derive(Copy, Clone, Debug)]"}, {"sha": "25badc3f4e17bd96cc954d6f765e5cd8ecc48cf5", "filename": "compiler/rustc_llvm/llvm-wrapper/CoverageMappingWrapper.cpp", "status": "modified", "additions": 37, "deletions": 15, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/0ae653a5318f4eaa9a3f319d1a622b6f2b354029/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0ae653a5318f4eaa9a3f319d1a622b6f2b354029/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp?ref=0ae653a5318f4eaa9a3f319d1a622b6f2b354029", "patch": "@@ -3,7 +3,6 @@\n #include \"llvm/ProfileData/Coverage/CoverageMappingWriter.h\"\n #include \"llvm/ProfileData/InstrProf.h\"\n #include \"llvm/ADT/ArrayRef.h\"\n-#include \"llvm/Support/LEB128.h\"\n \n #include <iostream>\n \n@@ -13,15 +12,14 @@ extern \"C\" void LLVMRustCoverageWriteFilenamesSectionToBuffer(\n     const char* const Filenames[],\n     size_t FilenamesLen,\n     RustStringRef BufferOut) {\n-  // LLVM 11's CoverageFilenamesSectionWriter uses its new `Version4` format,\n-  // so we're manually writing the `Version3` format ourselves.\n-  RawRustStringOstream OS(BufferOut);\n-  encodeULEB128(FilenamesLen, OS);\n+  SmallVector<StringRef,32> FilenameRefs;\n   for (size_t i = 0; i < FilenamesLen; i++) {\n-    StringRef Filename(Filenames[i]);\n-    encodeULEB128(Filename.size(), OS);\n-    OS << Filename;\n+    FilenameRefs.push_back(StringRef(Filenames[i]));\n   }\n+  auto FilenamesWriter = coverage::CoverageFilenamesSectionWriter(\n+    makeArrayRef(FilenameRefs));\n+  RawRustStringOstream OS(BufferOut);\n+  FilenamesWriter.write(OS);\n }\n \n extern \"C\" void LLVMRustCoverageWriteMappingToBuffer(\n@@ -45,26 +43,50 @@ extern \"C\" LLVMValueRef LLVMRustCoverageCreatePGOFuncNameVar(LLVMValueRef F, con\n   return wrap(createPGOFuncNameVar(*cast<Function>(unwrap(F)), FuncNameRef));\n }\n \n-extern \"C\" uint64_t LLVMRustCoverageComputeHash(const char *Name) {\n-  StringRef NameRef(Name);\n-  return IndexedInstrProf::ComputeHash(NameRef);\n+extern \"C\" uint64_t LLVMRustCoverageHashCString(const char *StrVal) {\n+  StringRef StrRef(StrVal);\n+  return IndexedInstrProf::ComputeHash(StrRef);\n+}\n+\n+extern \"C\" uint64_t LLVMRustCoverageHashByteArray(\n+    const char *Bytes,\n+    unsigned NumBytes) {\n+  StringRef StrRef(Bytes, NumBytes);\n+  return IndexedInstrProf::ComputeHash(StrRef);\n }\n \n-extern \"C\" void LLVMRustCoverageWriteSectionNameToString(LLVMModuleRef M,\n-                                                         RustStringRef Str) {\n+static void WriteSectionNameToString(LLVMModuleRef M,\n+                                     InstrProfSectKind SK,\n+                                     RustStringRef Str) {\n   Triple TargetTriple(unwrap(M)->getTargetTriple());\n-  auto name = getInstrProfSectionName(IPSK_covmap,\n-                                      TargetTriple.getObjectFormat());\n+  auto name = getInstrProfSectionName(SK, TargetTriple.getObjectFormat());\n   RawRustStringOstream OS(Str);\n   OS << name;\n }\n \n+extern \"C\" void LLVMRustCoverageWriteMapSectionNameToString(LLVMModuleRef M,\n+                                                            RustStringRef Str) {\n+  WriteSectionNameToString(M, IPSK_covmap, Str);\n+}\n+\n+extern \"C\" void LLVMRustCoverageWriteFuncSectionNameToString(LLVMModuleRef M,\n+                                                             RustStringRef Str) {\n+#if LLVM_VERSION_GE(11, 0)\n+  WriteSectionNameToString(M, IPSK_covfun, Str);\n+// else do nothing; the `Version` check will abort codegen on the Rust side\n+#endif\n+}\n+\n extern \"C\" void LLVMRustCoverageWriteMappingVarNameToString(RustStringRef Str) {\n   auto name = getCoverageMappingVarName();\n   RawRustStringOstream OS(Str);\n   OS << name;\n }\n \n extern \"C\" uint32_t LLVMRustCoverageMappingVersion() {\n+#if LLVM_VERSION_GE(11, 0)\n+  return coverage::CovMapVersion::Version4;\n+#else\n   return coverage::CovMapVersion::Version3;\n+#endif\n }"}, {"sha": "e17f933932e6a0649265ff6276619990aea15426", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0ae653a5318f4eaa9a3f319d1a622b6f2b354029/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/0ae653a5318f4eaa9a3f319d1a622b6f2b354029/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=0ae653a5318f4eaa9a3f319d1a622b6f2b354029", "patch": "@@ -1462,7 +1462,7 @@ extern \"C\" void LLVMRustSetComdat(LLVMModuleRef M, LLVMValueRef V,\n                                   const char *Name, size_t NameLen) {\n   Triple TargetTriple(unwrap(M)->getTargetTriple());\n   GlobalObject *GV = unwrap<GlobalObject>(V);\n-  if (!TargetTriple.isOSBinFormatMachO()) {\n+  if (TargetTriple.supportsCOMDAT()) {\n     StringRef NameRef(Name, NameLen);\n     GV->setComdat(unwrap(M)->getOrInsertComdat(NameRef));\n   }"}, {"sha": "8a6bf9dff7b6fb2ecb84464d239831b1a41aea34", "filename": "compiler/rustc_middle/src/mir/coverage.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0ae653a5318f4eaa9a3f319d1a622b6f2b354029/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0ae653a5318f4eaa9a3f319d1a622b6f2b354029/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs?ref=0ae653a5318f4eaa9a3f319d1a622b6f2b354029", "patch": "@@ -21,9 +21,9 @@ rustc_index::newtype_index! {\n impl ExpressionOperandId {\n     /// An expression operand for a \"zero counter\", as described in the following references:\n     ///\n-    /// * <https://github.com/rust-lang/llvm-project/blob/llvmorg-8.0.0/llvm/docs/CoverageMappingFormat.rst#counter>\n-    /// * <https://github.com/rust-lang/llvm-project/blob/llvmorg-8.0.0/llvm/docs/CoverageMappingFormat.rst#tag>\n-    /// * <https://github.com/rust-lang/llvm-project/blob/llvmorg-8.0.0/llvm/docs/CoverageMappingFormat.rst#counter-expressions>\n+    /// * <https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/docs/CoverageMappingFormat.rst#counter>\n+    /// * <https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/docs/CoverageMappingFormat.rst#tag>\n+    /// * <https://github.com/rust-lang/llvm-project/blob/rustc/11.0-2020-10-12/llvm/docs/CoverageMappingFormat.rst#counter-expressions>\n     ///\n     /// This operand can be used to count two or more separate code regions with a single counter,\n     /// if they run sequentially with no branches, by injecting the `Counter` in a `BasicBlock` for"}, {"sha": "219ba15ad116dd2d68027e8e00bb1b2185d94c63", "filename": "src/test/run-make-fulldeps/coverage-llvmir-base/Makefile", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0ae653a5318f4eaa9a3f319d1a622b6f2b354029/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-llvmir-base%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/0ae653a5318f4eaa9a3f319d1a622b6f2b354029/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-llvmir-base%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-llvmir-base%2FMakefile?ref=0ae653a5318f4eaa9a3f319d1a622b6f2b354029", "patch": "@@ -12,10 +12,12 @@ ifeq ($(UNAME),Darwin)\n \tINSTR_PROF_DATA_SUFFIX=,regular,live_support\n \tDATA_SECTION_PREFIX=__DATA,\n \tLLVM_COV_SECTION_PREFIX=__LLVM_COV,\n+\tCOMDAT_IF_SUPPORTED=\n else\n \tINSTR_PROF_DATA_SUFFIX=\n \tDATA_SECTION_PREFIX=\n \tLLVM_COV_SECTION_PREFIX=\n+\tCOMDAT_IF_SUPPORTED=, comdat\n endif\n \n ifeq ($(LINK_DEAD_CODE),yes)\n@@ -29,28 +31,39 @@ ifdef IS_WINDOWS\n \t\t-check-prefixes=CHECK,WINDOWS \\\n \t\t-DPRIVATE_GLOBAL='internal global' \\\n \t\t-DDEFINE_INTERNAL='$(DEFINE_INTERNAL)' \\\n+\t\t-DCOMDAT_IF_SUPPORTED='$(COMDAT_IF_SUPPORTED)' \\\n \t\t-DINSTR_PROF_DATA='.lprfd$$M' \\\n \t\t-DINSTR_PROF_NAME='.lprfn$$M' \\\n \t\t-DINSTR_PROF_CNTS='.lprfc$$M' \\\n \t\t-DINSTR_PROF_VALS='.lprfv$$M' \\\n \t\t-DINSTR_PROF_VNODES='.lprfnd$$M' \\\n \t\t-DINSTR_PROF_COVMAP='.lcovmap$$M' \\\n+\t\t-DINSTR_PROF_COVFUN='.lcovfun$$M' \\\n \t\t-DINSTR_PROF_ORDERFILE='.lorderfile$$M'\n else\n \tLLVM_FILECHECK_OPTIONS=\\\n \t\t-check-prefixes=CHECK \\\n \t\t-DPRIVATE_GLOBAL='private global' \\\n \t\t-DDEFINE_INTERNAL='$(DEFINE_INTERNAL)' \\\n+\t\t-DCOMDAT_IF_SUPPORTED='$(COMDAT_IF_SUPPORTED)' \\\n \t\t-DINSTR_PROF_DATA='$(DATA_SECTION_PREFIX)__llvm_prf_data$(INSTR_PROF_DATA_SUFFIX)' \\\n \t\t-DINSTR_PROF_NAME='$(DATA_SECTION_PREFIX)__llvm_prf_names' \\\n \t\t-DINSTR_PROF_CNTS='$(DATA_SECTION_PREFIX)__llvm_prf_cnts' \\\n \t\t-DINSTR_PROF_VALS='$(DATA_SECTION_PREFIX)__llvm_prf_vals' \\\n \t\t-DINSTR_PROF_VNODES='$(DATA_SECTION_PREFIX)__llvm_prf_vnds' \\\n \t\t-DINSTR_PROF_COVMAP='$(LLVM_COV_SECTION_PREFIX)__llvm_covmap' \\\n+\t\t-DINSTR_PROF_COVFUN='$(LLVM_COV_SECTION_PREFIX)__llvm_covfun' \\\n \t\t-DINSTR_PROF_ORDERFILE='$(DATA_SECTION_PREFIX)__llvm_orderfile'\n endif\n \n+ifeq ($(LLVM_VERSION_11_PLUS),true)\n+all: test_llvm_ir\n+else\n+$(info Rust option `-Z instrument-coverage` requires LLVM 11 or higher. Test skipped.)\n all:\n+endif\n+\n+test_llvm_ir:\n \t# Compile the test program with non-experimental coverage instrumentation, and generate LLVM IR\n \t#\n \t# Note: `-Clink-dead-code=no` disables the option, needed because the option is automatically\n@@ -62,4 +75,5 @@ all:\n \t\t\t-Clink-dead-code=$(LINK_DEAD_CODE) \\\n \t\t\t--emit=llvm-ir\n \n-\tcat \"$(TMPDIR)\"/testprog.ll | \"$(LLVM_FILECHECK)\" $(BASEDIR)/filecheck.testprog.txt $(LLVM_FILECHECK_OPTIONS)\n+\tcat \"$(TMPDIR)\"/testprog.ll | \\\n+\t\t\t\"$(LLVM_FILECHECK)\" $(BASEDIR)/filecheck.testprog.txt $(LLVM_FILECHECK_OPTIONS)"}, {"sha": "a312ec48e8498fb3bf8aa58907705c68942ae3fb", "filename": "src/test/run-make-fulldeps/coverage-llvmir-base/filecheck.testprog.txt", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0ae653a5318f4eaa9a3f319d1a622b6f2b354029/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-llvmir-base%2Ffilecheck.testprog.txt", "raw_url": "https://github.com/rust-lang/rust/raw/0ae653a5318f4eaa9a3f319d1a622b6f2b354029/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-llvmir-base%2Ffilecheck.testprog.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-llvmir-base%2Ffilecheck.testprog.txt?ref=0ae653a5318f4eaa9a3f319d1a622b6f2b354029", "patch": "@@ -3,7 +3,10 @@\n \n WINDOWS:      $__llvm_profile_runtime_user = comdat any\n \n-CHECK:        @__llvm_coverage_mapping = internal constant\n+CHECK:        @__covrec_{{[A-F0-9]+}}u = linkonce_odr hidden constant\n+CHECK-SAME:   section \"[[INSTR_PROF_COVFUN]]\"[[COMDAT_IF_SUPPORTED]], align 8\n+\n+CHECK:        @__llvm_coverage_mapping = private constant\n CHECK-SAME:   section \"[[INSTR_PROF_COVMAP]]\", align 8\n \n WINDOWS:      @__llvm_profile_runtime = external global i32"}, {"sha": "2dac8fc2225bf5010f86979c7950ea6b85b0c72b", "filename": "src/test/run-make-fulldeps/coverage-reports-base/Makefile", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0ae653a5318f4eaa9a3f319d1a622b6f2b354029/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports-base%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/0ae653a5318f4eaa9a3f319d1a622b6f2b354029/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports-base%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports-base%2FMakefile?ref=0ae653a5318f4eaa9a3f319d1a622b6f2b354029", "patch": "@@ -18,7 +18,10 @@ SOURCEDIR=../coverage\n # `llvm/release_debuginfo`. Note that some CI builds disable debug assertions (by setting\n # `NO_LLVM_ASSERTIONS=1`), so it is not OK to fail the test, but `bless`ed test results cannot be\n # generated without debug assertions.\n-LLVM_COV_DEBUG := $(shell \"$(LLVM_BIN_DIR)\"/llvm-cov show --debug 2>&1 | grep -q \"Unknown command line argument '--debug'\"; echo $$?)\n+LLVM_COV_DEBUG := $(shell \\\n+\t\t\"$(LLVM_BIN_DIR)\"/llvm-cov show --debug 2>&1 | \\\n+\t\tgrep -q \"Unknown command line argument '--debug'\"; \\\n+\t\techo $$?)\n ifeq ($(LLVM_COV_DEBUG), 1)\n DEBUG_FLAG=--debug\n endif\n@@ -30,7 +33,12 @@ ifdef RUSTC_BLESS_TEST\n DEBUG_FLAG=--debug\n endif\n \n+ifeq ($(LLVM_VERSION_11_PLUS),true)\n all: $(patsubst $(SOURCEDIR)/%.rs,%,$(wildcard $(SOURCEDIR)/*.rs))\n+else\n+$(info Rust option `-Z instrument-coverage` requires LLVM 11 or higher. Test skipped.)\n+all:\n+endif\n \n # Ensure there are no `expected` results for tests that may have been removed or renamed\n .PHONY: clear_expected_if_blessed"}, {"sha": "9f9440340e0eddfd7f4aee505f8e3caf31d74c8e", "filename": "src/test/run-make-fulldeps/coverage-spanview-base/Makefile", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0ae653a5318f4eaa9a3f319d1a622b6f2b354029/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview-base%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/0ae653a5318f4eaa9a3f319d1a622b6f2b354029/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview-base%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-spanview-base%2FMakefile?ref=0ae653a5318f4eaa9a3f319d1a622b6f2b354029", "patch": "@@ -24,7 +24,12 @@ For revisions in Pull Requests (PR):\n endef\n export SPANVIEW_HEADER\n \n+ifeq ($(LLVM_VERSION_11_PLUS),true)\n all: $(patsubst $(SOURCEDIR)/%.rs,%,$(wildcard $(SOURCEDIR)/*.rs))\n+else\n+$(info Rust option `-Z instrument-coverage` requires LLVM 11 or higher. Test skipped.)\n+all:\n+endif\n \n # Ensure there are no `expected` results for tests that may have been removed or renamed\n .PHONY: clear_expected_if_blessed"}, {"sha": "99a2e0ba9523e874c658326865df9505bfacf73d", "filename": "src/test/run-make-fulldeps/coverage/coverage_tools.mk", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0ae653a5318f4eaa9a3f319d1a622b6f2b354029/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fcoverage_tools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/0ae653a5318f4eaa9a3f319d1a622b6f2b354029/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fcoverage_tools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fcoverage_tools.mk?ref=0ae653a5318f4eaa9a3f319d1a622b6f2b354029", "patch": "@@ -38,6 +38,13 @@ endif\n \n UNAME = $(shell uname)\n \n+# Rust option `-Z instrument-coverage` uses LLVM Coverage Mapping Format version 4,\n+# which requires LLVM 11 or greater.\n+LLVM_VERSION_11_PLUS := $(shell \\\n+\t\tLLVM_VERSION=$$(\"$(LLVM_BIN_DIR)\"/llvm-config --version) && \\\n+\t\tLLVM_VERSION_MAJOR=$${LLVM_VERSION/.*/} && \\\n+\t\t[ $$LLVM_VERSION_MAJOR -ge 11 ] && echo true || echo false)\n+\n # FIXME(richkadel): Can any of the features tested by `run-make-fulldeps/coverage-*` tests be tested\n # just as completely by more focused unit tests of the code logic itself, to reduce the number of\n # test result files generated and maintained, and to help identify specific test failures and root"}]}