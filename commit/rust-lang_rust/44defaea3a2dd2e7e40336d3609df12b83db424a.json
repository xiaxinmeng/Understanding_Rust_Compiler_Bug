{"sha": "44defaea3a2dd2e7e40336d3609df12b83db424a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0ZGVmYWVhM2EyZGQyZTdlNDAzMzZkMzYwOWRmMTJiODNkYjQyNGE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-08-16T08:24:10Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-08-31T08:14:30Z"}, "message": "also detect DerefMut in nested union fields", "tree": {"sha": "e0d7f02d3a24db1c77603ef088f27bd7b363b56e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0d7f02d3a24db1c77603ef088f27bd7b363b56e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44defaea3a2dd2e7e40336d3609df12b83db424a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44defaea3a2dd2e7e40336d3609df12b83db424a", "html_url": "https://github.com/rust-lang/rust/commit/44defaea3a2dd2e7e40336d3609df12b83db424a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44defaea3a2dd2e7e40336d3609df12b83db424a/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec0924f9649ea472782df6d21595714cb594f038", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec0924f9649ea472782df6d21595714cb594f038", "html_url": "https://github.com/rust-lang/rust/commit/ec0924f9649ea472782df6d21595714cb594f038"}], "stats": {"total": 52, "additions": 36, "deletions": 16}, "files": [{"sha": "54b3fdd837e664c3f781c7cd16a45796d1e0cc50", "filename": "compiler/rustc_typeck/src/check/place_op.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/44defaea3a2dd2e7e40336d3609df12b83db424a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44defaea3a2dd2e7e40336d3609df12b83db424a/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fplace_op.rs?ref=44defaea3a2dd2e7e40336d3609df12b83db424a", "patch": "@@ -211,13 +211,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         debug!(\"convert_place_derefs_to_mutable: exprs={:?}\", exprs);\n \n         // Fix up autoderefs and derefs.\n+        let mut inside_union = false;\n         for (i, &expr) in exprs.iter().rev().enumerate() {\n             debug!(\"convert_place_derefs_to_mutable: i={} expr={:?}\", i, expr);\n \n+            let mut source = self.node_ty(expr.hir_id);\n+            if matches!(expr.kind, hir::ExprKind::Unary(hir::UnOp::UnDeref, _)) {\n+                // Clear previous flag; after a pointer indirection it does not apply any more.\n+                inside_union = false;\n+            }\n+            if source.ty_adt_def().map_or(false, |adt| adt.is_union()) {\n+                inside_union = true;\n+            }\n             // Fix up the autoderefs. Autorefs can only occur immediately preceding\n             // overloaded place ops, and will be fixed by them in order to get\n             // the correct region.\n-            let mut source = self.node_ty(expr.hir_id);\n             // Do not mutate adjustments in place, but rather take them,\n             // and replace them after mutating them, to avoid having the\n             // typeck results borrowed during (`deref_mut`) method resolution.\n@@ -238,17 +246,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             }\n                             // If this is a union field, also throw an error.\n                             // Union fields should not get mutable auto-deref'd (see RFC 2514).\n-                            if let hir::ExprKind::Field(ref outer_expr, _) = expr.kind {\n-                                let ty = self.node_ty(outer_expr.hir_id);\n-                                if ty.ty_adt_def().map_or(false, |adt| adt.is_union()) {\n-                                    let mut err = self.tcx.sess.struct_span_err(\n-                                        expr.span,\n-                                        \"not automatically applying `DerefMut` on union field\",\n-                                    );\n-                                    err.help(\"writing to this field calls the destructor for the old value\");\n-                                    err.help(\"add an explicit `*` if that is desired, or call `ptr::write` to not run the destructor\");\n-                                    err.emit();\n-                                }\n+                            if inside_union {\n+                                let mut err = self.tcx.sess.struct_span_err(\n+                                    expr.span,\n+                                    \"not automatically applying `DerefMut` on union field\",\n+                                );\n+                                err.help(\"writing to this field calls the destructor for the old value\");\n+                                err.help(\"add an explicit `*` if that is desired, or call `ptr::write` to not run the destructor\");\n+                                err.emit();\n                             }\n                         }\n                     }"}, {"sha": "4578110cd54ebc2af17ad51f85ba26769f801a8e", "filename": "src/test/ui/union/union-deref.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/44defaea3a2dd2e7e40336d3609df12b83db424a/src%2Ftest%2Fui%2Funion%2Funion-deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44defaea3a2dd2e7e40336d3609df12b83db424a/src%2Ftest%2Fui%2Funion%2Funion-deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-deref.rs?ref=44defaea3a2dd2e7e40336d3609df12b83db424a", "patch": "@@ -4,10 +4,16 @@\n \n use std::mem::ManuallyDrop;\n \n-union U<T> { x:(), f: ManuallyDrop<(T,)> }\n+union U1<T> { x:(), f: ManuallyDrop<(T,)> }\n+\n+union U2<T> { x:(), f: (ManuallyDrop<(T,)>,) }\n \n fn main() {\n-    let mut u : U<Vec<i32>> = U { x: () };\n+    let mut u : U1<Vec<i32>> = U1 { x: () };\n     unsafe { (*u.f).0 = Vec::new() }; // explicit deref, this compiles\n     unsafe { u.f.0 = Vec::new() }; //~ERROR not automatically applying `DerefMut` on union field\n+\n+    let mut u : U2<Vec<i32>> = U2 { x: () };\n+    unsafe { (*u.f.0).0 = Vec::new() }; // explicit deref, this compiles\n+    unsafe { u.f.0.0 = Vec::new() }; //~ERROR not automatically applying `DerefMut` on union field\n }"}, {"sha": "93374436d2f664e2fbe3409aef612619cd6f2dc8", "filename": "src/test/ui/union/union-deref.stderr", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/44defaea3a2dd2e7e40336d3609df12b83db424a/src%2Ftest%2Fui%2Funion%2Funion-deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/44defaea3a2dd2e7e40336d3609df12b83db424a/src%2Ftest%2Fui%2Funion%2Funion-deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-deref.stderr?ref=44defaea3a2dd2e7e40336d3609df12b83db424a", "patch": "@@ -1,11 +1,20 @@\n error: not automatically applying `DerefMut` on union field\n-  --> $DIR/union-deref.rs:12:14\n+  --> $DIR/union-deref.rs:14:14\n    |\n LL |     unsafe { u.f.0 = Vec::new() };\n    |              ^^^\n    |\n    = help: writing to this field calls the destructor for the old value\n    = help: add an explicit `*` if that is desired, or call `ptr::write` to not run the destructor\n \n-error: aborting due to previous error\n+error: not automatically applying `DerefMut` on union field\n+  --> $DIR/union-deref.rs:18:14\n+   |\n+LL |     unsafe { u.f.0.0 = Vec::new() };\n+   |              ^^^^^^^\n+   |\n+   = help: writing to this field calls the destructor for the old value\n+   = help: add an explicit `*` if that is desired, or call `ptr::write` to not run the destructor\n+\n+error: aborting due to 2 previous errors\n "}]}