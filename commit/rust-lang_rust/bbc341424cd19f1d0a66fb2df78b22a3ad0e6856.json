{"sha": "bbc341424cd19f1d0a66fb2df78b22a3ad0e6856", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiYzM0MTQyNGNkMTlmMWQwYTY2ZmIyZGY3OGIyMmEzYWQwZTY4NTY=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-01-11T15:35:54Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-01-28T00:56:46Z"}, "message": "rustc: simplify scope-tracking in resolve_lifetime.", "tree": {"sha": "471e44dccc70da28ee97961e86b5a3d776bfee29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/471e44dccc70da28ee97961e86b5a3d776bfee29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bbc341424cd19f1d0a66fb2df78b22a3ad0e6856", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bbc341424cd19f1d0a66fb2df78b22a3ad0e6856", "html_url": "https://github.com/rust-lang/rust/commit/bbc341424cd19f1d0a66fb2df78b22a3ad0e6856", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bbc341424cd19f1d0a66fb2df78b22a3ad0e6856/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0682a75f44c7fee5e7c60d72030deea8e4841732", "url": "https://api.github.com/repos/rust-lang/rust/commits/0682a75f44c7fee5e7c60d72030deea8e4841732", "html_url": "https://github.com/rust-lang/rust/commit/0682a75f44c7fee5e7c60d72030deea8e4841732"}], "stats": {"total": 541, "additions": 220, "deletions": 321}, "files": [{"sha": "11fdf6919ccbee19aa2b7c497b09bcd30ff5a868", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bbc341424cd19f1d0a66fb2df78b22a3ad0e6856/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbc341424cd19f1d0a66fb2df78b22a3ad0e6856/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=bbc341424cd19f1d0a66fb2df78b22a3ad0e6856", "patch": "@@ -30,6 +30,7 @@\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n #![feature(libc)]\n+#![feature(loop_break_value)]\n #![feature(nonzero)]\n #![feature(pub_restricted)]\n #![feature(quote)]"}, {"sha": "c76ce9dac6fb79f76ffac59540d763da0fb46b00", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 219, "deletions": 321, "changes": 540, "blob_url": "https://github.com/rust-lang/rust/blob/bbc341424cd19f1d0a66fb2df78b22a3ad0e6856/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bbc341424cd19f1d0a66fb2df78b22a3ad0e6856/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=bbc341424cd19f1d0a66fb2df78b22a3ad0e6856", "patch": "@@ -26,11 +26,10 @@ use std::mem::replace;\n use syntax::ast;\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n-use util::nodemap::NodeMap;\n+use util::nodemap::{NodeMap, FxHashSet, FxHashMap};\n \n-use rustc_data_structures::fx::FxHashSet;\n use hir;\n-use hir::intravisit::{self, Visitor, FnKind, NestedVisitorMap};\n+use hir::intravisit::{self, Visitor, NestedVisitorMap};\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub enum Region {\n@@ -40,6 +39,37 @@ pub enum Region {\n     Free(region::CallSiteScopeData, /* lifetime decl */ ast::NodeId),\n }\n \n+impl Region {\n+    fn early(index: &mut u32, def: &hir::LifetimeDef) -> (ast::Name, Region) {\n+        let i = *index;\n+        *index += 1;\n+        (def.lifetime.name, Region::EarlyBound(i, def.lifetime.id))\n+    }\n+\n+    fn late(def: &hir::LifetimeDef) -> (ast::Name, Region) {\n+        let depth = ty::DebruijnIndex::new(1);\n+        (def.lifetime.name, Region::LateBound(depth, def.lifetime.id))\n+    }\n+\n+    fn id(&self) -> Option<ast::NodeId> {\n+        match *self {\n+            Region::Static => None,\n+            Region::EarlyBound(_, id) |\n+            Region::LateBound(_, id) |\n+            Region::Free(_, id) => Some(id)\n+        }\n+    }\n+\n+    fn shifted(self, amount: u32) -> Region {\n+        match self {\n+            Region::LateBound(depth, id) => {\n+                Region::LateBound(depth.shifted(amount), id)\n+            }\n+            _ => self\n+        }\n+    }\n+}\n+\n // Maps the id of each lifetime reference to the lifetime decl\n // that it corresponds to.\n pub struct NamedRegionMap {\n@@ -79,28 +109,21 @@ struct LifetimeContext<'a, 'tcx: 'a> {\n     labels_in_fn: Vec<(ast::Name, Span)>,\n }\n \n-#[derive(PartialEq, Debug)]\n+#[derive(Debug)]\n enum Scope<'a> {\n-    /// Extends `s` with early-bound `lifetimes`, having consecutive parameter\n-    /// indices from `start`, i.e. `lifetimes[i]` has index `start + i`.\n-    /// Indices before `start` correspond to other generic parameters\n-    /// of a parent item (trait/impl of a method), or `Self` in traits.\n-    Early {\n-        lifetimes: &'a [hir::LifetimeDef],\n-        start: u32,\n-        s: ScopeRef<'a>\n-    },\n-\n-    /// Extends `s` with late-bound `lifetimes`.\n-    Late {\n-        lifetimes: &'a [hir::LifetimeDef],\n+    /// Declares lifetimes, and each can be early-bound or late-bound.\n+    /// The `DebruijnIndex` of late-bound lifetimes starts at `1` and\n+    /// it should be shifted by the number of `Binder`s in between the\n+    /// declaration `Binder` and the location it's referenced from.\n+    Binder {\n+        lifetimes: FxHashMap<ast::Name, Region>,\n         s: ScopeRef<'a>\n     },\n \n-    /// Lifetimes introduced by a fn are scoped to the call-site for that fn.\n-    Fn {\n-        fn_id: ast::NodeId,\n-        body_id: ast::NodeId,\n+    /// Lifetimes introduced by a fn are scoped to the call-site for that fn,\n+    /// if this is a fn body, otherwise the original definitions are used.\n+    Body {\n+        id: hir::BodyId,\n         s: ScopeRef<'a>\n     },\n \n@@ -121,133 +144,105 @@ pub fn krate(sess: &Session,\n         late_bound: NodeMap(),\n     };\n     sess.track_errors(|| {\n-        intravisit::walk_crate(&mut LifetimeContext {\n+        let mut visitor = LifetimeContext {\n             sess: sess,\n             hir_map: hir_map,\n             map: &mut map,\n             scope: ROOT_SCOPE,\n             trait_ref_hack: false,\n             labels_in_fn: vec![],\n-        }, krate);\n+        };\n+        for (_, item) in &krate.items {\n+            visitor.visit_item(item);\n+        }\n     })?;\n     Ok(map)\n }\n \n impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n-    // Override the nested functions -- lifetimes follow lexical scope,\n-    // so it's convenient to walk the tree in lexical order.\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n-        NestedVisitorMap::All(&self.hir_map)\n+        NestedVisitorMap::All(self.hir_map)\n+    }\n+\n+    // We want to nest trait/impl items in their parent, but nothing else.\n+    fn visit_nested_item(&mut self, _: hir::ItemId) {}\n+\n+    fn visit_nested_body(&mut self, body: hir::BodyId) {\n+        // Each body has their own set of labels, save labels.\n+        let saved = replace(&mut self.labels_in_fn, vec![]);\n+        let body = self.hir_map.body(body);\n+        extract_labels(self, body);\n+        self.with(Scope::Body { id: body.id(), s: self.scope }, |_, this| {\n+            this.visit_body(body);\n+        });\n+        replace(&mut self.labels_in_fn, saved);\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        // Save labels for nested items.\n-        let saved_labels_in_fn = replace(&mut self.labels_in_fn, vec![]);\n-\n-        // Items always introduce a new root scope\n-        self.with(Scope::Root, |_, this| {\n-            match item.node {\n-                hir::ItemFn(..) => {\n-                    // Fn lifetimes get added in visit_fn below:\n+        match item.node {\n+            hir::ItemFn(ref decl, _, _, _, ref generics, _) => {\n+                self.visit_early_late(item.id, None, decl, generics, |this| {\n                     intravisit::walk_item(this, item);\n-                }\n-                hir::ItemExternCrate(_) |\n-                hir::ItemUse(..) |\n-                hir::ItemMod(..) |\n-                hir::ItemDefaultImpl(..) |\n-                hir::ItemForeignMod(..) |\n-                hir::ItemStatic(..) |\n-                hir::ItemConst(..) => {\n-                    // These sorts of items have no lifetime parameters at all.\n+                });\n+            }\n+            hir::ItemExternCrate(_) |\n+            hir::ItemUse(..) |\n+            hir::ItemMod(..) |\n+            hir::ItemDefaultImpl(..) |\n+            hir::ItemForeignMod(..) |\n+            hir::ItemStatic(..) |\n+            hir::ItemConst(..) => {\n+                // These sorts of items have no lifetime parameters at all.\n+                intravisit::walk_item(self, item);\n+            }\n+            hir::ItemTy(_, ref generics) |\n+            hir::ItemEnum(_, ref generics) |\n+            hir::ItemStruct(_, ref generics) |\n+            hir::ItemUnion(_, ref generics) |\n+            hir::ItemTrait(_, ref generics, ..) |\n+            hir::ItemImpl(_, _, ref generics, ..) => {\n+                // These kinds of items have only early bound lifetime parameters.\n+                let mut index = if let hir::ItemTrait(..) = item.node {\n+                    1 // Self comes before lifetimes\n+                } else {\n+                    0\n+                };\n+                let lifetimes = generics.lifetimes.iter().map(|def| {\n+                    Region::early(&mut index, def)\n+                }).collect();\n+                let scope = Scope::Binder {\n+                    lifetimes: lifetimes,\n+                    s: ROOT_SCOPE\n+                };\n+                self.with(scope, |old_scope, this| {\n+                    this.check_lifetime_defs(old_scope, &generics.lifetimes);\n                     intravisit::walk_item(this, item);\n-                }\n-                hir::ItemTy(_, ref generics) |\n-                hir::ItemEnum(_, ref generics) |\n-                hir::ItemStruct(_, ref generics) |\n-                hir::ItemUnion(_, ref generics) |\n-                hir::ItemTrait(_, ref generics, ..) |\n-                hir::ItemImpl(_, _, ref generics, ..) => {\n-                    // These kinds of items have only early bound lifetime parameters.\n-                    let lifetimes = &generics.lifetimes;\n-                    let start = if let hir::ItemTrait(..) = item.node {\n-                        1 // Self comes before lifetimes\n-                    } else {\n-                        0\n-                    };\n-                    let early = Scope::Early {\n-                        lifetimes: lifetimes,\n-                        start: start,\n-                        s: ROOT_SCOPE\n-                    };\n-                    this.with(early, |old_scope, this| {\n-                        this.check_lifetime_defs(old_scope, lifetimes);\n-                        intravisit::walk_item(this, item);\n-                    });\n-                }\n+                });\n             }\n-        });\n-\n-        // Done traversing the item; remove any labels it created\n-        self.labels_in_fn = saved_labels_in_fn;\n+        }\n     }\n \n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem) {\n-        // Items save/restore the set of labels. This way inner items\n-        // can freely reuse names, be they loop labels or lifetimes.\n-        let saved = replace(&mut self.labels_in_fn, vec![]);\n-\n-        // Items always introduce a new root scope\n-        self.with(Scope::Root, |_, this| {\n-            match item.node {\n-                hir::ForeignItemFn(ref decl, _, ref generics) => {\n-                    this.visit_early_late(item.id, decl, generics, |this| {\n-                        intravisit::walk_foreign_item(this, item);\n-                    })\n-                }\n-                hir::ForeignItemStatic(..) => {\n+        match item.node {\n+            hir::ForeignItemFn(ref decl, _, ref generics) => {\n+                self.visit_early_late(item.id, None, decl, generics, |this| {\n                     intravisit::walk_foreign_item(this, item);\n-                }\n-            }\n-        });\n-\n-        // Done traversing the item; restore saved set of labels.\n-        replace(&mut self.labels_in_fn, saved);\n-    }\n-\n-    fn visit_fn(&mut self, fk: FnKind<'tcx>, decl: &'tcx hir::FnDecl,\n-                b: hir::BodyId, s: Span, fn_id: ast::NodeId) {\n-        match fk {\n-            FnKind::ItemFn(_, generics, ..) => {\n-                self.visit_early_late(fn_id,decl, generics, |this| {\n-                    this.add_scope_and_walk_fn(fk, decl, b, s, fn_id)\n                 })\n             }\n-            FnKind::Method(_, sig, ..) => {\n-                self.visit_early_late(\n-                    fn_id,\n-                    decl,\n-                    &sig.generics,\n-                    |this| this.add_scope_and_walk_fn(fk, decl, b, s, fn_id));\n-            }\n-            FnKind::Closure(_) => {\n-                // Closures have their own set of labels, save labels just\n-                // like for foreign items above.\n-                let saved = replace(&mut self.labels_in_fn, vec![]);\n-                let result = self.add_scope_and_walk_fn(fk, decl, b, s, fn_id);\n-                replace(&mut self.labels_in_fn, saved);\n-                result\n+            hir::ForeignItemStatic(..) => {\n+                intravisit::walk_foreign_item(self, item);\n             }\n         }\n     }\n \n     fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         match ty.node {\n             hir::TyBareFn(ref c) => {\n-                let late = Scope::Late {\n-                    lifetimes: &c.lifetimes,\n+                let scope = Scope::Binder {\n+                    lifetimes: c.lifetimes.iter().map(Region::late).collect(),\n                     s: self.scope\n                 };\n-                self.with(late, |old_scope, this| {\n+                self.with(scope, |old_scope, this| {\n                     // a bare fn has no bounds, so everything\n                     // contained within is scoped within its binder.\n                     this.check_lifetime_defs(old_scope, &c.lifetimes);\n@@ -259,7 +254,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 // a trait ref, which introduces a binding scope.\n                 match path.def {\n                     Def::Trait(..) => {\n-                        self.with(Scope::Late { lifetimes: &[], s: self.scope }, |_, this| {\n+                        let scope = Scope::Binder {\n+                            lifetimes: FxHashMap(),\n+                            s: self.scope\n+                        };\n+                        self.with(scope, |_, this| {\n                             this.visit_path(path, ty.id);\n                         });\n                     }\n@@ -275,21 +274,27 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     }\n \n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n-        // We reset the labels on every trait item, so that different\n-        // methods in an impl can reuse label names.\n-        let saved = replace(&mut self.labels_in_fn, vec![]);\n-\n-        if let hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Required(_)) =\n-                trait_item.node {\n+        if let hir::TraitItemKind::Method(ref sig, _) = trait_item.node {\n             self.visit_early_late(\n                 trait_item.id,\n+                Some(self.hir_map.get_parent(trait_item.id)),\n                 &sig.decl, &sig.generics,\n                 |this| intravisit::walk_trait_item(this, trait_item))\n         } else {\n             intravisit::walk_trait_item(self, trait_item);\n         }\n+    }\n \n-        replace(&mut self.labels_in_fn, saved);\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n+        if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n+            self.visit_early_late(\n+                impl_item.id,\n+                Some(self.hir_map.get_parent(impl_item.id)),\n+                &sig.decl, &sig.generics,\n+                |this| intravisit::walk_impl_item(this, impl_item))\n+        } else {\n+            intravisit::walk_impl_item(self, impl_item);\n+        }\n     }\n \n     fn visit_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n@@ -318,11 +323,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                                                                .. }) => {\n                     if !bound_lifetimes.is_empty() {\n                         self.trait_ref_hack = true;\n-                        let late = Scope::Late {\n-                            lifetimes: bound_lifetimes,\n+                        let scope = Scope::Binder {\n+                            lifetimes: bound_lifetimes.iter().map(Region::late).collect(),\n                             s: self.scope\n                         };\n-                        let result = self.with(late, |old_scope, this| {\n+                        let result = self.with(scope, |old_scope, this| {\n                             this.check_lifetime_defs(old_scope, bound_lifetimes);\n                             this.visit_ty(&bounded_ty);\n                             walk_list!(this, visit_ty_param_bound, bounds);\n@@ -363,11 +368,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 span_err!(self.sess, trait_ref.span, E0316,\n                           \"nested quantification of lifetimes\");\n             }\n-            let late = Scope::Late {\n-                lifetimes: &trait_ref.bound_lifetimes,\n+            let scope = Scope::Binder {\n+                lifetimes: trait_ref.bound_lifetimes.iter().map(Region::late).collect(),\n                 s: self.scope\n             };\n-            self.with(late, |old_scope, this| {\n+            self.with(scope, |old_scope, this| {\n                 this.check_lifetime_defs(old_scope, &trait_ref.bound_lifetimes);\n                 for lifetime in &trait_ref.bound_lifetimes {\n                     this.visit_lifetime_def(lifetime);\n@@ -391,8 +396,8 @@ fn original_label(span: Span) -> Original {\n fn shadower_label(span: Span) -> Shadower {\n     Shadower { kind: ShadowKind::Label, span: span }\n }\n-fn original_lifetime(l: &hir::Lifetime) -> Original {\n-    Original { kind: ShadowKind::Lifetime, span: l.span }\n+fn original_lifetime(span: Span) -> Original {\n+    Original { kind: ShadowKind::Lifetime, span: span }\n }\n fn shadower_lifetime(l: &hir::Lifetime) -> Shadower {\n     Shadower { kind: ShadowKind::Lifetime, span: l.span }\n@@ -430,33 +435,28 @@ fn signal_shadowing_problem(sess: &Session, name: ast::Name, orig: Original, sha\n \n // Adds all labels in `b` to `ctxt.labels_in_fn`, signalling a warning\n // if one of the label shadows a lifetime or another label.\n-fn extract_labels(ctxt: &mut LifetimeContext, b: hir::BodyId) {\n-    struct GatherLabels<'a> {\n+fn extract_labels(ctxt: &mut LifetimeContext, body: &hir::Body) {\n+    struct GatherLabels<'a, 'tcx: 'a> {\n         sess: &'a Session,\n+        hir_map: &'a Map<'tcx>,\n         scope: ScopeRef<'a>,\n         labels_in_fn: &'a mut Vec<(ast::Name, Span)>,\n     }\n \n     let mut gather = GatherLabels {\n         sess: ctxt.sess,\n+        hir_map: ctxt.hir_map,\n         scope: ctxt.scope,\n         labels_in_fn: &mut ctxt.labels_in_fn,\n     };\n-    gather.visit_body(ctxt.hir_map.body(b));\n-    return;\n+    gather.visit_body(body);\n \n-    impl<'v, 'a> Visitor<'v> for GatherLabels<'a> {\n+    impl<'v, 'a, 'tcx> Visitor<'v> for GatherLabels<'a, 'tcx> {\n         fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v> {\n             NestedVisitorMap::None\n         }\n \n-        fn visit_expr(&mut self, ex: &'v hir::Expr) {\n-            // do not recurse into closures defined in the block\n-            // since they are treated as separate fns from the POV of\n-            // labels_in_fn\n-            if let hir::ExprClosure(..) = ex.node {\n-                return\n-            }\n+        fn visit_expr(&mut self, ex: &hir::Expr) {\n             if let Some((label, label_span)) = expression_label(ex) {\n                 for &(prior, prior_span) in &self.labels_in_fn[..] {\n                     // FIXME (#24278): non-hygienic comparison\n@@ -469,6 +469,7 @@ fn extract_labels(ctxt: &mut LifetimeContext, b: hir::BodyId) {\n                 }\n \n                 check_if_label_shadows_lifetime(self.sess,\n+                                                self.hir_map,\n                                                 self.scope,\n                                                 label,\n                                                 label_span);\n@@ -492,26 +493,24 @@ fn extract_labels(ctxt: &mut LifetimeContext, b: hir::BodyId) {\n     }\n \n     fn check_if_label_shadows_lifetime<'a>(sess: &'a Session,\n+                                           hir_map: &Map,\n                                            mut scope: ScopeRef<'a>,\n                                            label: ast::Name,\n                                            label_span: Span) {\n         loop {\n             match *scope {\n-                Scope::Fn { s, .. } => { scope = s; }\n+                Scope::Body { s, .. } => { scope = s; }\n                 Scope::Root => { return; }\n \n-                Scope::Early { lifetimes, s, .. } |\n-                Scope::Late { lifetimes, s } => {\n-                    for lifetime_def in lifetimes {\n-                        // FIXME (#24278): non-hygienic comparison\n-                        if label == lifetime_def.lifetime.name {\n-                            signal_shadowing_problem(\n-                                sess,\n-                                label,\n-                                original_lifetime(&lifetime_def.lifetime),\n-                                shadower_label(label_span));\n-                            return;\n-                        }\n+                Scope::Binder { ref lifetimes, s } => {\n+                    // FIXME (#24278): non-hygienic comparison\n+                    if let Some(def) = lifetimes.get(&label) {\n+                        signal_shadowing_problem(\n+                            sess,\n+                            label,\n+                            original_lifetime(hir_map.span(def.id().unwrap())),\n+                            shadower_label(label_span));\n+                        return;\n                     }\n                     scope = s;\n                 }\n@@ -521,34 +520,6 @@ fn extract_labels(ctxt: &mut LifetimeContext, b: hir::BodyId) {\n }\n \n impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n-    fn add_scope_and_walk_fn(&mut self,\n-                             fk: FnKind<'tcx>,\n-                             fd: &'tcx hir::FnDecl,\n-                             fb: hir::BodyId,\n-                             _span: Span,\n-                             fn_id: ast::NodeId) {\n-        match fk {\n-            FnKind::ItemFn(_, generics, ..) => {\n-                intravisit::walk_fn_decl(self, fd);\n-                self.visit_generics(generics);\n-            }\n-            FnKind::Method(_, sig, ..) => {\n-                intravisit::walk_fn_decl(self, fd);\n-                self.visit_generics(&sig.generics);\n-            }\n-            FnKind::Closure(_) => {\n-                intravisit::walk_fn_decl(self, fd);\n-            }\n-        }\n-\n-        // After inpsecting the decl, add all labels from the body to\n-        // `self.labels_in_fn`.\n-        extract_labels(self, fb);\n-\n-        self.with(Scope::Fn { fn_id: fn_id, body_id: fb.node_id, s: self.scope },\n-                  |_old_scope, this| this.visit_nested_body(fb))\n-    }\n-\n     // FIXME(#37666) this works around a limitation in the region inferencer\n     fn hack<F>(&mut self, f: F) where\n         F: for<'b> FnOnce(&mut LifetimeContext<'b, 'tcx>),\n@@ -560,17 +531,19 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         F: for<'b> FnOnce(ScopeRef, &mut LifetimeContext<'b, 'tcx>),\n     {\n         let LifetimeContext {sess, hir_map, ref mut map, ..} = *self;\n+        let labels_in_fn = replace(&mut self.labels_in_fn, vec![]);\n         let mut this = LifetimeContext {\n             sess: sess,\n             hir_map: hir_map,\n             map: *map,\n             scope: &wrap_scope,\n             trait_ref_hack: self.trait_ref_hack,\n-            labels_in_fn: self.labels_in_fn.clone(),\n+            labels_in_fn: labels_in_fn,\n         };\n         debug!(\"entering scope {:?}\", this.scope);\n         f(self.scope, &mut this);\n         debug!(\"exiting scope {:?}\", this.scope);\n+        self.labels_in_fn = this.labels_in_fn;\n     }\n \n     /// Visits self by adding a scope and handling recursive walk over the contents with `walk`.\n@@ -593,6 +566,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     /// ordering is not important there.\n     fn visit_early_late<F>(&mut self,\n                            fn_id: ast::NodeId,\n+                           parent_id: Option<ast::NodeId>,\n                            decl: &'tcx hir::FnDecl,\n                            generics: &'tcx hir::Generics,\n                            walk: F) where\n@@ -604,162 +578,98 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                                     decl,\n                                     generics);\n \n-        let (late, early): (Vec<_>, _) =\n-            generics.lifetimes\n-                    .iter()\n-                    .cloned()\n-                    .partition(|l| self.map.late_bound.contains_key(&l.lifetime.id));\n-\n         // Find the start of nested early scopes, e.g. in methods.\n-        let mut start = 0;\n-        if let Scope::Early {..} = *self.scope {\n-            let parent = self.hir_map.expect_item(self.hir_map.get_parent(fn_id));\n+        let mut index = 0;\n+        if let Some(parent_id) = parent_id {\n+            let parent = self.hir_map.expect_item(parent_id);\n             if let hir::ItemTrait(..) = parent.node {\n-                start += 1; // Self comes first.\n+                index += 1; // Self comes first.\n             }\n             match parent.node {\n                 hir::ItemTrait(_, ref generics, ..) |\n                 hir::ItemImpl(_, _, ref generics, ..) => {\n-                    start += generics.lifetimes.len() + generics.ty_params.len();\n+                    index += (generics.lifetimes.len() + generics.ty_params.len()) as u32;\n                 }\n                 _ => {}\n             }\n         }\n \n-        let early = Scope::Early {\n-            lifetimes: &early,\n-            start: start as u32,\n+        let lifetimes = generics.lifetimes.iter().map(|def| {\n+            if self.map.late_bound.contains_key(&def.lifetime.id) {\n+                Region::late(def)\n+            } else {\n+                Region::early(&mut index, def)\n+            }\n+        }).collect();\n+\n+        let scope = Scope::Binder {\n+            lifetimes: lifetimes,\n             s: self.scope\n         };\n-        self.with(early, move |old_scope, this| {\n-            let late = Scope::Late {\n-                lifetimes: &late,\n-                s: this.scope\n-            };\n-            this.with(late, move |_, this| {\n-                this.check_lifetime_defs(old_scope, &generics.lifetimes);\n-                this.hack(walk); // FIXME(#37666) workaround in place of `walk(this)`\n-            });\n+        self.with(scope, move |old_scope, this| {\n+            this.check_lifetime_defs(old_scope, &generics.lifetimes);\n+            this.hack(walk); // FIXME(#37666) workaround in place of `walk(this)`\n         });\n     }\n \n     fn resolve_lifetime_ref(&mut self, lifetime_ref: &hir::Lifetime) {\n         // Walk up the scope chain, tracking the number of fn scopes\n         // that we pass through, until we find a lifetime with the\n-        // given name or we run out of scopes. If we encounter a code\n-        // block, then the lifetime is not bound but free, so switch\n-        // over to `resolve_free_lifetime_ref()` to complete the\n+        // given name or we run out of scopes.\n         // search.\n         let mut late_depth = 0;\n         let mut scope = self.scope;\n-        loop {\n+        let mut outermost_body = None;\n+        let result = loop {\n             match *scope {\n-                Scope::Fn { fn_id, body_id, s } => {\n-                    return self.resolve_free_lifetime_ref(\n-                        region::CallSiteScopeData { fn_id: fn_id, body_id: body_id },\n-                        lifetime_ref,\n-                        s);\n+                Scope::Body { id, s } => {\n+                    outermost_body = Some(id);\n+                    scope = s;\n                 }\n \n                 Scope::Root => {\n-                    break;\n+                    break None;\n                 }\n \n-                Scope::Early { lifetimes, start, s } => {\n-                    match search_lifetimes(lifetimes, lifetime_ref) {\n-                        Some((index, lifetime_def)) => {\n-                            let decl_id = lifetime_def.id;\n-                            let def = Region::EarlyBound(start + index, decl_id);\n-                            self.insert_lifetime(lifetime_ref, def);\n-                            return;\n-                        }\n-                        None => {\n-                            scope = s;\n-                        }\n-                    }\n-                }\n-\n-                Scope::Late { lifetimes, s } => {\n-                    match search_lifetimes(lifetimes, lifetime_ref) {\n-                        Some((_index, lifetime_def)) => {\n-                            let decl_id = lifetime_def.id;\n-                            let debruijn = ty::DebruijnIndex::new(late_depth + 1);\n-                            let def = Region::LateBound(debruijn, decl_id);\n-                            self.insert_lifetime(lifetime_ref, def);\n-                            return;\n-                        }\n-\n-                        None => {\n-                            late_depth += 1;\n-                            scope = s;\n-                        }\n+                Scope::Binder { ref lifetimes, s } => {\n+                    if let Some(&def) = lifetimes.get(&lifetime_ref.name) {\n+                        break Some(def.shifted(late_depth));\n+                    } else {\n+                        late_depth += 1;\n+                        scope = s;\n                     }\n                 }\n             }\n-        }\n-\n-        self.unresolved_lifetime_ref(lifetime_ref);\n-    }\n-\n-    fn resolve_free_lifetime_ref(&mut self,\n-                                 scope_data: region::CallSiteScopeData,\n-                                 lifetime_ref: &hir::Lifetime,\n-                                 scope: ScopeRef) {\n-        debug!(\"resolve_free_lifetime_ref \\\n-                scope_data: {:?} lifetime_ref: {:?} scope: {:?}\",\n-               scope_data, lifetime_ref, scope);\n-\n-        // Walk up the scope chain, tracking the outermost free scope,\n-        // until we encounter a scope that contains the named lifetime\n-        // or we run out of scopes.\n-        let mut scope_data = scope_data;\n-        let mut scope = scope;\n-        let mut search_result = None;\n-        loop {\n-            debug!(\"resolve_free_lifetime_ref \\\n-                    scope_data: {:?} scope: {:?} search_result: {:?}\",\n-                   scope_data, scope, search_result);\n-            match *scope {\n-                Scope::Fn { fn_id, body_id, s } => {\n-                    scope_data = region::CallSiteScopeData {\n-                        fn_id: fn_id, body_id: body_id\n-                    };\n-                    scope = s;\n-                }\n-\n-                Scope::Root => {\n-                    break;\n-                }\n+        };\n \n-                Scope::Early { lifetimes, s, .. } |\n-                Scope::Late { lifetimes, s } => {\n-                    search_result = search_lifetimes(lifetimes, lifetime_ref);\n-                    if search_result.is_some() {\n-                        break;\n+        if let Some(mut def) = result {\n+            if let Some(body_id) = outermost_body {\n+                let fn_id = self.hir_map.body_owner(body_id);\n+                let scope_data = region::CallSiteScopeData {\n+                    fn_id: fn_id, body_id: body_id.node_id\n+                };\n+                match self.hir_map.get(fn_id) {\n+                    hir::map::NodeItem(&hir::Item {\n+                        node: hir::ItemFn(..), ..\n+                    }) |\n+                    hir::map::NodeTraitItem(&hir::TraitItem {\n+                        node: hir::TraitItemKind::Method(..), ..\n+                    }) |\n+                    hir::map::NodeImplItem(&hir::ImplItem {\n+                        node: hir::ImplItemKind::Method(..), ..\n+                    }) => {\n+                        def = Region::Free(scope_data, def.id().unwrap());\n                     }\n-                    scope = s;\n+                    _ => {}\n                 }\n             }\n+            self.insert_lifetime(lifetime_ref, def);\n+        } else {\n+            struct_span_err!(self.sess, lifetime_ref.span, E0261,\n+                \"use of undeclared lifetime name `{}`\", lifetime_ref.name)\n+                .span_label(lifetime_ref.span, &format!(\"undeclared lifetime\"))\n+                .emit();\n         }\n-\n-        match search_result {\n-            Some((_depth, lifetime)) => {\n-                let def = Region::Free(scope_data, lifetime.id);\n-                self.insert_lifetime(lifetime_ref, def);\n-            }\n-\n-            None => {\n-                self.unresolved_lifetime_ref(lifetime_ref);\n-            }\n-        }\n-\n-    }\n-\n-    fn unresolved_lifetime_ref(&self, lifetime_ref: &hir::Lifetime) {\n-        struct_span_err!(self.sess, lifetime_ref.span, E0261,\n-            \"use of undeclared lifetime name `{}`\", lifetime_ref.name)\n-            .span_label(lifetime_ref.span, &format!(\"undeclared lifetime\"))\n-            .emit();\n     }\n \n     fn check_lifetime_defs(&mut self, old_scope: ScopeRef, lifetimes: &[hir::LifetimeDef]) {\n@@ -819,21 +729,20 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         loop {\n             match *old_scope {\n-                Scope::Fn { s, .. } => {\n+                Scope::Body { s, .. } => {\n                     old_scope = s;\n                 }\n \n                 Scope::Root => {\n                     return;\n                 }\n \n-                Scope::Early { lifetimes, s, .. } |\n-                Scope::Late { lifetimes, s } => {\n-                    if let Some((_, lifetime_def)) = search_lifetimes(lifetimes, lifetime) {\n+                Scope::Binder { ref lifetimes, s } => {\n+                    if let Some(&def) = lifetimes.get(&lifetime.name) {\n                         signal_shadowing_problem(\n                             self.sess,\n                             lifetime.name,\n-                            original_lifetime(&lifetime_def),\n+                            original_lifetime(self.hir_map.span(def.id().unwrap())),\n                             shadower_lifetime(&lifetime));\n                         return;\n                     }\n@@ -861,17 +770,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     }\n }\n \n-fn search_lifetimes<'a>(lifetimes: &'a [hir::LifetimeDef],\n-                    lifetime_ref: &hir::Lifetime)\n-                    -> Option<(u32, &'a hir::Lifetime)> {\n-    for (i, lifetime_decl) in lifetimes.iter().enumerate() {\n-        if lifetime_decl.lifetime.name == lifetime_ref.name {\n-            return Some((i as u32, &lifetime_decl.lifetime));\n-        }\n-    }\n-    return None;\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n \n /// Detects late-bound lifetimes and inserts them into"}]}