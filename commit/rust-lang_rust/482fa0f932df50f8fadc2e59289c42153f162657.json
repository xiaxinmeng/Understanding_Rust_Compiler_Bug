{"sha": "482fa0f932df50f8fadc2e59289c42153f162657", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4MmZhMGY5MzJkZjUwZjhmYWRjMmU1OTI4OWM0MjE1M2YxNjI2NTc=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-01-12T22:06:42Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-01-12T22:06:42Z"}, "message": "incr.comp.: Add some caching to Predecessors construction.", "tree": {"sha": "08567e18655f54ad8b2fa7cdb0ba542060cbdc09", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08567e18655f54ad8b2fa7cdb0ba542060cbdc09"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/482fa0f932df50f8fadc2e59289c42153f162657", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/482fa0f932df50f8fadc2e59289c42153f162657", "html_url": "https://github.com/rust-lang/rust/commit/482fa0f932df50f8fadc2e59289c42153f162657", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/482fa0f932df50f8fadc2e59289c42153f162657/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cde366d32989a9c126c79c43fd9c62845506614e", "url": "https://api.github.com/repos/rust-lang/rust/commits/cde366d32989a9c126c79c43fd9c62845506614e", "html_url": "https://github.com/rust-lang/rust/commit/cde366d32989a9c126c79c43fd9c62845506614e"}], "stats": {"total": 306, "additions": 297, "deletions": 9}, "files": [{"sha": "b2a4a2772ec263effe995f25d2c88e0ee4bf4acc", "filename": "src/librustc_incremental/persist/preds.rs", "status": "modified", "additions": 297, "deletions": 9, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/482fa0f932df50f8fadc2e59289c42153f162657/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/482fa0f932df50f8fadc2e59289c42153f162657/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fpreds.rs?ref=482fa0f932df50f8fadc2e59289c42153f162657", "patch": "@@ -11,7 +11,8 @@\n use rustc::dep_graph::{DepGraphQuery, DepNode};\n use rustc::hir::def_id::DefId;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::graph::{DepthFirstTraversal, INCOMING, NodeIndex};\n+use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::graph::{NodeIndex, Graph};\n \n use super::hash::*;\n use ich::Fingerprint;\n@@ -33,11 +34,21 @@ pub struct Predecessors<'query> {\n impl<'q> Predecessors<'q> {\n     pub fn new(query: &'q DepGraphQuery<DefId>, hcx: &mut HashContext) -> Self {\n         // Find nodes for which we want to know the full set of preds\n-        let mut dfs = DepthFirstTraversal::new(&query.graph, INCOMING);\n-        let all_nodes = query.graph.all_nodes();\n         let tcx = hcx.tcx;\n+        let node_count = query.graph.len_nodes();\n \n-        let inputs: FxHashMap<_, _> = all_nodes.iter()\n+        // Set up some data structures the cache predecessor search needs:\n+        let mut visit_counts: Vec<u32> = Vec::new();\n+        let mut node_cache: Vec<Option<Box<[u32]>>> = Vec::new();\n+        visit_counts.resize(node_count, 0);\n+        node_cache.resize(node_count, None);\n+        let mut dfs_workspace1 = DfsWorkspace::new(node_count);\n+        let mut dfs_workspace2 = DfsWorkspace::new(node_count);\n+\n+        let inputs: FxHashMap<_, _> = query\n+            .graph\n+            .all_nodes()\n+            .iter()\n             .enumerate()\n             .filter(|&(_, node)| match node.data {\n                 DepNode::WorkProduct(_) => true,\n@@ -51,11 +62,18 @@ impl<'q> Predecessors<'q> {\n                 _ => false,\n             })\n             .map(|(node_index, node)| {\n-                dfs.reset(NodeIndex(node_index));\n-                let inputs: Vec<_> = dfs.by_ref()\n-                    .map(|i| &all_nodes[i.node_id()].data)\n-                    .filter(|d| HashContext::is_hashable(d))\n-                    .collect();\n+                find_roots(&query.graph,\n+                           node_index as u32,\n+                           &mut visit_counts,\n+                           &mut node_cache[..],\n+                           HashContext::is_hashable,\n+                           &mut dfs_workspace1,\n+                           Some(&mut dfs_workspace2));\n+\n+                let inputs: Vec<_> = dfs_workspace1.output.nodes.iter().map(|&i| {\n+                    query.graph.node_data(NodeIndex(i as usize))\n+                }).collect();\n+\n                 (&node.data, inputs)\n             })\n             .collect();\n@@ -72,3 +90,273 @@ impl<'q> Predecessors<'q> {\n         }\n     }\n }\n+\n+const CACHING_THRESHOLD: u32 = 60;\n+\n+// Starting at `start_node`, this function finds this node's \"roots\", that is,\n+// anything that is hashable, in the dep-graph. It uses a simple depth-first\n+// search to achieve that. However, since some sub-graphs are traversed over\n+// and over again, the function also some caching built into it: Each time it\n+// visits a node it increases a counter for that node. If a node has been\n+// visited more often than CACHING_THRESHOLD, the function will allocate a\n+// cache entry in the `cache` array. This cache entry contains a flat list of\n+// all roots reachable from the given node. The next time the node is visited,\n+// the search can just add the contents of this array to the output instead of\n+// recursing further.\n+//\n+// The function takes two `DfsWorkspace` arguments. These contains some data\n+// structures that would be expensive to re-allocate all the time, so they are\n+// allocated once up-front. There are two of them because building a cache entry\n+// requires a recursive invocation of this function. Two are enough though,\n+// since function never recurses more than once.\n+fn find_roots<T, F>(graph: &Graph<T, ()>,\n+                    start_node: u32,\n+                    visit_counts: &mut [u32],\n+                    cache: &mut [Option<Box<[u32]>>],\n+                    is_root: F,\n+                    workspace: &mut DfsWorkspace,\n+                    mut sub_workspace: Option<&mut DfsWorkspace>)\n+    where F: Copy + Fn(&T) -> bool,\n+          T: ::std::fmt::Debug,\n+{\n+    workspace.visited.clear();\n+    workspace.output.clear();\n+    workspace.stack.clear();\n+    workspace.stack.push(start_node);\n+\n+    loop {\n+        let node = match workspace.stack.pop() {\n+            Some(node) => node,\n+            None => return,\n+        };\n+\n+        if !workspace.visited.insert(node as usize) {\n+            continue\n+        }\n+\n+        if is_root(graph.node_data(NodeIndex(node as usize))) {\n+            // If this is a root, just add it to the output.\n+            workspace.output.insert(node);\n+        } else {\n+            if let Some(ref cached) = cache[node as usize] {\n+                for &n in &cached[..] {\n+                    workspace.output.insert(n);\n+                }\n+                // No need to recurse further from this node\n+                continue\n+            }\n+\n+            visit_counts[node as usize] += 1;\n+\n+            // If this node has been visited often enough to be cached ...\n+            if visit_counts[node as usize] > CACHING_THRESHOLD {\n+                // ... we are actually allowed to cache something, do so:\n+                if let Some(ref mut sub_workspace) = sub_workspace {\n+                    // Note that the following recursive invocation does never\n+                    // write to the cache (since we pass None as sub_workspace).\n+                    // This is intentional: The graph we are working with\n+                    // contains cycles and this prevent us from simply building\n+                    // our caches recursively on-demand.\n+                    // However, we can just do a regular, non-caching DFS to\n+                    // yield the set of roots and cache that.\n+                    find_roots(graph,\n+                               node,\n+                               visit_counts,\n+                               cache,\n+                               is_root,\n+                               sub_workspace,\n+                               None);\n+\n+                    for &n in &sub_workspace.output.nodes {\n+                        workspace.output.insert(n);\n+                    }\n+\n+                    cache[node as usize] = Some(sub_workspace.output\n+                                                             .nodes\n+                                                             .clone()\n+                                                             .into_boxed_slice());\n+                    // No need to recurse further from this node\n+                    continue\n+                }\n+            }\n+\n+            for pred in graph.predecessor_nodes(NodeIndex(node as usize)) {\n+                workspace.stack.push(pred.node_id() as u32);\n+            }\n+        }\n+    }\n+}\n+\n+struct DfsWorkspace {\n+    stack: Vec<u32>,\n+    visited: BitVector,\n+    output: NodeIndexSet,\n+}\n+\n+impl DfsWorkspace {\n+    fn new(total_node_count: usize) -> DfsWorkspace {\n+        DfsWorkspace {\n+            stack: Vec::new(),\n+            visited: BitVector::new(total_node_count),\n+            output: NodeIndexSet::new(total_node_count),\n+        }\n+    }\n+}\n+\n+struct NodeIndexSet {\n+    bitset: BitVector,\n+    nodes: Vec<u32>,\n+}\n+\n+impl NodeIndexSet {\n+    fn new(total_node_count: usize) -> NodeIndexSet {\n+        NodeIndexSet {\n+            bitset: BitVector::new(total_node_count),\n+            nodes: Vec::new(),\n+        }\n+    }\n+\n+    #[inline]\n+    fn clear(&mut self) {\n+        self.bitset.clear();\n+        self.nodes.clear();\n+    }\n+\n+    #[inline]\n+    fn insert(&mut self, node: u32) {\n+        if self.bitset.insert(node as usize) {\n+            self.nodes.push(node)\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_cached_dfs_acyclic() {\n+\n+    //     0     1   2\n+    //     |      \\ /\n+    //     3---+   |\n+    //     |   |   |\n+    //     |   |   |\n+    //     4   5   6\n+    //      \\ / \\ / \\\n+    //       |   |   |\n+    //       7   8   9\n+\n+    let mut g: Graph<bool, ()> = Graph::new();\n+    g.add_node(false);\n+    g.add_node(false);\n+    g.add_node(false);\n+    g.add_node(false);\n+    g.add_node(false);\n+    g.add_node(false);\n+    g.add_node(false);\n+    g.add_node(true);\n+    g.add_node(true);\n+    g.add_node(true);\n+\n+    g.add_edge(NodeIndex(3), NodeIndex(0), ());\n+    g.add_edge(NodeIndex(4), NodeIndex(3), ());\n+    g.add_edge(NodeIndex(7), NodeIndex(4), ());\n+    g.add_edge(NodeIndex(5), NodeIndex(3), ());\n+    g.add_edge(NodeIndex(7), NodeIndex(5), ());\n+    g.add_edge(NodeIndex(8), NodeIndex(5), ());\n+    g.add_edge(NodeIndex(8), NodeIndex(6), ());\n+    g.add_edge(NodeIndex(9), NodeIndex(6), ());\n+    g.add_edge(NodeIndex(6), NodeIndex(1), ());\n+    g.add_edge(NodeIndex(6), NodeIndex(2), ());\n+\n+    let mut ws1 = DfsWorkspace::new(g.len_nodes());\n+    let mut ws2 = DfsWorkspace::new(g.len_nodes());\n+    let mut visit_counts: Vec<_> = g.all_nodes().iter().map(|_| 0u32).collect();\n+    let mut cache: Vec<Option<Box<[u32]>>> = g.all_nodes().iter().map(|_| None).collect();\n+\n+    fn is_root(x: &bool) -> bool { *x }\n+\n+    for _ in 0 .. CACHING_THRESHOLD + 1 {\n+        find_roots(&g, 5, &mut visit_counts, &mut cache[..], is_root, &mut ws1, Some(&mut ws2));\n+        ws1.output.nodes.sort();\n+        assert_eq!(ws1.output.nodes, vec![7, 8]);\n+\n+        find_roots(&g, 6, &mut visit_counts, &mut cache[..], is_root, &mut ws1, Some(&mut ws2));\n+        ws1.output.nodes.sort();\n+        assert_eq!(ws1.output.nodes, vec![8, 9]);\n+\n+        find_roots(&g, 0, &mut visit_counts, &mut cache[..], is_root, &mut ws1, Some(&mut ws2));\n+        ws1.output.nodes.sort();\n+        assert_eq!(ws1.output.nodes, vec![7, 8]);\n+\n+        find_roots(&g, 1, &mut visit_counts, &mut cache[..], is_root, &mut ws1, Some(&mut ws2));\n+        ws1.output.nodes.sort();\n+        assert_eq!(ws1.output.nodes, vec![8, 9]);\n+\n+        find_roots(&g, 2, &mut visit_counts, &mut cache[..], is_root, &mut ws1, Some(&mut ws2));\n+        ws1.output.nodes.sort();\n+        assert_eq!(ws1.output.nodes, vec![8, 9]);\n+\n+        find_roots(&g, 3, &mut visit_counts, &mut cache[..], is_root, &mut ws1, Some(&mut ws2));\n+        ws1.output.nodes.sort();\n+        assert_eq!(ws1.output.nodes, vec![7, 8]);\n+\n+        find_roots(&g, 4, &mut visit_counts, &mut cache[..], is_root, &mut ws1, Some(&mut ws2));\n+        ws1.output.nodes.sort();\n+        assert_eq!(ws1.output.nodes, vec![7]);\n+    }\n+}\n+\n+#[test]\n+fn test_cached_dfs_cyclic() {\n+\n+    //    0       1 <---- 2       3\n+    //    ^       |       ^       ^\n+    //    |       v       |       |\n+    //    4 ----> 5 ----> 6 ----> 7\n+    //    ^       ^       ^       ^\n+    //    |       |       |       |\n+    //    8       9      10      11\n+\n+\n+    let mut g: Graph<bool, ()> = Graph::new();\n+    g.add_node(false);\n+    g.add_node(false);\n+    g.add_node(false);\n+    g.add_node(false);\n+    g.add_node(false);\n+    g.add_node(false);\n+    g.add_node(false);\n+    g.add_node(false);\n+    g.add_node(true);\n+    g.add_node(true);\n+    g.add_node(true);\n+    g.add_node(true);\n+\n+    g.add_edge(NodeIndex( 4), NodeIndex(0), ());\n+    g.add_edge(NodeIndex( 8), NodeIndex(4), ());\n+    g.add_edge(NodeIndex( 4), NodeIndex(5), ());\n+    g.add_edge(NodeIndex( 1), NodeIndex(5), ());\n+    g.add_edge(NodeIndex( 9), NodeIndex(5), ());\n+    g.add_edge(NodeIndex( 5), NodeIndex(6), ());\n+    g.add_edge(NodeIndex( 6), NodeIndex(2), ());\n+    g.add_edge(NodeIndex( 2), NodeIndex(1), ());\n+    g.add_edge(NodeIndex(10), NodeIndex(6), ());\n+    g.add_edge(NodeIndex( 6), NodeIndex(7), ());\n+    g.add_edge(NodeIndex(11), NodeIndex(7), ());\n+    g.add_edge(NodeIndex( 7), NodeIndex(3), ());\n+\n+    let mut ws1 = DfsWorkspace::new(g.len_nodes());\n+    let mut ws2 = DfsWorkspace::new(g.len_nodes());\n+    let mut visit_counts: Vec<_> = g.all_nodes().iter().map(|_| 0u32).collect();\n+    let mut cache: Vec<Option<Box<[u32]>>> = g.all_nodes().iter().map(|_| None).collect();\n+\n+    fn is_root(x: &bool) -> bool { *x }\n+\n+    for _ in 0 .. CACHING_THRESHOLD + 1 {\n+        find_roots(&g, 2, &mut visit_counts, &mut cache[..], is_root, &mut ws1, Some(&mut ws2));\n+        ws1.output.nodes.sort();\n+        assert_eq!(ws1.output.nodes, vec![8, 9, 10]);\n+\n+        find_roots(&g, 3, &mut visit_counts, &mut cache[..], is_root, &mut ws1, Some(&mut ws2));\n+        ws1.output.nodes.sort();\n+        assert_eq!(ws1.output.nodes, vec![8, 9, 10, 11]);\n+    }\n+}"}]}