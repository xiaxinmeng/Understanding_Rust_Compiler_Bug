{"sha": "e22b6edae5787039dc0b85112702bb8d16a2aa60", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyMmI2ZWRhZTU3ODcwMzlkYzBiODUxMTI3MDJiYjhkMTZhMmFhNjA=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-23T15:09:45Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-23T15:09:45Z"}, "message": "refactor", "tree": {"sha": "a1baccf9b8916c7959307cb4eb6ece9b06e282a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1baccf9b8916c7959307cb4eb6ece9b06e282a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e22b6edae5787039dc0b85112702bb8d16a2aa60", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e22b6edae5787039dc0b85112702bb8d16a2aa60", "html_url": "https://github.com/rust-lang/rust/commit/e22b6edae5787039dc0b85112702bb8d16a2aa60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e22b6edae5787039dc0b85112702bb8d16a2aa60/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "343852d8b24a199b4f2ad4e1149214724b4526db", "url": "https://api.github.com/repos/rust-lang/rust/commits/343852d8b24a199b4f2ad4e1149214724b4526db", "html_url": "https://github.com/rust-lang/rust/commit/343852d8b24a199b4f2ad4e1149214724b4526db"}], "stats": {"total": 179, "additions": 81, "deletions": 98}, "files": [{"sha": "b201bf69bf9ae1bd67cfea86a251ab65136e1a10", "filename": "crates/ra_hir/src/module_tree.rs", "status": "modified", "additions": 81, "deletions": 98, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/e22b6edae5787039dc0b85112702bb8d16a2aa60/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e22b6edae5787039dc0b85112702bb8d16a2aa60/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmodule_tree.rs?ref=e22b6edae5787039dc0b85112702bb8d16a2aa60", "patch": "@@ -131,7 +131,8 @@ impl ModuleTree {\n         source_root: SourceRootId,\n     ) -> Arc<ModuleTree> {\n         db.check_canceled();\n-        let res = create_module_tree(db, source_root);\n+        let mut res = ModuleTree::default();\n+        res.init(db, source_root);\n         Arc::new(res)\n     }\n \n@@ -144,6 +145,85 @@ impl ModuleTree {\n         Some(res)\n     }\n \n+    fn init(&mut self, db: &impl HirDatabase, source_root: SourceRootId) {\n+        let mut roots = FxHashMap::default();\n+        let mut visited = FxHashSet::default();\n+\n+        let source_root = db.source_root(source_root);\n+        for &file_id in source_root.files.values() {\n+            let source = SourceItemId {\n+                file_id: file_id.into(),\n+                item_id: None,\n+            };\n+            if visited.contains(&source) {\n+                continue; // TODO: use explicit crate_roots here\n+            }\n+            assert!(!roots.contains_key(&file_id));\n+            let module_id =\n+                self.init_subtree(db, &source_root, &mut visited, &mut roots, None, source);\n+            roots.insert(file_id, module_id);\n+        }\n+    }\n+\n+    fn init_subtree(\n+        &mut self,\n+        db: &impl HirDatabase,\n+        source_root: &SourceRoot,\n+        visited: &mut FxHashSet<SourceItemId>,\n+        roots: &mut FxHashMap<FileId, ModuleId>,\n+        parent: Option<LinkId>,\n+        source: SourceItemId,\n+    ) -> ModuleId {\n+        visited.insert(source);\n+        let id = self.alloc_mod(ModuleData {\n+            source,\n+            parent,\n+            children: Vec::new(),\n+        });\n+        for sub in db.submodules(source).iter() {\n+            let link = self.alloc_link(LinkData {\n+                source: sub.source,\n+                name: sub.name.clone(),\n+                owner: id,\n+                points_to: Vec::new(),\n+                problem: None,\n+            });\n+\n+            let (points_to, problem) = if sub.is_declaration {\n+                let (points_to, problem) = resolve_submodule(db, source.file_id, &sub.name);\n+                let points_to = points_to\n+                    .into_iter()\n+                    .map(|file_id| match roots.remove(&file_id) {\n+                        Some(module_id) => {\n+                            self.mods[module_id].parent = Some(link);\n+                            module_id\n+                        }\n+                        None => self.init_subtree(\n+                            db,\n+                            source_root,\n+                            visited,\n+                            roots,\n+                            Some(link),\n+                            SourceItemId {\n+                                file_id: file_id.into(),\n+                                item_id: None,\n+                            },\n+                        ),\n+                    })\n+                    .collect::<Vec<_>>();\n+                (points_to, problem)\n+            } else {\n+                let points_to =\n+                    self.init_subtree(db, source_root, visited, roots, Some(link), sub.source);\n+                (vec![points_to], None)\n+            };\n+\n+            self.links[link].points_to = points_to;\n+            self.links[link].problem = problem;\n+        }\n+        id\n+    }\n+\n     fn alloc_mod(&mut self, data: ModuleData) -> ModuleId {\n         self.mods.alloc(data)\n     }\n@@ -221,103 +301,6 @@ impl LinkId {\n     }\n }\n \n-fn create_module_tree<'a>(db: &impl HirDatabase, source_root: SourceRootId) -> ModuleTree {\n-    let mut tree = ModuleTree::default();\n-\n-    let mut roots = FxHashMap::default();\n-    let mut visited = FxHashSet::default();\n-\n-    let source_root = db.source_root(source_root);\n-    for &file_id in source_root.files.values() {\n-        let source = SourceItemId {\n-            file_id: file_id.into(),\n-            item_id: None,\n-        };\n-        if visited.contains(&source) {\n-            continue; // TODO: use explicit crate_roots here\n-        }\n-        assert!(!roots.contains_key(&file_id));\n-        let module_id = build_subtree(\n-            db,\n-            &source_root,\n-            &mut tree,\n-            &mut visited,\n-            &mut roots,\n-            None,\n-            source,\n-        );\n-        roots.insert(file_id, module_id);\n-    }\n-    tree\n-}\n-\n-fn build_subtree(\n-    db: &impl HirDatabase,\n-    source_root: &SourceRoot,\n-    tree: &mut ModuleTree,\n-    visited: &mut FxHashSet<SourceItemId>,\n-    roots: &mut FxHashMap<FileId, ModuleId>,\n-    parent: Option<LinkId>,\n-    source: SourceItemId,\n-) -> ModuleId {\n-    visited.insert(source);\n-    let id = tree.alloc_mod(ModuleData {\n-        source,\n-        parent,\n-        children: Vec::new(),\n-    });\n-    for sub in db.submodules(source).iter() {\n-        let link = tree.alloc_link(LinkData {\n-            source: sub.source,\n-            name: sub.name.clone(),\n-            owner: id,\n-            points_to: Vec::new(),\n-            problem: None,\n-        });\n-\n-        let (points_to, problem) = if sub.is_declaration {\n-            let (points_to, problem) = resolve_submodule(db, source.file_id, &sub.name);\n-            let points_to = points_to\n-                .into_iter()\n-                .map(|file_id| match roots.remove(&file_id) {\n-                    Some(module_id) => {\n-                        tree.mods[module_id].parent = Some(link);\n-                        module_id\n-                    }\n-                    None => build_subtree(\n-                        db,\n-                        source_root,\n-                        tree,\n-                        visited,\n-                        roots,\n-                        Some(link),\n-                        SourceItemId {\n-                            file_id: file_id.into(),\n-                            item_id: None,\n-                        },\n-                    ),\n-                })\n-                .collect::<Vec<_>>();\n-            (points_to, problem)\n-        } else {\n-            let points_to = build_subtree(\n-                db,\n-                source_root,\n-                tree,\n-                visited,\n-                roots,\n-                Some(link),\n-                sub.source,\n-            );\n-            (vec![points_to], None)\n-        };\n-\n-        tree.links[link].points_to = points_to;\n-        tree.links[link].problem = problem;\n-    }\n-    id\n-}\n-\n fn resolve_submodule(\n     db: &impl HirDatabase,\n     file_id: HirFileId,"}]}