{"sha": "41499f45635d94003a9461c059d9b395b1a6e3ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxNDk5ZjQ1NjM1ZDk0MDAzYTk0NjFjMDU5ZDliMzk1YjFhNmUzZWE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-09T12:20:50Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-17T19:51:55Z"}, "message": "mir: Match against slices by calling PartialEq::eq.", "tree": {"sha": "5a0934fba8a418e71a312c857010ae1a44176d8c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5a0934fba8a418e71a312c857010ae1a44176d8c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41499f45635d94003a9461c059d9b395b1a6e3ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41499f45635d94003a9461c059d9b395b1a6e3ea", "html_url": "https://github.com/rust-lang/rust/commit/41499f45635d94003a9461c059d9b395b1a6e3ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41499f45635d94003a9461c059d9b395b1a6e3ea/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d9277b163c36448c5fbc39fa089a78256b45ffc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/d9277b163c36448c5fbc39fa089a78256b45ffc1", "html_url": "https://github.com/rust-lang/rust/commit/d9277b163c36448c5fbc39fa089a78256b45ffc1"}], "stats": {"total": 123, "additions": 99, "deletions": 24}, "files": [{"sha": "4e3a69bf745f5c47daaf892c095ecf8d4da734ac", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 69, "deletions": 24, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/41499f45635d94003a9461c059d9b395b1a6e3ea/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41499f45635d94003a9461c059d9b395b1a6e3ea/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=41499f45635d94003a9461c059d9b395b1a6e3ea", "patch": "@@ -174,33 +174,78 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 targets\n             }\n \n-            TestKind::Eq { ref value, ty } => {\n-                // If we're matching against &[u8] with b\"...\", we need to insert\n-                // an unsizing coercion, as the byte string has type &[u8; N].\n-                let expect = match *value {\n-                    ConstVal::ByteStr(ref bytes) if ty.is_slice() => {\n-                        let tcx = self.hir.tcx();\n-                        let array_ty = tcx.mk_array(tcx.types.u8, bytes.len());\n-                        let ref_ty = tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic), array_ty);\n-                        let array = self.literal_operand(test.span, ref_ty, Literal::Value {\n-                            value: value.clone()\n-                        });\n-\n-                        let sliced = self.temp(ty);\n-                        self.cfg.push_assign(block, test.span, &sliced,\n-                                             Rvalue::Cast(CastKind::Unsize, array, ty));\n-                        Operand::Consume(sliced)\n-                    }\n-                    _ => {\n-                        self.literal_operand(test.span, ty, Literal::Value {\n-                            value: value.clone()\n-                        })\n+            TestKind::Eq { ref value, mut ty } => {\n+                let mut val = Operand::Consume(lvalue.clone());\n+\n+                // If we're using b\"...\" as a pattern, we need to insert an\n+                // unsizing coercion, as the byte string has the type &[u8; N].\n+                let expect = if let ConstVal::ByteStr(ref bytes) = *value {\n+                    let tcx = self.hir.tcx();\n+\n+                    // Unsize the lvalue to &[u8], too, if necessary.\n+                    if let ty::TyRef(region, mt) = ty.sty {\n+                        if let ty::TyArray(_, _) = mt.ty.sty {\n+                            ty = tcx.mk_imm_ref(region, tcx.mk_slice(tcx.types.u8));\n+                            let val_slice = self.temp(ty);\n+                            self.cfg.push_assign(block, test.span, &val_slice,\n+                                                 Rvalue::Cast(CastKind::Unsize, val, ty));\n+                            val = Operand::Consume(val_slice);\n+                        }\n                     }\n+\n+                    assert!(ty.is_slice());\n+\n+                    let array_ty = tcx.mk_array(tcx.types.u8, bytes.len());\n+                    let array_ref = tcx.mk_imm_ref(tcx.mk_region(ty::ReStatic), array_ty);\n+                    let array = self.literal_operand(test.span, array_ref, Literal::Value {\n+                        value: value.clone()\n+                    });\n+\n+                    let slice = self.temp(ty);\n+                    self.cfg.push_assign(block, test.span, &slice,\n+                                         Rvalue::Cast(CastKind::Unsize, array, ty));\n+                    Operand::Consume(slice)\n+                } else {\n+                    self.literal_operand(test.span, ty, Literal::Value {\n+                        value: value.clone()\n+                    })\n                 };\n-                let val = Operand::Consume(lvalue.clone());\n+\n+                // Use PartialEq::eq for &str and &[u8] slices, instead of BinOp::Eq.\n                 let fail = self.cfg.start_new_block();\n-                let block = self.compare(block, fail, test.span, BinOp::Eq, expect, val.clone());\n-                vec![block, fail]\n+                if let ty::TyRef(_, mt) = ty.sty {\n+                    assert!(ty.is_slice());\n+                    let eq_def_id = self.hir.tcx().lang_items.eq_trait().unwrap();\n+                    let ty = mt.ty;\n+                    let (mty, method) = self.hir.trait_method(eq_def_id, \"eq\", ty, vec![ty]);\n+\n+                    let bool_ty = self.hir.bool_ty();\n+                    let eq_result = self.temp(bool_ty);\n+                    let eq_block = self.cfg.start_new_block();\n+                    let cleanup = self.diverge_cleanup();\n+                    self.cfg.terminate(block, Terminator::Call {\n+                        func: Operand::Constant(Constant {\n+                            span: test.span,\n+                            ty: mty,\n+                            literal: method\n+                        }),\n+                        args: vec![val, expect],\n+                        destination: Some((eq_result.clone(), eq_block)),\n+                        cleanup: cleanup,\n+                    });\n+\n+                    // check the result\n+                    let block = self.cfg.start_new_block();\n+                    self.cfg.terminate(eq_block, Terminator::If {\n+                        cond: Operand::Consume(eq_result),\n+                        targets: (block, fail),\n+                    });\n+\n+                    vec![block, fail]\n+                } else {\n+                    let block = self.compare(block, fail, test.span, BinOp::Eq, expect, val);\n+                    vec![block, fail]\n+                }\n             }\n \n             TestKind::Range { ref lo, ref hi, ty } => {"}, {"sha": "b97bfaf5aef68edbe73d2c20db41c432a3fe0737", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/41499f45635d94003a9461c059d9b395b1a6e3ea/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41499f45635d94003a9461c059d9b395b1a6e3ea/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=41499f45635d94003a9461c059d9b395b1a6e3ea", "patch": "@@ -19,7 +19,9 @@ use hair::*;\n use rustc::mir::repr::*;\n \n use rustc::middle::const_eval::{self, ConstVal};\n+use rustc::middle::def_id::DefId;\n use rustc::middle::infer::InferCtxt;\n+use rustc::middle::subst::{Subst, Substs};\n use rustc::middle::ty::{self, Ty, TyCtxt};\n use syntax::codemap::Span;\n use syntax::parse::token;\n@@ -96,6 +98,34 @@ impl<'a,'tcx:'a> Cx<'a, 'tcx> {\n         })\n     }\n \n+    pub fn trait_method(&mut self,\n+                        trait_def_id: DefId,\n+                        method_name: &str,\n+                        self_ty: Ty<'tcx>,\n+                        params: Vec<Ty<'tcx>>)\n+                        -> (Ty<'tcx>, Literal<'tcx>) {\n+        let method_name = token::intern(method_name);\n+        let substs = Substs::new_trait(params, vec![], self_ty);\n+        for trait_item in self.tcx.trait_items(trait_def_id).iter() {\n+            match *trait_item {\n+                ty::ImplOrTraitItem::MethodTraitItem(ref method) => {\n+                    if method.name == method_name {\n+                        let method_ty = self.tcx.lookup_item_type(method.def_id);\n+                        let method_ty = method_ty.ty.subst(self.tcx, &substs);\n+                        return (method_ty, Literal::Item {\n+                            def_id: method.def_id,\n+                            substs: self.tcx.mk_substs(substs),\n+                        });\n+                    }\n+                }\n+                ty::ImplOrTraitItem::ConstTraitItem(..) |\n+                ty::ImplOrTraitItem::TypeTraitItem(..) => {}\n+            }\n+        }\n+\n+        self.tcx.sess.bug(&format!(\"found no method `{}` in `{:?}`\", method_name, trait_def_id));\n+    }\n+\n     pub fn num_variants(&mut self, adt_def: ty::AdtDef<'tcx>) -> usize {\n         adt_def.variants.len()\n     }"}]}