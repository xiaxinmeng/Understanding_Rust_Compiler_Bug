{"sha": "63083ee7670f5331f6264b6bd235b1d9b909a943", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzMDgzZWU3NjcwZjUzMzFmNjI2NGI2YmQyMzViMWQ5YjkwOWE5NDM=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-08-12T23:44:07Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-08-14T20:42:58Z"}, "message": "rustc: Eliminate a derived error in check::_match", "tree": {"sha": "d96b9a4f7ebf0368f66b5c92cfb3fe938e33b404", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d96b9a4f7ebf0368f66b5c92cfb3fe938e33b404"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63083ee7670f5331f6264b6bd235b1d9b909a943", "comment_count": 6, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63083ee7670f5331f6264b6bd235b1d9b909a943", "html_url": "https://github.com/rust-lang/rust/commit/63083ee7670f5331f6264b6bd235b1d9b909a943", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63083ee7670f5331f6264b6bd235b1d9b909a943/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a677bcf6e359f6f013a7e580ef467b5f389e5b7", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a677bcf6e359f6f013a7e580ef467b5f389e5b7", "html_url": "https://github.com/rust-lang/rust/commit/0a677bcf6e359f6f013a7e580ef467b5f389e5b7"}], "stats": {"total": 86, "additions": 73, "deletions": 13}, "files": [{"sha": "b7114e602830f3aa634dfc7eae180d7dd38c348c", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 33, "deletions": 11, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/63083ee7670f5331f6264b6bd235b1d9b909a943/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63083ee7670f5331f6264b6bd235b1d9b909a943/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=63083ee7670f5331f6264b6bd235b1d9b909a943", "patch": "@@ -156,6 +156,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: &ast::Path,\n                     kind_name = \"variant\";\n                 }\n                 None => {\n+                    // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n                     fcx.infcx().type_error_message_str_with_expected(pat.span,\n                                                        |expected, actual| {\n                                                        expected.map_move_default(~\"\", |e| {\n@@ -199,6 +200,7 @@ pub fn check_pat_variant(pcx: &pat_ctxt, pat: @ast::pat, path: &ast::Path,\n             kind_name = \"structure\";\n         }\n         _ => {\n+            // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n             fcx.infcx().type_error_message_str_with_expected(pat.span,\n                                                |expected, actual| {\n                                                expected.map_move_default(~\"\", |e| {\n@@ -302,10 +304,13 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n             }\n             None => {\n                 let name = pprust::path_to_str(path, tcx.sess.intr());\n+                // Check the pattern anyway, so that attempts to look\n+                // up its type won't fail\n+                check_pat(pcx, field.pat, ty::mk_err());\n                 tcx.sess.span_err(span,\n-                                  fmt!(\"struct `%s` does not have a field\n-                                        named `%s`\", name,\n-                                       tcx.sess.str_of(field.ident)));\n+                    fmt!(\"struct `%s` does not have a field named `%s`\",\n+                         name,\n+                         tcx.sess.str_of(field.ident)));\n             }\n         }\n     }\n@@ -326,16 +331,17 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n pub fn check_struct_pat(pcx: &pat_ctxt, pat_id: ast::NodeId, span: span,\n                         expected: ty::t, path: &ast::Path,\n                         fields: &[ast::field_pat], etc: bool,\n-                        class_id: ast::def_id, substitutions: &ty::substs) {\n+                        struct_id: ast::def_id,\n+                        substitutions: &ty::substs) {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n \n-    let class_fields = ty::lookup_struct_fields(tcx, class_id);\n+    let class_fields = ty::lookup_struct_fields(tcx, struct_id);\n \n     // Check to ensure that the struct is the one specified.\n     match tcx.def_map.find(&pat_id) {\n         Some(&ast::def_struct(supplied_def_id))\n-                if supplied_def_id == class_id => {\n+                if supplied_def_id == struct_id => {\n             // OK.\n         }\n         Some(&ast::def_struct(*)) | Some(&ast::def_variant(*)) => {\n@@ -346,11 +352,11 @@ pub fn check_struct_pat(pcx: &pat_ctxt, pat_id: ast::NodeId, span: span,\n                                    name));\n         }\n         _ => {\n-            tcx.sess.span_bug(span, \"resolve didn't write in class\");\n+            tcx.sess.span_bug(span, \"resolve didn't write in struct ID\");\n         }\n     }\n \n-    check_struct_pat_fields(pcx, span, path, fields, class_fields, class_id,\n+    check_struct_pat_fields(pcx, span, path, fields, class_fields, struct_id,\n                             substitutions, etc);\n }\n \n@@ -499,9 +505,22 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n                     substs);\n             }\n             _ => {\n-                tcx.sess.span_err(pat.span,\n-                                  fmt!(\"mismatched types: expected `%s` but found struct\",\n-                                       fcx.infcx().ty_to_str(expected)));\n+               // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n+               fcx.infcx().type_error_message_str_with_expected(pat.span,\n+                                                                |expected, actual| {\n+                            expected.map_move_default(~\"\", |e| {\n+                                    fmt!(\"mismatched types: expected `%s` but found %s\",\n+                                         e, actual)})},\n+                                         Some(expected), ~\"a structure pattern\",\n+                                         None);\n+                match tcx.def_map.find(&pat.id) {\n+                    Some(&ast::def_struct(supplied_def_id)) => {\n+                         check_struct_pat(pcx, pat.id, pat.span, ty::mk_err(), path, *fields, etc,\n+                         supplied_def_id,\n+                         &ty::substs { self_ty: None, tps: ~[], regions: ty::ErasedRegions} );\n+                    }\n+                    _ => () // Error, but we're already in an error case\n+                }\n                 error_happened = true;\n             }\n         }\n@@ -534,6 +553,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n                                                            found: e_count}),\n                     _ => ty::terr_mismatch\n                 };\n+                // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n                 fcx.infcx().type_error_message_str_with_expected(pat.span, |expected, actual| {\n                 expected.map_move_default(~\"\", |e| {\n                     fmt!(\"mismatched types: expected `%s` but found %s\",\n@@ -581,6 +601,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n               for &elt in after.iter() {\n                   check_pat(pcx, elt, ty::mk_err());\n               }\n+              // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n               fcx.infcx().type_error_message_str_with_expected(\n                   pat.span,\n                   |expected, actual| {\n@@ -639,6 +660,7 @@ pub fn check_pointer_pat(pcx: &pat_ctxt,\n         }\n         _ => {\n             check_pat(pcx, inner, ty::mk_err());\n+            // See [Note-Type-error-reporting] in middle/typeck/infer/mod.rs\n             fcx.infcx().type_error_message_str_with_expected(\n                 span,\n                 |expected, actual| {"}, {"sha": "a11abda8ec529d78b20baa4b018a642940e605ef", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/63083ee7670f5331f6264b6bd235b1d9b909a943/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63083ee7670f5331f6264b6bd235b1d9b909a943/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=63083ee7670f5331f6264b6bd235b1d9b909a943", "patch": "@@ -698,6 +698,17 @@ impl InferCtxt {\n         }\n     }\n \n+    // [Note-Type-error-reporting]\n+    // An invariant is that anytime the expected or actual type is ty_err (the special\n+    // error type, meaning that an error occurred when typechecking this expression),\n+    // this is a derived error. The error cascaded from another error (that was already\n+    // reported), so it's not useful to display it to the user.\n+    // The following four methods -- type_error_message_str, type_error_message_str_with_expected,\n+    // type_error_message, and report_mismatched_types -- implement this logic.\n+    // They check if either the actual or expected type is ty_err, and don't print the error\n+    // in this case. The typechecker should only ever report type errors involving mismatched\n+    // types using one of these four methods, and should not call span_err directly for such\n+    // errors.\n     pub fn type_error_message_str(@mut self,\n                                   sp: span,\n                                   mk_msg: &fn(Option<~str>, ~str) -> ~str,"}, {"sha": "09e4380f346794da39d2ec91dd280b9c28ce39fe", "filename": "src/test/compile-fail/pattern-error-continue.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/63083ee7670f5331f6264b6bd235b1d9b909a943/src%2Ftest%2Fcompile-fail%2Fpattern-error-continue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63083ee7670f5331f6264b6bd235b1d9b909a943/src%2Ftest%2Fcompile-fail%2Fpattern-error-continue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-error-continue.rs?ref=63083ee7670f5331f6264b6bd235b1d9b909a943", "patch": "@@ -29,8 +29,9 @@ fn main() {\n         _ => ()\n     }\n     match 'c' {\n-        S { _ } => (),   //~ ERROR mismatched types: expected `char` but found struct\n+        S { _ } => (),   //~ ERROR mismatched types: expected `char` but found a structure pattern\n+\n         _ => ()\n     }\n     f(true);            //~ ERROR mismatched types: expected `char` but found `bool`\n-}\n\\ No newline at end of file\n+}"}, {"sha": "cafead3af0e667786c1f5b697487ed60748e4b14", "filename": "src/test/compile-fail/struct-pat-derived-error.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/63083ee7670f5331f6264b6bd235b1d9b909a943/src%2Ftest%2Fcompile-fail%2Fstruct-pat-derived-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63083ee7670f5331f6264b6bd235b1d9b909a943/src%2Ftest%2Fcompile-fail%2Fstruct-pat-derived-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstruct-pat-derived-error.rs?ref=63083ee7670f5331f6264b6bd235b1d9b909a943", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct a {\n+    b: uint,\n+    c: uint\n+}\n+\n+impl a {\n+    fn foo(&self) {\n+        let a { x, y } = self.d; //~ ERROR attempted access of field `d`\n+        //~^ ERROR struct `a` does not have a field named `x`\n+        //~^^ ERROR struct `a` does not have a field named `y`\n+        //~^^^ ERROR pattern does not mention field `b`\n+        //~^^^^ ERROR pattern does not mention field `c`\n+    }\n+}\n+\n+fn main() {}"}]}