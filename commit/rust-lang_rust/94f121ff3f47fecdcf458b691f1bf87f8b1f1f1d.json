{"sha": "94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0ZjEyMWZmM2Y0N2ZlY2RjZjQ1OGI2OTFmMWJmODdmOGIxZjFmMWQ=", "commit": {"author": {"name": "Taiki Endo", "email": "te316e89@gmail.com", "date": "2019-02-04T12:49:54Z"}, "committer": {"name": "Taiki Endo", "email": "te316e89@gmail.com", "date": "2019-02-04T12:49:54Z"}, "message": "libsyntax_ext => 2018", "tree": {"sha": "2a4e8a892978ce007579a7f44e016a6303a50c65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a4e8a892978ce007579a7f44e016a6303a50c65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "html_url": "https://github.com/rust-lang/rust/commit/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/comments", "author": {"login": "taiki-e", "id": 43724913, "node_id": "MDQ6VXNlcjQzNzI0OTEz", "avatar_url": "https://avatars.githubusercontent.com/u/43724913?v=4", "gravatar_id": "", "url": "https://api.github.com/users/taiki-e", "html_url": "https://github.com/taiki-e", "followers_url": "https://api.github.com/users/taiki-e/followers", "following_url": "https://api.github.com/users/taiki-e/following{/other_user}", "gists_url": "https://api.github.com/users/taiki-e/gists{/gist_id}", "starred_url": "https://api.github.com/users/taiki-e/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/taiki-e/subscriptions", "organizations_url": "https://api.github.com/users/taiki-e/orgs", "repos_url": "https://api.github.com/users/taiki-e/repos", "events_url": "https://api.github.com/users/taiki-e/events{/privacy}", "received_events_url": "https://api.github.com/users/taiki-e/received_events", "type": "User", "site_admin": false}, "committer": {"login": "taiki-e", "id": 43724913, "node_id": "MDQ6VXNlcjQzNzI0OTEz", "avatar_url": "https://avatars.githubusercontent.com/u/43724913?v=4", "gravatar_id": "", "url": "https://api.github.com/users/taiki-e", "html_url": "https://github.com/taiki-e", "followers_url": "https://api.github.com/users/taiki-e/followers", "following_url": "https://api.github.com/users/taiki-e/following{/other_user}", "gists_url": "https://api.github.com/users/taiki-e/gists{/gist_id}", "starred_url": "https://api.github.com/users/taiki-e/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/taiki-e/subscriptions", "organizations_url": "https://api.github.com/users/taiki-e/orgs", "repos_url": "https://api.github.com/users/taiki-e/repos", "events_url": "https://api.github.com/users/taiki-e/events{/privacy}", "received_events_url": "https://api.github.com/users/taiki-e/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e858c2637fa5bac40ac450628b30c56c2b4327b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e858c2637fa5bac40ac450628b30c56c2b4327b4", "html_url": "https://github.com/rust-lang/rust/commit/e858c2637fa5bac40ac450628b30c56c2b4327b4"}], "stats": {"total": 537, "additions": 269, "deletions": 268}, "files": [{"sha": "c22b55b8c13a0f1846f523cfe468a3398f68b0ff", "filename": "src/libsyntax_ext/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2FCargo.toml?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -2,6 +2,7 @@\n authors = [\"The Rust Project Developers\"]\n name = \"syntax_ext\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n name = \"syntax_ext\""}, {"sha": "ebcdceea7c5a90fcfc32846e28723621df5aaf63", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -1,20 +1,21 @@\n // Inline assembly support.\n //\n-use self::State::*;\n+use State::*;\n \n use rustc_data_structures::thin_vec::ThinVec;\n \n-use errors::DiagnosticBuilder;\n+use crate::errors::DiagnosticBuilder;\n+\n use syntax::ast;\n-use syntax::ext::base;\n-use syntax::ext::base::*;\n+use syntax::ext::base::{self, *};\n use syntax::feature_gate;\n use syntax::parse::{self, token};\n use syntax::ptr::P;\n use syntax::symbol::Symbol;\n use syntax::ast::AsmDialect;\n use syntax_pos::Span;\n use syntax::tokenstream;\n+use syntax::{span_err, struct_span_err};\n \n enum State {\n     Asm,\n@@ -40,7 +41,7 @@ impl State {\n \n const OPTIONS: &[&str] = &[\"volatile\", \"alignstack\", \"intel\"];\n \n-pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n+pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                        sp: Span,\n                        tts: &[tokenstream::TokenTree])\n                        -> Box<dyn base::MacResult + 'cx> {"}, {"sha": "984ef26f5ab8b12d01b17ea00f3e7a32541b9f0d", "filename": "src/libsyntax_ext/assert.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fassert.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -1,4 +1,5 @@\n-use errors::DiagnosticBuilder;\n+use crate::errors::DiagnosticBuilder;\n+\n use syntax::ast::{self, *};\n use syntax::source_map::Spanned;\n use syntax::ext::base::*;\n@@ -11,7 +12,7 @@ use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax_pos::{Span, DUMMY_SP};\n \n pub fn expand_assert<'cx>(\n-    cx: &'cx mut ExtCtxt,\n+    cx: &'cx mut ExtCtxt<'_>,\n     sp: Span,\n     tts: &[TokenTree],\n ) -> Box<dyn MacResult + 'cx> {"}, {"sha": "e2104550878ec8366a26f144400a8c00085ddcc2", "filename": "src/libsyntax_ext/cfg.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fcfg.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -2,17 +2,17 @@\n /// a literal `true` or `false` based on whether the given cfg matches the\n /// current compilation environment.\n \n-use errors::DiagnosticBuilder;\n+use crate::errors::DiagnosticBuilder;\n+\n use syntax::ast;\n-use syntax::ext::base::*;\n-use syntax::ext::base;\n+use syntax::ext::base::{self, *};\n use syntax::ext::build::AstBuilder;\n use syntax::attr;\n use syntax::tokenstream;\n use syntax::parse::token;\n use syntax_pos::Span;\n \n-pub fn expand_cfg<'cx>(cx: &mut ExtCtxt,\n+pub fn expand_cfg<'cx>(cx: &mut ExtCtxt<'_>,\n                        sp: Span,\n                        tts: &[tokenstream::TokenTree])\n                        -> Box<dyn base::MacResult + 'static> {"}, {"sha": "59d3f2c9c7813a0901097227b18546ead73315f8", "filename": "src/libsyntax_ext/compile_error.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fcompile_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fcompile_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fcompile_error.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -1,11 +1,10 @@\n // The compiler code necessary to support the compile_error! extension.\n \n-use syntax::ext::base::*;\n-use syntax::ext::base;\n+use syntax::ext::base::{self, *};\n use syntax_pos::Span;\n use syntax::tokenstream;\n \n-pub fn expand_compile_error<'cx>(cx: &'cx mut ExtCtxt,\n+pub fn expand_compile_error<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                               sp: Span,\n                               tts: &[tokenstream::TokenTree])\n                               -> Box<dyn base::MacResult + 'cx> {"}, {"sha": "230b00c0f8f552767f0c061c10354cb7dc834e96", "filename": "src/libsyntax_ext/concat.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -3,12 +3,11 @@ use syntax::ext::base;\n use syntax::ext::build::AstBuilder;\n use syntax::symbol::Symbol;\n use syntax::tokenstream;\n-use syntax_pos;\n \n use std::string::String;\n \n pub fn expand_syntax_ext(\n-    cx: &mut base::ExtCtxt,\n+    cx: &mut base::ExtCtxt<'_>,\n     sp: syntax_pos::Span,\n     tts: &[tokenstream::TokenTree],\n ) -> Box<dyn base::MacResult + 'static> {"}, {"sha": "8c9eb4bf2d8ffac3a6a98956d72e647a0e269814", "filename": "src/libsyntax_ext/concat_idents.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat_idents.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -1,16 +1,15 @@\n use rustc_data_structures::thin_vec::ThinVec;\n \n use syntax::ast;\n-use syntax::ext::base::*;\n-use syntax::ext::base;\n+use syntax::ext::base::{self, *};\n use syntax::feature_gate;\n use syntax::parse::token;\n use syntax::ptr::P;\n use syntax_pos::Span;\n use syntax_pos::symbol::Symbol;\n use syntax::tokenstream::TokenTree;\n \n-pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt,\n+pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                               sp: Span,\n                               tts: &[TokenTree])\n                               -> Box<dyn base::MacResult + 'cx> {"}, {"sha": "c7b805e0bdca6bf0dd8f23bf89760f4c83e6f359", "filename": "src/libsyntax_ext/deriving/bounds.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fbounds.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -1,19 +1,20 @@\n-use deriving::path_std;\n-use deriving::generic::*;\n-use deriving::generic::ty::*;\n+use crate::deriving::path_std;\n+use crate::deriving::generic::*;\n+use crate::deriving::generic::ty::*;\n+\n use syntax::ast::MetaItem;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax_pos::Span;\n \n-pub fn expand_deriving_unsafe_bound(cx: &mut ExtCtxt,\n+pub fn expand_deriving_unsafe_bound(cx: &mut ExtCtxt<'_>,\n                                     span: Span,\n                                     _: &MetaItem,\n                                     _: &Annotatable,\n                                     _: &mut dyn FnMut(Annotatable)) {\n     cx.span_err(span, \"this unsafe trait should be implemented explicitly\");\n }\n \n-pub fn expand_deriving_copy(cx: &mut ExtCtxt,\n+pub fn expand_deriving_copy(cx: &mut ExtCtxt<'_>,\n                             span: Span,\n                             mitem: &MetaItem,\n                             item: &Annotatable,"}, {"sha": "b347092e1bc4c3208847acf79f3b6e93ee392f63", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -1,17 +1,16 @@\n-use deriving::path_std;\n-use deriving::generic::*;\n-use deriving::generic::ty::*;\n+use crate::deriving::path_std;\n+use crate::deriving::generic::*;\n+use crate::deriving::generic::ty::*;\n \n-use syntax::ast::{self, Expr, Generics, ItemKind, MetaItem, VariantData};\n-use syntax::ast::GenericArg;\n+use syntax::ast::{self, Expr, GenericArg, Generics, ItemKind, MetaItem, VariantData};\n use syntax::attr;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n use syntax::symbol::{Symbol, keywords};\n use syntax_pos::Span;\n \n-pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n+pub fn expand_deriving_clone(cx: &mut ExtCtxt<'_>,\n                              span: Span,\n                              mitem: &MetaItem,\n                              item: &Annotatable,\n@@ -105,12 +104,12 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n }\n \n fn cs_clone_shallow(name: &str,\n-                    cx: &mut ExtCtxt,\n+                    cx: &mut ExtCtxt<'_>,\n                     trait_span: Span,\n-                    substr: &Substructure,\n+                    substr: &Substructure<'_>,\n                     is_union: bool)\n                     -> P<Expr> {\n-    fn assert_ty_bounds(cx: &mut ExtCtxt, stmts: &mut Vec<ast::Stmt>,\n+    fn assert_ty_bounds(cx: &mut ExtCtxt<'_>, stmts: &mut Vec<ast::Stmt>,\n                         ty: P<ast::Ty>, span: Span, helper_name: &str) {\n         // Generate statement `let _: helper_name<ty>;`,\n         // set the expn ID so we can use the unstable struct.\n@@ -120,7 +119,7 @@ fn cs_clone_shallow(name: &str,\n                                         vec![GenericArg::Type(ty)], vec![]);\n         stmts.push(cx.stmt_let_type_only(span, cx.ty_path(assert_path)));\n     }\n-    fn process_variant(cx: &mut ExtCtxt, stmts: &mut Vec<ast::Stmt>, variant: &VariantData) {\n+    fn process_variant(cx: &mut ExtCtxt<'_>, stmts: &mut Vec<ast::Stmt>, variant: &VariantData) {\n         for field in variant.fields() {\n             // let _: AssertParamIsClone<FieldTy>;\n             assert_ty_bounds(cx, stmts, field.ty.clone(), field.span, \"AssertParamIsClone\");\n@@ -151,14 +150,14 @@ fn cs_clone_shallow(name: &str,\n }\n \n fn cs_clone(name: &str,\n-            cx: &mut ExtCtxt,\n+            cx: &mut ExtCtxt<'_>,\n             trait_span: Span,\n-            substr: &Substructure)\n+            substr: &Substructure<'_>)\n             -> P<Expr> {\n     let ctor_path;\n     let all_fields;\n     let fn_path = cx.std_path(&[\"clone\", \"Clone\", \"clone\"]);\n-    let subcall = |cx: &mut ExtCtxt, field: &FieldInfo| {\n+    let subcall = |cx: &mut ExtCtxt<'_>, field: &FieldInfo<'_>| {\n         let args = vec![cx.expr_addr_of(field.span, field.self_.clone())];\n         cx.expr_call_global(field.span, fn_path.clone(), args)\n     };"}, {"sha": "a1035ff641fa191fdf15b2b87ec89ed8922d5d5b", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -1,6 +1,6 @@\n-use deriving::path_std;\n-use deriving::generic::*;\n-use deriving::generic::ty::*;\n+use crate::deriving::path_std;\n+use crate::deriving::generic::*;\n+use crate::deriving::generic::ty::*;\n \n use syntax::ast::{self, Expr, MetaItem, GenericArg};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n@@ -9,7 +9,7 @@ use syntax::ptr::P;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n-pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n+pub fn expand_deriving_eq(cx: &mut ExtCtxt<'_>,\n                           span: Span,\n                           mitem: &MetaItem,\n                           item: &Annotatable,\n@@ -44,8 +44,11 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n     trait_def.expand_ext(cx, mitem, item, push, true)\n }\n \n-fn cs_total_eq_assert(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> P<Expr> {\n-    fn assert_ty_bounds(cx: &mut ExtCtxt, stmts: &mut Vec<ast::Stmt>,\n+fn cs_total_eq_assert(cx: &mut ExtCtxt<'_>,\n+                      trait_span: Span,\n+                      substr: &Substructure<'_>)\n+                      -> P<Expr> {\n+    fn assert_ty_bounds(cx: &mut ExtCtxt<'_>, stmts: &mut Vec<ast::Stmt>,\n                         ty: P<ast::Ty>, span: Span, helper_name: &str) {\n         // Generate statement `let _: helper_name<ty>;`,\n         // set the expn ID so we can use the unstable struct.\n@@ -55,7 +58,9 @@ fn cs_total_eq_assert(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n                                         vec![GenericArg::Type(ty)], vec![]);\n         stmts.push(cx.stmt_let_type_only(span, cx.ty_path(assert_path)));\n     }\n-    fn process_variant(cx: &mut ExtCtxt, stmts: &mut Vec<ast::Stmt>, variant: &ast::VariantData) {\n+    fn process_variant(cx: &mut ExtCtxt<'_>,\n+                       stmts: &mut Vec<ast::Stmt>,\n+                       variant: &ast::VariantData) {\n         for field in variant.fields() {\n             // let _: AssertParamIsEq<FieldTy>;\n             assert_ty_bounds(cx, stmts, field.ty.clone(), field.span, \"AssertParamIsEq\");"}, {"sha": "e4f939c151f3ef1564b3e35de6ca619fc04a54de", "filename": "src/libsyntax_ext/deriving/cmp/ord.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -1,6 +1,6 @@\n-use deriving::path_std;\n-use deriving::generic::*;\n-use deriving::generic::ty::*;\n+use crate::deriving::path_std;\n+use crate::deriving::generic::*;\n+use crate::deriving::generic::ty::*;\n \n use syntax::ast::{self, Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n@@ -9,7 +9,7 @@ use syntax::ptr::P;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n-pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n+pub fn expand_deriving_ord(cx: &mut ExtCtxt<'_>,\n                            span: Span,\n                            mitem: &MetaItem,\n                            item: &Annotatable,\n@@ -44,7 +44,7 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n }\n \n \n-pub fn ordering_collapsed(cx: &mut ExtCtxt,\n+pub fn ordering_collapsed(cx: &mut ExtCtxt<'_>,\n                           span: Span,\n                           self_arg_tags: &[ast::Ident])\n                           -> P<ast::Expr> {\n@@ -53,7 +53,7 @@ pub fn ordering_collapsed(cx: &mut ExtCtxt,\n     cx.expr_method_call(span, lft, cx.ident_of(\"cmp\"), vec![rgt])\n }\n \n-pub fn cs_cmp(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n+pub fn cs_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<Expr> {\n     let test_id = cx.ident_of(\"cmp\").gensym();\n     let equals_path = cx.path_global(span, cx.std_path(&[\"cmp\", \"Ordering\", \"Equal\"]));\n "}, {"sha": "07026ae37391997aa3f723f59830904194a22bf4", "filename": "src/libsyntax_ext/deriving/cmp/partial_eq.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -1,6 +1,6 @@\n-use deriving::{path_local, path_std};\n-use deriving::generic::*;\n-use deriving::generic::ty::*;\n+use crate::deriving::{path_local, path_std};\n+use crate::deriving::generic::*;\n+use crate::deriving::generic::ty::*;\n \n use syntax::ast::{BinOpKind, Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n@@ -9,22 +9,22 @@ use syntax::ptr::P;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n-pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt,\n+pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt<'_>,\n                                   span: Span,\n                                   mitem: &MetaItem,\n                                   item: &Annotatable,\n                                   push: &mut dyn FnMut(Annotatable)) {\n     // structures are equal if all fields are equal, and non equal, if\n     // any fields are not equal or if the enum variants are different\n-    fn cs_op(cx: &mut ExtCtxt,\n+    fn cs_op(cx: &mut ExtCtxt<'_>,\n              span: Span,\n-             substr: &Substructure,\n+             substr: &Substructure<'_>,\n              op: BinOpKind,\n              combiner: BinOpKind,\n              base: bool)\n              -> P<Expr>\n     {\n-        let op = |cx: &mut ExtCtxt, span: Span, self_f: P<Expr>, other_fs: &[P<Expr>]| {\n+        let op = |cx: &mut ExtCtxt<'_>, span: Span, self_f: P<Expr>, other_fs: &[P<Expr>]| {\n             let other_f = match (other_fs.len(), other_fs.get(0)) {\n                 (1, Some(o_f)) => o_f,\n                 _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialEq)`\"),\n@@ -53,10 +53,10 @@ pub fn expand_deriving_partial_eq(cx: &mut ExtCtxt,\n             substr)\n     }\n \n-    fn cs_eq(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n+    fn cs_eq(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<Expr> {\n         cs_op(cx, span, substr, BinOpKind::Eq, BinOpKind::And, true)\n     }\n-    fn cs_ne(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n+    fn cs_ne(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<Expr> {\n         cs_op(cx, span, substr, BinOpKind::Ne, BinOpKind::Or, false)\n     }\n "}, {"sha": "e99abeb118ea2f116194edf46a96efcc95f4d196", "filename": "src/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -1,8 +1,8 @@\n-pub use self::OrderingOp::*;\n+pub use OrderingOp::*;\n \n-use deriving::{path_local, pathvec_std, path_std};\n-use deriving::generic::*;\n-use deriving::generic::ty::*;\n+use crate::deriving::{path_local, pathvec_std, path_std};\n+use crate::deriving::generic::*;\n+use crate::deriving::generic::ty::*;\n \n use syntax::ast::{self, BinOpKind, Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n@@ -11,7 +11,7 @@ use syntax::ptr::P;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n-pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt,\n+pub fn expand_deriving_partial_ord(cx: &mut ExtCtxt<'_>,\n                                    span: Span,\n                                    mitem: &MetaItem,\n                                    item: &Annotatable,\n@@ -95,7 +95,7 @@ pub enum OrderingOp {\n     GeOp,\n }\n \n-pub fn some_ordering_collapsed(cx: &mut ExtCtxt,\n+pub fn some_ordering_collapsed(cx: &mut ExtCtxt<'_>,\n                                span: Span,\n                                op: OrderingOp,\n                                self_arg_tags: &[ast::Ident])\n@@ -112,7 +112,7 @@ pub fn some_ordering_collapsed(cx: &mut ExtCtxt,\n     cx.expr_method_call(span, lft, cx.ident_of(op_str), vec![rgt])\n }\n \n-pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n+pub fn cs_partial_cmp(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<Expr> {\n     let test_id = cx.ident_of(\"cmp\").gensym();\n     let ordering = cx.path_global(span, cx.std_path(&[\"cmp\", \"Ordering\", \"Equal\"]));\n     let ordering_expr = cx.expr_path(ordering.clone());\n@@ -184,14 +184,14 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<\n /// Strict inequality.\n fn cs_op(less: bool,\n          inclusive: bool,\n-         cx: &mut ExtCtxt,\n+         cx: &mut ExtCtxt<'_>,\n          span: Span,\n-         substr: &Substructure) -> P<Expr> {\n-    let ordering_path = |cx: &mut ExtCtxt, name: &str| {\n+         substr: &Substructure<'_>) -> P<Expr> {\n+    let ordering_path = |cx: &mut ExtCtxt<'_>, name: &str| {\n         cx.expr_path(cx.path_global(span, cx.std_path(&[\"cmp\", \"Ordering\", name])))\n     };\n \n-    let par_cmp = |cx: &mut ExtCtxt, span, self_f: P<Expr>, other_fs: &[P<Expr>], default| {\n+    let par_cmp = |cx: &mut ExtCtxt<'_>, span, self_f: P<Expr>, other_fs: &[P<Expr>], default| {\n         let other_f = match (other_fs.len(), other_fs.get(0)) {\n             (1, Some(o_f)) => o_f,\n             _ => cx.span_bug(span, \"not exactly 2 arguments in `derive(PartialOrd)`\"),"}, {"sha": "7d9b8402cac3fc4a24161cf4aee17b3b0589a464", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -1,4 +1,7 @@\n-use errors::FatalError;\n+use crate::errors::FatalError;\n+use crate::proc_macro_impl::EXEC_STRATEGY;\n+use crate::proc_macro_server;\n+\n use syntax::ast::{self, ItemKind, Attribute, Mac};\n use syntax::attr::{mark_used, mark_known};\n use syntax::source_map::Span;\n@@ -9,8 +12,6 @@ use syntax::tokenstream;\n use syntax::visit::Visitor;\n use syntax_pos::DUMMY_SP;\n \n-use proc_macro_impl::EXEC_STRATEGY;\n-\n struct MarkAttrs<'a>(&'a [ast::Name]);\n \n impl<'a> Visitor<'a> for MarkAttrs<'a> {\n@@ -25,15 +26,15 @@ impl<'a> Visitor<'a> for MarkAttrs<'a> {\n }\n \n pub struct ProcMacroDerive {\n-    pub client: ::proc_macro::bridge::client::Client<\n-        fn(::proc_macro::TokenStream) -> ::proc_macro::TokenStream,\n+    pub client: proc_macro::bridge::client::Client<\n+        fn(proc_macro::TokenStream) -> proc_macro::TokenStream,\n     >,\n     pub attrs: Vec<ast::Name>,\n }\n \n impl MultiItemModifier for ProcMacroDerive {\n     fn expand(&self,\n-              ecx: &mut ExtCtxt,\n+              ecx: &mut ExtCtxt<'_>,\n               span: Span,\n               _meta_item: &ast::MetaItem,\n               item: Annotatable)\n@@ -67,7 +68,7 @@ impl MultiItemModifier for ProcMacroDerive {\n         let token = Token::interpolated(token::NtItem(item));\n         let input = tokenstream::TokenTree::Token(DUMMY_SP, token).into();\n \n-        let server = ::proc_macro_server::Rustc::new(ecx);\n+        let server = proc_macro_server::Rustc::new(ecx);\n         let stream = match self.client.run(&EXEC_STRATEGY, server, input) {\n             Ok(stream) => stream,\n             Err(e) => {"}, {"sha": "7dc2d007d73d6b86835075ae38af8c96336cf294", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -1,6 +1,6 @@\n-use deriving::path_std;\n-use deriving::generic::*;\n-use deriving::generic::ty::*;\n+use crate::deriving::path_std;\n+use crate::deriving::generic::*;\n+use crate::deriving::generic::ty::*;\n \n use rustc_data_structures::thin_vec::ThinVec;\n \n@@ -11,7 +11,7 @@ use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n use syntax_pos::{DUMMY_SP, Span};\n \n-pub fn expand_deriving_debug(cx: &mut ExtCtxt,\n+pub fn expand_deriving_debug(cx: &mut ExtCtxt<'_>,\n                              span: Span,\n                              mitem: &MetaItem,\n                              item: &Annotatable,\n@@ -47,7 +47,7 @@ pub fn expand_deriving_debug(cx: &mut ExtCtxt,\n }\n \n /// We use the debug builders to do the heavy lifting here\n-fn show_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n+fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>) -> P<Expr> {\n     // build fmt.debug_struct(<name>).field(<fieldname>, &<fieldval>)....build()\n     // or fmt.debug_tuple(<name>).field(&<fieldval>)....build()\n     // based on the \"shape\".\n@@ -124,7 +124,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<E\n     cx.expr_block(block)\n }\n \n-fn stmt_let_undescore(cx: &mut ExtCtxt, sp: Span, expr: P<ast::Expr>) -> ast::Stmt {\n+fn stmt_let_undescore(cx: &mut ExtCtxt<'_>, sp: Span, expr: P<ast::Expr>) -> ast::Stmt {\n     let local = P(ast::Local {\n         pat: cx.pat_wild(sp),\n         ty: None,"}, {"sha": "b082351d5f68411f1bd0a45fbeb026c3104061eb", "filename": "src/libsyntax_ext/deriving/decodable.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -1,9 +1,9 @@\n //! The compiler code necessary for `#[derive(Decodable)]`. See encodable.rs for more.\n \n-use deriving::{self, pathvec_std};\n-use deriving::generic::*;\n-use deriving::generic::ty::*;\n-use deriving::warn_if_deprecated;\n+use crate::deriving::{self, pathvec_std};\n+use crate::deriving::generic::*;\n+use crate::deriving::generic::ty::*;\n+use crate::deriving::warn_if_deprecated;\n \n use syntax::ast;\n use syntax::ast::{Expr, MetaItem, Mutability};\n@@ -13,15 +13,15 @@ use syntax::ptr::P;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n-pub fn expand_deriving_rustc_decodable(cx: &mut ExtCtxt,\n+pub fn expand_deriving_rustc_decodable(cx: &mut ExtCtxt<'_>,\n                                        span: Span,\n                                        mitem: &MetaItem,\n                                        item: &Annotatable,\n                                        push: &mut dyn FnMut(Annotatable)) {\n     expand_deriving_decodable_imp(cx, span, mitem, item, push, \"rustc_serialize\")\n }\n \n-pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n+pub fn expand_deriving_decodable(cx: &mut ExtCtxt<'_>,\n                                  span: Span,\n                                  mitem: &MetaItem,\n                                  item: &Annotatable,\n@@ -30,7 +30,7 @@ pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n     expand_deriving_decodable_imp(cx, span, mitem, item, push, \"serialize\")\n }\n \n-fn expand_deriving_decodable_imp(cx: &mut ExtCtxt,\n+fn expand_deriving_decodable_imp(cx: &mut ExtCtxt<'_>,\n                                  span: Span,\n                                  mitem: &MetaItem,\n                                  item: &Annotatable,\n@@ -79,9 +79,9 @@ fn expand_deriving_decodable_imp(cx: &mut ExtCtxt,\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-fn decodable_substructure(cx: &mut ExtCtxt,\n+fn decodable_substructure(cx: &mut ExtCtxt<'_>,\n                           trait_span: Span,\n-                          substr: &Substructure,\n+                          substr: &Substructure<'_>,\n                           krate: &str)\n                           -> P<Expr> {\n     let decoder = substr.nonself_args[0].clone();\n@@ -168,13 +168,13 @@ fn decodable_substructure(cx: &mut ExtCtxt,\n /// Create a decoder for a single enum variant/struct:\n /// - `outer_pat_path` is the path to this enum variant/struct\n /// - `getarg` should retrieve the `usize`-th field with name `@str`.\n-fn decode_static_fields<F>(cx: &mut ExtCtxt,\n+fn decode_static_fields<F>(cx: &mut ExtCtxt<'_>,\n                            trait_span: Span,\n                            outer_pat_path: ast::Path,\n                            fields: &StaticFields,\n                            mut getarg: F)\n                            -> P<Expr>\n-    where F: FnMut(&mut ExtCtxt, Span, Symbol, usize) -> P<Expr>\n+    where F: FnMut(&mut ExtCtxt<'_>, Span, Symbol, usize) -> P<Expr>\n {\n     match *fields {\n         Unnamed(ref fields, is_tuple) => {"}, {"sha": "6db0a29165a4a05e24e082fc2e71b42bd4de56a9", "filename": "src/libsyntax_ext/deriving/default.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdefault.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -1,15 +1,16 @@\n-use deriving::path_std;\n-use deriving::generic::*;\n-use deriving::generic::ty::*;\n+use crate::deriving::path_std;\n+use crate::deriving::generic::*;\n+use crate::deriving::generic::ty::*;\n \n use syntax::ast::{Expr, MetaItem};\n use syntax::ext::base::{Annotatable, DummyResult, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n use syntax::symbol::Symbol;\n+use syntax::span_err;\n use syntax_pos::Span;\n \n-pub fn expand_deriving_default(cx: &mut ExtCtxt,\n+pub fn expand_deriving_default(cx: &mut ExtCtxt<'_>,\n                                span: Span,\n                                mitem: &MetaItem,\n                                item: &Annotatable,\n@@ -42,7 +43,10 @@ pub fn expand_deriving_default(cx: &mut ExtCtxt,\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-fn default_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> P<Expr> {\n+fn default_substructure(cx: &mut ExtCtxt<'_>,\n+                        trait_span: Span,\n+                        substr: &Substructure<'_>)\n+                        -> P<Expr> {\n     let default_ident = cx.std_path(&[\"default\", \"Default\", \"default\"]);\n     let default_call = |span| cx.expr_call_global(span, default_ident.clone(), Vec::new());\n "}, {"sha": "dd5646342b362efda30f758539884efe785c13a5", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -82,10 +82,10 @@\n //! }\n //! ```\n \n-use deriving::{self, pathvec_std};\n-use deriving::generic::*;\n-use deriving::generic::ty::*;\n-use deriving::warn_if_deprecated;\n+use crate::deriving::{self, pathvec_std};\n+use crate::deriving::generic::*;\n+use crate::deriving::generic::ty::*;\n+use crate::deriving::warn_if_deprecated;\n \n use syntax::ast::{Expr, ExprKind, MetaItem, Mutability};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n@@ -94,15 +94,15 @@ use syntax::ptr::P;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n-pub fn expand_deriving_rustc_encodable(cx: &mut ExtCtxt,\n+pub fn expand_deriving_rustc_encodable(cx: &mut ExtCtxt<'_>,\n                                        span: Span,\n                                        mitem: &MetaItem,\n                                        item: &Annotatable,\n                                        push: &mut dyn FnMut(Annotatable)) {\n     expand_deriving_encodable_imp(cx, span, mitem, item, push, \"rustc_serialize\")\n }\n \n-pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n+pub fn expand_deriving_encodable(cx: &mut ExtCtxt<'_>,\n                                  span: Span,\n                                  mitem: &MetaItem,\n                                  item: &Annotatable,\n@@ -111,7 +111,7 @@ pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n     expand_deriving_encodable_imp(cx, span, mitem, item, push, \"serialize\")\n }\n \n-fn expand_deriving_encodable_imp(cx: &mut ExtCtxt,\n+fn expand_deriving_encodable_imp(cx: &mut ExtCtxt<'_>,\n                                  span: Span,\n                                  mitem: &MetaItem,\n                                  item: &Annotatable,\n@@ -162,9 +162,9 @@ fn expand_deriving_encodable_imp(cx: &mut ExtCtxt,\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-fn encodable_substructure(cx: &mut ExtCtxt,\n+fn encodable_substructure(cx: &mut ExtCtxt<'_>,\n                           trait_span: Span,\n-                          substr: &Substructure,\n+                          substr: &Substructure<'_>,\n                           krate: &'static str)\n                           -> P<Expr> {\n     let encoder = substr.nonself_args[0].clone();"}, {"sha": "0c88ae0311d522aecdaddcce5042c46fc136c136", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -174,8 +174,8 @@\n //!                 (<ident of C1>, <span of C1>, Named(vec![(<ident of x>, <span of x>)]))])\n //! ```\n \n-pub use self::StaticFields::*;\n-pub use self::SubstructureFields::*;\n+pub use StaticFields::*;\n+pub use SubstructureFields::*;\n \n use std::cell::RefCell;\n use std::iter;\n@@ -195,9 +195,9 @@ use syntax::symbol::{Symbol, keywords};\n use syntax::parse::ParseSess;\n use syntax_pos::{DUMMY_SP, Span};\n \n-use self::ty::{LifetimeBounds, Path, Ptr, PtrTy, Self_, Ty};\n+use ty::{LifetimeBounds, Path, Ptr, PtrTy, Self_, Ty};\n \n-use deriving;\n+use crate::deriving;\n \n pub mod ty;\n \n@@ -321,15 +321,15 @@ pub enum SubstructureFields<'a> {\n /// Combine the values of all the fields together. The last argument is\n /// all the fields of all the structures.\n pub type CombineSubstructureFunc<'a> =\n-    Box<dyn FnMut(&mut ExtCtxt, Span, &Substructure) -> P<Expr> + 'a>;\n+    Box<dyn FnMut(&mut ExtCtxt<'_>, Span, &Substructure<'_>) -> P<Expr> + 'a>;\n \n /// Deal with non-matching enum variants.  The tuple is a list of\n /// identifiers (one for each `Self` argument, which could be any of the\n /// variants since they have been collapsed together) and the identifiers\n /// holding the variant index value for each of the `Self` arguments.  The\n /// last argument is all the non-`Self` args of the method being derived.\n pub type EnumNonMatchCollapsedFunc<'a> =\n-    Box<dyn FnMut(&mut ExtCtxt, Span, (&[Ident], &[Ident]), &[P<Expr>]) -> P<Expr> + 'a>;\n+    Box<dyn FnMut(&mut ExtCtxt<'_>, Span, (&[Ident], &[Ident]), &[P<Expr>]) -> P<Expr> + 'a>;\n \n pub fn combine_substructure<'a>(f: CombineSubstructureFunc<'a>)\n                                 -> RefCell<CombineSubstructureFunc<'a>> {\n@@ -342,7 +342,7 @@ pub fn combine_substructure<'a>(f: CombineSubstructureFunc<'a>)\n fn find_type_parameters(ty: &ast::Ty,\n                         ty_param_names: &[ast::Name],\n                         span: Span,\n-                        cx: &ExtCtxt)\n+                        cx: &ExtCtxt<'_>)\n                         -> Vec<P<ast::Ty>> {\n     use syntax::visit;\n \n@@ -386,15 +386,15 @@ fn find_type_parameters(ty: &ast::Ty,\n \n impl<'a> TraitDef<'a> {\n     pub fn expand(self,\n-                  cx: &mut ExtCtxt,\n+                  cx: &mut ExtCtxt<'_>,\n                   mitem: &ast::MetaItem,\n                   item: &'a Annotatable,\n                   push: &mut dyn FnMut(Annotatable)) {\n         self.expand_ext(cx, mitem, item, push, false);\n     }\n \n     pub fn expand_ext(self,\n-                      cx: &mut ExtCtxt,\n+                      cx: &mut ExtCtxt<'_>,\n                       mitem: &ast::MetaItem,\n                       item: &'a Annotatable,\n                       push: &mut dyn FnMut(Annotatable),\n@@ -513,7 +513,7 @@ impl<'a> TraitDef<'a> {\n     /// where B1, ..., BN are the bounds given by `bounds_paths`.'. Z is a phantom type, and\n     /// therefore does not get bound by the derived trait.\n     fn create_derived_impl(&self,\n-                           cx: &mut ExtCtxt,\n+                           cx: &mut ExtCtxt<'_>,\n                            type_ident: Ident,\n                            generics: &Generics,\n                            field_tys: Vec<P<ast::Ty>>,\n@@ -696,7 +696,7 @@ impl<'a> TraitDef<'a> {\n     }\n \n     fn expand_struct_def(&self,\n-                         cx: &mut ExtCtxt,\n+                         cx: &mut ExtCtxt<'_>,\n                          struct_def: &'a VariantData,\n                          type_ident: Ident,\n                          generics: &Generics,\n@@ -746,7 +746,7 @@ impl<'a> TraitDef<'a> {\n     }\n \n     fn expand_enum_def(&self,\n-                       cx: &mut ExtCtxt,\n+                       cx: &mut ExtCtxt<'_>,\n                        enum_def: &'a EnumDef,\n                        type_attrs: &[ast::Attribute],\n                        type_ident: Ident,\n@@ -832,12 +832,12 @@ fn find_repr_type_name(sess: &ParseSess, type_attrs: &[ast::Attribute]) -> &'sta\n \n impl<'a> MethodDef<'a> {\n     fn call_substructure_method(&self,\n-                                cx: &mut ExtCtxt,\n-                                trait_: &TraitDef,\n+                                cx: &mut ExtCtxt<'_>,\n+                                trait_: &TraitDef<'_>,\n                                 type_ident: Ident,\n                                 self_args: &[P<Expr>],\n                                 nonself_args: &[P<Expr>],\n-                                fields: &SubstructureFields)\n+                                fields: &SubstructureFields<'_>)\n                                 -> P<Expr> {\n         let substructure = Substructure {\n             type_ident,\n@@ -847,13 +847,13 @@ impl<'a> MethodDef<'a> {\n             fields,\n         };\n         let mut f = self.combine_substructure.borrow_mut();\n-        let f: &mut CombineSubstructureFunc = &mut *f;\n+        let f: &mut CombineSubstructureFunc<'_> = &mut *f;\n         f(cx, trait_.span, &substructure)\n     }\n \n     fn get_ret_ty(&self,\n-                  cx: &mut ExtCtxt,\n-                  trait_: &TraitDef,\n+                  cx: &mut ExtCtxt<'_>,\n+                  trait_: &TraitDef<'_>,\n                   generics: &Generics,\n                   type_ident: Ident)\n                   -> P<ast::Ty> {\n@@ -866,8 +866,8 @@ impl<'a> MethodDef<'a> {\n \n     fn split_self_nonself_args\n         (&self,\n-         cx: &mut ExtCtxt,\n-         trait_: &TraitDef,\n+         cx: &mut ExtCtxt<'_>,\n+         trait_: &TraitDef<'_>,\n          type_ident: Ident,\n          generics: &Generics)\n          -> (Option<ast::ExplicitSelf>, Vec<P<Expr>>, Vec<P<Expr>>, Vec<(Ident, P<ast::Ty>)>) {\n@@ -912,8 +912,8 @@ impl<'a> MethodDef<'a> {\n     }\n \n     fn create_method(&self,\n-                     cx: &mut ExtCtxt,\n-                     trait_: &TraitDef,\n+                     cx: &mut ExtCtxt<'_>,\n+                     trait_: &TraitDef<'_>,\n                      type_ident: Ident,\n                      generics: &Generics,\n                      abi: Abi,\n@@ -1005,7 +1005,7 @@ impl<'a> MethodDef<'a> {\n     /// }\n     /// ```\n     fn expand_struct_method_body<'b>(&self,\n-                                     cx: &mut ExtCtxt,\n+                                     cx: &mut ExtCtxt<'_>,\n                                      trait_: &TraitDef<'b>,\n                                      struct_def: &'b VariantData,\n                                      type_ident: Ident,\n@@ -1077,8 +1077,8 @@ impl<'a> MethodDef<'a> {\n     }\n \n     fn expand_static_struct_method_body(&self,\n-                                        cx: &mut ExtCtxt,\n-                                        trait_: &TraitDef,\n+                                        cx: &mut ExtCtxt<'_>,\n+                                        trait_: &TraitDef<'_>,\n                                         struct_def: &VariantData,\n                                         type_ident: Ident,\n                                         self_args: &[P<Expr>],\n@@ -1125,7 +1125,7 @@ impl<'a> MethodDef<'a> {\n     /// as their results are unused.  The point of `__self_vi` and\n     /// `__arg_1_vi` is for `PartialOrd`; see #15503.)\n     fn expand_enum_method_body<'b>(&self,\n-                                   cx: &mut ExtCtxt,\n+                                   cx: &mut ExtCtxt<'_>,\n                                    trait_: &TraitDef<'b>,\n                                    enum_def: &'b EnumDef,\n                                    type_attrs: &[ast::Attribute],\n@@ -1179,7 +1179,7 @@ impl<'a> MethodDef<'a> {\n     /// }\n     /// ```\n     fn build_enum_match_tuple<'b>(&self,\n-                                  cx: &mut ExtCtxt,\n+                                  cx: &mut ExtCtxt<'_>,\n                                   trait_: &TraitDef<'b>,\n                                   enum_def: &'b EnumDef,\n                                   type_attrs: &[ast::Attribute],\n@@ -1230,7 +1230,7 @@ impl<'a> MethodDef<'a> {\n             .enumerate()\n             .filter(|&(_, v)| !(self.unify_fieldless_variants && v.node.data.fields().is_empty()))\n             .map(|(index, variant)| {\n-                let mk_self_pat = |cx: &mut ExtCtxt, self_arg_name: &str| {\n+                let mk_self_pat = |cx: &mut ExtCtxt<'_>, self_arg_name: &str| {\n                     let (p, idents) = trait_.create_enum_variant_pattern(cx,\n                                                      type_ident,\n                                                      variant,\n@@ -1296,7 +1296,7 @@ impl<'a> MethodDef<'a> {\n                                     other: others,\n                                     attrs,\n                         }\n-                    }).collect::<Vec<FieldInfo>>();\n+                    }).collect::<Vec<FieldInfo<'_>>>();\n \n                 // Now, for some given VariantK, we have built up\n                 // expressions for referencing every field of every\n@@ -1501,8 +1501,8 @@ impl<'a> MethodDef<'a> {\n     }\n \n     fn expand_static_enum_method_body(&self,\n-                                      cx: &mut ExtCtxt,\n-                                      trait_: &TraitDef,\n+                                      cx: &mut ExtCtxt<'_>,\n+                                      trait_: &TraitDef<'_>,\n                                       enum_def: &EnumDef,\n                                       type_ident: Ident,\n                                       self_args: &[P<Expr>],\n@@ -1527,7 +1527,7 @@ impl<'a> MethodDef<'a> {\n \n // general helper methods.\n impl<'a> TraitDef<'a> {\n-    fn summarise_struct(&self, cx: &mut ExtCtxt, struct_def: &VariantData) -> StaticFields {\n+    fn summarise_struct(&self, cx: &mut ExtCtxt<'_>, struct_def: &VariantData) -> StaticFields {\n         let mut named_idents = Vec::new();\n         let mut just_spans = Vec::new();\n         for field in struct_def.fields() {\n@@ -1553,7 +1553,7 @@ impl<'a> TraitDef<'a> {\n     }\n \n     fn create_subpatterns(&self,\n-                          cx: &mut ExtCtxt,\n+                          cx: &mut ExtCtxt<'_>,\n                           field_paths: Vec<ast::Ident>,\n                           mutbl: ast::Mutability,\n                           use_temporaries: bool)\n@@ -1573,7 +1573,7 @@ impl<'a> TraitDef<'a> {\n \n     fn create_struct_pattern\n         (&self,\n-         cx: &mut ExtCtxt,\n+         cx: &mut ExtCtxt<'_>,\n          struct_path: ast::Path,\n          struct_def: &'a VariantData,\n          prefix: &str,\n@@ -1633,7 +1633,7 @@ impl<'a> TraitDef<'a> {\n \n     fn create_enum_variant_pattern\n         (&self,\n-         cx: &mut ExtCtxt,\n+         cx: &mut ExtCtxt<'_>,\n          enum_ident: ast::Ident,\n          variant: &'a ast::Variant,\n          prefix: &str,\n@@ -1652,10 +1652,10 @@ impl<'a> TraitDef<'a> {\n pub fn cs_fold_fields<'a, F>(use_foldl: bool,\n                              mut f: F,\n                              base: P<Expr>,\n-                             cx: &mut ExtCtxt,\n+                             cx: &mut ExtCtxt<'_>,\n                              all_fields: &[FieldInfo<'a>])\n                              -> P<Expr>\n-    where F: FnMut(&mut ExtCtxt, Span, P<Expr>, P<Expr>, &[P<Expr>]) -> P<Expr>\n+    where F: FnMut(&mut ExtCtxt<'_>, Span, P<Expr>, P<Expr>, &[P<Expr>]) -> P<Expr>\n {\n     if use_foldl {\n         all_fields.iter().fold(base, |old, field| {\n@@ -1668,10 +1668,10 @@ pub fn cs_fold_fields<'a, F>(use_foldl: bool,\n     }\n }\n \n-pub fn cs_fold_enumnonmatch(mut enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n-                            cx: &mut ExtCtxt,\n+pub fn cs_fold_enumnonmatch(mut enum_nonmatch_f: EnumNonMatchCollapsedFunc<'_>,\n+                            cx: &mut ExtCtxt<'_>,\n                             trait_span: Span,\n-                            substructure: &Substructure)\n+                            substructure: &Substructure<'_>)\n                             -> P<Expr>\n {\n     match *substructure.fields {\n@@ -1685,7 +1685,7 @@ pub fn cs_fold_enumnonmatch(mut enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n     }\n }\n \n-pub fn cs_fold_static(cx: &mut ExtCtxt,\n+pub fn cs_fold_static(cx: &mut ExtCtxt<'_>,\n                       trait_span: Span)\n                       -> P<Expr>\n {\n@@ -1697,12 +1697,12 @@ pub fn cs_fold_static(cx: &mut ExtCtxt,\n pub fn cs_fold<F>(use_foldl: bool,\n                   f: F,\n                   base: P<Expr>,\n-                  enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n-                  cx: &mut ExtCtxt,\n+                  enum_nonmatch_f: EnumNonMatchCollapsedFunc<'_>,\n+                  cx: &mut ExtCtxt<'_>,\n                   trait_span: Span,\n-                  substructure: &Substructure)\n+                  substructure: &Substructure<'_>)\n                   -> P<Expr>\n-    where F: FnMut(&mut ExtCtxt, Span, P<Expr>, P<Expr>, &[P<Expr>]) -> P<Expr>\n+    where F: FnMut(&mut ExtCtxt<'_>, Span, P<Expr>, P<Expr>, &[P<Expr>]) -> P<Expr>\n {\n     match *substructure.fields {\n         EnumMatching(.., ref all_fields) |\n@@ -1730,13 +1730,13 @@ pub fn cs_fold<F>(use_foldl: bool,\n pub fn cs_fold1<F, B>(use_foldl: bool,\n                       f: F,\n                       mut b: B,\n-                      enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n-                      cx: &mut ExtCtxt,\n+                      enum_nonmatch_f: EnumNonMatchCollapsedFunc<'_>,\n+                      cx: &mut ExtCtxt<'_>,\n                       trait_span: Span,\n-                      substructure: &Substructure)\n+                      substructure: &Substructure<'_>)\n                       -> P<Expr>\n-    where F: FnMut(&mut ExtCtxt, Span, P<Expr>, P<Expr>, &[P<Expr>]) -> P<Expr>,\n-          B: FnMut(&mut ExtCtxt, Option<(Span, P<Expr>, &[P<Expr>])>) -> P<Expr>\n+    where F: FnMut(&mut ExtCtxt<'_>, Span, P<Expr>, P<Expr>, &[P<Expr>]) -> P<Expr>,\n+          B: FnMut(&mut ExtCtxt<'_>, Option<(Span, P<Expr>, &[P<Expr>])>) -> P<Expr>\n {\n     match *substructure.fields {\n         EnumMatching(.., ref all_fields) |\n@@ -1776,12 +1776,12 @@ pub fn cs_fold1<F, B>(use_foldl: bool,\n /// ```\n #[inline]\n pub fn cs_same_method<F>(f: F,\n-                         mut enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n-                         cx: &mut ExtCtxt,\n+                         mut enum_nonmatch_f: EnumNonMatchCollapsedFunc<'_>,\n+                         cx: &mut ExtCtxt<'_>,\n                          trait_span: Span,\n-                         substructure: &Substructure)\n+                         substructure: &Substructure<'_>)\n                          -> P<Expr>\n-    where F: FnOnce(&mut ExtCtxt, Span, Vec<P<Expr>>) -> P<Expr>\n+    where F: FnOnce(&mut ExtCtxt<'_>, Span, Vec<P<Expr>>) -> P<Expr>\n {\n     match *substructure.fields {\n         EnumMatching(.., ref all_fields) |"}, {"sha": "ea6e07922b2b375396b07753b60d1c10d7c5fd3e", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -1,11 +1,10 @@\n //! A mini version of ast::Ty, which is easier to use, and features an explicit `Self` type to use\n //! when specifying impls to be derived.\n \n-pub use self::PtrTy::*;\n-pub use self::Ty::*;\n+pub use PtrTy::*;\n+pub use Ty::*;\n \n-use syntax::ast;\n-use syntax::ast::{Expr, GenericParamKind, Generics, Ident, SelfKind, GenericArg};\n+use syntax::ast::{self, Expr, GenericParamKind, Generics, Ident, SelfKind, GenericArg};\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n use syntax::source_map::{respan, DUMMY_SP};\n@@ -60,15 +59,15 @@ impl<'a> Path<'a> {\n     }\n \n     pub fn to_ty(&self,\n-                 cx: &ExtCtxt,\n+                 cx: &ExtCtxt<'_>,\n                  span: Span,\n                  self_ty: Ident,\n                  self_generics: &Generics)\n                  -> P<ast::Ty> {\n         cx.ty_path(self.to_path(cx, span, self_ty, self_generics))\n     }\n     pub fn to_path(&self,\n-                   cx: &ExtCtxt,\n+                   cx: &ExtCtxt<'_>,\n                    span: Span,\n                    self_ty: Ident,\n                    self_generics: &Generics)\n@@ -127,19 +126,19 @@ pub fn nil_ty<'r>() -> Ty<'r> {\n     Tuple(Vec::new())\n }\n \n-fn mk_lifetime(cx: &ExtCtxt, span: Span, lt: &Option<&str>) -> Option<ast::Lifetime> {\n+fn mk_lifetime(cx: &ExtCtxt<'_>, span: Span, lt: &Option<&str>) -> Option<ast::Lifetime> {\n     lt.map(|s|\n         cx.lifetime(span, Ident::from_str(s))\n     )\n }\n \n-fn mk_lifetimes(cx: &ExtCtxt, span: Span, lt: &Option<&str>) -> Vec<ast::Lifetime> {\n+fn mk_lifetimes(cx: &ExtCtxt<'_>, span: Span, lt: &Option<&str>) -> Vec<ast::Lifetime> {\n     mk_lifetime(cx, span, lt).into_iter().collect()\n }\n \n impl<'a> Ty<'a> {\n     pub fn to_ty(&self,\n-                 cx: &ExtCtxt,\n+                 cx: &ExtCtxt<'_>,\n                  span: Span,\n                  self_ty: Ident,\n                  self_generics: &Generics)\n@@ -167,7 +166,7 @@ impl<'a> Ty<'a> {\n     }\n \n     pub fn to_path(&self,\n-                   cx: &ExtCtxt,\n+                   cx: &ExtCtxt<'_>,\n                    span: Span,\n                    self_ty: Ident,\n                    generics: &Generics)\n@@ -193,11 +192,11 @@ impl<'a> Ty<'a> {\n }\n \n \n-fn mk_ty_param(cx: &ExtCtxt,\n+fn mk_ty_param(cx: &ExtCtxt<'_>,\n                span: Span,\n                name: &str,\n                attrs: &[ast::Attribute],\n-               bounds: &[Path],\n+               bounds: &[Path<'_>],\n                self_ident: Ident,\n                self_generics: &Generics)\n                -> ast::GenericParam {\n@@ -237,7 +236,7 @@ impl<'a> LifetimeBounds<'a> {\n         }\n     }\n     pub fn to_generics(&self,\n-                       cx: &ExtCtxt,\n+                       cx: &ExtCtxt<'_>,\n                        span: Span,\n                        self_ty: Ident,\n                        self_generics: &Generics)\n@@ -262,9 +261,9 @@ impl<'a> LifetimeBounds<'a> {\n     }\n }\n \n-pub fn get_explicit_self(cx: &ExtCtxt,\n+pub fn get_explicit_self(cx: &ExtCtxt<'_>,\n                          span: Span,\n-                         self_ptr: &Option<PtrTy>)\n+                         self_ptr: &Option<PtrTy<'_>>)\n                          -> (P<Expr>, ast::ExplicitSelf) {\n     // this constructs a fresh `self` path\n     let self_path = cx.expr_self(span);"}, {"sha": "0d4f2ddc3be7b02fd8267cd34d410297b1719ba7", "filename": "src/libsyntax_ext/deriving/hash.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fhash.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -1,14 +1,14 @@\n-use deriving::{self, pathvec_std, path_std};\n-use deriving::generic::*;\n-use deriving::generic::ty::*;\n+use crate::deriving::{self, pathvec_std, path_std};\n+use crate::deriving::generic::*;\n+use crate::deriving::generic::ty::*;\n \n use syntax::ast::{Expr, MetaItem, Mutability};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::ptr::P;\n use syntax_pos::Span;\n \n-pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n+pub fn expand_deriving_hash(cx: &mut ExtCtxt<'_>,\n                             span: Span,\n                             mitem: &MetaItem,\n                             item: &Annotatable,\n@@ -50,7 +50,7 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n     hash_trait_def.expand(cx, mitem, item, push);\n }\n \n-fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> P<Expr> {\n+fn hash_substructure(cx: &mut ExtCtxt<'_>, trait_span: Span, substr: &Substructure<'_>) -> P<Expr> {\n     let state_expr = match (substr.nonself_args.len(), substr.nonself_args.get(0)) {\n         (1, Some(o_f)) => o_f,\n         _ => {"}, {"sha": "2c8a996cdb0cb495e93039f3bc578869b8f784ab", "filename": "src/libsyntax_ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -90,7 +90,7 @@ derive_traits! {\n }\n \n #[inline] // because `name` is a compile-time constant\n-fn warn_if_deprecated(ecx: &mut ExtCtxt, sp: Span, name: &str) {\n+fn warn_if_deprecated(ecx: &mut ExtCtxt<'_>, sp: Span, name: &str) {\n     if let Some(replacement) = match name {\n         \"Encodable\" => Some(\"RustcEncodable\"),\n         \"Decodable\" => Some(\"RustcDecodable\"),\n@@ -131,7 +131,7 @@ fn hygienic_type_parameter(item: &Annotatable, base: &str) -> String {\n }\n \n /// Constructs an expression that calls an intrinsic\n-fn call_intrinsic(cx: &ExtCtxt,\n+fn call_intrinsic(cx: &ExtCtxt<'_>,\n                   mut span: Span,\n                   intrinsic: &str,\n                   args: Vec<P<ast::Expr>>)"}, {"sha": "9bbd9fdec17d69d8951703488ba5c228e2d37d0c", "filename": "src/libsyntax_ext/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fdiagnostics.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -1,5 +1,7 @@\n #![allow(non_snake_case)]\n \n+use syntax::{register_diagnostic, register_long_diagnostics};\n+\n // Error messages for EXXXX errors.\n // Each message should start and end with a new line, and be wrapped to 80 characters.\n // In vim you can `:set tw=80` and use `gq` to wrap paragraphs. Use `:set tw=0` to disable."}, {"sha": "ccff4aec2c8c77f0bf87af561dd475436a5c39df", "filename": "src/libsyntax_ext/env.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fenv.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -4,16 +4,15 @@\n //\n \n use syntax::ast::{self, Ident, GenericArg};\n-use syntax::ext::base::*;\n-use syntax::ext::base;\n+use syntax::ext::base::{self, *};\n use syntax::ext::build::AstBuilder;\n use syntax::symbol::{keywords, Symbol};\n use syntax_pos::Span;\n use syntax::tokenstream;\n \n use std::env;\n \n-pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt,\n+pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                               sp: Span,\n                               tts: &[tokenstream::TokenTree])\n                               -> Box<dyn base::MacResult + 'cx> {\n@@ -44,7 +43,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt,\n     MacEager::expr(e)\n }\n \n-pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt,\n+pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                        sp: Span,\n                        tts: &[tokenstream::TokenTree])\n                        -> Box<dyn base::MacResult + 'cx> {"}, {"sha": "6bb7ee1d5ddfd9b174ce8367448c0aa2f9301ed4", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -1,9 +1,11 @@\n-use self::ArgumentType::*;\n-use self::Position::*;\n+use ArgumentType::*;\n+use Position::*;\n \n use fmt_macros as parse;\n \n-use errors::DiagnosticBuilder;\n+use crate::errors::DiagnosticBuilder;\n+use crate::errors::Applicability;\n+\n use syntax::ast;\n use syntax::ext::base::{self, *};\n use syntax::ext::build::AstBuilder;\n@@ -13,7 +15,6 @@ use syntax::ptr::P;\n use syntax::symbol::Symbol;\n use syntax::tokenstream;\n use syntax_pos::{MultiSpan, Span, DUMMY_SP};\n-use errors::Applicability;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use std::borrow::Cow;\n@@ -184,7 +185,7 @@ fn parse_args<'a>(\n }\n \n impl<'a, 'b> Context<'a, 'b> {\n-    fn resolve_name_inplace(&self, p: &mut parse::Piece) {\n+    fn resolve_name_inplace(&self, p: &mut parse::Piece<'_>) {\n         // NOTE: the `unwrap_or` branch is needed in case of invalid format\n         // arguments, e.g., `format_args!(\"{foo}\")`.\n         let lookup = |s| *self.names.get(s).unwrap_or(&0);\n@@ -208,7 +209,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     /// Verifies one piece of a parse string, and remembers it if valid.\n     /// All errors are not emitted as fatal so we can continue giving errors\n     /// about this and possibly other format strings.\n-    fn verify_piece(&mut self, p: &parse::Piece) {\n+    fn verify_piece(&mut self, p: &parse::Piece<'_>) {\n         match *p {\n             parse::String(..) => {}\n             parse::NextArgument(ref arg) => {\n@@ -231,7 +232,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n     }\n \n-    fn verify_count(&mut self, c: parse::Count) {\n+    fn verify_count(&mut self, c: parse::Count<'_>) {\n         match c {\n             parse::CountImplied |\n             parse::CountIs(..) => {}\n@@ -244,7 +245,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n     }\n \n-    fn describe_num_args(&self) -> Cow<str> {\n+    fn describe_num_args(&self) -> Cow<'_, str> {\n         match self.args.len() {\n             0 => \"no arguments were given\".into(),\n             1 => \"there is 1 argument\".into(),\n@@ -385,11 +386,11 @@ impl<'a, 'b> Context<'a, 'b> {\n         self.count_args_index_offset = sofar;\n     }\n \n-    fn rtpath(ecx: &ExtCtxt, s: &str) -> Vec<ast::Ident> {\n+    fn rtpath(ecx: &ExtCtxt<'_>, s: &str) -> Vec<ast::Ident> {\n         ecx.std_path(&[\"fmt\", \"rt\", \"v1\", s])\n     }\n \n-    fn build_count(&self, c: parse::Count) -> P<ast::Expr> {\n+    fn build_count(&self, c: parse::Count<'_>) -> P<ast::Expr> {\n         let sp = self.macsp;\n         let count = |c, arg| {\n             let mut path = Context::rtpath(self.ecx, \"Count\");\n@@ -426,7 +427,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     /// Build a static `rt::Argument` from a `parse::Piece` or append\n     /// to the `literal` string.\n     fn build_piece(&mut self,\n-                   piece: &parse::Piece,\n+                   piece: &parse::Piece<'_>,\n                    arg_index_consumed: &mut Vec<usize>)\n                    -> Option<P<ast::Expr>> {\n         let sp = self.macsp;\n@@ -647,7 +648,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         self.ecx.expr_call_global(self.macsp, path, fn_args)\n     }\n \n-    fn format_arg(ecx: &ExtCtxt,\n+    fn format_arg(ecx: &ExtCtxt<'_>,\n                   macsp: Span,\n                   mut sp: Span,\n                   ty: &ArgumentType,\n@@ -686,7 +687,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     }\n }\n \n-pub fn expand_format_args<'cx>(ecx: &'cx mut ExtCtxt,\n+pub fn expand_format_args<'cx>(ecx: &'cx mut ExtCtxt<'_>,\n                                mut sp: Span,\n                                tts: &[tokenstream::TokenTree])\n                                -> Box<dyn base::MacResult + 'cx> {\n@@ -703,7 +704,7 @@ pub fn expand_format_args<'cx>(ecx: &'cx mut ExtCtxt,\n }\n \n pub fn expand_format_args_nl<'cx>(\n-    ecx: &'cx mut ExtCtxt,\n+    ecx: &'cx mut ExtCtxt<'_>,\n     mut sp: Span,\n     tts: &[tokenstream::TokenTree],\n ) -> Box<dyn base::MacResult + 'cx> {\n@@ -734,7 +735,7 @@ pub fn expand_format_args_nl<'cx>(\n \n /// Take the various parts of `format_args!(efmt, args..., name=names...)`\n /// and construct the appropriate formatting expression.\n-pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n+pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt<'_>,\n                                     sp: Span,\n                                     efmt: P<ast::Expr>,\n                                     args: Vec<P<ast::Expr>>,\n@@ -952,7 +953,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt,\n         piece\n     }).collect::<Vec<_>>();\n \n-    let numbered_position_args = pieces.iter().any(|arg: &parse::Piece| {\n+    let numbered_position_args = pieces.iter().any(|arg: &parse::Piece<'_>| {\n         match *arg {\n             parse::String(_) => false,\n             parse::NextArgument(arg) => {"}, {"sha": "381325b2963ef8a928f107dc818255c0efde3b06", "filename": "src/libsyntax_ext/format_foreign.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fformat_foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat_foreign.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -68,7 +68,7 @@ pub mod printf {\n         pub position: (usize, usize),\n     }\n \n-    impl<'a> Format<'a> {\n+    impl Format<'_> {\n         /// Translate this directive into an equivalent Rust formatting directive.\n         ///\n         /// Returns `None` in cases where the `printf` directive does not have an exact Rust\n@@ -249,12 +249,12 @@ pub mod printf {\n             }\n         }\n \n-        fn translate(&self, s: &mut String) -> ::std::fmt::Result {\n+        fn translate(&self, s: &mut String) -> std::fmt::Result {\n             use std::fmt::Write;\n             match *self {\n                 Num::Num(n) => write!(s, \"{}\", n),\n                 Num::Arg(n) => {\n-                    let n = n.checked_sub(1).ok_or(::std::fmt::Error)?;\n+                    let n = n.checked_sub(1).ok_or(std::fmt::Error)?;\n                     write!(s, \"{}$\", n)\n                 },\n                 Num::Next => write!(s, \"*\"),\n@@ -263,7 +263,7 @@ pub mod printf {\n     }\n \n     /// Returns an iterator over all substitutions in a given string.\n-    pub fn iter_subs(s: &str) -> Substitutions {\n+    pub fn iter_subs(s: &str) -> Substitutions<'_> {\n         Substitutions {\n             s,\n             pos: 0,\n@@ -309,7 +309,7 @@ pub mod printf {\n     }\n \n     /// Parse the next substitution from the input string.\n-    pub fn parse_next_substitution(s: &str) -> Option<(Substitution, &str)> {\n+    pub fn parse_next_substitution(s: &str) -> Option<(Substitution<'_>, &str)> {\n         use self::State::*;\n \n         let at = {\n@@ -389,7 +389,7 @@ pub mod printf {\n         let mut precision: Option<Num> = None;\n         let mut length: Option<&str> = None;\n         let mut type_: &str = \"\";\n-        let end: Cur;\n+        let end: Cur<'_>;\n \n         if let Start = state {\n             match c {\n@@ -575,7 +575,7 @@ pub mod printf {\n         Some((Substitution::Format(f), end.slice_after()))\n     }\n \n-    fn at_next_cp_while<F>(mut cur: Cur, mut pred: F) -> Cur\n+    fn at_next_cp_while<F>(mut cur: Cur<'_>, mut pred: F) -> Cur<'_>\n     where F: FnMut(char) -> bool {\n         loop {\n             match cur.next_cp() {\n@@ -769,7 +769,7 @@ pub mod shell {\n         Escape((usize, usize)),\n     }\n \n-    impl<'a> Substitution<'a> {\n+    impl Substitution<'_> {\n         pub fn as_str(&self) -> String {\n             match self {\n                 Substitution::Ordinal(n, _) => format!(\"${}\", n),\n@@ -804,7 +804,7 @@ pub mod shell {\n     }\n \n     /// Returns an iterator over all substitutions in a given string.\n-    pub fn iter_subs(s: &str) -> Substitutions {\n+    pub fn iter_subs(s: &str) -> Substitutions<'_> {\n         Substitutions {\n             s,\n             pos: 0,\n@@ -839,7 +839,7 @@ pub mod shell {\n     }\n \n     /// Parse the next substitution from the input string.\n-    pub fn parse_next_substitution(s: &str) -> Option<(Substitution, &str)> {\n+    pub fn parse_next_substitution(s: &str) -> Option<(Substitution<'_>, &str)> {\n         let at = {\n             let start = s.find('$')?;\n             match s[start+1..].chars().next()? {\n@@ -868,7 +868,7 @@ pub mod shell {\n         }\n     }\n \n-    fn at_next_cp_while<F>(mut cur: Cur, mut pred: F) -> Cur\n+    fn at_next_cp_while<F>(mut cur: Cur<'_>, mut pred: F) -> Cur<'_>\n     where F: FnMut(char) -> bool {\n         loop {\n             match cur.next_cp() {\n@@ -962,8 +962,6 @@ pub mod shell {\n }\n \n mod strcursor {\n-    use std;\n-\n     pub struct StrCursor<'a> {\n         s: &'a str,\n         pub at: usize,\n@@ -1028,16 +1026,16 @@ mod strcursor {\n         }\n     }\n \n-    impl<'a> Copy for StrCursor<'a> {}\n+    impl Copy for StrCursor<'_> {}\n \n     impl<'a> Clone for StrCursor<'a> {\n         fn clone(&self) -> StrCursor<'a> {\n             *self\n         }\n     }\n \n-    impl<'a> std::fmt::Debug for StrCursor<'a> {\n-        fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {\n+    impl std::fmt::Debug for StrCursor<'_> {\n+        fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n             write!(fmt, \"StrCursor({:?} | {:?})\", self.slice_before(), self.slice_after())\n         }\n     }"}, {"sha": "14dbd9300232bc2df40ecc98f6f9d3d5e7d060c4", "filename": "src/libsyntax_ext/global_asm.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_asm.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -8,21 +8,22 @@\n /// LLVM's `module asm \"some assembly here\"`. All of LLVM's caveats\n /// therefore apply.\n \n-use errors::DiagnosticBuilder;\n+use crate::errors::DiagnosticBuilder;\n+\n use syntax::ast;\n use syntax::source_map::respan;\n-use syntax::ext::base;\n-use syntax::ext::base::*;\n+use syntax::ext::base::{self, *};\n use syntax::feature_gate;\n use syntax::parse::token;\n use syntax::ptr::P;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n use syntax::tokenstream;\n+use smallvec::smallvec;\n \n pub const MACRO: &str = \"global_asm\";\n \n-pub fn expand_global_asm<'cx>(cx: &'cx mut ExtCtxt,\n+pub fn expand_global_asm<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                               sp: Span,\n                               tts: &[tokenstream::TokenTree]) -> Box<dyn base::MacResult + 'cx> {\n     if !cx.ecfg.enable_global_asm() {"}, {"sha": "9308cfb3a4f2e6f1a92d87be87a819111b2ecc89", "filename": "src/libsyntax_ext/lib.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flib.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -4,29 +4,21 @@\n        html_favicon_url = \"https://doc.rust-lang.org/favicon.ico\",\n        html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n+#![deny(rust_2018_idioms)]\n+\n #![feature(in_band_lifetimes)]\n #![feature(proc_macro_diagnostic)]\n #![feature(proc_macro_internals)]\n #![feature(proc_macro_span)]\n #![feature(decl_macro)]\n-#![feature(nll)]\n #![feature(str_escape)]\n #![feature(rustc_diagnostic_macros)]\n \n #![recursion_limit=\"256\"]\n \n-extern crate fmt_macros;\n-#[macro_use]\n-extern crate syntax;\n-extern crate syntax_pos;\n extern crate proc_macro;\n-extern crate rustc_data_structures;\n-extern crate rustc_errors as errors;\n-extern crate rustc_target;\n-#[macro_use]\n-extern crate smallvec;\n-#[macro_use]\n-extern crate log;\n+\n+use rustc_errors as errors;\n \n mod diagnostics;\n "}, {"sha": "658ce98d268842bf4ccef0cf51a2e42457412d31", "filename": "src/libsyntax_ext/log_syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Flog_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Flog_syntax.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -4,7 +4,7 @@ use syntax::print;\n use syntax::tokenstream;\n use syntax_pos;\n \n-pub fn expand_syntax_ext<'cx>(cx: &'cx mut base::ExtCtxt,\n+pub fn expand_syntax_ext<'cx>(cx: &'cx mut base::ExtCtxt<'_>,\n                               sp: syntax_pos::Span,\n                               tts: &[tokenstream::TokenTree])\n                               -> Box<dyn base::MacResult + 'cx> {"}, {"sha": "fbc4d8990742c27f6b92447ee4729477280d94ec", "filename": "src/libsyntax_ext/proc_macro_decls.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_decls.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -1,6 +1,7 @@\n use std::mem;\n \n-use errors;\n+use crate::deriving;\n+use crate::errors;\n \n use syntax::ast::{self, Ident};\n use syntax::attr;\n@@ -18,8 +19,6 @@ use syntax::visit::{self, Visitor};\n \n use syntax_pos::{Span, DUMMY_SP};\n \n-use deriving;\n-\n const PROC_MACRO_KINDS: [&str; 3] = [\"proc_macro_derive\", \"proc_macro_attribute\", \"proc_macro\"];\n \n struct ProcMacroDerive {\n@@ -324,7 +323,7 @@ impl<'a> Visitor<'a> for CollectProcMacros<'a> {\n //          ];\n //      }\n fn mk_decls(\n-    cx: &mut ExtCtxt,\n+    cx: &mut ExtCtxt<'_>,\n     custom_derives: &[ProcMacroDerive],\n     custom_attrs: &[ProcMacroDef],\n     custom_macros: &[ProcMacroDef],"}, {"sha": "88e20e3dc7c9ea85bd458650eaa91514162ee889", "filename": "src/libsyntax_ext/proc_macro_impl.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fproc_macro_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fproc_macro_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_impl.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -1,27 +1,27 @@\n-use errors::FatalError;\n+use crate::errors::FatalError;\n+use crate::proc_macro_server;\n \n use syntax::source_map::Span;\n-use syntax::ext::base::*;\n+use syntax::ext::base::{self, *};\n use syntax::tokenstream::TokenStream;\n-use syntax::ext::base;\n \n-pub const EXEC_STRATEGY: ::proc_macro::bridge::server::SameThread =\n-    ::proc_macro::bridge::server::SameThread;\n+pub const EXEC_STRATEGY: proc_macro::bridge::server::SameThread =\n+    proc_macro::bridge::server::SameThread;\n \n pub struct AttrProcMacro {\n-    pub client: ::proc_macro::bridge::client::Client<\n-        fn(::proc_macro::TokenStream, ::proc_macro::TokenStream) -> ::proc_macro::TokenStream,\n+    pub client: proc_macro::bridge::client::Client<\n+        fn(proc_macro::TokenStream, proc_macro::TokenStream) -> proc_macro::TokenStream,\n     >,\n }\n \n impl base::AttrProcMacro for AttrProcMacro {\n     fn expand<'cx>(&self,\n-                   ecx: &'cx mut ExtCtxt,\n+                   ecx: &'cx mut ExtCtxt<'_>,\n                    span: Span,\n                    annotation: TokenStream,\n                    annotated: TokenStream)\n                    -> TokenStream {\n-        let server = ::proc_macro_server::Rustc::new(ecx);\n+        let server = proc_macro_server::Rustc::new(ecx);\n         match self.client.run(&EXEC_STRATEGY, server, annotation, annotated) {\n             Ok(stream) => stream,\n             Err(e) => {\n@@ -39,18 +39,18 @@ impl base::AttrProcMacro for AttrProcMacro {\n }\n \n pub struct BangProcMacro {\n-    pub client: ::proc_macro::bridge::client::Client<\n-        fn(::proc_macro::TokenStream) -> ::proc_macro::TokenStream,\n+    pub client: proc_macro::bridge::client::Client<\n+        fn(proc_macro::TokenStream) -> proc_macro::TokenStream,\n     >,\n }\n \n impl base::ProcMacro for BangProcMacro {\n     fn expand<'cx>(&self,\n-                   ecx: &'cx mut ExtCtxt,\n+                   ecx: &'cx mut ExtCtxt<'_>,\n                    span: Span,\n                    input: TokenStream)\n                    -> TokenStream {\n-        let server = ::proc_macro_server::Rustc::new(ecx);\n+        let server = proc_macro_server::Rustc::new(ecx);\n         match self.client.run(&EXEC_STRATEGY, server, input) {\n             Ok(stream) => stream,\n             Err(e) => {"}, {"sha": "730262683c0b7259b2496c68d8d2676f8718ccea", "filename": "src/libsyntax_ext/proc_macro_server.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_server.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -1,4 +1,5 @@\n-use errors::{self, Diagnostic, DiagnosticBuilder};\n+use crate::errors::{self, Diagnostic, DiagnosticBuilder};\n+\n use std::panic;\n \n use proc_macro::bridge::{server, TokenTree};\n@@ -369,7 +370,7 @@ pub(crate) struct Rustc<'a> {\n }\n \n impl<'a> Rustc<'a> {\n-    pub fn new(cx: &'a ExtCtxt) -> Self {\n+    pub fn new(cx: &'a ExtCtxt<'_>) -> Self {\n         // No way to determine def location for a proc macro right now, so use call location.\n         let location = cx.current_expansion.mark.expn_info().unwrap().call_site;\n         let to_span = |transparency| {\n@@ -650,7 +651,7 @@ impl server::Literal for Rustc<'_> {\n     }\n }\n \n-impl<'a> server::SourceFile for Rustc<'a> {\n+impl server::SourceFile for Rustc<'_> {\n     fn eq(&mut self, file1: &Self::SourceFile, file2: &Self::SourceFile) -> bool {\n         Lrc::ptr_eq(file1, file2)\n     }"}, {"sha": "832bebb6113e944151ee5b6ad105386e6960867b", "filename": "src/libsyntax_ext/test.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -13,7 +13,7 @@ use syntax::source_map::{ExpnInfo, MacroAttribute};\n use std::iter;\n \n pub fn expand_test(\n-    cx: &mut ExtCtxt,\n+    cx: &mut ExtCtxt<'_>,\n     attr_sp: Span,\n     _meta_item: &ast::MetaItem,\n     item: Annotatable,\n@@ -22,7 +22,7 @@ pub fn expand_test(\n }\n \n pub fn expand_bench(\n-    cx: &mut ExtCtxt,\n+    cx: &mut ExtCtxt<'_>,\n     attr_sp: Span,\n     _meta_item: &ast::MetaItem,\n     item: Annotatable,\n@@ -31,7 +31,7 @@ pub fn expand_bench(\n }\n \n pub fn expand_test_or_bench(\n-    cx: &mut ExtCtxt,\n+    cx: &mut ExtCtxt<'_>,\n     attr_sp: Span,\n     item: Annotatable,\n     is_bench: bool\n@@ -180,7 +180,7 @@ pub fn expand_test_or_bench(\n         ast::ItemKind::ExternCrate(Some(Symbol::intern(\"test\")))\n     );\n \n-    debug!(\"Synthetic test item:\\n{}\\n\", pprust::item_to_string(&test_const));\n+    log::debug!(\"Synthetic test item:\\n{}\\n\", pprust::item_to_string(&test_const));\n \n     vec![\n         // Access to libtest under a gensymed name\n@@ -210,7 +210,7 @@ fn should_fail(i: &ast::Item) -> bool {\n     attr::contains_name(&i.attrs, \"allow_fail\")\n }\n \n-fn should_panic(cx: &ExtCtxt, i: &ast::Item) -> ShouldPanic {\n+fn should_panic(cx: &ExtCtxt<'_>, i: &ast::Item) -> ShouldPanic {\n     match attr::find_by_name(&i.attrs, \"should_panic\") {\n         Some(attr) => {\n             let ref sd = cx.parse_sess.span_diagnostic;\n@@ -243,7 +243,7 @@ fn should_panic(cx: &ExtCtxt, i: &ast::Item) -> ShouldPanic {\n     }\n }\n \n-fn has_test_signature(cx: &ExtCtxt, i: &ast::Item) -> bool {\n+fn has_test_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n     let has_should_panic_attr = attr::contains_name(&i.attrs, \"should_panic\");\n     let ref sd = cx.parse_sess.span_diagnostic;\n     if let ast::ItemKind::Fn(ref decl, ref header, ref generics, _) = i.node {\n@@ -296,7 +296,7 @@ fn has_test_signature(cx: &ExtCtxt, i: &ast::Item) -> bool {\n     }\n }\n \n-fn has_bench_signature(cx: &ExtCtxt, i: &ast::Item) -> bool {\n+fn has_bench_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n     let has_sig = if let ast::ItemKind::Fn(ref decl, _, _, _) = i.node {\n         // N.B., inadequate check, but we're running\n         // well before resolve, can't get too deep."}, {"sha": "63417b702d5693f40d2ff6de73e1a0176962e603", "filename": "src/libsyntax_ext/test_case.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Ftest_case.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Ftest_case.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_case.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -20,7 +20,7 @@ use syntax::source_map::{ExpnInfo, MacroAttribute};\n use syntax::feature_gate;\n \n pub fn expand(\n-    ecx: &mut ExtCtxt,\n+    ecx: &mut ExtCtxt<'_>,\n     attr_sp: Span,\n     _meta_item: &ast::MetaItem,\n     anno_item: Annotatable"}, {"sha": "4d35daf3de998577d9c52499c74293d0b086dc43", "filename": "src/libsyntax_ext/trace_macros.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d/src%2Flibsyntax_ext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftrace_macros.rs?ref=94f121ff3f47fecdcf458b691f1bf87f8b1f1f1d", "patch": "@@ -1,11 +1,10 @@\n-use syntax::ext::base::ExtCtxt;\n-use syntax::ext::base;\n+use syntax::ext::base::{self, ExtCtxt};\n use syntax::feature_gate;\n use syntax::symbol::keywords;\n use syntax_pos::Span;\n use syntax::tokenstream::TokenTree;\n \n-pub fn expand_trace_macros(cx: &mut ExtCtxt,\n+pub fn expand_trace_macros(cx: &mut ExtCtxt<'_>,\n                            sp: Span,\n                            tt: &[TokenTree])\n                            -> Box<dyn base::MacResult + 'static> {"}]}