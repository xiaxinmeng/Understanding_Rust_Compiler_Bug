{"sha": "ea83349c9f06e13aae4a70e81d5dc470bf051bca", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhODMzNDljOWYwNmUxM2FhZTRhNzBlODFkNWRjNDcwYmYwNTFiY2E=", "commit": {"author": {"name": "mitaa", "email": "mitaa.ceb@gmail.com", "date": "2016-04-07T03:59:02Z"}, "committer": {"name": "mitaa", "email": "mitaa.ceb@gmail.com", "date": "2016-04-13T17:39:17Z"}, "message": "Retire rustdocs `ANALYSISKEY`\n\nThe thread-local isn't needed and consists of mostly empty fields which\nwere just used to move the data into `html::render::CACHE_KEY`.", "tree": {"sha": "7e4fc83dfa97fcb316d9efdd8a498e21b9d8a2ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e4fc83dfa97fcb316d9efdd8a498e21b9d8a2ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea83349c9f06e13aae4a70e81d5dc470bf051bca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea83349c9f06e13aae4a70e81d5dc470bf051bca", "html_url": "https://github.com/rust-lang/rust/commit/ea83349c9f06e13aae4a70e81d5dc470bf051bca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea83349c9f06e13aae4a70e81d5dc470bf051bca/comments", "author": {"login": "mitaa", "id": 6785936, "node_id": "MDQ6VXNlcjY3ODU5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6785936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mitaa", "html_url": "https://github.com/mitaa", "followers_url": "https://api.github.com/users/mitaa/followers", "following_url": "https://api.github.com/users/mitaa/following{/other_user}", "gists_url": "https://api.github.com/users/mitaa/gists{/gist_id}", "starred_url": "https://api.github.com/users/mitaa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mitaa/subscriptions", "organizations_url": "https://api.github.com/users/mitaa/orgs", "repos_url": "https://api.github.com/users/mitaa/repos", "events_url": "https://api.github.com/users/mitaa/events{/privacy}", "received_events_url": "https://api.github.com/users/mitaa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mitaa", "id": 6785936, "node_id": "MDQ6VXNlcjY3ODU5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6785936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mitaa", "html_url": "https://github.com/mitaa", "followers_url": "https://api.github.com/users/mitaa/followers", "following_url": "https://api.github.com/users/mitaa/following{/other_user}", "gists_url": "https://api.github.com/users/mitaa/gists{/gist_id}", "starred_url": "https://api.github.com/users/mitaa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mitaa/subscriptions", "organizations_url": "https://api.github.com/users/mitaa/orgs", "repos_url": "https://api.github.com/users/mitaa/repos", "events_url": "https://api.github.com/users/mitaa/events{/privacy}", "received_events_url": "https://api.github.com/users/mitaa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6136a86291b12f5441910d56d5bc0dfbc7eecdeb", "url": "https://api.github.com/repos/rust-lang/rust/commits/6136a86291b12f5441910d56d5bc0dfbc7eecdeb", "html_url": "https://github.com/rust-lang/rust/commit/6136a86291b12f5441910d56d5bc0dfbc7eecdeb"}], "stats": {"total": 201, "additions": 90, "deletions": 111}, "files": [{"sha": "478f662d0962a4646a9ae555f2bcca15abb7acb7", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ea83349c9f06e13aae4a70e81d5dc470bf051bca/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea83349c9f06e13aae4a70e81d5dc470bf051bca/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=ea83349c9f06e13aae4a70e81d5dc470bf051bca", "patch": "@@ -15,10 +15,11 @@\n use util::nodemap::{DefIdSet, FnvHashMap};\n \n use std::hash::Hash;\n+use std::fmt;\n use syntax::ast::NodeId;\n \n // Accessibility levels, sorted in ascending order\n-#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n pub enum AccessLevel {\n     // Exported items + items participating in various kinds of public interfaces,\n     // but not directly nameable. For example, if function `fn f() -> T {...}` is\n@@ -56,6 +57,12 @@ impl<Id: Hash + Eq> Default for AccessLevels<Id> {\n     }\n }\n \n+impl<Id: Hash + Eq + fmt::Debug> fmt::Debug for AccessLevels<Id> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&self.map, f)\n+    }\n+}\n+\n /// A set containing all exported definitions from external crates.\n /// The set does not contain any entries from local crates.\n pub type ExternalExports = DefIdSet;"}, {"sha": "6cca602466a3d68a7784a4e6dc8aa229cb06a5c0", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea83349c9f06e13aae4a70e81d5dc470bf051bca/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea83349c9f06e13aae4a70e81d5dc470bf051bca/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=ea83349c9f06e13aae4a70e81d5dc470bf051bca", "patch": "@@ -116,7 +116,7 @@ fn try_inline_def(cx: &DocContext, tcx: &TyCtxt,\n         }\n         _ => return None,\n     };\n-    cx.inlined.borrow_mut().as_mut().unwrap().insert(did);\n+    cx.renderinfo.borrow_mut().inlined.insert(did);\n     ret.push(clean::Item {\n         source: clean::Span::empty(),\n         name: Some(tcx.item_name(did).to_string()),\n@@ -146,7 +146,7 @@ pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n             elem.data.to_string()\n         });\n         let fqn = once(crate_name).chain(relative).collect();\n-        cx.external_paths.borrow_mut().as_mut().unwrap().insert(did, (fqn, kind));\n+        cx.renderinfo.borrow_mut().external_paths.insert(did, (fqn, kind));\n     }\n }\n \n@@ -295,7 +295,7 @@ pub fn build_impl(cx: &DocContext,\n                   tcx: &TyCtxt,\n                   did: DefId,\n                   ret: &mut Vec<clean::Item>) {\n-    if !cx.inlined.borrow_mut().as_mut().unwrap().insert(did) {\n+    if !cx.renderinfo.borrow_mut().inlined.insert(did) {\n         return\n     }\n "}, {"sha": "bba394bb90dc6743b048e9dc057e50d1715f6a02", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ea83349c9f06e13aae4a70e81d5dc470bf051bca/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea83349c9f06e13aae4a70e81d5dc470bf051bca/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ea83349c9f06e13aae4a70e81d5dc470bf051bca", "patch": "@@ -35,6 +35,7 @@ use syntax::ptr::P;\n \n use rustc_trans::back::link;\n use rustc::middle::cstore::{self, CrateStore};\n+use rustc::middle::privacy::AccessLevels;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{DefId, DefIndex};\n use rustc::ty::subst::{self, ParamSpace, VecPerParamSpace};\n@@ -46,8 +47,10 @@ use rustc::hir;\n use std::collections::{HashMap, HashSet};\n use std::path::PathBuf;\n use std::rc::Rc;\n+use std::sync::Arc;\n use std::u32;\n use std::env::current_dir;\n+use std::mem;\n \n use core::DocContext;\n use doctree;\n@@ -112,13 +115,16 @@ impl<T: Clean<U>, U> Clean<Vec<U>> for P<[T]> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+#[derive(Clone, Debug)]\n pub struct Crate {\n     pub name: String,\n     pub src: PathBuf,\n     pub module: Option<Item>,\n     pub externs: Vec<(ast::CrateNum, ExternalCrate)>,\n     pub primitives: Vec<PrimitiveType>,\n+    pub access_levels: Arc<AccessLevels<DefId>>,\n+    // These are later on moved into `CACHEKEY`, leaving the map empty.\n+    // Only here so that they can be filtered through the rustdoc passes.\n     pub external_traits: HashMap<DefId, Trait>,\n }\n \n@@ -130,6 +136,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n \n         if let Some(t) = cx.tcx_opt() {\n             cx.deref_trait_did.set(t.lang_items.deref_trait());\n+            cx.renderinfo.borrow_mut().deref_trait_did = cx.deref_trait_did.get();\n         }\n \n         let mut externs = Vec::new();\n@@ -204,14 +211,17 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n             Input::Str { ref name, .. } => PathBuf::from(name.clone()),\n         };\n \n+        let mut access_levels = cx.access_levels.borrow_mut();\n+        let mut external_traits = cx.external_traits.borrow_mut();\n+\n         Crate {\n             name: name.to_string(),\n             src: src,\n             module: Some(module),\n             externs: externs,\n             primitives: primitives,\n-            external_traits: cx.external_traits.borrow_mut().take()\n-                               .unwrap_or(HashMap::new()),\n+            access_levels: Arc::new(mem::replace(&mut access_levels, Default::default())),\n+            external_traits: mem::replace(&mut external_traits, Default::default()),\n         }\n     }\n }\n@@ -540,8 +550,7 @@ impl Clean<TyParam> for hir::TyParam {\n \n impl<'tcx> Clean<TyParam> for ty::TypeParameterDef<'tcx> {\n     fn clean(&self, cx: &DocContext) -> TyParam {\n-        cx.external_typarams.borrow_mut().as_mut().unwrap()\n-          .insert(self.def_id, self.name.clean(cx));\n+        cx.renderinfo.borrow_mut().external_typarams.insert(self.def_id, self.name.clean(cx));\n         TyParam {\n             name: self.name.clean(cx),\n             did: self.def_id,\n@@ -2668,7 +2677,7 @@ fn register_def(cx: &DocContext, def: Def) -> DefId {\n     inline::record_extern_fqn(cx, did, kind);\n     if let TypeTrait = kind {\n         let t = inline::build_external_trait(cx, tcx, did);\n-        cx.external_traits.borrow_mut().as_mut().unwrap().insert(did, t);\n+        cx.external_traits.borrow_mut().insert(did, t);\n     }\n     did\n }"}, {"sha": "c9773ebccb4eebe0ba7976a89a95fce842a20954", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 22, "deletions": 48, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/ea83349c9f06e13aae4a70e81d5dc470bf051bca/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea83349c9f06e13aae4a70e81d5dc470bf051bca/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=ea83349c9f06e13aae4a70e81d5dc470bf051bca", "patch": "@@ -29,12 +29,13 @@ use syntax::feature_gate::UnstableFeatures;\n use syntax::parse::token;\n \n use std::cell::{RefCell, Cell};\n-use std::collections::{HashMap, HashSet};\n+use std::collections::HashMap;\n use std::rc::Rc;\n \n use visit_ast::RustdocVisitor;\n use clean;\n use clean::Clean;\n+use html::render::RenderInfo;\n \n pub use rustc::session::config::Input;\n pub use rustc::session::search_paths::SearchPaths;\n@@ -45,19 +46,20 @@ pub enum MaybeTyped<'a, 'tcx: 'a> {\n     NotTyped(&'a session::Session)\n }\n \n-pub type ExternalPaths = RefCell<Option<HashMap<DefId,\n-                                                (Vec<String>, clean::TypeKind)>>>;\n+pub type ExternalPaths = HashMap<DefId, (Vec<String>, clean::TypeKind)>;\n \n pub struct DocContext<'a, 'tcx: 'a> {\n     pub map: &'a hir_map::Map<'tcx>,\n     pub maybe_typed: MaybeTyped<'a, 'tcx>,\n     pub input: Input,\n-    pub external_paths: ExternalPaths,\n-    pub external_traits: RefCell<Option<HashMap<DefId, clean::Trait>>>,\n-    pub external_typarams: RefCell<Option<HashMap<DefId, String>>>,\n-    pub inlined: RefCell<Option<HashSet<DefId>>>,\n     pub all_crate_impls: RefCell<HashMap<ast::CrateNum, Vec<clean::Item>>>,\n+    // Later on moved into `clean::Crate`\n+    pub access_levels: RefCell<AccessLevels<DefId>>,\n+    // Later on moved into `html::render::CACHE_KEY`\n+    pub renderinfo: RefCell<RenderInfo>,\n     pub deref_trait_did: Cell<Option<DefId>>,\n+    // Later on moved through `clean::Crate` into `html::render::CACHE_KEY`\n+    pub external_traits: RefCell<HashMap<DefId, clean::Trait>>,\n }\n \n impl<'b, 'tcx> DocContext<'b, 'tcx> {\n@@ -81,20 +83,14 @@ impl<'b, 'tcx> DocContext<'b, 'tcx> {\n     }\n }\n \n-pub struct CrateAnalysis {\n-    pub access_levels: AccessLevels<DefId>,\n-    pub external_paths: ExternalPaths,\n-    pub external_typarams: RefCell<Option<HashMap<DefId, String>>>,\n-    pub inlined: RefCell<Option<HashSet<DefId>>>,\n-    pub deref_trait_did: Option<DefId>,\n-}\n-\n pub type Externs = HashMap<String, Vec<String>>;\n \n-pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n-                input: Input, triple: Option<String>)\n-                -> (clean::Crate, CrateAnalysis) {\n-\n+pub fn run_core(search_paths: SearchPaths,\n+                cfgs: Vec<String>,\n+                externs: Externs,\n+                input: Input,\n+                triple: Option<String>) -> (clean::Crate, RenderInfo)\n+{\n     // Parse, resolve, and typecheck the given crate.\n \n     let cpath = match input {\n@@ -148,7 +144,7 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n     let arenas = ty::CtxtArenas::new();\n     let hir_map = driver::make_map(&sess, &mut hir_forest);\n \n-    let krate_and_analysis = abort_on_err(driver::phase_3_run_analysis_passes(&sess,\n+    abort_on_err(driver::phase_3_run_analysis_passes(&sess,\n                                                      &cstore,\n                                                      hir_map,\n                                                      &arenas,\n@@ -175,42 +171,20 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n             map: &tcx.map,\n             maybe_typed: Typed(tcx),\n             input: input,\n-            external_traits: RefCell::new(Some(HashMap::new())),\n-            external_typarams: RefCell::new(Some(HashMap::new())),\n-            external_paths: RefCell::new(Some(HashMap::new())),\n-            inlined: RefCell::new(Some(HashSet::new())),\n             all_crate_impls: RefCell::new(HashMap::new()),\n             deref_trait_did: Cell::new(None),\n+            access_levels: RefCell::new(access_levels),\n+            external_traits: RefCell::new(HashMap::new()),\n+            renderinfo: RefCell::new(Default::default()),\n         };\n         debug!(\"crate: {:?}\", ctxt.map.krate());\n \n-        let mut analysis = CrateAnalysis {\n-            access_levels: access_levels,\n-            external_paths: RefCell::new(None),\n-            external_typarams: RefCell::new(None),\n-            inlined: RefCell::new(None),\n-            deref_trait_did: None,\n-        };\n-\n         let krate = {\n-            let mut v = RustdocVisitor::new(&ctxt, Some(&analysis));\n+            let mut v = RustdocVisitor::new(&ctxt);\n             v.visit(ctxt.map.krate());\n             v.clean(&ctxt)\n         };\n \n-        let external_paths = ctxt.external_paths.borrow_mut().take();\n-        *analysis.external_paths.borrow_mut() = external_paths;\n-\n-        let map = ctxt.external_typarams.borrow_mut().take();\n-        *analysis.external_typarams.borrow_mut() = map;\n-\n-        let map = ctxt.inlined.borrow_mut().take();\n-        *analysis.inlined.borrow_mut() = map;\n-\n-        analysis.deref_trait_did = ctxt.deref_trait_did.get();\n-\n-        Some((krate, analysis))\n-    }), &sess);\n-\n-    krate_and_analysis.unwrap()\n+        Some((krate, ctxt.renderinfo.into_inner()))\n+    }), &sess).unwrap()\n }"}, {"sha": "2d59747d00c5b8eeb2c9ecb39b6e94d127e48c01", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ea83349c9f06e13aae4a70e81d5dc470bf051bca/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea83349c9f06e13aae4a70e81d5dc470bf051bca/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=ea83349c9f06e13aae4a70e81d5dc470bf051bca", "patch": "@@ -253,7 +253,7 @@ pub struct Cache {\n     parent_is_trait_impl: bool,\n     search_index: Vec<IndexItem>,\n     stripped_mod: bool,\n-    access_levels: AccessLevels<DefId>,\n+    access_levels: Arc<AccessLevels<DefId>>,\n     deref_trait_did: Option<DefId>,\n \n     // In rare case where a structure is defined in one module but implemented\n@@ -264,6 +264,16 @@ pub struct Cache {\n     orphan_methods: Vec<(DefId, clean::Item)>,\n }\n \n+/// Temporary storage for data obtained during `RustdocVisitor::clean()`.\n+/// Later on moved into `CACHE_KEY`.\n+#[derive(Default)]\n+pub struct RenderInfo {\n+    pub inlined: HashSet<DefId>,\n+    pub external_paths: ::core::ExternalPaths,\n+    pub external_typarams: HashMap<DefId, String>,\n+    pub deref_trait_did: Option<DefId>,\n+}\n+\n /// Helper struct to render all source code to HTML pages\n struct SourceCollector<'a> {\n     scx: &'a mut SharedContext,\n@@ -415,7 +425,8 @@ pub fn run(mut krate: clean::Crate,\n            external_html: &ExternalHtml,\n            dst: PathBuf,\n            passes: HashSet<String>,\n-           css_file_extension: Option<PathBuf>) -> Result<(), Error> {\n+           css_file_extension: Option<PathBuf>,\n+           renderinfo: RenderInfo) -> Result<(), Error> {\n     let src_root = match krate.src.parent() {\n         Some(p) => p.to_path_buf(),\n         None => PathBuf::new(),\n@@ -482,19 +493,20 @@ pub fn run(mut krate: clean::Crate,\n     };\n \n     // Crawl the crate to build various caches used for the output\n-    let analysis = ::ANALYSISKEY.with(|a| a.clone());\n-    let analysis = analysis.borrow();\n-    let access_levels = analysis.as_ref().map(|a| a.access_levels.clone());\n-    let access_levels = access_levels.unwrap_or(Default::default());\n-    let paths: HashMap<DefId, (Vec<String>, ItemType)> =\n-      analysis.as_ref().map(|a| {\n-        let paths = a.external_paths.borrow_mut().take().unwrap();\n-        paths.into_iter().map(|(k, (v, t))| (k, (v, ItemType::from_type_kind(t)))).collect()\n-      }).unwrap_or(HashMap::new());\n+    let RenderInfo {\n+        inlined,\n+        external_paths,\n+        external_typarams,\n+        deref_trait_did,\n+    } = renderinfo;\n+\n+    let paths = external_paths.into_iter()\n+                              .map(|(k, (v, t))| (k, (v, ItemType::from_type_kind(t))))\n+                              .collect::<HashMap<_, _>>();\n+\n     let mut cache = Cache {\n         impls: HashMap::new(),\n-        external_paths: paths.iter().map(|(&k, v)| (k, v.0.clone()))\n-                             .collect(),\n+        external_paths: paths.iter().map(|(&k, v)| (k, v.0.clone())).collect(),\n         paths: paths,\n         implementors: HashMap::new(),\n         stack: Vec::new(),\n@@ -504,16 +516,12 @@ pub fn run(mut krate: clean::Crate,\n         extern_locations: HashMap::new(),\n         primitive_locations: HashMap::new(),\n         stripped_mod: false,\n-        access_levels: access_levels,\n+        access_levels: krate.access_levels.clone(),\n         orphan_methods: Vec::new(),\n         traits: mem::replace(&mut krate.external_traits, HashMap::new()),\n-        deref_trait_did: analysis.as_ref().and_then(|a| a.deref_trait_did),\n-        typarams: analysis.as_ref().map(|a| {\n-            a.external_typarams.borrow_mut().take().unwrap()\n-        }).unwrap_or(HashMap::new()),\n-        inlined: analysis.as_ref().map(|a| {\n-            a.inlined.borrow_mut().take().unwrap()\n-        }).unwrap_or(HashSet::new()),\n+        deref_trait_did: deref_trait_did,\n+        typarams: external_typarams,\n+        inlined: inlined,\n     };\n \n     // Cache where all our extern crates are located"}, {"sha": "0d80e70281603ca3ffbdb1752ecf773fb05e708d", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ea83349c9f06e13aae4a70e81d5dc470bf051bca/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea83349c9f06e13aae4a70e81d5dc470bf051bca/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=ea83349c9f06e13aae4a70e81d5dc470bf051bca", "patch": "@@ -48,14 +48,11 @@ extern crate rustc_unicode;\n \n extern crate serialize as rustc_serialize; // used by deriving\n \n-use std::cell::RefCell;\n use std::collections::HashMap;\n use std::default::Default;\n use std::env;\n-use std::io::Read;\n use std::path::PathBuf;\n use std::process;\n-use std::rc::Rc;\n use std::sync::mpsc::channel;\n \n use externalfiles::ExternalHtml;\n@@ -113,12 +110,9 @@ const DEFAULT_PASSES: &'static [&'static str] = &[\n     \"unindent-comments\",\n ];\n \n-thread_local!(pub static ANALYSISKEY: Rc<RefCell<Option<core::CrateAnalysis>>> = {\n-    Rc::new(RefCell::new(None))\n-});\n-\n struct Output {\n     krate: clean::Crate,\n+    renderinfo: html::render::RenderInfo,\n     passes: Vec<String>,\n }\n \n@@ -302,14 +296,15 @@ pub fn main_args(args: &[String]) -> isize {\n             return 1;\n         }\n     };\n-    let Output { krate, passes, } = out;\n+    let Output { krate, passes, renderinfo } = out;\n     info!(\"going to format\");\n     match matches.opt_str(\"w\").as_ref().map(|s| &**s) {\n         Some(\"html\") | None => {\n             html::render::run(krate, &external_html,\n                               output.unwrap_or(PathBuf::from(\"doc\")),\n                               passes.into_iter().collect(),\n-                              css_file_extension)\n+                              css_file_extension,\n+                              renderinfo)\n                 .expect(\"failed to generate documentation\")\n         }\n         Some(s) => {\n@@ -380,12 +375,8 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n         tx.send(core::run_core(paths, cfgs, externs, Input::File(cr),\n                                triple)).unwrap();\n     });\n-    let (mut krate, analysis) = rx.recv().unwrap();\n+    let (mut krate, renderinfo) = rx.recv().unwrap();\n     info!(\"finished with rustc\");\n-    let mut analysis = Some(analysis);\n-    ANALYSISKEY.with(|s| {\n-        *s.borrow_mut() = analysis.take();\n-    });\n \n     if let Some(name) = matches.opt_str(\"crate-name\") {\n         krate.name = name\n@@ -443,5 +434,5 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n     // Run everything!\n     info!(\"Executing passes/plugins\");\n     let krate = pm.run_plugins(krate);\n-    Output { krate: krate, passes: passes }\n+    Output { krate: krate, renderinfo: renderinfo, passes: passes }\n }"}, {"sha": "b9a2acb02e8026035c7a9d8659fdf6e58654cad9", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ea83349c9f06e13aae4a70e81d5dc470bf051bca/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea83349c9f06e13aae4a70e81d5dc470bf051bca/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=ea83349c9f06e13aae4a70e81d5dc470bf051bca", "patch": "@@ -88,10 +88,7 @@ pub fn strip_hidden(krate: clean::Crate) -> plugins::PluginResult {\n pub fn strip_private(mut krate: clean::Crate) -> plugins::PluginResult {\n     // This stripper collects all *retained* nodes.\n     let mut retained = DefIdSet();\n-    let analysis = super::ANALYSISKEY.with(|a| a.clone());\n-    let analysis = analysis.borrow();\n-    let analysis = analysis.as_ref().unwrap();\n-    let access_levels = analysis.access_levels.clone();\n+    let access_levels = krate.access_levels.clone();\n \n     // strip all private items\n     {"}, {"sha": "5a7050fb42f3045a8115d0ecd616f27247e60da3", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ea83349c9f06e13aae4a70e81d5dc470bf051bca/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea83349c9f06e13aae4a70e81d5dc470bf051bca/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=ea83349c9f06e13aae4a70e81d5dc470bf051bca", "patch": "@@ -108,15 +108,14 @@ pub fn run(input: &str,\n         map: &map,\n         maybe_typed: core::NotTyped(&sess),\n         input: input,\n-        external_paths: RefCell::new(Some(HashMap::new())),\n-        external_traits: RefCell::new(None),\n-        external_typarams: RefCell::new(None),\n-        inlined: RefCell::new(None),\n+        external_traits: RefCell::new(HashMap::new()),\n         all_crate_impls: RefCell::new(HashMap::new()),\n         deref_trait_did: Cell::new(None),\n+        access_levels: Default::default(),\n+        renderinfo: Default::default(),\n     };\n \n-    let mut v = RustdocVisitor::new(&ctx, None);\n+    let mut v = RustdocVisitor::new(&ctx);\n     v.visit(ctx.map.krate());\n     let mut krate = v.clean(&ctx);\n     if let Some(name) = crate_name {"}, {"sha": "a406c843b82e46ce5ac673ea86da55b67439b16e", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ea83349c9f06e13aae4a70e81d5dc470bf051bca/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea83349c9f06e13aae4a70e81d5dc470bf051bca/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=ea83349c9f06e13aae4a70e81d5dc470bf051bca", "patch": "@@ -41,22 +41,19 @@ pub struct RustdocVisitor<'a, 'tcx: 'a> {\n     pub module: Module,\n     pub attrs: hir::HirVec<ast::Attribute>,\n     pub cx: &'a core::DocContext<'a, 'tcx>,\n-    pub analysis: Option<&'a core::CrateAnalysis>,\n     view_item_stack: HashSet<ast::NodeId>,\n     inlining_from_glob: bool,\n }\n \n impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n-    pub fn new(cx: &'a core::DocContext<'a, 'tcx>,\n-               analysis: Option<&'a core::CrateAnalysis>) -> RustdocVisitor<'a, 'tcx> {\n+    pub fn new(cx: &'a core::DocContext<'a, 'tcx>) -> RustdocVisitor<'a, 'tcx> {\n         // If the root is reexported, terminate all recursion.\n         let mut stack = HashSet::new();\n         stack.insert(ast::CRATE_NODE_ID);\n         RustdocVisitor {\n             module: Module::new(None),\n             attrs: hir::HirVec::new(),\n             cx: cx,\n-            analysis: analysis,\n             view_item_stack: stack,\n             inlining_from_glob: false,\n         }\n@@ -247,13 +244,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         let def_node_id = match tcx.map.as_local_node_id(def) {\n             Some(n) => n, None => return false\n         };\n-        let analysis = match self.analysis {\n-            Some(analysis) => analysis, None => return false\n-        };\n \n         let use_attrs = tcx.map.attrs(id).clean(self.cx);\n \n-        let is_private = !analysis.access_levels.is_public(def);\n+        let is_private = !self.cx.access_levels.borrow().is_public(def);\n         let is_hidden = inherits_doc_hidden(self.cx, def_node_id);\n         let is_no_inline = use_attrs.list(\"doc\").has_word(\"no_inline\");\n "}]}