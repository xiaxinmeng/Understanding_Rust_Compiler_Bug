{"sha": "b3e59bb291a0c0de8df0671c7acf87920c168aa5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzZTU5YmIyOTFhMGMwZGU4ZGYwNjcxYzdhY2Y4NzkyMGMxNjhhYTU=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-09-20T16:00:18Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-09-28T14:06:52Z"}, "message": "Move non-const ops into their own module", "tree": {"sha": "116a5acfa71a072a90d640f717f4fdcf33ba7072", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/116a5acfa71a072a90d640f717f4fdcf33ba7072"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b3e59bb291a0c0de8df0671c7acf87920c168aa5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b3e59bb291a0c0de8df0671c7acf87920c168aa5", "html_url": "https://github.com/rust-lang/rust/commit/b3e59bb291a0c0de8df0671c7acf87920c168aa5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b3e59bb291a0c0de8df0671c7acf87920c168aa5/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e296436ee0ff782491993892a85fc261baeef769", "url": "https://api.github.com/repos/rust-lang/rust/commits/e296436ee0ff782491993892a85fc261baeef769", "html_url": "https://github.com/rust-lang/rust/commit/e296436ee0ff782491993892a85fc261baeef769"}], "stats": {"total": 679, "additions": 342, "deletions": 337}, "files": [{"sha": "3f26b4f0f45cc039a2f5a6a8083c5003a8798864", "filename": "src/librustc_mir/transform/check_consts/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b3e59bb291a0c0de8df0671c7acf87920c168aa5/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3e59bb291a0c0de8df0671c7acf87920c168aa5/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=b3e59bb291a0c0de8df0671c7acf87920c168aa5", "patch": "@@ -4,8 +4,9 @@ use rustc::ty::{self, TyCtxt};\n \n pub use self::qualifs::Qualif;\n \n-mod resolver;\n+pub mod ops;\n mod qualifs;\n+mod resolver;\n pub mod validation;\n \n /// Information about the item currently being validated, as well as a reference to the global"}, {"sha": "31e981d2b5a9b026e73080e836849b594d1c3b16", "filename": "src/librustc_mir/transform/check_consts/ops.rs", "status": "added", "additions": 337, "deletions": 0, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/b3e59bb291a0c0de8df0671c7acf87920c168aa5/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3e59bb291a0c0de8df0671c7acf87920c168aa5/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fops.rs?ref=b3e59bb291a0c0de8df0671c7acf87920c168aa5", "patch": "@@ -0,0 +1,337 @@\n+use rustc::hir::def_id::DefId;\n+use rustc::mir::BorrowKind;\n+use rustc::session::config::nightly_options;\n+use rustc::ty::TyCtxt;\n+use syntax::feature_gate::{emit_feature_err, GateIssue};\n+use syntax::symbol::sym;\n+use syntax_pos::{Span, Symbol};\n+\n+use super::Item;\n+use super::validation::Mode;\n+\n+/// An operation that is not *always* allowed in a const context.\n+pub trait NonConstOp {\n+    /// Whether this operation can be evaluated by miri.\n+    const IS_SUPPORTED_IN_MIRI: bool = true;\n+\n+    /// Returns a boolean indicating whether the feature gate that would allow this operation is\n+    /// enabled, or `None` if such a feature gate does not exist.\n+    fn feature_gate(_tcx: TyCtxt<'tcx>) -> Option<bool> {\n+        None\n+    }\n+\n+    /// Returns `true` if this operation is allowed in the given item.\n+    ///\n+    /// This check should assume that we are not in a non-const `fn`, where all operations are\n+    /// legal.\n+    fn is_allowed_in_item(&self, item: &Item<'_, '_>) -> bool {\n+        Self::feature_gate(item.tcx).unwrap_or(false)\n+    }\n+\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        let mut err = struct_span_err!(\n+            item.tcx.sess,\n+            span,\n+            E0019,\n+            \"{} contains unimplemented expression type\",\n+            item.mode\n+        );\n+        if item.tcx.sess.teach(&err.get_code().unwrap()) {\n+            err.note(\"A function call isn't allowed in the const's initialization expression \\\n+                      because the expression's value must be known at compile-time.\");\n+            err.note(\"Remember: you can't use a function call inside a const's initialization \\\n+                      expression! However, you can use it anywhere else.\");\n+        }\n+        err.emit();\n+    }\n+}\n+\n+/// A `Downcast` projection.\n+#[derive(Debug)]\n+pub struct Downcast;\n+impl NonConstOp for Downcast {}\n+\n+/// A function call where the callee is a pointer.\n+#[derive(Debug)]\n+pub struct FnCallIndirect;\n+impl NonConstOp for FnCallIndirect {\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        let mut err = item.tcx.sess.struct_span_err(\n+            span,\n+            &format!(\"function pointers are not allowed in const fn\"));\n+        err.emit();\n+    }\n+}\n+\n+/// A function call where the callee is not marked as `const`.\n+#[derive(Debug)]\n+pub struct FnCallNonConst(pub DefId);\n+impl NonConstOp for FnCallNonConst {\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        let mut err = struct_span_err!(\n+            item.tcx.sess,\n+            span,\n+            E0015,\n+            \"calls in {}s are limited to constant functions, \\\n+             tuple structs and tuple variants\",\n+            item.mode,\n+        );\n+        err.emit();\n+    }\n+}\n+\n+/// A function call where the callee is not a function definition or function pointer, e.g. a\n+/// closure.\n+///\n+/// This can be subdivided in the future to produce a better error message.\n+#[derive(Debug)]\n+pub struct FnCallOther;\n+impl NonConstOp for FnCallOther {\n+    const IS_SUPPORTED_IN_MIRI: bool = false;\n+}\n+\n+/// A call to a `#[unstable]` const fn or `#[rustc_const_unstable]` function.\n+///\n+/// Contains the name of the feature that would allow the use of this function.\n+#[derive(Debug)]\n+pub struct FnCallUnstable(pub DefId, pub Symbol);\n+impl NonConstOp for FnCallUnstable {\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        let FnCallUnstable(def_id, feature) = *self;\n+\n+        let mut err = item.tcx.sess.struct_span_err(span,\n+            &format!(\"`{}` is not yet stable as a const fn\",\n+                    item.tcx.def_path_str(def_id)));\n+        if nightly_options::is_nightly_build() {\n+            help!(&mut err,\n+                  \"add `#![feature({})]` to the \\\n+                   crate attributes to enable\",\n+                  feature);\n+        }\n+        err.emit();\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct HeapAllocation;\n+impl NonConstOp for HeapAllocation {\n+    const IS_SUPPORTED_IN_MIRI: bool = false;\n+\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        let mut err = struct_span_err!(item.tcx.sess, span, E0010,\n+                                       \"allocations are not allowed in {}s\", item.mode);\n+        err.span_label(span, format!(\"allocation not allowed in {}s\", item.mode));\n+        if item.tcx.sess.teach(&err.get_code().unwrap()) {\n+            err.note(\n+                \"The value of statics and constants must be known at compile time, \\\n+                 and they live for the entire lifetime of a program. Creating a boxed \\\n+                 value allocates memory on the heap at runtime, and therefore cannot \\\n+                 be done at compile time.\"\n+            );\n+        }\n+        err.emit();\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct IfOrMatch;\n+impl NonConstOp for IfOrMatch {}\n+\n+#[derive(Debug)]\n+pub struct LiveDrop;\n+impl NonConstOp for LiveDrop {\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        struct_span_err!(item.tcx.sess, span, E0493,\n+                         \"destructors cannot be evaluated at compile-time\")\n+            .span_label(span, format!(\"{}s cannot evaluate destructors\",\n+                                      item.mode))\n+            .emit();\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct Loop;\n+impl NonConstOp for Loop {}\n+\n+#[derive(Debug)]\n+pub struct MutBorrow(pub BorrowKind);\n+impl NonConstOp for MutBorrow {\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        let kind = self.0;\n+        if let BorrowKind::Mut { .. } = kind {\n+            let mut err = struct_span_err!(item.tcx.sess, span, E0017,\n+                                           \"references in {}s may only refer \\\n+                                            to immutable values\", item.mode);\n+            err.span_label(span, format!(\"{}s require immutable values\",\n+                                                item.mode));\n+            if item.tcx.sess.teach(&err.get_code().unwrap()) {\n+                err.note(\"References in statics and constants may only refer \\\n+                          to immutable values.\\n\\n\\\n+                          Statics are shared everywhere, and if they refer to \\\n+                          mutable data one might violate memory safety since \\\n+                          holding multiple mutable references to shared data \\\n+                          is not allowed.\\n\\n\\\n+                          If you really want global mutable state, try using \\\n+                          static mut or a global UnsafeCell.\");\n+            }\n+            err.emit();\n+        } else {\n+            span_err!(item.tcx.sess, span, E0492,\n+                      \"cannot borrow a constant which may contain \\\n+                       interior mutability, create a static instead\");\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct MutDeref;\n+impl NonConstOp for MutDeref {}\n+\n+#[derive(Debug)]\n+pub struct Panic;\n+impl NonConstOp for Panic {\n+    fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {\n+        Some(tcx.features().const_panic)\n+    }\n+\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        emit_feature_err(\n+            &item.tcx.sess.parse_sess,\n+            sym::const_panic,\n+            span,\n+            GateIssue::Language,\n+            &format!(\"panicking in {}s is unstable\", item.mode),\n+        );\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct RawPtrComparison;\n+impl NonConstOp for RawPtrComparison {\n+    fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {\n+        Some(tcx.features().const_compare_raw_pointers)\n+    }\n+\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        emit_feature_err(\n+            &item.tcx.sess.parse_sess,\n+            sym::const_compare_raw_pointers,\n+            span,\n+            GateIssue::Language,\n+            &format!(\"comparing raw pointers inside {}\", item.mode),\n+        );\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct RawPtrDeref;\n+impl NonConstOp for RawPtrDeref {\n+    fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {\n+        Some(tcx.features().const_raw_ptr_deref)\n+    }\n+\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        emit_feature_err(\n+            &item.tcx.sess.parse_sess, sym::const_raw_ptr_deref,\n+            span, GateIssue::Language,\n+            &format!(\n+                \"dereferencing raw pointers in {}s is unstable\",\n+                item.mode,\n+            ),\n+        );\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct RawPtrToIntCast;\n+impl NonConstOp for RawPtrToIntCast {\n+    fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {\n+        Some(tcx.features().const_raw_ptr_to_usize_cast)\n+    }\n+\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        emit_feature_err(\n+            &item.tcx.sess.parse_sess, sym::const_raw_ptr_to_usize_cast,\n+            span, GateIssue::Language,\n+            &format!(\n+                \"casting pointers to integers in {}s is unstable\",\n+                item.mode,\n+            ),\n+        );\n+    }\n+}\n+\n+/// An access to a (non-thread-local) `static`.\n+#[derive(Debug)]\n+pub struct StaticAccess;\n+impl NonConstOp for StaticAccess {\n+    fn is_allowed_in_item(&self, item: &Item<'_, '_>) -> bool {\n+        item.mode.is_static()\n+    }\n+\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        let mut err = struct_span_err!(item.tcx.sess, span, E0013,\n+                                        \"{}s cannot refer to statics, use \\\n+                                        a constant instead\", item.mode);\n+        if item.tcx.sess.teach(&err.get_code().unwrap()) {\n+            err.note(\n+                \"Static and const variables can refer to other const variables. \\\n+                    But a const variable cannot refer to a static variable.\"\n+            );\n+            err.help(\n+                \"To fix this, the value can be extracted as a const and then used.\"\n+            );\n+        }\n+        err.emit();\n+    }\n+}\n+\n+/// An access to a thread-local `static`.\n+#[derive(Debug)]\n+pub struct ThreadLocalAccess;\n+impl NonConstOp for ThreadLocalAccess {\n+    const IS_SUPPORTED_IN_MIRI: bool = false;\n+\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        span_err!(item.tcx.sess, span, E0625,\n+            \"thread-local statics cannot be \\\n+            accessed at compile-time\");\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct Transmute;\n+impl NonConstOp for Transmute {\n+    fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {\n+        Some(tcx.features().const_transmute)\n+    }\n+\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        emit_feature_err(\n+            &item.tcx.sess.parse_sess, sym::const_transmute,\n+            span, GateIssue::Language,\n+            &format!(\"The use of std::mem::transmute() \\\n+            is gated in {}s\", item.mode));\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct UnionAccess;\n+impl NonConstOp for UnionAccess {\n+    fn is_allowed_in_item(&self, item: &Item<'_, '_>) -> bool {\n+        // Union accesses are stable in all contexts except `const fn`.\n+        item.mode != Mode::ConstFn || Self::feature_gate(item.tcx).unwrap()\n+    }\n+\n+    fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {\n+        Some(tcx.features().const_fn_union)\n+    }\n+\n+    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n+        emit_feature_err(\n+            &item.tcx.sess.parse_sess, sym::const_fn_union,\n+            span, GateIssue::Language,\n+            \"unions in const fn are unstable\",\n+        );\n+    }\n+}"}, {"sha": "c61fdf5b970e10f227cbeca50c484fc8665822b3", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 2, "deletions": 335, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/b3e59bb291a0c0de8df0671c7acf87920c168aa5/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3e59bb291a0c0de8df0671c7acf87920c168aa5/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=b3e59bb291a0c0de8df0671c7acf87920c168aa5", "patch": "@@ -1,14 +1,12 @@\n use rustc::hir::{self, def_id::DefId};\n use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext, NonMutatingUseContext};\n use rustc::mir::*;\n-use rustc::session::config::nightly_options;\n use rustc::ty::cast::CastTy;\n use rustc::ty::{self, TyCtxt};\n use rustc_data_structures::bit_set::BitSet;\n use rustc_target::spec::abi::Abi;\n-use syntax::feature_gate::{emit_feature_err, GateIssue};\n use syntax::symbol::sym;\n-use syntax_pos::{Span, Symbol};\n+use syntax_pos::Span;\n \n use std::cell::RefCell;\n use std::fmt;\n@@ -19,6 +17,7 @@ use crate::dataflow as old_dataflow;\n use super::{Item, Qualif, is_lang_panic_fn};\n use super::resolver::{QualifResolver, FlowSensitiveResolver};\n use super::qualifs::{HasMutInterior, NeedsDrop};\n+use super::ops::{self, NonConstOp};\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub enum CheckOpResult {\n@@ -91,43 +90,6 @@ impl fmt::Display for Mode {\n     }\n }\n \n-/// An operation that is not *always* allowed in a const context.\n-pub trait NonConstOp {\n-    /// Whether this operation can be evaluated by miri.\n-    const IS_SUPPORTED_IN_MIRI: bool = true;\n-\n-    /// Returns a boolean indicating whether the feature gate that would allow this operation is\n-    /// enabled, or `None` if such a feature gate does not exist.\n-    fn feature_gate(_tcx: TyCtxt<'tcx>) -> Option<bool> {\n-        None\n-    }\n-\n-    /// Returns `true` if this operation is allowed in the given item.\n-    ///\n-    /// This check should assume that we are not in a non-const `fn`, where all operations are\n-    /// legal.\n-    fn is_allowed_in_item(&self, item: &Item<'_, '_>) -> bool {\n-        Self::feature_gate(item.tcx).unwrap_or(false)\n-    }\n-\n-    fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n-        let mut err = struct_span_err!(\n-            item.tcx.sess,\n-            span,\n-            E0019,\n-            \"{} contains unimplemented expression type\",\n-            item.mode\n-        );\n-        if item.tcx.sess.teach(&err.get_code().unwrap()) {\n-            err.note(\"A function call isn't allowed in the const's initialization expression \\\n-                      because the expression's value must be known at compile-time.\");\n-            err.note(\"Remember: you can't use a function call inside a const's initialization \\\n-                      expression! However, you can use it anywhere else.\");\n-        }\n-        err.emit();\n-    }\n-}\n-\n pub struct Qualifs<'a, 'mir, 'tcx> {\n     has_mut_interior: FlowSensitiveResolver<'a, 'mir, 'tcx, HasMutInterior>,\n     needs_drop: FlowSensitiveResolver<'a, 'mir, 'tcx, NeedsDrop>,\n@@ -622,298 +584,3 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n         }\n     }\n }\n-\n-/// All implementers of `NonConstOp`.\n-pub mod ops {\n-    use super::*;\n-\n-    /// A `Downcast` projection.\n-    #[derive(Debug)]\n-    pub struct Downcast;\n-    impl NonConstOp for Downcast {}\n-\n-    /// A function call where the callee is a pointer.\n-    #[derive(Debug)]\n-    pub struct FnCallIndirect;\n-    impl NonConstOp for FnCallIndirect {\n-        fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n-            let mut err = item.tcx.sess.struct_span_err(\n-                span,\n-                &format!(\"function pointers are not allowed in const fn\"));\n-            err.emit();\n-        }\n-    }\n-\n-    /// A function call where the callee is not marked as `const`.\n-    #[derive(Debug)]\n-    pub struct FnCallNonConst(pub DefId);\n-    impl NonConstOp for FnCallNonConst {\n-        fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n-            let mut err = struct_span_err!(\n-                item.tcx.sess,\n-                span,\n-                E0015,\n-                \"calls in {}s are limited to constant functions, \\\n-                 tuple structs and tuple variants\",\n-                item.mode,\n-            );\n-            err.emit();\n-        }\n-    }\n-\n-    /// A function call where the callee is not a function definition or function pointer, e.g. a\n-    /// closure.\n-    ///\n-    /// This can be subdivided in the future to produce a better error message.\n-    #[derive(Debug)]\n-    pub struct FnCallOther;\n-    impl NonConstOp for FnCallOther {\n-        const IS_SUPPORTED_IN_MIRI: bool = false;\n-    }\n-\n-    /// A call to a `#[unstable]` const fn or `#[rustc_const_unstable]` function.\n-    ///\n-    /// Contains the name of the feature that would allow the use of this function.\n-    #[derive(Debug)]\n-    pub struct FnCallUnstable(pub DefId, pub Symbol);\n-    impl NonConstOp for FnCallUnstable {\n-        fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n-            let FnCallUnstable(def_id, feature) = *self;\n-\n-            let mut err = item.tcx.sess.struct_span_err(span,\n-                &format!(\"`{}` is not yet stable as a const fn\",\n-                        item.tcx.def_path_str(def_id)));\n-            if nightly_options::is_nightly_build() {\n-                help!(&mut err,\n-                      \"add `#![feature({})]` to the \\\n-                       crate attributes to enable\",\n-                      feature);\n-            }\n-            err.emit();\n-        }\n-    }\n-\n-    #[derive(Debug)]\n-    pub struct HeapAllocation;\n-    impl NonConstOp for HeapAllocation {\n-        const IS_SUPPORTED_IN_MIRI: bool = false;\n-\n-        fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n-            let mut err = struct_span_err!(item.tcx.sess, span, E0010,\n-                                           \"allocations are not allowed in {}s\", item.mode);\n-            err.span_label(span, format!(\"allocation not allowed in {}s\", item.mode));\n-            if item.tcx.sess.teach(&err.get_code().unwrap()) {\n-                err.note(\n-                    \"The value of statics and constants must be known at compile time, \\\n-                     and they live for the entire lifetime of a program. Creating a boxed \\\n-                     value allocates memory on the heap at runtime, and therefore cannot \\\n-                     be done at compile time.\"\n-                );\n-            }\n-            err.emit();\n-        }\n-    }\n-\n-    #[derive(Debug)]\n-    pub struct IfOrMatch;\n-    impl NonConstOp for IfOrMatch {}\n-\n-    #[derive(Debug)]\n-    pub struct LiveDrop;\n-    impl NonConstOp for LiveDrop {\n-        fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n-            struct_span_err!(item.tcx.sess, span, E0493,\n-                             \"destructors cannot be evaluated at compile-time\")\n-                .span_label(span, format!(\"{}s cannot evaluate destructors\",\n-                                          item.mode))\n-                .emit();\n-        }\n-    }\n-\n-    #[derive(Debug)]\n-    pub struct Loop;\n-    impl NonConstOp for Loop {}\n-\n-    #[derive(Debug)]\n-    pub struct MutBorrow(pub BorrowKind);\n-    impl NonConstOp for MutBorrow {\n-        fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n-            let kind = self.0;\n-            if let BorrowKind::Mut { .. } = kind {\n-                let mut err = struct_span_err!(item.tcx.sess, span, E0017,\n-                                               \"references in {}s may only refer \\\n-                                                to immutable values\", item.mode);\n-                err.span_label(span, format!(\"{}s require immutable values\",\n-                                                    item.mode));\n-                if item.tcx.sess.teach(&err.get_code().unwrap()) {\n-                    err.note(\"References in statics and constants may only refer \\\n-                              to immutable values.\\n\\n\\\n-                              Statics are shared everywhere, and if they refer to \\\n-                              mutable data one might violate memory safety since \\\n-                              holding multiple mutable references to shared data \\\n-                              is not allowed.\\n\\n\\\n-                              If you really want global mutable state, try using \\\n-                              static mut or a global UnsafeCell.\");\n-                }\n-                err.emit();\n-            } else {\n-                span_err!(item.tcx.sess, span, E0492,\n-                          \"cannot borrow a constant which may contain \\\n-                           interior mutability, create a static instead\");\n-            }\n-        }\n-    }\n-\n-    #[derive(Debug)]\n-    pub struct MutDeref;\n-    impl NonConstOp for MutDeref {}\n-\n-    #[derive(Debug)]\n-    pub struct Panic;\n-    impl NonConstOp for Panic {\n-        fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {\n-            Some(tcx.features().const_panic)\n-        }\n-\n-        fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n-            emit_feature_err(\n-                &item.tcx.sess.parse_sess,\n-                sym::const_panic,\n-                span,\n-                GateIssue::Language,\n-                &format!(\"panicking in {}s is unstable\", item.mode),\n-            );\n-        }\n-    }\n-\n-    #[derive(Debug)]\n-    pub struct RawPtrComparison;\n-    impl NonConstOp for RawPtrComparison {\n-        fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {\n-            Some(tcx.features().const_compare_raw_pointers)\n-        }\n-\n-        fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n-            emit_feature_err(\n-                &item.tcx.sess.parse_sess,\n-                sym::const_compare_raw_pointers,\n-                span,\n-                GateIssue::Language,\n-                &format!(\"comparing raw pointers inside {}\", item.mode),\n-            );\n-        }\n-    }\n-\n-    #[derive(Debug)]\n-    pub struct RawPtrDeref;\n-    impl NonConstOp for RawPtrDeref {\n-        fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {\n-            Some(tcx.features().const_raw_ptr_deref)\n-        }\n-\n-        fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n-            emit_feature_err(\n-                &item.tcx.sess.parse_sess, sym::const_raw_ptr_deref,\n-                span, GateIssue::Language,\n-                &format!(\n-                    \"dereferencing raw pointers in {}s is unstable\",\n-                    item.mode,\n-                ),\n-            );\n-        }\n-    }\n-\n-    #[derive(Debug)]\n-    pub struct RawPtrToIntCast;\n-    impl NonConstOp for RawPtrToIntCast {\n-        fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {\n-            Some(tcx.features().const_raw_ptr_to_usize_cast)\n-        }\n-\n-        fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n-            emit_feature_err(\n-                &item.tcx.sess.parse_sess, sym::const_raw_ptr_to_usize_cast,\n-                span, GateIssue::Language,\n-                &format!(\n-                    \"casting pointers to integers in {}s is unstable\",\n-                    item.mode,\n-                ),\n-            );\n-        }\n-    }\n-\n-    /// An access to a (non-thread-local) `static`.\n-    #[derive(Debug)]\n-    pub struct StaticAccess;\n-    impl NonConstOp for StaticAccess {\n-        fn is_allowed_in_item(&self, item: &Item<'_, '_>) -> bool {\n-            item.mode.is_static()\n-        }\n-\n-        fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n-            let mut err = struct_span_err!(item.tcx.sess, span, E0013,\n-                                            \"{}s cannot refer to statics, use \\\n-                                            a constant instead\", item.mode);\n-            if item.tcx.sess.teach(&err.get_code().unwrap()) {\n-                err.note(\n-                    \"Static and const variables can refer to other const variables. \\\n-                        But a const variable cannot refer to a static variable.\"\n-                );\n-                err.help(\n-                    \"To fix this, the value can be extracted as a const and then used.\"\n-                );\n-            }\n-            err.emit();\n-        }\n-    }\n-\n-    /// An access to a thread-local `static`.\n-    #[derive(Debug)]\n-    pub struct ThreadLocalAccess;\n-    impl NonConstOp for ThreadLocalAccess {\n-        const IS_SUPPORTED_IN_MIRI: bool = false;\n-\n-        fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n-            span_err!(item.tcx.sess, span, E0625,\n-                \"thread-local statics cannot be \\\n-                accessed at compile-time\");\n-        }\n-    }\n-\n-    #[derive(Debug)]\n-    pub struct Transmute;\n-    impl NonConstOp for Transmute {\n-        fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {\n-            Some(tcx.features().const_transmute)\n-        }\n-\n-        fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n-            emit_feature_err(\n-                &item.tcx.sess.parse_sess, sym::const_transmute,\n-                span, GateIssue::Language,\n-                &format!(\"The use of std::mem::transmute() \\\n-                is gated in {}s\", item.mode));\n-        }\n-    }\n-\n-    #[derive(Debug)]\n-    pub struct UnionAccess;\n-    impl NonConstOp for UnionAccess {\n-        fn is_allowed_in_item(&self, item: &Item<'_, '_>) -> bool {\n-            // Union accesses are stable in all contexts except `const fn`.\n-            item.mode != Mode::ConstFn || Self::feature_gate(item.tcx).unwrap()\n-        }\n-\n-        fn feature_gate(tcx: TyCtxt<'_>) -> Option<bool> {\n-            Some(tcx.features().const_fn_union)\n-        }\n-\n-        fn emit_error(&self, item: &Item<'_, '_>, span: Span) {\n-            emit_feature_err(\n-                &item.tcx.sess.parse_sess, sym::const_fn_union,\n-                span, GateIssue::Language,\n-                \"unions in const fn are unstable\",\n-            );\n-        }\n-    }\n-}"}, {"sha": "d9854237eeb8c18dde5a42e47c283c92aa11058f", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b3e59bb291a0c0de8df0671c7acf87920c168aa5/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b3e59bb291a0c0de8df0671c7acf87920c168aa5/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=b3e59bb291a0c0de8df0671c7acf87920c168aa5", "patch": "@@ -34,7 +34,7 @@ use std::usize;\n use rustc::hir::HirId;\n use crate::transform::{MirPass, MirSource};\n use super::promote_consts::{self, Candidate, TempState};\n-use crate::transform::check_consts::validation::{ops, NonConstOp};\n+use crate::transform::check_consts::ops::{self, NonConstOp};\n \n /// What kind of item we are in.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]"}]}