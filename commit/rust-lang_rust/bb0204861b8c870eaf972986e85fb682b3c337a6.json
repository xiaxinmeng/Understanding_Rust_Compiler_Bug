{"sha": "bb0204861b8c870eaf972986e85fb682b3c337a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJiMDIwNDg2MWI4Yzg3MGVhZjk3Mjk4NmU4NWZiNjgyYjNjMzM3YTY=", "commit": {"author": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2021-04-16T18:21:17Z"}, "committer": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2021-04-17T16:55:28Z"}, "message": "rustdoc: change 'cx to 'tcx, to match the struct itself", "tree": {"sha": "dd25f97f85fcac1521cc1685f81c046fc7859747", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd25f97f85fcac1521cc1685f81c046fc7859747"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bb0204861b8c870eaf972986e85fb682b3c337a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bb0204861b8c870eaf972986e85fb682b3c337a6", "html_url": "https://github.com/rust-lang/rust/commit/bb0204861b8c870eaf972986e85fb682b3c337a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bb0204861b8c870eaf972986e85fb682b3c337a6/comments", "author": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21bf8af8739235eda6e19b779bf19cad528f3b92", "url": "https://api.github.com/repos/rust-lang/rust/commits/21bf8af8739235eda6e19b779bf19cad528f3b92", "html_url": "https://github.com/rust-lang/rust/commit/21bf8af8739235eda6e19b779bf19cad528f3b92"}], "stats": {"total": 120, "additions": 60, "deletions": 60}, "files": [{"sha": "c65ad738a9d69991b7201598eb2bf4b86cf39ab4", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/bb0204861b8c870eaf972986e85fb682b3c337a6/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bb0204861b8c870eaf972986e85fb682b3c337a6/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=bb0204861b8c870eaf972986e85fb682b3c337a6", "patch": "@@ -124,10 +124,10 @@ fn comma_sep<T: fmt::Display>(items: impl Iterator<Item = T>) -> impl fmt::Displ\n     })\n }\n \n-crate fn print_generic_bounds<'a, 'cx: 'a>(\n-    cx: &'a Context<'cx>,\n+crate fn print_generic_bounds<'a, 'tcx: 'a>(\n+    cx: &'a Context<'tcx>,\n     bounds: &'a [clean::GenericBound],\n-) -> impl fmt::Display + 'a + Captures<'cx> {\n+) -> impl fmt::Display + 'a + Captures<'tcx> {\n     display_fn(move |f| {\n         let mut bounds_dup = FxHashSet::default();\n \n@@ -144,10 +144,10 @@ crate fn print_generic_bounds<'a, 'cx: 'a>(\n }\n \n impl clean::GenericParamDef {\n-    crate fn print<'a, 'cx: 'a>(\n+    crate fn print<'a, 'tcx: 'a>(\n         &'a self,\n-        cx: &'a Context<'cx>,\n-    ) -> impl fmt::Display + 'a + Captures<'cx> {\n+        cx: &'a Context<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| match self.kind {\n             clean::GenericParamDefKind::Lifetime => write!(f, \"{}\", self.name),\n             clean::GenericParamDefKind::Type { ref bounds, ref default, .. } => {\n@@ -183,10 +183,10 @@ impl clean::GenericParamDef {\n }\n \n impl clean::Generics {\n-    crate fn print<'a, 'cx: 'a>(\n+    crate fn print<'a, 'tcx: 'a>(\n         &'a self,\n-        cx: &'a Context<'cx>,\n-    ) -> impl fmt::Display + 'a + Captures<'cx> {\n+        cx: &'a Context<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| {\n             let real_params =\n                 self.params.iter().filter(|p| !p.is_synthetic_type_param()).collect::<Vec<_>>();\n@@ -205,12 +205,12 @@ impl clean::Generics {\n /// * The Generics from which to emit a where-clause.\n /// * The number of spaces to indent each line with.\n /// * Whether the where-clause needs to add a comma and newline after the last bound.\n-crate fn print_where_clause<'a, 'cx: 'a>(\n+crate fn print_where_clause<'a, 'tcx: 'a>(\n     gens: &'a clean::Generics,\n-    cx: &'a Context<'cx>,\n+    cx: &'a Context<'tcx>,\n     indent: usize,\n     end_newline: bool,\n-) -> impl fmt::Display + 'a + Captures<'cx> {\n+) -> impl fmt::Display + 'a + Captures<'tcx> {\n     display_fn(move |f| {\n         if gens.where_predicates.is_empty() {\n             return Ok(());\n@@ -314,10 +314,10 @@ impl clean::Constant {\n }\n \n impl clean::PolyTrait {\n-    fn print<'a, 'cx: 'a>(\n+    fn print<'a, 'tcx: 'a>(\n         &'a self,\n-        cx: &'a Context<'cx>,\n-    ) -> impl fmt::Display + 'a + Captures<'cx> {\n+        cx: &'a Context<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| {\n             if !self.generic_params.is_empty() {\n                 if f.alternate() {\n@@ -344,10 +344,10 @@ impl clean::PolyTrait {\n }\n \n impl clean::GenericBound {\n-    crate fn print<'a, 'cx: 'a>(\n+    crate fn print<'a, 'tcx: 'a>(\n         &'a self,\n-        cx: &'a Context<'cx>,\n-    ) -> impl fmt::Display + 'a + Captures<'cx> {\n+        cx: &'a Context<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| match self {\n             clean::GenericBound::Outlives(lt) => write!(f, \"{}\", lt.print()),\n             clean::GenericBound::TraitBound(ty, modifier) => {\n@@ -367,10 +367,10 @@ impl clean::GenericBound {\n }\n \n impl clean::GenericArgs {\n-    fn print<'a, 'cx: 'a>(\n+    fn print<'a, 'tcx: 'a>(\n         &'a self,\n-        cx: &'a Context<'cx>,\n-    ) -> impl fmt::Display + 'a + Captures<'cx> {\n+        cx: &'a Context<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| {\n             match self {\n                 clean::GenericArgs::AngleBracketed { args, bindings } => {\n@@ -602,10 +602,10 @@ fn primitive_link(\n }\n \n /// Helper to render type parameters\n-fn tybounds<'a, 'cx: 'a>(\n+fn tybounds<'a, 'tcx: 'a>(\n     param_names: &'a Option<Vec<clean::GenericBound>>,\n-    cx: &'a Context<'cx>,\n-) -> impl fmt::Display + 'a + Captures<'cx> {\n+    cx: &'a Context<'tcx>,\n+) -> impl fmt::Display + 'a + Captures<'tcx> {\n     display_fn(move |f| match *param_names {\n         Some(ref params) => {\n             for param in params {\n@@ -882,20 +882,20 @@ fn fmt_type<'cx>(\n }\n \n impl clean::Type {\n-    crate fn print<'b, 'a: 'b, 'cx: 'a>(\n+    crate fn print<'b, 'a: 'b, 'tcx: 'a>(\n         &'a self,\n-        cx: &'a Context<'cx>,\n-    ) -> impl fmt::Display + 'b + Captures<'cx> {\n+        cx: &'a Context<'tcx>,\n+    ) -> impl fmt::Display + 'b + Captures<'tcx> {\n         display_fn(move |f| fmt_type(self, f, false, cx))\n     }\n }\n \n impl clean::Impl {\n-    crate fn print<'a, 'cx: 'a>(\n+    crate fn print<'a, 'tcx: 'a>(\n         &'a self,\n         use_absolute: bool,\n-        cx: &'a Context<'cx>,\n-    ) -> impl fmt::Display + 'a + Captures<'cx> {\n+        cx: &'a Context<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| {\n             if f.alternate() {\n                 write!(f, \"impl{:#} \", self.generics.print(cx))?;\n@@ -924,10 +924,10 @@ impl clean::Impl {\n }\n \n impl clean::Arguments {\n-    crate fn print<'a, 'cx: 'a>(\n+    crate fn print<'a, 'tcx: 'a>(\n         &'a self,\n-        cx: &'a Context<'cx>,\n-    ) -> impl fmt::Display + 'a + Captures<'cx> {\n+        cx: &'a Context<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| {\n             for (i, input) in self.values.iter().enumerate() {\n                 if !input.name.is_empty() {\n@@ -948,10 +948,10 @@ impl clean::Arguments {\n }\n \n impl clean::FnRetTy {\n-    crate fn print<'a, 'cx: 'a>(\n+    crate fn print<'a, 'tcx: 'a>(\n         &'a self,\n-        cx: &'a Context<'cx>,\n-    ) -> impl fmt::Display + 'a + Captures<'cx> {\n+        cx: &'a Context<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| match self {\n             clean::Return(clean::Tuple(tys)) if tys.is_empty() => Ok(()),\n             clean::Return(ty) if f.alternate() => {\n@@ -964,10 +964,10 @@ impl clean::FnRetTy {\n }\n \n impl clean::BareFunctionDecl {\n-    fn print_hrtb_with_space<'a, 'cx: 'a>(\n+    fn print_hrtb_with_space<'a, 'tcx: 'a>(\n         &'a self,\n-        cx: &'a Context<'cx>,\n-    ) -> impl fmt::Display + 'a + Captures<'cx> {\n+        cx: &'a Context<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| {\n             if !self.generic_params.is_empty() {\n                 write!(f, \"for<{}> \", comma_sep(self.generic_params.iter().map(|g| g.print(cx))))\n@@ -979,10 +979,10 @@ impl clean::BareFunctionDecl {\n }\n \n impl clean::FnDecl {\n-    crate fn print<'b, 'a: 'b, 'cx: 'a>(\n+    crate fn print<'b, 'a: 'b, 'tcx: 'a>(\n         &'a self,\n-        cx: &'a Context<'cx>,\n-    ) -> impl fmt::Display + 'b + Captures<'cx> {\n+        cx: &'a Context<'tcx>,\n+    ) -> impl fmt::Display + 'b + Captures<'tcx> {\n         display_fn(move |f| {\n             let ellipsis = if self.c_variadic { \", ...\" } else { \"\" };\n             if f.alternate() {\n@@ -1011,13 +1011,13 @@ impl clean::FnDecl {\n     /// * `indent`: The number of spaces to indent each successive line with, if line-wrapping is\n     ///   necessary.\n     /// * `asyncness`: Whether the function is async or not.\n-    crate fn full_print<'a, 'cx: 'a>(\n+    crate fn full_print<'a, 'tcx: 'a>(\n         &'a self,\n-        cx: &'a Context<'cx>,\n+        cx: &'a Context<'tcx>,\n         header_len: usize,\n         indent: usize,\n         asyncness: hir::IsAsync,\n-    ) -> impl fmt::Display + 'a + Captures<'cx> {\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| self.inner_full_print(cx, header_len, indent, asyncness, f))\n     }\n \n@@ -1132,11 +1132,11 @@ impl clean::FnDecl {\n }\n \n impl clean::Visibility {\n-    crate fn print_with_space<'a, 'cx: 'a>(\n+    crate fn print_with_space<'a, 'tcx: 'a>(\n         self,\n-        cx: &'a Context<'cx>,\n+        cx: &'a Context<'tcx>,\n         item_did: DefId,\n-    ) -> impl fmt::Display + 'a + Captures<'cx> {\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         let to_print = match self {\n             clean::Public => \"pub \".to_owned(),\n             clean::Inherited => String::new(),\n@@ -1256,10 +1256,10 @@ impl PrintWithSpace for hir::Mutability {\n }\n \n impl clean::Import {\n-    crate fn print<'a, 'cx: 'a>(\n+    crate fn print<'a, 'tcx: 'a>(\n         &'a self,\n-        cx: &'a Context<'cx>,\n-    ) -> impl fmt::Display + 'a + Captures<'cx> {\n+        cx: &'a Context<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| match self.kind {\n             clean::ImportKind::Simple(name) => {\n                 if name == self.source.path.last() {\n@@ -1280,10 +1280,10 @@ impl clean::Import {\n }\n \n impl clean::ImportSource {\n-    crate fn print<'a, 'cx: 'a>(\n+    crate fn print<'a, 'tcx: 'a>(\n         &'a self,\n-        cx: &'a Context<'cx>,\n-    ) -> impl fmt::Display + 'a + Captures<'cx> {\n+        cx: &'a Context<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| match self.did {\n             Some(did) => resolved_path(f, did, &self.path, true, false, cx),\n             _ => {\n@@ -1303,10 +1303,10 @@ impl clean::ImportSource {\n }\n \n impl clean::TypeBinding {\n-    crate fn print<'a, 'cx: 'a>(\n+    crate fn print<'a, 'tcx: 'a>(\n         &'a self,\n-        cx: &'a Context<'cx>,\n-    ) -> impl fmt::Display + 'a + Captures<'cx> {\n+        cx: &'a Context<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| {\n             f.write_str(&*self.name.as_str())?;\n             match self.kind {\n@@ -1347,10 +1347,10 @@ crate fn print_default_space<'a>(v: bool) -> &'a str {\n }\n \n impl clean::GenericArg {\n-    crate fn print<'a, 'cx: 'a>(\n+    crate fn print<'a, 'tcx: 'a>(\n         &'a self,\n-        cx: &'a Context<'cx>,\n-    ) -> impl fmt::Display + 'a + Captures<'cx> {\n+        cx: &'a Context<'tcx>,\n+    ) -> impl fmt::Display + 'a + Captures<'tcx> {\n         display_fn(move |f| match self {\n             clean::GenericArg::Lifetime(lt) => fmt::Display::fmt(&lt.print(), f),\n             clean::GenericArg::Type(ty) => fmt::Display::fmt(&ty.print(cx), f),"}]}