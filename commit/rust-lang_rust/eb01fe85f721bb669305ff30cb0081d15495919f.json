{"sha": "eb01fe85f721bb669305ff30cb0081d15495919f", "node_id": "C_kwDOAAsO6NoAKGViMDFmZTg1ZjcyMWJiNjY5MzA1ZmYzMGNiMDA4MWQxNTQ5NTkxOWY", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-02-01T15:08:04Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-01T15:08:04Z"}, "message": "Rollup merge of #93267 - lcnr:auto-trait-lint, r=nikomatsakis\n\nimplement a lint for suspicious auto trait impls\n\ncc https://github.com/rust-lang/rust/pull/85048#issuecomment-1019805102\n\nr? ``@nikomatsakis``", "tree": {"sha": "b590ff9e86a417f4fb3d041a7a621b7fccb297d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b590ff9e86a417f4fb3d041a7a621b7fccb297d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb01fe85f721bb669305ff30cb0081d15495919f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh+UzVCRBK7hj4Ov3rIwAApO8IALE9po1HJh3qQQSN8DsO87ni\nGKEW4k5l96k3ORPZ++Warq/QrDr7Vxl5kNmcY+hZQ7PCl/965T8GbGfMM3vnJvJx\naf//c9+rT7csaAp8QGjVskizepXXj7xy2sBdDiUk9fc3rzEV43C1zVyM8zSyGYL1\nOFBhlSRMhvqgtrfQ3wBay3iLjZC4NNAHtsbY9UhvSxdm1PBqE44XVU/PTrn2X/ob\ndwSOHYPTeMVa3jsc3YQC76ffc4QL5Bw0jrq24PdikoxiN5iLG4UfBzDcLzCuGhf3\nHOgVa6z5Y+AO+VhlMEb5AssG+88OsVoeSuop27LYmPTKt6xlIYTeWehqSXrQZDU=\n=J0br\n-----END PGP SIGNATURE-----\n", "payload": "tree b590ff9e86a417f4fb3d041a7a621b7fccb297d9\nparent 741b62af0749ddf88ebbd7cad6ec7a15ab1fc1cb\nparent 94b0a7b8e9affe00c83c7afdb725edd530d855ee\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1643728084 +0100\ncommitter GitHub <noreply@github.com> 1643728084 +0100\n\nRollup merge of #93267 - lcnr:auto-trait-lint, r=nikomatsakis\n\nimplement a lint for suspicious auto trait impls\n\ncc https://github.com/rust-lang/rust/pull/85048#issuecomment-1019805102\n\nr? ``@nikomatsakis``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb01fe85f721bb669305ff30cb0081d15495919f", "html_url": "https://github.com/rust-lang/rust/commit/eb01fe85f721bb669305ff30cb0081d15495919f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb01fe85f721bb669305ff30cb0081d15495919f/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "741b62af0749ddf88ebbd7cad6ec7a15ab1fc1cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/741b62af0749ddf88ebbd7cad6ec7a15ab1fc1cb", "html_url": "https://github.com/rust-lang/rust/commit/741b62af0749ddf88ebbd7cad6ec7a15ab1fc1cb"}, {"sha": "94b0a7b8e9affe00c83c7afdb725edd530d855ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/94b0a7b8e9affe00c83c7afdb725edd530d855ee", "html_url": "https://github.com/rust-lang/rust/commit/94b0a7b8e9affe00c83c7afdb725edd530d855ee"}], "stats": {"total": 479, "additions": 421, "deletions": 58}, "files": [{"sha": "cf86c450a5bccff15950f986d196ee1e4f46b248", "filename": "compiler/rustc_index/src/bit_set.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb01fe85f721bb669305ff30cb0081d15495919f/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01fe85f721bb669305ff30cb0081d15495919f/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs?ref=eb01fe85f721bb669305ff30cb0081d15495919f", "patch": "@@ -938,6 +938,12 @@ pub struct GrowableBitSet<T: Idx> {\n     bit_set: BitSet<T>,\n }\n \n+impl<T: Idx> Default for GrowableBitSet<T> {\n+    fn default() -> Self {\n+        GrowableBitSet::new_empty()\n+    }\n+}\n+\n impl<T: Idx> GrowableBitSet<T> {\n     /// Ensure that the set can hold at least `min_domain_size` elements.\n     pub fn ensure(&mut self, min_domain_size: usize) {"}, {"sha": "f4eba25475eee0b43bc4abb2632d51cefb479c27", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/eb01fe85f721bb669305ff30cb0081d15495919f/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01fe85f721bb669305ff30cb0081d15495919f/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=eb01fe85f721bb669305ff30cb0081d15495919f", "patch": "@@ -1793,6 +1793,10 @@ declare_lint! {\n     Warn,\n     \"detects name collision with an existing but unstable method\",\n     @future_incompatible = FutureIncompatibleInfo {\n+        reason: FutureIncompatibilityReason::Custom(\n+            \"once this associated item is added to the standard library, \\\n+             the ambiguity may cause an error or change in behavior!\"\n+        ),\n         reference: \"issue #48919 <https://github.com/rust-lang/rust/issues/48919>\",\n         // Note: this item represents future incompatibility of all unstable functions in the\n         //       standard library, and thus should never be removed or changed to an error.\n@@ -2335,6 +2339,10 @@ declare_lint! {\n     Warn,\n     \"reservation of a two-phased borrow conflicts with other shared borrows\",\n     @future_incompatible = FutureIncompatibleInfo {\n+        reason: FutureIncompatibilityReason::Custom(\n+            \"this borrowing pattern was not meant to be accepted, \\\n+            and may become a hard error in the future\"\n+        ),\n         reference: \"issue #59159 <https://github.com/rust-lang/rust/issues/59159>\",\n     };\n }\n@@ -3046,6 +3054,7 @@ declare_lint_pass! {\n         DEREF_INTO_DYN_SUPERTRAIT,\n         DEPRECATED_CFG_ATTR_CRATE_TYPE_NAME,\n         DUPLICATE_MACRO_ATTRIBUTES,\n+        SUSPICIOUS_AUTO_TRAIT_IMPLS,\n     ]\n }\n \n@@ -3622,3 +3631,37 @@ declare_lint! {\n     Warn,\n     \"duplicated attribute\"\n }\n+\n+declare_lint! {\n+    /// The `suspicious_auto_trait_impls` lint checks for potentially incorrect\n+    /// implementations of auto traits.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust\n+    /// struct Foo<T>(T);\n+    ///\n+    /// unsafe impl<T> Send for Foo<*const T> {}\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// A type can implement auto traits, e.g. `Send`, `Sync` and `Unpin`,\n+    /// in two different ways: either by writing an explicit impl or if\n+    /// all fields of the type implement that auto trait.\n+    ///\n+    /// The compiler disables the automatic implementation if an explicit one\n+    /// exists for given type constructor. The exact rules governing this\n+    /// are currently unsound and quite subtle and and will be modified in the future.\n+    /// This change will cause the automatic implementation to be disabled in more\n+    /// cases, potentially breaking some code.\n+    pub SUSPICIOUS_AUTO_TRAIT_IMPLS,\n+    Warn,\n+    \"the rules governing auto traits will change in the future\",\n+    @future_incompatible = FutureIncompatibleInfo {\n+        reason: FutureIncompatibilityReason::FutureReleaseSemanticsChange,\n+        reference: \"issue #93367 <https://github.com/rust-lang/rust/issues/93367>\",\n+    };\n+}"}, {"sha": "1f834b7212fe58c697561b8e505b80e05c44c979", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/eb01fe85f721bb669305ff30cb0081d15495919f/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01fe85f721bb669305ff30cb0081d15495919f/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=eb01fe85f721bb669305ff30cb0081d15495919f", "patch": "@@ -163,12 +163,17 @@ pub enum FutureIncompatibilityReason {\n     /// This will be an error in a future release, and\n     /// Cargo should create a report even for dependencies\n     FutureReleaseErrorReportNow,\n+    /// Code that changes meaning in some way in a\n+    /// future release.\n+    FutureReleaseSemanticsChange,\n     /// Previously accepted code that will become an\n     /// error in the provided edition\n     EditionError(Edition),\n     /// Code that changes meaning in some way in\n     /// the provided edition\n     EditionSemanticsChange(Edition),\n+    /// A custom reason.\n+    Custom(&'static str),\n }\n \n impl FutureIncompatibilityReason {"}, {"sha": "17c77c1bbd891367b458576610f7c86d96b046b2", "filename": "compiler/rustc_middle/src/lint.rs", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/eb01fe85f721bb669305ff30cb0081d15495919f/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01fe85f721bb669305ff30cb0081d15495919f/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flint.rs?ref=eb01fe85f721bb669305ff30cb0081d15495919f", "patch": "@@ -221,7 +221,6 @@ pub fn struct_lint_level<'s, 'd>(\n         decorate: Box<dyn for<'b> FnOnce(LintDiagnosticBuilder<'b>) + 'd>,\n     ) {\n         // Check for future incompatibility lints and issue a stronger warning.\n-        let lint_id = LintId::of(lint);\n         let future_incompatible = lint.future_incompatible;\n \n         let has_future_breakage = future_incompatible.map_or(\n@@ -345,31 +344,29 @@ pub fn struct_lint_level<'s, 'd>(\n         err.code(DiagnosticId::Lint { name, has_future_breakage, is_force_warn });\n \n         if let Some(future_incompatible) = future_incompatible {\n-            let explanation = if lint_id == LintId::of(builtin::UNSTABLE_NAME_COLLISIONS) {\n-                \"once this associated item is added to the standard library, the ambiguity may \\\n-                 cause an error or change in behavior!\"\n-                    .to_owned()\n-            } else if lint_id == LintId::of(builtin::MUTABLE_BORROW_RESERVATION_CONFLICT) {\n-                \"this borrowing pattern was not meant to be accepted, and may become a hard error \\\n-                 in the future\"\n-                    .to_owned()\n-            } else if let FutureIncompatibilityReason::EditionError(edition) =\n-                future_incompatible.reason\n-            {\n-                let current_edition = sess.edition();\n-                format!(\n-                    \"this is accepted in the current edition (Rust {}) but is a hard error in Rust {}!\",\n-                    current_edition, edition\n-                )\n-            } else if let FutureIncompatibilityReason::EditionSemanticsChange(edition) =\n-                future_incompatible.reason\n-            {\n-                format!(\"this changes meaning in Rust {}\", edition)\n-            } else {\n-                \"this was previously accepted by the compiler but is being phased out; \\\n-                 it will become a hard error in a future release!\"\n-                    .to_owned()\n+            let explanation = match future_incompatible.reason {\n+                FutureIncompatibilityReason::FutureReleaseError\n+                | FutureIncompatibilityReason::FutureReleaseErrorReportNow => {\n+                    \"this was previously accepted by the compiler but is being phased out; \\\n+                         it will become a hard error in a future release!\"\n+                        .to_owned()\n+                }\n+                FutureIncompatibilityReason::FutureReleaseSemanticsChange => {\n+                    \"this will change its meaning in a future release!\".to_owned()\n+                }\n+                FutureIncompatibilityReason::EditionError(edition) => {\n+                    let current_edition = sess.edition();\n+                    format!(\n+                        \"this is accepted in the current edition (Rust {}) but is a hard error in Rust {}!\",\n+                        current_edition, edition\n+                    )\n+                }\n+                FutureIncompatibilityReason::EditionSemanticsChange(edition) => {\n+                    format!(\"this changes meaning in Rust {}\", edition)\n+                }\n+                FutureIncompatibilityReason::Custom(reason) => reason.to_owned(),\n             };\n+\n             if future_incompatible.explain_reason {\n                 err.warn(&explanation);\n             }"}, {"sha": "9e32c0162e6178e45a92ed6925585140916519f7", "filename": "compiler/rustc_middle/src/ty/trait_def.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/eb01fe85f721bb669305ff30cb0081d15495919f/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01fe85f721bb669305ff30cb0081d15495919f/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftrait_def.rs?ref=eb01fe85f721bb669305ff30cb0081d15495919f", "patch": "@@ -144,6 +144,23 @@ impl<'tcx> TyCtxt<'tcx> {\n         });\n     }\n \n+    pub fn non_blanket_impls_for_ty(\n+        self,\n+        def_id: DefId,\n+        self_ty: Ty<'tcx>,\n+    ) -> impl Iterator<Item = DefId> + 'tcx {\n+        let impls = self.trait_impls_of(def_id);\n+        if let Some(simp) =\n+            fast_reject::simplify_type(self, self_ty, SimplifyParams::No, StripReferences::No)\n+        {\n+            if let Some(impls) = impls.non_blanket_impls.get(&simp) {\n+                return impls.iter().copied();\n+            }\n+        }\n+\n+        [].iter().copied()\n+    }\n+\n     /// Applies function to every impl that could possibly match the self type `self_ty` and returns\n     /// the first non-none value.\n     pub fn find_map_relevant_impl<T, F: FnMut(DefId) -> Option<T>>("}, {"sha": "777bd640669ce8f1c33d8e192457a7925dd86847", "filename": "compiler/rustc_typeck/src/coherence/orphan.rs", "status": "modified", "additions": 210, "deletions": 3, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/eb01fe85f721bb669305ff30cb0081d15495919f/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01fe85f721bb669305ff30cb0081d15495919f/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcoherence%2Forphan.rs?ref=eb01fe85f721bb669305ff30cb0081d15495919f", "patch": "@@ -1,24 +1,33 @@\n //! Orphan checker: every impl either implements a trait defined in this\n //! crate or pertains to a type defined in this crate.\n \n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_errors::ErrorReported;\n use rustc_hir as hir;\n+use rustc_index::bit_set::GrowableBitSet;\n use rustc_infer::infer::TyCtxtInferExt;\n-use rustc_middle::ty::{self, TyCtxt};\n-use rustc_span::def_id::LocalDefId;\n+use rustc_middle::ty::subst::{GenericArg, InternalSubsts};\n+use rustc_middle::ty::{self, ImplPolarity, Ty, TyCtxt, TypeFoldable, TypeVisitor};\n+use rustc_session::lint;\n+use rustc_span::def_id::{DefId, LocalDefId};\n use rustc_span::Span;\n use rustc_trait_selection::traits;\n+use std::ops::ControlFlow;\n \n pub(super) fn orphan_check_crate(tcx: TyCtxt<'_>, (): ()) -> &[LocalDefId] {\n     let mut errors = Vec::new();\n-    for (_trait, impls_of_trait) in tcx.all_local_trait_impls(()) {\n+    for (&trait_def_id, impls_of_trait) in tcx.all_local_trait_impls(()) {\n         for &impl_of_trait in impls_of_trait {\n             match orphan_check_impl(tcx, impl_of_trait) {\n                 Ok(()) => {}\n                 Err(ErrorReported) => errors.push(impl_of_trait),\n             }\n         }\n+\n+        if tcx.trait_is_auto(trait_def_id) {\n+            lint_auto_trait_impls(tcx, trait_def_id, impls_of_trait);\n+        }\n     }\n     tcx.arena.alloc_slice(&errors)\n }\n@@ -265,3 +274,201 @@ fn emit_orphan_check_error<'tcx>(\n \n     Err(ErrorReported)\n }\n+\n+#[derive(Default)]\n+struct AreUniqueParamsVisitor {\n+    seen: GrowableBitSet<u32>,\n+}\n+\n+#[derive(Copy, Clone)]\n+enum NotUniqueParam<'tcx> {\n+    DuplicateParam(GenericArg<'tcx>),\n+    NotParam(GenericArg<'tcx>),\n+}\n+\n+impl<'tcx> TypeVisitor<'tcx> for AreUniqueParamsVisitor {\n+    type BreakTy = NotUniqueParam<'tcx>;\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        match t.kind() {\n+            ty::Param(p) => {\n+                if self.seen.insert(p.index) {\n+                    ControlFlow::CONTINUE\n+                } else {\n+                    ControlFlow::Break(NotUniqueParam::DuplicateParam(t.into()))\n+                }\n+            }\n+            _ => ControlFlow::Break(NotUniqueParam::NotParam(t.into())),\n+        }\n+    }\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        match r {\n+            ty::ReEarlyBound(p) => {\n+                if self.seen.insert(p.index) {\n+                    ControlFlow::CONTINUE\n+                } else {\n+                    ControlFlow::Break(NotUniqueParam::DuplicateParam(r.into()))\n+                }\n+            }\n+            _ => ControlFlow::Break(NotUniqueParam::NotParam(r.into())),\n+        }\n+    }\n+    fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        match c.val {\n+            ty::ConstKind::Param(p) => {\n+                if self.seen.insert(p.index) {\n+                    ControlFlow::CONTINUE\n+                } else {\n+                    ControlFlow::Break(NotUniqueParam::DuplicateParam(c.into()))\n+                }\n+            }\n+            _ => ControlFlow::Break(NotUniqueParam::NotParam(c.into())),\n+        }\n+    }\n+}\n+\n+/// Lint impls of auto traits if they are likely to have\n+/// unsound or surprising effects on auto impls.\n+fn lint_auto_trait_impls(tcx: TyCtxt<'_>, trait_def_id: DefId, impls: &[LocalDefId]) {\n+    let mut non_covering_impls = Vec::new();\n+    for &impl_def_id in impls {\n+        let trait_ref = tcx.impl_trait_ref(impl_def_id).unwrap();\n+        if trait_ref.references_error() {\n+            return;\n+        }\n+\n+        if tcx.impl_polarity(impl_def_id) != ImplPolarity::Positive {\n+            return;\n+        }\n+\n+        assert_eq!(trait_ref.substs.len(), 1);\n+        let self_ty = trait_ref.self_ty();\n+        let (self_type_did, substs) = match self_ty.kind() {\n+            ty::Adt(def, substs) => (def.did, substs),\n+            _ => {\n+                // FIXME: should also lint for stuff like `&i32` but\n+                // considering that auto traits are unstable, that\n+                // isn't too important for now as this only affects\n+                // crates using `nightly`, and std.\n+                continue;\n+            }\n+        };\n+\n+        // Impls which completely cover a given root type are fine as they\n+        // disable auto impls entirely. So only lint if the substs\n+        // are not a permutation of the identity substs.\n+        match substs.visit_with(&mut AreUniqueParamsVisitor::default()) {\n+            ControlFlow::Continue(()) => {} // ok\n+            ControlFlow::Break(arg) => {\n+                // Ideally:\n+                //\n+                // - compute the requirements for the auto impl candidate\n+                // - check whether these are implied by the non covering impls\n+                // - if not, emit the lint\n+                //\n+                // What we do here is a bit simpler:\n+                //\n+                // - badly check if an auto impl candidate definitely does not apply\n+                //   for the given simplified type\n+                // - if so, do not lint\n+                if fast_reject_auto_impl(tcx, trait_def_id, self_ty) {\n+                    // ok\n+                } else {\n+                    non_covering_impls.push((impl_def_id, self_type_did, arg));\n+                }\n+            }\n+        }\n+    }\n+\n+    for &(impl_def_id, self_type_did, arg) in &non_covering_impls {\n+        tcx.struct_span_lint_hir(\n+            lint::builtin::SUSPICIOUS_AUTO_TRAIT_IMPLS,\n+            tcx.hir().local_def_id_to_hir_id(impl_def_id),\n+            tcx.def_span(impl_def_id),\n+            |err| {\n+                let mut err = err.build(&format!(\n+                    \"cross-crate traits with a default impl, like `{}`, \\\n+                         should not be specialized\",\n+                    tcx.def_path_str(trait_def_id),\n+                ));\n+                let item_span = tcx.def_span(self_type_did);\n+                let self_descr = tcx.def_kind(self_type_did).descr(self_type_did);\n+                err.span_note(\n+                    item_span,\n+                    &format!(\n+                        \"try using the same sequence of generic parameters as the {} definition\",\n+                        self_descr,\n+                    ),\n+                );\n+                match arg {\n+                    NotUniqueParam::DuplicateParam(arg) => {\n+                        err.note(&format!(\"`{}` is mentioned multiple times\", arg));\n+                    }\n+                    NotUniqueParam::NotParam(arg) => {\n+                        err.note(&format!(\"`{}` is not a generic parameter\", arg));\n+                    }\n+                }\n+                err.emit();\n+            },\n+        );\n+    }\n+}\n+\n+fn fast_reject_auto_impl<'tcx>(tcx: TyCtxt<'tcx>, trait_def_id: DefId, self_ty: Ty<'tcx>) -> bool {\n+    struct DisableAutoTraitVisitor<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+        trait_def_id: DefId,\n+        self_ty_root: Ty<'tcx>,\n+        seen: FxHashSet<DefId>,\n+    }\n+\n+    impl<'tcx> TypeVisitor<'tcx> for DisableAutoTraitVisitor<'tcx> {\n+        type BreakTy = ();\n+        fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+            let tcx = self.tcx;\n+            if t != self.self_ty_root {\n+                for impl_def_id in tcx.non_blanket_impls_for_ty(self.trait_def_id, t) {\n+                    match tcx.impl_polarity(impl_def_id) {\n+                        ImplPolarity::Negative => return ControlFlow::BREAK,\n+                        ImplPolarity::Reservation => {}\n+                        // FIXME(@lcnr): That's probably not good enough, idk\n+                        //\n+                        // We might just want to take the rustdoc code and somehow avoid\n+                        // explicit impls for `Self`.\n+                        ImplPolarity::Positive => return ControlFlow::CONTINUE,\n+                    }\n+                }\n+            }\n+\n+            match t.kind() {\n+                ty::Adt(def, substs) => {\n+                    // @lcnr: This is the only place where cycles can happen. We avoid this\n+                    // by only visiting each `DefId` once.\n+                    //\n+                    // This will be is incorrect in subtle cases, but I don't care :)\n+                    if self.seen.insert(def.did) {\n+                        for ty in def.all_fields().map(|field| field.ty(tcx, substs)) {\n+                            ty.visit_with(self)?;\n+                        }\n+                    }\n+\n+                    ControlFlow::CONTINUE\n+                }\n+                _ => t.super_visit_with(self),\n+            }\n+        }\n+    }\n+\n+    let self_ty_root = match self_ty.kind() {\n+        ty::Adt(def, _) => tcx.mk_adt(def, InternalSubsts::identity_for_item(tcx, def.did)),\n+        _ => unimplemented!(\"unexpected self ty {:?}\", self_ty),\n+    };\n+\n+    self_ty_root\n+        .visit_with(&mut DisableAutoTraitVisitor {\n+            tcx,\n+            self_ty_root,\n+            trait_def_id,\n+            seen: FxHashSet::default(),\n+        })\n+        .is_break()\n+}"}, {"sha": "1026a35a455acd0a2224208934145eed827cef39", "filename": "src/test/ui/auto-traits/suspicious-impls-lint.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/eb01fe85f721bb669305ff30cb0081d15495919f/src%2Ftest%2Fui%2Fauto-traits%2Fsuspicious-impls-lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01fe85f721bb669305ff30cb0081d15495919f/src%2Ftest%2Fui%2Fauto-traits%2Fsuspicious-impls-lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fauto-traits%2Fsuspicious-impls-lint.rs?ref=eb01fe85f721bb669305ff30cb0081d15495919f", "patch": "@@ -0,0 +1,34 @@\n+#![deny(suspicious_auto_trait_impls)]\n+\n+struct MayImplementSendOk<T>(T);\n+unsafe impl<T: Send> Send for MayImplementSendOk<T> {} // ok\n+\n+struct MayImplementSendErr<T>(T);\n+unsafe impl<T: Send> Send for MayImplementSendErr<&T> {}\n+//~^ ERROR\n+//~| WARNING this will change its meaning\n+\n+struct ContainsNonSendDirect<T>(*const T);\n+unsafe impl<T: Send> Send for ContainsNonSendDirect<&T> {} // ok\n+\n+struct ContainsPtr<T>(*const T);\n+struct ContainsIndirectNonSend<T>(ContainsPtr<T>);\n+unsafe impl<T: Send> Send for ContainsIndirectNonSend<&T> {} // ok\n+\n+struct ContainsVec<T>(Vec<T>);\n+unsafe impl Send for ContainsVec<i32> {}\n+//~^ ERROR\n+//~| WARNING this will change its meaning\n+\n+struct TwoParams<T, U>(T, U);\n+unsafe impl<T: Send, U: Send> Send for TwoParams<T, U> {} // ok\n+\n+struct TwoParamsFlipped<T, U>(T, U);\n+unsafe impl<T: Send, U: Send> Send for TwoParamsFlipped<U, T> {} // ok\n+\n+struct TwoParamsSame<T, U>(T, U);\n+unsafe impl<T: Send> Send for TwoParamsSame<T, T> {}\n+//~^ ERROR\n+//~| WARNING this will change its meaning\n+\n+fn main() {}"}, {"sha": "f91aa862271d365eee21687a7c43e5ddc0402015", "filename": "src/test/ui/auto-traits/suspicious-impls-lint.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/eb01fe85f721bb669305ff30cb0081d15495919f/src%2Ftest%2Fui%2Fauto-traits%2Fsuspicious-impls-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eb01fe85f721bb669305ff30cb0081d15495919f/src%2Ftest%2Fui%2Fauto-traits%2Fsuspicious-impls-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fauto-traits%2Fsuspicious-impls-lint.stderr?ref=eb01fe85f721bb669305ff30cb0081d15495919f", "patch": "@@ -0,0 +1,52 @@\n+error: cross-crate traits with a default impl, like `Send`, should not be specialized\n+  --> $DIR/suspicious-impls-lint.rs:7:1\n+   |\n+LL | unsafe impl<T: Send> Send for MayImplementSendErr<&T> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/suspicious-impls-lint.rs:1:9\n+   |\n+LL | #![deny(suspicious_auto_trait_impls)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = warning: this will change its meaning in a future release!\n+   = note: for more information, see issue #93367 <https://github.com/rust-lang/rust/issues/93367>\n+note: try using the same sequence of generic parameters as the struct definition\n+  --> $DIR/suspicious-impls-lint.rs:6:1\n+   |\n+LL | struct MayImplementSendErr<T>(T);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: `&T` is not a generic parameter\n+\n+error: cross-crate traits with a default impl, like `Send`, should not be specialized\n+  --> $DIR/suspicious-impls-lint.rs:19:1\n+   |\n+LL | unsafe impl Send for ContainsVec<i32> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = warning: this will change its meaning in a future release!\n+   = note: for more information, see issue #93367 <https://github.com/rust-lang/rust/issues/93367>\n+note: try using the same sequence of generic parameters as the struct definition\n+  --> $DIR/suspicious-impls-lint.rs:18:1\n+   |\n+LL | struct ContainsVec<T>(Vec<T>);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: `i32` is not a generic parameter\n+\n+error: cross-crate traits with a default impl, like `Send`, should not be specialized\n+  --> $DIR/suspicious-impls-lint.rs:30:1\n+   |\n+LL | unsafe impl<T: Send> Send for TwoParamsSame<T, T> {}\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = warning: this will change its meaning in a future release!\n+   = note: for more information, see issue #93367 <https://github.com/rust-lang/rust/issues/93367>\n+note: try using the same sequence of generic parameters as the struct definition\n+  --> $DIR/suspicious-impls-lint.rs:29:1\n+   |\n+LL | struct TwoParamsSame<T, U>(T, U);\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: `T` is mentioned multiple times\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "cc75cd4909a234d734a36f7cbbeb0647228fdfc8", "filename": "src/test/ui/typeck/typeck-default-trait-impl-cross-crate-coherence.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eb01fe85f721bb669305ff30cb0081d15495919f/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-default-trait-impl-cross-crate-coherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01fe85f721bb669305ff30cb0081d15495919f/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-default-trait-impl-cross-crate-coherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-default-trait-impl-cross-crate-coherence.rs?ref=eb01fe85f721bb669305ff30cb0081d15495919f", "patch": "@@ -1,4 +1,5 @@\n // aux-build:tdticc_coherence_lib.rs\n+#![allow(suspicious_auto_trait_impls)]\n \n // Test that we do not consider associated types to be sendable without\n // some applicable trait bound (and we don't ICE)."}, {"sha": "cf5c15df7051cee43b705213b501dd19fdea6d8d", "filename": "src/test/ui/typeck/typeck-default-trait-impl-cross-crate-coherence.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/eb01fe85f721bb669305ff30cb0081d15495919f/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-default-trait-impl-cross-crate-coherence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eb01fe85f721bb669305ff30cb0081d15495919f/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-default-trait-impl-cross-crate-coherence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck-default-trait-impl-cross-crate-coherence.stderr?ref=eb01fe85f721bb669305ff30cb0081d15495919f", "patch": "@@ -1,5 +1,5 @@\n error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n-  --> $DIR/typeck-default-trait-impl-cross-crate-coherence.rs:13:1\n+  --> $DIR/typeck-default-trait-impl-cross-crate-coherence.rs:14:1\n    |\n LL | impl DefaultedTrait for (A,) { }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^----\n@@ -10,7 +10,7 @@ LL | impl DefaultedTrait for (A,) { }\n    = note: define and implement a trait or new type instead\n \n error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n-  --> $DIR/typeck-default-trait-impl-cross-crate-coherence.rs:16:1\n+  --> $DIR/typeck-default-trait-impl-cross-crate-coherence.rs:17:1\n    |\n LL | impl !DefaultedTrait for (B,) { }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^----\n@@ -21,13 +21,13 @@ LL | impl !DefaultedTrait for (B,) { }\n    = note: define and implement a trait or new type instead\n \n error[E0321]: cross-crate traits with a default impl, like `DefaultedTrait`, can only be implemented for a struct/enum type defined in the current crate\n-  --> $DIR/typeck-default-trait-impl-cross-crate-coherence.rs:20:1\n+  --> $DIR/typeck-default-trait-impl-cross-crate-coherence.rs:21:1\n    |\n LL | impl DefaultedTrait for Box<C> { }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ can't implement cross-crate trait for type in another crate\n \n error[E0117]: only traits defined in the current crate can be implemented for arbitrary types\n-  --> $DIR/typeck-default-trait-impl-cross-crate-coherence.rs:21:1\n+  --> $DIR/typeck-default-trait-impl-cross-crate-coherence.rs:22:1\n    |\n LL | impl DefaultedTrait for lib::Something<C> { }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^-----------------"}, {"sha": "514fb25c8cfd823bfacd62b2babbfcd3d05e2a22", "filename": "src/tools/clippy/tests/ui/non_send_fields_in_send_ty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eb01fe85f721bb669305ff30cb0081d15495919f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fnon_send_fields_in_send_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb01fe85f721bb669305ff30cb0081d15495919f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fnon_send_fields_in_send_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fnon_send_fields_in_send_ty.rs?ref=eb01fe85f721bb669305ff30cb0081d15495919f", "patch": "@@ -1,4 +1,5 @@\n #![warn(clippy::non_send_fields_in_send_ty)]\n+#![allow(suspicious_auto_trait_impls)]\n #![feature(extern_types)]\n \n use std::cell::UnsafeCell;"}, {"sha": "b6c904a147a5f4da727b9e75b70c94ced79ad607", "filename": "src/tools/clippy/tests/ui/non_send_fields_in_send_ty.stderr", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/eb01fe85f721bb669305ff30cb0081d15495919f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fnon_send_fields_in_send_ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eb01fe85f721bb669305ff30cb0081d15495919f/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fnon_send_fields_in_send_ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fnon_send_fields_in_send_ty.stderr?ref=eb01fe85f721bb669305ff30cb0081d15495919f", "patch": "@@ -1,167 +1,167 @@\n error: some fields in `RingBuffer<T>` are not safe to be sent to another thread\n-  --> $DIR/non_send_fields_in_send_ty.rs:16:1\n+  --> $DIR/non_send_fields_in_send_ty.rs:17:1\n    |\n LL | unsafe impl<T> Send for RingBuffer<T> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::non-send-fields-in-send-ty` implied by `-D warnings`\n note: it is not safe to send field `data` to another thread\n-  --> $DIR/non_send_fields_in_send_ty.rs:11:5\n+  --> $DIR/non_send_fields_in_send_ty.rs:12:5\n    |\n LL |     data: Vec<UnsafeCell<T>>,\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: add bounds on type parameter `T` that satisfy `Vec<UnsafeCell<T>>: Send`\n \n error: some fields in `MvccRwLock<T>` are not safe to be sent to another thread\n-  --> $DIR/non_send_fields_in_send_ty.rs:24:1\n+  --> $DIR/non_send_fields_in_send_ty.rs:25:1\n    |\n LL | unsafe impl<T> Send for MvccRwLock<T> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: it is not safe to send field `lock` to another thread\n-  --> $DIR/non_send_fields_in_send_ty.rs:21:5\n+  --> $DIR/non_send_fields_in_send_ty.rs:22:5\n    |\n LL |     lock: Mutex<Box<T>>,\n    |     ^^^^^^^^^^^^^^^^^^^\n    = help: add bounds on type parameter `T` that satisfy `Mutex<Box<T>>: Send`\n \n error: some fields in `ArcGuard<RC, T>` are not safe to be sent to another thread\n-  --> $DIR/non_send_fields_in_send_ty.rs:32:1\n+  --> $DIR/non_send_fields_in_send_ty.rs:33:1\n    |\n LL | unsafe impl<RC, T: Send> Send for ArcGuard<RC, T> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: it is not safe to send field `head` to another thread\n-  --> $DIR/non_send_fields_in_send_ty.rs:29:5\n+  --> $DIR/non_send_fields_in_send_ty.rs:30:5\n    |\n LL |     head: Arc<RC>,\n    |     ^^^^^^^^^^^^^\n    = help: add bounds on type parameter `RC` that satisfy `Arc<RC>: Send`\n \n error: some fields in `DeviceHandle<T>` are not safe to be sent to another thread\n-  --> $DIR/non_send_fields_in_send_ty.rs:48:1\n+  --> $DIR/non_send_fields_in_send_ty.rs:49:1\n    |\n LL | unsafe impl<T: UsbContext> Send for DeviceHandle<T> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: it is not safe to send field `context` to another thread\n-  --> $DIR/non_send_fields_in_send_ty.rs:44:5\n+  --> $DIR/non_send_fields_in_send_ty.rs:45:5\n    |\n LL |     context: T,\n    |     ^^^^^^^^^^\n    = help: add `T: Send` bound in `Send` impl\n \n error: some fields in `NoGeneric` are not safe to be sent to another thread\n-  --> $DIR/non_send_fields_in_send_ty.rs:55:1\n+  --> $DIR/non_send_fields_in_send_ty.rs:56:1\n    |\n LL | unsafe impl Send for NoGeneric {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: it is not safe to send field `rc_is_not_send` to another thread\n-  --> $DIR/non_send_fields_in_send_ty.rs:52:5\n+  --> $DIR/non_send_fields_in_send_ty.rs:53:5\n    |\n LL |     rc_is_not_send: Rc<String>,\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: use a thread-safe type that implements `Send`\n \n error: some fields in `MultiField<T>` are not safe to be sent to another thread\n-  --> $DIR/non_send_fields_in_send_ty.rs:63:1\n+  --> $DIR/non_send_fields_in_send_ty.rs:64:1\n    |\n LL | unsafe impl<T> Send for MultiField<T> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: it is not safe to send field `field1` to another thread\n-  --> $DIR/non_send_fields_in_send_ty.rs:58:5\n+  --> $DIR/non_send_fields_in_send_ty.rs:59:5\n    |\n LL |     field1: T,\n    |     ^^^^^^^^^\n    = help: add `T: Send` bound in `Send` impl\n note: it is not safe to send field `field2` to another thread\n-  --> $DIR/non_send_fields_in_send_ty.rs:59:5\n+  --> $DIR/non_send_fields_in_send_ty.rs:60:5\n    |\n LL |     field2: T,\n    |     ^^^^^^^^^\n    = help: add `T: Send` bound in `Send` impl\n note: it is not safe to send field `field3` to another thread\n-  --> $DIR/non_send_fields_in_send_ty.rs:60:5\n+  --> $DIR/non_send_fields_in_send_ty.rs:61:5\n    |\n LL |     field3: T,\n    |     ^^^^^^^^^\n    = help: add `T: Send` bound in `Send` impl\n \n error: some fields in `MyOption<T>` are not safe to be sent to another thread\n-  --> $DIR/non_send_fields_in_send_ty.rs:70:1\n+  --> $DIR/non_send_fields_in_send_ty.rs:71:1\n    |\n LL | unsafe impl<T> Send for MyOption<T> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: it is not safe to send field `0` to another thread\n-  --> $DIR/non_send_fields_in_send_ty.rs:66:12\n+  --> $DIR/non_send_fields_in_send_ty.rs:67:12\n    |\n LL |     MySome(T),\n    |            ^\n    = help: add `T: Send` bound in `Send` impl\n \n error: some fields in `MultiParam<A, B>` are not safe to be sent to another thread\n-  --> $DIR/non_send_fields_in_send_ty.rs:82:1\n+  --> $DIR/non_send_fields_in_send_ty.rs:83:1\n    |\n LL | unsafe impl<A, B> Send for MultiParam<A, B> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: it is not safe to send field `vec` to another thread\n-  --> $DIR/non_send_fields_in_send_ty.rs:79:5\n+  --> $DIR/non_send_fields_in_send_ty.rs:80:5\n    |\n LL |     vec: Vec<(A, B)>,\n    |     ^^^^^^^^^^^^^^^^\n    = help: add bounds on type parameters `A, B` that satisfy `Vec<(A, B)>: Send`\n \n error: some fields in `HeuristicTest` are not safe to be sent to another thread\n-  --> $DIR/non_send_fields_in_send_ty.rs:100:1\n+  --> $DIR/non_send_fields_in_send_ty.rs:101:1\n    |\n LL | unsafe impl Send for HeuristicTest {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: it is not safe to send field `field4` to another thread\n-  --> $DIR/non_send_fields_in_send_ty.rs:95:5\n+  --> $DIR/non_send_fields_in_send_ty.rs:96:5\n    |\n LL |     field4: (*const NonSend, Rc<u8>),\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: use a thread-safe type that implements `Send`\n \n error: some fields in `AttrTest3<T>` are not safe to be sent to another thread\n-  --> $DIR/non_send_fields_in_send_ty.rs:119:1\n+  --> $DIR/non_send_fields_in_send_ty.rs:120:1\n    |\n LL | unsafe impl<T> Send for AttrTest3<T> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: it is not safe to send field `0` to another thread\n-  --> $DIR/non_send_fields_in_send_ty.rs:114:11\n+  --> $DIR/non_send_fields_in_send_ty.rs:115:11\n    |\n LL |     Enum2(T),\n    |           ^\n    = help: add `T: Send` bound in `Send` impl\n \n error: some fields in `Complex<P, u32>` are not safe to be sent to another thread\n-  --> $DIR/non_send_fields_in_send_ty.rs:127:1\n+  --> $DIR/non_send_fields_in_send_ty.rs:128:1\n    |\n LL | unsafe impl<P> Send for Complex<P, u32> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: it is not safe to send field `field1` to another thread\n-  --> $DIR/non_send_fields_in_send_ty.rs:123:5\n+  --> $DIR/non_send_fields_in_send_ty.rs:124:5\n    |\n LL |     field1: A,\n    |     ^^^^^^^^^\n    = help: add `P: Send` bound in `Send` impl\n \n error: some fields in `Complex<Q, MutexGuard<'static, bool>>` are not safe to be sent to another thread\n-  --> $DIR/non_send_fields_in_send_ty.rs:130:1\n+  --> $DIR/non_send_fields_in_send_ty.rs:131:1\n    |\n LL | unsafe impl<Q: Send> Send for Complex<Q, MutexGuard<'static, bool>> {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: it is not safe to send field `field2` to another thread\n-  --> $DIR/non_send_fields_in_send_ty.rs:124:5\n+  --> $DIR/non_send_fields_in_send_ty.rs:125:5\n    |\n LL |     field2: B,\n    |     ^^^^^^^^^"}]}