{"sha": "1ae7ae0c1c7ed68c616273f245647afa47f3cbde", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhZTdhZTBjMWM3ZWQ2OGM2MTYyNzNmMjQ1NjQ3YWZhNDdmM2NiZGU=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-05-29T19:01:06Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-06-04T10:26:32Z"}, "message": "fix translation of terminators in MSVC cleanup blocks\n\nMSVC requires unwinding code to be split to a tree of *funclets*, where each funclet\ncan only branch to itself or to to its parent.\n\nLuckily, the code we generates matches this pattern. Recover that structure in\nan analyze pass and translate according to that.", "tree": {"sha": "86db461d0a98eb58db416248a96b42ede0d86798", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/86db461d0a98eb58db416248a96b42ede0d86798"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1ae7ae0c1c7ed68c616273f245647afa47f3cbde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1ae7ae0c1c7ed68c616273f245647afa47f3cbde", "html_url": "https://github.com/rust-lang/rust/commit/1ae7ae0c1c7ed68c616273f245647afa47f3cbde", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1ae7ae0c1c7ed68c616273f245647afa47f3cbde/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "506086ef9661e124280d46673b3ed93be6461ae8", "url": "https://api.github.com/repos/rust-lang/rust/commits/506086ef9661e124280d46673b3ed93be6461ae8", "html_url": "https://github.com/rust-lang/rust/commit/506086ef9661e124280d46673b3ed93be6461ae8"}], "stats": {"total": 452, "additions": 347, "deletions": 105}, "files": [{"sha": "f72e10d99cfd121f14c3e4632984ce023542183c", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1ae7ae0c1c7ed68c616273f245647afa47f3cbde/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ae7ae0c1c7ed68c616273f245647afa47f3cbde/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=1ae7ae0c1c7ed68c616273f245647afa47f3cbde", "patch": "@@ -998,9 +998,11 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                             continue\n                         }\n                         TerminatorKind::DropAndReplace { .. } => {\n-                            // this contains the consume of the source and\n+                            // this contains the move of the source and\n                             // the initialization of the destination. We\n-                            // only want the latter\n+                            // only want the former - the latter is handled\n+                            // by the elaboration code and must be done\n+                            // *after* the destination is dropped.\n                             assert!(self.patch.is_patched(bb));\n                             allow_initializations = false;\n                         }"}, {"sha": "bf62849818d4e3f8005b3e4662ece424ac158356", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1ae7ae0c1c7ed68c616273f245647afa47f3cbde/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ae7ae0c1c7ed68c616273f245647afa47f3cbde/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=1ae7ae0c1c7ed68c616273f245647afa47f3cbde", "patch": "@@ -577,6 +577,15 @@ impl<'blk, 'tcx> BlockS<'blk, 'tcx> {\n         self.lpad.get()\n     }\n \n+    pub fn set_lpad_ref(&self, lpad: Option<&'blk LandingPad>) {\n+        // FIXME: use an IVar?\n+        self.lpad.set(lpad);\n+    }\n+\n+    pub fn set_lpad(&self, lpad: Option<LandingPad>) {\n+        self.set_lpad_ref(lpad.map(|p| &*self.fcx().lpad_arena.alloc(p)))\n+    }\n+\n     pub fn mir(&self) -> CachedMir<'blk, 'tcx> {\n         self.fcx.mir()\n     }\n@@ -716,7 +725,16 @@ impl<'blk, 'tcx> BlockAndBuilder<'blk, 'tcx> {\n     }\n \n     pub fn set_lpad(&self, lpad: Option<LandingPad>) {\n-        self.bcx.lpad.set(lpad.map(|p| &*self.fcx().lpad_arena.alloc(p)))\n+        self.bcx.set_lpad(lpad)\n+    }\n+\n+    pub fn set_lpad_ref(&self, lpad: Option<&'blk LandingPad>) {\n+        // FIXME: use an IVar?\n+        self.bcx.set_lpad_ref(lpad);\n+    }\n+\n+    pub fn lpad(&self) -> Option<&'blk LandingPad> {\n+        self.bcx.lpad()\n     }\n }\n \n@@ -761,6 +779,10 @@ impl LandingPad {\n     pub fn bundle(&self) -> Option<&OperandBundleDef> {\n         self.operand.as_ref()\n     }\n+\n+    pub fn cleanuppad(&self) -> Option<ValueRef> {\n+        self.cleanuppad\n+    }\n }\n \n impl Clone for LandingPad {"}, {"sha": "03df1c451f0d1d30206e3bcc97b16ca6d8e5c3b1", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/1ae7ae0c1c7ed68c616273f245647afa47f3cbde/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ae7ae0c1c7ed68c616273f245647afa47f3cbde/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=1ae7ae0c1c7ed68c616273f245647afa47f3cbde", "patch": "@@ -13,7 +13,9 @@\n \n use rustc_data_structures::bitvec::BitVector;\n use rustc::mir::repr as mir;\n+use rustc::mir::repr::TerminatorKind;\n use rustc::mir::visit::{Visitor, LvalueContext};\n+use rustc_mir::traversal;\n use common::{self, Block, BlockAndBuilder};\n use super::rvalue;\n \n@@ -134,3 +136,104 @@ impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for TempAnalyzer<'mir, 'bcx, 'tcx> {\n         self.super_lvalue(lvalue, context);\n     }\n }\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum CleanupKind {\n+    NotCleanup,\n+    Funclet,\n+    Internal { funclet: mir::BasicBlock }\n+}\n+\n+pub fn cleanup_kinds<'bcx,'tcx>(_bcx: Block<'bcx,'tcx>,\n+                                mir: &mir::Mir<'tcx>)\n+                                -> Vec<CleanupKind>\n+{\n+    fn discover_masters<'tcx>(result: &mut [CleanupKind], mir: &mir::Mir<'tcx>) {\n+        for bb in mir.all_basic_blocks() {\n+            let data = mir.basic_block_data(bb);\n+            match data.terminator().kind {\n+                TerminatorKind::Goto { .. } |\n+                TerminatorKind::Resume |\n+                TerminatorKind::Return |\n+                TerminatorKind::If { .. } |\n+                TerminatorKind::Switch { .. } |\n+                TerminatorKind::SwitchInt { .. } => {\n+                    /* nothing to do */\n+                }\n+                TerminatorKind::Call { cleanup: unwind, .. } |\n+                TerminatorKind::DropAndReplace { unwind, .. } |\n+                TerminatorKind::Drop { unwind, .. } => {\n+                    if let Some(unwind) = unwind {\n+                        debug!(\"cleanup_kinds: {:?}/{:?} registering {:?} as funclet\",\n+                               bb, data, unwind);\n+                        result[unwind.index()] = CleanupKind::Funclet;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn propagate<'tcx>(result: &mut [CleanupKind], mir: &mir::Mir<'tcx>) {\n+        let mut funclet_succs : Vec<_> =\n+            mir.all_basic_blocks().iter().map(|_| None).collect();\n+\n+        let mut set_successor = |funclet: mir::BasicBlock, succ| {\n+            match funclet_succs[funclet.index()] {\n+                ref mut s @ None => {\n+                    debug!(\"set_successor: updating successor of {:?} to {:?}\",\n+                           funclet, succ);\n+                    *s = Some(succ);\n+                },\n+                Some(s) => if s != succ {\n+                    span_bug!(mir.span, \"funclet {:?} has 2 parents - {:?} and {:?}\",\n+                              funclet, s, succ);\n+                }\n+            }\n+        };\n+\n+        for (bb, data) in traversal::reverse_postorder(mir) {\n+            let funclet = match result[bb.index()] {\n+                CleanupKind::NotCleanup => continue,\n+                CleanupKind::Funclet => bb,\n+                CleanupKind::Internal { funclet } => funclet,\n+            };\n+\n+            debug!(\"cleanup_kinds: {:?}/{:?}/{:?} propagating funclet {:?}\",\n+                   bb, data, result[bb.index()], funclet);\n+\n+            for &succ in data.terminator().successors().iter() {\n+                let kind = result[succ.index()];\n+                debug!(\"cleanup_kinds: propagating {:?} to {:?}/{:?}\",\n+                       funclet, succ, kind);\n+                match kind {\n+                    CleanupKind::NotCleanup => {\n+                        result[succ.index()] = CleanupKind::Internal { funclet: funclet };\n+                    }\n+                    CleanupKind::Funclet => {\n+                        set_successor(funclet, succ);\n+                    }\n+                    CleanupKind::Internal { funclet: succ_funclet } => {\n+                        if funclet != succ_funclet {\n+                            // `succ` has 2 different funclet going into it, so it must\n+                            // be a funclet by itself.\n+\n+                            debug!(\"promoting {:?} to a funclet and updating {:?}\", succ,\n+                                   succ_funclet);\n+                            result[succ.index()] = CleanupKind::Funclet;\n+                            set_successor(succ_funclet, succ);\n+                            set_successor(funclet, succ);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    let mut result : Vec<_> =\n+        mir.all_basic_blocks().iter().map(|_| CleanupKind::NotCleanup).collect();\n+\n+    discover_masters(&mut result, mir);\n+    propagate(&mut result, mir);\n+    debug!(\"cleanup_kinds: result={:?}\", result);\n+    result\n+}"}, {"sha": "eb962b6615442c735fe13c3829699c14b908ba1d", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 120, "deletions": 80, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/1ae7ae0c1c7ed68c616273f245647afa47f3cbde/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ae7ae0c1c7ed68c616273f245647afa47f3cbde/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=1ae7ae0c1c7ed68c616273f245647afa47f3cbde", "patch": "@@ -8,15 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{self, BasicBlockRef, ValueRef, OperandBundleDef};\n+use llvm::{self, ValueRef};\n use rustc::ty;\n use rustc::mir::repr as mir;\n use abi::{Abi, FnType, ArgType};\n use adt;\n use base;\n use build;\n use callee::{Callee, CalleeData, Fn, Intrinsic, NamedTupleConstructor, Virtual};\n-use common::{self, type_is_fat_ptr, Block, BlockAndBuilder, C_undef};\n+use common::{self, type_is_fat_ptr, Block, BlockAndBuilder, LandingPad, C_undef};\n use debuginfo::DebugLoc;\n use Disr;\n use machine::{llalign_of_min, llbitsize_of_real};\n@@ -27,29 +27,70 @@ use type_::Type;\n use rustc_data_structures::fnv::FnvHashMap;\n \n use super::{MirContext, TempRef};\n+use super::analyze::CleanupKind;\n use super::constant::Const;\n use super::lvalue::{LvalueRef, load_fat_ptr};\n use super::operand::OperandRef;\n use super::operand::OperandValue::{self, FatPtr, Immediate, Ref};\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n     pub fn trans_block(&mut self, bb: mir::BasicBlock) {\n-        debug!(\"trans_block({:?})\", bb);\n-\n         let mut bcx = self.bcx(bb);\n         let mir = self.mir.clone();\n         let data = mir.basic_block_data(bb);\n \n-        // MSVC SEH bits\n-        let (cleanup_pad, cleanup_bundle) = if let Some((cp, cb)) = self.make_cleanup_pad(bb) {\n-            (Some(cp), Some(cb))\n-        } else {\n-            (None, None)\n+        debug!(\"trans_block({:?}={:?})\", bb, data);\n+\n+        // Create the cleanup bundle, if needed.\n+        let cleanup_pad = bcx.lpad().and_then(|lp| lp.cleanuppad());\n+        let cleanup_bundle = bcx.lpad().and_then(|l| l.bundle());\n+\n+        let funclet_br = |this: &Self, bcx: BlockAndBuilder, bb: mir::BasicBlock| {\n+            let lltarget = this.blocks[bb.index()].llbb;\n+            if let Some(cp) = cleanup_pad {\n+                match this.cleanup_kind(bb) {\n+                    CleanupKind::Funclet => {\n+                        // micro-optimization: generate a `ret` rather than a jump\n+                        // to a return block\n+                        bcx.cleanup_ret(cp, Some(lltarget));\n+                    }\n+                    CleanupKind::Internal { .. } => bcx.br(lltarget),\n+                    CleanupKind::NotCleanup => bug!(\"jump from cleanup bb to bb {:?}\", bb)\n+                }\n+            } else {\n+                bcx.br(lltarget);\n+            }\n         };\n-        let funclet_br = |bcx: BlockAndBuilder, llbb: BasicBlockRef| if let Some(cp) = cleanup_pad {\n-            bcx.cleanup_ret(cp, Some(llbb));\n-        } else {\n-            bcx.br(llbb);\n+\n+        let llblock = |this: &mut Self, target: mir::BasicBlock| {\n+            let lltarget = this.blocks[target.index()].llbb;\n+\n+            if let Some(cp) = cleanup_pad {\n+                match this.cleanup_kind(target) {\n+                    CleanupKind::Funclet => {\n+                        // MSVC cross-funclet jump - need a trampoline\n+\n+                        debug!(\"llblock: creating cleanup trampoline for {:?}\", target);\n+                        let name = &format!(\"{:?}_cleanup_trampoline_{:?}\", bb, target);\n+                        let trampoline = this.fcx.new_block(name, None).build();\n+                        trampoline.set_personality_fn(this.fcx.eh_personality());\n+                        trampoline.cleanup_ret(cp, Some(lltarget));\n+                        trampoline.llbb()\n+                    }\n+                    CleanupKind::Internal { .. } => lltarget,\n+                    CleanupKind::NotCleanup =>\n+                        bug!(\"jump from cleanup bb {:?} to bb {:?}\", bb, target)\n+                }\n+            } else {\n+                if let (CleanupKind::NotCleanup, CleanupKind::Funclet) =\n+                    (this.cleanup_kind(bb), this.cleanup_kind(target))\n+                {\n+                    // jump *into* cleanup - need a landing pad if GNU\n+                    this.landing_pad_to(target).llbb\n+                } else {\n+                    lltarget\n+                }\n+            }\n         };\n \n         for statement in &data.statements {\n@@ -78,13 +119,14 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n \n             mir::TerminatorKind::Goto { target } => {\n-                funclet_br(bcx, self.llblock(target));\n+                funclet_br(self, bcx, target);\n             }\n \n             mir::TerminatorKind::If { ref cond, targets: (true_bb, false_bb) } => {\n                 let cond = self.trans_operand(&bcx, cond);\n-                let lltrue = self.llblock(true_bb);\n-                let llfalse = self.llblock(false_bb);\n+\n+                let lltrue = llblock(self, true_bb);\n+                let llfalse = llblock(self, false_bb);\n                 bcx.cond_br(cond.immediate(), lltrue, llfalse);\n             }\n \n@@ -106,18 +148,18 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     // code. This is especially helpful in cases like an if-let on a huge enum.\n                     // Note: This optimization is only valid for exhaustive matches.\n                     Some((&&bb, &c)) if c > targets.len() / 2 => {\n-                        (Some(bb), self.blocks[bb.index()])\n+                        (Some(bb), llblock(self, bb))\n                     }\n                     // We're generating an exhaustive switch, so the else branch\n                     // can't be hit.  Branching to an unreachable instruction\n                     // lets LLVM know this\n-                    _ => (None, self.unreachable_block())\n+                    _ => (None, self.unreachable_block().llbb)\n                 };\n-                let switch = bcx.switch(discr, default_blk.llbb, targets.len());\n+                let switch = bcx.switch(discr, default_blk, targets.len());\n                 assert_eq!(adt_def.variants.len(), targets.len());\n                 for (adt_variant, &target) in adt_def.variants.iter().zip(targets) {\n                     if default_bb != Some(target) {\n-                        let llbb = self.llblock(target);\n+                        let llbb = llblock(self, target);\n                         let llval = bcx.with_block(|bcx| adt::trans_case(\n                                 bcx, &repr, Disr::from(adt_variant.disr_val)));\n                         build::AddCase(switch, llval, llbb)\n@@ -129,10 +171,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let (otherwise, targets) = targets.split_last().unwrap();\n                 let discr = bcx.load(self.trans_lvalue(&bcx, discr).llval);\n                 let discr = bcx.with_block(|bcx| base::to_immediate(bcx, discr, switch_ty));\n-                let switch = bcx.switch(discr, self.llblock(*otherwise), values.len());\n+                let switch = bcx.switch(discr, llblock(self, *otherwise), values.len());\n                 for (value, target) in values.iter().zip(targets) {\n                     let val = Const::from_constval(bcx.ccx(), value.clone(), switch_ty);\n-                    let llbb = self.llblock(*target);\n+                    let llbb = llblock(self, *target);\n                     build::AddCase(switch, val.llval, llbb)\n                 }\n             }\n@@ -148,7 +190,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let ty = lvalue.ty.to_ty(bcx.tcx());\n                 // Double check for necessity to drop\n                 if !glue::type_needs_drop(bcx.tcx(), ty) {\n-                    funclet_br(bcx, self.llblock(target));\n+                    funclet_br(self, bcx, target);\n                     return;\n                 }\n                 let drop_fn = glue::get_drop_glue(bcx.ccx(), ty);\n@@ -159,19 +201,14 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     lvalue.llval\n                 };\n                 if let Some(unwind) = unwind {\n-                    let uwbcx = self.bcx(unwind);\n-                    let unwind = self.make_landing_pad(uwbcx);\n                     bcx.invoke(drop_fn,\n                                &[llvalue],\n-                               self.llblock(target),\n-                               unwind.llbb(),\n-                               cleanup_bundle.as_ref());\n-                    self.bcx(target).at_start(|bcx| {\n-                        debug_loc.apply_to_bcx(bcx);\n-                    });\n+                               self.blocks[target.index()].llbb,\n+                               llblock(self, unwind),\n+                               cleanup_bundle);\n                 } else {\n-                    bcx.call(drop_fn, &[llvalue], cleanup_bundle.as_ref());\n-                    funclet_br(bcx, self.llblock(target));\n+                    bcx.call(drop_fn, &[llvalue], cleanup_bundle);\n+                    funclet_br(self, bcx, target);\n                 }\n             }\n \n@@ -213,7 +250,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     let llptr = self.trans_operand(&bcx, &args[0]).immediate();\n                     let val = self.trans_operand(&bcx, &args[1]);\n                     self.store_operand(&bcx, llptr, val);\n-                    funclet_br(bcx, self.llblock(target));\n+                    funclet_br(self, bcx, target);\n                     return;\n                 }\n \n@@ -223,7 +260,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         this.trans_transmute(&bcx, &args[0], dest);\n                     });\n \n-                    funclet_br(bcx, self.llblock(target));\n+                    funclet_br(self, bcx, target);\n                     return;\n                 }\n \n@@ -328,7 +365,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         }\n \n                         if let Some((_, target)) = *destination {\n-                            funclet_br(bcx, self.llblock(target));\n+                            funclet_br(self, bcx, target);\n                         } else {\n                             // trans_intrinsic_call already used Unreachable.\n                             // bcx.unreachable();\n@@ -341,19 +378,17 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 };\n \n                 // Many different ways to call a function handled here\n-                if let Some(cleanup) = cleanup.map(|bb| self.bcx(bb)) {\n+                if let &Some(cleanup) = cleanup {\n                     let ret_bcx = if let Some((_, target)) = *destination {\n                         self.blocks[target.index()]\n                     } else {\n                         self.unreachable_block()\n                     };\n-                    let landingpad = self.make_landing_pad(cleanup);\n-\n                     let invokeret = bcx.invoke(fn_ptr,\n                                                &llargs,\n                                                ret_bcx.llbb,\n-                                               landingpad.llbb(),\n-                                               cleanup_bundle.as_ref());\n+                                               llblock(self, cleanup),\n+                                               cleanup_bundle);\n                     fn_ty.apply_attrs_callsite(invokeret);\n \n                     if destination.is_some() {\n@@ -368,17 +403,16 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         });\n                     }\n                 } else {\n-                    let llret = bcx.call(fn_ptr, &llargs, cleanup_bundle.as_ref());\n+                    let llret = bcx.call(fn_ptr, &llargs, cleanup_bundle);\n                     fn_ty.apply_attrs_callsite(llret);\n                     if let Some((_, target)) = *destination {\n                         let op = OperandRef {\n                             val: OperandValue::Immediate(llret),\n                             ty: sig.output.unwrap()\n                         };\n                         self.store_return(&bcx, ret_dest, fn_ty.ret, op);\n-                        funclet_br(bcx, self.llblock(target));\n+                        funclet_br(self, bcx, target);\n                     } else {\n-                        // no need to drop args, because the call never returns\n                         bcx.unreachable();\n                     }\n                 }\n@@ -518,54 +552,64 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         }\n     }\n \n-    /// Create a landingpad wrapper around the given Block.\n+    fn cleanup_kind(&self, bb: mir::BasicBlock) -> CleanupKind {\n+        self.cleanup_kinds[bb.index()]\n+    }\n+\n+    /// Return the landingpad wrapper around the given basic block\n     ///\n     /// No-op in MSVC SEH scheme.\n-    fn make_landing_pad(&mut self,\n-                        cleanup: BlockAndBuilder<'bcx, 'tcx>)\n-                        -> BlockAndBuilder<'bcx, 'tcx>\n+    fn landing_pad_to(&mut self, target_bb: mir::BasicBlock) -> Block<'bcx, 'tcx>\n     {\n-        if base::wants_msvc_seh(cleanup.sess()) {\n-            return cleanup;\n+        if let Some(block) = self.landing_pads[target_bb.index()] {\n+            return block;\n+        }\n+\n+        if base::wants_msvc_seh(self.fcx.ccx.sess()) {\n+            return self.blocks[target_bb.index()];\n         }\n-        let bcx = self.fcx.new_block(\"cleanup\", None).build();\n+\n+        let target = self.bcx(target_bb);\n+\n+        let block = self.fcx.new_block(\"cleanup\", None);\n+        self.landing_pads[target_bb.index()] = Some(block);\n+\n+        let bcx = block.build();\n         let ccx = bcx.ccx();\n         let llpersonality = self.fcx.eh_personality();\n         let llretty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)], false);\n         let llretval = bcx.landing_pad(llretty, llpersonality, 1, self.fcx.llfn);\n         bcx.set_cleanup(llretval);\n         let slot = self.get_personality_slot(&bcx);\n         bcx.store(llretval, slot);\n-        bcx.br(cleanup.llbb());\n-        bcx\n+        bcx.br(target.llbb());\n+        block\n     }\n \n-    /// Create prologue cleanuppad instruction under MSVC SEH handling scheme.\n-    ///\n-    /// Also handles setting some state for the original trans and creating an operand bundle for\n-    /// function calls.\n-    fn make_cleanup_pad(&mut self, bb: mir::BasicBlock) -> Option<(ValueRef, OperandBundleDef)> {\n+    pub fn init_cpad(&mut self, bb: mir::BasicBlock) {\n         let bcx = self.bcx(bb);\n         let data = self.mir.basic_block_data(bb);\n-        let use_funclets = base::wants_msvc_seh(bcx.sess()) && data.is_cleanup;\n-        let cleanup_pad = if use_funclets {\n-            bcx.set_personality_fn(self.fcx.eh_personality());\n-            bcx.at_start(|bcx| {\n-                DebugLoc::None.apply_to_bcx(bcx);\n-                Some(bcx.cleanup_pad(None, &[]))\n-            })\n-        } else {\n-            None\n+        debug!(\"init_cpad({:?})\", data);\n+\n+        match self.cleanup_kinds[bb.index()] {\n+            CleanupKind::NotCleanup => {\n+                bcx.set_lpad(None)\n+            }\n+            _ if !base::wants_msvc_seh(bcx.sess()) => {\n+                bcx.set_lpad(Some(LandingPad::gnu()))\n+            }\n+            CleanupKind::Internal { funclet } => {\n+                // FIXME: is this needed?\n+                bcx.set_personality_fn(self.fcx.eh_personality());\n+                bcx.set_lpad_ref(self.bcx(funclet).lpad());\n+            }\n+            CleanupKind::Funclet => {\n+                bcx.set_personality_fn(self.fcx.eh_personality());\n+                DebugLoc::None.apply_to_bcx(&bcx);\n+                let cleanup_pad = bcx.cleanup_pad(None, &[]);\n+                bcx.set_lpad(Some(LandingPad::msvc(cleanup_pad)));\n+            }\n         };\n-        // Set the landingpad global-state for old translator, so it knows about the SEH used.\n-        bcx.set_lpad(if let Some(cleanup_pad) = cleanup_pad {\n-            Some(common::LandingPad::msvc(cleanup_pad))\n-        } else if data.is_cleanup {\n-            Some(common::LandingPad::gnu())\n-        } else {\n-            None\n-        });\n-        cleanup_pad.map(|f| (f, OperandBundleDef::new(\"funclet\", &[f])))\n     }\n \n     fn unreachable_block(&mut self) -> Block<'bcx, 'tcx> {\n@@ -581,10 +625,6 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n         self.blocks[bb.index()].build()\n     }\n \n-    pub fn llblock(&self, bb: mir::BasicBlock) -> BasicBlockRef {\n-        self.blocks[bb.index()].llbb\n-    }\n-\n     fn make_return_dest(&mut self, bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                         dest: &mir::Lvalue<'tcx>, fn_ret_ty: &ArgType,\n                         llargs: &mut Vec<ValueRef>, is_intrinsic: bool) -> ReturnDest {"}, {"sha": "d1206550b13d6bb705acb99000522a914da3b4ce", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1ae7ae0c1c7ed68c616273f245647afa47f3cbde/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ae7ae0c1c7ed68c616273f245647afa47f3cbde/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=1ae7ae0c1c7ed68c616273f245647afa47f3cbde", "patch": "@@ -73,6 +73,13 @@ pub struct MirContext<'bcx, 'tcx:'bcx> {\n     /// A `Block` for each MIR `BasicBlock`\n     blocks: Vec<Block<'bcx, 'tcx>>,\n \n+    /// The funclet status of each basic block\n+    cleanup_kinds: Vec<analyze::CleanupKind>,\n+\n+    /// This stores the landing-pad block for a given BB, computed lazily on GNU\n+    /// and eagerly on MSVC.\n+    landing_pads: Vec<Option<Block<'bcx, 'tcx>>>,\n+\n     /// Cached unreachable block\n     unreachable_block: Option<Block<'bcx, 'tcx>>,\n \n@@ -139,8 +146,9 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n \n     // Analyze the temps to determine which must be lvalues\n     // FIXME\n-    let lvalue_temps = bcx.with_block(|bcx| {\n-      analyze::lvalue_temps(bcx, &mir)\n+    let (lvalue_temps, cleanup_kinds) = bcx.with_block(|bcx| {\n+        (analyze::lvalue_temps(bcx, &mir),\n+         analyze::cleanup_kinds(bcx, &mir))\n     });\n \n     // Compute debuginfo scopes from MIR scopes.\n@@ -206,6 +214,8 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n         llpersonalityslot: None,\n         blocks: block_bcxs,\n         unreachable_block: None,\n+        cleanup_kinds: cleanup_kinds,\n+        landing_pads: mir_blocks.iter().map(|_| None).collect(),\n         vars: vars,\n         temps: temps,\n         args: args,\n@@ -214,7 +224,14 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n \n     let mut visited = BitVector::new(mir_blocks.len());\n \n-    let rpo = traversal::reverse_postorder(&mir);\n+    let mut rpo = traversal::reverse_postorder(&mir);\n+\n+    // Prepare each block for translation.\n+    for (bb, _) in rpo.by_ref() {\n+        mircx.init_cpad(bb);\n+    }\n+    rpo.reset();\n+\n     // Translate the body of each block using reverse postorder\n     for (bb, _) in rpo {\n         visited.insert(bb.index());\n@@ -228,8 +245,7 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n         let block = BasicBlock(block.llbb);\n         // Unreachable block\n         if !visited.contains(bb.index()) {\n-            block.delete();\n-        } else if block.pred_iter().count() == 0 {\n+            debug!(\"trans_mir: block {:?} was not visited\", bb);\n             block.delete();\n         }\n     }"}, {"sha": "eb668517bdf348ba514bfa4b9f437ed740b9bbec", "filename": "src/test/run-fail/issue-30380.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1ae7ae0c1c7ed68c616273f245647afa47f3cbde/src%2Ftest%2Frun-fail%2Fissue-30380.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ae7ae0c1c7ed68c616273f245647afa47f3cbde/src%2Ftest%2Frun-fail%2Fissue-30380.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-30380.rs?ref=1ae7ae0c1c7ed68c616273f245647afa47f3cbde", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![feature(rustc_attrs)]\n+\n // check that panics in destructors during assignment do not leave\n // destroyed values lying around for other destructors to observe.\n \n@@ -33,6 +35,7 @@ impl<'a> Drop for Observer<'a> {\n     }\n }\n \n+#[rustc_mir]\n fn foo(b: &mut Observer) {\n     *b.0 = FilledOnDrop(1);\n }"}, {"sha": "f917531e868f1ba29d93c75ce5b8a5a4bd287060", "filename": "src/test/run-pass/dynamic-drop.rs", "status": "modified", "additions": 73, "deletions": 17, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/1ae7ae0c1c7ed68c616273f245647afa47f3cbde/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1ae7ae0c1c7ed68c616273f245647afa47f3cbde/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdynamic-drop.rs?ref=1ae7ae0c1c7ed68c616273f245647afa47f3cbde", "patch": "@@ -8,12 +8,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cell::RefCell;\n+#![feature(rustc_attrs)]\n+\n+use std::cell::{Cell, RefCell};\n+use std::panic;\n+use std::usize;\n+\n+struct InjectedFailure;\n \n struct Allocator {\n     data: RefCell<Vec<bool>>,\n+    failing_op: usize,\n+    cur_ops: Cell<usize>,\n }\n \n+impl panic::UnwindSafe for Allocator {}\n+impl panic::RefUnwindSafe for Allocator {}\n+\n impl Drop for Allocator {\n     fn drop(&mut self) {\n         let data = self.data.borrow();\n@@ -24,8 +35,20 @@ impl Drop for Allocator {\n }\n \n impl Allocator {\n-    fn new() -> Self { Allocator { data: RefCell::new(vec![]) } }\n+    fn new(failing_op: usize) -> Self {\n+        Allocator {\n+            failing_op: failing_op,\n+            cur_ops: Cell::new(0),\n+            data: RefCell::new(vec![])\n+        }\n+    }\n     fn alloc(&self) -> Ptr {\n+        self.cur_ops.set(self.cur_ops.get() + 1);\n+\n+        if self.cur_ops.get() == self.failing_op {\n+            panic!(InjectedFailure);\n+        }\n+\n         let mut data = self.data.borrow_mut();\n         let addr = data.len();\n         data.push(true);\n@@ -42,25 +65,34 @@ impl<'a> Drop for Ptr<'a> {\n             }\n             ref mut d => *d = false\n         }\n+\n+        self.1.cur_ops.set(self.1.cur_ops.get()+1);\n+\n+        if self.1.cur_ops.get() == self.1.failing_op {\n+            panic!(InjectedFailure);\n+        }\n     }\n }\n \n+#[rustc_mir]\n fn dynamic_init(a: &Allocator, c: bool) {\n     let _x;\n     if c {\n         _x = Some(a.alloc());\n     }\n }\n \n-fn dynamic_drop(a: &Allocator, c: bool) -> Option<Ptr> {\n+#[rustc_mir]\n+fn dynamic_drop(a: &Allocator, c: bool) {\n     let x = a.alloc();\n     if c {\n         Some(x)\n     } else {\n         None\n-    }\n+    };\n }\n \n+#[rustc_mir]\n fn assignment2(a: &Allocator, c0: bool, c1: bool) {\n     let mut _v = a.alloc();\n     let mut _w = a.alloc();\n@@ -73,6 +105,7 @@ fn assignment2(a: &Allocator, c0: bool, c1: bool) {\n     }\n }\n \n+#[rustc_mir]\n fn assignment1(a: &Allocator, c0: bool) {\n     let mut _v = a.alloc();\n     let mut _w = a.alloc();\n@@ -82,19 +115,42 @@ fn assignment1(a: &Allocator, c0: bool) {\n     _v = _w;\n }\n \n+fn run_test<F>(mut f: F)\n+    where F: FnMut(&Allocator)\n+{\n+    let first_alloc = Allocator::new(usize::MAX);\n+    f(&first_alloc);\n+\n+    for failing_op in 1..first_alloc.cur_ops.get()+1 {\n+        let alloc = Allocator::new(failing_op);\n+        let alloc = &alloc;\n+        let f = panic::AssertUnwindSafe(&mut f);\n+        let result = panic::catch_unwind(move || {\n+            f.0(alloc);\n+        });\n+        match result {\n+            Ok(..) => panic!(\"test executed {} ops but now {}\",\n+                             first_alloc.cur_ops.get(), alloc.cur_ops.get()),\n+            Err(e) => {\n+                if e.downcast_ref::<InjectedFailure>().is_none() {\n+                    panic::resume_unwind(e);\n+                }\n+            }\n+        }\n+    }\n+}\n \n fn main() {\n-    let a = Allocator::new();\n-    dynamic_init(&a, false);\n-    dynamic_init(&a, true);\n-    dynamic_drop(&a, false);\n-    dynamic_drop(&a, true);\n-\n-    assignment2(&a, false, false);\n-    assignment2(&a, false, true);\n-    assignment2(&a, true, false);\n-    assignment2(&a, true, true);\n-\n-    assignment1(&a, false);\n-    assignment1(&a, true);\n+    run_test(|a| dynamic_init(a, false));\n+    run_test(|a| dynamic_init(a, true));\n+    run_test(|a| dynamic_drop(a, false));\n+    run_test(|a| dynamic_drop(a, true));\n+\n+    run_test(|a| assignment2(a, false, false));\n+    run_test(|a| assignment2(a, false, true));\n+    run_test(|a| assignment2(a, true, false));\n+    run_test(|a| assignment2(a, true, true));\n+\n+    run_test(|a| assignment1(a, false));\n+    run_test(|a| assignment1(a, true));\n }"}]}