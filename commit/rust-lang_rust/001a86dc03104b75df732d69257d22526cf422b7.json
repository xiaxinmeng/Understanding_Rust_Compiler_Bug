{"sha": "001a86dc03104b75df732d69257d22526cf422b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAwMWE4NmRjMDMxMDRiNzVkZjczMmQ2OTI1N2QyMjUyNmNmNDIyYjc=", "commit": {"author": {"name": "Hasan Ali", "email": "git@hasali.co.uk", "date": "2020-05-15T21:23:49Z"}, "committer": {"name": "Hasan Ali", "email": "git@hasali.co.uk", "date": "2020-05-16T00:09:04Z"}, "message": "Fix completion and hover for module and function of same name", "tree": {"sha": "4f1554da3d909c15d5e4cec7c8470687cf452467", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f1554da3d909c15d5e4cec7c8470687cf452467"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/001a86dc03104b75df732d69257d22526cf422b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/001a86dc03104b75df732d69257d22526cf422b7", "html_url": "https://github.com/rust-lang/rust/commit/001a86dc03104b75df732d69257d22526cf422b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/001a86dc03104b75df732d69257d22526cf422b7/comments", "author": {"login": "hasali19", "id": 10169241, "node_id": "MDQ6VXNlcjEwMTY5MjQx", "avatar_url": "https://avatars.githubusercontent.com/u/10169241?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hasali19", "html_url": "https://github.com/hasali19", "followers_url": "https://api.github.com/users/hasali19/followers", "following_url": "https://api.github.com/users/hasali19/following{/other_user}", "gists_url": "https://api.github.com/users/hasali19/gists{/gist_id}", "starred_url": "https://api.github.com/users/hasali19/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hasali19/subscriptions", "organizations_url": "https://api.github.com/users/hasali19/orgs", "repos_url": "https://api.github.com/users/hasali19/repos", "events_url": "https://api.github.com/users/hasali19/events{/privacy}", "received_events_url": "https://api.github.com/users/hasali19/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hasali19", "id": 10169241, "node_id": "MDQ6VXNlcjEwMTY5MjQx", "avatar_url": "https://avatars.githubusercontent.com/u/10169241?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hasali19", "html_url": "https://github.com/hasali19", "followers_url": "https://api.github.com/users/hasali19/followers", "following_url": "https://api.github.com/users/hasali19/following{/other_user}", "gists_url": "https://api.github.com/users/hasali19/gists{/gist_id}", "starred_url": "https://api.github.com/users/hasali19/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hasali19/subscriptions", "organizations_url": "https://api.github.com/users/hasali19/orgs", "repos_url": "https://api.github.com/users/hasali19/repos", "events_url": "https://api.github.com/users/hasali19/events{/privacy}", "received_events_url": "https://api.github.com/users/hasali19/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cffa70be01d4353184f874fc4768b692e255dd30", "url": "https://api.github.com/repos/rust-lang/rust/commits/cffa70be01d4353184f874fc4768b692e255dd30", "html_url": "https://github.com/rust-lang/rust/commit/cffa70be01d4353184f874fc4768b692e255dd30"}], "stats": {"total": 104, "additions": 102, "deletions": 2}, "files": [{"sha": "c1129a49442c8aa60cf05a52625d26caa86af67f", "filename": "crates/ra_hir/src/semantics.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/001a86dc03104b75df732d69257d22526cf422b7/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001a86dc03104b75df732d69257d22526cf422b7/crates%2Fra_hir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsemantics.rs?ref=001a86dc03104b75df732d69257d22526cf422b7", "patch": "@@ -23,7 +23,7 @@ use crate::{\n     db::HirDatabase,\n     diagnostics::Diagnostic,\n     semantics::source_to_def::{ChildContainer, SourceToDefCache, SourceToDefCtx},\n-    source_analyzer::{resolve_hir_path, SourceAnalyzer},\n+    source_analyzer::{resolve_hir_path, resolve_hir_path_qualifier, SourceAnalyzer},\n     AssocItem, Field, Function, HirFileId, ImplDef, InFile, Local, MacroDef, Module, ModuleDef,\n     Name, Origin, Path, ScopeDef, Trait, Type, TypeAlias, TypeParam,\n };\n@@ -451,6 +451,10 @@ impl<'a, DB: HirDatabase> SemanticsScope<'a, DB> {\n     pub fn resolve_hir_path(&self, path: &Path) -> Option<PathResolution> {\n         resolve_hir_path(self.db, &self.resolver, path)\n     }\n+\n+    pub fn resolve_hir_path_qualifier(&self, path: &Path) -> Option<PathResolution> {\n+        resolve_hir_path_qualifier(self.db, &self.resolver, path)\n+    }\n }\n \n // FIXME: Change `HasSource` trait to work with `Semantics` and remove this?"}, {"sha": "4b509f07c6b73303c0d3a53161f33ae147b1df0e", "filename": "crates/ra_hir/src/source_analyzer.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/001a86dc03104b75df732d69257d22526cf422b7/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001a86dc03104b75df732d69257d22526cf422b7/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_analyzer.rs?ref=001a86dc03104b75df732d69257d22526cf422b7", "patch": "@@ -226,6 +226,17 @@ impl SourceAnalyzer {\n         // This must be a normal source file rather than macro file.\n         let hir_path =\n             crate::Path::from_src(path.clone(), &Hygiene::new(db.upcast(), self.file_id))?;\n+\n+        // Case where path is a qualifier of another path, e.g. foo::bar::Baz where we\n+        // trying to resolve foo::bar.\n+        if let Some(outer_path) = path.syntax().parent().and_then(ast::Path::cast) {\n+            if let Some(qualifier) = outer_path.qualifier() {\n+                if path == &qualifier {\n+                    return resolve_hir_path_qualifier(db, &self.resolver, &hir_path);\n+                }\n+            }\n+        }\n+\n         resolve_hir_path(db, &self.resolver, &hir_path)\n     }\n \n@@ -404,6 +415,7 @@ pub(crate) fn resolve_hir_path(\n             TypeNs::BuiltinType(it) => PathResolution::Def(it.into()),\n             TypeNs::TraitId(it) => PathResolution::Def(Trait::from(it).into()),\n         });\n+\n     let body_owner = resolver.body_owner();\n     let values =\n         resolver.resolve_path_in_value_ns_fully(db.upcast(), path.mod_path()).and_then(|val| {\n@@ -426,9 +438,48 @@ pub(crate) fn resolve_hir_path(\n         .resolve_module_path_in_items(db.upcast(), path.mod_path())\n         .take_types()\n         .map(|it| PathResolution::Def(it.into()));\n+\n     types.or(values).or(items).or_else(|| {\n         resolver\n             .resolve_path_as_macro(db.upcast(), path.mod_path())\n             .map(|def| PathResolution::Macro(def.into()))\n     })\n }\n+\n+/// Resolves a path where we know it is a qualifier of another path.\n+///\n+/// For example, if we have:\n+/// ```\n+/// mod my {\n+///     pub mod foo {\n+///         struct Bar;\n+///     }\n+///\n+///     pub fn foo() {}\n+/// }\n+/// ```\n+/// then we know that `foo` in `my::foo::Bar` refers to the module, not the function.\n+pub(crate) fn resolve_hir_path_qualifier(\n+    db: &dyn HirDatabase,\n+    resolver: &Resolver,\n+    path: &crate::Path,\n+) -> Option<PathResolution> {\n+    let items = resolver\n+        .resolve_module_path_in_items(db.upcast(), path.mod_path())\n+        .take_types()\n+        .map(|it| PathResolution::Def(it.into()));\n+\n+    if items.is_some() {\n+        return items;\n+    }\n+\n+    resolver.resolve_path_in_type_ns_fully(db.upcast(), path.mod_path()).map(|ty| match ty {\n+        TypeNs::SelfType(it) => PathResolution::SelfType(it.into()),\n+        TypeNs::GenericParam(id) => PathResolution::TypeParam(TypeParam { id }),\n+        TypeNs::AdtSelfType(it) | TypeNs::AdtId(it) => PathResolution::Def(Adt::from(it).into()),\n+        TypeNs::EnumVariantId(it) => PathResolution::Def(EnumVariant::from(it).into()),\n+        TypeNs::TypeAliasId(it) => PathResolution::Def(TypeAlias::from(it).into()),\n+        TypeNs::BuiltinType(it) => PathResolution::Def(it.into()),\n+        TypeNs::TraitId(it) => PathResolution::Def(Trait::from(it).into()),\n+    })\n+}"}, {"sha": "db7430454c2940ef9276c3b4043835503dac7b49", "filename": "crates/ra_ide/src/completion/complete_qualified_path.rs", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/001a86dc03104b75df732d69257d22526cf422b7/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001a86dc03104b75df732d69257d22526cf422b7/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs?ref=001a86dc03104b75df732d69257d22526cf422b7", "patch": "@@ -20,7 +20,7 @@ pub(super) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n     let scope = ctx.scope();\n     let context_module = scope.module();\n \n-    let res = match scope.resolve_hir_path(&path) {\n+    let res = match scope.resolve_hir_path_qualifier(&path) {\n         Some(res) => res,\n         None => return,\n     };\n@@ -225,6 +225,34 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn completes_mod_with_same_name_as_function() {\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                r\"\n+                use self::my::<|>;\n+\n+                mod my {\n+                    pub struct Bar;\n+                }\n+\n+                fn my() {}\n+                \"\n+            ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"Bar\",\n+                source_range: 31..31,\n+                delete: 31..31,\n+                insert: \"Bar\",\n+                kind: Struct,\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n     #[test]\n     fn path_visibility() {\n         assert_debug_snapshot!("}, {"sha": "befa977c7fe7ecae4ebd89d7ac7526b08829c500", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/001a86dc03104b75df732d69257d22526cf422b7/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/001a86dc03104b75df732d69257d22526cf422b7/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=001a86dc03104b75df732d69257d22526cf422b7", "patch": "@@ -921,4 +921,21 @@ fn func(foo: i32) { if true { <|>foo; }; }\n             &[\"unsafe trait foo\"],\n         );\n     }\n+\n+    #[test]\n+    fn test_hover_mod_with_same_name_as_function() {\n+        check_hover_result(\n+            \"\n+            //- /lib.rs\n+            use self::m<|>y::Bar;\n+\n+            mod my {\n+                pub struct Bar;\n+            }\n+\n+            fn my() {}\n+            \",\n+            &[\"mod my\"],\n+        );\n+    }\n }"}]}