{"sha": "53aa8a1ad0fe12594347d68ee7f7c12e7c1a1937", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzYWE4YTFhZDBmZTEyNTk0MzQ3ZDY4ZWU3ZjdjMTJlN2MxYTE5Mzc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-01-12T09:54:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-01-12T09:54:53Z"}, "message": "Rollup merge of #56906 - blitzerr:master, r=nikomatsakis\n\nIssue #56905\n\nAdding a map to TypeckTables to get the list of all the Upvars\ngiven a closureID. This is help us get rid of the recurring\npattern in the codebase of iterating over the free vars\nusing with_freevars.", "tree": {"sha": "02010777dbd348871d0b4280a1d923b190882def", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/02010777dbd348871d0b4280a1d923b190882def"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53aa8a1ad0fe12594347d68ee7f7c12e7c1a1937", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcObltCRBK7hj4Ov3rIwAAdHIIABf7Bhy4j2lUwZQzDhk/v8si\n/4cJQ2OL4KMNsaKQ3GUCRM7Sm4+L+AWSJSvrgm4IJD0/hnwlczK+u2kKoAZaq2fP\nEluOro44HEs+r2qHMemnG4vNZzQKzkLh4vjA4PZfiiwEoqJZwjZ2SrvwXno17ZaJ\nBaw11+m8TeMBXRg5TB231wKH6X4hMT8qQQj6D7gLSSQjcZQVY5unGmTJh9YQwVHy\nVsF4yK5BlBHub1w/6djhKDghZGNPpf3mrrslBwcQijoIo1pQQzDTGoyCmH9/Lxp3\n8PBArZZruF+TBk1r5GwsA5xzjjqw5HPawa/brGB3pfqVpqqxcbLpvdCtKZ8UNIo=\n=nWi9\n-----END PGP SIGNATURE-----\n", "payload": "tree 02010777dbd348871d0b4280a1d923b190882def\nparent e69a5cb2d7d7a8ae40a6ea3687b7c1f319a2a8ea\nparent 69e491815d927b3206c8acf88fbdbed8521e5955\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1547286893 +0100\ncommitter GitHub <noreply@github.com> 1547286893 +0100\n\nRollup merge of #56906 - blitzerr:master, r=nikomatsakis\n\nIssue #56905\n\nAdding a map to TypeckTables to get the list of all the Upvars\ngiven a closureID. This is help us get rid of the recurring\npattern in the codebase of iterating over the free vars\nusing with_freevars.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53aa8a1ad0fe12594347d68ee7f7c12e7c1a1937", "html_url": "https://github.com/rust-lang/rust/commit/53aa8a1ad0fe12594347d68ee7f7c12e7c1a1937", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53aa8a1ad0fe12594347d68ee7f7c12e7c1a1937/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e69a5cb2d7d7a8ae40a6ea3687b7c1f319a2a8ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/e69a5cb2d7d7a8ae40a6ea3687b7c1f319a2a8ea", "html_url": "https://github.com/rust-lang/rust/commit/e69a5cb2d7d7a8ae40a6ea3687b7c1f319a2a8ea"}, {"sha": "69e491815d927b3206c8acf88fbdbed8521e5955", "url": "https://api.github.com/repos/rust-lang/rust/commits/69e491815d927b3206c8acf88fbdbed8521e5955", "html_url": "https://github.com/rust-lang/rust/commit/69e491815d927b3206c8acf88fbdbed8521e5955"}], "stats": {"total": 107, "additions": 81, "deletions": 26}, "files": [{"sha": "8d4b8aae8b1767641a3705010f4fdd0e4a7f668c", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/53aa8a1ad0fe12594347d68ee7f7c12e7c1a1937/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53aa8a1ad0fe12594347d68ee7f7c12e7c1a1937/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=53aa8a1ad0fe12594347d68ee7f7c12e7c1a1937", "patch": "@@ -417,6 +417,12 @@ pub struct TypeckTables<'tcx> {\n     /// All the existential types that are restricted to concrete types\n     /// by this function\n     pub concrete_existential_types: FxHashMap<DefId, Ty<'tcx>>,\n+\n+    /// Given the closure ID this map provides the list of UpvarIDs used by it.\n+    /// The upvarID contains the HIR node ID and it also contains the full path\n+    /// leading to the member of the struct or tuple that is used instead of the\n+    /// entire variable.\n+    pub upvar_list: ty::UpvarListMap,\n }\n \n impl<'tcx> TypeckTables<'tcx> {\n@@ -441,6 +447,7 @@ impl<'tcx> TypeckTables<'tcx> {\n             tainted_by_errors: false,\n             free_region_map: Default::default(),\n             concrete_existential_types: Default::default(),\n+            upvar_list: Default::default(),\n         }\n     }\n \n@@ -741,6 +748,8 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n             tainted_by_errors,\n             ref free_region_map,\n             ref concrete_existential_types,\n+            ref upvar_list,\n+\n         } = *self;\n \n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n@@ -783,6 +792,7 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n             tainted_by_errors.hash_stable(hcx, hasher);\n             free_region_map.hash_stable(hcx, hasher);\n             concrete_existential_types.hash_stable(hcx, hasher);\n+            upvar_list.hash_stable(hcx, hasher);\n         })\n     }\n }"}, {"sha": "cfd99948e4370424f991da6d61dc16a159006182", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/53aa8a1ad0fe12594347d68ee7f7c12e7c1a1937/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53aa8a1ad0fe12594347d68ee7f7c12e7c1a1937/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=53aa8a1ad0fe12594347d68ee7f7c12e7c1a1937", "patch": "@@ -808,6 +808,7 @@ pub struct UpvarBorrow<'tcx> {\n     pub region: ty::Region<'tcx>,\n }\n \n+pub type UpvarListMap = FxHashMap<DefId, Vec<UpvarId>>;\n pub type UpvarCaptureMap<'tcx> = FxHashMap<UpvarId, UpvarCapture<'tcx>>;\n \n #[derive(Copy, Clone)]"}, {"sha": "65ae111fbc0fcba1bf6b93c25aa565d671ea53b4", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/53aa8a1ad0fe12594347d68ee7f7c12e7c1a1937/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53aa8a1ad0fe12594347d68ee7f7c12e7c1a1937/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=53aa8a1ad0fe12594347d68ee7f7c12e7c1a1937", "patch": "@@ -4,7 +4,7 @@ use hair::cx::Cx;\n use hair::{LintLevel, BindingMode, PatternKind};\n use rustc::hir;\n use rustc::hir::Node;\n-use rustc::hir::def_id::{DefId, LocalDefId};\n+use rustc::hir::def_id::DefId;\n use rustc::middle::region;\n use rustc::mir::*;\n use rustc::mir::visit::{MutVisitor, TyContext};\n@@ -640,32 +640,39 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     let arguments: Vec<_> = arguments.collect();\n \n     let tcx = hir.tcx();\n-    let span = tcx.hir().span(fn_id);\n+    let tcx_hir = tcx.hir();\n+    let span = tcx_hir.span(fn_id);\n+\n+    let hir_tables = hir.tables();\n+    let fn_def_id = tcx_hir.local_def_id(fn_id);\n \n     // Gather the upvars of a closure, if any.\n-    let upvar_decls: Vec<_> = tcx.with_freevars(fn_id, |freevars| {\n-        freevars.iter().map(|fv| {\n-            let var_id = fv.var_id();\n-            let var_hir_id = tcx.hir().node_to_hir_id(var_id);\n-            let closure_expr_id = tcx.hir().local_def_id(fn_id);\n-            let capture = hir.tables().upvar_capture(ty::UpvarId {\n-                var_path: ty::UpvarPath {hir_id: var_hir_id},\n-                closure_expr_id: LocalDefId::from_def_id(closure_expr_id),\n-            });\n+    // In analyze_closure() in upvar.rs we gathered a list of upvars used by a\n+    // closure and we stored in a map called upvar_list in TypeckTables indexed\n+    // with the closure's DefId. Here, we run through that vec of UpvarIds for\n+    // the given closure and use the necessary information to create UpvarDecl.\n+    let upvar_decls: Vec<_> = hir_tables\n+        .upvar_list\n+        .get(&fn_def_id)\n+        .into_iter()\n+        .flatten()\n+        .map(|upvar_id| {\n+            let var_hir_id = upvar_id.var_path.hir_id;\n+            let var_node_id = tcx_hir.hir_to_node_id(var_hir_id);\n+            let capture = hir_tables.upvar_capture(*upvar_id);\n             let by_ref = match capture {\n                 ty::UpvarCapture::ByValue => false,\n-                ty::UpvarCapture::ByRef(..) => true\n+                ty::UpvarCapture::ByRef(..) => true,\n             };\n             let mut decl = UpvarDecl {\n                 debug_name: keywords::Invalid.name(),\n                 var_hir_id: ClearCrossCrate::Set(var_hir_id),\n                 by_ref,\n                 mutability: Mutability::Not,\n             };\n-            if let Some(Node::Binding(pat)) = tcx.hir().find(var_id) {\n+            if let Some(Node::Binding(pat)) = tcx_hir.find(var_node_id) {\n                 if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n                     decl.debug_name = ident.name;\n-\n                     if let Some(&bm) = hir.tables.pat_binding_modes().get(pat.hir_id) {\n                         if bm == ty::BindByValue(hir::MutMutable) {\n                             decl.mutability = Mutability::Mut;\n@@ -678,8 +685,8 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                 }\n             }\n             decl\n-        }).collect()\n-    });\n+        })\n+        .collect();\n \n     let mut builder = Builder::new(hir,\n         span,\n@@ -689,7 +696,6 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n         return_ty_span,\n         upvar_decls);\n \n-    let fn_def_id = tcx.hir().local_def_id(fn_id);\n     let call_site_scope = region::Scope {\n         id: body.value.hir_id.local_id,\n         data: region::ScopeData::CallSite\n@@ -732,7 +738,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n         // RustCall pseudo-ABI untuples the last argument.\n         spread_arg = Some(Local::new(arguments.len()));\n     }\n-    let closure_expr_id = tcx.hir().local_def_id(fn_id);\n+    let closure_expr_id = tcx_hir.local_def_id(fn_id);\n     info!(\"fn_id {:?} has attrs {:?}\", closure_expr_id,\n           tcx.get_attrs(closure_expr_id));\n "}, {"sha": "ffd7c2114e5ab34294c4f03584d02d669ce4cf42", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/53aa8a1ad0fe12594347d68ee7f7c12e7c1a1937/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53aa8a1ad0fe12594347d68ee7f7c12e7c1a1937/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=53aa8a1ad0fe12594347d68ee7f7c12e7c1a1937", "patch": "@@ -122,14 +122,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         self.tcx.with_freevars(closure_node_id, |freevars| {\n+            let mut freevar_list: Vec<ty::UpvarId> = Vec::with_capacity(freevars.len());\n             for freevar in freevars {\n                 let upvar_id = ty::UpvarId {\n                     var_path: ty::UpvarPath {\n-                        hir_id : self.tcx.hir().node_to_hir_id(freevar.var_id()),\n+                        hir_id: self.tcx.hir().node_to_hir_id(freevar.var_id()),\n                     },\n                     closure_expr_id: LocalDefId::from_def_id(closure_def_id),\n                 };\n                 debug!(\"seed upvar_id {:?}\", upvar_id);\n+                // Adding the upvar Id to the list of Upvars, which will be added\n+                // to the map for the closure at the end of the for loop.\n+                freevar_list.push(upvar_id);\n \n                 let capture_kind = match capture_clause {\n                     hir::CaptureByValue => ty::UpvarCapture::ByValue,\n@@ -149,6 +153,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     .upvar_capture_map\n                     .insert(upvar_id, capture_kind);\n             }\n+            // Add the vector of freevars to the map keyed with the closure id.\n+            // This gives us an easier access to them without having to call\n+            // with_freevars again..\n+            if !freevar_list.is_empty() {\n+                self.tables\n+                    .borrow_mut()\n+                    .upvar_list\n+                    .insert(closure_def_id, freevar_list);\n+            }\n         });\n \n         let body_owner_def_id = self.tcx.hir().body_owner_def_id(body.id());\n@@ -166,7 +179,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.param_env,\n             region_scope_tree,\n             &self.tables.borrow(),\n-        ).consume_body(body);\n+        )\n+        .consume_body(body);\n \n         if let Some(closure_substs) = infer_kind {\n             // Unify the (as yet unbound) type variable in the closure\n@@ -240,9 +254,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     let var_hir_id = tcx.hir().node_to_hir_id(var_node_id);\n                     let freevar_ty = self.node_ty(var_hir_id);\n                     let upvar_id = ty::UpvarId {\n-                        var_path: ty::UpvarPath {\n-                            hir_id: var_hir_id,\n-                        },\n+                        var_path: ty::UpvarPath { hir_id: var_hir_id },\n                         closure_expr_id: LocalDefId::from_def_id(closure_def_index),\n                     };\n                     let capture = self.tables.borrow().upvar_capture(upvar_id);\n@@ -262,7 +274,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             },\n                         ),\n                     }\n-                }).collect()\n+                })\n+                .collect()\n         })\n     }\n }"}, {"sha": "c61159eb4948121bb64bcfb2bfd46122a3bf3071", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/53aa8a1ad0fe12594347d68ee7f7c12e7c1a1937/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53aa8a1ad0fe12594347d68ee7f7c12e7c1a1937/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=53aa8a1ad0fe12594347d68ee7f7c12e7c1a1937", "patch": "@@ -21,6 +21,15 @@ use syntax_pos::Span;\n ///////////////////////////////////////////////////////////////////////////\n // Entry point\n \n+// During type inference, partially inferred types are\n+// represented using Type variables (ty::Infer). These don't appear in\n+// the final TypeckTables since all of the types should have been\n+// inferred once typeck_tables_of is done.\n+// When type inference is running however, having to update the typeck\n+// tables every time a new type is inferred would be unreasonably slow,\n+// so instead all of the replacement happens at the end in\n+// resolve_type_vars_in_body, which creates a new TypeTables which\n+// doesn't contain any inference types.\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn resolve_type_vars_in_body(&self, body: &'gcx hir::Body) -> &'gcx ty::TypeckTables<'gcx> {\n         let item_id = self.tcx.hir().body_owner(body.id());\n@@ -35,7 +44,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             wbcx.visit_node_id(arg.pat.span, arg.hir_id);\n         }\n         wbcx.visit_body(body);\n-        wbcx.visit_upvar_borrow_map();\n+        wbcx.visit_upvar_capture_map();\n+        wbcx.visit_upvar_list_map();\n         wbcx.visit_closures();\n         wbcx.visit_liberated_fn_sigs();\n         wbcx.visit_fru_field_types();\n@@ -291,7 +301,7 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n }\n \n impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n-    fn visit_upvar_borrow_map(&mut self) {\n+    fn visit_upvar_capture_map(&mut self) {\n         for (upvar_id, upvar_capture) in self.fcx.tables.borrow().upvar_capture_map.iter() {\n             let new_upvar_capture = match *upvar_capture {\n                 ty::UpvarCapture::ByValue => ty::UpvarCapture::ByValue,\n@@ -314,6 +324,21 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n+    /// Runs through the function context's upvar list map and adds the same to\n+    /// the TypeckTables. upvarlist is a hashmap of the list of upvars referred\n+    /// to in a closure..\n+    fn visit_upvar_list_map(&mut self) {\n+        for (closure_def_id, upvar_list) in self.fcx.tables.borrow().upvar_list.iter() {\n+            debug!(\n+                \"UpvarIDs captured by closure {:?} are: {:?}\",\n+                closure_def_id, upvar_list\n+            );\n+            self.tables\n+                .upvar_list\n+                .insert(*closure_def_id, upvar_list.to_vec());\n+        }\n+    }\n+\n     fn visit_closures(&mut self) {\n         let fcx_tables = self.fcx.tables.borrow();\n         debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);"}]}