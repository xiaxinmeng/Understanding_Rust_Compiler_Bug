{"sha": "3e98ab560a56492d70932066bb4d46f3a6a1bd4c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlOThhYjU2MGE1NjQ5MmQ3MDkzMjA2NmJiNGQ0NmYzYTZhMWJkNGM=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-03-14T00:36:41Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-03-17T19:00:21Z"}, "message": "rustc_trans: use the drop glue of T instead of Box<T> in Trait's vtable, be it &Trait or Box<Trait>.", "tree": {"sha": "daaa0e48d480df5385645fdd8becd429d6492cf9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/daaa0e48d480df5385645fdd8becd429d6492cf9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e98ab560a56492d70932066bb4d46f3a6a1bd4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e98ab560a56492d70932066bb4d46f3a6a1bd4c", "html_url": "https://github.com/rust-lang/rust/commit/3e98ab560a56492d70932066bb4d46f3a6a1bd4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e98ab560a56492d70932066bb4d46f3a6a1bd4c/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9", "html_url": "https://github.com/rust-lang/rust/commit/c64d671671aea2e44ee7fc6eb00ee75fc30ed7b9"}], "stats": {"total": 312, "additions": 90, "deletions": 222}, "files": [{"sha": "bd9313ee9b01378f02292b2801c129d78c33a892", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e98ab560a56492d70932066bb4d46f3a6a1bd4c/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e98ab560a56492d70932066bb4d46f3a6a1bd4c/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=3e98ab560a56492d70932066bb4d46f3a6a1bd4c", "patch": "@@ -660,7 +660,7 @@ fn bind_subslice_pat(bcx: Block,\n                      offset_right: uint) -> ValueRef {\n     let _icx = push_ctxt(\"match::bind_subslice_pat\");\n     let vec_ty = node_id_type(bcx, pat_id);\n-    let vt = tvec::vec_types(bcx, ty::sequence_element_type(bcx.tcx(), ty::type_content(vec_ty)));\n+    let unit_ty = ty::sequence_element_type(bcx.tcx(), ty::type_content(vec_ty));\n     let vec_datum = match_datum(val, vec_ty);\n     let (base, len) = vec_datum.get_vec_base_and_len(bcx);\n \n@@ -669,7 +669,7 @@ fn bind_subslice_pat(bcx: Block,\n     let slice_len = Sub(bcx, len, slice_len_offset, DebugLoc::None);\n     let slice_ty = ty::mk_slice(bcx.tcx(),\n                                 bcx.tcx().mk_region(ty::ReStatic),\n-                                ty::mt {ty: vt.unit_ty, mutbl: ast::MutImmutable});\n+                                ty::mt {ty: unit_ty, mutbl: ast::MutImmutable});\n     let scratch = rvalue_scratch_datum(bcx, slice_ty, \"\");\n     Store(bcx, slice_begin,\n           GEPi(bcx, scratch.val, &[0, abi::FAT_PTR_ADDR]));"}, {"sha": "3e0df733e9d1526e06a9e3b7f9b880b901a34cd7", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e98ab560a56492d70932066bb4d46f3a6a1bd4c/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e98ab560a56492d70932066bb4d46f3a6a1bd4c/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=3e98ab560a56492d70932066bb4d46f3a6a1bd4c", "patch": "@@ -702,6 +702,10 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n         let unit_ty = ty::sequence_element_type(cx.tcx(), t);\n         cx = tvec::iter_vec_raw(cx, base, unit_ty, len, f);\n       }\n+      ty::ty_vec(_, None) | ty::ty_str => {\n+        let unit_ty = ty::sequence_element_type(cx.tcx(), t);\n+        cx = tvec::iter_vec_raw(cx, data_ptr, unit_ty, info.unwrap(), f);\n+      }\n       ty::ty_tup(ref args) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n           for (i, arg) in args.iter().enumerate() {"}, {"sha": "9d2b20f288a791fbea17f68416880da66611a2a1", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3e98ab560a56492d70932066bb4d46f3a6a1bd4c/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e98ab560a56492d70932066bb4d46f3a6a1bd4c/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=3e98ab560a56492d70932066bb4d46f3a6a1bd4c", "patch": "@@ -314,7 +314,6 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                     let info =\n                         expr::unsized_info(\n                             cx, k, e.id, ty, param_substs,\n-                            |t| ty::mk_imm_rptr(cx.tcx(), cx.tcx().mk_region(ty::ReStatic), t),\n                             || const_get_elt(cx, llconst, &[abi::FAT_PTR_EXTRA as u32]));\n \n                     let unsized_ty = ty::unsize_ty(cx.tcx(), ty, k, e.span);"}, {"sha": "da04768ee06e1250b48c5049388271af31ad21ec", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e98ab560a56492d70932066bb4d46f3a6a1bd4c/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e98ab560a56492d70932066bb4d46f3a6a1bd4c/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=3e98ab560a56492d70932066bb4d46f3a6a1bd4c", "patch": "@@ -102,7 +102,7 @@ pub struct LocalCrateContext<'tcx> {\n     monomorphized: RefCell<FnvHashMap<MonoId<'tcx>, ValueRef>>,\n     monomorphizing: RefCell<DefIdMap<uint>>,\n     /// Cache generated vtables\n-    vtables: RefCell<FnvHashMap<(Ty<'tcx>, ty::PolyTraitRef<'tcx>), ValueRef>>,\n+    vtables: RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>, ValueRef>>,\n     /// Cache of constant strings,\n     const_cstr_cache: RefCell<FnvHashMap<InternedString, ValueRef>>,\n \n@@ -614,8 +614,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         &self.local.monomorphizing\n     }\n \n-    pub fn vtables<'a>(&'a self) -> &'a RefCell<FnvHashMap<(Ty<'tcx>, ty::PolyTraitRef<'tcx>),\n-                                                            ValueRef>> {\n+    pub fn vtables<'a>(&'a self) -> &'a RefCell<FnvHashMap<ty::PolyTraitRef<'tcx>, ValueRef>> {\n         &self.local.vtables\n     }\n "}, {"sha": "6de67754f11622879f29c80e3dc5af536bf112fa", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 16, "deletions": 39, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/3e98ab560a56492d70932066bb4d46f3a6a1bd4c/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e98ab560a56492d70932066bb4d46f3a6a1bd4c/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=3e98ab560a56492d70932066bb4d46f3a6a1bd4c", "patch": "@@ -288,64 +288,47 @@ pub fn get_dataptr(bcx: Block, fat_ptr: ValueRef) -> ValueRef {\n // Retrieve the information we are losing (making dynamic) in an unsizing\n // adjustment.\n //\n-// When making a dtor, we need to do different things depending on the\n-// ownership of the object.. mk_ty is a function for turning `unadjusted_ty`\n-// into a type to be destructed. If we want to end up with a Box pointer,\n-// then mk_ty should make a Box pointer (T -> Box<T>), if we want a\n-// borrowed reference then it should be T -> &T.\n-//\n // The `unadjusted_val` argument is a bit funny. It is intended\n // for use in an upcast, where the new vtable for an object will\n // be drived from the old one. Hence it is a pointer to the fat\n // pointer.\n-pub fn unsized_info_bcx<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n-                                       kind: &ty::UnsizeKind<'tcx>,\n-                                       id: ast::NodeId,\n-                                       unadjusted_ty: Ty<'tcx>,\n-                                       unadjusted_val: ValueRef, // see above (*)\n-                                       param_substs: &'tcx subst::Substs<'tcx>,\n-                                       mk_ty: F)\n-                                       -> ValueRef\n-    where F: FnOnce(Ty<'tcx>) -> Ty<'tcx>\n-{\n+pub fn unsized_info_bcx<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                                    kind: &ty::UnsizeKind<'tcx>,\n+                                    id: ast::NodeId,\n+                                    unadjusted_ty: Ty<'tcx>,\n+                                    unadjusted_val: ValueRef, // see above (*)\n+                                    param_substs: &'tcx subst::Substs<'tcx>)\n+                                    -> ValueRef {\n     unsized_info(\n         bcx.ccx(),\n         kind,\n         id,\n         unadjusted_ty,\n         param_substs,\n-        mk_ty,\n         || Load(bcx, GEPi(bcx, unadjusted_val, &[0, abi::FAT_PTR_EXTRA])))\n }\n \n // Same as `unsize_info_bcx`, but does not require a bcx -- instead it\n // takes an extra closure to compute the upcast vtable.\n-pub fn unsized_info<'ccx, 'tcx, MK_TY, MK_UPCAST_VTABLE>(\n+pub fn unsized_info<'ccx, 'tcx, MK_UPCAST_VTABLE>(\n     ccx: &CrateContext<'ccx, 'tcx>,\n     kind: &ty::UnsizeKind<'tcx>,\n     id: ast::NodeId,\n     unadjusted_ty: Ty<'tcx>,\n     param_substs: &'tcx subst::Substs<'tcx>,\n-    mk_ty: MK_TY,\n     mk_upcast_vtable: MK_UPCAST_VTABLE) // see notes above\n     -> ValueRef\n-    where MK_TY: FnOnce(Ty<'tcx>) -> Ty<'tcx>,\n-          MK_UPCAST_VTABLE: FnOnce() -> ValueRef,\n+    where MK_UPCAST_VTABLE: FnOnce() -> ValueRef\n {\n-    // FIXME(#19596) workaround: `|t| t` causes monomorphization recursion\n-    fn identity<T>(t: T) -> T { t }\n-\n     debug!(\"unsized_info(kind={:?}, id={}, unadjusted_ty={})\",\n            kind, id, unadjusted_ty.repr(ccx.tcx()));\n     match kind {\n         &ty::UnsizeLength(len) => C_uint(ccx, len),\n         &ty::UnsizeStruct(box ref k, tp_index) => match unadjusted_ty.sty {\n             ty::ty_struct(_, ref substs) => {\n                 let ty_substs = substs.types.get_slice(subst::TypeSpace);\n-                // The dtor for a field treats it like a value, so mk_ty\n-                // should just be the identity function.\n                 unsized_info(ccx, k, id, ty_substs[tp_index], param_substs,\n-                             identity, mk_upcast_vtable)\n+                             mk_upcast_vtable)\n             }\n             _ => ccx.sess().bug(&format!(\"UnsizeStruct with bad sty: {}\",\n                                          unadjusted_ty.repr(ccx.tcx())))\n@@ -359,8 +342,7 @@ pub fn unsized_info<'ccx, 'tcx, MK_TY, MK_UPCAST_VTABLE>(\n             let trait_ref = monomorphize::apply_param_substs(ccx.tcx(),\n                                                              param_substs,\n                                                              &trait_ref);\n-            let box_ty = mk_ty(unadjusted_ty);\n-            consts::ptrcast(meth::get_vtable(ccx, box_ty, trait_ref, param_substs),\n+            consts::ptrcast(meth::get_vtable(ccx, trait_ref, param_substs),\n                             Type::vtable_ptr(ccx))\n         }\n         &ty::UnsizeUpcast(_) => {\n@@ -498,8 +480,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let unsized_ty = ty::unsize_ty(tcx, datum_ty, k, expr.span);\n         debug!(\"unsized_ty={}\", unsized_ty.repr(bcx.tcx()));\n \n-        let info = unsized_info_bcx(bcx, k, expr.id, datum_ty, datum.val, bcx.fcx.param_substs,\n-                                    |t| ty::mk_imm_rptr(tcx, tcx.mk_region(ty::ReStatic), t));\n+        let info = unsized_info_bcx(bcx, k, expr.id, datum_ty, datum.val, bcx.fcx.param_substs);\n \n         // Arrange cleanup\n         let lval = unpack_datum!(bcx, datum.to_lvalue_datum(bcx, \"into_fat_ptr\", expr.id));\n@@ -590,8 +571,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let base = PointerCast(bcx, get_dataptr(bcx, scratch.val), llbox_ty.ptr_to());\n         bcx = datum.store_to(bcx, base);\n \n-        let info = unsized_info_bcx(bcx, k, expr.id, unboxed_ty, base, bcx.fcx.param_substs,\n-                                    |t| ty::mk_uniq(tcx, t));\n+        let info = unsized_info_bcx(bcx, k, expr.id, unboxed_ty, base, bcx.fcx.param_substs);\n         Store(bcx, info, get_len(bcx, scratch.val));\n \n         DatumBlock::new(bcx, scratch.to_expr_datum())\n@@ -888,10 +868,7 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 }\n             };\n \n-            let vt =\n-                tvec::vec_types(bcx,\n-                                ty::sequence_element_type(bcx.tcx(),\n-                                                          base_datum.ty));\n+            let unit_ty = ty::sequence_element_type(bcx.tcx(), base_datum.ty);\n \n             let (base, len) = base_datum.get_vec_base_and_len(bcx);\n \n@@ -916,8 +893,8 @@ fn trans_index<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                                      len)\n             });\n             let elt = InBoundsGEP(bcx, base, &[ix_val]);\n-            let elt = PointerCast(bcx, elt, vt.llunit_ty.ptr_to());\n-            Datum::new(elt, vt.unit_ty, LvalueExpr)\n+            let elt = PointerCast(bcx, elt, type_of::type_of(ccx, unit_ty).ptr_to());\n+            Datum::new(elt, unit_ty, LvalueExpr)\n         }\n     };\n "}, {"sha": "a9375ebe57d59453079c53d624ce9a0f77a416a5", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 32, "deletions": 65, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/3e98ab560a56492d70932066bb4d46f3a6a1bd4c/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e98ab560a56492d70932066bb4d46f3a6a1bd4c/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=3e98ab560a56492d70932066bb4d46f3a6a1bd4c", "patch": "@@ -32,7 +32,6 @@ use trans::datum;\n use trans::debuginfo::DebugLoc;\n use trans::expr;\n use trans::machine::*;\n-use trans::tvec;\n use trans::type_::Type;\n use trans::type_of::{self, type_of, sizing_type_of, align_of};\n use middle::ty::{self, Ty};\n@@ -386,51 +385,34 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n     let _icx = push_ctxt(\"make_drop_glue\");\n     match t.sty {\n         ty::ty_uniq(content_ty) => {\n-            match content_ty.sty {\n-                ty::ty_vec(ty, None) => {\n-                    tvec::make_drop_glue_unboxed(bcx, v0, ty, true)\n-                }\n-                ty::ty_str => {\n-                    let unit_ty = ty::sequence_element_type(bcx.tcx(), content_ty);\n-                    tvec::make_drop_glue_unboxed(bcx, v0, unit_ty, true)\n-                }\n-                ty::ty_trait(..) => {\n-                    let lluniquevalue = GEPi(bcx, v0, &[0, abi::FAT_PTR_ADDR]);\n-                    // Only drop the value when it is non-null\n-                    let concrete_ptr = Load(bcx, lluniquevalue);\n-                    with_cond(bcx, IsNotNull(bcx, concrete_ptr), |bcx| {\n-                        let dtor_ptr = Load(bcx, GEPi(bcx, v0, &[0, abi::FAT_PTR_EXTRA]));\n-                        let dtor = Load(bcx, dtor_ptr);\n-                        Call(bcx,\n-                             dtor,\n-                             &[PointerCast(bcx, lluniquevalue, Type::i8p(bcx.ccx()))],\n-                             None,\n-                             DebugLoc::None);\n-                        bcx\n-                    })\n-                }\n-                ty::ty_struct(..) if !type_is_sized(bcx.tcx(), content_ty) => {\n-                    let llval = GEPi(bcx, v0, &[0, abi::FAT_PTR_ADDR]);\n-                    let llbox = Load(bcx, llval);\n-                    let not_null = IsNotNull(bcx, llbox);\n-                    with_cond(bcx, not_null, |bcx| {\n-                        let bcx = drop_ty(bcx, v0, content_ty, DebugLoc::None);\n-                        let info = GEPi(bcx, v0, &[0, abi::FAT_PTR_EXTRA]);\n-                        let info = Load(bcx, info);\n-                        let (llsize, llalign) = size_and_align_of_dst(bcx, content_ty, info);\n+            if !type_is_sized(bcx.tcx(), content_ty) {\n+                let llval = GEPi(bcx, v0, &[0, abi::FAT_PTR_ADDR]);\n+                let llbox = Load(bcx, llval);\n+                let not_null = IsNotNull(bcx, llbox);\n+                with_cond(bcx, not_null, |bcx| {\n+                    let bcx = drop_ty(bcx, v0, content_ty, DebugLoc::None);\n+                    let info = GEPi(bcx, v0, &[0, abi::FAT_PTR_EXTRA]);\n+                    let info = Load(bcx, info);\n+                    let (llsize, llalign) = size_and_align_of_dst(bcx, content_ty, info);\n+\n+                    // `Box<ZeroSizeType>` does not allocate.\n+                    let needs_free = ICmp(bcx,\n+                                          llvm::IntNE,\n+                                          llsize,\n+                                          C_uint(bcx.ccx(), 0u64),\n+                                          DebugLoc::None);\n+                    with_cond(bcx, needs_free, |bcx| {\n                         trans_exchange_free_dyn(bcx, llbox, llsize, llalign, DebugLoc::None)\n                     })\n-                }\n-                _ => {\n-                    assert!(type_is_sized(bcx.tcx(), content_ty));\n-                    let llval = v0;\n-                    let llbox = Load(bcx, llval);\n-                    let not_null = IsNotNull(bcx, llbox);\n-                    with_cond(bcx, not_null, |bcx| {\n-                        let bcx = drop_ty(bcx, llbox, content_ty, DebugLoc::None);\n-                        trans_exchange_free_ty(bcx, llbox, content_ty, DebugLoc::None)\n-                    })\n-                }\n+                })\n+            } else {\n+                let llval = v0;\n+                let llbox = Load(bcx, llval);\n+                let not_null = IsNotNull(bcx, llbox);\n+                with_cond(bcx, not_null, |bcx| {\n+                    let bcx = drop_ty(bcx, llbox, content_ty, DebugLoc::None);\n+                    trans_exchange_free_ty(bcx, llbox, content_ty, DebugLoc::None)\n+                })\n             }\n         }\n         ty::ty_struct(did, substs) | ty::ty_enum(did, substs) => {\n@@ -462,34 +444,19 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                 }\n             }\n         }\n-        ty::ty_closure(..) => {\n-            iter_structural_ty(bcx,\n-                               v0,\n-                               t,\n-                               |bb, vv, tt| drop_ty(bb, vv, tt, DebugLoc::None))\n-        }\n         ty::ty_trait(..) => {\n-            // No need to do a null check here (as opposed to the Box<trait case\n-            // above), because this happens for a trait field in an unsized\n-            // struct. If anything is null, it is the whole struct and we won't\n-            // get here.\n-            let lluniquevalue = GEPi(bcx, v0, &[0, abi::FAT_PTR_ADDR]);\n-            let dtor_ptr = Load(bcx, GEPi(bcx, v0, &[0, abi::FAT_PTR_EXTRA]));\n-            let dtor = Load(bcx, dtor_ptr);\n+            let data_ptr = GEPi(bcx, v0, &[0, abi::FAT_PTR_ADDR]);\n+            let vtable_ptr = Load(bcx, GEPi(bcx, v0, &[0, abi::FAT_PTR_EXTRA]));\n+            let dtor = Load(bcx, vtable_ptr);\n             Call(bcx,\n                  dtor,\n-                 &[PointerCast(bcx, Load(bcx, lluniquevalue), Type::i8p(bcx.ccx()))],\n+                 &[PointerCast(bcx, Load(bcx, data_ptr), Type::i8p(bcx.ccx()))],\n                  None,\n                  DebugLoc::None);\n             bcx\n-        },\n-        ty::ty_vec(_, None) | ty::ty_str => {\n-            let unit_ty = ty::sequence_element_type(bcx.tcx(), t);\n-            tvec::make_drop_glue_unboxed(bcx, v0, unit_ty, false)\n-        },\n+        }\n         _ => {\n-            assert!(type_is_sized(bcx.tcx(), t));\n-            if bcx.fcx.type_needs_drop(t) && ty::type_is_structural(t) {\n+            if bcx.fcx.type_needs_drop(t) {\n                 iter_structural_ty(bcx,\n                                    v0,\n                                    t,"}, {"sha": "3f67c211f8c658043347fc670f003ba7445c4aef", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/3e98ab560a56492d70932066bb4d46f3a6a1bd4c/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e98ab560a56492d70932066bb4d46f3a6a1bd4c/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=3e98ab560a56492d70932066bb4d46f3a6a1bd4c", "patch": "@@ -680,25 +680,19 @@ pub fn trans_object_shim<'a, 'tcx>(\n ///\n /// The `trait_ref` encodes the erased self type. Hence if we are\n /// making an object `Foo<Trait>` from a value of type `Foo<T>`, then\n-/// `trait_ref` would map `T:Trait`, but `box_ty` would be\n-/// `Foo<T>`. This `box_ty` is primarily used to encode the destructor.\n-/// This will hopefully change now that DST is underway.\n+/// `trait_ref` would map `T:Trait`.\n pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                            box_ty: Ty<'tcx>,\n                             trait_ref: ty::PolyTraitRef<'tcx>,\n                             param_substs: &'tcx subst::Substs<'tcx>)\n                             -> ValueRef\n {\n     let tcx = ccx.tcx();\n     let _icx = push_ctxt(\"meth::get_vtable\");\n \n-    debug!(\"get_vtable(box_ty={}, trait_ref={})\",\n-           box_ty.repr(tcx),\n-           trait_ref.repr(tcx));\n+    debug!(\"get_vtable(trait_ref={})\", trait_ref.repr(tcx));\n \n     // Check the cache.\n-    let cache_key = (box_ty, trait_ref.clone());\n-    match ccx.vtables().borrow().get(&cache_key) {\n+    match ccx.vtables().borrow().get(&trait_ref) {\n         Some(&val) => { return val }\n         None => { }\n     }\n@@ -755,15 +749,15 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let components: Vec<_> = vec![\n         // Generate a destructor for the vtable.\n-        glue::get_drop_glue(ccx, box_ty),\n+        glue::get_drop_glue(ccx, trait_ref.self_ty()),\n         C_uint(ccx, size),\n         C_uint(ccx, align)\n     ].into_iter().chain(methods).collect();\n \n     let vtable = consts::addr_of(ccx, C_struct(ccx, &components, false),\n                                  \"vtable\", trait_ref.def_id().node);\n \n-    ccx.vtables().borrow_mut().insert(cache_key, vtable);\n+    ccx.vtables().borrow_mut().insert(trait_ref, vtable);\n     vtable\n }\n \n@@ -842,16 +836,15 @@ pub fn trans_trait_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     debug!(\"trans_trait_cast: trait_ref={}\",\n            trait_ref.repr(bcx.tcx()));\n \n-    let datum_ty = datum.ty;\n-    let llbox_ty = type_of(bcx.ccx(), datum_ty);\n+    let llty = type_of(bcx.ccx(), datum.ty);\n \n     // Store the pointer into the first half of pair.\n     let llboxdest = GEPi(bcx, lldest, &[0, abi::FAT_PTR_ADDR]);\n-    let llboxdest = PointerCast(bcx, llboxdest, llbox_ty.ptr_to());\n+    let llboxdest = PointerCast(bcx, llboxdest, llty.ptr_to());\n     bcx = datum.store_to(bcx, llboxdest);\n \n     // Store the vtable into the second half of pair.\n-    let vtable = get_vtable(bcx.ccx(), datum_ty, trait_ref, bcx.fcx.param_substs);\n+    let vtable = get_vtable(bcx.ccx(), trait_ref, bcx.fcx.param_substs);\n     let llvtabledest = GEPi(bcx, lldest, &[0, abi::FAT_PTR_EXTRA]);\n     let llvtabledest = PointerCast(bcx, llvtabledest, val_ty(vtable).ptr_to());\n     Store(bcx, vtable, llvtabledest);"}, {"sha": "6a35a1a55b6f7cd9ecabc842d432b08e8421ea0e", "filename": "src/librustc_trans/trans/tvec.rs", "status": "modified", "additions": 26, "deletions": 97, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/3e98ab560a56492d70932066bb4d46f3a6a1bd4c/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e98ab560a56492d70932066bb4d46f3a6a1bd4c/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftvec.rs?ref=3e98ab560a56492d70932066bb4d46f3a6a1bd4c", "patch": "@@ -24,8 +24,6 @@ use trans::datum::*;\n use trans::debuginfo::DebugLoc;\n use trans::expr::{Dest, Ignore, SaveIn};\n use trans::expr;\n-use trans::glue;\n-use trans::machine;\n use trans::machine::llsize_of_alloc;\n use trans::type_::Type;\n use trans::type_of;\n@@ -35,79 +33,17 @@ use util::ppaux::ty_to_string;\n use syntax::ast;\n use syntax::parse::token::InternedString;\n \n-fn get_len(bcx: Block, vptr: ValueRef) -> ValueRef {\n-    let _icx = push_ctxt(\"tvec::get_lenl\");\n-    Load(bcx, expr::get_len(bcx, vptr))\n-}\n-\n-fn get_dataptr(bcx: Block, vptr: ValueRef) -> ValueRef {\n-    let _icx = push_ctxt(\"tvec::get_dataptr\");\n-    Load(bcx, expr::get_dataptr(bcx, vptr))\n-}\n-\n-pub fn make_drop_glue_unboxed<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                          vptr: ValueRef,\n-                                          unit_ty: Ty<'tcx>,\n-                                          should_deallocate: bool)\n-                                          -> Block<'blk, 'tcx> {\n-    let not_null = IsNotNull(bcx, vptr);\n-    with_cond(bcx, not_null, |bcx| {\n-        let ccx = bcx.ccx();\n-        let _icx = push_ctxt(\"tvec::make_drop_glue_unboxed\");\n-\n-        let dataptr = get_dataptr(bcx, vptr);\n-        let bcx = if bcx.fcx.type_needs_drop(unit_ty) {\n-            let len = get_len(bcx, vptr);\n-            iter_vec_raw(bcx,\n-                         dataptr,\n-                         unit_ty,\n-                         len,\n-                         |bb, vv, tt| glue::drop_ty(bb, vv, tt, DebugLoc::None))\n-        } else {\n-            bcx\n-        };\n-\n-        if should_deallocate {\n-            let llty = type_of::type_of(ccx, unit_ty);\n-            let unit_size = llsize_of_alloc(ccx, llty);\n-            if unit_size != 0 {\n-                let len = get_len(bcx, vptr);\n-                let not_empty = ICmp(bcx,\n-                                     llvm::IntNE,\n-                                     len,\n-                                     C_uint(ccx, 0_u32),\n-                                     DebugLoc::None);\n-                with_cond(bcx, not_empty, |bcx| {\n-                    let llalign = C_uint(ccx, machine::llalign_of_min(ccx, llty));\n-                    let size = Mul(bcx, C_uint(ccx, unit_size), len, DebugLoc::None);\n-                    glue::trans_exchange_free_dyn(bcx,\n-                                                  dataptr,\n-                                                  size,\n-                                                  llalign,\n-                                                  DebugLoc::None)\n-                })\n-            } else {\n-                bcx\n-            }\n-        } else {\n-            bcx\n-        }\n-    })\n-}\n-\n #[derive(Copy)]\n-pub struct VecTypes<'tcx> {\n-    pub unit_ty: Ty<'tcx>,\n-    pub llunit_ty: Type,\n-    pub llunit_alloc_size: u64\n+struct VecTypes<'tcx> {\n+    unit_ty: Ty<'tcx>,\n+    llunit_ty: Type\n }\n \n impl<'tcx> VecTypes<'tcx> {\n     pub fn to_string<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> String {\n-        format!(\"VecTypes {{unit_ty={}, llunit_ty={}, llunit_alloc_size={}}}\",\n+        format!(\"VecTypes {{unit_ty={}, llunit_ty={}}}\",\n                 ty_to_string(ccx.tcx(), self.unit_ty),\n-                ccx.tn().type_to_string(self.llunit_ty),\n-                self.llunit_alloc_size)\n+                ccx.tn().type_to_string(self.llunit_ty))\n     }\n }\n \n@@ -221,12 +157,12 @@ pub fn trans_lit_str<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-pub fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                 vt: &VecTypes<'tcx>,\n-                                 vstore_expr: &ast::Expr,\n-                                 content_expr: &ast::Expr,\n-                                 dest: Dest)\n-                                 -> Block<'blk, 'tcx> {\n+fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n+                             vt: &VecTypes<'tcx>,\n+                             vstore_expr: &ast::Expr,\n+                             content_expr: &ast::Expr,\n+                             dest: Dest)\n+                             -> Block<'blk, 'tcx> {\n     let _icx = push_ctxt(\"tvec::write_content\");\n     let fcx = bcx.fcx;\n     let mut bcx = bcx;\n@@ -315,28 +251,21 @@ pub fn write_content<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-pub fn vec_types_from_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                       vec_expr: &ast::Expr)\n-                                       -> VecTypes<'tcx> {\n+fn vec_types_from_expr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, vec_expr: &ast::Expr)\n+                                   -> VecTypes<'tcx> {\n     let vec_ty = node_id_type(bcx, vec_expr.id);\n     vec_types(bcx, ty::sequence_element_type(bcx.tcx(), vec_ty))\n }\n \n-pub fn vec_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                             unit_ty: Ty<'tcx>)\n-                             -> VecTypes<'tcx> {\n-    let ccx = bcx.ccx();\n-    let llunit_ty = type_of::type_of(ccx, unit_ty);\n-    let llunit_alloc_size = llsize_of_alloc(ccx, llunit_ty);\n-\n+fn vec_types<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, unit_ty: Ty<'tcx>)\n+                         -> VecTypes<'tcx> {\n     VecTypes {\n         unit_ty: unit_ty,\n-        llunit_ty: llunit_ty,\n-        llunit_alloc_size: llunit_alloc_size\n+        llunit_ty: type_of::type_of(bcx.ccx(), unit_ty)\n     }\n }\n \n-pub fn elements_required(bcx: Block, content_expr: &ast::Expr) -> uint {\n+fn elements_required(bcx: Block, content_expr: &ast::Expr) -> uint {\n     //! Figure out the number of elements we need to store this content\n \n     match content_expr.node {\n@@ -401,12 +330,12 @@ pub fn get_base_and_len<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n }\n \n-pub fn iter_vec_loop<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n-                                     data_ptr: ValueRef,\n-                                     vt: &VecTypes<'tcx>,\n-                                     count: ValueRef,\n-                                     f: F)\n-                                     -> Block<'blk, 'tcx> where\n+fn iter_vec_loop<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n+                                data_ptr: ValueRef,\n+                                vt: &VecTypes<'tcx>,\n+                                count: ValueRef,\n+                                f: F)\n+                                -> Block<'blk, 'tcx> where\n     F: FnOnce(Block<'blk, 'tcx>, ValueRef, Ty<'tcx>) -> Block<'blk, 'tcx>,\n {\n     let _icx = push_ctxt(\"tvec::iter_vec_loop\");\n@@ -426,7 +355,7 @@ pub fn iter_vec_loop<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n     let bcx = loop_bcx;\n \n-    let lleltptr = if vt.llunit_alloc_size == 0 {\n+    let lleltptr = if llsize_of_alloc(bcx.ccx(), vt.llunit_ty) == 0 {\n         data_ptr\n     } else {\n         InBoundsGEP(bcx, data_ptr, &[loop_counter])\n@@ -454,7 +383,7 @@ pub fn iter_vec_raw<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n     let vt = vec_types(bcx, unit_ty);\n \n-    if vt.llunit_alloc_size == 0 {\n+    if llsize_of_alloc(bcx.ccx(), vt.llunit_ty) == 0 {\n         // Special-case vectors with elements of size 0  so they don't go out of bounds (#9890)\n         iter_vec_loop(bcx, data_ptr, &vt, len, f)\n     } else {\n@@ -471,7 +400,7 @@ pub fn iter_vec_raw<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         let body_bcx = fcx.new_temp_block(\"iter_vec_loop_body\");\n         let next_bcx = fcx.new_temp_block(\"iter_vec_next\");\n         CondBr(header_bcx, not_yet_at_end, body_bcx.llbb, next_bcx.llbb, DebugLoc::None);\n-        let body_bcx = f(body_bcx, data_ptr, vt.unit_ty);\n+        let body_bcx = f(body_bcx, data_ptr, unit_ty);\n         AddIncomingToPhi(data_ptr, InBoundsGEP(body_bcx, data_ptr,\n                                                &[C_int(bcx.ccx(), 1)]),\n                          body_bcx.llbb);"}]}