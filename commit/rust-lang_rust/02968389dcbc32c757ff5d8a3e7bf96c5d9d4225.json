{"sha": "02968389dcbc32c757ff5d8a3e7bf96c5d9d4225", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyOTY4Mzg5ZGNiYzMyYzc1N2ZmNWQ4YTNlN2JmOTZjNWQ5ZDQyMjU=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-01-16T21:21:06Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-01-17T15:51:07Z"}, "message": "Beef up Copy documentation\n\nFixes #21249\nFixes #11540", "tree": {"sha": "67f10a540e6f964b71c7dbe634b3bbba17734798", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67f10a540e6f964b71c7dbe634b3bbba17734798"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02968389dcbc32c757ff5d8a3e7bf96c5d9d4225", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02968389dcbc32c757ff5d8a3e7bf96c5d9d4225", "html_url": "https://github.com/rust-lang/rust/commit/02968389dcbc32c757ff5d8a3e7bf96c5d9d4225", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02968389dcbc32c757ff5d8a3e7bf96c5d9d4225/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "433ea0bd555977ae4defee7b6aeb65a05be747f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/433ea0bd555977ae4defee7b6aeb65a05be747f2", "html_url": "https://github.com/rust-lang/rust/commit/433ea0bd555977ae4defee7b6aeb65a05be747f2"}], "stats": {"total": 98, "additions": 98, "deletions": 0}, "files": [{"sha": "99ba9666cd2963157fb52ee4be2c28c0a466eefd", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/02968389dcbc32c757ff5d8a3e7bf96c5d9d4225/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02968389dcbc32c757ff5d8a3e7bf96c5d9d4225/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=02968389dcbc32c757ff5d8a3e7bf96c5d9d4225", "patch": "@@ -42,6 +42,104 @@ pub trait Sized {\n }\n \n /// Types that can be copied by simply copying bits (i.e. `memcpy`).\n+///\n+/// By default, variable bindings have 'move semantics.' In other\n+/// words:\n+///\n+/// ```\n+/// #[derive(Show)]\n+/// struct Foo;\n+///\n+/// let x = Foo;\n+///\n+/// let y = x;\n+///\n+/// // `x` has moved into `y`, and so cannot be used\n+///\n+/// // println!(\"{:?}\", x); // error: use of moved value\n+/// ```\n+///\n+/// However, if a type implements `Copy`, it instead has 'copy semantics':\n+///\n+/// ```\n+/// // we can just derive a `Copy` implementation\n+/// #[derive(Show, Copy)]\n+/// struct Foo;\n+///\n+/// let x = Foo;\n+///\n+/// let y = x;\n+///\n+/// // `y` is a copy of `x`\n+///\n+/// println!(\"{:?}\", x); // A-OK!\n+/// ```\n+///\n+/// It's important to note that in these two examples, the only difference is if you are allowed to\n+/// access `x` after the assignment: a move is also a bitwise copy under the hood.\n+///\n+/// ## When can my type be `Copy`?\n+///\n+/// A type can implement `Copy` if all of its components implement `Copy`. For example, this\n+/// `struct` can be `Copy`:\n+///\n+/// ```\n+/// struct Point {\n+///    x: i32,\n+///    y: i32,\n+/// }\n+/// ```\n+///\n+/// A `struct` can be `Copy`, and `i32` is `Copy`, so therefore, `Point` is eligible to be `Copy`.\n+///\n+/// ```\n+/// # struct Point;\n+/// struct PointList {\n+///     points: Vec<Point>,\n+/// }\n+/// ```\n+///\n+/// The `PointList` `struct` cannot implement `Copy`, because `Vec<T>` is not `Copy`. If we\n+/// attempt to derive a `Copy` implementation, we'll get an error.\n+///\n+/// ```text\n+/// error: the trait `Copy` may not be implemented for this type; field `points` does not implement\n+/// `Copy`\n+/// ```\n+///\n+/// ## How can I implement `Copy`?\n+///\n+/// There are two ways to implement `Copy` on your type:\n+///\n+/// ```\n+/// #[derive(Copy)]\n+/// struct MyStruct;\n+/// ```\n+///\n+/// and\n+///\n+/// ```\n+/// struct MyStruct;\n+/// impl Copy for MyStruct {}\n+/// ```\n+///\n+/// There is a small difference between the two: the `derive` strategy will also place a `Copy`\n+/// bound on type parameters, which isn't always desired.\n+///\n+/// ## When can my type _not_ be `Copy`?\n+///\n+/// Some types can't be copied safely. For example, copying `&mut T` would create an aliased\n+/// mutable reference, and copying `String` would result in two attempts to free the same buffer.\n+///\n+/// Generalizing the latter case, any type implementing `Drop` can't be `Copy`, because it's\n+/// managing some resource besides its own `size_of::<T>()` bytes.\n+///\n+/// ## When should my type be `Copy`?\n+///\n+/// Generally speaking, if your type _can_ implement `Copy`, it should. There's one important thing\n+/// to consider though: if you think your type may _not_ be able to implement `Copy` in the future,\n+/// then it might be prudent to not implement `Copy`. This is because removing `Copy` is a breaking\n+/// change: that second example would fail to compile if we made `Foo` non-`Copy`.\n #[stable]\n #[lang=\"copy\"]\n pub trait Copy {"}]}