{"sha": "e59a4584c98e0eb21be5ba0a972a647025f14df5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1OWE0NTg0Yzk4ZTBlYjIxYmU1YmEwYTk3MmE2NDcwMjVmMTRkZjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-02T08:46:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-02T08:46:05Z"}, "message": "auto merge of #16805 : nick29581/rust/dst-raw, r=nikomatsakis\n\nr? @pnkfelix or @nikomatsakis", "tree": {"sha": "0a8c0bc1213d84583cbe4f8241e16f6a45935adb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a8c0bc1213d84583cbe4f8241e16f6a45935adb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e59a4584c98e0eb21be5ba0a972a647025f14df5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e59a4584c98e0eb21be5ba0a972a647025f14df5", "html_url": "https://github.com/rust-lang/rust/commit/e59a4584c98e0eb21be5ba0a972a647025f14df5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e59a4584c98e0eb21be5ba0a972a647025f14df5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ff7bac2d8b365926e0b336c9c2a5b1c8aa72a36", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ff7bac2d8b365926e0b336c9c2a5b1c8aa72a36", "html_url": "https://github.com/rust-lang/rust/commit/0ff7bac2d8b365926e0b336c9c2a5b1c8aa72a36"}, {"sha": "5520ea81a1ce986e0ca1a6305c82290571a0be4c", "url": "https://api.github.com/repos/rust-lang/rust/commits/5520ea81a1ce986e0ca1a6305c82290571a0be4c", "html_url": "https://github.com/rust-lang/rust/commit/5520ea81a1ce986e0ca1a6305c82290571a0be4c"}], "stats": {"total": 489, "additions": 413, "deletions": 76}, "files": [{"sha": "a8bcb97067122baad16374474023560f3f06389b", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=e59a4584c98e0eb21be5ba0a972a647025f14df5", "patch": "@@ -170,5 +170,6 @@ register_diagnostics!(\n     E0156,\n     E0157,\n     E0158,\n-    E0159\n+    E0159,\n+    E0160\n )"}, {"sha": "ee964c729fca35e7acf06413405fe9c6d0a15438", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=e59a4584c98e0eb21be5ba0a972a647025f14df5", "patch": "@@ -1073,9 +1073,18 @@ impl<'a> rbml_writer_helpers for Encoder<'a> {\n                         this.emit_enum_variant_arg(0, |this| Ok(this.emit_unsize_kind(ecx, uk)))\n                     })\n                 }\n-                &ty::AutoUnsafe(m) => {\n-                    this.emit_enum_variant(\"AutoUnsafe\", 3, 1, |this| {\n-                        this.emit_enum_variant_arg(0, |this| m.encode(this))\n+                &ty::AutoUnsafe(m, None) => {\n+                    this.emit_enum_variant(\"AutoUnsafe\", 3, 2, |this| {\n+                        this.emit_enum_variant_arg(0, |this| m.encode(this));\n+                        this.emit_enum_variant_arg(1,\n+                            |this| this.emit_option(|this| this.emit_option_none()))\n+                    })\n+                }\n+                &ty::AutoUnsafe(m, Some(box ref a)) => {\n+                    this.emit_enum_variant(\"AutoUnsafe\", 3, 2, |this| {\n+                        this.emit_enum_variant_arg(0, |this| m.encode(this));\n+                        this.emit_enum_variant_arg(1, |this| this.emit_option(\n+                            |this| this.emit_option_some(|this| Ok(this.emit_autoref(ecx, a)))))\n                     })\n                 }\n             }\n@@ -1635,8 +1644,16 @@ impl<'a> rbml_decoder_decoder_helpers for reader::Decoder<'a> {\n                     3 => {\n                         let m: ast::Mutability =\n                             this.read_enum_variant_arg(0, |this| Decodable::decode(this)).unwrap();\n+                        let a: Option<Box<ty::AutoRef>> =\n+                            this.read_enum_variant_arg(1, |this| this.read_option(|this, b| {\n+                                if b {\n+                                    Ok(Some(box this.read_autoref(xcx)))\n+                                } else {\n+                                    Ok(None)\n+                                }\n+                            })).unwrap();\n \n-                        ty::AutoUnsafe(m)\n+                        ty::AutoUnsafe(m, a)\n                     }\n                     _ => fail!(\"bad enum variant for ty::AutoRef\")\n                 })"}, {"sha": "a7e49edbc8e4a5972a9f6cb5c7989975abd7855d", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=e59a4584c98e0eb21be5ba0a972a647025f14df5", "patch": "@@ -762,7 +762,7 @@ impl<'d,'t,TYPER:mc::Typer> ExprUseVisitor<'d,'t,TYPER> {\n                                      ty::BorrowKind::from_mutbl(m),\n                                      AutoRef);\n             }\n-            ty::AutoUnsizeUniq(_) | ty::AutoUnsize(_) | ty::AutoUnsafe(_) => {}\n+            ty::AutoUnsizeUniq(_) | ty::AutoUnsize(_) | ty::AutoUnsafe(..) => {}\n         }\n     }\n "}, {"sha": "f9b4c2879dc3ae07a4b893886f8d52ed7096fefa", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=e59a4584c98e0eb21be5ba0a972a647025f14df5", "patch": "@@ -296,8 +296,9 @@ impl Case {\n \n         for (i, &ty) in self.tys.iter().enumerate() {\n             match ty::get(ty).sty {\n-                // &T/&mut T could either be a thin or fat pointer depending on T\n-                ty::ty_rptr(_, ty::mt { ty, .. }) => match ty::get(ty).sty {\n+                // &T/&mut T/*T could either be a thin or fat pointer depending on T\n+                ty::ty_rptr(_, ty::mt { ty, .. })\n+                | ty::ty_ptr(ty::mt { ty, .. }) => match ty::get(ty).sty {\n                     // &[T] and &str are a pointer and length pair\n                     ty::ty_vec(_, None) | ty::ty_str => return Some(FatPointer(i, slice_elt_base)),\n "}, {"sha": "7c0a332ce43cd2deb0eb9ea3f776afb3fd2ec0be", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=e59a4584c98e0eb21be5ba0a972a647025f14df5", "patch": "@@ -566,8 +566,8 @@ pub fn compare_scalar_types<'a>(\n \n     match ty::get(t).sty {\n         ty::ty_nil => f(nil_type),\n-        ty::ty_bool | ty::ty_ptr(_) |\n-        ty::ty_uint(_) | ty::ty_char => f(unsigned_int),\n+        ty::ty_bool | ty::ty_uint(_) | ty::ty_char => f(unsigned_int),\n+        ty::ty_ptr(mt) if ty::type_is_sized(cx.tcx(), mt.ty) => f(unsigned_int),\n         ty::ty_int(_) => f(signed_int),\n         ty::ty_float(_) => f(floating_point),\n             // Should never get here, because t is scalar."}, {"sha": "0b80c4f0b7a73e14d18a33d54a008c04638c8341", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=e59a4584c98e0eb21be5ba0a972a647025f14df5", "patch": "@@ -243,7 +243,7 @@ pub fn const_expr(cx: &CrateContext, e: &ast::Expr, is_local: bool) -> (ValueRef\n                         }\n                         Some(ref autoref) => {\n                             match *autoref {\n-                                ty::AutoUnsafe(_) |\n+                                ty::AutoUnsafe(_, None) |\n                                 ty::AutoPtr(ty::ReStatic, _, None) => {\n                                     // Don't copy data to do a deref+ref\n                                     // (i.e., skip the last auto-deref)."}, {"sha": "ce4c5c9de1688e2adda2fb0674ec6118e58e8632", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=e59a4584c98e0eb21be5ba0a972a647025f14df5", "patch": "@@ -254,11 +254,7 @@ fn apply_adjustments<'a>(bcx: &'a Block<'a>,\n         let mut datum = datum;\n \n         let datum = match autoref {\n-            &AutoUnsafe(..) => {\n-                debug!(\"  AutoUnsafe\");\n-                unpack_datum!(bcx, ref_ptr(bcx, expr, datum))\n-            }\n-            &AutoPtr(_, _, ref a) => {\n+            &AutoPtr(_, _, ref a) | &AutoUnsafe(_, ref a) => {\n                 debug!(\"  AutoPtr\");\n                 match a {\n                     &Some(box ref a) => datum = unpack_datum!(bcx,\n@@ -1847,8 +1843,7 @@ pub fn cast_type_kind(tcx: &ty::ctxt, t: ty::t) -> cast_kind {\n     match ty::get(t).sty {\n         ty::ty_char        => cast_integral,\n         ty::ty_float(..)   => cast_float,\n-        ty::ty_ptr(..)     => cast_pointer,\n-        ty::ty_rptr(_, mt) => {\n+        ty::ty_rptr(_, mt) | ty::ty_ptr(mt) => {\n             if ty::type_is_sized(tcx, mt.ty) {\n                 cast_pointer\n             } else {"}, {"sha": "a49dc1b915028552db0bfb668f4d008238575d14", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=e59a4584c98e0eb21be5ba0a972a647025f14df5", "patch": "@@ -154,7 +154,7 @@ impl<'a, 'b> Reflector<'a, 'b> {\n               // Unfortunately we can't do anything here because at runtime we\n               // pass around the value by pointer (*u8). But unsized pointers are\n               // fat and so we can't just cast them to *u8 and back. So we have\n-              // to work with the pointer directly (see ty_rptr/ty_uniq).\n+              // to work with the pointer directly (see ty_ptr/ty_rptr/ty_uniq).\n               fail!(\"Can't reflect unsized type\")\n           }\n           // FIXME(15049) Reflection for unsized structs.\n@@ -177,8 +177,24 @@ impl<'a, 'b> Reflector<'a, 'b> {\n               self.visit(\"box\", extra.as_slice())\n           }\n           ty::ty_ptr(ref mt) => {\n-              let extra = self.c_mt(mt);\n-              self.visit(\"ptr\", extra.as_slice())\n+              match ty::get(mt.ty).sty {\n+                  ty::ty_vec(ty, None) => {\n+                      let extra = self.c_mt(&ty::mt{ty: ty, mutbl: mt.mutbl});\n+                      self.visit(\"evec_slice\", extra.as_slice())\n+                  }\n+                  ty::ty_str => self.visit(\"estr_slice\", &[]),\n+                  ty::ty_trait(..) => {\n+                      let extra = [\n+                          self.c_slice(token::intern_and_get_ident(\n+                                  ty_to_string(tcx, t).as_slice()))\n+                      ];\n+                      self.visit(\"trait\", extra);\n+                  }\n+                  _ => {\n+                      let extra = self.c_mt(mt);\n+                      self.visit(\"ptr\", extra.as_slice())\n+                  }\n+              }\n           }\n           ty::ty_uniq(typ) => {\n               match ty::get(typ).sty {"}, {"sha": "ab7e71c41d3685c9db530c9cd18eb67138082d86", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=e59a4584c98e0eb21be5ba0a972a647025f14df5", "patch": "@@ -174,9 +174,8 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n         ty::ty_uint(t) => Type::uint_from_ty(cx, t),\n         ty::ty_float(t) => Type::float_from_ty(cx, t),\n \n-        ty::ty_box(..) |\n-        ty::ty_ptr(..) => Type::i8p(cx),\n-        ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => {\n+        ty::ty_box(..) => Type::i8p(cx),\n+        ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) | ty::ty_ptr(ty::mt{ty, ..}) => {\n             if ty::type_is_sized(cx.tcx(), ty) {\n                 Type::i8p(cx)\n             } else {\n@@ -303,9 +302,8 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n       ty::ty_box(typ) => {\n           Type::at_box(cx, type_of(cx, typ)).ptr_to()\n       }\n-      ty::ty_ptr(ref mt) => type_of(cx, mt.ty).ptr_to(),\n \n-      ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => {\n+      ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) | ty::ty_ptr(ty::mt{ty, ..}) => {\n           match ty::get(ty).sty {\n               ty::ty_str => {\n                   // This means we get a nicer name in the output (str is always"}, {"sha": "5198a96291286807e6bb873cfa4607ac473bcefd", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=e59a4584c98e0eb21be5ba0a972a647025f14df5", "patch": "@@ -298,7 +298,8 @@ pub enum AutoRef {\n \n     /// Convert from T to *T\n     /// Value to thin pointer\n-    AutoUnsafe(ast::Mutability),\n+    /// The second field allows us to wrap other AutoRef adjustments.\n+    AutoUnsafe(ast::Mutability, Option<Box<AutoRef>>),\n }\n \n // Ugly little helper function. The first bool in the returned tuple is true if\n@@ -326,6 +327,7 @@ fn autoref_object_region(autoref: &AutoRef) -> (bool, bool, Option<Region>) {\n                 (b, u, Some(adj_r))\n             }\n         }\n+        &AutoUnsafe(_, Some(box ref autoref)) => autoref_object_region(autoref),\n         _ => (false, false, None)\n     }\n }\n@@ -380,6 +382,12 @@ pub fn type_of_adjust(cx: &ctxt, adj: &AutoAdjustment) -> Option<t> {\n                     None => None\n                 }\n             }\n+            &AutoUnsafe(m, Some(box ref autoref)) => {\n+                match type_of_autoref(cx, autoref) {\n+                    Some(t) => Some(mk_ptr(cx, mt {mutbl: m, ty: t})),\n+                    None => None\n+                }\n+            }\n             _ => None\n         }\n     }\n@@ -1898,7 +1906,7 @@ pub fn type_is_self(ty: t) -> bool {\n \n fn type_is_slice(ty: t) -> bool {\n     match get(ty).sty {\n-        ty_rptr(_, mt) => match get(mt.ty).sty {\n+        ty_ptr(mt) | ty_rptr(_, mt) => match get(mt.ty).sty {\n             ty_vec(_, None) | ty_str => true,\n             _ => false,\n         },\n@@ -1996,7 +2004,8 @@ pub fn type_is_unique(ty: t) -> bool {\n \n pub fn type_is_fat_ptr(cx: &ctxt, ty: t) -> bool {\n     match get(ty).sty {\n-        ty_rptr(_, mt{ty, ..}) | ty_uniq(ty) if !type_is_sized(cx, ty) => true,\n+        ty_ptr(mt{ty, ..}) | ty_rptr(_, mt{ty, ..})\n+        | ty_uniq(ty) if !type_is_sized(cx, ty) => true,\n         _ => false,\n     }\n }\n@@ -2896,7 +2905,7 @@ pub fn is_type_representable(cx: &ctxt, sp: Span, ty: t) -> Representability {\n \n pub fn type_is_trait(ty: t) -> bool {\n     match get(ty).sty {\n-        ty_uniq(ty) | ty_rptr(_, mt { ty, ..}) => match get(ty).sty {\n+        ty_uniq(ty) | ty_rptr(_, mt { ty, ..}) | ty_ptr(mt { ty, ..}) => match get(ty).sty {\n             ty_trait(..) => true,\n             _ => false\n         },\n@@ -3392,8 +3401,12 @@ pub fn adjust_ty(cx: &ctxt,\n                 })\n             }\n \n-            AutoUnsafe(m) => {\n-                mk_ptr(cx, mt {ty: ty, mutbl: m})\n+            AutoUnsafe(m, ref a) => {\n+                let adjusted_ty = match a {\n+                    &Some(box ref a) => adjust_for_autoref(cx, span, ty, a),\n+                    &None => ty\n+                };\n+                mk_ptr(cx, mt {ty: adjusted_ty, mutbl: m})\n             }\n \n             AutoUnsize(ref k) => unsize_ty(cx, ty, k, span),\n@@ -3444,7 +3457,8 @@ impl AutoRef {\n             ty::AutoPtr(r, m, Some(ref a)) => ty::AutoPtr(f(r), m, Some(box a.map_region(f))),\n             ty::AutoUnsize(ref k) => ty::AutoUnsize(k.clone()),\n             ty::AutoUnsizeUniq(ref k) => ty::AutoUnsizeUniq(k.clone()),\n-            ty::AutoUnsafe(m) => ty::AutoUnsafe(m),\n+            ty::AutoUnsafe(m, None) => ty::AutoUnsafe(m, None),\n+            ty::AutoUnsafe(m, Some(ref a)) => ty::AutoUnsafe(m, Some(box a.map_region(f))),\n         }\n     }\n }"}, {"sha": "07c8573ef853ba8b8c5129dc572145baaf166d9a", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=e59a4584c98e0eb21be5ba0a972a647025f14df5", "patch": "@@ -466,7 +466,10 @@ pub fn super_fold_autoref<T:TypeFolder>(this: &mut T,\n         ty::AutoPtr(r, m, Some(ref a)) => {\n             ty::AutoPtr(this.fold_region(r), m, Some(box super_fold_autoref(this, &**a)))\n         }\n-        ty::AutoUnsafe(m) => ty::AutoUnsafe(m),\n+        ty::AutoUnsafe(m, None) => ty::AutoUnsafe(m, None),\n+        ty::AutoUnsafe(m, Some(ref a)) => {\n+            ty::AutoUnsafe(m, Some(box super_fold_autoref(this, &**a)))\n+        }\n         ty::AutoUnsize(ref k) => ty::AutoUnsize(k.fold_with(this)),\n         ty::AutoUnsizeUniq(ref k) => ty::AutoUnsizeUniq(k.fold_with(this)),\n     }"}, {"sha": "0ce4dd96025912244d89c6539fa96810e84fe673", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=e59a4584c98e0eb21be5ba0a972a647025f14df5", "patch": "@@ -3650,7 +3650,7 @@ fn check_expr_with_unifier(fcx: &FnCtxt,\n       ast::ExprAddrOf(mutbl, ref oprnd) => {\n         let expected = expected.only_has_type();\n         let hint = expected.map(fcx, |sty| {\n-            match *sty { ty::ty_rptr(_, ref mt) => ExpectHasType(mt.ty),\n+            match *sty { ty::ty_rptr(_, ref mt) | ty::ty_ptr(ref mt) => ExpectHasType(mt.ty),\n                          _ => NoExpectation }\n         });\n         let lvalue_pref = match mutbl {"}, {"sha": "16ecaa9714ec73a0b3102b0c1b0e27d7a77312ab", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=e59a4584c98e0eb21be5ba0a972a647025f14df5", "patch": "@@ -1363,7 +1363,7 @@ fn link_autoref(rcx: &Rcx,\n                 ty::BorrowKind::from_mutbl(m), expr_cmt);\n         }\n \n-        ty::AutoUnsafe(_) | ty::AutoUnsizeUniq(_) | ty::AutoUnsize(_) => {}\n+        ty::AutoUnsafe(..) | ty::AutoUnsizeUniq(_) | ty::AutoUnsize(_) => {}\n     }\n }\n "}, {"sha": "da4bc4dbc7694f97eab14654d6d9325307ef933c", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=e59a4584c98e0eb21be5ba0a972a647025f14df5", "patch": "@@ -630,9 +630,13 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n \n     let cx = fcx.ccx;\n     let check_object_cast = |src_ty: ty::t, target_ty: ty::t| {\n+      debug!(\"check_object_cast {} to {}\",\n+             fcx.infcx().ty_to_string(src_ty),\n+             fcx.infcx().ty_to_string(target_ty));\n       // Check that a cast is of correct types.\n       match (&ty::get(target_ty).sty, &ty::get(src_ty).sty) {\n           (&ty::ty_rptr(_, ty::mt{ty, mutbl}), &ty::ty_rptr(_, mt))\n+          | (&ty::ty_ptr(ty::mt{ty, mutbl}), &ty::ty_rptr(_, mt))\n             if !mutability_allowed(mt.mutbl, mutbl) => {\n               match ty::get(ty).sty {\n                   ty::ty_trait(..) => {\n@@ -641,7 +645,9 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                   _ => {}\n               }\n           }\n-          (&ty::ty_uniq(..), &ty::ty_uniq(..) ) => {}\n+          (&ty::ty_uniq(..), &ty::ty_uniq(..) )\n+          | (&ty::ty_ptr(..), &ty::ty_ptr(..) )\n+          | (&ty::ty_ptr(..), &ty::ty_rptr(..)) => {}\n           (&ty::ty_rptr(r_t, _), &ty::ty_rptr(r_s, _)) => {\n               infer::mk_subr(fcx.infcx(),\n                              infer::RelateObjectBound(ex.span),\n@@ -669,6 +675,16 @@ pub fn early_resolve_expr(ex: &ast::Expr, fcx: &FnCtxt, is_early: bool) {\n                   _ => {}\n               }\n           }\n+          (&ty::ty_ptr(ty::mt{ty, ..}), _) => {\n+              match ty::get(ty).sty {\n+                  ty::ty_trait(..) => {\n+                      span_err!(fcx.ccx.tcx.sess, ex.span, E0160,\n+                                \"can only cast an *-pointer or &-pointer to an *-object, not a {}\",\n+                                ty::ty_sort_string(fcx.tcx(), src_ty));\n+                  }\n+                  _ => {}\n+              }\n+          }\n           _ => {}\n       }\n     };\n@@ -880,7 +896,8 @@ fn trait_cast_types(fcx: &FnCtxt,\n         match autoref {\n             &ty::AutoUnsize(ref k) |\n             &ty::AutoUnsizeUniq(ref k) => trait_cast_types_unsize(fcx, k, src_ty, sp),\n-            &ty::AutoPtr(_, _, Some(box ref autoref)) => {\n+            &ty::AutoPtr(_, _, Some(box ref autoref)) |\n+            &ty::AutoUnsafe(_, Some(box ref autoref)) => {\n                 trait_cast_types_autoref(fcx, autoref, src_ty, sp)\n             }\n             _ => None\n@@ -891,7 +908,7 @@ fn trait_cast_types(fcx: &FnCtxt,\n         &ty::AutoDerefRef(AutoDerefRef{autoref: Some(ref autoref), autoderefs}) => {\n             let mut derefed_type = src_ty;\n             for _ in range(0, autoderefs) {\n-                derefed_type = ty::deref(derefed_type, false).unwrap().ty;\n+                derefed_type = ty::deref(derefed_type, true).unwrap().ty;\n                 derefed_type = structurally_resolved_type(fcx, sp, derefed_type)\n             }\n             trait_cast_types_autoref(fcx, autoref, derefed_type, sp)"}, {"sha": "9c58a4c79f057a400b37d0a73ed3762b29f6fef0", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=e59a4584c98e0eb21be5ba0a972a647025f14df5", "patch": "@@ -157,15 +157,19 @@ fn get_base_type_def_id(inference_context: &InferCtxt,\n                 ty_unboxed_closure(def_id, _) => {\n                     Some(def_id)\n                 }\n-                ty_rptr(_, ty::mt {ty, ..}) | ty_uniq(ty) => match ty::get(ty).sty {\n-                    ty_trait(box ty::TyTrait { def_id, .. }) => {\n-                        Some(def_id)\n-                    }\n-                    _ => {\n-                        fail!(\"get_base_type() returned a type that wasn't an \\\n-                               enum, struct, or trait\");\n+                ty_ptr(ty::mt {ty, ..}) |\n+                ty_rptr(_, ty::mt {ty, ..}) |\n+                ty_uniq(ty) => {\n+                    match ty::get(ty).sty {\n+                        ty_trait(box ty::TyTrait { def_id, .. }) => {\n+                            Some(def_id)\n+                        }\n+                        _ => {\n+                            fail!(\"get_base_type() returned a type that wasn't an \\\n+                                   enum, struct, or trait\");\n+                        }\n                     }\n-                },\n+                }\n                 ty_trait(box ty::TyTrait { def_id, .. }) => {\n                     Some(def_id)\n                 }"}, {"sha": "c22baa1d9e5d3aa0466333129a95ccdf510048f4", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=e59a4584c98e0eb21be5ba0a972a647025f14df5", "patch": "@@ -1401,7 +1401,7 @@ fn check_method_self_type<RS:RegionScope>(\n         ast::SelfExplicit(ref ast_type, _) => {\n             let typ = crate_context.to_ty(rs, &**ast_type);\n             let base_type = match ty::get(typ).sty {\n-                ty::ty_rptr(_, tm) => tm.ty,\n+                ty::ty_ptr(tm) | ty::ty_rptr(_, tm) => tm.ty,\n                 ty::ty_uniq(typ) => typ,\n                 _ => typ,\n             };"}, {"sha": "381c47279e390ff8ef7f88ee37c7d7f422bf1251", "filename": "src/librustc/middle/typeck/infer/coercion.rs", "status": "modified", "additions": 100, "deletions": 28, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcoercion.rs?ref=e59a4584c98e0eb21be5ba0a972a647025f14df5", "patch": "@@ -65,7 +65,7 @@ we may want to adjust precisely when coercions occur.\n */\n \n use middle::subst;\n-use middle::ty::{AutoPtr, AutoDerefRef, AutoUnsize};\n+use middle::ty::{AutoPtr, AutoDerefRef, AutoUnsize, AutoUnsafe};\n use middle::ty::{mt};\n use middle::ty;\n use middle::typeck::infer::{CoerceResult, resolve_type, Coercion};\n@@ -100,7 +100,7 @@ impl<'f> Coerce<'f> {\n         // to `&[T]`. Doing it all at once makes the target code a bit more\n         // efficient and spares us from having to handle multiple coercions.\n         match ty::get(b).sty {\n-            ty::ty_rptr(_, mt_b) => {\n+            ty::ty_ptr(mt_b) | ty::ty_rptr(_, mt_b) => {\n                 match ty::get(mt_b.ty).sty {\n                     ty::ty_vec(_, None) => {\n                         let unsize_and_ref = self.unpack_actual_value(a, |sty_a| {\n@@ -129,6 +129,33 @@ impl<'f> Coerce<'f> {\n         // Note: does not attempt to resolve type variables we encounter.\n         // See above for details.\n         match ty::get(b).sty {\n+            ty::ty_ptr(mt_b) => {\n+                match ty::get(mt_b.ty).sty {\n+                    ty::ty_str => {\n+                        return self.unpack_actual_value(a, |sty_a| {\n+                            self.coerce_unsafe_ptr(a, sty_a, b, ast::MutImmutable)\n+                        });\n+                    }\n+\n+                    ty::ty_trait(..) => {\n+                        let result = self.unpack_actual_value(a, |sty_a| {\n+                            self.coerce_unsafe_object(a, sty_a, b, mt_b.mutbl)\n+                        });\n+\n+                        match result {\n+                            Ok(t) => return Ok(t),\n+                            Err(..) => {}\n+                        }\n+                    }\n+\n+                    _ => {\n+                        return self.unpack_actual_value(a, |sty_a| {\n+                            self.coerce_unsafe_ptr(a, sty_a, b, mt_b.mutbl)\n+                        });\n+                    }\n+                };\n+            }\n+\n             ty::ty_rptr(_, mt_b) => {\n                 match ty::get(mt_b.ty).sty {\n                     ty::ty_str => {\n@@ -165,12 +192,6 @@ impl<'f> Coerce<'f> {\n                 });\n             }\n \n-            ty::ty_ptr(mt_b) => {\n-                return self.unpack_actual_value(a, |sty_a| {\n-                    self.coerce_unsafe_ptr(a, sty_a, b, mt_b)\n-                });\n-            }\n-\n             _ => {}\n         }\n \n@@ -329,6 +350,25 @@ impl<'f> Coerce<'f> {\n                     }\n                 })\n             }\n+            (&ty::ty_rptr(_, ty::mt{ty: t_a, ..}), &ty::ty_ptr(mt_b)) => {\n+                self.unpack_actual_value(t_a, |sty_a| {\n+                    match self.unsize_ty(sty_a, mt_b.ty) {\n+                        Some((ty, kind)) => {\n+                            let ty = ty::mk_ptr(self.get_ref().infcx.tcx,\n+                                                 ty::mt{ty: ty, mutbl: mt_b.mutbl});\n+                            try!(self.get_ref().infcx.try(|| sub.tys(ty, b)));\n+                            debug!(\"Success, coerced with AutoDerefRef(1, \\\n+                                    AutoPtr(AutoUnsize({:?})))\", kind);\n+                            Ok(Some(AutoDerefRef(AutoDerefRef {\n+                                autoderefs: 1,\n+                                autoref: Some(ty::AutoUnsafe(mt_b.mutbl,\n+                                                             Some(box AutoUnsize(kind))))\n+                            })))\n+                        }\n+                        _ => Err(ty::terr_mismatch)\n+                    }\n+                })\n+            }\n             (&ty::ty_uniq(t_a), &ty::ty_uniq(t_b)) => {\n                 self.unpack_actual_value(t_a, |sty_a| {\n                     match self.unsize_ty(sty_a, t_b) {\n@@ -357,7 +397,7 @@ impl<'f> Coerce<'f> {\n                  sty_a: &ty::sty,\n                  ty_b: ty::t)\n                  -> Option<(ty::t, ty::UnsizeKind)> {\n-        debug!(\"unsize_ty(sty_a={:?}\", sty_a);\n+        debug!(\"unsize_ty(sty_a={:?}, ty_b={})\", sty_a, ty_b.repr(self.get_ref().infcx.tcx));\n \n         let tcx = self.get_ref().infcx.tcx;\n \n@@ -430,15 +470,47 @@ impl<'f> Coerce<'f> {\n                               b: ty::t,\n                               b_mutbl: ast::Mutability) -> CoerceResult\n     {\n+        let tcx = self.get_ref().infcx.tcx;\n+\n         debug!(\"coerce_borrowed_object(a={}, sty_a={:?}, b={})\",\n-               a.repr(self.get_ref().infcx.tcx), sty_a,\n-               b.repr(self.get_ref().infcx.tcx));\n+               a.repr(tcx), sty_a,\n+               b.repr(tcx));\n \n-        let tcx = self.get_ref().infcx.tcx;\n         let coercion = Coercion(self.get_ref().trace.clone());\n         let r_a = self.get_ref().infcx.next_region_var(coercion);\n \n-        let a_borrowed = match *sty_a {\n+        self.coerce_object(a, sty_a, b,\n+                           |tr| ty::mk_rptr(tcx, r_a, ty::mt{ mutbl: b_mutbl, ty: tr }),\n+                           || AutoPtr(r_a, b_mutbl, None))\n+    }\n+\n+    fn coerce_unsafe_object(&self,\n+                            a: ty::t,\n+                            sty_a: &ty::sty,\n+                            b: ty::t,\n+                            b_mutbl: ast::Mutability) -> CoerceResult\n+    {\n+        let tcx = self.get_ref().infcx.tcx;\n+\n+        debug!(\"coerce_unsafe_object(a={}, sty_a={:?}, b={})\",\n+               a.repr(tcx), sty_a,\n+               b.repr(tcx));\n+\n+        self.coerce_object(a, sty_a, b,\n+                           |tr| ty::mk_ptr(tcx, ty::mt{ mutbl: b_mutbl, ty: tr }),\n+                           || AutoUnsafe(b_mutbl, None))\n+    }\n+\n+    fn coerce_object(&self,\n+                     a: ty::t,\n+                     sty_a: &ty::sty,\n+                     b: ty::t,\n+                     mk_ty: |ty::t| -> ty::t,\n+                     mk_adjust: || -> ty::AutoRef) -> CoerceResult\n+    {\n+        let tcx = self.get_ref().infcx.tcx;\n+\n+        match *sty_a {\n             ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) => match ty::get(ty).sty {\n                 ty::ty_trait(box ty::TyTrait {\n                         def_id,\n@@ -447,22 +519,20 @@ impl<'f> Coerce<'f> {\n                         ..\n                     }) => {\n                     let tr = ty::mk_trait(tcx, def_id, substs.clone(), bounds);\n-                    ty::mk_rptr(tcx, r_a, ty::mt{ mutbl: b_mutbl, ty: tr })\n+                    try!(self.subtype(mk_ty(tr), b));\n+                    Ok(Some(AutoDerefRef(AutoDerefRef {\n+                        autoderefs: 1,\n+                        autoref: Some(mk_adjust())\n+                    })))\n                 }\n                 _ => {\n-                    return self.subtype(a, b);\n+                    self.subtype(a, b)\n                 }\n             },\n             _ => {\n-                return self.subtype(a, b);\n+                self.subtype(a, b)\n             }\n-        };\n-\n-        try!(self.subtype(a_borrowed, b));\n-        Ok(Some(AutoDerefRef(AutoDerefRef {\n-            autoderefs: 1,\n-            autoref: Some(AutoPtr(r_a, b_mutbl, None))\n-        })))\n+        }\n     }\n \n     pub fn coerce_borrowed_fn(&self,\n@@ -521,7 +591,7 @@ impl<'f> Coerce<'f> {\n                              a: ty::t,\n                              sty_a: &ty::sty,\n                              b: ty::t,\n-                             mt_b: ty::mt)\n+                             mutbl_b: ast::Mutability)\n                              -> CoerceResult {\n         debug!(\"coerce_unsafe_ptr(a={}, sty_a={:?}, b={})\",\n                a.repr(self.get_ref().infcx.tcx), sty_a,\n@@ -534,16 +604,18 @@ impl<'f> Coerce<'f> {\n             }\n         };\n \n-        // check that the types which they point at are compatible\n+        // Check that the types which they point at are compatible.\n+        // Note that we don't adjust the mutability here. We cannot change\n+        // the mutability and the kind of pointer in a single coercion.\n         let a_unsafe = ty::mk_ptr(self.get_ref().infcx.tcx, mt_a);\n         try!(self.subtype(a_unsafe, b));\n \n-        // although references and unsafe ptrs have the same\n+        // Although references and unsafe ptrs have the same\n         // representation, we still register an AutoDerefRef so that\n-        // regionck knows that the region for `a` must be valid here\n+        // regionck knows that the region for `a` must be valid here.\n         Ok(Some(AutoDerefRef(AutoDerefRef {\n             autoderefs: 1,\n-            autoref: Some(ty::AutoUnsafe(mt_b.mutbl))\n+            autoref: Some(ty::AutoUnsafe(mutbl_b, None))\n         })))\n     }\n }"}, {"sha": "cc5d3b520f95cc89ebeaf7727476a5eeffd5276e", "filename": "src/test/compile-fail/dst-bad-coercions.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdst-bad-coercions.rs?ref=e59a4584c98e0eb21be5ba0a972a647025f14df5", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test implicit coercions involving DSTs and raw pointers.\n+\n+struct S;\n+trait T {}\n+impl T for S {}\n+\n+struct Foo<Sized? T> {\n+    f: T\n+}\n+\n+pub fn main() {\n+    // Test that we cannot convert from *-ptr to &-ptr\n+    let x: *const S = &S;\n+    let y: &S = x; //~ ERROR mismatched types\n+    let y: &T = x; //~ ERROR mismatched types\n+\n+    // Test that we cannot convert from *-ptr to &-ptr (mut version)\n+    let x: *mut S = &mut S;\n+    let y: &S = x; //~ ERROR mismatched types\n+    let y: &T = x; //~ ERROR mismatched types\n+\n+    // Test that we cannot convert an immutable ptr to a mutable one using *-ptrs\n+    let x: &mut T = &S; //~ ERROR types differ in mutability\n+    let x: *mut T = &S; //~ ERROR types differ in mutability\n+    let x: *mut S = &S;\n+    //~^ ERROR mismatched types\n+\n+    // The below four sets of tests test that we cannot implicitly deref a *-ptr\n+    // during a coercion.\n+    let x: *const S = &S;\n+    let y: *const T = x;  //~ ERROR mismatched types\n+\n+    let x: *mut S = &mut S;\n+    let y: *mut T = x;  //~ ERROR mismatched types\n+\n+    let x: *const Foo<S> = &Foo {f: S};\n+    let y: *const Foo<T> = x;  //~ ERROR mismatched types\n+\n+    let x: *mut Foo<S> = &mut Foo {f: S};\n+    let y: *mut Foo<T> = x;  //~ ERROR mismatched types\n+}"}, {"sha": "39bf899a023f14fce9ea3d20293b7cf52c7385bb", "filename": "src/test/run-fail/dst-raw-slice.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Ftest%2Frun-fail%2Fdst-raw-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Ftest%2Frun-fail%2Fdst-raw-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fdst-raw-slice.rs?ref=e59a4584c98e0eb21be5ba0a972a647025f14df5", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test bounds checking for DST raw slices\n+// error-pattern:index out of bounds\n+\n+fn main() {\n+    let a: *const [_] = &[1i, 2, 3];\n+    unsafe {\n+        let _b = (*a)[3];\n+    }\n+}"}, {"sha": "1c9d5cd3afe4d6c2a8b997090bd864ec694e9936", "filename": "src/test/run-pass/dst-coercions.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Ftest%2Frun-pass%2Fdst-coercions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Ftest%2Frun-pass%2Fdst-coercions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-coercions.rs?ref=e59a4584c98e0eb21be5ba0a972a647025f14df5", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test coercions involving DST and/or raw pointers\n+\n+struct S;\n+trait T {}\n+impl T for S {}\n+\n+pub fn main() {\n+    let x: &T = &S;\n+    // Test we can convert from &-ptr to *-ptr of trait objects\n+    let x: *const T = &S;\n+\n+    // Test we can convert from &-ptr to *-ptr of struct pointer (not DST)\n+    let x: *const S = &S;\n+\n+    // As above, but mut\n+    let x: &mut T = &mut S;\n+    let x: *mut T = &mut S;\n+\n+    let x: *mut S = &mut S;\n+\n+    // Test we can chnage the mutability from mut to const.\n+    let x: &T = &mut S;\n+    let x: *const T = &mut S;\n+}"}, {"sha": "a977e961b13521c826f2f391d04dbd35f849776b", "filename": "src/test/run-pass/dst-raw.rs", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Ftest%2Frun-pass%2Fdst-raw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e59a4584c98e0eb21be5ba0a972a647025f14df5/src%2Ftest%2Frun-pass%2Fdst-raw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdst-raw.rs?ref=e59a4584c98e0eb21be5ba0a972a647025f14df5", "patch": "@@ -0,0 +1,95 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test DST raw pointers\n+\n+trait Trait {\n+    fn foo(&self) -> int;\n+}\n+\n+struct A {\n+    f: int\n+}\n+impl Trait for A {\n+    fn foo(&self) -> int {\n+        self.f\n+    }\n+}\n+\n+struct Foo<Sized? T> {\n+    f: T\n+}\n+\n+pub fn main() {\n+    // raw trait object\n+    let x = A { f: 42 };\n+    let z: *const Trait = &x;\n+    let r = unsafe {\n+        (&*z).foo()\n+    };\n+    assert!(r == 42);\n+\n+    // raw DST struct\n+    let p = Foo {f: A { f: 42 }};\n+    let o: *const Foo<Trait> = &p;\n+    let r = unsafe {\n+        (&*o).f.foo()\n+    };\n+    assert!(r == 42);\n+\n+    // raw slice\n+    let a: *const [_] = &[1i, 2, 3];\n+    unsafe {\n+        let b = (*a)[2];\n+        assert!(b == 3);\n+        let len = (*a).len();\n+        assert!(len == 3);\n+    }\n+\n+    // raw DST struct with slice\n+    let c: *const Foo<[_]> = &Foo {f: [1i, 2, 3]};\n+    unsafe {\n+        let b = (&*c).f[0];\n+        assert!(b == 1);\n+        let len = (&*c).f.len();\n+        assert!(len == 3);\n+    }\n+\n+    // all of the above with *mut\n+    let mut x = A { f: 42 };\n+    let z: *mut Trait = &mut x;\n+    let r = unsafe {\n+        (&*z).foo()\n+    };\n+    assert!(r == 42);\n+\n+    let mut p = Foo {f: A { f: 42 }};\n+    let o: *mut Foo<Trait> = &mut p;\n+    let r = unsafe {\n+        (&*o).f.foo()\n+    };\n+    assert!(r == 42);\n+\n+    let a: *mut [_] = &mut [1i, 2, 3];\n+    unsafe {\n+        let b = (*a)[2];\n+        assert!(b == 3);\n+        let len = (*a).len();\n+        assert!(len == 3);\n+    }\n+\n+    let c: *mut Foo<[_]> = &mut Foo {f: [1i, 2, 3]};\n+    unsafe {\n+        let b = (&*c).f[0];\n+        assert!(b == 1);\n+        let len = (&*c).f.len();\n+        assert!(len == 3);\n+    }\n+}\n\\ No newline at end of file"}]}