{"sha": "5d41be3629067ddfd16fc672e75c2fcaf95c27ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkNDFiZTM2MjkwNjdkZGZkMTZmYzY3MmU3NWMyZmNhZjk1YzI3ZmY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-12-09T14:54:19Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-12-20T10:37:15Z"}, "message": "don't special case having 1 item", "tree": {"sha": "8c4d5c5c17c2d44408dfadc238fe4f3a0568a35d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c4d5c5c17c2d44408dfadc238fe4f3a0568a35d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d41be3629067ddfd16fc672e75c2fcaf95c27ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d41be3629067ddfd16fc672e75c2fcaf95c27ff", "html_url": "https://github.com/rust-lang/rust/commit/5d41be3629067ddfd16fc672e75c2fcaf95c27ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d41be3629067ddfd16fc672e75c2fcaf95c27ff/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25a2d13cdea6011046a9929824deafd332b94436", "url": "https://api.github.com/repos/rust-lang/rust/commits/25a2d13cdea6011046a9929824deafd332b94436", "html_url": "https://github.com/rust-lang/rust/commit/25a2d13cdea6011046a9929824deafd332b94436"}], "stats": {"total": 93, "additions": 22, "deletions": 71}, "files": [{"sha": "e478638a5e02e20f37ba92d42a25c4615eecac5c", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 22, "deletions": 71, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/5d41be3629067ddfd16fc672e75c2fcaf95c27ff/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d41be3629067ddfd16fc672e75c2fcaf95c27ff/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=5d41be3629067ddfd16fc672e75c2fcaf95c27ff", "patch": "@@ -484,22 +484,16 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         debug!(\"assemble_inherent_impl_probe {:?}\", impl_def_id);\n \n-        let items = self.impl_or_trait_item(impl_def_id);\n-        if items.len() < 1 {\n-            return // No method with correct name on this impl\n-        }\n-\n-        if self.looking_for.is_method_name() {\n-            let item = items[0];\n-\n+        for item in self.impl_or_trait_item(impl_def_id) {\n             if !self.has_applicable_self(&item) {\n                 // No receiver declared. Not a candidate.\n-                return self.record_static_candidate(ImplSource(impl_def_id));\n+                self.record_static_candidate(ImplSource(impl_def_id));\n+                continue\n             }\n \n             if !item.vis.is_accessible_from(self.body_id, &self.tcx.map) {\n                 self.private_candidate = Some(item.def());\n-                return;\n+                continue\n             }\n \n             let (impl_ty, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n@@ -523,41 +517,6 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 kind: InherentImplCandidate(impl_substs, obligations),\n                 import_id: self.import_id,\n             });\n-        } else {\n-            for item in items {\n-                if !self.has_applicable_self(&item) {\n-                    // No receiver declared. Not a candidate.\n-                    self.record_static_candidate(ImplSource(impl_def_id));\n-                    continue\n-                }\n-\n-                if !item.vis.is_accessible_from(self.body_id, &self.tcx.map) {\n-                    self.private_candidate = Some(item.def());\n-                    continue\n-                }\n-\n-                let (impl_ty, impl_substs) = self.impl_ty_and_substs(impl_def_id);\n-                let impl_ty = impl_ty.subst(self.tcx, impl_substs);\n-\n-                // Determine the receiver type that the method itself expects.\n-                let xform_self_ty = self.xform_self_ty(&item, impl_ty, impl_substs);\n-\n-                // We can't use normalize_associated_types_in as it will pollute the\n-                // fcx's fulfillment context after this probe is over.\n-                let cause = traits::ObligationCause::misc(self.span, self.body_id);\n-                let mut selcx = &mut traits::SelectionContext::new(self.fcx);\n-                let traits::Normalized { value: xform_self_ty, obligations } =\n-                    traits::normalize(selcx, cause, &xform_self_ty);\n-                debug!(\"assemble_inherent_impl_probe: xform_self_ty = {:?}\",\n-                       xform_self_ty);\n-\n-                self.inherent_candidates.push(Candidate {\n-                    xform_self_ty: xform_self_ty,\n-                    item: item,\n-                    kind: InherentImplCandidate(impl_substs, obligations),\n-                    import_id: self.import_id,\n-                });\n-            }\n         }\n     }\n \n@@ -651,16 +610,12 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n \n         let tcx = self.tcx;\n         for bound_trait_ref in traits::transitive_bounds(tcx, bounds) {\n-            let items = self.impl_or_trait_item(bound_trait_ref.def_id());\n-            if items.len() < 1 {\n-                continue\n-            }\n-            let item = items[0];\n-\n-            if !self.has_applicable_self(&item) {\n-                self.record_static_candidate(TraitSource(bound_trait_ref.def_id()));\n-            } else {\n-                mk_cand(self, bound_trait_ref, item);\n+            for item in self.impl_or_trait_item(bound_trait_ref.def_id()) {\n+                if !self.has_applicable_self(&item) {\n+                    self.record_static_candidate(TraitSource(bound_trait_ref.def_id()));\n+                } else {\n+                    mk_cand(self, bound_trait_ref, item);\n+                }\n             }\n         }\n     }\n@@ -717,26 +672,22 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         debug!(\"assemble_extension_candidates_for_trait(trait_def_id={:?})\",\n                trait_def_id);\n \n-        let items = self.impl_or_trait_item(trait_def_id);\n-        if items.len() < 1 {\n-            return Ok(());\n-        }\n-        let item = items[0];\n-\n-        // Check whether `trait_def_id` defines a method with suitable name:\n-        if !self.has_applicable_self(&item) {\n-            debug!(\"method has inapplicable self\");\n-            self.record_static_candidate(TraitSource(trait_def_id));\n-            return Ok(());\n-        }\n+        for item in self.impl_or_trait_item(trait_def_id) {\n+            // Check whether `trait_def_id` defines a method with suitable name:\n+            if !self.has_applicable_self(&item) {\n+                debug!(\"method has inapplicable self\");\n+                self.record_static_candidate(TraitSource(trait_def_id));\n+                continue;\n+            }\n \n-        self.assemble_extension_candidates_for_trait_impls(trait_def_id, item.clone());\n+            self.assemble_extension_candidates_for_trait_impls(trait_def_id, item.clone());\n \n-        self.assemble_closure_candidates(trait_def_id, item.clone())?;\n+            self.assemble_closure_candidates(trait_def_id, item.clone())?;\n \n-        self.assemble_projection_candidates(trait_def_id, item.clone());\n+            self.assemble_projection_candidates(trait_def_id, item.clone());\n \n-        self.assemble_where_clause_candidates(trait_def_id, item.clone());\n+            self.assemble_where_clause_candidates(trait_def_id, item.clone());\n+        }\n \n         Ok(())\n     }"}]}