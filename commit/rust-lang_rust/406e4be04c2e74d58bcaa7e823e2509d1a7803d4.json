{"sha": "406e4be04c2e74d58bcaa7e823e2509d1a7803d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwNmU0YmUwNGMyZTc0ZDU4YmNhYTdlODIzZTI1MDlkMWE3ODAzZDQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-14T15:34:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-14T15:34:37Z"}, "message": "Merge #8016\n\n8016: More Chalk adaptations r=flodiebold a=flodiebold\n\n - rename a bunch of fields\r\n - use `chalk_ir::FnSig`\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "79dcaa50fe38214d03c4e60b3738ca578e09d659", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79dcaa50fe38214d03c4e60b3738ca578e09d659"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/406e4be04c2e74d58bcaa7e823e2509d1a7803d4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgTi0NCRBK7hj4Ov3rIwAAdHIIAJVx4IVfuLx35FTbFlwHmDUh\n5UusiUUXonMcXFlJcG6dEWogxrYBHJpVxaGxQZYAVcHex9OKZz44rrxDpdgCotk5\nqawyxA9A0agKSuZQFoggxUwzYo/sQW7zfZQWBMp9iD+ZWe/kOrtU20uX660xT/3L\nJbKTYlL8cnPkEI62jo+EVD1V9GKeEOXkA92DNbBVlof3x2Dg2G/mw0TB+R2SJNuS\nxoLZCGupZ4rQBaV4qkqObyDzPMm/kdtiNcqJiAGQk/i+B3545yS2sFsMYR5ViFk+\nZncnXaInrnjSb1Ryb4peL+3NtM/xOhjewbLqh6wfHWq8u3AgQ2+XaE6UnWEjkg4=\n=roGN\n-----END PGP SIGNATURE-----\n", "payload": "tree 79dcaa50fe38214d03c4e60b3738ca578e09d659\nparent f57e2f55984758a83644b852a4cc47e0b27945df\nparent 195414783402d6973f4e673e84be9b7bc19cbfa6\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1615736077 +0000\ncommitter GitHub <noreply@github.com> 1615736077 +0000\n\nMerge #8016\n\n8016: More Chalk adaptations r=flodiebold a=flodiebold\n\n - rename a bunch of fields\r\n - use `chalk_ir::FnSig`\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/406e4be04c2e74d58bcaa7e823e2509d1a7803d4", "html_url": "https://github.com/rust-lang/rust/commit/406e4be04c2e74d58bcaa7e823e2509d1a7803d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/406e4be04c2e74d58bcaa7e823e2509d1a7803d4/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f57e2f55984758a83644b852a4cc47e0b27945df", "url": "https://api.github.com/repos/rust-lang/rust/commits/f57e2f55984758a83644b852a4cc47e0b27945df", "html_url": "https://github.com/rust-lang/rust/commit/f57e2f55984758a83644b852a4cc47e0b27945df"}, {"sha": "195414783402d6973f4e673e84be9b7bc19cbfa6", "url": "https://api.github.com/repos/rust-lang/rust/commits/195414783402d6973f4e673e84be9b7bc19cbfa6", "html_url": "https://github.com/rust-lang/rust/commit/195414783402d6973f4e673e84be9b7bc19cbfa6"}], "stats": {"total": 173, "additions": 89, "deletions": 84}, "files": [{"sha": "eb1cd66fb15c505076bdeed44927acc0374ec490", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/406e4be04c2e74d58bcaa7e823e2509d1a7803d4/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406e4be04c2e74d58bcaa7e823e2509d1a7803d4/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=406e4be04c2e74d58bcaa7e823e2509d1a7803d4", "patch": "@@ -1686,8 +1686,8 @@ impl Type {\n             .build();\n         let predicate = ProjectionPredicate {\n             projection_ty: ProjectionTy {\n-                associated_ty: to_assoc_type_id(alias.id),\n-                parameters: subst,\n+                associated_ty_id: to_assoc_type_id(alias.id),\n+                substitution: subst,\n             },\n             ty: TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0)).intern(&Interner),\n         };\n@@ -1979,7 +1979,7 @@ impl Type {\n                         walk_bounds(db, &type_.derived(ty.clone()), &bounds, cb);\n                     }\n \n-                    walk_substs(db, type_, &opaque_ty.parameters, cb);\n+                    walk_substs(db, type_, &opaque_ty.substitution, cb);\n                 }\n                 TyKind::Placeholder(_) => {\n                     if let Some(bounds) = ty.impl_trait_bounds(db) {"}, {"sha": "56c6b92d4e00ea70211013c2ed794309ae7ab18e", "filename": "crates/hir_ty/src/autoderef.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/406e4be04c2e74d58bcaa7e823e2509d1a7803d4/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406e4be04c2e74d58bcaa7e823e2509d1a7803d4/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs?ref=406e4be04c2e74d58bcaa7e823e2509d1a7803d4", "patch": "@@ -84,7 +84,10 @@ fn deref_by_trait(\n     let projection = super::traits::ProjectionPredicate {\n         ty: TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, ty.value.kinds.len()))\n             .intern(&Interner),\n-        projection_ty: super::ProjectionTy { associated_ty: to_assoc_type_id(target), parameters },\n+        projection_ty: super::ProjectionTy {\n+            associated_ty_id: to_assoc_type_id(target),\n+            substitution: parameters,\n+        },\n     };\n \n     let obligation = super::Obligation::Projection(projection);"}, {"sha": "378c951c5e500b7edc082214226dc610ab50f490", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/406e4be04c2e74d58bcaa7e823e2509d1a7803d4/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406e4be04c2e74d58bcaa7e823e2509d1a7803d4/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=406e4be04c2e74d58bcaa7e823e2509d1a7803d4", "patch": "@@ -245,19 +245,19 @@ impl HirDisplay for ProjectionTy {\n         }\n \n         let trait_ = f.db.trait_data(self.trait_(f.db));\n-        let first_parameter = self.parameters[0].into_displayable(\n+        let first_parameter = self.substitution[0].into_displayable(\n             f.db,\n             f.max_size,\n             f.omit_verbose_types,\n             f.display_target,\n         );\n         write!(f, \"<{} as {}\", first_parameter, trait_.name)?;\n-        if self.parameters.len() > 1 {\n+        if self.substitution.len() > 1 {\n             write!(f, \"<\")?;\n-            f.write_joined(&self.parameters[1..], \", \")?;\n+            f.write_joined(&self.substitution[1..], \", \")?;\n             write!(f, \">\")?;\n         }\n-        write!(f, \">::{}\", f.db.type_alias_data(from_assoc_type_id(self.associated_ty)).name)?;\n+        write!(f, \">::{}\", f.db.type_alias_data(from_assoc_type_id(self.associated_ty_id)).name)?;\n         Ok(())\n     }\n }\n@@ -319,7 +319,10 @@ impl HirDisplay for Ty {\n                     TyKind::Dyn(predicates) if predicates.len() > 1 => {\n                         Cow::Borrowed(predicates.as_ref())\n                     }\n-                    &TyKind::Alias(AliasTy::Opaque(OpaqueTy { opaque_ty_id, ref parameters })) => {\n+                    &TyKind::Alias(AliasTy::Opaque(OpaqueTy {\n+                        opaque_ty_id,\n+                        substitution: ref parameters,\n+                    })) => {\n                         let impl_trait_id = f.db.lookup_intern_impl_trait_id(opaque_ty_id.into());\n                         if let ImplTraitId::ReturnTypeImplTrait(func, idx) = impl_trait_id {\n                             datas =\n@@ -491,8 +494,8 @@ impl HirDisplay for Ty {\n                     }\n                 } else {\n                     let projection_ty = ProjectionTy {\n-                        associated_ty: to_assoc_type_id(type_alias),\n-                        parameters: parameters.clone(),\n+                        associated_ty_id: to_assoc_type_id(type_alias),\n+                        substitution: parameters.clone(),\n                     };\n \n                     projection_ty.hir_fmt(f)?;\n@@ -579,7 +582,7 @@ impl HirDisplay for Ty {\n                         let data = (*datas)\n                             .as_ref()\n                             .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n-                        let bounds = data.subst(&opaque_ty.parameters);\n+                        let bounds = data.subst(&opaque_ty.substitution);\n                         write_bounds_like_dyn_trait_with_prefix(\"impl\", &bounds.value, f)?;\n                     }\n                     ImplTraitId::AsyncBlockTypeImplTrait(..) => {\n@@ -709,7 +712,7 @@ fn write_bounds_like_dyn_trait(\n                     angle_open = true;\n                 }\n                 let type_alias = f.db.type_alias_data(from_assoc_type_id(\n-                    projection_pred.projection_ty.associated_ty,\n+                    projection_pred.projection_ty.associated_ty_id,\n                 ));\n                 write!(f, \"{} = \", type_alias.name)?;\n                 projection_pred.ty.hir_fmt(f)?;\n@@ -782,7 +785,7 @@ impl HirDisplay for GenericPredicate {\n                     f,\n                     \">::{} = \",\n                     f.db.type_alias_data(from_assoc_type_id(\n-                        projection_pred.projection_ty.associated_ty\n+                        projection_pred.projection_ty.associated_ty_id\n                     ))\n                     .name,\n                 )?;"}, {"sha": "fbfedb4e68af7dea7e3c560682b7dc4db1b98fbf", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/406e4be04c2e74d58bcaa7e823e2509d1a7803d4/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406e4be04c2e74d58bcaa7e823e2509d1a7803d4/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=406e4be04c2e74d58bcaa7e823e2509d1a7803d4", "patch": "@@ -385,8 +385,8 @@ impl<'a> InferenceContext<'a> {\n                 let projection = ProjectionPredicate {\n                     ty: ty.clone(),\n                     projection_ty: ProjectionTy {\n-                        associated_ty: to_assoc_type_id(res_assoc_ty),\n-                        parameters: substs,\n+                        associated_ty_id: to_assoc_type_id(res_assoc_ty),\n+                        substitution: substs,\n                     },\n                 };\n                 self.obligations.push(Obligation::Trait(trait_ref));"}, {"sha": "55163c963f2aa611ddeac909a39d73f7ce13d160", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/406e4be04c2e74d58bcaa7e823e2509d1a7803d4/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406e4be04c2e74d58bcaa7e823e2509d1a7803d4/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=406e4be04c2e74d58bcaa7e823e2509d1a7803d4", "patch": "@@ -99,8 +99,8 @@ impl<'a> InferenceContext<'a> {\n         if self.db.trait_solve(krate, goal.value).is_some() {\n             self.obligations.push(implements_fn_trait);\n             let output_proj_ty = crate::ProjectionTy {\n-                associated_ty: to_assoc_type_id(output_assoc_type),\n-                parameters: substs,\n+                associated_ty_id: to_assoc_type_id(output_assoc_type),\n+                substitution: substs,\n             };\n             let return_ty = self.normalize_projection_ty(output_proj_ty);\n             Some((arg_tys, return_ty))\n@@ -261,7 +261,7 @@ impl<'a> InferenceContext<'a> {\n                 sig_tys.push(ret_ty.clone());\n                 let sig_ty = TyKind::Function(FnPointer {\n                     num_args: sig_tys.len() - 1,\n-                    sig: FnSig { variadic: false },\n+                    sig: FnSig { abi: (), safety: chalk_ir::Safety::Safe, variadic: false },\n                     substs: Substs(sig_tys.clone().into()),\n                 })\n                 .intern(&Interner);"}, {"sha": "ebc612ca9cef43be2cb1618d5b595f0125f1da69", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/406e4be04c2e74d58bcaa7e823e2509d1a7803d4/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406e4be04c2e74d58bcaa7e823e2509d1a7803d4/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=406e4be04c2e74d58bcaa7e823e2509d1a7803d4", "patch": "@@ -381,11 +381,11 @@ impl InferenceTable {\n                 self.unify_substs(&tr1.substs, &tr2.substs, depth + 1)\n             }\n             (GenericPredicate::Projection(proj1), GenericPredicate::Projection(proj2))\n-                if proj1.projection_ty.associated_ty == proj2.projection_ty.associated_ty =>\n+                if proj1.projection_ty.associated_ty_id == proj2.projection_ty.associated_ty_id =>\n             {\n                 self.unify_substs(\n-                    &proj1.projection_ty.parameters,\n-                    &proj2.projection_ty.parameters,\n+                    &proj1.projection_ty.substitution,\n+                    &proj2.projection_ty.substitution,\n                     depth + 1,\n                 ) && self.unify_inner(&proj1.ty, &proj2.ty, depth + 1)\n             }"}, {"sha": "484652073c56788ff83656746e0ace7646992582", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/406e4be04c2e74d58bcaa7e823e2509d1a7803d4/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406e4be04c2e74d58bcaa7e823e2509d1a7803d4/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=406e4be04c2e74d58bcaa7e823e2509d1a7803d4", "patch": "@@ -46,7 +46,7 @@ pub use lower::{\n };\n pub use traits::{InEnvironment, Obligation, ProjectionPredicate, TraitEnvironment};\n \n-pub use chalk_ir::{AdtId, BoundVar, DebruijnIndex, Mutability, Scalar, TyVariableKind};\n+pub use chalk_ir::{AdtId, BoundVar, DebruijnIndex, Mutability, Safety, Scalar, TyVariableKind};\n \n pub use crate::traits::chalk::Interner;\n \n@@ -66,25 +66,25 @@ pub enum Lifetime {\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct OpaqueTy {\n     pub opaque_ty_id: OpaqueTyId,\n-    pub parameters: Substs,\n+    pub substitution: Substs,\n }\n \n /// A \"projection\" type corresponds to an (unnormalized)\n /// projection like `<P0 as Trait<P1..Pn>>::Foo`. Note that the\n /// trait and all its parameters are fully known.\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct ProjectionTy {\n-    pub associated_ty: AssocTypeId,\n-    pub parameters: Substs,\n+    pub associated_ty_id: AssocTypeId,\n+    pub substitution: Substs,\n }\n \n impl ProjectionTy {\n     pub fn trait_ref(&self, db: &dyn HirDatabase) -> TraitRef {\n-        TraitRef { trait_: self.trait_(db), substs: self.parameters.clone() }\n+        TraitRef { trait_: self.trait_(db), substs: self.substitution.clone() }\n     }\n \n     fn trait_(&self, db: &dyn HirDatabase) -> TraitId {\n-        match from_assoc_type_id(self.associated_ty).lookup(db.upcast()).container {\n+        match from_assoc_type_id(self.associated_ty_id).lookup(db.upcast()).container {\n             AssocContainerId::TraitId(it) => it,\n             _ => panic!(\"projection ty without parent trait\"),\n         }\n@@ -93,22 +93,19 @@ impl ProjectionTy {\n \n impl TypeWalk for ProjectionTy {\n     fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        self.parameters.walk(f);\n+        self.substitution.walk(f);\n     }\n \n     fn walk_mut_binders(\n         &mut self,\n         f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n         binders: DebruijnIndex,\n     ) {\n-        self.parameters.walk_mut_binders(f, binders);\n+        self.substitution.walk_mut_binders(f, binders);\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Debug, Hash)]\n-pub struct FnSig {\n-    pub variadic: bool,\n-}\n+pub type FnSig = chalk_ir::FnSig<Interner>;\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct FnPointer {\n@@ -643,7 +640,7 @@ impl Ty {\n     pub fn fn_ptr(sig: CallableSig) -> Self {\n         TyKind::Function(FnPointer {\n             num_args: sig.params().len(),\n-            sig: FnSig { variadic: sig.is_varargs },\n+            sig: FnSig { abi: (), safety: Safety::Safe, variadic: sig.is_varargs },\n             substs: Substs(sig.params_and_return),\n         })\n         .intern(&Interner)\n@@ -906,7 +903,7 @@ impl Ty {\n                             let data = (*it)\n                                 .as_ref()\n                                 .map(|rpit| rpit.impl_traits[idx as usize].bounds.clone());\n-                            data.subst(&opaque_ty.parameters)\n+                            data.subst(&opaque_ty.substitution)\n                         })\n                     }\n                     // It always has an parameter for Future::Output type.\n@@ -945,7 +942,9 @@ impl Ty {\n                 }\n             }\n             TyKind::Alias(AliasTy::Projection(projection_ty)) => {\n-                match from_assoc_type_id(projection_ty.associated_ty).lookup(db.upcast()).container\n+                match from_assoc_type_id(projection_ty.associated_ty_id)\n+                    .lookup(db.upcast())\n+                    .container\n                 {\n                     AssocContainerId::TraitId(trait_id) => Some(trait_id),\n                     _ => None,\n@@ -1055,12 +1054,12 @@ impl TypeWalk for Ty {\n     fn walk(&self, f: &mut impl FnMut(&Ty)) {\n         match self.interned(&Interner) {\n             TyKind::Alias(AliasTy::Projection(p_ty)) => {\n-                for t in p_ty.parameters.iter() {\n+                for t in p_ty.substitution.iter() {\n                     t.walk(f);\n                 }\n             }\n             TyKind::Alias(AliasTy::Opaque(o_ty)) => {\n-                for t in o_ty.parameters.iter() {\n+                for t in o_ty.substitution.iter() {\n                     t.walk(f);\n                 }\n             }\n@@ -1087,15 +1086,15 @@ impl TypeWalk for Ty {\n     ) {\n         match &mut self.0 {\n             TyKind::Alias(AliasTy::Projection(p_ty)) => {\n-                p_ty.parameters.walk_mut_binders(f, binders);\n+                p_ty.substitution.walk_mut_binders(f, binders);\n             }\n             TyKind::Dyn(predicates) => {\n                 for p in make_mut_slice(predicates) {\n                     p.walk_mut_binders(f, binders.shifted_in());\n                 }\n             }\n             TyKind::Alias(AliasTy::Opaque(o_ty)) => {\n-                o_ty.parameters.walk_mut_binders(f, binders);\n+                o_ty.substitution.walk_mut_binders(f, binders);\n             }\n             _ => {\n                 if let Some(substs) = self.substs_mut() {"}, {"sha": "d026310f4d6b0a039ac62cd6294b9d2baf4cccc4", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/406e4be04c2e74d58bcaa7e823e2509d1a7803d4/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406e4be04c2e74d58bcaa7e823e2509d1a7803d4/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=406e4be04c2e74d58bcaa7e823e2509d1a7803d4", "patch": "@@ -8,7 +8,7 @@\n use std::{iter, sync::Arc};\n \n use base_db::CrateId;\n-use chalk_ir::{cast::Cast, Mutability};\n+use chalk_ir::{cast::Cast, Mutability, Safety};\n use hir_def::{\n     adt::StructKind,\n     builtin_type::BuiltinType,\n@@ -181,7 +181,7 @@ impl<'a> TyLoweringContext<'a> {\n                 let substs = Substs(params.iter().map(|tr| self.lower_ty(tr)).collect());\n                 TyKind::Function(FnPointer {\n                     num_args: substs.len() - 1,\n-                    sig: FnSig { variadic: *is_varargs },\n+                    sig: FnSig { abi: (), safety: Safety::Safe, variadic: *is_varargs },\n                     substs,\n                 })\n                 .intern(&Interner)\n@@ -230,8 +230,11 @@ impl<'a> TyLoweringContext<'a> {\n                         let opaque_ty_id = self.db.intern_impl_trait_id(impl_trait_id).into();\n                         let generics = generics(self.db.upcast(), func.into());\n                         let parameters = Substs::bound_vars(&generics, self.in_binders);\n-                        TyKind::Alias(AliasTy::Opaque(OpaqueTy { opaque_ty_id, parameters }))\n-                            .intern(&Interner)\n+                        TyKind::Alias(AliasTy::Opaque(OpaqueTy {\n+                            opaque_ty_id,\n+                            substitution: parameters,\n+                        }))\n+                        .intern(&Interner)\n                     }\n                     ImplTraitLoweringMode::Param => {\n                         let idx = self.impl_trait_counter.get();\n@@ -357,8 +360,8 @@ impl<'a> TyLoweringContext<'a> {\n                         Some((super_trait_ref, associated_ty)) => {\n                             // FIXME handle type parameters on the segment\n                             TyKind::Alias(AliasTy::Projection(ProjectionTy {\n-                                associated_ty: to_assoc_type_id(associated_ty),\n-                                parameters: super_trait_ref.substs,\n+                                associated_ty_id: to_assoc_type_id(associated_ty),\n+                                substitution: super_trait_ref.substs,\n                             }))\n                             .intern(&Interner)\n                         }\n@@ -478,8 +481,8 @@ impl<'a> TyLoweringContext<'a> {\n                         // FIXME handle type parameters on the segment\n                         return Some(\n                             TyKind::Alias(AliasTy::Projection(ProjectionTy {\n-                                associated_ty: to_assoc_type_id(associated_ty),\n-                                parameters: substs,\n+                                associated_ty_id: to_assoc_type_id(associated_ty),\n+                                substitution: substs,\n                             }))\n                             .intern(&Interner),\n                         );\n@@ -736,8 +739,8 @@ impl<'a> TyLoweringContext<'a> {\n                     Some(t) => t,\n                 };\n                 let projection_ty = ProjectionTy {\n-                    associated_ty: to_assoc_type_id(associated_ty),\n-                    parameters: super_trait_ref.substs,\n+                    associated_ty_id: to_assoc_type_id(associated_ty),\n+                    substitution: super_trait_ref.substs,\n                 };\n                 let mut preds = SmallVec::with_capacity(\n                     binding.type_ref.as_ref().map_or(0, |_| 1) + binding.bounds.len(),"}, {"sha": "a6a63c6736fca91c53d4c217db105fb4e9debbe8", "filename": "crates/hir_ty/src/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/406e4be04c2e74d58bcaa7e823e2509d1a7803d4/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406e4be04c2e74d58bcaa7e823e2509d1a7803d4/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits.rs?ref=406e4be04c2e74d58bcaa7e823e2509d1a7803d4", "patch": "@@ -143,7 +143,7 @@ pub(crate) fn trait_solve_query(\n     log::info!(\"trait_solve_query({})\", goal.value.value.display(db));\n \n     if let Obligation::Projection(pred) = &goal.value.value {\n-        if let TyKind::BoundVar(_) = &pred.projection_ty.parameters[0].interned(&Interner) {\n+        if let TyKind::BoundVar(_) = &pred.projection_ty.substitution[0].interned(&Interner) {\n             // Hack: don't ask Chalk to normalize with an unknown self type, it'll say that's impossible\n             return Some(Solution::Ambig(Guidance::Unknown));\n         }"}, {"sha": "232cf9cd0d66d6bad17e8b860ab2b18fc25fabc8", "filename": "crates/hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/406e4be04c2e74d58bcaa7e823e2509d1a7803d4/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406e4be04c2e74d58bcaa7e823e2509d1a7803d4/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=406e4be04c2e74d58bcaa7e823e2509d1a7803d4", "patch": "@@ -234,9 +234,9 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n                         ty: TyKind::BoundVar(BoundVar { debruijn: DebruijnIndex::ONE, index: 0 })\n                             .intern(&Interner),\n                         projection_ty: ProjectionTy {\n-                            associated_ty: to_assoc_type_id(future_output),\n+                            associated_ty_id: to_assoc_type_id(future_output),\n                             // Self type as the first parameter.\n-                            parameters: Substs::single(\n+                            substitution: Substs::single(\n                                 TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0))\n                                     .intern(&Interner),\n                             ),"}, {"sha": "05a4bf0df6ff6f45070cd061554a18fd7fb4e4f4", "filename": "crates/hir_ty/src/traits/chalk/mapping.rs", "status": "modified", "additions": 27, "deletions": 30, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/406e4be04c2e74d58bcaa7e823e2509d1a7803d4/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/406e4be04c2e74d58bcaa7e823e2509d1a7803d4/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=406e4be04c2e74d58bcaa7e823e2509d1a7803d4", "patch": "@@ -14,7 +14,7 @@ use crate::{\n     from_assoc_type_id,\n     primitive::UintTy,\n     traits::{Canonical, Obligation},\n-    AliasTy, CallableDefId, FnPointer, FnSig, GenericPredicate, InEnvironment, OpaqueTy,\n+    AliasTy, CallableDefId, FnPointer, GenericPredicate, InEnvironment, OpaqueTy,\n     ProjectionPredicate, ProjectionTy, Scalar, Substs, TraitRef, Ty,\n };\n \n@@ -27,11 +27,11 @@ impl ToChalk for Ty {\n         match self.0 {\n             TyKind::Ref(m, parameters) => ref_to_chalk(db, m, parameters),\n             TyKind::Array(parameters) => array_to_chalk(db, parameters),\n-            TyKind::Function(FnPointer { sig: FnSig { variadic }, substs, .. }) => {\n+            TyKind::Function(FnPointer { sig, substs, .. }) => {\n                 let substitution = chalk_ir::FnSubst(substs.to_chalk(db).shifted_in(&Interner));\n                 chalk_ir::TyKind::Function(chalk_ir::FnPointer {\n                     num_binders: 0,\n-                    sig: chalk_ir::FnSig { abi: (), safety: chalk_ir::Safety::Safe, variadic },\n+                    sig,\n                     substitution,\n                 })\n                 .intern(&Interner)\n@@ -78,15 +78,22 @@ impl ToChalk for Ty {\n                 chalk_ir::TyKind::Adt(adt_id, substitution).intern(&Interner)\n             }\n             TyKind::Alias(AliasTy::Projection(proj_ty)) => {\n-                let associated_ty_id = proj_ty.associated_ty;\n-                let substitution = proj_ty.parameters.to_chalk(db);\n+                let associated_ty_id = proj_ty.associated_ty_id;\n+                let substitution = proj_ty.substitution.to_chalk(db);\n                 chalk_ir::AliasTy::Projection(chalk_ir::ProjectionTy {\n                     associated_ty_id,\n                     substitution,\n                 })\n                 .cast(&Interner)\n                 .intern(&Interner)\n             }\n+            TyKind::Alias(AliasTy::Opaque(opaque_ty)) => {\n+                let opaque_ty_id = opaque_ty.opaque_ty_id;\n+                let substitution = opaque_ty.substitution.to_chalk(db);\n+                chalk_ir::AliasTy::Opaque(chalk_ir::OpaqueTy { opaque_ty_id, substitution })\n+                    .cast(&Interner)\n+                    .intern(&Interner)\n+            }\n             TyKind::Placeholder(idx) => idx.to_ty::<Interner>(&Interner),\n             TyKind::BoundVar(idx) => chalk_ir::TyKind::BoundVar(idx).intern(&Interner),\n             TyKind::InferenceVar(..) => panic!(\"uncanonicalized infer ty\"),\n@@ -101,15 +108,6 @@ impl ToChalk for Ty {\n                 };\n                 chalk_ir::TyKind::Dyn(bounded_ty).intern(&Interner)\n             }\n-            TyKind::Alias(AliasTy::Opaque(opaque_ty)) => {\n-                let opaque_ty_id = opaque_ty.opaque_ty_id;\n-                let substitution = opaque_ty.parameters.to_chalk(db);\n-                chalk_ir::TyKind::Alias(chalk_ir::AliasTy::Opaque(chalk_ir::OpaqueTy {\n-                    opaque_ty_id,\n-                    substitution,\n-                }))\n-                .intern(&Interner)\n-            }\n             TyKind::Unknown => chalk_ir::TyKind::Error.intern(&Interner),\n         }\n     }\n@@ -121,16 +119,19 @@ impl ToChalk for Ty {\n             chalk_ir::TyKind::Alias(chalk_ir::AliasTy::Projection(proj)) => {\n                 let associated_ty = proj.associated_ty_id;\n                 let parameters = from_chalk(db, proj.substitution);\n-                TyKind::Alias(AliasTy::Projection(ProjectionTy { associated_ty, parameters }))\n+                TyKind::Alias(AliasTy::Projection(ProjectionTy {\n+                    associated_ty_id: associated_ty,\n+                    substitution: parameters,\n+                }))\n             }\n             chalk_ir::TyKind::Alias(chalk_ir::AliasTy::Opaque(opaque_ty)) => {\n                 let opaque_ty_id = opaque_ty.opaque_ty_id;\n                 let parameters = from_chalk(db, opaque_ty.substitution);\n-                TyKind::Alias(AliasTy::Opaque(OpaqueTy { opaque_ty_id, parameters }))\n+                TyKind::Alias(AliasTy::Opaque(OpaqueTy { opaque_ty_id, substitution: parameters }))\n             }\n             chalk_ir::TyKind::Function(chalk_ir::FnPointer {\n                 num_binders,\n-                sig: chalk_ir::FnSig { variadic, .. },\n+                sig,\n                 substitution,\n                 ..\n             }) => {\n@@ -139,11 +140,7 @@ impl ToChalk for Ty {\n                     db,\n                     substitution.0.shifted_out(&Interner).expect(\"fn ptr should have no binders\"),\n                 );\n-                TyKind::Function(FnPointer {\n-                    num_args: (substs.len() - 1),\n-                    sig: FnSig { variadic },\n-                    substs,\n-                })\n+                TyKind::Function(FnPointer { num_args: (substs.len() - 1), sig, substs })\n             }\n             chalk_ir::TyKind::BoundVar(idx) => TyKind::BoundVar(idx),\n             chalk_ir::TyKind::InferenceVar(_iv, _kind) => TyKind::Unknown,\n@@ -372,8 +369,8 @@ impl ToChalk for ProjectionTy {\n \n     fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::ProjectionTy<Interner> {\n         chalk_ir::ProjectionTy {\n-            associated_ty_id: self.associated_ty,\n-            substitution: self.parameters.to_chalk(db),\n+            associated_ty_id: self.associated_ty_id,\n+            substitution: self.substitution.to_chalk(db),\n         }\n     }\n \n@@ -382,8 +379,8 @@ impl ToChalk for ProjectionTy {\n         projection_ty: chalk_ir::ProjectionTy<Interner>,\n     ) -> ProjectionTy {\n         ProjectionTy {\n-            associated_ty: projection_ty.associated_ty_id,\n-            parameters: from_chalk(db, projection_ty.substitution),\n+            associated_ty_id: projection_ty.associated_ty_id,\n+            substitution: from_chalk(db, projection_ty.substitution),\n         }\n     }\n }\n@@ -533,24 +530,24 @@ pub(super) fn generic_predicate_to_inline_bound(\n             Some(rust_ir::InlineBound::TraitBound(trait_bound))\n         }\n         GenericPredicate::Projection(proj) => {\n-            if &proj.projection_ty.parameters[0] != self_ty {\n+            if &proj.projection_ty.substitution[0] != self_ty {\n                 return None;\n             }\n-            let trait_ = match from_assoc_type_id(proj.projection_ty.associated_ty)\n+            let trait_ = match from_assoc_type_id(proj.projection_ty.associated_ty_id)\n                 .lookup(db.upcast())\n                 .container\n             {\n                 AssocContainerId::TraitId(t) => t,\n                 _ => panic!(\"associated type not in trait\"),\n             };\n-            let args_no_self = proj.projection_ty.parameters[1..]\n+            let args_no_self = proj.projection_ty.substitution[1..]\n                 .iter()\n                 .map(|ty| ty.clone().to_chalk(db).cast(&Interner))\n                 .collect();\n             let alias_eq_bound = rust_ir::AliasEqBound {\n                 value: proj.ty.clone().to_chalk(db),\n                 trait_bound: rust_ir::TraitBound { trait_id: trait_.to_chalk(db), args_no_self },\n-                associated_ty_id: proj.projection_ty.associated_ty,\n+                associated_ty_id: proj.projection_ty.associated_ty_id,\n                 parameters: Vec::new(), // FIXME we don't support generic associated types yet\n             };\n             Some(rust_ir::InlineBound::AliasEqBound(alias_eq_bound))"}]}