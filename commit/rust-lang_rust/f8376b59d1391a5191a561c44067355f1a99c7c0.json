{"sha": "f8376b59d1391a5191a561c44067355f1a99c7c0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4Mzc2YjU5ZDEzOTFhNTE5MWE1NjFjNDQwNjczNTVmMWE5OWM3YzA=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2020-08-09T19:08:45Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2020-09-04T12:00:49Z"}, "message": "shim: monomorphic `FnPtrShim`s during construction\n\nThis commit adjusts MIR shim construction so that substitutions are\napplied to function pointer shims during construction, rather than\nduring codegen (as determined by `substs_for_mir_body`) - as\nsubstitutions will no longer occur during codegen, function pointer\nshims can now be polymorphic without incurring double substitutions.\n\nSigned-off-by: David Wood <david@davidtw.co>", "tree": {"sha": "2e6e0b5256a11a2faa396ea48e6263ce8a3e69df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e6e0b5256a11a2faa396ea48e6263ce8a3e69df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8376b59d1391a5191a561c44067355f1a99c7c0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEfgm2/wUjk9OnjxlyJZLnbIc4H9kFAl9SLHEACgkQJZLnbIc4\nH9n+cg//TLdCvZ2ULtui4tgl8ZajVRkBU1hhuAANraTa+O2TZ1mdy2NXRUj8ceSJ\nzAKGOqy9GyklJ2FM5ww1ANocYh+mbvk+NUz5Srm4+vaSLb4Orb5VG5Zs/C01YXos\nPnWx747rkp7h+Bkt4Oj4wsVoEhLISsogdyEkeLcwEcKOOXjyOEs7RYf1sf1mmUoU\n1eZTHiIsGU+KJTV644s05nSnHCQH5mDXfTlxVkbm44VIOddsYN2wd7hKOqArfhRx\n4mofuewo6CVIDsv9wFX7osjj70mBPI3Td2h0dZ09CXY+HTNsJX2vfIzcZjbBcmDU\ntOIXBjIzt1hPLzC3yx0MyKc+HxOlvGxcdNo3JlpZHfh4fjG7/NnrOO3tO9YtHKQp\nedJJ3xor/rEtEscVXCxLvYLpElexXITWzu20SgoV1Jy7/I3DTaVnsVIiaC0Vo30q\nF/F2HU8ArsXc0n5kF+p1dK+LAfL6XsXn++7XuUlBGEhE9Q8DkSdqw1XPx23h4q4n\n5H61COfvb88hyDyMaRODp7wNyh4Q2U+z2as+c9j9huoY5l/bLzGAm916xsicpC5t\nQpa4zQb3ZgVOhFwDgZS6pp4jyvDl/umwzLeMCLPQNuXr4Sqfm0oLGkJAooJ5Wk71\nC4pRxkL0Ozsl1yMCoJNGXhs5hYjcmNWg6Pkr0NxM2h9UWTxj+cA=\n=OxLL\n-----END PGP SIGNATURE-----", "payload": "tree 2e6e0b5256a11a2faa396ea48e6263ce8a3e69df\nparent 4ffb5c5954a304daf47a567b34e74e421db86d98\nauthor David Wood <david@davidtw.co> 1597000125 +0100\ncommitter David Wood <david@davidtw.co> 1599220849 +0100\n\nshim: monomorphic `FnPtrShim`s during construction\n\nThis commit adjusts MIR shim construction so that substitutions are\napplied to function pointer shims during construction, rather than\nduring codegen (as determined by `substs_for_mir_body`) - as\nsubstitutions will no longer occur during codegen, function pointer\nshims can now be polymorphic without incurring double substitutions.\n\nSigned-off-by: David Wood <david@davidtw.co>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8376b59d1391a5191a561c44067355f1a99c7c0", "html_url": "https://github.com/rust-lang/rust/commit/f8376b59d1391a5191a561c44067355f1a99c7c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8376b59d1391a5191a561c44067355f1a99c7c0/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ffb5c5954a304daf47a567b34e74e421db86d98", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ffb5c5954a304daf47a567b34e74e421db86d98", "html_url": "https://github.com/rust-lang/rust/commit/4ffb5c5954a304daf47a567b34e74e421db86d98"}], "stats": {"total": 117, "additions": 58, "deletions": 59}, "files": [{"sha": "a6b62097d5b18d8d3baf764192ef081b968c9da2", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f8376b59d1391a5191a561c44067355f1a99c7c0/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8376b59d1391a5191a561c44067355f1a99c7c0/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=f8376b59d1391a5191a561c44067355f1a99c7c0", "patch": "@@ -62,10 +62,6 @@ pub enum InstanceDef<'tcx> {\n     /// `<fn() as FnTrait>::call_*` (generated `FnTrait` implementation for `fn()` pointers).\n     ///\n     /// `DefId` is `FnTrait::call_*`.\n-    ///\n-    /// NB: the (`fn` pointer) type must currently be monomorphic to avoid double substitution\n-    /// problems with the MIR shim bodies. `Instance::resolve` enforces this.\n-    // FIXME(#69925) support polymorphic MIR shim bodies properly instead.\n     FnPtrShim(DefId, Ty<'tcx>),\n \n     /// Dynamic dispatch to `<dyn Trait as Trait>::fn`.\n@@ -87,10 +83,6 @@ pub enum InstanceDef<'tcx> {\n     /// The `DefId` is for `core::ptr::drop_in_place`.\n     /// The `Option<Ty<'tcx>>` is either `Some(T)`, or `None` for empty drop\n     /// glue.\n-    ///\n-    /// NB: the type must currently be monomorphic to avoid double substitution\n-    /// problems with the MIR shim bodies. `Instance::resolve` enforces this.\n-    // FIXME(#69925) support polymorphic MIR shim bodies properly instead.\n     DropGlue(DefId, Option<Ty<'tcx>>),\n \n     /// Compiler-generated `<T as Clone>::clone` implementation.\n@@ -99,10 +91,6 @@ pub enum InstanceDef<'tcx> {\n     /// Additionally, arrays, tuples, and closures get a `Clone` shim even if they aren't `Copy`.\n     ///\n     /// The `DefId` is for `Clone::clone`, the `Ty` is the type `T` with the builtin `Clone` impl.\n-    ///\n-    /// NB: the type must currently be monomorphic to avoid double substitution\n-    /// problems with the MIR shim bodies. `Instance::resolve` enforces this.\n-    // FIXME(#69925) support polymorphic MIR shim bodies properly instead.\n     CloneShim(DefId, Ty<'tcx>),\n }\n \n@@ -243,6 +231,27 @@ impl<'tcx> InstanceDef<'tcx> {\n             _ => false,\n         }\n     }\n+\n+    /// Returns `true` when the MIR body associated with this instance should be monomorphized\n+    /// by its users (e.g. codegen or miri) by substituting the `substs` from `Instance` (see\n+    /// `Instance::substs_for_mir_body`).\n+    ///\n+    /// Otherwise, returns `false` only for some kinds of shims where the construction of the MIR\n+    /// body should perform necessary substitutions.\n+    pub fn has_polymorphic_mir_body(&self) -> bool {\n+        match *self {\n+            InstanceDef::CloneShim(..)\n+            | InstanceDef::FnPtrShim(..)\n+            | InstanceDef::DropGlue(_, Some(_)) => false,\n+            InstanceDef::ClosureOnceShim { .. }\n+            | InstanceDef::DropGlue(..)\n+            | InstanceDef::Item(_)\n+            | InstanceDef::Intrinsic(..)\n+            | InstanceDef::ReifyShim(..)\n+            | InstanceDef::Virtual(..)\n+            | InstanceDef::VtableShim(..) => true,\n+        }\n+    }\n }\n \n impl<'tcx> fmt::Display for Instance<'tcx> {\n@@ -440,30 +449,18 @@ impl<'tcx> Instance<'tcx> {\n         Instance { def, substs }\n     }\n \n-    /// FIXME(#69925) Depending on the kind of `InstanceDef`, the MIR body associated with an\n+    /// Depending on the kind of `InstanceDef`, the MIR body associated with an\n     /// instance is expressed in terms of the generic parameters of `self.def_id()`, and in other\n     /// cases the MIR body is expressed in terms of the types found in the substitution array.\n     /// In the former case, we want to substitute those generic types and replace them with the\n     /// values from the substs when monomorphizing the function body. But in the latter case, we\n     /// don't want to do that substitution, since it has already been done effectively.\n     ///\n-    /// This function returns `Some(substs)` in the former case and None otherwise -- i.e., if\n+    /// This function returns `Some(substs)` in the former case and `None` otherwise -- i.e., if\n     /// this function returns `None`, then the MIR body does not require substitution during\n-    /// monomorphization.\n+    /// codegen.\n     pub fn substs_for_mir_body(&self) -> Option<SubstsRef<'tcx>> {\n-        match self.def {\n-            InstanceDef::CloneShim(..)\n-            | InstanceDef::DropGlue(_, Some(_)) => None,\n-            InstanceDef::ClosureOnceShim { .. }\n-            | InstanceDef::DropGlue(..)\n-            // FIXME(#69925): `FnPtrShim` should be in the other branch.\n-            | InstanceDef::FnPtrShim(..)\n-            | InstanceDef::Item(_)\n-            | InstanceDef::Intrinsic(..)\n-            | InstanceDef::ReifyShim(..)\n-            | InstanceDef::Virtual(..)\n-            | InstanceDef::VtableShim(..) => Some(self.substs),\n-        }\n+        if self.def.has_polymorphic_mir_body() { Some(self.substs) } else { None }\n     }\n \n     /// Returns a new `Instance` where generic parameters in `instance.substs` are replaced by"}, {"sha": "a99302e9521554a84da8714f1ffd3432cd686f97", "filename": "compiler/rustc_mir/src/shim.rs", "status": "modified", "additions": 31, "deletions": 29, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f8376b59d1391a5191a561c44067355f1a99c7c0/compiler%2Frustc_mir%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8376b59d1391a5191a561c44067355f1a99c7c0/compiler%2Frustc_mir%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fshim.rs?ref=f8376b59d1391a5191a561c44067355f1a99c7c0", "patch": "@@ -33,7 +33,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> Body<'\n     let mut result = match instance {\n         ty::InstanceDef::Item(..) => bug!(\"item {:?} passed to make_shim\", instance),\n         ty::InstanceDef::VtableShim(def_id) => {\n-            build_call_shim(tcx, instance, Some(Adjustment::Deref), CallKind::Direct(def_id), None)\n+            build_call_shim(tcx, instance, Some(Adjustment::Deref), CallKind::Direct(def_id))\n         }\n         ty::InstanceDef::FnPtrShim(def_id, ty) => {\n             let trait_ = tcx.trait_of_item(def_id).unwrap();\n@@ -42,24 +42,16 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> Body<'\n                 Some(ty::ClosureKind::FnMut | ty::ClosureKind::Fn) => Adjustment::Deref,\n                 None => bug!(\"fn pointer {:?} is not an fn\", ty),\n             };\n-            // HACK: we need the \"real\" argument types for the MIR,\n-            // but because our substs are (Self, Args), where Args\n-            // is a tuple, we must include the *concrete* argument\n-            // types in the MIR. They will be substituted again with\n-            // the param-substs, but because they are concrete, this\n-            // will not do any harm.\n-            let sig = tcx.erase_late_bound_regions(&ty.fn_sig(tcx));\n-            let arg_tys = sig.inputs();\n-\n-            build_call_shim(tcx, instance, Some(adjustment), CallKind::Indirect(ty), Some(arg_tys))\n+\n+            build_call_shim(tcx, instance, Some(adjustment), CallKind::Indirect(ty))\n         }\n         // We are generating a call back to our def-id, which the\n         // codegen backend knows to turn to an actual call, be it\n         // a virtual call, or a direct call to a function for which\n         // indirect calls must be codegen'd differently than direct ones\n         // (such as `#[track_caller]`).\n         ty::InstanceDef::ReifyShim(def_id) => {\n-            build_call_shim(tcx, instance, None, CallKind::Direct(def_id), None)\n+            build_call_shim(tcx, instance, None, CallKind::Direct(def_id))\n         }\n         ty::InstanceDef::ClosureOnceShim { call_once: _ } => {\n             let fn_mut = tcx.require_lang_item(LangItem::FnMut, None);\n@@ -70,13 +62,7 @@ fn make_shim<'tcx>(tcx: TyCtxt<'tcx>, instance: ty::InstanceDef<'tcx>) -> Body<'\n                 .unwrap()\n                 .def_id;\n \n-            build_call_shim(\n-                tcx,\n-                instance,\n-                Some(Adjustment::RefMut),\n-                CallKind::Direct(call_mut),\n-                None,\n-            )\n+            build_call_shim(tcx, instance, Some(Adjustment::RefMut), CallKind::Direct(call_mut))\n         }\n         ty::InstanceDef::DropGlue(def_id, ty) => build_drop_shim(tcx, def_id, ty),\n         ty::InstanceDef::CloneShim(def_id, ty) => build_clone_shim(tcx, def_id, ty),\n@@ -641,29 +627,45 @@ impl CloneShimBuilder<'tcx> {\n     }\n }\n \n-/// Builds a \"call\" shim for `instance`. The shim calls the\n-/// function specified by `call_kind`, first adjusting its first\n-/// argument according to `rcvr_adjustment`.\n-///\n-/// If `untuple_args` is a vec of types, the second argument of the\n-/// function will be untupled as these types.\n+/// Builds a \"call\" shim for `instance`. The shim calls the function specified by `call_kind`,\n+/// first adjusting its first argument according to `rcvr_adjustment`.\n fn build_call_shim<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     instance: ty::InstanceDef<'tcx>,\n     rcvr_adjustment: Option<Adjustment>,\n     call_kind: CallKind<'tcx>,\n-    untuple_args: Option<&[Ty<'tcx>]>,\n ) -> Body<'tcx> {\n     debug!(\n-        \"build_call_shim(instance={:?}, rcvr_adjustment={:?}, \\\n-            call_kind={:?}, untuple_args={:?})\",\n-        instance, rcvr_adjustment, call_kind, untuple_args\n+        \"build_call_shim(instance={:?}, rcvr_adjustment={:?}, call_kind={:?})\",\n+        instance, rcvr_adjustment, call_kind\n     );\n \n+    // `FnPtrShim` contains the fn pointer type that a call shim is being built for - this is used\n+    // to substitute into the signature of the shim. It is not necessary for users of this\n+    // MIR body to perform further substitutions (see `InstanceDef::has_polymorphic_mir_body`).\n+    let (sig_substs, untuple_args) = if let ty::InstanceDef::FnPtrShim(_, ty) = instance {\n+        let sig = tcx.erase_late_bound_regions(&ty.fn_sig(tcx));\n+\n+        let untuple_args = sig.inputs();\n+\n+        // Create substitutions for the `Self` and `Args` generic parameters of the shim body.\n+        let arg_tup = tcx.mk_tup(untuple_args.iter());\n+        let sig_substs = tcx.mk_substs_trait(ty, &[ty::subst::GenericArg::from(arg_tup)]);\n+\n+        (Some(sig_substs), Some(untuple_args))\n+    } else {\n+        (None, None)\n+    };\n+\n     let def_id = instance.def_id();\n     let sig = tcx.fn_sig(def_id);\n     let mut sig = tcx.erase_late_bound_regions(&sig);\n \n+    assert_eq!(sig_substs.is_some(), !instance.has_polymorphic_mir_body());\n+    if let Some(sig_substs) = sig_substs {\n+        sig = sig.subst(tcx, sig_substs);\n+    }\n+\n     if let CallKind::Indirect(fnty) = call_kind {\n         // `sig` determines our local decls, and thus the callee type in the `Call` terminator. This\n         // can only be an `FnDef` or `FnPtr`, but currently will be `Self` since the types come from"}, {"sha": "bcc6042f2fb622b8caddad6ae18151a7aa6aa825", "filename": "src/test/mir-opt/fn_ptr_shim.core.ops-function-Fn-call.AddMovesForPackedDrops.before.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f8376b59d1391a5191a561c44067355f1a99c7c0/src%2Ftest%2Fmir-opt%2Ffn_ptr_shim.core.ops-function-Fn-call.AddMovesForPackedDrops.before.mir", "raw_url": "https://github.com/rust-lang/rust/raw/f8376b59d1391a5191a561c44067355f1a99c7c0/src%2Ftest%2Fmir-opt%2Ffn_ptr_shim.core.ops-function-Fn-call.AddMovesForPackedDrops.before.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Ffn_ptr_shim.core.ops-function-Fn-call.AddMovesForPackedDrops.before.mir?ref=f8376b59d1391a5191a561c44067355f1a99c7c0", "patch": "@@ -1,7 +1,7 @@\n // MIR for `std::ops::Fn::call` before AddMovesForPackedDrops\n \n-fn std::ops::Fn::call(_1: *const fn(), _2: Args) -> <Self as FnOnce<Args>>::Output {\n-    let mut _0: <Self as std::ops::FnOnce<Args>>::Output; // return place in scope 0 at $SRC_DIR/core/src/ops/function.rs:LL:COL\n+fn std::ops::Fn::call(_1: *const fn(), _2: ()) -> <fn() as FnOnce<()>>::Output {\n+    let mut _0: <fn() as std::ops::FnOnce<()>>::Output; // return place in scope 0 at $SRC_DIR/core/src/ops/function.rs:LL:COL\n \n     bb0: {\n         _0 = move (*_1)() -> bb1;        // scope 0 at $SRC_DIR/core/src/ops/function.rs:LL:COL"}]}