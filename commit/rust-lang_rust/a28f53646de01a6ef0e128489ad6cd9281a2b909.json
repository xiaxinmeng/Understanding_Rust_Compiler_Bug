{"sha": "a28f53646de01a6ef0e128489ad6cd9281a2b909", "node_id": "C_kwDOAAsO6NoAKGEyOGY1MzY0NmRlMDFhNmVmMGUxMjg0ODlhZDZjZDkyODFhMmI5MDk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-10T15:18:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-10T15:18:46Z"}, "message": "Auto merge of #14119 - Veykril:miniopt, r=Veykril\n\ninternal: Remove a few allocations in hir-ty::utils", "tree": {"sha": "1187c7ea8af33b288165a6e0af93448873ae8d49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1187c7ea8af33b288165a6e0af93448873ae8d49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a28f53646de01a6ef0e128489ad6cd9281a2b909", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a28f53646de01a6ef0e128489ad6cd9281a2b909", "html_url": "https://github.com/rust-lang/rust/commit/a28f53646de01a6ef0e128489ad6cd9281a2b909", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a28f53646de01a6ef0e128489ad6cd9281a2b909/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f11cff89761aebfca183a8a01b1ae06d7459aa3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f11cff89761aebfca183a8a01b1ae06d7459aa3c", "html_url": "https://github.com/rust-lang/rust/commit/f11cff89761aebfca183a8a01b1ae06d7459aa3c"}, {"sha": "8f5deb4ff2e38896599866b1a33e1fffb0b7304a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f5deb4ff2e38896599866b1a33e1fffb0b7304a", "html_url": "https://github.com/rust-lang/rust/commit/8f5deb4ff2e38896599866b1a33e1fffb0b7304a"}], "stats": {"total": 189, "additions": 96, "deletions": 93}, "files": [{"sha": "5fcbdf34f3cbbdaf4fc5073837fe8f8be105eab5", "filename": "crates/hir-ty/src/display.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a28f53646de01a6ef0e128489ad6cd9281a2b909/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a28f53646de01a6ef0e128489ad6cd9281a2b909/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=a28f53646de01a6ef0e128489ad6cd9281a2b909", "patch": "@@ -927,7 +927,7 @@ impl HirDisplay for CallableSig {\n     }\n }\n \n-fn fn_traits(db: &dyn DefDatabase, trait_: TraitId) -> impl Iterator<Item = TraitId> {\n+fn fn_traits(db: &dyn DefDatabase, trait_: TraitId) -> impl Iterator<Item = TraitId> + '_ {\n     let krate = trait_.lookup(db).container.krate();\n     utils::fn_traits(db, krate)\n }"}, {"sha": "7cce13a793e02800c5177c0f0b3c333b41e9dd65", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a28f53646de01a6ef0e128489ad6cd9281a2b909/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a28f53646de01a6ef0e128489ad6cd9281a2b909/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=a28f53646de01a6ef0e128489ad6cd9281a2b909", "patch": "@@ -1235,7 +1235,7 @@ fn named_associated_type_shorthand_candidates<R>(\n     mut cb: impl FnMut(&Name, &TraitRef, TypeAliasId) -> Option<R>,\n ) -> Option<R> {\n     let mut search = |t| {\n-        for t in all_super_trait_refs(db, t) {\n+        all_super_trait_refs(db, t, |t| {\n             let data = db.trait_data(t.hir_trait_id());\n \n             for (name, assoc_id) in &data.items {\n@@ -1245,8 +1245,8 @@ fn named_associated_type_shorthand_candidates<R>(\n                     }\n                 }\n             }\n-        }\n-        None\n+            None\n+        })\n     };\n \n     match res {"}, {"sha": "70d2d5efa6cdee5e33f11a66801d2fb909acef4b", "filename": "crates/hir-ty/src/utils.rs", "status": "modified", "additions": 92, "deletions": 89, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/a28f53646de01a6ef0e128489ad6cd9281a2b909/crates%2Fhir-ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a28f53646de01a6ef0e128489ad6cd9281a2b909/crates%2Fhir-ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Futils.rs?ref=a28f53646de01a6ef0e128489ad6cd9281a2b909", "patch": "@@ -27,23 +27,84 @@ use crate::{\n     db::HirDatabase, ChalkTraitId, Interner, Substitution, TraitRef, TraitRefExt, WhereClause,\n };\n \n-pub(crate) fn fn_traits(db: &dyn DefDatabase, krate: CrateId) -> impl Iterator<Item = TraitId> {\n-    [\n-        db.lang_item(krate, LangItem::Fn),\n-        db.lang_item(krate, LangItem::FnMut),\n-        db.lang_item(krate, LangItem::FnOnce),\n-    ]\n-    .into_iter()\n-    .flatten()\n-    .flat_map(|it| it.as_trait())\n+pub(crate) fn fn_traits(\n+    db: &dyn DefDatabase,\n+    krate: CrateId,\n+) -> impl Iterator<Item = TraitId> + '_ {\n+    [LangItem::Fn, LangItem::FnMut, LangItem::FnOnce]\n+        .into_iter()\n+        .filter_map(move |lang| db.lang_item(krate, lang))\n+        .flat_map(|it| it.as_trait())\n }\n \n-fn direct_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> SmallVec<[TraitId; 4]> {\n+/// Returns an iterator over the whole super trait hierarchy (including the\n+/// trait itself).\n+pub fn all_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> SmallVec<[TraitId; 4]> {\n+    // we need to take care a bit here to avoid infinite loops in case of cycles\n+    // (i.e. if we have `trait A: B; trait B: A;`)\n+\n+    let mut result = smallvec![trait_];\n+    let mut i = 0;\n+    while let Some(&t) = result.get(i) {\n+        // yeah this is quadratic, but trait hierarchies should be flat\n+        // enough that this doesn't matter\n+        direct_super_traits(db, t, |tt| {\n+            if !result.contains(&tt) {\n+                result.push(tt);\n+            }\n+        });\n+        i += 1;\n+    }\n+    result\n+}\n+\n+/// Given a trait ref (`Self: Trait`), builds all the implied trait refs for\n+/// super traits. The original trait ref will be included. So the difference to\n+/// `all_super_traits` is that we keep track of type parameters; for example if\n+/// we have `Self: Trait<u32, i32>` and `Trait<T, U>: OtherTrait<U>` we'll get\n+/// `Self: OtherTrait<i32>`.\n+pub(super) fn all_super_trait_refs<T>(\n+    db: &dyn HirDatabase,\n+    trait_ref: TraitRef,\n+    cb: impl FnMut(TraitRef) -> Option<T>,\n+) -> Option<T> {\n+    let seen = iter::once(trait_ref.trait_id).collect();\n+    let mut stack = Vec::new();\n+    stack.push(trait_ref);\n+    SuperTraits { db, seen, stack }.find_map(cb)\n+}\n+\n+struct SuperTraits<'a> {\n+    db: &'a dyn HirDatabase,\n+    stack: Vec<TraitRef>,\n+    seen: FxHashSet<ChalkTraitId>,\n+}\n+\n+impl<'a> SuperTraits<'a> {\n+    fn elaborate(&mut self, trait_ref: &TraitRef) {\n+        direct_super_trait_refs(self.db, trait_ref, |trait_ref| {\n+            if !self.seen.contains(&trait_ref.trait_id) {\n+                self.stack.push(trait_ref);\n+            }\n+        });\n+    }\n+}\n+\n+impl<'a> Iterator for SuperTraits<'a> {\n+    type Item = TraitRef;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        if let Some(next) = self.stack.pop() {\n+            self.elaborate(&next);\n+            Some(next)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+fn direct_super_traits(db: &dyn DefDatabase, trait_: TraitId, cb: impl FnMut(TraitId)) {\n     let resolver = trait_.resolver(db);\n-    // returning the iterator directly doesn't easily work because of\n-    // lifetime problems, but since there usually shouldn't be more than a\n-    // few direct traits this should be fine (we could even use some kind of\n-    // SmallVec if performance is a concern)\n     let generic_params = db.generic_params(trait_.into());\n     let trait_self = generic_params.find_trait_self_param();\n     generic_params\n@@ -73,18 +134,14 @@ fn direct_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> SmallVec<[Trait\n             Some(TypeNs::TraitId(t)) => Some(t),\n             _ => None,\n         })\n-        .collect()\n+        .for_each(cb);\n }\n \n-fn direct_super_trait_refs(db: &dyn HirDatabase, trait_ref: &TraitRef) -> Vec<TraitRef> {\n-    // returning the iterator directly doesn't easily work because of\n-    // lifetime problems, but since there usually shouldn't be more than a\n-    // few direct traits this should be fine (we could even use some kind of\n-    // SmallVec if performance is a concern)\n+fn direct_super_trait_refs(db: &dyn HirDatabase, trait_ref: &TraitRef, cb: impl FnMut(TraitRef)) {\n     let generic_params = db.generic_params(trait_ref.hir_trait_id().into());\n     let trait_self = match generic_params.find_trait_self_param() {\n         Some(p) => TypeOrConstParamId { parent: trait_ref.hir_trait_id().into(), local_id: p },\n-        None => return Vec::new(),\n+        None => return,\n     };\n     db.generic_predicates_for_param(trait_self.parent, trait_self, None)\n         .iter()\n@@ -100,72 +157,15 @@ fn direct_super_trait_refs(db: &dyn HirDatabase, trait_ref: &TraitRef) -> Vec<Tr\n             })\n         })\n         .map(|pred| pred.substitute(Interner, &trait_ref.substitution))\n-        .collect()\n-}\n-\n-/// Returns an iterator over the whole super trait hierarchy (including the\n-/// trait itself).\n-pub fn all_super_traits(db: &dyn DefDatabase, trait_: TraitId) -> SmallVec<[TraitId; 4]> {\n-    // we need to take care a bit here to avoid infinite loops in case of cycles\n-    // (i.e. if we have `trait A: B; trait B: A;`)\n-\n-    let mut result = smallvec![trait_];\n-    let mut i = 0;\n-    while let Some(&t) = result.get(i) {\n-        // yeah this is quadratic, but trait hierarchies should be flat\n-        // enough that this doesn't matter\n-        for tt in direct_super_traits(db, t) {\n-            if !result.contains(&tt) {\n-                result.push(tt);\n-            }\n-        }\n-        i += 1;\n-    }\n-    result\n-}\n-\n-/// Given a trait ref (`Self: Trait`), builds all the implied trait refs for\n-/// super traits. The original trait ref will be included. So the difference to\n-/// `all_super_traits` is that we keep track of type parameters; for example if\n-/// we have `Self: Trait<u32, i32>` and `Trait<T, U>: OtherTrait<U>` we'll get\n-/// `Self: OtherTrait<i32>`.\n-pub(super) fn all_super_trait_refs(db: &dyn HirDatabase, trait_ref: TraitRef) -> SuperTraits<'_> {\n-    SuperTraits { db, seen: iter::once(trait_ref.trait_id).collect(), stack: vec![trait_ref] }\n-}\n-\n-pub(super) struct SuperTraits<'a> {\n-    db: &'a dyn HirDatabase,\n-    stack: Vec<TraitRef>,\n-    seen: FxHashSet<ChalkTraitId>,\n-}\n-\n-impl<'a> SuperTraits<'a> {\n-    fn elaborate(&mut self, trait_ref: &TraitRef) {\n-        let mut trait_refs = direct_super_trait_refs(self.db, trait_ref);\n-        trait_refs.retain(|tr| !self.seen.contains(&tr.trait_id));\n-        self.stack.extend(trait_refs);\n-    }\n-}\n-\n-impl<'a> Iterator for SuperTraits<'a> {\n-    type Item = TraitRef;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        if let Some(next) = self.stack.pop() {\n-            self.elaborate(&next);\n-            Some(next)\n-        } else {\n-            None\n-        }\n-    }\n+        .for_each(cb);\n }\n \n pub(super) fn associated_type_by_name_including_super_traits(\n     db: &dyn HirDatabase,\n     trait_ref: TraitRef,\n     name: &Name,\n ) -> Option<(TraitRef, TypeAliasId)> {\n-    all_super_trait_refs(db, trait_ref).find_map(|t| {\n+    all_super_trait_refs(db, trait_ref, |t| {\n         let assoc_type = db.trait_data(t.hir_trait_id()).associated_type_by_name(name)?;\n         Some((t, assoc_type))\n     })\n@@ -238,15 +238,18 @@ impl Generics {\n \n     /// (parent total, self param, type param list, const param list, impl trait)\n     pub(crate) fn provenance_split(&self) -> (usize, usize, usize, usize, usize) {\n-        let ty_iter = || self.params.iter().filter_map(|x| x.1.type_param());\n-\n-        let self_params =\n-            ty_iter().filter(|p| p.provenance == TypeParamProvenance::TraitSelf).count();\n-        let type_params =\n-            ty_iter().filter(|p| p.provenance == TypeParamProvenance::TypeParamList).count();\n-        let impl_trait_params =\n-            ty_iter().filter(|p| p.provenance == TypeParamProvenance::ArgumentImplTrait).count();\n-        let const_params = self.params.iter().filter_map(|x| x.1.const_param()).count();\n+        let mut self_params = 0;\n+        let mut type_params = 0;\n+        let mut impl_trait_params = 0;\n+        let mut const_params = 0;\n+        self.params.iter().for_each(|(_, data)| match data {\n+            TypeOrConstParamData::TypeParamData(p) => match p.provenance {\n+                TypeParamProvenance::TypeParamList => type_params += 1,\n+                TypeParamProvenance::TraitSelf => self_params += 1,\n+                TypeParamProvenance::ArgumentImplTrait => impl_trait_params += 1,\n+            },\n+            TypeOrConstParamData::ConstParamData(_) => const_params += 1,\n+        });\n \n         let parent_len = self.parent_generics().map_or(0, Generics::len);\n         (parent_len, self_params, type_params, const_params, impl_trait_params)"}]}